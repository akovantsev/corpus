<!DOCTYPE html>
<head><title>malli</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 160px;} r {min-width: 192px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#malli</h2><pre><i>generated UTC: 2022-12-24 22:16</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/malli/2022-12-23">https://clojurians-log.clojureverse.org/malli/2022-12-23</a></i><i>
messages: 8506</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter2(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}
function textFilter(text) {
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (s){
            var sid = s.getAttribute("id");
            text.split(' ').forEach(function (t) {
                if (t !== '') {
                    filterTextStyle.innerHTML += "\ng#" + sid + " > z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
                }
            });
        })
    }
}
function textFilter3(text) {
    console.time("text search");
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        const re = new RegExp( text, "i");
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (w){
            var zs = w.getElementsByTagName ("z");
            var zsArr = Array.prototype.slice.call(zs);
            var ids = zsArr
                .filter(function (el) {
                    return !re.test(el.innerText);
                })
                .map(function (el){
                    return el.getAttribute("id");
                });
            if (ids) {
                filterTextStyle.innerHTML += "\n#" + ids.join(",#") + " {display: none; opacity: 0.6}";
            }
        })
    }
    console.timeEnd("text search");
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><g id="s0"><z id="t1563115186" t="ikitommi Any comments and critique on design welcome"><y>#</y><d>2019-07-14</d><h>14:39</h><w>ikitommi</w>Any comments and critique on design welcome</z><z id="t1564673048" t="ikitommi (defn composite-perf2 [] (let [tests [[true [-1]] [true [-1 1 2]] [false [-1 0 2]] [false [-1 -1 -1 -1]]] assert! (fn [f] (doseq [[expected data] tests] (assert (= expected (f data)))))] ;; 155ns (let [valid? (fn [x] (and (vector? x) (&lt;= (count x) 3) (every? #(and (int? %) (or (pos-int? %) (neg-int? %))) x)))] (assert! valid?) (cc/quick-bench (valid? [-1 1 2]))) ;; 27ns (let [valid? (m/validator [:vector {:max 3} [:and int? [:or pos-int? neg-int?]]])] (assert! valid?) (cc/quick-bench (valid? [-1 1 2]))) ;; 506ns (let [spec (s/coll-of (s/and int? (s/or :pos-int pos-int? :neg-int neg-int?)) :kind vector? :max-count 3) valid? (partial s/valid? spec)] (assert! valid?) (cc/quick-bench (valid? [-1 1 2]))))) "><y>#</y><d>2019-08-01</d><h>15:24</h><w>ikitommi</w><pre>(defn composite-perf2 []
  (let [tests [[true [-1]]
               [true [-1 1 2]]
               [false [-1 0 2]]
               [false [-1 -1 -1 -1]]]
        assert! (fn [f]
                  (doseq [[expected data] tests]
                    (assert (= expected (f data)))))]

    ;; 155ns
    (let [valid? (fn [x]
                   (and (vector? x)
                        (&lt;= (count x) 3)
                        (every? #(and (int? %) (or (pos-int? %) (neg-int? %))) x)))]
      (assert! valid?)
      (cc/quick-bench
        (valid? [-1 1 2])))

    ;; 27ns
    (let [valid? (m/validator
                   [:vector {:max 3}
                    [:and int? [:or pos-int? neg-int?]]])]
      (assert! valid?)
      (cc/quick-bench
        (valid? [-1 1 2])))

    ;; 506ns
    (let [spec (s/coll-of
                 (s/and int? (s/or :pos-int pos-int? :neg-int neg-int?))
                 :kind vector?
                 :max-count 3)
          valid? (partial s/valid? spec)]
      (assert! valid?)
      (cc/quick-bench
        (valid? [-1 1 2])))))
</pre></z><z id="t1564736557" t="ikitommi some discussion about defaults: https://github.com/metosin/malli/issues/25"><y>#</y><d>2019-08-02</d><h>09:02</h><w>ikitommi</w>some discussion about defaults: <a href="https://github.com/metosin/malli/issues/25" target="_blank">https://github.com/metosin/malli/issues/25</a></z><z id="t1570130239" t="beders hey there, I was trying to play with malli a bit today"><y>#</y><d>2019-10-03</d><h>19:17</h><w>beders</w>hey there, I was trying to play with malli a bit today</z><z id="t1570130247" t="beders having trouble downloading its dependencies though"><y>#</y><d>2019-10-03</d><h>19:17</h><w>beders</w>having trouble downloading its dependencies though</z><z id="t1570130265" t="beders I used the latest commit id and `{:git/url &quot; https://github.com/metosin/malli &quot; :sha &quot;59b226968025502e3830f5c6404b0f95f8c080e6&quot;}`"><y>#</y><d>2019-10-03</d><h>19:17</h><w>beders</w>I used the latest commit id and `{:git/url &quot;<a href="https://github.com/metosin/malli" target="_blank">https://github.com/metosin/malli</a>&quot;
         :sha &quot;59b226968025502e3830f5c6404b0f95f8c080e6&quot;}`</z><z id="t1570130291" t="beders Not super familiar with deps I must admit"><y>#</y><d>2019-10-03</d><h>19:18</h><w>beders</w>Not super familiar with deps I must admit</z><z id="t1570130303" t="beders getting this error at the moment: Error building classpath. Unable to compare versions for borkdude/edamame: {:mvn/version &quot;0.0.5-SNAPSHOT&quot;, :deps/manifest :mvn} and {:git/url &quot;&quot;, :sha &quot;b577e565b136d3dd51945fe874049d4297946f57&quot;, :deps/manifest :deps, :deps/root &quot;/Users/beders/.gitlibs/libs/borkdude/edamame/b577e565b136d3dd51945fe874049d4297946f57&quot;} "><y>#</y><d>2019-10-03</d><h>19:18</h><w>beders</w>getting this error at the moment:
<pre>Error building classpath. Unable to compare versions for borkdude/edamame: {:mvn/version &quot;0.0.5-SNAPSHOT&quot;, :deps/manifest :mvn} and {:git/url &quot;&quot;, :sha &quot;b577e565b136d3dd51945fe874049d4297946f57&quot;, :deps/manifest :deps, :deps/root &quot;/Users/beders/.gitlibs/libs/borkdude/edamame/b577e565b136d3dd51945fe874049d4297946f57&quot;}
</pre></z><z id="t1570131920" t="ikitommi [:attrs {:href &quot;/_/_/users/U628K7XGQ&quot;}] hmm.. not sure what’s wrong with edamame, but this should work: clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;10b09bef72a52755764ba21933edc983fc4135e7&quot;}, borkdude/edamame {:git/url &quot;&quot;, :sha &quot;d7d0f12c336dc513702c8c704b147223f85e377f&quot;}}}&apos; "><y>#</y><d>2019-10-03</d><h>19:45</h><w>ikitommi</w><a>@beders</a> hmm.. not sure what’s wrong with edamame, but this should work:
<pre>clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;10b09bef72a52755764ba21933edc983fc4135e7&quot;}, borkdude/edamame {:git/url &quot;&quot;, :sha &quot;d7d0f12c336dc513702c8c704b147223f85e377f&quot;}}}&apos;
</pre></z><z id="t1570131935" t="beders thank you!"><y>#</y><d>2019-10-03</d><h>19:45</h><w>beders</w>thank you!</z><z id="t1570273630" t="ikitommi asked in #tools-deps how to resolve that, meanwhile, changed edamame to use mvn versio, so this works now: clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;22122b2ff9434bfd0db8d72fcd06cb48914c6eb4&quot;}}}&apos; "><y>#</y><d>2019-10-05</d><h>11:07</h><w>ikitommi</w>asked in #tools-deps how to resolve that, meanwhile, changed edamame to use mvn versio, so this works now:
<pre>clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;22122b2ff9434bfd0db8d72fcd06cb48914c6eb4&quot;}}}&apos;
</pre></z><z id="t1570560582" t="sammikko hi, couldnt find channel for jsonista.. is it possible to de-serialize json date strings &quot;2019-10-04T09:08:36.078Z&quot; to org.joda.time.DateTime objects, based on the format of the incoming string... i understand it works the other way around"><y>#</y><d>2019-10-08</d><h>18:49</h><w>sammikko</w>hi, couldnt find channel for jsonista.. is it possible to de-serialize json date strings &quot;2019-10-04T09:08:36.078Z&quot; to org.joda.time.DateTime objects, based on the format of the incoming string... i understand it works the other way around</z><z id="t1570560744" t="sammikko i&apos;d just like to get a clojure map from json string, but the strings looking like dates should be converted into DateTime.."><y>#</y><d>2019-10-08</d><h>18:52</h><r>sammikko</r>i&apos;d just like to get a clojure map from json string, but the strings looking like dates should be converted into DateTime..</z><z id="t1570565377" t="ikitommi you need to describe which fields should be dates and apply coercion with that. E.g. need to use spec/schema or malli."><y>#</y><d>2019-10-08</d><h>20:09</h><r>ikitommi</r>you need to describe which fields should be dates and apply coercion with that. E.g. need to use spec/schema or malli.</z><z id="t1570565452" t="ikitommi based on format... you could also roll your own walker that inspects the strings, but would be slow I think"><y>#</y><d>2019-10-08</d><h>20:10</h><r>ikitommi</r>based on format... you could also roll your own walker that inspects the strings, but would be slow I think</z><z id="t1570606113" t="sammikko yeah.. we are using Schema atm and schema bijections library to do the conversions.. but its very slow.."><y>#</y><d>2019-10-09</d><h>07:28</h><r>sammikko</r>yeah.. we are using Schema atm and schema bijections library to do the conversions.. but its very slow..</z><z id="t1570606686" t="ikitommi Schema coercion should be fast? Malli will be Really Fast, but doesn&apos;t have an easy way to create custom transforming schemas. One PR away from...."><y>#</y><d>2019-10-09</d><h>07:38</h><r>ikitommi</r>Schema coercion should be fast? Malli will be Really Fast, but doesn&apos;t have an easy way to create custom transforming schemas. One PR away from....</z><z id="t1570607913" t="sammikko thanks.. I&apos;ll check out coercion as well.."><y>#</y><d>2019-10-09</d><h>07:58</h><r>sammikko</r>thanks.. I&apos;ll check out coercion as well..</z><z id="t1570609613" t="ikitommi ok, could be faster. the date parsing on java-side seems quite slow in general: (require &apos;[malli.core :as m]) (require &apos;[malli.transform :as mt]) (def Pizza [:map [:id int?] [:name string?] [:created inst?]]) (def json-&gt;Pizza (m/transformer Pizza mt/json-transformer)) (json-&gt;Pizza {:id 1 :name &quot;salami&quot; :created &quot;2019-10-04T09:08:36.078Z&quot;}) ;{:id 1 ; :name &quot;salami&quot; ; :created #inst&quot;2019-10-04T09:08:36.078-00:00&quot;} (require &apos;[criterium.core :as cc]) (cc/quick-bench (json-&gt;Pizza {:id 1 :name &quot;salami&quot; :created &quot;2019-10-04T09:08:36.078Z&quot;})) ; Evaluation count : 386256 in 6 samples of 64376 calls. ; Execution time mean : 1.719360 µs ; Execution time std-deviation : 100.090402 ns ; Execution time lower quantile : 1.601860 µs ( 2.5%) ; Execution time upper quantile : 1.811632 µs (97.5%) ; Overhead used : 1.862824 ns "><y>#</y><d>2019-10-09</d><h>08:26</h><w>ikitommi</w>ok, could be faster. the date parsing on java-side seems quite slow in general:

<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.transform :as mt])

(def Pizza
  [:map
   [:id int?]
   [:name string?]
   [:created inst?]])

(def json-&gt;Pizza
  (m/transformer
    Pizza
    mt/json-transformer))


(json-&gt;Pizza
  {:id 1
   :name &quot;salami&quot;
   :created &quot;2019-10-04T09:08:36.078Z&quot;})
;{:id 1
; :name &quot;salami&quot;
; :created #inst&quot;2019-10-04T09:08:36.078-00:00&quot;}

(require &apos;[criterium.core :as cc])

(cc/quick-bench
  (json-&gt;Pizza
    {:id 1
     :name &quot;salami&quot;
     :created &quot;2019-10-04T09:08:36.078Z&quot;}))
; Evaluation count : 386256 in 6 samples of 64376 calls.
;              Execution time mean : 1.719360 µs
;     Execution time std-deviation : 100.090402 ns
;    Execution time lower quantile : 1.601860 µs ( 2.5%)
;    Execution time upper quantile : 1.811632 µs (97.5%)
;                    Overhead used : 1.862824 ns
</pre></z><z id="t1570609774" t="ikitommi oh, Plumatic Schema doesn’t have date coercion oob, forgot about that."><y>#</y><d>2019-10-09</d><h>08:29</h><w>ikitommi</w>oh, Plumatic Schema doesn’t have date coercion oob, forgot about that.</z><z id="t1570609979" t="ikitommi with schema-tools: (require &apos;[schema.core :as s]) (require &apos;[schema-tools.coerce :as stc]) (def json-&gt;Pizza2 (stc/coercer {:id s/Int, :name s/Str, :created s/Inst} stc/json-coercion-matcher)) (json-&gt;Pizza2 {:id 1 :name &quot;salami&quot; :created &quot;2019-10-04T09:08:36.078Z&quot;}) ;{:id 1 ; :name &quot;salami&quot; ; :created #inst&quot;2019-10-04T09:08:36.078-00:00&quot;} (cc/quick-bench (json-&gt;Pizza2 {:id 1 :name &quot;salami&quot; :created &quot;2019-10-04T09:08:36.078Z&quot;})) ; Evaluation count : 261396 in 6 samples of 43566 calls. ; Execution time mean : 2.352737 µs ; Execution time std-deviation : 173.369968 ns ; Execution time lower quantile : 2.255370 µs ( 2.5%) ; Execution time upper quantile : 2.636725 µs (97.5%) ; Overhead used : 1.600826 ns "><y>#</y><d>2019-10-09</d><h>08:32</h><w>ikitommi</w>with schema-tools:
<pre>(require &apos;[schema.core :as s])
(require &apos;[schema-tools.coerce :as stc])

(def json-&gt;Pizza2
  (stc/coercer {:id s/Int, :name s/Str, :created s/Inst} stc/json-coercion-matcher))

(json-&gt;Pizza2
  {:id 1
   :name &quot;salami&quot;
   :created &quot;2019-10-04T09:08:36.078Z&quot;})
;{:id 1
; :name &quot;salami&quot;
; :created #inst&quot;2019-10-04T09:08:36.078-00:00&quot;}

(cc/quick-bench
  (json-&gt;Pizza2
    {:id 1
     :name &quot;salami&quot;
     :created &quot;2019-10-04T09:08:36.078Z&quot;}))
; Evaluation count : 261396 in 6 samples of 43566 calls.
;              Execution time mean : 2.352737 µs
;     Execution time std-deviation : 173.369968 ns
;    Execution time lower quantile : 2.255370 µs ( 2.5%)
;    Execution time upper quantile : 2.636725 µs (97.5%)
;                    Overhead used : 1.600826 ns
</pre></z><z id="t1572023988" t="sammikko hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] what you think of specter lib.. i know you like performance etc., you guys like to use it? see any trouble with it?"><y>#</y><d>2019-10-25</d><h>17:19</h><w>sammikko</w>hey <a>@ikitommi</a> what you think of specter lib.. i know you like performance etc., you guys like to use it? see any trouble with it?</z><z id="t1572024223" t="sammikko I get some 90s flashbacks of the XSLT and xpath times, but it sure seems convenient.."><y>#</y><d>2019-10-25</d><h>17:23</h><r>sammikko</r>I get some 90s flashbacks of the XSLT and xpath times, but it sure seems convenient..</z><z id="t1572267983" t="eskos Hey so I feel really dumb but how would I make a malli schema which validates that I have a non-empty string 😅 I’m thinking something like [:and string? [:not= blank?]] but there’s no blank? predicate support…"><y>#</y><d>2019-10-28</d><h>13:06</h><w>eskos</w>Hey so I feel really dumb but how would I make a malli schema which validates that I have a non-empty string <b>😅</b> I’m thinking something like <code>[:and string? [:not= blank?]]</code> but there’s no <code>blank?</code> predicate support…</z><z id="t1572268006" t="eskos blank? does string check internally as well so it doesn’t need to be :and schema but anyhoos…"><y>#</y><d>2019-10-28</d><h>13:06</h><r>eskos</r><code>blank?</code> does string check internally as well so it doesn’t need to be <code>:and</code> schema but anyhoos…</z><z id="t1572270858" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] You can use any predicate with :fn , either: [:fn str/blank?] (local, fast) or [:fn &apos;str/blank?] (portable)"><y>#</y><d>2019-10-28</d><h>13:54</h><w>ikitommi</w><a>@suomi.esko</a> You can use any predicate with <code>:fn</code>, either: <code>[:fn str/blank?]</code> (local, fast) or <code>[:fn &apos;str/blank?]</code> (portable)</z><z id="t1572271531" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Seems to work for the positive case, but I really do want to test the negation of that and I can’t seem to get it to work, or at least :not= isn’t what I should use. I think there isn’t a complementing predicate yet? 🙂"><y>#</y><d>2019-10-28</d><h>14:05</h><w>eskos</w><a>@ikitommi</a> Seems to work for the positive case, but I really do want to test the negation of that and I can’t seem to get it to work, or at least <code>:not=</code> isn’t what I should use. I think there isn’t a complementing predicate yet? <b>🙂</b></z><z id="t1572271664" t="ikitommi [:and string? some?] or [:fn {:error/message &quot;should be non-empty string&quot;} &apos;(complement str/blank?)] ?"><y>#</y><d>2019-10-28</d><h>14:07</h><w>ikitommi</w><code>[:and string? some?]</code> or <code>[:fn {:error/message &quot;should be non-empty string&quot;} &apos;(complement str/blank?)]</code>?</z><z id="t1572271679" t="ikitommi could be :not ...."><y>#</y><d>2019-10-28</d><h>14:07</h><w>ikitommi</w>could be <code>:not</code> ....</z><z id="t1572271793" t="eskos latter works though"><y>#</y><d>2019-10-28</d><h>14:09</h><w>eskos</w>latter works though</z><z id="t1572271875" t="eskos former indeed does not, some? is effectively “not nil” check"><y>#</y><d>2019-10-28</d><h>14:11</h><w>eskos</w>former indeed does not, <code>some?</code> is effectively “not nil” check</z><z id="t1572441680" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Had a thought, should I create an issue on GitHub about my “non-empty string” problem or do you think this is eventually solved as side effect or by other means?"><y>#</y><d>2019-10-30</d><h>13:21</h><w>eskos</w><a>@ikitommi</a> Had a thought, should I create an issue on GitHub about my “non-empty string” problem or do you think this is eventually solved as side effect or by other means?</z><z id="t1572444191" t="ikitommi issue welcome, and suggestion how to fix that 🙂"><y>#</y><d>2019-10-30</d><h>14:03</h><w>ikitommi</w>issue welcome, and suggestion how to fix that <b>🙂</b></z><z id="t1572444193" t="ikitommi https://malli.io/?value=%22%22&amp;amp;schema=%5B%3Aand%20string%3F%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20(complement%20str%2Fblank%3F)%5D%5D"><y>#</y><d>2019-10-30</d><h>14:03</h><w>ikitommi</w><a href="https://malli.io/?value=%22%22&amp;amp;schema=%5B%3Aand%20string%3F%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20(complement%20str%2Fblank%3F)%5D%5D" target="_blank">https://malli.io/?value=%22%22&amp;amp;schema=%5B%3Aand%20string%3F%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20(complement%20str%2Fblank%3F)%5D%5D</a></z><z id="t1572444433" t="Toni Vanhala There’s not-empty in core, while blank? is in clojure.string"><y>#</y><d>2019-10-30</d><h>14:07</h><w>Toni Vanhala</w>There’s <code>not-empty</code> in core, while <code>blank?</code> is in <code>clojure.string</code></z><z id="t1572444520" t="Toni Vanhala I would expect [:and string? not-empty] to work out-of-the-box, while blank? is arguable"><y>#</y><d>2019-10-30</d><h>14:08</h><w>Toni Vanhala</w>I would expect <code>[:and string? not-empty]</code> to work out-of-the-box, while <code>blank?</code> is arguable</z><z id="t1572444647" t="ikitommi not-empty is not registered by default, should it be?"><y>#</y><d>2019-10-30</d><h>14:10</h><w>ikitommi</w><code>not-empty</code> is not registered by default, should it be?</z><z id="t1572444671" t="ikitommi [:and string? [:fn {:error/message &quot;should not be empty&quot;} &apos;not-empty]] "><y>#</y><d>2019-10-30</d><h>14:11</h><w>ikitommi</w><pre>[:and string? [:fn {:error/message &quot;should not be empty&quot;} &apos;not-empty]]
</pre></z><z id="t1572444674" t="ikitommi works"><y>#</y><d>2019-10-30</d><h>14:11</h><w>ikitommi</w>works</z><z id="t1572444679" t="ikitommi https://malli.io/?value=%221%22&amp;amp;schema=%5B%3Aand%0A%20string%3F%0A%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20not-empty%5D%5D"><y>#</y><d>2019-10-30</d><h>14:11</h><w>ikitommi</w><a href="https://malli.io/?value=%221%22&amp;amp;schema=%5B%3Aand%0A%20string%3F%0A%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20not-empty%5D%5D" target="_blank">https://malli.io/?value=%221%22&amp;amp;schema=%5B%3Aand%0A%20string%3F%0A%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22should%20not%20be%20empty%22%7D%20not-empty%5D%5D</a></z><z id="t1572444940" t="eskos Would be nice 🙂"><y>#</y><d>2019-10-30</d><h>14:15</h><w>eskos</w>Would be nice <b>🙂</b></z><z id="t1572444967" t="eskos Although I think complements are also useful in general…"><y>#</y><d>2019-10-30</d><h>14:16</h><w>eskos</w>Although I think complements are also useful in general…</z><z id="t1572515257" t="orestis I&apos;m evaluating various &quot;spec&quot; libraries for use in production. It&apos;s a bit of a sticky situation, since clojure.spec is alpha, clojure.spec2 and malli are pre-alpha. The only &quot;stable&quot; library is Plumatic Schema, but that&apos;s also old (though actively maintained)."><y>#</y><d>2019-10-31</d><h>09:47</h><w>orestis</w>I&apos;m evaluating various &quot;spec&quot; libraries for use in production. It&apos;s a bit of a sticky situation, since clojure.spec is alpha, clojure.spec2 and malli are pre-alpha. The only &quot;stable&quot; library is Plumatic Schema, but that&apos;s also old (though actively maintained).</z><z id="t1572515294" t="orestis But, everyone&apos;s definition of pre-alpha is different. Alex Miller explicitly says &quot;don&apos;t use spec2 in production yet, eta is in the order of months&quot;."><y>#</y><d>2019-10-31</d><h>09:48</h><w>orestis</w>But, everyone&apos;s definition of pre-alpha is different. Alex Miller explicitly says &quot;don&apos;t use spec2 in production yet, eta is in the order of months&quot;.</z><z id="t1572515308" t="orestis What is the definition of pre-alpha for Malli?"><y>#</y><d>2019-10-31</d><h>09:48</h><w>orestis</w>What is the definition of pre-alpha for Malli?</z><z id="t1572515849" t="ikitommi we wanted to optimize the whole - currently all non-core modules (generators, providers, transformers, etc) have initial versions and we know how to core should be done to support the needs of the modules. There will be few namespace &amp; function renames (e.g. breaking) after which we’ll put a alpha out. Will be in alpha as long all the relevant features are feature-complete, but I would guess there will be a real release within 1-2 months."><y>#</y><d>2019-10-31</d><h>09:57</h><w>ikitommi</w>we wanted to optimize the whole - currently all non-core modules (generators, providers, transformers, etc) have initial versions and we know how to core should be done to support the needs of the modules. There will be few namespace &amp; function renames (e.g. breaking) after which we’ll put a alpha out. Will be in alpha as long all the relevant features are feature-complete, but I would guess there will be a real release within 1-2 months.</z><z id="t1572515942" t="ikitommi there is for example now m/transform function but it will be split into m/encode and m/decode , like in spec-tools. Didn’t want to start maintaining CHANGELOG for all the things that are in a flux now, but final design starts to emerge, so getting close."><y>#</y><d>2019-10-31</d><h>09:59</h><w>ikitommi</w>there is for example now <code>m/transform</code> function but it will be split into <code>m/encode</code> and <code>m/decode</code>, like in spec-tools. Didn’t want to start maintaining CHANGELOG for all the things that are in a flux now, but final design starts to emerge, so getting close.</z><z id="t1572515985" t="ikitommi also, there are some big things that need to be decided before release, will write a post &amp;/ poll out of those."><y>#</y><d>2019-10-31</d><h>09:59</h><w>ikitommi</w>also, there are some big things that need to be decided before release, will write a post &amp;/ poll out of those.</z><z id="t1572516054" t="ikitommi • open or closed maps by default? (open) • support clojure core predicates (`ìnt?`, string? ) by default or make keyword type schemas (`:int`, :string , ...)"><y>#</y><d>2019-10-31</d><h>10:00</h><w>ikitommi</w>• open or closed maps by default? (open)
• support clojure core predicates  (`ìnt?`, <code>string?</code>) by default or make keyword type schemas (`:int`, <code>:string</code>, ...)</z><z id="t1572516135" t="ikitommi we’ll push a reitit coercion module of malli soon, so people can start playing (and reporting issues) with it."><y>#</y><d>2019-10-31</d><h>10:02</h><w>ikitommi</w>we’ll push a reitit coercion module of malli soon, so people can start playing (and reporting issues) with it.</z><z id="t1572527923" t="orestis Thanks for the update! Looking forward to see what&apos;s cooking."><y>#</y><d>2019-10-31</d><h>13:18</h><w>orestis</w>Thanks for the update! Looking forward to see what&apos;s cooking.</z><z id="t1572593672" t="ikitommi still surprised how well the schema/hiccup syntax supports elegant extensions: https://github.com/metosin/malli/issues/105"><y>#</y><d>2019-11-01</d><h>07:34</h><w>ikitommi</w>still surprised how well the schema/hiccup syntax supports elegant extensions: <a href="https://github.com/metosin/malli/issues/105" target="_blank">https://github.com/metosin/malli/issues/105</a></z><z id="t1572775581" t="eskos I&apos;d claim that&apos;s the benefit of supple systems 🙂 Not only hiccup syntax has low mental load, it is easy to reason without switching contexts just for the specific task and being just data it can be rustled as lightly or heavily as one needs to... TBH this is my primary reason I&apos;m now lurking here, using hiccup syntax is definitely if not the absolutely correct, at least a very good idea as it is very approachable."><y>#</y><d>2019-11-03</d><h>10:06</h><r>eskos</r>I&apos;d claim that&apos;s the benefit of supple systems <b>🙂</b> Not only hiccup syntax has low mental load, it is easy to reason without switching contexts just for the specific task and being just data it can be rustled as lightly or heavily as one needs to... TBH this is my primary reason I&apos;m now lurking here, using hiccup syntax is definitely if not the absolutely correct, at least a very good idea as it is very approachable.</z><z id="t1572718230" t="roklenarcic I have a question related to malli, but it&apos;s probably just an error on my part but I cannot spot it: I defined macro as this (simplified example): (defmacro x [y] `(println ~(m/schema [:tuple y]))) And when I call (x int?) I get: Syntax error compiling fn* at (/private/var/folders/fm/5mzhclpd7mj0tzjjq796ftc00000gn/T/form-init14721255528686671623.clj:1:1). Can&apos;t embed object in code, maybe print-dup not defined: However if I define macro as this it works: (defmacro x [y] `(println (m/schema [:tuple ~y]))) =&gt; #&apos;clj-rest-client.core/x (x int?) [:tuple int?] "><y>#</y><d>2019-11-02</d><h>18:10</h><w>roklenarcic</w>I have a question related to malli, but it&apos;s probably just an error on my part but I cannot spot it:
I defined macro as this (simplified example):
<pre>(defmacro x [y]
  `(println ~(m/schema [:tuple y])))
</pre>

And when I call <code>(x int?)</code> I get:
<pre>Syntax error compiling fn* at (/private/var/folders/fm/5mzhclpd7mj0tzjjq796ftc00000gn/T/form-init14721255528686671623.clj:1:1).
Can&apos;t embed object in code, maybe print-dup not defined: </pre>

However if I define macro as this it works:
<pre>(defmacro x [y]
  `(println (m/schema [:tuple ~y])))
=&gt; #&apos;clj-rest-client.core/x
(x int?)
[:tuple int?]
</pre></z><z id="t1572718275" t="roklenarcic I wanted to compute the schema value at macro expansion time to make it faster, but it doesn&apos;t seem to work for some reason"><y>#</y><d>2019-11-02</d><h>18:11</h><w>roklenarcic</w>I wanted to compute the schema value at macro expansion time to make it faster, but it doesn&apos;t seem to work for some reason</z><z id="t1572718295" t="roklenarcic maybe someone else can spot it, I&apos;ve been looking at this for a while with no idea"><y>#</y><d>2019-11-02</d><h>18:11</h><w>roklenarcic</w>maybe someone else can spot it, I&apos;ve been looking at this for a while with no idea</z><z id="t1572719926" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] macros should return source code, the first example returns a reified protocol instance. You can run (macroexpand ...) to that"><y>#</y><d>2019-11-02</d><h>18:38</h><w>ikitommi</w><a>@roklenarcic</a> macros should return source code, the first example returns a reified protocol instance. You can run <code>(macroexpand ...)</code> to that</z><z id="t1572719954" t="ikitommi Just curious, &quot;to make it faster&quot;?"><y>#</y><d>2019-11-02</d><h>18:39</h><w>ikitommi</w>Just curious, &quot;to make it faster&quot;?</z><z id="t1572719972" t="roklenarcic I thought that m/schema does some preprocessing"><y>#</y><d>2019-11-02</d><h>18:39</h><w>roklenarcic</w>I thought that m/schema does some preprocessing</z><z id="t1572719989" t="roklenarcic which would make it faster than sticking simply [:tuple x] in there"><y>#</y><d>2019-11-02</d><h>18:39</h><w>roklenarcic</w>which would make it faster than sticking simply [:tuple x] in there</z><z id="t1572720007" t="roklenarcic btw, it seems that [:tuple] doesn;&apos;t work"><y>#</y><d>2019-11-02</d><h>18:40</h><w>roklenarcic</w>btw, it seems that <code>[:tuple]</code> doesn;&apos;t work</z><z id="t1572720051" t="roklenarcic (m/schema [:tuple]) -&gt; :tuple but (m/schema [:tuple int?]) -&gt; [:tuple int?]"><y>#</y><d>2019-11-02</d><h>18:40</h><w>roklenarcic</w><code>(m/schema [:tuple])</code> -&gt; <code>:tuple</code> but <code>(m/schema [:tuple int?])</code> -&gt; <code>[:tuple int?]</code></z><z id="t1572720084" t="ikitommi malli has it&apos;s own compiler for validation, explain &amp; transform. Reaults of those should be pretty fast."><y>#</y><d>2019-11-02</d><h>18:41</h><w>ikitommi</w>malli has it&apos;s own compiler for validation, explain &amp; transform. Reaults of those should be pretty fast.</z><z id="t1572720154" t="ikitommi Creation of schema has some overhead, but if you can store a reference to a transformer, it should be as fast as one can do with Clojure."><y>#</y><d>2019-11-02</d><h>18:42</h><w>ikitommi</w>Creation of schema has some overhead, but if you can store a reference to a transformer, it should be as fast as one can do with Clojure.</z><z id="t1572720185" t="roklenarcic thanks for the info"><y>#</y><d>2019-11-02</d><h>18:43</h><w>roklenarcic</w>thanks for the info</z><z id="t1572720403" t="ikitommi the :tuple thing... some schemas has a constraint that they should have 1+ childs. I guess tuple doesn&apos;t and empty tuple is ok..."><y>#</y><d>2019-11-02</d><h>18:46</h><w>ikitommi</w>the <code>:tuple</code> thing...  some schemas has a constraint that they should have 1+ childs. I guess tuple doesn&apos;t and empty tuple is ok...</z><z id="t1572720403" t="roklenarcic I had spec1 code that said -&gt; give me a vector of values and a vector of specs and I will generate a s/fdef spec (which uses s/cat ), so the code generated a spec like this (s/cat :arg1 arg-spec1 ...) and potentially (s/cat) which took an empty sequence just fine. I replaced this with :tuple from malli and it seems to have a corner case for empty tuple"><y>#</y><d>2019-11-02</d><h>18:46</h><w>roklenarcic</w>I had spec1 code that said -&gt; give me a vector of values and a vector of specs and I will generate a <code>s/fdef</code> spec (which uses <code>s/cat</code>), so the code generated a spec like this <code>(s/cat :arg1 arg-spec1 ...)</code> and potentially <code>(s/cat)</code> which took an empty sequence just fine. I replaced this with <code>:tuple</code> from malli and it seems to have a corner case for empty tuple</z><z id="t1572720445" t="ikitommi should it require at least 1 child?"><y>#</y><d>2019-11-02</d><h>18:47</h><w>ikitommi</w>should it require at least 1 child?</z><z id="t1572720457" t="roklenarcic it works the opposite"><y>#</y><d>2019-11-02</d><h>18:47</h><w>roklenarcic</w>it works the opposite</z><z id="t1572720483" t="roklenarcic (m/explain [:tuple] []) Execution error (NullPointerException) at malli.core/-tuple-schema$reify$reify$fn (core.cljc:447). null"><y>#</y><d>2019-11-02</d><h>18:48</h><w>roklenarcic</w><pre>(m/explain [:tuple] [])
Execution error (NullPointerException) at malli.core/-tuple-schema$reify$reify$fn (core.cljc:447).
null</pre></z><z id="t1572720504" t="roklenarcic but spec with empty (s/cat) would work fine"><y>#</y><d>2019-11-02</d><h>18:48</h><w>roklenarcic</w>but spec with empty <code>(s/cat)</code> would work fine</z><z id="t1572720512" t="ikitommi Oh, that&apos;s a bug."><y>#</y><d>2019-11-02</d><h>18:48</h><w>ikitommi</w>Oh, that&apos;s a bug.</z><z id="t1572720536" t="roklenarcic yeah I thought so"><y>#</y><d>2019-11-02</d><h>18:48</h><w>roklenarcic</w>yeah I thought so</z><z id="t1572720546" t="roklenarcic NPEs are usually not intended"><y>#</y><d>2019-11-02</d><h>18:49</h><w>roklenarcic</w>NPEs are usually not intended</z><z id="t1572720597" t="roklenarcic I&apos;m porting my rest client lib from spec to malli now... hopefully I&apos;ll have encode/decode soon"><y>#</y><d>2019-11-02</d><h>18:49</h><w>roklenarcic</w>I&apos;m porting my rest client lib from spec to malli now... hopefully I&apos;ll have encode/decode soon</z><z id="t1572720813" t="roklenarcic I&apos;d like for user to be able to specify the transformation to string I should do before sending any opaque types over the wire"><y>#</y><d>2019-11-02</d><h>18:53</h><w>roklenarcic</w>I&apos;d like for user to be able to specify the transformation to string I should do before sending any opaque types over the wire</z><z id="t1572720829" t="roklenarcic transforms seem to be doing the opposite direction"><y>#</y><d>2019-11-02</d><h>18:53</h><w>roklenarcic</w>transforms seem to be doing the opposite direction</z><z id="t1572720907" t="roklenarcic e.g. if user has LocalDateTime object I&apos;d like for them to specify format in schema that I format it to before I send it..."><y>#</y><d>2019-11-02</d><h>18:55</h><w>roklenarcic</w>e.g. if user has LocalDateTime object I&apos;d like for them to specify format in schema that I format it to before I send it...</z><z id="t1572721284" t="ikitommi https://github.com/metosin/malli/commit/c2f6b45bd12751f18b737cb227d17fae7f024663"><y>#</y><d>2019-11-02</d><h>19:01</h><w>ikitommi</w><a href="https://github.com/metosin/malli/commit/c2f6b45bd12751f18b737cb227d17fae7f024663" target="_blank">https://github.com/metosin/malli/commit/c2f6b45bd12751f18b737cb227d17fae7f024663</a></z><z id="t1572721440" t="ikitommi encode &amp; decode is done (#99), but requires (#98) before will merge that in."><y>#</y><d>2019-11-02</d><h>19:04</h><w>ikitommi</w>encode &amp; decode is done (#99), but requires (#98) before will merge that in.</z><z id="t1572722213" t="roklenarcic I&apos;ll be finally rid of the nightmare that is trying to conform s/merge specs"><y>#</y><d>2019-11-02</d><h>19:16</h><w>roklenarcic</w>I&apos;ll be finally rid of the nightmare that is trying to conform <code>s/merge</code> specs</z><z id="t1572741856" t="roklenarcic Base Registry includes schemas :vector , :list , :set , but what I&apos;m missing here is :sequential . Often I have use cases where I don&apos;t particularly care which collection it is as long as I can process it like a sequence."><y>#</y><d>2019-11-03</d><h>00:44</h><w>roklenarcic</w>Base Registry includes schemas <code>:vector</code>, <code>:list</code>, <code>:set</code>, but what I&apos;m missing here is <code>:sequential</code>. Often I have use cases where I don&apos;t particularly care which collection it is as long as I can process it like a sequence.</z><z id="t1572781852" t="roklenarcic How would I write (s/coll-of string?) in malli?"><y>#</y><d>2019-11-03</d><h>11:50</h><w>roklenarcic</w>How would I write <code>(s/coll-of string?)</code> in malli?</z><z id="t1572786119" t="ikitommi I think :sequential would be nice. Is :list actually useful at all?"><y>#</y><d>2019-11-03</d><h>13:01</h><w>ikitommi</w>I think <code>:sequential</code> would be nice. Is <code>:list</code> actually useful at all?</z><z id="t1572787106" t="roklenarcic I mean it is if you want to schema a list but thats so rare except when you’re validating macro arguments"><y>#</y><d>2019-11-03</d><h>13:18</h><w>roklenarcic</w>I mean it is if you want to schema a list but thats so rare except when you’re validating macro arguments</z><z id="t1572787150" t="roklenarcic The operators i miss the most are coll-of and every"><y>#</y><d>2019-11-03</d><h>13:19</h><w>roklenarcic</w>The operators i miss the most are coll-of and every</z><z id="t1572871853" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] in latest master, you can use IntoSchema values as element in the schema ast: (require &apos;[malli.core :as m]) (def sequential (#&apos;m/-collection-schema `sequential sequential? seq nil)) (m/validate [sequential int?] &apos;(1 2 3)) ; =&gt; true (m/validate [sequential int?] [1 2 3]) ; =&gt; true (m/form [sequential int?]) ; =&gt; [user/sequential int?] "><y>#</y><d>2019-11-04</d><h>12:50</h><w>ikitommi</w><a>@roklenarcic</a> in latest master, you can use <code>IntoSchema</code> values as element in the schema ast:
<pre>(require &apos;[malli.core :as m])

(def sequential (#&apos;m/-collection-schema `sequential sequential? seq nil))

(m/validate [sequential int?] &apos;(1 2 3)) 
; =&gt; true

(m/validate [sequential int?] [1 2 3]) 
; =&gt; true

(m/form [sequential int?])
; =&gt; [user/sequential int?]
</pre></z><z id="t1572872049" t="ikitommi https://github.com/metosin/malli/commit/adc9994043977965cdca3e37bfa3187c36cc6b1b"><y>#</y><d>2019-11-04</d><h>12:54</h><r>ikitommi</r><a href="https://github.com/metosin/malli/commit/adc9994043977965cdca3e37bfa3187c36cc6b1b" target="_blank">https://github.com/metosin/malli/commit/adc9994043977965cdca3e37bfa3187c36cc6b1b</a></z><z id="t1572879468" t="roklenarcic nice trick to get around private var 🙂"><y>#</y><d>2019-11-04</d><h>14:57</h><w>roklenarcic</w>nice trick to get around private var <b>🙂</b></z><z id="t1572888268" t="ikitommi not complete, transforming needs to retain the original type, but an example of all the extensions implemented and tested for a schema: https://github.com/metosin/malli/pull/110"><y>#</y><d>2019-11-04</d><h>17:24</h><w>ikitommi</w>not complete, transforming needs to retain the original  type, but an example of all the extensions implemented and tested for a schema: <a href="https://github.com/metosin/malli/pull/110" target="_blank">https://github.com/metosin/malli/pull/110</a></z><z id="t1572888356" t="ikitommi I&apos;m thinking of adding a supporting protocol for the different extension, so one could just implement all the concerns with one reify."><y>#</y><d>2019-11-04</d><h>17:25</h><w>ikitommi</w>I&apos;m thinking of adding a supporting protocol for the different extension, so one could just implement all the concerns with one reify.</z><z id="t1572888379" t="ikitommi malli.json-schema/JsonSchema etc."><y>#</y><d>2019-11-04</d><h>17:26</h><w>ikitommi</w><code>malli.json-schema/JsonSchema</code> etc.</z><z id="t1572888675" t="ikitommi not going to use the protocols in the core, e.g. core doesn&apos;t depend on anything to keep it small, but for custom new client schemas, I think the all-protocols approach is more declarative than the mixture of protocols and mms"><y>#</y><d>2019-11-04</d><h>17:31</h><w>ikitommi</w>not going to use the protocols in the core, e.g. core doesn&apos;t depend on anything to keep it small, but for custom new client schemas, I think the all-protocols approach is more declarative than the mixture of protocols and mms</z><z id="t1572953910" t="plexus Seems there&apos;s an issue when using a custom registry with generate . The generators don&apos;t pass the opts down into m/schema , so when you have nested schemas they end up using the default registry"><y>#</y><d>2019-11-05</d><h>11:38</h><w>plexus</w>Seems there&apos;s an issue when using a custom registry with <code>generate</code>. The generators don&apos;t pass the <code>opts</code> down into <code>m/schema</code>, so when you have nested schemas they end up using the default registry</z><z id="t1572954156" t="plexus or I&apos;m holding it wrong 🙂 trying to come up with a minimal repro"><y>#</y><d>2019-11-05</d><h>11:42</h><w>plexus</w>or I&apos;m holding it wrong <b>🙂</b> trying to come up with a minimal repro</z><z id="t1572955848" t="ikitommi hmm… quick look says the sequential schemas are not passing the opts. PR welcome [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}]"><y>#</y><d>2019-11-05</d><h>12:10</h><w>ikitommi</w>hmm… quick look says the sequential schemas are not passing the opts. PR welcome <a>@plexus</a></z><z id="t1572955870" t="plexus https://github.com/metosin/malli/pull/112"><y>#</y><d>2019-11-05</d><h>12:11</h><w>plexus</w><a href="https://github.com/metosin/malli/pull/112" target="_blank">https://github.com/metosin/malli/pull/112</a></z><z id="t1572955922" t="ikitommi thanks, merged"><y>#</y><d>2019-11-05</d><h>12:12</h><w>ikitommi</w>thanks, merged</z><z id="t1572955938" t="plexus sweet!"><y>#</y><d>2019-11-05</d><h>12:12</h><w>plexus</w>sweet!</z><z id="t1572955987" t="plexus side note, is it too late to change childs to children ?"><y>#</y><d>2019-11-05</d><h>12:13</h><w>plexus</w>side note, is it too late to change <code>childs</code> to <code>children</code>?</z><z id="t1572956013" t="plexus it bothers me every time 🙂"><y>#</y><d>2019-11-05</d><h>12:13</h><w>plexus</w>it bothers me every time <b>🙂</b></z><z id="t1572956039" t="ikitommi * children - 8 700 000 000 hits * childs - 75 200 000 hits"><y>#</y><d>2019-11-05</d><h>12:13</h><w>ikitommi</w>* children - 8 700 000 000 hits
* childs - 75 200 000 hits</z><z id="t1572956069" t="ikitommi it’s pre-alpha, good time for fixing things like this. Do you have time for a PR?"><y>#</y><d>2019-11-05</d><h>12:14</h><w>ikitommi</w>it’s pre-alpha, good time for fixing things like this. Do you have time for a PR?</z><z id="t1572956117" t="ikitommi &gt; The difficulty with the plural began in Old English, where the nominative plural was at first cild, identical with the singular, then c.975 a plural form cildru (genitive cildra) arose, probably for clarity’s sake, only to be re-pluraled late 12c. as children, which is thus a double plural. Middle English plural cildre survives in Lancashire dialect childer and in Childermas."><y>#</y><d>2019-11-05</d><h>12:15</h><w>ikitommi</w>&gt; The difficulty with the plural began in Old English, where the nominative plural was at first cild, identical with the singular, then c.975 a plural form cildru (genitive cildra) arose, probably for clarity’s sake, only to be re-pluraled late 12c. as children, which is thus a double plural. Middle English plural cildre survives in Lancashire dialect childer and in Childermas.</z><z id="t1572956150" t="plexus interesting! wiktionary is a bit more harsh"><y>#</y><d>2019-11-05</d><h>12:15</h><w>plexus</w>interesting! wiktionary is a bit more harsh</z><z id="t1572956167" t="plexus"><y>#</y><d>2019-11-05</d><h>12:16</h><w>plexus</w></z><z id="t1572956187" t="plexus yeah, I can do a PR for that later today"><y>#</y><d>2019-11-05</d><h>12:16</h><w>plexus</w>yeah, I can do a PR for that later today</z><z id="t1572957056" t="plexus I see I also broke some tests... will send a PR for that as well"><y>#</y><d>2019-11-05</d><h>12:30</h><w>plexus</w>I see I also broke some tests... will send a PR for that as well</z><z id="t1572961547" t="plexus new PR sent. I really appreciate that the project has a bin/kaocha , it&apos;s so great not to have to think about how to run the tests on each project."><y>#</y><d>2019-11-05</d><h>13:45</h><w>plexus</w>new PR sent. I really appreciate that the project has a <code>bin/kaocha</code>, it&apos;s so great not to have to think about how to run the tests on each project.</z><z id="t1572962404" t="ikitommi thanks for the PR kaocha, makes things kinda simple 🙂"><y>#</y><d>2019-11-05</d><h>14:00</h><w>ikitommi</w>thanks for the PR kaocha, makes things kinda simple <b>🙂</b></z><z id="t1573578900" t="ikitommi two new PRs in master: support for two-way transformations (`m/decode` &amp; m/encode ), :sequential schema and allowing any schema properties based (serializable!) encoders &amp; decoders"><y>#</y><d>2019-11-12</d><h>17:15</h><w>ikitommi</w>two new PRs in master: support for two-way transformations (`m/decode` &amp; <code>m/encode</code>), <code>:sequential</code> schema and allowing any schema properties based (serializable!) encoders &amp; decoders</z><z id="t1573579298" t="ikitommi (let [schema (-&gt; [:and {:title &quot;lower-upper-string&quot; :decode/string &apos;(constantly str/upper-case) :encode/string &apos;(constantly str/lower-case)} string?] (malli.edn/write-string) (malli.edn/read-string))] (as-&gt; &quot;kikka&quot; $ (m/decode schema $ mt/string-transformer) (doto $ prn) (m/encode schema $ mt/string-transformer) (doto $ prn) schema)) ; prints &quot;KIKKA&quot; ; prints &quot;kikka&quot; ; =&gt; [:and ; {:title &quot;lower-upper-string&quot; ; :decode/string (constantly str/upper-case) ; :encode/string (constantly str/lower-case)} ; string?] "><y>#</y><d>2019-11-12</d><h>17:21</h><w>ikitommi</w><pre>(let [schema (-&gt; [:and {:title &quot;lower-upper-string&quot;
                        :decode/string &apos;(constantly str/upper-case)
                        :encode/string &apos;(constantly str/lower-case)}
                  string?]
                 (malli.edn/write-string)
                 (malli.edn/read-string))]
  (as-&gt; &quot;kikka&quot; $
        (m/decode schema $ mt/string-transformer)
        (doto $ prn)
        (m/encode schema $ mt/string-transformer)
        (doto $ prn)
        schema))
; prints &quot;KIKKA&quot;
; prints &quot;kikka&quot;
; =&gt; [:and
;     {:title &quot;lower-upper-string&quot;
;      :decode/string (constantly str/upper-case)
;      :encode/string (constantly str/lower-case)}
;      string?]
</pre></z><z id="t1573579576" t="ikitommi The two-way thing looks from outside the same as with spec-tools, but it actually works 🙂"><y>#</y><d>2019-11-12</d><h>17:26</h><w>ikitommi</w>The two-way thing looks from outside the same as with spec-tools, but it actually works <b>🙂</b></z><z id="t1573579657" t="ikitommi … thanks to clear separation of transformation and validation. the encode mostly creates values that are not valid (e.g. a string representation of a date), and had to add all kind of hacks to make that work with clojure.spec."><y>#</y><d>2019-11-12</d><h>17:27</h><w>ikitommi</w>… thanks to clear separation of transformation and validation. the encode mostly creates values that are not valid (e.g. a string representation of a date), and had to add all kind of hacks to make that work with clojure.spec.</z><z id="t1573712413" t="eskos I’m not sure if I like that str is directly usable in schemas like that. From user point of view I’d assume my own namespace requires to apply, not implicit ones from within malli and in that case I’d rather see an error…I do see the usefulness of that, but it makes me go a bit :face_with_raised_eyebrow: Eh, maybe that’s just me…"><y>#</y><d>2019-11-14</d><h>06:20</h><w>eskos</w>I’m not sure if I like that <code>str</code> is directly usable in schemas like that. From user point of view I’d assume my own namespace requires to apply, not implicit ones from within malli and in that case I’d rather see an error…I do see the usefulness of that, but it makes me go a bit <b>:face_with_raised_eyebrow:</b> Eh, maybe that’s just me…</z><z id="t1573713926" t="ikitommi you can explicitly allow certain qualified symbols to be used, could allow that via global options. I guess clojure.string is a dependency and is available for users of malli. BUT, might fail with advanced compilation unless explixitely registered those functions. Explicit is always better…"><y>#</y><d>2019-11-14</d><h>06:45</h><w>ikitommi</w>you can explicitly allow certain qualified symbols to be used, could allow that via global options. I guess <code>clojure.string</code> is a dependency and is available for users of malli. BUT, might fail with advanced compilation unless explixitely registered those functions. Explicit is always better…</z><z id="t1573714105" t="ikitommi though of exposing explicitely some clojure.test.check.generators functions for generators, to enable portable generators with :gen/gen schema property. Those definitions should be in optional ns so if not needed, doesn’t make the bundle size bigger."><y>#</y><d>2019-11-14</d><h>06:48</h><w>ikitommi</w>though of exposing explicitely some <code>clojure.test.check.generators</code> functions for generators, to enable portable generators with <code>:gen/gen</code> schema property. Those definitions should be in optional ns so if not needed, doesn’t make the bundle size bigger.</z><z id="t1573714167" t="ikitommi better portable example in a tweet: https://twitter.com/ikitommi/status/1194555187995848705"><y>#</y><d>2019-11-14</d><h>06:49</h><w>ikitommi</w>better portable example in a tweet: <a href="https://twitter.com/ikitommi/status/1194555187995848705" target="_blank">https://twitter.com/ikitommi/status/1194555187995848705</a></z><z id="t1573714264" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] actually, the str stuff is explicitly allowed in sci, so ok: https://github.com/borkdude/sci/blob/9b70708c5c42e89d94a72aa961bfa1d3a6ef8be4/src/sci/impl/namespaces.cljc#L437-L475"><y>#</y><d>2019-11-14</d><h>06:51</h><w>ikitommi</w><a>@suomi.esko</a> actually, the <code>str</code> stuff is explicitly allowed in sci, so ok: <a href="https://github.com/borkdude/sci/blob/9b70708c5c42e89d94a72aa961bfa1d3a6ef8be4/src/sci/impl/namespaces.cljc#L437-L475" target="_blank">https://github.com/borkdude/sci/blob/9b70708c5c42e89d94a72aa961bfa1d3a6ef8be4/src/sci/impl/namespaces.cljc#L437-L475</a></z><z id="t1573714339" t="eskos ¯\(ツ)/¯"><y>#</y><d>2019-11-14</d><h>06:52</h><w>eskos</w>¯\(ツ)/¯</z><z id="t1573842887" t="pithyless What is the expected way to check for a function? Something like [:map [:handler fn?]] It looks like fn? is not one of the symbols exported in https://github.com/borkdude/sci/blob/cb1dc3139a53c680b2bdc1038d2c6e26b975ee8e/src/sci/impl/namespaces.cljc#L96 I could do something like [:map [:handler [:fn fn?]]] , but I&apos;m wondering if this is something that will be supported for serialization."><y>#</y><d>2019-11-15</d><h>18:34</h><w>pithyless</w>What is the expected way to check for a function? Something like <code>[:map [:handler fn?]]</code>
It looks like <code>fn?</code> is not one of the symbols exported in <a href="https://github.com/borkdude/sci/blob/cb1dc3139a53c680b2bdc1038d2c6e26b975ee8e/src/sci/impl/namespaces.cljc#L96" target="_blank">https://github.com/borkdude/sci/blob/cb1dc3139a53c680b2bdc1038d2c6e26b975ee8e/src/sci/impl/namespaces.cljc#L96</a>
I could do something like <code>[:map [:handler [:fn fn?]]]</code>, but I&apos;m wondering if this is something that will be supported for serialization.</z><z id="t1573845889" t="ikitommi I think [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] knows if sci could support fn?"><y>#</y><d>2019-11-15</d><h>19:24</h><w>ikitommi</w>I think <a>@borkdude</a> knows if sci could support <code>fn?</code></z><z id="t1573845919" t="borkdude sure. PR welcome, it should be added about here: https://github.com/borkdude/sci/blob/ab5ba82fa61ab47b7ace8b3e58bfa633ae8e1f72/src/sci/impl/namespaces.cljc#L201"><y>#</y><d>2019-11-15</d><h>19:25</h><w>borkdude</w>sure. PR welcome, it should be added about here: <a href="https://github.com/borkdude/sci/blob/ab5ba82fa61ab47b7ace8b3e58bfa633ae8e1f72/src/sci/impl/namespaces.cljc#L201" target="_blank">https://github.com/borkdude/sci/blob/ab5ba82fa61ab47b7ace8b3e58bfa633ae8e1f72/src/sci/impl/namespaces.cljc#L201</a></z><z id="t1573845931" t="borkdude slipped through, don&apos;t know why"><y>#</y><d>2019-11-15</d><h>19:25</h><w>borkdude</w>slipped through, don&apos;t know why</z><z id="t1573845966" t="ikitommi Awesome, [:map [:handler [:fn &apos;fn?]]] would work after that &amp; survive the serialization"><y>#</y><d>2019-11-15</d><h>19:26</h><w>ikitommi</w>Awesome, <code>[:map [:handler [:fn &apos;fn?]]]</code> would work after that &amp; survive the serialization</z><z id="t1573943575" t="borkdude I just added fn? to sci master"><y>#</y><d>2019-11-16</d><h>22:32</h><w>borkdude</w>I just added <code>fn?</code> to sci master</z><z id="t1574057625" t="danielgrosse Hi, when adding the latest ref from malli in the deps.edn and starting a repl, I&apos;ve got this error: error in process sentinel: Could not start nREPL server: Error building classpath. Unable to compare versions for borkdude/edamame: {:mvn/version &quot;0.0.8-alpha.4&quot;, :deps/manifest :mvn} and {:git/url &quot;&quot;, :sha &quot;34755e7a875fae2ab4d64e6be89b6270046a91a3&quot;, :deps/manifest :deps, :deps/root &quot;/Users/xxx/.gitlibs/libs/borkdude/edamame/34755e7a875fae2ab4d64e6be89b6270046a91a3&quot;} "><y>#</y><d>2019-11-18</d><h>06:13</h><w>danielgrosse</w>Hi, when adding the latest ref from malli in the deps.edn and starting a repl, I&apos;ve got this error: <pre>error in process sentinel: Could not start nREPL server: Error building classpath. Unable to compare versions for borkdude/edamame: {:mvn/version &quot;0.0.8-alpha.4&quot;, :deps/manifest :mvn} and {:git/url &quot;&quot;, :sha &quot;34755e7a875fae2ab4d64e6be89b6270046a91a3&quot;, :deps/manifest :deps, :deps/root &quot;/Users/xxx/.gitlibs/libs/borkdude/edamame/34755e7a875fae2ab4d64e6be89b6270046a91a3&quot;}
</pre></z><z id="t1574057657" t="danielgrosse Any tips how I could solve this?"><y>#</y><d>2019-11-18</d><h>06:14</h><w>danielgrosse</w>Any tips how I could solve this?</z><z id="t1574058065" t="ikitommi [:attrs {:href &quot;/_/_/users/U068SUJNT&quot;}] fixed that on master - for edamame, it uses now the “0.0.8-alpha.4” version. DEPS doesn’t know which one is latest that or the SHA (which was later)."><y>#</y><d>2019-11-18</d><h>06:21</h><w>ikitommi</w><a>@danielgrosse</a> fixed that on master - for edamame, it uses now the “0.0.8-alpha.4” version. DEPS doesn’t know which one is latest that or the SHA (which was later).</z><z id="t1574058068" t="ikitommi ➜ ~ clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;e2ff736ff923c676de655b853180be2503715d88&quot;}}}&apos; Checking out: at e2ff736ff923c676de655b853180be2503715d88 Clojure 1.10.1 user=&gt; "><y>#</y><d>2019-11-18</d><h>06:21</h><w>ikitommi</w><pre>➜  ~ clj -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot;
                                        :sha &quot;e2ff736ff923c676de655b853180be2503715d88&quot;}}}&apos;
Checking out:  at e2ff736ff923c676de655b853180be2503715d88
Clojure 1.10.1
user=&gt;
</pre></z><z id="t1574058162" t="ikitommi Not sure if that is a transitive dependency bug of deps, or just a feature."><y>#</y><d>2019-11-18</d><h>06:22</h><w>ikitommi</w>Not sure if that is a transitive dependency bug of deps, or just a feature.</z><z id="t1574058231" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] master uses the latest version of sci, so [:map [:handler [:fn &apos;fn?]]] should work now."><y>#</y><d>2019-11-18</d><h>06:23</h><w>ikitommi</w><a>@pithyless</a> master uses the latest version of sci, so  <code>[:map [:handler [:fn &apos;fn?]]]</code> should work now.</z><z id="t1574058256" t="danielgrosse Thanks for the fast fix. :thumbsup:"><y>#</y><d>2019-11-18</d><h>06:24</h><w>danielgrosse</w>Thanks for the fast fix. <b>:thumbsup:</b></z><z id="t1574058715" t="ikitommi It was an easy fix 😉"><y>#</y><d>2019-11-18</d><h>06:31</h><w>ikitommi</w>It was an easy fix <b>😉</b></z><z id="t1574058723" t="ikitommi btw my next steps are to finish :multi schema and the pretty error printer btw, both 80% done."><y>#</y><d>2019-11-18</d><h>06:32</h><w>ikitommi</w>btw my next steps are to finish <code>:multi</code> schema and the pretty error printer btw, both 80% done.</z><z id="t1574058753" t="danielgrosse Cool. Keep up the great work."><y>#</y><d>2019-11-18</d><h>06:32</h><w>danielgrosse</w>Cool. Keep up the great work.</z><z id="t1574058792" t="ikitommi recursive schemas &amp; support for local registries might come via this PR https://github.com/metosin/malli/pull/117#issuecomment-554737541"><y>#</y><d>2019-11-18</d><h>06:33</h><w>ikitommi</w>recursive schemas &amp; support for local registries might come via this PR <a href="https://github.com/metosin/malli/pull/117#issuecomment-554737541" target="_blank">https://github.com/metosin/malli/pull/117#issuecomment-554737541</a></z><z id="t1574070032" t="eskos Tangential thought on documentation, would absolutely love to see documentation like this for malli eventually: https://pomb.us/build-your-own-react/ scroll a bit to see what I mean - the library behind that is https://github.com/pomber/code-surfer/blob/code-surfer-v2/readme.md"><y>#</y><d>2019-11-18</d><h>09:40</h><w>eskos</w>Tangential thought on documentation, would absolutely love to see documentation like this for malli eventually: <a href="https://pomb.us/build-your-own-react/" target="_blank">https://pomb.us/build-your-own-react/</a> scroll a bit to see what I mean - the library behind that is <a href="https://github.com/pomber/code-surfer/blob/code-surfer-v2/readme.md" target="_blank">https://github.com/pomber/code-surfer/blob/code-surfer-v2/readme.md</a></z><z id="t1574081594" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] feel free to build the docs. looks good, despite not being interactive."><y>#</y><d>2019-11-18</d><h>12:53</h><w>ikitommi</w><a>@suomi.esko</a> feel free to build the docs. looks good, despite not being interactive.</z><z id="t1574184188" t="eskos I’ll try to give this a swing when I get some free time just to see if the idea actually works."><y>#</y><d>2019-11-19</d><h>17:23</h><r>eskos</r>I’ll try to give this a swing when I get some free time just to see if the idea actually works.</z><z id="t1574184201" t="eskos Gives me a good excuse to really dive into malli as well 🙂"><y>#</y><d>2019-11-19</d><h>17:23</h><r>eskos</r>Gives me a good excuse to really dive into malli as well <b>🙂</b></z><z id="t1574187034" t="ikitommi looking forward to seeing the new docs ;)"><y>#</y><d>2019-11-19</d><h>18:10</h><r>ikitommi</r>looking forward to seeing the new docs ;)</z><z id="t1574233092" t="eskos they might end up being trash ¯\(ツ)/¯ but then we’ll know why"><y>#</y><d>2019-11-20</d><h>06:58</h><r>eskos</r>they might end up being trash ¯\(ツ)/¯ but then we’ll know why</z><z id="t1574172047" t="ikitommi Oh, the :multi popped out from the train: https://github.com/metosin/malli/pull/118"><y>#</y><d>2019-11-19</d><h>14:00</h><w>ikitommi</w>Oh, the <code>:multi</code> popped out from the train: <a href="https://github.com/metosin/malli/pull/118" target="_blank">https://github.com/metosin/malli/pull/118</a></z><z id="t1574245703" t="kszabo Are there any plans of supporting clojure.spec1/2? The value proposition of Malli looks nice, but tooling has moved towards supporting clojure.spec and to ease adoption an iterative approach would be nice, slowly redefining existing system clojure.specs to Malli based data-oriented schemas."><y>#</y><d>2019-11-20</d><h>10:28</h><w>kszabo</w>Are there any plans of supporting clojure.spec1/2? The value proposition of Malli looks nice, but tooling has moved towards supporting clojure.spec and to ease adoption an iterative approach would be nice, slowly redefining existing system clojure.specs to Malli based data-oriented schemas.</z><z id="t1574246722" t="miikka What would supporting spec mean?"><y>#</y><d>2019-11-20</d><h>10:45</h><w>miikka</w>What would supporting spec mean?</z><z id="t1574246850" t="miikka I suppose you could try to compile Malli schemata to spec-tools data specs"><y>#</y><d>2019-11-20</d><h>10:47</h><w>miikka</w>I suppose you could try to compile Malli schemata to spec-tools data specs</z><z id="t1574246879" t="miikka In my experience, mixing clojure.spec and prismatic schema was not a big deal, though, so not sure there&apos;s big need for integration in practice."><y>#</y><d>2019-11-20</d><h>10:47</h><w>miikka</w>In my experience, mixing clojure.spec and prismatic schema was not a big deal, though, so not sure there&apos;s big need for integration in practice.</z><z id="t1574247113" t="Toni Vanhala &gt; I suppose you could try to compile Malli schemata to spec-tools data specs I think the requirement was other way around “redefining existing system clojure.specs to Malli”"><y>#</y><d>2019-11-20</d><h>10:51</h><w>Toni Vanhala</w>&gt; I suppose you could try to compile Malli schemata to spec-tools data specs

I think the requirement was other way around “redefining existing system clojure.specs to Malli”</z><z id="t1574247443" t="ikitommi no activities currently for the interop with spec. Feel free to suggest new tooling for this."><y>#</y><d>2019-11-20</d><h>10:57</h><w>ikitommi</w>no activities currently for the interop with spec. Feel free to suggest new tooling for this.</z><z id="t1574249582" t="kszabo actually both directions would be great 🙂 thanks for the notice"><y>#</y><d>2019-11-20</d><h>11:33</h><w>kszabo</w>actually both directions would be great <b>🙂</b> thanks for the notice</z><z id="t1574317075" t="ikitommi As schemas are responsible for parsing their own ast, we could have container schemas for doing translation between modelling systems. Doesn’t help with spec as it’s built around the global registry &amp; macros, but would work with declarative models like JSON Schema: [:json-schema {:type &quot;object&quot; :properties {:name {:type &quot;string&quot;} :number {:type &quot;number&quot;} :required [:name]}]"><y>#</y><d>2019-11-21</d><h>06:17</h><w>ikitommi</w>As schemas are responsible for parsing their own ast, we could have container schemas for doing translation between modelling systems. Doesn’t help with spec as it’s built around the global registry &amp; macros, but would work with declarative models like JSON Schema:

<pre>[:json-schema 
  {:type &quot;object&quot;
   :properties {:name {:type &quot;string&quot;}
                :number {:type &quot;number&quot;}
   :required [:name]}]</pre></z><z id="t1574421187" t="roklenarcic Not having a global registry has a downside though. Let’s say some library introduces a new Schema protocol implementation. Then someone uses that in schemas in namespace X. With Spec when you load the namespace you automatically gain all specs in there with all the required bits and pieces to make it all work. But with the way Malli is set up, if something is using a custom :datetime schema, then all the users of that thing must invoke all the Malli functions with an opts map where :registry is set to the default one with all the extensions added. If the calls to m/validate and such are burried inside a third party library, then that library must provide a way for you to pass the registry to be used otherwise, you cannot use any new schema types except the ones defined in malli.core"><y>#</y><d>2019-11-22</d><h>11:13</h><w>roklenarcic</w>Not having a global registry has a downside though. Let’s say some library introduces a new <code>Schema</code> protocol implementation. Then someone uses that in schemas in namespace X. With <code>Spec</code> when you load the namespace you automatically gain all specs in there with all the required bits and pieces to make it all work. But with the way Malli is set up, if something is using a custom <code>:datetime</code> schema, then all the users of that thing must invoke all the Malli functions with an opts map where <code>:registry</code> is set to the default one with all the extensions added. If the calls to <code>m/validate</code> and such are burried inside a third party library, then that library must provide a way for you to pass the registry to be used otherwise, you cannot use any new schema types except the ones defined in <code>malli.core</code></z><z id="t1574421279" t="roklenarcic Also I’d like to ask, what is the policy regarding non-serializable content in schemas. I see that some examples include opts map where you have keys like {:decode/string some-fn} which isn’t really serializable"><y>#</y><d>2019-11-22</d><h>11:14</h><w>roklenarcic</w>Also I’d like to ask, what is the policy regarding non-serializable content in schemas. I see that some examples include opts map where you have keys like <code>{:decode/string some-fn}</code> which isn’t really serializable</z><z id="t1574421804" t="roklenarcic This is meant vis-a-vis developing own schema implementations… should I disallow non-serializable options?"><y>#</y><d>2019-11-22</d><h>11:23</h><w>roklenarcic</w>This is meant vis-a-vis developing own schema implementations… should I disallow non-serializable options?</z><z id="t1574424575" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] you can always define the library schemas as Vars, the first value in the Schema vector syntax can be an instance of IntoSchema ."><y>#</y><d>2019-11-22</d><h>12:09</h><w>ikitommi</w><a>@roklenarcic</a> you can always define the library schemas as Vars, the first value in the Schema vector syntax can be an instance of <code>IntoSchema</code>.</z><z id="t1574424643" t="ikitommi (def date-time (reify IntoSchema ...)) (m/validate date-time (java.time.DateTime.)) ; =&gt; true"><y>#</y><d>2019-11-22</d><h>12:10</h><w>ikitommi</w><pre>(def date-time (reify IntoSchema ...))

(m/validate date-time (java.time.DateTime.))
; =&gt; true</pre></z><z id="t1574424679" t="ikitommi the work like components on Reagent."><y>#</y><d>2019-11-22</d><h>12:11</h><w>ikitommi</w>the work like components on Reagent.</z><z id="t1574424784" t="roklenarcic so I can also do `[datetime “format”]?"><y>#</y><d>2019-11-22</d><h>12:13</h><w>roklenarcic</w>so I can  also do `[datetime “format”]?</z><z id="t1574424786" t="ikitommi policy on non-serializable: up to the user. There is an issue about making an utility that checks if a schemas can be fully persisted or not. One can put that into project tests."><y>#</y><d>2019-11-22</d><h>12:13</h><w>ikitommi</w>policy on non-serializable: up to the user. There is an issue about making an utility that checks if a schemas can be fully persisted or not. One can put that into project tests.</z><z id="t1574424788" t="ikitommi yes"><y>#</y><d>2019-11-22</d><h>12:13</h><w>ikitommi</w>yes</z><z id="t1574424803" t="roklenarcic thanks that is very helpful"><y>#</y><d>2019-11-22</d><h>12:13</h><w>roklenarcic</w>thanks that is very helpful</z><z id="t1574424832" t="roklenarcic I mean any schema that specifies decode/encode implementation cannot be persisted?"><y>#</y><d>2019-11-22</d><h>12:13</h><w>roklenarcic</w>I mean any schema that  specifies decode/encode implementation cannot be persisted?</z><z id="t1574424834" t="ikitommi (defprotocol IntoSchema (-into-schema [this properties children opts] &quot;creates a new schema instance&quot;))"><y>#</y><d>2019-11-22</d><h>12:13</h><w>ikitommi</w><pre>(defprotocol IntoSchema
  (-into-schema [this properties children opts] &quot;creates a new schema instance&quot;))</pre></z><z id="t1574424852" t="ikitommi quote the functions and they can be serialized."><y>#</y><d>2019-11-22</d><h>12:14</h><w>ikitommi</w>quote the functions and they can be serialized.</z><z id="t1574424895" t="ikitommi (require &apos;[malli.core :as m]) (require &apos;[malli.edn :as edn]) (-&gt; [:and [:map [:x int?] [:y int?]] [:fn &apos;(fn [{:keys [x y]}] (&gt; x y))]] (edn/write-string) (doto prn) ; =&gt; &quot;[:and [:map [:x int?] [:y int?]] [:fn (fn [{:keys [x y]}] (&gt; x y))]]&quot; (edn/read-string) (doto (-&gt; (m/validate {:x 0, :y 1}) prn)) ; =&gt; false (doto (-&gt; (m/validate {:x 2, :y 1}) prn))) ; =&gt; true ;[:and ; [:map ; [:x int?] ; [:y int?]] ; [:fn (fn [{:keys [x y]}] (&gt; x y))]]"><y>#</y><d>2019-11-22</d><h>12:14</h><w>ikitommi</w><pre>(require &apos;[malli.core :as m])
(require &apos;[malli.edn :as edn])

(-&gt; [:and
     [:map
      [:x int?]
      [:y int?]]
     [:fn &apos;(fn [{:keys [x y]}] (&gt; x y))]]
    (edn/write-string)
    (doto prn) ; =&gt; &quot;[:and [:map [:x int?] [:y int?]] [:fn (fn [{:keys [x y]}] (&gt; x y))]]&quot;
    (edn/read-string)
    (doto (-&gt; (m/validate {:x 0, :y 1}) prn)) ; =&gt; false
    (doto (-&gt; (m/validate {:x 2, :y 1}) prn))) ; =&gt; true
;[:and 
; [:map 
;  [:x int?] 
;  [:y int?]] 
; [:fn (fn [{:keys [x y]}] (&gt; x y))]]</pre></z><z id="t1574424896" t="roklenarcic ah.. but then the code processing the value has to call eval or something on it?"><y>#</y><d>2019-11-22</d><h>12:14</h><w>roklenarcic</w>ah.. but then the code processing the value has to call eval or something on it?</z><z id="t1574424936" t="ikitommi it uses sci , a small interpreter. So it works on JVM, ClojureScript &amp; GraalVM, no eval needed"><y>#</y><d>2019-11-22</d><h>12:15</h><w>ikitommi</w>it uses <code>sci</code> ,  a small interpreter. So it works on JVM, ClojureScript &amp; GraalVM, no eval needed</z><z id="t1574424959" t="ikitommi it’s &lt;10kb on cljs."><y>#</y><d>2019-11-22</d><h>12:15</h><w>ikitommi</w>it’s &lt;10kb on cljs.</z><z id="t1574424990" t="ikitommi https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D"><y>#</y><d>2019-11-22</d><h>12:16</h><w>ikitommi</w><a href="https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D</a></z><z id="t1574425016" t="ikitommi that’s all normal code, no clojurescript compiler used in the demo."><y>#</y><d>2019-11-22</d><h>12:16</h><w>ikitommi</w>that’s all normal code, no clojurescript compiler used in the demo.</z><z id="t1574425021" t="roklenarcic sorry, I should be clearer. If my custom datetime schema has an option :formatter which someone puts the value of DateTimeFormatter/ISO_INSTANT"><y>#</y><d>2019-11-22</d><h>12:17</h><w>roklenarcic</w>sorry, I should be clearer. If my custom datetime schema has an option <code>:formatter</code> which someone puts the value of <code>DateTimeFormatter/ISO_INSTANT</code></z><z id="t1574425024" t="ikitommi e.g. “production code”"><y>#</y><d>2019-11-22</d><h>12:17</h><w>ikitommi</w>e.g. “production code”</z><z id="t1574425047" t="ikitommi oh, that. can’t serialize that."><y>#</y><d>2019-11-22</d><h>12:17</h><w>ikitommi</w>oh, that. can’t serialize that.</z><z id="t1574425063" t="roklenarcic if I quote this, I get a symbol"><y>#</y><d>2019-11-22</d><h>12:17</h><w>roklenarcic</w>if I quote this, I get  a symbol</z><z id="t1574425073" t="ikitommi it could have :format option, which could be string?"><y>#</y><d>2019-11-22</d><h>12:17</h><w>ikitommi</w>it could have <code>:format</code> option, which could be string?</z><z id="t1574425084" t="borkdude the latest version of sci supports Java reflection, if you bring this class in with the :classes option. but that won&apos;t work in CLJS of course"><y>#</y><d>2019-11-22</d><h>12:18</h><w>borkdude</w>the latest version of sci supports Java reflection, if you bring this class in with the <code>:classes</code> option.
but that won&apos;t work in CLJS of course</z><z id="t1574425095" t="roklenarcic sure, but you cannot specify instant formatter by giving a string"><y>#</y><d>2019-11-22</d><h>12:18</h><w>roklenarcic</w>sure, but  you cannot specify  instant formatter by giving a string</z><z id="t1574425126" t="borkdude but you can use reader conditionals for that maybe"><y>#</y><d>2019-11-22</d><h>12:18</h><w>borkdude</w>but you can use reader conditionals for that maybe</z><z id="t1574425129" t="roklenarcic specifying something like “yyyy-MM-dd” then telling it to format an Instant object will fail"><y>#</y><d>2019-11-22</d><h>12:18</h><w>roklenarcic</w>specifying something like “yyyy-MM-dd” then telling it to format an <code>Instant</code> object will fail</z><z id="t1574425158" t="ikitommi {:format :iso_instant} maybe?"><y>#</y><d>2019-11-22</d><h>12:19</h><w>ikitommi</w><code>{:format :iso_instant}</code> maybe?</z><z id="t1574425178" t="ikitommi time is hard to get do in a portable way anyway."><y>#</y><d>2019-11-22</d><h>12:19</h><w>ikitommi</w>time is hard to get do in a portable way anyway.</z><z id="t1574425182" t="roklenarcic My current idea is to support everything"><y>#</y><d>2019-11-22</d><h>12:19</h><w>roklenarcic</w>My current idea is to support everything</z><z id="t1574425197" t="roklenarcic so if someone puts a formatter instance there, then I will use it"><y>#</y><d>2019-11-22</d><h>12:19</h><w>roklenarcic</w>so if  someone puts a formatter instance there, then I will use it</z><z id="t1574425200" t="ikitommi string or a (predefined) keyword?"><y>#</y><d>2019-11-22</d><h>12:20</h><w>ikitommi</w>string or a (predefined) keyword?</z><z id="t1574425211" t="ikitommi .. or a class, which is used."><y>#</y><d>2019-11-22</d><h>12:20</h><w>ikitommi</w>.. or a class, which is used.</z><z id="t1574425223" t="roklenarcic but then they lose serializability, but that’s on them"><y>#</y><d>2019-11-22</d><h>12:20</h><w>roklenarcic</w>but then they lose serializability, but that’s on them</z><z id="t1574425233" t="roklenarcic ok… this was very helpful"><y>#</y><d>2019-11-22</d><h>12:20</h><w>roklenarcic</w>ok… this  was very helpful</z><z id="t1574425301" t="ikitommi one thing there could be is to have a startup-time altering of a registry. via JVM options for example. It would be explicit, but still global."><y>#</y><d>2019-11-22</d><h>12:21</h><w>ikitommi</w>one thing there could be is to have a startup-time altering of a registry. via JVM options for example. It would be explicit, but still global.</z><z id="t1574425337" t="ikitommi plan is to pull schema defn and fn syntax helpers, can’t pass easily any custom options/registry there."><y>#</y><d>2019-11-22</d><h>12:22</h><w>ikitommi</w>plan is to pull schema <code>defn</code> and <code>fn</code> syntax helpers, can’t pass easily any custom options/registry there.</z><z id="t1574425395" t="ikitommi (m/defn plus :- int? [x :- int?, y :- int?] (+ x y))"><y>#</y><d>2019-11-22</d><h>12:23</h><w>ikitommi</w><pre>(m/defn plus :- int? 
  [x :- int?, y :- int?] 
  (+ x y))</pre></z><z id="t1574425532" t="ikitommi to support something like [:json-schema {:type &quot;string&quot;}] schema would require some way to change the one registry. could just be the var reference (`[json/json-schema {:type &quot;string&quot;}]`), but could be a JVM property to bootstrap some extra schemas into the registry… not sure if thi is a good idea"><y>#</y><d>2019-11-22</d><h>12:25</h><w>ikitommi</w>to support something like <code>[:json-schema {:type &quot;string&quot;}]</code> schema would require some way to change the one registry. could just be the var reference (`[json/json-schema {:type &quot;string&quot;}]`), but could be a JVM property to bootstrap some extra schemas into the registry… not sure if thi is a good idea</z><z id="t1574425802" t="ikitommi … or just malli.evil ns, which has all the public functions of other namespaces, but with the default-registry as an atom. (require &apos;[malli.evil :as evil]) (evil/register! ::int int?) (evil/validate ::int 1) ; =&gt; true"><y>#</y><d>2019-11-22</d><h>12:30</h><w>ikitommi</w>… or just <code>malli.evil</code> ns, which has all the public functions of other namespaces, but with the default-registry as an atom.

<pre>(require &apos;[malli.evil :as evil])

(evil/register! ::int int?)

(evil/validate ::int 1)
; =&gt; true</pre></z><z id="t1574425917" t="ikitommi … or a JVM option to define the default-registry implementation. by default, it points to the immutable map, but could be swapped to atom impl. Bad Idea 🙂"><y>#</y><d>2019-11-22</d><h>12:31</h><w>ikitommi</w>… or a JVM option to define the <code>default-registry</code> implementation. by default, it points to the immutable map, but could be swapped to atom impl. Bad Idea <b>🙂</b></z><z id="t1574605276" t="ikitommi about closed/open schemas, comments welcome on this: https://github.com/metosin/malli/issues/31#issuecomment-557892061"><y>#</y><d>2019-11-24</d><h>14:21</h><w>ikitommi</w>about closed/open schemas, comments welcome on this: <a href="https://github.com/metosin/malli/issues/31#issuecomment-557892061" target="_blank">https://github.com/metosin/malli/issues/31#issuecomment-557892061</a></z><z id="t1574616806" t="rschmukler Hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks for your response on https://github.com/metosin/malli/pull/119"><y>#</y><d>2019-11-24</d><h>17:33</h><w>rschmukler</w>Hey <a>@ikitommi</a> thanks for your response on <a href="https://github.com/metosin/malli/pull/119" target="_blank">https://github.com/metosin/malli/pull/119</a></z><z id="t1574616864" t="rschmukler This feature is currently blocking me, and I&apos;m relatively familiar with malli&apos;s code at this point (lots of tracing to figure out how to implement the above - if you had ideas on what you were thinking in terms of implementation for #120 I could potentially submit a PR"><y>#</y><d>2019-11-24</d><h>17:34</h><w>rschmukler</w>This feature is currently blocking me, and I&apos;m relatively familiar with malli&apos;s code at this point (lots of tracing to figure out how to implement the above - if you had ideas on what you were thinking in terms of implementation for #120 I could potentially submit a PR</z><z id="t1574616898" t="rschmukler One possible solution that comes to mind is to just extend the Schema protocol to have a -parent method and then invoke things as appropriate"><y>#</y><d>2019-11-24</d><h>17:34</h><w>rschmukler</w>One possible solution that comes to mind is to just extend the <code>Schema</code> protocol to have a <code>-parent</code> method and then invoke things as appropriate</z><z id="t1574616935" t="rschmukler Also, regarding the public m/parent function, perhaps we could also specify passing in a name to traverse up parents until one with the provided name is found"><y>#</y><d>2019-11-24</d><h>17:35</h><w>rschmukler</w>Also, regarding the public <code>m/parent</code> function, perhaps we could also specify passing in a name to traverse up parents until one with the provided name is found</z><z id="t1574616957" t="rschmukler eg (m/parent schema :map)"><y>#</y><d>2019-11-24</d><h>17:35</h><w>rschmukler</w>eg <code>(m/parent schema :map)</code></z><z id="t1574617451" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] I think the -parent is the way to go, but it might need some bigger refactoring on internals: when a Schema is created, the -father is not yet available, as we are creating the childs from the mothers “constructor”, so it needs to be a Delay or similar value. Deref on that while creating a child would either return nil or block indefinitely, depending on the implementation. So, would have to see the code after the change to know if that’s a good value for adding the (potential) complexity in."><y>#</y><d>2019-11-24</d><h>17:44</h><w>ikitommi</w><a>@rschmukler</a> I think the <code>-parent</code> is the way to go, but it might need some bigger refactoring on internals: when a Schema is created, the <code>-father</code> is not yet available, as we are creating the childs from the mothers “constructor”, so it needs to be a <code>Delay</code> or similar value. <code>Deref</code>on that while creating a child would either return <code>nil</code> or block indefinitely, depending on the implementation. So, would have to see the code after the change to know if that’s a good value for adding the (potential) complexity in.</z><z id="t1574617472" t="ikitommi if that is blocking you, you could add a custom decoder on the :map schema already?"><y>#</y><d>2019-11-24</d><h>17:44</h><w>ikitommi</w>if that is blocking you, you could add a custom decoder on the <code>:map</code> schema already?</z><z id="t1574617514" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I initially went down that path but then I had to do the key tracking to invoke the child schemas appropriately"><y>#</y><d>2019-11-24</d><h>17:45</h><w>rschmukler</w><a>@ikitommi</a> I initially went down that path but then I had to do the key tracking to invoke the child schemas appropriately</z><z id="t1574617538" t="rschmukler I was actually wondering if we might be better of implementing the coercions as a postwalk instead of a prewalk"><y>#</y><d>2019-11-24</d><h>17:45</h><w>rschmukler</w>I was actually wondering if we might be better of implementing the coercions as a postwalk instead of a prewalk</z><z id="t1574617565" t="ikitommi (m/decode [:map {:decode/my-thing (fn [schema opts] ...do...thing...)} [:a int?] [:b int?]] {&quot;a_kikka&quot; 12, &quot;b_kikka&quot; 32} (mt/transformer {:name :my-thing))"><y>#</y><d>2019-11-24</d><h>17:46</h><w>ikitommi</w><pre>(m/decode 
  [:map {:decode/my-thing (fn [schema opts] ...do...thing...)} [:a int?] [:b int?]]
  {&quot;a_kikka&quot; 12, &quot;b_kikka&quot; 32}
  (mt/transformer {:name :my-thing))</pre></z><z id="t1574617616" t="rschmukler The issue becomes that if the map renames a key, the child schemas don&apos;t get mapped"><y>#</y><d>2019-11-24</d><h>17:46</h><w>rschmukler</w>The issue becomes that if the map renames a key, the child schemas don&apos;t get mapped</z><z id="t1574617668" t="rschmukler (because the map now has a new key at a different path, and the transformers for the values are resolved via key, after the key is renamed"><y>#</y><d>2019-11-24</d><h>17:47</h><w>rschmukler</w>(because the map now has a new key at a different path, and the transformers for the values are resolved via key, after the key is renamed</z><z id="t1574617704" t="rschmukler (Hence why I potentially suggest doing a postwalk instead of a prewalk for coercions) - is there any reason that it&apos;s currently implemented as a prewalk?"><y>#</y><d>2019-11-24</d><h>17:48</h><w>rschmukler</w>(Hence why I potentially suggest doing a postwalk instead of a prewalk for coercions) - is there any reason that it&apos;s currently implemented as a prewalk?</z><z id="t1574617927" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I have another PR that I&apos;m going to submit that might be a simpler solution for what I&apos;m trying to achieve - feel free to reject it"><y>#</y><d>2019-11-24</d><h>17:52</h><w>rschmukler</w><a>@ikitommi</a> I have another PR that I&apos;m going to submit that might be a simpler solution for what I&apos;m trying to achieve - feel free to reject it</z><z id="t1574619736" t="ikitommi It has to be prewalk, good example: (m/decode [:multi {:dispatch :type :decode/string &apos;(constantly #(update % :type keyword))} [:sized [:map [:type [:= :sized] [:size int?]]] [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]] {:type &quot;human&quot; :name &quot;Tiina&quot; :age &quot;98&quot; :address {:country &quot;finland&quot; :street &quot;this is an extra key&quot;}} (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer)) ;{:type :human ; :name &quot;Tiina&quot; ; :address {:country :finland}} "><y>#</y><d>2019-11-24</d><h>18:22</h><w>ikitommi</w>It has to be prewalk, good example:
<pre>(m/decode
  [:multi {:dispatch :type
           :decode/string &apos;(constantly #(update % :type keyword))}
   [:sized [:map [:type [:= :sized] [:size int?]]]
   [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]]
  {:type &quot;human&quot;
   :name &quot;Tiina&quot;
   :age &quot;98&quot;
   :address {:country &quot;finland&quot;
             :street &quot;this is an extra key&quot;}}
  (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer))
;{:type :human
; :name &quot;Tiina&quot;
; :address {:country :finland}}
</pre></z><z id="t1574619836" t="ikitommi there will be two-way transformers using interceptos, one could put all the stuff into :leave to get postwalk"><y>#</y><d>2019-11-24</d><h>18:23</h><w>ikitommi</w>there will be two-way transformers using interceptos, one could put all the stuff into <code>:leave</code> to get postwalk</z><z id="t1574619862" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Interceptors is a great idea"><y>#</y><d>2019-11-24</d><h>18:24</h><w>rschmukler</w><a>@ikitommi</a> Interceptors is a great idea</z><z id="t1574620553" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] are you open to applying the map transformer after the key and value transformer for the :map schema?"><y>#</y><d>2019-11-24</d><h>18:35</h><w>rschmukler</w><a>@ikitommi</a> are you open to applying the map transformer after the key and value transformer for the <code>:map</code> schema?</z><z id="t1574620571" t="rschmukler ie. Ideally I&apos;d like to be able to have: (is (= {:x_key &quot;true&quot;, :y 1} (m/decode schema {:x true :y &quot;1&quot;} (transform/transformer {:name :custom :decoders {:map (constantly (fn [map] (if-not (contains? map :x) map (-&gt; map (assoc :x_key (:x map)) (dissoc :x))))) &apos;boolean? (constantly str)}}))))"><y>#</y><d>2019-11-24</d><h>18:36</h><w>rschmukler</w>ie. Ideally I&apos;d like to be able to have:


<pre>(is (= {:x_key &quot;true&quot;, :y 1} (m/decode schema {:x true :y &quot;1&quot;}
                                             (transform/transformer
                                              {:name :custom
                                               :decoders
                                               {:map
                                                (constantly (fn [map]
                                                              (if-not (contains? map :x)
                                                                map
                                                                (-&gt; map
                                                                    (assoc :x_key (:x map))
                                                                    (dissoc :x)))))
                                                &apos;boolean? (constantly str)}}))))</pre></z><z id="t1574620980" t="rschmukler Actually this feels inconsistent - perhaps just implementing the interceptors is the way to go"><y>#</y><d>2019-11-24</d><h>18:43</h><w>rschmukler</w>Actually this feels inconsistent - perhaps just implementing the interceptors is the way to go</z><z id="t1574626427" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] what is your schema in the example?"><y>#</y><d>2019-11-24</d><h>20:13</h><w>ikitommi</w><a>@rschmukler</a> what is your schema in the example?</z><z id="t1574626507" t="rschmukler [:map [:x boolean? :y int?]]"><y>#</y><d>2019-11-24</d><h>20:15</h><w>rschmukler</w><code>[:map [:x boolean? :y int?]]</code></z><z id="t1574626525" t="rschmukler (although lets assume that I composed with transformer/json-transformer so that the number decodes correctly"><y>#</y><d>2019-11-24</d><h>20:15</h><w>rschmukler</w>(although lets assume that I composed with <code>transformer/json-transformer</code> so that the number decodes correctly</z><z id="t1574626586" t="rschmukler I realize that I can always pop an escape hatch and write a :custom/decode function but since I want to apply it on every map, it seems like a transformer is the idiomatic way to go"><y>#</y><d>2019-11-24</d><h>20:16</h><w>rschmukler</w>I realize that I can always pop an escape hatch and write a <code>:custom/decode</code> function but since I want to apply it on every map, it seems like a transformer is the idiomatic way to go</z><z id="t1574626625" t="rschmukler I think interceptors solve everything so I&apos;m trying my hand at implementing them right now"><y>#</y><d>2019-11-24</d><h>20:17</h><w>rschmukler</w>I think interceptors solve everything so I&apos;m trying my hand at implementing them right now</z><z id="t1574626644" t="ikitommi but, isn’t that m/encode you are doing?"><y>#</y><d>2019-11-24</d><h>20:17</h><w>ikitommi</w>but, isn’t that <code>m/encode</code> you are doing?</z><z id="t1574626706" t="ikitommi decode should end up in valid values against the schema (eg. JSON-&gt;Schema), encode is Schema-&gt;JSON."><y>#</y><d>2019-11-24</d><h>20:18</h><w>ikitommi</w>decode should end up in valid values against the schema (eg. JSON-&gt;Schema), encode is Schema-&gt;JSON.</z><z id="t1574626752" t="rschmukler That&apos;s a buggy example haha"><y>#</y><d>2019-11-24</d><h>20:19</h><w>rschmukler</w>That&apos;s a buggy example haha</z><z id="t1574626756" t="rschmukler (mine above)"><y>#</y><d>2019-11-24</d><h>20:19</h><w>rschmukler</w>(mine above)</z><z id="t1574626786" t="rschmukler It is indeed an encode"><y>#</y><d>2019-11-24</d><h>20:19</h><w>rschmukler</w>It is indeed an encode</z><z id="t1574626820" t="rschmukler But, none the less, I believe after the key is renamed during the encode, the subsequent value transformers will fail because they look up by the original key name"><y>#</y><d>2019-11-24</d><h>20:20</h><w>rschmukler</w>But, none the less, I believe after the key is renamed during the encode, the subsequent value transformers will fail because they look up by the original key name</z><z id="t1574626889" t="rschmukler (ie. (if-let [entry (find m k)] (assoc m k (t (val entry))) I believe is the code in the map schema)"><y>#</y><d>2019-11-24</d><h>20:21</h><w>rschmukler</w>(ie. <code>(if-let [entry (find m k)] (assoc m k (t (val entry)))</code> I believe is the code in the map schema)</z><z id="t1574626962" t="ikitommi true that. interceptors are needed"><y>#</y><d>2019-11-24</d><h>20:22</h><w>ikitommi</w>true that. interceptors are needed</z><z id="t1574626976" t="rschmukler Yeah, hoping to have a PR today"><y>#</y><d>2019-11-24</d><h>20:22</h><w>rschmukler</w>Yeah, hoping to have a PR today</z><z id="t1574626977" t="rschmukler 😄"><y>#</y><d>2019-11-24</d><h>20:22</h><w>rschmukler</w><b>😄</b></z><z id="t1574627002" t="ikitommi of interceptors? that’s a big one."><y>#</y><d>2019-11-24</d><h>20:23</h><w>ikitommi</w>of interceptors? that’s a big one.</z><z id="t1574627026" t="rschmukler Right now I&apos;m having it so that -transformer and -value-transformer return {:enter _ :exit _} maps"><y>#</y><d>2019-11-24</d><h>20:23</h><w>rschmukler</w>Right now I&apos;m having it so that <code>-transformer</code> and <code>-value-transformer</code>  return <code>{:enter _ :exit _}</code> maps</z><z id="t1574627045" t="rschmukler and then I&apos;m updating the schema impls to use those on children as needed"><y>#</y><d>2019-11-24</d><h>20:24</h><w>rschmukler</w>and then I&apos;m updating the schema impls to use those on children as needed</z><z id="t1574627051" t="ikitommi there is https://github.com/metosin/malli/issues/114"><y>#</y><d>2019-11-24</d><h>20:24</h><w>ikitommi</w>there is <a href="https://github.com/metosin/malli/issues/114" target="_blank">https://github.com/metosin/malli/issues/114</a></z><z id="t1574627074" t="rschmukler (defn- -&gt;interceptor &quot;Utility function to convert a transformer into an interceptor. Works with transformers that are already interceptors, as well as sequences of transformers&quot; [transformer] (cond (fn? transformer) {:enter transformer :exit nil} (and (map? transformer) (or (contains? transformer :enter) (contains? transformer :exit))) transformer (coll? transformer) (reduce (fn [{:keys [enter exit]} {new-enter :enter new-exit :exit}] (let [enter (if (and enter new-enter) (comp enter new-enter) (or enter new-enter)) exit (if (and exit new-exit) (comp exit new-exit) (or exit new-exit))] {:enter enter :exit exit})) (map -&gt;interceptor transformer)) (nil? transformer) nil :else (throw (ex-info &quot;Invalid transformer. Must be a function, sequence, or interceptor map&quot; {:value transformer})))) "><y>#</y><d>2019-11-24</d><h>20:24</h><w>rschmukler</w><pre>(defn- -&gt;interceptor
  &quot;Utility function to convert a transformer into an interceptor. Works with transformers
  that are already interceptors, as well as sequences of transformers&quot;
  [transformer]
  (cond
   (fn? transformer) {:enter transformer :exit nil}
   (and (map? transformer)
        (or (contains? transformer :enter)
            (contains? transformer :exit))) transformer

   (coll? transformer) (reduce
                        (fn [{:keys [enter exit]} {new-enter :enter new-exit :exit}]
                          (let [enter (if (and enter new-enter)
                                        (comp enter new-enter)
                                        (or enter new-enter))
                                exit (if (and exit new-exit)
                                       (comp exit new-exit)
                                       (or exit new-exit))]
                            {:enter enter :exit exit}))
                        (map -&gt;interceptor transformer))
   (nil? transformer) nil
   :else (throw (ex-info &quot;Invalid transformer. Must be a function, sequence, or interceptor map&quot;
                         {:value transformer}))))</pre>
</z><z id="t1574627106" t="rschmukler I think that solves it, converting all transformers into an interceptor, even allowing for the vectors that you included"><y>#</y><d>2019-11-24</d><h>20:25</h><w>rschmukler</w>I think that solves it, converting all transformers into an interceptor, even allowing for the vectors that you included</z><z id="t1574627111" t="rschmukler (in 114)"><y>#</y><d>2019-11-24</d><h>20:25</h><w>rschmukler</w>(in 114)</z><z id="t1574627138" t="rschmukler that map call should be a keep"><y>#</y><d>2019-11-24</d><h>20:25</h><w>rschmukler</w>that <code>map</code> call should be a <code>keep</code></z><z id="t1574627165" t="rschmukler Then, like I said, basically all Schema impls need to be aware of :enter and :exit when returning their own interceptor (with :enter and :exit) themselves"><y>#</y><d>2019-11-24</d><h>20:26</h><w>rschmukler</w>Then, like I said, basically all <code>Schema</code> impls need to be aware of <code>:enter</code> and <code>:exit</code> when returning their own interceptor (with :enter and :exit) themselves</z><z id="t1574627174" t="ikitommi awesome, looking forward to the PR. (`:exit`=&gt; :leave would be coherent with interceptor libs)"><y>#</y><d>2019-11-24</d><h>20:26</h><w>ikitommi</w>awesome, looking forward to the PR. (`:exit`=&gt; <code>:leave</code> would be coherent with interceptor libs)</z><z id="t1574627186" t="rschmukler and then, I think encoder / decoder / encode / decode just need to call (comp exit enter)"><y>#</y><d>2019-11-24</d><h>20:26</h><w>rschmukler</w>and then, I think encoder / decoder / encode / decode just need to call <code>(comp exit enter)</code></z><z id="t1574627195" t="rschmukler Ah, yes, will rename the key, thank you!"><y>#</y><d>2019-11-24</d><h>20:26</h><w>rschmukler</w>Ah, yes, will rename the key, thank you!</z><z id="t1574627208" t="ikitommi 👍"><y>#</y><d>2019-11-24</d><h>20:26</h><w>ikitommi</w><b>👍</b></z><z id="t1574627219" t="rschmukler Do you want me to rename the -transformer and -value-transformer fns to -interceptor and -value-interceptor ?"><y>#</y><d>2019-11-24</d><h>20:26</h><w>rschmukler</w>Do you want me to rename the <code>-transformer</code> and <code>-value-transformer</code> fns to <code>-interceptor</code> and <code>-value-interceptor</code>?</z><z id="t1574627223" t="rschmukler (no opinions here)"><y>#</y><d>2019-11-24</d><h>20:27</h><w>rschmukler</w>(no opinions here)</z><z id="t1574691343" t="roklenarcic so what happens when you use mt/transformer to combine two existing transformers that have an encoder/decoder for same schema name?"><y>#</y><d>2019-11-25</d><h>14:15</h><w>roklenarcic</w>so what happens when you use <code>mt/transformer</code> to combine two existing transformers that have an encoder/decoder for same schema name?</z><z id="t1574691451" t="roklenarcic seems to me that the last encoder/decoder function wins"><y>#</y><d>2019-11-25</d><h>14:17</h><w>roklenarcic</w>seems to me that the last encoder/decoder function wins</z><z id="t1574691508" t="roklenarcic so if you have a modifying transformer like strip-extra-keys-transformer and someone else defines a transformer for :map then one of them doesn’t work, if I am not mistaken"><y>#</y><d>2019-11-25</d><h>14:18</h><w>roklenarcic</w>so if you have a modifying transformer like <code>strip-extra-keys-transformer</code> and someone else defines a transformer for <code>:map</code> then one of them doesn’t work, if I am not mistaken</z><z id="t1574691521" t="ikitommi should put into chain (after interceptors)"><y>#</y><d>2019-11-25</d><h>14:18</h><w>ikitommi</w>should put into chain (after interceptors)</z><z id="t1574691549" t="ikitommi I think"><y>#</y><d>2019-11-25</d><h>14:19</h><w>ikitommi</w>I think</z><z id="t1574691618" t="roklenarcic chain?"><y>#</y><d>2019-11-25</d><h>14:20</h><w>roklenarcic</w>chain?</z><z id="t1574691638" t="roklenarcic is this some new branch?"><y>#</y><d>2019-11-25</d><h>14:20</h><w>roklenarcic</w>is this some new branch?</z><z id="t1574691764" t="roklenarcic should I try to tamper with -transformer function to achieve a modifying effect"><y>#</y><d>2019-11-25</d><h>14:22</h><w>roklenarcic</w>should I try to tamper with <code>-transformer</code>  function to achieve a modifying effect</z><z id="t1574697690" t="rschmukler [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] https://github.com/metosin/malli/pull/122"><y>#</y><d>2019-11-25</d><h>16:01</h><w>rschmukler</w><a>@roklenarcic</a> <a href="https://github.com/metosin/malli/pull/122" target="_blank">https://github.com/metosin/malli/pull/122</a></z><z id="t1574697737" t="rschmukler It&apos;d be reasonably easy to move the -&gt;interceptor function in to have it compose if there&apos;s already existing transformers"><y>#</y><d>2019-11-25</d><h>16:02</h><w>rschmukler</w>It&apos;d be reasonably easy to move the <code>-&gt;interceptor</code> function in to have it compose if there&apos;s already existing transformers</z><z id="t1574697788" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] it might be worth having it compose with both :enter and :leave steps"><y>#</y><d>2019-11-25</d><h>16:03</h><w>rschmukler</w><a>@ikitommi</a> it might be worth having it compose with both <code>:enter</code>  and <code>:leave</code> steps</z><z id="t1574697793" t="roklenarcic you have a comment block at the top there"><y>#</y><d>2019-11-25</d><h>16:03</h><w>roklenarcic</w>you have a comment block at the top there</z><z id="t1574697809" t="rschmukler I just noticed that! Thanks!"><y>#</y><d>2019-11-25</d><h>16:03</h><w>rschmukler</w>I just noticed that! Thanks!</z><z id="t1574697940" t="rschmukler https://github.com/metosin/malli/pull/122/files#diff-f4026c83e07e6f542344d5945d310607R12"><y>#</y><d>2019-11-25</d><h>16:05</h><w>rschmukler</w><a href="https://github.com/metosin/malli/pull/122/files#diff-f4026c83e07e6f542344d5945d310607R12" target="_blank">https://github.com/metosin/malli/pull/122/files#diff-f4026c83e07e6f542344d5945d310607R12</a></z><z id="t1574697999" t="rschmukler So basically on the transformer call where it calls -&gt;interceptor - you could move that reduce internally and then later transformers in &amp; options could just compose"><y>#</y><d>2019-11-25</d><h>16:06</h><w>rschmukler</w>So basically on the <code>transformer</code> call where it calls <code>-&gt;interceptor</code> - you could move that reduce internally and then later transformers in <code>&amp; options</code>  could just compose</z><z id="t1574698093" t="roklenarcic maybe schema seems to be reporting wrong name in error message"><y>#</y><d>2019-11-25</d><h>16:08</h><w>roklenarcic</w>maybe schema seems to be reporting wrong name in error message</z><z id="t1574698094" t="roklenarcic https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L556"><y>#</y><d>2019-11-25</d><h>16:08</h><w>roklenarcic</w><a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L556" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L556</a></z><z id="t1574698672" t="ikitommi .. about composing the transformers. What should happen when there are multiple transformers for same key? 1. last one wins (current) 2. all transformers with different name get chained 3. all get chained"><y>#</y><d>2019-11-25</d><h>16:17</h><w>ikitommi</w>.. about composing the transformers. What should happen when there are multiple transformers for same key?

1. last one wins (current)
2. all transformers with different name get chained
3. all get chained</z><z id="t1574698728" t="ikitommi (mt/transformer mt/json-transformer mt/json-transformer) 1. normal json 2. normal json 3. json + json"><y>#</y><d>2019-11-25</d><h>16:18</h><w>ikitommi</w><pre>(mt/transformer mt/json-transformer mt/json-transformer)</pre>
1. normal json
2. normal json
3. json + json</z><z id="t1574698879" t="ikitommi (mt/transformer {:decoders {:map keywordize-keys}} mt/strip-extra-keys-transformer) 1. strip-keys wins 2. both 3. both"><y>#</y><d>2019-11-25</d><h>16:21</h><w>ikitommi</w><pre>(mt/transformer {:decoders {:map keywordize-keys}} mt/strip-extra-keys-transformer)</pre>
1. strip-keys wins
2. both
3. both</z><z id="t1574698948" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I wouldn&apos;t do unique based off of name - I think for people unfamiliar with the implementation, you might not think that name matters much. Someone might write their own :json that they also compose with the built in json"><y>#</y><d>2019-11-25</d><h>16:22</h><w>rschmukler</w><a>@ikitommi</a> I wouldn&apos;t do unique based off of name - I think for people unfamiliar with the implementation, you might not think that name matters much. Someone might write their own <code>:json</code> that they also compose with the built in json</z><z id="t1574698956" t="rschmukler We could do all unique functions though"><y>#</y><d>2019-11-25</d><h>16:22</h><w>rschmukler</w>We could do all unique functions though</z><z id="t1574698966" t="ikitommi (mt/transformer {:decoders {:map keywordize-keys}} {:decoders {:map upper-case-keys}) 1. upper-case wins 2. upper-case wins 3. both"><y>#</y><d>2019-11-25</d><h>16:22</h><w>ikitommi</w><pre>(mt/transformer {:decoders {:map keywordize-keys}} {:decoders {:map upper-case-keys})</pre>
1. upper-case wins
2. upper-case wins
3. both</z><z id="t1574698982" t="rschmukler I think both would be most useful"><y>#</y><d>2019-11-25</d><h>16:23</h><w>rschmukler</w>I think both would be most useful</z><z id="t1574699029" t="rschmukler then you can write things like (mt/transformer keywords-as-strings capitalize-keywords)"><y>#</y><d>2019-11-25</d><h>16:23</h><w>rschmukler</w>then you can write things like <code>(mt/transformer keywords-as-strings capitalize-keywords)</code></z><z id="t1574699088" t="rschmukler (I could even see utility libraries existing with tons of tiny compositions of common transformer needs)"><y>#</y><d>2019-11-25</d><h>16:24</h><w>rschmukler</w>(I could even see utility libraries existing with tons of tiny compositions of common transformer needs)</z><z id="t1574699127" t="rschmukler Also, I actually take back my comment on using unique functions"><y>#</y><d>2019-11-25</d><h>16:25</h><w>rschmukler</w>Also, I actually take back my comment on using unique functions</z><z id="t1574699138" t="rschmukler I&apos;d say let the user compose things however they want"><y>#</y><d>2019-11-25</d><h>16:25</h><w>rschmukler</w>I&apos;d say let the user compose things however they want</z><z id="t1574699780" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] if you&apos;d like I can add that functionality to my interceptor PR"><y>#</y><d>2019-11-25</d><h>16:36</h><w>rschmukler</w><a>@ikitommi</a> if you&apos;d like I can add that functionality to my interceptor PR</z><z id="t1574701472" t="eskos I almost commented on GitHub but not sure where this thought would actually fit, I started pondering that what if the data given to interceptor would be a zipper like navigation cursor instead? This would actually allow the interceptor to walk up/down/left/right the data structure when needed, without &quot;bind to parent to get access&quot; kind of tricks."><y>#</y><d>2019-11-25</d><h>17:04</h><w>eskos</w>I almost commented on GitHub but not sure where this thought would actually fit, I started pondering that what if the data given to interceptor would be a zipper like navigation cursor instead? This would actually allow the interceptor to walk up/down/left/right the data structure when needed, without &quot;bind to parent to get access&quot; kind of tricks.</z><z id="t1574703456" t="rschmukler Personally I prefer the interceptor pattern as a balance of simplicity, power, and because it&apos;s common in other libraries in the ecosystem. The cursor is definitely much much much more powerful, but building it will be non-trivial. Specifically, the way schema expansion currently happens is sort of a pre-walk - so a child doesn&apos;t even have reference to its parent because when the child is instantiated the parent doesn&apos;t even exist yet."><y>#</y><d>2019-11-25</d><h>17:37</h><w>rschmukler</w>Personally I prefer the interceptor pattern as a balance of simplicity, power, and because it&apos;s common in other libraries in the ecosystem. The cursor is definitely much much much more powerful, but building it will be non-trivial. Specifically, the way schema expansion currently happens is sort of a pre-walk - so a child doesn&apos;t even have reference to its parent because when the child is instantiated the parent doesn&apos;t even exist yet.</z><z id="t1574703772" t="rschmukler The other thing of note is that right now all of the traversal / introspection of the schema happens at compile time (or, at encoder / decoder ) time. I&apos;m not familiar enough with zippers to think through how mapping the functions produced by the zipper could then be composed into a transformer"><y>#</y><d>2019-11-25</d><h>17:42</h><w>rschmukler</w>The other thing of note is that right now all of the traversal / introspection of the schema happens at compile time (or, at <code>encoder</code> / <code>decoder</code> ) time. I&apos;m not familiar enough with zippers to think through how mapping the functions produced by the zipper could then be composed into a transformer</z><z id="t1574704533" t="eskos I&apos;m almost certain it would be runtime only and probably not that incredibly fast :)"><y>#</y><d>2019-11-25</d><h>17:55</h><w>eskos</w>I&apos;m almost certain it would be runtime only and probably not that incredibly fast :)</z><z id="t1574704851" t="eskos But I disagree on that sentiment of simplicity, as I don&apos;t see it as simple for any other than the simple use case - this parent awareness being a very good example of a sudden trickery situation, esp. with multi schemas where the parent doesn&apos;t necessarily dictate which child there is. It is always possible everyone&apos;s gotten things wrong so far... 🙂"><y>#</y><d>2019-11-25</d><h>18:00</h><w>eskos</w>But I disagree on that sentiment of simplicity, as I don&apos;t see it as simple for any other than the simple use case - this parent awareness being a very good example of a sudden trickery situation, esp. with multi schemas where the parent doesn&apos;t necessarily dictate which child there is.

It is always possible everyone&apos;s gotten things wrong so far... <b>🙂</b></z><z id="t1574704891" t="rschmukler It absolutely is!"><y>#</y><d>2019-11-25</d><h>18:01</h><w>rschmukler</w>It absolutely is!</z><z id="t1574704898" t="rschmukler I agree with you 100%"><y>#</y><d>2019-11-25</d><h>18:01</h><w>rschmukler</w>I agree with you 100%</z><z id="t1574704975" t="rschmukler Because the schema&apos;s are data, we at least have the escape hatch of compiling a different schema"><y>#</y><d>2019-11-25</d><h>18:02</h><w>rschmukler</w>Because the schema&apos;s are data, we at least have the escape hatch of compiling a different schema</z><z id="t1574705000" t="rschmukler But that feels &quot;dirty&quot; to me - not sure why... maybe bad habits from spec"><y>#</y><d>2019-11-25</d><h>18:03</h><w>rschmukler</w>But that feels &quot;dirty&quot; to me - not sure why... maybe bad habits from spec</z><z id="t1574705056" t="eskos I&apos;ve never used spec beyond tutorials tbh, I disliked its global registry and nested specs too much."><y>#</y><d>2019-11-25</d><h>18:04</h><w>eskos</w>I&apos;ve never used spec beyond tutorials tbh, I disliked its global registry and nested specs too much.</z><z id="t1574705069" t="eskos So maybe I&apos;m not tainted/enlightened in that sense? 🙂"><y>#</y><d>2019-11-25</d><h>18:04</h><w>eskos</w>So maybe I&apos;m not tainted/enlightened in that sense? <b>🙂</b></z><z id="t1574705076" t="rschmukler Lucky you 😉"><y>#</y><d>2019-11-25</d><h>18:04</h><w>rschmukler</w>Lucky you <b>😉</b></z><z id="t1574705123" t="eskos But anyway, it definitely is a concern that it would probably be really slow (in relation to rest of malli)"><y>#</y><d>2019-11-25</d><h>18:05</h><w>eskos</w>But anyway, it definitely is a concern that it would probably be really slow (in relation to rest of malli)</z><z id="t1574705133" t="rschmukler The tooling story for spec is pretty cool. Definitely something I intend to port over to malli once things stabilize a bit"><y>#</y><d>2019-11-25</d><h>18:05</h><w>rschmukler</w>The tooling story for spec is pretty cool. Definitely something I intend to port over to malli once things stabilize a bit</z><z id="t1574705137" t="rschmukler (&gt;defn- wrap-vec &quot;Wraps the given target into a vector. If its already in a sequence, it will be converted to a vector. If its a vector it will return itself. If its a value it will be inserted into a vector&quot; [item] [any? =&gt; (s/coll-of any? :kind vector?)] (cond (vector? item) item (seq? item) (into [] item) :else [item]))"><y>#</y><d>2019-11-25</d><h>18:05</h><w>rschmukler</w><pre>(&gt;defn- wrap-vec
  &quot;Wraps the given target into a vector. If its already in a sequence, it will
  be converted to a vector. If its a vector it will return itself. If its a value
  it will be inserted into a vector&quot;
  [item]
  [any? =&gt; (s/coll-of any? :kind vector?)]
  (cond
   (vector? item) item
   (seq? item)    (into [] item)
   :else          [item]))</pre></z><z id="t1574705151" t="rschmukler That kind of inline annotation + optional checks is pretty useful"><y>#</y><d>2019-11-25</d><h>18:05</h><w>rschmukler</w>That kind of inline annotation + optional checks is pretty useful</z><z id="t1574705162" t="rschmukler optional instrumentation I should say"><y>#</y><d>2019-11-25</d><h>18:06</h><w>rschmukler</w>optional instrumentation I should say</z><z id="t1574714918" t="ikitommi I would prefer the plumatic schema fn syntax: (m/defn plus :- int? [x :- int?, y :- int?] (+ x y))"><y>#</y><d>2019-11-25</d><h>20:48</h><w>ikitommi</w>I would prefer the plumatic schema fn syntax:


<pre>(m/defn plus :- int? 
  [x :- int?, y :- int?] 
  (+ x y))</pre></z><z id="t1574714956" t="ikitommi effectively about the same."><y>#</y><d>2019-11-25</d><h>20:49</h><w>ikitommi</w>effectively about the same.</z><z id="t1574720262" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] interesting, why the preference? You like the type annotations right next to the variable name?"><y>#</y><d>2019-11-25</d><h>22:17</h><w>rschmukler</w><a>@ikitommi</a> interesting, why the preference? You like the type annotations right next to the variable name?</z><z id="t1574721172" t="rschmukler I can likely make both valid. I&apos;ll probably just have different namespaces that you can import from"><y>#</y><d>2019-11-25</d><h>22:32</h><w>rschmukler</w>I can likely make both valid. I&apos;ll probably just have different namespaces that you can import from</z><z id="t1574783863" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] been using that with schema for 5+ years, no complaints. Cursive does static analysis for that + you can omit the type hints if you don&apos;t know/want to define those, e.g (m/defn plus [x :- int?, y] (+ x y))"><y>#</y><d>2019-11-26</d><h>15:57</h><w>ikitommi</w><a>@rschmukler</a> been using that with schema for 5+ years, no complaints. Cursive does static analysis for that + you can omit the type hints if you don&apos;t know/want to define those, e.g


<pre>(m/defn plus
  [x :- int?, y] 
  (+ x y))</pre></z><z id="t1574783900" t="ikitommi will check the interceptor PR as soon as have extra time."><y>#</y><d>2019-11-26</d><h>15:58</h><w>ikitommi</w>will check the interceptor PR as soon as have extra time.</z><z id="t1574783979" t="ikitommi the chaining of encoders &amp; decoders with mt/transformer , I think it&apos;s a good idea."><y>#</y><d>2019-11-26</d><h>15:59</h><w>ikitommi</w>the chaining of encoders &amp; decoders with <code>mt/transformer</code>, I think it&apos;s a good idea.</z><z id="t1574784819" t="ikitommi https://github.com/danielcompton/defn-spec"><y>#</y><d>2019-11-26</d><h>16:13</h><w>ikitommi</w><a href="https://github.com/danielcompton/defn-spec" target="_blank">https://github.com/danielcompton/defn-spec</a></z><z id="t1574787760" t="kszabo there is also: https://github.com/fulcrologic/guardrails/"><y>#</y><d>2019-11-26</d><h>17:02</h><w>kszabo</w>there is also: <a href="https://github.com/fulcrologic/guardrails/" target="_blank">https://github.com/fulcrologic/guardrails/</a></z></g><g id="s1"><z id="t1574787997" t="ikitommi and https://github.com/jeaye/orchestra/blob/master/README.md#defn-spec"><y>#</y><d>2019-11-26</d><h>17:06</h><w>ikitommi</w>and <a href="https://github.com/jeaye/orchestra/blob/master/README.md#defn-spec" target="_blank">https://github.com/jeaye/orchestra/blob/master/README.md#defn-spec</a></z><z id="t1574788057" t="ikitommi Is there something missing from the original plumatic schema syntax?"><y>#</y><d>2019-11-26</d><h>17:07</h><w>ikitommi</w>Is there something missing from the original plumatic schema syntax?</z><z id="t1574796387" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I’ve got a proof of concept. I’ve separated the parsing from the code generation (the generation just takes a map). This will allow different styles to work."><y>#</y><d>2019-11-26</d><h>19:26</h><w>rschmukler</w><a>@ikitommi</a> I’ve got a proof of concept. I’ve separated the parsing from the code generation (the generation just takes a map). This will allow different styles to work.</z><z id="t1574796534" t="rschmukler Regarding the composition of interceptors, if you don’t mind, I may do it as a separate PR to keep thins more focused."><y>#</y><d>2019-11-26</d><h>19:28</h><w>rschmukler</w>Regarding the composition of interceptors, if you don’t mind, I may do it as a separate PR to keep thins more focused.</z><z id="t1574833194" t="eskos My only gripe with Schema’s defn macros is that there’s no private versions and IIRC they sort of b0rked if you try to include type information or other metadata…but those are all fixable issues 🙂 And I might be misremembering things, I’m quite good at that."><y>#</y><d>2019-11-27</d><h>05:39</h><w>eskos</w>My only gripe with Schema’s defn macros is that there’s no private versions and IIRC they sort of b0rked if you try to include type information or other metadata…but those are all fixable issues <b>🙂</b> And I might be misremembering things, I’m quite good at that.</z><z id="t1574926842" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] As morning chore I made a Makefile for Malli 😛 mainly meant to replace the bin/kaocha and to make sure deps are installed. Since no one even asked for this, should I push this out or just keep to myself?"><y>#</y><d>2019-11-28</d><h>07:40</h><w>eskos</w><a>@ikitommi</a> As morning chore I made a <code>Makefile</code> for Malli <b>😛</b> mainly meant to replace the <code>bin/kaocha</code> and to make sure deps are installed. Since no one even asked for this, should I push this out or just keep to myself?</z><z id="t1575007322" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] So I made a PR of this anyway, feel free to reject it if you disagree with my reasoning :)"><y>#</y><d>2019-11-29</d><h>06:02</h><r>eskos</r><a>@ikitommi</a> So I made a PR of this anyway, feel free to reject it if you disagree with my reasoning :)</z><z id="t1575007844" t="ikitommi There are smarter on Metosin like [:attrs {:href &quot;/_/_/users/U1NDXLDUG&quot;}] doing our OS tooling stuff, looking forward to comments too."><y>#</y><d>2019-11-29</d><h>06:10</h><r>ikitommi</r>There are smarter on Metosin  like <a>@U1NDXLDUG</a> doing our OS tooling stuff, looking forward to comments too.</z><z id="t1575009116" t="miikka bin/kaocha should not be replaced, it’s essential part of the Kaocha interface"><y>#</y><d>2019-11-29</d><h>06:31</h><r>miikka</r><code>bin/kaocha</code> should not be replaced, it’s essential part of the Kaocha interface</z><z id="t1575009181" t="eskos Please elaborate 🙂"><y>#</y><d>2019-11-29</d><h>06:33</h><r>eskos</r>Please elaborate <b>🙂</b></z><z id="t1575009196" t="eskos I’m replacing the literal bash file, not kaocha itself."><y>#</y><d>2019-11-29</d><h>06:33</h><r>eskos</r>I’m replacing the literal bash file, not kaocha itself.</z><z id="t1575009243" t="miikka Yes, but Kaocha is supposed to be used from command-line"><y>#</y><d>2019-11-29</d><h>06:34</h><r>miikka</r>Yes, but Kaocha is supposed to be used from command-line</z><z id="t1575009262" t="miikka You can do stuff like bin/kaocha --watch and bin/kaocha --focus test-symbol and stuff like that"><y>#</y><d>2019-11-29</d><h>06:34</h><r>miikka</r>You can do stuff like <code>bin/kaocha --watch</code>  and <code>bin/kaocha --focus test-symbol</code>  and stuff like that</z><z id="t1575009287" t="miikka That said, I wouldn&apos;t be against something like make test which would install the npm deps and then run the tests with bin/kaocha"><y>#</y><d>2019-11-29</d><h>06:34</h><r>miikka</r>That said, I wouldn&apos;t be against something like <code>make test</code> which would install the npm deps and then run the tests with <code>bin/kaocha</code></z><z id="t1575009301" t="eskos Ah, I see."><y>#</y><d>2019-11-29</d><h>06:35</h><r>eskos</r>Ah, I see.</z><z id="t1575009323" t="eskos Well, that’s not a big adjustment 🙂"><y>#</y><d>2019-11-29</d><h>06:35</h><r>eskos</r>Well, that’s not a big adjustment <b>🙂</b></z><z id="t1575009784" t="eskos There. I did the unfashionable and hid my crimes 😉"><y>#</y><d>2019-11-29</d><h>06:43</h><r>eskos</r>There. I did the unfashionable and hid my crimes <b>😉</b></z><z id="t1575014295" t="miikka I&apos;m honestly not feeling very positive about your PR, but I&apos;ll try to review it at some point."><y>#</y><d>2019-11-29</d><h>07:58</h><r>miikka</r>I&apos;m honestly not feeling very positive about your PR, but I&apos;ll try to review it at some point.</z><z id="t1575017714" t="eskos That’s totally fine 🙂 Just wanted to push it out to clarify your stance on it."><y>#</y><d>2019-11-29</d><h>08:55</h><r>eskos</r>That’s totally fine <b>🙂</b> Just wanted to push it out to clarify your stance on it.</z><z id="t1574971185" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] Merged the interceptor-branch, thanks! Wanted to test myself if/how that works and re-formatted the code: https://github.com/metosin/malli/pull/124/files?w=1"><y>#</y><d>2019-11-28</d><h>19:59</h><w>ikitommi</w><a>@rschmukler</a> Merged the interceptor-branch, thanks! Wanted to test myself if/how that works and re-formatted the code: <a href="https://github.com/metosin/malli/pull/124/files?w=1" target="_blank">https://github.com/metosin/malli/pull/124/files?w=1</a></z><z id="t1574971288" t="ikitommi (is (= [24 48 8 10] (m/decode [:tuple {:decode/string (constantly {:enter (partial mapv inc), :leave (partial mapv (partial * 2))})} [int? {:decode/string (constantly {:enter (partial + 2), :leave (partial * 3)})}] [int? {:decode/string (constantly {:enter (partial + 3), :leave (partial * 4)})}]] [1 2 3 4] mt/string-transformer)))"><y>#</y><d>2019-11-28</d><h>20:01</h><w>ikitommi</w><pre>(is (= [24 48 8 10]
       (m/decode
         [:tuple
          {:decode/string (constantly {:enter (partial mapv inc), :leave (partial mapv (partial * 2))})}
          [int? {:decode/string (constantly {:enter (partial + 2), :leave (partial * 3)})}]
          [int? {:decode/string (constantly {:enter (partial + 3), :leave (partial * 4)})}]]
         [1 2 3 4] mt/string-transformer)))</pre></z><z id="t1574971984" t="ikitommi did an issue about the defn syntax, labelled “for discussion”."><y>#</y><d>2019-11-28</d><h>20:13</h><w>ikitommi</w>did an issue about the <code>defn</code> syntax, labelled “for discussion”.</z><z id="t1574974589" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Woo! Looks great 🍻"><y>#</y><d>2019-11-28</d><h>20:56</h><w>rschmukler</w><a>@ikitommi</a> Woo! Looks great  <b>🍻</b></z><z id="t1574974665" t="rschmukler I was just recently thinking that there are probably some interesting behaviors we should add for multi schemas. Eg. should we have a :dispatch/leave option? and then assume :dispatch and :dispatch/enter to be the same?"><y>#</y><d>2019-11-28</d><h>20:57</h><w>rschmukler</w>I was just recently thinking that there are probably some interesting behaviors we should add for multi schemas. Eg. should we have a <code>:dispatch/leave</code> option? and then assume <code>:dispatch</code> and <code>:dispatch/enter</code> to be the same?</z><z id="t1575006682" t="ikitommi hmm… I think the :dispatch doesn’t need a separate leave?"><y>#</y><d>2019-11-29</d><h>05:51</h><w>ikitommi</w>hmm… I think the <code>:dispatch</code> doesn’t need a separate leave?</z><z id="t1575006749" t="ikitommi as the dispatch is used to select the schema when going in, when returning, we don’t need the selection, we just go back the same route."><y>#</y><d>2019-11-29</d><h>05:52</h><w>ikitommi</w>as the dispatch is used to select the schema when going in, when returning, we don’t need the selection, we just go back the same route.</z><z id="t1575007395" t="ikitommi Hmm,.. after mt/transformer chains the interceptors for the same schema key (instead of overriding), what if the names are also chained so that one could define multiple schema-based decode/encode via schema properties?"><y>#</y><d>2019-11-29</d><h>06:03</h><w>ikitommi</w>Hmm,.. after <code>mt/transformer</code> chains the interceptors for the same schema key (instead of overriding), what if the names are also chained so that one could define multiple schema-based decode/encode via schema properties?</z><z id="t1575007630" t="ikitommi e.g. (mt/transformer {:name :enter} mt/string-transformer {:name :leave}) would make a name chain of [:enter :string :leave] which would allow fine grained control of overriding things in the schemas: (m/decode [:and {:decode/enter (constantly inc), :decode/string (constantly (partial * 2)) :decode/leave (constantly (partial + 10))} int?] 1 (mt/transformer {:name :enter} mt/string-transformer {:name :leave})) ; =&gt; 30"><y>#</y><d>2019-11-29</d><h>06:07</h><w>ikitommi</w>e.g. <code>(mt/transformer {:name :enter} mt/string-transformer {:name :leave})</code> would make a name chain of <code>[:enter :string :leave]</code> which would allow fine grained control of overriding things in the schemas:
<pre>(m/decode
  [:and {:decode/enter (constantly inc), 
         :decode/string (constantly (partial * 2))
         :decode/leave (constantly (partial + 10))} int?]
  1
  (mt/transformer {:name :enter} mt/string-transformer {:name :leave}))
; =&gt; 30</pre></z><z id="t1575007685" t="ikitommi more common case would be to “after normal decoding, do this too”: (m/decode [:and {:decode/leave (constantly (partial + 10))} int?] &quot;1&quot; (mt/transformer {:name :enter} mt/string-transformer {:name :leave})) ; =&gt; 11"><y>#</y><d>2019-11-29</d><h>06:08</h><w>ikitommi</w>more common case would be to “after normal decoding, do this too”:
<pre>(m/decode
  [:and {:decode/leave (constantly (partial + 10))} int?]
  &quot;1&quot;
  (mt/transformer {:name :enter} mt/string-transformer {:name :leave}))
; =&gt; 11</pre></z><z id="t1575007726" t="ikitommi getting complex, not sure if this is a good idea."><y>#</y><d>2019-11-29</d><h>06:08</h><w>ikitommi</w>getting complex, not sure if this is a good idea.</z><z id="t1575007967" t="eskos Not going to lie, I had to read that about 5 times to grok it…"><y>#</y><d>2019-11-29</d><h>06:12</h><w>eskos</w>Not going to lie, I had to read that about 5 times to grok it…</z><z id="t1575007999" t="ikitommi (m/decode [:and [int? {:decode/string &apos;(constantly {:enter (partial + 2), :leave (partial * 3)})}]] &quot;1&quot; mt/string-transformer)"><y>#</y><d>2019-11-29</d><h>06:13</h><w>ikitommi</w><pre>(m/decode
  [:and [int? {:decode/string &apos;(constantly {:enter (partial + 2), :leave (partial * 3)})}]]
  &quot;1&quot;
  mt/string-transformer)</pre></z><z id="t1575008006" t="ikitommi currently, that doesn’t work, as there is no way to compose the normal transformation and a custom one. if you define anything at schema-level, it overrides the default. might be ok and just needs to be documented."><y>#</y><d>2019-11-29</d><h>06:13</h><w>ikitommi</w>currently, that doesn’t work, as there is no way to compose the normal transformation and a custom one. if you define anything at schema-level, it overrides the default. might be ok and just needs to be documented.</z><z id="t1575008469" t="ikitommi btw, do you [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] have a defn-parser in some of your utility libs? would be great not need to reinvent the wheel with the schema defn -syntax, expecially if malli already depends on that functionality (sci or edamame)"><y>#</y><d>2019-11-29</d><h>06:21</h><w>ikitommi</w>btw, do you <a>@borkdude</a> have a defn-parser in some of your utility libs? would be great not need to reinvent the wheel with the schema <code>defn</code> -syntax, expecially if malli already depends on that functionality (sci or edamame)</z><z id="t1575008750" t="eskos You can rip it out of Clojure quite easily ( https://github.com/clojure/clojure/blob/clojure-1.9.0/src/clj/clojure/core.clj#L283 )"><y>#</y><d>2019-11-29</d><h>06:25</h><r>eskos</r>You can rip it out of Clojure quite easily (<a href="https://github.com/clojure/clojure/blob/clojure-1.9.0/src/clj/clojure/core.clj#L283" target="_blank">https://github.com/clojure/clojure/blob/clojure-1.9.0/src/clj/clojure/core.clj#L283</a>)</z><z id="t1575009081" t="eskos And if that feels dangerous, I’ve made one incomplete implementation of defn parser with clojure.tools.reader a while back because I needed to analyze defn s (don’t ask) and ended up with this sort of bleh thing which eats defn s and produces data maps."><y>#</y><d>2019-11-29</d><h>06:31</h><r>eskos</r>And if that feels dangerous, I’ve made one incomplete implementation of defn parser with clojure.tools.reader  a while back because I needed to analyze defn s (don’t ask) and ended up with this sort of bleh thing which eats defn s and produces data maps.</z><z id="t1575009112" t="eskos I’m sharing that just for the idea, it’s obviously not complete 😛 In fact I should continue this project, I’ve been sitting on it for far too long…"><y>#</y><d>2019-11-29</d><h>06:31</h><r>eskos</r>I’m sharing that just for the idea, it’s obviously not complete <b>😛</b> In fact I should continue this project, I’ve been sitting on it for far too long…</z><z id="t1575014124" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] there is a defn parser in sci of course but I haven’t thought about sharing it so it might be a little specific for sci "><y>#</y><d>2019-11-29</d><h>07:55</h><w>borkdude</w><a>@ikitommi</a> there is a defn parser in sci of course but I haven’t thought about sharing it so it might be a little specific for sci </z><z id="t1575014232" t="borkdude In edamame there is a fn literal -&gt; fn parser feature "><y>#</y><d>2019-11-29</d><h>07:57</h><w>borkdude</w>In edamame there is a fn literal -&gt; fn parser feature </z><z id="t1575310909" t="ikitommi integrating into reitit (wip): https://github.com/metosin/reitit/pull/341"><y>#</y><d>2019-12-02</d><h>18:21</h><w>ikitommi</w>integrating into reitit (wip): <a href="https://github.com/metosin/reitit/pull/341" target="_blank">https://github.com/metosin/reitit/pull/341</a></z><z id="t1575311157" t="ikitommi We can create all the needed functions per schema &amp; transformer ahead of time: (-&gt;Coercer (m/decoder schema t) (m/encoder schema t) (m/validator schema) (m/explainer schema))"><y>#</y><d>2019-12-02</d><h>18:25</h><w>ikitommi</w>We can create all the needed functions per schema &amp; transformer ahead of time:
<pre>(-&gt;Coercer (m/decoder schema t)
           (m/encoder schema t)
           (m/validator schema)
           (m/explainer schema))</pre></z><z id="t1575562219" t="rschmukler Sorry about that [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !!"><y>#</y><d>2019-12-05</d><h>16:10</h><w>rschmukler</w>Sorry about that <a>@ikitommi</a>!!</z><z id="t1575567535" t="roklenarcic Sequential schema doesn’t seem to be working correctly: (m/encode [:sequential {:encode/string (constantly #(clojure.string/join &quot;,&quot; %))} string?] [&quot;A&quot; &quot;B&quot; &quot;C&quot;] mt/string-transformer) =&gt; (\A \, \B \, \C) instead of expected: &quot;A,B,C&quot;"><y>#</y><d>2019-12-05</d><h>17:38</h><w>roklenarcic</w>Sequential schema doesn’t seem to be working correctly:
<pre>(m/encode [:sequential {:encode/string (constantly #(clojure.string/join &quot;,&quot; %))}
           string?]
          [&quot;A&quot; &quot;B&quot; &quot;C&quot;]
          mt/string-transformer)
          
=&gt; (\A \, \B \, \C)</pre>
instead of expected: <code>&quot;A,B,C&quot;</code></z><z id="t1575567580" t="roklenarcic the encode function correctly receives the input vector, and returns a string"><y>#</y><d>2019-12-05</d><h>17:39</h><w>roklenarcic</w>the encode function correctly receives the input vector, and returns a string</z><z id="t1575567588" t="roklenarcic the result should be a string"><y>#</y><d>2019-12-05</d><h>17:39</h><w>roklenarcic</w>the result should be a string</z><z id="t1575584151" t="rschmukler [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] I actually just ran into the same bug in a different manifestation! [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] PR incoming..."><y>#</y><d>2019-12-05</d><h>22:15</h><w>rschmukler</w><a>@roklenarcic</a> I actually just ran into the same bug in a different manifestation! <a>@ikitommi</a> PR incoming...</z><z id="t1575587116" t="rschmukler [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] https://github.com/metosin/malli/pull/135"><y>#</y><d>2019-12-05</d><h>23:05</h><w>rschmukler</w><a>@roklenarcic</a> <a href="https://github.com/metosin/malli/pull/135" target="_blank">https://github.com/metosin/malli/pull/135</a></z><z id="t1575588441" t="roklenarcic What is the use case for the “interceptors” in Malli? What use cases did it solve? Because all I see is things getting more complicated and yet it adds no features. The interceptor change smells like cargo cult programming to me. Because http request/response frameworks have switched to interceptors, people think they are applicable to every problem. I just don’t see what it adds to Malli"><y>#</y><d>2019-12-05</d><h>23:27</h><w>roklenarcic</w>What is the use case for the “interceptors” in Malli? What use cases did it solve? Because all I see is things getting more complicated and yet it adds no features. The interceptor change smells like cargo cult programming to me. Because http request/response frameworks have switched to interceptors, people think they are applicable to every problem. I just don’t see what it adds to Malli</z><z id="t1575588560" t="rschmukler You&apos;re right that in their current form they aren&apos;t that useful. The big draw to them would be if the :leave could execute in a more post-walk fashion. Right now, for simple use cases, they give an opportunity for a transformer to finalize a value after most things are done (ie. all :leave execute after all :enter have finished). I&apos;m hoping that we can make it a true postwalk, in which case they become much more useful"><y>#</y><d>2019-12-05</d><h>23:29</h><w>rschmukler</w>You&apos;re right that in their current form they aren&apos;t that useful. The big draw to them would be if the <code>:leave</code> could execute in a more post-walk fashion. Right now, for simple use cases, they give an opportunity for a transformer to finalize a value after most things are done (ie. all <code>:leave</code> execute after all <code>:enter</code> have finished). I&apos;m hoping that we can make it a true postwalk, in which case they become much more useful</z><z id="t1575623279" t="roklenarcic But I was able to do that in the old system as well. My transform function was simply: call the child transformer and then finalize and return a value."><y>#</y><d>2019-12-06</d><h>09:07</h><w>roklenarcic</w>But I was able to do that in the old system as well. My transform function was simply: call the child transformer and then finalize and return a value.</z><z id="t1575625198" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] could you show example how do you call the child transformer from a transformer?"><y>#</y><d>2019-12-06</d><h>09:39</h><w>ikitommi</w><a>@roklenarcic</a> could you show example how do you call the child transformer from a transformer?</z><z id="t1575625239" t="ikitommi the lib is at pre-alpha , so we can still rollback anything if there is unneeded complexity around"><y>#</y><d>2019-12-06</d><h>09:40</h><w>ikitommi</w>the lib is at pre-alpha , so we can still rollback anything if there is unneeded complexity around</z><z id="t1575625248" t="roklenarcic Assuming you have in -into-schema schema&apos; (-&gt; children first (m/schema opts))"><y>#</y><d>2019-12-06</d><h>09:40</h><w>roklenarcic</w>Assuming you have in <code>-into-schema</code> <code>schema&apos; (-&gt; children first (m/schema opts))</code></z><z id="t1575625336" t="roklenarcic (-transformer [this transformer context] (let [child-xf (m/-value-transformer transformer schema&apos; context)] (if child-xf (if (= :decode context) (comp child-xf xf) (comp xf child-xf)) xf)))"><y>#</y><d>2019-12-06</d><h>09:42</h><w>roklenarcic</w><pre>(-transformer [this transformer context]
            (let [child-xf (m/-value-transformer transformer schema&apos; context)]
              (if child-xf
                (if (= :decode context)
                  (comp child-xf xf)
                  (comp xf child-xf))
                xf)))</pre></z><z id="t1575625339" t="ikitommi example: you want to transform map after the keys have been renamed, using transformed keys. This is a good place to do it in leave."><y>#</y><d>2019-12-06</d><h>09:42</h><w>ikitommi</w>example: you want to transform map after the keys have been renamed, using transformed keys. This is a good place to do it in leave.</z><z id="t1575625492" t="roklenarcic you can create a transformer like this: my enter logic call child my leave logic"><y>#</y><d>2019-12-06</d><h>09:44</h><w>roklenarcic</w>you can create a transformer like this:
<pre>my enter logic
call child
my leave logic</pre></z><z id="t1575625523" t="roklenarcic the difference is that in the interceptor pattern, calling the child (i.e. next in chain) is handled by the function that runs the whole thing"><y>#</y><d>2019-12-06</d><h>09:45</h><w>roklenarcic</w>the difference is that in the interceptor pattern, calling the child (i.e. next in chain) is handled by the function that runs the whole thing</z><z id="t1575625564" t="roklenarcic but in http request/response interceptors that code is doable because it is obvious how to handle calling the next interceptor in chain"><y>#</y><d>2019-12-06</d><h>09:46</h><w>roklenarcic</w>but in http request/response interceptors that code is doable because it is obvious how to handle calling the next interceptor in chain</z><z id="t1575625579" t="roklenarcic there is 0 or 1 next interceptors"><y>#</y><d>2019-12-06</d><h>09:46</h><w>roklenarcic</w>there is 0 or 1 next interceptors</z><z id="t1575625647" t="roklenarcic in malli, you have maps and vectors and custom types, which means you cannot have standard function which will invoke next interceptors and combine results"><y>#</y><d>2019-12-06</d><h>09:47</h><w>roklenarcic</w>in malli, you have maps and vectors and custom types, which means you cannot have standard function which will invoke next interceptors and combine results</z><z id="t1575626032" t="ikitommi the current interceptor runner is quite simple, but my idea was to use next version of sieppari, on which, the chain is a vector of IntoInterceptor instances, e.g. functions, maps or Interceptor Instances. The runner composes the (optimized) chain. This allows things like visual chain debugging, good perf and overall, and reuse."><y>#</y><d>2019-12-06</d><h>09:53</h><w>ikitommi</w>the current interceptor runner is quite simple, but my idea was to use next version of sieppari, on which, the chain is a vector of <code>IntoInterceptor</code> instances, e.g. functions, maps or Interceptor Instances. The runner composes the (optimized) chain. This allows things like visual chain debugging, good perf and overall, and reuse.</z><z id="t1575626072" t="roklenarcic Are you talking about multiple interceptors on same schema?"><y>#</y><d>2019-12-06</d><h>09:54</h><w>roklenarcic</w>Are you talking about multiple interceptors on same schema?</z><z id="t1575626077" t="ikitommi manual chaining is not that handy if you want to inline the transformation via schema properties"><y>#</y><d>2019-12-06</d><h>09:54</h><w>ikitommi</w>manual chaining is not that handy if you want to inline the transformation via schema properties</z><z id="t1575626082" t="ikitommi yes"><y>#</y><d>2019-12-06</d><h>09:54</h><w>ikitommi</w>yes</z><z id="t1575626111" t="roklenarcic or are you talking about composing say an interceptor on :sequential schema with those on child schemas"><y>#</y><d>2019-12-06</d><h>09:55</h><w>roklenarcic</w>or are you talking about composing say an interceptor on <code>:sequential</code> schema with those on child schemas</z><z id="t1575626156" t="ikitommi https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc"><y>#</y><d>2019-12-06</d><h>09:55</h><w>ikitommi</w><a href="https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc</a></z><z id="t1575626206" t="ikitommi added some tests to document how the chaining works now. Grep for :enter"><y>#</y><d>2019-12-06</d><h>09:56</h><w>ikitommi</w>added some tests to document how the chaining works now. Grep for <code>:enter</code></z><z id="t1575626241" t="roklenarcic Those are serializable?"><y>#</y><d>2019-12-06</d><h>09:57</h><w>roklenarcic</w>Those are serializable?</z><z id="t1575626252" t="ikitommi Yes"><y>#</y><d>2019-12-06</d><h>09:57</h><w>ikitommi</w>Yes</z><z id="t1575626260" t="roklenarcic #() is serializable?"><y>#</y><d>2019-12-06</d><h>09:57</h><w>roklenarcic</w><code>#()</code>  is serializable?</z><z id="t1575626266" t="roklenarcic I never knew"><y>#</y><d>2019-12-06</d><h>09:57</h><w>roklenarcic</w>I never knew</z><z id="t1575626291" t="ikitommi Thanks to sci by [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] . Just quote them and it works"><y>#</y><d>2019-12-06</d><h>09:58</h><w>ikitommi</w>Thanks to sci by <a>@borkdude</a>. Just quote them and it works</z><z id="t1575626330" t="roklenarcic as said, the biggest difference is that in request/response interceptor chains, they are strictly linear"><y>#</y><d>2019-12-06</d><h>09:58</h><w>roklenarcic</w>as said, the biggest difference is that in request/response interceptor chains, they are strictly linear</z><z id="t1575626341" t="ikitommi Malli uses a safe/always-terminating subset of Clojure core with sci"><y>#</y><d>2019-12-06</d><h>09:59</h><w>ikitommi</w>Malli uses a safe/always-terminating subset of Clojure core with sci</z><z id="t1575626368" t="ikitommi is non-linear also needed?"><y>#</y><d>2019-12-06</d><h>09:59</h><w>ikitommi</w>is non-linear also needed?</z><z id="t1575626488" t="ikitommi"><y>#</y><d>2019-12-06</d><h>10:01</h><w>ikitommi</w></z><z id="t1575626521" t="ikitommi that&apos;s sieppari-based data visualization that we get for free with intercwptors"><y>#</y><d>2019-12-06</d><h>10:02</h><w>ikitommi</w>that&apos;s sieppari-based data visualization that we get for free with intercwptors</z><z id="t1575626537" t="roklenarcic :map-of and :vector combine enter and exit function in non-linear maner"><y>#</y><d>2019-12-06</d><h>10:02</h><w>roklenarcic</w><code>:map-of</code> and <code>:vector</code> combine enter and exit function in non-linear maner</z><z id="t1575626587" t="ikitommi hmm. haven&apos;t had time to check out that. Could you please explain?"><y>#</y><d>2019-12-06</d><h>10:03</h><w>ikitommi</w>hmm. haven&apos;t had time to check out that. Could you please explain?</z><z id="t1575626665" t="roklenarcic yes, when writing -transformer function you would expect that with interceptors one doesn’t have to do the composing with the next interceptor in chain"><y>#</y><d>2019-12-06</d><h>10:04</h><w>roklenarcic</w>yes, when writing <code>-transformer</code> function you would expect that with interceptors one doesn’t have to do the composing with the next interceptor in chain</z><z id="t1575626705" t="roklenarcic but you still have to manually write -transformer function to compose your interceptor with the others"><y>#</y><d>2019-12-06</d><h>10:05</h><w>roklenarcic</w>but you still have to manually write <code>-transformer</code>  function to compose your interceptor with the others</z><z id="t1575626811" t="roklenarcic e.g. in :vector you need to write code that will return a map {:enter … :leave ...} such that it correctly composes its enter/leave logic with the elements enter/leave logicks"><y>#</y><d>2019-12-06</d><h>10:06</h><w>roklenarcic</w>e.g. in <code>:vector</code> you need to write code that will return a map <code>{:enter … :leave ...}</code> such that it correctly composes its enter/leave logic with the elements enter/leave logicks</z><z id="t1575627009" t="roklenarcic I guess I’ll see where this is going"><y>#</y><d>2019-12-06</d><h>10:10</h><w>roklenarcic</w>I guess I’ll see where this is going</z><z id="t1575627746" t="ikitommi I see. Need to think about this when at computer."><y>#</y><d>2019-12-06</d><h>10:22</h><w>ikitommi</w>I see. Need to think about this when at computer.</z><z id="t1575627899" t="roklenarcic [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] yesterday I hit this snag https://clojurians.slack.com/archives/CLDK6MFMK/p1575567535304400"><y>#</y><d>2019-12-06</d><h>10:24</h><w>roklenarcic</w><a>@rschmukler</a> yesterday I hit this snag <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1575567535304400" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1575567535304400</a></z><z id="t1575627911" t="roklenarcic you made a patch"><y>#</y><d>2019-12-06</d><h>10:25</h><w>roklenarcic</w>you made a patch</z><z id="t1575627950" t="roklenarcic I found another problem"><y>#</y><d>2019-12-06</d><h>10:25</h><w>roklenarcic</w>I found another problem</z><z id="t1575627969" t="ikitommi It was [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] &apos;s patch"><y>#</y><d>2019-12-06</d><h>10:26</h><w>ikitommi</w>It was <a>@rschmukler</a>&apos;s patch</z><z id="t1575627996" t="roklenarcic (m/encode [:sequential {:encode/string (constantly {:leave #(clojure.string/join &quot;,&quot; %)})} string?] [&quot;A&quot; &quot;B&quot; &quot;C&quot;] mt/string-transformer) Error printing return value (NullPointerException) at clojure.core/map$fn (core.clj:2755). null"><y>#</y><d>2019-12-06</d><h>10:26</h><w>roklenarcic</w><pre>(m/encode [:sequential {:encode/string (constantly {:leave #(clojure.string/join &quot;,&quot; %)})}
           string?]
          [&quot;A&quot; &quot;B&quot; &quot;C&quot;]
          mt/string-transformer)
Error printing return value (NullPointerException) at clojure.core/map$fn (core.clj:2755).
null</pre></z><z id="t1575628029" t="roklenarcic so if I wrap it in :leave I get NPE"><y>#</y><d>2019-12-06</d><h>10:27</h><w>roklenarcic</w>so if I wrap it in <code>:leave</code> I get NPE</z><z id="t1575628068" t="roklenarcic I know it was his patch that’s why I @ him"><y>#</y><d>2019-12-06</d><h>10:27</h><w>roklenarcic</w>I know it was his patch that’s why I <code>@</code> him</z><z id="t1575628278" t="ikitommi please report all issues, clearly need to fix or rethink this. If you have suggestions how to make the transforming good with/without interceptors, while supporting the schema property based extension (serializable), I&apos;m all ears."><y>#</y><d>2019-12-06</d><h>10:31</h><w>ikitommi</w>please report all issues, clearly need to fix or rethink this. If you have suggestions how to make the transforming good with/without interceptors, while supporting the schema property based extension (serializable), I&apos;m all ears.</z><z id="t1575629220" t="roklenarcic my question before thinking about this is what is the desired logic for this part: • if multiple transformers define encoder/decoder for same symbol/schema what is desired, last one wins? • if schema use-site property map defined encode decode keys, what is the desired interaction with existing encode decode operation already defined by schema type itself, full override? does it also override the construction in -transformer ? "><y>#</y><d>2019-12-06</d><h>10:47</h><w>roklenarcic</w>my question before thinking about this is what is the desired logic for this part:
• if multiple transformers define encoder/decoder for same symbol/schema what is desired, last one wins?
• if schema use-site property map defined <code>encode</code> <code>decode</code> keys, what is the desired interaction with existing encode decode operation already defined by schema type itself, full override? does it also override the construction in <code>-transformer</code>?
</z><z id="t1575647355" t="rschmukler [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] Try the latest of that patch. Fixed that issue."><y>#</y><d>2019-12-06</d><h>15:49</h><w>rschmukler</w><a>@roklenarcic</a> Try the latest of that patch. Fixed that issue.</z><z id="t1575647393" t="rschmukler That was actually a lingering issue from a work-around that I did because fwrap wasn&apos;t skipping on non-collection input. Should be good now"><y>#</y><d>2019-12-06</d><h>15:49</h><w>rschmukler</w>That was actually a lingering issue from a work-around that I did because <code>fwrap</code> wasn&apos;t skipping on non-collection input. Should be good now</z><z id="t1575662705" t="ikitommi my 2 cents: • transformer should not have only one -transformer-name , but instead, a chain of names. strip-extra-keys should have an unique name • with mt/transformer , one can create a chain of transformations, wehre both names and encoders &amp; decoders are chained together and the chain of names is used for schema property based lookups. Any schema-defined will override the one defined in the transformer • encoders and decoders are defined as a transformation function of type schema opts =&gt; IntoInterceptor . This allows any transformation function to access the schema in question at “compile time”, allowing fast “drop extran keys” etc. • interceptor is to describe a transformation step. There is a IntoInterceptor Protocol, which is extended for a function (maps to :enter ), a map, Interceptor Record or a chain of IntoInterceptor . Malli could use sieppari later, as it already defines all of these."><y>#</y><d>2019-12-06</d><h>20:05</h><w>ikitommi</w>my 2 cents:
• transformer should not have only one <code>-transformer-name</code>, but instead, a chain of names. <code>strip-extra-keys</code> should have an unique name
• with <code>mt/transformer</code>, one can create a chain of transformations, wehre both names and encoders &amp; decoders are chained together and the chain of names is used for schema property based lookups. Any schema-defined will override the one defined in the transformer
• encoders and decoders are defined as a transformation function of type <code>schema opts =&gt; IntoInterceptor</code>. This allows any transformation function to access the schema in question at “compile time”, allowing fast “drop extran keys” etc.
• interceptor is to describe a transformation step.  There is a <code>IntoInterceptor</code> Protocol, which is extended for a function (maps to <code>:enter</code>), a map, Interceptor Record or a chain of <code>IntoInterceptor</code> . Malli could use sieppari later, as it already defines all of these.</z><z id="t1575662800" t="ikitommi In most cases, users don’t have to worry anything about the interceptor machineny, just use plain functions and it works. When you need more batteries on what happens when, you can either a) start using interceptors (enter &amp; leave) b) add more steps into the transformation chain c) both"><y>#</y><d>2019-12-06</d><h>20:06</h><w>ikitommi</w>In most cases, users don’t have to worry anything about the interceptor machineny, just use plain functions and it works. When you need more batteries on what happens when, you can either
a) start using interceptors (enter &amp; leave)
b) add more steps into the transformation chain
c) both</z><z id="t1575662823" t="ikitommi Simplest thing: (m/decode [string? {:decode/string &apos;(constantly #(str &quot;olipa_&quot; %))}] &quot;kerran&quot; mt/string-transformer) ; =&gt; olipa_kerran"><y>#</y><d>2019-12-06</d><h>20:07</h><w>ikitommi</w>Simplest thing:
<pre>(m/decode
  [string? {:decode/string &apos;(constantly #(str &quot;olipa_&quot; %))}]
  &quot;kerran&quot; mt/string-transformer)
; =&gt; olipa_kerran</pre></z><z id="t1575662838" t="ikitommi With Interceptor: (m/decode [string? {:decode/string &apos;(constantly {:enter #(str &quot;olipa_&quot; %) :leave #(str % &quot;_avaruus&quot;)})}] &quot;kerran&quot; mt/string-transformer) ; =&gt; &quot;olipa_kerran_avaruus&quot;"><y>#</y><d>2019-12-06</d><h>20:07</h><w>ikitommi</w>With Interceptor:
<pre>(m/decode
  [string? {:decode/string &apos;(constantly {:enter #(str &quot;olipa_&quot; %)
                                         :leave #(str % &quot;_avaruus&quot;)})}]
  &quot;kerran&quot; mt/string-transformer)
; =&gt; &quot;olipa_kerran_avaruus&quot;</pre></z><z id="t1575662886" t="ikitommi A custom transformaton chain: (m/decode [:and {:decode/before &apos;(constantly inc) :decode/after &apos;(constantly (partial * 2))} int?] 1 (mt/transformer {:name :before} {:name :after})) ; =&gt; 4"><y>#</y><d>2019-12-06</d><h>20:08</h><w>ikitommi</w>A custom transformaton chain:
<pre>(m/decode
  [:and
   {:decode/before &apos;(constantly inc)
    :decode/after  &apos;(constantly (partial * 2))}
   int?]
  1
  (mt/transformer {:name :before} {:name :after}))
; =&gt; 4</pre></z><z id="t1575663000" t="ikitommi both: (m/decode [:and {:decode/before &apos;(constantly {:enter inc :leave (partial * 2)}) :decode/after &apos;(constantly {:enter (partial * 4) :leave inc})} int?] 1 (mt/transformer {:name :before} {:name :after})) ; =&gt; 18"><y>#</y><d>2019-12-06</d><h>20:10</h><w>ikitommi</w>both:
<pre>(m/decode
  [:and
   {:decode/before &apos;(constantly {:enter inc
                                 :leave (partial * 2)})
    :decode/after  &apos;(constantly {:enter (partial * 4)
                                 :leave inc})}
   int?]
  1
  (mt/transformer {:name :before} {:name :after}))
; =&gt; 18</pre></z><z id="t1575663065" t="ikitommi using a chain: (m/decode [:and {:decode/before &apos;(constantly [inc inc #(* % 2) inc])} int?] 1 (mt/transformer {:name :before} {:name :after})) ; =&gt; 7"><y>#</y><d>2019-12-06</d><h>20:11</h><w>ikitommi</w>using a chain:
<pre>(m/decode
  [:and
   {:decode/before &apos;(constantly [inc inc #(* % 2) inc])}
   int?]
  1
  (mt/transformer {:name :before} {:name :after}))
; =&gt; 7</pre></z><z id="t1575664244" t="ikitommi As we’ll soon lose the Slack History, wrote it down as issue: https://github.com/metosin/malli/issues/136"><y>#</y><d>2019-12-06</d><h>20:30</h><w>ikitommi</w>As we’ll soon lose the Slack History, wrote it down as issue: <a href="https://github.com/metosin/malli/issues/136" target="_blank">https://github.com/metosin/malli/issues/136</a></z><z id="t1575664328" t="ikitommi also, idea to remote the schema opts =&gt; interceptor intermediate step in favor of reitit-style interceptors that have a separate compile-step. Sounds even more complex, but actually would simplify things."><y>#</y><d>2019-12-06</d><h>20:32</h><w>ikitommi</w>also, idea to remote the <code>schema opts =&gt; interceptor</code> intermediate step in favor of reitit-style interceptors that have a separate compile-step. Sounds even more complex, but actually would simplify things.</z><z id="t1575664344" t="ikitommi with it, the simple case: (m/decode [:and {:decode/after &apos;inc} int?] &quot;1&quot; (mt/transformer {:name :before} mt/string-transformer {:name :after})) ; =&gt; 2"><y>#</y><d>2019-12-06</d><h>20:32</h><w>ikitommi</w>with it, the simple case:
<pre>(m/decode
  [:and
   {:decode/after &apos;inc}
   int?]
  &quot;1&quot;
  (mt/transformer {:name :before} mt/string-transformer {:name :after}))
; =&gt; 2</pre></z><z id="t1575664425" t="ikitommi the complex case: ;; mounts only if there :multiplier property in schema (def multiply-interceptor {:name ::multiply :compile (fn [schema _] (if-let [multiplier (:multiplier (m/properties schema))] (partial * multiplier)))}) ;; the interceptor does not mount as the `:multiplier` is missing: (m/decode [:and {:decode/after multiply-interceptor} int?] &quot;2&quot; (mt/transformer {:name :before} mt/string-transformer {:name :after})) ; =&gt; 2 (m/decode [:and {:decode/after multiply-interceptor :multiplier 10} int?] &quot;2&quot; (mt/transformer {:name :before} mt/string-transformer {:name :after})) ; =&gt; 20"><y>#</y><d>2019-12-06</d><h>20:33</h><w>ikitommi</w>the complex case:
<pre>;; mounts only if there :multiplier property in schema
(def multiply-interceptor
  {:name ::multiply
   :compile (fn [schema _]
              (if-let [multiplier (:multiplier (m/properties schema))]
                (partial * multiplier)))})

;; the interceptor does not mount as the `:multiplier` is missing:
(m/decode
  [:and
   {:decode/after multiply-interceptor}
   int?]
  &quot;2&quot;
  (mt/transformer {:name :before} mt/string-transformer {:name :after}))
; =&gt; 2

(m/decode
  [:and
   {:decode/after multiply-interceptor
    :multiplier 10}
   int?]
  &quot;2&quot;
  (mt/transformer {:name :before} mt/string-transformer {:name :after}))
; =&gt; 20</pre></z><z id="t1575664541" t="ikitommi … and for the question: &gt; does it also override the construction in -transformer no."><y>#</y><d>2019-12-06</d><h>20:35</h><w>ikitommi</w>… and for the question:
&gt;  does it also override the construction in <code>-transformer</code>
no.</z><z id="t1575678479" t="roklenarcic hm ok… but should the`-transformer` function return a function that returns transform function? Because so far it just seems that it brings a lot of constantly use"><y>#</y><d>2019-12-07</d><h>00:27</h><w>roklenarcic</w>hm ok… but should the`-transformer` function return a function that returns transform function? Because so far it just seems that it brings a lot of <code>constantly</code> use</z><z id="t1575678553" t="roklenarcic I see so much constantly use that I wonder what is the other case (i.e. non-constantly)"><y>#</y><d>2019-12-07</d><h>00:29</h><w>roklenarcic</w>I see so much <code>constantly</code> use that I wonder what is the other case (i.e. non-constantly)</z><z id="t1575691084" t="ikitommi -transformer already sees the schema, so it can return directly an .... interceptor? The later comment shows how we can get rid of vobstantly in the schema properties too: https://github.com/metosin/malli/issues/136#issuecomment-562731476"><y>#</y><d>2019-12-07</d><h>03:58</h><w>ikitommi</w><code>-transformer</code> already sees the schema, so it can return directly an .... interceptor? The later comment shows how we can get rid of <code>vobstantly</code> in the schema properties too: <a href="https://github.com/metosin/malli/issues/136#issuecomment-562731476" target="_blank">https://github.com/metosin/malli/issues/136#issuecomment-562731476</a></z><z id="t1575717343" t="ikitommi the current internal vocabulary is quite messy, would these be good names for the future: * method :decode :encode * stage :enter :leave * context :json :string :before :after ..."><y>#</y><d>2019-12-07</d><h>11:15</h><w>ikitommi</w>the current internal vocabulary is quite messy, would these be good names for the future:
* <code>method</code> :decode :encode
* <code>stage</code> :enter :leave
* <code>context</code> :json :string :before :after ...</z><z id="t1575720312" t="ikitommi :enter/:leave and chain of contexts enable same kind of things. Wondering do we need them both… (def transformer (mt/transformer {:name :before} mt/string-transformer {:name :after})) (m/decode [:and {:decode/after &apos;inc} int?] &quot;1&quot; transformer) ; =&gt; 2 ; :enter ; :before ; :strip-keys ; :string =&gt; -&gt;int &quot;1&quot; =&gt; 1 ; :after =&gt; inc 1 =&gt; 2 ; :leave ; :after ; :string ; :strip-keys ; :before (m/decode [:and {:decode/before {:leave &apos;inc}} int?] &quot;1&quot; transformer) ; =&gt; 2 ; :enter ; :before ; :strip-keys ; :string =&gt; -&gt;int &quot;1&quot; =&gt; 1 ; :after ; :leave ; :after ; :string ; :strip-keys ; :before =&gt; inc 1 =&gt; 2 "><y>#</y><d>2019-12-07</d><h>12:05</h><w>ikitommi</w>:enter/:leave and chain of contexts enable same kind of things. Wondering do we need them both…

<pre>(def transformer (mt/transformer {:name :before} mt/string-transformer {:name :after}))

(m/decode 
  [:and 
   {:decode/after &apos;inc} 
   int?] 
  &quot;1&quot; 
  transformer)
; =&gt; 2

; :enter
;  :before
;  :strip-keys
;  :string =&gt; -&gt;int &quot;1&quot; =&gt; 1
;  :after =&gt; inc 1 =&gt; 2
; :leave
;  :after
;  :string
;  :strip-keys
;  :before

(m/decode 
  [:and 
   {:decode/before {:leave &apos;inc}}
   int?]
  &quot;1&quot; 
  transformer)
; =&gt; 2

; :enter
;  :before
;  :strip-keys
;  :string =&gt; -&gt;int &quot;1&quot; =&gt; 1
;  :after
; :leave
;  :after
;  :string
;  :strip-keys
;  :before =&gt; inc 1 =&gt; 2 </pre></z><z id="t1575737496" t="ikitommi welcome [:attrs {:href &quot;/_/_/users/U06QSF3BK&quot;}] simple_smile"><y>#</y><d>2019-12-07</d><h>16:51</h><w>ikitommi</w>welcome <a>@viesti</a> <b>simple_smile</b></z><z id="t1575737570" t="viesti 👋"><y>#</y><d>2019-12-07</d><h>16:52</h><w>viesti</w><b>👋</b></z><z id="t1575737585" t="ikitommi Did a small spike, seems to work, so PR out. Simplifies the Transformer Protocol and enables chaining of tranformers (instead of overriding schema-based encoder &amp; decoders like before). Also, better naming of things https://github.com/metosin/malli/pull/137"><y>#</y><d>2019-12-07</d><h>16:53</h><w>ikitommi</w>Did a small spike, seems to work, so PR out. Simplifies the <code>Transformer</code> Protocol and enables chaining of tranformers (instead of overriding schema-based encoder &amp; decoders like before). Also, better naming of things  <a href="https://github.com/metosin/malli/pull/137" target="_blank">https://github.com/metosin/malli/pull/137</a></z><z id="t1575737595" t="ikitommi (m/decode [int? {:decode/before &apos;(constantly {:leave inc}) :decode/after &apos;(constantly (partial * 2))}] &quot;10&quot; (mt/transformer {:name :before} mt/string-transformer {:decoders {&apos;int? (constantly inc)}} ;; anonymous {:name :after})) ; =&gt; 23 ;; :enter ;; :string &quot;10&quot; =&gt; 10 ;; anonymous 10 =&gt; 11 ;; :after 11 =&gt; 22 ;; :leave ;; :before 22 =&gt; 23"><y>#</y><d>2019-12-07</d><h>16:53</h><w>ikitommi</w><pre>(m/decode
  [int? {:decode/before &apos;(constantly {:leave inc})
         :decode/after &apos;(constantly (partial * 2))}]
  &quot;10&quot;
  (mt/transformer
    {:name :before}
    mt/string-transformer
    {:decoders {&apos;int? (constantly inc)}} ;; anonymous
    {:name :after}))
; =&gt; 23

;; :enter
;;  :string   &quot;10&quot; =&gt; 10
;;  anonymous   10 =&gt; 11
;;  :after      11 =&gt; 22
;; :leave
;;  :before     22 =&gt; 23</pre></z><z id="t1575911483" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] just confirming that with the changes, a custom :string/decode on a schema entry will still fully overwrite the default mt/string-transformer for the type, yes? I think that escape hatch is quite useful."><y>#</y><d>2019-12-09</d><h>17:11</h><w>rschmukler</w><a>@ikitommi</a> just confirming that with the changes, a custom <code>:string/decode</code>  on a schema entry will still fully overwrite the default <code>mt/string-transformer</code> for the type, yes? I think that escape hatch is quite useful.</z><z id="t1575911579" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] yes, will override, no changes there"><y>#</y><d>2019-12-09</d><h>17:12</h><w>ikitommi</w><a>@rschmukler</a> yes, will override, no changes there</z><z id="t1575911601" t="rschmukler Wonderful! Reading through the code but it looks great so far"><y>#</y><d>2019-12-09</d><h>17:13</h><w>rschmukler</w>Wonderful! Reading through the code but it looks great so far</z><z id="t1575911627" t="ikitommi just chains all the different names."><y>#</y><d>2019-12-09</d><h>17:13</h><w>ikitommi</w>just chains all the different names.</z><z id="t1575911642" t="rschmukler Hmmmm - do we even need transformer-chain protocol method?"><y>#</y><d>2019-12-09</d><h>17:14</h><w>rschmukler</w>Hmmmm - do we even need <code>transformer-chain</code>  protocol method?</z><z id="t1575911645" t="rschmukler Is it just for introspection?"><y>#</y><d>2019-12-09</d><h>17:14</h><w>rschmukler</w>Is it just for introspection?</z><z id="t1575911682" t="rschmukler I guess we&apos;re using it to assemble the interceptor chain"><y>#</y><d>2019-12-09</d><h>17:14</h><w>rschmukler</w>I guess we&apos;re using it to assemble the interceptor chain</z><z id="t1575911683" t="ikitommi oh, good point."><y>#</y><d>2019-12-09</d><h>17:14</h><w>ikitommi</w>oh, good point.</z><z id="t1575911710" t="rschmukler But I think we could move all of that into the transformer function and then simplify Transformer to a single value-transformer method, which could be nice"><y>#</y><d>2019-12-09</d><h>17:15</h><w>rschmukler</w>But I think we could move all of that into the <code>transformer</code> function and then simplify <code>Transformer</code> to a single <code>value-transformer</code> method, which could be nice</z><z id="t1575911925" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] do you have any thoughts on https://github.com/metosin/malli/pull/132"><y>#</y><d>2019-12-09</d><h>17:18</h><w>rschmukler</w><a>@ikitommi</a> do you have any thoughts on <a href="https://github.com/metosin/malli/pull/132" target="_blank">https://github.com/metosin/malli/pull/132</a></z><z id="t1575911970" t="rschmukler It ended up being critical for my application (the ability to encode the renaming of keys for future transformers) but I&apos;m open to alternative approaches if you&apos;ve got other ideas you want me to explore"><y>#</y><d>2019-12-09</d><h>17:19</h><w>rschmukler</w>It ended up being critical for my application (the ability to encode the renaming of keys for future transformers) but I&apos;m open to alternative approaches if you&apos;ve got other ideas you want me to explore</z><z id="t1575911991" t="rschmukler Part of me thinks using metadata is odd - part of me thinks that this is the perfect use case for it"><y>#</y><d>2019-12-09</d><h>17:19</h><w>rschmukler</w>Part of me thinks using metadata is odd - part of me thinks that this is the perfect use case for it</z><z id="t1575912009" t="rschmukler ie. it is metadata about how the new value was created... so maybe it makes sense?"><y>#</y><d>2019-12-09</d><h>17:20</h><w>rschmukler</w>ie. it is metadata about how the new value was created... so maybe it makes sense?</z><z id="t1575912114" t="rschmukler One thing we may have to do though, if we end up sticking with that API, is merge the metadata about transformers as we compose them"><y>#</y><d>2019-12-09</d><h>17:21</h><w>rschmukler</w>One thing we may have to do though, if we end up sticking with that API, is merge the metadata about transformers as we compose them</z><z id="t1575912502" t="rschmukler Also, random aside, but malli is Finish, correct?"><y>#</y><d>2019-12-09</d><h>17:28</h><w>rschmukler</w>Also, random aside, but malli is Finish, correct?</z><z id="t1575959451" t="eskos It’s Finnish for model (in both shape, example and fashion model sense), yes 🙂"><y>#</y><d>2019-12-10</d><h>06:30</h><w>eskos</w>It’s Finnish for model (in both shape, example and fashion model sense), yes <b>🙂</b></z><z id="t1575959525" t="eskos https://www.sanakirja.org/search.php?q=malli&amp;amp;l=17&amp;amp;l2=3"><y>#</y><d>2019-12-10</d><h>06:32</h><w>eskos</w><a href="https://www.sanakirja.org/search.php?q=malli&amp;amp;l=17&amp;amp;l2=3" target="_blank">https://www.sanakirja.org/search.php?q=malli&amp;amp;l=17&amp;amp;l2=3</a></z><z id="t1575962015" t="Toni Vanhala and mälli is chewing tobacco 😉"><y>#</y><d>2019-12-10</d><h>07:13</h><w>Toni Vanhala</w>and <code>mälli</code> is chewing tobacco <b>😉</b></z><z id="t1575972515" t="eskos or heavy impact 🙃"><y>#</y><d>2019-12-10</d><h>10:08</h><w>eskos</w>or heavy impact <b>🙃</b></z><z id="t1575993931" t="roklenarcic is there some way to have a schema like ` s/keys* "><y>#</y><d>2019-12-10</d><h>16:05</h><w>roklenarcic</w>is there some way to have a schema like `
<pre>s/keys*</pre>
</z><z id="t1575993959" t="roklenarcic Namely I’d like to generate sample function arguments, so I need a schema that describes function input"><y>#</y><d>2019-12-10</d><h>16:05</h><w>roklenarcic</w>Namely I’d like to generate sample function arguments, so I need a schema that describes function input</z><z id="t1575994002" t="roklenarcic but the function is defined as [arg1 arg2 &amp; {:keys [arg3 arg4]}"><y>#</y><d>2019-12-10</d><h>16:06</h><w>roklenarcic</w>but the function is defined as <code>[arg1 arg2 &amp; {:keys [arg3 arg4]}</code></z><z id="t1575995018" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] there are no sequence schemas like that, yet. Feature Request welcome."><y>#</y><d>2019-12-10</d><h>16:23</h><w>ikitommi</w><a>@roklenarcic</a> there are no sequence schemas like that, yet. Feature Request welcome.</z><z id="t1575995075" t="ikitommi definetely interested in having that, ideas on impl also welcome."><y>#</y><d>2019-12-10</d><h>16:24</h><w>ikitommi</w>definetely interested in having that, ideas on impl also welcome.</z><z id="t1575995228" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] haven&apos;t had time to check the rename keys, will do that when next time doing anything for malli. Good thing is that you can depend your fork that&apos;s to deps."><y>#</y><d>2019-12-10</d><h>16:27</h><w>ikitommi</w><a>@rschmukler</a> haven&apos;t had time to check the rename keys, will do that when next time doing anything for malli. Good thing is that you can depend your fork that&apos;s to deps.</z><z id="t1576000473" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] checking your latest recommendation but I think I&apos;ll be able to break it 😛"><y>#</y><d>2019-12-10</d><h>17:54</h><w>rschmukler</w><a>@ikitommi</a> checking your latest recommendation but I think I&apos;ll be able to break it <b>😛</b></z><z id="t1576000562" t="rschmukler Ah, I think I figured it out!"><y>#</y><d>2019-12-10</d><h>17:56</h><w>rschmukler</w>Ah, I think I figured it out!</z><z id="t1576003067" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] updated https://github.com/metosin/malli/pull/132 with something less abstract so you can see why it&apos;s difficult as currently implemented"><y>#</y><d>2019-12-10</d><h>18:37</h><w>rschmukler</w><a>@ikitommi</a> updated <a href="https://github.com/metosin/malli/pull/132" target="_blank">https://github.com/metosin/malli/pull/132</a> with something less abstract so you can see why it&apos;s difficult as currently implemented</z><z id="t1576003364" t="ikitommi thanks, will try to find an elegant way to resolve."><y>#</y><d>2019-12-10</d><h>18:42</h><w>ikitommi</w>thanks, will try to find an elegant way to resolve.</z><z id="t1576044218" t="ikitommi Checked the code., the build-transformer doesn’t work correctly. I think the same problem is with all sequential schemas: the chain in :leave shoud be in reverse order, so first apply the (child) value-transformers, then keys and last the map. This way, when changing the keys in :leave , it’s the last thing that happens."><y>#</y><d>2019-12-11</d><h>06:03</h><w>ikitommi</w>Checked the code., the <code>build-transformer</code> doesn’t work correctly. I think the same problem is with all sequential schemas:  the chain in <code>:leave</code> shoud be in reverse order, so first apply the (child) value-transformers, then keys and last the map. This way, when changing the keys in <code>:leave</code> , it’s the last thing that happens.</z><z id="t1576044380" t="ikitommi Also, all the three type of transformers should be created outside of the build-transformer fn. Current impl creates all three two times (both in enter &amp; leave) causing potential state-bugs with -value-transformer impls as the enter &amp; leave have different instances attached to them."><y>#</y><d>2019-12-11</d><h>06:06</h><w>ikitommi</w>Also, all the three type of transformers should be created outside of the <code>build-transformer</code> fn. Current impl creates all three two times (both in enter &amp; leave) causing potential state-bugs with <code>-value-transformer</code>impls as the enter &amp; leave have different instances attached to them.</z><z id="t1576044392" t="ikitommi I’ll write an issue, PR welcome."><y>#</y><d>2019-12-11</d><h>06:06</h><w>ikitommi</w>I’ll write an issue, PR welcome.</z><z id="t1576044442" t="ikitommi After that, this is the way to rename keys locally on encode: (m/encode [:map [:foo [:map [:foo int?] [:bar int?]]] [:bar int?]] {:foo {:foo 2 :bar 1} :bar 3} (transformer {:encoders {&apos;int? (constantly inc) :map (constantly {:leave #(set/rename-keys % {:foo :oof :bar :rab})})}})) ; =&gt; {:oof {:oof 3, :rab 2}, :rab 4}"><y>#</y><d>2019-12-11</d><h>06:07</h><w>ikitommi</w>After that,  this is the way to rename keys locally on encode:
<pre>(m/encode
  [:map
   [:foo [:map
          [:foo int?]
          [:bar int?]]]
   [:bar int?]]
  {:foo {:foo 2 :bar 1} :bar 3}
  (transformer
    {:encoders {&apos;int? (constantly inc)
                :map (constantly {:leave #(set/rename-keys % {:foo :oof :bar :rab})})}}))
; =&gt; {:oof {:oof 3, :rab 2}, :rab 4}</pre></z><z id="t1576044489" t="ikitommi after the upcoming interceptor :compile , will reduce to: (m/encode [:map [:foo [:map [:foo int?] [:bar int?]]] [:bar int?]] {:foo {:foo 2 :bar 1} :bar 3} (transformer {:encoders {&apos;int? inc :map {:leave #(set/rename-keys % {:foo :oof :bar :rab})}}})) ; =&gt; {:oof {:oof 3, :rab 2}, :rab 4}"><y>#</y><d>2019-12-11</d><h>06:08</h><w>ikitommi</w>after the upcoming interceptor <code>:compile</code>, will reduce to:
<pre>(m/encode
  [:map
   [:foo [:map
          [:foo int?]
          [:bar int?]]]
   [:bar int?]]
  {:foo {:foo 2 :bar 1} :bar 3}
  (transformer
    {:encoders {&apos;int? inc
                :map {:leave #(set/rename-keys % {:foo :oof :bar :rab})}}}))
; =&gt; {:oof {:oof 3, :rab 2}, :rab 4}</pre></z><z id="t1576044531" t="ikitommi which will, I hope, solve your case [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] elegantly enough?"><y>#</y><d>2019-12-11</d><h>06:08</h><w>ikitommi</w>which will, I hope, solve your case <a>@rschmukler</a> elegantly enough?</z><z id="t1576077926" t="ikitommi would be interesting to see how malli would work on the dev-tooling space. Related to https://www.reddit.com/r/Clojure/comments/e95pr5/data_structure_shape_hints_and_intellisense/"><y>#</y><d>2019-12-11</d><h>15:25</h><w>ikitommi</w>would be interesting to see how malli would work on the dev-tooling space. Related to <a href="https://www.reddit.com/r/Clojure/comments/e95pr5/data_structure_shape_hints_and_intellisense/" target="_blank">https://www.reddit.com/r/Clojure/comments/e95pr5/data_structure_shape_hints_and_intellisense/</a></z><z id="t1576079663" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] nice! Good catch on build-transformer being called twice and its impact on local state! Changing the order of the chains is also perfect - that&apos;ll make it much more like a postwalk on leave"><y>#</y><d>2019-12-11</d><h>15:54</h><w>rschmukler</w><a>@ikitommi</a> nice! Good catch on <code>build-transformer</code> being called twice and its impact on local state! Changing the order of the chains is also perfect - that&apos;ll make it much more like a postwalk on leave</z><z id="t1576087467" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;ve got the first prototype of my defn-spec / ghostwheel clone. For now I&apos;m doing it as a separate project (called aave ). Will be releasing a first version shortly"><y>#</y><d>2019-12-11</d><h>18:04</h><w>rschmukler</w><a>@ikitommi</a> I&apos;ve got the first prototype of my <code>defn-spec</code> / ghostwheel clone. For now I&apos;m doing it as a separate project (called <code>aave</code>). Will be releasing a first version shortly</z><z id="t1576087581" t="rschmukler The syntax is abstractable though, so you can use schema style too if you want. Things that it currently supports are purity detection, configurable hooks for input and output validation at both compile time and run time. Next up is benchmarking."><y>#</y><d>2019-12-11</d><h>18:06</h><w>rschmukler</w>The syntax is abstractable though, so you can use schema style too if you want. Things that it currently supports are purity detection, configurable hooks for input and output validation at both compile time and run time. Next up is benchmarking.</z><z id="t1576087596" t="rschmukler I also thought it&apos;d be cool to be able to do something like"><y>#</y><d>2019-12-11</d><h>18:06</h><w>rschmukler</w>I also thought it&apos;d be cool to be able to do something like</z><z id="t1576087689" t="rschmukler (defn add-name-key [a] [:map =&gt; (+ a [:name string?])] (assoc a :name &quot;Bob&quot;) Where + symbol basically expands out to &quot;merge schema from parameter a &quot;"><y>#</y><d>2019-12-11</d><h>18:08</h><w>rschmukler</w><pre>(defn add-name-key
  [a]
  [:map =&gt; (+ a [:name string?])]
  (assoc a :name &quot;Bob&quot;)</pre>
Where <code>+ symbol</code> basically expands out to &quot;merge schema from parameter <code>a</code> &quot;</z><z id="t1576087734" t="rschmukler Might be overkill haha - but it could enable deep compile-time tracking of types"><y>#</y><d>2019-12-11</d><h>18:08</h><w>rschmukler</w>Might be overkill haha - but it could enable deep compile-time tracking of types</z><z id="t1576088025" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] sounds awesome, and what a name! 👻"><y>#</y><d>2019-12-11</d><h>18:13</h><w>ikitommi</w><a>@rschmukler</a> sounds awesome, and what a name! <b>👻</b></z><z id="t1576088039" t="rschmukler 😄 I&apos;m glad you like it"><y>#</y><d>2019-12-11</d><h>18:13</h><w>rschmukler</w><b>😄</b> I&apos;m glad you like it</z><z id="t1576088099" t="beders ok, let&apos;s try this again. How would you write a function that returns a malli spec to test if a string is of length n?"><y>#</y><d>2019-12-11</d><h>18:14</h><w>beders</w>ok, let&apos;s try this again. How would you write a function that returns a malli spec to test if a string is of length n?</z><z id="t1576088103" t="beders I&apos;m getting this far:"><y>#</y><d>2019-12-11</d><h>18:15</h><w>beders</w>I&apos;m getting this far:</z><z id="t1576088106" t="beders (defn fixed-length? [n] [:and &apos;string? [:fn `(~&apos;fn [~&apos;val] (~&apos;= ~n (~&apos;count ~&apos;val)))]] )"><y>#</y><d>2019-12-11</d><h>18:15</h><w>beders</w><pre>(defn fixed-length? [n]
  [:and &apos;string? [:fn `(~&apos;fn [~&apos;val] (~&apos;= ~n (~&apos;count ~&apos;val)))]]
  )</pre></z><z id="t1576088152" t="beders that gives me: (preds/fixed-length? 10) =&gt; [:and string? [:fn (fn [val] (= 10 (count val)))]]"><y>#</y><d>2019-12-11</d><h>18:15</h><w>beders</w>that gives me:
<pre>(preds/fixed-length? 10)
=&gt; [:and string? [:fn (fn [val] (= 10 (count val)))]]</pre></z><z id="t1576088294" t="rschmukler [:attrs {:href &quot;/_/_/users/U628K7XGQ&quot;}] Do you need it to all be quoted? Malli should take care of that for you. if not, you can just do: (defn fixed-length? [n] [:and string? [:fn #(= n (count %)]])"><y>#</y><d>2019-12-11</d><h>18:18</h><w>rschmukler</w><a>@beders</a> Do you need it to all be quoted? Malli should take care of that for you. if not, you can just do:

<pre>(defn fixed-length? [n]
  [:and string? [:fn #(= n (count %)]])</pre></z><z id="t1576088300" t="beders but my code doesn&apos;t look very nice. Lots of quoting to prevent backtick from full name resolution"><y>#</y><d>2019-12-11</d><h>18:18</h><w>beders</w>but my code doesn&apos;t look very nice. Lots of quoting to prevent backtick from full name resolution</z><z id="t1576088359" t="beders your version captures n"><y>#</y><d>2019-12-11</d><h>18:19</h><w>beders</w>your version captures n</z><z id="t1576088364" t="beders I think"><y>#</y><d>2019-12-11</d><h>18:19</h><w>beders</w>I think</z><z id="t1576088460" t="beders (defn fixed-length? [n] [:and string? [:fn #(= n (count %))]]) =&gt; #&apos;sql-to-malli.integration/fixed-length? (edn/write-string (fixed-length? 10)) =&gt; &quot;[:and string? [:fn #object[sql_to_malli.integration$fixed_length_QMARK_$fn__10416 0x576cee60 \&quot;"><y>#</y><d>2019-12-11</d><h>18:21</h><w>beders</w><pre>(defn fixed-length? [n]
  [:and string? [:fn #(= n (count %))]])
=&gt; #&apos;sql-to-malli.integration/fixed-length?
(edn/write-string (fixed-length? 10))
=&gt;
&quot;[:and string? [:fn #object[sql_to_malli.integration$fixed_length_QMARK_$fn__10416 0x576cee60 \&quot;</pre></z><z id="t1576088513" t="rschmukler Ah I suppose that&apos;s true!"><y>#</y><d>2019-12-11</d><h>18:21</h><w>rschmukler</w>Ah I suppose that&apos;s true!</z><z id="t1576088517" t="beders if I don&apos;t use the extension unquote-quoting, I get the fully resolved names"><y>#</y><d>2019-12-11</d><h>18:21</h><w>beders</w>if I don&apos;t use the extension unquote-quoting, I get the fully resolved names</z><z id="t1576088552" t="rschmukler can you do"><y>#</y><d>2019-12-11</d><h>18:22</h><w>rschmukler</w>can you do</z><z id="t1576088554" t="beders (defn fixed-length? [n] [:and &apos;string? [:fn `(fn [val] (= ~n (~&apos;count val)))]] ) (fixed-length? 10) =&gt; [:and string? [:fn (clojure.core/fn [clojure.core/val] (clojure.core/= 10 (count clojure.core/val)))]]"><y>#</y><d>2019-12-11</d><h>18:22</h><w>beders</w><pre>(defn fixed-length? [n]
  [:and &apos;string? [:fn `(fn [val] (= ~n (~&apos;count val)))]]
  
  )
(fixed-length? 10)
=&gt; [:and string? [:fn (clojure.core/fn [clojure.core/val] (clojure.core/= 10 (count clojure.core/val)))]]</pre></z><z id="t1576088569" t="beders which kinda works, just not very readable"><y>#</y><d>2019-12-11</d><h>18:22</h><w>beders</w>which kinda works, just not very readable</z><z id="t1576088611" t="beders trying to stick with the data-only mantra here"><y>#</y><d>2019-12-11</d><h>18:23</h><w>beders</w>trying to stick with the data-only mantra here</z><z id="t1576088623" t="beders so no capturing"><y>#</y><d>2019-12-11</d><h>18:23</h><w>beders</w>so no capturing</z><z id="t1576088625" t="rschmukler But you need your schema to be serializable?"><y>#</y><d>2019-12-11</d><h>18:23</h><w>rschmukler</w>But you need your schema to be serializable?</z><z id="t1576088669" t="beders I&apos;m working on a library that takes a SQL database schema and spits out malli"><y>#</y><d>2019-12-11</d><h>18:24</h><w>beders</w>I&apos;m working on a library that takes a SQL database schema and spits out malli</z><z id="t1576088679" t="rschmukler I&apos;d consider adding it to your registry using fn-schema"><y>#</y><d>2019-12-11</d><h>18:24</h><w>rschmukler</w>I&apos;d consider adding it to your registry using <code>fn-schema</code></z><z id="t1576088679" t="beders I can probably do without serialization"><y>#</y><d>2019-12-11</d><h>18:24</h><w>beders</w>I can probably do without serialization</z><z id="t1576088682" t="ikitommi you can single-quote the fn"><y>#</y><d>2019-12-11</d><h>18:24</h><w>ikitommi</w>you can single-quote the fn</z><z id="t1576088697" t="beders if I single-quote the fn, I&apos;m capturing n"><y>#</y><d>2019-12-11</d><h>18:24</h><w>beders</w>if I single-quote the fn, I&apos;m capturing <code>n</code></z><z id="t1576088699" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] he needs to get the 10 in there though"><y>#</y><d>2019-12-11</d><h>18:24</h><w>rschmukler</w><a>@ikitommi</a> he needs to get the 10 in there though</z><z id="t1576088744" t="rschmukler but with a custom registry, you could just do [:and &apos;string? [:fixed-length 10]]"><y>#</y><d>2019-12-11</d><h>18:25</h><w>rschmukler</w>but with a custom registry, you could just do <code>[:and &apos;string? [:fixed-length 10]]</code></z><z id="t1576088746" t="beders yes, adding it to the registry might be the only sane choice for now"><y>#</y><d>2019-12-11</d><h>18:25</h><w>beders</w>yes, adding it to the registry might be the only sane choice for now</z><z id="t1576088807" t="beders that would make my library a runtime dependency"><y>#</y><d>2019-12-11</d><h>18:26</h><w>beders</w>that would make my library a runtime dependency</z><z id="t1576088831" t="beders I was hoping I could run this on a database schema, copy the resulting malli schemas and then run with them"><y>#</y><d>2019-12-11</d><h>18:27</h><w>beders</w>I was hoping I could run this on a database schema, copy the resulting malli schemas and then run with them</z><z id="t1576088860" t="beders looks like I need to decide on various trade-offs"><y>#</y><d>2019-12-11</d><h>18:27</h><w>beders</w>looks like I need to decide on various trade-offs</z><z id="t1576088875" t="ikitommi a :fn variant that takes extra args from properties?"><y>#</y><d>2019-12-11</d><h>18:27</h><w>ikitommi</w>a <code>:fn</code> variant that takes extra args from properties?</z><z id="t1576088878" t="beders just wanted to get some ideas on code generation"><y>#</y><d>2019-12-11</d><h>18:27</h><w>beders</w>just wanted to get some ideas on code generation</z><z id="t1576088891" t="beders that make for readable schemas"><y>#</y><d>2019-12-11</d><h>18:28</h><w>beders</w>that make for readable schemas</z><z id="t1576088908" t="beders I like [:fixed-length 10] though. Very readable"><y>#</y><d>2019-12-11</d><h>18:28</h><w>beders</w>I like <code>[:fixed-length 10]</code> though. Very readable</z><z id="t1576089032" t="beders thanks for the ideas!"><y>#</y><d>2019-12-11</d><h>18:30</h><w>beders</w>thanks for the ideas!</z><z id="t1576089059" t="rschmukler Oh you know"><y>#</y><d>2019-12-11</d><h>18:30</h><w>rschmukler</w>Oh you know</z><z id="t1576089063" t="rschmukler you might be able to do"><y>#</y><d>2019-12-11</d><h>18:31</h><w>rschmukler</w>you might be able to do</z><z id="t1576089151" t="rschmukler Nope, never mind 😄"><y>#</y><d>2019-12-11</d><h>18:32</h><w>rschmukler</w>Nope, never mind <b>😄</b></z><z id="t1576090216" t="ikitommi JSON Schema defines extra attributes for numbers, strings and arrays. Malli could have those too? [string? {:min 10, :max 10}]"><y>#</y><d>2019-12-11</d><h>18:50</h><w>ikitommi</w>JSON Schema defines extra attributes for numbers, strings and arrays. Malli could have those too?

 <code>[string? {:min 10, :max 10}]</code></z><z id="t1576090282" t="ikitommi Also, malli schema properties should be defined with malli schemas to get nice docs &amp; validation of those too."><y>#</y><d>2019-12-11</d><h>18:51</h><w>ikitommi</w>Also, malli schema properties should be defined with malli schemas to get nice docs &amp; validation of those too.</z><z id="t1576090471" t="ikitommi [:attrs {:href &quot;/_/_/users/U628K7XGQ&quot;}] if the runtime dependwncy would be ok, you could also just use the Schema Var instead of registry: [my-lib.schemas/fixed-lenght 10]"><y>#</y><d>2019-12-11</d><h>18:54</h><w>ikitommi</w><a>@beders</a> if the runtime dependwncy would be ok, you could also just use the Schema Var instead of registry:

<code>[my-lib.schemas/fixed-lenght 10]</code></z><z id="t1576090690" t="beders Good point. I mean, technically, this works too: (m/validate [:re #&quot;^.{4}$&quot;] &quot;bubu&quot;)"><y>#</y><d>2019-12-11</d><h>18:58</h><w>beders</w>Good point. I mean, technically, this works too:
<pre>(m/validate [:re #&quot;^.{4}$&quot;] &quot;bubu&quot;)</pre></z><z id="t1576090696" t="beders but probably a bit overkill 😉"><y>#</y><d>2019-12-11</d><h>18:58</h><w>beders</w>but probably a bit overkill <b>😉</b></z><z id="t1576090718" t="ikitommi the fn can also be a string btw, so this should work (injection warning!!): [:and string? [:fn (str &quot;#(= &quot; n &quot; (count %))&quot;)]]"><y>#</y><d>2019-12-11</d><h>18:58</h><w>ikitommi</w>the fn can also be a string btw, so this should work (injection warning!!):

<code>[:and string? [:fn (str &quot;#(= &quot; n &quot; (count %))&quot;)]]</code></z><z id="t1576090838" t="beders ah, didn&apos;t know that. Thx!"><y>#</y><d>2019-12-11</d><h>19:00</h><w>beders</w>ah, didn&apos;t know that. Thx!</z><z id="t1576090927" t="ikitommi looking forward to seeing the lib."><y>#</y><d>2019-12-11</d><h>19:02</h><w>ikitommi</w>looking forward to seeing the lib.</z><z id="t1576114977" t="beders it looks like m/fn-schema doesn&apos;t allow for any other parameters (or children)"><y>#</y><d>2019-12-12</d><h>01:42</h><w>beders</w>it looks like <code>m/fn-schema</code> doesn&apos;t allow for any other parameters (or children)</z><z id="t1576115019" t="beders here&apos;s what I tried: (defn max-length? ([n s] (and (string? s) (&lt; (count s) n))) ) (def default-registry (merge m/default-registry {:max-length (m/fn-schema :max-length preds/max-length?)}))"><y>#</y><d>2019-12-12</d><h>01:43</h><w>beders</w>here&apos;s what I tried:
<pre>(defn max-length?
  ([n s]
   (and (string? s) (&lt; (count s) n)))
  )
(def default-registry (merge m/default-registry {:max-length (m/fn-schema :max-length preds/max-length?)}))</pre></z><z id="t1576115058" t="beders I then should be able to say this, right? (m/validate [:max-length 4] &quot;bubu&quot; {:registry default-registry})"><y>#</y><d>2019-12-12</d><h>01:44</h><w>beders</w>I then should be able to say this, right?
<pre>(m/validate [:max-length 4] &quot;bubu&quot; {:registry default-registry})</pre></z><z id="t1576115102" t="beders but alas #error{:cause &quot;:malli.core/child-error&quot;, :data {:type :malli.core/child-error, :data {:name :max-length, :properties nil, :children (4), :min 0, :max 0}},"><y>#</y><d>2019-12-12</d><h>01:45</h><w>beders</w>but alas
<pre>#error{:cause &quot;:malli.core/child-error&quot;,
       :data {:type :malli.core/child-error, :data {:name :max-length, :properties nil, :children (4), :min 0, :max 0}},</pre></z><z id="t1576115142" t="beders which - when checking the code - happens in fn-schema"><y>#</y><d>2019-12-12</d><h>01:45</h><w>beders</w>which - when checking the code - happens in <code>fn-schema</code></z><z id="t1576115175" t="beders it seems -partial-fn-schema allows for additional parameters, but is private"><y>#</y><d>2019-12-12</d><h>01:46</h><w>beders</w>it seems <code>-partial-fn-schema</code>  allows for additional parameters, but is private</z><z id="t1576115217" t="beders also, fn-schema doesn&apos;t pass on properties"><y>#</y><d>2019-12-12</d><h>01:46</h><w>beders</w>also, <code>fn-schema</code>  doesn&apos;t pass on properties</z><z id="t1576115332" t="beders any hints on how to register custom predicates with params would be awesome"><y>#</y><d>2019-12-12</d><h>01:48</h><w>beders</w>any hints on how to register custom predicates with params would be awesome</z><z id="t1576129312" t="Johan Is Malli a good place to handle default value ?"><y>#</y><d>2019-12-12</d><h>05:41</h><w>Johan</w>Is Malli a good place to handle default value ?</z><z id="t1576134599" t="ikitommi [:attrs {:href &quot;/_/_/users/UFSMGQ690&quot;}] sure. could be just :default property and a pre-defined transformer to use that for missing values. metosin/schema-tools has just about that."><y>#</y><d>2019-12-12</d><h>07:09</h><w>ikitommi</w><a>@johan178</a> sure. could be just <code>:default</code> property and a pre-defined transformer to use that for missing values. <code>metosin/schema-tools</code> has just about that.</z><z id="t1576134646" t="ikitommi need to add capability to transform all schemas, so need a small development before it can work. Please raise an issue."><y>#</y><d>2019-12-12</d><h>07:10</h><w>ikitommi</w>need to add capability to transform all schemas, so need a small development before it can work. Please raise an issue.</z><z id="t1576180026" t="rschmukler Hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;m in the process of fixing up transforms for independent leaves and enters (and reverse order). I have a few questions for you while I&apos;m in here..."><y>#</y><d>2019-12-12</d><h>19:47</h><w>rschmukler</w>Hey <a>@ikitommi</a> I&apos;m in the process of fixing up transforms for independent leaves and enters (and reverse order). I have a few questions for you while I&apos;m in here...</z><z id="t1576180311" t="rschmukler 1. For the collection transformer, right now fwrap auto-coerces things into the appropriate type. This happens after the value-transformer is called currently - meaning that I don&apos;t think it&apos;s possible for the value-transformer to change it&apos;s collection type on encode because it&apos;ll always be coerced back. Should we keep this behavior? 2. the map-of transformer currently calls transform keys and transform values at the same time as it iterates through the map. I think it&apos;s fine to keep this for enter and leave? ie. it&apos;ll basically be enter: transform-map -&gt; transform k 1 -&gt; transform v 1 -&gt; transform k 2 -&gt; transform v 2 and leave: transform k 1 -&gt; transform v 1 -&gt; transform k 2 -&gt; transform v 2 -&gt; transform map 3. The collection transformer currently does a single step of building the collection and mapping the values. We probably want to do enter: coll-transform -&gt; transform children and leave: transform-children -&gt; transform"><y>#</y><d>2019-12-12</d><h>19:51</h><w>rschmukler</w>1. For the collection transformer, right now <code>fwrap</code> auto-coerces things into the appropriate type. This happens after the <code>value-transformer</code> is called currently - meaning that I don&apos;t think it&apos;s possible for the <code>value-transformer</code> to change it&apos;s collection type on <code>encode</code> because it&apos;ll always be coerced back. Should we keep this behavior?
2. the <code>map-of</code> transformer currently calls transform keys and transform values at the same time as it iterates through the map. I think it&apos;s fine to keep this for enter and leave? ie. it&apos;ll basically be <code>enter: transform-map -&gt; transform k 1 -&gt; transform v 1 -&gt; transform k 2 -&gt; transform v 2</code>  and <code>leave: transform k 1 -&gt; transform v 1 -&gt; transform k 2 -&gt; transform v 2 -&gt; transform map</code> 
3. The collection transformer currently does a single step of building the collection and mapping the values. We probably want to do <code>enter: coll-transform -&gt; transform children</code> and <code>leave: transform-children -&gt; transform</code></z><z id="t1576184603" t="ikitommi 1) I think the fwrap should be removed and moved under Transformer decoders. e.g. as the arrays are always mapped to Clojure vectors in JSON decoding (by json parsers in both clj &amp; cljs), with mt/json-transformer there should be no transformation needed for :vector , only for other sequence types. The currently silly mt/collection-transformer could have decoders for all collection types."><y>#</y><d>2019-12-12</d><h>21:03</h><w>ikitommi</w>1) I think the <code>fwrap</code> should be removed and moved under Transformer decoders. e.g. as the arrays are always mapped to Clojure vectors in JSON decoding (by json parsers in both clj &amp; cljs), with <code>mt/json-transformer</code> there should be no transformation needed for <code>:vector</code>, only for other sequence types. The currently silly <code>mt/collection-transformer</code>could have decoders for all collection types.</z><z id="t1576184631" t="ikitommi 2 &amp; 3 👍"><y>#</y><d>2019-12-12</d><h>21:03</h><w>ikitommi</w>2 &amp; 3 <b>👍</b></z><z id="t1576184675" t="rschmukler Re. 1 I want to land this PR w/o that then if you don&apos;t mind. It&apos;s already huge"><y>#</y><d>2019-12-12</d><h>21:04</h><w>rschmukler</w>Re. 1 I want to land this PR w/o that then if you don&apos;t mind. It&apos;s already huge</z><z id="t1576184683" t="ikitommi sure"><y>#</y><d>2019-12-12</d><h>21:04</h><w>ikitommi</w>sure</z><z id="t1576184713" t="rschmukler The other thing that we don&apos;t do much, that I&apos;m going to add, if you think it&apos;s a good idea, is ensuring that the type doesn&apos;t change between transforms"><y>#</y><d>2019-12-12</d><h>21:05</h><w>rschmukler</w>The other thing that we don&apos;t do much, that I&apos;m going to add, if you think it&apos;s a good idea, is ensuring that the type doesn&apos;t change between transforms</z><z id="t1576184733" t="rschmukler ie. if a map encodes itself to an integer, we still try and call reduce-kv on it for the key and value transformers"><y>#</y><d>2019-12-12</d><h>21:05</h><w>rschmukler</w>ie. if a map encodes itself to an integer, we still try and call <code>reduce-kv</code> on it for the key and value transformers</z><z id="t1576184740" t="rschmukler We likely shouldn&apos;t do that"><y>#</y><d>2019-12-12</d><h>21:05</h><w>rschmukler</w>We likely shouldn&apos;t do that</z><z id="t1576184799" t="rschmukler Actually - I&apos;m going to keep this focused at just the changes to fix #140 and the encode decode order - we can add more later"><y>#</y><d>2019-12-12</d><h>21:06</h><w>rschmukler</w>Actually - I&apos;m going to keep this focused at just the changes to fix #140 and the encode decode order - we can add more later</z><z id="t1576184855" t="ikitommi btw, the 3 might have a big effect on the perf?"><y>#</y><d>2019-12-12</d><h>21:07</h><w>ikitommi</w>btw, the 3 might have a big effect on the perf?</z><z id="t1576184910" t="rschmukler I&apos;m still using transducers where possible"><y>#</y><d>2019-12-12</d><h>21:08</h><w>rschmukler</w>I&apos;m still using transducers where possible</z><z id="t1576184915" t="ikitommi depending on how the collection is transformed, retaining the type automatically or not"><y>#</y><d>2019-12-12</d><h>21:08</h><w>ikitommi</w>depending on how the collection is transformed, retaining the type automatically or not</z><z id="t1576184926" t="rschmukler and using fempty etc"><y>#</y><d>2019-12-12</d><h>21:08</h><w>rschmukler</w>and using fempty etc</z><z id="t1576184936" t="ikitommi cool. Sorry, Need to go."><y>#</y><d>2019-12-12</d><h>21:08</h><w>ikitommi</w>cool. Sorry, Need to go.</z><z id="t1576184939" t="rschmukler I tried to be mindful of the performance implications - but a close look is definitely a good idea!"><y>#</y><d>2019-12-12</d><h>21:08</h><w>rschmukler</w>I tried to be mindful of the performance implications - but a close look is definitely a good idea!</z><z id="t1576184942" t="rschmukler Cool, PR incoming"><y>#</y><d>2019-12-12</d><h>21:09</h><w>rschmukler</w>Cool, PR incoming</z><z id="t1576184944" t="rschmukler Catch you later!"><y>#</y><d>2019-12-12</d><h>21:09</h><w>rschmukler</w>Catch you later!</z><z id="t1576212797" t="Johan Can a defined transformer access the schema ? So given [:map [:key {:option :cool} keyword?]] Can a transformer access the [:key {:option :cool} keyword?]] data ?"><y>#</y><d>2019-12-13</d><h>04:53</h><w>Johan</w>Can a defined transformer access the schema ?
So given [:map [:key {:option :cool} keyword?]]
Can a transformer access the [:key {:option :cool} keyword?]] data ?</z><z id="t1576217569" t="ikitommi [:attrs {:href &quot;/_/_/users/UFSMGQ690&quot;}] yes, the current transformer is of type schema opts =&gt; value =&gt; value , so: [:map {:decode/string (fn [schema opts] (let [cool (:option (m/properties schema))] (fn [value] …)))}]"><y>#</y><d>2019-12-13</d><h>06:12</h><w>ikitommi</w><a>@johan178</a> yes, the current transformer is of type <code>schema opts =&gt; value =&gt; value</code>, so:

<pre>[:map {:decode/string (fn [schema opts] 
                        (let [cool (:option (m/properties schema))]
                          (fn [value] …)))}]</pre></z><z id="t1576217631" t="ikitommi the syntax will change before hitting first public to: [:map {:decode/string {:compile (fn [schema opts] (let [cool (:option (m/properties schema))] (fn [value] …)))}}]"><y>#</y><d>2019-12-13</d><h>06:13</h><w>ikitommi</w>the syntax will change before hitting first public to:
<pre>[:map {:decode/string {:compile (fn [schema opts] 
                                  (let [cool (:option (m/properties schema))]
                                    (fn [value] …)))}}]</pre></z><z id="t1576217653" t="ikitommi https://github.com/metosin/malli/issues/136#issuecomment-562731476"><y>#</y><d>2019-12-13</d><h>06:14</h><r>ikitommi</r><a href="https://github.com/metosin/malli/issues/136#issuecomment-562731476" target="_blank">https://github.com/metosin/malli/issues/136#issuecomment-562731476</a></z><z id="t1576254900" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks for the quick PR review! Would you be open to me adding .nrepl-port and .dir-locals.el to gitignore? Alternatively if you want me to commit a .`dir-locals.el` it would make it so that new people contributing would automatically adhere to your style preferences"><y>#</y><d>2019-12-13</d><h>16:35</h><w>rschmukler</w><a>@ikitommi</a> Thanks for the quick PR review! Would you be open to me adding <code>.nrepl-port</code> and <code>.dir-locals.el</code> to gitignore? Alternatively if you want me to commit a .`dir-locals.el` it would make it so that new people contributing would automatically adhere to your style preferences</z><z id="t1576255603" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] sure, go ahead, either way"><y>#</y><d>2019-12-13</d><h>16:46</h><w>ikitommi</w><a>@rschmukler</a> sure, go ahead, either way</z><z id="t1576255612" t="rschmukler :thumbsup:"><y>#</y><d>2019-12-13</d><h>16:46</h><w>rschmukler</w><b>:thumbsup:</b></z><z id="t1576258189" t="eskos .dir-locals.el is only relevant to cider users, so I wouldn&apos;t commit them. In general tooling/IDE config files shouldn&apos;t live in source repos 😛"><y>#</y><d>2019-12-13</d><h>17:29</h><w>eskos</w><code>.dir-locals.el</code> is only relevant to cider users, so I wouldn&apos;t commit them. In general tooling/IDE config files shouldn&apos;t live in source repos <b>😛</b></z><z id="t1576259313" t="rschmukler .dir-locals.el is relevant to all emacs users"><y>#</y><d>2019-12-13</d><h>17:48</h><w>rschmukler</w><code>.dir-locals.el</code> is relevant to all emacs users</z><z id="t1576259397" t="rschmukler But I&apos;m happy to not commit it - just could save PR time of people having to adjust their formatting to the project style"><y>#</y><d>2019-12-13</d><h>17:49</h><w>rschmukler</w>But I&apos;m happy to not commit it - just could save PR time of people having to adjust their formatting to the project style</z><z id="t1576259973" t="rschmukler https://github.com/teknql/aave - First rendition of Aave!"><y>#</y><d>2019-12-13</d><h>17:59</h><w>rschmukler</w><a href="https://github.com/teknql/aave" target="_blank">https://github.com/teknql/aave</a> - First rendition of Aave!</z><z id="t1576260488" t="ikitommi agree on Esko for now, so let’s ignore the files."><y>#</y><d>2019-12-13</d><h>18:08</h><w>ikitommi</w>agree on Esko for now, so let’s ignore the files.</z><z id="t1576260540" t="ikitommi Congratz on Aave!! I’ll add it to README as soon as the PRs are merged (just did the interceptor :compile , will merge it after yours [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] )."><y>#</y><d>2019-12-13</d><h>18:09</h><w>ikitommi</w>Congratz on Aave!! I’ll add it to README as soon as the PRs are merged (just did the interceptor <code>:compile</code>, will merge it after yours <a>@rschmukler</a>).</z><z id="t1576260569" t="rschmukler Woo! Thanks! Love the momentum we&apos;ve got going on!"><y>#</y><d>2019-12-13</d><h>18:09</h><w>rschmukler</w>Woo! Thanks! Love the momentum we&apos;ve got going on!</z><z id="t1576261346" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What&apos;re your thoughts for potentially adding support for a dynamic variable for either full on malli options, or perhaps something like *registry-extensions* which is usually nil but is automatically merged into default-registry when set. I sometimes find myself having to thread malli options through things, or wrapping malli functions with my own namespace with a custom registry, etc. Since it&apos;s mostly for compile-time code anyway, the performance implications shouldn&apos;t matter much. Part of me feels like it might be too &quot;magical&quot; but the other part makes me feel like it could improve ergonomics"><y>#</y><d>2019-12-13</d><h>18:22</h><w>rschmukler</w><a>@ikitommi</a> What&apos;re your thoughts for potentially adding support for a dynamic variable for either full on malli options, or perhaps something like <code>*registry-extensions*</code> which is usually <code>nil</code> but is automatically merged into <code>default-registry</code> when set. I sometimes find myself having to thread malli options through things, or wrapping malli functions with my own namespace with a custom registry, etc. Since it&apos;s mostly for compile-time code anyway, the performance implications shouldn&apos;t matter much. Part of me feels like it might be too &quot;magical&quot; but the other part makes me feel like it could improve ergonomics</z><z id="t1576262005" t="ikitommi need to think about that."><y>#</y><d>2019-12-13</d><h>18:33</h><w>ikitommi</w>need to think about that.</z><z id="t1576262077" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] do you have plan to fix the 142? (the is the x bug IMO + the formatting)"><y>#</y><d>2019-12-13</d><h>18:34</h><w>ikitommi</w><a>@rschmukler</a> do you have plan to fix the 142? (the is the <code>x</code> bug IMO + the formatting)</z><z id="t1576262108" t="rschmukler I think I already did no?"><y>#</y><d>2019-12-13</d><h>18:35</h><w>rschmukler</w>I think I already did no?</z><z id="t1576262120" t="rschmukler I force pushed updates an hour or two ago"><y>#</y><d>2019-12-13</d><h>18:35</h><w>rschmukler</w>I force pushed updates an hour or two ago</z><z id="t1576262172" t="rschmukler Let me know if it needs anything. The x bug wasn’t caught by tests because map-of tests were disabled so I also fixed those "><y>#</y><d>2019-12-13</d><h>18:36</h><w>rschmukler</w>Let me know if it needs anything. The x bug wasn’t caught by tests because map-of tests were disabled so I also fixed those </z><z id="t1576262268" t="ikitommi oh, the review panel just doesn’t show the updated. my bad. will merge."><y>#</y><d>2019-12-13</d><h>18:37</h><w>ikitommi</w>oh, the review panel just doesn’t show the updated. my bad. will merge.</z><z id="t1576262288" t="rschmukler Awesome!"><y>#</y><d>2019-12-13</d><h>18:38</h><w>rschmukler</w>Awesome!</z><z id="t1576262412" t="ikitommi could you check https://github.com/metosin/malli/pull/146 ?"><y>#</y><d>2019-12-13</d><h>18:40</h><w>ikitommi</w>could you check <a href="https://github.com/metosin/malli/pull/146" target="_blank">https://github.com/metosin/malli/pull/146</a> ?</z><z id="t1576262648" t="rschmukler Yep, will take a look now"><y>#</y><d>2019-12-13</d><h>18:44</h><w>rschmukler</w>Yep, will take a look now</z><z id="t1576263188" t="rschmukler Looks good! Sorry I missed some indents"><y>#</y><d>2019-12-13</d><h>18:53</h><w>rschmukler</w>Looks good! Sorry I missed some indents</z><z id="t1576264158" t="ikitommi np, off to weekend. cheers."><y>#</y><d>2019-12-13</d><h>19:09</h><w>ikitommi</w>np, off to weekend. cheers.</z><z id="t1576407444" t="ikitommi About to add :default-decoder and :default-encoder to Transformer options: used if nothing else matches. Makes things like “adding defaults” easy. Comments welcome on that: https://github.com/metosin/malli/issues/143#issuecomment-565798326"><y>#</y><d>2019-12-15</d><h>10:57</h><w>ikitommi</w>About to add <code>:default-decoder</code> and <code>:default-encoder</code> to Transformer options: used if nothing else matches. Makes things like “adding defaults” easy. Comments welcome on that: <a href="https://github.com/metosin/malli/issues/143#issuecomment-565798326" target="_blank">https://github.com/metosin/malli/issues/143#issuecomment-565798326</a></z><z id="t1576441859" t="ikitommi And here’s the PR. Rewrote the malli.core naming to be more corerent, more reuse in chaining &amp; collection schemas now accept nil in transformations. https://github.com/metosin/malli/pull/148"><y>#</y><d>2019-12-15</d><h>20:30</h><w>ikitommi</w>And here’s the PR. Rewrote the <code>malli.core</code> naming to be more corerent, more reuse in chaining &amp; collection schemas now accept <code>nil</code> in transformations. <a href="https://github.com/metosin/malli/pull/148" target="_blank">https://github.com/metosin/malli/pull/148</a></z><z id="t1576517103" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] awesome cleanup on malli.core. Code looks 😍"><y>#</y><d>2019-12-16</d><h>17:25</h><w>rschmukler</w><a>@ikitommi</a> awesome cleanup on malli.core. Code looks <b>😍</b></z><z id="t1576517477" t="rschmukler Just rebased https://github.com/metosin/malli/pull/147"><y>#</y><d>2019-12-16</d><h>17:31</h><w>rschmukler</w>Just rebased <a href="https://github.com/metosin/malli/pull/147" target="_blank">https://github.com/metosin/malli/pull/147</a></z><z id="t1576518173" t="ikitommi actually, the logic to convert from keywords should be somewhere. JSON Parsers keywordize the keys. If keys are defined to be int? , They are seen as :12 etc. The string-&gt;int doesn&apos;t work here"><y>#</y><d>2019-12-16</d><h>17:42</h><w>ikitommi</w>actually, the logic to convert from keywords should be somewhere. JSON Parsers keywordize the keys. If keys are defined to be <code>int?</code>, They are seen as <code>:12</code> etc. The string-&gt;int doesn&apos;t work here</z><z id="t1576518205" t="rschmukler Ah! I can look into re-adding that to the json transformer then"><y>#</y><d>2019-12-16</d><h>17:43</h><w>rschmukler</w>Ah! I can look into re-adding that to the json transformer then</z><z id="t1576518220" t="ikitommi .. and string too"><y>#</y><d>2019-12-16</d><h>17:43</h><w>ikitommi</w>.. and string too</z><z id="t1576518240" t="rschmukler Okay, should I just add it to the string transformer then?"><y>#</y><d>2019-12-16</d><h>17:44</h><w>rschmukler</w>Okay, should I just add it to the string transformer then?</z><z id="t1576518269" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think we should consider dropping the schema-based type checks and instead leave that to the transformer functions. ie. sometimes we check (if (or (map? x) (nil? x)) (transform x)) - especially on decode, it might not be the same shape at all..."><y>#</y><d>2019-12-16</d><h>17:44</h><w>rschmukler</w><a>@ikitommi</a> I think we should consider dropping the schema-based type checks and instead leave that to the transformer functions. ie. sometimes we check <code>(if (or (map? x) (nil? x)) (transform x))</code>  - especially on decode, it might not be the same shape at all...</z><z id="t1576518298" t="rschmukler Consider a JSON body that returns [x y z] and wanting to decode that into a map... or similarly wanting to use malli to decode CSV rows into maps"><y>#</y><d>2019-12-16</d><h>17:44</h><w>rschmukler</w>Consider a JSON body that returns <code>[x y z]</code> and wanting to decode that into a map... or similarly wanting to use malli to decode CSV rows into maps</z><z id="t1576518303" t="rschmukler (decode [:map {:decode/row (fn [row] {:name (nth row 0) :age (nth row 1)})} [:name string?] [:age int?]] [&quot;Bob&quot; &quot;42&quot;] (malli.transform/transformer malli.transform/string-transformer {:name :row}))"><y>#</y><d>2019-12-16</d><h>17:45</h><w>rschmukler</w><pre>(decode [:map {:decode/row (fn [row]
                               {:name (nth row 0)
                                :age (nth row 1)})}
           [:name string?]
           [:age int?]]
          [&quot;Bob&quot; &quot;42&quot;]
          (malli.transform/transformer
           malli.transform/string-transformer
           {:name :row}))</pre></z><z id="t1576518310" t="rschmukler Ideally that&apos;d work"><y>#</y><d>2019-12-16</d><h>17:45</h><w>rschmukler</w>Ideally that&apos;d work</z><z id="t1576518456" t="rschmukler I think it should be the transformer&apos;s responsibility to handle (or not handle) arbitrary data"><y>#</y><d>2019-12-16</d><h>17:47</h><w>rschmukler</w>I think it should be the transformer&apos;s responsibility to handle (or not handle) arbitrary data</z><z id="t1576519459" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] re-added the coercion behavior to string + json transformer. Still marked the commit as breaking since it&apos;ll break people who were relying on the keyword-&gt;string coercion in their transformers... but I updated the message + commit body to tell as much."><y>#</y><d>2019-12-16</d><h>18:04</h><w>rschmukler</w><a>@ikitommi</a> re-added the coercion behavior to string + json transformer. Still marked the commit as breaking since it&apos;ll break people who were relying on the keyword-&gt;string coercion in their transformers... but I updated the message + commit body to tell as much.</z><z id="t1576521853" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] agree on pushing the checks to transformers. Currently, the check is only done before the whole chain. If the first step changes the type, with the current solution, the next will blow anyway."><y>#</y><d>2019-12-16</d><h>18:44</h><w>ikitommi</w><a>@rschmukler</a> agree on pushing the checks to transformers. Currently, the check is only done before the whole chain. If the first step changes the type, with the current solution, the next will blow anyway.</z><z id="t1576521937" t="ikitommi 147 looks good. I was told not to pull in before the EPL2 license is in place, need still few approvals."><y>#</y><d>2019-12-16</d><h>18:45</h><w>ikitommi</w>147 looks good. I was told not to pull in before the EPL2 license is in place, need still few approvals.</z><z id="t1576522052" t="ikitommi I think the current :malli.core/map-key target (and impl) can be removed - same can be done with anonymous transformer with :map target."><y>#</y><d>2019-12-16</d><h>18:47</h><w>ikitommi</w>I think the current <code>:malli.core/map-key</code> target (and impl) can be removed - same can be done with anonymous transformer with <code>:map</code> target.</z><z id="t1576524301" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Alright sounds good. I think I&apos;ve got a elegant solution to the transformer chain checks"><y>#</y><d>2019-12-16</d><h>19:25</h><w>rschmukler</w><a>@ikitommi</a> Alright sounds good. I think I&apos;ve got a elegant solution to the transformer chain checks</z><z id="t1576530165" t="ikitommi https://github.com/metosin/malli/pull/149"><y>#</y><d>2019-12-16</d><h>21:02</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/149" target="_blank">https://github.com/metosin/malli/pull/149</a></z><z id="t1576534929" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] https://github.com/metosin/malli/pull/150 😄"><y>#</y><d>2019-12-16</d><h>22:22</h><w>rschmukler</w><a>@ikitommi</a> <a href="https://github.com/metosin/malli/pull/150" target="_blank">https://github.com/metosin/malli/pull/150</a> <b>😄</b></z><z id="t1576599993" t="rschmukler Any word on when the code freeze will end?"><y>#</y><d>2019-12-17</d><h>16:26</h><w>rschmukler</w>Any word on when the code freeze will end?</z><z id="t1576608103" t="miikka As soon as hear back from everyone. I&apos;ve got 4/6 confirmations so far."><y>#</y><d>2019-12-17</d><h>18:41</h><r>miikka</r>As soon as hear back from everyone. I&apos;ve got 4/6 confirmations so far.</z><z id="t1576616714" t="rschmukler Woo!"><y>#</y><d>2019-12-17</d><h>21:05</h><r>rschmukler</r>Woo!</z><z id="t1576685750" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I haven&apos;t looked at the code at all yet, but how difficult do you think it would be to extend the malli.provider to be pluggable / use transformers? ie. Ideally I could specify a transformer and it&apos;d try transformations in there, and it&apos;d check types that exist in the registry when called"><y>#</y><d>2019-12-18</d><h>16:15</h><w>rschmukler</w><a>@ikitommi</a> I haven&apos;t looked at the code at all yet, but how difficult do you think it would be to extend the <code>malli.provider</code> to be pluggable / use transformers? ie. Ideally I could specify a transformer and it&apos;d try transformations in there, and it&apos;d check types that exist in the registry when called</z><z id="t1576685997" t="rschmukler Looking at the code - doesn&apos;t look like it&apos;d be too hard to make it take a transformer!"><y>#</y><d>2019-12-18</d><h>16:19</h><w>rschmukler</w>Looking at the code - doesn&apos;t look like it&apos;d be too hard to make it take a transformer!</z><z id="t1576686025" t="rschmukler The only thing would be handling the fact that multiple transformers could pass and then having to keep track of which one was most successful"><y>#</y><d>2019-12-18</d><h>16:20</h><w>rschmukler</w>The only thing would be handling the fact that multiple transformers could pass and then having to keep track of which one was most successful</z><z id="t1576686036" t="rschmukler But we are kinda already doing that with the type anyway"><y>#</y><d>2019-12-18</d><h>16:20</h><w>rschmukler</w>But we are kinda already doing that with the <code>type</code> anyway</z><z id="t1576746350" t="miikka Malli is now under EPL-2.0 and the code freeze has ended."><y>#</y><d>2019-12-19</d><h>09:05</h><w>miikka</w>Malli is now under EPL-2.0 and the code freeze has ended.</z><z id="t1576763001" t="pez I should have looked for a malli channel, of course!"><y>#</y><d>2019-12-19</d><h>13:43</h><w>pez</w>I should have looked for a malli channel, of course!</z><z id="t1576769555" t="ikitommi"><y>#</y><d>2019-12-19</d><h>15:32</h><w>ikitommi</w></z><z id="t1576769571" t="ikitommi"><y>#</y><d>2019-12-19</d><h>15:32</h><w>ikitommi</w></z><z id="t1576769592" t="ikitommi welcome [:attrs {:href &quot;/_/_/users/U0ETXRFEW&quot;}] ! looking forward to your validation lib 🙂"><y>#</y><d>2019-12-19</d><h>15:33</h><w>ikitommi</w>welcome <a>@pez</a>! looking forward to your validation lib <b>🙂</b></z><z id="t1576770690" t="pez Awesome. I am using 1 right now. It was 3 I was trying to do but didn&apos;t figure out about the :error/path property. Will try that now."><y>#</y><d>2019-12-19</d><h>15:51</h><w>pez</w>Awesome. I am using 1 right now. It was 3 I was trying to do but didn&apos;t figure out about the <code>:error/path</code> property. Will try that now.</z><z id="t1576770810" t="pez Don&apos;t hold your breath about that lib. 😃 But who knows, we do have many kinds of form scenarios in our app so maybe I get reason to really figure this out."><y>#</y><d>2019-12-19</d><h>15:53</h><w>pez</w>Don&apos;t hold your breath about that lib. <b>😃</b> But who knows, we do have many kinds of form scenarios in our app so maybe I get reason to really figure this out.</z><z id="t1576777328" t="rschmukler https://github.com/weavejester/integrant/pull/60 - fingers crossed 🙂"><y>#</y><d>2019-12-19</d><h>17:42</h><w>rschmukler</w><a href="https://github.com/weavejester/integrant/pull/60" target="_blank">https://github.com/weavejester/integrant/pull/60</a> - fingers crossed <b>🙂</b></z><z id="t1576824940" t="ikitommi [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] malli.provider, transformer, so it could if there is a use case for it. Some kind of extension mechanism would be good anyway, adding inferring to :tuple and :multi currently require a lot of internal refactoring. Not easy to add inferrers to own schemas."><y>#</y><d>2019-12-20</d><h>06:55</h><w>ikitommi</w><a>@rschmukler</a> malli.provider, transformer, so it could if there is a use case for it. Some kind of extension mechanism would be good anyway, adding inferring to <code>:tuple</code> and <code>:multi</code> currently require a lot of internal refactoring. Not easy to add inferrers to own schemas.</z><z id="t1576825042" t="ikitommi as it&apos;s not complete yet, would be good to add the missing inferrers and options to controls those and see what kind of architecture evolves out of those."><y>#</y><d>2019-12-20</d><h>06:57</h><w>ikitommi</w>as it&apos;s not complete yet, would be good to add the missing inferrers and options to controls those and see what kind of architecture evolves out of those.</z><z id="t1576825361" t="ikitommi maybe options like {:infer {:multi {:stats ...,. :schema ..., :opts {:dispatch #{:type &apos;first}, :min 2, :propability 0.90}}} ,"><y>#</y><d>2019-12-20</d><h>07:02</h><w>ikitommi</w>maybe options like <code>{:infer {:multi {:stats ...,. :schema ..., :opts {:dispatch #{:type &apos;first}, :min 2, :propability 0.90}}}</code>,</z><z id="t1576825467" t="ikitommi e.g. callback to participate in extracting stats out of samples, and converting those into schemas + opts for what kind of multis to look and how many samples needed"><y>#</y><d>2019-12-20</d><h>07:04</h><w>ikitommi</w>e.g. callback to participate in extracting stats out of samples, and converting those into schemas + opts for what kind of multis to look and how many samples needed</z><z id="t1576825589" t="ikitommi might be better to start with just options and hard-code the impl, and try to extract the callback mechanism later."><y>#</y><d>2019-12-20</d><h>07:06</h><w>ikitommi</w>might be better to start with just options and hard-code the impl, and try to extract the callback mechanism later.</z><z id="t1576859229" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] the other thing I was thinking about is the ability to code options. ie. imagine a LocalDateTime parser that has an property of :date/format &quot;MM/dd/yyyy&quot; - ideally it&apos;d be good to specify &quot;try these formats when you try to parse things as a date&quot; etc"><y>#</y><d>2019-12-20</d><h>16:27</h><w>rschmukler</w><a>@ikitommi</a> the other thing I was thinking about is the ability to code options. ie. imagine a LocalDateTime parser that has an property of <code>:date/format &quot;MM/dd/yyyy&quot;</code> - ideally it&apos;d be good to specify &quot;try these formats when you try to parse things as a date&quot; etc</z></g><g id="s2"><z id="t1576859247" t="rschmukler Still thinking about how it could look"><y>#</y><d>2019-12-20</d><h>16:27</h><w>rschmukler</w>Still thinking about how it could look</z><z id="t1576866549" t="ikitommi idea: If the inferrer is good, there could be a tool that records all args and return values for functions and infers defn-schemas out of those. I think [:attrs {:href &quot;/_/_/users/U055XFK8V&quot;}] did something similar with spec (using core.typed)"><y>#</y><d>2019-12-20</d><h>18:29</h><w>ikitommi</w>idea: If the inferrer is good, there could be a tool that records all args and return values for functions and infers defn-schemas out of those. I think <a>@ambrosebs</a> did something similar with spec (using core.typed)</z><z id="t1576867101" t="pez Lovely idea!"><y>#</y><d>2019-12-20</d><h>18:38</h><w>pez</w>Lovely idea!</z><z id="t1576885371" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] that&apos;s awesome. this information can then also be used to generate clj-kondo type annotations"><y>#</y><d>2019-12-20</d><h>23:42</h><w>borkdude</w><a>@ikitommi</a> that&apos;s awesome. this information can then also be used to generate clj-kondo type annotations</z><z id="t1576937560" t="ikitommi 2 months to ClojureD, would be awesome to have some clj-kondo integration for that."><y>#</y><d>2019-12-21</d><h>14:12</h><w>ikitommi</w>2 months to ClojureD, would be awesome to have some clj-kondo integration for that.</z><z id="t1576937586" t="ikitommi Also, to finalize this…"><y>#</y><d>2019-12-21</d><h>14:13</h><w>ikitommi</w>Also, to finalize this…</z><z id="t1576937852" t="ikitommi don’t know if it’s problem in fipp or in my cursive setup, but some some broken ansi escape codes threre."><y>#</y><d>2019-12-21</d><h>14:17</h><w>ikitommi</w>don’t know if it’s problem in fipp or in my cursive setup, but some some broken ansi escape codes threre.</z><z id="t1576944351" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] This is the format the clj-kondo currently understands: https://github.com/borkdude/clj-kondo/blob/master/doc/types.md Any tool that can generate that format from whatever data available can integrate with clj-kondo"><y>#</y><d>2019-12-21</d><h>16:05</h><w>borkdude</w><a>@ikitommi</a> This is the format the clj-kondo currently understands: <a href="https://github.com/borkdude/clj-kondo/blob/master/doc/types.md" target="_blank">https://github.com/borkdude/clj-kondo/blob/master/doc/types.md</a>
Any tool that can generate that format from whatever data available can integrate with clj-kondo</z><z id="t1576955251" t="ikitommi well, that’s looks simple."><y>#</y><d>2019-12-21</d><h>19:07</h><w>ikitommi</w>well, that’s looks simple.</z><z id="t1577463164" t="ikitommi did a quick cleanup, without too much thinking, so comments welcome, https://github.com/metosin/malli/pull/152"><y>#</y><d>2019-12-27</d><h>16:12</h><w>ikitommi</w>did a quick cleanup, without too much thinking, so comments welcome, <a href="https://github.com/metosin/malli/pull/152" target="_blank">https://github.com/metosin/malli/pull/152</a></z><z id="t1577525910" t="ikitommi reitit coercion with malli 90% done"><y>#</y><d>2019-12-28</d><h>09:38</h><w>ikitommi</w>reitit coercion with malli 90% done</z><z id="t1577557734" t="rschmukler 🔥 🔥 🔥"><y>#</y><d>2019-12-28</d><h>18:28</h><w>rschmukler</w><b>🔥</b><b>🔥</b><b>🔥</b></z><z id="t1577677299" t="Johan I&apos;m trying to implement the ideas developed on this talk with Malli. Anyone else is splitting attributes schemas and selections ? source: https://www.youtube.com/watch?v=YR5WdGrpoug"><y>#</y><d>2020-12-30</d><h>03:41</h><w>Johan</w>I&apos;m trying to implement the ideas developed on this talk with Malli.
Anyone else is splitting attributes schemas and selections ?

source: <a href="https://www.youtube.com/watch?v=YR5WdGrpoug" target="_blank">https://www.youtube.com/watch?v=YR5WdGrpoug</a></z><z id="t1577696084" t="ikitommi [:attrs {:href &quot;/_/_/users/UFSMGQ690&quot;}] some discussion here: https://github.com/metosin/malli/issues/95"><y>#</y><d>2020-12-30</d><h>08:54</h><w>ikitommi</w><a>@johan178</a> some discussion here: <a href="https://github.com/metosin/malli/issues/95" target="_blank">https://github.com/metosin/malli/issues/95</a></z><z id="t1577696686" t="ikitommi Also: https://github.com/metosin/malli/issues/14"><y>#</y><d>2020-12-30</d><h>09:04</h><w>ikitommi</w>Also: <a href="https://github.com/metosin/malli/issues/14" target="_blank">https://github.com/metosin/malli/issues/14</a></z><z id="t1577696909" t="ikitommi that said, it would be trivial to write a custom select schema, allowing serializable selects: [:select [:map [:x int?] [:y int?]] [:x]]"><y>#</y><d>2020-12-30</d><h>09:08</h><w>ikitommi</w>that said, it would be trivial to write a custom <code>select</code> schema, allowing serializable selects:

<pre>[:select 
 [:map [:x int?] [:y int?]]
 [:x]]</pre></z><z id="t1577789869" t="borkdude Does malli have something like s/conform for s/cat?"><y>#</y><d>2020-12-31</d><h>10:57</h><w>borkdude</w>Does malli have something like s/conform for s/cat?</z><z id="t1577790695" t="ikitommi not yet, but it will come. Can&apos;t recall if there was an issue of conform yet, or just discussed"><y>#</y><d>2020-12-31</d><h>11:11</h><w>ikitommi</w>not yet, but it will come. Can&apos;t recall if there was an issue of <code>conform</code> yet, or just discussed</z><z id="t1577796271" t="ikitommi 12 added lines later: (explain [:map {:closed true} [:xy [:map {:closed true} [:x int?] [:y int?]]]] {:xy {:x 1, :y 2, :EVIL &quot;LYN&quot;} :DARK &quot;ORKO&quot;}) ;{:schema [:map {:closed true} [:xy [:map {:closed true} [:x int?] [:y int?]]]], ; :value {:xy {:x 1, :y 2, :EVIL &quot;LYN&quot;}, :DARK &quot;ORKO&quot;}, ; :errors (#Error{:path [2 1], ; :in [:xy :EVIL], ; :schema [:map {:closed true} [:x int?] [:y int?]], ; :type :malli.core/extra-key} ; #Error{:path [], ; :in [:DARK], ; :schema [:map {:closed true} [:xy [:map {:closed true} [:x int?] [:y int?]]]], ; :type :malli.core/extra-key})}"><y>#</y><d>2020-12-31</d><h>12:44</h><w>ikitommi</w>12 added lines later:
<pre>(explain
  [:map {:closed true}
   [:xy
    [:map {:closed true}
     [:x int?]
     [:y int?]]]]
  {:xy {:x 1, :y 2, :EVIL &quot;LYN&quot;}
   :DARK &quot;ORKO&quot;})
;{:schema [:map {:closed true} [:xy [:map {:closed true} [:x int?] [:y int?]]]],
; :value {:xy {:x 1, :y 2, :EVIL &quot;LYN&quot;}, :DARK &quot;ORKO&quot;},
; :errors (#Error{:path [2 1],
;                 :in [:xy :EVIL],
;                 :schema [:map {:closed true} [:x int?] [:y int?]],
;                 :type :malli.core/extra-key}
;           #Error{:path [],
;                  :in [:DARK],
;                  :schema [:map {:closed true} [:xy [:map {:closed true} [:x int?] [:y int?]]]],
;                  :type :malli.core/extra-key})}</pre></z><z id="t1577796343" t="ikitommi that should contain all the needed info to get spell-spec grade error messages."><y>#</y><d>2020-12-31</d><h>12:45</h><w>ikitommi</w>that should contain all the needed info to get spell-spec grade error messages.</z><z id="t1577796408" t="ikitommi e.g. :in points to the actual key and :type can be used to format suggestions on misspelled keys etc."><y>#</y><d>2020-12-31</d><h>12:46</h><w>ikitommi</w>e.g. <code>:in</code> points to the actual key and <code>:type</code> can be used to format suggestions on misspelled keys etc.</z><z id="t1577797894" t="ikitommi https://github.com/metosin/malli/pull/156"><y>#</y><d>2020-12-31</d><h>13:11</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/156" target="_blank">https://github.com/metosin/malli/pull/156</a></z><z id="t1577798881" t="ikitommi also: (-&gt; [:map {:closed true} [:x int?]] (m/explain {:x 1, :extra &quot;key&quot;}) (me/humanize)) ; =&gt; {:extra [&quot;disallowed key&quot;]}"><y>#</y><d>2020-12-31</d><h>13:28</h><w>ikitommi</w>also:
<pre>(-&gt; [:map {:closed true} [:x int?]]
    (m/explain {:x 1, :extra &quot;key&quot;})
    (me/humanize))
; =&gt; {:extra [&quot;disallowed key&quot;]}</pre></z><z id="t1577955158" t="ikitommi Programming with Schemas: https://github.com/metosin/malli/pull/158"><y>#</y><d>2020-01-02</d><h>08:52</h><w>ikitommi</w>Programming with Schemas: <a href="https://github.com/metosin/malli/pull/158" target="_blank">https://github.com/metosin/malli/pull/158</a></z><z id="t1577955327" t="ikitommi Quite happy how simple Schema transformations are with the current design, recursively closing all Schemas: (defn closed-schema &quot;Closes all :map Schemas recursively.&quot; [schema] (m/accept schema (m/schema-visitor (fn [schema] (if (= :map (m/name schema)) (update-properties schema assoc :closed true) schema)))))"><y>#</y><d>2020-01-02</d><h>08:55</h><w>ikitommi</w>Quite happy how simple Schema transformations are with the current design, recursively closing all Schemas:
<pre>(defn closed-schema
  &quot;Closes all :map Schemas recursively.&quot;
  [schema]
  (m/accept
    schema
    (m/schema-visitor
      (fn [schema]
        (if (= :map (m/name schema))
          (update-properties schema assoc :closed true)
          schema)))))</pre></z><z id="t1578057174" t="ikitommi comments welcome on handling extra keys with maps: https://github.com/metosin/malli/issues/43"><y>#</y><d>2020-01-03</d><h>13:12</h><w>ikitommi</w>comments welcome on handling extra keys with maps: <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a></z><z id="t1578238115" t="roklenarcic there;’s a lot of branches in repo that have been merged and not deleted"><y>#</y><d>2020-01-05</d><h>15:28</h><w>roklenarcic</w>there;’s a lot of branches  in repo that have been merged and  not deleted</z><z id="t1578258462" t="ikitommi sure there is, I guess there is no automation removing those after merge/rebase."><y>#</y><d>2020-01-05</d><h>21:07</h><w>ikitommi</w>sure there is, I guess there is no automation removing those after merge/rebase.</z><z id="t1578309616" t="eskos https://help.github.com/en/github/administering-a-repository/managing-the-automatic-deletion-of-branches"><y>#</y><d>2020-01-06</d><h>11:20</h><r>eskos</r><a href="https://help.github.com/en/github/administering-a-repository/managing-the-automatic-deletion-of-branches" target="_blank">https://help.github.com/en/github/administering-a-repository/managing-the-automatic-deletion-of-branches</a></z><z id="t1578309642" t="eskos You do need to delete the old merged branches manually though; Google will find you some bash scripts for that."><y>#</y><d>2020-01-06</d><h>11:20</h><r>eskos</r>You do need to delete the old merged branches manually though; Google will find you some bash scripts for that.</z><z id="t1578258558" t="ikitommi would like to break thing a bit: mt/strip-extra-keys-transformer should be a function of options =&gt; Transformer , not a Transformer . Question: should it remove extra keys by default: a) from all maps (open or closed) b) only from closed maps"><y>#</y><d>2020-01-05</d><h>21:09</h><w>ikitommi</w>would like to break thing a bit: <code>mt/strip-extra-keys-transformer</code> should be a function of <code>options =&gt; Transformer</code> , not a <code>Transformer</code>. Question: should it remove extra keys by default:
a) from all maps (open or closed)
b) only from closed maps</z><z id="t1578258581" t="ikitommi will add a option to control this, but leaning on a) as the default."><y>#</y><d>2020-01-05</d><h>21:09</h><w>ikitommi</w>will add a option to control this, but leaning on a) as the default.</z><z id="t1578265008" t="roklenarcic hm… how do I make a transformer that uses a schema property as param to transform function"><y>#</y><d>2020-01-05</d><h>22:56</h><w>roklenarcic</w>hm… how do I make a transformer that uses a schema property as param to transform function</z><z id="t1578265040" t="roklenarcic you have this showcased in the :compile option example"><y>#</y><d>2020-01-05</d><h>22:57</h><w>roklenarcic</w>you have this showcased in the <code>:compile</code> option example</z><z id="t1578265130" t="roklenarcic but I’d like to look up something like that ` :math/multiplier in the default transformer function"><y>#</y><d>2020-01-05</d><h>22:58</h><w>roklenarcic</w>but I’d like to look up something like that `
<pre>:math/multiplier</pre>
in the default transformer function</z><z id="t1578265183" t="roklenarcic e.g. I have datetime schema and it’s transformer would like to check if schema had :format property"><y>#</y><d>2020-01-05</d><h>22:59</h><w>roklenarcic</w>e.g. I have datetime schema and  it’s transformer would like to check if schema had  <code>:format</code> property</z><z id="t1578265204" t="roklenarcic the :compile thing requires one to add it to every use-site"><y>#</y><d>2020-01-05</d><h>23:00</h><w>roklenarcic</w>the  <code>:compile</code> thing requires  one to add it to every use-site</z><z id="t1578265334" t="roklenarcic oh, I see how it’s done elsewhere, ignore that"><y>#</y><d>2020-01-05</d><h>23:02</h><w>roklenarcic</w>oh, I see how it’s done elsewhere, ignore that</z><z id="t1578309032" t="ikitommi yeah, the default-value-transformer uses schema properties and mounts for all schemas."><y>#</y><d>2020-01-06</d><h>11:10</h><w>ikitommi</w>yeah, the <code>default-value-transformer</code> uses schema properties and mounts for all schemas.</z><z id="t1578335195" t="ikitommi Breaking transformer api, hopefully making it better: https://github.com/metosin/malli/pull/162"><y>#</y><d>2020-01-06</d><h>18:26</h><w>ikitommi</w>Breaking transformer api, hopefully making it better: <a href="https://github.com/metosin/malli/pull/162" target="_blank">https://github.com/metosin/malli/pull/162</a></z><z id="t1578335206" t="ikitommi comments welcome on that"><y>#</y><d>2020-01-06</d><h>18:26</h><w>ikitommi</w>comments welcome on that</z><z id="t1578335374" t="ikitommi The goal is to have a unified api for creating Transformers: all are created via a function, instead of mixing functions and actual Transformer instances. So, instead of: (mt/transformer mt/string-transformer mt/strip-extra-keys-transformer (mt/key-transformer {:decode #(-&gt; % name (str &quot;_key&quot;) keyword) :encode #(-&gt; % name (str &quot;_key&quot;))})) we should do: (mt/transformer (mt/string-transformer) (mt/strip-extra-keys-transformer) (mt/key-transformer {:decode #(-&gt; % name (str &quot;_key&quot;) keyword) :encode #(-&gt; % name (str &quot;_key&quot;))})) … both work thou, thanks to auto-coercion of functions =&gt; Transformers."><y>#</y><d>2020-01-06</d><h>18:29</h><w>ikitommi</w>The goal is to have a unified api for creating Transformers: all are created via a function, instead of mixing functions and actual <code>Transformer</code> instances. So, instead of:
<pre>(mt/transformer
  mt/string-transformer
  mt/strip-extra-keys-transformer
  (mt/key-transformer
    {:decode #(-&gt; % name (str &quot;_key&quot;) keyword)
     :encode #(-&gt; % name (str &quot;_key&quot;))}))</pre>
we should do:
<pre>(mt/transformer
  (mt/string-transformer)
  (mt/strip-extra-keys-transformer)
  (mt/key-transformer
    {:decode #(-&gt; % name (str &quot;_key&quot;) keyword)
     :encode #(-&gt; % name (str &quot;_key&quot;))}))</pre>
… both work thou, thanks to auto-coercion of functions =&gt; Transformers.</z><z id="t1578335547" t="ikitommi in other libs (schema, spec-tools) the json-transformer|matcher are just values, so people most likely try that instead of call the function. Not 100% happy with having the auto-coercion, but here thought the developer experience is more important than having an one explicit (non-familiar?) syntax."><y>#</y><d>2020-01-06</d><h>18:32</h><w>ikitommi</w>in other libs (schema, spec-tools) the <code>json-transformer|matcher</code> are just values, so people most likely try that instead of call the function. Not 100% happy with having the auto-coercion, but here thought the developer experience is more important than having an one explicit (non-familiar?) syntax.</z><z id="t1578485157" t="ikitommi merged into master"><y>#</y><d>2020-01-08</d><h>12:05</h><w>ikitommi</w>merged into master</z><z id="t1578571727" t="ikitommi hei, someone suggested that malli (and reitit) should be sponsored by Clojurists Together, any insight what should be developed? Thanks anyway 🙇 https://www.clojuriststogether.org/news/q1-2020-survey-results/"><y>#</y><d>2020-01-09</d><h>12:08</h><w>ikitommi</w>hei, someone suggested that malli (and reitit) should be sponsored by Clojurists Together, any insight what should be developed? Thanks anyway <b>🙇</b> <a href="https://www.clojuriststogether.org/news/q1-2020-survey-results/" target="_blank">https://www.clojuriststogether.org/news/q1-2020-survey-results/</a></z><z id="t1578590507" t="roklenarcic are you sure -composite-schema function -transformer works correctly? other schemas with children use -chain helper to make sure that :leave transformers are combined in reverse order than :enter , but this one does not"><y>#</y><d>2020-01-09</d><h>17:21</h><w>roklenarcic</w>are you sure <code>-composite-schema</code> function <code>-transformer</code> works correctly? other schemas with children use <code>-chain</code> helper to make sure that <code>:leave</code> transformers are combined in reverse order than <code>:enter</code> , but this one does not</z><z id="t1578591316" t="ikitommi bug? PR welcome."><y>#</y><d>2020-01-09</d><h>17:35</h><w>ikitommi</w>bug? PR welcome.</z><z id="t1578733827" t="ikitommi Upcoming: (-&gt; (m/explain [:map {:closed true} [:orders boolean?] [:deliver boolean?]] {:orders true :deliverz true}) (me/with-suggestions) (me/humanize)) ;{:deliver [&quot;missing required key&quot;] ; :deliverz [&quot;likely misspelling of :deliver&quot;]}"><y>#</y><d>2020-01-11</d><h>09:10</h><w>ikitommi</w>Upcoming:
<pre>(-&gt; (m/explain
      [:map {:closed true}
       [:orders boolean?]
       [:deliver boolean?]]
      {:orders true
       :deliverz true})
    (me/with-suggestions)
    (me/humanize))
;{:deliver [&quot;missing required key&quot;]
; :deliverz [&quot;likely misspelling of :deliver&quot;]}</pre></z><z id="t1578775612" t="roklenarcic Added a couple of schemas I’m using to a public repo https://github.com/RokLenarcic/malli-schemas"><y>#</y><d>2020-01-11</d><h>20:46</h><w>roklenarcic</w>Added a couple of schemas I’m using to a public repo <a href="https://github.com/RokLenarcic/malli-schemas" target="_blank">https://github.com/RokLenarcic/malli-schemas</a></z><z id="t1578827322" t="ikitommi Nice, date-support is on malli backlog, need to figure out a way to make it work with cljs too."><y>#</y><d>2020-01-12</d><h>11:08</h><w>ikitommi</w>Nice, date-support is on malli backlog, need to figure out a way to make it work with cljs too.</z><z id="t1578842033" t="roklenarcic Generally, transform operations do not validate that input passes the validator first, which is good for performance, but when you have an operation like :or how do you know which branch of OR to use for transformation? Currently you try every branch as transformation and return the first result that changes the value."><y>#</y><d>2020-01-12</d><h>15:13</h><w>roklenarcic</w>Generally, transform operations do not validate that input passes the validator first, which is good for performance, but when you have an operation like <code>:or</code> how do you know which branch of OR to use for transformation? Currently you try every branch as transformation and return the first result that changes the value.</z><z id="t1578842038" t="roklenarcic however this leads to this:"><y>#</y><d>2020-01-12</d><h>15:13</h><w>roklenarcic</w>however this leads to this:</z><z id="t1578842043" t="roklenarcic (m/encode [:or [string? {:encode/string #(.toUpperCase %)}] [int? {:encode/string str}]] 1 mt/string-transformer)"><y>#</y><d>2020-01-12</d><h>15:14</h><w>roklenarcic</w><pre>(m/encode [:or
           [string? {:encode/string #(.toUpperCase %)}]
           [int? {:encode/string str}]]
          1
          mt/string-transformer)</pre></z><z id="t1578842055" t="roklenarcic Execution error (IllegalArgumentException) at com.github.roklenarcic.malli-inline/eval17000$fn (form-init15839185010501867114.clj:2). "><y>#</y><d>2020-01-12</d><h>15:14</h><w>roklenarcic</w><pre>Execution error (IllegalArgumentException) at com.github.roklenarcic.malli-inline/eval17000$fn (form-init15839185010501867114.clj:2).</pre>
</z><z id="t1578842069" t="roklenarcic No matching field found: toUpperCase for class java.lang.Long"><y>#</y><d>2020-01-12</d><h>15:14</h><w>roklenarcic</w><pre>No matching field found: toUpperCase for class java.lang.Long</pre></z><z id="t1578842176" t="roklenarcic none of the built-in transformers will validate input and return the value itself if not the right type, which would make :or work correctly in this regard"><y>#</y><d>2020-01-12</d><h>15:16</h><w>roklenarcic</w>none of the built-in transformers will validate input and return the value itself if not the right type, which would make :or work correctly in this regard</z><z id="t1578842892" t="roklenarcic The only realistic way to fix this would be to have :or do validate for each branch until it finds one that validates and then run that transform. This would perform as expected, I can prepare a PR."><y>#</y><d>2020-01-12</d><h>15:28</h><w>roklenarcic</w>The only realistic way to fix this would be to have <code>:or</code> do validate for each branch until it finds one that validates and then run that transform. This would perform as expected, I can prepare a PR.</z><z id="t1578854937" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] sounds right to me to select branch based on validate"><y>#</y><d>2020-01-12</d><h>18:48</h><w>ikitommi</w><a>@roklenarcic</a> sounds right to me to select branch based on validate</z><z id="t1578854961" t="roklenarcic another possible bug"><y>#</y><d>2020-01-12</d><h>18:49</h><w>roklenarcic</w>another possible bug</z><z id="t1578854997" t="roklenarcic in about 5 different explainer functions in malli.core you have distance (if (seq properties) 2 1)"><y>#</y><d>2020-01-12</d><h>18:49</h><w>roklenarcic</w>in about 5 different <code>explainer</code> functions in malli.core you have <code>distance (if (seq properties) 2 1)</code></z><z id="t1578855016" t="roklenarcic if properties is missing then distance should be 1"><y>#</y><d>2020-01-12</d><h>18:50</h><w>roklenarcic</w>if properties is missing then distance should be 1</z><z id="t1578855040" t="roklenarcic the problem is that if someone puts {} as properties, then (seq properties) is false"><y>#</y><d>2020-01-12</d><h>18:50</h><w>roklenarcic</w>the problem is that if someone puts <code>{}</code> as properties, then <code>(seq properties)</code> is false</z><z id="t1578855063" t="roklenarcic and it will say distance 1, when the form has [symbol {} children]"><y>#</y><d>2020-01-12</d><h>18:51</h><w>roklenarcic</w>and it will say distance 1, when the form has <code>[symbol {} children]</code></z><z id="t1578855063" t="ikitommi true"><y>#</y><d>2020-01-12</d><h>18:51</h><w>ikitommi</w>true</z><z id="t1578855090" t="roklenarcic so the path is possibly wrong… I don’t know what the semantics of path is exactly"><y>#</y><d>2020-01-12</d><h>18:51</h><w>roklenarcic</w>so the path is possibly wrong… I don’t know what the semantics of path is exactly</z><z id="t1578855135" t="ikitommi get-in to m/form of the schema with the error :in should point to schema"><y>#</y><d>2020-01-12</d><h>18:52</h><w>ikitommi</w>get-in to <code>m/form</code> of the schema with the error <code>:in</code> should point to schema</z><z id="t1578855166" t="ikitommi needed in pretty error reporting , which is wip."><y>#</y><d>2020-01-12</d><h>18:52</h><w>ikitommi</w>needed in pretty error reporting , which is wip.</z><z id="t1578855168" t="roklenarcic but you see what I’m getting at… (seq properties) is nil for nil and {} , not good for counting elements in form"><y>#</y><d>2020-01-12</d><h>18:52</h><w>roklenarcic</w>but you see what I’m getting at… <code>(seq properties)</code> is nil for <code>nil</code> and <code>{}</code>, not good for counting elements in form</z><z id="t1578855202" t="ikitommi yes, that&apos;s currently wrong but should be easy to fix"><y>#</y><d>2020-01-12</d><h>18:53</h><w>ikitommi</w>yes, that&apos;s currently wrong but should be easy to fix</z><z id="t1578855214" t="ikitommi Good thing that it&apos;s pre-alpha ;)"><y>#</y><d>2020-01-12</d><h>18:53</h><w>ikitommi</w>Good thing that it&apos;s pre-alpha ;)</z><z id="t1578855260" t="ikitommi Will need malli at a project starting tomorrow, so good reason to push out first alpha too"><y>#</y><d>2020-01-12</d><h>18:54</h><w>ikitommi</w>Will need malli at a project starting tomorrow, so good reason to push out first alpha too</z><z id="t1578860363" t="ikitommi should the schemas allow nil children? e.g. [:and int? nil pos-int?] . Currently :map allows, composite schemas don’t."><y>#</y><d>2020-01-12</d><h>20:19</h><w>ikitommi</w>should the schemas allow <code>nil</code> children? e.g. <code>[:and int? nil pos-int?]</code>. Currently <code>:map</code> allows, composite schemas don’t.</z><z id="t1578860411" t="ikitommi e.g. [:map [:x int?] nil [:y pos-int?]] works, [:and int? nil pos-int?] doesn’t."><y>#</y><d>2020-01-12</d><h>20:20</h><w>ikitommi</w>e.g. <code>[:map [:x int?] nil [:y pos-int?]]</code> works, <code>[:and int? nil pos-int?]</code> doesn’t.</z><z id="t1578860426" t="ikitommi all core schemas should behave identically."><y>#</y><d>2020-01-12</d><h>20:20</h><w>ikitommi</w>all core schemas should behave identically.</z><z id="t1578860553" t="ikitommi also, currently: (m/form [:and {} int?]) ; =&gt; [:and int?] (m/properties [:and {} int?]) ; =&gt; {}"><y>#</y><d>2020-01-12</d><h>20:22</h><w>ikitommi</w>also, currently:
<pre>(m/form [:and {} int?])
; =&gt; [:and int?]

(m/properties [:and {} int?])
; =&gt; {}</pre></z><z id="t1578860602" t="ikitommi should empty properties be removed (set to nil ) already when schema is created from AST?"><y>#</y><d>2020-01-12</d><h>20:23</h><w>ikitommi</w>should empty properties be removed (set to <code>nil</code>) already when schema is created from AST?</z><z id="t1578860624" t="ikitommi after that: (m/form [:and {} int?]) ; =&gt; [:and int?] (m/properties [:and {} int?]) ; =&gt; nil"><y>#</y><d>2020-01-12</d><h>20:23</h><w>ikitommi</w>after that:
<pre>(m/form [:and {} int?])
; =&gt; [:and int?]
(m/properties [:and {} int?])
; =&gt; nil</pre></z><z id="t1578860908" t="ikitommi my suggestion: • allow nil child schemas in all core schemas: easy to create programmatically (e.g. [:map [:x int?] (if require-y [:y int?])] ) • treat empty properties as nil , allows (`[:map (if close-maps {:closed true}) [:x int?]]`)"><y>#</y><d>2020-01-12</d><h>20:28</h><w>ikitommi</w>my suggestion:
• allow <code>nil</code> child schemas in all core schemas: easy to create programmatically (e.g. <code>[:map [:x int?] (if require-y [:y int?])]</code>)
• treat empty properties as <code>nil</code>, allows (`[:map (if close-maps {:closed true}) [:x int?]]`)</z><z id="t1578861503" t="roklenarcic sure, sounds sensible"><y>#</y><d>2020-01-12</d><h>20:38</h><w>roklenarcic</w>sure, sounds sensible</z><z id="t1578866435" t="roklenarcic can explainer fn return null? I thought it must return acc"><y>#</y><d>2020-01-12</d><h>22:00</h><w>roklenarcic</w>can explainer fn return null? I thought it must return <code>acc</code></z><z id="t1578870550" t="pithyless I agree all core schemas should behave identically; I would suggest not ignoring nil children, which gives more obvious semantics in cases like this: [:and int? nil pos-int?] (this would always be false, instead of implementing a special-case for nil that behaves differently than regular &quot;falsey&quot; semantics in Clojure). In the map example, I find it more intuitive to use malli.util/merge semantics to describe programmmatic optionality: (malli.util/merge [:map [:x int?]] (if require-y [:map [:y int?]]))"><y>#</y><d>2020-01-12</d><h>23:09</h><w>pithyless</w>I agree all core schemas should behave identically; I would suggest not ignoring nil children, which gives more obvious semantics in cases like this: <code>[:and int? nil pos-int?]</code> (this would always be false, instead of implementing a special-case for nil that behaves differently than regular &quot;falsey&quot; semantics in Clojure). In the map example, I find it more intuitive to use <code>malli.util/merge</code> semantics to describe programmmatic optionality: <code>(malli.util/merge [:map [:x int?]] (if require-y [:map [:y int?]]))</code></z><z id="t1578894331" t="ikitommi fixed so that nil is allowed as properties and empty properties are treated as nil (and stripped from m/form )."><y>#</y><d>2020-01-13</d><h>05:45</h><w>ikitommi</w>fixed so that <code>nil</code> is allowed as properties and empty properties are treated as <code>nil</code> (and stripped from <code>m/form</code>).</z><z id="t1578894691" t="ikitommi https://github.com/metosin/malli/pull/164"><y>#</y><d>2020-01-13</d><h>05:51</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/164" target="_blank">https://github.com/metosin/malli/pull/164</a></z><z id="t1578894389" t="ikitommi I don’t think nil should be treated as “always fail” in composite schemas. Currently, it will blow as nil is not a valid schema."><y>#</y><d>2020-01-13</d><h>05:46</h><w>ikitommi</w>I don’t think <code>nil</code> should be treated as “always fail” in composite schemas. Currently, it will blow as  <code>nil</code> is not a valid schema.</z><z id="t1578894430" t="ikitommi also, can’t strip all nil s from children, as things like :enum might have actual valid value of nil ."><y>#</y><d>2020-01-13</d><h>05:47</h><w>ikitommi</w>also, can’t strip all <code>nil</code>s from children, as things like <code>:enum</code> might have actual valid value of <code>nil</code>.</z><z id="t1578894554" t="ikitommi So, options being: 1. allow (and strip) nil in map &amp; composite schemas, for convenience sake 2. blow up in case of nil as child schema 3. map nil to “always fail”"><y>#</y><d>2020-01-13</d><h>05:49</h><w>ikitommi</w>So, options being:
1. allow (and strip) <code>nil</code> in map &amp; composite schemas, for convenience sake
2. blow up in case of <code>nil</code> as child schema
3. map <code>nil</code> to “always fail”</z><z id="t1578894651" t="ikitommi the malli.util merge is not that fun for deeply nested maps: (malli.util/merge [:map [:x [:map [:y [:map [:z int?]] (if require-z2 [:map [:x [:map [:y [:map [:z2 int?]]))"><y>#</y><d>2020-01-13</d><h>05:50</h><w>ikitommi</w>the <code>malli.util</code> merge is not that fun for deeply nested maps:
<pre>(malli.util/merge 
  [:map [:x [:map [:y [:map [:z int?]] 
  (if require-z2 [:map [:x [:map [:y [:map [:z2 int?]]))</pre></z><z id="t1578905677" t="roklenarcic each into-schema should probably decide for itself what to do with nil values"><y>#</y><d>2020-01-13</d><h>08:54</h><w>roklenarcic</w>each into-schema should probably decide for itself what to do with nil values</z><z id="t1579013621" t="ikitommi merged the spell-checking, https://twitter.com/ikitommi/status/1217096807316119553"><y>#</y><d>2020-01-14</d><h>14:53</h><w>ikitommi</w>merged the spell-checking, <a href="https://twitter.com/ikitommi/status/1217096807316119553" target="_blank">https://twitter.com/ikitommi/status/1217096807316119553</a></z><z id="t1579118803" t="rschmukler Hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] just a heads up that https://github.com/teknql/pablo exists for when / if you go to break malli into sperate libraries. It&apos;s still early days, but it&apos;s made to ease the burden of managing mono-repo-like libraries. Documentation is sparse at the moment, but I don&apos;t anticipate that you&apos;ll be slicing malli up too soon either"><y>#</y><d>2020-01-15</d><h>20:06</h><w>rschmukler</w>Hey <a>@ikitommi</a> just a heads up that <a href="https://github.com/teknql/pablo" target="_blank">https://github.com/teknql/pablo</a> exists for when / if you go to break malli into sperate libraries. It&apos;s still early days, but it&apos;s made to ease the burden of managing mono-repo-like libraries. Documentation is sparse at the moment, but I don&apos;t anticipate that you&apos;ll be slicing malli up too soon either</z><z id="t1579120594" t="ikitommi Oh, that looks great! How do you setup the artifact version when pushing to clojars?"><y>#</y><d>2020-01-15</d><h>20:36</h><w>ikitommi</w>Oh, that looks great! How do you setup the artifact version when pushing to clojars?</z><z id="t1579122853" t="rschmukler Two options (again, sorry on the sparse docs)"><y>#</y><d>2020-01-15</d><h>21:14</h><w>rschmukler</w>Two options (again, sorry on the sparse docs)</z><z id="t1579122876" t="rschmukler either, you invoke it with an explicit :version via the repl / CLI (cli coming soon)"><y>#</y><d>2020-01-15</d><h>21:14</h><w>rschmukler</w>either, you invoke it with an explicit <code>:version</code> via the repl / CLI (cli coming soon)</z><z id="t1579122896" t="rschmukler or, it automatically looks at your git status and uses the tag"><y>#</y><d>2020-01-15</d><h>21:14</h><w>rschmukler</w>or, it automatically looks at your git status and uses the tag</z><z id="t1579122935" t="rschmukler ie. if git is tagged at 1.3.0 and not dirty, it&apos;s 1.3.0 , if it&apos;s dirty then it&apos;s 1.3.0-SNAPSHOT"><y>#</y><d>2020-01-15</d><h>21:15</h><w>rschmukler</w>ie. if git is tagged at <code>1.3.0</code> and not dirty, it&apos;s <code>1.3.0</code>, if it&apos;s dirty then it&apos;s <code>1.3.0-SNAPSHOT</code></z><z id="t1579122946" t="miikka Hmh "><y>#</y><d>2020-01-15</d><h>21:15</h><w>miikka</w>Hmh </z><z id="t1579122955" t="rschmukler Might also make it so that if you&apos;re ahead of a tag (but not dirty) it does 1.3.0-SNAPSHOT too"><y>#</y><d>2020-01-15</d><h>21:15</h><w>rschmukler</w>Might also make it so that if you&apos;re ahead of a tag (but not dirty) it does <code>1.3.0-SNAPSHOT</code> too</z><z id="t1579122957" t="miikka Why not just use Leiningen?"><y>#</y><d>2020-01-15</d><h>21:15</h><w>miikka</w>Why not just use Leiningen?</z><z id="t1579122979" t="rschmukler I ask myself that at least once a week 😉"><y>#</y><d>2020-01-15</d><h>21:16</h><w>rschmukler</w>I ask myself that at least once a week <b>😉</b></z><z id="t1579123047" t="rschmukler I&apos;m hoping to get pablo to ultimately compile as a native image"><y>#</y><d>2020-01-15</d><h>21:17</h><w>rschmukler</w>I&apos;m hoping to get pablo to ultimately compile as a native image</z><z id="t1579123132" t="rschmukler Also, I think the biggest thing that tools-deps gets right is that it forces your project into a edn map - lein allows real programming to happen inside the project.clj file which can allow it to become quite the mess"><y>#</y><d>2020-01-15</d><h>21:18</h><w>rschmukler</w>Also, I think the biggest thing that tools-deps gets right is that it forces your project into a edn map - lein allows real programming to happen inside the <code>project.clj</code> file which can allow it to become quite the mess</z><z id="t1579123174" t="rschmukler But, I don&apos;t disagree that this is shoe-horning some lein-like functionality into tools deps"><y>#</y><d>2020-01-15</d><h>21:19</h><w>rschmukler</w>But, I don&apos;t disagree that this is shoe-horning some lein-like functionality into tools deps</z><z id="t1579123308" t="miikka Yeah… my ideal setup right now would be actually to have Leiningen for the project management (because it already works) and tools.deps for dependency management. Too bad that lein-tools-deps doesn’t quite make it work. "><y>#</y><d>2020-01-15</d><h>21:21</h><w>miikka</w>Yeah… my ideal setup right now would be actually to have Leiningen for the project management (because it already works) and tools.deps for dependency management. Too bad that lein-tools-deps doesn’t quite make it work. </z><z id="t1579123415" t="rschmukler The thing that kills me with tools-deps is that they didn&apos;t make a project.clj parser for when cloning via git... So if you attempt to depend on a git repo and they use lein and don&apos;t publish the xml file in the repo, you&apos;re SOL"><y>#</y><d>2020-01-15</d><h>21:23</h><w>rschmukler</w>The thing that kills me with <code>tools-deps</code> is that they didn&apos;t make a <code>project.clj</code> parser for when cloning via git... So if you attempt to depend on a git repo and they use lein and don&apos;t publish the xml file in the repo, you&apos;re SOL</z><z id="t1579123440" t="miikka Yeah"><y>#</y><d>2020-01-15</d><h>21:24</h><w>miikka</w>Yeah</z><z id="t1579123448" t="rschmukler It feels very unpragmatic"><y>#</y><d>2020-01-15</d><h>21:24</h><w>rschmukler</w>It feels very unpragmatic</z><z id="t1579123471" t="miikka Well, you can’t correctly parse project.clj without running it. Although of course you could make it work in most cases. "><y>#</y><d>2020-01-15</d><h>21:24</h><w>miikka</w>Well, you can’t correctly parse project.clj without running it. Although of course you could make it work in most cases. </z><z id="t1579123509" t="rschmukler Yeah, 1) you could naively parse it and cover 99%, and 2) sci now exists - so you could eval it at make it work in 99.9999% of cases"><y>#</y><d>2020-01-15</d><h>21:25</h><w>rschmukler</w>Yeah, 1) you could naively parse it and cover 99%, and 2) sci now exists - so you could eval it at make it work in 99.9999% of cases</z><z id="t1579123601" t="miikka I think tools.deps is designed in such a way that you can add new dep types. But it’s not nice if it’s not there out of the box"><y>#</y><d>2020-01-15</d><h>21:26</h><w>miikka</w>I think tools.deps is designed in such a way that you can add new dep types. But it’s not nice if it’s not there out of the box</z><z id="t1579123667" t="rschmukler Yeah I think you&apos;re right - I think the coordinates can all be expanded on via multi-method. But then I&apos;m not quite sure how you get it to load those multimethods before trying to resolve the local deps.edn file"><y>#</y><d>2020-01-15</d><h>21:27</h><w>rschmukler</w>Yeah I think you&apos;re right - I think the coordinates can all be expanded on via multi-method. But then I&apos;m not quite sure how you get it to load those multimethods before trying to resolve the local <code>deps.edn</code> file</z><z id="t1579123688" t="miikka Yeah"><y>#</y><d>2020-01-15</d><h>21:28</h><w>miikka</w>Yeah</z><z id="t1579277113" t="theeternalpulse Hi folks, starting to incorporate malli into my project, was wondering is there a mechanism to add metadata to a function so that input and output are automatically validated, or is all the validation meant to be done manually within the function?"><y>#</y><d>2020-01-17</d><h>16:05</h><w>theeternalpulse</w>Hi folks, starting to incorporate malli into my project, was wondering is there a mechanism to add metadata to a function so that input and output are automatically validated, or is all the validation meant to be done manually within the function?</z><z id="t1579277726" t="ikitommi [:attrs {:href &quot;/_/_/users/U1CUUKHDL&quot;}] two choises: 1. wait for https://github.com/metosin/malli/issues/125 2. try aave, https://github.com/teknql/aave"><y>#</y><d>2020-01-17</d><h>16:15</h><w>ikitommi</w><a>@theeternalpulse</a> two choises:
1. wait for <a href="https://github.com/metosin/malli/issues/125" target="_blank">https://github.com/metosin/malli/issues/125</a>
2. try aave, <a href="https://github.com/teknql/aave" target="_blank">https://github.com/teknql/aave</a></z><z id="t1579277784" t="theeternalpulse oh sweet"><y>#</y><d>2020-01-17</d><h>16:16</h><w>theeternalpulse</w>oh sweet</z><z id="t1579277805" t="ikitommi goal of malli is to be a complete schema-system, both function schemas and linting (integration to clj-condo) will be there, soon, I hope."><y>#</y><d>2020-01-17</d><h>16:16</h><w>ikitommi</w>goal of malli is to be a complete schema-system, both function schemas and linting (integration to clj-condo) will be there, soon, I hope.</z><z id="t1579277868" t="theeternalpulse 👍 thanks, I&apos;ll take a look at aave in the meantime."><y>#</y><d>2020-01-17</d><h>16:17</h><w>theeternalpulse</w><b>👍</b> thanks, I&apos;ll take a look at aave in the meantime.</z><z id="t1579277937" t="ikitommi any discussion of aave most welcome here, as [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] is here too."><y>#</y><d>2020-01-17</d><h>16:18</h><w>ikitommi</w>any discussion of aave most welcome here, as <a>@rschmukler</a> is here too.</z><z id="t1579278090" t="rschmukler Hi [:attrs {:href &quot;/_/_/users/U1CUUKHDL&quot;}] ! Aave is in its early days but it does exist! It&apos;s syntax is extendable so if you don&apos;t like the ghostwheel-like syntax, it wouldn&apos;t be too hard to add. The other thing that I want to add is the option for compile time testing of pure functions (so we refuse to compile, rather than wait for the user to call the function). If you have any feature requirements please feel free to open some issues"><y>#</y><d>2020-01-17</d><h>16:21</h><w>rschmukler</w>Hi <a>@theeternalpulse</a>! Aave is in its early days but it does exist! It&apos;s syntax is extendable so if you don&apos;t like the ghostwheel-like syntax, it wouldn&apos;t be too hard to add. The other thing that I want to add is the option for compile time testing of pure functions (so we refuse to compile, rather than wait for the user to call the function). If you have any feature requirements please feel free to open some issues</z><z id="t1579710990" t="ikitommi the m/accept will need extra parameters, maybe both :in and :path . Need to be able to better support schema mappings and inferring ui’s from mall schemas."><y>#</y><d>2020-01-22</d><h>16:36</h><w>ikitommi</w>the <code>m/accept</code> will need extra parameters, maybe both <code>:in</code> and <code>:path</code>. Need to be able to better support schema mappings and inferring ui’s from mall schemas.</z><z id="t1579711032" t="ikitommi will break all 3rd party Schema extensons, sorry."><y>#</y><d>2020-01-22</d><h>16:37</h><w>ikitommi</w>will break all 3rd party <code>Schema</code> extensons, sorry.</z><z id="t1580837765" t="ikitommi maybe there should be default-options-provider , that can be overridden once?"><y>#</y><d>2020-02-04</d><h>17:36</h><w>ikitommi</w>maybe there should be <code>default-options-provider</code>, that can be overridden once?</z><z id="t1580837801" t="ikitommi , would allow easy plugging in of custom registeries, and other options how things work"><y>#</y><d>2020-02-04</d><h>17:36</h><w>ikitommi</w>, would allow easy plugging in of custom registeries, and other options how things work</z><z id="t1580837857" t="ikitommi (integrating malli into real projects, need custom global schemas without a hassle)"><y>#</y><d>2020-02-04</d><h>17:37</h><w>ikitommi</w>(integrating malli into real projects, need custom global  schemas without a hassle)</z><z id="t1580898701" t="borkdude Maybe metosin wants to be mentioned here because they are using sci in malli? https://github.com/borkdude/babashka/issues/254"><y>#</y><d>2020-02-05</d><h>10:31</h><w>borkdude</w>Maybe metosin wants to be mentioned here because they are using sci in malli? <a href="https://github.com/borkdude/babashka/issues/254" target="_blank">https://github.com/borkdude/babashka/issues/254</a></z><z id="t1580899770" t="ikitommi did. I guess you have logo already from clj-condo question 😉"><y>#</y><d>2020-02-05</d><h>10:49</h><w>ikitommi</w>did. I guess you have logo already from clj-condo question <b>😉</b></z><z id="t1580900057" t="borkdude yep, thanks"><y>#</y><d>2020-02-05</d><h>10:54</h><w>borkdude</w>yep, thanks</z><z id="t1581015527" t="eoliphant will malli eventually do, for lack of a better term, a keyset coerce/conform? I try to use open keysets as much as possible, but always struggle the best way to handle stuff like the following (-&gt; {:a .. b:.. :c .. :d} ; say input from api call validate ; we only care about :a,:b and :c but ignore :d do-something-with-a-and-b ; fine with a s/keys [:a :b] or m/validate equivalent precondition do-something-with-c ; fine with a s/keys [:c] (select-keys [:a ::c]) ; or (transform my-schema) (write-a-b-c-to-datomic) ; at this point I want a closed schema/spec precond, that could potentially narrow the keys on the way in? "><y>#</y><d>2020-02-06</d><h>18:58</h><w>eoliphant</w>will malli eventually do, for lack of a better term, a keyset coerce/conform?  I try to use open keysets as much as possible, but always struggle the best way to handle stuff like the following
<pre>(-&gt; {:a .. b:.. :c .. :d} ; say input from api call
     validate ; we only care about :a,:b and :c but ignore :d
     do-something-with-a-and-b ; fine with a s/keys [:a :b] or m/validate equivalent precondition
     do-something-with-c ; fine with a s/keys [:c]
     (select-keys [:a ::c]) ; or (transform my-schema)
     (write-a-b-c-to-datomic) ; at this point I want a closed schema/spec precond, that could potentially narrow the keys on the way in? </pre></z><z id="t1581015910" t="ikitommi [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] would something like (mu/select-keys map-of-abc [:a :b]) be good? you can always make maps closed, to either fail on extra keys or to strip extra keys in transform"><y>#</y><d>2020-02-06</d><h>19:05</h><w>ikitommi</w><a>@eoliphant</a>  would something like <code>(mu/select-keys map-of-abc [:a :b])</code> be good? you can always make maps closed, to either fail on extra keys or to strip extra keys in transform</z><z id="t1581015955" t="ikitommi e.g. select-keys, but for schemas"><y>#</y><d>2020-02-06</d><h>19:05</h><w>ikitommi</w>e.g. select-keys, but for schemas</z><z id="t1581016122" t="eoliphant hmm yeah, perhaps strip extra on transform is the way to go? again, just been thinking about this, in terms of a structural coercion, but that might not be the best approach"><y>#</y><d>2020-02-06</d><h>19:08</h><w>eoliphant</w>hmm yeah, perhaps strip extra on transform is the way to go?  again, just been thinking about this, in terms of a structural coercion, but that might not be the best approach</z><z id="t1581016391" t="ikitommi I think it&apos;s the way to go: open schemas are great , but external systems like db&apos;s aren&apos;t always happy with extra stuff in. We are at least stripping data away at the boundaries."><y>#</y><d>2020-02-06</d><h>19:13</h><w>ikitommi</w>I think it&apos;s the way to go: open schemas are great , but external systems like db&apos;s aren&apos;t always happy with extra stuff in. We are at least stripping data away at the boundaries.</z><z id="t1581016435" t="ikitommi there is malli.transform/strip-extra-keys-transformer for this"><y>#</y><d>2020-02-06</d><h>19:13</h><w>ikitommi</w>there is <code>malli.transform/strip-extra-keys-transformer</code>for this</z><z id="t1581016583" t="eoliphant especially for stuff like datomic lets you do maps, etc all the way down, but it gets understandably upset if you pass in attributes it doesn’t know about 😉"><y>#</y><d>2020-02-06</d><h>19:16</h><w>eoliphant</w>especially for stuff like datomic lets you do maps, etc all the way down, but it gets understandably upset if you pass in attributes it doesn’t know about <b>😉</b></z><z id="t1581108145" t="eoliphant hi quick question on error messages. I’m trying to do a custom message for each condition, so for your initial example, somehting like (-&gt; [:and [int? {:error/message &quot;Not int&quot;}] [:&gt; 6 {:error/message &quot;Less than 6&quot;}]] (m/explain 6)) That doesn’t work, nor does say this [[:&gt; 6] {:error/message &quot;Less than 6&quot;}]] though (-&gt; [:and [int? {:error/message &quot;Not int&quot;}] [:&gt; 6]] (m/explain &quot;a&quot;)) is just fine"><y>#</y><d>2020-02-07</d><h>20:42</h><w>eoliphant</w>hi quick question on error messages.  I’m trying to do a custom message for each condition, so for your initial example, somehting like
<pre>(-&gt; [:and
     [int? {:error/message &quot;Not int&quot;}]
     [:&gt; 6 {:error/message &quot;Less than 6&quot;}]]
  (m/explain 6))</pre>
That doesn’t work, nor does say this <code>[[:&gt; 6] {:error/message &quot;Less than 6&quot;}]]</code> though
<pre>(-&gt; [:and
     [int? {:error/message &quot;Not int&quot;}]
     [:&gt; 6]]
  (m/explain &quot;a&quot;))</pre>
is just fine</z><z id="t1581143906" t="ikitommi properties are always (if defined) the first argument in the schema vector, so [:&gt; {...} 6] should work"><y>#</y><d>2020-02-08</d><h>06:38</h><w>ikitommi</w>properties are always (if defined) the first argument in the schema vector, so <code>[:&gt; {...} 6]</code> should work</z><z id="t1581143960" t="ikitommi &quot;hiccup syntax&quot;"><y>#</y><d>2020-02-08</d><h>06:39</h><w>ikitommi</w>&quot;hiccup syntax&quot;</z><z id="t1581173470" t="eskos How battle tested is the serializable function schemas feature of malli? I&apos;m tinkering on a small side project of mine and realized malli would actually fit into it really well for the purposes of schema+coercion of data structures saving me the effort of doing those myself... 🙂"><y>#</y><d>2020-02-08</d><h>14:51</h><w>eskos</w>How battle tested is the serializable function schemas feature of malli? I&apos;m tinkering on a small side project of mine and realized malli would actually fit into it really well for the purposes of schema+coercion of data structures saving me the effort of doing those myself... <b>🙂</b></z><z id="t1581174993" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] heavy lifting done by https://github.com/borkdude/sci"><y>#</y><d>2020-02-08</d><h>15:16</h><w>ikitommi</w><a>@suomi.esko</a> heavy lifting done by <a href="https://github.com/borkdude/sci" target="_blank">https://github.com/borkdude/sci</a></z><z id="t1581175022" t="ikitommi malli should be in alpha around ClojureD"><y>#</y><d>2020-02-08</d><h>15:17</h><w>ikitommi</w>malli should be in alpha around ClojureD</z><z id="t1581353358" t="ikitommi started to add programmatic helpers to malli: https://github.com/metosin/malli/pull/172"><y>#</y><d>2020-02-10</d><h>16:49</h><w>ikitommi</w>started to add programmatic helpers to malli: <a href="https://github.com/metosin/malli/pull/172" target="_blank">https://github.com/metosin/malli/pull/172</a></z><z id="t1581353414" t="ikitommi looks like: (malli.util/get-in [:map {:title &quot;test&quot;} [:x [:vector [:list [:set [:sequential [:tuple int? [:map [:y [:maybe boolean?]]]]]]]]]] [:x 0 0 0 0 1 :y 0]) ; =&gt; boolean?"><y>#</y><d>2020-02-10</d><h>16:50</h><w>ikitommi</w>looks like:
<pre>(malli.util/get-in
  [:map {:title &quot;test&quot;}
   [:x [:vector
        [:list
         [:set
          [:sequential
           [:tuple int? [:map [:y [:maybe boolean?]]]]]]]]]]
  [:x 0 0 0 0 1 :y 0])
; =&gt; boolean?</pre></z><z id="t1581353472" t="ikitommi there is a new Protocol LookupSchema , which is implemented for :map, :multi, :vector, :list, :set, :sequential, :tuple ."><y>#</y><d>2020-02-10</d><h>16:51</h><w>ikitommi</w>there is a new Protocol <code>LookupSchema</code> , which is implemented for <code>:map, :multi, :vector, :list, :set, :sequential, :tuple</code>.</z><z id="t1581353523" t="ikitommi (malli.util/select-keys [:map {:title &quot;map&quot;} [:a int?] [:b {:optional true} int?] [:c string?]] [:a ::extra]) ;[:map {:title &quot;map&quot;} ; [:a int?] ; [:b {:optional true} int?]]"><y>#</y><d>2020-02-10</d><h>16:52</h><w>ikitommi</w><pre>(malli.util/select-keys
  [:map {:title &quot;map&quot;}
   [:a int?]
   [:b {:optional true} int?]
   [:c string?]]
  [:a ::extra])
;[:map {:title &quot;map&quot;}
; [:a int?]
; [:b {:optional true} int?]]</pre></z><z id="t1581353557" t="borkdude so kinda like the new spec2 thing, where you can select from your schema in different contexts?"><y>#</y><d>2020-02-10</d><h>16:52</h><w>borkdude</w>so kinda like the new spec2 thing, where you can select from your schema in different contexts?</z><z id="t1581353647" t="ikitommi well, almost. like in schema-tools , going to use the clojure.core functions names. There could be malli.util/select to do things like spec2 does."><y>#</y><d>2020-02-10</d><h>16:54</h><w>ikitommi</w>well, almost. like in <code>schema-tools</code>, going to use the clojure.core functions names. There could be <code>malli.util/select</code> to do things like spec2 does.</z><z id="t1581353698" t="ikitommi (-&gt; [:map [:a int?] [:b string?] [:c [:map [:x int?] [:y keyword?]]]] (mu/select-keys [:a :c]) (mu/update-in [:c] mu/dissoc :y)) ;[:map ; [:a int?] ; [:c [:map ; [:x int?]]]]"><y>#</y><d>2020-02-10</d><h>16:54</h><w>ikitommi</w><pre>(-&gt; [:map
     [:a int?]
     [:b string?]
     [:c [:map
          [:x int?]
          [:y keyword?]]]]
    (mu/select-keys [:a :c])
    (mu/update-in [:c] mu/dissoc :y))
;[:map
; [:a int?]
; [:c [:map
;      [:x int?]]]]</pre></z><z id="t1581353711" t="borkdude nice"><y>#</y><d>2020-02-10</d><h>16:55</h><w>borkdude</w>nice</z><z id="t1581353723" t="ikitommi that’s the thing we have been using with prismatic schema for 3+ years now, happy with that 🙂"><y>#</y><d>2020-02-10</d><h>16:55</h><w>ikitommi</w>that’s the thing we have been using with prismatic schema for 3+ years now, happy with that <b>🙂</b></z><z id="t1581353861" t="ikitommi I’m not sure how the spec2 select works with nested sequential specs"><y>#</y><d>2020-02-10</d><h>16:57</h><w>ikitommi</w>I’m not sure how the spec2 select works with nested sequential specs</z><z id="t1581353892" t="ikitommi in malli, I want to keep things explicit: you need to walk those over yourself."><y>#</y><d>2020-02-10</d><h>16:58</h><w>ikitommi</w>in malli, I want to keep things explicit: you need to walk those over yourself.</z><z id="t1581353910" t="borkdude me neither, I kinda lost track on spec2"><y>#</y><d>2020-02-10</d><h>16:58</h><w>borkdude</w>me neither, I kinda lost track on spec2</z><z id="t1581353931" t="ikitommi LookupSchema (-get [_ key default] (if (= 0 key) schema default)))"><y>#</y><d>2020-02-10</d><h>16:58</h><w>ikitommi</w><pre>LookupSchema
(-get [_ key default] (if (= 0 key) schema default)))</pre></z><z id="t1581353969" t="ikitommi ^:--- for all sequential specs, all have just the 0"><y>#</y><d>2020-02-10</d><h>16:59</h><w>ikitommi</w>^:--- for all sequential specs, all have just the 0</z><z id="t1581353993" t="ikitommi also, planning to support schamas as maps, via a helper."><y>#</y><d>2020-02-10</d><h>16:59</h><w>ikitommi</w>also, planning to support schamas as maps, via a helper.</z><z id="t1581354058" t="ikitommi [:vector {:min 0, :max 10} int?] ; =&gt; {:name :vector :properties {:min 0, :max 10} :children [int?]}"><y>#</y><d>2020-02-10</d><h>17:00</h><w>ikitommi</w><pre>[:vector {:min 0, :max 10} int?]
; =&gt;
{:name :vector
 :properties {:min 0, :max 10}
 :children [int?]}</pre></z><z id="t1581354089" t="ikitommi there is already a walker that recursively transforms between formats."><y>#</y><d>2020-02-10</d><h>17:01</h><w>ikitommi</w>there is already a walker that recursively transforms between formats.</z><z id="t1581354147" t="ikitommi will push these extras into malli.util , so there is just the absolute minimum stuff in the core."><y>#</y><d>2020-02-10</d><h>17:02</h><w>ikitommi</w>will push these extras into <code>malli.util</code>, so there is just the absolute minimum stuff in the core.</z><z id="t1581371261" t="ikitommi should the m/name be m/type ? In both React &amp; json schema it&apos;s a type"><y>#</y><d>2020-02-10</d><h>21:47</h><w>ikitommi</w>should the <code>m/name</code> be <code>m/type</code>? In both React &amp; json schema it&apos;s a type</z><z id="t1581371283" t="ikitommi [:vector {:min 0, :max 10} int?] ; =&gt; {:type :vector :properties {:min 0, :max 10} :children [int?]}"><y>#</y><d>2020-02-10</d><h>21:48</h><w>ikitommi</w><pre>[:vector {:min 0, :max 10} int?]
; =&gt;
{:type :vector
 :properties {:min 0, :max 10}
 :children [int?]}</pre></z><z id="t1581401218" t="ikitommi (mu/assoc-in nil [:a ::c :d] int?) ; [:map [:a [:map [:b [:map [:c [:map [:d int?]]]]]]]]"><y>#</y><d>2020-02-11</d><h>06:06</h><w>ikitommi</w><pre>(mu/assoc-in nil [:a ::c :d] int?)
; [:map [:a [:map [:b [:map [:c [:map [:d int?]]]]]]]]</pre></z><z id="t1581401307" t="ikitommi great thing about clojure is the functions compose nicely. HOFs are mostly 1:1 counterparts from Clojure (just cleaned up): (defn update-in &quot;Like [[clojure.core/update-in]], but for LensSchemas.&quot; [schema ks f &amp; args] (letfn [(up [s [k &amp; ks] f args] (assoc s k (if ks (up (get s k) ks f args) (apply f (get s k) args))))] (up schema ks f args)))"><y>#</y><d>2020-02-11</d><h>06:08</h><w>ikitommi</w>great thing about clojure is the functions compose nicely. HOFs are mostly 1:1 counterparts from Clojure (just cleaned up):
<pre>(defn update-in
  &quot;Like [[clojure.core/update-in]], but for LensSchemas.&quot;
  [schema ks f &amp; args]
  (letfn [(up [s [k &amp; ks] f args]
            (assoc s k (if ks (up (get s k) ks f args)
                              (apply f (get s k) args))))]
    (up schema ks f args)))</pre></z><z id="t1581401356" t="ikitommi (defn update &quot;Like [[clojure.core/update]], but for LensSchemas.&quot; [schema key f &amp; args] (let [schema (m/schema schema)] (m/-set schema key (apply f (m/-get schema key nil) args))))"><y>#</y><d>2020-02-11</d><h>06:09</h><w>ikitommi</w><pre>(defn update
  &quot;Like [[clojure.core/update]], but for LensSchemas.&quot;
  [schema key f &amp; args]
  (let [schema (m/schema schema)]
    (m/-set schema key (apply f (m/-get schema key nil) args))))</pre></z><z id="t1581401377" t="ikitommi Internally, there are just -get and -set functions in a LensSchema protocol. Dead simple."><y>#</y><d>2020-02-11</d><h>06:09</h><w>ikitommi</w>Internally, there are just <code>-get</code> and <code>-set</code> functions in a <code>LensSchema</code> protocol. Dead simple.</z><z id="t1581562956" t="eckardjf How could I use a custom error message for a failed regex match? Something like: (-&gt; [:map [:a [#&quot;^[0-9]+$&quot; {:error/message &quot;should match&quot;}]]] (mc/explain {:a &quot;aaa&quot;}) (me/humanize))"><y>#</y><d>2020-02-13</d><h>03:02</h><w>eckardjf</w>How could I use a custom error message for a failed regex match? Something like:
<pre>(-&gt; [:map [:a [#&quot;^[0-9]+$&quot; {:error/message &quot;should match&quot;}]]]
    (mc/explain {:a &quot;aaa&quot;})
    (me/humanize))</pre></z><z id="t1581571798" t="eckardjf Ah, I see what I was missing - this works [:map [:a [:re {:error/message &quot;should match&quot;} #&quot;^[0-9]+$&quot;]]]"><y>#</y><d>2020-02-13</d><h>05:29</h><w>eckardjf</w>Ah, I see what I was missing - this works
<pre>[:map [:a [:re {:error/message &quot;should match&quot;} #&quot;^[0-9]+$&quot;]]]</pre></z><z id="t1581667343" t="ikitommi I&apos;m bit surprised that the first one doesn&apos;t work."><y>#</y><d>2020-02-14</d><h>08:02</h><w>ikitommi</w>I&apos;m bit surprised that the first one doesn&apos;t work.</z><z id="t1581690038" t="plexus I&apos;m trying to use malli to coerce reitit query arguments, but not quite getting the results I&apos;m expecting."><y>#</y><d>2020-02-14</d><h>14:20</h><w>plexus</w>I&apos;m trying to use malli to coerce reitit query arguments, but not quite getting the results I&apos;m expecting.</z><z id="t1581690088" t="plexus route: [&quot;/paginated/:table&quot; {:get {:coercion reitit.coercion.malli/coercion :parameters {:path {:table string?} :query {:page int? :page-size int?}} :responses {200 {:body any?}} :handler (fn [{:keys [path-params params] :as req}] {:status 200 :body &quot;OK&quot;})}}]"><y>#</y><d>2020-02-14</d><h>14:21</h><w>plexus</w>route:
<pre>[&quot;/paginated/:table&quot;
 {:get {:coercion reitit.coercion.malli/coercion
        :parameters {:path {:table string?}
                     :query {:page int?
                             :page-size int?}}
        :responses {200 {:body any?}}
        :handler (fn [{:keys [path-params params] :as req}]
                   {:status 200
                    :body &quot;OK&quot;})}}]</pre></z><z id="t1581690120" t="plexus and router"><y>#</y><d>2020-02-14</d><h>14:22</h><w>plexus</w>and router</z><z id="t1581690123" t="plexus (http/router routes {:data {:middleware [rrc/coerce-exceptions-middleware rrc/coerce-request-middleware rrc/coerce-response-middleware]}}) "><y>#</y><d>2020-02-14</d><h>14:22</h><w>plexus</w><pre>(http/router routes {:data {:middleware [rrc/coerce-exceptions-middleware
                                         rrc/coerce-request-middleware
                                         rrc/coerce-response-middleware]}})</pre>
</z><z id="t1581690156" t="plexus is it reasonable to expect that this way a ?page=1 parameter will come in as {:query-params {&quot;page&quot; 1}} ?"><y>#</y><d>2020-02-14</d><h>14:22</h><w>plexus</w>is it reasonable to expect that this way a <code>?page=1</code> parameter will come in as <code>{:query-params {&quot;page&quot; 1}}</code>?</z><z id="t1581690300" t="ikitommi yes, but the coerced params are under :parameters , so_ {:parameters {:query {{:page 1}}}"><y>#</y><d>2020-02-14</d><h>14:25</h><r>ikitommi</r>yes, but the coerced params are under <code>:parameters</code>, so_
<pre>{:parameters {:query {{:page 1}}}</pre></z><z id="t1581690164" t="ikitommi {:table string?} --&gt; [:map [:table string?]]"><y>#</y><d>2020-02-14</d><h>14:22</h><w>ikitommi</w><pre>{:table string?} --&gt; [:map [:table string?]]</pre></z><z id="t1581690164" t="plexus and not {&quot;page&quot; &quot;1&quot;}"><y>#</y><d>2020-02-14</d><h>14:22</h><w>plexus</w>and not <code>{&quot;page&quot; &quot;1&quot;}</code></z><z id="t1581690186" t="plexus ahhh thanks, let me try that"><y>#</y><d>2020-02-14</d><h>14:23</h><w>plexus</w>ahhh thanks, let me try that</z><z id="t1581690206" t="plexus same for :query then I suppose? [:map {:page ...}]"><y>#</y><d>2020-02-14</d><h>14:23</h><w>plexus</w>same for :query then I suppose? <code>[:map {:page ...}]</code></z><z id="t1581690222" t="ikitommi didn’t add any sugar for the top-level maps in the malli coercion, so, all parameters need to be defined in the malli syntax."><y>#</y><d>2020-02-14</d><h>14:23</h><w>ikitommi</w>didn’t add any sugar for the top-level maps in the malli coercion, so, all parameters need to be defined in the malli syntax.</z><z id="t1581690248" t="ikitommi crossed my mind to do that, would be 1:1 to switch the simple cases from data-specs to malli…"><y>#</y><d>2020-02-14</d><h>14:24</h><w>ikitommi</w>crossed my mind to do that, would be 1:1 to switch the simple cases from data-specs to malli…</z><z id="t1581690339" t="plexus still getting string... :parameters {:path [:map [:table string?]] :query [:map [:page int?] [:page-size int?]]} "><y>#</y><d>2020-02-14</d><h>14:25</h><w>plexus</w>still getting string...
<pre>:parameters {:path [:map
                               [:table string?]]
                        :query [:map
                                [:page int?]
                                [:page-size int?]]}</pre>
</z><z id="t1581690367" t="ikitommi there is an example app in https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger"><y>#</y><d>2020-02-14</d><h>14:26</h><w>ikitommi</w>there is an example app in <a href="https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger" target="_blank">https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger</a></z><z id="t1581690432" t="ikitommi [&quot;/math&quot; {:swagger {:tags [&quot;math&quot;]}} [&quot;/plus&quot; {:get {:summary &quot;plus with malli query parameters&quot; :parameters {:query [:map [:x int?] [:y int?]]} :responses {200 {:body [:map [:total int?]]}} :handler (fn [{{{:keys [x y]} :query} :parameters}] {:status 200 :body {:total (+ x y)}})} :post {:summary &quot;plus with malli body parameters&quot; :parameters {:body [:map [:x int?] [:y int?]]} :responses {200 {:body [:map [:total int?]]}} :handler (fn [{{{:keys [x y]} :body} :parameters}] {:status 200 :body {:total (+ x y)}})}}]]]"><y>#</y><d>2020-02-14</d><h>14:27</h><w>ikitommi</w><pre>[&quot;/math&quot;
        {:swagger {:tags [&quot;math&quot;]}}

        [&quot;/plus&quot;
         {:get {:summary &quot;plus with malli query parameters&quot;
                :parameters {:query [:map [:x int?] [:y int?]]}
                :responses {200 {:body [:map [:total int?]]}}
                :handler (fn [{{{:keys [x y]} :query} :parameters}]
                           {:status 200
                            :body {:total (+ x y)}})}
          :post {:summary &quot;plus with malli body parameters&quot;
                 :parameters {:body [:map [:x int?] [:y int?]]}
                 :responses {200 {:body [:map [:total int?]]}}
                 :handler (fn [{{{:keys [x y]} :body} :parameters}]
                            {:status 200
                             :body {:total (+ x y)}})}}]]]</pre></z><z id="t1581690573" t="plexus sorry, had some connectivity issues there. Let me have a look at the example."><y>#</y><d>2020-02-14</d><h>14:29</h><w>plexus</w>sorry, had some connectivity issues there. Let me have a look at the example.</z><z id="t1581690750" t="plexus I guess you use all the reitit.*.middleware instead of ring-defaults now"><y>#</y><d>2020-02-14</d><h>14:32</h><w>plexus</w>I guess you use all the reitit.*.middleware instead of ring-defaults now</z><z id="t1581691527" t="ikitommi there are useful middeware there, but for example the site is really heavy and many things are solved alread (like fallback to look up file resources)"><y>#</y><d>2020-02-14</d><h>14:45</h><w>ikitommi</w>there are useful middeware there, but for example the <code>site</code> is really heavy and many things are solved alread (like fallback to look up file resources)</z><z id="t1581691544" t="plexus ok, progress. changed reitit.http/router to reitit.ring/router, and now I&apos;m getting a 406 Not Acceptable"><y>#</y><d>2020-02-14</d><h>14:45</h><w>plexus</w>ok, progress. changed reitit.http/router to reitit.ring/router, and now I&apos;m getting a 406 Not Acceptable</z><z id="t1581691616" t="ikitommi there is a bug somewhere in the malli-coercion, bumped into it few days ago, if the response is not valid, gives really weird error. will fix that soon."><y>#</y><d>2020-02-14</d><h>14:46</h><w>ikitommi</w>there is a bug somewhere in the malli-coercion, bumped into it few days ago, if the response is not valid, gives really weird error. will fix that soon.</z><z id="t1581691678" t="plexus added Accept-Encoding=application/json and now it&apos;s a 405 Method Not Allowed"><y>#</y><d>2020-02-14</d><h>14:47</h><w>plexus</w>added <code>Accept-Encoding=application/json</code> and now it&apos;s  a <code>405 Method Not Allowed</code></z><z id="t1581691684" t="plexus still going to consider this progress 🙂"><y>#</y><d>2020-02-14</d><h>14:48</h><w>plexus</w>still going to consider this progress <b>🙂</b></z><z id="t1581691854" t="ikitommi I have a minimal shadow-cljs + deps + reitit + malli example project, will good defaults, try to push that out before ClojureD"><y>#</y><d>2020-02-14</d><h>14:50</h><w>ikitommi</w>I have a minimal shadow-cljs + deps + reitit + malli example project, will good defaults, try to push that out before ClojureD</z><z id="t1581691871" t="plexus that&apos;d be great, thanks!"><y>#</y><d>2020-02-14</d><h>14:51</h><w>plexus</w>that&apos;d be great, thanks!</z><z id="t1581691895" t="plexus was hoping not to manually have to parse those integers but maybe the trouble isn&apos;t worth it right now"><y>#</y><d>2020-02-14</d><h>14:51</h><w>plexus</w>was hoping not to manually have to parse those integers but maybe the trouble isn&apos;t worth it right now</z><z id="t1581691905" t="ikitommi default reitit has no opinions, lot’s of things that need to decided, not the friendliest for new users"><y>#</y><d>2020-02-14</d><h>14:51</h><w>ikitommi</w>default reitit has no opinions, lot’s of things that need to decided, not the friendliest for new users</z><z id="t1581691946" t="ikitommi if you test the sample app I pointed and just strip away things?"><y>#</y><d>2020-02-14</d><h>14:52</h><w>ikitommi</w>if you test the sample app I pointed and just strip away things?</z><z id="t1581691965" t="ikitommi there is also the request/response printer, just commented out."><y>#</y><d>2020-02-14</d><h>14:52</h><w>ikitommi</w>there is also the request/response printer, just commented out.</z><z id="t1581691979" t="ikitommi let’s you see what the different mw do in the chain."><y>#</y><d>2020-02-14</d><h>14:52</h><w>ikitommi</w>let’s you see what the different mw do in the chain.</z><z id="t1581692003" t="ikitommi uses deep-diff btw 😉"><y>#</y><d>2020-02-14</d><h>14:53</h><w>ikitommi</w>uses deep-diff btw <b>😉</b></z><z id="t1581692144" t="plexus nice, probably why it&apos;s been doing so well. most downloaded lambdaisland project 🙂"><y>#</y><d>2020-02-14</d><h>14:55</h><w>plexus</w>nice, probably why it&apos;s been doing so well. most downloaded lambdaisland project <b>🙂</b></z><z id="t1581692382" t="plexus we&apos;re working on clojurescript support for deep-diff BTW"><y>#</y><d>2020-02-14</d><h>14:59</h><w>plexus</w>we&apos;re working on clojurescript support for deep-diff BTW</z><z id="t1581716198" t="steveb8n [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] this is great news. when using Shadow-cljs and Cursive, there’s basically no easy visual diff tooling that I can find. cljs support in deep-diff will fill this gap perfectly"><y>#</y><d>2020-02-14</d><h>21:36</h><r>steveb8n</r><a>@U07FP7QJ0</a> this is great news. when using Shadow-cljs and Cursive, there’s basically no easy visual diff tooling that I can find. cljs support in deep-diff will fill this gap perfectly</z><z id="t1581692552" t="plexus oh it&apos;s working now!"><y>#</y><d>2020-02-14</d><h>15:02</h><w>plexus</w>oh it&apos;s working now!</z><z id="t1581692580" t="plexus misunderstood something about httpie :face_palm: :skin-tone-2:"><y>#</y><d>2020-02-14</d><h>15:03</h><w>plexus</w>misunderstood something about httpie <b>:face_palm:</b><b>:skin-tone-2:</b></z><z id="t1581693504" t="ikitommi It looks like malli need support for sequence schemas. I just need the simplest “varargs” case, why not do the whole thing while at it."><y>#</y><d>2020-02-14</d><h>15:18</h><w>ikitommi</w>It looks like malli need support for sequence schemas. I just need the simplest “varargs” case, why not do the whole thing while at it.</z><z id="t1581693527" t="ikitommi I’m thinking of re-using the map/multi syntax: (m/valid? [:cat [:x int?] [:y int?] [:rest [:* string?]]] [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ; =&gt; true"><y>#</y><d>2020-02-14</d><h>15:18</h><w>ikitommi</w>I’m thinking of re-using the map/multi syntax:
<pre>(m/valid?
  [:cat
   [:x int?]
   [:y int?]
   [:rest [:* string?]]]
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
; =&gt; true</pre></z><z id="t1581693566" t="ikitommi if https://github.com/cgrand/seqexp would be ported to cljs, could use that behind the scenes."><y>#</y><d>2020-02-14</d><h>15:19</h><w>ikitommi</w>if <a href="https://github.com/cgrand/seqexp" target="_blank">https://github.com/cgrand/seqexp</a> would be ported to cljs, could use that behind the scenes.</z><z id="t1581693716" t="ikitommi like clojure.spec.alpha/conform , there could be something for that? (m/destructure [:cat [:x int?] [:y int?] [:rest [:* string?]]] [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ; {:x 1 ; :y 2 ; :rest (&quot;kikka &quot;kukka&quot;)}"><y>#</y><d>2020-02-14</d><h>15:21</h><w>ikitommi</w>like <code>clojure.spec.alpha/conform</code>, there could be something for that?
<pre>(m/destructure
  [:cat
   [:x int?]
   [:y int?]
   [:rest [:* string?]]]
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
; {:x 1
;  :y 2
;  :rest (&quot;kikka &quot;kukka&quot;)}</pre></z><z id="t1581693767" t="ikitommi without that, this would be just enough: (m/valid? [:cat int? int? [:* string?]] [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ; =&gt; true"><y>#</y><d>2020-02-14</d><h>15:22</h><w>ikitommi</w>without that, this would be just enough:
<pre>(m/valid?
  [:cat int? int? [:* string?]]
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
; =&gt; true</pre></z><z id="t1581693835" t="ikitommi ideas most welcome on this."><y>#</y><d>2020-02-14</d><h>15:23</h><w>ikitommi</w>ideas most welcome on this.</z><z id="t1581694299" t="ikitommi (require &apos;[net.cgrand.seqexp :as se]) (se/exec (se/cat (se/as :x int?) (se/as :y int?) (se/as :restz (se/* :string?))) [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ;{:x (1) ; :y (2) ; :restz (&quot;kikka&quot; &quot;kukka&quot;) ; :rest ()}"><y>#</y><d>2020-02-14</d><h>15:31</h><w>ikitommi</w><pre>(require &apos;[net.cgrand.seqexp :as se])

(se/exec
  (se/cat
    (se/as :x int?)
    (se/as :y int?)
    (se/as :restz (se/* :string?)))
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
;{:x (1)
; :y (2)
; :restz (&quot;kikka&quot; &quot;kukka&quot;)
; :rest ()}</pre></z><z id="t1581707254" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] fwiw, I ported clojure spec to a graalvm compatible subset here: https://github.com/borkdude/spartan.spec"><y>#</y><d>2020-02-14</d><h>19:07</h><w>borkdude</w><a>@ikitommi</a> fwiw, I ported clojure spec to a graalvm compatible subset here:

<a href="https://github.com/borkdude/spartan.spec" target="_blank">https://github.com/borkdude/spartan.spec</a></z><z id="t1581707273" t="borkdude it contains all the regex ops"><y>#</y><d>2020-02-14</d><h>19:07</h><w>borkdude</w>it contains all the regex ops</z><z id="t1581708959" t="ikitommi oh, nice. Will have a look."><y>#</y><d>2020-02-14</d><h>19:35</h><w>ikitommi</w>oh, nice. Will have a look.</z><z id="t1581708995" t="borkdude it&apos;s basically a copy with things removed"><y>#</y><d>2020-02-14</d><h>19:36</h><w>borkdude</w>it&apos;s basically a copy with things removed</z><z id="t1581709119" t="ikitommi What if explainer would also report succesfully validated values in same format as errors? At top level, the m/explain it would return either errors or succefull values."><y>#</y><d>2020-02-14</d><h>19:38</h><w>ikitommi</w>What if <code>explainer</code> would also report succesfully validated values in same format as errors? At top level, the <code>m/explain</code> it would return either errors or succefull values.</z><z id="t1581709136" t="ikitommi it would give destructuring basically for free."><y>#</y><d>2020-02-14</d><h>19:38</h><w>ikitommi</w>it would give destructuring basically for free.</z><z id="t1581709307" t="ikitommi now, only errors are pushed to the accumulator. It could be swapped Into a protocol, which has -explain-error and -explain-success functions. Schemas write to those and internally, in case of first error, it just tosses away the successes and collects only errors. In case of no errors, it would return the successes in the same explain -format!!"><y>#</y><d>2020-02-14</d><h>19:41</h><w>ikitommi</w>now, only errors are pushed to the accumulator. It could be swapped Into a protocol, which has <code>-explain-error</code> and <code>-explain-success</code> functions. Schemas write to those and internally, in case of first error, it just tosses away the successes and collects only errors. In case of no errors, it would return the successes in the same explain -format!!</z><z id="t1581709452" t="ikitommi as it contains both the paths to schemas and in data, one can &quot;unexplain&quot; in a generic way"><y>#</y><d>2020-02-14</d><h>19:44</h><w>ikitommi</w>as it contains both the paths to schemas and in data, one can &quot;unexplain&quot; in a generic way</z><z id="t1581710253" t="ikitommi Spec has conform , unform and explain , malli could only have explain for all these, but has validate for perf reasons. Still, less for more."><y>#</y><d>2020-02-14</d><h>19:57</h><w>ikitommi</w>Spec has <code>conform</code>, <code>unform</code> and <code>explain</code> , malli could only have <code>explain</code>  for all these, but has <code>validate</code> for perf reasons. Still, less for more.</z><z id="t1581710538" t="borkdude in spec the bulk of the work is done in conform. this result is fed into explain which transforms that result to something readable, but even valid? uses conform"><y>#</y><d>2020-02-14</d><h>20:02</h><w>borkdude</w>in spec the bulk of the work is done in conform. this result is fed into explain which transforms that result to something readable, but even valid? uses conform</z><z id="t1581760598" t="ikitommi I don’t think result of s/conform is fed into explain. It either returns the conformed value of ::s/invalid . In case of latter, s/explain is called again with the original data. Which is fine, as it’s the failure path as you said."><y>#</y><d>2020-02-15</d><h>09:56</h><r>ikitommi</r>I don’t think result of <code>s/conform</code> is fed into explain. It either returns the conformed value of <code>::s/invalid</code>. In case of latter, <code>s/explain</code> is called again with the original data. Which is fine, as it’s the failure path as you said.</z><z id="t1581760624" t="ikitommi m/validate does much less than s/valid? and because of that - is much faster."><y>#</y><d>2020-02-15</d><h>09:57</h><r>ikitommi</r><code>m/validate</code> does much less than  <code>s/valid?</code> and because of that - is much faster.</z><z id="t1581760692" t="ikitommi or, actually, m/validator ."><y>#</y><d>2020-02-15</d><h>09:58</h><r>ikitommi</r>or, actually, <code>m/validator</code>.</z><z id="t1581760718" t="ikitommi ;; 40ns (let [spec (s/and int? (s/or :pos-int pos-int? :neg-int neg-int?)) valid? (partial s/valid? spec)] (cc/quick-bench (valid? 0))) ;; 5ns (let [valid? (m/validator [:and int? [:or pos-int? neg-int?]])] (cc/quick-bench (valid? 0)))"><y>#</y><d>2020-02-15</d><h>09:58</h><r>ikitommi</r><pre>;; 40ns
(let [spec (s/and int? (s/or :pos-int pos-int? :neg-int neg-int?))
      valid? (partial s/valid? spec)]
  (cc/quick-bench
    (valid? 0)))

;; 5ns
(let [valid? (m/validator [:and int? [:or pos-int? neg-int?]])]
  (cc/quick-bench
    (valid? 0)))</pre></z><z id="t1581710577" t="borkdude I think might have the philosophy that when something is valid it should go fast, but when something is invalid, it doesn&apos;t matter if you have to call conform again"><y>#</y><d>2020-02-14</d><h>20:02</h><w>borkdude</w>I think might have the philosophy that when something is valid it should go fast, but when something is invalid, it doesn&apos;t matter if you have to call conform again</z><z id="t1581710583" t="borkdude because something is wrong anyway"><y>#</y><d>2020-02-14</d><h>20:03</h><w>borkdude</w>because something is wrong anyway</z><z id="t1581764877" t="ikitommi no unform in spartan-spec?"><y>#</y><d>2020-02-15</d><h>11:07</h><w>ikitommi</w>no <code>unform</code> in spartan-spec?</z><z id="t1581770462" t="borkdude since I&apos;ve never used it, I didn&apos;t port it yet 😛"><y>#</y><d>2020-02-15</d><h>12:41</h><w>borkdude</w>since I&apos;ve never used it, I didn&apos;t port it yet <b>😛</b></z><z id="t1581770491" t="borkdude PR welcome!"><y>#</y><d>2020-02-15</d><h>12:41</h><w>borkdude</w>PR welcome!</z><z id="t1582131814" t="ikitommi (require &apos;[malli.core :as m]) (require &apos;[malli.transform :as mt]) (def transformer (mt/transformer ;; first run schema-based transformations named :before {:name :before} ;; run json-things (mt/json-transformer) ;; add default values (mt/default-value-transformer) ;; run custom things {:name :after})) (m/decoder [:map [:name string?] [:age int?] [:address [:map [:street string?] [:country [:enum &quot;finland&quot; &quot;germany&quot;]]]]] transformer) ; =&gt; clojure.core$identity"><y>#</y><d>2020-02-19</d><h>17:03</h><w>ikitommi</w><pre>(require &apos;[malli.core :as m])
(require &apos;[malli.transform :as mt])

(def transformer
  (mt/transformer
    ;; first run schema-based transformations named :before
    {:name :before}
    ;; run json-things
    (mt/json-transformer)
    ;; add default values
    (mt/default-value-transformer)
    ;; run custom things
    {:name :after}))

(m/decoder
  [:map
   [:name string?]
   [:age int?]
   [:address
    [:map
     [:street string?]
     [:country [:enum &quot;finland&quot; &quot;germany&quot;]]]]]
  transformer)
; =&gt; clojure.core$identity</pre></z><z id="t1582131877" t="ikitommi I keep surprised how good the transformation engine really is."><y>#</y><d>2020-02-19</d><h>17:04</h><w>ikitommi</w>I keep surprised how good the transformation engine really is.</z><z id="t1582552889" t="Scar Hey everyone. Love using this tool. Seems like validation works blazing fast, however mp/provide is slow. for example - creating a schema from a vector of 200 items will take more than 2 minutes. The processing growth is linear so 20,000 would take about 9 hours :(. I think it has to do with the fact the schema is built using exceptions."><y>#</y><d>2020-02-24</d><h>14:01</h><w>Scar</w>Hey everyone. Love using this tool.
Seems like validation works blazing fast, however <code>mp/provide</code> is slow.
for example - creating a schema from a vector of 200 items will take more than 2 minutes. The processing growth is linear so 20,000 would take about 9 hours :(.
I think it has to do with the fact the schema is built using exceptions.</z><z id="t1582552999" t="Scar"><y>#</y><d>2020-02-24</d><h>14:03</h><w>Scar</w></z><z id="t1582566352" t="ikitommi oh, that&apos;s horrible. The only really perf optimized trails are -validator , -explainer and -transformer paths of schemas. Ideas welcome how to make the providers faster."><y>#</y><d>2020-02-24</d><h>17:45</h><w>ikitommi</w>oh, that&apos;s horrible. The only really perf optimized trails are <code>-validator</code>, <code>-explainer</code> and <code>-transformer</code> paths of schemas. Ideas welcome how to make the providers faster.</z><z id="t1582566479" t="ikitommi the algo is currently brute force, but I think if there were some kind of type-based narrower, it would not throw. e.g. Java Long would only be checked against predicates that work with that."><y>#</y><d>2020-02-24</d><h>17:47</h><w>ikitommi</w>the algo is currently brute force, but I think if there were some kind of type-based narrower, it would not throw. e.g. Java <code>Long</code> would only be checked against predicates that work with that.</z><z id="t1582620371" t="Ben Sless off the top of my head, wouldn&apos;t &quot;errors as values&quot; be faster? i.e. instead of throwing, return the data in a map with an :error key"><y>#</y><d>2020-02-25</d><h>08:46</h><r>Ben Sless</r>off the top of my head, wouldn&apos;t &quot;errors as values&quot; be faster? i.e. instead of throwing, return the data in a map with an <code>:error</code> key</z><z id="t1582645160" t="ikitommi Errors as values would be slower in the happy case / success - one would have to check always is the result an error or not. Try is basically zero cost in JVM, so the perf penalty (of throwing) only happens at the unhappy path."><y>#</y><d>2020-02-25</d><h>15:39</h><r>ikitommi</r>Errors as values would be slower in the happy case / success - one would have to check always is the result an error or not. Try is basically zero cost in JVM, so the perf penalty (of throwing) only happens at the unhappy path.</z><z id="t1582645279" t="ikitommi I think the exceptions originate from the fact that the inferrer tries to make all registered schemas from it and they throw on invalid childs. E.g. for value 1 , it tries to make a map with [:map 1] , which throws on creation."><y>#</y><d>2020-02-25</d><h>15:41</h><r>ikitommi</r>I think the exceptions originate from the fact that the inferrer tries to make all registered schemas from it and they throw on invalid childs. E.g. for value <code>1</code>, it tries to make a map with <code>[:map 1]</code>, which throws on creation.</z><z id="t1582645362" t="ikitommi narrowing possible schemas to test would make it orders of magnitude faster, my guess on 2 (orders)"><y>#</y><d>2020-02-25</d><h>15:42</h><r>ikitommi</r>narrowing possible schemas to test would make it orders of magnitude faster, my guess on 2 (orders)</z><z id="t1582721727" t="eskos There’s IIRC some newer optimizations in post-JDK9 versions for making stack&amp;exception handling way faster, but I haven’t really looked into those beyond StackWalker…at least one of them was a throw-without-resolving-stack kind of operation; the stack unrolling is what generally is the slow part when exception gets thrown."><y>#</y><d>2020-02-26</d><h>12:55</h><r>eskos</r>There’s IIRC some newer optimizations in post-JDK9 versions for making stack&amp;exception handling way faster, but I haven’t really looked into those beyond StackWalker…at least one of them was a throw-without-resolving-stack kind of operation; the stack unrolling is what generally is the slow part when exception gets thrown.</z><z id="t1582721861" t="eskos It is also maybe possible to memoize the exception itself, although I wonder if that would work at all with the ex-info…"><y>#</y><d>2020-02-26</d><h>12:57</h><r>eskos</r>It is also maybe possible to memoize the exception itself, although I wonder if that would work at all with the ex-info…</z><z id="t1582893419" t="ikitommi just in time for tomorrows talk 🙂"><y>#</y><d>2020-02-28</d><h>12:36</h><w>ikitommi</w>just in time for tomorrows talk <b>🙂</b></z><z id="t1582893465" t="ikitommi that’s clj-kondo talking"><y>#</y><d>2020-02-28</d><h>12:37</h><w>ikitommi</w>that’s clj-kondo talking</z><z id="t1582933452" t="Jorin Looking forward!"><y>#</y><d>2020-02-28</d><h>23:44</h><w>Jorin</w>Looking forward!</z><z id="t1582966506" t="kszabo good luck with the talk!"><y>#</y><d>2020-02-29</d><h>08:55</h><w>kszabo</w>good luck with the talk!</z><z id="t1582975667" t="ikitommi thanks! the slides are here: https://www.slideshare.net/mobile/metosin/malli-inside-datadriven-schemas"><y>#</y><d>2020-02-29</d><h>11:27</h><w>ikitommi</w>thanks! the slides are here: <a href="https://www.slideshare.net/mobile/metosin/malli-inside-datadriven-schemas" target="_blank">https://www.slideshare.net/mobile/metosin/malli-inside-datadriven-schemas</a></z><z id="t1583135066" t="eskos Is there going to be a video of this?"><y>#</y><d>2020-03-02</d><h>07:44</h><r>eskos</r>Is there going to be a video of this?</z><z id="t1582979236" t="zilti Nice, thanks! I enjoyed the presentation. Considering the library for the project at work now."><y>#</y><d>2020-02-29</d><h>12:27</h><w>zilti</w>Nice, thanks! I enjoyed the presentation. Considering the library for the project at work now.</z><z id="t1582979380" t="zilti You mentioned something about generating input forms, right?"><y>#</y><d>2020-02-29</d><h>12:29</h><w>zilti</w>You mentioned something about generating input forms, right?</z><z id="t1583159995" t="ikitommi we have been doing that is many projects, but with other schema-libs, nothing library-quality for malli yet. Did a spike using antd+malli, and learned that we need to add 1-2 extra args to m/-accept for this."><y>#</y><d>2020-03-02</d><h>14:39</h><r>ikitommi</r>we have been doing that is many projects, but with other schema-libs, nothing library-quality for malli yet. Did a spike using antd+malli, and learned that we need to add 1-2 extra args to <code>m/-accept</code> for this.</z><z id="t1583160046" t="ikitommi once it’s done, goal is to make an alternative schema backend for https://domino-clj.github.io/ from malli."><y>#</y><d>2020-03-02</d><h>14:40</h><r>ikitommi</r>once it’s done, goal is to make an alternative schema backend for <a href="https://domino-clj.github.io/" target="_blank">https://domino-clj.github.io/</a> from malli.</z><z id="t1583195905" t="zilti I see. Thing is I am very interested in everything that gives me a bit of a hint for how to tacke flexible form generation for a project at work. Do you happen to have a link to something, no matter if done with another schema lib?"><y>#</y><d>2020-03-03</d><h>00:38</h><r>zilti</r>I see. Thing is I am very interested in everything that gives me a bit of a hint for how to tacke flexible form generation for a project at work. Do you happen to have a link to something, no matter if done with another schema lib?</z><z id="t1582992263" t="Vincent Cantin Is there some guidelines for contributing to Malli?"><y>#</y><d>2020-02-29</d><h>16:04</h><w>Vincent Cantin</w>Is there some guidelines for contributing to Malli?</z><z id="t1583160059" t="ikitommi not yet, should be,."><y>#</y><d>2020-03-02</d><h>14:40</h><r>ikitommi</r>not yet, should be,.</z><z id="t1583160059" t="ikitommi not yet, should be,."><y>#</y><d>2020-03-02</d><h>14:40</h><w>ikitommi</w>not yet, should be,.</z><z id="t1583125050" t="Vincent Cantin if I understand correctly, the most natural way to implement the equivalent of spec/conform and spec/unform in Malli is to use a Transformer, isn&apos;t it?"><y>#</y><d>2020-03-02</d><h>04:57</h><w>Vincent Cantin</w>if I understand correctly, the most natural way to implement the equivalent of spec/conform and spec/unform in Malli is to use a Transformer, isn&apos;t it?</z><z id="t1583160132" t="ikitommi are you interested in the branching information from s/conform ?"><y>#</y><d>2020-03-02</d><h>14:42</h><r>ikitommi</r>are you interested in the branching information from <code>s/conform</code>?</z><z id="t1583160195" t="Vincent Cantin yes, totally. I need it for my Vrac project."><y>#</y><d>2020-03-02</d><h>14:43</h><r>Vincent Cantin</r>yes, totally. I need it for my Vrac project.</z><z id="t1583160262" t="ikitommi Currently, there is no such thing. But one idea was that the m/explain also collected the explain info from the successfully validated values."><y>#</y><d>2020-03-02</d><h>14:44</h><r>ikitommi</r>Currently, there is no such thing. But one idea was that the <code>m/explain</code> also collected the explain info from the successfully validated values.</z><z id="t1583160316" t="ikitommi … that would contain all the needed branching information and could be used to produce “humanized” result like the one s/conform does."><y>#</y><d>2020-03-02</d><h>14:45</h><r>ikitommi</r>… that would contain all the needed branching information and could be used to produce “humanized” result like the one <code>s/conform</code> does.</z><z id="t1583160363" t="ikitommi also, would be easy to “unform” that as all the locations and values already exist there."><y>#</y><d>2020-03-02</d><h>14:46</h><r>ikitommi</r>also, would be easy to “unform” that as all the locations and values already exist there.</z><z id="t1583160653" t="Vincent Cantin I am not totally convinced that the function explain should also be used for s/conform. The implementation might be similar, but explain and conform have different purposes."><y>#</y><d>2020-03-02</d><h>14:50</h><r>Vincent Cantin</r>I am not totally convinced that the function explain should also be used for s/conform. The implementation might be similar, but explain and conform have different purposes.</z><z id="t1583160707" t="Vincent Cantin That’s why I was wondering if it would be better to have a separate function for that, maybe via a Transformer."><y>#</y><d>2020-03-02</d><h>14:51</h><r>Vincent Cantin</r>That’s why I was wondering if it would be better to have a separate function for that, maybe via a Transformer.</z><z id="t1583160744" t="Vincent Cantin I did not finish to play with Malli, not sure if the Transformer pattern is suitable for those 2 functions."><y>#</y><d>2020-03-02</d><h>14:52</h><r>Vincent Cantin</r>I did not finish to play with Malli, not sure if the Transformer pattern is suitable for those 2 functions.</z><z id="t1583160957" t="ikitommi you should be able to do that with a transformer"><y>#</y><d>2020-03-02</d><h>14:55</h><r>ikitommi</r>you should be able to do that with a transformer</z><z id="t1583141541" t="borkdude Enjoyed the presentation, thanks!"><y>#</y><d>2020-03-02</d><h>09:32</h><w>borkdude</w>Enjoyed the presentation, thanks!</z><z id="t1583144640" t="orestis I browsed the slides - is the Kondo integration a vision for the future or does it work today already? I’m super excited!"><y>#</y><d>2020-03-02</d><h>10:24</h><w>orestis</w>I browsed the slides - is the Kondo integration a vision for the future or does it work today already? I’m super excited!</z><z id="t1583161377" t="ikitommi it was a 15min hack to check if that would work and it did! I just emitted a lint.edn which the fn description in the form clj-kondo understands it and hard-wired clj-kondo to read that file. I think there is betters ways to do this automatically. The m/defn is also not finished, but will be a 1:1 port from plumatic schema so cursive knows that too. Might take few (dev) days to get them cleaned up and pushed to master for testing."><y>#</y><d>2020-03-02</d><h>15:02</h><r>ikitommi</r>it was a 15min hack to check if that would work and it did! I just emitted a <code>lint.edn</code> which the fn description in the form clj-kondo understands it and hard-wired clj-kondo to read that file. I think there is betters ways to do this automatically. The <code>m/defn</code> is also not finished, but will be a 1:1 port from plumatic schema so cursive knows that too. Might take few (dev) days to get them cleaned up and pushed to master for testing.</z><z id="t1583172037" t="orestis Super cool! I’ve wanted to generate specs for GraphQL input objects which are closed maps, and being able to statically analyze functions that consume them. Looks like this might be possible soon!"><y>#</y><d>2020-03-02</d><h>18:00</h><r>orestis</r>Super cool! I’ve wanted to generate specs for GraphQL input objects which are closed maps, and being able to statically analyze functions that consume them. Looks like this might be possible soon!</z><z id="t1583172121" t="orestis Oh and I could probably also annotate React components that consume GraphQL..."><y>#</y><d>2020-03-02</d><h>18:02</h><r>orestis</r>Oh and I could probably also annotate React components that consume GraphQL...</z><z id="t1583154198" t="teodorlu Thanks for the great talk on ClojureD, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2020-03-02</d><h>13:03</h><w>teodorlu</w>Thanks for the great talk on ClojureD, <a>@ikitommi</a>!</z><z id="t1583154322" t="teodorlu I stumbled over an article that I figured people here might find interesting: QuickREST: Property-based Test Generation of OpenAPI-Described RESTful APIs The article discusses generating Clojure specs from OpenAPI specifications, and running generative testing against those. With Malli, I figure that process might become even simpler. https://arxiv.org/pdf/1912.09686.pdf"><y>#</y><d>2020-03-02</d><h>13:05</h><w>teodorlu</w>I stumbled over an article that I figured people here might find interesting:

QuickREST: Property-based Test Generation of OpenAPI-Described RESTful APIs

The article discusses generating Clojure specs from OpenAPI specifications, and running generative testing against those. With Malli, I figure that process might become even simpler.

<a href="https://arxiv.org/pdf/1912.09686.pdf" target="_blank">https://arxiv.org/pdf/1912.09686.pdf</a></z><z id="t1583161010" t="ikitommi Conform/unform using explain would look something like this: (def Schema [:map [:a [:or pos-int? string?]] [:b string?]]) (m/explain Schema {:a 42, :&quot;a&quot;}) ;{:schema [:map ; [:a [:or pos-int? string?]] ; [:b string?]] ; :value {:a 42, :&quot;a&quot;}, ; :results [#Success{:path [1 1 1], :in [:a], :schema pos-int?, :value 42} ; #Success{:path [2 1], :in [:b], :schema string?, :value &quot;a&quot;}]} (-&gt; Schema (m/explain {:a 42 :b &quot;a&quot;}) (me/humanize)) ;{:a #Branch{1 42} ; :b &quot;a&quot;}"><y>#</y><d>2020-03-02</d><h>14:56</h><w>ikitommi</w>Conform/unform using explain would look something like this:
<pre>(def Schema
  [:map
   [:a [:or pos-int? string?]]
   [:b string?]])

(m/explain Schema {:a 42, :&quot;a&quot;})
;{:schema [:map
;          [:a [:or pos-int? string?]]
;          [:b string?]]
; :value {:a 42, :&quot;a&quot;},
; :results [#Success{:path [1 1 1], :in [:a], :schema pos-int?, :value 42}
;           #Success{:path [2 1], :in [:b], :schema string?, :value &quot;a&quot;}]}

(-&gt; Schema
    (m/explain {:a 42 :b &quot;a&quot;})
    (me/humanize))
;{:a #Branch{1 42}
; :b &quot;a&quot;}</pre></z><z id="t1583161435" t="Vincent Cantin in my use case with spec, I encountered a few times the need to apply custom transformations during s/conform , that’s also why I would think that a Transformer would be better if it can be easily customized to produce the format I want in one pass."><y>#</y><d>2020-03-02</d><h>15:03</h><w>Vincent Cantin</w>in my use case with spec, I encountered a few times the need to apply custom transformations during <code>s/conform</code> , that’s also why I would think that a Transformer would be better if it can be easily customized to produce the format I want in one pass.</z><z id="t1583161460" t="ikitommi [:attrs {:href &quot;/_/_/users/U3X7174KS&quot;}] looks interesting. need to read that when extra time."><y>#</y><d>2020-03-02</d><h>15:04</h><w>ikitommi</w><a>@teodorlu</a> looks interesting. need to read that when extra time.</z><z id="t1583161546" t="ikitommi yeah, transformers give you the single pass. looking forward to seeing if that helps over spec."><y>#</y><d>2020-03-02</d><h>15:05</h><w>ikitommi</w>yeah, transformers give you the single pass. looking forward to seeing if that helps over spec.</z><z id="t1583169483" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] the :keys doesn’t work with :ret values with clj-kondo yet?"><y>#</y><d>2020-03-02</d><h>17:18</h><w>ikitommi</w><a>@borkdude</a> the <code>:keys</code> doesn’t work with <code>:ret</code> values with clj-kondo yet?</z><z id="t1583169500" t="ikitommi on :args it seems to work, which is awesome 🙂"><y>#</y><d>2020-03-02</d><h>17:18</h><w>ikitommi</w>on <code>:args</code> it seems to work, which is awesome <b>🙂</b></z><z id="t1583169557" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] what :ret type are you using?"><y>#</y><d>2020-03-02</d><h>17:19</h><w>borkdude</w><a>@ikitommi</a> what <code>:ret</code> type are you using?</z><z id="t1583169671" t="ikitommi {:args [{:op :keys :req {:a {:op :keys :req {:b {:op :keys :req {:c :int}}}}}}] :ret {:op :keys :req {:b {:op :keys :req {:c :int}}}}}"><y>#</y><d>2020-03-02</d><h>17:21</h><r>ikitommi</r><pre>{:args [{:op :keys
         :req {:a {:op :keys
                   :req {:b {:op :keys
                             :req {:c :int}}}}}}]
 :ret {:op :keys
       :req {:b {:op :keys
                 :req {:c :int}}}}}</pre></z><z id="t1583169723" t="borkdude I don&apos;t think that&apos;s supported yet. As a fallback you can use :tag :map for now and post an issue about it."><y>#</y><d>2020-03-02</d><h>17:22</h><r>borkdude</r>I don&apos;t think that&apos;s supported yet. As a fallback you can use <code>:tag :map</code> for now and post an issue about it.</z><z id="t1583169748" t="borkdude maybe it works when you add :tag :map in that same map you pass to :ret now, so you can keep the code the same when it gets fixed?"><y>#</y><d>2020-03-02</d><h>17:22</h><r>borkdude</r>maybe it works when you add <code>:tag :map</code> in that same map you pass to <code>:ret</code> now, so you can keep the code the same when it gets fixed?</z><z id="t1583169905" t="ikitommi will write an issue, the :tag :map makes it a map, but the keys are not followed, at least (:a my-fn) succeed despite the ret says there is no such key"><y>#</y><d>2020-03-02</d><h>17:25</h><r>ikitommi</r>will write an issue, the <code>:tag :map</code> makes it a map, but the keys are not followed, at least <code>(:a my-fn)</code> succeed despite the ret says there is no such key</z><z id="t1583169938" t="borkdude thanks"><y>#</y><d>2020-03-02</d><h>17:25</h><r>borkdude</r>thanks</z><z id="t1583171942" t="ikitommi kinda bad explanation, but https://github.com/borkdude/clj-kondo/issues/783"><y>#</y><d>2020-03-02</d><h>17:59</h><r>ikitommi</r>kinda bad explanation, but <a href="https://github.com/borkdude/clj-kondo/issues/783" target="_blank">https://github.com/borkdude/clj-kondo/issues/783</a></z><z id="t1583337394" t="plexus I vaguely remember talk at ClojuTRE about generating forms / UI based on Malli. Has anyone tried something like that? Any interesting pointers?"><y>#</y><d>2020-03-04</d><h>15:56</h><w>plexus</w>I vaguely remember talk at ClojuTRE about generating forms / UI based on Malli. Has anyone tried something like that? Any interesting pointers?</z><z id="t1583340789" t="zilti Yea that is something I am highly interested in finding out"><y>#</y><d>2020-03-04</d><h>16:53</h><r>zilti</r>Yea that is something I am highly interested in finding out</z><z id="t1583347038" t="ikitommi generating UIs - there are many ways to do that: 1. walk the malli schema and emit an ui-application out of that, did a quick hack of that in a project, reagent + antd 2. walk the malli schema and emit an ui-schema out of that, to be rendered somehow 3. have both malli schema (“the model”) and an ui-schema (“the layout”) and use them together to generate the ui"><y>#</y><d>2020-03-04</d><h>18:37</h><w>ikitommi</w>generating UIs - there are many ways to do that:
1. walk the malli schema and emit an ui-application out of that, did a quick hack of that in a project, reagent + antd 
2. walk the malli schema and emit an ui-schema out of that, to be rendered somehow
3. have both malli schema (“the model”) and an ui-schema (“the layout”) and use them together to generate the ui</z><z id="t1583347189" t="ikitommi in 1 &amp; 2, the malli.visitor needs 1-2 extra args to be usefull: all walked schemas should know their place in the schema (e.g. the :in in explain) and in the data (the :path ). This enables the ui-elements to be standalone, the ui-component knows where in the app-state the data needs to be stored."><y>#</y><d>2020-03-04</d><h>18:39</h><w>ikitommi</w>in 1 &amp; 2, the <code>malli.visitor</code> needs 1-2 extra args to be usefull: all walked schemas should know their place in the schema (e.g. the <code>:in</code> in explain) and in the data (the <code>:path</code>). This enables the ui-elements to be standalone, the ui-component knows where in the app-state the data needs to be stored.</z><z id="t1583347222" t="ikitommi I used formik-style custom helper to get the usability-stuff done right, dirty form state etc."><y>#</y><d>2020-03-04</d><h>18:40</h><w>ikitommi</w>I used formik-style custom helper to get the usability-stuff done right, dirty form state etc.</z><z id="t1583347264" t="ikitommi but, nothing Ready now, if someone has time and skills at making awesome forms, happy to help with that."><y>#</y><d>2020-03-04</d><h>18:41</h><w>ikitommi</w>but, nothing Ready now, if someone has time and skills at making awesome forms, happy to help with that.</z><z id="t1583347363" t="ikitommi there is https://domino-clj.github.io/ , idea was that it’s own model could be swapped with malli (just need a protocol to abstract the model and make malli-domino wrapper). It has also a graph-engine to calculate values &amp; other cool features."><y>#</y><d>2020-03-04</d><h>18:42</h><w>ikitommi</w>there is <a href="https://domino-clj.github.io/" target="_blank">https://domino-clj.github.io/</a>, idea was that it’s own model could be swapped with malli (just need a protocol to abstract the model and make <code>malli-domino</code> wrapper). It has also a graph-engine to calculate values &amp; other cool features.</z><z id="t1583347556" t="ikitommi checked the js-side form generators last year, some good things to learn from there, e.g. https://github.com/rjsf-team/react-jsonschema-form &amp; https://jsonforms.io/"><y>#</y><d>2020-03-04</d><h>18:45</h><w>ikitommi</w>checked the js-side form generators last year, some good things to learn from there, e.g. <a href="https://github.com/rjsf-team/react-jsonschema-form" target="_blank">https://github.com/rjsf-team/react-jsonschema-form</a> &amp; <a href="https://jsonforms.io/" target="_blank">https://jsonforms.io/</a></z><z id="t1583347909" t="ikitommi in my ad-hoc generator, had ui-hints as properties like this: [:and {:ui/label &quot;arvostelu&quot;, :ui/type :rate} int?]"><y>#</y><d>2020-03-04</d><h>18:51</h><w>ikitommi</w>in my ad-hoc generator, had ui-hints as properties like this: <code>[:and {:ui/label &quot;arvostelu&quot;, :ui/type :rate} int?]</code></z><z id="t1583347939" t="ikitommi emitting a https://ant.design/components/rate/"><y>#</y><d>2020-03-04</d><h>18:52</h><r>ikitommi</r>emitting a <a href="https://ant.design/components/rate/" target="_blank">https://ant.design/components/rate/</a></z><z id="t1583390251" t="ikitommi https://github.com/metosin/malli/pull/184 &lt;-- adding the :in to visitor, :path not needed."><y>#</y><d>2020-03-05</d><h>06:37</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/184" target="_blank">https://github.com/metosin/malli/pull/184</a> &lt;-- adding the <code>:in</code> to visitor, <code>:path</code> not needed.</z><z id="t1583390285" t="ikitommi fxed :path with :multi schema: https://github.com/metosin/malli/pull/185"><y>#</y><d>2020-03-05</d><h>06:38</h><w>ikitommi</w>fxed <code>:path</code> with <code>:multi</code> schema: <a href="https://github.com/metosin/malli/pull/185" target="_blank">https://github.com/metosin/malli/pull/185</a></z><z id="t1583390359" t="ikitommi"><y>#</y><d>2020-03-05</d><h>06:39</h><w>ikitommi</w></z><z id="t1583390453" t="ikitommi as with sequencial schemas, we don’t know the actual index of the value, so added just a placeholder “value here” using :malli.core/in marker. Comments welcome on that."><y>#</y><d>2020-03-05</d><h>06:40</h><w>ikitommi</w>as with sequencial schemas, we don’t know the actual index of the value, so added just a placeholder “value here” using <code>:malli.core/in</code> marker. Comments welcome on that.</z><z id="t1583390694" t="ikitommi another options would be to: 1. use -1 , e.g. temp-id like in datomic 2. use 0 , the first index"><y>#</y><d>2020-03-05</d><h>06:44</h><w>ikitommi</w>another options would be to:
1. use <code>-1</code>, e.g. temp-id like in datomic
2. use <code>0</code>, the first index</z><z id="t1583395035" t="eskos re: Form generation based on malli discussed yesterday, I’ve been thinking that since malli has the capability, it could be interesting to provide the entire form with the validator functions from backend - in projects I’ve been eg. translations for error messages are managed on the backend services anyway, so generating a full-blown “form scheme” with not just what the desired data structure is but also how it’s validated and what the translations and help texts, labels etc. are in various languages and whatever else could actually be the most interesting usability wise. This approach would of course mean doing some extra heavy lifting as binding this data would mean the UI component (think React) would need to have indirection to the path to data (both read and updates) instead of being instanced directly with the data, but that is a better architecture anyway. This was discussed in some conference last year, I’ll try to find a link…"><y>#</y><d>2020-03-05</d><h>07:57</h><w>eskos</w>re: Form generation based on malli discussed yesterday, I’ve been thinking that since malli has the capability, it could be interesting to provide the entire form with the validator functions from backend - in projects I’ve been eg. translations for error messages are managed on the backend services anyway, so generating a full-blown “form scheme” with not just what the desired data structure is but also how it’s validated and what the translations and help texts, labels etc. are in various languages and whatever else could actually be the most interesting usability wise.

This approach would of course mean doing some extra heavy lifting as binding this data would mean the UI component (think React) would need to have indirection to the path to data (both read and updates) instead of being instanced directly with the data, but that is a better architecture anyway. This was discussed in some conference last year, I’ll try to find a link…</z><z id="t1583396490" t="eskos For the life of me I can’t find the post/talk. Anyway it was mostly just a suggestion that 1. have global state (eg. re-frame’s db ) 2. all components should know only the path to their data in the state (`[:foo :went :to :bar]`) 3. all updates to data is done to that same path What my caffeinated flow of mind above tried to convey was that with this pattern having the malli data to be mounted to some path in semi-generic fashion would allow instancing the form components quite nicely as well 🙂"><y>#</y><d>2020-03-05</d><h>08:21</h><w>eskos</w>For the life of me I can’t find the post/talk. Anyway it was mostly just a suggestion that
1. have global state (eg. re-frame’s <code>db</code>)
2. all components should know only the path to their data in the state (`[:foo :went :to :bar]`)
3. all updates to data is done to that same path
What my caffeinated flow of mind above tried to convey was that with this pattern having the malli data to be mounted to some path in semi-generic fashion would allow instancing the form components quite nicely as well <b>🙂</b></z></g><g id="s3"><z id="t1583396664" t="ikitommi did you check my code snipplet from above? allows to add the path to data…"><y>#</y><d>2020-03-05</d><h>08:24</h><w>ikitommi</w>did you check my code snipplet from above? allows to add the path to data…</z><z id="t1583396759" t="ikitommi ui-components need to know how to handle sequences and :map-of s, e.g. need to generate / retain indexes for the elementes. for nested maps &amp; tuples, the path can be fully calculated forehand."><y>#</y><d>2020-03-05</d><h>08:25</h><w>ikitommi</w>ui-components need to know how to handle sequences and <code>:map-of</code>s, e.g. need to generate / retain indexes for the elementes. for nested maps &amp; tuples, the path can be fully calculated forehand.</z><z id="t1583397396" t="eskos Yes, now that I re-read that I think we’re at least in the same ballpark with how it should be."><y>#</y><d>2020-03-05</d><h>08:36</h><w>eskos</w>Yes, now that I re-read that I think we’re at least in the same ballpark with how it should be.</z><z id="t1583397450" t="eskos got me thinking, does malli handle seq keys for maps? 😅 there’s this one terrible API I saw recently which returned data like this {[:foo :bar] :baz [:more] :stuff}"><y>#</y><d>2020-03-05</d><h>08:37</h><w>eskos</w>got me thinking, does malli handle seq keys for maps? <b>😅</b> there’s this one terrible API I saw recently which returned data like this <code>{[:foo :bar] :baz [:more] :stuff}</code></z><z id="t1583398334" t="ikitommi what other ways there are to handle seq keys than to use seqs like in the example?"><y>#</y><d>2020-03-05</d><h>08:52</h><w>ikitommi</w>what other ways there are to handle seq keys than to use seqs like in the example?</z><z id="t1583398416" t="eskos The first step is to make sure that is even parsed correctly 🙂 afaik python/ruby/php can’t even read that in"><y>#</y><d>2020-03-05</d><h>08:53</h><w>eskos</w>The first step is to make sure that is even parsed correctly <b>🙂</b> afaik python/ruby/php can’t even read that in</z><z id="t1583398458" t="eskos (why am I on the weird side of this industry all the time…)"><y>#</y><d>2020-03-05</d><h>08:54</h><w>eskos</w>(why am I on the weird side of this industry all the time…)</z><z id="t1583398621" t="eskos Anyway, the biggest concern with that is that correct validator is matched per key which actually a sequence; in my laziness I made that example uniform while in practice it probably wouldn’t be."><y>#</y><d>2020-03-05</d><h>08:57</h><w>eskos</w>Anyway, the biggest concern with that is that correct validator is matched per key which actually a sequence; in my laziness I made that example uniform while in practice it probably wouldn’t be.</z><z id="t1583488955" t="teodorlu Just pasted a huge JSON sequence into https://malli.io and got a nice, readable schema out, with optional values, sequences and everything in place. What a pleasure! Thanks! 🙏"><y>#</y><d>2020-03-06</d><h>10:02</h><w>teodorlu</w>Just pasted a huge JSON sequence into <a href="https://malli.io" target="_blank">https://malli.io</a> and got a nice, readable schema out, with optional values, sequences and everything in place.

What a pleasure! Thanks! <b>🙏</b></z><z id="t1583489084" t="mike_ananev Hi! I&apos;m trying to mu/merge two specs [:map ...] and [:multi ... ]. Why I always have only one of them in a result? Is there any examples?"><y>#</y><d>2020-03-06</d><h>10:04</h><w>mike_ananev</w>Hi! I&apos;m trying to mu/merge two specs [:map ...] and [:multi ... ]. Why I always have only one of them in a result? Is there any examples?</z><z id="t1583489338" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] they are of different types and the last one wins (like with clojure.core/merge )"><y>#</y><d>2020-03-06</d><h>10:08</h><w>ikitommi</w><a>@mike1452</a> they are of different types and the last one wins (like with <code>clojure.core/merge</code>)</z><z id="t1583489365" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanx."><y>#</y><d>2020-03-06</d><h>10:09</h><w>mike_ananev</w><a>@ikitommi</a> thanx.</z><z id="t1583489366" t="ikitommi but, the merge is far from perfect, not sure what happens if one merges two multis for example."><y>#</y><d>2020-03-06</d><h>10:09</h><w>ikitommi</w>but, the merge is far from perfect, not sure what happens if one merges two multis for example.</z><z id="t1583489415" t="ikitommi i would assume that they get merged together, but not sure if the impl has a special condition just for :map (should be for MapSchema s, which both multi and map are)"><y>#</y><d>2020-03-06</d><h>10:10</h><w>ikitommi</w>i would assume that they get merged together, but not sure if the impl has a special condition just for <code>:map</code> (should be for <code>MapSchema</code>s, which both multi and map are)</z><z id="t1583489466" t="ikitommi … with that change, could actually merge those togerher. not sure if that’s a good idea thou :thinking_face:"><y>#</y><d>2020-03-06</d><h>10:11</h><w>ikitommi</w>… with that change, could actually merge those togerher. not sure if that’s a good idea thou <b>:thinking_face:</b></z><z id="t1583489487" t="mike_ananev another question: when I generate multi spec, why I have random values in dispatch type instead of those values that in multi spec? (def mumap [:multi {:dispatch :db/shared-channel} [&quot;folder&quot; [:map [:db/shared-channel string?] [:db/shared-channel-folder string?]]] [&quot;web&quot; [:map [:db/shared-channel string?] [:db/shared-channel-url string?]]]]) "><y>#</y><d>2020-03-06</d><h>10:11</h><w>mike_ananev</w>another question: when I generate multi spec, why I have random values in dispatch type instead of those values that in multi spec?
<pre>(def mumap
  [:multi {:dispatch :db/shared-channel}
   [&quot;folder&quot; [:map [:db/shared-channel string?] [:db/shared-channel-folder string?]]]
   [&quot;web&quot; [:map [:db/shared-channel string?] [:db/shared-channel-url string?]]]])</pre>
</z><z id="t1583489532" t="mike_ananev instead of &quot;folder&quot; and &quot;web&quot; in shared channel i have random values. I expect only these two values"><y>#</y><d>2020-03-06</d><h>10:12</h><w>mike_ananev</w>instead of &quot;folder&quot; and &quot;web&quot; in shared channel  i have random values. I expect only these two values</z><z id="t1583489555" t="ikitommi the generator is picked from the multi branch, which doesn’t limit the key."><y>#</y><d>2020-03-06</d><h>10:12</h><w>ikitommi</w>the generator is picked from the multi branch, which doesn’t limit the key.</z><z id="t1583489574" t="ikitommi try: [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]]"><y>#</y><d>2020-03-06</d><h>10:12</h><w>ikitommi</w>try:
<pre>[:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]]</pre></z><z id="t1583489643" t="mike_ananev It helps, thanks!"><y>#</y><d>2020-03-06</d><h>10:14</h><w>mike_ananev</w>It helps, thanks!</z><z id="t1583489687" t="ikitommi as the dispatch can be anything, it’s non-trivial to use the branch name in a generator automatically"><y>#</y><d>2020-03-06</d><h>10:14</h><w>ikitommi</w>as the dispatch can be anything, it’s non-trivial to use the branch name in a generator automatically</z><z id="t1583491165" t="mike_ananev I have data structure in which first half is always the same and second half is multi-spec based on :db/shared-channel value (def sample1 {:db/type &quot;h2&quot;, :h2/user &quot;sa&quot;, :h2/filename &quot;./boxdb&quot;, :db/shared-channel &quot;folder&quot;, :db/shared-channel-folder &quot;dev/resources/shared&quot;}) (def sample2 {:db/type &quot;h2&quot;, :h2/user &quot;sa&quot;, :h2/filename &quot;./boxdb&quot;, :db/shared-channel &quot;web&quot;, :db/shared-channel-url &quot;&quot;}) "><y>#</y><d>2020-03-06</d><h>10:39</h><w>mike_ananev</w>I have data structure in which first half is always the same and second half is multi-spec based on :db/shared-channel value
<pre>(def sample1 {:db/type                  &quot;h2&quot;,
              :h2/user                  &quot;sa&quot;,
              :h2/filename              &quot;./boxdb&quot;,

              :db/shared-channel        &quot;folder&quot;,
              :db/shared-channel-folder &quot;dev/resources/shared&quot;})

(def sample2 {:db/type               &quot;h2&quot;,
              :h2/user               &quot;sa&quot;,
              :h2/filename           &quot;./boxdb&quot;,

              :db/shared-channel     &quot;web&quot;,
              :db/shared-channel-url &quot;&quot;})</pre>
</z><z id="t1583491197" t="mike_ananev I did multi spec (def mumap [:multi {:dispatch :db/shared-channel} [&quot;folder&quot; [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?] [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]] [:h2/filename {:default &quot;./boxdb&quot;} string?] [:h2/user {:default &quot;sa&quot;} string?]]] [&quot;web&quot; [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-url string?] [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]] [:h2/filename {:default &quot;./boxdb&quot;} string?] [:h2/user {:default &quot;sa&quot;} string?]]]]) "><y>#</y><d>2020-03-06</d><h>10:39</h><w>mike_ananev</w>I did multi spec
<pre>(def mumap
  [:multi {:dispatch :db/shared-channel}
   [&quot;folder&quot; [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]
              [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]]
              [:h2/filename {:default &quot;./boxdb&quot;} string?]
              [:h2/user {:default &quot;sa&quot;} string?]]]
   [&quot;web&quot; [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-url string?]
           [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]]
           [:h2/filename {:default &quot;./boxdb&quot;} string?]
           [:h2/user {:default &quot;sa&quot;} string?]]]])</pre>
</z><z id="t1583491235" t="mike_ananev Question: how to avoid duplication of first half? (merge is not work like in spec1)"><y>#</y><d>2020-03-06</d><h>10:40</h><w>mike_ananev</w>Question: how to avoid duplication of first half? (merge is not work like in spec1)</z><z id="t1583492201" t="mike_ananev I need something like: [:map [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]] [:h2/filename {:default &quot;./boxdb&quot;} string?] [:h2/user {:default &quot;sa&quot;} string?] [:multi {:dispatch :db/shared-channel} [&quot;folder&quot; [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]]] [&quot;web&quot; [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-web string?]]]]] "><y>#</y><d>2020-03-06</d><h>10:56</h><w>mike_ananev</w>I need something like:
<pre>[:map
 [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]]
 [:h2/filename {:default &quot;./boxdb&quot;} string?]
 [:h2/user {:default &quot;sa&quot;} string?]
 [:multi {:dispatch :db/shared-channel}
  [&quot;folder&quot; [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]]]
  [&quot;web&quot; [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-web string?]]]]]</pre>
</z><z id="t1583492341" t="ikitommi many ways to do that, one would be to create a basemap, and merge that in all branches: (def BaseMap [:map [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]] [:h2/filename {:default &quot;./boxdb&quot;} string?] [:h2/user {:default &quot;sa&quot;} string?]]) (def Multi [:multi {:dispatch :db/shared-channel} [&quot;folder&quot; (mu/merge BaseMap [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]])] [&quot;web&quot; (mu/merge BaseMap [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-web string?]]])]]) "><y>#</y><d>2020-03-06</d><h>10:59</h><w>ikitommi</w>many ways to do that, one would be to create a basemap, and merge that in all branches:
<pre>(def BaseMap
  [:map
   [:db/type [:and string? [:fn {:error/message &quot;should not be empty string&quot;} not-empty-string?]]]
   [:h2/filename {:default &quot;./boxdb&quot;} string?]
   [:h2/user {:default &quot;sa&quot;} string?]])

(def Multi
  [:multi {:dispatch :db/shared-channel}
    [&quot;folder&quot; (mu/merge BaseMap [:map [:db/shared-channel [:= &quot;folder&quot;]] [:db/shared-channel-folder string?]])]
    [&quot;web&quot; (mu/merge BaseMap [:map [:db/shared-channel [:= &quot;web&quot;]] [:db/shared-channel-web string?]]])]])</pre>
</z><z id="t1583492386" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] 👍"><y>#</y><d>2020-03-06</d><h>10:59</h><w>mike_ananev</w><a>@ikitommi</a> <b>👍</b></z><z id="t1583492457" t="ikitommi the oldest non-resolved issue in malli: https://github.com/metosin/malli/issues/14"><y>#</y><d>2020-03-06</d><h>11:00</h><w>ikitommi</w>the oldest non-resolved issue in malli: <a href="https://github.com/metosin/malli/issues/14" target="_blank">https://github.com/metosin/malli/issues/14</a></z><z id="t1583492515" t="ikitommi kinda like select in spec2."><y>#</y><d>2020-03-06</d><h>11:01</h><w>ikitommi</w>kinda like <code>select</code> in spec2.</z><z id="t1583493478" t="teodorlu https://malli.io seems to fail to infer the schema of values containing instants. Example value: {:some-date #inst &quot;2020-02-02&quot;} Is this expected behavior?"><y>#</y><d>2020-03-06</d><h>11:17</h><w>teodorlu</w><a href="https://malli.io" target="_blank">https://malli.io</a> seems to fail to infer the schema of values containing instants. Example value:

<pre>{:some-date #inst &quot;2020-02-02&quot;}</pre>
Is this expected behavior?</z><z id="t1583493752" t="ikitommi I would not expect that. from a repl: (require &apos;[malli.provider :as mp]) (mp/provide [{:some-date #inst &quot;2020-02-02&quot;}]) ; =&gt; [:map [:some-date inst?]]"><y>#</y><d>2020-03-06</d><h>11:22</h><w>ikitommi</w>I would not expect that. from a repl:
<pre>(require &apos;[malli.provider :as mp])

(mp/provide [{:some-date #inst &quot;2020-02-02&quot;}])
; =&gt; [:map [:some-date inst?]]</pre></z><z id="t1583494237" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] for https://github.com/metosin/malli/issues/180 , do we want to also add support for :+ :* :? and some other operators? in the :cat driven sequence?"><y>#</y><d>2020-03-06</d><h>11:30</h><w>Vincent Cantin</w><a>@ikitommi</a> for <a href="https://github.com/metosin/malli/issues/180" target="_blank">https://github.com/metosin/malli/issues/180</a>, do we want to also add support for <code>:+ :* :?</code>  and some other operators? in the <code>:cat</code> driven sequence?</z><z id="t1583494289" t="Vincent Cantin I hope to start this issue if I have some time this weekend."><y>#</y><d>2020-03-06</d><h>11:31</h><w>Vincent Cantin</w>I hope to start this issue if I have some time this weekend.</z><z id="t1583494340" t="ikitommi that would be awesome!"><y>#</y><d>2020-03-06</d><h>11:32</h><w>ikitommi</w>that would be awesome!</z><z id="t1583494367" t="Vincent Cantin (if I have time)"><y>#</y><d>2020-03-06</d><h>11:32</h><w>Vincent Cantin</w>(if I have time)</z><z id="t1583494385" t="ikitommi did an intial spike, using the net.cgrand/seqexp , something like:"><y>#</y><d>2020-03-06</d><h>11:33</h><w>ikitommi</w>did an intial spike, using the <code>net.cgrand/seqexp</code> , something like:</z><z id="t1583494397" t="ikitommi (def registry (merge default-registry {:cat (cat-schema :cat) :| (cat-schema :|) :* (regex-schema :* se/*) :*? (regex-schema : se/*?) :+ (regex-schema :+ se/+) :+? (regex-schema :+? se/+?) :? (regex-schema :? se/?) :?? (regex-schema :?? se/??) :repeat (regex-schema :repeat? se/repeat) :repeat? (regex-schema :repeat? se/repeat?)}))"><y>#</y><d>2020-03-06</d><h>11:33</h><w>ikitommi</w><pre>(def registry
  (merge
    default-registry
    {:cat (cat-schema :cat)
     :| (cat-schema :|)
     :* (regex-schema :* se/*)
     :*? (regex-schema : se/*?)
     :+ (regex-schema :+ se/+)
     :+? (regex-schema :+? se/+?)
     :? (regex-schema :? se/?)
     :?? (regex-schema :?? se/??)
     :repeat (regex-schema :repeat? se/repeat)
     :repeat? (regex-schema :repeat? se/repeat?)}))</pre></z><z id="t1583494419" t="ikitommi didn’t get very far thou."><y>#</y><d>2020-03-06</d><h>11:33</h><w>ikitommi</w>didn’t get very far thou.</z><z id="t1583494422" t="Vincent Cantin Could you push this to a branch ?"><y>#</y><d>2020-03-06</d><h>11:33</h><w>Vincent Cantin</w>Could you push this to a branch ?</z><z id="t1583494710" t="ikitommi actually, that’s about it. here are the codes I was playing with: (require &apos;[net.cgrand.seqexp :as se]) (se/exec (se/cat (se/as :x int?) (se/as :y int?) (se/as :rest2 (se/* string?))) [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ; {:rest (), :match (1 2 &quot;kikka&quot; &quot;kukka&quot;), :x (1), :y (2), :rest2 (&quot;kikka&quot; &quot;kukka&quot;)} [:cat [:x int?] [:y int?] [:rest [:* string?]]] (se/exec-tree (se/cat (se/* (se/as [:opts] (se/cat (se/as [:opts :x] string?) (se/| (se/as [:opts :s] string?) (se/as [:opts :b] boolean?)))))) [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;]) (se/exec (se/cat (se/as :x (se/repeat 1 int?)) (se/as :y int?) (se/as :restz (se/* string?))) [1 2 &quot;kikka&quot; &quot;kukka&quot;]) ; {:rest (), :match (1 2 &quot;kikka&quot; &quot;kukka&quot;), :x (1), :y (2)} (se/* (se/as [:sections] (se/cat :h1 (se/as [:sections :ps] (se/+ :p)))))"><y>#</y><d>2020-03-06</d><h>11:38</h><r>ikitommi</r>actually, that’s about it. here are the codes I was playing with:
<pre>(require &apos;[net.cgrand.seqexp :as se])

(se/exec
  (se/cat
    (se/as :x int?)
    (se/as :y int?)
    (se/as :rest2 (se/* string?)))
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
; {:rest (), :match (1 2 &quot;kikka&quot; &quot;kukka&quot;), :x (1), :y (2), :rest2 (&quot;kikka&quot; &quot;kukka&quot;)}

[:cat
 [:x int?]
 [:y int?]
 [:rest [:* string?]]]

(se/exec-tree
  (se/cat
    (se/*
      (se/as [:opts]
             (se/cat
               (se/as [:opts :x] string?)
               (se/| (se/as [:opts :s] string?) (se/as [:opts :b] boolean?))))))
  [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;])

(se/exec
  (se/cat
    (se/as :x (se/repeat 1 int?))
    (se/as :y int?)
    (se/as :restz (se/* string?)))
  [1 2 &quot;kikka&quot; &quot;kukka&quot;])
; {:rest (), :match (1 2 &quot;kikka&quot; &quot;kukka&quot;), :x (1), :y (2)}

(se/*
  (se/as [:sections]
         (se/cat :h1
                 (se/as [:sections :ps]
                        (se/+ :p)))))</pre></z><z id="t1583494740" t="Vincent Cantin thank you"><y>#</y><d>2020-03-06</d><h>11:39</h><r>Vincent Cantin</r>thank you</z><z id="t1583494740" t="ikitommi just updated https://github.com/cgrand/seqexp/issues/11 , which is about using seqexp here"><y>#</y><d>2020-03-06</d><h>11:39</h><r>ikitommi</r>just updated <a href="https://github.com/cgrand/seqexp/issues/11" target="_blank">https://github.com/cgrand/seqexp/issues/11</a>, which is about using seqexp here</z><z id="t1583494757" t="ikitommi not going to do anything for this for now, so all yours 🙂"><y>#</y><d>2020-03-06</d><h>11:39</h><r>ikitommi</r>not going to do anything for this for now, so all yours <b>🙂</b></z><z id="t1583494767" t="Vincent Cantin I will start by writing tests"><y>#</y><d>2020-03-06</d><h>11:39</h><r>Vincent Cantin</r>I will start by writing tests</z><z id="t1583494785" t="Vincent Cantin .. then the implementation to make them pass"><y>#</y><d>2020-03-06</d><h>11:39</h><r>Vincent Cantin</r>.. then the implementation to make them pass</z><z id="t1583495062" t="ikitommi 👍"><y>#</y><d>2020-03-06</d><h>11:44</h><r>ikitommi</r><b>👍</b></z><z id="t1583494466" t="ikitommi sure, doesn’t do anything thou"><y>#</y><d>2020-03-06</d><h>11:34</h><w>ikitommi</w>sure, doesn’t do anything thou</z><z id="t1583494744" t="borkdude why not just &quot;steal&quot; the impl from spec?"><y>#</y><d>2020-03-06</d><h>11:39</h><w>borkdude</w>why not just &quot;steal&quot; the impl from spec?</z><z id="t1583494783" t="teodorlu Using malli.provider/provide does the trick! Thanks. I was surprised by what happened when I forgot to provide a sequence: (mp/provide {:some-date #inst &quot;2020-02-02&quot;}) ;; =&gt; [:vector some?] com.github.metosin/malli {:git/url &quot;&quot; :sha &quot;9db4ff998b641d4a0cff4eb6d772fd0cb5d3b56c&quot;}"><y>#</y><d>2020-03-06</d><h>11:39</h><w>teodorlu</w>Using <code>malli.provider/provide</code> does the trick! Thanks.

I was surprised by what happened when I forgot to provide a sequence:

<pre>(mp/provide {:some-date #inst &quot;2020-02-02&quot;})
;; =&gt; [:vector some?]</pre>
<pre>com.github.metosin/malli {:git/url &quot;&quot;
                            :sha &quot;9db4ff998b641d4a0cff4eb6d772fd0cb5d3b56c&quot;}</pre></z><z id="t1583583951" t="ikitommi Maps turn into sequences in Clojure, so it’s a sequence of a vector of keyword? and inst? , which both are some? (seq {:some-date #inst &quot;2020-02-02&quot;}) ;; =&gt; ([:some-date #inst&quot;2020-02-02T00:00:00.000-00:00&quot;])"><y>#</y><d>2020-03-07</d><h>12:25</h><r>ikitommi</r>Maps turn into sequences in Clojure, so it’s a sequence of a vector of <code>keyword?</code> and <code>inst?</code> , which both are <code>some?</code>
<pre>(seq {:some-date #inst &quot;2020-02-02&quot;})
;; =&gt; ([:some-date #inst&quot;2020-02-02T00:00:00.000-00:00&quot;])</pre></z><z id="t1583841354" t="teodorlu Ah, that makes sense. Thanks."><y>#</y><d>2020-03-10</d><h>11:55</h><r>teodorlu</r>Ah, that makes sense. Thanks.</z><z id="t1583494861" t="ikitommi taking the impl from spec is always an option."><y>#</y><d>2020-03-06</d><h>11:41</h><w>ikitommi</w>taking the impl from spec is always an option.</z><z id="t1583494968" t="ikitommi last time I checked, the regexs where implemented using regular hashmaps in spec, would need at least some wrapping, don’t want to reserve maps for any one schema (family) type."><y>#</y><d>2020-03-06</d><h>11:42</h><w>ikitommi</w>last time I checked, the regexs where implemented using regular hashmaps in spec, would need at least some wrapping, don’t want to reserve maps for any one schema (family) type.</z><z id="t1583495040" t="ikitommi grand’s lib is 6y+ old, so “prior art” for this and all libs by Christophe have been great, also perf)."><y>#</y><d>2020-03-06</d><h>11:44</h><w>ikitommi</w>grand’s lib is 6y+ old, so “prior art” for this and all libs by Christophe have been great, also perf).</z><z id="t1583495069" t="borkdude ok"><y>#</y><d>2020-03-06</d><h>11:44</h><w>borkdude</w>ok</z><z id="t1583582558" t="ikitommi added a contrinbution guide, 95% copy from reitit: https://github.com/metosin/malli/pull/186"><y>#</y><d>2020-03-07</d><h>12:02</h><w>ikitommi</w>added a contrinbution guide, 95% copy from reitit: <a href="https://github.com/metosin/malli/pull/186" target="_blank">https://github.com/metosin/malli/pull/186</a></z><z id="t1583669164" t="Vincent Cantin Request for comments on https://github.com/metosin/malli/pull/187"><y>#</y><d>2020-03-08</d><h>12:06</h><w>Vincent Cantin</w>Request for comments on <a href="https://github.com/metosin/malli/pull/187" target="_blank">https://github.com/metosin/malli/pull/187</a></z><z id="t1583720205" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] https://github.com/cgrand/seqexp will need some adjustments if we want to use it in Malli: • Its implementation is not cross platform. • The maps returned by se/exec contain the keyed groups in the middle of :rest and :match , that could be a problem when the keys of those groups are controlled by Malli’s users."><y>#</y><d>2020-03-09</d><h>02:16</h><w>Vincent Cantin</w><a>@ikitommi</a> <a href="https://github.com/cgrand/seqexp" target="_blank">https://github.com/cgrand/seqexp</a> will need some adjustments if we want to use it in Malli:
• Its implementation is not cross platform.
• The maps returned by <code>se/exec</code> contain the keyed groups in the middle of <code>:rest</code> and <code>:match</code> , that could be a problem when the keys of those groups are controlled by Malli’s users.</z><z id="t1583734562" t="ikitommi [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] ok. The cross-platform should be doable, ig Cristophe takes PRS (there should be an issue about that), not sure about the second. If that is not a good base lib to use, do you have plans on using something else? or from scratch?"><y>#</y><d>2020-03-09</d><h>06:16</h><w>ikitommi</w><a>@vincent.cantin</a> ok. The cross-platform should be doable, ig Cristophe takes PRS (there should be an issue about that), not sure about the second. If that is not a good base lib to use, do you have plans on using something else? or from scratch?</z><z id="t1583735585" t="Vincent Cantin I started to scratch my head about a new impl this morning. What&apos;s next depends on what features we want to offer the users."><y>#</y><d>2020-03-09</d><h>06:33</h><w>Vincent Cantin</w>I started to scratch my head about a new impl this morning. What&apos;s next depends on what features we want to offer the users.</z><z id="t1583735718" t="ikitommi just commented on the issue"><y>#</y><d>2020-03-09</d><h>06:35</h><w>ikitommi</w>just commented on the issue</z><z id="t1583735848" t="Vincent Cantin I think that an optimized &amp; naive impl might be faster on most use cases compared to a general algorith that works in theory faster and cover all edge cases. I would like to put them to a benchmark on realworld usages."><y>#</y><d>2020-03-09</d><h>06:37</h><w>Vincent Cantin</w>I think that an optimized &amp; naive impl might be faster on most use cases compared to a general algorith that works in theory faster and cover all edge cases.

I would like to put them to a benchmark on realworld usages.</z><z id="t1583742393" t="ikitommi What kind of edge cases would not be covered using a naive impl? Benchmarks most welcome!"><y>#</y><d>2020-03-09</d><h>08:26</h><r>ikitommi</r>What kind of edge cases would not be covered using a naive impl? Benchmarks most welcome!</z><z id="t1583808699" t="Vincent Cantin All the use cases would be covered by using a naive impl. Some edge cases might have a high computational cost in a naive impl while a smarter impl would mitigate the cost of their parsing. The edge cases I am thinking about are consecutive sequences of variable length. But I am not sure if it is a real concern or my imagination."><y>#</y><d>2020-03-10</d><h>02:51</h><r>Vincent Cantin</r>All the use cases would be covered by using a naive impl. Some edge cases might have a high computational cost in a naive impl while a smarter impl would mitigate the cost of their parsing.

The edge cases I am thinking about are consecutive sequences of variable length. But I am not sure if it is a real concern or my imagination.</z><z id="t1583736500" t="ikitommi did a quick draft of a swappable default registry: idea that the default registry could be bootstrapped into something that satisifes m/Registry protocol. There could be malli.mutable with an alternative impl using a extra atom to look for the schemas and malli.mutable/register! to register schemas into that. This would be a simple -&gt; easy helper, already not happy with that. Comments welcome https://github.com/metosin/malli/pull/188"><y>#</y><d>2020-03-09</d><h>06:48</h><w>ikitommi</w>did a quick draft of a swappable default registry: idea that the default registry could be bootstrapped into something that satisifes <code>m/Registry</code> protocol. There could be <code>malli.mutable</code> with an alternative impl using a extra atom to look for the schemas and <code>malli.mutable/register!</code>to register schemas into that. This would be a simple -&gt; easy helper, already not happy with that. Comments welcome <a href="https://github.com/metosin/malli/pull/188" target="_blank">https://github.com/metosin/malli/pull/188</a></z><z id="t1583765091" t="ikitommi ;; JVM started with -Dmalli.core.registry=malli.mutable/registry (require &apos;[malli.core :as m]) (require &apos;[malli.mutable :as mm]) (mm/register! ::age [:and int? [:&gt; 18]]) (m/validate ::age 20) ; =&gt; true"><y>#</y><d>2020-03-09</d><h>14:44</h><r>ikitommi</r><pre>;; JVM started with -Dmalli.core.registry=malli.mutable/registry

(require &apos;[malli.core :as m])
(require &apos;[malli.mutable :as mm])

(mm/register! ::age [:and int? [:&gt; 18]])

(m/validate ::age 20)
; =&gt; true</pre></z><z id="t1583765121" t="ikitommi 🙈"><y>#</y><d>2020-03-09</d><h>14:45</h><r>ikitommi</r><b>🙈</b></z><z id="t1583807615" t="Vincent Cantin I also don’t like the idea to lose the property of working with immutable values."><y>#</y><d>2020-03-10</d><h>02:33</h><r>Vincent Cantin</r>I also don’t like the idea to lose the property of working with immutable values.</z><z id="t1583807958" t="Vincent Cantin I would suggest users who don’t want to have to pass the registry as option to Malli all the time to just create their own wrapper functions. ;; in my-ns (defn validate [schema data options] (m/validate schema data (assoc options :registry my-registry))) "><y>#</y><d>2020-03-10</d><h>02:39</h><r>Vincent Cantin</r>I would suggest users who don’t want to have to pass the registry as option to Malli all the time to just create their own wrapper functions.

<pre>;; in my-ns
(defn validate [schema data options]
  (m/validate schema data (assoc options :registry my-registry)))</pre>
</z><z id="t1583808163" t="Vincent Cantin I was facing the same situation in projects which use Vrac, and I used the wrapper pattern everywhere. It’s really not a big deal and it keep the satisfaction of working in an environment where we don’t even have to think about the side effects."><y>#</y><d>2020-03-10</d><h>02:42</h><r>Vincent Cantin</r>I was facing the same situation in projects which use Vrac, and I used the wrapper pattern everywhere. It’s really not a big deal and it keep the satisfaction of working in an environment where we don’t even have to think about the side effects.</z><z id="t1583740595" t="eskos Is cross-platform regex even possible? Beyond basics I don’t think JS/Java/C# regex engines are even close to compatible with each other."><y>#</y><d>2020-03-09</d><h>07:56</h><w>eskos</w>Is cross-platform regex even possible? Beyond basics I don’t think JS/Java/C# regex engines are even close to compatible with each other.</z><z id="t1583744566" t="Vincent Cantin we are talking about validating data structures, not string content."><y>#</y><d>2020-03-09</d><h>09:02</h><r>Vincent Cantin</r>we are talking about validating data structures, not string content.</z><z id="t1583744596" t="eskos :thinking_face:"><y>#</y><d>2020-03-09</d><h>09:03</h><r>eskos</r><b>:thinking_face:</b></z><z id="t1583749493" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] see https://clojure.org/guides/spec#_sequences"><y>#</y><d>2020-03-09</d><h>10:24</h><r>ikitommi</r><a>@U8SFC8HLP</a> see <a href="https://clojure.org/guides/spec#_sequences" target="_blank">https://clojure.org/guides/spec#_sequences</a></z><z id="t1583749680" t="eskos Right, thank you. I got confused, quite obviously 🙂"><y>#</y><d>2020-03-09</d><h>10:28</h><r>eskos</r>Right, thank you. I got confused, quite obviously <b>🙂</b></z><z id="t1583780014" t="shaunxcode are recursive schemas possible w/ malli?"><y>#</y><d>2020-03-09</d><h>18:53</h><w>shaunxcode</w>are recursive schemas possible w/ malli?</z><z id="t1583780065" t="shaunxcode e.g. defining a schema for a {:name &quot;something&quot; :kids [{:name &quot;something&quot; :kids [....]}]}"><y>#</y><d>2020-03-09</d><h>18:54</h><w>shaunxcode</w>e.g. defining a schema for a <code>{:name &quot;something&quot; :kids [{:name &quot;something&quot; :kids [....]}]}</code></z><z id="t1583780114" t="shaunxcode it does appear such things are possible in spec: https://gist.github.com/bhb/6cfcb3b38757442aec4ba5db46148699"><y>#</y><d>2020-03-09</d><h>18:55</h><w>shaunxcode</w>it does appear such things are possible in spec: <a href="https://gist.github.com/bhb/6cfcb3b38757442aec4ba5db46148699" target="_blank">https://gist.github.com/bhb/6cfcb3b38757442aec4ba5db46148699</a></z><z id="t1583780920" t="ikitommi [:attrs {:href &quot;/_/_/users/U07EV8R70&quot;}] not yet, see https://github.com/metosin/malli/issues/20"><y>#</y><d>2020-03-09</d><h>19:08</h><w>ikitommi</w><a>@shaunxcode</a> not yet, see <a href="https://github.com/metosin/malli/issues/20" target="_blank">https://github.com/metosin/malli/issues/20</a></z><z id="t1583781102" t="shaunxcode sorry just reading the whole of that linked issue and I see you guys are putting a lot of thought and effort into your approach so I will wait and see!"><y>#</y><d>2020-03-09</d><h>19:11</h><w>shaunxcode</w>sorry just reading the whole of that linked issue and I see you guys are putting a lot of thought and effort into your approach so I will wait and see!</z><z id="t1583787037" t="zilti I am about to start to try generating Malli schemas from PostgreSQL metadata. Very curious how far I can take this. If I find a way to store additional custom metadata in the database, I could end up generating 90% of a form simply by converting Postgres metadata, the rest being the layout."><y>#</y><d>2020-03-09</d><h>20:50</h><w>zilti</w>I am about to start to try generating Malli schemas from PostgreSQL metadata. Very curious how far I can take this. If I find a way to store additional custom metadata in the database, I could end up generating 90% of a form simply by converting Postgres metadata, the rest being the layout.</z><z id="t1583914428" t="eskos Just curious, what kind of metadata you mean? PostgreSQL’s information schema is already quite extensive…"><y>#</y><d>2020-03-11</d><h>08:13</h><r>eskos</r>Just curious, what kind of metadata you mean? PostgreSQL’s information schema is already quite extensive…</z><z id="t1583928183" t="beders I have some code that does the same. I wasn&apos;t able to find a good solution for restricting string length. Maybe that has changed in the meantime."><y>#</y><d>2020-03-11</d><h>12:03</h><r>beders</r>I have some code that does the same. I wasn&apos;t able to find a good solution for restricting string length. Maybe that has changed in the meantime.</z><z id="t1583932013" t="eskos In PostgreSQL `TEXT` is string with infinite length (_=&lt;https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F|1GB&gt; because that is any field’s maximum size_); string with specific maximum should be done with `VARCHAR` columns in which case `information_schema.columns` `character_maximum_length` has the column’s size limit information."><y>#</y><d>2020-03-11</d><h>13:06</h><r>eskos</r>In PostgreSQL `TEXT` is string with infinite length (_=&lt;https://wiki.postgresql.org/wiki/FAQ#What_is_the_maximum_size_for_a_row.2C_a_table.2C_and_a_database.3F|1GB&gt; because that is any field’s maximum size_); string with specific maximum should be done with `VARCHAR` columns in which case `information_schema.columns` `character_maximum_length` has the column’s size limit information.</z><z id="t1583932051" t="eskos Assuming I’ve understood correctly, I seem to have a lousy track record on that part this week… 🙂"><y>#</y><d>2020-03-11</d><h>13:07</h><r>eskos</r>Assuming I’ve understood correctly, I seem to have a lousy track record on that part this week… <b>🙂</b></z><z id="t1584000229" t="viesti The JDBC API also offers metadata, but probable less than direct PostgreSQL use. Prior art in spec land: • https://github.com/tatut/specql • https://github.com/viesti/table-spec"><y>#</y><d>2020-03-12</d><h>08:03</h><r>viesti</r>The JDBC API also offers metadata, but probable less than direct PostgreSQL use. Prior art in spec land:

• <a href="https://github.com/tatut/specql" target="_blank">https://github.com/tatut/specql</a>
• <a href="https://github.com/viesti/table-spec" target="_blank">https://github.com/viesti/table-spec</a></z><z id="t1584000239" t="viesti [:attrs {:href &quot;/_/_/users/U2APCNHCN&quot;}] the specql implementation might be really good help in looking what postgresql offers"><y>#</y><d>2020-03-12</d><h>08:03</h><r>viesti</r><a>@U2APCNHCN</a> the specql implementation might be really good help in looking what postgresql offers</z><z id="t1584003490" t="eskos JDBC https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html is very extensive, haven’t tested but it seems with https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html#getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String) COLUMN_SIZE has the maximum length; the same TEXT/VARCHAR size detail as described above of course still applies."><y>#</y><d>2020-03-12</d><h>08:58</h><r>eskos</r>JDBC <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html</a> is very extensive, haven’t tested but it seems with <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html#getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)" target="_blank">https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/DatabaseMetaData.html#getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)</a> <code>COLUMN_SIZE</code> has the maximum length; the same TEXT/VARCHAR size detail as described above of course still applies.</z><z id="t1584029384" t="viesti yup, although I have a feeling that it might lack info on postgresql specific extensions"><y>#</y><d>2020-03-12</d><h>16:09</h><r>viesti</r>yup, although I have a feeling that it might lack info on postgresql specific extensions</z><z id="t1584037077" t="zilti Yes, DatabaseMetaData is what I currently use. My showstopper right now is that I can&apos;t get the data transformations to work..."><y>#</y><d>2020-03-12</d><h>18:17</h><r>zilti</r>Yes, DatabaseMetaData is what I currently use. My showstopper right now is that I can&apos;t get the data transformations to work...</z><z id="t1584037106" t="zilti I haven&apos;t heard of specql so far, but I will give it a look"><y>#</y><d>2020-03-12</d><h>18:18</h><r>zilti</r>I haven&apos;t heard of specql so far, but I will give it a look</z><z id="t1584085150" t="eskos Might be just me but if I were doing something very product specific, I’d steer far away from any kind of abstraction and just go as raw and bare in as possible… 🙂"><y>#</y><d>2020-03-13</d><h>07:39</h><r>eskos</r>Might be just me but if I were doing something very product specific, I’d steer far away from any kind of abstraction and just go as raw and bare in as possible… <b>🙂</b></z><z id="t1584095148" t="zilti Well I think the problem wih going as raw and bare as possible is that you lose all the flexibility. And we&apos;re going to need that flexibility. My competition for creating forms are airtable and typeform. And I&apos;d prefer we don&apos;t use either of those for our product"><y>#</y><d>2020-03-13</d><h>10:25</h><r>zilti</r>Well I think the problem wih going as raw and bare as possible is that you lose all the flexibility. And we&apos;re going to need that flexibility. My competition for creating forms are airtable and typeform. And I&apos;d prefer we don&apos;t use either of those for our product</z><z id="t1584360530" t="teodorlu Quickly model your tables with malli.provider/provide . Works well with JSON columns -- malli finds a specification that works with all your data. (-&gt;&gt; (with-open [conn (jdbc/get-connection db-datasource)] (jdbc.sql/query conn [&quot;select * from myschema.mytable&quot;])) (malli.provider/provide)) [:map [:mytable/id int?] [:mytable/name string?]]"><y>#</y><d>2020-03-16</d><h>12:08</h><w>teodorlu</w>Quickly model your tables with <code>malli.provider/provide</code>. Works well with JSON columns -- malli finds a specification that works with all your data.

<pre>(-&gt;&gt; (with-open [conn (jdbc/get-connection db-datasource)]
         (jdbc.sql/query conn [&quot;select * from myschema.mytable&quot;]))
       (malli.provider/provide))
  [:map
   [:mytable/id int?]
   [:mytable/name string?]]</pre></z><z id="t1584700581" t="eskos General consensus on whether this should work or not? (require &apos;[malli.util :as mu]) (mu/get-in [:map [keyword? int?]] [:a]) ;=&gt; returns nil, but I expected int? I have nested maps with a few generic bits (my use case doesn’t allow composing schemas from reusable parts, yet) and noticed this behavior. Considering it’s supposed to mirror https://clojuredocs.org/clojure.core/get-in in functionality I’m hesitant to call this a bug, just wondering out loud… 🙂"><y>#</y><d>2020-03-20</d><h>10:36</h><w>eskos</w>General consensus on whether this should work or not?
<pre>(require &apos;[malli.util :as mu])
(mu/get-in [:map [keyword? int?]] [:a])
;=&gt; returns nil, but I expected int?</pre>
I have nested maps with a few generic bits (my use case doesn’t allow composing schemas from reusable parts, yet) and noticed this behavior. Considering it’s supposed to mirror <a href="https://clojuredocs.org/clojure.core/get-in" target="_blank">https://clojuredocs.org/clojure.core/get-in</a> in functionality I’m hesitant to call this a bug, just wondering out loud… <b>🙂</b></z><z id="t1584701611" t="ikitommi (m/validate [:map [keyword? int?]] {:a 1}) ; =&gt; false (m/validate [:map [keyword? int?]] {keyword? 1}) ; =&gt; true"><y>#</y><d>2020-03-20</d><h>10:53</h><w>ikitommi</w><pre>(m/validate [:map [keyword? int?]] {:a 1})
; =&gt; false

(m/validate [:map [keyword? int?]] {keyword? 1})
; =&gt; true</pre></z><z id="t1584701624" t="ikitommi do you mean :map-of here?"><y>#</y><d>2020-03-20</d><h>10:53</h><w>ikitommi</w>do you mean <code>:map-of</code> here?</z><z id="t1584703324" t="eskos Hm, I think I broke something else in the process as well… a moment 🙂"><y>#</y><d>2020-03-20</d><h>11:22</h><w>eskos</w>Hm, I think I broke something else in the process as well… a moment <b>🙂</b></z><z id="t1584703435" t="eskos Yes indeed, :map-of"><y>#</y><d>2020-03-20</d><h>11:23</h><w>eskos</w>Yes indeed, <code>:map-of</code></z><z id="t1584703514" t="eskos This of course changes the nature of the error, although I’m still not willing to call this a bug; I’m kind of hoping for magic which obviously isn’t there… :) =&gt; (mu/get-in [:map-of keyword? int?] [:a]) Execution error (IllegalArgumentException) at malli.core/fn$G (core.cljc:26). No implementation of method: :-get of protocol: #&apos;malli.core/LensSchema found for class: malli.core$_map_of_schema$reify$reify__692 "><y>#</y><d>2020-03-20</d><h>11:25</h><w>eskos</w>This of course changes the nature of the error, although I’m still not willing to call this a bug; I’m kind of hoping for magic which obviously isn’t there… :)
<pre>=&gt; (mu/get-in [:map-of keyword? int?] [:a])
Execution error (IllegalArgumentException) at malli.core/fn$G (core.cljc:26).
No implementation of method: :-get of protocol: #&apos;malli.core/LensSchema found for class: malli.core$_map_of_schema$reify$reify__692</pre>
</z><z id="t1584709294" t="ikitommi would you like to do a PR of making :map-of implement the LensSchema protocol?"><y>#</y><d>2020-03-20</d><h>13:01</h><w>ikitommi</w>would you like to do a PR of making <code>:map-of</code> implement the <code>LensSchema</code> protocol?</z><z id="t1584716045" t="eskos So had a quick stab at it, -get is literally just (-get [_ key default] (if (key-valid? key) value-schema default)) but -set is a lot harder as semantically it doesn’t really make sense as the result should probably be some kind of weirdo map schema, eg. (mu/assoc [:map-of keyword? int?] :foo boolean?) ;=&gt; should probably create [:or [:map [:foo boolean?]] [:map-of keyword? int?]] and that wouldn’t work for subsequent calls, assoc-in etc… One way to do this would be to allow :map to have default validators for kv pairs, effectively :map-of within :map , but that’s way too much work and decisions to do at this point of week 😅"><y>#</y><d>2020-03-20</d><h>14:54</h><r>eskos</r>So had a quick stab at it, -get is literally just
<pre>(-get [_ key default] (if (key-valid? key) value-schema default))</pre>
but <code>-set</code> is a lot harder as semantically it doesn’t really make sense as the result should probably be some kind of weirdo map schema, eg.
<pre>(mu/assoc [:map-of keyword? int?] :foo boolean?)
;=&gt; should probably create
[:or
 [:map [:foo boolean?]]
 [:map-of keyword? int?]]</pre>
and that wouldn’t work for subsequent calls, <code>assoc-in</code> etc…

One way to do this would be to allow <code>:map</code> to have default validators for kv pairs, effectively <code>:map-of</code> within <code>:map</code>, but that’s way too much work and decisions to do at this point of week <b>😅</b></z><z id="t1584779955" t="eskos Coming back to this, would it make sense to have it as an option for open maps that one could specify default k/v validators for :map schema? This way the -get could work if the given validator matches and -set would switch the default k/v validator to whatever is given if it doesn&apos;t match any of the actual keys."><y>#</y><d>2020-03-21</d><h>08:39</h><r>eskos</r>Coming back to this, would it make sense to have it as an option for open maps that one could specify default k/v validators for <code>:map</code> schema? This way the <code>-get</code> could work if the given validator matches and <code>-set</code> would switch the default k/v validator to whatever is given if it doesn&apos;t match any of the actual keys.</z><z id="t1584711745" t="eskos Hmm, I could take a look at it at least. Haven’t delved into malli code base that much yet so no promises on that side but what the hey, it’s not like I’d have any other places to be… 😄"><y>#</y><d>2020-03-20</d><h>13:42</h><w>eskos</w>Hmm, I could take a look at it at least. Haven’t delved into malli code base that much yet so no promises on that side but what the hey, it’s not like I’d have any other places to be… <b>😄</b></z><z id="t1584711864" t="ikitommi maybe we should do a form-heavy work project together and finalize all the things 😉"><y>#</y><d>2020-03-20</d><h>13:44</h><w>ikitommi</w>maybe we should do a form-heavy work project together and finalize all the things <b>😉</b></z><z id="t1584775522" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Clojure spec’s cat is doing 2 things at the same time and I don’t like that: • It says something about the container type of the sequence, • It says something about the content of the sequence. In Malli, I propose to move the description on the type of container to a separate structure schema name and to remove this responsibility from :cat and :alt . Maybe we can have something like: [:cat [:a int?] [:b :string?]] ;; matches &apos;(1 &quot;a&quot;) and [1 &quot;a&quot;] [:in-list [:cat [:a int?] [:b :string?]]] ;; matches &apos;(1 &quot;a&quot;) [:in-vector [:cat [:a int?] [:b :string?]]] ;; matches &apos;[1 &quot;a&quot;]"><y>#</y><d>2020-03-21</d><h>07:25</h><w>Vincent Cantin</w><a>@ikitommi</a> Clojure spec’s <code>cat</code> is doing 2 things at the same time and I don’t like that:
• It says something about the container type of the sequence,
• It says something about the content of the sequence.
In Malli, I propose to move the description on the type of container to a separate structure schema name and to remove this responsibility from <code>:cat</code> and <code>:alt</code> .

Maybe we can have something like:
<pre>[:cat [:a int?] [:b :string?]]              ;; matches &apos;(1 &quot;a&quot;) and [1 &quot;a&quot;]
[:in-list [:cat [:a int?] [:b :string?]]]   ;; matches &apos;(1 &quot;a&quot;)
[:in-vector [:cat [:a int?] [:b :string?]]] ;; matches &apos;[1 &quot;a&quot;]</pre></z><z id="t1585202242" t="ikitommi [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] I guess you can say already [:and vector? [:cat ...]]"><y>#</y><d>2020-03-26</d><h>05:57</h><r>ikitommi</r><a>@U8MJBRSR5</a> I guess you can say already <code>[:and vector? [:cat ...]]</code></z><z id="t1584776068" t="Vincent Cantin or we can call them seq-of list-of and vector-of"><y>#</y><d>2020-03-21</d><h>07:34</h><w>Vincent Cantin</w>or we can call them <code>seq-of</code> <code>list-of</code>  and <code>vector-of</code></z><z id="t1584776686" t="Vincent Cantin I am preparing a commit in my MR, on which we can comment later."><y>#</y><d>2020-03-21</d><h>07:44</h><w>Vincent Cantin</w>I am preparing a commit in my MR, on which we can comment later.</z><z id="t1584856775" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What is the reason Malli use [:map [:x int?] [:y int?]] instead of [:map :x int? :y int?] ?"><y>#</y><d>2020-03-22</d><h>05:59</h><w>Vincent Cantin</w><a>@ikitommi</a> What is the reason Malli use <code>[:map [:x int?] [:y int?]]</code>  instead of <code>[:map :x int? :y int?]</code> ?</z><z id="t1584856829" t="Vincent Cantin (I am asking for :map because I am wondering the same for :cat and :alt )"><y>#</y><d>2020-03-22</d><h>06:00</h><w>Vincent Cantin</w>(I am asking for <code>:map</code> because I am wondering the same for <code>:cat</code> and <code>:alt</code> )</z><z id="t1584858745" t="mike_ananev I guess that inside [:x int?] you can set many things: customized error message, validation function etc. Without vector[:x int?] expression structure becomes unreadable."><y>#</y><d>2020-03-22</d><h>06:32</h><w>mike_ananev</w>I guess that inside [:x int?] you can set many things: customized error message,  validation function etc. Without vector[:x int?] expression structure becomes unreadable.</z><z id="t1584860109" t="Vincent Cantin Good point."><y>#</y><d>2020-03-22</d><h>06:55</h><w>Vincent Cantin</w>Good point.</z><z id="t1584861137" t="Vincent Cantin I updated the tests for :cat and :alt . Those tests represent the proposal I make for the data format which constitutes the API for this part of Malli. Feedback welcome ! https://github.com/metosin/malli/pull/187/files"><y>#</y><d>2020-03-22</d><h>07:12</h><w>Vincent Cantin</w>I updated the tests for <code>:cat</code> and <code>:alt</code> . Those tests represent the proposal I make for the data format which constitutes the API for this part of Malli.
Feedback welcome ! <a href="https://github.com/metosin/malli/pull/187/files" target="_blank">https://github.com/metosin/malli/pull/187/files</a></z><z id="t1585061630" t="naomarik There a way to use a custom :error/message for :or ? Something like this: [:or {:error/message &quot;nil, string, or int&quot;} nil? string? int?]"><y>#</y><d>2020-03-24</d><h>14:53</h><w>naomarik</w>There a way to use a custom <code>:error/message</code> for <code>:or</code>?
Something like this:
<pre>[:or
 {:error/message &quot;nil, string, or int&quot;}
 nil?
 string?
 int?]</pre></z><z id="t1585202484" t="ikitommi [:attrs {:href &quot;/_/_/users/U0DHHFEDP&quot;}] currently, no. And same applies for adding error messages on map entries. Would we solved with some way to figure out parents: https://github.com/metosin/malli/issues/120"><y>#</y><d>2020-03-26</d><h>06:01</h><w>ikitommi</w><a>@naomarik</a> currently, no. And same applies for adding error messages on map entries. Would we solved with some way to figure out parents: <a href="https://github.com/metosin/malli/issues/120" target="_blank">https://github.com/metosin/malli/issues/120</a></z><z id="t1585202497" t="ikitommi ideas welcome on how to do that."><y>#</y><d>2020-03-26</d><h>06:01</h><w>ikitommi</w>ideas welcome on how to do that.</z><z id="t1585202620" t="ikitommi thought of copying props to childs from map entries and ors, but that would duplicate the info in m/form etc. knowing the parent at runtime would be cleanest way to resolve these."><y>#</y><d>2020-03-26</d><h>06:03</h><w>ikitommi</w>thought of copying props to childs from map entries and ors, but that would duplicate the info in <code>m/form</code> etc. knowing the parent at runtime would be cleanest way to resolve these.</z><z id="t1585313799" t="ikitommi in a project swapping plumatic into malli and I think there should be more built-in schemas for common thigns, strings and dates. Maybe something like: [:string {:min 1, :max 10}] [:int {:min 1, :max 10}] [:date {:min &quot;2012-04-23&quot;}] [:date-time {:min &quot;2012-04-23 00:00:00&quot;, :format &quot;yyyy-MM-dd HH:mm:ss&quot;}] "><y>#</y><d>2020-03-27</d><h>12:56</h><w>ikitommi</w>in a project swapping plumatic into malli and I think there should be more built-in schemas for common thigns, strings and dates. Maybe something like:
<pre>[:string {:min 1, :max 10}]
[:int {:min 1, :max 10}]
[:date {:min &quot;2012-04-23&quot;}]
[:date-time {:min &quot;2012-04-23 00:00:00&quot;, :format &quot;yyyy-MM-dd HH:mm:ss&quot;}] </pre></z><z id="t1585314629" t="eskos Sounds good to me. Maybe some of those should be aliases for other more in-depth schemas, but it’ll help the users a lot if there’s a good collection of those available out of the box."><y>#</y><d>2020-03-27</d><h>13:10</h><w>eskos</w>Sounds good to me. Maybe some of those should be aliases for other more in-depth schemas, but it’ll help the users a lot if there’s a good collection of those available out of the box.</z><z id="t1585315193" t="eskos …huh, even? and odd? are not in the predicate registry. I was about to mention how to something like [:range {:from 0 :to 10 :step 2}] would really be just [:and [:int {:min 0 :max 10}] [:even?]] and thought to check that. Sorry, my mind’s wandering 🙂"><y>#</y><d>2020-03-27</d><h>13:19</h><w>eskos</w>…huh, <code>even?</code> and <code>odd?</code> are not in the predicate registry. I was about to mention how to something like <code>[:range {:from 0 :to 10 :step 2}]</code> would really be just <code>[:and [:int {:min 0 :max 10}] [:even?]]</code> and thought to check that. Sorry, my mind’s wandering <b>🙂</b></z><z id="t1585315728" t="eskos Also pos? neg? seem to be missing. Are these left out on purpose or just forgotten?"><y>#</y><d>2020-03-27</d><h>13:28</h><w>eskos</w>Also <code>pos?</code> <code>neg?</code> seem to be missing. Are these left out on purpose or just forgotten?</z><z id="t1585318552" t="ikitommi the initial set of predicates for taken from clojure.spec, those which have generators defined. no other reason, could be added."><y>#</y><d>2020-03-27</d><h>14:15</h><w>ikitommi</w>the initial set of predicates for taken from clojure.spec, those which have generators defined. no other reason, could be added.</z><z id="t1585318581" t="eskos Righto 🙂"><y>#</y><d>2020-03-27</d><h>14:16</h><w>eskos</w>Righto <b>🙂</b></z><z id="t1585559590" t="teodorlu I just had a pleasant experience during my team&apos;s standup. I&apos;m working on code that depends on some PostgreSQL tables with JSON columns. We&apos;re migrating to a new set of tables given new needs. In that change, we&apos;re also moving some data from within the old JSON structure out into normal table columns. To give insight into my work, I generated schemas for the JSON with malli.provider/provide , and shared the generated malli schemas with my team. Explaining malli took 30 seconds and one example: &quot;Malli is a schema system for JSON.&quot; &quot;This JSON:&quot; {&quot;x&quot;: 1, &quot;name&quot;: &quot;something&quot;} &quot;Gets this schema:&quot; [:map [:x int?] [:name string?]] This resulted in an experienced team member saying &quot;oh, that somePropertyName, I didn&apos;t even know we had those.&quot; Felt great! 🎉"><y>#</y><d>2020-03-30</d><h>09:13</h><w>teodorlu</w>I just had a pleasant experience during my team&apos;s standup. I&apos;m working on code that depends on some PostgreSQL tables with JSON columns. We&apos;re migrating to a new set of tables given new needs. In that change, we&apos;re also moving some data from within the old JSON structure out into normal table columns.

To give insight into my work, I generated schemas for the JSON with <code>malli.provider/provide</code>, and shared the generated malli schemas with my team. Explaining malli took 30 seconds and one example:

<pre>&quot;Malli is a schema system for JSON.&quot;

&quot;This JSON:&quot;

{&quot;x&quot;: 1,
 &quot;name&quot;: &quot;something&quot;}

&quot;Gets this schema:&quot;

[:map
 [:x int?]
 [:name string?]]</pre>
This resulted in an experienced team member saying &quot;oh, that somePropertyName, I didn&apos;t even know we had those.&quot;

Felt great! <b>🎉</b></z><z id="t1585574637" t="pithyless If I want to add a custom tag to the registry, to support something like [:string {:min 1, :max 10}] - do I need to create a brand new IntoSchema (e.g. modeled similarly to m/fn-schema on -leaf-schema but with support for properties) + define a custom mg/-generator ? Or is there some way I can reuse more of the existing malli machinery?"><y>#</y><d>2020-03-30</d><h>13:23</h><w>pithyless</w>If I want to add a custom tag to the registry, to support something like <code>[:string {:min 1, :max 10}]</code> - do I need to create a brand new <code>IntoSchema</code> (e.g. modeled similarly to <code>m/fn-schema</code> on <code>-leaf-schema</code> but with support for properties) + define a custom <code>mg/-generator</code> ? Or is there some way I can reuse more of the existing malli machinery?</z><z id="t1585590938" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] there are not many helpers in the core currently, but reifying the IntoSchema is a good way to do those. I think all the separate concerns (JSONSchema, Generators, Providers etc) should have a supporting protocol so one could easily satisfy all the concerns with one reify-block. Currently requires protocol + set of multimethods. For core stuff, it’s intentional to have the mm’s: the core remains small as it doesn’t have to know much/anythning about the other concerns."><y>#</y><d>2020-03-30</d><h>17:55</h><w>ikitommi</w><a>@pithyless</a> there are not many helpers in the core currently, but reifying the <code>IntoSchema</code> is a good way to do those. I think all the separate concerns (JSONSchema, Generators, Providers etc) should have a supporting protocol so one could easily satisfy all the concerns with one reify-block. Currently requires protocol  + set of multimethods. For core stuff, it’s intentional to have the mm’s: the core remains small as it doesn’t have to know much/anythning about the other concerns.</z><z id="t1585590982" t="ikitommi also, there is a PR for discussion about swapping the default registry - to support spec-like mutable registries."><y>#</y><d>2020-03-30</d><h>17:56</h><w>ikitommi</w>also, there is a PR for discussion about swapping the default registry - to support spec-like mutable registries.</z><z id="t1585591074" t="ikitommi I think if there would be a set of type-kind-of schemas in malli core, one would not need the current core predicates at all. e.g. :string instead of string? , :date-time instead of inst etc."><y>#</y><d>2020-03-30</d><h>17:57</h><w>ikitommi</w>I think if there would be a set of type-kind-of schemas in malli core, one would not need the current core predicates at all. e.g. <code>:string</code> instead of <code>string?</code> , <code>:date-time</code> instead of <code>inst</code> etc.</z><z id="t1585648829" t="eskos I’ve been lately thinking whether malli should adopt git’s porcelain vs plumbing mentality for the schemas, but haven’t drafted anything sensible yet about it. To me there seems to be a lot of cases where the more complex/abstract schema really is just a composition of simpler ones, eg. range is just int with min and max and stepping validation (`[:range {:from 0 :to 10 :step 2}) =&gt; [:and [:int {:min 0 :max 10}] [:fn &apos;(fn [i] (= 0 (mod i 2))]]`) or [:map-of keyword? string?] could be [:map {:default-kv [keyword? string?]}] &amp;lt;- this one doesn’t exist! just an example) etc. but this would require quite a bit of thought on choosing what the base schemas in registries are and what counts as plumbing and what doesn’t… 🙂"><y>#</y><d>2020-03-31</d><h>10:00</h><w>eskos</w>I’ve been lately thinking whether malli should adopt git’s porcelain vs plumbing mentality for the schemas, but haven’t drafted anything sensible yet about it. To me there seems to be a lot of cases where the more complex/abstract schema really is just a composition of simpler ones, eg. range is just int with min and max and stepping validation (`[:range {:from 0 :to 10 :step 2}) =&gt; [:and [:int {:min 0 :max 10}] [:fn &apos;(fn [i] (= 0 (mod i 2))]]`) or <code>[:map-of keyword? string?]</code> could be <code>[:map {:default-kv [keyword? string?]}]</code> &amp;lt;- this one doesn’t exist! just an example) etc. but this would require quite a bit of thought on choosing what the base schemas in registries are and what counts as plumbing and what doesn’t… <b>🙂</b></z><z id="t1585662411" t="teodorlu Vega/Vega Lite does something similar. Vega Lite is high-level data format (for plotting), and compiles down to Vega. https://vega.github.io/vega-lite/"><y>#</y><d>2020-03-31</d><h>13:46</h><r>teodorlu</r>Vega/Vega Lite does something similar. Vega Lite is high-level data format (for plotting), and compiles down to Vega.

<a href="https://vega.github.io/vega-lite/" target="_blank">https://vega.github.io/vega-lite/</a></z><z id="t1585740880" t="mike_ananev What is an idiomatic way to put docstring into spec? via properties?"><y>#</y><d>2020-04-01</d><h>11:34</h><w>mike_ananev</w>What is an idiomatic way to put docstring into spec? via properties?</z><z id="t1585745428" t="teodorlu I suspect that if you want to use Malli for your specs, you might want to model your documentation as pure data too. I&apos;m eager to hear where other people would prefer to store those docstrings."><y>#</y><d>2020-04-01</d><h>12:50</h><w>teodorlu</w>I suspect that if you want to use Malli for your specs, you might want to model your documentation as pure data too. I&apos;m eager to hear where other people would prefer to store those docstrings.</z><z id="t1585746250" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] keys :title and :description are the default keys for docs, but free to use any other keys too."><y>#</y><d>2020-04-01</d><h>13:04</h><w>ikitommi</w><a>@mike1452</a> keys <code>:title</code> and <code>:description</code> are the default keys for docs, but free to use any other keys too.</z><z id="t1585746263" t="ikitommi those keys get pulled into JSON Schema &amp; Swagger Schema docs."><y>#</y><d>2020-04-01</d><h>13:04</h><w>ikitommi</w>those keys get pulled into JSON Schema &amp; Swagger Schema docs.</z><z id="t1585746277" t="ikitommi (and should be used for other documentation too)"><y>#</y><d>2020-04-01</d><h>13:04</h><w>ikitommi</w>(and should be used for other documentation too)</z><z id="t1585838068" t="ikitommi fixed a bug on collection type transformations, which turned maps into vectors. Will push a new SNAPSHOT to clojars as need it with reitit (which uses leiningen)"><y>#</y><d>2020-04-02</d><h>14:34</h><w>ikitommi</w>fixed a bug on collection type transformations, which turned maps into vectors. Will push a new SNAPSHOT to clojars as need it with reitit (which uses leiningen)</z><z id="t1585838072" t="ikitommi https://github.com/metosin/malli/pull/192"><y>#</y><d>2020-04-02</d><h>14:34</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/192" target="_blank">https://github.com/metosin/malli/pull/192</a></z><z id="t1585846551" t="dcj Presumably mailli schema properties are open? So I can specify a (new) key, that I use for my own purposes? Example: assign :postgres/type &quot;some-postgres-type&quot;, later I walk schema and &quot;make it so&quot; via connection to database?"><y>#</y><d>2020-04-02</d><h>16:55</h><w>dcj</w>Presumably mailli schema properties are open?
So I can specify a (new) key, that I use for my own purposes?
Example: assign :postgres/type &quot;some-postgres-type&quot;,  later I walk schema and &quot;make it so&quot; via connection to database?</z><z id="t1585858063" t="dcj Apparently so, a test schema for a database table: (def metadata-schema [:map {:postgres/schema &quot;slm&quot; :postgres/table &quot;measurement_metadatas&quot;} [:id {:postgres/type :bigserial :postgres/key :primary} int?] [:instrument-id {:postgres/type :bigint :postgres/null? false} int?] [:datafile-id {:postgres/type :bigint :postgres/null? false} int?] [:seq {:postgres/type :integer :postgres/null? false} int?] [:origin {:postgres/type :float8 :postgres/null? false} double?] [:scale {:postgres/type :float4 :postgres/null? false} float?] [:starting-timestamp {:postgres/type :timestamptz :postgres/null? false} inst?] ;; TODO: fix [:sample-rate {:postgres/type :float4 :postgres/null? false} float?] [:log-interval {:postgres/type :float4 :postgres/null? false} float?] [:weighting {:postgres/type :text :postgres/null? false} string?] [:manifest {:postgres/type :int :postgres/null? false} int?] [:time-zone {:postgres/type :int :postgres/null? false} int?]]) And, as a quick experiment, wrote fn to print DDL text driven by the above, yielding: CREATE TABLE slm.measurement_metadatas ( id bigserial PRIMARY KEY, instrument_id bigint NOT NULL, datafile_id bigint NOT NULL, seq integer NOT NULL, origin float8 NOT NULL, scale float4 NOT NULL, starting_timestamp timestamptz NOT NULL, sample_rate float4 NOT NULL, log_interval float4 NOT NULL, weighting text NOT NULL, manifest int NOT NULL, time_zone int NOT NULL ); "><y>#</y><d>2020-04-02</d><h>20:07</h><w>dcj</w>Apparently so, a test schema for a database table:
<pre>(def metadata-schema
  [:map {:postgres/schema &quot;slm&quot;
         :postgres/table &quot;measurement_metadatas&quot;}
   [:id {:postgres/type :bigserial
         :postgres/key  :primary} int?]
   [:instrument-id {:postgres/type :bigint
                    :postgres/null? false} int?]
   [:datafile-id   {:postgres/type :bigint
                    :postgres/null? false} int?]
   [:seq           {:postgres/type :integer
                    :postgres/null? false} int?]
   [:origin        {:postgres/type :float8
                    :postgres/null? false} double?]
   [:scale         {:postgres/type :float4
                    :postgres/null? false} float?]
   [:starting-timestamp {:postgres/type :timestamptz
                         :postgres/null? false} inst?] ;; TODO: fix
   [:sample-rate   {:postgres/type :float4
                    :postgres/null? false} float?]
   [:log-interval  {:postgres/type :float4
                    :postgres/null? false} float?]
   [:weighting     {:postgres/type :text
                    :postgres/null? false} string?]
   [:manifest      {:postgres/type :int
                    :postgres/null? false} int?]
   [:time-zone     {:postgres/type :int
                    :postgres/null? false} int?]])</pre>
And, as a quick experiment, wrote fn to print DDL text driven by the above, yielding:
<pre>CREATE TABLE slm.measurement_metadatas (
    id bigserial PRIMARY KEY,
    instrument_id bigint NOT NULL,
    datafile_id bigint NOT NULL,
    seq integer NOT NULL,
    origin float8 NOT NULL,
    scale float4 NOT NULL,
    starting_timestamp timestamptz NOT NULL,
    sample_rate float4 NOT NULL,
    log_interval float4 NOT NULL,
    weighting text NOT NULL,
    manifest int NOT NULL,
    time_zone int NOT NULL
    );</pre>
</z><z id="t1585858331" t="dcj Is there (should there be) a long? predicate in malli?"><y>#</y><d>2020-04-02</d><h>20:12</h><w>dcj</w>Is there (should there be) a <code>long?</code> predicate in malli?</z><z id="t1585874254" t="dcj OK, I have been [:attrs nil] experimenting with Malli most of the day, having lots of fun! I have a bunch of questions: • After creating a new predicate, I want to assoc it into the existing predicate-registry map (creating my own). -register-var and -register are private. Obviously I can copy/paste these functions...suggestions? • Given my metadata-schema above, I want to transform a map via this schema. I get how m/decode is helpful, and I can specify key-transformer but I&apos;m scratching my head about why/how I need to specify specific value transformers eg, string-transformer . Given that my schema has specified the type of each value (eg. int? ), then what I want to say is &quot;coerce whatever you see into the specified type&quot; I get that not all coercions can be pre-defined, and maybe there needs to be a way to add coercions....advice? • Again, given my metadata-schema above, let&apos;s say I want to obtain all the keys of that map schema. The top level form is a schema, and m/children gives me the list of children, but I can&apos;t figure out how to obtain the &quot;name&quot; of each child, without resorting to digging into the current implementation of that vector. In other words, sure I can first each child, but is there some better way to get that info/field? • Similar to the above, say I want to get each key in my map schema transformed in some way. When I want to transform a map, I do this: (m/decode my-schema my-map (mt/key-transformer {:decode csk/-&gt;snake_case_keyword}) because SQL column names are snake_case, but wouldn&apos;t it be better to include that transformer into my schema itself? Maybe I should define a new property at the map level :postgres/key-transformer and I (-&gt; my-schema m/properties :postgres/key-transformer) ? Thoughts? • Similar to the schema navigation/accessor questions above. when I first attempted to write the function to walk the schema and generate the DDL based on the :postgres/ properties, I tried to use m/accept with an function that would look at each [schema properties _] it encountered, but this didn&apos;t work because AFAICT the children are not schemas themselves. Finally I gave up and walked the schema using the obvious vector destructuring, but I don&apos;t feel this the right way to do it..."><y>#</y><d>2020-04-03</d><h>00:37</h><w>dcj</w>OK, I have been <del>yak shaving</del> experimenting with Malli most of the day, having lots of fun!
I have a bunch of questions:
• After creating a new predicate, I want to assoc it into the existing <code>predicate-registry</code> map (creating my own).  <code>-register-var</code> and <code>-register</code> are private.  Obviously I can copy/paste these functions...suggestions?
• Given my <code>metadata-schema</code> above, I want to transform a map via this schema.  I get how <code>m/decode</code> is helpful, and I can specify <code>key-transformer</code> but I&apos;m scratching my head about why/how I need to specify specific value transformers eg, <code>string-transformer</code> . Given that my schema has specified  the type of each value (eg. <code>int?</code> ), then what I want to say is &quot;coerce whatever you see into the specified type&quot;  I get that not all coercions can be pre-defined, and maybe there needs to be a way to add coercions....advice?
• Again, given my <code>metadata-schema</code> above, let&apos;s say I want to obtain all the keys of that map schema.  The top level form is a schema, and <code>m/children</code> gives me the list of children, but I can&apos;t figure out how to obtain the &quot;name&quot; of each child, without resorting to digging into the current implementation of that vector.  In other words, sure I can <code>first</code> each child, but is there some better way to get that info/field?
• Similar to the above, say I want to get each key in my map schema transformed in some way.  When I want to transform a map, I do this: <code>(m/decode  my-schema my-map (mt/key-transformer {:decode csk/-&gt;snake_case_keyword})</code> because SQL column names are snake_case, but wouldn&apos;t it be better to include that transformer into my schema itself?  Maybe I should define a new property at the map level <code>:postgres/key-transformer</code> and I <code>(-&gt; my-schema m/properties :postgres/key-transformer)</code>?  Thoughts?
• Similar to the schema navigation/accessor questions above. when I first attempted to write the function to walk the schema and generate the DDL based on the <code>:postgres/</code> properties, I tried to use <code>m/accept</code> with an function that would look at each <code>[schema properties _]</code> it encountered, but this didn&apos;t work because AFAICT the children are not schemas themselves.  Finally I gave up and walked the schema using the obvious vector destructuring, but I don&apos;t feel this the right way to do it...</z><z id="t1585892047" t="ikitommi • properties are open, there is a bunch of reserved keys (`:title` , :description , :default , :min , :max etc.) and some namespaces that are reserved for extensions (`json-schema`, gen , swagger , encode , decode etc.). Should be documented and I guess a good convention could be “new unqualified might be used by malli in the future, to be safe, use qualified keys to avoid future clashes”. Goal is to describe the properties with malli schemas to get good error reporting on those too"><y>#</y><d>2020-04-03</d><h>05:34</h><w>ikitommi</w>• properties are open, there is a bunch of reserved keys (`:title` , <code>:description</code>,  <code>:default</code>, <code>:min</code>, <code>:max</code> etc.) and some namespaces that are reserved for extensions (`json-schema`, <code>gen</code>, <code>swagger</code>, <code>encode</code>, <code>decode</code> etc.). Should be documented and I guess a good convention could be “new unqualified might be used by malli in the future, to be safe, use qualified keys to avoid future clashes”.  Goal is to describe the properties with malli schemas to get good error reporting on those too</z><z id="t1585892275" t="ikitommi • -register and -register-var could be made non-private, just undocumented. But in the end, it’s just assoc into the map. There is https://github.com/metosin/malli/pull/188 for discussion whether to support mutable registries oob"><y>#</y><d>2020-04-03</d><h>05:37</h><w>ikitommi</w>• <code>-register</code>and <code>-register-var</code> could be made non-private, just undocumented. But in the end, it’s just <code>assoc</code> into the map. There is <a href="https://github.com/metosin/malli/pull/188" target="_blank">https://github.com/metosin/malli/pull/188</a> for discussion whether to support mutable registries oob</z><z id="t1585892458" t="ikitommi • coercions, sorry, didn’t get the question."><y>#</y><d>2020-04-03</d><h>05:40</h><w>ikitommi</w>• coercions, sorry, didn’t get the question.</z><z id="t1585892541" t="ikitommi • all :map schemas implement MapSchema , which allows you to say (m/map-entries schema) to get the entries out"><y>#</y><d>2020-04-03</d><h>05:42</h><w>ikitommi</w>• all <code>:map</code> schemas implement <code>MapSchema</code> , which allows you to say <code>(m/map-entries schema)</code> to get the entries out</z><z id="t1585892964" t="ikitommi • if you want to transform just the entities, you could create a new Transformer , that only mount to :map s which have the :postgres/schema defined, this way, it doesn’t effect all maps. You can add a custom encoder &amp; decoder just like with key-transformer . "><y>#</y><d>2020-04-03</d><h>05:49</h><w>ikitommi</w>• if you want to transform just the entities, you could create a new <code>Transformer</code>, that only mount to <code>:map</code>s which have the <code>:postgres/schema</code> defined, this way, it doesn’t effect all maps. You can add a custom encoder &amp; decoder just like with <code>key-transformer</code>. </z><z id="t1585893403" t="ikitommi • the m/accept … each IntoSchema is responsible for it’s own syntax so walking over schemas requires some knowledge of the schema in question. With maps, children is the sequence of entries, which are tuple3 of key-props-child."><y>#</y><d>2020-04-03</d><h>05:56</h><w>ikitommi</w>• the <code>m/accept</code>… each <code>IntoSchema</code> is responsible for it’s own syntax so walking over schemas requires some knowledge of the schema in question. With maps, <code>children</code> is the sequence of entries, which are tuple3 of key-props-child.</z><z id="t1585893605" t="ikitommi You can run (m/accept Schema m/map-syntax-visitor) to see the structure to be walked. With Java, the Visitor impl would have dispatch methods with different class signatures, with clojure, one can use multimethods for doing schema-based dispatch, see malli.generator or malli.json-schema for examples."><y>#</y><d>2020-04-03</d><h>06:00</h><w>ikitommi</w>You can run <code>(m/accept Schema m/map-syntax-visitor)</code> to see the structure to be walked. With Java, the Visitor impl would have dispatch methods with different class signatures, with clojure, one can use multimethods for doing schema-based dispatch, see <code>malli.generator</code> or <code>malli.json-schema</code> for examples.</z><z id="t1585893667" t="ikitommi Currently, only :map and :multi use custom syntax for it’s contents, later some variants of :or , :cat and :alt too (to support named branches). Could be others."><y>#</y><d>2020-04-03</d><h>06:01</h><w>ikitommi</w>Currently, only <code>:map</code> and <code>:multi</code> use custom syntax for it’s contents, later some variants of <code>:or</code> , <code>:cat</code> and <code>:alt</code> too (to support named branches). Could be others.</z><z id="t1585893778" t="ikitommi There is also m/schema-visitor helper for walking."><y>#</y><d>2020-04-03</d><h>06:02</h><w>ikitommi</w>There is also <code>m/schema-visitor</code> helper for walking.</z><z id="t1585893834" t="ikitommi hope this helps [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}]"><y>#</y><d>2020-04-03</d><h>06:03</h><w>ikitommi</w>hope this helps <a>@dcj</a></z><z id="t1585893904" t="ikitommi the long? predicate… could be, or :long type schema to companion :date-time , :date etc"><y>#</y><d>2020-04-03</d><h>06:05</h><w>ikitommi</w>the <code>long?</code> predicate… could be, or <code>:long</code> type schema to companion <code>:date-time</code>, <code>:date</code> etc</z><z id="t1585893924" t="ikitommi (there is no long? in clojure core, for some reason)"><y>#</y><d>2020-04-03</d><h>06:05</h><w>ikitommi</w>(there is no <code>long?</code> in clojure core, for some reason)</z><z id="t1585894058" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] any plans to release the malli? malli is awesome! without release I clone malli to my projects every month manually."><y>#</y><d>2020-04-03</d><h>06:07</h><w>mike_ananev</w><a>@ikitommi</a> any plans to release the malli? malli is awesome! without release I clone malli to my projects every month manually.</z><z id="t1585894868" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thank you for all the answers/advice/tips, I will try those tomorrow! I will also try to better explain my coercion question, but too tired to do it justice ATM..."><y>#</y><d>2020-04-03</d><h>06:21</h><w>dcj</w><a>@ikitommi</a> Thank you for all the answers/advice/tips, I will try those tomorrow!
I will also try to better explain my coercion question, but too tired to do it justice ATM...</z><z id="t1585899962" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] not going to do that yet, but soon. with deps, you can depend on th the latest commit directly. With Leiningen, there is [metosin/malli &quot;0.0.1-20200305.102752-13&quot;] , could start pushing new SNAPSHOTS after each merge."><y>#</y><d>2020-04-03</d><h>07:46</h><w>ikitommi</w><a>@mike1452</a> not going to do that yet, but soon. with deps, you can depend on th the latest commit directly. With Leiningen, there is <code>[metosin/malli &quot;0.0.1-20200305.102752-13&quot;]</code>, could start pushing new SNAPSHOTS after each merge.</z><z id="t1585900116" t="ikitommi as soon as malli works fully with reitit, could push first alpha. some small hiccups still."><y>#</y><d>2020-04-03</d><h>07:48</h><w>ikitommi</w>as soon as malli works fully with reitit, could push first alpha. some small hiccups still.</z><z id="t1585901762" t="eskos edit: all of this is garbage 🙂 see below [:attrs nil]"><y>#</y><d>2020-04-03</d><h>08:16</h><w>eskos</w>edit: all of this is garbage <b>🙂</b> see below
<del>`long?` predicate might be missing from Clojure due to the original design decision of having transparently coercing number types based on number size (</del></z><z id="t1585902148" t="eskos int? is true for Bytes, Shorts, Integers, Longs, while integer? is true for Integers, Longs, Clojure BigInts, BigIntegers, Shorts and Bytes. I don’t think there’s specifically benefit for checking if value is strictly Long, but YMMV."><y>#</y><d>2020-04-03</d><h>08:22</h><w>eskos</w><code>int?</code> is true for Bytes, Shorts, Integers, Longs, while <code>integer?</code> is true for Integers, Longs, Clojure BigInts, BigIntegers, Shorts and Bytes. I don’t think there’s specifically benefit for checking if value is strictly Long, but YMMV.</z><z id="t1585906972" t="teodorlu Differentiating between Integer and Long would allow generating precise Java source code from a schema"><y>#</y><d>2020-04-03</d><h>09:42</h><w>teodorlu</w>Differentiating between Integer and Long would allow generating precise Java source code from a schema</z><z id="t1585934944" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] m/map-entries and map-schema-entry structure as 3tuple of [key props child] is very helpful. For some reason, it makes me uneasy to just destructure the map-schema-entry 3tuple (instead of having accessor functions), but the good news is that you enforce that format, so even if the entry was specified without props, you provide the correct 3tuple, so destructuring works well! How would I test for a map schema? Is there a better way than: (= :map (m/name my-schema)) ?"><y>#</y><d>2020-04-03</d><h>17:29</h><w>dcj</w><a>@ikitommi</a> <code>m/map-entries</code> and map-schema-entry structure as 3tuple of <code>[key props child]</code>is very helpful.
For some reason, it makes me uneasy to just destructure the map-schema-entry 3tuple (instead of having accessor functions),
but the good news is that you enforce that format, so even if the entry was specified without props, you provide the correct 3tuple, so destructuring works well!
How would I test for a map schema? Is there a better way than: <code>(= :map (m/name my-schema))</code> ?</z><z id="t1585935240" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] (m/accept Schema m/map-syntax-visitor) is an awesome way to understand how the walking works, thanks! ATM, for my current &quot;database table schema&quot; task, I am pretty happy with m/map-entries and processing the returned map-schema-entries.... But I&apos;m sure I&apos;ll want to walk schemas at some point and good to know this."><y>#</y><d>2020-04-03</d><h>17:34</h><w>dcj</w><a>@ikitommi</a> <code>(m/accept Schema m/map-syntax-visitor)</code> is an awesome way to understand how the walking works, thanks!
ATM, for my current &quot;database table schema&quot; task, I am pretty happy with <code>m/map-entries</code>and processing the returned map-schema-entries....
But I&apos;m sure I&apos;ll want to walk schemas at some point and good to know this.</z><z id="t1585936031" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I don&apos;t want to mutate the default registry, I just want to add a few more things to the default registry. My initial feeling is that I am happy to provide my registry as options map. Maybe there should be public functions to support users adding to the registry, to make their own variants I&apos;ll just copy/paste from -register and -register-var for now...."><y>#</y><d>2020-04-03</d><h>17:47</h><w>dcj</w><a>@ikitommi</a> I don&apos;t want to mutate the default registry, I just want to add a few more things to the default registry.
My initial feeling is that I am happy to provide my registry as options map.
Maybe there should be public functions to support users adding to the registry, to make their own variants
I&apos;ll just copy/paste from <code>-register</code> and <code>-register-var</code> for now....</z><z id="t1585938849" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] WRT my earlier coercion question(s), I studied the README and transform.cljc further, looks like this machinery will do everything I want, I&apos;ll just need to provide/add my own encoding and decoding functions...I&apos;ll get to that soon enough"><y>#</y><d>2020-04-03</d><h>18:34</h><w>dcj</w><a>@ikitommi</a> WRT my earlier coercion question(s), I studied the README and <code>transform.cljc</code> further,
looks like this machinery will do everything I want, I&apos;ll just need to provide/add my own encoding and decoding functions...I&apos;ll get to that soon enough</z><z id="t1585939675" t="dcj Regarding long? and/or :long This requires further thought. If I am specifying a key :epoch-millisconds then it feels like that should specified as a long, not an int, so transformers can provide the correct type. Currently: (def +string-decoders+ (merge +json-decoders+ {&apos;integer? string-&gt;long &apos;int? string-&gt;long So, ATM those transforms do produce longs, but this seems somewhat arbitrary and not as precise as it might be. If the schema doesn&apos;t care about the the specific numeric type, then specifying something that includes a variety of types is fine."><y>#</y><d>2020-04-03</d><h>18:47</h><w>dcj</w>Regarding <code>long?</code> and/or <code>:long</code> This requires further thought.  If I am specifying a key <code>:epoch-millisconds</code> then it feels like that should specified as a long, not an int, so transformers can provide the correct type.
Currently:
<pre>(def +string-decoders+
  (merge
    +json-decoders+
    {&apos;integer? string-&gt;long
     &apos;int? string-&gt;long</pre>
So, ATM those transforms do produce longs, but this seems somewhat arbitrary and not as precise as it might be.
If the schema doesn&apos;t care about the the specific numeric type, then specifying something that includes a variety of types is fine.</z><z id="t1585957195" t="dcj More progress this afternoon: • Was able to add a new predicate to the default-registry, creating my-registry, and used it to define and validate a schema • Created a value transformer, and was able to get it invoked to transform a value via decode. Questions: • What is the meaning/use of the :name key in the mt/transformer input map? Can I put anything I want here? Should I use a namespaced keyword? • What other uses are there for the (optional) options map argument? (other than :registry )?"><y>#</y><d>2020-04-03</d><h>23:39</h><w>dcj</w>More progress this afternoon:
• Was able to add a new predicate to the default-registry, creating my-registry, and used it to define and validate a schema 
• Created a value transformer, and was able to get it invoked to transform a value via decode.
Questions:
• What is the meaning/use of the <code>:name</code> key in the <code>mt/transformer</code> input map?  Can I put anything I want here?  Should I use a namespaced keyword?
• What other uses are there for the (optional) options map argument? (other than <code>:registry</code>)?</z><z id="t1585963132" t="dcj So when I create a registry, and use it with m/schema , does that registry get saved with the schema (in -options)?"><y>#</y><d>2020-04-04</d><h>01:18</h><w>dcj</w>So when I create a registry, and use it with <code>m/schema</code>, does that registry get saved with the schema (in -options)?</z><z id="t1585969514" t="dcj WRT: What is the meaning/use of the :name key in the mt/transformer input map? Is it the case that executing mt/transformer {:name :foo :decode ... :encode...} registers that transformer via the key :foo somewhere, and it can be retrieved via mt/transformer {:name :foo}) ?"><y>#</y><d>2020-04-04</d><h>03:05</h><w>dcj</w>WRT:
<pre>What is the meaning/use of the :name key in the mt/transformer input map?</pre>
Is it the case that executing <code>mt/transformer {:name :foo :decode ... :encode...}</code> registers that transformer via the key <code>:foo</code> somewhere, and it can be retrieved via <code>mt/transformer {:name :foo})</code> ?</z><z id="t1585969934" t="dcj Does a transformer that uses {:compile have to be defined inline within a specific schema, or can it be a &quot;general&quot; transformer that gets called against any schema ? The README example shows ` {:compile &apos;(fn [schema _] What is the second arg to that function (ignored here) ?"><y>#</y><d>2020-04-04</d><h>03:12</h><w>dcj</w>Does a transformer that uses <code>{:compile</code> have to be defined inline within a specific schema, or can it be a &quot;general&quot; transformer that gets called against any schema ?
The README example shows `
<pre>{:compile &apos;(fn [schema _]</pre>
What is the second arg to that function (ignored here) ?</z><z id="t1585981886" t="ikitommi • :name in transformer is used for property-based transformation, I think only unqualified work right now (could be changed to support qualified too), having a transformer named :postgres allows one to define :encode/postgres and :decode/postgres keys in schema properties • currently no other used built-in keys than :registry in options, you can add you own - options are passed in mostly all user-defined callback functions. You should namespace your own option keys, just like custom schema property values, to avoid clashes • Schemas should save the options they were created with. I believe all in-built schemas do that. • :compile - it’s a feature of the interceptor, so can be used for general stuff, see the default-transformer (adding default values to schemas if missing): https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L315-L341 • second arg is the options"><y>#</y><d>2020-04-04</d><h>06:31</h><w>ikitommi</w>• <code>:name</code> in transformer is used for property-based transformation, I think only unqualified work right now (could be changed to support qualified too), having a transformer named <code>:postgres</code> allows one to define <code>:encode/postgres</code> and <code>:decode/postgres</code> keys in schema properties
• currently no other used built-in keys than <code>:registry</code> in options, you can add you own - options are passed in mostly all user-defined callback functions. You should namespace your own option keys, just like custom schema property values, to avoid clashes
• Schemas should save the options they were created with. I believe all in-built schemas do that.
• <code>:compile</code> - it’s a feature of the interceptor, so can be used for general stuff, see the default-transformer (adding default values to schemas if missing): <a href="https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L315-L341" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L315-L341</a>
• second arg is the options</z><z id="t1585982086" t="ikitommi I would like to see to options be One place to customize how malli works: defining the registry, adding error messages &amp; localizations ( https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L5-L55 ), generarators etc, whether to use serializable functions or not (sci adds some to the bundle size in cljs) etc."><y>#</y><d>2020-04-04</d><h>06:34</h><w>ikitommi</w>I would like to see to options be One place to customize how malli works: defining the registry, adding error messages &amp; localizations (<a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L5-L55" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L5-L55</a>), generarators etc, whether to use serializable functions or not (sci adds some to the bundle size in cljs) etc.</z><z id="t1585982154" t="ikitommi having a malli schema to define the core malli options would also give good errors on invalid options 😉"><y>#</y><d>2020-04-04</d><h>06:35</h><w>ikitommi</w>having a malli schema to define the core malli options would also give good errors on invalid options <b>😉</b></z><z id="t1585982255" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] here’s the line: only non-qualified transformer names are supported right now https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L60 . Issue &amp; PR welcome if you want qualified too."><y>#</y><d>2020-04-04</d><h>06:37</h><w>ikitommi</w><a>@dcj</a> here’s the line: only non-qualified transformer names are supported right now <a href="https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L60" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L60</a>. Issue &amp; PR welcome if you want qualified too.</z><z id="t1585982419" t="ikitommi can you ask for the entries: (satisfies? malli.core/MapSchema schema)"><y>#</y><d>2020-04-04</d><h>06:40</h><w>ikitommi</w>can you ask for the entries:  <code>(satisfies? malli.core/MapSchema schema)</code></z><z id="t1585982460" t="ikitommi looking at the source: (defn map-entries &quot;Returns a sequence of 3-element map-entry tuples of type `key ?properties schema`&quot; ([?schema] (map-entries ?schema nil)) ([?schema options] (if-let [schema (schema ?schema options)] (if (satisfies? MapSchema schema) (-map-entries schema)))))"><y>#</y><d>2020-04-04</d><h>06:41</h><w>ikitommi</w>looking at the source:
<pre>(defn map-entries
  &quot;Returns a sequence of 3-element map-entry tuples of type `key ?properties schema`&quot;
  ([?schema]
   (map-entries ?schema nil))
  ([?schema options]
   (if-let [schema (schema ?schema options)]
     (if (satisfies? MapSchema schema)
       (-map-entries schema)))))</pre></z><z id="t1585982472" t="ikitommi so, return nil or entries."><y>#</y><d>2020-04-04</d><h>06:41</h><w>ikitommi</w>so, return <code>nil</code> or entries.</z><z id="t1585982612" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] no current need for qualified transformer names. Thank you again for all these answers. I will need to experiment/study transformers more tomorrow... "><y>#</y><d>2020-04-04</d><h>06:43</h><w>dcj</w><a>@ikitommi</a> no current need for qualified transformer names.
Thank you again for all these answers.
I will need to experiment/study transformers more tomorrow...

</z><z id="t1585983431" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Can :decode/foo keys in schema props be on the props for a single key in map, or only at the top :map level?"><y>#</y><d>2020-04-04</d><h>06:57</h><w>dcj</w><a>@ikitommi</a> Can :decode/foo keys in schema props be on the props for a single key in map, or only at the top :map level?</z><z id="t1585983525" t="ikitommi all schemas, but not currently the map-entries, later, see https://github.com/metosin/malli/issues/86"><y>#</y><d>2020-04-04</d><h>06:58</h><w>ikitommi</w>all schemas, but not currently the map-entries, later, see <a href="https://github.com/metosin/malli/issues/86" target="_blank">https://github.com/metosin/malli/issues/86</a></z><z id="t1585983565" t="ikitommi but this works: [:map [:x [int? {:decode/postgre ...}]]]"><y>#</y><d>2020-04-04</d><h>06:59</h><w>ikitommi</w>but this works:
<pre>[:map
 [:x [int? {:decode/postgre ...}]]]</pre></z><z id="t1585983647" t="ikitommi the parent-child thing (and support for recursive schemas) is the last big thing to resolve before a release. Ideas welcome on that."><y>#</y><d>2020-04-04</d><h>07:00</h><w>ikitommi</w>the parent-child thing (and support for recursive schemas) is the last big thing to resolve before a release. Ideas welcome on that.</z><z id="t1586004273" t="pithyless What kind of naming conventions have people found useful for malli-specs? In clojure.spec, one has a separate registry of names (s/def ::user) but malli just uses existing ns vars. Some idioms I&apos;ve seen: user-schema , User , ns.just.specs/user ; a plain (def user) I&apos;m afraid will clash too frequently with other/local bindings in your domain."><y>#</y><d>2020-04-04</d><h>12:44</h><w>pithyless</w>What kind of naming conventions have people found useful for malli-specs?  In clojure.spec, one has a separate registry of names <code>(s/def ::user)</code> but malli just uses existing ns vars. Some idioms I&apos;ve seen: <code>user-schema</code>, <code>User</code>, <code>ns.just.specs/user</code> ; a plain <code>(def user)</code> I&apos;m afraid will clash too frequently with other/local bindings in your domain.</z><z id="t1586017758" t="dcj [:attrs {:href &quot;/_/_/users/U05476190&quot;}] Never having used malli &apos;in anger&apos;, my plan is to create a new/separate project/repo definitions to hold schemas and the like for a collection of interrelated projects. There will be subdirectories within definitions for specific domains, each with its own schema file/ns. So: definitions.foo.schema Within each schema file/ns I will just def the indvidual schemas, eg (def measurement (m/schema ...) I&apos;ll require these as needed like this: [definitions.foo.schema :as foo.schema] So then I&apos;ll access as foo.schema/measurement Disclaimer: Currently re-writing some code using my third schema tool, third database access library, and third time library, so clearly I can&apos;t get anything right the first N times 🙂"><y>#</y><d>2020-04-04</d><h>16:29</h><w>dcj</w><a>@pithyless</a> Never having used malli &apos;in anger&apos;, my plan is to create a new/separate project/repo <code>definitions</code> to hold schemas and the like for a collection of interrelated projects.
There will be subdirectories within definitions for specific domains, each with its own schema file/ns.  So: <code>definitions.foo.schema</code>
Within each schema file/ns I will just def the indvidual schemas, eg <code>(def measurement (m/schema ...)</code>
I&apos;ll require these as needed like this: <code>[definitions.foo.schema :as foo.schema]</code>
So then I&apos;ll access as <code>foo.schema/measurement</code>
Disclaimer:  Currently re-writing some code using my third schema tool, third database access library, and third time library, so clearly I can&apos;t get anything right the first N times <b>🙂</b></z><z id="t1586028033" t="dcj I&apos;m having trouble groking property-based transformation. Here is a simplified example: (def my-schema (m/schema [:map {:closed true :encode/postgres csk/-&gt;kebab-case-keyword :decode/postgres csk/-&gt;snake_case_keyword} [:id {:optional true :postgres/type :bigserial :postgres/key :primary} int?] [:instrument-id {:postgres/type :bigint :postgres/null? false} int?] ] )) (def sample {:id 12345 :instrument-id 67890}) (m/decode my-schema sample (mt/key-transformer {:name :postgres})) ;; {:id 12345, :instrument-id 67890} I was expecting the :instrument-id key to be transformed to :instrument_id I have tried quoting the values of :encode/postgres and :decode/postgres various ways both single-quote and hash-single-quite to no avail. Also tried to use mt/transformer different problems. How should I do this?"><y>#</y><d>2020-04-04</d><h>19:20</h><w>dcj</w>I&apos;m having trouble groking property-based transformation.
Here is a simplified example:
<pre>(def my-schema
  (m/schema
   [:map {:closed true
          :encode/postgres csk/-&gt;kebab-case-keyword
          :decode/postgres csk/-&gt;snake_case_keyword}
    [:id             {:optional true
                      :postgres/type :bigserial
                      :postgres/key  :primary} int?]
    [:instrument-id  {:postgres/type :bigint
                      :postgres/null? false} int?]
    ]
   ))

(def sample
  {:id 12345
   :instrument-id 67890})

(m/decode my-schema sample (mt/key-transformer {:name :postgres}))

;; {:id 12345, :instrument-id 67890}</pre>
I was expecting the <code>:instrument-id</code> key to be transformed to <code>:instrument_id</code>
I have tried quoting the values of <code>:encode/postgres</code> and <code>:decode/postgres</code> various ways both single-quote and hash-single-quite to no avail.
Also tried to use <code>mt/transformer</code> different problems.
How should I do this?</z><z id="t1586031672" t="dcj I guess my example above is confused about the encode/decode directions/terminology, be that as it may, I still can&apos;t seem to get the key-transformers to run, no matter what...."><y>#</y><d>2020-04-04</d><h>20:21</h><w>dcj</w>I guess my example above is confused about the encode/decode directions/terminology, be that as it may,  I still can&apos;t seem to get the key-transformers to run, no matter what....</z><z id="t1586081075" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] the key-transformer doesn’t understand the :name . It’s simple transformes all keys, not usefull in your case. You should use normal transformer instead. I created a gist, which might show the needed core for the thing you are looking for, using both named property-driven and a custom transformer options. Hope this helps: https://gist.github.com/ikitommi/5d71fc6b320e996b1ac9c17c4d412b71"><y>#</y><d>2020-04-05</d><h>10:04</h><w>ikitommi</w><a>@dcj</a> the <code>key-transformer</code> doesn’t understand the <code>:name</code>. It’s simple transformes all keys, not usefull in your case. You should use normal transformer instead. I created a gist, which might show the needed core for the thing you are looking for, using both named property-driven and a custom transformer options. Hope this helps: <a href="https://gist.github.com/ikitommi/5d71fc6b320e996b1ac9c17c4d412b71" target="_blank">https://gist.github.com/ikitommi/5d71fc6b320e996b1ac9c17c4d412b71</a></z><z id="t1586081617" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] coming (and loving) Plumatic Schema, I have use the class-like naming: User , Address . Currently porting a Schema-project to use Malli, so the var names existed already. If I would add the schemas to the registry, might want to use qualified keywords: (assoc registry ::user User) ."><y>#</y><d>2020-04-05</d><h>10:13</h><w>ikitommi</w><a>@pithyless</a> coming (and loving) Plumatic Schema, I have use the class-like naming: <code>User</code>, <code>Address</code>. Currently porting a Schema-project to use Malli, so the var names existed already. If I would add the schemas to the registry, might want to use qualified keywords: <code>(assoc registry ::user User)</code>.</z><z id="t1586081671" t="ikitommi Currently, haven’t added any domain schemas into the registry. is anyone doing that?"><y>#</y><d>2020-04-05</d><h>10:14</h><w>ikitommi</w>Currently, haven’t added any domain schemas into the registry. is anyone doing that?</z><z id="t1586082576" t="kwrooijen I was thinking of doing this. I want to create UI elements based on the type of the schema. My initial thought was to use properties, but creating a registry could also be a valid option. But I&apos;m still learning all the ins and outs of Malli though."><y>#</y><d>2020-04-05</d><h>10:29</h><r>kwrooijen</r>I was thinking of doing this. I want to create UI elements based on the type of the schema. My initial thought was to use properties, but creating a registry could also be a valid option. But I&apos;m still learning all the ins and outs of Malli though.</z><z id="t1586090781" t="kwrooijen Is there an idiomatic way of writing documentation for keys? I can&apos;t seem to find anything about that in the README. Currently I have this, which works, but feels very hacky."><y>#</y><d>2020-04-05</d><h>12:46</h><w>kwrooijen</w>Is there an idiomatic way of writing documentation for keys? I can&apos;t seem to find anything about that in the README. Currently I have this, which works, but feels very hacky.</z><z id="t1586092656" t="ikitommi just for keys: (def Human [:map [:human/name {:description &quot;Human name&quot;} string?] [:human/age {:description &quot;Human age&quot;} int?]]) (doseq [[k p _] (m/map-entries Human)] (println k &quot;-&gt;&quot; (-&gt; p :description))) ;:human/name -&gt; Human name ;:human/age -&gt; Human age"><y>#</y><d>2020-04-05</d><h>13:17</h><w>ikitommi</w>just for keys:
<pre>(def Human
  [:map
   [:human/name {:description &quot;Human name&quot;} string?]
   [:human/age {:description &quot;Human age&quot;} int?]])

(doseq [[k p _] (m/map-entries Human)]
  (println k &quot;-&gt;&quot; (-&gt; p :description)))
;:human/name -&gt; Human name
;:human/age -&gt; Human age</pre></z><z id="t1586092678" t="ikitommi for values: (def Human [:map [:human/name [:and {:description &quot;Human name&quot;} string?]] [:human/age [:and {:description &quot;Human age&quot;} int?]]]) (doseq [[k _ s] (m/map-entries Human)] (println k &quot;-&gt;&quot; (-&gt; s m/properties :description))) ;:human/name -&gt; Human name ;:human/age -&gt; Human age"><y>#</y><d>2020-04-05</d><h>13:17</h><w>ikitommi</w>for values:
<pre>(def Human
  [:map
   [:human/name [:and {:description &quot;Human name&quot;} string?]]
   [:human/age  [:and {:description &quot;Human age&quot;} int?]]])

(doseq [[k _ s] (m/map-entries Human)]
  (println k &quot;-&gt;&quot; (-&gt; s m/properties :description)))
;:human/name -&gt; Human name
;:human/age -&gt; Human age</pre></z><z id="t1586092704" t="ikitommi or: (def Human [:map [:human/name [string? {:description &quot;Human name&quot;}]] [:human/age [int? {:description &quot;Human age&quot;}]]]) (doseq [[k _ s] (m/map-entries Human)] (println k &quot;-&gt;&quot; (-&gt; s m/properties :description))) ;:human/name -&gt; Human name ;:human/age -&gt; Human age"><y>#</y><d>2020-04-05</d><h>13:18</h><w>ikitommi</w>or:
<pre>(def Human
  [:map
   [:human/name [string? {:description &quot;Human name&quot;}]]
   [:human/age  [int? {:description &quot;Human age&quot;}]]])

(doseq [[k _ s] (m/map-entries Human)]
  (println k &quot;-&gt;&quot; (-&gt; s m/properties :description)))
;:human/name -&gt; Human name
;:human/age -&gt; Human age</pre></z><z id="t1586092961" t="ikitommi as Slack history loses all code, wrote a gist: https://gist.github.com/ikitommi/7c26aebf2b0f58d58432c884c8a55b5a"><y>#</y><d>2020-04-05</d><h>13:22</h><w>ikitommi</w>as Slack history loses all code, wrote a gist: <a href="https://gist.github.com/ikitommi/7c26aebf2b0f58d58432c884c8a55b5a" target="_blank">https://gist.github.com/ikitommi/7c26aebf2b0f58d58432c884c8a55b5a</a></z><z id="t1586093010" t="kwrooijen Ahh nice, m/map-entries is what I needed simple_smile also didn&apos;t know the :and was redundant. There are a couple of example that use :and + opts in the README"><y>#</y><d>2020-04-05</d><h>13:23</h><w>kwrooijen</w>Ahh nice, <code>m/map-entries</code> is what I needed <b>simple_smile</b>  also didn&apos;t know the <code>:and</code> was redundant. There are a couple of example that use <code>:and</code> + opts in the README</z><z id="t1586093081" t="kwrooijen So would the convention be :description then? Since that was also used by json_schema ?"><y>#</y><d>2020-04-05</d><h>13:24</h><w>kwrooijen</w>So would the convention be <code>:description</code> then? Since that was also used by json_schema ?</z><z id="t1586093236" t="ikitommi yes, :title and :description should be used, I’ll add those to README."><y>#</y><d>2020-04-05</d><h>13:27</h><w>ikitommi</w>yes, <code>:title</code> and <code>:description</code> should be used, I’ll add those to README.</z><z id="t1586093240" t="ikitommi (malli.json-schema/transform [:map [:human/name [string? {:description &quot;Human name&quot;}]] [:human/age [int? {:description &quot;Human age&quot;}]]]) ;{:type &quot;object&quot;, ; :properties #:human{:name {:type &quot;string&quot;, :description &quot;Human name&quot;}, ; :age {:type &quot;integer&quot;, :format &quot;int64&quot;, :description &quot;Human age&quot;}}, ; :required [:human/name :human/age]}"><y>#</y><d>2020-04-05</d><h>13:27</h><w>ikitommi</w><pre>(malli.json-schema/transform
  [:map
   [:human/name [string? {:description &quot;Human name&quot;}]]
   [:human/age [int? {:description &quot;Human age&quot;}]]])
;{:type &quot;object&quot;,
; :properties #:human{:name {:type &quot;string&quot;, :description &quot;Human name&quot;},
;                     :age {:type &quot;integer&quot;, :format &quot;int64&quot;, :description &quot;Human age&quot;}},
; :required [:human/name :human/age]}</pre></z><z id="t1586093287" t="kwrooijen Ok, thank you for the clarification 👍"><y>#</y><d>2020-04-05</d><h>13:28</h><w>kwrooijen</w>Ok, thank you for the clarification <b>👍</b></z><z id="t1586102971" t="sudakatux Hi"><y>#</y><d>2020-04-05</d><h>16:09</h><w>sudakatux</w>Hi</z><z id="t1586104218" t="sudakatux So how can i test malli on a lein project"><y>#</y><d>2020-04-05</d><h>16:30</h><w>sudakatux</w>So how can i test malli on a lein project</z><z id="t1586104220" t="sudakatux ?"><y>#</y><d>2020-04-05</d><h>16:30</h><w>sudakatux</w>?</z><z id="t1586104504" t="dcj [metosin/malli &quot;0.0.1-SNAPSHOT&quot;]"><y>#</y><d>2020-04-05</d><h>16:35</h><w>dcj</w><code>[metosin/malli &quot;0.0.1-SNAPSHOT&quot;]</code></z><z id="t1586104531" t="sudakatux cool just found it at the same time. Thank u"><y>#</y><d>2020-04-05</d><h>16:35</h><w>sudakatux</w>cool just found it at the same time. Thank u</z><z id="t1586104648" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thank you for the gist, that is super helpful! You provided two different examples, named property-driven transformations and named transformations, ATM I think I like the named transformations more, but will mull it over... The named transformations version of postgres-transformer answered further questions I had about how to use :complle Would it be a good/interesting idea to store transformers like these in the options of the schema? If so, then presumably they could be accessed later when needed for encode/decode calls...."><y>#</y><d>2020-04-05</d><h>16:37</h><w>dcj</w><a>@ikitommi</a> Thank you for the gist, that is super helpful!
You provided two different examples, named property-driven transformations and named transformations, ATM I think I like the named transformations more, but will mull it over...
The named transformations version of <code>postgres-transformer</code> answered further questions I had about how to use <code>:complle</code>
Would it be a good/interesting idea to store transformers like these in the options of the schema?
If so, then presumably they could be accessed later when needed for encode/decode calls....</z><z id="t1586132168" t="dcj Regarding map schemas: To get all the map keys from the schema itself: (mapv first (m/map-entries my-schema)) So far there have been two different cases where I need to get all the &quot;encoded&quot; keys from the schema itself, is there any way to do that? For the moment, I have defined the &quot;key-encode-fn` and I store that away in the schema, then when I need the encoded keys, I go fetch it, and (mapv (comp key-encode-fn first) (m/map-entries my-schema) And when I am creating the encoders for a key related mt/transformer , again, I go get this function, and (partial -transform-keys key-encode-fn) This all works if I define and follow the convention above. Is there another/better way to get the &quot;encoded&quot; keys from a schema?"><y>#</y><d>2020-04-06</d><h>00:16</h><w>dcj</w>Regarding map schemas:
To get all the map keys from the schema itself: <code>(mapv first (m/map-entries my-schema))</code>
So far there have been two different cases where I need to get all the &quot;encoded&quot; keys from the schema itself, is there any way to do that?
For the moment, I have defined the &quot;key-encode-fn` and I store that away in the schema, then when I need the encoded keys, I go fetch it, and <code>(mapv (comp key-encode-fn first) (m/map-entries my-schema)</code>
And when I am creating the encoders for a key related <code>mt/transformer</code>, again, I go get this function, and <code>(partial -transform-keys key-encode-fn)</code>
This all works if I define and follow the convention above.
Is there another/better way to get the &quot;encoded&quot; keys from a schema?</z><z id="t1586132888" t="dcj For the record, defining transformers with :compile can be difficult to get correct, until you get an accurate mental model of when in time the various parts really happen on the &apos;def time&apos; vs &apos;execution time&apos; continuum. I struggled with this for a while, then eventually went back to a working example [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] gave me, and put println s at various places. That really helped! Finally I got it working! Very useful and powerful!"><y>#</y><d>2020-04-06</d><h>00:28</h><w>dcj</w>For the record, defining transformers with <code>:compile</code> can be difficult to get correct, until you get an accurate mental model of when in time the various parts really happen on the &apos;def time&apos; vs &apos;execution time&apos; continuum. I struggled with this for a while, then eventually went back to a working example <a>@ikitommi</a> gave me, and put <code>println</code>s at various places.
That really helped!  Finally I got it working!  Very useful and powerful!</z><z id="t1586135845" t="dcj A map-entry is a 3tuple vector containing [`key ?properties schema]` , and as data/text, the properties is/are optional... If you&apos;ve been following along with my &quot;map-schema with support for Postgres tables&quot; example(s), one map entry might like like this: [:id {:optional true :postgres/type :column :postgres/datatype :bigserial :postgres/key :primary} int?] Functionally, this is working great. From a schema readability perspective, IMHO, there is quite a lot of &quot;textual distance&quot; between the key, and the schema, when properties are specified/used, I really need to search for the schema of this key... So far, the schemas I have specified for keys are textually simple/short (mostly the built-in ones, or similar predicates I have created) Given that malli is &quot;Pre-alpha, in design and prototyping phase&quot; I wonder if switching the order of the propertes and the schema in a map-entry would improve readability/comprehension... Disclaimers: maybe this is a terrible idea. I have only a small number of hours of experience with malli, and only with pretty simple map schemas. I imagine this change would be extremely painful for everyone involved, and that could easily outweigh any benefits (assuming there are any benefits). I will happily live with the current map entry structure..."><y>#</y><d>2020-04-06</d><h>01:17</h><w>dcj</w>A map-entry is a 3tuple vector containing [`key ?properties schema]` , and as data/text, the properties is/are optional...
If you&apos;ve been following along with my &quot;map-schema with support for Postgres tables&quot; example(s), one map entry might like like this:
<pre>[:id {:optional true
        :postgres/type :column
        :postgres/datatype :bigserial
        :postgres/key :primary} int?]</pre>
Functionally, this is working great.
From a schema readability perspective, IMHO, there is quite a lot of &quot;textual distance&quot; between the key, and the schema, when properties are specified/used,
I really need to search for the schema of this key...
So far, the schemas I have specified for keys are textually simple/short (mostly the built-in ones, or similar predicates I have created)
Given that malli is &quot;Pre-alpha, in design and prototyping phase&quot; I wonder if switching the order of the propertes and the schema in a map-entry would improve readability/comprehension...
Disclaimers:  maybe this is a terrible idea.  I have only a small number of hours of experience with malli, and only with pretty simple map schemas.  I imagine this change would be extremely painful for everyone involved, and that could easily outweigh any benefits (assuming there are any benefits).  I will happily live with the current map entry structure...</z><z id="t1586158502" t="kwrooijen An alternative is adding :id to the registry as {::id int?} . and then using the upcoming map syntax (if this pr gets approved https://github.com/metosin/malli/pull/194 ) (def my-registry {::id int?}) (m/schema [::id {:optional true :postgres/type :column :postgres/datatype :bigserial :postgres/key :primary}] {:registry my-registry}) Something like this. And I think it will be easier to extend the registry later (if I&apos;m reading the issues / PRs correctly)"><y>#</y><d>2020-04-06</d><h>07:35</h><r>kwrooijen</r>An alternative is adding <code>:id</code> to the registry as <code>{::id int?}</code>. and then using the upcoming map syntax (if this pr gets approved <a href="https://github.com/metosin/malli/pull/194" target="_blank">https://github.com/metosin/malli/pull/194</a>)

<pre>(def my-registry {::id int?})

(m/schema  
  [::id {:optional true
        :postgres/type :column
        :postgres/datatype :bigserial
        :postgres/key :primary}]
{:registry my-registry})</pre>
Something like this. And I think it will be easier to extend the registry later (if I&apos;m reading the issues / PRs correctly)</z><z id="t1586158933" t="kwrooijen Also I think the reason for this format: [key ?properties schema] is because it&apos;s inline with the Hiccup syntax https://github.com/weavejester/hiccup Meaning that it would be a bit couter-intuitive to change the order. I could be wrong though."><y>#</y><d>2020-04-06</d><h>07:42</h><r>kwrooijen</r>Also I think the reason for this format: <code>[key ?properties schema]</code>

is because it&apos;s inline with the Hiccup syntax <a href="https://github.com/weavejester/hiccup" target="_blank">https://github.com/weavejester/hiccup</a>
Meaning that it would be a bit couter-intuitive to change the order. I could be wrong though.</z><z id="t1586186851" t="dcj Seems like it depends on how ‘terminal’ the schema element in a map-entry is. If the schema element was going to describe a another map/list/etc, then switching the props and schema would be horrible, which is probably why the current ordering is the way it is.... "><y>#</y><d>2020-04-06</d><h>15:27</h><r>dcj</r>Seems like it depends on how ‘terminal’ the schema element in a map-entry is.  
If the schema element was going to describe a another map/list/etc, then switching the props and schema would be horrible, which is probably why the current ordering is the way it is....
</z><z id="t1586188900" t="dcj Which is the case with the example schema grounded_sage showed in a subsequent post. So now I see why the current ordering is best. Never mind...."><y>#</y><d>2020-04-06</d><h>16:01</h><r>dcj</r>Which is the case with the example schema grounded_sage showed in a subsequent post.
So now I see why the current ordering is best.
Never mind....</z><z id="t1586189058" t="dcj NEVERMIND, I now see why current element ordering is best.... A map-entry is a 3tuple vector containing [`key ?properties schema]` , and as data/text, the properties is/are optional... If you&apos;ve been following along with my &quot;map-schema with support for Postgres tables&quot; example(s), one map entry might like like this: [:id {:optional true :postgres/type :column :postgres/datatype :bigserial :postgres/key :primary} int?] Functionally, this is working great. From a schema readability perspective, IMHO, there is quite a lot of &quot;textual distance&quot; between the key, and the schema, when properties are specified/used, I really need to search for the schema of this key... So far, the schemas I have specified for keys are textually simple/short (mostly the built-in ones, or similar predicates I have created) Given that malli is &quot;Pre-alpha, in design and prototyping phase&quot; I wonder if switching the order of the propertes and the schema in a map-entry would improve readability/comprehension... Disclaimers: maybe this is a terrible idea. I have only a small number of hours of experience with malli, and only with pretty simple map schemas. I imagine this change would be extremely painful for everyone involved, and that could easily outweigh any benefits (assuming there are any benefits). I will happily live with the current map entry structure..."><y>#</y><d>2020-04-06</d><h>16:04</h><r>dcj</r>NEVERMIND, I now see why current element ordering is best....
A map-entry is a 3tuple vector containing [`key ?properties schema]` , and as data/text, the properties is/are optional...
If you&apos;ve been following along with my &quot;map-schema with support for Postgres tables&quot; example(s), one map entry might like like this:
<pre>[:id {:optional true
        :postgres/type :column
        :postgres/datatype :bigserial
        :postgres/key :primary} int?]</pre>
Functionally, this is working great.
From a schema readability perspective, IMHO, there is quite a lot of &quot;textual distance&quot; between the key, and the schema, when properties are specified/used,
I really need to search for the schema of this key...
So far, the schemas I have specified for keys are textually simple/short (mostly the built-in ones, or similar predicates I have created)
Given that malli is &quot;Pre-alpha, in design and prototyping phase&quot; I wonder if switching the order of the propertes and the schema in a map-entry would improve readability/comprehension...
Disclaimers:  maybe this is a terrible idea.  I have only a small number of hours of experience with malli, and only with pretty simple map schemas.  I imagine this change would be extremely painful for everyone involved, and that could easily outweigh any benefits (assuming there are any benefits).  I will happily live with the current map entry structure...</z><z id="t1586188483" t="grounded_sage I’m having trouble updating a schema. Not sure how to do it. Current schema [:map [:Data [:map [:CommunicationChannels [:vector [:map [:Identifier [:map [:Value string?] [:Details [:map [:ID string?] [:SystemID string?]]]]] [:ChannelType [:map [:Type int?] [:Name string?]]] [:Content string?]]]]]]] Desired schema -&gt; [:map [:Data [:map [:CommunicationChannels [:vector [:map [:Identifier [:map [:Value string?] [:Details [:map [:ID string?] [:SystemID string?]]]]] [:ChannelType [:map [:Type int?] [:or [:Name &quot;EMail&quot;] [:Name &quot;Mobile&quot;] [:Name &quot;Fax&quot;]]]] [:Content string?]]]]]]] "><y>#</y><d>2020-04-06</d><h>15:54</h><w>grounded_sage</w>I’m having trouble updating a schema. Not sure how to do it.
Current schema
<pre>[:map
   [:Data
    [:map
     [:CommunicationChannels
      [:vector
       [:map
        [:Identifier [:map [:Value string?] [:Details [:map [:ID string?] [:SystemID string?]]]]]
        [:ChannelType [:map [:Type int?] [:Name string?]]]
        [:Content string?]]]]]]]</pre>
Desired schema -&gt;
<pre>[:map
   [:Data
    [:map
     [:CommunicationChannels
      [:vector
       [:map
        [:Identifier [:map [:Value string?] [:Details [:map [:ID string?] [:SystemID string?]]]]]
        [:ChannelType [:map [:Type int?]
                       [:or
                        [:Name &quot;EMail&quot;]
                        [:Name &quot;Mobile&quot;]
                        [:Name &quot;Fax&quot;]]]]
        [:Content string?]]]]]]]</pre>
</z><z id="t1586190090" t="grounded_sage Oh figured it out. Have to use the :enum"><y>#</y><d>2020-04-06</d><h>16:21</h><w>grounded_sage</w>Oh figured it out. Have to use the <code>:enum</code></z><z id="t1586205602" t="kwrooijen I&apos;m trying to run the malli tests locally, but getting the following error: Exception: clojure.lang.ExceptionInfo: Kaocha ClojureScript client failed connecting back."><y>#</y><d>2020-04-06</d><h>20:40</h><w>kwrooijen</w>I&apos;m trying to run the malli tests locally, but getting the following error:
<code>Exception: clojure.lang.ExceptionInfo: Kaocha ClojureScript client failed connecting back.</code></z><z id="t1586205635" t="kwrooijen This doesn&apos;t happen in CI though. And I do have some tests that are actually failing, but this error is swallowing them all 😕"><y>#</y><d>2020-04-06</d><h>20:40</h><w>kwrooijen</w>This doesn&apos;t happen in CI though. And I do have some tests that are actually failing, but this error is swallowing them all <b>😕</b></z><z id="t1586205655" t="kwrooijen Does anyone else have this issue?"><y>#</y><d>2020-04-06</d><h>20:40</h><w>kwrooijen</w>Does anyone else have this issue?</z><z id="t1586205672" t="kwrooijen MacOS Catalina, by the way"><y>#</y><d>2020-04-06</d><h>20:41</h><w>kwrooijen</w>MacOS Catalina, by the way</z><z id="t1586227736" t="grounded_sage I can’t get Union working on my schemas"><y>#</y><d>2020-04-07</d><h>02:48</h><w>grounded_sage</w>I can’t get <code>Union</code> working on my schemas</z><z id="t1586228059" t="grounded_sage This is the gist with the schemas in it."><y>#</y><d>2020-04-07</d><h>02:54</h><w>grounded_sage</w>This is the gist with the schemas in it.</z><z id="t1586228201" t="grounded_sage https://gist.github.com/groundedSAGE/4752ff810afe184ce119416a76eb8894"><y>#</y><d>2020-04-07</d><h>02:56</h><w>grounded_sage</w><a href="https://gist.github.com/groundedSAGE/4752ff810afe184ce119416a76eb8894" target="_blank">https://gist.github.com/groundedSAGE/4752ff810afe184ce119416a76eb8894</a></z><z id="t1586247206" t="eskos [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] it seems neither of those are valid schemas, I split the first one and reduced it into this which fails user=&gt; (m/validator [:map #_=&gt; [:Data #_=&gt; [:map #_=&gt; [:GroupMemberships [:vector [:or]]]]]]) Execution error (ExceptionInfo) at malli.core/fail! (core.cljc:73). :malli.core/no-children "><y>#</y><d>2020-04-07</d><h>08:13</h><w>eskos</w><a>@grounded_sage</a> it seems neither of those are valid schemas, I split the first one and reduced it into this which fails
<pre>user=&gt; (m/validator [:map
  #_=&gt;  [:Data
  #_=&gt;   [:map
  #_=&gt;    [:GroupMemberships [:vector [:or]]]]]])
Execution error (ExceptionInfo) at malli.core/fail! (core.cljc:73).
:malli.core/no-children</pre>
</z><z id="t1586247275" t="eskos That :or seems lingering, typo?"><y>#</y><d>2020-04-07</d><h>08:14</h><w>eskos</w>That <code>:or</code> seems lingering, typo?</z><z id="t1586247309" t="grounded_sage Yea I thought that was strange. Can malli generate invalid schemas?"><y>#</y><d>2020-04-07</d><h>08:15</h><w>grounded_sage</w>Yea I thought that was strange. Can malli generate invalid schemas?</z><z id="t1586247319" t="grounded_sage Because this was after doing schema inference."><y>#</y><d>2020-04-07</d><h>08:15</h><w>grounded_sage</w>Because this was after doing schema inference.</z><z id="t1586247479" t="eskos If that is a result of inferring then I guess the answer is yes 🙂 If you can figure out the minimal set of input data which produces invalid inferred schemas, I’m sure an issue is warmly welcomed."><y>#</y><d>2020-04-07</d><h>08:17</h><w>eskos</w>If that is a result of inferring then I guess the answer is yes <b>🙂</b> If you can figure out the minimal set of input data which produces invalid inferred schemas, I’m sure an issue is warmly welcomed.</z><z id="t1586252383" t="ikitommi Sounds like a bug."><y>#</y><d>2020-04-07</d><h>09:39</h><w>ikitommi</w>Sounds like a bug.</z><z id="t1586352704" t="grounded_sage Just posted an issue for it. https://github.com/metosin/malli/issues/196"><y>#</y><d>2020-04-08</d><h>13:31</h><r>grounded_sage</r>Just posted an issue for it.
<a href="https://github.com/metosin/malli/issues/196" target="_blank">https://github.com/metosin/malli/issues/196</a></z><z id="t1586264144" t="sudakatux Hi"><y>#</y><d>2020-04-07</d><h>12:55</h><w>sudakatux</w>Hi</z><z id="t1586294530" t="kwrooijen Anyone now if this is possible? :spritesheet/frame and :spritesheet/animation are technically both optional. But the map MUST have one or the other. This code snippet is invalid, the :or doesn&apos;t work (disclaimer, I&apos;m working off of this PR https://github.com/metosin/malli/pull/194 which is why I can use this qualified-keyword syntax)"><y>#</y><d>2020-04-07</d><h>21:22</h><w>kwrooijen</w>Anyone now if this is possible? <code>:spritesheet/frame</code> and <code>:spritesheet/animation</code> are technically both optional. But the map MUST have one or the other. This code snippet is invalid, the <code>:or</code> doesn&apos;t work (disclaimer, I&apos;m working off of this PR <a href="https://github.com/metosin/malli/pull/194" target="_blank">https://github.com/metosin/malli/pull/194</a> which is why I can use this qualified-keyword syntax)</z><z id="t1586352457" t="aisamu The way I&apos;ve done such xor -like unions in regular spec is to move the or up one level: [:or [:map :spritesheet/name :spritesheet/frame] [:map :spritesheet/name :spritesheet/animation]]"><y>#</y><d>2020-04-08</d><h>13:27</h><r>aisamu</r>The way I&apos;ve done such <code>xor</code>-like unions in regular spec is to move the <code>or</code> up one level:
<pre>[:or
 [:map
  :spritesheet/name
  :spritesheet/frame]
 [:map
  :spritesheet/name
  :spritesheet/animation]]</pre></z><z id="t1586301381" t="dcj Let&apos;s say I have a value that is an enum: (def Weighting [:enum :dB-A :dB-C :dB-Z]) I can specify that as a value in another schema: (def MyMap (m/schema [:map [:weighting Weighting]])) Is there a way to turn the value schema into a &quot;type&quot; that malli understands? Let&apos;s say I need to transform the numbers 0,1,2 into the enumerated values... (defn weighting-&gt;kw [n] (if (int? n) (case n 0 :dB-C 1 :dB-A 2 :dB-Z n) n)) I specify a value transformer as: (mt/transformer {:name :weighting :decoders {:enum weighting-&gt;kw}}) But in writing this, I am reaching into Weighting to pull out the :enum If I had two different enum values then dispatching via &quot;value is an enum&quot; doesn&apos;t seem like it will work, they will both resolve to enum. How does one handle this? Seems like I would want to specify the decoder as {:Weighting weighting-&gt;kw}"><y>#</y><d>2020-04-07</d><h>23:16</h><w>dcj</w>Let&apos;s say I have a value that is an enum:
<pre>(def Weighting
  [:enum :dB-A :dB-C :dB-Z])</pre>
I can specify that as a value in another schema:
<pre>(def MyMap
  (m/schema
   [:map
    [:weighting Weighting]]))</pre>
Is there a way to turn the value schema into a &quot;type&quot; that malli understands?

Let&apos;s say I need to transform the numbers 0,1,2 into the enumerated values...
<pre>(defn weighting-&gt;kw
  [n]
  (if (int? n)
    (case n
      0 :dB-C
      1 :dB-A
      2 :dB-Z
      n)
    n))</pre>
I specify a value transformer as:
<pre>(mt/transformer
 {:name :weighting
  :decoders {:enum weighting-&gt;kw}})</pre>
But in writing this, I am reaching into Weighting to pull out the <code>:enum</code>
If I had two different enum values then dispatching via &quot;value is an enum&quot; doesn&apos;t seem like it will work, they will both resolve to enum.
How does one handle this?
Seems like I would want to specify the decoder as <code>{:Weighting weighting-&gt;kw}</code></z><z id="t1586352457" t="aisamu The way I&apos;ve done such xor -like unions in regular spec is to move the or up one level: [:or [:map :spritesheet/name :spritesheet/frame] [:map :spritesheet/name :spritesheet/animation]]"><y>#</y><d>2020-04-08</d><h>13:27</h><w>aisamu</w>The way I&apos;ve done such <code>xor</code>-like unions in regular spec is to move the <code>or</code> up one level:
<pre>[:or
 [:map
  :spritesheet/name
  :spritesheet/frame]
 [:map
  :spritesheet/name
  :spritesheet/animation]]</pre></z><z id="t1586320498" t="ikitommi ping [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}]"><y>#</y><d>2020-04-08</d><h>04:34</h><w>ikitommi</w>ping <a>@kevin.van.rooijen</a></z><z id="t1586320595" t="ikitommi I’m not a fond of too much extra syntax for :map . If the spec-like :or or :and are liked, I guess there could be :keys schema for that?"><y>#</y><d>2020-04-08</d><h>04:36</h><w>ikitommi</w>I’m not a fond of too much extra syntax for <code>:map</code>. If the spec-like <code>:or</code> or <code>:and</code> are liked, I guess there could be <code>:keys</code> schema for that?</z><z id="t1586331908" t="kwrooijen Thanks! This does exactly what I need. One question for clarification though; When talking about too much extra syntax, do you mean :or / :and or are you referring to my pull request?"><y>#</y><d>2020-04-08</d><h>07:45</h><r>kwrooijen</r>Thanks! This does exactly what I need. One question for clarification though; When talking about too much extra syntax, do you mean <code>:or</code> / <code>:and</code> or are you referring to my pull request?</z><z id="t1586331992" t="ikitommi just referring to the :or and :and , like spec1 has."><y>#</y><d>2020-04-08</d><h>07:46</h><r>ikitommi</r>just referring to the <code>:or</code> and <code>:and</code> , like spec1 has.</z><z id="t1586332017" t="ikitommi will check the PRs as soon as have time. busy times."><y>#</y><d>2020-04-08</d><h>07:46</h><r>ikitommi</r>will check the PRs as soon as have time. busy times.</z><z id="t1586332157" t="kwrooijen Ahh ok thanks. Take your time!"><y>#</y><d>2020-04-08</d><h>07:49</h><r>kwrooijen</r>Ahh ok thanks. Take your time!</z><z id="t1586349131" t="yonatanel I need something similar and even a bit more complex. I want to require a value either at top level or nested: ;Valid: {:key1 &quot;yo&quot;} ;Also valid {:nested {:key2 &quot;yo&quot;}} It’s not the same key but they have the same meaning and one must exist. Currently I have this schema: [:or [:map [:key1 any?] [:nested {:optional true} [:map [:key2 {:optional true} any?]]]] [:map [:key1 {:optional true} any?] [:nested [:map [:key2 any?]]]]] but I have more keys like this, and some options can be either of 3 keys so I need 3 maps for each key and then combine all of it with :and."><y>#</y><d>2020-04-08</d><h>12:32</h><r>yonatanel</r>I need something similar and even a bit more complex. I want to require a value either at top level or nested:
<pre>;Valid:
{:key1 &quot;yo&quot;}

;Also valid
{:nested {:key2 &quot;yo&quot;}}</pre>
It’s not the same key but they have the same meaning and one must exist.
Currently I have this schema:
<pre>[:or
 [:map
  [:key1 any?]
  [:nested {:optional true} [:map [:key2 {:optional true} any?]]]]
 [:map
  [:key1 {:optional true} any?]
  [:nested [:map [:key2 any?]]]]]</pre>
but I have more keys like this, and some options can be either of 3 keys so I need 3 maps for each key and then combine all of it with :and.</z><z id="t1586320974" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] easiest way to attach a decoder just for that enum would be: (def Weighting [:enum {:decode/enum weighting-&gt;kw} :dB-A :dB-C :dB-Z]) and then applying it with: (m/decode MyMap {:weighting 0} (mt/transformer {:name :enum})) ; =&gt; {:weighting :dB-C}"><y>#</y><d>2020-04-08</d><h>04:42</h><w>ikitommi</w><a>@dcj</a> easiest way to attach a decoder just for that enum would be:
<pre>(def Weighting
  [:enum {:decode/enum weighting-&gt;kw} :dB-A :dB-C :dB-Z])</pre>
and then applying it with:
<pre>(m/decode MyMap {:weighting 0} (mt/transformer {:name :enum}))
; =&gt; {:weighting :dB-C}</pre></z><z id="t1586321114" t="ikitommi if you want to have a transformer for that, you can do the same as I gisted about the :postgres/table =&gt; add some hint to the enum and create a transformer that attaches in :compile just for that schema. hope this helps."><y>#</y><d>2020-04-08</d><h>04:45</h><w>ikitommi</w>if you want to have a transformer for that, you can do the same as I gisted about the <code>:postgres/table</code> =&gt; add some hint to the enum and create a transformer that attaches in <code>:compile</code> just for that schema. hope this helps.</z><z id="t1586352726" t="kwrooijen Yeah that&apos;s a good option as well. But that will probably lead to a lot of duplication (since my example was just a stripped down version)"><y>#</y><d>2020-04-08</d><h>13:32</h><w>kwrooijen</w>Yeah that&apos;s a good option as well. But that will probably lead to a lot of duplication (since my example was just a stripped down version)</z><z id="t1586355515" t="aisamu Yup, it was quite annoying"><y>#</y><d>2020-04-08</d><h>14:18</h><r>aisamu</r>Yup, it was quite annoying</z><z id="t1586513964" t="yonatanel [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] meanwhile I have this require-either function that adds :fn schema to the map with a humanized error message and makes the relevant keys optional ( https://gist.github.com/yonatane/7bd1d38449f56b3aea62eb391964aee4 )"><y>#</y><d>2020-04-10</d><h>10:19</h><w>yonatanel</w><a>@kevin.van.rooijen</a> meanwhile I have this <code>require-either</code> function that adds <code>:fn</code> schema to the map with a humanized error message and makes the relevant keys optional (<a href="https://gist.github.com/yonatane/7bd1d38449f56b3aea62eb391964aee4" target="_blank">https://gist.github.com/yonatane/7bd1d38449f56b3aea62eb391964aee4</a>)</z><z id="t1586633566" t="dcj Just to confirm: When specifying keys in a map schema, it is fine to http://use.so a namespaced keyword, eg: [:instrument/id int?] AFAICT from one quick test, this &quot;just works&quot;. The schema can be defined, and validate works as expected... Correct?"><y>#</y><d>2020-04-11</d><h>19:32</h><w>dcj</w>Just to confirm:  When specifying keys in a map schema, it is fine to <a href="http://use.so" target="_blank">http://use.so</a> a namespaced keyword, eg: <code>[:instrument/id int?]</code> AFAICT from one quick test, this &quot;just works&quot;.  The schema can be defined, and validate works as expected...  Correct?</z><z id="t1586636579" t="pithyless Yes. There&apos;s even an open documentation issue for this - https://github.com/metosin/malli/issues/189#issue-590324344"><y>#</y><d>2020-04-11</d><h>20:22</h><r>pithyless</r>Yes. There&apos;s even an open documentation issue for this - <a href="https://github.com/metosin/malli/issues/189#issue-590324344" target="_blank">https://github.com/metosin/malli/issues/189#issue-590324344</a></z><z id="t1586721767" t="sudakatux Hi"><y>#</y><d>2020-04-12</d><h>20:02</h><w>sudakatux</w>Hi</z><z id="t1586721826" t="sudakatux So im testing malli with cohersion and swagger. I was wondering when following the example online. the type dispatcher for swagger. its an empty object. how does one pass the descriminator value"><y>#</y><d>2020-04-12</d><h>20:03</h><w>sudakatux</w>So im testing malli with cohersion and swagger. I was wondering when following the example online. the type dispatcher for swagger. its an empty object. how does one pass the descriminator value</z><z id="t1586721843" t="sudakatux So multi here https://malli.io/?value=%5B%7B%3Atype%20%3Asized%2C%20%3Asize%2010%7D%0A%20%7B%3Atype%20%3Ahuman%2C%20%3Aname%20%22tiina%22%2C%20%3Aaddress%20%7B%3Astreet%20%22kikka%22%7D%7D%5D&amp;amp;schema=%5B%3Avector%0A%20%5B%3Amulti%0A%20%20%7B%3Adispatch%20%3Atype%7D%0A%20%20%5B%3Asized%20%5B%3Amap%20%5B%3Atype%20%5B%3A%3D%20%3Asized%5D%5D%20%5B%3Asize%20int%3F%5D%5D%5D%0A%20%20%5B%3Ahuman%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%3Ahuman%5D%5D%0A%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%5B%3Aaddress%20%5B%3Amap%20%5B%3Astreet%20string%3F%5D%5D%5D%5D%5D%5D%5D"><y>#</y><d>2020-04-12</d><h>20:04</h><w>sudakatux</w>So multi here <a href="https://malli.io/?value=%5B%7B%3Atype%20%3Asized%2C%20%3Asize%2010%7D%0A%20%7B%3Atype%20%3Ahuman%2C%20%3Aname%20%22tiina%22%2C%20%3Aaddress%20%7B%3Astreet%20%22kikka%22%7D%7D%5D&amp;amp;schema=%5B%3Avector%0A%20%5B%3Amulti%0A%20%20%7B%3Adispatch%20%3Atype%7D%0A%20%20%5B%3Asized%20%5B%3Amap%20%5B%3Atype%20%5B%3A%3D%20%3Asized%5D%5D%20%5B%3Asize%20int%3F%5D%5D%5D%0A%20%20%5B%3Ahuman%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%3Ahuman%5D%5D%0A%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%5B%3Aaddress%20%5B%3Amap%20%5B%3Astreet%20string%3F%5D%5D%5D%5D%5D%5D%5D" target="_blank">https://malli.io/?value=%5B%7B%3Atype%20%3Asized%2C%20%3Asize%2010%7D%0A%20%7B%3Atype%20%3Ahuman%2C%20%3Aname%20%22tiina%22%2C%20%3Aaddress%20%7B%3Astreet%20%22kikka%22%7D%7D%5D&amp;amp;schema=%5B%3Avector%0A%20%5B%3Amulti%0A%20%20%7B%3Adispatch%20%3Atype%7D%0A%20%20%5B%3Asized%20%5B%3Amap%20%5B%3Atype%20%5B%3A%3D%20%3Asized%5D%5D%20%5B%3Asize%20int%3F%5D%5D%5D%0A%20%20%5B%3Ahuman%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%3Ahuman%5D%5D%0A%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%5B%3Aaddress%20%5B%3Amap%20%5B%3Astreet%20string%3F%5D%5D%5D%5D%5D%5D%5D</a></z><z id="t1586721872" t="sudakatux the type attribute. say i want to pass that value. how should i pass it"><y>#</y><d>2020-04-12</d><h>20:04</h><w>sudakatux</w>the type attribute. say i want to pass that value. how should i pass it</z><z id="t1586721915" t="sudakatux because in swagger its shown like :properties {:type {},"><y>#</y><d>2020-04-12</d><h>20:05</h><w>sudakatux</w>because in swagger its shown like <code>:properties {:type {},</code></z><z id="t1586763423" t="ikitommi maybe :swagger/discriminator :type ?"><y>#</y><d>2020-04-13</d><h>07:37</h><w>ikitommi</w>maybe <code>:swagger/discriminator :type</code>?</z><z id="t1586763491" t="ikitommi haven’t used the discriminator, so not sure how it should work. what is the expected swagger schema?"><y>#</y><d>2020-04-13</d><h>07:38</h><w>ikitommi</w>haven’t used the discriminator, so not sure how it should work. what is the expected swagger schema?</z><z id="t1586774702" t="sudakatux so i would expect i could &quot;type&quot;:&quot;mytype&quot;"><y>#</y><d>2020-04-13</d><h>10:45</h><w>sudakatux</w>so i would expect i could &quot;type&quot;:&quot;mytype&quot;</z><z id="t1586774705" t="sudakatux GM"><y>#</y><d>2020-04-13</d><h>10:45</h><w>sudakatux</w>GM</z><z id="t1586775018" t="sudakatux So my probelm was that i could not POST since it could not figure out the type"><y>#</y><d>2020-04-13</d><h>10:50</h><w>sudakatux</w>So my probelm was that i could not POST since it could not figure out the type</z><z id="t1586775042" t="sudakatux the way i got what i wanted was by doing this"><y>#</y><d>2020-04-13</d><h>10:50</h><w>sudakatux</w>the way i got what i wanted was by doing this</z><z id="t1586775076" t="sudakatux (m/validate schema (m/decode schema data (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer)))))"><y>#</y><d>2020-04-13</d><h>10:51</h><w>sudakatux</w><pre>(m/validate schema (m/decode
    schema data
    (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer)))))</pre></z><z id="t1586775085" t="sudakatux where schema is"><y>#</y><d>2020-04-13</d><h>10:51</h><w>sudakatux</w>where schema is</z><z id="t1586775116" t="sudakatux [:multi {:dispatch :type, :decode/string (fn* [p1__40150#] (update p1__40150# :type keyword))} [:other [:map [:data [:map [:nombre string?] [:apellido string?] [:edad int?]]] [:type [:= :other]]]] [:one [:map [:data [:map [:nombre string?] [:apellido string?] [:kk int?]]] [:type [:= :one]]]]]"><y>#</y><d>2020-04-13</d><h>10:51</h><w>sudakatux</w><pre>[:multi
 {:dispatch :type, :decode/string (fn* [p1__40150#] (update p1__40150# :type keyword))}
 [:other [:map [:data [:map [:nombre string?] [:apellido string?] [:edad int?]]] [:type [:= :other]]]]
 [:one [:map [:data [:map [:nombre string?] [:apellido string?] [:kk int?]]] [:type [:= :one]]]]]</pre></z><z id="t1586775178" t="sudakatux and data"><y>#</y><d>2020-04-13</d><h>10:52</h><w>sudakatux</w>and data</z><z id="t1586775180" t="sudakatux {:data {:nombre &quot;nombre&quot; :apellido &quot;apellido&quot; :edad 12} :type &quot;other&quot;}"><y>#</y><d>2020-04-13</d><h>10:53</h><w>sudakatux</w><pre>{:data {:nombre &quot;nombre&quot; :apellido &quot;apellido&quot; :edad 12} :type &quot;other&quot;}</pre></z><z id="t1586775267" t="sudakatux on an ideal I would have liked to be able to use that schema in the {:paremeters {:body here}}"><y>#</y><d>2020-04-13</d><h>10:54</h><w>sudakatux</w>on an ideal I would have liked to be able to use that schema in the <code>{:paremeters {:body here}}</code></z><z id="t1586782876" t="plexus am I right that this is not supported? should it be? (def m [:map [:i {:error/message &quot;not a number&quot;} int?]]) (me/humanize (m/explain m {:i &quot;123&quot;})) ;; =&gt; {:i [&quot;should be int&quot;]}"><y>#</y><d>2020-04-13</d><h>13:01</h><w>plexus</w>am I right that this is not supported? should it be?
<pre>(def m [:map
          [:i {:error/message &quot;not a number&quot;} int?]])

  (me/humanize (m/explain m {:i &quot;123&quot;}))
  ;; =&gt; {:i [&quot;should be int&quot;]}</pre></z><z id="t1586782973" t="plexus I find in general there&apos;s some annoying asymmetry between properties on map entries vs properties schemas. See also my PR for adding :gen/gen / :gen/elements / :gen/fmap support to map entries"><y>#</y><d>2020-04-13</d><h>13:02</h><w>plexus</w>I find in general there&apos;s some annoying asymmetry between properties on map entries vs properties schemas. See also my PR for adding <code>:gen/gen</code> / <code>:gen/elements</code> / <code>:gen/fmap</code> support to map entries</z><z id="t1586783264" t="sudakatux sorry deleted the message by mistake"><y>#</y><d>2020-04-13</d><h>13:07</h><r>sudakatux</r>sorry deleted the message by mistake</z><z id="t1586783268" t="sudakatux will take a look"><y>#</y><d>2020-04-13</d><h>13:07</h><r>sudakatux</r>will take a look</z><z id="t1586783316" t="plexus thanks [:attrs {:href &quot;/_/_/users/U8JTE9PG8&quot;}] . I&apos;m interested in general if users should expect props on schemas to also work on map entries, or if that&apos;s not a design goal."><y>#</y><d>2020-04-13</d><h>13:08</h><r>plexus</r>thanks <a>@U8JTE9PG8</a>. I&apos;m interested in general if users should expect props on schemas to also work on map entries, or if that&apos;s not a design goal.</z><z id="t1586968011" t="ikitommi Thanks [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] for the PR! Will check it soon along others. I would like to have first class entry meta, not sure what is the best way for it."><y>#</y><d>2020-04-15</d><h>16:26</h><r>ikitommi</r>Thanks <a>@U07FP7QJ0</a> for the PR! Will check it soon along others. I would like to have first class entry meta, not sure what is the best way for it.</z><z id="t1586783128" t="plexus I suppose you can do this (def m [:map [:i [int? {:error/message &quot;not a number&quot;}]]])"><y>#</y><d>2020-04-13</d><h>13:05</h><w>plexus</w>I suppose you can do this
<pre>(def m [:map
          [:i
           [int? {:error/message &quot;not a number&quot;}]]])</pre></z><z id="t1586958245" t="orestis I saw the ClojureD talk where it’s mention that there was some experiments tying malli and clj-kondo together. Is that code somewhere available? I’d love to have compile-time checks of some map usage. I don’t care particularly about the syntax right now, mostly about the hooking up kondo and its analyzer to validate malli schemas."><y>#</y><d>2020-04-15</d><h>13:44</h><w>orestis</w>I saw the ClojureD talk where it’s mention that there was some experiments tying malli and clj-kondo together. Is that code somewhere available? I’d love to have compile-time checks of some map usage. I don’t care particularly about the syntax right now, mostly about the hooking up kondo and its analyzer to validate malli schemas.</z><z id="t1586967777" t="ikitommi [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] it was a quick hack, not published to repo. The m/defn is [:attrs nil] day to make it real."><y>#</y><d>2020-04-15</d><h>16:22</h><w>ikitommi</w><a>@orestis</a> it was a quick hack, not published to repo. The <code>m/defn</code> is <del>1:1 from plumatic schema, emitting a clj-kondo file into the project. No generic conversion and plumatic port just a poc. Would take a </del>day to make it real.</z><z id="t1586968111" t="orestis So essentially it was just emitting clj-kondo specific schemas for the function, right? As if you hand-typed the kondo conf manually. I can work with that..."><y>#</y><d>2020-04-15</d><h>16:28</h><r>orestis</r>So essentially it was just emitting clj-kondo specific schemas for the function, right? As if you hand-typed the kondo conf manually. I can work with that...</z><z id="t1586968328" t="ikitommi yes. Generic malli Schema -&gt; clj-kondo schema transformer would be great - and relatively easy to do, just like the json-schema transformer."><y>#</y><d>2020-04-15</d><h>16:32</h><r>ikitommi</r>yes. Generic malli Schema -&gt; clj-kondo schema transformer would be great - and relatively easy to do, just like the json-schema transformer.</z><z id="t1586968152" t="ikitommi [:attrs {:href &quot;/_/_/users/U8JTE9PG8&quot;}] if you know the form of the swagger schema, you could add the swagger transformation for :multi . It&apos;s an multimethod doing that, so can be done in user space. PR welcome when it works ;)"><y>#</y><d>2020-04-15</d><h>16:29</h><w>ikitommi</w><a>@jstuartmilne</a> if you know the form of the swagger schema, you could add the swagger transformation for <code>:multi</code>. It&apos;s an multimethod doing that, so can be done in user space. PR welcome when it works ;)</z><z id="t1586968205" t="ikitommi Also, you can write the swagger manually, just add a :swagger key to schema and a full schema as value. Overrides everything"><y>#</y><d>2020-04-15</d><h>16:30</h><w>ikitommi</w>Also, you can write the swagger manually, just add a <code>:swagger</code> key to schema and a full schema as value. Overrides everything</z><z id="t1587077502" t="sudakatux cool thanks. it working how i want now 🙂"><y>#</y><d>2020-04-16</d><h>22:51</h><r>sudakatux</r>cool thanks. it working how i want now <b>🙂</b></z><z id="t1587030088" t="grounded_sage This bug https://github.com/metosin/malli/issues/196 is pretty critical for us atm. I’m happy to try jump in and fix if someone can point me in the right direction with some ideas on how to fix it."><y>#</y><d>2020-04-16</d><h>09:41</h><w>grounded_sage</w>This bug <a href="https://github.com/metosin/malli/issues/196" target="_blank">https://github.com/metosin/malli/issues/196</a> is pretty critical for us atm. I’m happy to try jump in and fix if someone can point me in the right direction with some ideas on how to fix it.</z><z id="t1587038571" t="ikitommi [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] I think the culprit is here: https://github.com/metosin/malli/blob/master/src/malli/provider.cljc#L41"><y>#</y><d>2020-04-16</d><h>12:02</h><w>ikitommi</w><a>@grounded_sage</a> I think the culprit is here: <a href="https://github.com/metosin/malli/blob/master/src/malli/provider.cljc#L41" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/provider.cljc#L41</a></z><z id="t1587038630" t="ikitommi for empty sequences, it tries to figure out what is a valid schema and finds empty :or"><y>#</y><d>2020-04-16</d><h>12:03</h><r>ikitommi</r>for empty sequences, it tries to figure out what is a valid schema and finds empty <code>:or</code></z><z id="t1587038707" t="ikitommi (require &apos;[malli.provider]) (malli.provider/provide [[]]) ; =&gt; [:vector [:or]]"><y>#</y><d>2020-04-16</d><h>12:05</h><r>ikitommi</r><pre>(require &apos;[malli.provider])
(malli.provider/provide [[]])
; =&gt; [:vector [:or]]</pre></z><z id="t1587039905" t="ikitommi [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] should be fixed in master."><y>#</y><d>2020-04-16</d><h>12:25</h><w>ikitommi</w><a>@grounded_sage</a> should be fixed in master.</z><z id="t1587046972" t="grounded_sage Legend! "><y>#</y><d>2020-04-16</d><h>14:22</h><r>grounded_sage</r>Legend! </z><z id="t1587040063" t="ikitommi (provide []) ; =&gt; any? (provide [[]]) ; =&gt; [:vector any?] (provide [[[[[[[]]]]]]]) ; =&gt; [:vector [:vector [:vector [:vector [:vector [:vector any?]]]]]]"><y>#</y><d>2020-04-16</d><h>12:27</h><w>ikitommi</w><pre>(provide [])
; =&gt; any?

(provide [[]])
; =&gt; [:vector any?]

(provide [[[[[[[]]]]]]])
; =&gt; [:vector [:vector [:vector [:vector [:vector [:vector any?]]]]]]</pre></z><z id="t1587047107" t="grounded_sage This is so helpful for the work I am doing atm where we are ingesting messy JSON from third parties. I use Malli to show me all the variations of schemas their JSON can have. Check the frequencies to see which ones we want to support. Can deep diff the schemas to see the differences. Then use the generated unified schema as the base for robust Meander pattern matching. "><y>#</y><d>2020-04-16</d><h>14:25</h><w>grounded_sage</w>This is so helpful for the work I am doing atm where we are ingesting messy JSON from third parties. I use Malli to show me all the variations of schemas their JSON can have. Check the frequencies to see which ones we want to support. Can deep diff the schemas to see the differences. Then use the generated unified schema as the base for robust Meander pattern matching. </z><z id="t1587054689" t="ikitommi Sounds cool! do you write the meander definitions manually or programmatically from schemas?"><y>#</y><d>2020-04-16</d><h>16:31</h><w>ikitommi</w>Sounds cool! do you write the meander definitions manually or programmatically from schemas?</z><z id="t1587055239" t="grounded_sage Create them manually. Would be interesting to see if I can generate a nice starting point from a Malli schema.. haven’t dove in that much yet to see if it’s practical."><y>#</y><d>2020-04-16</d><h>16:40</h><w>grounded_sage</w>Create them manually. Would be interesting to see if I can generate a nice starting point from a Malli schema.. haven’t dove in that much yet to see if it’s practical.</z><z id="t1587055412" t="grounded_sage Reminds me I did find another bug or unexpected behaviour earlier. Where doing unions over a number of schemas resulted in created some nested schema definitions that weren’t there. I got around this by just capturing the original JSON for the various schemas"><y>#</y><d>2020-04-16</d><h>16:43</h><w>grounded_sage</w>Reminds me I did find another bug or unexpected behaviour earlier. Where doing unions over a number of schemas resulted in created some nested schema definitions that weren’t there. I got around this by just capturing the original JSON for the various schemas</z><z id="t1587328768" t="teodorlu Are anyone using Malli for recursive schemas? Attached schema generated with malli.provider/provide . In spec, I&apos;d do something like this (not tested, and missing some properties): (s/def ::title string?) (s/def ::children (s/coll-of ::node)) (s/def ::node (s/keys :req-un [::title ::children]))"><y>#</y><d>2020-04-19</d><h>20:39</h><w>teodorlu</w>Are anyone using Malli for recursive schemas? Attached schema generated with <code>malli.provider/provide</code>.

In spec, I&apos;d do something like this (not tested, and missing some properties):

<pre>(s/def ::title string?)
(s/def ::children (s/coll-of ::node))

(s/def ::node
  (s/keys :req-un [::title
                   ::children]))</pre></z><z id="t1587331858" t="roklenarcic I am trying to add an error message to an existing schema, I tried simply saying: [:and {:error/message &quot;X&quot;} myschema] and that didn’t work"><y>#</y><d>2020-04-19</d><h>21:30</h><w>roklenarcic</w>I am trying to add an error message to an existing schema, I tried simply saying: <code>[:and {:error/message &quot;X&quot;} myschema]</code> and that didn’t work</z><z id="t1587363022" t="eskos :and requires two leaves, you have only one."><y>#</y><d>2020-04-20</d><h>06:10</h><w>eskos</w><code>:and</code> requires two leaves, you have only one.</z><z id="t1587364086" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What would be your preferred media for discussing some design choices malli could potentially have a stake in? I’ve been thinking for quite a while that there’s two topics I’d like to have persistently discussed, decided and documented, namely the plumbing&amp;porcelain concept for schemas themselves I’ve mentioned before and swagger2 vs openapi3 vs postman collections generation, and while we could discuss those things here, the ephemeral nature of Slack and this unpaid Clojurians Slack instance especially isn’t very good documentation wise… 🙂"><y>#</y><d>2020-04-20</d><h>06:28</h><w>eskos</w><a>@ikitommi</a> What would be your preferred media for discussing some design choices malli could potentially have a stake in? I’ve been thinking for quite a while that there’s two topics I’d like to have persistently discussed, decided and documented, namely the plumbing&amp;porcelain concept for schemas themselves I’ve mentioned before and swagger2 vs openapi3 vs postman collections generation, and while we could discuss those things here, the ephemeral nature of Slack and this unpaid Clojurians Slack instance especially isn’t very good documentation wise… <b>🙂</b></z><z id="t1587391847" t="aisamu I&apos;ll just chime in to mention that some folks here (#data-science IIRC) have been using Zulip for that with apparent success! Doesn&apos;t lose history and has a much better (i.e. usable) threading model"><y>#</y><d>2020-04-20</d><h>14:10</h><r>aisamu</r>I&apos;ll just chime in to mention that some folks here (#data-science IIRC) have been using Zulip for that with apparent success!
Doesn&apos;t lose history and has a much better (i.e. usable) threading model</z><z id="t1587396127" t="teodorlu Second chime in: I&apos;ve been using Zulip quite a bit, and I think I prefer it to Slack. I don&apos;t see a huge difference, but it would be possible to have a single malli channel with different topics, where design could be one."><y>#</y><d>2020-04-20</d><h>15:22</h><r>teodorlu</r>Second chime in: I&apos;ve been using Zulip quite a bit, and I think I prefer it to Slack. I don&apos;t see a huge difference, but it would be possible to have a single malli channel with different topics, where <code>design</code> could be one.</z><z id="t1587396322" t="aisamu Yup! I actually consume this slack&apos;s content through Zulip&apos;s mirror."><y>#</y><d>2020-04-20</d><h>15:25</h><r>aisamu</r>Yup!
I actually consume this slack&apos;s content through Zulip&apos;s mirror.</z><z id="t1587396357" t="teodorlu Huh, cool. Didn&apos;t know that was possible. Do you happen to have a link?"><y>#</y><d>2020-04-20</d><h>15:25</h><r>teodorlu</r>Huh, cool. Didn&apos;t know that was possible. Do you happen to have a link?</z><z id="t1587396629" t="aisamu Sure! https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli Each one of slack-archive &apos;s topics is a channel (after you invite [:attrs {:href &quot;/_/_/users/UFNE73UF4&quot;}] , that is)"><y>#</y><d>2020-04-20</d><h>15:30</h><r>aisamu</r>Sure!

<a href="https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli" target="_blank">https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli</a>

Each one of  <code>slack-archive</code>&apos;s topics is a channel (after you invite <a>@UFNE73UF4</a>, that is)</z></g><g id="s4"><z id="t1587397287" t="eskos Looks like Zulip’s free tier has limited search, are you sure it’s not going to lose history?"><y>#</y><d>2020-04-20</d><h>15:41</h><r>eskos</r>Looks like Zulip’s free tier has limited search, are you sure it’s not going to lose history?</z><z id="t1587397301" t="eskos Or is someone paying/hosting that? 🙂 Sorry, not familiar with Zulip’s hosting scheme…"><y>#</y><d>2020-04-20</d><h>15:41</h><r>eskos</r>Or is someone paying/hosting that? <b>🙂</b> Sorry, not familiar with Zulip’s hosting scheme…</z><z id="t1587397499" t="aisamu &gt; Zulip Cloud Standard is free for open source projects! 🎉"><y>#</y><d>2020-04-20</d><h>15:44</h><r>aisamu</r>&gt; Zulip Cloud Standard is free for open source projects!
<b>🎉</b></z><z id="t1587449484" t="eskos [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] that could maybe actually work for Metosin’s OSS? --^"><y>#</y><d>2020-04-21</d><h>06:11</h><r>eskos</r><a>@ikitommi</a> that could maybe actually work for Metosin’s OSS? --^</z><z id="t1587465056" t="eval2020 Zulip-admin here. We&apos;re indeed using Zulip&apos;s OSS-plan ( https://www.zulipchat.com/for/open-source/ ) Happy to answer any more questions."><y>#</y><d>2020-04-21</d><h>10:30</h><r>eval2020</r>Zulip-admin here. We&apos;re indeed using Zulip&apos;s OSS-plan (<a href="https://www.zulipchat.com/for/open-source/" target="_blank">https://www.zulipchat.com/for/open-source/</a>)
Happy to answer any more questions.</z><z id="t1587465098" t="eval2020 btw I see [:attrs {:href &quot;/_/_/users/UFNE73UF4&quot;}] is no longer a member of this channel... :thinking_face:"><y>#</y><d>2020-04-21</d><h>10:31</h><r>eval2020</r>btw I see <a>@UFNE73UF4</a> is no longer a member of this channel... <b>:thinking_face:</b></z><z id="t1587466699" t="eval2020 scratch that (bots don’t appear in the member-list)"><y>#</y><d>2020-04-21</d><h>10:58</h><r>eval2020</r>scratch that (bots don’t appear in the member-list)</z><z id="t1587477796" t="teodorlu Thanks for keeping Zulip working 🙂 It&apos;s been really helpful for doing Scicloj-work 💯"><y>#</y><d>2020-04-21</d><h>14:03</h><r>teodorlu</r>Thanks for keeping Zulip working <b>🙂</b> It&apos;s been really helpful for doing Scicloj-work <b>💯</b></z><z id="t1587479908" t="eval2020 yw!, great to hear."><y>#</y><d>2020-04-21</d><h>14:38</h><r>eval2020</r>yw!, great to hear.</z><z id="t1587545351" t="plexus late to the thread here but I&apos;d like to propose ClojureVerse for this. Long form asynchronous is more suitable for writing out proposals and discussing their merit. Happy to set up a Malli category."><y>#</y><d>2020-04-22</d><h>08:49</h><r>plexus</r>late to the thread here but I&apos;d like to propose ClojureVerse for this. Long form asynchronous is more suitable for writing out proposals and discussing their merit. Happy to set up a Malli category.</z><z id="t1587558118" t="aisamu Worth noting that Zulip also favours long form, async content (with proper quoting, nesting, etc) given the threading model. (And I also consume ClojureVerse through Zulip&apos;s mirror - annoucements, but still) simple_smile"><y>#</y><d>2020-04-22</d><h>12:21</h><r>aisamu</r>Worth noting that Zulip also favours long form, async content (with proper quoting, nesting, etc) given the threading model.

(And I also consume ClojureVerse through Zulip&apos;s mirror - annoucements, but still) <b>simple_smile</b></z><z id="t1587636353" t="ikitommi oh, what would the category mean? all the discussion still go to the main feed?"><y>#</y><d>2020-04-23</d><h>10:05</h><r>ikitommi</r>oh, what would the category mean? all the discussion still go to the main feed?</z><z id="t1587636511" t="ikitommi But, as the discussions are anyway in threads in clojureverse, one could just not read the malli thread/s if that’s not relevant to them."><y>#</y><d>2020-04-23</d><h>10:08</h><r>ikitommi</r>But, as the discussions are anyway in threads in clojureverse, one could just not read the malli thread/s if that’s not relevant to them.</z><z id="t1587639816" t="teodorlu [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Here are all the project threads: https://clojureverse.org/c/projects/24 And here&apos;s the shadow-CLJS category: https://clojureverse.org/c/projects/shadow-cljs/20"><y>#</y><d>2020-04-23</d><h>11:03</h><r>teodorlu</r><a>@ikitommi</a>
Here are all the project threads: <a href="https://clojureverse.org/c/projects/24" target="_blank">https://clojureverse.org/c/projects/24</a>

And here&apos;s the shadow-CLJS category:
<a href="https://clojureverse.org/c/projects/shadow-cljs/20" target="_blank">https://clojureverse.org/c/projects/shadow-cljs/20</a></z><z id="t1587364915" t="ikitommi [:attrs {:href &quot;/_/_/users/U3X7174KS&quot;}] recursion schemas, discussion here: https://github.com/metosin/malli/issues/20"><y>#</y><d>2020-04-20</d><h>06:41</h><w>ikitommi</w><a>@teodorlu</a> recursion schemas, discussion here: <a href="https://github.com/metosin/malli/issues/20" target="_blank">https://github.com/metosin/malli/issues/20</a></z><z id="t1587367673" t="teodorlu Thanks for the reference!"><y>#</y><d>2020-04-20</d><h>07:27</h><r>teodorlu</r>Thanks for the reference!</z><z id="t1587365319" t="ikitommi [:attrs {:href &quot;/_/_/users/U66G3SGP5&quot;}] [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] there are two ways that the properties are used: 1. top-down: generators use this. the first generator that is found is used. [:and {:gen/elements [&quot;a&quot; &quot;b&quot; &quot;c&quot;], :error/message &quot;fail&quot;} string?] short-circuits on that gen. decoders &amp; encoders compose top-down, json-schema overrides work this way etc. 2. after-the-fact: error messages are looked for after the error has happened. here: it the example, the failure happens at string? , which doesn’t know any of the parent decorations for errors. this is bad, and should be fixed in a coherent way, related issues: https://github.com/metosin/malli/issues/120 &amp; https://github.com/metosin/malli/issues/86"><y>#</y><d>2020-04-20</d><h>06:48</h><w>ikitommi</w><a>@roklenarcic</a> <a>@suomi.esko</a> there are two ways that the properties are used:
1. top-down: generators use this. the first generator that is found is used. <code>[:and {:gen/elements [&quot;a&quot; &quot;b&quot; &quot;c&quot;], :error/message &quot;fail&quot;} string?]</code> short-circuits on that gen. decoders &amp; encoders compose top-down, json-schema overrides work this way etc.
2. after-the-fact: error messages are looked for after the error has happened. here: it the example, the failure happens at <code>string?</code> , which doesn’t know any of the parent decorations for errors.
this is bad, and should be fixed in a coherent way, related issues: <a href="https://github.com/metosin/malli/issues/120" target="_blank">https://github.com/metosin/malli/issues/120</a> &amp; <a href="https://github.com/metosin/malli/issues/86" target="_blank">https://github.com/metosin/malli/issues/86</a></z><z id="t1587365409" t="ikitommi the error message thing could be “easily” fixed so that the error message formatter looks also at the parent schemas (all the information is available in malli.core/explain result."><y>#</y><d>2020-04-20</d><h>06:50</h><w>ikitommi</w>the error message thing could be “easily” fixed so that the error message formatter looks also at the parent schemas (all the information is available in <code>malli.core/explain</code> result.</z><z id="t1587365460" t="ikitommi … but would not solve [:map [:x {:error/message &quot;fail&quot;} string?]]] , where the info is in the entry meta."><y>#</y><d>2020-04-20</d><h>06:51</h><w>ikitommi</w>… but would not solve <code>[:map [:x {:error/message &quot;fail&quot;} string?]]]</code>, where the info is in the entry meta.</z><z id="t1587365509" t="ikitommi ideas welcome, will put my hammock on the backyard this week, so will think about how to do this"><y>#</y><d>2020-04-20</d><h>06:51</h><w>ikitommi</w>ideas welcome, will put my hammock on the backyard this week, so will think about how to do this</z><z id="t1587365811" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] maybe a open malli video chat? google hangouts for example later this week? issues have persistent discussion, but as things link, the discussion is bit scattered."><y>#</y><d>2020-04-20</d><h>06:56</h><w>ikitommi</w><a>@suomi.esko</a> maybe a open malli video chat? google hangouts for example later this week? issues have persistent discussion, but as things link, the discussion is bit scattered.</z><z id="t1587366798" t="eskos Hmm, video chat could probably be an interesting way to solve this, as I have no idea if this is like 5, 15 or 50 minute topic and it’s not quite clear to myself either entirely what the whole scope is…"><y>#</y><d>2020-04-20</d><h>07:13</h><w>eskos</w>Hmm, video chat could probably be an interesting way to solve this, as I have no idea if this is like 5, 15 or 50 minute topic and it’s not quite clear to myself either entirely what the whole scope is…</z><z id="t1587391847" t="aisamu I&apos;ll just chime in to mention that some folks here (#data-science IIRC) have been using Zulip for that with apparent success! Doesn&apos;t lose history and has a much better (i.e. usable) threading model"><y>#</y><d>2020-04-20</d><h>14:10</h><w>aisamu</w>I&apos;ll just chime in to mention that some folks here (#data-science IIRC) have been using Zulip for that with apparent success!
Doesn&apos;t lose history and has a much better (i.e. usable) threading model</z><z id="t1587415918" t="ikitommi (def Country [:map {:id &quot;Country&quot;} [:name [:enum :FI :PO]] [:neighbors any?]]) (def Burger [:map {:id &quot;Burger&quot;} [:name string?] [:description {:optional true} string?] [:origin [:maybe [:maybe Country]]] [:price pos-int?]]) (def OrderLine [:map {:id &quot;OrderLine&quot;} [:burger Burger] [:amount int?]]) (def Order [:map {:id &quot;Order&quot;} [:lines [:vector OrderLine]] [:delivery [:map [:delivered boolean?] [:address [:map [:street string?] [:zip int?] [:country Country]]]]]])"><y>#</y><d>2020-04-20</d><h>20:51</h><w>ikitommi</w><pre>(def Country
  [:map {:id &quot;Country&quot;}
   [:name [:enum :FI :PO]]
   [:neighbors any?]])

(def Burger
  [:map {:id &quot;Burger&quot;}
   [:name string?]
   [:description {:optional true} string?]
   [:origin [:maybe [:maybe Country]]]
   [:price pos-int?]])

(def OrderLine
  [:map {:id &quot;OrderLine&quot;}
   [:burger Burger]
   [:amount int?]])

(def Order
  [:map {:id &quot;Order&quot;}
   [:lines [:vector OrderLine]]
   [:delivery [:map
               [:delivered boolean?]
               [:address [:map
                          [:street string?]
                          [:zip int?]
                          [:country Country]]]]]])</pre></z><z id="t1587415968" t="ikitommi (require &apos;[malli.mermaid :as mermaid]) (mermaid/class-diagram Order) ;&quot;classDiagram ; class Country { ; + :name [:enum :FI :PO] ; + :neighbors any? ; } ; class Burger { ; + :name string? ; + :description string? ; + :origin Country ; + :price pos-int? ; } ; Burger o-- Country ; class OrderLine { ; + :burger Burger ; + :amount int? ; } ; OrderLine o-- Burger ; class OrderDeliveryAddress { ; &lt;&lt;embedded&gt;&gt; ; + :street string? ; + :zip int? ; + :country Country ; } ; OrderDeliveryAddress o-- Country ; class OrderDelivery { ; &lt;&lt;embedded&gt;&gt; ; + :delivered boolean? ; + :address OrderDeliveryAddress ; } ; OrderDelivery *-- OrderDeliveryAddress ; class Order { ; + :lines OrderLine ; + :delivery OrderDelivery ; } ; Order o-- OrderLine ; Order *-- OrderDelivery&quot;"><y>#</y><d>2020-04-20</d><h>20:52</h><w>ikitommi</w><pre>(require &apos;[malli.mermaid :as mermaid])

(mermaid/class-diagram Order)
;&quot;classDiagram
;   class Country {
;     + :name [:enum :FI :PO]
;     + :neighbors any?
;   }
;   class Burger {
;     + :name string?
;     + :description string?
;     + :origin Country
;     + :price pos-int?
;   }
;   Burger o-- Country
;   class OrderLine {
;     + :burger Burger
;     + :amount int?
;   }
;   OrderLine o-- Burger
;   class OrderDeliveryAddress {
;     &lt;&lt;embedded&gt;&gt;
;     + :street string?
;     + :zip int?
;     + :country Country
;   }
;   OrderDeliveryAddress o-- Country
;   class OrderDelivery {
;     &lt;&lt;embedded&gt;&gt;
;     + :delivered boolean?
;     + :address OrderDeliveryAddress
;   }
;   OrderDelivery *-- OrderDeliveryAddress
;   class Order {
;     + :lines OrderLine
;     + :delivery OrderDelivery
;   }
;   Order o-- OrderLine
;   Order *-- OrderDelivery&quot;</pre></z><z id="t1587415981" t="ikitommi"><y>#</y><d>2020-04-20</d><h>20:53</h><w>ikitommi</w></z><z id="t1587415995" t="ikitommi https://github.com/metosin/malli/pull/198"><y>#</y><d>2020-04-20</d><h>20:53</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/198" target="_blank">https://github.com/metosin/malli/pull/198</a></z><z id="t1587416069" t="ikitommi (59 loc 😉 )"><y>#</y><d>2020-04-20</d><h>20:54</h><w>ikitommi</w>(59 loc <b>😉</b>)</z><z id="t1587420050" t="kwrooijen Wow that&apos;s awesome"><y>#</y><d>2020-04-20</d><h>22:00</h><w>kwrooijen</w>Wow that&apos;s awesome</z><z id="t1587420275" t="kwrooijen The tree structure logic is the mermaid namespace, right? I think it could be useful to have generic function to generate a dependency tree"><y>#</y><d>2020-04-20</d><h>22:04</h><w>kwrooijen</w>The tree structure logic is the mermaid namespace, right? I think it could be useful to have generic function to generate a dependency tree</z><z id="t1587545351" t="plexus late to the thread here but I&apos;d like to propose ClojureVerse for this. Long form asynchronous is more suitable for writing out proposals and discussing their merit. Happy to set up a Malli category."><y>#</y><d>2020-04-22</d><h>08:49</h><w>plexus</w>late to the thread here but I&apos;d like to propose ClojureVerse for this. Long form asynchronous is more suitable for writing out proposals and discussing their merit. Happy to set up a Malli category.</z><z id="t1587558118" t="aisamu Worth noting that Zulip also favours long form, async content (with proper quoting, nesting, etc) given the threading model. (And I also consume ClojureVerse through Zulip&apos;s mirror - annoucements, but still) simple_smile"><y>#</y><d>2020-04-22</d><h>12:21</h><w>aisamu</w>Worth noting that Zulip also favours long form, async content (with proper quoting, nesting, etc) given the threading model.

(And I also consume ClojureVerse through Zulip&apos;s mirror - annoucements, but still) <b>simple_smile</b></z><z id="t1587446293" t="ikitommi now in malli.mermaid , but could push some of the building blocks into malli.util : • function to resolve names for the anonymous nested schemas • function to pull out relations between schemas that match a precidate"><y>#</y><d>2020-04-21</d><h>05:18</h><w>ikitommi</w>now in <code>malli.mermaid</code>, but could push some of the building blocks into <code>malli.util</code>:
• function to resolve names for the anonymous nested schemas
• function to pull out relations between schemas that match a precidate</z><z id="t1587446409" t="ikitommi the actual mermaid code would be ~20 lines. would be easy to add a DOT printer too."><y>#</y><d>2020-04-21</d><h>05:20</h><w>ikitommi</w>the actual mermaid code would be ~20 lines. would be easy to add a DOT printer too.</z><z id="t1587446495" t="ikitommi mermaid doesn’t seem to allow special symbols in the class names, would have liked Order$Delivery$Address instead for the derived class names, easier not to clash. DOT allows that."><y>#</y><d>2020-04-21</d><h>05:21</h><w>ikitommi</w>mermaid doesn’t seem to allow special symbols in the class names, would have liked <code>Order$Delivery$Address</code> instead for the derived class names, easier not to clash. DOT allows that.</z><z id="t1587502818" t="geraldodev Hi , I was trying to create a malli zipper and was using children to get down the tree. It happens that it crashes when there is no children. Is there a function for that ?"><y>#</y><d>2020-04-21</d><h>21:00</h><w>geraldodev</w>Hi , I was trying to create a malli zipper and was using children to get down the tree. It happens that it crashes when there is no children. Is there a function for that ?</z><z id="t1587503029" t="geraldodev https://gist.github.com/geraldodev/f637da76bdac78fe8f7e330db43fe311 A malli zipper if anyone want to criticize is more than welcome"><y>#</y><d>2020-04-21</d><h>21:03</h><w>geraldodev</w><a href="https://gist.github.com/geraldodev/f637da76bdac78fe8f7e330db43fe311" target="_blank">https://gist.github.com/geraldodev/f637da76bdac78fe8f7e330db43fe311</a>
A malli zipper if anyone want to criticize is more than welcome</z><z id="t1587855836" t="sudakatux Hi"><y>#</y><d>2020-04-25</d><h>23:03</h><w>sudakatux</w>Hi</z><z id="t1587855863" t="sudakatux i have a question regarding the json-schema suport"><y>#</y><d>2020-04-25</d><h>23:04</h><w>sudakatux</w>i have a  question regarding the json-schema suport</z><z id="t1587855872" t="sudakatux So if i go to the example:"><y>#</y><d>2020-04-25</d><h>23:04</h><w>sudakatux</w>So if i go to the example:</z><z id="t1587855877" t="sudakatux [:map {:title &quot;Address&quot;} [:id string?] [:tags [:set keyword?]] [:address [:map {:json-schema/title &quot;Something&quot;} [:street {:json-schema/title &quot;Something Else&quot;} string?] [:city string?] [:zip int?] [:lonlat [:tuple double? double?]]]]]"><y>#</y><d>2020-04-25</d><h>23:04</h><w>sudakatux</w><code>[:map</code>
 <code>{:title &quot;Address&quot;}</code>
 <code>[:id string?]</code>
 <code>[:tags [:set keyword?]]</code>
 <code>[:address</code>
  <code>[:map {:json-schema/title &quot;Something&quot;}</code>
   <code>[:street  {:json-schema/title &quot;Something Else&quot;} string?]</code>
   <code>[:city string?]</code>
   <code>[:zip int?]</code>
   <code>[:lonlat [:tuple double? double?]]]]]</code></z><z id="t1587856152" t="sudakatux and add title to :street that will not work i would expect to see &quot;Something Else&quot; as a title property for street"><y>#</y><d>2020-04-25</d><h>23:09</h><w>sudakatux</w>and add title to :street that will not work i would expect to see &quot;Something Else&quot; as a title property for street</z><z id="t1587856182" t="sudakatux I do see &quot;Something&quot; as the title for Addess"><y>#</y><d>2020-04-25</d><h>23:09</h><w>sudakatux</w>I do see &quot;Something&quot; as the title for Addess</z><z id="t1587856192" t="sudakatux Generated JSON-schema :"><y>#</y><d>2020-04-25</d><h>23:09</h><w>sudakatux</w>Generated JSON-schema :</z><z id="t1587856229" t="sudakatux {:type &quot;object&quot;, :properties {:id {:type &quot;string&quot;}, :tags {:type &quot;array&quot;, :items {:type &quot;string&quot;}, :uniqueItems true}, :address {:type &quot;object&quot;, :properties {:street {:type &quot;string&quot;}, :city {:type &quot;string&quot;}, :zip {:type &quot;integer&quot;, :format &quot;int64&quot;}, :lonlat {:type &quot;array&quot;, :items [{:type &quot;number&quot;} {:type &quot;number&quot;}], :additionalItems false}}, :required [:street :city :zip :lonlat], :title &quot;Something&quot;}}, :required [:id :tags :address], :title &quot;Address&quot;}"><y>#</y><d>2020-04-25</d><h>23:10</h><w>sudakatux</w><pre>{:type &quot;object&quot;,
 :properties {:id {:type &quot;string&quot;},
              :tags {:type &quot;array&quot;,
                     :items {:type &quot;string&quot;},
                     :uniqueItems true},
              :address {:type &quot;object&quot;,
                        :properties {:street {:type &quot;string&quot;},
                                     :city {:type &quot;string&quot;},
                                     :zip {:type &quot;integer&quot;,
                                           :format &quot;int64&quot;},
                                     :lonlat {:type &quot;array&quot;,
                                              :items [{:type &quot;number&quot;}
                                                      {:type &quot;number&quot;}],
                                              :additionalItems false}},
                        :required [:street :city :zip :lonlat],
                        :title &quot;Something&quot;}},
 :required [:id :tags :address],
 :title &quot;Address&quot;}</pre></z><z id="t1587856285" t="sudakatux Why is not &quot;Something Else&quot; a title for street am i missing something?"><y>#</y><d>2020-04-25</d><h>23:11</h><w>sudakatux</w>Why is not &quot;Something Else&quot; a title for street am i missing something?</z><z id="t1588087408" t="ikitommi [:attrs {:href &quot;/_/_/users/U8JTE9PG8&quot;}] it’s a known issue, to be solved, see https://github.com/metosin/malli/issues/86"><y>#</y><d>2020-04-28</d><h>15:23</h><w>ikitommi</w><a>@jstuartmilne</a> it’s a known issue, to be solved, see <a href="https://github.com/metosin/malli/issues/86" target="_blank">https://github.com/metosin/malli/issues/86</a></z><z id="t1588087437" t="ikitommi for now, this works: [:street [string? {:json-schema/title &quot;Something Else&quot;}]]"><y>#</y><d>2020-04-28</d><h>15:23</h><w>ikitommi</w>for now, this works: <code>[:street  [string? {:json-schema/title &quot;Something Else&quot;}]]</code></z><z id="t1588087464" t="ikitommi e.g. put the meta into entry schema, not to entry itself."><y>#</y><d>2020-04-28</d><h>15:24</h><w>ikitommi</w>e.g. put the meta into entry schema, not to entry itself.</z><z id="t1588087483" t="ikitommi this needs a day in the hammock to figure out how to best resolve that."><y>#</y><d>2020-04-28</d><h>15:24</h><w>ikitommi</w>this needs a day in the hammock to figure out how to best resolve that.</z><z id="t1588087511" t="ikitommi (good thing I just found my hammock from the basement :)), also ideas &amp; help welcome."><y>#</y><d>2020-04-28</d><h>15:25</h><w>ikitommi</w>(good thing I just found my hammock from the basement :)), also ideas  &amp; help welcome.</z><z id="t1588087802" t="sudakatux ahhh cool"><y>#</y><d>2020-04-28</d><h>15:30</h><w>sudakatux</w>ahhh cool</z><z id="t1588087805" t="sudakatux will try that"><y>#</y><d>2020-04-28</d><h>15:30</h><w>sudakatux</w>will try that</z><z id="t1588087813" t="sudakatux thank u verry much"><y>#</y><d>2020-04-28</d><h>15:30</h><w>sudakatux</w>thank u verry much</z><z id="t1588175268" t="daveliepmann How much control does Malli currently give over map keys? For instance that they should be of a particular set, or within a range, or keywords or strings, but without specifying the key precisely? I have an existing non-relational database for which I&apos;d like to infer schemas with mp/provide , but it seems to get confused around hashmaps that are built to store user input (e.g. a mapping from username to info)."><y>#</y><d>2020-04-29</d><h>15:47</h><w>daveliepmann</w>How much control does Malli currently give over map keys? For instance that they should be of a particular set, or within a range, or keywords or strings, but without specifying the key precisely? I have an existing non-relational database for which I&apos;d like to infer schemas with <code>mp/provide</code> , but it seems to get confused around hashmaps that are built to store user input (e.g. a mapping from username to info).</z><z id="t1588177126" t="ikitommi [:attrs {:href &quot;/_/_/users/U05092LD5&quot;}] there is :map-of , like in spec."><y>#</y><d>2020-04-29</d><h>16:18</h><w>ikitommi</w><a>@daveliepmann</a> there is <code>:map-of</code> , like in spec.</z><z id="t1588177210" t="ikitommi the mp/provide is not smart enough yet to figure those out. Could be.."><y>#</y><d>2020-04-29</d><h>16:20</h><w>ikitommi</w>the <code>mp/provide</code> is not smart enough yet to figure those out. Could be..</z><z id="t1588177397" t="daveliepmann Thanks!"><y>#</y><d>2020-04-29</d><h>16:23</h><w>daveliepmann</w>Thanks!</z><z id="t1588192042" t="teodorlu [:attrs {:href &quot;/_/_/users/U05092LD5&quot;}] [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I was also getting more corarse-grained results with provide than I would like. I would love to be able to provide a &quot;starting point&quot; for the schema. Please excuse my backseat driving:"><y>#</y><d>2020-04-29</d><h>20:27</h><w>teodorlu</w><a>@daveliepmann</a> <a>@ikitommi</a> I was also getting more corarse-grained results with provide than I would like. I would love to be able to provide a &quot;starting point&quot; for the schema. Please excuse my backseat driving:</z><z id="t1588235764" t="ikitommi [:attrs {:href &quot;/_/_/users/U3X7174KS&quot;}] Agree, would be useful. I think someone could make a thesis (and read other people theses ;)) out of the providers. The current impl is really naive (69 loc), help most welcome. Ambrose might have some math for this already on typed clojure"><y>#</y><d>2020-04-30</d><h>08:36</h><w>ikitommi</w><a>@teodorlu</a> Agree, would be useful. I think someone could make a thesis (and read other people theses ;)) out of the providers. The current impl is really naive (69 loc), help most welcome. Ambrose might have some math for this already on typed clojure</z><z id="t1588235791" t="ikitommi"><y>#</y><d>2020-04-30</d><h>08:36</h><w>ikitommi</w></z><z id="t1588235818" t="ikitommi"><y>#</y><d>2020-04-30</d><h>08:36</h><w>ikitommi</w></z><z id="t1588235894" t="teodorlu I&apos;ll have a look at the provider source 🙂"><y>#</y><d>2020-04-30</d><h>08:38</h><w>teodorlu</w>I&apos;ll have a look at the provider source <b>🙂</b></z><z id="t1588257592" t="daveliepmann [:attrs {:href &quot;/_/_/users/U3X7174KS&quot;}] I had a similar thought under which your hypothetical looked like [:map [:strength int?] #{&quot;mage&quot; &quot;paladin&quot; &quot;ranger&quot;}] in my head 🙂"><y>#</y><d>2020-04-30</d><h>14:39</h><w>daveliepmann</w><a>@teodorlu</a> I had a similar thought under which your hypothetical looked like <code>[:map [:strength int?] #{&quot;mage&quot; &quot;paladin&quot; &quot;ranger&quot;}]</code> in my head <b>🙂</b></z><z id="t1588257981" t="daveliepmann The shortest real example I have is [:map-of #{&lt;domain-specific items&gt;} [:map-of #{&lt;more domain-specific items&gt;} boolean?]] . (The first set of domain items is limited but long enough to make me not want to enumerate each key to the same spec of values; the second set of domain items is IDs from another system that can&apos;t be enumerated in a spec but that I might want to check the existence of.) On some of the larger schemas I can see some difficulty getting the API for mp/provide to play nicely with a skeleton schema, because of how nested it would have to be."><y>#</y><d>2020-04-30</d><h>14:46</h><w>daveliepmann</w>The shortest real example I have is <code>[:map-of #{&lt;domain-specific items&gt;} [:map-of #{&lt;more domain-specific items&gt;} boolean?]]</code> . (The first set of domain items is limited but long enough to make me not want to enumerate each key to the same spec of values; the second set of domain items is IDs from another system that can&apos;t be enumerated in a spec but that I might want to check the existence of.) On some of the larger schemas I can see some difficulty getting the API for <code>mp/provide</code> to play nicely with a skeleton schema, because of how nested it would have to be.</z><z id="t1588376999" t="geraldodev (m/decode int? &quot;23.abc&quot; mt/string-transformer) gives me a string on clojure on cljs it gives me an 23 integer. it strips the integer part and passes. is it normal ?"><y>#</y><d>2020-05-01</d><h>23:49</h><w>geraldodev</w>(m/decode int? &quot;23.abc&quot; mt/string-transformer) gives me a string on clojure on cljs it gives me an 23 integer. it strips the integer part and passes. is it normal ?</z><z id="t1588592847" t="katox Hi all, I neeed a simple clojure.test check whether a struct conforms to Malli schema. I came up with this helper:"><y>#</y><d>2020-05-04</d><h>11:47</h><w>katox</w>Hi all, I neeed a simple clojure.test check whether a struct conforms to Malli schema. I came up with this helper:</z><z id="t1588592849" t="katox https://gist.github.com/katox/d5817209aec78edb052f851c86e34f99"><y>#</y><d>2020-05-04</d><h>11:47</h><w>katox</w><a href="https://gist.github.com/katox/d5817209aec78edb052f851c86e34f99" target="_blank">https://gist.github.com/katox/d5817209aec78edb052f851c86e34f99</a></z><z id="t1590324166" t="rutledgepaulv fyi I&apos;m working on something similar to https://github.com/rjsf-team/react-jsonschema-form for malli using semantic-ui-react components w/ reagent and it&apos;s coming together nicely so far. good job tommi and other contributors 🙂 . i&apos;ll share something as i make more progress (just started yesterday)"><y>#</y><d>2020-05-24</d><h>12:42</h><w>rutledgepaulv</w>fyi I&apos;m working on something similar to <a href="https://github.com/rjsf-team/react-jsonschema-form" target="_blank">https://github.com/rjsf-team/react-jsonschema-form</a> for malli using semantic-ui-react components w/ reagent and it&apos;s coming together nicely so far. good job tommi and other contributors <b>🙂</b> . i&apos;ll share something as i make more progress (just started yesterday)</z><z id="t1590395340" t="ikitommi looking forward to this!"><y>#</y><d>2020-05-25</d><h>08:29</h><r>ikitommi</r>looking forward to this!</z><z id="t1590396131" t="ikitommi could someone check the reasoning in https://github.com/metosin/malli/pull/201 ?"><y>#</y><d>2020-05-25</d><h>08:42</h><w>ikitommi</w>could someone check the reasoning in <a href="https://github.com/metosin/malli/pull/201" target="_blank">https://github.com/metosin/malli/pull/201</a>?</z><z id="t1590396305" t="ikitommi I now understand why schema.core/both got deprecated. :or is kinda complex when you wan’t to cover both validation and transformation. Same thing was “fixed” in spec-tools some weeks ago: results of a transformed branch needs to be validated to know if the branch was good."><y>#</y><d>2020-05-25</d><h>08:45</h><w>ikitommi</w>I now understand why <code>schema.core/both</code> got deprecated. <code>:or</code> is kinda complex when you wan’t to cover both validation and transformation. Same thing was “fixed” in spec-tools some weeks ago: results of a transformed branch needs to be validated to know if the branch was good.</z><z id="t1590664358" t="Vincent Cantin I faced the same issue in my lib, and tried to separate shape-type elements from the predicates which are checking properties on them."><y>#</y><d>2020-05-28</d><h>11:12</h><r>Vincent Cantin</r>I faced the same issue in my lib, and tried to separate shape-type elements from the predicates which are checking properties on them.</z><z id="t1590396416" t="ikitommi schema had s/conditional , maybe Malli should have :conditional too :thinking_face:"><y>#</y><d>2020-05-25</d><h>08:46</h><w>ikitommi</w>schema had <code>s/conditional</code>, maybe Malli should have <code>:conditional</code> too <b>:thinking_face:</b></z><z id="t1590396494" t="ikitommi could be implemented using :multi with just few extra lines to swap the dispatch function &amp; values."><y>#</y><d>2020-05-25</d><h>08:48</h><w>ikitommi</w>could be implemented using <code>:multi</code> with just few extra lines to swap the dispatch function &amp; values.</z><z id="t1590504860" t="sudakatux Hi"><y>#</y><d>2020-05-26</d><h>14:54</h><w>sudakatux</w>Hi</z><z id="t1590505412" t="sudakatux im looking for a way to filter out"><y>#</y><d>2020-05-26</d><h>15:03</h><w>sudakatux</w>im looking for a way to filter out</z><z id="t1590505458" t="sudakatux recursively in a nested schema every schema containing a certian property"><y>#</y><d>2020-05-26</d><h>15:04</h><w>sudakatux</w>recursively in a nested schema every schema containing a certian property</z><z id="t1590505491" t="sudakatux ` [:identity [:map [:user map?] [:profile map?] [:token [string? {:deleteMe true}] ]]]] "><y>#</y><d>2020-05-26</d><h>15:04</h><w>sudakatux</w>`
<pre>[:identity [:map [:user map?] [:profile map?] [:token  [string? {:deleteMe true}] ]]]]</pre>
</z><z id="t1590505526" t="sudakatux (my-cool-filter [:identity [:map [:user map?] [:profile map?] [:token [string? {:deleteMe true}] ]]]])"><y>#</y><d>2020-05-26</d><h>15:05</h><w>sudakatux</w>(my-cool-filter  [:identity [:map [:user map?] [:profile map?] [:token  [string? {:deleteMe true}] ]]]])</z><z id="t1590505548" t="sudakatux [:identity [:map [:user map?] [:profile map?]]]] "><y>#</y><d>2020-05-26</d><h>15:05</h><w>sudakatux</w><pre>[:identity [:map [:user map?] [:profile map?]]]]</pre>
</z><z id="t1590505596" t="sudakatux I suppose i should be looking at the visitor. since i can see it runns through every node. but im not sure how to filter it out"><y>#</y><d>2020-05-26</d><h>15:06</h><w>sudakatux</w>I suppose i should be looking at the visitor. since i can see it runns through every node. but im not sure how to filter it out</z><z id="t1590643586" t="ikitommi [:attrs {:href &quot;/_/_/users/U8JTE9PG8&quot;}] something like: (m/accept [:map [:user map?] [:profile map?] [:nested [:map [:x [:tuple {:deleteMe true} string? string?]]]] [:token [string? {:deleteMe true}]]] (fn [schema children _ options] (if-not (:deleteMe (m/properties schema)) (let [children (filterv (if (m/map-entries schema) last identity) children)] (m/into-schema (m/name schema) (m/properties schema) children options))))) ; =&gt; [:map [:user map?] [:profile map?] [:nested :map]]"><y>#</y><d>2020-05-28</d><h>05:26</h><w>ikitommi</w><a>@jstuartmilne</a> something like:
<pre>(m/accept
  [:map
   [:user map?]
   [:profile map?]
   [:nested [:map [:x [:tuple {:deleteMe true} string? string?]]]]
   [:token [string? {:deleteMe true}]]]
  (fn [schema children _ options]
    (if-not (:deleteMe (m/properties schema))
      (let [children (filterv (if (m/map-entries schema) last identity) children)]
        (m/into-schema (m/name schema) (m/properties schema) children options)))))
; =&gt; [:map [:user map?] [:profile map?] [:nested :map]]</pre></z><z id="t1590643666" t="ikitommi e.g. check if the schema has the property, remove if it has. if not, you have to remove the nil childs as it’s currently not valid syntax. There are two child syntaxes: the normal and the (map)entry-one. need to handled differently."><y>#</y><d>2020-05-28</d><h>05:27</h><w>ikitommi</w>e.g. check if the schema has the property, remove if it has. if not, you have to remove the <code>nil</code> childs as it’s currently not valid syntax. There are two child syntaxes: the normal and the (map)entry-one. need to handled differently.</z><z id="t1590643700" t="ikitommi that doesn’t drop the empty nodes, e.g. :map without any keys is valid, same with empty :tuple etc."><y>#</y><d>2020-05-28</d><h>05:28</h><w>ikitommi</w>that doesn’t drop the empty nodes, e.g. <code>:map</code> without any keys is valid, same with empty  <code>:tuple</code> etc.</z><z id="t1590660561" t="ikitommi anyone interested in doing malli.xml ? something like: (def User [:map [:users [:vector [:map [:user string?]]]]]) (m/decode User &quot;&lt;users&gt;&lt;user&gt;simo&lt;/user&gt;&lt;/users&gt;&quot; malli.xml/xml-transformer) ; =&gt; {:users [{:user &quot;simo&quot;}]} (m/encode User {:users [{:user &quot;simo&quot;}]} malli.xml/xml-transformer) ; =&gt; &quot;&lt;users&gt;&lt;user&gt;simo&lt;/user&gt;&lt;/users&gt;&quot;"><y>#</y><d>2020-05-28</d><h>10:09</h><w>ikitommi</w>anyone interested in doing <code>malli.xml</code>? something like:
<pre>(def User [:map [:users [:vector [:map [:user string?]]]]])

(m/decode User &quot;&lt;users&gt;&lt;user&gt;simo&lt;/user&gt;&lt;/users&gt;&quot; malli.xml/xml-transformer)
; =&gt; {:users [{:user &quot;simo&quot;}]}

(m/encode User {:users [{:user &quot;simo&quot;}]} malli.xml/xml-transformer)
; =&gt; &quot;&lt;users&gt;&lt;user&gt;simo&lt;/user&gt;&lt;/users&gt;&quot;</pre></z><z id="t1590660572" t="ikitommi related: https://github.com/metosin/muuntaja/pull/114"><y>#</y><d>2020-05-28</d><h>10:09</h><r>ikitommi</r>related: <a href="https://github.com/metosin/muuntaja/pull/114" target="_blank">https://github.com/metosin/muuntaja/pull/114</a></z><z id="t1590667565" t="sudakatux Thank u so much.Ive been struggling witth that"><y>#</y><d>2020-05-28</d><h>12:06</h><w>sudakatux</w>Thank u so much.Ive been struggling witth that</z><z id="t1590844042" t="ikitommi Converting between vector (hiccup) and map-syntax: (defn -&gt;map-syntax ([?schema] (-&gt;map-syntax ?schema nil)) ([?schema options] (m/accept ?schema m/map-syntax-visitor options))) (defn &lt;-map-syntax ([m] (&lt;-map-syntax m nil)) ([{:keys [name properties children]} options] (let [&lt;-child (if (-&gt; children first vector?) (fn [f] #(update % 2 f)) identity)] (m/into-schema name properties (mapv (&lt;-child #(&lt;-map-syntax % options)) children))))) =&gt; (def Schema [:map [:id string?] [:tags [:set keyword?]] [:address [:vector [:map [:street string?] [:lonlat [:tuple double? double?]]]]]]) (-&gt;map-syntax Schema) ;{:name :map, ; :children [[:id nil {:name string?}] ; [:tags nil {:name :set ; :children [{:name keyword?}]}] ; [:address nil {:name :vector, ; :children [{:name :map, ; :children [[:street nil {:name string?}] ; [:lonlat nil {:name :tuple ; :children [{:name double?} {:name double?}]}]]}]}]]} (-&gt; Schema (-&gt;map-syntax) (&lt;-map-syntax)) ;[:map ; [:id string?] ; [:tags [:set keyword?]] ; [:address ; [:vector ; [:map ; [:street string?] ; [:lonlat [:tuple double? double?]]]]]]"><y>#</y><d>2020-05-30</d><h>13:07</h><w>ikitommi</w>Converting between vector (hiccup) and map-syntax:
<pre>(defn -&gt;map-syntax
  ([?schema] (-&gt;map-syntax ?schema nil))
  ([?schema options] (m/accept ?schema m/map-syntax-visitor options)))

(defn &lt;-map-syntax
  ([m] (&lt;-map-syntax m nil))
  ([{:keys [name properties children]} options]
   (let [&lt;-child (if (-&gt; children first vector?) (fn [f] #(update % 2 f)) identity)]
     (m/into-schema name properties (mapv (&lt;-child #(&lt;-map-syntax % options)) children)))))</pre>
=&gt;
<pre>(def Schema
  [:map
   [:id string?]
   [:tags [:set keyword?]]
   [:address
    [:vector
     [:map
      [:street string?]
      [:lonlat [:tuple double? double?]]]]]])

(-&gt;map-syntax Schema)
;{:name :map,
; :children [[:id nil {:name string?}]
;            [:tags nil {:name :set
;                        :children [{:name keyword?}]}]
;            [:address nil {:name :vector,
;                           :children [{:name :map,
;                                       :children [[:street nil {:name string?}]
;                                                  [:lonlat nil {:name :tuple
;                                                                :children [{:name double?} {:name double?}]}]]}]}]]}

(-&gt; Schema
    (-&gt;map-syntax)
    (&lt;-map-syntax))
;[:map
; [:id string?]
; [:tags [:set keyword?]]
; [:address
;  [:vector
;   [:map
;    [:street string?]
;    [:lonlat [:tuple double? double?]]]]]]</pre></z><z id="t1590844709" t="ikitommi Should the support for map-syntax be baked into malli.core directly? One could create a schema with m/schema using either one (can’t mix - the whole Schema tree needs to be created with same syntax - not to lose any extensibility) and the created Schema would know the syntax it’s created with: m/form would return in the original one."><y>#</y><d>2020-05-30</d><h>13:18</h><w>ikitommi</w>Should the support for map-syntax be baked into <code>malli.core</code>directly? One could create a schema with <code>m/schema</code> using either one (can’t mix - the whole Schema tree needs to be created with same syntax - not to lose any extensibility) and the created Schema would know the syntax it’s created with: <code>m/form</code> would return in the original one.</z><z id="t1590845089" t="ikitommi hmm. maybe not now (thinking aloud), have some really big map schemas in a project with a lot of properties everywhere, that could benefit from map-syntax, but should verify it first."><y>#</y><d>2020-05-30</d><h>13:24</h><w>ikitommi</w>hmm. maybe not now (thinking aloud), have some really big map schemas in a project with a lot of properties everywhere, that could benefit from map-syntax, but should verify it first.</z><z id="t1590845137" t="ikitommi will just push the helpers into malli."><y>#</y><d>2020-05-30</d><h>13:25</h><w>ikitommi</w>will just push the helpers into malli.</z><z id="t1590846189" t="ikitommi https://github.com/metosin/malli/pull/202"><y>#</y><d>2020-05-30</d><h>13:43</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/202" target="_blank">https://github.com/metosin/malli/pull/202</a></z><z id="t1590852578" t="ikitommi merged. Also, added a docs/tips.md to collect stuff from here. All tips, docs welcome! https://github.com/metosin/malli/blob/master/docs/tips.md"><y>#</y><d>2020-05-30</d><h>15:29</h><w>ikitommi</w>merged. Also, added a <code>docs/tips.md</code> to collect stuff from here. All tips, docs welcome! <a href="https://github.com/metosin/malli/blob/master/docs/tips.md" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md</a></z><z id="t1590852629" t="ikitommi Asciidoc might be a better format as it has the table of contents etc."><y>#</y><d>2020-05-30</d><h>15:30</h><w>ikitommi</w>Asciidoc might be a better format as it has the table of contents etc.</z><z id="t1590896061" t="naomarik It took a little while to figure this out by examining malli source, is this how you guys are passing in outside vars to the error/fn property? (register! :phone [:re {:description &quot;Phone&quot;, :phone-prefix-regex phone-prefix-regex :phone-code-regex phone-code-regex :error/fn &apos;(fn [{:keys [value schema]} _] (let [{:keys [phone-prefix-regex phone-code-regex]} (m/properties schema) has-prefix? (re-find phone-prefix-regex value) has-code? (re-find phone-code-regex value)] (cond (not has-prefix?) :errors/phone-invalid-prefix (not has-code?) :errors/phone-invalid-country-code :else :errors/phone-invalid-number)))} phone-regex])"><y>#</y><d>2020-05-31</d><h>03:34</h><w>naomarik</w>It took a little while to figure this out by examining malli source, is this how you guys are passing in outside vars to the error/fn property?
<pre>(register! :phone [:re
                   {:description &quot;Phone&quot;,
                    :phone-prefix-regex phone-prefix-regex
                    :phone-code-regex phone-code-regex
                    :error/fn
                    &apos;(fn [{:keys [value schema]} _]
                       (let [{:keys [phone-prefix-regex
                                     phone-code-regex]} (m/properties schema)
                             has-prefix? (re-find phone-prefix-regex value)
                             has-code? (re-find phone-code-regex value)]
                         (cond
                           (not has-prefix?)
                           :errors/phone-invalid-prefix
                           (not has-code?)
                           :errors/phone-invalid-country-code
                           :else
                           :errors/phone-invalid-number)))}
                   phone-regex])</pre></z><z id="t1590896359" t="naomarik Maybe would be helpful in the tips section 🙂"><y>#</y><d>2020-05-31</d><h>03:39</h><w>naomarik</w>Maybe would be helpful in the tips section <b>🙂</b></z><z id="t1590897822" t="naomarik Actually this doesn&apos;t work in clojurescript. (m/properties schema) returns #object[:cljs.coreMetaFn] and don&apos;t know what to do with that."><y>#</y><d>2020-05-31</d><h>04:03</h><w>naomarik</w>Actually this doesn&apos;t work in clojurescript. <code>(m/properties schema)</code> returns <code>#object[:cljs.coreMetaFn]</code> and don&apos;t know what to do with that.</z><z id="t1590899579" t="naomarik I noticed (sci.core/eval-string &quot;(inc 1)&quot;) was returning the same MetaFn object and not 2 like the sci docs says it should. Just tried using the latest sci dependency and the error/fn works as expected. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] would you expect any issues using the latest sci with the current implementation of malli? Will do more testing on my end, I&apos;m using the exact same validations for frontend and backend."><y>#</y><d>2020-05-31</d><h>04:32</h><w>naomarik</w>I noticed <code>(sci.core/eval-string &quot;(inc 1)&quot;)</code> was returning the same MetaFn object and not <code>2</code> like the sci docs says it should. Just tried using the latest sci dependency and the error/fn works as expected. <a>@ikitommi</a> would you expect any issues using the latest sci with the current implementation of malli? Will do more testing on my end, I&apos;m using the exact same validations for frontend and backend.</z><z id="t1590904566" t="ikitommi [:attrs {:href &quot;/_/_/users/U0DHHFEDP&quot;}] I would expect latest sci works ok."><y>#</y><d>2020-05-31</d><h>05:56</h><w>ikitommi</w><a>@naomarik</a> I would expect latest sci works ok.</z><z id="t1590905048" t="ikitommi Also, if you define the validations as cljc code, e.g. no need to serialize over the wire, you can use plain functions instead of fn source code: (defn valid? [x] (and (int? x) (&gt; x 10))) `(m/validate [:fn valid?] 11) ; =&gt; true` "><y>#</y><d>2020-05-31</d><h>06:04</h><w>ikitommi</w>Also, if you define the validations as cljc code, e.g. no need to serialize over the wire, you can use plain functions instead of fn source code:

<code>(defn valid? [x] (and (int? x) (&gt; x 10)))</code>

`(m/validate [:fn valid?] 11)
; =&gt; true`
</z><z id="t1591123027" t="naomarik Hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I have all my malli specs in a cljc file, already. If I pass in functions instead of quoted functions, the clojurescript side won&apos;t through SCI will it? If that&apos;s the case will sci dependency get removed with advanced builds?"><y>#</y><d>2020-06-02</d><h>18:37</h><r>naomarik</r>Hey <a>@ikitommi</a>,

I have all my malli specs in a cljc file, already.

If I pass in functions instead of quoted functions, the clojurescript side won&apos;t through SCI will it? If that&apos;s the case will sci dependency get removed with advanced builds?</z><z id="t1591168585" t="naomarik [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Sorry was being lazy about this didn&apos;t try it yet... Just tested myself and SCI adds about 0.5 megs to the (non gzipped) output and 93kb to the final JS output with gzip -9. I&apos;m not sending code to be evalled as string in my project, is it cool if we make SCI an optional require?"><y>#</y><d>2020-06-03</d><h>07:16</h><r>naomarik</r><a>@ikitommi</a> Sorry was being lazy about this didn&apos;t try it yet... Just tested myself and SCI adds about 0.5 megs to the (non gzipped) output and 93kb to the final JS output with gzip -9. I&apos;m not sending code to be evalled as string in my project, is it cool if we make SCI an optional require?</z><z id="t1591168725" t="naomarik I can try to do that myself but not sure how clean my solution would be compared to what you can come up with. Let me know what you think. I think I could also help with the docs to state that if sending functions over the wire is being used then SCI will be included for a heavier JS file."><y>#</y><d>2020-06-03</d><h>07:18</h><r>naomarik</r>I can try to do that myself but not sure how clean my solution would be compared to what you can come up with. Let me know what you think. I think I could also help with the docs to state that if sending functions over the wire is being used then SCI will be included for a heavier JS file.</z><z id="t1591168823" t="naomarik I think this function (defn ^:no-doc eval [?code] (if (fn? ?code) ?code (sci/eval-string (str ?code) {:preset :termination-safe :bindings {&apos;m/properties properties &apos;m/name name &apos;m/children children &apos;m/map-entries map-entries}}))) if we conditionally require sci if the if test fails the fn? check would be good."><y>#</y><d>2020-06-03</d><h>07:20</h><r>naomarik</r>I think this function
<pre>(defn ^:no-doc eval [?code]
  (if (fn? ?code) ?code (sci/eval-string (str ?code) {:preset :termination-safe
                                                      :bindings {&apos;m/properties properties
                                                                 &apos;m/name name
                                                                 &apos;m/children children
                                                                 &apos;m/map-entries map-entries}})))</pre>
if we conditionally require sci if the if test fails the <code>fn?</code> check would be good.</z><z id="t1591170623" t="naomarik Just tried, conditional requires seem to not work, not sure what I was expecting requiring a library at runtime :)"><y>#</y><d>2020-06-03</d><h>07:50</h><r>naomarik</r>Just tried, conditional requires seem to not work, not sure what I was expecting requiring a library at runtime :)</z><z id="t1590905130" t="ikitommi there could also be an option to add custom bindings to sci, so one could use own fn&apos;s as part of the sci source code."><y>#</y><d>2020-05-31</d><h>06:05</h><w>ikitommi</w>there could also be an option to add custom bindings to sci, so one could use own fn&apos;s as part of the sci source code.</z><z id="t1590905372" t="ikitommi basically just merge to existing bindings https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L878-L883"><y>#</y><d>2020-05-31</d><h>06:09</h><w>ikitommi</w>basically just merge to existing bindings <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L878-L883" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L878-L883</a></z><z id="t1590921671" t="naomarik Yeah adding to the list of sci bindings would have been the most obvious thing to do for me . I saw it wasn&apos;t parameterized though so kept investigating. Actually I didn&apos;t try the error/fn property without quoting it, passing in a function is a lot better in my use case. All the examples show quoted functions in the github page, so didn&apos;t think to try that."><y>#</y><d>2020-05-31</d><h>10:41</h><w>naomarik</w>Yeah adding to the list of sci bindings would have been the most obvious thing to do for me . I saw it wasn&apos;t parameterized though so kept investigating. Actually I didn&apos;t try the <code>error/fn</code> property without quoting it, passing in a function is a lot better in my use case. All the examples show quoted functions in the github page, so didn&apos;t think to try that.</z><z id="t1590925657" t="ikitommi Doc updates welcome"><y>#</y><d>2020-05-31</d><h>11:47</h><w>ikitommi</w>Doc updates welcome</z><z id="t1591104669" t="ikitommi Great talk by [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] about malli: https://youtu.be/ww9yR_rbgQs"><y>#</y><d>2020-06-02</d><h>13:31</h><w>ikitommi</w>Great talk by <a>@plexus</a> about malli: <a href="https://youtu.be/ww9yR_rbgQs" target="_blank">https://youtu.be/ww9yR_rbgQs</a></z><z id="t1591104695" t="ikitommi and the event today: https://clojureverse.org/t/new-online-meetup-clojure-european-summer-time/6018/6"><y>#</y><d>2020-06-02</d><h>13:31</h><r>ikitommi</r>and the event today: <a href="https://clojureverse.org/t/new-online-meetup-clojure-european-summer-time/6018/6" target="_blank">https://clojureverse.org/t/new-online-meetup-clojure-european-summer-time/6018/6</a></z><z id="t1591106571" t="katox Just a thought: one thing that makes debugging Malli structures hard is that it doesn&apos;t retain any information of how it was composed. If you def a SubPart and then def a Part based on that using mu/union that info is lost. Not that it would always be possible (because schemas can just be created programatically) but it might be useful to stuff something into Meta to display it later in the explain ."><y>#</y><d>2020-06-02</d><h>14:02</h><w>katox</w>Just a thought: one thing that makes debugging Malli structures hard is that it doesn&apos;t retain any information of how it was composed. If you def a <code>SubPart</code> and then def a <code>Part</code> based on that using <code>mu/union</code> that info is lost. Not that it would always be possible (because schemas can just be created programatically) but it might be useful to stuff something into Meta to display it later in the  <code>explain</code>.</z><z id="t1591284024" t="Vincent Cantin In Minimallist, there are :let and :ref nodes which make composition of models explicit. Maybe Malli will get something similar once it supports recursion."><y>#</y><d>2020-06-04</d><h>15:20</h><r>Vincent Cantin</r>In Minimallist, there are <code>:let</code> and <code>:ref</code> nodes which make composition of models explicit.

Maybe Malli will get something similar once it supports recursion.</z><z id="t1591554802" t="ikitommi Arne had a custom :ref too."><y>#</y><d>2020-06-07</d><h>18:33</h><r>ikitommi</r>Arne had a custom  <code>:ref</code> too.</z><z id="t1591554847" t="ikitommi there is also some thinking in the README about entities &amp; values: https://github.com/metosin/malli#entities-and-values"><y>#</y><d>2020-06-07</d><h>18:34</h><r>ikitommi</r>there is also some thinking in the README about entities &amp; values: <a href="https://github.com/metosin/malli#entities-and-values" target="_blank">https://github.com/metosin/malli#entities-and-values</a></z><z id="t1591554883" t="ikitommi Hi all. Goal is to get malli out of pre-alpha before my summer vacations = this month."><y>#</y><d>2020-06-07</d><h>18:34</h><w>ikitommi</w>Hi all. Goal is to get malli out of pre-alpha before my summer vacations = this month.</z><z id="t1591554927" t="ikitommi started with adding some new Protocols: https://github.com/metosin/malli/pull/204"><y>#</y><d>2020-06-07</d><h>18:35</h><w>ikitommi</w>started with adding some new Protocols: <a href="https://github.com/metosin/malli/pull/204" target="_blank">https://github.com/metosin/malli/pull/204</a></z><z id="t1591598658" t="ikitommi first class :string coming up: (m/validate :string &quot;&quot;) ; =&gt; true (m/validate [:string {:min 1}] &quot;&quot;) ; =&gt; false (json-schema/transform [:string {:min 1, :max 4}]) ; =&gt; {:type &quot;string&quot;, :minLength 1, :maxLenght 4} (mg/sample [:string {:min 1, :max 4}]) ; =&gt; (&quot;RMmR&quot; &quot;5&quot; &quot;oL&quot; &quot;G7&quot; &quot;ENo&quot; &quot;cAh&quot; &quot;iOb&quot; &quot;jG&quot; &quot;l8&quot; &quot;kuo&quot;) (-&gt; [:map [:a :string] [:b [:string {:min 1}]] [:c [:string {:max 4}]] [:d [:string {:min 1, :max 4}]]] (m/explain {:a 123 :b &quot;&quot; :c &quot;invalid&quot; :d &quot;&quot;}) (me/humanize)) ;{:a [&quot;should be string&quot;], ; :b [&quot;should be at least 1 characters&quot;], ; :c [&quot;should be at most 4 characters&quot;], ; :d [&quot;should be between 1 and 4 characters&quot;]}"><y>#</y><d>2020-06-08</d><h>06:44</h><w>ikitommi</w>first class <code>:string</code> coming up:
<pre>(m/validate :string &quot;&quot;)
; =&gt; true

(m/validate [:string {:min 1}] &quot;&quot;)
; =&gt; false

(json-schema/transform [:string {:min 1, :max 4}])
; =&gt; {:type &quot;string&quot;, :minLength 1, :maxLenght 4}

(mg/sample [:string {:min 1, :max 4}])
; =&gt; (&quot;RMmR&quot; &quot;5&quot; &quot;oL&quot; &quot;G7&quot; &quot;ENo&quot; &quot;cAh&quot; &quot;iOb&quot; &quot;jG&quot; &quot;l8&quot; &quot;kuo&quot;)

(-&gt; [:map
     [:a :string]
     [:b [:string {:min 1}]]
     [:c [:string {:max 4}]]
     [:d [:string {:min 1, :max 4}]]]
    (m/explain
      {:a 123
       :b &quot;&quot;
       :c &quot;invalid&quot;
       :d &quot;&quot;})
    (me/humanize))
;{:a [&quot;should be string&quot;],
; :b [&quot;should be at least 1 characters&quot;],
; :c [&quot;should be at most 4 characters&quot;],
; :d [&quot;should be between 1 and 4 characters&quot;]}</pre></z><z id="t1591600112" t="ikitommi https://github.com/metosin/malli/pull/205"><y>#</y><d>2020-06-08</d><h>07:08</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/205" target="_blank">https://github.com/metosin/malli/pull/205</a></z><z id="t1591601821" t="naomarik Perfect. I accidentally had a string? predicate in my spec awhile ago allowing unbounded inputs."><y>#</y><d>2020-06-08</d><h>07:37</h><r>naomarik</r>Perfect. I accidentally had a <code>string?</code> predicate in my spec awhile ago allowing unbounded inputs.</z><z id="t1591609292" t="pithyless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] any chance for a blank? option? Or is that too specific to add to malli-core? It&apos;s the first thing I have to add to all my string specs, since you almost never want to allow user input of just blank characters. In a similar vein, do you think malli-core generator should be using char-alphanumeric or simply string ? I understand the first gives you nicer looking example data, but the second is more useful in testing edge cases."><y>#</y><d>2020-06-08</d><h>09:41</h><r>pithyless</r><a>@U055NJ5CC</a> any chance for a <code>blank?</code> option? Or is that too specific to add to malli-core? It&apos;s the first thing I have to add to all my string specs, since you almost never want to allow user input of just blank characters. In a similar vein, do you think malli-core generator should be using <code>char-alphanumeric</code> or simply <code>string</code>? I understand the first gives you nicer looking example data, but the second is more useful in testing edge cases.</z><z id="t1591610761" t="pithyless On second thought, the latter question is probably not worth the hassle (and one can always write a custom gen where it&apos;s needed). But still curious about a possibility of blank? or present? option."><y>#</y><d>2020-06-08</d><h>10:06</h><r>pithyless</r>On second thought, the latter question is probably not worth the hassle (and one can always write a custom gen where it&apos;s needed). But still curious about a possibility of <code>blank?</code> or <code>present?</code> option.</z><z id="t1591610851" t="pithyless I moved my question to the PR, where it is probably more appropriate."><y>#</y><d>2020-06-08</d><h>10:07</h><r>pithyless</r>I moved my question to the PR, where it is probably more appropriate.</z><z id="t1591685025" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] chaned the generator to char &amp; string ."><y>#</y><d>2020-06-09</d><h>06:43</h><r>ikitommi</r><a>@U05476190</a> chaned the generator to <code>char</code> &amp; <code>string</code>.</z><z id="t1591642215" t="ikitommi Example string-trimmer here too: (require &apos;[malli.transform :as mt]) (require &apos;[malli.core :as m]) (require &apos;[clojure.string :as str]) (defn string-trimmer [] (mt/transformer {:decoders {:string {:compile (fn [schema _] (let [{:string/keys [trim]} (m/properties schema)] (when trim #(cond-&gt; % (string? %) str/trim))))}}})) (m/decode [:string {:min 1}] &quot; &quot; string-trimmer) ; =&gt; &quot; &quot; (m/decode [:string {:string/trim true, :min 1}] &quot; &quot; string-trimmer) ; =&gt; &quot;&quot; (m/decoder :string string-trimmer) ; =&gt; #object[clojure.core$identity] ... no-op! :)"><y>#</y><d>2020-06-08</d><h>18:50</h><w>ikitommi</w>Example string-trimmer here too:
<pre>(require &apos;[malli.transform :as mt])
(require &apos;[malli.core :as m])
(require &apos;[clojure.string :as str])

(defn string-trimmer []
  (mt/transformer
    {:decoders
     {:string
      {:compile (fn [schema _]
                  (let [{:string/keys [trim]} (m/properties schema)]
                    (when trim #(cond-&gt; % (string? %) str/trim))))}}}))

(m/decode [:string {:min 1}] &quot;    &quot; string-trimmer)
; =&gt; &quot;    &quot;

(m/decode [:string {:string/trim true, :min 1}] &quot;    &quot; string-trimmer)
; =&gt; &quot;&quot;

(m/decoder :string string-trimmer)
; =&gt; #object[clojure.core$identity] ... no-op! :)</pre></z><z id="t1591683210" t="ikitommi As the renaming of m/name to m/type got only upvotes, going to change that: https://github.com/metosin/malli/pull/206 . It’s a BREAKING CHANGE - both for the public api &amp; for people who have extended the Schema protocol. Sorry for that."><y>#</y><d>2020-06-09</d><h>06:13</h><w>ikitommi</w>As the renaming of <code>m/name</code> to  <code>m/type</code> got only upvotes, going to change that: <a href="https://github.com/metosin/malli/pull/206" target="_blank">https://github.com/metosin/malli/pull/206</a>. It’s a BREAKING CHANGE - both for the public api &amp; for people who have extended the <code>Schema</code> protocol. Sorry for that.</z><z id="t1591686541" t="ikitommi Merged the protocol extensions ( https://github.com/metosin/malli/pull/204 ) and realized that there is a breaking change, malli.generator/-generator is used by the new malli.generator/Generator protocol, so the old multimethod is called malli.generator/-schema-generator . Feedback welcome."><y>#</y><d>2020-06-09</d><h>07:09</h><w>ikitommi</w>Merged the protocol extensions (<a href="https://github.com/metosin/malli/pull/204" target="_blank">https://github.com/metosin/malli/pull/204</a>) and realized that there is a breaking change, <code>malli.generator/-generator</code> is used by the new <code>malli.generator/Generator</code> protocol, so the old multimethod is called <code>malli.generator/-schema-generator</code>. Feedback welcome.</z><z id="t1591687662" t="ikitommi started to track the before-release changed into https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased , as some are breaking, for the better."><y>#</y><d>2020-06-09</d><h>07:27</h><w>ikitommi</w>started to track the before-release changed into <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased</a>, as some are breaking, for the better.</z><z id="t1591860178" t="pithyless I&apos;m struggling to wrap my head around custom transformers and validators; is there some way to create a pipeline of validate -&gt; transform -&gt; validate (ala spec/conform ?) Or when defining a transform interceptor, can I in some way tell the the chain to stop executing further since some assumption is invalid?"><y>#</y><d>2020-06-11</d><h>07:22</h><w>pithyless</w>I&apos;m struggling to wrap my head around custom transformers and validators; is there some way to create a pipeline of validate -&gt; transform -&gt; validate (ala <code>spec/conform</code> ?) Or when defining a transform interceptor, can I in some way tell the the chain to stop executing further since some assumption is invalid?</z><z id="t1591872070" t="ikitommi currently no way to stop the chain in interceptors [:attrs {:href &quot;/_/_/users/U05476190&quot;}] , could be added easily with reduced . There are Schemas that short-circuit in -transform like the :or ."><y>#</y><d>2020-06-11</d><h>10:41</h><w>ikitommi</w>currently no way to stop the chain in interceptors <a>@pithyless</a>, could be added easily with <code>reduced</code>. There are Schemas that short-circuit in <code>-transform</code> like the <code>:or</code>.</z><z id="t1591872123" t="ikitommi in reitit-malli , there is a Corcion protocol and impl which does transform + validate for requests and transform + validate + transform for responses."><y>#</y><d>2020-06-11</d><h>10:42</h><w>ikitommi</w>in <code>reitit-malli</code>, there is a <code>Corcion</code> protocol and impl which does transform + validate for requests and transform + validate + transform for responses.</z><z id="t1591872166" t="ikitommi for responses, it’s basically doing: 1. apply defaults, strip extra keys 2. validate the result 3. encode to whatever (string, json, xml)"><y>#</y><d>2020-06-11</d><h>10:42</h><w>ikitommi</w>for responses, it’s basically doing:
1. apply defaults, strip extra keys
2. validate the result
3. encode to whatever (string, json, xml)</z><z id="t1591872188" t="ikitommi If you have some minimal sample, could take a look."><y>#</y><d>2020-06-11</d><h>10:43</h><w>ikitommi</w>If you have some minimal sample, could take a look.</z><z id="t1591874585" t="pithyless ^ the reitit Coercer case is the kind of thing I have in mind. I&apos;ve been going back and forth on this, but malli has been forcing me to rethink my approach: perhaps, I should just assume there is only one canonical form of data inside my project runtime, and only at the boundaries do all the encoding/decoding via custom protocols (i.e. a custom Coercer protocol and implementation for reitit, datomic, etc.)"><y>#</y><d>2020-06-11</d><h>11:23</h><w>pithyless</w>^ the reitit <code>Coercer</code> case is the kind of thing I have in mind. I&apos;ve been going back and forth on this, but malli has been forcing me to rethink my approach: perhaps, I should just assume there is only one canonical form of data inside my project runtime, and only at the boundaries do all the encoding/decoding via custom protocols (i.e. a custom Coercer protocol and implementation for reitit, datomic, etc.)</z><z id="t1591875207" t="ikitommi the reitit code is here: https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc . Basically, at route(r) creation time, for each Schema, a reified Coercion is created, storing encoder , decoder , validator and explainer for that schema. At runtime, it’s just a calling those (optimized fns) in whatever order suits for the use case."><y>#</y><d>2020-06-11</d><h>11:33</h><w>ikitommi</w>the reitit code is here: <a href="https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc" target="_blank">https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc</a>. Basically, at route(r) creation time, for each Schema, a reified <code>Coercion</code> is created, storing <code>encoder</code>, <code>decoder</code>, <code>validator</code> and <code>explainer</code> for that schema. At runtime, it’s just a calling those (optimized fns) in whatever order suits for the use case.</z><z id="t1591942201" t="ikitommi"><y>#</y><d>2020-06-12</d><h>06:10</h><w>ikitommi</w></z><z id="t1591942234" t="ikitommi initial bundle-size anaysis for cljs. related to #203"><y>#</y><d>2020-06-12</d><h>06:10</h><w>ikitommi</w>initial bundle-size anaysis for cljs. related to #203</z><z id="t1591954610" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Note that about 200kb of the sci bundle is coming from docstrings 🙂"><y>#</y><d>2020-06-12</d><h>09:36</h><w>borkdude</w><a>@ikitommi</a> Note that about 200kb of the sci bundle is coming from docstrings <b>🙂</b></z><z id="t1591954622" t="borkdude at least, if you bump to the newest sci"><y>#</y><d>2020-06-12</d><h>09:37</h><w>borkdude</w>at least, if you bump to the newest sci</z><z id="t1591956424" t="ikitommi yes, updated the latest. Haven’t really studied how the dce works and how can libraries be smaller. Would be great if one could drop off whole protocol method impls if the protocol method was not used. E.g. if you don’t have any calls to the transformers, we coud remote the -transformer methods, which is easily 30% of the whole malli.core."><y>#</y><d>2020-06-12</d><h>10:07</h><w>ikitommi</w>yes, updated the latest. Haven’t really studied how the dce works and how can libraries be smaller. Would be great if one could drop off whole protocol method impls if the protocol method was not used. E.g. if you don’t have any calls to the transformers, we coud remote the <code>-transformer</code> methods, which is easily 30% of the whole malli.core.</z><z id="t1591956472" t="ikitommi most of the concerns are in separate namespaces (json-schma, human errors, inferring), but the important ones are in the core right now. But not always important 🙂"><y>#</y><d>2020-06-12</d><h>10:07</h><w>ikitommi</w>most of the concerns are in separate namespaces (json-schma, human errors, inferring), but the important ones are in the core right now. But not always important <b>🙂</b></z><z id="t1591956505" t="ikitommi also, would be great to have a sci-lite version without the docstrings."><y>#</y><d>2020-06-12</d><h>10:08</h><w>ikitommi</w>also, would be great to have a <code>sci-lite</code>version without the docstrings.</z><z id="t1591956554" t="borkdude maybe that can be accomplished using a goog/define"><y>#</y><d>2020-06-12</d><h>10:09</h><w>borkdude</w>maybe that can be accomplished using a goog/define</z><z id="t1591956608" t="borkdude :closure-defines {&quot;sci.foo/DOCSTRINGS&quot; false}"><y>#</y><d>2020-06-12</d><h>10:10</h><w>borkdude</w><pre>:closure-defines {&quot;sci.foo/DOCSTRINGS&quot; false}</pre></z><z id="t1591956672" t="borkdude made an issue for it: https://github.com/borkdude/sci/issues/352"><y>#</y><d>2020-06-12</d><h>10:11</h><w>borkdude</w>made an issue for it: <a href="https://github.com/borkdude/sci/issues/352" target="_blank">https://github.com/borkdude/sci/issues/352</a></z><z id="t1592119058" t="ikitommi Going to change how the registry is composed. Goal is to allow easy bootstrapping of custom registries. Allows much smaller bundle size on cljs and one can (hopefully) easily add custom registries."><y>#</y><d>2020-06-14</d><h>07:17</h><w>ikitommi</w>Going to change how the registry is composed. Goal is to allow easy bootstrapping of custom registries. Allows much smaller bundle size on cljs and one can (hopefully) easily add custom registries.</z><z id="t1592119262" t="ikitommi few sample sizes (gzipped), for malli.core (just validation): • current (full): 12kb • just :map , :vector and :string : 4kb • just :string : 700b"><y>#</y><d>2020-06-14</d><h>07:21</h><w>ikitommi</w>few sample sizes (gzipped), for malli.core (just validation):
• current (full): 12kb
• just <code>:map</code> , <code>:vector</code> and <code>:string</code>: 4kb
• just <code>:string</code>: 700b</z><z id="t1592119545" t="ikitommi I was surprised that the closure dce actually removes all the protocol method impls too if there is nothing using those methods. e.g. not using m/decode or m/encode =&gt; all -transformer impls are removed under :advanced . This is really, reaaly, great."><y>#</y><d>2020-06-14</d><h>07:25</h><w>ikitommi</w>I was surprised that the closure dce actually removes all the protocol method impls too if there is nothing using those methods. e.g. not using <code>m/decode</code> or <code>m/encode</code> =&gt; all <code>-transformer</code> impls are removed under <code>:advanced</code>. This is really, reaaly, great.</z><z id="t1592119614" t="ikitommi app that uses all the features from malli, might still be big, e.g. validation, human errors, transformation, programming with schemas etc."><y>#</y><d>2020-06-14</d><h>07:26</h><w>ikitommi</w>app that uses all the features from malli, might still be big, e.g. validation, human errors, transformation, programming with schemas etc.</z><z id="t1592159763" t="naomarik nice!"><y>#</y><d>2020-06-14</d><h>18:36</h><w>naomarik</w>nice!</z><z id="t1592159790" t="naomarik one step closer to malli frontend domination"><y>#</y><d>2020-06-14</d><h>18:36</h><w>naomarik</w>one step closer to malli frontend domination</z><z id="t1592304333" t="ikitommi"><y>#</y><d>2020-06-16</d><h>10:45</h><w>ikitommi</w></z><z id="t1592304400" t="ikitommi with default, malli is all-immutable, with a CLOSURE_DEFINES or JVM Prop setup, the default registry can be swapped out in the user space."><y>#</y><d>2020-06-16</d><h>10:46</h><w>ikitommi</w>with default, malli is all-immutable, with a CLOSURE_DEFINES or JVM Prop setup, the default registry can be swapped out in the user space.</z><z id="t1592304470" t="ikitommi allows also really smaller bundle sizes, moved all the def s into defns so closure can eliminate those if needed."><y>#</y><d>2020-06-16</d><h>10:47</h><w>ikitommi</w>allows also really smaller bundle sizes, moved all the <code>def</code>s into <code>defns</code> so closure can eliminate those if needed.</z><z id="t1592304487" t="ikitommi [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] , would that help with your acme-schema sample?"><y>#</y><d>2020-06-16</d><h>10:48</h><w>ikitommi</w><a>@plexus</a>, would that help with your acme-schema sample?</z><z id="t1592304537" t="ikitommi also, the options would be default (immutable) or managed (swappable). any suggestions for better names?"><y>#</y><d>2020-06-16</d><h>10:48</h><w>ikitommi</w>also, the options would be <code>default</code> (immutable) or <code>managed</code> (swappable). any suggestions for better names?</z><z id="t1592306962" t="plexus yeah I think that would help us"><y>#</y><d>2020-06-16</d><h>11:29</h><w>plexus</w>yeah I think that would help us</z><z id="t1592317319" t="ikitommi"><y>#</y><d>2020-06-16</d><h>14:21</h><w>ikitommi</w></z><z id="t1592317358" t="ikitommi even more evil. optional MUTABLE registry constructor, just pass in your own atom."><y>#</y><d>2020-06-16</d><h>14:22</h><w>ikitommi</w>even more evil. optional MUTABLE registry constructor, just pass in your own atom.</z><z id="t1592323451" t="Vincent Cantin would it be possible to avoid having any mutable registry by having the user define his own API functions defaulting to their own registry?"><y>#</y><d>2020-06-16</d><h>16:04</h><w>Vincent Cantin</w>would it be possible to avoid having any mutable registry by having the user define his own API functions defaulting to their own registry?</z><z id="t1592323519" t="Vincent Cantin maybe via a macro? (def-malli-api my-registry)"><y>#</y><d>2020-06-16</d><h>16:05</h><w>Vincent Cantin</w>maybe via a macro? <code>(def-malli-api my-registry)</code></z><z id="t1592326998" t="ikitommi that is one approach, and can be done on top of the current api. Not a fan of macros generating functions personally. Need extra work to work with static analysis tools (like cursive) Also, the api should require all the malli namespaces to be complete."><y>#</y><d>2020-06-16</d><h>17:03</h><w>ikitommi</w>that is one approach, and can be done on top of the current api. Not a fan of macros generating functions personally. Need extra work to work with static analysis tools (like cursive) Also, the api should require all the malli namespaces to be complete.</z><z id="t1592327577" t="ikitommi I&apos;ll make set-default-regisyry! to throw if the registry swapping is not enabled."><y>#</y><d>2020-06-16</d><h>17:12</h><w>ikitommi</w>I&apos;ll make <code>set-default-regisyry!</code> to throw if the registry swapping is not enabled.</z><z id="t1592453862" t="ikitommi merged the registries in."><y>#</y><d>2020-06-18</d><h>04:17</h><w>ikitommi</w>merged the registries in.</z><z id="t1592453886" t="ikitommi quick poke on the recursive schemas, using :ref : (def ConsCell [:maybe {:id :cons} [:tuple int? [:ref :cons]]]) (m/explain ConsCell [1 [2 [3 [4 nil]]]]) ; =&gt; nil (m/explain ConsCell [1 [2 [3 [4]]]]) ;{:schema [:maybe {:id :cons} [:tuple int? [:ref :cons]]], ; :value [1 [2 [3 [4]]]], ; :errors (#Error{:path [2 2 0 2 2 0 2 2 0 2], ; :in [1 1 1], ; :schema [:tuple int? [:ref :cons]], ; :value [4], ; :type :malli.core/tuple-size})}"><y>#</y><d>2020-06-18</d><h>04:18</h><w>ikitommi</w>quick poke on the recursive schemas, using <code>:ref</code>:
<pre>(def ConsCell
  [:maybe {:id :cons}
   [:tuple int? [:ref :cons]]])

(m/explain ConsCell [1 [2 [3 [4 nil]]]])
; =&gt; nil

(m/explain ConsCell [1 [2 [3 [4]]]])
;{:schema [:maybe {:id :cons} [:tuple int? [:ref :cons]]],
; :value [1 [2 [3 [4]]]],
; :errors (#Error{:path [2 2 0 2 2 0 2 2 0 2],
;                 :in [1 1 1],
;                 :schema [:tuple int? [:ref :cons]],
;                 :value [4],
;                 :type :malli.core/tuple-size})}</pre></z><z id="t1592457522" t="viesti Nice! :)"><y>#</y><d>2020-06-18</d><h>05:18</h><r>viesti</r>Nice! :)</z><z id="t1592457920" t="Vincent Cantin does it still work with cross recursion ? ping refers to pong, and pong refers to ping"><y>#</y><d>2020-06-18</d><h>05:25</h><r>Vincent Cantin</r>does it still work with cross recursion ?

ping refers to pong, and pong refers to ping</z><z id="t1592455887" t="ikitommi ok, need to figure out how things like -accept should work with recursive schemas as it’s eager (validation and explain can be both lazy). I guess need to keep a local book keeping not to walk over already walked :ref s so that it doesn’t go to infinite loop."><y>#</y><d>2020-06-18</d><h>04:51</h><w>ikitommi</w>ok, need to figure out how things like <code>-accept</code> should work with recursive schemas as it’s eager (validation and explain can be both lazy). I guess need to keep a local book keeping not to walk over already walked <code>:ref</code>s so that it doesn’t go to infinite loop.</z><z id="t1592457825" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] welcome to the club of infinite loop avoiders :-)"><y>#</y><d>2020-06-18</d><h>05:23</h><w>Vincent Cantin</w><a>@ikitommi</a> welcome to the club of infinite loop avoiders :-)</z><z id="t1592459158" t="ikitommi does not work yet with mutual recursion, but I think we need :registry schema anyway, like there is :definitions for JSON Schma. Needed anyway for persisting the things. maybe something like: (explain [:registry {:schemas [[:maybe {:id :ping} [:tuple [:eq &quot;ping&quot;] [:ref :pong]]] [:maybe {:id :pong} [:tuple [:eq &quot;pong&quot;] [:ref :pong]]]]} [:ref :pong]] [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]]) ; =&gt; true"><y>#</y><d>2020-06-18</d><h>05:45</h><w>ikitommi</w>does not work yet with mutual recursion, but I think we need <code>:registry</code> schema anyway, like there is <code>:definitions</code> for JSON Schma. Needed anyway for persisting the things. maybe something like:
<pre>(explain
  [:registry
   {:schemas [[:maybe {:id :ping} [:tuple [:eq &quot;ping&quot;] [:ref :pong]]]
              [:maybe {:id :pong} [:tuple [:eq &quot;pong&quot;] [:ref :pong]]]]}
   [:ref :pong]]
  [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]])
; =&gt; true</pre></z><z id="t1592459253" t="ikitommi btw, a colourful discussion at the old draft PR: https://github.com/metosin/malli/pull/117"><y>#</y><d>2020-06-18</d><h>05:47</h><w>ikitommi</w>btw, a colourful discussion at the old draft PR: <a href="https://github.com/metosin/malli/pull/117" target="_blank">https://github.com/metosin/malli/pull/117</a></z><z id="t1592496469" t="pithyless I&apos;ve got :closure-defines {malli.registry/type &quot;custom&quot;} in my shadow-cljs.edn, but still seeing error: can&apos;t set default registry {:type &quot;default&quot;} Any ideas what I may be forgetting?"><y>#</y><d>2020-06-18</d><h>16:07</h><w>pithyless</w>I&apos;ve got
<pre>:closure-defines  {malli.registry/type &quot;custom&quot;}</pre>
 in my shadow-cljs.edn, but still seeing error:
<pre>can&apos;t set default registry {:type &quot;default&quot;}</pre>
Any ideas what I may be forgetting?</z><z id="t1592496637" t="pithyless oh, that&apos;s weird - some kind of caching bug; forcing a recompile (after it showed the error) and it went away. ¯\(ツ)/¯"><y>#</y><d>2020-06-18</d><h>16:10</h><w>pithyless</w>oh, that&apos;s weird - some kind of caching bug; forcing a recompile (after it showed the error) and it went away. ¯\(ツ)/¯</z><z id="t1592497048" t="pithyless The new registry setup allows for easier bootstrapping custom code. :thumbsup:"><y>#</y><d>2020-06-18</d><h>16:17</h><w>pithyless</w>The new registry setup allows for easier bootstrapping custom code. <b>:thumbsup:</b></z><z id="t1592500458" t="jkent it doesn’t look like the new first class :string is bundled with the latest reitit [metosin/reitit-malli &quot;0.5.2&quot;] is there reason for this or am I missing something?"><y>#</y><d>2020-06-18</d><h>17:14</h><w>jkent</w>it doesn’t look like the new first class <code>:string</code>  is bundled with the latest reitit <code>[metosin/reitit-malli &quot;0.5.2&quot;]</code>  is there reason for this or am I missing something?</z><z id="t1592503324" t="pithyless metosin/reitit-malli on clojars is dependent on malli 0.0.1-SNAPSHOT - theoretically, last version was uploaded yesterday, but maybe you have some caching issues? (I think clojure deps caches any snapshot locally for 24(?) hours). Perhaps try to update your deps to depend directly on latest malli from master?"><y>#</y><d>2020-06-18</d><h>18:02</h><w>pithyless</w><code>metosin/reitit-malli</code> on clojars is dependent on <code>malli 0.0.1-SNAPSHOT</code> - theoretically, last version was uploaded yesterday, but maybe you have some caching issues? (I think clojure deps caches any snapshot locally for 24(?) hours). Perhaps try to update your deps to depend directly on latest malli from master?</z><z id="t1592553875" t="pithyless I think there may be some kind of race-condition bug with the malli.registry/type code in closure-defines. Once in a while (after a clean shadow restart) I see the {:type &quot;default&quot;} error, but it works if I &quot;force compile&quot; in shadow."><y>#</y><d>2020-06-19</d><h>08:04</h><w>pithyless</w>I think there may be some kind of race-condition bug with the <code>malli.registry/type</code> code in closure-defines. Once in a while (after a clean shadow restart) I see the <code>{:type &quot;default&quot;}</code> error, but it works if I &quot;force compile&quot; in shadow.</z><z id="t1592555086" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] that is weird, might be a bug in #shadow-cljs ?"><y>#</y><d>2020-06-19</d><h>08:24</h><w>ikitommi</w><a>@pithyless</a> that is weird, might be a bug in #shadow-cljs ?</z><z id="t1592555279" t="ikitommi [:attrs {:href &quot;/_/_/users/U011CL58Q4W&quot;}] I&apos;ll release a new reitit version next week, master is build against the latest malli."><y>#</y><d>2020-06-19</d><h>08:27</h><w>ikitommi</w><a>@jkent</a> I&apos;ll release a new reitit version next week, master is build against the latest malli.</z><z id="t1592591121" t="eskos Default update policy for snapshots in pomegranate is daily; that is, once per 24 hours. If you&apos;re using Leiningen, see https://github.com/technomancy/leiningen/blob/stable/sample.project.clj#L115-L117 and if you&apos;re using something else, I have no idea 🙂"><y>#</y><d>2020-06-19</d><h>18:25</h><w>eskos</w>Default update policy for snapshots in pomegranate is daily; that is, once per 24 hours. If you&apos;re using Leiningen, see <a href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj#L115-L117" target="_blank">https://github.com/technomancy/leiningen/blob/stable/sample.project.clj#L115-L117</a> and if you&apos;re using something else, I have no idea <b>🙂</b></z><z id="t1592591181" t="eskos Oh that was weird, got a whole screen of text after typing that... Slack&apos;s lagging. Meant this as continuation to [:attrs {:href &quot;/_/_/users/U05476190&quot;}]"><y>#</y><d>2020-06-19</d><h>18:26</h><w>eskos</w>Oh that was weird, got a whole screen of text after typing that... Slack&apos;s lagging. Meant this as continuation to <a>@pithyless</a></z><z id="t1592680996" t="dcj A month or so ago I used Malli for a project, and with recent changes to Malli, my code broke: (def predicate-registry (-&gt; m/predicate-registry (-register-var #&apos;zoned-date-time?) (-register-var #&apos;local-date?))) (def registry (merge predicate-registry m/class-registry m/comparator-registry m/base-registry)) So now the -registry is -schemas , but then my -register-var calls fail. I&apos;ll keep working on this, but any ideas?"><y>#</y><d>2020-06-20</d><h>19:23</h><w>dcj</w>A month or so ago I used Malli for a project, and with recent changes to Malli, my code broke:
<pre>(def predicate-registry
  (-&gt; m/predicate-registry
      (-register-var #&apos;zoned-date-time?)
      (-register-var #&apos;local-date?)))


(def registry
  (merge predicate-registry m/class-registry m/comparator-registry m/base-registry))</pre>
So now the <code>-registry</code> is <code>-schemas</code>, but then my <code>-register-var</code> calls fail.
I&apos;ll keep working on this, but any ideas?</z><z id="t1592683434" t="dcj OK, this worked: (def registry (merge (m/predicate-schemas) (m/class-schemas) (m/comparator-schemas) (m/base-schemas) {:zoned-date-time (m/fn-schema :zoned-date-time #&apos;zoned-date-time?) :local-date (m/fn-schema :local-date #&apos;local-date?)})) And then I changed my schema references from zoned-date-time? to :zoned-date-time , etc, and also changed the associated transformer encoder/decoder names"><y>#</y><d>2020-06-20</d><h>20:03</h><w>dcj</w>OK, this worked:
<pre>(def registry
  (merge (m/predicate-schemas)
         (m/class-schemas)
         (m/comparator-schemas)
         (m/base-schemas)
         {:zoned-date-time (m/fn-schema :zoned-date-time #&apos;zoned-date-time?)
          :local-date      (m/fn-schema :local-date      #&apos;local-date?)}))</pre>
And then I changed my schema references from <code>zoned-date-time?</code> to <code>:zoned-date-time</code>, etc, and also changed the associated transformer encoder/decoder names</z><z id="t1592685037" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] we are doing final code polishing to get the non-pre-aloha out. The breaking changes are listed in https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased . Also, if you are using custom schemas, you should read https://github.com/metosin/malli/blob/master/README.md#schema-registry . Lot of options, and supports properly dce on cljs now"><y>#</y><d>2020-06-20</d><h>20:30</h><w>ikitommi</w><a>@dcj</a> we are doing final code polishing to get the non-pre-aloha out. The breaking changes are listed in <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md#unreleased</a>. Also, if you are using custom schemas, you should read <a href="https://github.com/metosin/malli/blob/master/README.md#schema-registry" target="_blank">https://github.com/metosin/malli/blob/master/README.md#schema-registry</a>. Lot of options, and supports properly dce on cljs now</z><z id="t1592809359" t="ikitommi About recursive schemas. It seems that because of those, should to to add a (-children [this]) method into Schema protocol. Why? Currently, there is generic children function that returns the Schema AST for the children. The AST is unaware of any instance bindings such as local recursion targets. Given a Schema: [:maybe {:id :cons} [:tuple int? [:ref :cons]]] , the generator for :tuple just sees children of (int? [:ref :cons]) and doesn’t know what :cons refers to and fails."><y>#</y><d>2020-06-22</d><h>07:02</h><w>ikitommi</w>About recursive schemas. It seems that because of those, should to to add a <code>(-children [this])</code> method into <code>Schema</code> protocol. Why? Currently, there is generic <code>children</code> function that returns the Schema AST for the children. The AST is unaware of any instance bindings such as local recursion targets. Given a Schema:
<pre>[:maybe {:id :cons}
   [:tuple int? [:ref :cons]]]</pre>
, the generator for  <code>:tuple</code> just sees children of <code>(int? [:ref :cons])</code>and doesn’t know what <code>:cons</code> refers to and fails.</z><z id="t1592809527" t="ikitommi We could hack around this by pulling out options that created :tuple and using those to re-create the child schemas, providing all the needed local context. But, this is error-prone as one needs to wire-up all generators, visitors etc. using the original options from the father schema."><y>#</y><d>2020-06-22</d><h>07:05</h><w>ikitommi</w>We could hack around this by pulling out options that created <code>:tuple</code> and using those to re-create the child schemas, providing all the needed local context. But, this is error-prone as one needs to wire-up all generators, visitors etc. using the original options from the father schema.</z><z id="t1592809558" t="ikitommi (currently passing the local context via options, which seems to be a good way to do it)"><y>#</y><d>2020-06-22</d><h>07:05</h><w>ikitommi</w>(currently passing the local context via options, which seems to be a good way to do it)</z><z id="t1592809574" t="ikitommi Anyway, this works now:"><y>#</y><d>2020-06-22</d><h>07:06</h><w>ikitommi</w>Anyway, this works now:</z><z id="t1592809584" t="ikitommi"><y>#</y><d>2020-06-22</d><h>07:06</h><w>ikitommi</w></z><z id="t1592809679" t="ikitommi with recursion, one can set the recursion limit, just like with spec. One setting, but each :ref is counted separatly, defaulting to 10."><y>#</y><d>2020-06-22</d><h>07:07</h><w>ikitommi</w>with recursion, one can set the recursion limit, just like with spec. One setting, but each <code>:ref</code> is counted separatly, defaulting to 10.</z><z id="t1592812700" t="ikitommi wrote more to the recursion issue, comments welcome: https://github.com/metosin/malli/pull/117#issuecomment-647348039"><y>#</y><d>2020-06-22</d><h>07:58</h><w>ikitommi</w>wrote more to the recursion issue, comments welcome: <a href="https://github.com/metosin/malli/pull/117#issuecomment-647348039" target="_blank">https://github.com/metosin/malli/pull/117#issuecomment-647348039</a></z><z id="t1592834807" t="Vincent Cantin I feel that having more than 1 way of defining recursive structures implies that users will have to choose which to use. Choice can sometimes be a problem more than a solution."><y>#</y><d>2020-06-22</d><h>14:06</h><r>Vincent Cantin</r>I feel that having more than 1 way of defining recursive structures implies that users will have to choose which to use.

Choice can sometimes be a problem more than a solution.</z><z id="t1592891100" t="ikitommi mutual recursion, current status: (mg/generate ::ping {:registry (mr/composite-registry (m/default-schemas) {::ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref ::pong]]] ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}) :size 7, :seed 86}) ; =&gt; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]]]] tested also a fail-fast on ambiguity with refs, so instead of: (mg/generate ::ping {:registry (mr/composite-registry (m/default-schemas) {::ping [:maybe {:id ::pong} [:tuple [:= &quot;ping&quot;] [:ref ::pong]]] ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}) :size 7, :seed 86}) ; =&gt; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; nil]]]]] the default code will throw instead: Execution error (ExceptionInfo) at malli.core/fail! (core.cljc:80). :malli.core/ambiguous-ref {:type :ref, :ref :user/pong}"><y>#</y><d>2020-06-23</d><h>05:45</h><w>ikitommi</w>mutual recursion, current status:

<pre>(mg/generate
  ::ping
  {:registry (mr/composite-registry
               (m/default-schemas)
               {::ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref ::pong]]]
                ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]})
   :size 7, :seed 86})
; =&gt; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]]]]</pre>
tested also a fail-fast on ambiguity with refs, so instead of:

<pre>(mg/generate
  ::ping
  {:registry (mr/composite-registry
               (m/default-schemas)
               {::ping [:maybe {:id ::pong} [:tuple [:= &quot;ping&quot;] [:ref ::pong]]]
                ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]})
   :size 7, :seed 86})
; =&gt; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; [&quot;ping&quot; nil]]]]]</pre>
the default code will throw instead:

<pre>Execution error (ExceptionInfo) at malli.core/fail! (core.cljc:80).
:malli.core/ambiguous-ref {:type :ref, :ref :user/pong}</pre></z><z id="t1592891196" t="ikitommi the code is in a new PR: https://github.com/metosin/malli/pull/209"><y>#</y><d>2020-06-23</d><h>05:46</h><w>ikitommi</w>the code is in a new PR: <a href="https://github.com/metosin/malli/pull/209" target="_blank">https://github.com/metosin/malli/pull/209</a></z><z id="t1592894890" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] [suggestion] if you can embed registries locally, then maybe you don&apos;t need to have support for a custom global registry - just ask the users to include their registry as a part of their models."><y>#</y><d>2020-06-23</d><h>06:48</h><w>Vincent Cantin</w><a>@ikitommi</a> [suggestion] if you can embed registries locally, then maybe you don&apos;t need to have support for a custom global registry - just ask the users to include their registry as a part of their models.</z><z id="t1592895589" t="ikitommi The custom Schema elements can’t be embedded as data, if they are code. It’s good have a mechanism to add those to the schema registry. All user/project-defined that are just data COULD be used via embedded registries, a decision done in user space."><y>#</y><d>2020-06-23</d><h>06:59</h><w>ikitommi</w>The custom <code>Schema</code> elements can’t be embedded as data, if they are code. It’s good have a mechanism to add those to the schema registry. All user/project-defined that are just data COULD be used via embedded registries, a decision done in user space.</z><z id="t1592895745" t="ikitommi I woudn’t register any project-spesific (data) schemas into global registry, as they can be references mosty as Vars."><y>#</y><d>2020-06-23</d><h>07:02</h><w>ikitommi</w>I woudn’t register any project-spesific (data) schemas into global registry, as they can be references mosty as Vars.</z><z id="t1592895915" t="ikitommi The recursive schemas could also be allowed to be introduces using Vars, but not sure if that’s a good idea."><y>#</y><d>2020-06-23</d><h>07:05</h><w>ikitommi</w>The recursive schemas could also be allowed to be introduces using Vars, but not sure if that’s a good idea.</z><z id="t1592895989" t="ikitommi Something like: (declare Pong) (def Ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref #&apos;Pong]]]) (def Pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref #&apos;Ping]]])"><y>#</y><d>2020-06-23</d><h>07:06</h><w>ikitommi</w>Something like:
<pre>(declare Pong)

(def Ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref #&apos;Pong]]])

(def Pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref #&apos;Ping]]])</pre></z><z id="t1592896184" t="ikitommi Imaginary example with not much boilerplate with schematized fns using custom schema element :db/ref registered into the global registry: (m/defn my-fn [x :- int?, y :- [:maybe [:db/ref uuid?]] (println x y))"><y>#</y><d>2020-06-23</d><h>07:09</h><w>ikitommi</w>Imaginary example with not much boilerplate with schematized fns using custom schema element <code>:db/ref</code> registered into the global registry:
<pre>(m/defn my-fn [x :- int?, y :- [:maybe [:db/ref uuid?]]
  (println x y))</pre></z><z id="t1592896473" t="ikitommi About the Var refs - how would that be serialized? It could be done by having an asymmetric m/form for that component, which might be a bad idea: (m/form [:maybe [:tuple [:= &quot;ping&quot;] [:ref #&apos;Pong]]) ;[:registry ; {:registry {::ping [:maybe {:id ::pong} [:tuple [:= &quot;ping&quot;] [:ref ::pong]]] ; ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}} ; [:ref ::ping]]"><y>#</y><d>2020-06-23</d><h>07:14</h><w>ikitommi</w>About the Var refs - how would that be serialized? It could be done by having an asymmetric <code>m/form</code> for that component, which might be a bad idea:
<pre>(m/form [:maybe [:tuple [:= &quot;ping&quot;] [:ref #&apos;Pong]])
;[:registry
; {:registry {::ping [:maybe {:id ::pong} [:tuple [:= &quot;ping&quot;] [:ref ::pong]]]
;             ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}}
; [:ref ::ping]]</pre></z><z id="t1592896489" t="ikitommi or is it?"><y>#</y><d>2020-06-23</d><h>07:14</h><w>ikitommi</w>or is it?</z><z id="t1592898467" t="ikitommi this works now too: (mg/generate [:registry {:registry {::ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref ::pong]]] ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}} [:ref ::ping]] {:size 7, :seed 86}) ; =&gt; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]]]]"><y>#</y><d>2020-06-23</d><h>07:47</h><w>ikitommi</w>this works now too:
<pre>(mg/generate
  [:registry
   {:registry {::ping [:maybe [:tuple [:= &quot;ping&quot;] [:ref ::pong]]]
               ::pong [:maybe [:tuple [:= &quot;pong&quot;] [:ref ::ping]]]}}
   [:ref ::ping]]
  {:size 7, :seed 86})
; =&gt; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; [&quot;pong&quot; [&quot;ping&quot; nil]]]]]</pre></z><z id="t1593070100" t="ikitommi local registries, holes, nesting and masking - the recent thoughts from the hammock, comments most welcome: https://github.com/metosin/malli/pull/117#issuecomment-649305848"><y>#</y><d>2020-06-25</d><h>07:28</h><w>ikitommi</w>local registries, holes, nesting and masking - the recent thoughts from the hammock, comments most welcome: <a href="https://github.com/metosin/malli/pull/117#issuecomment-649305848" target="_blank">https://github.com/metosin/malli/pull/117#issuecomment-649305848</a></z><z id="t1593343416" t="ikitommi About to add eager references too: (def Schema [:and {:registry {::a ::b ::b ::c ::c [:schema pos-int?]}} [:and ::a ::b ::c]]) (m/form Schema) ;[:and {:registry #:user{:a :user/b ; :b :user/c ; :c [:schema pos-int?]}} ; [:and :user/a :user/b :user/c]] (m/to-map-syntax Schema) ;{:type :and ; :properties {:registry #:user{:a :user/b ; :b :user/c ; :c [:schema pos-int?]}} ; :children [{:type :and ; :children [{:type :schema ; :children [:user/a]} ; {:type :schema ; :children [:user/b]} ; {:type :schema ; :children [:user/c]}]}]}"><y>#</y><d>2020-06-28</d><h>11:23</h><w>ikitommi</w>About to add eager references too:
<pre>(def Schema
  [:and
   {:registry {::a ::b
               ::b ::c
               ::c [:schema pos-int?]}}
   [:and ::a ::b ::c]])

(m/form Schema)
;[:and {:registry #:user{:a :user/b
;                        :b :user/c
;                        :c [:schema pos-int?]}}
; [:and :user/a :user/b :user/c]]

(m/to-map-syntax Schema)
;{:type :and
; :properties {:registry #:user{:a :user/b
;                               :b :user/c
;                               :c [:schema pos-int?]}}
; :children [{:type :and
;             :children [{:type :schema
;                         :children [:user/a]}
;                        {:type :schema
;                         :children [:user/b]}
;                        {:type :schema
;                         :children [:user/c]}]}]}</pre></z><z id="t1593343523" t="ikitommi e.g. each registry hop retains the information the original linkage + :schema element to mark Entitys in a schema data graph."><y>#</y><d>2020-06-28</d><h>11:25</h><w>ikitommi</w>e.g. each registry hop retains the information the original linkage + <code>:schema</code> element to mark Entitys in a schema data graph.</z><z id="t1593343552" t="ikitommi (all registry hops are internaly :schema too)"><y>#</y><d>2020-06-28</d><h>11:25</h><w>ikitommi</w>(all registry hops are internaly <code>:schema</code> too)</z><z id="t1593343579" t="ikitommi accept can be configured to automatically walk over those, if wanted."><y>#</y><d>2020-06-28</d><h>11:26</h><w>ikitommi</w>accept can be configured to automatically walk over those, if wanted.</z><z id="t1593343616" t="ikitommi both :schema and :ref also implement the new (defprotocol RefSchema (-deref [this] &quot;returns the referenced schema&quot;))"><y>#</y><d>2020-06-28</d><h>11:26</h><w>ikitommi</w>both <code>:schema</code> and <code>:ref</code> also implement the new
<pre>(defprotocol RefSchema
  (-deref [this] &quot;returns the referenced schema&quot;))</pre></z><z id="t1593346579" t="ikitommi … and for the given schema, the validation fn is just pos-int?"><y>#</y><d>2020-06-28</d><h>12:16</h><w>ikitommi</w>… and for the given schema, the validation fn is just <code>pos-int?</code></z><z id="t1593346585" t="ikitommi (m/validator Schema) ; #object[clojure.core$pos_int]"><y>#</y><d>2020-06-28</d><h>12:16</h><w>ikitommi</w><pre>(m/validator Schema)
; #object[clojure.core$pos_int]</pre></z><z id="t1593346602" t="ikitommi which is kinda awesome 🙂"><y>#</y><d>2020-06-28</d><h>12:16</h><w>ikitommi</w>which is kinda awesome <b>🙂</b></z><z id="t1593511207" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] https://github.com/metosin/malli/pull/210"><y>#</y><d>2020-06-30</d><h>10:00</h><w>borkdude</w><a>@ikitommi</a> <a href="https://github.com/metosin/malli/pull/210" target="_blank">https://github.com/metosin/malli/pull/210</a></z><z id="t1593511411" t="borkdude I made a PR to malli which makes sci optional. The tests are failing, but this is only because the order in which namespaces are loaded is random. sci.core needs to be loaded first. But since sci.core is now optional, the tests have to be refactored accordingly anyway. Just putting this here in case someone has ideas about it."><y>#</y><d>2020-06-30</d><h>10:03</h><w>borkdude</w>I made a PR to malli which makes sci optional.
The tests are failing, but this is only because the order in which namespaces are loaded is random. sci.core needs to be loaded first. But since sci.core is now optional, the tests have to be refactored accordingly anyway. Just putting this here in case someone has ideas about it.</z><z id="t1593511420" t="borkdude Locally the tests pass, FWIW."><y>#</y><d>2020-06-30</d><h>10:03</h><w>borkdude</w>Locally the tests pass, FWIW.</z><z id="t1593512376" t="borkdude I might put that dynaload code into a library so it can be used in more projects."><y>#</y><d>2020-06-30</d><h>10:19</h><w>borkdude</w>I might put that dynaload code into a library so it can be used in more projects.</z><z id="t1593521352" t="ikitommi will check that out, thanks!"><y>#</y><d>2020-06-30</d><h>12:49</h><w>ikitommi</w>will check that out, thanks!</z><z id="t1593521360" t="ikitommi a separat one-purpose lib would be good"><y>#</y><d>2020-06-30</d><h>12:49</h><w>ikitommi</w>a separat one-purpose lib would be good</z><z id="t1593521376" t="ikitommi merged recursion PR into master."><y>#</y><d>2020-06-30</d><h>12:49</h><w>ikitommi</w>merged recursion PR into master.</z><z id="t1593521417" t="ikitommi here’s a sample (the generation is blocking the main thread, should port to use web-worker?): https://malli.io/?value=%7B%3Alines%20%5B%7B%3Aburger%20%7B%3Aname%20%22NAUGHTY%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22Finnish%20100%25%20beef%20patty%2C%20cheddar%2C%20St%20Agur%20blue%20cheese%2C%20bacon%20jam%2C%20rocket%2C%20aioli%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aorigin%20%7B%3Aname%20%3AFI%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aprice%2011%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%3Aamount%202%7D%5D%2C%0A%20%3Adelivery%20%7B%3Adelivered%20false%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Aaddress%20%7B%3Astreet%20%22H%C3%A4meenkatu%2010%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Azip%2033100%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Acountry%20%7B%3Aname%20%3AFI%2C%20%3Aneighbors%20%5B%7B%3Aname%20%3APO%7D%5D%7D%7D%7D%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Auser%2Fcountry%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20%5B%3Aenum%20%3AFI%20%3APO%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aneighbors%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aoptional%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avector%20%5B%3Aref%20%3Auser%2Fcountry%5D%5D%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fburger%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adescription%20%7B%3Aoptional%20true%7D%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorigin%20%5B%3Amaybe%20%3Auser%2Fcountry%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprice%20pos-int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder-line%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aburger%20%3Auser%2Fburger%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aamount%20int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Alines%20%5B%3Avector%20%3Auser%2Forder-line%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivery%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivered%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aaddress%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astreet%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Azip%20int%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acountry%20%3Auser%2Fcountry%5D%5D%5D%5D%5D%5D%7D%7D%0A%20%3Auser%2Forder%5D"><y>#</y><d>2020-06-30</d><h>12:50</h><w>ikitommi</w>here’s a sample (the generation is blocking the main thread, should port to use web-worker?): <a href="https://malli.io/?value=%7B%3Alines%20%5B%7B%3Aburger%20%7B%3Aname%20%22NAUGHTY%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22Finnish%20100%25%20beef%20patty%2C%20cheddar%2C%20St%20Agur%20blue%20cheese%2C%20bacon%20jam%2C%20rocket%2C%20aioli%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aorigin%20%7B%3Aname%20%3AFI%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aprice%2011%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%3Aamount%202%7D%5D%2C%0A%20%3Adelivery%20%7B%3Adelivered%20false%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Aaddress%20%7B%3Astreet%20%22H%C3%A4meenkatu%2010%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Azip%2033100%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Acountry%20%7B%3Aname%20%3AFI%2C%20%3Aneighbors%20%5B%7B%3Aname%20%3APO%7D%5D%7D%7D%7D%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Auser%2Fcountry%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20%5B%3Aenum%20%3AFI%20%3APO%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aneighbors%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aoptional%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avector%20%5B%3Aref%20%3Auser%2Fcountry%5D%5D%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fburger%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adescription%20%7B%3Aoptional%20true%7D%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorigin%20%5B%3Amaybe%20%3Auser%2Fcountry%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprice%20pos-int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder-line%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aburger%20%3Auser%2Fburger%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aamount%20int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Alines%20%5B%3Avector%20%3Auser%2Forder-line%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivery%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivered%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aaddress%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astreet%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Azip%20int%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acountry%20%3Auser%2Fcountry%5D%5D%5D%5D%5D%5D%7D%7D%0A%20%3Auser%2Forder%5D" target="_blank">https://malli.io/?value=%7B%3Alines%20%5B%7B%3Aburger%20%7B%3Aname%20%22NAUGHTY%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22Finnish%20100%25%20beef%20patty%2C%20cheddar%2C%20St%20Agur%20blue%20cheese%2C%20bacon%20jam%2C%20rocket%2C%20aioli%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aorigin%20%7B%3Aname%20%3AFI%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aprice%2011%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%3Aamount%202%7D%5D%2C%0A%20%3Adelivery%20%7B%3Adelivered%20false%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Aaddress%20%7B%3Astreet%20%22H%C3%A4meenkatu%2010%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Azip%2033100%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Acountry%20%7B%3Aname%20%3AFI%2C%20%3Aneighbors%20%5B%7B%3Aname%20%3APO%7D%5D%7D%7D%7D%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Auser%2Fcountry%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20%5B%3Aenum%20%3AFI%20%3APO%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aneighbors%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aoptional%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avector%20%5B%3Aref%20%3Auser%2Fcountry%5D%5D%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fburger%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adescription%20%7B%3Aoptional%20true%7D%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorigin%20%5B%3Amaybe%20%3Auser%2Fcountry%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprice%20pos-int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder-line%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aburger%20%3Auser%2Fburger%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aamount%20int%3F%5D%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Forder%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Alines%20%5B%3Avector%20%3Auser%2Forder-line%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivery%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%3Aclosed%20true%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Adelivered%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aaddress%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astreet%20string%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Azip%20int%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acountry%20%3Auser%2Fcountry%5D%5D%5D%5D%5D%5D%7D%7D%0A%20%3Auser%2Forder%5D</a></z><z id="t1593530909" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] https://github.com/borkdude/dynaload"><y>#</y><d>2020-06-30</d><h>15:28</h><w>borkdude</w><a>@ikitommi</a> <a href="https://github.com/borkdude/dynaload" target="_blank">https://github.com/borkdude/dynaload</a></z><z id="t1593535428" t="Sathiya Hi. I have an use case with the data structure and scenario similar to the following example { &quot;name&quot;: string, &quot;age&quot;: int, &quot;married&quot;: boolean, &quot;sex&quot;: string &quot;partner&quot;: { &quot;husband&quot;:{&quot;name&quot;: string, &quot;age&quot;: int}, &quot;wife&quot;:{&quot;name&quot;: string, &quot;age&quot;: int} } } name in husband is mandatory if the status is married and sex is Male. name in wife is mandatory if status is married and sex is female. both are not needed if married is false. how do i write the malli schema validations for the following scenario. if both the fields are at the same level i could add a function and validation. since one is at a parent and the other field is inside the child, i am unable to find a solution to implement this. any help would be appreciated. thanks in advance"><y>#</y><d>2020-06-30</d><h>16:43</h><w>Sathiya</w>Hi. I have an use case with the data structure and scenario similar to the following example
<code>{</code>
<code>&quot;name&quot;: string,</code>
<code>&quot;age&quot;: int,</code>
<code>&quot;married&quot;: boolean,</code>
<code>&quot;sex&quot;: string</code>
<code>&quot;partner&quot;: {</code>
	<code>&quot;husband&quot;:{&quot;name&quot;: string, &quot;age&quot;: int},</code>
	<code>&quot;wife&quot;:{&quot;name&quot;: string, &quot;age&quot;: int}</code>
	<code>}</code>
<code>}</code>
 name in husband is mandatory if the status is married and sex is Male. name in wife is mandatory if status is married and sex is female. both are not needed if married is false. how do i write the malli schema validations for the following scenario. if both the fields are at the same level i could add a function and validation. since one is at a parent and the other field is inside the child, i am unable to find a solution to implement this. any help would be appreciated. thanks in advance</z><z id="t1593538161" t="ikitommi hi [:attrs {:href &quot;/_/_/users/U016GSFNDNY&quot;}] . You can add rules to top-level and add error metadata to point into nested fields. Something like: (def Person [:and {:registry {:partner [:map [&quot;name&quot; string?] [&quot;age&quot; int?]]}} [:map [&quot;name&quot; string?] [&quot;age&quot; int?] [&quot;married&quot; boolean?] [&quot;sex&quot; string?] [&quot;partner&quot; {:optional true} [:map [&quot;husband&quot; {:optional true} :partner] [&quot;wife&quot; {:optional true} :partner]]]] [:fn {:error/message &quot;wife name is mandatory for married men&quot; :error/path [&quot;partner&quot; &quot;wife&quot; &quot;name&quot;]} (fn [{:strs [sex married partner]}] (not (and married (= &quot;male&quot; sex) (not (get-in partner [&quot;wife&quot; &quot;name&quot;])))))] [:fn {:error/message &quot;husband name is mandatory for married female&quot; :error/path [&quot;partner&quot; &quot;wife&quot; &quot;name&quot;]} (fn [{:strs [sex married partner]}] (not (and married (= &quot;female&quot; sex) (not (get-in partner [&quot;husband&quot; &quot;name&quot;])))))]]) (-&gt; Person (m/explain {&quot;name&quot; &quot;Mauno&quot; &quot;age&quot; 31 &quot;married&quot; true &quot;sex&quot; &quot;male&quot; &quot;partner&quot; {&quot;wife&quot; {&quot;age&quot; 41}}}) (me/humanize)) ;{&quot;partner&quot; {&quot;wife&quot; {&quot;name&quot; [&quot;missing required key&quot; ; &quot;wife name is mandatory for married men&quot;]}}} "><y>#</y><d>2020-06-30</d><h>17:29</h><w>ikitommi</w>hi <a>@kspriyan31</a>. You can add rules to top-level and add error metadata to point into nested fields. Something like:
<pre>(def Person
  [:and {:registry {:partner [:map [&quot;name&quot; string?] [&quot;age&quot; int?]]}}
   [:map
    [&quot;name&quot; string?]
    [&quot;age&quot; int?]
    [&quot;married&quot; boolean?]
    [&quot;sex&quot; string?]
    [&quot;partner&quot; {:optional true}
     [:map
      [&quot;husband&quot; {:optional true} :partner]
      [&quot;wife&quot; {:optional true} :partner]]]]
   
   [:fn {:error/message &quot;wife name is mandatory for married men&quot;
         :error/path [&quot;partner&quot; &quot;wife&quot; &quot;name&quot;]}
    (fn [{:strs [sex married partner]}]
      (not (and married (= &quot;male&quot; sex) (not (get-in partner [&quot;wife&quot; &quot;name&quot;])))))]
   
   [:fn {:error/message &quot;husband name is mandatory for married female&quot;
         :error/path [&quot;partner&quot; &quot;wife&quot; &quot;name&quot;]}
    (fn [{:strs [sex married partner]}]
      (not (and married (= &quot;female&quot; sex) (not (get-in partner [&quot;husband&quot; &quot;name&quot;])))))]])

(-&gt; Person
    (m/explain {&quot;name&quot; &quot;Mauno&quot;
                &quot;age&quot; 31
                &quot;married&quot; true
                &quot;sex&quot; &quot;male&quot;
                &quot;partner&quot; {&quot;wife&quot; {&quot;age&quot; 41}}})
    (me/humanize))
;{&quot;partner&quot; {&quot;wife&quot; {&quot;name&quot; [&quot;missing required key&quot; 
;                            &quot;wife name is mandatory for married men&quot;]}}} </pre></z><z id="t1593538467" t="ikitommi here’s the same in http://malli.io : http://shorturl.at/hmuFV"><y>#</y><d>2020-06-30</d><h>17:34</h><w>ikitommi</w>here’s the same in <a href="http://malli.io" target="_blank">http://malli.io</a>: <a href="http://shorturl.at/hmuFV" target="_blank">http://shorturl.at/hmuFV</a></z><z id="t1593538736" t="Sathiya Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2020-06-30</d><h>17:38</h><w>Sathiya</w>Thank you <a>@ikitommi</a></z><z id="t1593538765" t="ikitommi if you change the sex to [:enum &quot;male&quot; &quot;female&quot; &quot;other&quot;] the sample value generation can generate better values: ({&quot;name&quot; &quot;&quot;, &quot;age&quot; 1, &quot;married&quot; true, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -1}, &quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; 0}}} {&quot;name&quot; &quot;&quot;, &quot;age&quot; 2, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;} {&quot;name&quot; &quot;K5&quot;, &quot;age&quot; 2, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -1}}} {&quot;name&quot; &quot;&quot;, &quot;age&quot; 3, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;} {&quot;name&quot; &quot;8Mn&quot;, &quot;age&quot; 3, &quot;married&quot; true, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;J&quot;, &quot;age&quot; -4}, &quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; 3}}} {&quot;name&quot; &quot;bsyt4&quot;, &quot;age&quot; 1, &quot;married&quot; false, &quot;sex&quot; &quot;female&quot;} {&quot;name&quot; &quot;8k5yk&quot;, &quot;age&quot; 6, &quot;married&quot; false, &quot;sex&quot; &quot;female&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;4&quot;, &quot;age&quot; 13}}} {&quot;name&quot; &quot;5ut0D2sm&quot;, &quot;age&quot; 1, &quot;married&quot; true, &quot;sex&quot; &quot;female&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -102}, &quot;wife&quot; {&quot;name&quot; &quot;i4Q5l6xa&quot;, &quot;age&quot; 0}}} {&quot;name&quot; &quot;&quot;, &quot;age&quot; 1, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;} {&quot;name&quot; &quot;l&quot;, &quot;age&quot; 3, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;Ixh4drJNb&quot;, &quot;age&quot; -37}}})"><y>#</y><d>2020-06-30</d><h>17:39</h><w>ikitommi</w>if you change the <code>sex</code> to <code>[:enum &quot;male&quot; &quot;female&quot; &quot;other&quot;]</code>the sample value generation can generate better values:
<pre>({&quot;name&quot; &quot;&quot;,
  &quot;age&quot; 1,
  &quot;married&quot; true,
  &quot;sex&quot; &quot;male&quot;,
  &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -1}, &quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; 0}}}
 {&quot;name&quot; &quot;&quot;, &quot;age&quot; 2, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;}
 {&quot;name&quot; &quot;K5&quot;, &quot;age&quot; 2, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -1}}}
 {&quot;name&quot; &quot;&quot;, &quot;age&quot; 3, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;}
 {&quot;name&quot; &quot;8Mn&quot;,
  &quot;age&quot; 3,
  &quot;married&quot; true,
  &quot;sex&quot; &quot;male&quot;,
  &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;J&quot;, &quot;age&quot; -4}, &quot;wife&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; 3}}}
 {&quot;name&quot; &quot;bsyt4&quot;, &quot;age&quot; 1, &quot;married&quot; false, &quot;sex&quot; &quot;female&quot;}
 {&quot;name&quot; &quot;8k5yk&quot;, &quot;age&quot; 6, &quot;married&quot; false, &quot;sex&quot; &quot;female&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;4&quot;, &quot;age&quot; 13}}}
 {&quot;name&quot; &quot;5ut0D2sm&quot;,
  &quot;age&quot; 1,
  &quot;married&quot; true,
  &quot;sex&quot; &quot;female&quot;,
  &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;&quot;, &quot;age&quot; -102}, &quot;wife&quot; {&quot;name&quot; &quot;i4Q5l6xa&quot;, &quot;age&quot; 0}}}
 {&quot;name&quot; &quot;&quot;, &quot;age&quot; 1, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;}
 {&quot;name&quot; &quot;l&quot;, &quot;age&quot; 3, &quot;married&quot; false, &quot;sex&quot; &quot;male&quot;, &quot;partner&quot; {&quot;husband&quot; {&quot;name&quot; &quot;Ixh4drJNb&quot;, &quot;age&quot; -37}}})</pre></z><z id="t1593538779" t="ikitommi your welcome"><y>#</y><d>2020-06-30</d><h>17:39</h><w>ikitommi</w>your welcome</z><z id="t1593636424" t="katox I&apos;m looing at https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj How can I enable the same kind of coercion but to path-params instead of query params? If I change just the key it goes through untouched."><y>#</y><d>2020-07-01</d><h>20:47</h><w>katox</w>I&apos;m looing at <a href="https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj" target="_blank">https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj</a>

How can I enable the same kind of coercion but to path-params instead of query params? If I change just the key it goes through untouched.</z><z id="t1593646460" t="jkent [:attrs {:href &quot;/_/_/users/U0KD0N5T5&quot;}] here’s an example of path coercion [&quot;/foo/:x/:y&quot; {:get {:summary &quot;plus with malli query parameters&quot; :parameters {:path [:map [:x int?] [:y int?]]} :handler (fn [{{{:keys [x y]} :path} :parameters}] {:status 200 :body {:total (+ x y)}})}}]"><y>#</y><d>2020-07-01</d><h>23:34</h><w>jkent</w><a>@katox</a> here’s an example of path coercion
<pre>[&quot;/foo/:x/:y&quot;
     {:get {:summary    &quot;plus with malli query parameters&quot;
            :parameters {:path [:map [:x int?] [:y int?]]}
            :handler    (fn [{{{:keys [x y]} :path} :parameters}]
                          {:status 200
                           :body   {:total  (+ x y)}})}}]</pre></z><z id="t1593676961" t="katox [:attrs {:href &quot;/_/_/users/U011CL58Q4W&quot;}] of course, a shorter key than variants I tried. Thank you, it works!"><y>#</y><d>2020-07-02</d><h>08:02</h><w>katox</w><a>@jkent</a> of course, a shorter key than variants I tried. Thank you, it works!</z><z id="t1593687034" t="ikitommi Almost there: (def Order [:schema {:registry {&quot;Country&quot; [:map [:name [:enum :FI :PO]] [:neighbors [:vector [:ref &quot;Country&quot;]]]] &quot;Burger&quot; [:map [:name string?] [:description {:optional true} string?] [:origin [:maybe &quot;Country&quot;]] [:price pos-int?]] &quot;OrderLine&quot; [:map [:burger &quot;Burger&quot;] [:amount int?]] &quot;Order&quot; [:map [:lines [:vector &quot;OrderLine&quot;]] [:delivery [:map [:delivered boolean?] [:address [:map [:street string?] [:zip int?] [:country &quot;Country&quot;]]]]]]}} &quot;Order&quot;]) (malli.mermaid/class-diagram Order) ; classDiagram ; class Country { ; :name [:enum :FI :PO] ; :neighbors [:vector #:gen{:max 0} [:ref Country]] ; } ; class Burger { ; :name string? ; :description string? ; :origin [:maybe Country] ; :price pos-int? ; } ; class OrderLine { ; :burger Burger ; :amount int? ; } ; class Order { ; :lines [:vector OrderLine] ; :delivery Order_Delivery ; } ; class Order_Delivery_Address { ; :street string? ; :zip int? ; :country Country ; } ; class Order_Delivery { ; :delivered boolean? ; :address Order_Delivery_Address ; } ; Country o-- Country ; Burger o-- Country ; OrderLine o-- Burger ; Order o-- OrderLine ; Order *-- Order_Delivery ; Order_Delivery_Address o-- Country ; Order_Delivery *-- Order_Delivery_Address"><y>#</y><d>2020-07-02</d><h>10:50</h><w>ikitommi</w>Almost there:
<pre>(def Order
  [:schema
   {:registry {&quot;Country&quot; [:map
                          [:name [:enum :FI :PO]]
                          [:neighbors [:vector  [:ref &quot;Country&quot;]]]]
               &quot;Burger&quot; [:map
                         [:name string?]
                         [:description {:optional true} string?]
                         [:origin [:maybe &quot;Country&quot;]]
                         [:price pos-int?]]
               &quot;OrderLine&quot; [:map
                            [:burger &quot;Burger&quot;]
                            [:amount int?]]
               &quot;Order&quot; [:map
                        [:lines [:vector &quot;OrderLine&quot;]]
                        [:delivery [:map
                                    [:delivered boolean?]
                                    [:address [:map
                                               [:street string?]
                                               [:zip int?]
                                               [:country &quot;Country&quot;]]]]]]}}
   &quot;Order&quot;])

(malli.mermaid/class-diagram Order)
; classDiagram
;   class Country {
;     :name [:enum :FI :PO]
;     :neighbors [:vector #:gen{:max 0} [:ref Country]]
;   }
;   class Burger {
;     :name string?
;     :description string?
;     :origin [:maybe Country]
;     :price pos-int?
;   }
;   class OrderLine {
;     :burger Burger
;     :amount int?
;   }
;   class Order {
;     :lines [:vector OrderLine]
;     :delivery Order_Delivery
;   }
;   class Order_Delivery_Address {
;     :street string?
;     :zip int?
;     :country Country
;   }
;   class Order_Delivery {
;     :delivered boolean?
;     :address Order_Delivery_Address
;   }
;   Country o-- Country
;   Burger o-- Country
;   OrderLine o-- Burger
;   Order o-- OrderLine
;   Order *-- Order_Delivery
;   Order_Delivery_Address o-- Country
;   Order_Delivery *-- Order_Delivery_Address</pre></z><z id="t1593687047" t="ikitommi"><y>#</y><d>2020-07-02</d><h>10:50</h><w>ikitommi</w></z><z id="t1593687200" t="ikitommi as the map keys can be anything, the registry keys can be any non-vector. Strings looks nice."><y>#</y><d>2020-07-02</d><h>10:53</h><w>ikitommi</w>as the map keys can be anything, the registry keys can be any non-vector. Strings looks nice.</z><z id="t1593687507" t="ikitommi when a Schema is created (using m/schema ), all the registry refs are eagerly validated and the current values are captured: • have an Invalid ref? -&gt; fail early • using mutable registry? -&gt; the created schema instance (including refs!) is still immutable • wan’t to know the local registry which the schema was created with -&gt; accessible via m/options"><y>#</y><d>2020-07-02</d><h>10:58</h><w>ikitommi</w>when a Schema is created (using <code>m/schema</code>), all the registry refs are eagerly validated and the current values are captured:
• have an Invalid ref? -&gt; fail early
• using mutable registry? -&gt; the created schema instance (including refs!) is still immutable
• wan’t to know the local registry which the schema was created with -&gt; accessible via <code>m/options</code></z><z id="t1593687610" t="ikitommi clojure.spec with mutable global registry, fail late and mutable refs doesn’t seem that right anymore."><y>#</y><d>2020-07-02</d><h>11:00</h><w>ikitommi</w>clojure.spec with mutable global registry, fail late and mutable refs doesn’t seem that right anymore.</z><z id="t1593719445" t="kwrooijen Is this intended behavior? Here we say that the :id field is optional in the map schema. Which works (m/validate [:map [:id {:optional true} int?]] {}) ; =&gt; true Here we give the :id field a default value. But this doesn&apos;t work (m/decode [:map [:id {:default 42} int?]] {} mt/default-value-transformer) ; =&gt; {} Instead, we have to give field&apos;s spec a default, not the map&apos;s key (m/decode [:map [:id [:and {:default 42} int?]]] {} mt/default-value-transformer) ; =&gt; {:id 42} Personally I find the last example a bit strange (Or better yet, I find it strange that the second doesn&apos;t work). I&apos;m not saying the ints have a default, I&apos;m saying that this maps :id field has a default. Just like how :id is an optional field, not that that int? is an optional schema. Maybe there&apos;s a reason it&apos;s designed this way? I could just be looking at this from the wrong angle."><y>#</y><d>2020-07-02</d><h>19:50</h><w>kwrooijen</w>Is this intended behavior?

Here we say that the <code>:id</code> field is optional in the map schema. Which works
<pre>(m/validate
 [:map
  [:id {:optional true} int?]]
 {}) ; =&gt; true</pre>
Here we give the <code>:id</code> field a default value. But this doesn&apos;t work
<pre>(m/decode
 [:map
  [:id {:default 42} int?]]
 {}
 mt/default-value-transformer) ; =&gt; {}</pre>
Instead, we have to give field&apos;s spec a default, not the map&apos;s key
<pre>(m/decode
 [:map
  [:id [:and {:default 42} int?]]]
 {}
 mt/default-value-transformer) ; =&gt; {:id 42}</pre>
Personally I find the last example a bit strange (Or better yet, I find it strange that the second doesn&apos;t work). I&apos;m not saying the ints have a default, I&apos;m saying that this maps <code>:id</code> field has a default. Just like how <code>:id</code> is an optional field, not that that <code>int?</code>  is an optional schema.
Maybe there&apos;s a reason it&apos;s designed this way? I could just be looking at this from the wrong angle.</z><z id="t1593719551" t="kwrooijen I guess it&apos;s more that I find it very unexpected that the second example doesn&apos;t work"><y>#</y><d>2020-07-02</d><h>19:52</h><w>kwrooijen</w>I guess it&apos;s more that I find it very unexpected that the second example doesn&apos;t work</z><z id="t1593761257" t="ikitommi [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] handling map-entry properties is the last issue to be resolved to make the malli design complete for release, see https://github.com/metosin/malli/issues/116"><y>#</y><d>2020-07-03</d><h>07:27</h><w>ikitommi</w><a>@kevin.van.rooijen</a> handling map-entry properties is the last issue to be resolved to make the malli design complete for release, see <a href="https://github.com/metosin/malli/issues/116" target="_blank">https://github.com/metosin/malli/issues/116</a></z><z id="t1593761364" t="ikitommi Have some ideas how to fix that elegantly, but comments on the issues most welcome"><y>#</y><d>2020-07-03</d><h>07:29</h><w>ikitommi</w>Have some ideas how to fix that elegantly, but comments on the issues most welcome</z><z id="t1593761364" t="kwrooijen Ah ok, good to hear"><y>#</y><d>2020-07-03</d><h>07:29</h><w>kwrooijen</w>Ah ok, good to hear</z><z id="t1593761394" t="kwrooijen I did some digging and realized I asked the same question 3 months ago haha (but no answer at that time)"><y>#</y><d>2020-07-03</d><h>07:29</h><w>kwrooijen</w>I did some digging and realized I asked the same question 3 months ago haha (but no answer at that time)</z><z id="t1593761442" t="ikitommi Hmm.. could you link that with #86?"><y>#</y><d>2020-07-03</d><h>07:30</h><w>ikitommi</w>Hmm.. could you link that with #86?</z><z id="t1593761504" t="ikitommi or do you mean here? Slack history kinda sucks"><y>#</y><d>2020-07-03</d><h>07:31</h><w>ikitommi</w>or do you mean here? Slack history kinda sucks</z><z id="t1593761519" t="kwrooijen Apparently I asked that question in my PR to support qualified keywords in maps"><y>#</y><d>2020-07-03</d><h>07:31</h><w>kwrooijen</w>Apparently I asked that question in my PR to support qualified keywords in maps</z><z id="t1593761552" t="kwrooijen I had a bit of a monologue in that pr haha"><y>#</y><d>2020-07-03</d><h>07:32</h><w>kwrooijen</w>I had a bit of a monologue in that pr haha</z><z id="t1593761581" t="kwrooijen https://github.com/metosin/malli/pull/194#issuecomment-609977835"><y>#</y><d>2020-07-03</d><h>07:33</h><w>kwrooijen</w><a href="https://github.com/metosin/malli/pull/194#issuecomment-609977835" target="_blank">https://github.com/metosin/malli/pull/194#issuecomment-609977835</a></z><z id="t1593761640" t="ikitommi there is a bunch of PRs I know are related to this, wanted to have this figured out before merging any of those in. Sorry for the lag with PRs."><y>#</y><d>2020-07-03</d><h>07:34</h><w>ikitommi</w>there is a bunch of PRs I know are related to this, wanted to have this figured out before merging any of those in. Sorry for the lag with PRs.</z><z id="t1593761708" t="kwrooijen Don&apos;t worry about it, it&apos;s a tough problem to handle"><y>#</y><d>2020-07-03</d><h>07:35</h><w>kwrooijen</w>Don&apos;t worry about it, it&apos;s a tough problem to handle</z><z id="t1593775954" t="sudakatux HI."><y>#</y><d>2020-07-03</d><h>11:32</h><w>sudakatux</w>HI.</z><z id="t1593775968" t="sudakatux So what would be the correct type for a date LocalDateTime to be more specific"><y>#</y><d>2020-07-03</d><h>11:32</h><w>sudakatux</w>So what would be the correct type for a date LocalDateTime to be more specific</z><z id="t1593775974" t="sudakatux :responses {200 {:body [:vector [:map [:id int?] [:sender_id int?] [:conversation_id int?] [:created_at string?] [:state string?]] ]} "><y>#</y><d>2020-07-03</d><h>11:32</h><w>sudakatux</w><pre>:responses  {200 {:body [:vector
                                     [:map
                                      [:id int?]
                                      [:sender_id int?]
                                      [:conversation_id int?]
                                      [:created_at string?]
                                      [:state string?]]
                                     ]}      </pre></z><z id="t1593776024" t="sudakatux I tried inst? and it did not work. the error shows it as a string because of the conversion. but the validation seems to run before"><y>#</y><d>2020-07-03</d><h>11:33</h><w>sudakatux</w>I tried inst? and it did not work. the error shows it as a string because of the conversion. but the validation seems to run before</z><z id="t1593776323" t="sudakatux {:id 1, :message &quot;string&quot;, :sender_id 1, :conversation_id 1, :created_at #object[java.time.LocalDateTime 0x4cc366e7 &quot;2020-06-30T18:50:23.695073&quot;], :state &quot;UNREAD&quot;}"><y>#</y><d>2020-07-03</d><h>11:38</h><w>sudakatux</w><pre>{:id 1,
  :message &quot;string&quot;,
  :sender_id 1,
  :conversation_id 1,
  :created_at #object[java.time.LocalDateTime 0x4cc366e7 &quot;2020-06-30T18:50:23.695073&quot;],
  :state &quot;UNREAD&quot;}</pre></z><z id="t1593777765" t="ikitommi https://github.com/metosin/malli/issues/49 is the issue for adding proper (Java8+ &amp; goog.*) dates."><y>#</y><d>2020-07-03</d><h>12:02</h><w>ikitommi</w><a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a> is the issue for adding proper (Java8+ &amp; goog.*) dates.</z><z id="t1593777814" t="ikitommi before that, [:fn (partial instance? LocalDateTime)] does the validation part"><y>#</y><d>2020-07-03</d><h>12:03</h><w>ikitommi</w>before that, <code>[:fn (partial instance? LocalDateTime)]</code> does the validation part</z><z id="t1593779071" t="sudakatux cool thanks"><y>#</y><d>2020-07-03</d><h>12:24</h><w>sudakatux</w>cool thanks</z><z id="t1593883788" t="ikitommi started on thinking https://github.com/metosin/malli/pull/212"><y>#</y><d>2020-07-04</d><h>17:29</h><w>ikitommi</w>started on thinking <a href="https://github.com/metosin/malli/pull/212" target="_blank">https://github.com/metosin/malli/pull/212</a></z><z id="t1594023356" t="steveb8n Q: I’m starting with Malli in my re-frame client/forms. just checking to see if there’s any gotchas/advice from the team here?"><y>#</y><d>2020-07-06</d><h>08:15</h><w>steveb8n</w>Q: I’m starting with Malli in my re-frame client/forms. just checking to see if there’s any gotchas/advice from the team here?</z><z id="t1594025483" t="Vincent Cantin It depends how you use Malli .. validation and coercion?"><y>#</y><d>2020-07-06</d><h>08:51</h><w>Vincent Cantin</w>It depends how you use Malli .. validation and coercion?</z><z id="t1594027468" t="steveb8n just validation for now. keeping it simple to start. schemas hardcoded in client code. later I intend to send schemas over the wire from the server"><y>#</y><d>2020-07-06</d><h>09:24</h><w>steveb8n</w>just validation for now. keeping it simple to start. schemas hardcoded in client code. later I intend to send schemas over the wire from the server</z><z id="t1594027542" t="steveb8n I’m using it as a validator for https://github.com/luciodale/fork in this iteration. thus no coercion since the form inputs will constrain the values"><y>#</y><d>2020-07-06</d><h>09:25</h><w>steveb8n</w>I’m using it as a validator for <a href="https://github.com/luciodale/fork" target="_blank">https://github.com/luciodale/fork</a> in this iteration. thus no coercion since the form inputs will constrain the values</z><z id="t1594027862" t="ikitommi only notice is the bundle size, few hours away from making sci optional. Before that, the bundle is 200+kb. After, it&apos;s 1-12kb gzipped."><y>#</y><d>2020-07-06</d><h>09:31</h><w>ikitommi</w>only notice is the bundle size, few hours away from making sci optional. Before that, the bundle is 200+kb. After, it&apos;s 1-12kb gzipped.</z><z id="t1594027961" t="ikitommi oh, and you should create validators ahead of time, running m/validate can be orders of magnitude slower than just calling the returned function from m/validator ."><y>#</y><d>2020-07-06</d><h>09:32</h><w>ikitommi</w>oh, and you should create validators ahead of time, running <code>m/validate</code> can be orders of magnitude slower than just calling the returned function from <code>m/validator</code>.</z><z id="t1594028017" t="ikitommi same applies to m/explain vs m/explainer and to m/decode &amp; m/decoder (and encoders, generators etc)"><y>#</y><d>2020-07-06</d><h>09:33</h><w>ikitommi</w>same applies to <code>m/explain</code> vs <code>m/explainer</code> and to <code>m/decode</code> &amp; <code>m/decoder</code> (and encoders, generators etc)</z><z id="t1594028253" t="ikitommi fork-malli-example would be great gist/blog. Tried the first version of it, but was stumbling with nested data and for that case, did my own formik-kinda-thing for that project."><y>#</y><d>2020-07-06</d><h>09:37</h><w>ikitommi</w>fork-malli-example would be great gist/blog. Tried the first version of it, but was stumbling with nested data and for that case, did my own formik-kinda-thing for that project.</z><z id="t1594028307" t="ikitommi looking forward to seeing how the integration would look today [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] !"><y>#</y><d>2020-07-06</d><h>09:38</h><w>ikitommi</w>looking forward to seeing how the integration would look today <a>@steveb8n</a> !</z><z id="t1594028371" t="steveb8n thanks! great to know about the bundle increase."><y>#</y><d>2020-07-06</d><h>09:39</h><w>steveb8n</w>thanks! great to know about the bundle increase.</z><z id="t1594028391" t="steveb8n and I’ll def the schemas for now since they are static"><y>#</y><d>2020-07-06</d><h>09:39</h><w>steveb8n</w>and I’ll def the schemas for now since they are static</z><z id="t1594028657" t="steveb8n I’ll try and squeeze in a sample repo this week 🙂"><y>#</y><d>2020-07-06</d><h>09:44</h><w>steveb8n</w>I’ll try and squeeze in a sample repo this week <b>🙂</b></z><z id="t1594030427" t="kwrooijen Hey, is it possible to generate only alpha-numeric values with the :string type? Currently it will go wild and generate whatever it wants (which makes sense)"><y>#</y><d>2020-07-06</d><h>10:13</h><w>kwrooijen</w>Hey, is it possible to generate only alpha-numeric values with the <code>:string</code> type? Currently it will go wild and generate whatever it wants (which makes sense)</z><z id="t1594030456" t="kwrooijen Or is my only option to use a regular expression?"><y>#</y><d>2020-07-06</d><h>10:14</h><w>kwrooijen</w>Or is my only option to use a regular expression?</z><z id="t1594030809" t="ikitommi [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] you can use :gen/gen to override the generator, there is one for alphanumeric. Or use :gen/elements and list all valid in there."><y>#</y><d>2020-07-06</d><h>10:20</h><w>ikitommi</w><a>@kevin.van.rooijen</a> you can use <code>:gen/gen</code> to override the generator, there is one for alphanumeric. Or use <code>:gen/elements</code> and list all valid in there.</z><z id="t1594030884" t="ikitommi I think :string could have format option too, like in JSON Schema. But doesn&apos;t have that yet. One format could be :alphanumeric , validator and generator would follow that..."><y>#</y><d>2020-07-06</d><h>10:21</h><w>ikitommi</w>I think <code>:string</code> could have format option too, like in JSON Schema. But doesn&apos;t have that yet. One format could be <code>:alphanumeric</code> , validator and generator would follow that...</z><z id="t1594031107" t="kwrooijen Ah cool, the :gen/gen is what I need. And it would be nice to allow something like a :format option. Maybe make it extendable in some sort of way, perhaps a multimethod?"><y>#</y><d>2020-07-06</d><h>10:25</h><w>kwrooijen</w>Ah cool, the <code>:gen/gen</code> is what I need. And it would be nice to allow something like a <code>:format</code> option. Maybe make it extendable in some sort of way, perhaps a multimethod?</z><z id="t1594031170" t="kwrooijen e.g. [:string {:format :alphanumeric}] (defmethod malli/format :alphanumeric [_ v] ,,,) Something like this, or possibly more inline with how the registry for types works"><y>#</y><d>2020-07-06</d><h>10:26</h><w>kwrooijen</w>e.g.

<code>[:string {:format :alphanumeric}]</code>

<pre>(defmethod malli/format :alphanumeric [_ v]
  ,,,)</pre>
Something like this, or possibly more inline with how the registry for types works</z><z id="t1594084023" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] sample repo up and running: https://github.com/stevebuik/fork-malli-ideas"><y>#</y><d>2020-07-07</d><h>01:07</h><w>steveb8n</w><a>@ikitommi</a> sample repo up and running: <a href="https://github.com/stevebuik/fork-malli-ideas" target="_blank">https://github.com/stevebuik/fork-malli-ideas</a></z><z id="t1594084056" t="steveb8n first question to come from it: can the fast validation i.e. m/validator be used with m/explain?"><y>#</y><d>2020-07-07</d><h>01:07</h><w>steveb8n</w>first question to come from it: can the fast validation i.e. m/validator be used with m/explain?</z><z id="t1594097440" t="steveb8n and what was the “nested data” problem you had with this integration? maybe it’s another good demo in this repo"><y>#</y><d>2020-07-07</d><h>04:50</h><w>steveb8n</w>and what was the “nested data” problem you had with this integration? maybe it’s another good demo in this repo</z><z id="t1594130229" t="jkent does malli support default error messages for enums? I’m getting &quot;message&quot;: &quot;unknown error&quot; unless I do something like this for each enum: (def source-system [:enum {:error/message &quot;should be either: foo|bar&quot; :swagger/type &quot;string&quot; :description &quot;source system from where the request comes in&quot;} &quot;foo&quot; &quot;bar&quot;])"><y>#</y><d>2020-07-07</d><h>13:57</h><w>jkent</w>does <code>malli</code> support default error messages for enums? I’m getting <code>&quot;message&quot;: &quot;unknown error&quot;</code> unless I do something like this for each enum:
<pre>(def source-system
  [:enum
   {:error/message &quot;should be either: foo|bar&quot;
    :swagger/type  &quot;string&quot;
    :description   &quot;source system from where the request comes in&quot;}
   &quot;foo&quot; &quot;bar&quot;])</pre></z><z id="t1594154221" t="ikitommi [:attrs {:href &quot;/_/_/users/U011CL58Q4W&quot;}] the default errors are defined in https://github.com/metosin/malli/blob/master/src/malli/error.cljc . There is no default for :enum , but could be. PR welcome!"><y>#</y><d>2020-07-07</d><h>20:37</h><w>ikitommi</w><a>@jkent</a> the default errors are defined in <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc</a>. There is no default for <code>:enum</code>, but could be. PR welcome!</z><z id="t1594154311" t="ikitommi also, if some more native english-writing person could check the spelling of the default errors, should should be int be should be an int etc…"><y>#</y><d>2020-07-07</d><h>20:38</h><w>ikitommi</w>also, if some more native english-writing person could check the spelling of the default errors, should <code>should be int</code> be <code>should be an int</code> etc…</z><z id="t1594176731" t="steveb8n here you go…."><y>#</y><d>2020-07-08</d><h>02:52</h><r>steveb8n</r>here you go….</z><z id="t1594176732" t="steveb8n https://github.com/metosin/malli/pull/215"><y>#</y><d>2020-07-08</d><h>02:52</h><r>steveb8n</r><a href="https://github.com/metosin/malli/pull/215" target="_blank">https://github.com/metosin/malli/pull/215</a></z><z id="t1594176809" t="steveb8n oops. broke the tests. fix coming"><y>#</y><d>2020-07-08</d><h>02:53</h><r>steveb8n</r>oops. broke the tests. fix coming</z><z id="t1594177584" t="steveb8n fixed!"><y>#</y><d>2020-07-08</d><h>03:06</h><r>steveb8n</r>fixed!</z><z id="t1594155781" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] just trying to update a value in path like [:user :address :street] , I recall it expected string paths and didn&apos;t support nesting. Might have been just user error."><y>#</y><d>2020-07-07</d><h>21:03</h><w>ikitommi</w><a>@steveb8n</a> just trying to update a value in path like <code>[:user :address :street]</code> , I recall it expected string paths and didn&apos;t support nesting. Might have been just user error.</z><z id="t1594171540" t="jkent [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] great suggestion. here’s a PR to add a default error message for enums: https://github.com/metosin/malli/pull/214/commits"><y>#</y><d>2020-07-08</d><h>01:25</h><w>jkent</w><a>@ikitommi</a> great suggestion. here’s a PR to add a default error message for enums: <a href="https://github.com/metosin/malli/pull/214/commits" target="_blank">https://github.com/metosin/malli/pull/214/commits</a></z><z id="t1594189092" t="ikitommi Merged both PRs, thanks!"><y>#</y><d>2020-07-08</d><h>06:18</h><w>ikitommi</w>Merged both PRs, thanks!</z><z id="t1594280203" t="ikitommi re-implemented the schema visitor using walker: m/accept is now a postwalk and and there is new m/find-first to do lazy scanning for schemas. Though of doing a prewalk too, but coudn’t find any valid use case for such and would be more complex for schema extenders to add support for it. Not sure how useful the m/find-first is and should merge this: https://github.com/metosin/malli/pull/216"><y>#</y><d>2020-07-09</d><h>07:36</h><w>ikitommi</w>re-implemented the schema visitor using walker: <code>m/accept</code> is now a postwalk and  and there is new <code>m/find-first</code> to do lazy scanning for schemas. Though of doing a prewalk too, but coudn’t find any valid use case for such and would be more complex for schema extenders to add support for it. Not sure how useful the <code>m/find-first</code> is and should merge this: <a href="https://github.com/metosin/malli/pull/216" target="_blank">https://github.com/metosin/malli/pull/216</a></z><z id="t1594280355" t="ikitommi should the m/accept be just m/walk in the future? or m/post-walk ?"><y>#</y><d>2020-07-09</d><h>07:39</h><w>ikitommi</w>should the <code>m/accept</code> be just <code>m/walk</code> in the future? or <code>m/post-walk</code>?</z><z id="t1594285505" t="ikitommi (deftest find-first-test (let [schema [:map [:x int?] [:y [:vector [:tuple [:maybe int?] [:or [:and {:salaisuus &quot;turvassa&quot;} boolean?] int?] [:schema {:salaisuus &quot;vaarassa&quot;} false?]]]] [:z [:string {:salaisuus &quot;piilossa&quot;}]]]] (let [walked-properties (atom [])] (is (= &quot;turvassa&quot; (m/find-first schema (fn [s _in _options] (some-&gt;&gt; s m/properties (swap! walked-properties conj)) (some-&gt; s m/properties :salaisuus))))) (is (= [{:salaisuus &quot;turvassa&quot;}] @walked-properties))) (let [walked-properties (atom [])] (is (= &quot;vaarassa&quot; (m/find-first schema (fn [s _in _options] (some-&gt;&gt; s m/properties (swap! walked-properties conj)) (some-&gt; s m/properties :salaisuus #{&quot;vaarassa&quot;}))))) (is (= [{:salaisuus &quot;turvassa&quot;} {:salaisuus &quot;vaarassa&quot;}] @walked-properties)))))"><y>#</y><d>2020-07-09</d><h>09:05</h><w>ikitommi</w><pre>(deftest find-first-test
  (let [schema [:map
                [:x int?]
                [:y [:vector [:tuple
                              [:maybe int?]
                              [:or [:and {:salaisuus &quot;turvassa&quot;} boolean?] int?]
                              [:schema {:salaisuus &quot;vaarassa&quot;} false?]]]]
                [:z [:string {:salaisuus &quot;piilossa&quot;}]]]]

    (let [walked-properties (atom [])]
      (is (= &quot;turvassa&quot; (m/find-first
                          schema
                          (fn [s _in _options]
                            (some-&gt;&gt; s m/properties (swap! walked-properties conj))
                            (some-&gt; s m/properties :salaisuus)))))
      (is (= [{:salaisuus &quot;turvassa&quot;}] @walked-properties)))

    (let [walked-properties (atom [])]
      (is (= &quot;vaarassa&quot; (m/find-first
                          schema
                          (fn [s _in _options]
                            (some-&gt;&gt; s m/properties (swap! walked-properties conj))
                            (some-&gt; s m/properties :salaisuus #{&quot;vaarassa&quot;})))))
      (is (= [{:salaisuus &quot;turvassa&quot;}
              {:salaisuus &quot;vaarassa&quot;}] @walked-properties)))))</pre></z><z id="t1594287924" t="alpox Hi all! Is there a possibility to merge definitions declaratively - for example in an edn definition given that the definitions to merge are defined in a registry?"><y>#</y><d>2020-07-09</d><h>09:45</h><w>alpox</w>Hi all! Is there a possibility to merge definitions declaratively - for example in an edn definition given that the definitions to merge are defined in a registry?</z><z id="t1594288097" t="alpox I see I can do [:and [:ref :test/object] [:ref :test/annotated] [:map ....]] but sadly this would test for all to be true rather than that later definitions override definitions from the former. Basically, I&apos;m asking if there is something like mu/merge in a declarative way"><y>#</y><d>2020-07-09</d><h>09:48</h><w>alpox</w>I see I can do
<pre>[:and
 [:ref :test/object]
 [:ref :test/annotated]
 [:map ....]]</pre>
but sadly this would test for all to be true rather than that later definitions override definitions from the former. Basically, I&apos;m asking if there is something like <code>mu/merge</code> in a declarative way</z><z id="t1594297412" t="ikitommi [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] nothing just now, but sounds like a good idea. Could you write an issue of that?"><y>#</y><d>2020-07-09</d><h>12:23</h><w>ikitommi</w><a>@alpox</a> nothing just now, but sounds like a good idea. Could you write an issue of that?</z><z id="t1594301957" t="alpox [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Done: https://github.com/metosin/malli/issues/217 thanks for the response!"><y>#</y><d>2020-07-09</d><h>13:39</h><w>alpox</w><a>@ikitommi</a> Done: <a href="https://github.com/metosin/malli/issues/217" target="_blank">https://github.com/metosin/malli/issues/217</a> thanks for the response!</z><z id="t1594305307" t="euccastro what&apos;s the idiomatic way to specify a nonempty string in a schema? should I actually use a custom registry as in the README?"><y>#</y><d>2020-07-09</d><h>14:35</h><w>euccastro</w>what&apos;s the idiomatic way to specify a nonempty string in a schema?  should I actually use a custom registry as in the README?</z><z id="t1594305583" t="euccastro currently I&apos;m doing this (def nonempty-string [:and string? [:fn {:error/message &quot;should be nonempty string&quot;} (fn [x] (pos? (count x)))]])"><y>#</y><d>2020-07-09</d><h>14:39</h><r>euccastro</r>currently I&apos;m doing this
<pre>(def nonempty-string
  [:and
   string?
   [:fn {:error/message &quot;should be nonempty string&quot;}
    (fn [x] (pos? (count x)))]])</pre></z><z id="t1594305725" t="euccastro one minor problem with that is that malli/explain gives me two error messages: &quot;should be string&quot; and &quot;should be nonempty string&quot;. I tried to set the :error/message in the :and instead to get only one error, but that didn&apos;t work"><y>#</y><d>2020-07-09</d><h>14:42</h><r>euccastro</r>one minor problem with that is that <code>malli/explain</code> gives me two error messages: &quot;should be string&quot; and &quot;should be nonempty string&quot;.  I tried to set the <code>:error/message</code> in the <code>:and</code> instead to get only one error, but that didn&apos;t work</z><z id="t1594305888" t="euccastro (I&apos;m using the malli version that reitit 0.5.2 requires, i.e. 0.0.1-20200525.162645-15, if that matters)"><y>#</y><d>2020-07-09</d><h>14:44</h><r>euccastro</r>(I&apos;m using the malli version that reitit 0.5.2 requires, i.e. 0.0.1-20200525.162645-15, if that matters)</z></g><g id="s5"><z id="t1594305949" t="euccastro I&apos;m happy to upgrade to any version that is compatible with reitit 0.5.2"><y>#</y><d>2020-07-09</d><h>14:45</h><r>euccastro</r>I&apos;m happy to upgrade to any version that is compatible with reitit 0.5.2</z><z id="t1594306692" t="ikitommi [:attrs {:href &quot;/_/_/users/U65FN6WL9&quot;}] [:string {:min 1}] , will need to release new version to work with reitit"><y>#</y><d>2020-07-09</d><h>14:58</h><r>ikitommi</r><a>@U65FN6WL9</a> <code>[:string {:min 1}]</code>, will need to release new version to work with reitit</z><z id="t1594307754" t="euccastro thank you!"><y>#</y><d>2020-07-09</d><h>15:15</h><r>euccastro</r>thank you!</z><z id="t1594308190" t="jkent [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] is there any chance you can release a new version of reitit with the latest malli ?"><y>#</y><d>2020-07-09</d><h>15:23</h><w>jkent</w><a>@ikitommi</a> is there any chance you can release a new version of <code>reitit</code> with the latest <code>malli</code>?</z><z id="t1594315450" t="euccastro another option for early adopters would be to release cutting-edge versions of malli under a separate namespace and artifact id (e.g., malli.pre-alpha ) so we can use that for our own code without fear of breaking reitit. that would also reduce the pressure to update reitit unless new malli functionality is actually needed there"><y>#</y><d>2020-07-09</d><h>17:24</h><w>euccastro</w>another option for early adopters would be to release cutting-edge versions of malli under a separate namespace and artifact id (e.g., <code>malli.pre-alpha</code>) so we can use that for our own code without fear of breaking reitit.  that would also reduce the pressure to update reitit unless new malli functionality is actually needed there</z><z id="t1594315477" t="euccastro please ignore this if it sounds like too much of a hassle 🙂"><y>#</y><d>2020-07-09</d><h>17:24</h><r>euccastro</r>please ignore this if it sounds like too much of a hassle <b>🙂</b></z><z id="t1594362121" t="ikitommi Morning. Pushed out new immutable &amp; compatible versions into clojars, ping [:attrs {:href &quot;/_/_/users/U65FN6WL9&quot;}] [:attrs {:href &quot;/_/_/users/U011CL58Q4W&quot;}] [metosin/malli &quot;0.0.1-20200709.163702-18&quot;] [metosin/reitit &quot;0.5.3&quot;]"><y>#</y><d>2020-07-10</d><h>06:22</h><w>ikitommi</w>Morning. Pushed out new immutable &amp; compatible versions into clojars, ping <a>@euccastro</a> <a>@jkent</a>
<pre>[metosin/malli &quot;0.0.1-20200709.163702-18&quot;]
[metosin/reitit &quot;0.5.3&quot;]</pre></z><z id="t1594367835" t="ikitommi merged the Walker PR into master, here’s the BREAKING: * 10.7.2020 * `[metosin/malli &quot;0.0.1-20200710.075225-19&quot;]` * **BREAKING:**: Visitor is implemented using a Walker. * `m/accept` -&gt; `m/walk` * `m/schema-visitor` -&gt; `m/schema-walker` * `m/map-syntax-visitor` -&gt; `m/map-syntax-walker `"><y>#</y><d>2020-07-10</d><h>07:57</h><w>ikitommi</w>merged the Walker PR into master, here’s the BREAKING:
<pre>* 10.7.2020
  * `[metosin/malli &quot;0.0.1-20200710.075225-19&quot;]`
  * **BREAKING:**: Visitor is implemented using a Walker.
    * `m/accept` -&gt; `m/walk`
    * `m/schema-visitor` -&gt; `m/schema-walker`
    * `m/map-syntax-visitor` -&gt; `m/map-syntax-walker</pre>`</z><z id="t1594540734" t="ikitommi About to replace MermaidJS with DOT, because it just works: https://github.com/metosin/malli/pull/219"><y>#</y><d>2020-07-12</d><h>07:58</h><w>ikitommi</w>About to replace MermaidJS with DOT, because it just works: <a href="https://github.com/metosin/malli/pull/219" target="_blank">https://github.com/metosin/malli/pull/219</a></z><z id="t1594540785" t="ikitommi the whole transformer is 69 loc, with most code reusable and could be part of malli.util (collecting and resolving references)."><y>#</y><d>2020-07-12</d><h>07:59</h><w>ikitommi</w>the whole transformer is 69 loc, with most code reusable and could be part of <code>malli.util</code> (collecting and resolving references).</z><z id="t1594540835" t="ikitommi the actual DOT-transformer is ~30 loc 🙂"><y>#</y><d>2020-07-12</d><h>08:00</h><w>ikitommi</w>the actual DOT-transformer is ~30 loc <b>🙂</b></z><z id="t1594546376" t="shmuel buchnik Hi I am new to malli Can I use multi with recursive ? I tried this and it does not work (def map-multi-recursive [:map {:registry {::filter [:multi {:dispatch :type} [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]] [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map [:dimensions dimension] [:values [:vector string?]]]]]]]}} :filter ::filter]) "><y>#</y><d>2020-07-12</d><h>09:32</h><w>shmuel buchnik</w>Hi I am new to malli
Can I use multi with recursive ?
I tried this and it does not work
<pre>(def map-multi-recursive
  [:map
   {:registry
    {::filter
     [:multi
      {:dispatch :type}
      [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:vector [:ref ::filter]]]]]
      [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]]
      [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]]
      [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map
                                             [:dimensions dimension]
                                             [:values [:vector string?]]]]]]]}}
   :filter ::filter])</pre>
</z><z id="t1594548361" t="ikitommi [:attrs {:href &quot;/_/_/users/U014XRLPSER&quot;}] I believe the map entry should be [:filter ::filter] , e.g. surround with brackets"><y>#</y><d>2020-07-12</d><h>10:06</h><w>ikitommi</w><a>@shmuel.buchnic</a> I believe the map entry should be <code>[:filter ::filter]</code>, e.g. surround with brackets</z><z id="t1594548418" t="ikitommi recursion is a generic solution, unless there are bugs, it works with all Schemas"><y>#</y><d>2020-07-12</d><h>10:06</h><w>ikitommi</w>recursion is a generic solution, unless there are bugs, it works with all Schemas</z><z id="t1594551662" t="shmuel buchnik [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks for the fast response I tried and it still return an invalid schema . I will try to narrow down the issue ."><y>#</y><d>2020-07-12</d><h>11:01</h><r>shmuel buchnik</r><a>@U055NJ5CC</a> thanks for the fast response I tried and it still return an invalid schema .
I will try to narrow down the issue .</z><z id="t1594558760" t="shmuel buchnik [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] well it is working with simple validate , but trying to use it as :coercion to body parameters and it fails ."><y>#</y><d>2020-07-12</d><h>12:59</h><r>shmuel buchnik</r><a>@U055NJ5CC</a> well it is working with simple validate , but trying to use it as
:coercion to body parameters and it fails .</z><z id="t1594558858" t="ikitommi you seem to have two &quot;in&quot; branches in multi."><y>#</y><d>2020-07-12</d><h>13:00</h><r>ikitommi</r>you seem to have two <code>&quot;in&quot;</code> branches in multi.</z><z id="t1594558898" t="ikitommi will fail-fast in master: https://github.com/metosin/malli/commit/5d54e6b285c3ce440f1310302bdc2ba20a84d508"><y>#</y><d>2020-07-12</d><h>13:01</h><r>ikitommi</r>will fail-fast in master: <a href="https://github.com/metosin/malli/commit/5d54e6b285c3ce440f1310302bdc2ba20a84d508" target="_blank">https://github.com/metosin/malli/commit/5d54e6b285c3ce440f1310302bdc2ba20a84d508</a></z><z id="t1594558916" t="ikitommi (m/schema [:map {:registry {::filter [:multi {:dispatch :type} [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]] [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map [:dimensions [:tuple int? int?]] [:values [:vector string?]]]]]]]}} [:filter ::filter]]) ; =&gt; Throws :malli.core/non-distinct-entry-keys {:keys (&quot;in&quot; &quot;or&quot; &quot;not&quot; &quot;in&quot;)}"><y>#</y><d>2020-07-12</d><h>13:01</h><r>ikitommi</r><pre>(m/schema
  [:map
   {:registry
    {::filter
     [:multi
      {:dispatch :type}
      [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:vector [:ref ::filter]]]]]
      [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]]
      [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]]
      [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map
                                             [:dimensions [:tuple int? int?]]
                                             [:values [:vector string?]]]]]]]}}
   [:filter ::filter]])
; =&gt; Throws :malli.core/non-distinct-entry-keys {:keys (&quot;in&quot; &quot;or&quot; &quot;not&quot; &quot;in&quot;)}</pre></z><z id="t1594558943" t="shmuel buchnik I fixed that the updated looks like this : (def filter-local-registry {:registry {::filter [:multi {:dispatch :type} [&quot;and&quot; [:map [:type [:= &quot;and&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]] [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]] [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map [:dimension dimension] [:values [:vector string?]]]]]]]}}) "><y>#</y><d>2020-07-12</d><h>13:02</h><r>shmuel buchnik</r>I fixed that the updated looks like this :
<pre>(def filter-local-registry
  {:registry
   {::filter
    [:multi
     {:dispatch :type}
     [&quot;and&quot; [:map [:type [:= &quot;and&quot;]] [:value [:vector [:ref ::filter]]]]]
     [&quot;or&quot; [:map [:type [:= &quot;or&quot;]] [:value [:vector [:ref ::filter]]]]]
     [&quot;not&quot; [:map [:type [:= &quot;not&quot;]] [:value [:ref ::filter]]]]
     [&quot;in&quot; [:map [:type [:= &quot;in&quot;]] [:value [:map
                                            [:dimension dimension]
                                            [:values [:vector string?]]]]]]]}})</pre>
</z><z id="t1594558959" t="ikitommi works now?"><y>#</y><d>2020-07-12</d><h>13:02</h><r>ikitommi</r>works now?</z><z id="t1594559006" t="shmuel buchnik no 😞 I fixed it before u wrote forgot to update. validate call is working"><y>#</y><d>2020-07-12</d><h>13:03</h><r>shmuel buchnik</r>no <b>😞</b> I fixed it before u wrote forgot to update.
validate call is working</z><z id="t1594559033" t="shmuel buchnik but as :coercion it does not work"><y>#</y><d>2020-07-12</d><h>13:03</h><r>shmuel buchnik</r>but as :coercion it does not work</z><z id="t1594562738" t="ikitommi what version are you using of reitit?"><y>#</y><d>2020-07-12</d><h>14:05</h><r>ikitommi</r>what version are you using of reitit?</z><z id="t1594562838" t="shmuel buchnik 0.5.3 I debug it . It looks like at first he find filter in registry (holds 2 the default one and the local) But on later call I only see the default on the registry and than lookup fail ."><y>#</y><d>2020-07-12</d><h>14:07</h><r>shmuel buchnik</r>0.5.3 I debug it .
It looks like at first he find filter in registry (holds 2 the default one and the local)
But on later call I only see the default on the registry and than lookup fail .</z><z id="t1594570722" t="shmuel buchnik Narrowing issue : This is the schema (def sample-request [:map {:registry {::age [:and int? [:&gt; 18]]}} [:age ::age]]) This is the route (def overview [&quot;/api/v1/overview&quot; {:swagger {:tags [&quot;Overview&quot;]} :post {:summary &quot;get an overview data&quot; :parameters {:body sample-request} :handler get-overview-data }}]) The handler and other are just like in : https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj So it is not related to recursive or mutli I guess it is just wrong usage of me with registry I just did not find out what it is 😞"><y>#</y><d>2020-07-12</d><h>16:18</h><r>shmuel buchnik</r>Narrowing issue :
This is the schema
<pre>(def sample-request
  [:map {:registry {::age [:and int? [:&gt; 18]]}}
   [:age ::age]])</pre>
This is the route

<pre>(def overview
  [&quot;/api/v1/overview&quot;
   {:swagger {:tags [&quot;Overview&quot;]}
    :post {:summary &quot;get an overview data&quot;
                   :parameters {:body sample-request}
                   :handler get-overview-data
                   }}])</pre>
The handler and other are just like in :
<a href="https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj" target="_blank">https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj</a>
So it is not related to recursive or mutli I guess it is just wrong usage of me with registry I just did not find out what it is <b>😞</b></z><z id="t1594578172" t="ikitommi I can reproduce this."><y>#</y><d>2020-07-12</d><h>18:22</h><r>ikitommi</r>I can reproduce this.</z><z id="t1594578183" t="ikitommi Will check this out"><y>#</y><d>2020-07-12</d><h>18:23</h><r>ikitommi</r>Will check this out</z><z id="t1594627832" t="ikitommi fixed in https://github.com/metosin/malli/commit/9f105a53e459f9b85bfbd5c07d747fbe5d5d6f65"><y>#</y><d>2020-07-13</d><h>08:10</h><r>ikitommi</r>fixed in <a href="https://github.com/metosin/malli/commit/9f105a53e459f9b85bfbd5c07d747fbe5d5d6f65" target="_blank">https://github.com/metosin/malli/commit/9f105a53e459f9b85bfbd5c07d747fbe5d5d6f65</a></z><z id="t1594627869" t="ikitommi pushed out [metosin/reitit &quot;0.5.4&quot;] with the fix in."><y>#</y><d>2020-07-13</d><h>08:11</h><r>ikitommi</r>pushed out <code>[metosin/reitit &quot;0.5.4&quot;]</code> with the fix in.</z><z id="t1594621399" t="steveb8n I enhanced the Malli/Fork integration demo to use idiomatic keyword maps in the re-frame app-db and string keyword for Fork forms. [:attrs {:href &quot;/_/_/users/UE35Y835W&quot;}]"><y>#</y><d>2020-07-13</d><h>06:23</h><w>steveb8n</w>I enhanced the Malli/Fork integration demo to use idiomatic keyword maps in the re-frame app-db and string keyword for Fork forms. <a>@lucio</a></z><z id="t1594621402" t="steveb8n https://stevebuik.github.io/fork-malli-ideas/#!/basics"><y>#</y><d>2020-07-13</d><h>06:23</h><w>steveb8n</w><a href="https://stevebuik.github.io/fork-malli-ideas/#!/basics" target="_blank">https://stevebuik.github.io/fork-malli-ideas/#!/basics</a></z><z id="t1594621425" t="steveb8n Malli transforms makes this easy to do"><y>#</y><d>2020-07-13</d><h>06:23</h><w>steveb8n</w>Malli transforms makes this easy to do</z><z id="t1594621463" t="steveb8n It has raised another question. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] when you have a chance, can you comment on the 2 questions?"><y>#</y><d>2020-07-13</d><h>06:24</h><w>steveb8n</w>It has raised another question. <a>@ikitommi</a> when you have a chance, can you comment on the 2 questions?</z><z id="t1594628260" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] sure: 1. m/explainer returns a optimized pure function for explaining, e.g: (m/explainer [:map [:x int?]]) 2. mt/transformer can be used to compose transformers, runs them in single sweep. Also, you could store the computed m/decoder : (m/decoder [:map [:x int?]] (mt/transformer (mt/key-transformer {:decode keyword}) (mt/string-transformer))) "><y>#</y><d>2020-07-13</d><h>08:17</h><w>ikitommi</w><a>@steveb8n</a> sure:

1. <code>m/explainer</code> returns a optimized pure function for explaining, e.g:
<pre>(m/explainer [:map [:x int?]])</pre>
2. <code>mt/transformer</code> can be used to compose transformers, runs them in single sweep. Also, you could store the computed <code>m/decoder</code> :
<pre>(m/decoder
  [:map [:x int?]]
  (mt/transformer (mt/key-transformer {:decode keyword}) (mt/string-transformer)))</pre>
</z><z id="t1594628363" t="steveb8n thanks. for #2 I tried the composition via mt/transformer but couldn’t get it to transform properly. I am adding complexity by using it with a “multi-schema”"><y>#</y><d>2020-07-13</d><h>08:19</h><w>steveb8n</w>thanks. for #2 I tried the composition via mt/transformer but couldn’t get it to transform properly. I am adding complexity by using it with a “multi-schema”</z><z id="t1594628364" t="ikitommi at best, the m/decoder (or m/encoder ) know there is nothing to do and return identity : (m/decoder [:map [:x int?]] (mt/transformer (mt/json-transformer) (mt/json-transformer) (mt/json-transformer) (mt/json-transformer))) ; =&gt; #object[clojure.core$identity]"><y>#</y><d>2020-07-13</d><h>08:19</h><w>ikitommi</w>at best, the <code>m/decoder</code> (or <code>m/encoder</code>) know there is nothing to do and return <code>identity</code>:
<pre>(m/decoder
  [:map [:x int?]]
  (mt/transformer
    (mt/json-transformer)
    (mt/json-transformer)
    (mt/json-transformer)
    (mt/json-transformer)))
; =&gt; #object[clojure.core$identity]</pre></z><z id="t1594628413" t="steveb8n not in the public repo, in my private app"><y>#</y><d>2020-07-13</d><h>08:20</h><w>steveb8n</w>not in the public repo, in my private app</z><z id="t1594628413" t="ikitommi If you have and example of multi-schema that doesn’t work, please share, I could take a look"><y>#</y><d>2020-07-13</d><h>08:20</h><w>ikitommi</w>If you have and example of multi-schema that doesn’t work, please share, I could take a look</z><z id="t1594628430" t="steveb8n thanks. will do."><y>#</y><d>2020-07-13</d><h>08:20</h><w>steveb8n</w>thanks. will do.</z><z id="t1594628442" t="steveb8n and I’ll try m/explainer as well 🙂"><y>#</y><d>2020-07-13</d><h>08:20</h><w>steveb8n</w>and I’ll try m/explainer as well <b>🙂</b></z><z id="t1594628529" t="ikitommi transformers are computed into interceptor chains, where the order matters."><y>#</y><d>2020-07-13</d><h>08:22</h><w>ikitommi</w>transformers are computed into interceptor chains, where the order matters.</z><z id="t1594628593" t="steveb8n I think that’s the right direction to solve it: ordering"><y>#</y><d>2020-07-13</d><h>08:23</h><w>steveb8n</w>I think that’s the right direction to solve it: ordering</z><z id="t1594628614" t="steveb8n but I’ll start with the simpler (public) example"><y>#</y><d>2020-07-13</d><h>08:23</h><w>steveb8n</w>but I’ll start with the simpler (public) example</z><z id="t1594628617" t="ikitommi also, as the transformers are mounted from root schema towards leafs, the :multi decoding is applied before it’s childs (as we don’t know which child is selected), so you might need to decode the :multi dispatch key manually."><y>#</y><d>2020-07-13</d><h>08:23</h><w>ikitommi</w>also, as the transformers are mounted from root schema towards leafs, the <code>:multi</code> decoding is applied before it’s childs (as we don’t know which child is selected), so you might need to decode the <code>:multi</code> dispatch key manually.</z><z id="t1594628647" t="ikitommi there is an example in the README: (m/decode [:multi {:dispatch :type :decode/string &apos;#(update % :type keyword)} [:sized [:map [:type [:= :sized] [:size int?]]] [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]] {:type &quot;human&quot; :name &quot;Tiina&quot; :age &quot;98&quot; :address {:country &quot;finland&quot; :street &quot;this is an extra key&quot;}} (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer)) ;{:type :human ; :name &quot;Tiina&quot; ; :address {:country :finland}}"><y>#</y><d>2020-07-13</d><h>08:24</h><w>ikitommi</w>there is an example in the README:
<pre>(m/decode
  [:multi {:dispatch :type
           :decode/string &apos;#(update % :type keyword)}
   [:sized [:map [:type [:= :sized] [:size int?]]]
   [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]]
  {:type &quot;human&quot;
   :name &quot;Tiina&quot;
   :age &quot;98&quot;
   :address {:country &quot;finland&quot;
             :street &quot;this is an extra key&quot;}}
  (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer))
;{:type :human
; :name &quot;Tiina&quot;
; :address {:country :finland}}</pre></z><z id="t1594628663" t="steveb8n yep: tried that too. failed. I’ll dig deeper"><y>#</y><d>2020-07-13</d><h>08:24</h><w>steveb8n</w>yep: tried that too. failed. I’ll dig deeper</z><z id="t1594628711" t="steveb8n I’ll get back to you. making this work makes the fork/malli integration nice and idiomatic on both sides"><y>#</y><d>2020-07-13</d><h>08:25</h><w>steveb8n</w>I’ll get back to you. making this work makes the fork/malli integration nice and idiomatic on both sides</z><z id="t1594628720" t="steveb8n so worth the effort from me"><y>#</y><d>2020-07-13</d><h>08:25</h><w>steveb8n</w>so worth the effort from me</z><z id="t1594628845" t="ikitommi oh, noticed you have the custom error message for :enum : {:error/message &quot;Must be London or Tampere&quot;} . Enums have something decend nowadays by default: https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L63-L66"><y>#</y><d>2020-07-13</d><h>08:27</h><w>ikitommi</w>oh, noticed you have the custom error message for <code>:enum</code>: <code>{:error/message &quot;Must be London or Tampere&quot;}</code>. Enums have something decend nowadays by default: <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L63-L66" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L63-L66</a></z><z id="t1594628871" t="ikitommi maybe that could be polished into having , &amp; or s by default?"><y>#</y><d>2020-07-13</d><h>08:27</h><w>ikitommi</w>maybe that could be polished into having <code>,</code> &amp; <code>or</code> s by default?</z><z id="t1594628917" t="steveb8n ok. I’ll try that too. and I’ll send a PR for the english grammar if required"><y>#</y><d>2020-07-13</d><h>08:28</h><w>steveb8n</w>ok. I’ll try that too. and I’ll send a PR for the english grammar if required</z><z id="t1594628939" t="steveb8n end of the day here (Sydney) so probably not till tomorrow"><y>#</y><d>2020-07-13</d><h>08:28</h><w>steveb8n</w>end of the day here (Sydney) so probably not till tomorrow</z><z id="t1594630305" t="ikitommi My guess is that you should have a new named transformer, something like: (mt/transformer {:name :before} (mt/key-transformer {:decode keyword}) (mt/string-transformer)) and in the :multi : [:multi {:dispatch :type :decode/before &apos;#(update % :type keyword)} ..."><y>#</y><d>2020-07-13</d><h>08:51</h><w>ikitommi</w>My guess is that you should have a new named transformer, something like:
<pre>(mt/transformer 
  {:name :before}
  (mt/key-transformer {:decode keyword}) 
  (mt/string-transformer))</pre>
and in the <code>:multi</code>:
<pre>[:multi {:dispatch :type
         :decode/before &apos;#(update % :type keyword)} ...</pre></z><z id="t1594630387" t="ikitommi this way, the :multi selects the branch correctly before anything else, and the key-transformer &amp; string-transformer both work correctly."><y>#</y><d>2020-07-13</d><h>08:53</h><w>ikitommi</w>this way, the  <code>:multi</code> selects the branch correctly before anything else, and the <code>key-transformer</code> &amp; <code>string-transformer</code> both work correctly.</z><z id="t1594682334" t="steveb8n ok. here’s a simple test case from the demo repo…."><y>#</y><d>2020-07-13</d><h>23:18</h><w>steveb8n</w>ok. here’s a simple test case from the demo repo….</z><z id="t1594682355" t="steveb8n (let [v {&quot;id&quot; &quot;123&quot; &quot;github-followers&quot; &quot;10&quot;} schema [:map [:id :string] [:github-followers pos-int?]]] (-&gt;&gt; (mt/transformer (mt/key-transformer {:decode keyword}) mt/string-transformer) (m/decode schema v) cljs.pprint/pprint)) why does the string transformer not work?"><y>#</y><d>2020-07-13</d><h>23:19</h><w>steveb8n</w><pre>(let [v {&quot;id&quot;               &quot;123&quot;
         &quot;github-followers&quot; &quot;10&quot;}
      schema [:map
              [:id :string]
              [:github-followers pos-int?]]]
  (-&gt;&gt; (mt/transformer (mt/key-transformer {:decode keyword})
                       mt/string-transformer)
       (m/decode schema v)
       cljs.pprint/pprint))</pre>
why does the string transformer not work?</z><z id="t1594715793" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] doesn’t work :thinking_face: . Will check it out."><y>#</y><d>2020-07-14</d><h>08:36</h><w>ikitommi</w><a>@steveb8n</a> doesn’t work <b>:thinking_face:</b>. Will check it out.</z><z id="t1594715825" t="ikitommi (for some reason, the keys are not followed AFTER converted to keywords."><y>#</y><d>2020-07-14</d><h>08:37</h><w>ikitommi</w>(for some reason, the keys are not followed AFTER converted to keywords.</z><z id="t1594715861" t="ikitommi oh, the key-transformer applies on :leave , which is after-the-fact."><y>#</y><d>2020-07-14</d><h>08:37</h><w>ikitommi</w>oh, the key-transformer applies on <code>:leave</code>, which is after-the-fact.</z><z id="t1594715965" t="ikitommi … should be on :enter on decode and on :leave on encode. Just a sec."><y>#</y><d>2020-07-14</d><h>08:39</h><w>ikitommi</w>… should be on <code>:enter</code> on decode and on <code>:leave</code> on encode. Just a sec.</z><z id="t1594717129" t="steveb8n no hurry. the workaround of doing 2 transforms is ok. but it will be good to see the transform composition handling this use case eventually"><y>#</y><d>2020-07-14</d><h>08:58</h><w>steveb8n</w>no hurry. the workaround of doing 2 transforms is ok. but it will be good to see the transform composition handling this use case eventually</z><z id="t1594717142" t="steveb8n even if that means dropping down to the interceptor level"><y>#</y><d>2020-07-14</d><h>08:59</h><w>steveb8n</w>even if that means dropping down to the interceptor level</z><z id="t1594717209" t="steveb8n btw: for fun I might run https://github.com/stevebuik/Stu on my project. it’ll show the extra 200k from sci very clearly"><y>#</y><d>2020-07-14</d><h>09:00</h><w>steveb8n</w>btw: for fun I might run <a href="https://github.com/stevebuik/Stu" target="_blank">https://github.com/stevebuik/Stu</a> on my project. it’ll show the extra 200k from sci very clearly</z><z id="t1594718075" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] fixed in master: https://github.com/metosin/malli/commit/679ca7780f2e36e427885e2343772369e048598e"><y>#</y><d>2020-07-14</d><h>09:14</h><w>ikitommi</w><a>@steveb8n</a> fixed in master: <a href="https://github.com/metosin/malli/commit/679ca7780f2e36e427885e2343772369e048598e" target="_blank">https://github.com/metosin/malli/commit/679ca7780f2e36e427885e2343772369e048598e</a></z><z id="t1594718103" t="steveb8n great! that was quick. I’ll update first thing tomorrow"><y>#</y><d>2020-07-14</d><h>09:15</h><w>steveb8n</w>great! that was quick. I’ll update first thing tomorrow</z><z id="t1594718179" t="steveb8n [:attrs {:href &quot;/_/_/users/UE35Y835W&quot;}] just added a feature to fork at about the same speed. you guys are awesome"><y>#</y><d>2020-07-14</d><h>09:16</h><w>steveb8n</w><a>@lucio</a> just added a feature to fork at about the same speed. you guys are awesome</z><z id="t1594718192" t="ikitommi didn’t know about Stu, looks nice"><y>#</y><d>2020-07-14</d><h>09:16</h><w>ikitommi</w>didn’t know about Stu, looks nice</z><z id="t1594718245" t="steveb8n it needs a couple of fixes to use properly. let me know if you want to use it. then I’ll go fix them"><y>#</y><d>2020-07-14</d><h>09:17</h><w>steveb8n</w>it needs a couple of fixes to use properly. let me know if you want to use it. then I’ll go fix them</z><z id="t1594720012" t="ikitommi [:attrs {:href &quot;/_/_/users/UUW2H9LG2&quot;}] related to you question on #reitit, would this help: (let [path-&gt;schema (atom {})] (mu/find-first [:and [:fn &apos;(constantly true)] [:map [:name string?] [:tags [:set [:map [:name string?]]]] [:address [:and [:fn &apos;(constantly true)] [:map [:street string?]] [:fn &apos;(constantly true)]]]] [:fn &apos;(constantly true)]] (fn [s i _] (swap! path-&gt;schema update i (fnil identity s)) nil)) @path-&gt;schema) ;{[] [:and ; [:fn (constantly true)] ; [:map ; [:name string?] ; [:tags [:set [:map [:name string?]]]] ; [:address [:and [:fn (constantly true)] [:map [:street string?]] [:fn (constantly true)]]]] ; [:fn (constantly true)]], ; [:name] string?, ; [:tags] [:set [:map [:name string?]]], ; [:tags :malli.core/in] [:map [:name string?]], ; [:tags :malli.core/in :name] string?, ; [:address] [:and [:fn (constantly true)] [:map [:street string?]] [:fn (constantly true)]], ; [:address :street] string?}"><y>#</y><d>2020-07-14</d><h>09:46</h><w>ikitommi</w><a>@shortlyportly</a> related to you question on #reitit, would this help:
<pre>(let [path-&gt;schema (atom {})]
  (mu/find-first
    [:and
     [:fn &apos;(constantly true)]
     [:map
      [:name string?]
      [:tags [:set [:map [:name string?]]]]
      [:address [:and
                 [:fn &apos;(constantly true)]
                 [:map [:street string?]]
                 [:fn &apos;(constantly true)]]]]
     [:fn &apos;(constantly true)]]
    (fn [s i _]
      (swap! path-&gt;schema update i (fnil identity s))
      nil))
  @path-&gt;schema)
;{[] [:and
;     [:fn (constantly true)]
;     [:map
;      [:name string?]
;      [:tags [:set [:map [:name string?]]]]
;      [:address [:and [:fn (constantly true)] [:map [:street string?]] [:fn (constantly true)]]]]
;     [:fn (constantly true)]],
; [:name] string?,
; [:tags] [:set [:map [:name string?]]],
; [:tags :malli.core/in] [:map [:name string?]],
; [:tags :malli.core/in :name] string?,
; [:address] [:and [:fn (constantly true)] [:map [:street string?]] [:fn (constantly true)]],
; [:address :street] string?}</pre></z><z id="t1594720052" t="ikitommi you would get the schemas per value path for standalone validation."><y>#</y><d>2020-07-14</d><h>09:47</h><w>ikitommi</w>you would get the schemas per value path for standalone validation.</z><z id="t1594744054" t="Dave Simmons Thanks again [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] - I&apos;ll take a look. Just wanted to say love your talks and the libraries metosin are putting out. many thanks."><y>#</y><d>2020-07-14</d><h>16:27</h><w>Dave Simmons</w>Thanks again <a>@ikitommi</a> - I&apos;ll take a look. Just wanted to say love your talks and the libraries metosin are putting out. many thanks.</z><z id="t1594799643" t="steveb8n [:attrs {:href &quot;/_/_/users/UE35Y835W&quot;}] [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I updated the demo app with the new composable transformers fix https://stevebuik.github.io/fork-malli-ideas/#!/basics"><y>#</y><d>2020-07-15</d><h>07:54</h><w>steveb8n</w><a>@lucio</a> <a>@ikitommi</a>  I updated the demo app with the new composable transformers fix <a href="https://stevebuik.github.io/fork-malli-ideas/#!/basics" target="_blank">https://stevebuik.github.io/fork-malli-ideas/#!/basics</a></z><z id="t1594799683" t="steveb8n so now we have an example of keyword maps, validated by Malli but also transformed to string keys for Fork inputs"><y>#</y><d>2020-07-15</d><h>07:54</h><w>steveb8n</w>so now we have an example of keyword maps, validated by Malli but also transformed to string keys for Fork inputs</z><z id="t1594799692" t="steveb8n works great!"><y>#</y><d>2020-07-15</d><h>07:54</h><w>steveb8n</w>works great!</z><z id="t1594800998" t="ikitommi added the path-&gt;schema as malli.util/path-schemas , I think that is useful in things like generating forms from malli Schemas: you get an ordered list of value paths and the corresponding subschemas: 1. you can validate whole schema on blur / submitting 2. you can push subschema validation to components, faster local validation on keypress works for all basic clojure data structures, also for nested sequences (via :malli.core/in marker in path)"><y>#</y><d>2020-07-15</d><h>08:16</h><w>ikitommi</w>added the path-&gt;schema as <code>malli.util/path-schemas</code>, I think that is useful in things like generating forms from malli Schemas: you get an ordered list of value paths and the corresponding subschemas:
1. you can validate whole schema on blur / submitting
2. you can push subschema validation to components, faster local validation on keypress
works for all basic clojure data structures, also for nested sequences (via <code>:malli.core/in</code> marker in path)</z><z id="t1594801070" t="ikitommi"><y>#</y><d>2020-07-15</d><h>08:17</h><w>ikitommi</w></z><z id="t1594848117" t="rutledgepaulv This sounds like it might help with something I&apos;ve been pondering while working on https://github.com/RutledgePaulV/ui-kit ! Still working out some of the state structure / data validation / conformance stuff before I go hard on nailing down all the component types"><y>#</y><d>2020-07-15</d><h>21:21</h><r>rutledgepaulv</r>This sounds like it might help with something I&apos;ve been pondering while working on <a href="https://github.com/RutledgePaulV/ui-kit" target="_blank">https://github.com/RutledgePaulV/ui-kit</a>! Still working out some of the state structure / data validation / conformance stuff before I go hard on nailing down all the component types</z><z id="t1594848146" t="rutledgepaulv Trying to do minimal redraws and making sense of reagent cursors + malli trees"><y>#</y><d>2020-07-15</d><h>21:22</h><r>rutledgepaulv</r>Trying to do minimal redraws and making sense of reagent cursors + malli trees</z><z id="t1594889744" t="ikitommi 👍"><y>#</y><d>2020-07-16</d><h>08:55</h><r>ikitommi</r><b>👍</b></z><z id="t1594801118" t="ikitommi e.g. just iterate the map entries and emit form components"><y>#</y><d>2020-07-15</d><h>08:18</h><w>ikitommi</w>e.g. just iterate the map entries and emit form components</z><z id="t1594801914" t="steveb8n that’s an interesting idea. this could also be used with Fork to generate forms. might have to try that 🙂"><y>#</y><d>2020-07-15</d><h>08:31</h><w>steveb8n</w>that’s an interesting idea. this could also be used with Fork to generate forms. might have to try that <b>🙂</b></z><z id="t1594801950" t="steveb8n how far we’ve come from multi-tenant validation!"><y>#</y><d>2020-07-15</d><h>08:32</h><w>steveb8n</w>how far we’ve come from multi-tenant validation!</z><z id="t1595058548" t="ikitommi final(?) cleanup for transformers: https://github.com/metosin/malli/pull/224"><y>#</y><d>2020-07-18</d><h>07:49</h><w>ikitommi</w>final(?) cleanup for transformers: <a href="https://github.com/metosin/malli/pull/224" target="_blank">https://github.com/metosin/malli/pull/224</a></z><z id="t1595058584" t="ikitommi big change is that collection transformers don&apos;t coerce their type if children don&apos;t need transformation . In practise: (m/decode [:vector keyword?] &apos;(&quot;abba&quot;) (mt/json-transformer)) ; =&gt; [:abba] (m/decode [:vector string?] &apos;(&quot;abba&quot;) (mt/json-transformer)) ; =&gt; (&quot;abba&quot;)"><y>#</y><d>2020-07-18</d><h>07:49</h><w>ikitommi</w>big change is that <code>collection transformers don&apos;t coerce their type if children don&apos;t need transformation</code>. In practise:
<pre>(m/decode [:vector keyword?] &apos;(&quot;abba&quot;) (mt/json-transformer))
; =&gt; [:abba]

(m/decode [:vector string?] &apos;(&quot;abba&quot;) (mt/json-transformer))
; =&gt; (&quot;abba&quot;)</pre></z><z id="t1595058648" t="ikitommi for string-transformer , works like before: (m/decode [:vector string?] &apos;(&quot;abba&quot;) (mt/string-transformer)) ; =&gt; [:abba]"><y>#</y><d>2020-07-18</d><h>07:50</h><w>ikitommi</w>for <code>string-transformer</code>, works like before:
<pre>(m/decode [:vector string?] &apos;(&quot;abba&quot;) (mt/string-transformer))
; =&gt; [:abba]</pre></z><z id="t1595058736" t="ikitommi =&gt; the transformer instances can decide how to transform the collections, with JSON, both Jsonista and Cheshire decode JSON arrays as vectors, so they don’t need any “just in case” transformations."><y>#</y><d>2020-07-18</d><h>07:52</h><w>ikitommi</w>=&gt; the transformer instances can decide how to transform the collections, with JSON, both Jsonista and Cheshire decode JSON arrays as vectors, so they don’t need any “just in case” transformations.</z><z id="t1595058799" t="ikitommi if you have a deep Malli Schema, which only has things that can be presented in JSON, the transformation engine return identity . Which is nice."><y>#</y><d>2020-07-18</d><h>07:53</h><w>ikitommi</w>if you have a deep Malli Schema, which only has things that can be presented in JSON, the transformation engine return <code>identity</code>.  Which is nice.</z><z id="t1595149706" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Hi. Is there any roadmap for the first release? (How many features/errors should be improved/fixed before release? )"><y>#</y><d>2020-07-19</d><h>09:08</h><w>mike_ananev</w><a>@ikitommi</a> Hi. Is there any roadmap for the first release? (How many features/errors should be improved/fixed before release? )</z><z id="t1595154855" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] just the https://github.com/metosin/malli/pull/212 I think. But it seems to be a rabbit hole, can’t do the error thing in it elegantly with the current api, need either to discover a simple resolution for it, to change the explain (internal) api or the LensSchema api."><y>#</y><d>2020-07-19</d><h>10:34</h><w>ikitommi</w><a>@mike1452</a> just the <a href="https://github.com/metosin/malli/pull/212" target="_blank">https://github.com/metosin/malli/pull/212</a> I think. But it seems to be a rabbit hole, can’t do the error thing in it elegantly with the current api, need either to discover a simple resolution for it, to change the explain (internal) api or the <code>LensSchema</code> api.</z><z id="t1595154957" t="ikitommi also, checked the regal-malli integration, and might do a quick re-pacakge of the protocols so that implementing a new schema instance doesn’t require requiring all malli namespaces."><y>#</y><d>2020-07-19</d><h>10:35</h><w>ikitommi</w>also, checked the regal-malli integration, and might do a quick re-pacakge of the protocols so that implementing a new schema instance doesn’t require requiring all malli namespaces.</z><z id="t1595155024" t="ikitommi all small things, the first release will be alpha with [:attrs nil] 80% stabile internal. try to get all the breaking things (for the better) before the release."><y>#</y><d>2020-07-19</d><h>10:37</h><w>ikitommi</w>all small things, the first release will be alpha with <del>98% stabile public api and </del>80% stabile internal. try to get all the breaking things (for the better) before the release.</z><z id="t1595159852" t="mike_ananev 👍"><y>#</y><d>2020-07-19</d><h>11:57</h><w>mike_ananev</w><b>👍</b></z><z id="t1595492563" t="ikitommi sci will be an optional dependency, why? • faster standalone usage for JVM (2.5sec -&gt; 0.5sec to load `malli.core`) • smaller js-bundles: 120kb -&gt; 7kb first cut: https://github.com/metosin/malli/pull/227"><y>#</y><d>2020-07-23</d><h>08:22</h><w>ikitommi</w>sci will be an optional dependency, why?
• faster standalone usage for JVM (2.5sec -&gt; 0.5sec to load `malli.core`)
• smaller js-bundles: 120kb -&gt; 7kb
first cut: <a href="https://github.com/metosin/malli/pull/227" target="_blank">https://github.com/metosin/malli/pull/227</a></z><z id="t1595493797" t="ikitommi to make the sci-integration explicit, might be a good idea to make the whole default options customizable, instead of just the default registry. would allow one to pass sci as the default :evaluator , one could pass in default custom localizations for error messages etc. Wrote an issue here: https://github.com/metosin/malli/issues/228"><y>#</y><d>2020-07-23</d><h>08:43</h><w>ikitommi</w>to make the sci-integration explicit, might be a good idea to make the whole default options customizable, instead of just the default registry. would allow one to pass sci as the default <code>:evaluator</code> ,  one could pass in default custom localizations for error messages etc. Wrote an issue here: <a href="https://github.com/metosin/malli/issues/228" target="_blank">https://github.com/metosin/malli/issues/228</a></z><z id="t1595493842" t="ikitommi comments welcome. it’s a rainy day, should have few hours later today to do that."><y>#</y><d>2020-07-23</d><h>08:44</h><w>ikitommi</w>comments welcome. it’s a rainy day, should have few hours later today to do that.</z><z id="t1595494560" t="plexus should a schema-schema&apos;s properties delegate to the referenced schema?"><y>#</y><d>2020-07-23</d><h>08:56</h><w>plexus</w>should a schema-schema&apos;s properties delegate to the referenced schema?</z><z id="t1595494580" t="plexus (schema/properties (malli.core/-deref (schema/schema :ars/address))) (schema/properties (schema/schema :ars/address))"><y>#</y><d>2020-07-23</d><h>08:56</h><w>plexus</w><pre>(schema/properties (malli.core/-deref (schema/schema :ars/address)))
  (schema/properties (schema/schema :ars/address))</pre></z><z id="t1595494616" t="plexus the first returns a properties map, the second returns nil. would be nice if it actually returned the properties of the child schema"><y>#</y><d>2020-07-23</d><h>08:56</h><w>plexus</w>the first returns a properties map, the second returns nil. would be nice if it actually returned the properties of the child schema</z><z id="t1595494681" t="plexus (I&apos;m upgrading our project to the latest Malli. Nice addition of RefSchema and schema-schema!)"><y>#</y><d>2020-07-23</d><h>08:58</h><w>plexus</w>(I&apos;m upgrading our project to the latest Malli. Nice addition of RefSchema and schema-schema!)</z><z id="t1595495854" t="plexus I guess the question is how transparent a RefSchema is expected to be. We had our implementation of a RefSchema before Malli added it, and in our case we tried to make it largely transparent, e.g. it implements MapSchema and LensSchema which delegate to the child schema. Was very convenient but maybe you prefer to be explicit and have (if (satisfies? RefSchema s) (-deref s) s) checks"><y>#</y><d>2020-07-23</d><h>09:17</h><w>plexus</w>I guess the question is how transparent a <code>RefSchema</code> is expected to be. We had our implementation of a <code>RefSchema</code> before Malli added it, and in our case we tried to make it largely transparent, e.g. it implements <code>MapSchema</code> and <code>LensSchema</code> which delegate to the child schema. Was very convenient but maybe you prefer to be explicit and have <code>(if (satisfies? RefSchema s) (-deref s) s)</code> checks</z><z id="t1595496050" t="ikitommi Good question. :schema can now have it&apos;s own properties: [::m/schema {:title &quot;foo&quot;} :ars/address]"><y>#</y><d>2020-07-23</d><h>09:20</h><w>ikitommi</w>Good question. <code>:schema</code> can now have it&apos;s own properties:

<code>[::m/schema {:title &quot;foo&quot;} :ars/address]</code></z><z id="t1595496167" t="ikitommi would help if there was distinction between properties and derived/accumulated properties"><y>#</y><d>2020-07-23</d><h>09:22</h><w>ikitommi</w>would help if there was distinction between properties and derived/accumulated properties</z><z id="t1595496295" t="ikitommi properties are used in transforming schemas, e.g. into map-format. If they are looked from child, the map-format would duplicate the properties into ::m/schema"><y>#</y><d>2020-07-23</d><h>09:24</h><w>ikitommi</w>properties are used in transforming schemas, e.g. into map-format. If they are looked from child, the   map-format would duplicate the properties into <code>::m/schema</code></z><z id="t1595496390" t="ikitommi a new Protocol / method would solve that, but not sure if that&apos;s the right fix"><y>#</y><d>2020-07-23</d><h>09:26</h><w>ikitommi</w>a new Protocol / method would solve that, but not sure if that&apos;s the right fix</z><z id="t1595497526" t="plexus makes sense to keep them separate if they have different uses, maybe some more helpers would already go a long way, there&apos;s no deref yet for instance, only -deref . A version of deref/resolve that checks for RefSchema and otherwise returns the schema directly would also be nice."><y>#</y><d>2020-07-23</d><h>09:45</h><w>plexus</w>makes sense to keep them separate if they have different uses, maybe some more helpers would already go a long way, there&apos;s no <code>deref</code> yet for instance, only <code>-deref</code>. A version of deref/resolve that checks for <code>RefSchema</code> and otherwise returns the schema directly would also be nice.</z><z id="t1595497593" t="plexus what about if you do an update-in , but one of the schemas on the path is not a map schema but a reference to a map schema? should that work? (we do stuff like that and it&apos;s quite handy :))"><y>#</y><d>2020-07-23</d><h>09:46</h><w>plexus</w>what about if you do an <code>update-in</code>, but one of the schemas on the path is not a map schema but a reference to a map schema? should that work? (we do stuff like that and it&apos;s quite handy :))</z><z id="t1595511185" t="ikitommi Merged the SCI Optional PR. From Changelog: * 23.7.2020 * **BREAKING:**: `sci` is not a default dependency. Enabling sci-support: * **Clojure**: add a dependency to `borkdude/sci` * **ClojureScript**: also require `sci.core` (directly or via `:preloads`)"><y>#</y><d>2020-07-23</d><h>13:33</h><w>ikitommi</w>Merged the SCI Optional PR. From Changelog:
<pre>* 23.7.2020
  * **BREAKING:**: `sci` is not a default dependency. Enabling sci-support:
    * **Clojure**: add a dependency to `borkdude/sci`
    * **ClojureScript**: also require `sci.core` (directly or via `:preloads`)</pre></z><z id="t1595511223" t="ikitommi before and after (a small sample app)"><y>#</y><d>2020-07-23</d><h>13:33</h><w>ikitommi</w>before and after (a small sample app)</z><z id="t1595511315" t="borkdude What is the total size of the app before and after, un-gzipped? What does optimized mean, Clojure advanced?"><y>#</y><d>2020-07-23</d><h>13:35</h><w>borkdude</w>What is the total size of the app before and after, un-gzipped? What does optimized mean, Clojure advanced?</z><z id="t1595511928" t="ikitommi here’s the javascript: ➜ malli git:(master) ✗ ls -lh app2-sci total 1536 -rw-r--r-- 1 tommi staff 8.8K Jul 23 16:43 app.js -rw-r--r-- 1 tommi staff 177K Jul 23 16:43 cljs.js -rw-r--r-- 1 tommi staff 16K Jul 23 16:43 malli.js -rw-r--r-- 1 tommi staff 2.0K Jul 23 16:43 manifest.edn -rw-r--r-- 1 tommi staff 556K Jul 23 16:43 sci.js ➜ malli git:(master) ✗ ls -lh app2 total 288 -rw-r--r-- 1 tommi staff 10K Jul 23 16:41 app.js -rw-r--r-- 1 tommi staff 102K Jul 23 16:41 cljs.js -rw-r--r-- 1 tommi staff 24K Jul 23 16:41 malli.js -rw-r--r-- 1 tommi staff 987B Jul 23 16:41 manifest.edn"><y>#</y><d>2020-07-23</d><h>13:45</h><w>ikitommi</w>here’s the javascript:
<pre>➜  malli git:(master) ✗ ls -lh app2-sci
total 1536
-rw-r--r--  1 tommi  staff   8.8K Jul 23 16:43 app.js
-rw-r--r--  1 tommi  staff   177K Jul 23 16:43 cljs.js
-rw-r--r--  1 tommi  staff    16K Jul 23 16:43 malli.js
-rw-r--r--  1 tommi  staff   2.0K Jul 23 16:43 manifest.edn
-rw-r--r--  1 tommi  staff   556K Jul 23 16:43 sci.js

➜  malli git:(master) ✗ ls -lh app2
total 288
-rw-r--r--  1 tommi  staff    10K Jul 23 16:41 app.js
-rw-r--r--  1 tommi  staff   102K Jul 23 16:41 cljs.js
-rw-r--r--  1 tommi  staff    24K Jul 23 16:41 malli.js
-rw-r--r--  1 tommi  staff   987B Jul 23 16:41 manifest.edn</pre></z><z id="t1595511967" t="ikitommi manually zipped: ➜ malli git:(master) ✗ ls -lh app2-sci total 344 -rw-r--r-- 1 tommi staff 2.3K Jul 23 16:43 app.js.gz -rw-r--r-- 1 tommi staff 35K Jul 23 16:43 cljs.js.gz -rw-r--r-- 1 tommi staff 4.7K Jul 23 16:43 malli.js.gz -rw-r--r-- 1 tommi staff 624B Jul 23 16:43 manifest.edn.gz -rw-r--r-- 1 tommi staff 119K Jul 23 16:43 sci.js.gz ➜ malli git:(master) ✗ ls -lh app2 total 80 -rw-r--r-- 1 tommi staff 3.0K Jul 23 16:41 app.js.gz -rw-r--r-- 1 tommi staff 22K Jul 23 16:41 cljs.js.gz -rw-r--r-- 1 tommi staff 6.5K Jul 23 16:41 malli.js.gz -rw-r--r-- 1 tommi staff 370B Jul 23 16:41 manifest.edn.gz"><y>#</y><d>2020-07-23</d><h>13:46</h><w>ikitommi</w>manually zipped:
<pre>➜  malli git:(master) ✗ ls -lh app2-sci
total 344
-rw-r--r--  1 tommi  staff   2.3K Jul 23 16:43 app.js.gz
-rw-r--r--  1 tommi  staff    35K Jul 23 16:43 cljs.js.gz
-rw-r--r--  1 tommi  staff   4.7K Jul 23 16:43 malli.js.gz
-rw-r--r--  1 tommi  staff   624B Jul 23 16:43 manifest.edn.gz
-rw-r--r--  1 tommi  staff   119K Jul 23 16:43 sci.js.gz

➜  malli git:(master) ✗ ls -lh app2
total 80
-rw-r--r--  1 tommi  staff   3.0K Jul 23 16:41 app.js.gz
-rw-r--r--  1 tommi  staff    22K Jul 23 16:41 cljs.js.gz
-rw-r--r--  1 tommi  staff   6.5K Jul 23 16:41 malli.js.gz
-rw-r--r--  1 tommi  staff   370B Jul 23 16:41 manifest.edn.gz</pre></z><z id="t1595512014" t="ikitommi the app itself is silly, bare-bones malli with few schemas: https://github.com/metosin/malli/blob/master/app/malli/app2.cljc"><y>#</y><d>2020-07-23</d><h>13:46</h><w>ikitommi</w>the app itself is silly, bare-bones malli with few schemas: <a href="https://github.com/metosin/malli/blob/master/app/malli/app2.cljc" target="_blank">https://github.com/metosin/malli/blob/master/app/malli/app2.cljc</a></z><z id="t1595512055" t="borkdude ok"><y>#</y><d>2020-07-23</d><h>13:47</h><w>borkdude</w>ok</z><z id="t1595512055" t="ikitommi shadow config: https://github.com/metosin/malli/blob/master/shadow-cljs.edn"><y>#</y><d>2020-07-23</d><h>13:47</h><w>ikitommi</w>shadow config: <a href="https://github.com/metosin/malli/blob/master/shadow-cljs.edn" target="_blank">https://github.com/metosin/malli/blob/master/shadow-cljs.edn</a></z><z id="t1595512085" t="borkdude modules are a bit confusing since one thing can get randomly moved from one module to another"><y>#</y><d>2020-07-23</d><h>13:48</h><w>borkdude</w>modules are a bit confusing since one thing can get randomly moved from one module to another</z><z id="t1595512112" t="borkdude but overall, this is a win for people who don&apos;t want to use sci"><y>#</y><d>2020-07-23</d><h>13:48</h><w>borkdude</w>but overall, this is a win for people who don&apos;t want to use sci</z><z id="t1595512342" t="ikitommi so total sizes: • js: 757,8kb -&gt; 136kb • gz: 161kb -&gt; 31,5kb , so 1/5 the size."><y>#</y><d>2020-07-23</d><h>13:52</h><w>ikitommi</w>so total sizes:
• js: 757,8kb -&gt; 136kb
• gz: 161kb -&gt; 31,5kb
, so 1/5 the size.</z><z id="t1595512474" t="ikitommi yup (javascript) is 223kB unpacked, so we can say malli can be small too. or batteries-included."><y>#</y><d>2020-07-23</d><h>13:54</h><w>ikitommi</w>yup (javascript) is 223kB unpacked, so we can say malli can be small too. or batteries-included.</z><z id="t1595512842" t="ikitommi anyone btw interested in writing a malli-&gt;typescript transformer? in a project with both, might be useful, most likely fun"><y>#</y><d>2020-07-23</d><h>14:00</h><w>ikitommi</w>anyone btw interested in writing a malli-&gt;typescript transformer? in a project with both, might be useful, most likely fun</z><z id="t1595512908" t="ikitommi with yup, you can say: type Person = yup.InferType&lt;typeof personSchema&gt;;"><y>#</y><d>2020-07-23</d><h>14:01</h><w>ikitommi</w>with yup, you can say:
<pre>type Person = yup.InferType&lt;typeof personSchema&gt;;</pre></z><z id="t1595512963" t="ikitommi I don’t think it would be much more work than the malli -&gt; JSON Schema."><y>#</y><d>2020-07-23</d><h>14:02</h><w>ikitommi</w>I don’t think it would be much more work than the malli -&gt; JSON Schema.</z><z id="t1595512976" t="ikitommi might be wrong 🙂"><y>#</y><d>2020-07-23</d><h>14:02</h><w>ikitommi</w>might be wrong <b>🙂</b></z><z id="t1595761311" t="mike_ananev Hi! How I can express if A is optional in schema and if A exists then B should present too?"><y>#</y><d>2020-07-26</d><h>11:01</h><w>mike_ananev</w>Hi! How I can express if A is optional in schema and if A exists then B should present too?</z><z id="t1595761376" t="borkdude probably using a predicate?"><y>#</y><d>2020-07-26</d><h>11:02</h><w>borkdude</w>probably using a predicate?</z><z id="t1595761717" t="mike_ananev I mean how to express it as spec (inside spec one value depends on another) ?"><y>#</y><d>2020-07-26</d><h>11:08</h><w>mike_ananev</w>I mean how to express it as spec (inside spec one value depends on another) ?</z><z id="t1595761934" t="mike_ananev { :java-src-folder &quot;test-projects/javac/src/java&quot; :javac-options [&quot;-target&quot; &quot;1.8&quot; &quot;-source&quot; &quot;1.8&quot; &quot;-Xlint:-options&quot;] } How to express as spec if :java-src-folder is present then :javac-options should be present?"><y>#</y><d>2020-07-26</d><h>11:12</h><w>mike_ananev</w><pre>{
 :java-src-folder             &quot;test-projects/javac/src/java&quot;
 :javac-options               [&quot;-target&quot; &quot;1.8&quot; &quot;-source&quot; &quot;1.8&quot; &quot;-Xlint:-options&quot;] }</pre>
How to express as spec  if :java-src-folder is present then :javac-options should be present?</z><z id="t1595764657" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] you can compose rules with :and , from README: `(-&gt; [:and [:map [:password string?] [:password2 string?]] [:fn {:error/message &quot;passwords don&apos;t match&quot; :error/path [:password2]} &apos;(fn [{:keys [password password2]}] (= password password2))]] (m/explain {:password &quot;secret&quot; :password2 &quot;faarao&quot;}) (me/humanize)) ; {:password2 [&quot;passwords don&apos;t match&quot;]}`"><y>#</y><d>2020-07-26</d><h>11:57</h><w>ikitommi</w><a>@mike1452</a> you can compose rules with <code>:and</code>, from README:

`(-&gt; [:and [:map
           [:password string?]
           [:password2 string?]]
     [:fn {:error/message &quot;passwords don&apos;t match&quot;
           :error/path [:password2]}
      &apos;(fn [{:keys [password password2]}]
         (= password password2))]]
    (m/explain {:password &quot;secret&quot;
                :password2 &quot;faarao&quot;})
    (me/humanize))
; {:password2 [&quot;passwords don&apos;t match&quot;]}`</z><z id="t1595764874" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks! 👍"><y>#</y><d>2020-07-26</d><h>12:01</h><w>mike_ananev</w><a>@ikitommi</a> Thanks! <b>👍</b></z><z id="t1595840694" t="steveb8n Q: I’m having trouble with Cursive and shadow compilation ever since I updated to the dynaload/sci update. anyone else seeing weird behaviour?"><y>#</y><d>2020-07-27</d><h>09:04</h><w>steveb8n</w>Q: I’m having trouble with Cursive and shadow compilation ever since I updated to the dynaload/sci update. anyone else seeing weird behaviour?</z><z id="t1595840806" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] do you have the sci.core preloaded?"><y>#</y><d>2020-07-27</d><h>09:06</h><w>ikitommi</w><a>@steveb8n</a> do you have the <code>sci.core</code> preloaded?</z><z id="t1595840821" t="borkdude Are you using sci?"><y>#</y><d>2020-07-27</d><h>09:07</h><w>borkdude</w>Are you using sci?</z><z id="t1595840823" t="steveb8n no but I don’t want sci in the build"><y>#</y><d>2020-07-27</d><h>09:07</h><w>steveb8n</w>no but I don’t want sci in the build</z><z id="t1595840829" t="steveb8n no, not using sci"><y>#</y><d>2020-07-27</d><h>09:07</h><w>steveb8n</w>no, not using sci</z><z id="t1595840843" t="borkdude Then you should not preload it and it should all work fine theoretically."><y>#</y><d>2020-07-27</d><h>09:07</h><w>borkdude</w>Then you should not preload it and it should all work fine theoretically.</z><z id="t1595840865" t="steveb8n I did previously but I don’t need it (yet) so would rather save the bundle output size"><y>#</y><d>2020-07-27</d><h>09:07</h><w>steveb8n</w>I did previously but I don’t need it (yet) so would rather save the bundle output size</z><z id="t1595840873" t="ikitommi what kind of errors do you get?"><y>#</y><d>2020-07-27</d><h>09:07</h><w>ikitommi</w>what kind of errors do you get?</z><z id="t1595840914" t="steveb8n ➜ client-editor git:(master) ✗ shadow-cljs -A:dev --verbose release frontend shadow-cljs - config: /Users/steve/Documents/dev-personal/nextdoc-cloud/client-editor/shadow-cljs.edn shadow-cljs - starting via “clojure” [:frontend] Compiling ... -&gt; build target: :browser stage: :configure &lt;- build target: :browser stage: :configure (6 ms) -&gt; Resolving Module: :main The required namespace “borkdude.dynaload-cljs” is not available, it was required by “malli/sci.cljc”. ➜ client-editor git:(master) ✗ clojure -Stree org.clojure/clojure 1.10.1 org.clojure/core.specs.alpha 0.2.44 org.clojure/spec.alpha 0.2.176 cljs-http/cljs-http 0.1.46 noencore/noencore 0.3.4 commons-codec/commons-codec 1.11 org.clojure/tools.namespace 0.2.11 org.clojure/core.async 0.4.474 org.clojure/tools.analyzer.jvm 0.7.0 org.clojure/tools.analyzer 0.6.9 org.clojure/core.memoize 0.5.9 org.clojure/core.cache 0.6.5 org.clojure/data.priority-map 0.0.7 org.ow2.asm/asm-all 4.2 com.lucasbradstreet/cljs-uuid-utils 1.0.2 riverford/compound 2020.01.09 appliedscience/js-interop 0.1.19 org.clojure/clojurescript 1.10.520 org.clojure/data.json 0.2.6 org.clojure/google-closure-library 0.0-20170809-b9c14c6b org.clojure/google-closure-library-third-party 0.0-20170809-b9c14c6b org.mozilla/rhino 1.7R5 com.google.javascript/closure-compiler-unshaded v20180805 com.google.jsinterop/jsinterop-annotations 1.0.0 com.google.javascript/closure-compiler-externs v20180805 com.google.guava/guava 25.1-jre com.google.errorprone/error_prone_annotations 2.1.3 org.codehaus.mojo/animal-sniffer-annotations 1.14 com.google.j2objc/j2objc-annotations 1.1 org.checkerframework/checker-qual 2.0.0 com.google.code.findbugs/jsr305 3.0.2 args4j/args4j 2.0.26 com.google.protobuf/protobuf-java 3.0.2 com.google.code.gson/gson 2.7 com.cognitect/transit-cljs 0.8.256 com.cognitect/transit-js 0.8.846 fork/fork https://github.com/luciodale/fork.git 25276c0 grafeo/grafeo 0.1.4 r0man/alumbra.printer 0.1.1 r0man/alumbra.js 0.1.0 clj-http/clj-http 3.9.1 org.apache.httpcomponents/httpasyncclient 4.1.3 org.apache.httpcomponents/httpcore-nio 4.4.6 slingshot/slingshot 0.12.2 commons-io/commons-io 2.6 org.apache.httpcomponents/httpcore 4.4.9 org.apache.httpcomponents/httpclient-cache 4.5.5 org.apache.httpcomponents/httpclient 4.5.5 commons-logging/commons-logging 1.2 potemkin/potemkin 0.4.5 clj-tuple/clj-tuple 0.2.2 org.apache.httpcomponents/httpmime 4.5.5 cheshire/cheshire 5.8.1 com.fasterxml.jackson.dataformat/jackson-dataformat-cbor 2.9.6 tigris/tigris 0.1.1 com.fasterxml.jackson.dataformat/jackson-dataformat-smile 2.9.6 re-frame/re-frame 0.10.6 org.clojure/tools.logging 0.3.1 net.cgrand/macrovich 0.2.0 reagent/reagent 0.7.0 cljsjs/react-dom 15.5.4-0 cljsjs/react 15.5.4-0 cljsjs/react-dom-server 15.5.4-0 cljsjs/create-react-class 15.5.3-0 cljc.java-time/cljc.java-time 0.1.11 cljs.java-time/cljs.java-time 0.1.16 henryw374/js-joda 1.12.0-1 metosin/malli https://github.com/metosin/malli.git 3a670d8 com.gfredericks/test.chuck 0.2.10 instaparse/instaparse 1.3.6 com.andrewmcveigh/cljs-time 0.5.1 borkdude/dynaload https://github.com/borkdude/dynaload.git 52f71bc borkdude/edamame 0.0.11-alpha.12 org.clojure/tools.reader 1.3.2 org.clojure/test.check 1.0.0 funcool/promesa 4.0.2 com.rpl/specter 1.1.3-SNAPSHOT riddley/riddley 0.1.12 metosin/reitit-frontend 0.2.9 metosin/reitit-core 0.2.9 meta-merge/meta-merge 1.0.0 metosin/reitit 0.2.9 metosin/reitit-middleware 0.2.9 metosin/muuntaja 0.6.1 com.cognitect/transit-clj 0.8.313 com.cognitect/transit-java 0.8.337 org.msgpack/msgpack 0.6.12 com.googlecode.json-simple/json-simple 1.1.1 org.javassist/javassist 3.18.1-GA javax.xml.bind/jaxb-api 2.3.0 lambdaisland/deep-diff 0.0-25 mvxcvi/puget 1.0.3 fipp/fipp 0.6.14 mvxcvi/arrangement 1.1.1 org.clojure/core.rrb-vector 0.0.13 tech.droit/clj-diff 1.0.0 metosin/reitit-swagger 0.2.9 metosin/reitit-ring 0.2.9 ring/ring-core 1.7.1 commons-fileupload/commons-fileupload 1.3.3 clj-time/clj-time 0.14.3 joda-time/joda-time 2.9.9 crypto-random/crypto-random 1.2.0 ring/ring-codec 1.1.1 crypto-equality/crypto-equality 1.0.0 metosin/reitit-schema 0.2.9 metosin/schema-tools 0.10.5 prismatic/schema 1.1.9 metosin/reitit-sieppari 0.2.9 metosin/sieppari 0.0.0-alpha6 metosin/reitit-http 0.2.9 metosin/reitit-spec 0.2.9 metosin/spec-tools 0.8.2 com.fasterxml.jackson.core/jackson-databind 2.9.7 com.fasterxml.jackson.core/jackson-core 2.9.7 com.fasterxml.jackson.core/jackson-annotations 2.9.0 metosin/reitit-swagger-ui 0.2.9 metosin/ring-swagger-ui 2.2.10 metosin/jsonista 0.2.2 org.ow2.asm/asm 5.1 virgil/virgil 0.1.6 com.fasterxml.jackson.datatype/jackson-datatype-jsr310 2.9.7 metosin/reitit-interceptors 0.2.9 camel-snake-kebab/camel-snake-kebab 0.4.0 ➜ client-editor git:(master) ✗"><y>#</y><d>2020-07-27</d><h>09:08</h><w>steveb8n</w>➜  client-editor git:(master) ✗ shadow-cljs -A:dev --verbose release frontend
shadow-cljs - config: /Users/steve/Documents/dev-personal/nextdoc-cloud/client-editor/shadow-cljs.edn
shadow-cljs - starting via “clojure”
[:frontend] Compiling ...
-&gt; build target: :browser stage: :configure
&lt;- build target: :browser stage: :configure (6 ms)
-&gt; Resolving Module: :main
The required namespace “borkdude.dynaload-cljs” is not available, it was required by “malli/sci.cljc”.

➜  client-editor git:(master) ✗ clojure -Stree
org.clojure/clojure 1.10.1
  org.clojure/core.specs.alpha 0.2.44
  org.clojure/spec.alpha 0.2.176
cljs-http/cljs-http 0.1.46
  noencore/noencore 0.3.4
    commons-codec/commons-codec 1.11
  org.clojure/tools.namespace 0.2.11
  org.clojure/core.async 0.4.474
    org.clojure/tools.analyzer.jvm 0.7.0
      org.clojure/tools.analyzer 0.6.9
      org.clojure/core.memoize 0.5.9
        org.clojure/core.cache 0.6.5
          org.clojure/data.priority-map 0.0.7
      org.ow2.asm/asm-all 4.2
com.lucasbradstreet/cljs-uuid-utils 1.0.2
riverford/compound 2020.01.09
appliedscience/js-interop 0.1.19
  org.clojure/clojurescript 1.10.520
    org.clojure/data.json 0.2.6
    org.clojure/google-closure-library 0.0-20170809-b9c14c6b
      org.clojure/google-closure-library-third-party 0.0-20170809-b9c14c6b
    org.mozilla/rhino 1.7R5
    com.google.javascript/closure-compiler-unshaded v20180805
      com.google.jsinterop/jsinterop-annotations 1.0.0
      com.google.javascript/closure-compiler-externs v20180805
      com.google.guava/guava 25.1-jre
        com.google.errorprone/error_prone_annotations 2.1.3
        org.codehaus.mojo/animal-sniffer-annotations 1.14
        com.google.j2objc/j2objc-annotations 1.1
        org.checkerframework/checker-qual 2.0.0
        com.google.code.findbugs/jsr305 3.0.2
      args4j/args4j 2.0.26
      com.google.protobuf/protobuf-java 3.0.2
      com.google.code.gson/gson 2.7
com.cognitect/transit-cljs 0.8.256
  com.cognitect/transit-js 0.8.846
fork/fork <a href="https://github.com/luciodale/fork.git" target="_blank">https://github.com/luciodale/fork.git</a> 25276c0
grafeo/grafeo 0.1.4
  r0man/alumbra.printer 0.1.1
  r0man/alumbra.js 0.1.0
  clj-http/clj-http 3.9.1
    org.apache.httpcomponents/httpasyncclient 4.1.3
      org.apache.httpcomponents/httpcore-nio 4.4.6
    slingshot/slingshot 0.12.2
    commons-io/commons-io 2.6
    org.apache.httpcomponents/httpcore 4.4.9
    org.apache.httpcomponents/httpclient-cache 4.5.5
    org.apache.httpcomponents/httpclient 4.5.5
      commons-logging/commons-logging 1.2
    potemkin/potemkin 0.4.5
      clj-tuple/clj-tuple 0.2.2
    org.apache.httpcomponents/httpmime 4.5.5
  cheshire/cheshire 5.8.1
    com.fasterxml.jackson.dataformat/jackson-dataformat-cbor 2.9.6
    tigris/tigris 0.1.1
    com.fasterxml.jackson.dataformat/jackson-dataformat-smile 2.9.6
re-frame/re-frame 0.10.6
  org.clojure/tools.logging 0.3.1
  net.cgrand/macrovich 0.2.0
reagent/reagent 0.7.0
  cljsjs/react-dom 15.5.4-0
    cljsjs/react 15.5.4-0
  cljsjs/react-dom-server 15.5.4-0
  cljsjs/create-react-class 15.5.3-0
cljc.java-time/cljc.java-time 0.1.11
  cljs.java-time/cljs.java-time 0.1.16
    henryw374/js-joda 1.12.0-1
metosin/malli <a href="https://github.com/metosin/malli.git" target="_blank">https://github.com/metosin/malli.git</a> 3a670d8
  com.gfredericks/test.chuck 0.2.10
    instaparse/instaparse 1.3.6
    com.andrewmcveigh/cljs-time 0.5.1
  borkdude/dynaload <a href="https://github.com/borkdude/dynaload.git" target="_blank">https://github.com/borkdude/dynaload.git</a> 52f71bc
  borkdude/edamame 0.0.11-alpha.12
    org.clojure/tools.reader 1.3.2
  org.clojure/test.check 1.0.0
funcool/promesa 4.0.2
com.rpl/specter 1.1.3-SNAPSHOT
  riddley/riddley 0.1.12
metosin/reitit-frontend 0.2.9
  metosin/reitit-core 0.2.9
    meta-merge/meta-merge 1.0.0
metosin/reitit 0.2.9
  metosin/reitit-middleware 0.2.9
    metosin/muuntaja 0.6.1
      com.cognitect/transit-clj 0.8.313
        com.cognitect/transit-java 0.8.337
          org.msgpack/msgpack 0.6.12
            com.googlecode.json-simple/json-simple 1.1.1
            org.javassist/javassist 3.18.1-GA
          javax.xml.bind/jaxb-api 2.3.0
    lambdaisland/deep-diff 0.0-25
      mvxcvi/puget 1.0.3
      fipp/fipp 0.6.14
      mvxcvi/arrangement 1.1.1
      org.clojure/core.rrb-vector 0.0.13
      tech.droit/clj-diff 1.0.0
  metosin/reitit-swagger 0.2.9
  metosin/reitit-ring 0.2.9
    ring/ring-core 1.7.1
      commons-fileupload/commons-fileupload 1.3.3
      clj-time/clj-time 0.14.3
        joda-time/joda-time 2.9.9
      crypto-random/crypto-random 1.2.0
      ring/ring-codec 1.1.1
      crypto-equality/crypto-equality 1.0.0
  metosin/reitit-schema 0.2.9
    metosin/schema-tools 0.10.5
      prismatic/schema 1.1.9
  metosin/reitit-sieppari 0.2.9
    metosin/sieppari 0.0.0-alpha6
  metosin/reitit-http 0.2.9
  metosin/reitit-spec 0.2.9
    metosin/spec-tools 0.8.2
      com.fasterxml.jackson.core/jackson-databind 2.9.7
        com.fasterxml.jackson.core/jackson-core 2.9.7
        com.fasterxml.jackson.core/jackson-annotations 2.9.0
  metosin/reitit-swagger-ui 0.2.9
    metosin/ring-swagger-ui 2.2.10
    metosin/jsonista 0.2.2
      org.ow2.asm/asm 5.1
      virgil/virgil 0.1.6
      com.fasterxml.jackson.datatype/jackson-datatype-jsr310 2.9.7
  metosin/reitit-interceptors 0.2.9
camel-snake-kebab/camel-snake-kebab 0.4.0
➜  client-editor git:(master) ✗</z><z id="t1595840959" t="steveb8n I can also make it fail by starting a clojure repl in the terminal and trying to require dynaload"><y>#</y><d>2020-07-27</d><h>09:09</h><w>steveb8n</w>I can also make it fail by starting a clojure repl in the terminal and trying to require dynaload</z><z id="t1595840995" t="borkdude maybe kill your ~/.gitlibs ?"><y>#</y><d>2020-07-27</d><h>09:09</h><w>borkdude</w>maybe kill your <code>~/.gitlibs</code> ?</z><z id="t1595841009" t="borkdude and clear out your .cpcache"><y>#</y><d>2020-07-27</d><h>09:10</h><w>borkdude</w>and clear out your <code>.cpcache</code></z><z id="t1595841015" t="borkdude and use -Sforce"><y>#</y><d>2020-07-27</d><h>09:10</h><w>borkdude</w>and use <code>-Sforce</code></z><z id="t1595841040" t="steveb8n Clojure 1.10.1or git:(master) ✗ clojure user=&gt; (require ’borkdude.dynaload-clj) Execution error (FileNotFoundException) at user/eval1 (REPL:1). Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name."><y>#</y><d>2020-07-27</d><h>09:10</h><w>steveb8n</w>Clojure 1.10.1or git:(master) ✗ clojure
user=&gt; (require ’borkdude.dynaload-clj)
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name.</z><z id="t1595841071" t="steveb8n I did try deleting it from gitlibs but I haven’t tried deleting the whole dir"><y>#</y><d>2020-07-27</d><h>09:11</h><w>steveb8n</w>I did try deleting it from gitlibs but I haven’t tried deleting the whole dir</z><z id="t1595841078" t="steveb8n have already deleted .cpcache"><y>#</y><d>2020-07-27</d><h>09:11</h><w>steveb8n</w>have already deleted .cpcache</z><z id="t1595841087" t="steveb8n trying -Sforce …."><y>#</y><d>2020-07-27</d><h>09:11</h><w>steveb8n</w>trying -Sforce ….</z><z id="t1595841125" t="steveb8n clojure -Sforce Clojure 1.10.1 user=&gt; (require ’borkdude.dynaload-clj) Execution error (FileNotFoundException) at user/eval1 (REPL:1). Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name."><y>#</y><d>2020-07-27</d><h>09:12</h><w>steveb8n</w>clojure -Sforce
Clojure 1.10.1
user=&gt; (require ’borkdude.dynaload-clj)
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name.</z><z id="t1595841143" t="borkdude [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] when you do clojure -Spath do you see borkdude/dynaload there?"><y>#</y><d>2020-07-27</d><h>09:12</h><w>borkdude</w><a>@steveb8n</a> when you do <code>clojure -Spath</code> do you see borkdude/dynaload there?</z><z id="t1595841161" t="steveb8n what’s even stranger is that it works in another project and in CI for this (problematic) project"><y>#</y><d>2020-07-27</d><h>09:12</h><w>steveb8n</w>what’s even stranger is that it works in another project and in CI for this (problematic) project</z><z id="t1595841200" t="borkdude maybe it&apos;s a shadow problem? can you try with vanilla CLJS?"><y>#</y><d>2020-07-27</d><h>09:13</h><w>borkdude</w>maybe it&apos;s a shadow problem? can you try with vanilla CLJS?</z><z id="t1595841216" t="steveb8n yes. with -Spath it is present"><y>#</y><d>2020-07-27</d><h>09:13</h><w>steveb8n</w>yes. with -Spath it is present</z><z id="t1595841233" t="borkdude oh you tried already with the JVM huh. that&apos;s strange"><y>#</y><d>2020-07-27</d><h>09:13</h><w>borkdude</w>oh you tried already with the JVM huh. that&apos;s strange</z><z id="t1595841238" t="steveb8n that’s why I also tested using the clj repl. to exclude shadow"><y>#</y><d>2020-07-27</d><h>09:13</h><w>steveb8n</w>that’s why I also tested using the clj repl. to exclude shadow</z><z id="t1595841272" t="steveb8n Cursive is also weird. it appears in the deps panel but not in “external libraries”"><y>#</y><d>2020-07-27</d><h>09:14</h><w>steveb8n</w>Cursive is also weird. it appears in the deps panel but not in “external libraries”</z><z id="t1595841286" t="ikitommi ➜ ~ clojure -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}&apos; Checking out: at 627b0f0592d129a317f8ccf3dff5296376948bf9 Clojure 1.10.1 user=&gt; (require &apos;borkdude.dynaload-clj) Syntax error (ClassNotFoundException) compiling at (REPL:1:1). &apos;borkdude.dynaload-clj"><y>#</y><d>2020-07-27</d><h>09:14</h><w>ikitommi</w><pre>➜  ~ clojure -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}&apos;
Checking out:  at 627b0f0592d129a317f8ccf3dff5296376948bf9
Clojure 1.10.1
user=&gt; (require &apos;borkdude.dynaload-clj)
Syntax error (ClassNotFoundException) compiling at (REPL:1:1).
&apos;borkdude.dynaload-clj</pre></z><z id="t1595841318" t="borkdude what SHA is malli using for dynaload? maybe it was a branch that got deleted?"><y>#</y><d>2020-07-27</d><h>09:15</h><w>borkdude</w>what SHA is malli using for dynaload? maybe it was a branch that got deleted?</z><z id="t1595841347" t="borkdude the latest SHA is 52f71bc2cb7389a932835fe02f185e3801f7e063"><y>#</y><d>2020-07-27</d><h>09:15</h><w>borkdude</w>the latest SHA is <code>52f71bc2cb7389a932835fe02f185e3801f7e063</code></z><z id="t1595841376" t="steveb8n malli is using 52…."><y>#</y><d>2020-07-27</d><h>09:16</h><w>steveb8n</w>malli is using 52….</z><z id="t1595841390" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] when I run that in my terminal, it works ok"><y>#</y><d>2020-07-27</d><h>09:16</h><w>steveb8n</w><a>@ikitommi</a> when I run that in my terminal, it works ok</z><z id="t1595841404" t="steveb8n sorry. wrong"><y>#</y><d>2020-07-27</d><h>09:16</h><w>steveb8n</w>sorry. wrong</z><z id="t1595841411" t="steveb8n repl starts but require fails"><y>#</y><d>2020-07-27</d><h>09:16</h><w>steveb8n</w>repl starts but require fails</z><z id="t1595841428" t="steveb8n if you try the same require with the 52… sha, does it work?"><y>#</y><d>2020-07-27</d><h>09:17</h><w>steveb8n</w>if you try the same require with the 52… sha, does it work?</z><z id="t1595841432" t="borkdude $ clojure -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}&apos; Cloning: Checking out: at 627b0f0592d129a317f8ccf3dff5296376948bf9 Cloning: Checking out: at 52f71bc2cb7389a932835fe02f185e3801f7e063 Clojure 1.10.1 user=&gt; (require &apos;borkdude.dynaload-clj) nil user=&gt;"><y>#</y><d>2020-07-27</d><h>09:17</h><w>borkdude</w><pre>$ clojure -Sdeps &apos;{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}&apos;
Cloning: 
Checking out:  at 627b0f0592d129a317f8ccf3dff5296376948bf9
Cloning: 
Checking out:  at 52f71bc2cb7389a932835fe02f185e3801f7e063
Clojure 1.10.1
user=&gt; (require &apos;borkdude.dynaload-clj)
nil
user=&gt;</pre></z><z id="t1595841438" t="borkdude works fine over here"><y>#</y><d>2020-07-27</d><h>09:17</h><w>borkdude</w>works fine over here</z><z id="t1595841478" t="borkdude doing this from a clean dir"><y>#</y><d>2020-07-27</d><h>09:17</h><w>borkdude</w>doing this from a clean dir</z><z id="t1595841528" t="steveb8n clojure -Sdeps ‘{:deps {metosin/malli {:git/url “ https://github.com/metosin/malli.git ” :sha “627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}’ Clojure 1.10.1 user=&gt; user=&gt; user=&gt; (require ’borkdude.dynaload-clj) Execution error (FileNotFoundException) at user/eval1 (REPL:1). Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name."><y>#</y><d>2020-07-27</d><h>09:18</h><w>steveb8n</w>clojure -Sdeps ‘{:deps {metosin/malli {:git/url “<a href="https://github.com/metosin/malli.git" target="_blank">https://github.com/metosin/malli.git</a>” :sha “627b0f0592d129a317f8ccf3dff5296376948bf9&quot;}}}’
Clojure 1.10.1
user=&gt;
user=&gt;
user=&gt; (require ’borkdude.dynaload-clj)
Execution error (FileNotFoundException) at user/eval1 (REPL:1).
Could not locate borkdude/dynaload_clj__init.class, borkdude/dynaload_clj.clj or borkdude/dynaload_clj.cljc on classpath. Please check that namespaces with dashes use underscores in the Clojure file name.</z><z id="t1595841543" t="steveb8n must be a deps boycott on Australia"><y>#</y><d>2020-07-27</d><h>09:19</h><w>steveb8n</w>must be a deps boycott on Australia</z><z id="t1595841563" t="ikitommi working here now too :thinking_face:"><y>#</y><d>2020-07-27</d><h>09:19</h><w>ikitommi</w>working here now too <b>:thinking_face:</b></z><z id="t1595841583" t="ikitommi checked out dynaload manually, started working after that."><y>#</y><d>2020-07-27</d><h>09:19</h><w>ikitommi</w>checked out dynaload manually, started working after that.</z><z id="t1595841594" t="borkdude maybe it&apos;s a deps.edn bug?"><y>#</y><d>2020-07-27</d><h>09:19</h><w>borkdude</w>maybe it&apos;s a deps.edn bug?</z><z id="t1595841598" t="steveb8n yeah I could try that"><y>#</y><d>2020-07-27</d><h>09:19</h><w>steveb8n</w>yeah I could try that</z><z id="t1595841605" t="steveb8n explicit checkout locally"><y>#</y><d>2020-07-27</d><h>09:20</h><w>steveb8n</w>explicit checkout locally</z><z id="t1595841611" t="borkdude $ clojure -Sdescribe {:version &quot;1.10.1.536&quot;"><y>#</y><d>2020-07-27</d><h>09:20</h><w>borkdude</w><pre>$ clojure -Sdescribe
{:version &quot;1.10.1.536&quot;</pre></z><z id="t1595841613" t="ikitommi borkdude/dynaload {:git/url &quot;&quot; :sha &quot;52f71bc2cb7389a932835fe02f185e3801f7e063&quot;}"><y>#</y><d>2020-07-27</d><h>09:20</h><w>ikitommi</w><pre>borkdude/dynaload {:git/url &quot;&quot;
                           :sha &quot;52f71bc2cb7389a932835fe02f185e3801f7e063&quot;}</pre></z><z id="t1595841668" t="steveb8n I’ve got 1.10.1.447"><y>#</y><d>2020-07-27</d><h>09:21</h><w>steveb8n</w>I’ve got 1.10.1.447</z><z id="t1595841692" t="steveb8n I’ve seen deps bugs before. I might try updating clojure cli"><y>#</y><d>2020-07-27</d><h>09:21</h><w>steveb8n</w>I’ve seen deps bugs before. I might try updating clojure cli</z><z id="t1595841733" t="borkdude I&apos;m willing to cut a .jar release later on, but since malli itself is still git only, I wasn&apos;t in a hurry"><y>#</y><d>2020-07-27</d><h>09:22</h><w>borkdude</w>I&apos;m willing to cut a .jar release later on, but since malli itself is still git only, I wasn&apos;t in a hurry</z><z id="t1595841948" t="steveb8n I tried adding an explicit dep on dynaload. same behaviour as with the transitive dep via malli"><y>#</y><d>2020-07-27</d><h>09:25</h><w>steveb8n</w>I tried adding an explicit dep on dynaload. same behaviour as with the transitive dep via malli</z><z id="t1595841965" t="steveb8n still waiting on brew upgrade 🙂"><y>#</y><d>2020-07-27</d><h>09:26</h><w>steveb8n</w>still waiting on brew upgrade <b>🙂</b></z><z id="t1595842119" t="steveb8n are either of you using Cursive? if so, do you see dynaload in the “External Libraries”?"><y>#</y><d>2020-07-27</d><h>09:28</h><w>steveb8n</w>are either of you using Cursive? if so, do you see dynaload in the “External Libraries”?</z><z id="t1595842256" t="steveb8n after the clojure deps upgrade, the require works in the terminal. 1 step forward!"><y>#</y><d>2020-07-27</d><h>09:30</h><w>steveb8n</w>after the clojure deps upgrade, the require works in the terminal. 1 step forward!</z><z id="t1595842339" t="steveb8n shadow compile from cli also now works. it is looking like a deps bug"><y>#</y><d>2020-07-27</d><h>09:32</h><w>steveb8n</w>shadow compile from cli also now works. it is looking like a deps bug</z><z id="t1595842349" t="steveb8n trying Cursive …."><y>#</y><d>2020-07-27</d><h>09:32</h><w>steveb8n</w>trying Cursive ….</z><z id="t1595842471" t="steveb8n cursive/shadow via repl still broken. I’ll keep digging…"><y>#</y><d>2020-07-27</d><h>09:34</h><w>steveb8n</w>cursive/shadow via repl still broken. I’ll keep digging…</z><z id="t1595842707" t="borkdude maybe cursive uses its own version of deps.edn or maybe tools.deps directly which may be behind"><y>#</y><d>2020-07-27</d><h>09:38</h><w>borkdude</w>maybe cursive uses its own version of deps.edn or maybe tools.deps directly which may be behind</z><z id="t1595842810" t="steveb8n that’s exactly what is was! I switched (in prefs) to using the CLI dep executable and now shadow works inside Cursive as well"><y>#</y><d>2020-07-27</d><h>09:40</h><w>steveb8n</w>that’s exactly what is was! I switched (in prefs) to using the CLI dep executable and now shadow works inside Cursive as well</z><z id="t1595842844" t="steveb8n I got bitten by a double-whammy: deps bug and Cursive config"><y>#</y><d>2020-07-27</d><h>09:40</h><w>steveb8n</w>I got bitten by a double-whammy: deps bug and Cursive config</z><z id="t1595842860" t="steveb8n thanks for the help team 🙏"><y>#</y><d>2020-07-27</d><h>09:41</h><w>steveb8n</w>thanks for the help team <b>🙏</b></z><z id="t1595843282" t="ikitommi what was the root cause for the bug? I’m using 1.10.1.536 and still saw it. A stale cache?"><y>#</y><d>2020-07-27</d><h>09:48</h><w>ikitommi</w>what was the root cause for the bug? I’m using 1.10.1.536 and still saw it. A stale cache?</z><z id="t1595843871" t="borkdude maybe in your case, an AOT-cache related bug?"><y>#</y><d>2020-07-27</d><h>09:57</h><w>borkdude</w>maybe in your case, an AOT-cache related bug?</z><z id="t1595843904" t="steveb8n not sure as I’ve blown away so much stuff now"><y>#</y><d>2020-07-27</d><h>09:58</h><w>steveb8n</w>not sure as I’ve blown away so much stuff now</z><z id="t1595843936" t="steveb8n I’m now on 1.10.1.561"><y>#</y><d>2020-07-27</d><h>09:58</h><w>steveb8n</w>I’m now on 1.10.1.561</z><z id="t1595843940" t="borkdude I mean in ikitommi&apos;s case, since he had a ClassNotFoundException"><y>#</y><d>2020-07-27</d><h>09:59</h><w>borkdude</w>I mean in ikitommi&apos;s case, since he had a ClassNotFoundException</z><z id="t1595843957" t="borkdude whereas steveb8n got a file not found related exception"><y>#</y><d>2020-07-27</d><h>09:59</h><w>borkdude</w>whereas steveb8n got a file not found related exception</z><z id="t1595844079" t="steveb8n my best guess is a bug in handling transitive deps via git deps"><y>#</y><d>2020-07-27</d><h>10:01</h><w>steveb8n</w>my best guess is a bug in handling transitive deps via git deps</z><z id="t1595844130" t="steveb8n btw: loving the reduction in bundle size. thanks both of you"><y>#</y><d>2020-07-27</d><h>10:02</h><w>steveb8n</w>btw: loving the reduction in bundle size. thanks both of you</z><z id="t1595844147" t="steveb8n although I then added vega lite and added another 200k"><y>#</y><d>2020-07-27</d><h>10:02</h><w>steveb8n</w>although I then added vega lite and added another 200k</z><z id="t1595933351" t="dharrigan Any thoughts on my PR? https://github.com/metosin/malli/pull/234 . It&apos;s a shorthand way of fixing the length of the string to be accepted 🙂"><y>#</y><d>2020-07-28</d><h>10:49</h><w>dharrigan</w>Any thoughts on my PR? <a href="https://github.com/metosin/malli/pull/234" target="_blank">https://github.com/metosin/malli/pull/234</a>. It&apos;s a shorthand way of fixing the length of the string to be accepted <b>🙂</b></z><z id="t1596026908" t="ikitommi [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] not fond of that. You can already say [:string {:min 4, :max 4}] , which is not that much longer than [:string {:length 4}] . And you can always uses aliases to save on typing: [:schema {:registry {::str4 [:string {:min 4, :max 4}]}} ::str4] or: (def string4 [:string {:min 4, :max 4}]) (m/validate string4 &quot;kikka&quot;) ; =&gt; false"><y>#</y><d>2020-07-29</d><h>12:48</h><w>ikitommi</w><a>@dharrigan</a> not fond of that. You can already say <code>[:string {:min 4, :max 4}]</code> , which is not that much longer than <code>[:string {:length 4}]</code>. And you can always uses aliases to save on typing:
<pre>[:schema 
 {:registry {::str4 [:string {:min 4, :max 4}]}} 
 ::str4]</pre>
or:
<pre>(def string4 [:string {:min 4, :max 4}])

(m/validate string4 &quot;kikka&quot;)
; =&gt; false</pre></z><z id="t1596026949" t="ikitommi there could be a pretty error formatter for that, e.g. (and min (= min max)) (str &quot;should be &quot; min &quot; characters&quot;)"><y>#</y><d>2020-07-29</d><h>12:49</h><w>ikitommi</w>there could be a pretty error formatter for that, e.g.
<pre>(and min (= min max)) (str &quot;should be &quot; min &quot; characters&quot;)</pre></z><z id="t1596026970" t="ikitommi =&gt; (-&gt; [:schema {:registry {::str4 [:string {:min 4, :max 4}]}} ::str4] (m/explain &quot;kikka&quot;) (me/humanize)) ; =&gt; [&quot;should be 4 characters&quot;]"><y>#</y><d>2020-07-29</d><h>12:49</h><w>ikitommi</w>=&gt;
<pre>(-&gt; [:schema {:registry {::str4 [:string {:min 4, :max 4}]}} ::str4]
    (m/explain &quot;kikka&quot;)
    (me/humanize))
; =&gt; [&quot;should be 4 characters&quot;]</pre></z><z id="t1596027644" t="ikitommi fixed that in master, thanks for giving it a though."><y>#</y><d>2020-07-29</d><h>13:00</h><w>ikitommi</w>fixed that in master, thanks for giving it a though.</z><z id="t1596027754" t="ikitommi JSON Schema also has only minLength &amp; maxLength."><y>#</y><d>2020-07-29</d><h>13:02</h><w>ikitommi</w>JSON Schema also has only minLength &amp; maxLength.</z><z id="t1596028188" t="ikitommi (def registry (reduce (fn [acc i] (assoc acc (str &quot;string&quot; i) [:string {:min i, :max i}])) {} (range 5))) registry ;{&quot;string0&quot; [:string {:min 0, :max 0}], ; &quot;string1&quot; [:string {:min 1, :max 1}], ; &quot;string2&quot; [:string {:min 2, :max 2}], ; &quot;string3&quot; [:string {:min 3, :max 3}], ; &quot;string4&quot; [:string {:min 4, :max 4}]} (-&gt; [:map {:registry registry} [:s1 &quot;string1&quot;] [:s2 &quot;string2&quot;] [:s3 &quot;string3&quot;]] (m/explain {:s1 &quot;hi&quot;, :s2 &quot;hi&quot;, :s3 &quot;hi&quot;}) (me/humanize)) ;{:s1 [&quot;should be 1 characters&quot;] ; :s3 [&quot;should be 3 characters&quot;]}"><y>#</y><d>2020-07-29</d><h>13:09</h><w>ikitommi</w><pre>(def registry
  (reduce
    (fn [acc i]
      (assoc acc (str &quot;string&quot; i) [:string {:min i, :max i}]))
    {}
    (range 5)))

registry
;{&quot;string0&quot; [:string {:min 0, :max 0}],
; &quot;string1&quot; [:string {:min 1, :max 1}],
; &quot;string2&quot; [:string {:min 2, :max 2}],
; &quot;string3&quot; [:string {:min 3, :max 3}],
; &quot;string4&quot; [:string {:min 4, :max 4}]}

(-&gt; [:map {:registry registry}
     [:s1 &quot;string1&quot;]
     [:s2 &quot;string2&quot;]
     [:s3 &quot;string3&quot;]]
    (m/explain {:s1 &quot;hi&quot;, :s2 &quot;hi&quot;, :s3 &quot;hi&quot;})
    (me/humanize))
;{:s1 [&quot;should be 1 characters&quot;]
; :s3 [&quot;should be 3 characters&quot;]}</pre></z><z id="t1596037304" t="ikitommi Is anyone leaning on the current format of :errors of m/explain ?"><y>#</y><d>2020-07-29</d><h>15:41</h><w>ikitommi</w>Is anyone leaning on the current format of <code>:errors</code> of <code>m/explain</code> ?</z><z id="t1596037403" t="ikitommi About to break the :path and :in so that :path is a valid pointer to mu/get-in ."><y>#</y><d>2020-07-29</d><h>15:43</h><w>ikitommi</w>About to break the <code>:path</code> and <code>:in</code> so that <code>:path</code> is a valid pointer to <code>mu/get-in</code>.</z><z id="t1596037454" t="ikitommi this gives symmetry, that should have been there since beginning."><y>#</y><d>2020-07-29</d><h>15:44</h><w>ikitommi</w>this gives symmetry, that should have been there since beginning.</z><z id="t1596038264" t="ikitommi the paths are so much better now 🙂 (m/explain [:multi {:dispatch :type} [:sized [:map [:type [:= :sized]] [:size [:maybe int?]]]] [:human [:map [:type [:= :human]] [:name string?] [:age int?] [:address [:maybe [:map [:country keyword?]]]]]]] {:type :human :name &quot;inkeri&quot; :age &quot;100&quot; :address {:country &quot;sweden&quot;}}) ;{:schema [:multi ; {:dispatch :type} ; [:sized [:map [:type [:= :sized]] [:size [:maybe int?]]]] ; [:human [:map [:type [:= :human]] [:name string?] [:age int?] [:address [:maybe [:map [:country keyword?]]]]]]], ; :value {:type :human, :name &quot;inkeri&quot;, :age &quot;100&quot;, :address {:country &quot;sweden&quot;}}, ; :errors (#Error{:path [:human :age] ; :in [:age] ; :schema int? ; :value &quot;100&quot;} ; #Error{:path [:human :address 0 :country] ; :in [:address :country] ; :schema keyword? ; :value &quot;sweden&quot;})}"><y>#</y><d>2020-07-29</d><h>15:57</h><w>ikitommi</w>the paths are so much better now <b>🙂</b>
<pre>(m/explain
  [:multi {:dispatch :type}
   [:sized [:map
            [:type [:= :sized]]
            [:size [:maybe int?]]]]
   [:human [:map
            [:type [:= :human]]
            [:name string?]
            [:age int?]
            [:address [:maybe [:map [:country keyword?]]]]]]]
  {:type :human
   :name &quot;inkeri&quot;
   :age &quot;100&quot;
   :address {:country &quot;sweden&quot;}})
;{:schema [:multi
;          {:dispatch :type}
;          [:sized [:map [:type [:= :sized]] [:size [:maybe int?]]]]
;          [:human [:map [:type [:= :human]] [:name string?] [:age int?] [:address [:maybe [:map [:country keyword?]]]]]]],
; :value {:type :human, :name &quot;inkeri&quot;, :age &quot;100&quot;, :address {:country &quot;sweden&quot;}},
; :errors (#Error{:path [:human :age]
;                 :in [:age]
;                 :schema int?
;                 :value &quot;100&quot;}
;           #Error{:path [:human :address 0 :country]
;                  :in [:address :country]
;                  :schema keyword?
;                  :value &quot;sweden&quot;})}</pre></z><z id="t1596038296" t="ikitommi (Schemas with named branches, e.g. :map and :multi use the name instead of vector index."><y>#</y><d>2020-07-29</d><h>15:58</h><w>ikitommi</w>(Schemas with named branches, e.g. <code>:map</code> and <code>:multi</code> use the name instead of vector index.</z><z id="t1596064341" t="danielglauser How can you validate a &quot;naked&quot; series of integers? Like 1,4,8,10"><y>#</y><d>2020-07-29</d><h>23:12</h><w>danielglauser</w>How can you validate a &quot;naked&quot; series of integers? Like <code>1,4,8,10</code></z><z id="t1596064390" t="danielglauser Not in a vector, they are coming in as a query parameter."><y>#</y><d>2020-07-29</d><h>23:13</h><w>danielglauser</w>Not in a vector, they are coming in as a query parameter.</z><z id="t1596092860" t="ikitommi as one string? Maybe something like: (m/decode [:vector {:decode/string (partial str/split &quot;,&quot;)} int?] &quot;1,2,4,8,10&quot; mt/string-transformer) not near a computer, so not 100% sure it works"><y>#</y><d>2020-07-30</d><h>07:07</h><w>ikitommi</w>as one string? Maybe something like:

<pre>(m/decode 
  [:vector {:decode/string (partial str/split &quot;,&quot;)} int?] 
  &quot;1,2,4,8,10&quot;
  mt/string-transformer)
</pre>
not near a computer, so not 100% sure it works</z><z id="t1596092917" t="ikitommi first splits the string, the decodes parts string-&gt;int"><y>#</y><d>2020-07-30</d><h>07:08</h><w>ikitommi</w>first splits the string, the decodes parts string-&gt;int</z><z id="t1596125239" t="danielglauser Thanks, I&apos;ll give that a try. I came up with this but your solution seems simpler: (defn ids? &quot;Takes in a string and returns true if that string is of the form 1,4,7,9 or a sequence (in the math sense) of positive integers.&quot; [data] (let [ids (-&gt; data (clojure.string/split #&quot;,&quot;) (as-&gt; ids (mapv #(Integer/parseInt %) ids)))] (every? pos? ids))) (def GetClassesQueryOptions [:map [:approved {:optional true} boolean?] [:instructors {:optional true} [:fn (fn [ids] (ids? ids))]] [:machine {:optional true} [:fn (fn [ids] (ids? ids))]] [:music {:optional true} [:fn (fn [ids] (ids? ids))]] [:bookmarked {:optional true} boolean?] [:minlength {:optional true} int?] [:maxlength {:optional true} pos?]])"><y>#</y><d>2020-07-30</d><h>16:07</h><w>danielglauser</w>Thanks, I&apos;ll give that a try. I came up with this but your solution seems simpler:
<pre>(defn ids?                                                                      
  &quot;Takes in a string and returns true if that string is of the form             
  1,4,7,9 or a sequence (in the math sense) of positive integers.&quot;              
  [data]                                                                        
  (let [ids (-&gt; data                                                            
                (clojure.string/split #&quot;,&quot;)                                     
                (as-&gt; ids (mapv #(Integer/parseInt %) ids)))]                   
    (every? pos? ids)))

(def GetClassesQueryOptions                                                     
  [:map                                                                        
   [:approved {:optional true} boolean?]                                        
   [:instructors {:optional true} [:fn (fn [ids] (ids? ids))]]                  
   [:machine {:optional true} [:fn (fn [ids] (ids? ids))]]                      
   [:music {:optional true} [:fn (fn [ids] (ids? ids))]]                        
   [:bookmarked {:optional true} boolean?]                                      
   [:minlength {:optional true} int?]                                           
   [:maxlength {:optional true} pos?]])</pre></z><z id="t1596129612" t="ikitommi It&apos;s good to keep decoding and validation in separate steps. [:attrs {:href &quot;/_/_/users/U064X3EF3&quot;}] has many times called the spec conform &quot;a meat grinder&quot;, as it bundles the two and runs the transformations every time."><y>#</y><d>2020-07-30</d><h>17:20</h><w>ikitommi</w>It&apos;s good to keep decoding and validation in separate steps. <a>@alexmiller</a> has many times called the spec conform &quot;a meat grinder&quot;, as it bundles the two and runs the transformations every time.</z><z id="t1596213178" t="ikitommi After #238, there will be two ways to program with schemas: via schema keys (`:in` in explain) and value keys (`:path`in explain). e.g. one can walk easily over parts of schemas that don’t effect the value paths: (def Schema (m/schema [:maybe [:and [:map [:id string?] [:tags [:set keyword?]] [:address [:and [:map [:street {:optional true} string?] [:lonlat {:optional true} [:tuple double? double?]]] [:fn &apos;(fn [{:keys [street lonlat]}] (or street lonlat))]]]] [:fn &apos;(fn [{:keys [id tags]}] (and id tags))]]])) (mu/get-in Schema [0 0 :address 0 :lonlat]) ; =&gt; [:tuple double? double?] (mu/get-in* Schema [:address :lonlat]) ; =&gt; [:tuple double? double?]"><y>#</y><d>2020-07-31</d><h>16:32</h><w>ikitommi</w>After #238, there will be two ways to program with schemas: via schema keys (`:in` in explain) and value keys (`:path`in explain). e.g. one can walk easily over parts of schemas that don’t effect the value paths:
<pre>(def Schema
  (m/schema
    [:maybe
     [:and
      [:map
       [:id string?]
       [:tags [:set keyword?]]
       [:address
        [:and
         [:map
          [:street {:optional true} string?]
          [:lonlat {:optional true} [:tuple double? double?]]]
         [:fn &apos;(fn [{:keys [street lonlat]}] (or street lonlat))]]]]
      [:fn &apos;(fn [{:keys [id tags]}] (and id tags))]]]))

(mu/get-in Schema [0 0 :address 0 :lonlat])
; =&gt; [:tuple double? double?]

(mu/get-in* Schema [:address :lonlat])
; =&gt; [:tuple double? double?]</pre></z><z id="t1596386338" t="ikitommi Oh my. Accumulating both :in and :path in explain errors seems redundant. If we know Schema and either of schema-path (`:path`) or a value-path (`:in`), we can calculate the other. Simplifies both -explain and the malli utils. Sweet."><y>#</y><d>2020-08-02</d><h>16:38</h><w>ikitommi</w>Oh my. Accumulating both <code>:in</code> and <code>:path</code> in explain errors seems redundant. If we know Schema and either of schema-path (`:path`) or a value-path (`:in`),  we can calculate the other. Simplifies both <code>-explain</code> and the malli utils. Sweet.</z><z id="t1596386361" t="ikitommi and the code is dead simple: (defn in-&gt;path [schema in] (loop [i 0, s schema, acc []] (or (and (&gt;= i (count in)) acc) (recur (inc i) (get s (in i)) (if-not (m/-key s) (conj acc (in i)) acc))))) (defn path-&gt;in [schema path] (loop [i 0, s schema, acc []] (or (and (&gt;= i (count path)) acc) (let [[i k] (if-let [k (m/-key s)] [i k] [(inc i) (path i)])] (recur i (get s k) (conj acc k))))))"><y>#</y><d>2020-08-02</d><h>16:39</h><w>ikitommi</w>and the code is dead simple:
<pre>(defn in-&gt;path [schema in]
  (loop [i 0, s schema, acc []]
    (or (and (&gt;= i (count in)) acc)
        (recur (inc i) (get s (in i)) (if-not (m/-key s) (conj acc (in i)) acc)))))

(defn path-&gt;in [schema path]
  (loop [i 0, s schema, acc []]
    (or (and (&gt;= i (count path)) acc)
        (let [[i k] (if-let [k (m/-key s)] [i k] [(inc i) (path i)])]
          (recur i (get s k) (conj acc k))))))</pre></z><z id="t1596386435" t="ikitommi (also, performant, as it’s only protocols and vector indexes)"><y>#</y><d>2020-08-02</d><h>16:40</h><w>ikitommi</w>(also, performant, as it’s only protocols and vector indexes)</z><z id="t1596395889" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Published dynaload to Clojars: https://clojars.org/borkdude/dynaload"><y>#</y><d>2020-08-02</d><h>19:18</h><w>borkdude</w><a>@ikitommi</a> Published dynaload to Clojars: <a href="https://clojars.org/borkdude/dynaload" target="_blank">https://clojars.org/borkdude/dynaload</a></z><z id="t1596441632" t="ikitommi thanks! Will update the deps"><y>#</y><d>2020-08-03</d><h>08:00</h><w>ikitommi</w>thanks! Will update the deps</z><z id="t1596540958" t="ikitommi merged #238 in master. The Breaking: • :path  in explain is re-implemented: map keys by value, others by child index • m/-walk  and `m/Walker` uses `:path`, not `:in` • m/-outer  has new parameter order: `walker schema path children options` • malli.util/path-schemas  replaced with `malli.util/subschemas` &amp; `malli.util/distict-by` • LensSchema  has a new `-keep` method • renamed some non-user apis in `malli.core` &amp; `malli.util` • moved map-syntax helpers from `malli.core` to `malli.util` • dynaload `com.gfredericks/test.chuck`"><y>#</y><d>2020-08-04</d><h>11:35</h><w>ikitommi</w>merged #238 in master. The Breaking:
• <code>:path</code> in explain is re-implemented: map keys by value, others by child index
• <code>m/-walk</code> and `m/Walker` uses `:path`, not `:in`
• <code>m/-outer</code> has new parameter order: `walker schema path children options`
• <code>malli.util/path-schemas</code> replaced with `malli.util/subschemas` &amp; `malli.util/distict-by`
• <code>LensSchema</code> has a new `-keep` method
• renamed some non-user apis in `malli.core` &amp; `malli.util`
• moved map-syntax helpers from `malli.core` to `malli.util`
• dynaload `com.gfredericks/test.chuck`</z><z id="t1596541088" t="ikitommi There are few more PRs to go, many half-way complete and should unroll after the 238. But, going back to work within few days, don’t know when will have time to finish all the things."><y>#</y><d>2020-08-04</d><h>11:38</h><w>ikitommi</w>There are few more PRs to go, many half-way complete and should unroll after the 238. But, going back to work within few days, don’t know when will have time to finish all the things.</z><z id="t1596541602" t="ikitommi Applied for Malli for the Clojurists Together aug-sep, but haven’t heard anything, so just:crossed_fingers:."><y>#</y><d>2020-08-04</d><h>11:46</h><w>ikitommi</w>Applied for Malli for the Clojurists Together aug-sep, but haven’t heard anything, so just:crossed_fingers:.</z><z id="t1596624653" t="ikitommi Comments on https://github.com/metosin/malli/pull/194 ? e.g. allowing spec2-like schema+select using just :map ."><y>#</y><d>2020-08-05</d><h>10:50</h><w>ikitommi</w>Comments on <a href="https://github.com/metosin/malli/pull/194" target="_blank">https://github.com/metosin/malli/pull/194</a>? e.g. allowing spec2-like schema+select using just <code>:map</code>.</z><z id="t1596624689" t="ikitommi"><y>#</y><d>2020-08-05</d><h>10:51</h><w>ikitommi</w></z><z id="t1596639027" t="teodorlu Hey! I just found :map-of through after some searching, first reading the Readme, then guessing its name after rechecking the documentation for Spec. Is there interest for a PR adding an example to the Readme?"><y>#</y><d>2020-08-05</d><h>14:50</h><w>teodorlu</w>Hey! I just found <code>:map-of</code> through after some searching, first reading the Readme, then guessing its name after rechecking the documentation for Spec. Is there interest for a PR adding an example to the Readme?</z><z id="t1596642971" t="ikitommi definetely! All doc improvements most welcome"><y>#</y><d>2020-08-05</d><h>15:56</h><r>ikitommi</r>definetely! All doc improvements most welcome</z><z id="t1596643026" t="ikitommi someone suggested setting up real docs too, under docs so that cljdoc would pick them up too"><y>#</y><d>2020-08-05</d><h>15:57</h><r>ikitommi</r>someone suggested setting up real docs too, under <code>docs</code> so that cljdoc would pick them up too</z><z id="t1596724768" t="ikitommi with current master:"><y>#</y><d>2020-08-06</d><h>14:39</h><w>ikitommi</w>with current master:</z><z id="t1596724770" t="ikitommi"><y>#</y><d>2020-08-06</d><h>14:39</h><w>ikitommi</w></z><z id="t1596790011" t="borkdude Hoe does one combine validate and transform? E.g. this doesn&apos;t crash: (prn (m/decode int? :foo mt/string-transformer)) I&apos;m not saying it should, just wondering how to do it. Not clear from the README"><y>#</y><d>2020-08-07</d><h>08:46</h><w>borkdude</w>Hoe does one combine validate and transform? E.g. this doesn&apos;t crash:
<pre>(prn (m/decode int? :foo mt/string-transformer))</pre>
I&apos;m not saying it should, just wondering how to do it. Not clear from the README</z><z id="t1596790090" t="borkdude Should I first call m/valid, if not valid, then m/explain and else m/decode, effectively traversing the structure twice?"><y>#</y><d>2020-08-07</d><h>08:48</h><w>borkdude</w>Should I first call m/valid, if not valid, then m/explain and else m/decode, effectively traversing the structure twice?</z><z id="t1596792111" t="ikitommi If you need decoding, the flow should be: 1. decode 2. validate 3. explain on error"><y>#</y><d>2020-08-07</d><h>09:21</h><w>ikitommi</w>If you need decoding, the flow should be:
1. decode
2. validate
3. explain on error</z><z id="t1596792125" t="ikitommi there is 2-3 walks in the error case."><y>#</y><d>2020-08-07</d><h>09:22</h><w>ikitommi</w>there is 2-3 walks in the error case.</z><z id="t1596792143" t="ikitommi for happy case, 1-2"><y>#</y><d>2020-08-07</d><h>09:22</h><w>ikitommi</w>for happy case, 1-2</z><z id="t1596792260" t="ikitommi having a seoarate optimized validate makes the happy case fast"><y>#</y><d>2020-08-07</d><h>09:24</h><w>ikitommi</w>having a seoarate optimized validate makes the happy case fast</z><z id="t1596792291" t="ikitommi the docs could have examples on this..."><y>#</y><d>2020-08-07</d><h>09:24</h><w>ikitommi</w>the docs could have examples on this...</z><z id="t1596792411" t="ikitommi the m/decoder doesn&apos;t have to walk the structure, it returns an function to transform just the parts that need to be decoded. In case there is nothing to do, it returns identity"><y>#</y><d>2020-08-07</d><h>09:26</h><w>ikitommi</w>the <code>m/decoder</code> doesn&apos;t have to walk the structure, it returns an function to transform just the parts that need to be decoded. In case there is nothing to do, it returns <code>identity</code></z><z id="t1596792908" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] The concrete example I was going to try: $ cat deps.edn {:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;2bd749f7148e28a379f1e628a32188e7f6cf0bc4&quot;} borkdude/edamame {:git/url &quot;&quot; :sha &quot;64c7eb43950eb500ba7429dded48257cd15355ae&quot;}}} $ cat src/edamalli/core.clj (ns edamalli.core (:require [edamame.core :as e] [malli.core :as m] [malli.transform :as mt])) (defrecord WrappedNum [obj loc]) (defn postprocess [{:keys [:obj :loc]}] (if (number? obj) (-&gt;WrappedNum obj loc) obj)) (defn -main [&amp; args] (prn (e/parse-string &quot;[:foo 42]&quot; {:postprocess postprocess})) ;; TODO: ;; - validate that the WrappedNum contains value &lt; 42 ;; - then transform it to only that number ;; - else raise error, printing the location metadata of that number ) $ clojure -m edamalli.core [:foo #edamalli.core.WrappedNum{:obj 42, :loc {:row 1, :col 7, :end-row 1, :end-col 9}}]"><y>#</y><d>2020-08-07</d><h>09:35</h><w>borkdude</w><a>@ikitommi</a> The concrete example I was going to try:
<pre>$ cat deps.edn
{:deps {metosin/malli {:git/url &quot;&quot; :sha &quot;2bd749f7148e28a379f1e628a32188e7f6cf0bc4&quot;}
        borkdude/edamame {:git/url &quot;&quot; :sha &quot;64c7eb43950eb500ba7429dded48257cd15355ae&quot;}}}</pre>
<pre>$ cat src/edamalli/core.clj
(ns edamalli.core
  (:require [edamame.core :as e]
            [malli.core :as m]
            [malli.transform  :as mt]))

(defrecord WrappedNum [obj loc])

(defn postprocess [{:keys [:obj :loc]}]
  (if (number? obj) (-&gt;WrappedNum obj loc) obj))

(defn -main [&amp; args]
  (prn (e/parse-string &quot;[:foo 42]&quot; {:postprocess postprocess}))
  ;; TODO:
  ;; - validate that the WrappedNum contains value &lt; 42
  ;; - then transform it to only that number
  ;; - else raise error, printing the location metadata of that number
  )</pre>
<pre>$ clojure -m edamalli.core
[:foo #edamalli.core.WrappedNum{:obj 42, :loc {:row 1, :col 7, :end-row 1, :end-col 9}}]</pre></z><z id="t1596798390" t="zclj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I am parsing a schema into a malli-schema. The original might contain recursive references to other &quot;entities&quot; in the schema. I do not know this up front. Are there any trade-offs in putting all my potential recursive entity references in a [:ref ], even if they turn out not to be?"><y>#</y><d>2020-08-07</d><h>11:06</h><w>zclj</w><a>@ikitommi</a> I am parsing a schema into a malli-schema. The original might contain recursive references to other &quot;entities&quot; in the schema. I do not know this up front. Are there any trade-offs in putting all my potential recursive entity references in a [:ref ], even if they turn out not to be?</z><z id="t1596800690" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] would [:foo 42] be transformed to [:foo 42] , as would [:foo :bar #{42}] to itself and {:a 41} would fail on the fact that there was a number that was not 42?"><y>#</y><d>2020-08-07</d><h>11:44</h><w>ikitommi</w><a>@borkdude</a> would <code>[:foo 42]</code> be transformed to <code>[:foo 42]</code> , as would <code>[:foo :bar #{42}]</code> to itself and <code>{:a 41}</code> would fail on the fact that there was a number that was not 42?</z><z id="t1596800718" t="ikitommi happy to help, sample inputs -&gt; outputs would help."><y>#</y><d>2020-08-07</d><h>11:45</h><w>ikitommi</w>happy to help, sample inputs -&gt; outputs would help.</z><z id="t1596800754" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] No, [:foo (WrappedNum. x y)] would be transformed to [:foo x] only if x &lt; 42, else error with explain using y"><y>#</y><d>2020-08-07</d><h>11:45</h><w>borkdude</w><a>@ikitommi</a> No, <code>[:foo (WrappedNum. x y)]</code> would be transformed to <code>[:foo x]</code> only if x &lt; 42, else error with explain using <code>y</code></z><z id="t1596800806" t="ikitommi could that validation happen already in the :postprocess ?"><y>#</y><d>2020-08-07</d><h>11:46</h><w>ikitommi</w>could that validation happen already in the <code>:postprocess</code>?</z><z id="t1596800865" t="borkdude I just want to feed this data to malli and not intertwine parsing data from text to sexprs with malli validation"><y>#</y><d>2020-08-07</d><h>11:47</h><w>borkdude</w>I just want to feed this data to malli and not intertwine parsing data from text to sexprs with malli validation</z><z id="t1596800903" t="ikitommi ok. can the input be anything, e.g [:foo {:bar (WrappedNum. x y)}] ?"><y>#</y><d>2020-08-07</d><h>11:48</h><w>ikitommi</w>ok. can the input be anything, e.g <code>[:foo {:bar (WrappedNum. x y)}]</code>?</z><z id="t1596800903" t="borkdude [:foo y] could also be {:foo y} if that&apos;s easier for you"><y>#</y><d>2020-08-07</d><h>11:48</h><w>borkdude</w><code>[:foo y]</code> could also be <code>{:foo y}</code> if that&apos;s easier for you</z><z id="t1596800940" t="borkdude No, it&apos;s more like person: {:name &quot;foo&quot; :age 42} , let&apos;s say"><y>#</y><d>2020-08-07</d><h>11:49</h><w>borkdude</w>No, it&apos;s more like person: <code>{:name &quot;foo&quot; :age 42}</code>, let&apos;s say</z><z id="t1596800946" t="borkdude so attribute+value"><y>#</y><d>2020-08-07</d><h>11:49</h><w>borkdude</w>so attribute+value</z><z id="t1596801001" t="borkdude so unwrapping would just be (:obj wrapped) , that would be the transform step"><y>#</y><d>2020-08-07</d><h>11:50</h><w>borkdude</w>so unwrapping would just be <code>(:obj wrapped)</code>, that would be the transform step</z><z id="t1596801046" t="borkdude The use case for this is: normally edamame doesn&apos;t let you have location metadata for numbers and strings, but using a wrapped value you can have that"><y>#</y><d>2020-08-07</d><h>11:50</h><w>borkdude</w>The use case for this is: normally edamame doesn&apos;t let you have location metadata for numbers and strings, but using a wrapped value you can have that</z><z id="t1596801075" t="borkdude so I want to use malli like normally, but just use the location metadata in the wrapped value for reporting errors and discard it if the value is valid"><y>#</y><d>2020-08-07</d><h>11:51</h><w>borkdude</w>so I want to use malli like normally, but just use the location metadata in the wrapped value for reporting errors and discard it if the value is valid</z><z id="t1596801575" t="borkdude I believe in spec you would write a conformer for this"><y>#</y><d>2020-08-07</d><h>11:59</h><w>borkdude</w>I believe in spec you would write a conformer for this</z><z id="t1596802362" t="ikitommi yes, this is kinda tricky with current malli, as there is not yet a parsing api, like conform."><y>#</y><d>2020-08-07</d><h>12:12</h><w>ikitommi</w>yes, this is kinda tricky with current malli, as there is not yet a parsing api, like conform.</z><z id="t1596802422" t="ikitommi also, there is no custom overridable validator, so one needs to describe the given data structure (here, a tuple with keyword and a record)."><y>#</y><d>2020-08-07</d><h>12:13</h><w>ikitommi</w>also, there is no custom overridable validator, so one needs to describe the given data structure (here, a tuple with keyword and a record).</z><z id="t1596802519" t="borkdude ok, so one would write a schema using the records and if everything&apos;s ok, then postwalk yourself, unwrapping them?"><y>#</y><d>2020-08-07</d><h>12:15</h><w>borkdude</w>ok, so one would write a schema using the records and if everything&apos;s ok, then postwalk yourself, unwrapping them?</z><z id="t1596802519" t="ikitommi but, something like this: ;; schemas (def &lt;42 [:and int? [:&lt; 42]]) (def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure :loc} [:obj &lt;42]]]) ;; validator and encoders for both success &amp; failure (def valid? (m/validator Schema)) (def success (m/encoder Schema (mt/transformer {:name :success}))) (def failure (m/encoder Schema (mt/transformer {:name :failure}))) ;; in action (defn parse-validate-and-transform [s] (let [x (e/parse-string s {:postprocess postprocess})] (if (valid? x) (success x) (failure x)))) =&gt; (parse-validate-and-transform &quot;[:foo 41]&quot;) ; =&gt; [:foo 41] (parse-validate-and-transform &quot;[:foo 42]&quot;) ; =&gt; [:foo {:row 1, :col 7, :end-row 1, :end-col 9}]"><y>#</y><d>2020-08-07</d><h>12:15</h><w>ikitommi</w>but, something like this:
<pre>;; schemas
(def &lt;42 [:and int? [:&lt; 42]])
(def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure :loc} [:obj &lt;42]]])

;; validator and encoders for both success &amp; failure
(def valid? (m/validator Schema))
(def success (m/encoder Schema (mt/transformer {:name :success})))
(def failure (m/encoder Schema (mt/transformer {:name :failure})))

;; in action
(defn parse-validate-and-transform [s]
  (let [x (e/parse-string s {:postprocess postprocess})]
    (if (valid? x) (success x) (failure x))))</pre>
=&gt;
<pre>(parse-validate-and-transform &quot;[:foo 41]&quot;)
; =&gt; [:foo 41]

(parse-validate-and-transform &quot;[:foo 42]&quot;)
; =&gt; [:foo {:row 1, :col 7, :end-row 1, :end-col 9}]</pre></z><z id="t1596802563" t="ikitommi yes, postwalk would do. or a recursive schema definition. if the wrapped records can be anywhere"><y>#</y><d>2020-08-07</d><h>12:16</h><w>ikitommi</w>yes, postwalk would do. or a recursive schema definition. if the wrapped records can be anywhere</z><z id="t1596802572" t="borkdude let me try your snippet"><y>#</y><d>2020-08-07</d><h>12:16</h><w>borkdude</w>let me try your snippet</z><z id="t1596802672" t="borkdude $ clojure -m edamalli.core Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:76). :sci-not-available {:code &quot;:obj&quot;} That was unexpected, I don&apos;t need sci in this example?"><y>#</y><d>2020-08-07</d><h>12:17</h><w>borkdude</w><pre>$ clojure -m edamalli.core
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:76).
:sci-not-available {:code &quot;:obj&quot;}</pre>
That was unexpected, I don&apos;t need sci in this example?</z><z id="t1596802704" t="ikitommi oh, should not."><y>#</y><d>2020-08-07</d><h>12:18</h><w>ikitommi</w>oh, should not.</z><z id="t1596802762" t="ikitommi (def Schema [:tuple keyword? [:map {:encode/success (fn [x] (:obj x)), :encode/failure (fn [x] (:loc x)) [:obj &lt;42]}]])"><y>#</y><d>2020-08-07</d><h>12:19</h><w>ikitommi</w><pre>(def Schema [:tuple keyword? [:map {:encode/success (fn [x] (:obj x)), :encode/failure (fn [x] (:loc x)) [:obj &lt;42]}]])</pre></z><z id="t1596802889" t="ikitommi pushed e19872273c3660fbc482dcff4c2d8439dbcbb2a6 , which should allow naked keywords as functions."><y>#</y><d>2020-08-07</d><h>12:21</h><w>ikitommi</w>pushed <code>e19872273c3660fbc482dcff4c2d8439dbcbb2a6</code>, which should allow naked keywords as functions.</z><z id="t1596802913" t="ikitommi (def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure :loc} [:obj &lt;42]]])"><y>#</y><d>2020-08-07</d><h>12:21</h><w>ikitommi</w><pre>(def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure :loc} [:obj &lt;42]]])</pre></z><z id="t1596802914" t="borkdude"><y>#</y><d>2020-08-07</d><h>12:21</h><w>borkdude</w></z><z id="t1596802962" t="borkdude I&apos;m still getting the sci-not-available error"><y>#</y><d>2020-08-07</d><h>12:22</h><w>borkdude</w>I&apos;m still getting the sci-not-available error</z><z id="t1596803036" t="borkdude When I do include sci, I get: [:foo {:row 1, :col 7, :end-row 1, :end-col 9}]"><y>#</y><d>2020-08-07</d><h>12:23</h><w>borkdude</w>When I do include sci, I get:
<pre>[:foo {:row 1, :col 7, :end-row 1, :end-col 9}]</pre></z><z id="t1596803064" t="borkdude I guess I should throw my own error in :encode/failure ?"><y>#</y><d>2020-08-07</d><h>12:24</h><w>borkdude</w>I guess I should throw my own error in <code>:encode/failure</code>?</z><z id="t1596803181" t="ikitommi yes, that’s one place to do it. will check why sci is needed. just a sec."><y>#</y><d>2020-08-07</d><h>12:26</h><w>ikitommi</w>yes, that’s one place to do it. will check why sci is needed. just a sec.</z><z id="t1596803279" t="borkdude (defn parse-validate-and-transform [s] (let [x (e/parse-string s {:postprocess postprocess})] (if (valid? x) (prn &quot;SUCCESS&quot; (success x)) (prn &quot;ERROR&quot; (failure x))))) $ clojure -m edamalli.core &quot;ERROR&quot; [:foo {:row 1, :col 7, :end-row 1, :end-col 9}]"><y>#</y><d>2020-08-07</d><h>12:27</h><w>borkdude</w><pre>(defn parse-validate-and-transform [s]
  (let [x (e/parse-string s {:postprocess postprocess})]
    (if (valid? x)
      (prn &quot;SUCCESS&quot; (success x))
      (prn &quot;ERROR&quot; (failure x)))))</pre>
<pre>$ clojure -m edamalli.core
&quot;ERROR&quot; [:foo {:row 1, :col 7, :end-row 1, :end-col 9}]</pre></z><z id="t1596803354" t="borkdude haha, when I do this: :encode/failure {:message &quot;should be lower than 42&quot;} I get: $ clojure -m edamalli.core Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:54). Could not resolve symbol: should [at line 1, column 1]"><y>#</y><d>2020-08-07</d><h>12:29</h><w>borkdude</w>haha, when I do this:
<pre>:encode/failure {:message &quot;should be lower than 42&quot;}</pre>
I get:
<pre>$ clojure -m edamalli.core
Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:54).
Could not resolve symbol: should [at line 1, column 1]</pre></z><z id="t1596803378" t="borkdude I have no idea what I&apos;m doing, since I don&apos;t know these APIs well. I&apos;ll take a look after work again some time"><y>#</y><d>2020-08-07</d><h>12:29</h><w>borkdude</w>I have no idea what I&apos;m doing, since I don&apos;t know these APIs well. I&apos;ll take a look after work again some time</z><z id="t1596803800" t="ikitommi 8e067b3d004d1692cbfc695bc73d7e032ecb6e7f"><y>#</y><d>2020-08-07</d><h>12:36</h><w>ikitommi</w>8e067b3d004d1692cbfc695bc73d7e032ecb6e7f</z><z id="t1596803834" t="ikitommi the code used sci for all non fn? s, no to all non ifn? s. need to add tests."><y>#</y><d>2020-08-07</d><h>12:37</h><w>ikitommi</w>the code used sci for all non <code>fn?</code>s, no to all non  <code>ifn?</code>s. need to add tests.</z><z id="t1596803925" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I now have this: (def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure {:message &quot;should be lower than 42&quot;}} [:obj &lt;42]]]) Output: &quot;eval!&quot; &quot;should be lower than 42&quot; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:76). :sci-not-available {:code &quot;should be lower than 42&quot;}"><y>#</y><d>2020-08-07</d><h>12:38</h><w>borkdude</w><a>@ikitommi</a> I now have this:
<pre>(def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure {:message &quot;should be lower than 42&quot;}} [:obj &lt;42]]])</pre>
Output:
<pre>&quot;eval!&quot; &quot;should be lower than 42&quot;
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:76).
:sci-not-available {:code &quot;should be lower than 42&quot;}</pre></z><z id="t1596803954" t="borkdude I might be doing something wrong, but it seems there&apos;s a debug println in there?"><y>#</y><d>2020-08-07</d><h>12:39</h><w>borkdude</w>I might be doing something wrong, but it seems there&apos;s a debug println in there?</z><z id="t1596804185" t="ikitommi picard-facepalm my bad. but this kinda works (but is bad, should be better when we have the parsing api):"><y>#</y><d>2020-08-07</d><h>12:43</h><w>ikitommi</w><b>picard-facepalm</b> my bad. but this kinda works (but is bad, should be better when we have the parsing api):</z><z id="t1596804211" t="ikitommi ➜ ~ clojure -Sdeps &apos;{:deps {metosin/malli {:sha &quot;230b1767729aad3e02568f1320855e2b45d2d9b5&quot;, :git/url &quot;&quot;}, borkdude/edamame {:sha &quot;64c7eb43950eb500ba7429dded48257cd15355ae&quot;, :git/url &quot;&quot;}}}&apos; Checking out: at 230b1767729aad3e02568f1320855e2b45d2d9b5 Clojure 1.10.1 user=&gt; (ns edamalli.core (:require [edamame.core :as e] [malli.core :as m] [malli.transform :as mt])) (defrecord WrappedNum [obj loc]) (defn postprocess [{:keys [:obj :loc]}] (if (number? obj) (-&gt;WrappedNum obj loc) obj)) (defn fail! [{:keys [:obj :loc]}] (throw (ex-info (str &quot;so bad &quot; obj &quot;/&quot; loc) {}))) (def &lt;42 [:and int? [:&lt; 42]]) (def Schema [:tuple keyword? [:map {:encode/success :obj, :encode/failure fail!} [:obj &lt;42]]]) (def valid? (m/validator Schema)) (def success (m/encoder Schema (mt/transformer {:name :success}))) (def failure (m/encoder Schema (mt/transformer {:name :failure}))) (defn parse-validate-and-transform [s] (let [x (e/parse-string s {:postprocess postprocess})] (if (valid? x) (success x) (failure x)))) edamalli.core=&gt; (parse-validate-and-transform &quot;[:foo 41]&quot;) [:foo 41] edamalli.core=&gt; (parse-validate-and-transform &quot;[:foo 42]&quot;) Execution error (ExceptionInfo) at edamalli.core/fail! (REPL:2). so bad 42/{:row 1, :col 7, :end-row 1, :end-col 9}"><y>#</y><d>2020-08-07</d><h>12:43</h><w>ikitommi</w><pre>➜  ~ clojure -Sdeps &apos;{:deps {metosin/malli {:sha &quot;230b1767729aad3e02568f1320855e2b45d2d9b5&quot;, :git/url &quot;&quot;}, borkdude/edamame {:sha &quot;64c7eb43950eb500ba7429dded48257cd15355ae&quot;, :git/url &quot;&quot;}}}&apos;
Checking out:  at 230b1767729aad3e02568f1320855e2b45d2d9b5

Clojure 1.10.1
user=&gt; (ns edamalli.core
  (:require [edamame.core :as e]
            [malli.core :as m]
            [malli.transform :as mt]))

(defrecord WrappedNum [obj loc])

(defn postprocess [{:keys [:obj :loc]}]
  (if (number? obj) (-&gt;WrappedNum obj loc) obj))

(defn fail! [{:keys [:obj :loc]}]
  (throw (ex-info (str &quot;so bad &quot; obj &quot;/&quot; loc) {})))

(def &lt;42 [:and int? [:&lt; 42]])
(def Schema [:tuple keyword? [:map {:encode/success :obj,
                                    :encode/failure fail!} [:obj &lt;42]]])

(def valid? (m/validator Schema))
(def success (m/encoder Schema (mt/transformer {:name :success})))
(def failure (m/encoder Schema (mt/transformer {:name :failure})))

(defn parse-validate-and-transform [s]
  (let [x (e/parse-string s {:postprocess postprocess})]
    (if (valid? x) (success x) (failure x))))

edamalli.core=&gt; (parse-validate-and-transform &quot;[:foo 41]&quot;)
[:foo 41]

edamalli.core=&gt; (parse-validate-and-transform &quot;[:foo 42]&quot;)
Execution error (ExceptionInfo) at edamalli.core/fail! (REPL:2).
so bad 42/{:row 1, :col 7, :end-row 1, :end-col 9}</pre></z><z id="t1596804348" t="ikitommi [:attrs {:href &quot;/_/_/users/U1G8B7ZD3&quot;}] there is a small (have not measured) penalty for using ref-schemas, one function hop basically as the values are memoized."><y>#</y><d>2020-08-07</d><h>12:45</h><w>ikitommi</w><a>@zclj</a> there is a small (have not measured) penalty for using ref-schemas, one function hop basically as the values are memoized.</z><z id="t1596805436" t="zclj ok, that&apos;s fine since I have to do something to solve it anyway, by post-walking or such. Doing it up-front with malli ref considerable make the design simpler. Thanks for the info!"><y>#</y><d>2020-08-07</d><h>13:03</h><r>zclj</r>ok, that&apos;s fine since I have to do something to solve it anyway, by post-walking or such. Doing it up-front with malli ref considerable make the design simpler. Thanks for the info!</z><z id="t1596822638" t="ikitommi rollback on the perf info [:attrs {:href &quot;/_/_/users/U1G8B7ZD3&quot;}] . Validation &amp; explain perf is about the same but transforming values is potentially much slower. Why? Malli can&apos;t optimize over :ref s. Transformation behind :ref could be no-op, but it won&apos;t be removed as it&apos;s wrapped in a function. Still, orders of magnitude faster than with spec(-tools)"><y>#</y><d>2020-08-07</d><h>17:50</h><r>ikitommi</r>rollback on the perf info <a>@zclj</a> . Validation &amp; explain perf is about the same but transforming values is potentially much slower. Why? Malli can&apos;t optimize over <code>:ref</code>s. Transformation behind <code>:ref</code> could be no-op, but it won&apos;t be removed as it&apos;s wrapped in a function. Still, orders of magnitude faster than with spec(-tools)</z><z id="t1596879941" t="zclj thanks for the update! In my use-case I will also do generation from the schema, where I will blow the stack if I don&apos;t use :ref for recursive references. Are there any implications for using :ref for potentially non-recursive entities in that case?"><y>#</y><d>2020-08-08</d><h>09:45</h><r>zclj</r>thanks for the update! In my use-case I will also do generation from the schema, where I will blow the stack if I don&apos;t use :ref for recursive references. Are there any implications for using :ref for potentially non-recursive entities in that case?</z><z id="t1596804353" t="borkdude works, thanks"><y>#</y><d>2020-08-07</d><h>12:45</h><w>borkdude</w>works, thanks</z><z id="t1596822638" t="ikitommi rollback on the perf info [:attrs {:href &quot;/_/_/users/U1G8B7ZD3&quot;}] . Validation &amp; explain perf is about the same but transforming values is potentially much slower. Why? Malli can&apos;t optimize over :ref s. Transformation behind :ref could be no-op, but it won&apos;t be removed as it&apos;s wrapped in a function. Still, orders of magnitude faster than with spec(-tools)"><y>#</y><d>2020-08-07</d><h>17:50</h><w>ikitommi</w>rollback on the perf info <a>@zclj</a> . Validation &amp; explain perf is about the same but transforming values is potentially much slower. Why? Malli can&apos;t optimize over <code>:ref</code>s. Transformation behind <code>:ref</code> could be no-op, but it won&apos;t be removed as it&apos;s wrapped in a function. Still, orders of magnitude faster than with spec(-tools)</z><z id="t1597060952" t="Shuai Lin How can I express a schema of &quot;map of string keys to integer values?&quot; in malli?"><y>#</y><d>2020-08-10</d><h>12:02</h><w>Shuai Lin</w>How can I express a schema of &quot;map of string keys to integer values?&quot; in malli?</z><z id="t1597060994" t="ikitommi [:attrs {:href &quot;/_/_/users/UNMKEJQ1E&quot;}] [:map-of string? int?]"><y>#</y><d>2020-08-10</d><h>12:03</h><w>ikitommi</w><a>@linshuai2012</a> <code>[:map-of string? int?]</code></z><z id="t1597061038" t="Shuai Lin Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , just found it&apos;s there in README, I read through the README and missed it 😄"><y>#</y><d>2020-08-10</d><h>12:03</h><w>Shuai Lin</w>Thanks <a>@ikitommi</a>, just found it&apos;s there in README, I read through the README and missed it <b>😄</b></z><z id="t1597061282" t="Shuai Lin btw thanks for creating malli, it&apos;s much data friendly and intuitive than spec ! I&apos;m most looking forward to see the fdef equivalent https://github.com/metosin/malli/issues/125"><y>#</y><d>2020-08-10</d><h>12:08</h><w>Shuai Lin</w>btw thanks for creating malli, it&apos;s much data friendly and intuitive than spec ! I&apos;m most looking forward to see the fdef equivalent <a href="https://github.com/metosin/malli/issues/125" target="_blank">https://github.com/metosin/malli/issues/125</a></z><z id="t1597061322" t="ikitommi me too 😉"><y>#</y><d>2020-08-10</d><h>12:08</h><w>ikitommi</w>me too <b>😉</b></z><z id="t1597061976" t="borkdude I&apos;m also looking forward to a s/conformer equivalent"><y>#</y><d>2020-08-10</d><h>12:19</h><w>borkdude</w>I&apos;m also looking forward to a <code>s/conformer</code> equivalent</z><z id="t1597065872" t="zclj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I have a schema where some maps have a lot of optional keys, up to 50-ish. When I generate from this schema I got a, to me, surprising result. What happens is that even for very small sizes I get very large generated maps (and since they are recursive this is magnified). Looking into how malli generates maps with optional keys, it seems that each key will have a 50% change of being included, so there is no notion of &apos;size&apos; for the complete map. This also effect shrinking. So in practice my first generated map can be empty, while the second sample contains 20 keys. Intuitively I would expect the generation of optional keys to start small and then grow larger with size. Is this something you think malli should take care of or is it out of scope for malli and something I need to take care of with custom generators?"><y>#</y><d>2020-08-10</d><h>13:24</h><w>zclj</w><a>@ikitommi</a> I have a schema where some maps have a lot of optional keys, up to 50-ish. When I generate from this schema I got a, to me, surprising result. What happens is that even for very small sizes I get very large generated maps (and since they are recursive this is magnified). Looking into how malli generates maps with optional keys, it seems that each key will have a 50% change of being included, so there is no notion of &apos;size&apos; for the complete map. This also effect shrinking. So in practice my first generated map can be empty, while the second sample contains 20 keys. Intuitively I would expect the generation of optional keys to start small and then grow larger with size. Is this something you think malli should take care of or is it out of scope for malli and something I need to take care of with custom generators?</z><z id="t1597066085" t="ikitommi [:attrs {:href &quot;/_/_/users/U1G8B7ZD3&quot;}] if you have a simple improved algorithm for generating with optional keys, please PR, the code is kinda naive atm: https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L84-L87"><y>#</y><d>2020-08-10</d><h>13:28</h><w>ikitommi</w><a>@zclj</a> if you have a simple improved algorithm for generating with optional keys, please PR, the code is kinda naive atm: <a href="https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L84-L87" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L84-L87</a></z><z id="t1597306317" t="zclj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I have tried out some different solutions to this and though about it. My conclusion so far is that there are really no perfect default solution. As is usally the case in software testing (where I use the generators) the proper distribution of values are dependent on both the system under test and the outcome you want (positive tests, negative tests etc.) With this in mind, would you be open to a solution where malli could allow for the options to contain a :malli.generators/map-gen-optional-fn, where the user can provide their own implementaiton of the value selection and keep the default as is? In general, if malli provided such options it would be an awesome way to experiment with different distributions and allow for libraries to provide commonly used variants."><y>#</y><d>2020-08-13</d><h>08:11</h><r>zclj</r><a>@ikitommi</a> I have tried out some different solutions to this and though about it. My conclusion so far is that there are really no perfect default solution. As is usally the case in software testing (where I use the generators) the proper distribution of values are dependent on both the system under test and the outcome you want (positive tests, negative tests etc.) With this in mind, would you be open to a solution where malli could allow for the options to contain a :malli.generators/map-gen-optional-fn, where the user can provide their own implementaiton of the value selection and keep the default as is? In general, if malli provided such options it would be an awesome way to experiment with different distributions and allow for libraries to provide commonly used variants.</z><z id="t1597306503" t="ikitommi with the current api, you can override the whole :map generator with: (defmethod malli.generator/-schema-generator :map [schema options] (-my-map-gen schema options))"><y>#</y><d>2020-08-13</d><h>08:15</h><r>ikitommi</r>with the current api, you can override the whole <code>:map</code> generator with:
<pre>(defmethod malli.generator/-schema-generator :map [schema options] (-my-map-gen schema options))</pre></z><z id="t1597306573" t="ikitommi would that be enough?"><y>#</y><d>2020-08-13</d><h>08:16</h><r>ikitommi</r>would that be enough?</z><z id="t1597306649" t="ikitommi (not happy that one can globally override the generators, I concider this as mutable evil, but is like that today)"><y>#</y><d>2020-08-13</d><h>08:17</h><r>ikitommi</r>(not happy that one can globally override the generators, I concider this as mutable evil, but is like that today)</z><z id="t1597307356" t="zclj I experimented some with that option but did not pursue it further due to me still wanting the -recur funtionallity and then having to do that in my own code. I could of course re-use mallis -recur but it felt that I started to depend to much on malli internals for this to be a clean method of extension, but maybe I was to defensive in that decision?"><y>#</y><d>2020-08-13</d><h>08:29</h><r>zclj</r>I experimented some with that option but did not pursue it further due to me still wanting the <code>-recur</code> funtionallity and then having to do that in my own code. I could of course re-use mallis <code>-recur</code> but it felt that I started to depend to much on malli internals for this to be a clean method of extension, but maybe I was to defensive in that decision?</z><z id="t1597308096" t="ikitommi need to publish a malli internal naming convention guide. my idea was that all public - starting functions are public for library extensions / advanced use, tracked separately in CHANGELOG from the public end user api. Using those for basic use cases is a sign of invalid usage. Those will break more than the user-facing public api, but so that it’s easy for advanced users adapt to changes, e.g. no silent breaking changes after initial public release."><y>#</y><d>2020-08-13</d><h>08:41</h><r>ikitommi</r>need to publish a malli internal naming convention guide. my idea was that all public  <code>-</code> starting functions are public for library extensions / advanced use, tracked separately in CHANGELOG from the public end user api. Using those for basic use cases is a sign of invalid usage. Those will break more than the user-facing public api, but so that it’s easy for advanced users adapt to changes, e.g. no silent breaking changes after initial public release.</z><z id="t1597308155" t="ikitommi but, on second thought, if that one new option is good / you can provide alternative example impl (into README/docs) that might be of value to someone else, open to PR for adding that."><y>#</y><d>2020-08-13</d><h>08:42</h><r>ikitommi</r>but, on second thought, if that one new option is good / you can provide alternative example impl (into README/docs) that might be of value to someone else, open to PR for adding that.</z></g><g id="s6"><z id="t1597308206" t="ikitommi as options are passed in to -map-gen already, it’s most likely &lt;4 lines of code + tests + docs."><y>#</y><d>2020-08-13</d><h>08:43</h><r>ikitommi</r>as options are passed in to <code>-map-gen</code> already, it’s most likely &lt;4 lines of code + tests + docs.</z><z id="t1597308231" t="ikitommi (and doesn’t add much to cljs bundle size)"><y>#</y><d>2020-08-13</d><h>08:43</h><r>ikitommi</r>(and doesn’t add much to cljs bundle size)</z><z id="t1597411658" t="eskos Is there a reason the private stuff simply isn’t defn- ? Are the private parts split across multiple namespaces in such a way it would make this complicated?"><y>#</y><d>2020-08-14</d><h>13:27</h><r>eskos</r>Is there a reason the private stuff simply isn’t <code>defn-</code> ? Are the private parts split across multiple namespaces in such a way it would make this complicated?</z><z id="t1597413088" t="ikitommi real privates are ^:private . Vars like malli.core/-map-schema are public but only needed if you build your own registry, which is for advanced users only. Another is malli.core/-parse-entries which is a helper for building your own Schema instance, which wants to use the map-syntax"><y>#</y><d>2020-08-14</d><h>13:51</h><r>ikitommi</r>real privates are <code>^:private</code>. Vars like <code>malli.core/-map-schema</code> are public but only needed if you build your own registry, which is for  advanced users only. Another is <code>malli.core/-parse-entries</code> which is a helper for building your own Schema instance, which wants to use the map-syntax</z><z id="t1597413179" t="ikitommi spec is mostly closed for extensions, malli is built to be extended."><y>#</y><d>2020-08-14</d><h>13:52</h><r>ikitommi</r>spec is mostly closed for extensions, malli is built to be extended.</z><z id="t1597066373" t="zclj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I will take a look and see if I can figure something out 🙂"><y>#</y><d>2020-08-10</d><h>13:32</h><w>zclj</w><a>@ikitommi</a> I will take a look and see if I can figure something out <b>🙂</b></z><z id="t1597068106" t="Shuai Lin another question, can I add some meta information to each field? Like this: (def Person [:map [:name string? {:doc &quot;The name of the person&quot;}] [:age string?]])"><y>#</y><d>2020-08-10</d><h>14:01</h><w>Shuai Lin</w>another question, can I add some meta information to each field? Like this:
<pre>(def Person
  [:map
   [:name string? {:doc &quot;The name of the person&quot;}]
   [:age string?]])</pre></z><z id="t1597068718" t="ikitommi [:attrs {:href &quot;/_/_/users/UNMKEJQ1E&quot;}] map entries can have optional property map: (def Person [:map [:name {:doc &quot;The name of the person&quot;} string?] [:age string?]])"><y>#</y><d>2020-08-10</d><h>14:11</h><w>ikitommi</w><a>@linshuai2012</a> map entries can have optional property map:
<pre>(def Person
  [:map
   [:name {:doc &quot;The name of the person&quot;} string?]
   [:age string?]])</pre></z><z id="t1597068775" t="ikitommi just polishing the generic traversal of child-parents: (defn parent-properties [schema path] (loop [i (count path), acc []] (if (&gt;= i 0) (let [p (subvec path 0 i) s (mu/get-in schema p) ++ #(conj % (m/properties s))] (if (and (m/entries s) (&lt; i (count path))) (recur (dec i) (++ (conj acc (m/properties (mu/get-in schema (conj p [::m/entry (path i)])))))) (recur (dec i) (++ acc)))) acc))) (parent-properties [:map {:error/message &quot;1&quot;} [:y {:error/message &quot;2&quot;} [:and {:error/message &quot;3&quot;} [:map {:error/message &quot;4&quot;} [:x {:error/message &quot;5&quot;} [:and {:error/message &quot;6&quot;} int? [:&gt; {:error/message &quot;7&quot;} 18]]]]]]] [:y 0 :x 1]) ;[#:error{:message &quot;7&quot;} ; #:error{:message &quot;6&quot;} ; #:error{:message &quot;5&quot;} ; #:error{:message &quot;4&quot;} ; #:error{:message &quot;3&quot;} ; #:error{:message &quot;2&quot;} ; #:error{:message &quot;1&quot;}]"><y>#</y><d>2020-08-10</d><h>14:12</h><w>ikitommi</w>just polishing the generic traversal of child-parents:
<pre>(defn parent-properties [schema path]
  (loop [i (count path), acc []]
    (if (&gt;= i 0)
      (let [p (subvec path 0 i)
            s (mu/get-in schema p)
            ++ #(conj % (m/properties s))]
        (if (and (m/entries s) (&lt; i (count path)))
          (recur (dec i) (++ (conj acc (m/properties (mu/get-in schema (conj p [::m/entry (path i)]))))))
          (recur (dec i) (++ acc))))
      acc)))

(parent-properties
  [:map {:error/message &quot;1&quot;}
   [:y {:error/message &quot;2&quot;}
    [:and {:error/message &quot;3&quot;}
     [:map {:error/message &quot;4&quot;}
      [:x {:error/message &quot;5&quot;}
       [:and {:error/message &quot;6&quot;}
        int? [:&gt; {:error/message &quot;7&quot;} 18]]]]]]]
  [:y 0 :x 1])
;[#:error{:message &quot;7&quot;}
; #:error{:message &quot;6&quot;}
; #:error{:message &quot;5&quot;}
; #:error{:message &quot;4&quot;}
; #:error{:message &quot;3&quot;}
; #:error{:message &quot;2&quot;}
; #:error{:message &quot;1&quot;}]</pre></z><z id="t1597076398" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] collected some thoughts on the s/conform here: https://github.com/metosin/malli/issues/241 . Comments and ideas welcome."><y>#</y><d>2020-08-10</d><h>16:19</h><w>ikitommi</w><a>@borkdude</a> collected some thoughts on the <code>s/conform</code> here: <a href="https://github.com/metosin/malli/issues/241" target="_blank">https://github.com/metosin/malli/issues/241</a>. Comments and ideas welcome.</z><z id="t1597078859" t="borkdude Cool! I was asking about s/conforming specifically which was a spelling error, it should be https://clojuredocs.org/clojure.spec.alpha/conformer"><y>#</y><d>2020-08-10</d><h>17:00</h><w>borkdude</w>Cool! I was asking about <code>s/conforming</code> specifically which was a spelling error, it should be <a href="https://clojuredocs.org/clojure.spec.alpha/conformer" target="_blank">https://clojuredocs.org/clojure.spec.alpha/conformer</a></z><z id="t1597079012" t="borkdude This was the &quot;transform while conforming&quot; issue"><y>#</y><d>2020-08-10</d><h>17:03</h><w>borkdude</w>This was the &quot;transform while conforming&quot; issue</z><z id="t1597308096" t="ikitommi need to publish a malli internal naming convention guide. my idea was that all public - starting functions are public for library extensions / advanced use, tracked separately in CHANGELOG from the public end user api. Using those for basic use cases is a sign of invalid usage. Those will break more than the user-facing public api, but so that it’s easy for advanced users adapt to changes, e.g. no silent breaking changes after initial public release."><y>#</y><d>2020-08-13</d><h>08:41</h><w>ikitommi</w>need to publish a malli internal naming convention guide. my idea was that all public  <code>-</code> starting functions are public for library extensions / advanced use, tracked separately in CHANGELOG from the public end user api. Using those for basic use cases is a sign of invalid usage. Those will break more than the user-facing public api, but so that it’s easy for advanced users adapt to changes, e.g. no silent breaking changes after initial public release.</z><z id="t1597156543" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] do the names :encode/conform and (mt/transformer {:name :conform}) match? why is mt/transform not called mt/encode ?"><y>#</y><d>2020-08-11</d><h>14:35</h><w>borkdude</w><a>@ikitommi</a> do the names <code>:encode/conform</code> and <code>(mt/transformer {:name :conform})</code> match? why is <code>mt/transform</code> not called <code>mt/encode</code>?</z><z id="t1597156582" t="borkdude ah because it also has decode , gotcha"><y>#</y><d>2020-08-11</d><h>14:36</h><w>borkdude</w>ah because it also has <code>decode</code>, gotcha</z><z id="t1597216093" t="ikitommi the transformation terms: • transformation function, a function of A-&gt;B, e.g. converts strings to dates • decoding, a process of transforming (invalid) values into potentially valid ones (IN*), m/decoder &amp; m/decode * • encoding, a process of transforming (valid) values into something else (OUT), m/encoder &amp; m/encode • transformer, a top-level component that maps Schemas with transformation functions (“json-transformer transforms strings to dates, but not strings to numbers”). Needed in encoding and decoding, mt/transformer • named transformer, If a transformer has :name defined, Schemas can define their transformation functions (for both encoding &amp; decoding) using Schema properties • interceptor, a component that bundles transforming functions into transforming phases • transforming phase, either :enter or :leave , timing when a transformation function is applied in the chain (before the fact or after the fact) • interceptor chain, a sequence of interceptors that is used to run the (optimized chain of) transformation functions from interceptors in correct order • transformation chain , transformers compose too: (mt/transformer {:name :before} mt/json-transfomer {:name :after})"><y>#</y><d>2020-08-12</d><h>07:08</h><w>ikitommi</w>the transformation terms:
• transformation function, a function of A-&gt;B, e.g. converts strings to dates
• decoding, a process of transforming (invalid) values into potentially valid ones (IN*), <code>m/decoder</code>&amp; <code>m/decode</code>*
• encoding, a process of transforming (valid) values into something else (OUT), <code>m/encoder</code> &amp; <code>m/encode</code>
• transformer, a top-level component that maps Schemas with transformation functions (“json-transformer transforms strings to dates, but not strings to numbers”). Needed in encoding and decoding,  <code>mt/transformer</code>
• named transformer, If a transformer has <code>:name</code> defined, Schemas can define their transformation functions (for both encoding &amp; decoding) using Schema properties 
• interceptor, a component that bundles transforming functions into transforming phases
• transforming phase, either <code>:enter</code> or <code>:leave</code>, timing when a transformation function is applied in the chain (before the fact or after the fact)
• interceptor chain, a sequence of interceptors that is used to run the (optimized chain of) transformation functions from interceptors in correct order
• transformation chain , transformers compose too: <code>(mt/transformer {:name :before} mt/json-transfomer {:name :after})</code></z><z id="t1597228422" t="eskos Could be valuable to add these as glossary doc to the repository (`docs/glossary.md`) to document them 👍"><y>#</y><d>2020-08-12</d><h>10:33</h><r>eskos</r>Could be valuable to add these as glossary doc to the repository (`docs/glossary.md`) to document them <b>👍</b></z><z id="t1597216129" t="ikitommi lot of things inside to make things composable and fast, the basic user doesn’t have to know much of the details."><y>#</y><d>2020-08-12</d><h>07:08</h><w>ikitommi</w>lot of things inside to make things composable and fast, the basic user doesn’t have to know much of the details.</z><z id="t1597216981" t="ikitommi (m/decode [:map [:x {:default 42} int?] [:y [:vector {:decode/before #(str/split % #&quot;,&quot;) :decode/after {:leave #(mapv inc %)}} int?]]] {:y &quot;1,2,3&quot;} (mt/transformer {:name :before} (mt/default-value-transformer) (mt/string-transformer) {:name :after})) ;{:y [2 3 4] ; :x 42}"><y>#</y><d>2020-08-12</d><h>07:23</h><w>ikitommi</w><pre>(m/decode
  [:map
   [:x {:default 42} int?]
   [:y [:vector {:decode/before #(str/split % #&quot;,&quot;)
                 :decode/after {:leave #(mapv inc %)}} int?]]]
  {:y &quot;1,2,3&quot;}
  (mt/transformer
    {:name :before}
    (mt/default-value-transformer)
    (mt/string-transformer)
    {:name :after}))
;{:y [2 3 4]
; :x 42}</pre></z><z id="t1597217098" t="ikitommi (m/decode [:map [:x {:default 42} int?] [:y [:vector {:decode/before #(str/split % #&quot;,&quot;) :decode/after {:leave #(mapv inc %)}} int?]]] {:y &quot;1,2,3&quot;} (mt/transformer {:name :before} (mt/default-value-transformer) (mt/string-transformer) {:decoders {&apos;int? #(* % 2)}} {:name :after})) ;{:y [3 5 7] ; :x 84}"><y>#</y><d>2020-08-12</d><h>07:24</h><w>ikitommi</w><pre>(m/decode
  [:map
   [:x {:default 42} int?]
   [:y [:vector {:decode/before #(str/split % #&quot;,&quot;)
                 :decode/after {:leave #(mapv inc %)}} int?]]]
  {:y &quot;1,2,3&quot;}
  (mt/transformer
    {:name :before}
    (mt/default-value-transformer)
    (mt/string-transformer)
    {:decoders {&apos;int? #(* % 2)}}
    {:name :after}))
;{:y [3 5 7]
; :x 84}</pre></z><z id="t1597655701" t="Shuai Lin is it possible for my transformer/decode to know the current path when decoding? e.g. in the below example, I&apos;d like to replace the &lt;location&gt; with :k1 (ma/decode [:map [:k1 [:map {:decode/foo #(assoc % :location :&lt;location?&gt;)} [:x int?]]]] {:k1 {:x 1}} (mt/transformer {:name :foo})) ;; =&gt; {:k1 {:x 1, :location :&lt;location?&gt;}}"><y>#</y><d>2020-08-17</d><h>09:15</h><w>Shuai Lin</w>is it possible for my transformer/decode to know the current path when decoding?  e.g.  in the below example, I&apos;d like to replace the <code>&lt;location&gt;</code> with <code>:k1</code>
<pre>(ma/decode
 [:map 
  [:k1 [:map {:decode/foo #(assoc % :location :&lt;location?&gt;)}
        [:x int?]]]]
 {:k1 {:x 1}}
 (mt/transformer
  {:name :foo}))
;; =&gt; {:k1 {:x 1, :location :&lt;location?&gt;}}</pre></z><z id="t1597655850" t="Shuai Lin the background story is I want to generate a unique key for each such map based on its path in the whole tree"><y>#</y><d>2020-08-17</d><h>09:17</h><w>Shuai Lin</w>the background story is I want to generate a unique key for each such map based on its path in the whole tree</z><z id="t1597657535" t="ikitommi [:attrs {:href &quot;/_/_/users/UNMKEJQ1E&quot;}] not at the moment, but you can do the following: 1) use m/walk to transform the schemas by adding a :in property to schemas (Schema :path and value :in are available for walkers) 2) create a decoder that uses the interceptor :compile hook to access the Schema at decoder creation time"><y>#</y><d>2020-08-17</d><h>09:45</h><w>ikitommi</w><a>@linshuai2012</a> not at the moment, but you can do the following:
1) use <code>m/walk</code> to transform the schemas by adding a <code>:in</code> property to schemas (Schema <code>:path</code> and value <code>:in</code> are available for walkers)
2) create a decoder that uses the interceptor <code>:compile</code> hook to access the Schema at decoder creation time</z><z id="t1597657604" t="ikitommi there are few pending PRs around walkers, not 100% sure what is in the current master."><y>#</y><d>2020-08-17</d><h>09:46</h><w>ikitommi</w>there are few pending PRs around walkers, not 100% sure what is in the current master.</z><z id="t1597657688" t="Shuai Lin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thx! I&apos;ll take a look at this approach. Currently I&apos;m trying a solution that 1. leaves a place holder when decoding, and then 2. after decoding the whole tree, walk my tree on my own (and accumulate the path), and for each such map, use clojure.walk/prewalk to replace the placeholder with the current path"><y>#</y><d>2020-08-17</d><h>09:48</h><w>Shuai Lin</w><a>@ikitommi</a> thx! I&apos;ll take a look at this approach. Currently I&apos;m trying a solution that
1. leaves a place holder when decoding, and then
2. after decoding the whole tree, walk my tree on my own (and accumulate the path), and for each such map, use clojure.walk/prewalk to replace the placeholder with the current path</z><z id="t1597657809" t="ikitommi pretty sure it&apos;s not very performant that way. There is an example of attaching a generated sample value to all schemas in the readme."><y>#</y><d>2020-08-17</d><h>09:50</h><w>ikitommi</w>pretty sure it&apos;s not very performant that way. There is an example of attaching a generated sample value to all schemas in the readme.</z><z id="t1597657884" t="ikitommi It uses the m/schema-walker , you need the plain walker to access the :in data. But otherwise, the 1) should be copyable from that."><y>#</y><d>2020-08-17</d><h>09:51</h><w>ikitommi</w>It uses the <code>m/schema-walker</code> , you need the plain walker to access the <code>:in</code> data. But otherwise, the 1) should be copyable from that.</z><z id="t1597665805" t="Shuai Lin Just realized it&apos;s not what I want, the schema walker walks the schema, not the actual data. I still need to walk the actual data to get the pat to generate the unique key for each map in the tree based on its actual location. Also, my schema is recursive - think about a file system, where there are directories as maps, files as leaves, and sub-directories as child maps."><y>#</y><d>2020-08-17</d><h>12:03</h><r>Shuai Lin</r>Just realized it&apos;s not what I want, the schema walker walks the schema, not the actual data.

I still need to walk the actual data to get the pat to generate the unique key for each map in the tree based on its actual location. Also, my schema is recursive - think about a file system, where there are directories as maps, files as leaves, and sub-directories as child maps.</z><z id="t1597668041" t="ikitommi walk + decode would work for non-recursive schemas. Please write an issue, I&apos;ll think about the solution."><y>#</y><d>2020-08-17</d><h>12:40</h><r>ikitommi</r>walk + decode would work for non-recursive schemas. Please write an issue, I&apos;ll think about the solution.</z><z id="t1597677994" t="Shuai Lin Thx! I will."><y>#</y><d>2020-08-17</d><h>15:26</h><r>Shuai Lin</r>Thx! I will.</z><z id="t1597657933" t="ikitommi also, the interceptor :compile hook could publish more information about the context to the transformers, last call to break the api before freezing things. Please write an issue if you want that"><y>#</y><d>2020-08-17</d><h>09:52</h><w>ikitommi</w>also, the interceptor <code>:compile</code> hook could publish more information about the context to the transformers, last call to break the api before freezing things. Please write an issue if you want that</z><z id="t1597658035" t="ikitommi It is now a callback fn with args of schema value , could be schema value path in root-schema for example"><y>#</y><d>2020-08-17</d><h>09:53</h><w>ikitommi</w>It is now a callback fn with args of <code>schema value</code>, could be <code>schema value path in root-schema</code> for example</z><z id="t1597658243" t="Shuai Lin the m/walker apporach looks promising, I&apos;ll try it next"><y>#</y><d>2020-08-17</d><h>09:57</h><w>Shuai Lin</w>the m/walker apporach looks promising, I&apos;ll try it next</z><z id="t1597659531" t="Casey I&apos;m just getting started exploring malli"><y>#</y><d>2020-08-17</d><h>10:18</h><w>Casey</w>I&apos;m just getting started exploring malli</z><z id="t1597659575" t="Casey https://github.com/metosin/malli#mallicorebase-schemas seem to indicate if I want a :int or :int-in schema, I&apos;d have to register it myself, is that correct?"><y>#</y><d>2020-08-17</d><h>10:19</h><w>Casey</w><a href="https://github.com/metosin/malli#mallicorebase-schemas" target="_blank">https://github.com/metosin/malli#mallicorebase-schemas</a> seem to indicate if I want a <code>:int</code> or <code>:int-in</code> schema, I&apos;d have to register it myself, is that correct?</z><z id="t1597659879" t="ikitommi [:attrs {:href &quot;/_/_/users/U70QFSCG2&quot;}] you can just create a function that returns a form for it: (defn int-in [min max] [:and int? [:fn &apos;(fn [x] (&lt; min x max))]])"><y>#</y><d>2020-08-17</d><h>10:24</h><w>ikitommi</w><a>@ramblurr</a> you can just create a function that returns a form for it:
<pre>(defn int-in [min max]
 [:and int? [:fn &apos;(fn [x] (&lt; min x max))]])</pre></z><z id="t1597659923" t="ikitommi but you should add a :gen/gen for it too. I think there should be a built-in for that (and for dates too)"><y>#</y><d>2020-08-17</d><h>10:25</h><w>ikitommi</w>but you should add a <code>:gen/gen</code> for it too. I think there should be a built-in for that (and for dates too)</z><z id="t1597659967" t="ikitommi [:int {:min 1, :max 10}] [:date {:min &quot;2020-08-16&quot;, :max &quot;2020-10-10&quot;}] kinda things"><y>#</y><d>2020-08-17</d><h>10:26</h><w>ikitommi</w><pre>[:int {:min 1, :max 10}]
[:date {:min &quot;2020-08-16&quot;, :max &quot;2020-10-10&quot;}]</pre>
kinda things</z><z id="t1597660117" t="ikitommi the raw impl would look much like :string : https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L772-L805"><y>#</y><d>2020-08-17</d><h>10:28</h><w>ikitommi</w>the raw impl would look much like <code>:string</code>: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L772-L805" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L772-L805</a></z><z id="t1597660120" t="Casey ah great, i see"><y>#</y><d>2020-08-17</d><h>10:28</h><w>Casey</w>ah great, i see</z><z id="t1597660120" t="Casey is there an aggregated list of built ins somewhere (with docs as to their properties)"><y>#</y><d>2020-08-17</d><h>10:28</h><w>Casey</w>is there an aggregated list of built ins somewhere (with docs as to their properties)</z><z id="t1597660171" t="Casey &gt; I think there should be a built-in for that (and for dates too) Do you mean you think this built-in already exists, or you had the idea that it should be added ? 🙂"><y>#</y><d>2020-08-17</d><h>10:29</h><w>Casey</w>&gt; I think there should be a built-in for that (and for dates too)
Do you mean you think this built-in already exists, or you had the idea that it should be added ? <b>🙂</b></z><z id="t1597660178" t="ikitommi (m/default-schemas) gives a list of all. the source code is currently the best source of descriptions."><y>#</y><d>2020-08-17</d><h>10:29</h><w>ikitommi</w><code>(m/default-schemas)</code> gives a list of all. the source code is currently the best source of descriptions.</z><z id="t1597660183" t="ikitommi should be added 🙂"><y>#</y><d>2020-08-17</d><h>10:29</h><w>ikitommi</w>should be added <b>🙂</b></z><z id="t1597660232" t="ikitommi the properties - will add description of those using malli (eat your own..), but not there yet."><y>#</y><d>2020-08-17</d><h>10:30</h><w>ikitommi</w>the properties - will add description of those using malli (eat your own..), but not there yet.</z><z id="t1597660435" t="Casey Using the int-in function def you gave an example for above.. if you added it to a registry {:int-in (m/fn-schema :int-in int-in)} , how could it be consumed later? In fact, this wouldn&apos;t work right?"><y>#</y><d>2020-08-17</d><h>10:33</h><w>Casey</w>Using the <code>int-in</code> function def you gave an example for above.. if you added it to a registry <code>{:int-in (m/fn-schema :int-in int-in)}</code>  , how could it be consumed later? In fact, this wouldn&apos;t work right?</z><z id="t1597660539" t="Casey You could do something like {:int-in-0-10 (m/fn-schema :int-in-0-10 (partial int-in 0 10))} I suppose"><y>#</y><d>2020-08-17</d><h>10:35</h><w>Casey</w>You could do something like <code>{:int-in-0-10 (m/fn-schema :int-in-0-10 (partial int-in 0 10))}</code> I suppose</z><z id="t1597661077" t="ikitommi (defn int-in [min max] [:and int? [:fn `(fn [x] (&lt; ~min x ~max))]]) (def int-in-1-10 (int-in 1 10)) (validate [:tuple int-in-1-10 (int-in 10 100)] [2 12]) ; =&gt; true (form [:tuple int-in-1-10 (int-in 10 100)]) ;[:tuple ; [:and int? [:fn (clojure.core/fn [malli.core/x] (clojure.core/&lt; 1 malli.core/x 10))]] ; [:and int? [:fn (clojure.core/fn [malli.core/x] (clojure.core/&lt; 10 malli.core/x 100))]]]"><y>#</y><d>2020-08-17</d><h>10:44</h><w>ikitommi</w><pre>(defn int-in [min max]
  [:and int? [:fn `(fn [x] (&lt; ~min x ~max))]])

(def int-in-1-10 (int-in 1 10))

(validate [:tuple int-in-1-10 (int-in 10 100)] [2 12])
; =&gt; true

(form [:tuple int-in-1-10 (int-in 10 100)])
;[:tuple
; [:and int? [:fn (clojure.core/fn [malli.core/x] (clojure.core/&lt; 1 malli.core/x 10))]]
; [:and int? [:fn (clojure.core/fn [malli.core/x] (clojure.core/&lt; 10 malli.core/x 100))]]]</pre></z><z id="t1597661166" t="ikitommi if you write an issue about the :int as built-in, happy to add that. much cleaner"><y>#</y><d>2020-08-17</d><h>10:46</h><w>ikitommi</w>if you write an issue about the <code>:int</code> as built-in, happy to add that. much cleaner</z><z id="t1597662949" t="Casey Am I correct that you can&apos;t use the generic :int-in as defined above in a registry, because the &quot;registered&quot; specs must be predicate predicate functions (single value as input)?"><y>#</y><d>2020-08-17</d><h>11:15</h><w>Casey</w>Am I correct that you can&apos;t use the generic <code>:int-in</code> as defined above in a registry, because the &quot;registered&quot; specs must be predicate predicate functions (single value as input)?</z><z id="t1597663465" t="ikitommi • registered schemas are one of: 1) IntoSchema instance (e.g. something that take the schema syntax and return a Schema . 2) Schema instance, 3) Schema syntax. • m/fn-schema just takes a predicate fn, which is only used to build a validator for the schema • there could be more helpers to build custom schemas easier, something between m/fn-schema (here: too simple) and writing IntoSchema impl (here: too much work) by hand, but currently, there is not."><y>#</y><d>2020-08-17</d><h>11:24</h><w>ikitommi</w>• registered schemas are one of: 1) <code>IntoSchema</code> instance (e.g. something that take the schema syntax and return a <code>Schema</code>. 2) <code>Schema</code> instance, 3) Schema syntax.
• <code>m/fn-schema</code> just takes a predicate fn, which is only used to build a validator for the schema
• there could be more helpers to build custom schemas easier, something between <code>m/fn-schema</code> (here: too simple) and writing <code>IntoSchema</code> impl (here: too much work) by hand, but currently, there is not.</z><z id="t1597663569" t="ikitommi I think I’ll extract the code from :string so that :date , :number , :date-time etc can reuse most of it (e.g. the :min + :max handling of via properties, effecting both validation and value generation)"><y>#</y><d>2020-08-17</d><h>11:26</h><w>ikitommi</w>I think I’ll extract the code from <code>:string</code> so that <code>:date</code>, <code>:number</code>, <code>:date-time</code> etc can reuse most of it (e.g. the <code>:min</code> + <code>:max</code> handling of via properties, effecting both validation and value generation)</z><z id="t1597663728" t="ikitommi also, you could build your own things with it easily: {:registry {:bigdec (m/-ranged-pred-schema {:pred bigdec?, :range-pred …, :range-gen ...})}}"><y>#</y><d>2020-08-17</d><h>11:28</h><w>ikitommi</w>also, you could build your own things with it easily: <code>{:registry {:bigdec (m/-ranged-pred-schema {:pred bigdec?, :range-pred …, :range-gen ...})}}</code></z><z id="t1597665805" t="Shuai Lin Just realized it&apos;s not what I want, the schema walker walks the schema, not the actual data. I still need to walk the actual data to get the pat to generate the unique key for each map in the tree based on its actual location. Also, my schema is recursive - think about a file system, where there are directories as maps, files as leaves, and sub-directories as child maps."><y>#</y><d>2020-08-17</d><h>12:03</h><w>Shuai Lin</w>Just realized it&apos;s not what I want, the schema walker walks the schema, not the actual data.

I still need to walk the actual data to get the pat to generate the unique key for each map in the tree based on its actual location. Also, my schema is recursive - think about a file system, where there are directories as maps, files as leaves, and sub-directories as child maps.</z><z id="t1597674941" t="Casey [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] I&apos;ve been playing with your demo ( https://github.com/stevebuik/fork-malli-ideas ) , it&apos;s a really nice approach to form validation."><y>#</y><d>2020-08-17</d><h>14:35</h><w>Casey</w><a>@steveb8n</a> I&apos;ve been playing with your demo (<a href="https://github.com/stevebuik/fork-malli-ideas" target="_blank">https://github.com/stevebuik/fork-malli-ideas</a>) , it&apos;s a really nice approach to form validation.</z><z id="t1597702495" t="steveb8n [:attrs {:href &quot;/_/_/users/UE35Y835W&quot;}] nice to see some interest"><y>#</y><d>2020-08-17</d><h>22:14</h><r>steveb8n</r><a>@UE35Y835W</a> nice to see some interest</z><z id="t1597822347" t="Lu Yeah pretty cool!! 😎 "><y>#</y><d>2020-08-19</d><h>07:32</h><r>Lu</r>Yeah pretty cool!! <b>😎</b> </z><z id="t1597841060" t="Lu in 2.1.4 you can add a keywordize-keys true option to work exclusivley with keywords/namespaced keywords instead of strings, also in the validation"><y>#</y><d>2020-08-19</d><h>12:44</h><r>Lu</r>in 2.1.4 you can add a keywordize-keys true option to work exclusivley with keywords/namespaced keywords instead of strings, also in the validation</z><z id="t1597674965" t="Casey The keyword &lt;-&gt; string transformations are clever too, though don&apos;t work when namespaced keys are used"><y>#</y><d>2020-08-17</d><h>14:36</h><w>Casey</w>The keyword &lt;-&gt; string transformations are clever too, though don&apos;t work when namespaced keys are used</z><z id="t1597678818" t="Casey I&apos;m working around this using (defn unkeyword [m] (map-keys #(subs (str %) 1) m)) at the end of validator-for-humans to turn :foo/attr -&gt; &quot;foo/attr&quot; .. and of course using &quot;foo/attr&quot; as the name in the form form. Works well enough, if a little dirty."><y>#</y><d>2020-08-17</d><h>15:40</h><r>Casey</r>I&apos;m  working around this using

<code>(defn unkeyword [m]</code>
  <code>(map-keys #(subs (str %) 1) m))</code>

at the end of <code>validator-for-humans</code> to turn <code>:foo/attr</code>-&gt; <code>&quot;foo/attr&quot;</code> .. and of course using &quot;foo/attr&quot; as the name in the form form. Works well enough, if a little dirty.</z><z id="t1597675044" t="ikitommi [:attrs {:href &quot;/_/_/users/U70QFSCG2&quot;}] https://github.com/metosin/malli/pull/243/commits/7d335e916d9769d4039b69e1475f04f3239ac5c7"><y>#</y><d>2020-08-17</d><h>14:37</h><w>ikitommi</w><a>@ramblurr</a> <a href="https://github.com/metosin/malli/pull/243/commits/7d335e916d9769d4039b69e1475f04f3239ac5c7" target="_blank">https://github.com/metosin/malli/pull/243/commits/7d335e916d9769d4039b69e1475f04f3239ac5c7</a></z><z id="t1597675100" t="ikitommi merged in master"><y>#</y><d>2020-08-17</d><h>14:38</h><w>ikitommi</w>merged in master</z><z id="t1597675154" t="Casey first look comment: the max range should be exclusive, not inclusive. That&apos;s a pretty standard trope across all range checks in almost any language I know"><y>#</y><d>2020-08-17</d><h>14:39</h><w>Casey</w>first look comment: the max range should be exclusive, not inclusive. That&apos;s a pretty standard trope across all range checks in almost any language I know</z><z id="t1597675197" t="ikitommi with m/-simple-schema it should be easy to add new schemas that use properties in validation: (-simple-schema {:type :double, :pred double?, :property-pred (-min-max-pred identity)}))"><y>#</y><d>2020-08-17</d><h>14:39</h><w>ikitommi</w>with <code>m/-simple-schema</code> it should be easy to add new schemas that use properties in validation:
<pre>(-simple-schema {:type :double, :pred double?, :property-pred (-min-max-pred identity)}))</pre></z><z id="t1597675209" t="ikitommi :thinking_face:"><y>#</y><d>2020-08-17</d><h>14:40</h><w>ikitommi</w><b>:thinking_face:</b></z><z id="t1597675223" t="ikitommi spec has that, test.check uses inclusive for both."><y>#</y><d>2020-08-17</d><h>14:40</h><w>ikitommi</w>spec has that, test.check uses inclusive for both.</z><z id="t1597675241" t="ikitommi could you link some external wisdom for that?"><y>#</y><d>2020-08-17</d><h>14:40</h><w>ikitommi</w>could you link some external wisdom for that?</z><z id="t1597675258" t="Casey https://clojuredocs.org/clojure.spec.alpha/int-in-range_q is exclusive"><y>#</y><d>2020-08-17</d><h>14:40</h><w>Casey</w><a href="https://clojuredocs.org/clojure.spec.alpha/int-in-range_q" target="_blank">https://clojuredocs.org/clojure.spec.alpha/int-in-range_q</a>  is exclusive</z><z id="t1597675289" t="ikitommi https://clojure.github.io/test.check/clojure.test.check.generators.html#var-large-integer* is inclusive"><y>#</y><d>2020-08-17</d><h>14:41</h><w>ikitommi</w><a href="https://clojure.github.io/test.check/clojure.test.check.generators.html#var-large-integer*" target="_blank">https://clojure.github.io/test.check/clojure.test.check.generators.html#var-large-integer*</a> is inclusive</z><z id="t1597675375" t="ikitommi JSON Schema has inclusive: https://json-schema.org/understanding-json-schema/reference/numeric.html"><y>#</y><d>2020-08-17</d><h>14:42</h><w>ikitommi</w>JSON Schema has inclusive: <a href="https://json-schema.org/understanding-json-schema/reference/numeric.html" target="_blank">https://json-schema.org/understanding-json-schema/reference/numeric.html</a></z><z id="t1597675386" t="Casey and so s/int-in and s/double-in are exclusive, https://clojuredocs.org/clojure.core/range is exclusive,"><y>#</y><d>2020-08-17</d><h>14:43</h><w>Casey</w>and so s/int-in and s/double-in are exclusive, <a href="https://clojuredocs.org/clojure.core/range" target="_blank">https://clojuredocs.org/clojure.core/range</a> is exclusive,</z><z id="t1597675429" t="Casey json schema supports inclusive and exclusive options 😛"><y>#</y><d>2020-08-17</d><h>14:43</h><w>Casey</w>json schema supports inclusive and exclusive options  <b>😛</b></z><z id="t1597675608" t="Casey to be clear, i&apos;m advocating only the max be exclusive, look at pretty much and langugage: python&apos;s list slice operator, java&apos;s IntStreams,"><y>#</y><d>2020-08-17</d><h>14:46</h><w>Casey</w>to be clear, i&apos;m advocating only the <code>max</code>  be exclusive, look at pretty much and langugage: python&apos;s list slice operator, java&apos;s IntStreams,</z><z id="t1597675630" t="Casey here&apos;s an argument why: https://wrschneider.github.io/2014/01/07/time-intervals-and-other-ranges-should.html (starting off about time, but then at the end mentions integer ranges)"><y>#</y><d>2020-08-17</d><h>14:47</h><w>Casey</w>here&apos;s an argument why: <a href="https://wrschneider.github.io/2014/01/07/time-intervals-and-other-ranges-should.html" target="_blank">https://wrschneider.github.io/2014/01/07/time-intervals-and-other-ranges-should.html</a> (starting off about time, but then at the end mentions integer ranges)</z><z id="t1597675699" t="Casey Haha, and https://stackoverflow.com/questions/8441749/representing-intervals-or-ranges is a link to https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html by Dijkstra on the topic"><y>#</y><d>2020-08-17</d><h>14:48</h><w>Casey</w>Haha, and <a href="https://stackoverflow.com/questions/8441749/representing-intervals-or-ranges" target="_blank">https://stackoverflow.com/questions/8441749/representing-intervals-or-ranges</a> is a link to <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html</a>  by Dijkstra on the topic</z><z id="t1597675739" t="ikitommi thanks. will read those."><y>#</y><d>2020-08-17</d><h>14:48</h><w>ikitommi</w>thanks. will read those.</z><z id="t1597675809" t="Casey That said, I don&apos;t need to die on this hill 🙂 Just sharing my experience that generally when I see a range in an api, I assume (and assumed others did too!) that it was inclusive start and exclusive end. As long as it&apos;s documented, it&apos;ll be ok either way"><y>#</y><d>2020-08-17</d><h>14:50</h><w>Casey</w>That said, I don&apos;t need to die on this hill <b>🙂</b>  Just sharing my experience that generally when I see a range in an api, I assume (and assumed others did too!) that it was inclusive start and exclusive end. As long as it&apos;s documented, it&apos;ll be ok either way</z><z id="t1597685159" t="ikitommi meanwhile: (mg/generate [:map [:string :string] [:int :int] [:double :double] [:boolean :boolean] [:keyword :keyword] [:symbol :symbol] [:qualified-keyword :qualified-keyword] [:qualified-symbol :qualified-symbol]] {:size 42, :seed 42}) ;{:string &quot;¦®GÏVá@£°5o,&amp;µ7\rØã&quot;, ; :int -1251, ; :double -0.03125, ; :boolean true, ; :keyword :WD_VS_-r, ; :symbol k5K_2i, ; :qualified-keyword :M8qL/u?RAmf, ; :qualified-symbol x/y0T} related: https://github.com/metosin/malli/issues/25"><y>#</y><d>2020-08-17</d><h>17:25</h><w>ikitommi</w>meanwhile:
<pre>(mg/generate
  [:map
   [:string :string]
   [:int :int]
   [:double :double]
   [:boolean :boolean]
   [:keyword :keyword]
   [:symbol :symbol]
   [:qualified-keyword :qualified-keyword]
   [:qualified-symbol :qualified-symbol]]
  {:size 42, :seed 42})
;{:string &quot;¦®GÏVá@£°5o,&amp;µ7\rØã&quot;,
; :int -1251,
; :double -0.03125,
; :boolean true,
; :keyword :WD_VS_-r,
; :symbol k5K_2i,
; :qualified-keyword :M8qL/u?RAmf,
; :qualified-symbol x/y0T}</pre>
related: <a href="https://github.com/metosin/malli/issues/25" target="_blank">https://github.com/metosin/malli/issues/25</a></z><z id="t1597839349" t="Casey Given a registry map, is there a function that will return a list of the qualified keys in the registry?"><y>#</y><d>2020-08-19</d><h>12:15</h><w>Casey</w>Given a registry map, is there a function that will return a list of the qualified keys in the registry?</z><z id="t1597848925" t="ikitommi no, there isn&apos;t"><y>#</y><d>2020-08-19</d><h>14:55</h><w>ikitommi</w>no, there isn&apos;t</z><z id="t1597903636" t="ikitommi ... but just filter or reduce the keys?"><y>#</y><d>2020-08-20</d><h>06:07</h><w>ikitommi</w>... but just filter or reduce the keys?</z><z id="t1597906812" t="Casey Yup, that&apos;s what I did 🙂"><y>#</y><d>2020-08-20</d><h>07:00</h><w>Casey</w>Yup, that&apos;s what I did <b>🙂</b></z><z id="t1597907034" t="Casey I&apos;m finding malli very useful for client and server side entity validation. When you have an entity that a client can submit, but is only allowed to submit a subset of all possible attributes and the other attributes are populated by the server. In a ns for an entity, I have one main custom registry (which is just a map!) that defines all possible attributes of the entity, then I build little schemas that pick out the &quot;views&quot; of what a valid entity looks like at different stages in its lifecycle."><y>#</y><d>2020-08-20</d><h>07:03</h><w>Casey</w>I&apos;m finding malli very useful for client and server side entity validation. When you have an entity that a client can submit, but is only allowed to submit a subset of all possible attributes and the other attributes are populated by the server. In a ns for an entity, I have one main custom registry (which is just a map!) that defines all possible attributes of the entity, then I build little schemas that pick out the &quot;views&quot; of what a valid entity looks like at different stages in its lifecycle.</z><z id="t1597923925" t="Casey What&apos;s the story behind the name malli, is there one?"><y>#</y><d>2020-08-20</d><h>11:45</h><w>Casey</w>What&apos;s the story behind the name malli, is there one?</z><z id="t1597926524" t="ikitommi https://www.slideshare.net/metosin/malli-inside-datadriven-schemas#21 (slide 21)"><y>#</y><d>2020-08-20</d><h>12:28</h><w>ikitommi</w><a href="https://www.slideshare.net/metosin/malli-inside-datadriven-schemas#21" target="_blank">https://www.slideshare.net/metosin/malli-inside-datadriven-schemas#21</a> (slide 21)</z><z id="t1598015224" t="Casey Following the local registry example at https://github.com/metosin/malli#local-registry calling (malli.core/schema? Adult) =&gt; false . This surprises me.."><y>#</y><d>2020-08-21</d><h>13:07</h><w>Casey</w>Following the local registry example at <a href="https://github.com/metosin/malli#local-registry" target="_blank">https://github.com/metosin/malli#local-registry</a>  calling <code>(malli.core/schema? Adult)</code>  =&gt; <code>false</code> . This surprises me..</z><z id="t1598015363" t="Casey Is it not a schema? Why not?"><y>#</y><d>2020-08-21</d><h>13:09</h><w>Casey</w>Is it not a schema? Why not?</z><z id="t1598015562" t="ikitommi it’s just data?"><y>#</y><d>2020-08-21</d><h>13:12</h><w>ikitommi</w>it’s just data?</z><z id="t1598016210" t="Casey Ah, I see. I see it expects a Schema protocol.... and you can use m/schema to turn the data into a Schema entity"><y>#</y><d>2020-08-21</d><h>13:23</h><w>Casey</w>Ah, I see. I see it expects a Schema protocol.... and you can use <code>m/schema</code> to turn the data into a Schema entity</z><z id="t1598016288" t="ikitommi I think the m/schema? is not that useful, could be removed."><y>#</y><d>2020-08-21</d><h>13:24</h><w>ikitommi</w>I think the <code>m/schema?</code> is not that useful, could be removed.</z><z id="t1598016327" t="ikitommi as most of the functions consume data, Schema or IntoSchema ."><y>#</y><d>2020-08-21</d><h>13:25</h><w>ikitommi</w>as most of the functions consume  data, <code>Schema</code> or <code>IntoSchema</code> .</z><z id="t1598016348" t="Casey m/schema? is used in some fdef specs in gungnir"><y>#</y><d>2020-08-21</d><h>13:25</h><w>Casey</w><code>m/schema?</code> is used in some fdef specs in gungnir</z><z id="t1598357351" t="Elso &quot;No implementation of method: :-form of protocol: #&apos;malli.core/Schema found for class: clojure.core$int_QMARK_&quot; Version bumped from &quot;0.0.1-20200404.091302-14&quot; to &quot;0.0.1-SNAPSHOT&quot;. Validating with (-&gt;&gt; (m/decode schema data mt/string-transformer) (m/explain schema) me/humanize)) and a schema like [:map [:something [:map [:a int?]]] and input data like {:something {:a 10}}"><y>#</y><d>2020-08-25</d><h>12:09</h><w>Elso</w><pre>&quot;No implementation of method: :-form of protocol: #&apos;malli.core/Schema found for class: clojure.core$int_QMARK_&quot;</pre>
Version bumped from &quot;0.0.1-20200404.091302-14&quot; to &quot;0.0.1-SNAPSHOT&quot;.
Validating with
<pre>(-&gt;&gt; (m/decode schema data mt/string-transformer)
     (m/explain schema)
     me/humanize))</pre>
and a schema like
<pre>[:map
  [:something [:map
                [:a int?]]]</pre>
and input data like
<pre>{:something {:a 10}}</pre></z><z id="t1598357399" t="Elso What&apos;s going on here?"><y>#</y><d>2020-08-25</d><h>12:09</h><r>Elso</r>What&apos;s going on here?</z><z id="t1598361565" t="Elso Apparently, my example was not telling the important part and the breaking change was that this: [:map [:issue keyword? :user-endpoint string?]] used to work but is now required to be [:map [:issue keyword?] [:user-endpoint string?]]"><y>#</y><d>2020-08-25</d><h>13:19</h><r>Elso</r>Apparently, my example was not telling the important part and the breaking change was that this:
<code>[:map</code>
  <code>[:issue keyword?</code>
   <code>:user-endpoint string?]]</code>
used to work but is now required to be
<code>[:map</code>
  <code>[:issue keyword?]</code>
  <code>[:user-endpoint string?]]</code></z><z id="t1598361584" t="Elso Which seems quite reasonable"><y>#</y><d>2020-08-25</d><h>13:19</h><r>Elso</r>Which seems quite reasonable</z><z id="t1598370991" t="ikitommi plan is to describe malli schema syntax using malli to get humanized errors on invalid syntax"><y>#</y><d>2020-08-25</d><h>15:56</h><r>ikitommi</r>plan is to describe malli schema syntax using malli to get humanized errors on invalid syntax</z><z id="t1598683143" t="ikitommi 🎉"><y>#</y><d>2020-08-29</d><h>06:39</h><w>ikitommi</w><b>🎉</b></z><z id="t1598786229" t="borkdude Congrats on the CT grant :)"><y>#</y><d>2020-08-30</d><h>11:17</h><w>borkdude</w>Congrats on the CT grant :)</z><z id="t1598786256" t="borkdude Will malli have something like spec/fdef + instrument + unstrument? And will the sequential destructuring be part of the first production release?"><y>#</y><d>2020-08-30</d><h>11:17</h><w>borkdude</w>Will malli have something like spec/fdef + instrument + unstrument? And will the sequential destructuring be part of the first production release?</z><z id="t1598802699" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] the first release is planned to be just the current and (hopefully) immutable core on which everything builds on, Here’s the roadmap for the together funding: 1) get a stable release out! lot&apos;s of small and some bigger design decisions, tracked via metosin/malli#116 2) help early adopters (users and libraries like reitit, regal, aave and gungnir) to upgrade to use the initial version After the release, would work on the following: 3) finalize sequence schemas, 4) enhance developer tooling: - function schemas with clj-kondo integration - pull out and reuse the reitit development time error pretty printer as a separate library () 5) implement pluggable schema inference 6) parsers "><y>#</y><d>2020-08-30</d><h>15:51</h><w>ikitommi</w><a>@borkdude</a> the first release is planned to be just the current and (hopefully) immutable core on which everything builds on, Here’s the roadmap for the together funding:
<pre>1) get a stable release out! lot&apos;s of small and some bigger design decisions, tracked via metosin/malli#116

2) help early adopters (users and libraries like reitit, regal, aave and gungnir) to upgrade to use the initial version

After the release, would work on the following:

3) finalize sequence schemas, 

4) enhance developer tooling: 
  - function schemas with clj-kondo integration 
  - pull out and reuse the reitit development time error pretty printer as a separate library ()

5) implement pluggable schema inference

6) parsers</pre>
</z><z id="t1598802813" t="ikitommi destucturing might be easy to implement using the current explain api, need to visit that for the first release to see will it require changes to the m/explain format."><y>#</y><d>2020-08-30</d><h>15:53</h><w>ikitommi</w>destucturing might be easy to implement using the current explain api, need to visit that for the first release to see will it require changes to the <code>m/explain</code> format.</z><z id="t1598802857" t="ikitommi Vincent has done a great initial work already with the sequence schemas, will dig into that soon."><y>#</y><d>2020-08-30</d><h>15:54</h><w>ikitommi</w>Vincent has done a great initial work already with the sequence schemas, will dig into that soon.</z><z id="t1598986985" t="Vincent Cantin Thx ^_^ I recommend to take the impl from Minimallist as a reference, as it is the most up-to-date and (most importantly) well tested. The work remaining to be done is integration and optimization."><y>#</y><d>2020-09-01</d><h>19:03</h><r>Vincent Cantin</r>Thx ^_^

I recommend to take the impl from Minimallist as a reference, as it is the most up-to-date and (most importantly) well tested.

The work remaining to be done is integration and optimization.</z><z id="t1599039328" t="ikitommi was just about to ask from which codebase should I look this for. Thanks!"><y>#</y><d>2020-09-02</d><h>09:35</h><r>ikitommi</r>was just about to ask from which codebase should I look this for. Thanks!</z><z id="t1599043692" t="Vincent Cantin the latest commit of the main branch all-work-and-no-play"><y>#</y><d>2020-09-02</d><h>10:48</h><r>Vincent Cantin</r>the latest commit of the main branch <code>all-work-and-no-play</code></z><z id="t1598802875" t="ikitommi so, no, but hopefully soon has both."><y>#</y><d>2020-08-30</d><h>15:54</h><w>ikitommi</w>so, no, but hopefully soon has both.</z><z id="t1598802884" t="borkdude :thumbsup:"><y>#</y><d>2020-08-30</d><h>15:54</h><w>borkdude</w><b>:thumbsup:</b></z><z id="t1598803181" t="ikitommi merged https://github.com/metosin/malli/pull/249 . Adds :double ,  `:boolean`,  `:keyword`,  `:symbol`,  `:qualified-keyword`, `:qualified-symbol` and `:uuid`. There is now m/-simple-schema to easily build custom schemas using properties in validation. Could rewrite m/-predicate-schema to use that too."><y>#</y><d>2020-08-30</d><h>15:59</h><w>ikitommi</w>merged <a href="https://github.com/metosin/malli/pull/249" target="_blank">https://github.com/metosin/malli/pull/249</a>. Adds <code>:double</code>,  `:boolean`,  `:keyword`,  `:symbol`,  `:qualified-keyword`, `:qualified-symbol` and `:uuid`. There is now <code>m/-simple-schema</code> to easily build custom schemas using properties in validation. Could rewrite <code>m/-predicate-schema</code> to use that too.</z><z id="t1598854133" t="ikitommi https://github.com/metosin/malli/pull/212 would remove m/map-entries in favor of m/entries retuning a sequence of clojure.lang.MapEntry . m/children is quaranteed to return the tupl-3 of [key properties schema] in the future. This is a breaking change, so comments welcome."><y>#</y><d>2020-08-31</d><h>06:08</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/212" target="_blank">https://github.com/metosin/malli/pull/212</a> would remove <code>m/map-entries</code> in favor of <code>m/entries</code> retuning a sequence of <code>clojure.lang.MapEntry</code>. <code>m/children</code> is quaranteed to return the tupl-3 of <code>[key properties schema]</code> in the future. This is a breaking change, so comments welcome.</z><z id="t1598854234" t="ikitommi relates to 5 issues and 2 PRs, one of the last design decisions that needed re-visiting."><y>#</y><d>2020-08-31</d><h>06:10</h><w>ikitommi</w>relates to 5 issues and 2 PRs, one of the last design decisions that needed re-visiting.</z><z id="t1598993737" t="shaunxcode Have recursive schemas been implemented now? I know there was a ticket (which I cant find right now) where various versions were being discussed."><y>#</y><d>2020-09-01</d><h>20:55</h><w>shaunxcode</w>Have recursive schemas been implemented now? I know there was a ticket (which I cant find right now) where various versions were being discussed.</z><z id="t1598994461" t="jhacks [:attrs {:href &quot;/_/_/users/U07EV8R70&quot;}] It looks like this might be the discussion: https://github.com/metosin/malli/pull/117 and maybe this is the implementation?: https://github.com/metosin/malli/pull/209 but I’m just getting familiar with malli"><y>#</y><d>2020-09-01</d><h>21:07</h><w>jhacks</w><a>@shaunxcode</a> It looks like this might be the discussion: <a href="https://github.com/metosin/malli/pull/117" target="_blank">https://github.com/metosin/malli/pull/117</a> and maybe this is the implementation?: <a href="https://github.com/metosin/malli/pull/209" target="_blank">https://github.com/metosin/malli/pull/209</a>  but I’m just getting familiar with malli</z><z id="t1598994624" t="shaunxcode thanks that is it exactly!"><y>#</y><d>2020-09-01</d><h>21:10</h><w>shaunxcode</w>thanks that is it exactly!</z><z id="t1598994862" t="jhacks [:attrs {:href &quot;/_/_/users/U07EV8R70&quot;}] I just saw this section in the readme: https://github.com/metosin/malli#recursive-schemas which might be helpful too"><y>#</y><d>2020-09-01</d><h>21:14</h><w>jhacks</w><a>@shaunxcode</a> I just saw this section in the readme: <a href="https://github.com/metosin/malli#recursive-schemas" target="_blank">https://github.com/metosin/malli#recursive-schemas</a> which might be helpful too</z><z id="t1598996374" t="jhacks I was following along with this code from the README.md: ;; regexs work too (mg/generate [:re #&quot;^[a-zA-Z0-9._%+-] In order for it to work I needed to explicitly add test.chuck as a dependency, or else I would get this error: Execution error (IllegalStateException) at malli.generator/eval20132$fn (generator.cljc:135). Attempting to call unbound fn: #&apos;malli.generator/-re-gen If that’s the expected behavior (and I didn’t mess something up), maybe it would be good to add a note to the README.md under https://github.com/metosin/malli#value-generation about adding test.chuck as a dependency?"><y>#</y><d>2020-09-01</d><h>21:39</h><w>jhacks</w>I was following along with this code from the README.md:

<pre>;; regexs work too
(mg/generate 
  [:re #&quot;^[a-zA-Z0-9._%+-]</pre>
In order for it to work I needed to explicitly add <code>test.chuck</code> as a dependency, or else I would get this error:

<pre>Execution error (IllegalStateException) at malli.generator/eval20132$fn (generator.cljc:135).
    Attempting to call unbound fn: #&apos;malli.generator/-re-gen</pre>
If that’s the expected behavior (and I didn’t mess something up), maybe it would be good to add a note to the README.md under <a href="https://github.com/metosin/malli#value-generation" target="_blank">https://github.com/metosin/malli#value-generation</a> about adding <code>test.chuck</code> as a dependency?</z><z id="t1599022791" t="ikitommi [:attrs {:href &quot;/_/_/users/U2NNQ4GP9&quot;}] documented the dependency to README and made it fail better: https://github.com/metosin/malli/commit/5c3689fd42f2c73253a0f81a88b23e20a3b6417b"><y>#</y><d>2020-09-02</d><h>04:59</h><w>ikitommi</w><a>@jhacks</a> documented the dependency to README and made it fail better: <a href="https://github.com/metosin/malli/commit/5c3689fd42f2c73253a0f81a88b23e20a3b6417b" target="_blank">https://github.com/metosin/malli/commit/5c3689fd42f2c73253a0f81a88b23e20a3b6417b</a></z><z id="t1599022970" t="ikitommi I believe regal has regex generators for both clj &amp; cljs, could use that instead. It’s still wip according to README: &gt; The following aspects have known issues or are otherwise untested or incomplete, and you can expect them to change significantly as we further develop them: &gt; * Creating test.check generators from regal forms"><y>#</y><d>2020-09-02</d><h>05:02</h><w>ikitommi</w>I believe regal has regex generators for both clj &amp; cljs, could use that instead. It’s still wip according to README:
&gt; The following aspects have known issues or are otherwise untested or incomplete, and you can expect them to change significantly as we further develop them:
&gt; * Creating test.check generators from regal forms</z><z id="t1599023031" t="ikitommi maybe [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] could verify the readiness there? (there is also a schema type for malli in regal, which is awesome!)"><y>#</y><d>2020-09-02</d><h>05:03</h><w>ikitommi</w>maybe <a>@plexus</a> could verify the readiness there? (there is also a schema type for malli in regal, which is awesome!)</z><z id="t1599055741" t="Elso Is there something like nillable in malli? Because (malli.core/validate [:map [:a {:optional true} string?]] {:a nil}) =&gt; false (malli.core/validate [:map [:a {:optional true} string?]] {}) =&gt; true this is rather odd to me."><y>#</y><d>2020-09-02</d><h>14:09</h><w>Elso</w>Is there something like nillable in malli?
Because
<pre>(malli.core/validate [:map [:a {:optional true} string?]] {:a nil})
=&gt; false
(malli.core/validate [:map [:a {:optional true} string?]] {})
=&gt; true</pre>
this is rather odd to me.</z><z id="t1599056024" t="jeroenvandijk I’m wondering if Malli supports lazy registries. I’m guessing it should be possible with the registry protocol. Anyone know of examples?"><y>#</y><d>2020-09-02</d><h>14:13</h><w>jeroenvandijk</w>I’m wondering if Malli supports lazy registries. I’m guessing it should be possible with the registry protocol. Anyone know of examples?</z><z id="t1599056077" t="jeroenvandijk I want to build an AWS Cloudformation validator, but I don’t want to load all schema files upfront. By doing it lazy I hope to win some startup time"><y>#</y><d>2020-09-02</d><h>14:14</h><r>jeroenvandijk</r>I want to build an AWS Cloudformation validator, but I don’t want to load all schema files upfront. By doing it lazy I hope to win some startup time</z><z id="t1599057096" t="ikitommi Sounds like a great idea. Just implement something lazy behind malli.registry/Registry and plug it in."><y>#</y><d>2020-09-02</d><h>14:31</h><r>ikitommi</r>Sounds like a great idea. Just implement something lazy behind <code>malli.registry/Registry</code> and plug it in.</z><z id="t1599057322" t="jeroenvandijk Thanks! I’ll give it a try"><y>#</y><d>2020-09-02</d><h>14:35</h><r>jeroenvandijk</r>Thanks! I’ll give it a try</z><z id="t1599058050" t="jeroenvandijk So the value defines what needs to be looked up. E.g. {:Type &quot;AWS::EC2::Instance&quot; …} would need to be validated with the schema for &quot;AWS::EC2::Instance&quot; , so I need to inspect the value before I know the type. Might make it a bit trickier"><y>#</y><d>2020-09-02</d><h>14:47</h><r>jeroenvandijk</r>So the value defines what needs to be looked up. E.g. <code>{:Type &quot;AWS::EC2::Instance&quot; …}</code> would need to be validated with the schema for  <code>&quot;AWS::EC2::Instance&quot;</code> , so I need to inspect the value before I know the type. Might make it a bit trickier</z><z id="t1599056844" t="jhacks &gt; documented the dependency to README and made it fail better Thanks, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ! 🙌"><y>#</y><d>2020-09-02</d><h>14:27</h><w>jhacks</w>&gt; documented the dependency to README and made it fail better
Thanks, <a>@ikitommi</a>! <b>🙌</b></z><z id="t1599057399" t="ikitommi [:attrs {:href &quot;/_/_/users/UU5KDUCBT&quot;}] (m/validate [:maybe :string] nil) ; =&gt; true (m/validate [:maybe :string] &quot;sheep&quot;) ; =&gt; true"><y>#</y><d>2020-09-02</d><h>14:36</h><w>ikitommi</w><a>@d.eltzner012</a>
<pre>(m/validate [:maybe :string] nil)
; =&gt; true

(m/validate [:maybe :string] &quot;sheep&quot;)
; =&gt; true</pre></z><z id="t1599058372" t="Elso Thanks a lot!"><y>#</y><d>2020-09-02</d><h>14:52</h><r>Elso</r>Thanks a lot!</z><z id="t1599060980" t="jhacks &gt; I believe regal has regex generators for both clj &amp; cljs, could use that instead Wow, thanks for mentioning regal, I was not aware of it: https://github.com/lambdaisland/regal#use-with-malli"><y>#</y><d>2020-09-02</d><h>15:36</h><w>jhacks</w>&gt; I believe regal has regex generators for both clj &amp; cljs, could use that instead
Wow, thanks for mentioning regal, I was not aware of it: <a href="https://github.com/lambdaisland/regal#use-with-malli" target="_blank">https://github.com/lambdaisland/regal#use-with-malli</a></z><z id="t1599110610" t="ikitommi [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] wanted to test the lazy registries. (require &apos;[malli.core :as m]) (require &apos;[malli.registry :as mr]) Given a data-source that can map names to schemas: (def schema-provider {&quot;int&quot; :int &quot;map&quot; [:map [:x &quot;int&quot;]] &quot;maps&quot; [:vector &quot;map&quot;]}) We can compose a registry that uses both local and lazy/external resolving: (defn LazyRegistry [default-registry] (let [cache* (atom {}) registry* (atom nil)] (reset! registry* (mr/composite-registry default-registry (reify mr/Registry (-schema [_ name] (or (@cache* name) (do (println &quot;loading&quot; (pr-str name)) (when-let [schema (schema-provider name)] (swap! cache* assoc name (m/schema schema {:registry @registry*})) schema)))) (-schemas [_] @cache*)))))) (def registry (LazyRegistry m/default-registry)) Using the registry (either swap the m/default-registry or pass as argument: (count (mr/-schemas registry)) ; =&gt; 125 (m/validate &quot;map&quot; {:x 1} {:registry registry}) ;loading &quot;map&quot; ;loading &quot;int&quot; ; =&gt; true (m/validate &quot;map&quot; {:x 1} {:registry registry}) ;; cached ; =&gt; true (count (mr/-schemas registry)) ; =&gt; 127 (m/validate &quot;maps&quot; [{:x 1}] {:registry registry}) ;loading &quot;maps&quot; ; =&gt; true (count (mr/-schemas registry)) ; =&gt; 128 Schemas are first class :ref s: (m/schema &quot;map&quot; {:registry registry}) ; =&gt; &quot;map&quot; (m/-deref (m/schema &quot;map&quot; {:registry registry})) ; =&gt; [:map [:x &quot;int&quot;]] Hope this helps."><y>#</y><d>2020-09-03</d><h>05:23</h><w>ikitommi</w><a>@jeroenvandijk</a> wanted to test the lazy registries.

<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.registry :as mr])</pre>
Given a data-source that can map names to schemas:
<pre>(def schema-provider
  {&quot;int&quot; :int
   &quot;map&quot; [:map [:x &quot;int&quot;]]
   &quot;maps&quot; [:vector &quot;map&quot;]})</pre>
We can compose a registry that uses both local and lazy/external resolving:
<pre>(defn LazyRegistry [default-registry]
  (let [cache* (atom {})
        registry* (atom nil)]
    (reset!
      registry*
      (mr/composite-registry
        default-registry
        (reify
          mr/Registry
          (-schema [_ name]
            (or (@cache* name)
                (do (println &quot;loading&quot; (pr-str name))
                    (when-let [schema (schema-provider name)]
                      (swap! cache* assoc name (m/schema schema {:registry @registry*}))
                      schema))))
          (-schemas [_] @cache*))))))

(def registry (LazyRegistry m/default-registry))</pre>
Using the registry (either swap the <code>m/default-registry</code> or pass as argument:
<pre>(count (mr/-schemas registry))
; =&gt; 125

(m/validate &quot;map&quot; {:x 1} {:registry registry})
;loading &quot;map&quot;
;loading &quot;int&quot;
; =&gt; true

(m/validate &quot;map&quot; {:x 1} {:registry registry}) ;; cached
; =&gt; true

(count (mr/-schemas registry))
; =&gt; 127

(m/validate &quot;maps&quot; [{:x 1}] {:registry registry})
;loading &quot;maps&quot;
; =&gt; true

(count (mr/-schemas registry))
; =&gt; 128</pre>
Schemas are first class <code>:ref</code>s:
<pre>(m/schema &quot;map&quot; {:registry registry})
; =&gt; &quot;map&quot;

(m/-deref (m/schema &quot;map&quot; {:registry registry}))
; =&gt; [:map [:x &quot;int&quot;]]</pre>
Hope this helps.</z><z id="t1599119788" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks for sharing. I think it’s almost what I need. I’m puzzling how to deal with the (lazy) dispatch on a map key. In clojure.spec I would use multimethods and multispec: (defmulti resource-type :Type) (s/def :aws.cfn/resource (s/multi-spec resource-type :Type)) ;; Some random examples (defmethod resource-type &quot;AWS::AmazonMQ::Broker&quot; [_] :aws.amazon-mq/broker) (defmethod resource-type &quot;AWS::AmazonMQ::Configuration&quot; [_] :aws.amazon-mq/configuration) (defmethod resource-type &quot;AWS::ApiGateway::Account&quot; [_] :aws.api-gateway/account) (defmethod resource-type &quot;AWS::ApiGateway::ApiKey&quot; [_] :aws.api-gateway/api-key) ... If I can do this dispatch somehow, with your suggestion I think I have all I need"><y>#</y><d>2020-09-03</d><h>07:56</h><w>jeroenvandijk</w><a>@ikitommi</a> Thanks for sharing. I think it’s almost what I need. I’m puzzling how to deal with the (lazy) dispatch on a map key. In <code>clojure.spec</code> I would use multimethods and multispec:

<pre>(defmulti resource-type :Type)

(s/def :aws.cfn/resource (s/multi-spec resource-type :Type))

;; Some random examples
(defmethod resource-type &quot;AWS::AmazonMQ::Broker&quot; [_] :aws.amazon-mq/broker)
(defmethod resource-type &quot;AWS::AmazonMQ::Configuration&quot; [_] :aws.amazon-mq/configuration)
(defmethod resource-type &quot;AWS::ApiGateway::Account&quot; [_] :aws.api-gateway/account)
(defmethod resource-type &quot;AWS::ApiGateway::ApiKey&quot; [_] :aws.api-gateway/api-key)
...</pre>
If I can do this dispatch somehow, with your suggestion I think I have all I need</z><z id="t1599120169" t="jeroenvandijk I’ll study the :multi schema and see if that is the missing piece"><y>#</y><d>2020-09-03</d><h>08:02</h><w>jeroenvandijk</w>I’ll study the <code>:multi</code> schema and see if that is the missing piece</z><z id="t1599120526" t="ikitommi s/multi-spec is open &amp; mutable, :multi is closed &amp; immutable."><y>#</y><d>2020-09-03</d><h>08:08</h><w>ikitommi</w><code>s/multi-spec</code> is open &amp; mutable, <code>:multi</code> is closed &amp; immutable.</z><z id="t1599120580" t="ikitommi so here, I think a lazy multi variant would be needed."><y>#</y><d>2020-09-03</d><h>08:09</h><w>ikitommi</w>so here, I think a lazy multi variant would be needed.</z><z id="t1599120735" t="ikitommi a) lazy multi, with immutable values [:multi {:dispatch :type, :children children-fn}] b) mutable multi, backed by a custom (mutable) multimethod: [:multi {:dispatch :type, :children my-multimethod}]"><y>#</y><d>2020-09-03</d><h>08:12</h><w>ikitommi</w>a) lazy multi, with immutable values
<pre>[:multi {:dispatch :type, :children children-fn}]</pre>
b) mutable multi, backed by a custom (mutable) multimethod:
<pre>[:multi {:dispatch :type, :children my-multimethod}]</pre></z><z id="t1599120778" t="ikitommi … actually would be the same code, it’s in user-space whether to allow overriding the keys."><y>#</y><d>2020-09-03</d><h>08:12</h><w>ikitommi</w>… actually would be the same code, it’s in user-space whether to allow overriding the keys.</z><z id="t1599120796" t="ikitommi should not be many loc to implement"><y>#</y><d>2020-09-03</d><h>08:13</h><w>ikitommi</w>should not be many loc to implement</z><z id="t1599121777" t="jeroenvandijk Thanks. Makes sense. I’ll try to adapt https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L796"><y>#</y><d>2020-09-03</d><h>08:29</h><w>jeroenvandijk</w>Thanks. Makes sense. I’ll try to adapt <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L796" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L796</a></z><z id="t1599122455" t="ikitommi If you make a PR, would like that the default case (e.g. no :children key set) will not slow down -&gt; the entry parsing will happen at schema creation time. for the case of dynamic childs - it would happen at runtime."><y>#</y><d>2020-09-03</d><h>08:40</h><w>ikitommi</w>If you make a PR, would like that the default case (e.g. no <code>:children</code> key set) will not slow down -&gt; the entry parsing will happen at schema creation time. for the case of dynamic childs - it would happen at runtime.</z><z id="t1599122509" t="ikitommi one question is: what happens if you create a validator, explainer or generator out of that schema: should the current children be used or should those be dynamic too."><y>#</y><d>2020-09-03</d><h>08:41</h><w>ikitommi</w>one question is: what happens if you create a validator, explainer or generator out of that schema: should the current children be used or should those be dynamic too.</z><z id="t1599122548" t="ikitommi e.g. if you add a branch after creating a validator, will the validators before that see it or not."><y>#</y><d>2020-09-03</d><h>08:42</h><w>ikitommi</w>e.g. if you add a branch after creating a validator, will the validators before that see it or not.</z><z id="t1599122738" t="jeroenvandijk With clojure.spec I have one spec that contains all types. This gives you a suggestion in case the dispatch on type fails. E.g. (s/def :cfn.all/Type #{&quot;AWS::AmazonMQ::Broker&quot; &quot;AWS::AmazonMQ::Configuration&quot; &quot;AWS::ApiGateway::Account&quot; &quot;AWS::ApiGateway::ApiKey&quot; &quot;AWS::ApiGateway::Authorizer&quot; &quot;AWS::ApiGateway::BasePathMapping&quot; &quot;AWS::ApiGateway::ClientCertificate&quot; .....}) This is not ideal either because it doesn’t have spell-check functionality. But to answer your question, I don’t think, at least for my use case, everything has to be dynamic"><y>#</y><d>2020-09-03</d><h>08:45</h><w>jeroenvandijk</w>With <code>clojure.spec</code> I have one spec that contains all types. This gives you a suggestion in case the dispatch on type fails. E.g.
<pre>(s/def :cfn.all/Type #{&quot;AWS::AmazonMQ::Broker&quot; &quot;AWS::AmazonMQ::Configuration&quot; &quot;AWS::ApiGateway::Account&quot; &quot;AWS::ApiGateway::ApiKey&quot; &quot;AWS::ApiGateway::Authorizer&quot; &quot;AWS::ApiGateway::BasePathMapping&quot; &quot;AWS::ApiGateway::ClientCertificate&quot; .....})</pre>
This is not ideal either because it doesn’t have spell-check functionality. But to answer your question, I don’t think, at least for my use case, everything has to be dynamic</z><z id="t1599143980" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] The start of this seems to be simple indeed https://gist.github.com/jeroenvandijk/59d22a726cda2158c01b9d63790aec50#file-malli_lazy-clj-L80 I’ve only added the validator part, not sure if the transformers and explainers will make things more painful"><y>#</y><d>2020-09-03</d><h>14:39</h><w>jeroenvandijk</w><a>@ikitommi</a> The start of this seems to be simple indeed <a href="https://gist.github.com/jeroenvandijk/59d22a726cda2158c01b9d63790aec50#file-malli_lazy-clj-L80" target="_blank">https://gist.github.com/jeroenvandijk/59d22a726cda2158c01b9d63790aec50#file-malli_lazy-clj-L80</a> I’ve only added the validator part, not sure if the transformers and explainers will make things more painful</z><z id="t1599148633" t="ikitommi [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] just to Make sure: you do know all the possible dispatch keys in advance?"><y>#</y><d>2020-09-03</d><h>15:57</h><w>ikitommi</w><a>@jeroenvandijk</a> just to Make sure: you do know all the possible dispatch keys in advance?</z><z id="t1599148653" t="ikitommi (if so, there might be a simpler solution)"><y>#</y><d>2020-09-03</d><h>15:57</h><w>ikitommi</w>(if so, there might be a simpler solution)</z><z id="t1599149836" t="jeroenvandijk Yeah all the dispatch types are known in this case. The raw schema data is close to 1mb. So that&apos;s the main reason to do it lazy"><y>#</y><d>2020-09-03</d><h>16:17</h><w>jeroenvandijk</w>Yeah all the dispatch types are known in this case. The raw schema data is close to 1mb. So that&apos;s the main reason to do it lazy</z><z id="t1599160369" t="ikitommi [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] This would be a small change in :ref impl: (defn LazyRegistry [default-registry f] (let [cache* (atom {}) registry* (atom nil)] (reset! registry* (mr/composite-registry default-registry (reify mr/Registry (-schema [_ name] (or (@cache* name) (do (println &quot;loading&quot; (pr-str name)) (when-let [schema (f name)] (swap! cache* assoc name (m/schema schema {:registry @registry*})) schema)))) (-schemas [_] @cache*)))))) (def registry (LazyRegistry m/default-registry {&quot;map1&quot; [:map [:type [:= &quot;map1&quot;]] [:x :int]] &quot;map2&quot; [:map [:type [:= &quot;map2&quot;]] [:y :int]] &quot;map3&quot; [:map [:type [:= &quot;map3&quot;]] [:z :int]]})) (m/validate [:multi {:dispatch :type} [&quot;map1&quot; [:ref &quot;map1&quot;]] [&quot;map2&quot; [:ref &quot;map2&quot;]] [&quot;map3&quot; [:ref &quot;map3&quot;]]] {:type &quot;map3&quot;, :z 1} {:registry registry ::m/lazy-refs true}) ;loading &quot;map3&quot; ;=&gt; true"><y>#</y><d>2020-09-03</d><h>19:12</h><w>ikitommi</w><a>@jeroenvandijk</a> This would be a small change in <code>:ref</code> impl:

<pre>(defn LazyRegistry [default-registry f]
  (let [cache* (atom {})
        registry* (atom nil)]
    (reset!
      registry*
      (mr/composite-registry
        default-registry
        (reify
          mr/Registry
          (-schema [_ name]
            (or (@cache* name)
                (do (println &quot;loading&quot; (pr-str name))
                    (when-let [schema (f name)]
                      (swap! cache* assoc name (m/schema schema {:registry @registry*}))
                      schema))))
          (-schemas [_] @cache*))))))

(def registry
  (LazyRegistry
    m/default-registry
    {&quot;map1&quot; [:map [:type [:= &quot;map1&quot;]] [:x :int]]
     &quot;map2&quot; [:map [:type [:= &quot;map2&quot;]] [:y :int]]
     &quot;map3&quot; [:map [:type [:= &quot;map3&quot;]] [:z :int]]}))

(m/validate
  [:multi {:dispatch :type}
   [&quot;map1&quot; [:ref &quot;map1&quot;]]
   [&quot;map2&quot; [:ref &quot;map2&quot;]]
   [&quot;map3&quot; [:ref &quot;map3&quot;]]]
  {:type &quot;map3&quot;, :z 1}
  {:registry registry
   ::m/lazy-refs true})
;loading &quot;map3&quot;
;=&gt; true</pre></z><z id="t1599160480" t="ikitommi new option :malli.core/lazy-refs that would control if the :ref s are checked eagerly or lazily"><y>#</y><d>2020-09-03</d><h>19:14</h><w>ikitommi</w>new option <code>:malli.core/lazy-refs</code> that would control if the <code>:ref</code>s are checked eagerly or lazily</z><z id="t1599160510" t="ikitommi or there could be a :lazy variant of :ref to make things explicit."><y>#</y><d>2020-09-03</d><h>19:15</h><w>ikitommi</w>or there could be a <code>:lazy</code> variant of <code>:ref</code> to make things explicit.</z><z id="t1599160583" t="ikitommi or a new property :lazy to :ref to mark it being lazy: [:ref &quot;map1&quot;] [:ref {:lazy true} &quot;map1&quot;]"><y>#</y><d>2020-09-03</d><h>19:16</h><w>ikitommi</w>or a new property <code>:lazy</code> to  <code>:ref</code> to mark it being lazy:
<pre>[:ref &quot;map1&quot;]

[:ref {:lazy true} &quot;map1&quot;]</pre></z><z id="t1599160610" t="ikitommi I think that’s actually good."><y>#</y><d>2020-09-03</d><h>19:16</h><w>ikitommi</w>I think that’s actually good.</z><z id="t1599161016" t="ikitommi https://github.com/metosin/malli/pull/252"><y>#</y><d>2020-09-03</d><h>19:23</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/252" target="_blank">https://github.com/metosin/malli/pull/252</a></z><z id="t1599163551" t="ikitommi actually, we can push all the changes from user api (e.f. schema props) into extender api (here: lazy registry impl). This allows to write fully lazy multis: [:multi {:dispatch :type} &quot;AWS::AmazonMQ::Broker&quot; &quot;AWS::AmazonMQ::Configuration&quot; &quot;AWS::ApiGateway::Account&quot; &quot;AWS::ApiGateway::ApiKey&quot; &quot;AWS::ApiGateway::Authorizer&quot;]"><y>#</y><d>2020-09-03</d><h>20:05</h><w>ikitommi</w>actually, we can push all the changes from user api (e.f. schema props) into extender api (here: lazy registry impl). This allows to write fully lazy multis:

<pre>[:multi {:dispatch :type}
 &quot;AWS::AmazonMQ::Broker&quot;         
 &quot;AWS::AmazonMQ::Configuration&quot;
 &quot;AWS::ApiGateway::Account&quot;
 &quot;AWS::ApiGateway::ApiKey&quot;
 &quot;AWS::ApiGateway::Authorizer&quot;]</pre></z><z id="t1599163673" t="ikitommi (`:multi` uses the entry-syntax, like :map which allows single-value elements if they are valid schema reference types, now: just qualified keywords, should be strings too)"><y>#</y><d>2020-09-03</d><h>20:07</h><w>ikitommi</w>(`:multi` uses the entry-syntax, like <code>:map</code> which allows single-value elements if they are valid schema reference types, now: just qualified keywords, should be strings too)</z><z id="t1599209170" t="ikitommi"><y>#</y><d>2020-09-04</d><h>08:46</h><w>ikitommi</w></z><z id="t1599209221" t="ikitommi that look ok [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] ?"><y>#</y><d>2020-09-04</d><h>08:47</h><w>ikitommi</w>that look ok <a>@jeroenvandijk</a>?</z><z id="t1599209297" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] it looks perfect! I need to wrap my head around it, but the demo looks exactly what I want. I’ll try to convert a spec project today and give some feedback"><y>#</y><d>2020-09-04</d><h>08:48</h><w>jeroenvandijk</w><a>@ikitommi</a> it looks perfect! I need to wrap my head around it, but the demo looks exactly what I want. I’ll try to convert a spec project today and give some feedback</z><z id="t1599209709" t="ikitommi great! changes in the core are in this commit: https://github.com/metosin/malli/pull/252/commits/3a5c7f35141e32eea3b374b6a81e706377a44d26 , need to add polish the code before merging in, most likely this week."><y>#</y><d>2020-09-04</d><h>08:55</h><w>ikitommi</w>great! changes in the core are in this commit: <a href="https://github.com/metosin/malli/pull/252/commits/3a5c7f35141e32eea3b374b6a81e706377a44d26" target="_blank">https://github.com/metosin/malli/pull/252/commits/3a5c7f35141e32eea3b374b6a81e706377a44d26</a>, need to add polish the code before merging in, most likely this week.</z><z id="t1599237485" t="jeroenvandijk Does Malli have an equivalent of (clojure.spec.alpha/map-of string? string) .e.g {&quot;any-string-key&quot; &quot;any-string-value&quot;} ?"><y>#</y><d>2020-09-04</d><h>16:38</h><w>jeroenvandijk</w>Does Malli have an equivalent of <code>(clojure.spec.alpha/map-of string? string)</code> .e.g <code>{&quot;any-string-key&quot; &quot;any-string-value&quot;}</code> ?</z><z id="t1599238289" t="jeroenvandijk As an alternative this seems to work: (require &apos;[malli.core :as m]) (defn map-of [k v] (clojure.walk/postwalk-replace {::k k ::v v} &apos;[:fn (fn [x] (and (map? x) (every? (fn [[k v]] (::k k) (::v v)) x)))])) (m/validate (map-of &apos;string? &apos;string?) {:a 1}) "><y>#</y><d>2020-09-04</d><h>16:51</h><r>jeroenvandijk</r>As an alternative this seems to work:
<pre>(require &apos;[malli.core :as m])

(defn map-of [k v]
  (clojure.walk/postwalk-replace
   {::k k
    ::v v}
   &apos;[:fn (fn [x] (and (map? x)
                     (every? (fn [[k v]]
                               (::k k)
                               (::v v))
                             x)))]))

(m/validate (map-of &apos;string? &apos;string?) {:a 1})</pre>
</z><z id="t1599238991" t="ikitommi [:map-of string? string?]"><y>#</y><d>2020-09-04</d><h>17:03</h><r>ikitommi</r><code>[:map-of string? string?]</code></z><z id="t1599239079" t="jeroenvandijk ah 🙂"><y>#</y><d>2020-09-04</d><h>17:04</h><r>jeroenvandijk</r>ah <b>🙂</b></z><z id="t1599239086" t="jeroenvandijk Thanks"><y>#</y><d>2020-09-04</d><h>17:04</h><r>jeroenvandijk</r>Thanks</z><z id="t1599239723" t="jeroenvandijk Would it make sense to add validation on the schema definition? e.g. i did this in a nested schema (m/validate &apos;[:map string? string?] {}) I had no idea of course and I was looking for the place that was causing this message java.lang.UnsupportedOperationException: count not supported on this type: Symbol"><y>#</y><d>2020-09-04</d><h>17:15</h><r>jeroenvandijk</r>Would it make sense to add validation on the schema definition? e.g. i did this in a nested schema
<pre>(m/validate &apos;[:map string? string?] {})</pre>
I had no idea of course and I was looking for the place that was causing this message
<pre>java.lang.UnsupportedOperationException: count not supported on this type: Symbol</pre></z><z id="t1599242690" t="ikitommi IntoSchema protocol will have a methods that describe both children and properties as malli schemas. After that, malli validates the malli schemas :) That requires the regex-schemas, which is the next thing. So, yes, but not yet."><y>#</y><d>2020-09-04</d><h>18:04</h><r>ikitommi</r><code>IntoSchema</code> protocol will have a methods that describe both children and properties as malli schemas. After that, malli validates the malli schemas :) That requires the regex-schemas, which is the next thing. So, yes, but not yet.</z><z id="t1599242794" t="ikitommi not sure if there is an issue of that, should be."><y>#</y><d>2020-09-04</d><h>18:06</h><r>ikitommi</r>not sure if there is an issue of that, should be.</z><z id="t1599241159" t="jeroenvandijk I was thinking of trying the non-lazy approach first, but I think the lazy version will be easier to debug 😅 I can print what faulty schema is being loaded just before it crashes"><y>#</y><d>2020-09-04</d><h>17:39</h><w>jeroenvandijk</w>I was thinking of trying the non-lazy approach first, but I think the lazy version will be easier to debug <b>😅</b> I can print what faulty schema is being loaded just before it crashes</z><z id="t1599243830" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] So far the lazyness works really nice. I’ll let you know when I’m done"><y>#</y><d>2020-09-04</d><h>18:23</h><w>jeroenvandijk</w><a>@ikitommi</a> So far the lazyness works really nice. I’ll let you know when I’m done</z><z id="t1599244906" t="jeroenvandijk Is it possible to somehow add the spellcheck on the dispatch as well? Would be super fancy 🙂 E.g. when I type &quot;AWS::AppSync::ApiK&quot; ==&gt; you misspelled &quot;AWS::AppSync::ApiKey&quot;"><y>#</y><d>2020-09-04</d><h>18:41</h><w>jeroenvandijk</w>Is it possible to somehow add the spellcheck on the dispatch as well? Would be super fancy <b>🙂</b> E.g. when I type
<pre>&quot;AWS::AppSync::ApiK&quot; ==&gt; you misspelled &quot;AWS::AppSync::ApiKey&quot;</pre></z><z id="t1599244992" t="jeroenvandijk I’ve added a try/catch around the schema loading. Makes it much easier to debug a wrong definition: (fn [type registry] (let [definition (lookup-fn type) schema (when definition (try (m/schema definition {:registry registry}) (catch Exception e (throw (ex-info (str &quot;Error while loading &quot; type &quot;: &quot; (pr-str (ex-message e))) {:definition definition}))) ))] (println &quot;loaded&quot; (pr-str type)) schema))"><y>#</y><d>2020-09-04</d><h>18:43</h><w>jeroenvandijk</w>I’ve added a try/catch around the schema loading. Makes it much easier to debug a wrong definition:
<pre>(fn [type registry]
    (let [definition (lookup-fn type)
          schema (when definition
                   (try
                     (m/schema definition {:registry registry})
                     (catch Exception e

                       (throw (ex-info (str &quot;Error while loading &quot; type &quot;: &quot; (pr-str (ex-message e))) {:definition definition})))
                     ))]
      (println &quot;loaded&quot; (pr-str type))
      schema))</pre></z><z id="t1599247363" t="ikitommi should be possible. The spell checking reads the explain output. Just need to ensure :multi emits error on invalid dispatch key that the spell checker understands. Internally, :map and :multi both use the entry-syntax, so might be just few loc."><y>#</y><d>2020-09-04</d><h>19:22</h><w>ikitommi</w>should be possible. The spell checking reads the explain output. Just need to ensure <code>:multi</code> emits error on invalid dispatch key that the spell checker understands. Internally, <code>:map</code> and <code>:multi</code> both use the entry-syntax, so might be just few loc.</z><z id="t1599248341" t="jeroenvandijk As far as I can see the spelling feature is focussed on the misspelling of keys and not of values. I probably missing something though. I was missing this spelling on values also when I was spec with expound and spell-check. Maybe it’s a different kind of problem"><y>#</y><d>2020-09-04</d><h>19:39</h><r>jeroenvandijk</r>As far as I can see the spelling feature is focussed on the misspelling of keys and not of values. I probably missing something though. I was missing this spelling on values also when I was spec with expound and spell-check. Maybe it’s a different kind of problem</z><z id="t1599248829" t="jeroenvandijk ah wait i think i see some pointers"><y>#</y><d>2020-09-04</d><h>19:47</h><r>jeroenvandijk</r>ah wait i think i see some pointers</z><z id="t1599247481" t="ikitommi next step would be to make clj-kondo use malli somehow, so we would get static inspection."><y>#</y><d>2020-09-04</d><h>19:24</h><w>ikitommi</w>next step would be to make clj-kondo use malli somehow, so we would get static inspection.</z><z id="t1599247521" t="ikitommi and the next would be to have auto-complete via lsp."><y>#</y><d>2020-09-04</d><h>19:25</h><w>ikitommi</w>and the next would be to have auto-complete via lsp.</z><z id="t1599273795" t="rutledgepaulv I was wondering if lsp integration was in the cards 🙂 I would love to be able to write a malli schema and from it receive strong editor support for data that needs to conform to that schema (like some tools provide for xsd)."><y>#</y><d>2020-09-05</d><h>02:43</h><r>rutledgepaulv</r>I was wondering if lsp integration was in the cards <b>🙂</b> I would love to be able to write a malli schema and from it receive strong editor support for data that needs to conform to that schema (like some tools provide for xsd).</z><z id="t1599247580" t="ikitommi (no idea how to do the last, clj-kondo should be fun to try)"><y>#</y><d>2020-09-04</d><h>19:26</h><w>ikitommi</w>(no idea how to do the last, clj-kondo should be fun to try)</z><z id="t1599248204" t="jeroenvandijk Sounds awesome!"><y>#</y><d>2020-09-04</d><h>19:36</h><w>jeroenvandijk</w>Sounds awesome!</z><z id="t1599249702" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] is this related to what you showed on ClojureD? I&apos;m not sure what you mean by clj-kondo using malli"><y>#</y><d>2020-09-04</d><h>20:01</h><w>borkdude</w><a>@ikitommi</a> is this related to what you showed on ClojureD? I&apos;m not sure what you mean by clj-kondo using malli</z><z id="t1599292137" t="ikitommi The demo on ClojureD was schematized malli fn&apos;s emitting clj-kondo type definitions. I&apos;ll make a real impl out of that now with the clj-together funding. Not the first thing, but will most likely need help with that [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] , will poke you when about to do that. The second thing, which would be a nice experiment is if malli itself could be used inside clj-kondo to validate both malli data and schemas, e.g. (do-it {:Type &quot;AWS::AppSync::ApiKey&quot; :Descriptionz &quot;kikka&quot;}) .. would emit clj-kondo errors: {:ApiId [&quot;missing required key&quot;] :Descriptionz [&quot;should be spelled :Description&quot;]}"><y>#</y><d>2020-09-05</d><h>07:48</h><w>ikitommi</w>The demo on ClojureD was schematized malli fn&apos;s emitting clj-kondo type definitions. I&apos;ll make a real impl out of that now with the clj-together funding. Not the first thing, but will most likely need help with that <a>@borkdude</a>, will poke you when about to do that.

The second thing, which would be a nice experiment is if malli itself could be used inside clj-kondo to validate both malli data and schemas, e.g.

<pre>(do-it {:Type &quot;AWS::AppSync::ApiKey&quot;
        :Descriptionz &quot;kikka&quot;})
</pre>
..  would emit clj-kondo errors:

<pre>{:ApiId [&quot;missing required key&quot;]
 :Descriptionz [&quot;should be spelled :Description&quot;]}</pre></z><z id="t1599292270" t="ikitommi autocomplete-stuff: I don&apos;t know how to do those, and most likely don&apos;t have to study that, but happy to help on Malli side if someone want&apos;s to try that out"><y>#</y><d>2020-09-05</d><h>07:51</h><w>ikitommi</w>autocomplete-stuff: I don&apos;t know how to do those, and most likely don&apos;t have to study that, but happy to help on Malli side if someone want&apos;s to try that out</z><z id="t1599294429" t="ikitommi with the :multi dispatch key validation, it would yield: (do-it {:Type &quot;AWS::ApiGatway::UsagePlan&quot; :Description &quot;kikka&quot; :UsagePlanName &quot;kukka&quot;} .. would emit clj-kondo errors: {:Type [&quot;should be spelled \&quot;AWS::ApiGateway::UsagePlan\&quot;&quot;]}"><y>#</y><d>2020-09-05</d><h>08:27</h><w>ikitommi</w>with the <code>:multi</code> dispatch key validation, it would yield:

<pre>(do-it {:Type &quot;AWS::ApiGatway::UsagePlan&quot;
        :Description &quot;kikka&quot;
        :UsagePlanName &quot;kukka&quot;}
</pre>
..  would emit clj-kondo errors:

<pre>{:Type [&quot;should be spelled \&quot;AWS::ApiGateway::UsagePlan\&quot;&quot;]}</pre></z><z id="t1599294558" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I tried a similar thing using the type system in clj-kondo. It can be done, but it only works at places where literal maps are passed. So when you use assoc et al, it already breaks (although I think I have some logic which tries to account for that, it&apos;s been a while)"><y>#</y><d>2020-09-05</d><h>08:29</h><w>borkdude</w><a>@ikitommi</a> I tried a similar thing using the type system in clj-kondo. It can be done, but it only works at places where literal maps are passed. So when you use assoc et al, it already breaks (although I think I have some logic which tries to account for that, it&apos;s been a while)</z><z id="t1599294597" t="borkdude as an experiment, it&apos;d be interesting what comes out of it"><y>#</y><d>2020-09-05</d><h>08:29</h><w>borkdude</w>as an experiment, it&apos;d be interesting what comes out of it</z><z id="t1599294745" t="borkdude I recently listened to a podcast with Tony Kay. He is working on something similar called GuardRails Pro which will be closed source"><y>#</y><d>2020-09-05</d><h>08:32</h><w>borkdude</w>I recently listened to a podcast with Tony Kay. He is working on something similar called GuardRails Pro which will be closed source</z><z id="t1599294789" t="borkdude It would be great to have a free alternative"><y>#</y><d>2020-09-05</d><h>08:33</h><w>borkdude</w>It would be great to have a free alternative</z><z id="t1599311601" t="ikitommi Looked up and listened the ClojureScript Podcast about GRP, sounds interesting."><y>#</y><d>2020-09-05</d><h>13:13</h><w>ikitommi</w>Looked up and listened the ClojureScript Podcast about GRP, sounds interesting.</z><z id="t1599311674" t="ikitommi Interesting times ahead, sounds like Clojure is getting mature :)"><y>#</y><d>2020-09-05</d><h>13:14</h><w>ikitommi</w>Interesting times ahead, sounds like Clojure is getting mature :)</z><z id="t1599312783" t="ikitommi [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] small changes: • :dispatch is mandatory in :multi , e.g. can’t set via Schema creations opts =&gt; this makes it visible for error handling • malli.error/with-spell-checking now understands :multi dispatch values if the :dispatch value is a keyword"><y>#</y><d>2020-09-05</d><h>13:33</h><w>ikitommi</w><a>@jeroenvandijk</a> small changes:
• <code>:dispatch</code> is mandatory in <code>:multi</code>, e.g.  can’t set via Schema creations opts =&gt; this makes it visible for error handling
• <code>malli.error/with-spell-checking</code> now understands  <code>:multi</code> dispatch values if the <code>:dispatch</code> value is a keyword</z><z id="t1599312783" t="ikitommi https://github.com/metosin/malli/pull/252/commits/fecd792d02e20a9a22730ea0163b661c539eaa79"><y>#</y><d>2020-09-05</d><h>13:33</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/252/commits/fecd792d02e20a9a22730ea0163b661c539eaa79" target="_blank">https://github.com/metosin/malli/pull/252/commits/fecd792d02e20a9a22730ea0163b661c539eaa79</a></z><z id="t1599312809" t="ikitommi (-&gt; (m/explain Schema {:Type &quot;AWS::AppSync::ApiKey&quot; :Descriptionz &quot;kikka&quot;}) (me/with-spell-checking) (me/humanize)) ; loaded &quot;AWS::AppSync::ApiKey&quot; ; =&gt; {:ApiId [&quot;missing required key&quot;] ; :Descriptionz [&quot;should be spelled :Description&quot;]} (-&gt; Schema (m/explain {:Type &quot;AWS::ApiGatway::UsagePlan&quot; :Description &quot;kikka&quot; :UsagePlanName &quot;kukka&quot;}) (me/with-spell-checking) (me/humanize)) ; =&gt; {:Type [&quot;did you mean AWS::ApiGateway::UsagePlan&quot;]}"><y>#</y><d>2020-09-05</d><h>13:33</h><w>ikitommi</w><pre>(-&gt; (m/explain
      Schema
      {:Type &quot;AWS::AppSync::ApiKey&quot;
       :Descriptionz &quot;kikka&quot;})
    (me/with-spell-checking)
    (me/humanize))
; loaded &quot;AWS::AppSync::ApiKey&quot;
; =&gt; {:ApiId [&quot;missing required key&quot;]
;     :Descriptionz [&quot;should be spelled :Description&quot;]}

(-&gt; Schema
    (m/explain
      {:Type &quot;AWS::ApiGatway::UsagePlan&quot;
       :Description &quot;kikka&quot;
       :UsagePlanName &quot;kukka&quot;})
    (me/with-spell-checking)
    (me/humanize))
; =&gt; {:Type [&quot;did you mean AWS::ApiGateway::UsagePlan&quot;]}</pre></z><z id="t1599312935" t="ikitommi full gist here: https://gist.github.com/ikitommi/06143540e6259323b95253e87e1ef710"><y>#</y><d>2020-09-05</d><h>13:35</h><w>ikitommi</w>full gist here: <a href="https://gist.github.com/ikitommi/06143540e6259323b95253e87e1ef710" target="_blank">https://gist.github.com/ikitommi/06143540e6259323b95253e87e1ef710</a></z><z id="t1599313248" t="jeroenvandijk Wow, super nice. Thanks!"><y>#</y><d>2020-09-05</d><h>13:40</h><w>jeroenvandijk</w>Wow, super nice. Thanks!</z><z id="t1599460421" t="ikitommi first spike of heterogenous sequences, aka “regex schemas”. Looked into seqexp, clojure.spec and minimallist for inspiration. Slicing a [1 2 3 &quot;4&quot; &quot;5&quot; 6 7 8 9 &quot;10&quot;] sequence with spec-equivalient: (s/cat :1 (s/+ int?) :2 (s/+ string?) :3 (s/+ int?) :4 (s/+ string?)) in malli, it would be: [:catn [:1 [:+ int?]] [:2 [:+ string?]] [:3 [:+ int?]] [:4 [:+ string?]]] or anonymus (uses vector indexes as keys) [:cat [:+ int?] [:+ string?] [:+ int?] [:+ string?]] some silly perf numbers with 10000 &amp; time (and intermediate results): Malli: {:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]} &quot;Elapsed time: 35.535477 msecs&quot; Minimallist: {:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]} &quot;Elapsed time: 386.464772 msecs&quot; Seqexp: {:rest (), :match (1 2 3 &quot;4&quot; &quot;5&quot; 6 7 8 9 &quot;10&quot;), :1 (1 2 3), :2 (&quot;4&quot; &quot;5&quot;), :3 (6 7 8 9), :4 (&quot;10&quot;)} &quot;Elapsed time: 686.08428 msecs&quot; Clojure.Spec: {:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]} &quot;Elapsed time: 879.329458 msecs&quot;"><y>#</y><d>2020-09-07</d><h>06:33</h><w>ikitommi</w>first spike of heterogenous sequences, aka “regex schemas”. Looked into seqexp, clojure.spec and minimallist for inspiration. Slicing a <code>[1 2 3 &quot;4&quot; &quot;5&quot; 6 7 8 9 &quot;10&quot;]</code> sequence with spec-equivalient:
<pre>(s/cat :1 (s/+ int?)
       :2 (s/+ string?)
       :3 (s/+ int?)
       :4 (s/+ string?))</pre>
in malli, it would be:
<pre>[:catn
  [:1 [:+ int?]]
  [:2 [:+ string?]]
  [:3 [:+ int?]]
  [:4 [:+ string?]]]</pre>
or anonymus (uses vector indexes as keys)
<pre>[:cat
  [:+ int?]
  [:+ string?]
  [:+ int?]
  [:+ string?]]</pre>
some silly perf numbers with 10000 &amp; <code>time</code>  (and intermediate results):
<pre>Malli:
{:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]}
&quot;Elapsed time: 35.535477 msecs&quot;

Minimallist:
{:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]}
&quot;Elapsed time: 386.464772 msecs&quot;

Seqexp:
{:rest (), :match (1 2 3 &quot;4&quot; &quot;5&quot; 6 7 8 9 &quot;10&quot;), :1 (1 2 3), :2 (&quot;4&quot; &quot;5&quot;), :3 (6 7 8 9), :4 (&quot;10&quot;)}
&quot;Elapsed time: 686.08428 msecs&quot;

Clojure.Spec:
{:1 [1 2 3], :2 [&quot;4&quot; &quot;5&quot;], :3 [6 7 8 9], :4 [&quot;10&quot;]}
&quot;Elapsed time: 879.329458 msecs&quot;</pre></z><z id="t1599629895" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] You made my day ! I never tried any benchmark on my lib, I did not know it was faster than Clojure Spec 😃"><y>#</y><d>2020-09-09</d><h>05:38</h><r>Vincent Cantin</r><a>@ikitommi</a> You made my day ! I never tried any benchmark on my lib, I did not know it was faster than Clojure Spec <b>😃</b></z><z id="t1599761214" t="ikitommi awesome"><y>#</y><d>2020-09-10</d><h>18:06</h><r>ikitommi</r><b>awesome</b></z><z id="t1599471412" t="borkdude cool :)"><y>#</y><d>2020-09-07</d><h>09:36</h><w>borkdude</w>cool :)</z><z id="t1599473132" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think this new clj-kondo feature can help with annotations generated by malli in some other config file: https://github.com/borkdude/clj-kondo/issues/992 Users can e.g. use {:config-paths [&quot;malli-types&quot;]} . If malli then spits out the type information in .clj-kondo/malli-types/config.edn , then it will work"><y>#</y><d>2020-09-07</d><h>10:05</h><w>borkdude</w><a>@ikitommi</a> I think this new clj-kondo feature can help with annotations generated by malli in some other config file:
<a href="https://github.com/borkdude/clj-kondo/issues/992" target="_blank">https://github.com/borkdude/clj-kondo/issues/992</a>
Users can e.g. use <code>{:config-paths [&quot;malli-types&quot;]}</code>. If malli then spits out the type information in <code>.clj-kondo/malli-types/config.edn</code>, then it will work</z><z id="t1599473152" t="borkdude This is for the ClojureD-demoed functionality"><y>#</y><d>2020-09-07</d><h>10:05</h><w>borkdude</w>This is for the ClojureD-demoed functionality</z><z id="t1599473196" t="borkdude I&apos;m also considering a similar tool for clojure spec which inspects specs at runtime and then spits out a file. Maybe there could also be a CIDER middleware which populates things there as you eval code."><y>#</y><d>2020-09-07</d><h>10:06</h><w>borkdude</w>I&apos;m also considering a similar tool for clojure spec which inspects specs at runtime and then spits out a file. Maybe there could also be a CIDER middleware which populates things there as you eval code.</z><z id="t1599474792" t="borkdude but if malli is going to have a defn like macro, I think making built-in functionality for it would also be cool. can we do this without depending on malli itself for keeping the dependencies of clj-kondo lean? e.g. it also doesn&apos;t depend on schema, it only recognizes the syntax"><y>#</y><d>2020-09-07</d><h>10:33</h><w>borkdude</w>but if malli is going to have a defn like macro, I think making built-in functionality for it would also be cool. can we do this without depending on malli itself for keeping the dependencies of clj-kondo lean? e.g. it also doesn&apos;t depend on schema, it only recognizes the syntax</z><z id="t1599482841" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] good stuff. yes, the planned m/defn can emit the clj-kondo format directly, it’s a great start. Will keep an eye on your spec-tooling work too."><y>#</y><d>2020-09-07</d><h>12:47</h><w>ikitommi</w><a>@borkdude</a> good stuff. yes, the planned <code>m/defn</code> can emit the clj-kondo format directly, it’s a great start. Will keep an eye on your spec-tooling work too.</z><z id="t1599511384" t="tekacs Really looking forward to the m/defn support! I forked aave to add ClojureScript support and m/humanize-d errors recently and am adding in a few additional things — I’ll try to comment in the m/defn threads once they’re live to see whether any of the features added can make it across when the time comes. In particular, I’m binding up parameter and return types together (rather than separately), so that :multi / :or specs can be used as a poor-man’s (although runtime-dispatched) facsimile of overloading. i.e. [[[:vector int?] =&gt; [:map-of int? string?]] [[:vector string?] =&gt; [:map-of string? int?]]] translates to [:or [:tuple [:vector int?] [:map-of int? string?]] [:tuple [:vector string?] [:map-of string? int?]]]"><y>#</y><d>2020-09-07</d><h>20:43</h><w>tekacs</w>Really looking forward to the m/defn support!

I forked aave to add ClojureScript support and m/humanize-d errors recently and am adding in a few additional things — I’ll try to comment in the m/defn threads once they’re live to see whether any of the features added can make it across when the time comes.

In particular, I’m binding up parameter and return types together (rather than separately), so that :multi / :or specs can be used as a poor-man’s (although runtime-dispatched) facsimile of overloading.

i.e.

<pre>[[[:vector int?] =&gt; [:map-of int? string?]]
 [[:vector string?] =&gt; [:map-of string? int?]]]</pre>
translates to

<pre>[:or [:tuple [:vector int?] [:map-of int? string?]]
     [:tuple [:vector string?] [:map-of string? int?]]]</pre></z><z id="t1599511430" t="tekacs cc/ [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}]"><y>#</y><d>2020-09-07</d><h>20:43</h><w>tekacs</w>cc/ <a>@borkdude</a></z><z id="t1599511526" t="tekacs I’m also excited to use [:multi {:dispatch …}] instead of [:or] (the above are or-ed together), to see whether dispatch to a particular signature can be more sophisticated than simply ‘first matching signature’"><y>#</y><d>2020-09-07</d><h>20:45</h><w>tekacs</w>I’m also excited to use [:multi {:dispatch …}] instead of [:or] (the above are or-ed together), to see whether dispatch to a particular signature can be more sophisticated than simply ‘first matching signature’</z><z id="t1599545493" t="ikitommi sounds great [:attrs {:href &quot;/_/_/users/U0H98U6SY&quot;}] , hopefully planning to push changes back to original Aave? Looking forward to hearing how the malli-&gt;kondo works with that. The. m/defn demo was a fork of Plumatic Schema s/defn , need to clean it up before use and open for comments. If the aave-syntax is already good, one option is just to add a fdef -malli decorator for existing functions into the core lib. Not sure. I believe Rich has been deep in the hammock thinking about new syntax for spec2 embedded defn syntax. Might take a while, but if becomes de-facto, malli could do that too."><y>#</y><d>2020-09-08</d><h>06:11</h><w>ikitommi</w>sounds great <a>@tekacs</a>, hopefully planning to push changes back to original Aave? Looking forward to hearing how the malli-&gt;kondo works with that. The. <code>m/defn</code> demo was a fork of Plumatic Schema <code>s/defn</code>, need to clean it up before use and open for comments. If the aave-syntax is already good, one option is just to add a <code>fdef</code> -malli decorator for existing functions into the core lib. Not sure. I believe Rich has been deep in the hammock thinking about new syntax for spec2 embedded defn syntax. Might take a while, but if becomes de-facto, malli could do that too.</z><z id="t1599545657" t="ikitommi Plumatic has btw s/conditional which might be handy with malli too. Like :multi but the keys are schemas to match the original value, e.g. [:conditional [vector? [:vector int?]] [map? [:map [:x int?] [:y int?]]] "><y>#</y><d>2020-09-08</d><h>06:14</h><w>ikitommi</w>Plumatic has btw <code>s/conditional</code> which might be handy with malli too. Like <code>:multi</code> but the keys are schemas to match the original value, e.g.
<pre>[:conditional
 [vector? [:vector int?]]
 [map? [:map [:x int?] [:y int?]]] </pre></z><z id="t1599581660" t="tekacs oh that’s interesting, yes (to both :conditional and :else as really helpful things to have)"><y>#</y><d>2020-09-08</d><h>16:14</h><w>tekacs</w>oh that’s interesting, yes (to both :conditional and :else as really helpful things to have)</z><z id="t1599660928" t="jhacks Following along with the example here: https://github.com/metosin/malli#custom-registry (def registry (merge (m/class-schemas) (m/comparator-schemas) (m/base-schemas) {:int (m/fn-schema :int int?) :bool (m/fn-schema :bool boolean?)})) (m/validate [:or :int :bool] &apos;kikka {:registry registry}) ; =&gt; false (m/validate [:or :int :bool] 123 {:registry registry}) ; =&gt; true It looks like m/fn-schema no longer exists. I tried using m/-fn-schema (which does exist) but that didn’t work. How does this example work with the current code?"><y>#</y><d>2020-09-09</d><h>14:15</h><w>jhacks</w>Following along with the example here: <a href="https://github.com/metosin/malli#custom-registry" target="_blank">https://github.com/metosin/malli#custom-registry</a>

<pre>(def registry
  (merge
    (m/class-schemas)
    (m/comparator-schemas)
    (m/base-schemas)
    {:int (m/fn-schema :int int?)
     :bool (m/fn-schema :bool boolean?)}))

(m/validate [:or :int :bool] &apos;kikka {:registry registry})
; =&gt; false

(m/validate [:or :int :bool] 123 {:registry registry})
; =&gt; true</pre>
It looks like <code>m/fn-schema</code> no longer exists. I tried using <code>m/-fn-schema</code> (which does exist) but that didn’t work.

How does this example work with the current code?</z><z id="t1599751711" t="ikitommi fixed the README"><y>#</y><d>2020-09-10</d><h>15:28</h><r>ikitommi</r>fixed the README</z><z id="t1599667442" t="ikitommi [:attrs {:href &quot;/_/_/users/U2NNQ4GP9&quot;}] oh, the README is out of sync. This should work: (m/-simple-schema {:type :boolean, :pred boolean?})"><y>#</y><d>2020-09-09</d><h>16:04</h><w>ikitommi</w><a>@jhacks</a> oh, the README is out of sync. This should work:
<pre>(m/-simple-schema {:type :boolean, :pred boolean?})</pre></z><z id="t1599667495" t="ikitommi there seems to be (m/-predicate-schema :boolean boolean?) too"><y>#</y><d>2020-09-09</d><h>16:04</h><w>ikitommi</w>there seems to be <code>(m/-predicate-schema :boolean boolean?)</code> too</z><z id="t1599673080" t="jhacks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks, both methods work! Is there a way to register a default error message for schemas in the custom registry? For example, the custom :boolean schema has &quot;unknown error&quot; for the error message. Could I define a different message?"><y>#</y><d>2020-09-09</d><h>17:38</h><w>jhacks</w><a>@ikitommi</a> Thanks, both methods work! Is there a way to register a default error message for schemas in the custom registry?  For example, the custom <code>:boolean</code> schema has <code>&quot;unknown error&quot;</code> for the error message. Could I define a different message?</z><z id="t1599751009" t="ikitommi [:attrs {:href &quot;/_/_/users/U2NNQ4GP9&quot;}] currently no, but should be. wrote an issue about it: https://github.com/metosin/malli/issues/254 &amp; will fix that soon."><y>#</y><d>2020-09-10</d><h>15:16</h><w>ikitommi</w><a>@jhacks</a> currently no, but should be. wrote an issue about it: <a href="https://github.com/metosin/malli/issues/254" target="_blank">https://github.com/metosin/malli/issues/254</a> &amp; will fix that soon.</z><z id="t1599751185" t="ikitommi renaming (&amp; moving) the malli.error/ErrorSchema as malli.core/Humanized would make humanized errors more first class and would enable setting those easily when creating custom schemas - either via helpers of by reifying the protocols. Closure DCE will remove those anyway if not used in an app."><y>#</y><d>2020-09-10</d><h>15:19</h><w>ikitommi</w>renaming (&amp; moving) the <code>malli.error/ErrorSchema</code> as <code>malli.core/Humanized</code> would make humanized errors more first class and would enable setting those easily when creating custom schemas - either via helpers of by reifying the protocols. Closure DCE will remove those anyway if not used in an app.</z><z id="t1599751354" t="ikitommi could also move the Generator protocol (not impls!) into core. Currently - if one want’s to implement fully custom Schma impl (like regal does), the lib must include all the support namespaces to access the Protocols. This drags is a lot of code that the end user might not need, making initial load time slower on clj and making the bundle size bigger on cljs."><y>#</y><d>2020-09-10</d><h>15:22</h><w>ikitommi</w>could also move the Generator protocol (not impls!) into core. Currently - if one want’s to implement fully custom Schma impl (like <code>regal</code> does), the lib must include all the support namespaces to access the Protocols. This drags is a lot of code that the end user might not need, making initial load time slower on clj and making the bundle size bigger on cljs.</z><z id="t1599760229" t="ikitommi looks legit."><y>#</y><d>2020-09-10</d><h>17:50</h><w>ikitommi</w>looks legit.</z><z id="t1599760829" t="ikitommi big thanks to [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] for the initial work on the issue! it’s now a full rewrite (protocols &amp; vectors), but took the internal syntax from minimallist. minimallist inspired by malli, inspired by minimallist 😉"><y>#</y><d>2020-09-10</d><h>18:00</h><w>ikitommi</w>big thanks to <a>@vincent.cantin</a> for the initial work on the issue! it’s now a full rewrite (protocols &amp; vectors), but took the internal syntax from minimallist. minimallist inspired by malli, inspired by minimallist <b>😉</b></z><z id="t1599761163" t="ikitommi quite happy with the internal design. both validation and parsing use the same code, but when validating, the parsing results are not realized. that given example is 40µs on spec (both validation &amp; parsing), malli is now: 6µs when parsing and 3µs on validation. not optimized yet, I think it could be made much faster still."><y>#</y><d>2020-09-10</d><h>18:06</h><w>ikitommi</w>quite happy with the internal design. both validation and parsing use the same code, but when validating, the parsing results are not realized. that given example is <code>40µs</code> on spec (both validation &amp; parsing), malli is now: <code>6µs</code> when parsing and <code>3µs</code> on validation. not optimized yet, I think it could be made much faster still.</z><z id="t1599761757" t="ikitommi 123 loc 🙂"><y>#</y><d>2020-09-10</d><h>18:15</h><w>ikitommi</w>123 loc <b>🙂</b></z><z id="t1599781697" t="Vincent Cantin micromallist"><y>#</y><d>2020-09-10</d><h>23:48</h><r>Vincent Cantin</r>micromallist</z><z id="t1599765292" t="borkdude looks awesome"><y>#</y><d>2020-09-10</d><h>19:14</h><w>borkdude</w>looks awesome</z><z id="t1599773967" t="tekacs I was considering making an issue to ask, but trying here first — is there a particular way you’d recommend doing a map on (or otherwise delegating to) existing schemas, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ? Some examples are: • Validating JS objects with a spec for their keys/values by using some of the implementation of [:map-of …] on a (decently efficient) cljs-bean.core/bean • ^ similarly with JS arrays • Ideally I’d like to pass the underlying explainer’s output through and be able to humanize the aggregate schema, which I’m especially having trouble with. So far I’ve done things like: (defn transform-spec [transform inner-spec] (let [explainer (m/explainer inner-spec)] [:fn {:error/fn (fn [{:keys [value]} _] (explainer value))} #(m/validate inner-spec (transform %))])) ; and (defn js-obj [&amp; map-spec] (let [inner-spec (into [:map] map-spec) explainer (m/explainer inner-spec)] [:fn {:error/fn (fn [{:keys [value]}] (explainer value))} #(-&gt;&gt; (bean %) (m/validate inner-spec))])) … but I’m breaking the explainer output no matter how I slice it. The best approach for now I imagine is to directly implement the protocol(s) and do a bunch of delegation to the underlying schemas, but wondering if combinators/transformers are possible?"><y>#</y><d>2020-09-10</d><h>21:39</h><w>tekacs</w>I was considering making an issue to ask, but trying here first — is there a particular way you’d recommend doing a map on (or otherwise delegating to) existing schemas, <a>@ikitommi</a>?

Some examples are:
• Validating JS objects with a spec for their keys/values by using some of the implementation of [:map-of …] on a (decently efficient) cljs-bean.core/bean
• ^ similarly with JS arrays
• 
Ideally I’d like to pass the underlying explainer’s output through and be able to humanize the aggregate schema, which I’m especially having trouble with.

So far I’ve done things like:

<pre>(defn transform-spec [transform inner-spec]
  (let [explainer (m/explainer inner-spec)]
    [:fn {:error/fn (fn [{:keys [value]} _] (explainer value))}
     #(m/validate inner-spec (transform %))]))

; and

(defn js-obj [&amp; map-spec]
  (let [inner-spec (into [:map] map-spec)
        explainer (m/explainer inner-spec)]
    [:fn {:error/fn (fn [{:keys [value]}] (explainer value))}
     #(-&gt;&gt; (bean %) (m/validate inner-spec))]))</pre>
… but I’m breaking the explainer output no matter how I slice it.

The best approach for now I imagine is to directly implement the protocol(s) and do a bunch of delegation to the underlying schemas, but wondering if combinators/transformers are possible?</z><z id="t1599778326" t="jhacks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks for the very informative response. https://github.com/metosin/malli/issues/254 looks great! Also, sequence/regex schemas! Wohoo!"><y>#</y><d>2020-09-10</d><h>22:52</h><w>jhacks</w><a>@ikitommi</a> Thanks for the very informative response. <a href="https://github.com/metosin/malli/issues/254" target="_blank">https://github.com/metosin/malli/issues/254</a> looks great! Also, sequence/regex schemas! Wohoo!</z><z id="t1599781473" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] now, you can finally use Malli itself to validate Malli’s models."><y>#</y><d>2020-09-10</d><h>23:44</h><w>Vincent Cantin</w><a>@ikitommi</a> now, you can finally use Malli itself to validate Malli’s models.</z><z id="t1599817854" t="ikitommi [:attrs {:href &quot;/_/_/users/U0H98U6SY&quot;}] not 100% sure about your use case, what about using transformers?"><y>#</y><d>2020-09-11</d><h>09:50</h><w>ikitommi</w><a>@tekacs</a> not 100% sure about your use case, what about using transformers?</z><z id="t1600213137" t="tekacs I was hoping rather to do something more like gen/fmap but for malli types. The hope being to be able to first run a transform on a value before validating it using an existing/builtin validator. I can do this today using simple-schema or similar, but passing errors along is just tricky."><y>#</y><d>2020-09-15</d><h>23:38</h><r>tekacs</r>I was hoping rather to do something more like gen/fmap but for malli types.

The hope being to be able to first run a transform on a value before validating it using an existing/builtin validator.

I can do this today using simple-schema or similar, but passing errors along is just tricky.</z><z id="t1600614744" t="ikitommi does the new -simple-schema solve this?"><y>#</y><d>2020-09-20</d><h>15:12</h><r>ikitommi</r>does the new <code>-simple-schema</code> solve this?</z><z id="t1599818137" t="ikitommi I recently tested the end-to-end performance of JSON and realized we could plug malli into the jsonista pipeline: define a malli schema, create a jsonista functional-decoder out of it which picks just the defined keys from the JSON stream and runs (already optimized) value transformation for it. As there are no intermediate conversions, it should be MUCH faster."><y>#</y><d>2020-09-11</d><h>09:55</h><w>ikitommi</w>I recently tested the end-to-end performance of JSON and realized we could plug malli into the jsonista pipeline: define a malli schema, create a jsonista functional-decoder out of it which picks just the defined keys from the JSON stream and runs (already optimized) value transformation for it. As there are no intermediate conversions, it should be MUCH faster.</z><z id="t1599818461" t="ikitommi • old-style json: stream --json-decode--&gt; edn --schema-decode--&gt; domain-data --json-encode--&gt; string --ring-adapter--&gt; bytes • malli+jsonista: stream --json-and-schema-decode--&gt; domain-data --json-and-schema-encode--&gt; bytes"><y>#</y><d>2020-09-11</d><h>10:01</h><w>ikitommi</w>• old-style json: <code>stream --json-decode--&gt; edn --schema-decode--&gt; domain-data --json-encode--&gt; string --ring-adapter--&gt; bytes</code>
• malli+jsonista: <code>stream --json-and-schema-decode--&gt; domain-data --json-and-schema-encode--&gt; bytes</code></z><z id="t1599820405" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] That&apos;s exactly an issue that I posted a couple of years ago in the compojure-api channel :) Awesome that this will now be supported via malli!"><y>#</y><d>2020-09-11</d><h>10:33</h><w>borkdude</w><a>@ikitommi</a> That&apos;s exactly an issue that I posted a couple of years ago in the compojure-api channel :) Awesome that this will now be supported via malli!</z><z id="t1599820461" t="borkdude This is typically what you do in typed languages: write (de)serialization code which results in very efficient JSON processing. But in Clojure we typically just parse the entire blob"><y>#</y><d>2020-09-11</d><h>10:34</h><w>borkdude</w>This is typically what you do in typed languages: write (de)serialization code which results in very efficient JSON processing. But in Clojure we typically just parse the entire blob</z><z id="t1599820530" t="borkdude If you have a working example of this, I&apos;d be very interested"><y>#</y><d>2020-09-11</d><h>10:35</h><w>borkdude</w>If you have a working example of this, I&apos;d be very interested</z><z id="t1599820905" t="borkdude since jsonista is also based on jackson-core I might be able to switch/add from cheshire to jsonista without adding very much binary size. if we then also add malli and reitit and http-kit server ... in babashka I mean. small web-apps :)"><y>#</y><d>2020-09-11</d><h>10:41</h><w>borkdude</w>since jsonista is also based on jackson-core I might be able to switch/add from cheshire to jsonista without adding very much binary size. if we then also add malli and reitit and http-kit server ... in babashka I mean. small web-apps :)</z><z id="t1599836102" t="ikitommi that would be great! Would like to get vertx working with clj + graalvm at some point. After that, one could write a code that can run really fast with jvm, with low resources with graalvm and with bb for scripting."><y>#</y><d>2020-09-11</d><h>14:55</h><w>ikitommi</w>that would be great! Would like to get vertx working with clj + graalvm at some point. After that, one could write a code that can run really fast with jvm, with low resources with graalvm and with bb for scripting.</z><z id="t1599836266" t="ikitommi reitit+jsonista+porsas+pohjavirta is still one of the fastest jvm stacks in techempower db-query tests. It&apos;s a silly benchmark, but, still."><y>#</y><d>2020-09-11</d><h>14:57</h><w>ikitommi</w>reitit+jsonista+porsas+pohjavirta is still one of the fastest jvm stacks in techempower db-query tests. It&apos;s a silly benchmark, but, still.</z><z id="t1599836409" t="ikitommi https://www.techempower.com/benchmarks/#section=data-r19&amp;amp;hw=ph&amp;amp;test=db&amp;amp;a=2&amp;amp;f=35s1-1ekg-27xgcg-75-0-pfk-8vn0dc-kb4lg-13ydj4-8-0"><y>#</y><d>2020-09-11</d><h>15:00</h><r>ikitommi</r><a href="https://www.techempower.com/benchmarks/#section=data-r19&amp;amp;hw=ph&amp;amp;test=db&amp;amp;a=2&amp;amp;f=35s1-1ekg-27xgcg-75-0-pfk-8vn0dc-kb4lg-13ydj4-8-0" target="_blank">https://www.techempower.com/benchmarks/#section=data-r19&amp;amp;hw=ph&amp;amp;test=db&amp;amp;a=2&amp;amp;f=35s1-1ekg-27xgcg-75-0-pfk-8vn0dc-kb4lg-13ydj4-8-0</a></z><z id="t1599836469" t="ikitommi don&apos;t have an example of the json+malli, just know it&apos;s possible. Will do."><y>#</y><d>2020-09-11</d><h>15:01</h><w>ikitommi</w>don&apos;t have an example of the json+malli, just know it&apos;s possible. Will do.</z><z id="t1600213137" t="tekacs I was hoping rather to do something more like gen/fmap but for malli types. The hope being to be able to first run a transform on a value before validating it using an existing/builtin validator. I can do this today using simple-schema or similar, but passing errors along is just tricky."><y>#</y><d>2020-09-15</d><h>23:38</h><w>tekacs</w>I was hoping rather to do something more like gen/fmap but for malli types.

The hope being to be able to first run a transform on a value before validating it using an existing/builtin validator.

I can do this today using simple-schema or similar, but passing errors along is just tricky.</z><z id="t1600012190" t="borkdude I just realized that borkdude/dynaload isn&apos;t GraalVM friendly in that it uses require at runtime. I made an issue for this: https://github.com/borkdude/dynaload/issues/6 I think we&apos;ll have to adapt to the CLJS model of dynaload, i.e. the require is on the user, dynaload only prints a warning"><y>#</y><d>2020-09-13</d><h>15:49</h><w>borkdude</w>I just realized that borkdude/dynaload isn&apos;t GraalVM friendly in that it uses require at runtime.
I made an issue for this: <a href="https://github.com/borkdude/dynaload/issues/6" target="_blank">https://github.com/borkdude/dynaload/issues/6</a>
I think we&apos;ll have to adapt to the CLJS model of dynaload, i.e. the require is on the user, dynaload only prints a warning</z><z id="t1600013610" t="borkdude Note: it did work, but it&apos;s just not good for binary size and compilation time"><y>#</y><d>2020-09-13</d><h>16:13</h><w>borkdude</w>Note: it did work, but it&apos;s just not good for binary size and compilation time</z><z id="t1600026584" t="borkdude Do you test GraalVM builds on CI?"><y>#</y><d>2020-09-13</d><h>19:49</h><w>borkdude</w>Do you test GraalVM builds on CI?</z><z id="t1600336439" t="Stefan Hi all, somebody pointed me to Malli (thx [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] [:attrs {:href &quot;/_/_/users/UGFL22X0Q&quot;}] ) because of the situation with spec being alpha and spec2 on the horizon. But then I noticed in the Malli readme that it says: “Pre-alpha”, which scares me a bit. Can somebody clarify the situation and whether or not this is a good time to start using Malli? Our situation by the way is that we have a big existing codebase without any sort of spec/schema, so in that respect we’re starting from scratch."><y>#</y><d>2020-09-17</d><h>09:53</h><w>Stefan</w>Hi all, somebody pointed me to Malli (thx <a>@borkdude</a> <a>@hobosarefriends</a>) because of the situation with spec being alpha and spec2 on the horizon. But then I noticed in the Malli readme that it says: “Pre-alpha”, which scares me a bit. Can somebody clarify the situation and whether or not this is a good time to start using Malli? Our situation by the way is that we have a big existing codebase without any sort of spec/schema, so in that respect we’re starting from scratch.</z><z id="t1600341092" t="jeroenvandijk All the solutions are officially still alpha. Trying any of them is a good learning experience. If you don’t have specific requirements, I would suggest to start with clojure.spec (1) as it has the most examples and documentation. I think Malli is modelled like spec(2) so any learnings with clojure.spec will be applicable later in malli"><y>#</y><d>2020-09-17</d><h>11:11</h><r>jeroenvandijk</r>All the solutions are officially still alpha. Trying any of them is a good learning experience. If you don’t have specific requirements, I would suggest to start with clojure.spec (1) as it has the most examples and documentation. I think Malli is modelled like spec(2) so any learnings with clojure.spec will be applicable later in malli</z><z id="t1600341309" t="borkdude Although [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] mentioned that the goal of the current Clojurists Together funding is to make a stable (non-alpha) release?"><y>#</y><d>2020-09-17</d><h>11:15</h><r>borkdude</r>Although <a>@ikitommi</a> mentioned that the goal of the current Clojurists Together funding is to make a stable (non-alpha) release?</z><z id="t1600341391" t="borkdude With spec it remains to be seen. It&apos;s been in alpha for over 4 years."><y>#</y><d>2020-09-17</d><h>11:16</h><r>borkdude</r>With spec it remains to be seen. It&apos;s been in alpha for over 4 years.</z><z id="t1600342132" t="jeroenvandijk Good point 🙂"><y>#</y><d>2020-09-17</d><h>11:28</h><r>jeroenvandijk</r>Good point <b>🙂</b></z><z id="t1600374483" t="rschmukler There&apos;s some discussion on github that might be interesting: https://github.com/metosin/malli/issues/207"><y>#</y><d>2020-09-17</d><h>20:28</h><r>rschmukler</r>There&apos;s some discussion on github that might be interesting: <a href="https://github.com/metosin/malli/issues/207" target="_blank">https://github.com/metosin/malli/issues/207</a></z><z id="t1600340572" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] A small heads up I have generated a Malli spec that can validate all of our cfn templates (around 30, pretty big and complete). I’ll try to publish it soon and point to some pitfalls. One thing that is hard to debug are (deeply nested) recursive schemas. Without the use of [:ref …] it will give a stackoverflow error without a good pointer. And I had to do a trick in the :multi dispatch to prevent :invalid-type errors and to stay compatible with spell-check. All in all it works pretty well! Thanks"><y>#</y><d>2020-09-17</d><h>11:02</h><w>jeroenvandijk</w><a>@ikitommi</a> A small heads up I have generated a Malli spec that can validate all of our cfn templates (around 30, pretty big and complete). I’ll try to publish it soon and point to some pitfalls. One thing that is hard to debug are (deeply nested) recursive schemas. Without the use of <code>[:ref …]</code> it will give a stackoverflow error without a good pointer. And I had to do a trick in the <code>:multi</code> dispatch to prevent  <code>:invalid-type</code>  errors and to stay compatible with spell-check. All in all it works pretty well! Thanks</z><z id="t1600354436" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Here is the current state of my AWS cloudformation malli code https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj#L15-L232"><y>#</y><d>2020-09-17</d><h>14:53</h><r>jeroenvandijk</r><a>@ikitommi</a> Here is the current state of my AWS cloudformation malli code <a href="https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj#L15-L232" target="_blank">https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj#L15-L232</a></z><z id="t1600354481" t="jeroenvandijk (now public)"><y>#</y><d>2020-09-17</d><h>14:54</h><r>jeroenvandijk</r>(now public)</z><z id="t1600354617" t="jeroenvandijk Maybe useful information; I’ve reduced the usage of :or and used :multi instead to prevent super long lists of errors (reduces branching factor)"><y>#</y><d>2020-09-17</d><h>14:56</h><r>jeroenvandijk</r>Maybe useful information; I’ve reduced the usage of <code>:or</code> and used <code>:multi</code> instead to prevent super long lists of errors (reduces branching factor)</z><z id="t1600354650" t="jeroenvandijk I think I broke proper spell check feedback by not using a keyword as dispatch function. I’ll look into this soon again"><y>#</y><d>2020-09-17</d><h>14:57</h><r>jeroenvandijk</r>I think I broke proper spell check feedback by not using a keyword as dispatch function. I’ll look into this soon again</z><z id="t1600341447" t="ikitommi [:attrs {:href &quot;/_/_/users/UGNFXV1FA&quot;}] Just checked that last bullet on “last things before initial stable release” yesterday. will clean up corners and will ship the alpha, most likely next week."><y>#</y><d>2020-09-17</d><h>11:17</h><w>ikitommi</w><a>@stefan.van.den.oord</a> Just checked that last bullet on “last things before initial stable release” yesterday. will clean up corners and will ship the alpha, most likely next week.</z><z id="t1600341529" t="ikitommi the public api has been mostly stable since june, there has been small changes in the advanced user / extender api, and most likely will be after the first release."><y>#</y><d>2020-09-17</d><h>11:18</h><w>ikitommi</w>the public api has been mostly stable since june, there has been small changes in the advanced user / extender api,  and most likely will be after the first release.</z><z id="t1600341565" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] (Note my remarks on borkdude/dynaload. I&apos;m currently solving a problem with GraalVM. Using resolve at runtime bloats the binary with +20MB. But it does work.)"><y>#</y><d>2020-09-17</d><h>11:19</h><w>borkdude</w><a>@ikitommi</a> (Note my remarks on borkdude/dynaload. I&apos;m currently solving a problem with GraalVM. Using resolve at runtime bloats the binary with +20MB. But it does work.)</z><z id="t1600341565" t="ikitommi 1.0.0 might be soon too, after feedback from the community."><y>#</y><d>2020-09-17</d><h>11:19</h><w>ikitommi</w>1.0.0 might be soon too, after feedback from the community.</z><z id="t1600341624" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] sorry, read you message, but didn’t have time to answer. There is no GraalVM tests atm, should be."><y>#</y><d>2020-09-17</d><h>11:20</h><w>ikitommi</w><a>@borkdude</a> sorry, read you message, but didn’t have time to answer. There is no GraalVM tests atm, should be.</z><z id="t1600341648" t="borkdude I will publish dynaload 0.2.0 or so that will have breaking changes to fix this problem, but I&apos;ll notify you"><y>#</y><d>2020-09-17</d><h>11:20</h><w>borkdude</w>I will publish dynaload 0.2.0 or so that will have breaking changes to fix this problem, but I&apos;ll notify you</z><z id="t1600341652" t="borkdude and possibly make a PR"><y>#</y><d>2020-09-17</d><h>11:20</h><w>borkdude</w>and possibly make a PR</z><z id="t1600341684" t="ikitommi that would be great! GraalVM support is top priority, don’t want bloated binaries 🙂"><y>#</y><d>2020-09-17</d><h>11:21</h><w>ikitommi</w>that would be great! GraalVM support is top priority, don’t want bloated binaries <b>🙂</b></z><z id="t1600341769" t="ikitommi when writing libraries, the goals matter a lot. few years ago, didn’t know much about perf. can’t add that later. now, the cljs bundle size, learned how to handle that. Next: GraalVM as a target."><y>#</y><d>2020-09-17</d><h>11:22</h><w>ikitommi</w>when writing libraries, the goals matter a lot. few years ago, didn’t know much about perf. can’t add that later. now, the cljs bundle size, learned how to handle that. Next: GraalVM as a target.</z><z id="t1600341772" t="borkdude yeah. I have a dynaload-graal-friendly branch, with script/graal-test . currently this code still bloats: #?(:clj (defn resolve* [sym] ;; TODO: this adds + 20MB to the GraalVM binary #_(let [ns (symbol (namespace sym)) v (symbol (name sym))] (when-let [ns (find-ns ns)] (.getMapping ^clojure.lang.Namespace ns v))))) so it&apos;s either in find-ns or in the namespace interop"><y>#</y><d>2020-09-17</d><h>11:22</h><w>borkdude</w>yeah. I have a <code>dynaload-graal-friendly</code> branch, with <code>script/graal-test</code>.
currently this code still bloats:
<pre>#?(:clj (defn resolve* [sym]
          ;; TODO: this adds + 20MB to the GraalVM binary
          #_(let [ns (symbol (namespace sym))
                v (symbol (name sym))]
            (when-let [ns (find-ns ns)]
              (.getMapping ^clojure.lang.Namespace ns v)))))</pre>
so it&apos;s either in find-ns or in the namespace interop</z><z id="t1600342040" t="borkdude yeah, it&apos;s the namespace interop"><y>#</y><d>2020-09-17</d><h>11:27</h><w>borkdude</w>yeah, it&apos;s the namespace interop</z><z id="t1600342117" t="borkdude I think using this interop will make GraalVM think it should hold on to more that it actually needs"><y>#</y><d>2020-09-17</d><h>11:28</h><w>borkdude</w>I think using this interop will make GraalVM think it should hold on to more that it actually needs</z><z id="t1600342202" t="borkdude so what we can do is only resolve at compile time. The user should take care of requiring the lib namespace before they load the dynaloaded code, else it will be considered not there."><y>#</y><d>2020-09-17</d><h>11:30</h><w>borkdude</w>so what we can do is only resolve at compile time. The user should take care of requiring the lib namespace before they load the dynaloaded code, else it will be considered not there.</z><z id="t1600342363" t="ikitommi is there a :preload thing with deps? other than the -e from command line?"><y>#</y><d>2020-09-17</d><h>11:32</h><w>ikitommi</w>is there a <code>:preload</code> thing with deps? other than the <code>-e</code> from command line?</z><z id="t1600342411" t="borkdude no"><y>#</y><d>2020-09-17</d><h>11:33</h><w>borkdude</w>no</z><z id="t1600342412" t="ikitommi have this on my project Justfile: # start backend nrepl @backend: clj -A:dev:test:common:backend -e &quot;(require &apos;[hashp.core])&quot; -m nrepl.cmdline -i -C"><y>#</y><d>2020-09-17</d><h>11:33</h><w>ikitommi</w>have this on my project Justfile:
<pre># start backend nrepl
@backend:
    clj -A:dev:test:common:backend -e &quot;(require &apos;[hashp.core])&quot; -m nrepl.cmdline -i -C</pre></z><z id="t1600342490" t="borkdude for graalvm builds with deps.edn that may work"><y>#</y><d>2020-09-17</d><h>11:34</h><w>borkdude</w>for graalvm builds with deps.edn that may work</z><z id="t1600342500" t="borkdude with the lein + uberjar approach it may not"><y>#</y><d>2020-09-17</d><h>11:35</h><w>borkdude</w>with the lein + uberjar approach it may not</z><z id="t1600342545" t="borkdude just take care in your main to require those libs first, then it will be solved. we can make this behavior graalvm only for example by reading an environment variable or java property"><y>#</y><d>2020-09-17</d><h>11:35</h><w>borkdude</w>just take care in your main to require those libs first, then it will be solved. we can make this behavior graalvm only for example by reading an environment variable or java property</z><z id="t1600342640" t="ikitommi where is borkdude/am-i-in-graalvm library?"><y>#</y><d>2020-09-17</d><h>11:37</h><w>ikitommi</w>where is <code>borkdude/am-i-in-graalvm</code> library?</z><z id="t1600342702" t="ikitommi so: 1. cljs: preload or direct require 2. jvm: just in a classpath 3. graalvm: direct require , right?"><y>#</y><d>2020-09-17</d><h>11:38</h><w>ikitommi</w>so:
1. cljs: preload or direct require
2. jvm: just in a classpath
3. graalvm: direct require
, right?</z><z id="t1600342724" t="ikitommi or: 2. jvm: just direct require"><y>#</y><d>2020-09-17</d><h>11:38</h><w>ikitommi</w>or:
2. jvm: just direct require</z><z id="t1600342810" t="ikitommi can one differentiate if the lib is required or just in the classpath in 2? could be an option in dynaload?"><y>#</y><d>2020-09-17</d><h>11:40</h><w>ikitommi</w>can one differentiate if the lib is required or just in the classpath in 2? could be an option in dynaload?</z><z id="t1600342914" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] 1) I think in CLJS the order of require doesn&apos;t matter, because the check happens at runtime at the first deref. 2) this works because CLJ has runtime require 3) Like 1, but now the order matters, since we check at compile time, before the deref. About checking the classpath: not sure how this would look. That&apos;s kind of the same as compile time resolve."><y>#</y><d>2020-09-17</d><h>11:41</h><w>borkdude</w><a>@ikitommi</a> 1) I think in CLJS the order of require doesn&apos;t matter, because the check happens at runtime at the first deref. 2) this works because CLJ has runtime require 3) Like 1, but now the order matters, since we check at compile time, before the deref.
About checking the classpath: not sure how this would look. That&apos;s kind of the same as compile time resolve.</z><z id="t1600343074" t="borkdude Checking whether you are in a GraalVM binary already works, but that&apos;s too late. You have to check at (Clojure) compile time."><y>#</y><d>2020-09-17</d><h>11:44</h><w>borkdude</w>Checking whether you are in a GraalVM binary already works, but that&apos;s too late. You have to check at (Clojure) compile time.</z><z id="t1600343372" t="borkdude So based on setting -J-Dborkdude.dynaload.target=graalvm-native we could alter the behavior or 2 to 3"><y>#</y><d>2020-09-17</d><h>11:49</h><w>borkdude</w>So based on setting <code>-J-Dborkdude.dynaload.target=graalvm-native</code> we could alter the behavior or 2 to 3</z><z id="t1600343417" t="borkdude or -J-Dborkdude.dynaload.resolve-time=compile"><y>#</y><d>2020-09-17</d><h>11:50</h><w>borkdude</w>or <code>-J-Dborkdude.dynaload.resolve-time=compile</code></z><z id="t1600349704" t="eskos re: graalvm library, shouldn’t that be called antioch ?)"><y>#</y><d>2020-09-17</d><h>13:35</h><w>eskos</w>re: graalvm library, shouldn’t that be called <code>antioch</code> ?)</z><z id="t1600378277" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Pushed dynaload 0.2.1 with better support for GraalVM binaries: https://github.com/borkdude/dynaload#graalvm"><y>#</y><d>2020-09-17</d><h>21:31</h><w>borkdude</w><a>@ikitommi</a> Pushed dynaload 0.2.1 with better support for GraalVM binaries:
<a href="https://github.com/borkdude/dynaload#graalvm" target="_blank">https://github.com/borkdude/dynaload#graalvm</a></z><z id="t1600493700" t="ikitommi Malli now supports type-level properties (a breaking for extenders as there is a new protocol method in m/Schema ) . Added a guide how to use them &amp; also how to use non-registered Schemas."><y>#</y><d>2020-09-19</d><h>05:35</h><w>ikitommi</w>Malli now supports type-level properties (a breaking for extenders as there is a new protocol method in <code>m/Schema</code>) . Added a guide how to use them &amp; also how to use non-registered Schemas.</z><z id="t1600493751" t="ikitommi https://github.com/metosin/malli#custom-schema-types"><y>#</y><d>2020-09-19</d><h>05:35</h><w>ikitommi</w><a href="https://github.com/metosin/malli#custom-schema-types" target="_blank">https://github.com/metosin/malli#custom-schema-types</a></z><z id="t1600493989" t="ikitommi In short: (def Over6 (m/-simple-schema {:type :user/over6 :pred #(and (int? %) (&gt; % 6)) :type-properties {:error/message &quot;shuould be over 6&quot; :json-schema/type &quot;integer&quot;}})) (m/into-schema? Over6) ; =&gt; true (-&gt; (m/explain Over6 5) (me/humanize)) ; =&gt; [&quot;shuould be over 6&quot;] (json-schema/transform [Over6 {:json-schema/example 7}]) ; =&gt; {:type &quot;integer&quot;, :example 7}"><y>#</y><d>2020-09-19</d><h>05:39</h><w>ikitommi</w>In short:
<pre>(def Over6
  (m/-simple-schema
    {:type :user/over6
     :pred #(and (int? %) (&gt; % 6))
     :type-properties {:error/message &quot;shuould be over 6&quot;
                       :json-schema/type &quot;integer&quot;}}))

(m/into-schema? Over6)
; =&gt; true

(-&gt; (m/explain Over6 5) (me/humanize))
; =&gt; [&quot;shuould be over 6&quot;]

(json-schema/transform [Over6 {:json-schema/example 7}])
; =&gt; {:type &quot;integer&quot;, :example 7}</pre></z><z id="t1600519518" t="pithyless (m/explain Over6 &quot;not-an-int&quot;) would not return the most obvious error. What is the idiomatic way to reuse and compose custom types? Something like this? (def Over6 [:and pos-int? (m/-simple-schema {:type :user/over6 ;; is this required? :pred #(&gt; % 6) :type-properties {:error/message &quot;should be over 6&quot;}}])"><y>#</y><d>2020-09-19</d><h>12:45</h><r>pithyless</r><code>(m/explain Over6 &quot;not-an-int&quot;)</code> would not return the most obvious error. What is the idiomatic way to reuse and compose custom types? Something like this?
<pre>(def Over6
  [:and 
    pos-int? 
    (m/-simple-schema
     {:type :user/over6  ;; is this required?
      :pred #(&gt; % 6)
      :type-properties {:error/message &quot;should be over 6&quot;}}])</pre></z><z id="t1600520059" t="pithyless I am currently using a custom version of -simple-schema (that allows setting custom error messages and generators). It&apos;s nice to see :type-properties added; maybe I can get rid of my custom code now. But I&apos;m still struggling a bit with understanding how to best write custom types that don&apos;t need to re-implement predicate logic twice (once for validation, once for humanized errors); and how to compose things better."><y>#</y><d>2020-09-19</d><h>12:54</h><r>pithyless</r>I am currently using a custom version of <code>-simple-schema</code> (that allows setting custom error messages and generators). It&apos;s nice to see <code>:type-properties</code> added; maybe I can get rid of my custom code now. But I&apos;m still struggling a bit with understanding how to best write custom types that don&apos;t need to re-implement predicate logic twice (once for validation, once for humanized errors); and how to compose things better.</z><z id="t1600520213" t="pithyless This Over6 is a great example of a custom type, where ideally I could take advantage of all of the logic from e.g. pos-int? or [:int {:min 7}] and possibly add only additional :pred and :error/message"><y>#</y><d>2020-09-19</d><h>12:56</h><r>pithyless</r>This <code>Over6</code> is a great example of a custom type, where ideally I could take advantage of all of the logic from e.g. <code>pos-int?</code> or <code>[:int {:min 7}]</code> and possibly add only additional <code>:pred</code> and <code>:error/message</code></z><z id="t1600520323" t="pithyless Or I could just be wrong. But this is currently the one thing I don&apos;t understand on how to do well, in an otherwise fantastic library. :)"><y>#</y><d>2020-09-19</d><h>12:58</h><r>pithyless</r>Or I could just be wrong. But this is currently the one thing I don&apos;t understand on how to do well, in an otherwise fantastic library. :)</z><z id="t1600514555" t="schmee hello 👋 just curious if anyone has tried to derive Postgres schemas from Malli schemas (or Malli -&gt; DB schemas in general)?"><y>#</y><d>2020-09-19</d><h>11:22</h><w>schmee</w>hello <b>👋</b> just curious if anyone has tried to derive Postgres schemas from Malli schemas (or Malli -&gt; DB schemas in general)?</z><z id="t1600544567" t="dcj Here is what I did, This was my first Mailli use, not saying it is awesome or prefect: Added properties to map schema that provide info about how to defiine a Postgres table to store the map: (def Datafile (m/schema [:map {:closed true :postgres/type :table :postgres/schema &quot;slm&quot; :postgres/table &quot;datafile&quot; :postgres/key-encoder (comp csk/-&gt;snake_case_keyword remove-trailing-? name)} [:id {:optional true :postgres/type :column :postgres/datatype :bigserial :postgres/key :primary} int?] [:serial-number {:postgres/type :column :postgres/datatype [:varchar 64] :postgres/null? false} string?] [:filename {:postgres/type :column :postgres/datatype [:varchar 64] :postgres/null? false} string?] [:extension {:postgres/type :column :postgres/datatype [:varchar 8] :postgres/null? false} string?] [:create-time {:postgres/type :column :postgres/datatype :timestamptz :postgres/null? false} :zoned-date-time] [:ingest-time {:optional true :postgres/type :column :postgres/datatype :timestamptz :postgres/null? false} :zoned-date-time] [:complete? {:optional true :postgres/type :column :postgres/datatype :boolean :postgres/null? false} boolean?] ] {:registry registry})) Then I wrote functions that create a DDL text file from this info. I also considered creating the table by connecting to the DB and directly creating it, but left that as an exercise for another day.... I also created functions that create a postgres-column-name-transformer And I created functions edn-&gt;postgres and postgres-&gt;edn that take a schema and a map, and returns a map that has been transformed per the schema. I found this pretty useful, and plan to continue to improve and use this going forward. There are cases where there is also some related web API, that has its own keys/values, and I did something similar for that, e.g. added properties that define the keys and datatypes of the API, and am able to create api-&gt;edn and edn-&gt;api functions to transform back and forth...."><y>#</y><d>2020-09-19</d><h>19:42</h><r>dcj</r>Here is what I did, This was my first Mailli use, not saying it is awesome or prefect:

Added properties to map schema that provide info about how to defiine a Postgres table to store the map:

<pre>(def Datafile
  (m/schema
   [:map {:closed true
          :postgres/type :table
          :postgres/schema &quot;slm&quot;
          :postgres/table &quot;datafile&quot;
          :postgres/key-encoder (comp csk/-&gt;snake_case_keyword remove-trailing-? name)}
    [:id                {:optional true
                         :postgres/type :column
                         :postgres/datatype :bigserial
                         :postgres/key  :primary} int?]
    [:serial-number     {:postgres/type :column
                         :postgres/datatype [:varchar 64]
                         :postgres/null? false} string?]
    [:filename          {:postgres/type :column
                         :postgres/datatype  [:varchar 64]
                         :postgres/null? false} string?]
    [:extension         {:postgres/type :column
                         :postgres/datatype  [:varchar 8]
                         :postgres/null? false} string?]
    [:create-time       {:postgres/type :column
                         :postgres/datatype :timestamptz
                         :postgres/null? false} :zoned-date-time]
    [:ingest-time       {:optional true
                         :postgres/type :column
                         :postgres/datatype :timestamptz
                         :postgres/null? false} :zoned-date-time]
    [:complete?         {:optional true
                         :postgres/type :column
                         :postgres/datatype :boolean
                         :postgres/null? false} boolean?]
    ]
   {:registry registry}))</pre>
Then I wrote functions that create a DDL text file from this info.
I also considered creating the table by connecting to the DB and directly creating it, but left that as an exercise for another day....

I also created functions that create a <code>postgres-column-name-transformer</code>

And I created functions <code>edn-&gt;postgres</code> and <code>postgres-&gt;edn</code> that take a schema and a map, and returns a map that has been transformed per the schema.

I found this pretty useful, and plan to continue to improve and use this going forward.

There are cases where there is also some related web API, that has its own keys/values, and I did something similar for that, e.g. added properties that define the keys and datatypes of the API, and am able to create <code>api-&gt;edn</code> and <code>edn-&gt;api</code> functions to transform back and forth....</z><z id="t1600545236" t="schmee cool, thanks for sharing! 😄"><y>#</y><d>2020-09-19</d><h>19:53</h><r>schmee</r>cool, thanks for sharing! <b>😄</b></z><z id="t1600595311" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] good point about composition of things. Not sure myself what is a best practise with everything. Thinking aloud the ways to do things and when they should (or not) be used: Advanced usage: 1. implementing IntoSchema is the last effort in doing things, e.g. adding a new :regal/regex type, which has custom explain, transform etc. 2. using -simple-schema is helper for 1 (but only for leaf-schemas). Basic usage: using schemas as data should be the common way of doing &amp; composing things. One can set transformation rules, humanized error messages, json schema mappings etc. as schema properties. Two options for composing things: 1. Vars. just say (def Over6 (m/schema [:int {:min 6, :description &quot;should be over 6}])) and use the Var. Caveat: inlines the forms: (m/form [:and int? Over6]) ; =&gt; [:and int? [:int {:min 6, :description &quot;should be over 6&quot;}]] , making large schema hard to read 2. Via registry:, e.g. {&quot;Over6&quot; [:int {:min 6}]} , keeps the reference visible: (m/form [:and int? &quot;Over6&quot;]) ; =&gt; [:and int? &quot;Over6&quot;] keeping the schema forms clean too"><y>#</y><d>2020-09-20</d><h>09:48</h><w>ikitommi</w><a>@pithyless</a> good point about composition of things. Not sure myself what is a best practise with everything. Thinking aloud the ways to do things and when they should (or not) be used:

Advanced usage:
1. implementing <code>IntoSchema</code> is the last effort in doing things, e.g. adding a new <code>:regal/regex</code> type, which has custom explain, transform etc.
2. using <code>-simple-schema</code> is helper for 1 (but only for leaf-schemas).
Basic usage:
using schemas as data should be the common way of doing &amp; composing things. One can set transformation rules, humanized error messages, json schema mappings etc. as schema properties. Two options for composing things:

1. Vars. just say <code>(def Over6 (m/schema [:int {:min 6, :description &quot;should be over 6}]))</code> and use the Var. Caveat: inlines the forms: <code>(m/form [:and int? Over6]) ; =&gt; [:and int?  [:int {:min 6, :description &quot;should be over 6&quot;}]]</code>, making large schema hard to read
2. Via registry:, e.g. <code>{&quot;Over6&quot; [:int {:min 6}]}</code> , keeps the reference visible: <code>(m/form [:and int? &quot;Over6&quot;]) ; =&gt; [:and int? &quot;Over6&quot;]</code> keeping the schema forms clean too</z><z id="t1600595778" t="ikitommi added support for m/type-properties -based transformations too. And a way for -m/simple-schema to create the Schema Instances based on actual Schema instance properties."><y>#</y><d>2020-09-20</d><h>09:56</h><w>ikitommi</w>added support for <code>m/type-properties</code> -based transformations too. And a way for <code>-m/simple-schema</code> to create the Schema Instances based on actual Schema instance properties.</z><z id="t1600595953" t="ikitommi Not sure how useful this is, but as the malli lifecycle already supports this, just made it easy to use: (testing &quot;with instance-based type-properties&quot; (let [Over (m/-simple-schema (fn [{:keys [value]} _] (assert (int? value)) {:type :user/over :pred #(and (int? %) (&gt; % value)) :type-properties {:error/message (str &quot;should be over &quot; value) :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum value}}))] (testing &quot;over6&quot; (let [schema [Over {:value 6}]] (testing &quot;form&quot; (is (= [:user/over {:value 6}] (m/form schema)))) (testing &quot;validation&quot; (is (false? (m/validate schema 6))) (is (true? (m/validate schema 7)))) (testing &quot;properties&quot; (is (= {:error/message &quot;should be over 6&quot; :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum 6} (m/type-properties schema))) (is (= {:value 6} (m/properties schema)))))) (testing &quot;over42&quot; (let [schema [Over {:value 42}]] (testing &quot;form&quot; (is (= [:user/over {:value 42}] (m/form schema)))) (testing &quot;validation&quot; (is (false? (m/validate schema 42))) (is (true? (m/validate schema 43)))) (testing &quot;properties&quot; (is (= {:error/message &quot;should be over 42&quot; :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum 42} (m/type-properties schema))) (is (= {:value 42} (m/properties schema))))))))"><y>#</y><d>2020-09-20</d><h>09:59</h><w>ikitommi</w>Not sure how useful this is, but as the malli lifecycle already supports this, just made it easy to use:
<pre>(testing &quot;with instance-based type-properties&quot;
  (let [Over (m/-simple-schema
               (fn [{:keys [value]} _]
                 (assert (int? value))
                 {:type :user/over
                  :pred #(and (int? %) (&gt; % value))
                  :type-properties {:error/message (str &quot;should be over &quot; value)
                                    :decode/string mt/-string-&gt;long
                                    :json-schema/type &quot;integer&quot;
                                    :json-schema/format &quot;int64&quot;
                                    :json-schema/minimum value}}))]

    (testing &quot;over6&quot;
      (let [schema [Over {:value 6}]]
        (testing &quot;form&quot;
          (is (= [:user/over {:value 6}] (m/form schema))))
        (testing &quot;validation&quot;
          (is (false? (m/validate schema 6)))
          (is (true? (m/validate schema 7))))
        (testing &quot;properties&quot;
          (is (= {:error/message &quot;should be over 6&quot;
                  :decode/string mt/-string-&gt;long
                  :json-schema/type &quot;integer&quot;
                  :json-schema/format &quot;int64&quot;
                  :json-schema/minimum 6}
                 (m/type-properties schema)))
          (is (= {:value 6}
                 (m/properties schema))))))

    (testing &quot;over42&quot;
      (let [schema [Over {:value 42}]]
        (testing &quot;form&quot;
          (is (= [:user/over {:value 42}] (m/form schema))))
        (testing &quot;validation&quot;
          (is (false? (m/validate schema 42)))
          (is (true? (m/validate schema 43))))
        (testing &quot;properties&quot;
          (is (= {:error/message &quot;should be over 42&quot;
                  :decode/string mt/-string-&gt;long
                  :json-schema/type &quot;integer&quot;
                  :json-schema/format &quot;int64&quot;
                  :json-schema/minimum 42}
                 (m/type-properties schema)))
          (is (= {:value 42}
                 (m/properties schema))))))))</pre></z><z id="t1600595972" t="ikitommi 🍺 to the first who finds a valid use case for this."><y>#</y><d>2020-09-20</d><h>09:59</h><w>ikitommi</w><b>🍺</b> to the first who finds a valid use case for this.</z><z id="t1600596065" t="ikitommi so m/-simple-schema taks either a props map or a function of properties children =&gt; props so the props (including :type-properties ) can be derived from schema properties."><y>#</y><d>2020-09-20</d><h>10:01</h><w>ikitommi</w>so <code>m/-simple-schema</code> taks either a props map or a function of  <code>properties children =&gt; props</code> so the props (including <code>:type-properties</code>) can be derived from schema properties.</z><z id="t1600620674" t="schmee I’m trying out Malli for the first time: (def schema [:map-of int? uuid?]) (def m {&quot;0&quot; &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot; &quot;1&quot; &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}) (m/decode schema m mt/json-transformer) user=&gt; {&quot;0&quot; #uuid &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot; &quot;1&quot; #uuid &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;} I expected that this code would convert the keys to ints, can I modify the code in some way to make that happen?"><y>#</y><d>2020-09-20</d><h>16:51</h><w>schmee</w>I’m trying out Malli for the first time:
<pre>(def schema [:map-of int? uuid?])
(def m {&quot;0&quot; &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot;
        &quot;1&quot; &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;})
(m/decode schema m mt/json-transformer)
user=&gt; {&quot;0&quot; #uuid &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot;
        &quot;1&quot; #uuid &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}</pre>
I expected that this code would convert the keys to ints, can I modify the code in some way to make that happen?</z><z id="t1600620957" t="ikitommi hi [:attrs {:href &quot;/_/_/users/U3L6TFEJF&quot;}] . The mt/json-transformer doesn’t transform ints from strings as ints can be presented in JSON. But - actually, this only applies to values, so I think the keys should still be converted (as all keys are strings in JSON. Could you write an issue out of this?"><y>#</y><d>2020-09-20</d><h>16:55</h><w>ikitommi</w>hi <a>@schmee</a>. The <code>mt/json-transformer</code> doesn’t transform ints from strings as ints can be presented in JSON. But - actually, this only applies to values, so I think the keys should still be converted (as all keys are strings in JSON. Could you write an issue out of this?</z><z id="t1600620982" t="ikitommi to make it work today, you can use mt/string-transformer which covers that out-of-the-box."><y>#</y><d>2020-09-20</d><h>16:56</h><w>ikitommi</w>to make it work today, you can use <code>mt/string-transformer</code> which covers that out-of-the-box.</z></g><g id="s7"><z id="t1600621008" t="schmee perfect, thanks! I’ll make an issue :thumbsup:"><y>#</y><d>2020-09-20</d><h>16:56</h><w>schmee</w>perfect, thanks! I’ll make an issue <b>:thumbsup:</b></z><z id="t1600621130" t="schmee https://github.com/metosin/malli/issues/259"><y>#</y><d>2020-09-20</d><h>16:58</h><w>schmee</w><a href="https://github.com/metosin/malli/issues/259" target="_blank">https://github.com/metosin/malli/issues/259</a></z><z id="t1600621137" t="ikitommi re-wrote m/-predicate-schema , `m/-partial-predicate-schema` and `m/-leaf-schema` using m/-simple-schema . -39 loc."><y>#</y><d>2020-09-20</d><h>16:58</h><w>ikitommi</w>re-wrote <code>m/-predicate-schema</code>, `m/-partial-predicate-schema` and `m/-leaf-schema` using <code>m/-simple-schema</code>. -39 loc.</z><z id="t1600621153" t="schmee feel free to rename the issue to something that makes more sense to you!"><y>#</y><d>2020-09-20</d><h>16:59</h><w>schmee</w>feel free to rename the issue to something that makes more sense to you!</z><z id="t1600625116" t="ikitommi Actually, the fix was simple, we already had :map-of type transformation. Just needed add a optional argument to the mt/json-transformer that is the string-decoders, which are used for :map-of keys. The full impl looks like:"><y>#</y><d>2020-09-20</d><h>18:05</h><w>ikitommi</w>Actually, the fix was simple, we already had <code>:map-of</code> type transformation. Just needed add a optional argument to the <code>mt/json-transformer</code> that is the string-decoders, which are used for <code>:map-of</code> keys. The full impl looks like:</z><z id="t1600625165" t="ikitommi"><y>#</y><d>2020-09-20</d><h>18:06</h><w>ikitommi</w></z><z id="t1600625307" t="ikitommi and now: (deftest map-of-json-keys-transform (let [schema [:map-of int? uuid?]] (doseq [data [{:0 &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot; :1 &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;} {&quot;0&quot; &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot; &quot;1&quot; &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}]] (is (= {0 #uuid&quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot; 1 #uuid&quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;} (m/decode schema data mt/json-transformer))))))"><y>#</y><d>2020-09-20</d><h>18:08</h><w>ikitommi</w>and now:
<pre>(deftest map-of-json-keys-transform
  (let [schema [:map-of int? uuid?]]
    (doseq [data [{:0 &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot;
                   :1 &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}
                  {&quot;0&quot; &quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot;
                   &quot;1&quot; &quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}]]

      (is (= {0 #uuid&quot;2ac307dc-4ec8-4046-9b7e-57716b7ecfd2&quot;
              1 #uuid&quot;820e5003-6fff-480b-9e2b-ec3cdc5d2f78&quot;}
             (m/decode schema data mt/json-transformer))))))</pre></z><z id="t1600625342" t="ikitommi [:attrs {:href &quot;/_/_/users/U3L6TFEJF&quot;}] fixed in master."><y>#</y><d>2020-09-20</d><h>18:09</h><w>ikitommi</w><a>@schmee</a> fixed in master.</z><z id="t1600628482" t="schmee haha, that is one fast fix, thanks! 😄"><y>#</y><d>2020-09-20</d><h>19:01</h><w>schmee</w>haha, that is one fast fix, thanks! <b>😄</b></z><z id="t1600628488" t="schmee looking forward to playing around more with Malli :thumbsup:"><y>#</y><d>2020-09-20</d><h>19:01</h><w>schmee</w>looking forward to playing around more with Malli <b>:thumbsup:</b></z><z id="t1600762383" t="steveb8n I just started using Malli for json-schema. this lib is becoming a swiss army knife for me 🙂"><y>#</y><d>2020-09-22</d><h>08:13</h><w>steveb8n</w>I just started using Malli for json-schema. this lib is becoming a swiss army knife for me <b>🙂</b></z><z id="t1600764866" t="ts1503 Hello guys. Any ideas when a stable version of malli will arrive? I’m using the malli for a while in production but the latest release broke my app because the transitive dependency doesn’t work with Java 11 ( https://github.com/borkdude/sci ) 😢"><y>#</y><d>2020-09-22</d><h>08:54</h><w>ts1503</w>Hello guys. Any ideas when a stable version of malli will arrive? I’m using the malli for a while in production but the latest release broke my app because the transitive dependency doesn’t work with Java 11 (<a href="https://github.com/borkdude/sci" target="_blank">https://github.com/borkdude/sci</a>) <b>😢</b></z><z id="t1600765018" t="borkdude [:attrs {:href &quot;/_/_/users/UF2GC1JRM&quot;}] sci is optional with malli since a couple of releases, so if you aren&apos;t using it, it should not be a problem"><y>#</y><d>2020-09-22</d><h>08:56</h><w>borkdude</w><a>@sergey.tkachenko</a> sci is optional with malli since a couple of releases, so if you aren&apos;t using it, it should not be a problem</z><z id="t1600765040" t="borkdude if you are using it, then there are instructions in the README of sci what should be done with java 11"><y>#</y><d>2020-09-22</d><h>08:57</h><w>borkdude</w>if you are using it, then there are instructions in the README of sci what should be done with java 11</z><z id="t1600765073" t="ts1503 I’m not using it directly I’m using only a malli"><y>#</y><d>2020-09-22</d><h>08:57</h><w>ts1503</w>I’m not using it directly I’m using only a malli</z><z id="t1600765089" t="borkdude then depending on a newer version of malli should automatically fix this"><y>#</y><d>2020-09-22</d><h>08:58</h><w>borkdude</w>then depending on a newer version of malli should automatically fix this</z><z id="t1600765129" t="ts1503 what is the latest version? I see only a 0.0.1-SNAPSHOT"><y>#</y><d>2020-09-22</d><h>08:58</h><w>ts1503</w>what is the latest version? I see only a <code>0.0.1-SNAPSHOT</code></z><z id="t1600765170" t="ikitommi 0.0.1-20200920.124124-25"><y>#</y><d>2020-09-22</d><h>08:59</h><w>ikitommi</w>0.0.1-20200920.124124-25</z><z id="t1600765172" t="ts1503 and it worked fine for a months but after the latest release/override it broke my build"><y>#</y><d>2020-09-22</d><h>08:59</h><w>ts1503</w>and it worked fine for a months but after the latest release/override it broke my build</z><z id="t1600765188" t="ikitommi all SNAPSHOTs have immutable versions behind them."><y>#</y><d>2020-09-22</d><h>08:59</h><w>ikitommi</w>all SNAPSHOTs have immutable versions behind them.</z><z id="t1600765209" t="ikitommi that version has these deps: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;borkdude&lt;/groupId&gt; &lt;artifactId&gt;dynaload&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;borkdude&lt;/groupId&gt; &lt;artifactId&gt;edamame&lt;/artifactId&gt; &lt;version&gt;0.0.11-alpha.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.clojure&lt;/groupId&gt; &lt;artifactId&gt;test.check&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;"><y>#</y><d>2020-09-22</d><h>09:00</h><w>ikitommi</w>that version has these deps:
<pre>&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;borkdude&lt;/groupId&gt;
      &lt;artifactId&gt;dynaload&lt;/artifactId&gt;
      &lt;version&gt;0.1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;borkdude&lt;/groupId&gt;
      &lt;artifactId&gt;edamame&lt;/artifactId&gt;
      &lt;version&gt;0.0.11-alpha.13&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.clojure&lt;/groupId&gt;
      &lt;artifactId&gt;test.check&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</pre></z><z id="t1600765259" t="ts1503 is this version (0.0.1-20200920.124124-25) in the clojars?"><y>#</y><d>2020-09-22</d><h>09:00</h><w>ts1503</w>is this version (0.0.1-20200920.124124-25) in the clojars?</z><z id="t1600765263" t="ikitommi so, you can use the “previous” SNAPSHOT too, just need to find the full version, e.g. .m2/repository/metosin/malli/0.0.1-SNAPSHOT"><y>#</y><d>2020-09-22</d><h>09:01</h><w>ikitommi</w>so, you can use the “previous” SNAPSHOT too, just need to find the full version, e.g. <code>.m2/repository/metosin/malli/0.0.1-SNAPSHOT</code></z><z id="t1600765269" t="ikitommi yes"><y>#</y><d>2020-09-22</d><h>09:01</h><w>ikitommi</w>yes</z><z id="t1600765313" t="ikitommi ➜ 0.0.1-SNAPSHOT ls -l total 304 -rw-r--r-- 1 tommi staff 405 Sep 21 08:02 _remote.repositories -rw-r--r-- 1 tommi staff 19391 Sep 21 08:02 malli-0.0.1-20200305.102752-13.jar -rw-r--r-- 1 tommi staff 40 Sep 21 08:02 malli-0.0.1-20200305.102752-13.jar.sha1 -rw-r--r-- 1 tommi staff 1692 Sep 21 08:02 malli-0.0.1-20200305.102752-13.pom -rw-r--r-- 1 tommi staff 40 Sep 21 08:02 malli-0.0.1-20200305.102752-13.pom.sha1 -rw-r--r-- 1 tommi staff 24437 Sep 21 07:37 malli-0.0.1-20200715.082439-21.jar -rw-r--r-- 1 tommi staff 40 Sep 21 07:37 malli-0.0.1-20200715.082439-21.jar.sha1 -rw-r--r-- 1 tommi staff 1692 Sep 21 07:37 malli-0.0.1-20200715.082439-21.pom -rw-r--r-- 1 tommi staff 40 Sep 21 07:37 malli-0.0.1-20200715.082439-21.pom.sha1 -rw-r--r-- 1 tommi staff 27727 Sep 20 15:43 malli-0.0.1-20200920.124124-25.jar -rw-r--r-- 1 tommi staff 40 Sep 20 15:43 malli-0.0.1-20200920.124124-25.jar.sha1 -rw-r--r-- 1 tommi staff 1547 Sep 20 15:43 malli-0.0.1-20200920.124124-25.pom -rw-r--r-- 1 tommi staff 40 Sep 20 15:43 malli-0.0.1-20200920.124124-25.pom.sha1 -rw-r--r-- 1 tommi staff 24437 Sep 21 07:37 malli-0.0.1-SNAPSHOT.jar -rw-r--r-- 1 tommi staff 1692 Sep 21 07:37 malli-0.0.1-SNAPSHOT.pom -rw-r--r-- 1 tommi staff 765 Sep 20 15:43 maven-metadata-clojars.xml -rw-r--r-- 1 tommi staff 40 Sep 20 15:43 maven-metadata-clojars.xml.sha1 -rw-r--r-- 1 tommi staff 370 Sep 20 15:43 resolver-status.properties"><y>#</y><d>2020-09-22</d><h>09:01</h><r>ikitommi</r><pre>➜  0.0.1-SNAPSHOT ls -l
total 304
-rw-r--r--  1 tommi  staff    405 Sep 21 08:02 _remote.repositories
-rw-r--r--  1 tommi  staff  19391 Sep 21 08:02 malli-0.0.1-20200305.102752-13.jar
-rw-r--r--  1 tommi  staff     40 Sep 21 08:02 malli-0.0.1-20200305.102752-13.jar.sha1
-rw-r--r--  1 tommi  staff   1692 Sep 21 08:02 malli-0.0.1-20200305.102752-13.pom
-rw-r--r--  1 tommi  staff     40 Sep 21 08:02 malli-0.0.1-20200305.102752-13.pom.sha1
-rw-r--r--  1 tommi  staff  24437 Sep 21 07:37 malli-0.0.1-20200715.082439-21.jar
-rw-r--r--  1 tommi  staff     40 Sep 21 07:37 malli-0.0.1-20200715.082439-21.jar.sha1
-rw-r--r--  1 tommi  staff   1692 Sep 21 07:37 malli-0.0.1-20200715.082439-21.pom
-rw-r--r--  1 tommi  staff     40 Sep 21 07:37 malli-0.0.1-20200715.082439-21.pom.sha1
-rw-r--r--  1 tommi  staff  27727 Sep 20 15:43 malli-0.0.1-20200920.124124-25.jar
-rw-r--r--  1 tommi  staff     40 Sep 20 15:43 malli-0.0.1-20200920.124124-25.jar.sha1
-rw-r--r--  1 tommi  staff   1547 Sep 20 15:43 malli-0.0.1-20200920.124124-25.pom
-rw-r--r--  1 tommi  staff     40 Sep 20 15:43 malli-0.0.1-20200920.124124-25.pom.sha1
-rw-r--r--  1 tommi  staff  24437 Sep 21 07:37 malli-0.0.1-SNAPSHOT.jar
-rw-r--r--  1 tommi  staff   1692 Sep 21 07:37 malli-0.0.1-SNAPSHOT.pom
-rw-r--r--  1 tommi  staff    765 Sep 20 15:43 maven-metadata-clojars.xml
-rw-r--r--  1 tommi  staff     40 Sep 20 15:43 maven-metadata-clojars.xml.sha1
-rw-r--r--  1 tommi  staff    370 Sep 20 15:43 resolver-status.properties</pre></z><z id="t1600765272" t="ikitommi … should be."><y>#</y><d>2020-09-22</d><h>09:01</h><w>ikitommi</w>… should be.</z><z id="t1600765301" t="borkdude I used to have a way of seeing these fully qualified snapshot versions on clojars. forgot"><y>#</y><d>2020-09-22</d><h>09:01</h><w>borkdude</w>I used to have a way of seeing these fully qualified snapshot versions on clojars. forgot</z><z id="t1600765310" t="borkdude I usually look it up in CI when it is pushed"><y>#</y><d>2020-09-22</d><h>09:01</h><w>borkdude</w>I usually look it up in CI when it is pushed</z><z id="t1600765316" t="ts1503 there is only a snapshot"><y>#</y><d>2020-09-22</d><h>09:01</h><w>ts1503</w>there is only a snapshot</z><z id="t1600765344" t="ts1503 or I’m missing something?"><y>#</y><d>2020-09-22</d><h>09:02</h><w>ts1503</w>or I’m missing something?</z><z id="t1600765394" t="borkdude btw [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] please bump dynaload to 0.2.2 :)"><y>#</y><d>2020-09-22</d><h>09:03</h><w>borkdude</w>btw <a>@ikitommi</a> please bump dynaload to 0.2.2 :)</z><z id="t1600765456" t="ikitommi will do + publish a new version out."><y>#</y><d>2020-09-22</d><h>09:04</h><w>ikitommi</w>will do  + publish a new version out.</z><z id="t1600768962" t="ikitommi updated dynaload and pushed to clojars, ping [:attrs {:href &quot;/_/_/users/UF2GC1JRM&quot;}]"><y>#</y><d>2020-09-22</d><h>10:02</h><w>ikitommi</w>updated dynaload and pushed to clojars, ping <a>@sergey.tkachenko</a></z><z id="t1600768969" t="ikitommi Downloading: metosin/malli/0.0.1-SNAPSHOT/malli-0.0.1-20200922.100025-26.pom from clojars"><y>#</y><d>2020-09-22</d><h>10:02</h><w>ikitommi</w><pre>Downloading: metosin/malli/0.0.1-SNAPSHOT/malli-0.0.1-20200922.100025-26.pom from clojars</pre></z><z id="t1600768977" t="ikitommi that’s the immutable version handle to it."><y>#</y><d>2020-09-22</d><h>10:02</h><w>ikitommi</w>that’s the immutable version handle to it.</z><z id="t1600769497" t="ts1503 Thanks"><y>#</y><d>2020-09-22</d><h>10:11</h><w>ts1503</w>Thanks</z><z id="t1600827897" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] This issue might be interesting for Malli, specially before the release. https://github.com/green-coder/minimallist/issues/8"><y>#</y><d>2020-09-23</d><h>02:24</h><w>Vincent Cantin</w><a>@ikitommi</a> This issue might be interesting for Malli, specially before the release. <a href="https://github.com/green-coder/minimallist/issues/8" target="_blank">https://github.com/green-coder/minimallist/issues/8</a></z><z id="t1600838184" t="ikitommi [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] that is the case of mixing :map and :map-of right? the issue and discussion in malli-side here: https://github.com/metosin/malli/issues/43"><y>#</y><d>2020-09-23</d><h>05:16</h><w>ikitommi</w><a>@vincent.cantin</a> that is the case of mixing <code>:map</code> and <code>:map-of</code> right? the issue and discussion in malli-side here: <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a></z><z id="t1600843915" t="ikitommi discussion about dates, need this (date range validation) in a work project, comments welcome: https://github.com/metosin/malli/issues/49"><y>#</y><d>2020-09-23</d><h>06:51</h><w>ikitommi</w>discussion about dates, need this (date range validation) in a work project, comments welcome: <a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a></z><z id="t1600844270" t="ikitommi a good backgrounder: http://widdindustries.com/ecma-temporal-vs-java-time/"><y>#</y><d>2020-09-23</d><h>06:57</h><w>ikitommi</w>a good backgrounder: <a href="http://widdindustries.com/ecma-temporal-vs-java-time/" target="_blank">http://widdindustries.com/ecma-temporal-vs-java-time/</a></z><z id="t1600904594" t="dcj I have some code I wrote a few months back that made use of map-entries which is now gone... IIRC, map-entries returned a collection of [key properties value-schema] ? AFAICT in my old code, I would get this, and access the key or the properties, what should I do to move my code to entries ? What exactly is a -val-schema ?"><y>#</y><d>2020-09-23</d><h>23:43</h><w>dcj</w>I have some code I wrote a few months back that made use of <code>map-entries</code> which is now gone...
IIRC, <code>map-entries</code> returned a collection of <code>[key properties value-schema]</code> ?
AFAICT in my old code, I would get this, and access the key or the properties, what should I do to move my code to <code>entries</code>?
What exactly is a <code>-val-schema</code>?</z><z id="t1600919322" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] there is poor man&apos;s documentation about that change in CHANGELOG. The m/children returns the [key properties schema] tuple3s, so just use that instead. The new m/entries (renamed iit so it&apos;s not a silent/evil breakage) is needed to effectively use the entry properties in schema applications like value transformation and schema transformations."><y>#</y><d>2020-09-24</d><h>03:48</h><w>ikitommi</w><a>@dcj</a> there is poor man&apos;s documentation about that change in CHANGELOG. The <code>m/children</code> returns the <code>[key properties schema]</code> tuple3s, so just use that instead. The new <code>m/entries</code> (renamed iit so it&apos;s not a silent/evil breakage) is needed to effectively use the entry properties in schema applications like value transformation and schema transformations.</z><z id="t1600920160" t="ikitommi there is a long discussion about the options and the second in the related issue ( https://github.com/metosin/malli/pull/212 ) and it&apos;s also documented in docstrings now: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1127-L1155"><y>#</y><d>2020-09-24</d><h>04:02</h><w>ikitommi</w>there is a long discussion about the options and the second in the related issue (<a href="https://github.com/metosin/malli/pull/212" target="_blank">https://github.com/metosin/malli/pull/212</a>) and it&apos;s also documented in docstrings now: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1127-L1155" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1127-L1155</a></z><z id="t1600926534" t="Dave Simmons Morning - I&apos;ve been using Malli for the last few month. Last night when compiling my code lein pulled down a new version. I now get a failure when trying to compile my project Exception in thread &quot;main&quot; Syntax error compiling at (malli/core.cljc:1164:1)."><y>#</y><d>2020-09-24</d><h>05:48</h><w>Dave Simmons</w>Morning - I&apos;ve been using Malli for the last few month. Last night when compiling my code lein pulled down a new version. I now get a failure when trying to compile my project Exception in thread &quot;main&quot; Syntax error compiling at (malli/core.cljc:1164:1).</z><z id="t1600926580" t="Dave Simmons I pulled down an earlier version of my project but in case I&apos;d done something daft but still get the same problem. Has anyone else experienced this issue? cheers."><y>#</y><d>2020-09-24</d><h>05:49</h><w>Dave Simmons</w>I pulled down an earlier version of my project but in case I&apos;d done something daft but still get the same problem. Has anyone else experienced this issue? cheers.</z><z id="t1600927873" t="ikitommi [:attrs {:href &quot;/_/_/users/UUW2H9LG2&quot;}] i can reproduce. the new dynaload works differently (better!), will fix that."><y>#</y><d>2020-09-24</d><h>06:11</h><w>ikitommi</w><a>@shortlyportly</a> i can reproduce. the new dynaload works differently (better!), will fix that.</z><z id="t1600928493" t="Dave Simmons [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] - awesome - many thanks."><y>#</y><d>2020-09-24</d><h>06:21</h><w>Dave Simmons</w><a>@ikitommi</a> - awesome - many thanks.</z><z id="t1600929178" t="ikitommi [:attrs {:href &quot;/_/_/users/UUW2H9LG2&quot;}] should be fixed in master &amp; [metosin/malli &quot;0.0.1-20200924.063109-27&quot;] , ping [:attrs {:href &quot;/_/_/users/UF2GC1JRM&quot;}] too."><y>#</y><d>2020-09-24</d><h>06:32</h><w>ikitommi</w><a>@shortlyportly</a> should be fixed in master &amp; <code>[metosin/malli &quot;0.0.1-20200924.063109-27&quot;]</code>, ping <a>@sergey.tkachenko</a> too.</z><z id="t1600929401" t="ikitommi https://github.com/metosin/malli/pull/261"><y>#</y><d>2020-09-24</d><h>06:36</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/261" target="_blank">https://github.com/metosin/malli/pull/261</a></z><z id="t1600929304" t="ikitommi also, sci is now loaded when it’s first used. Using preload (cljs) or direct require (cljs, graalvm, jvm) makes it eager. But: having sci on classpath and not needing it, means it wont get loaded by malli, yielding faster startup time: (time (require &apos;[malli.core :as m])) &quot;Elapsed time: 466.76624 msecs&quot; =&gt; nil (time (m/eval &quot;(+ 1 1)&quot;)) &quot;Elapsed time: 1591.515317 msecs&quot; =&gt; 2 (time (m/eval &quot;(+ 1 1)&quot;)) &quot;Elapsed time: 0.587728 msecs&quot; =&gt; 2 (time (m/eval &quot;(+ 1 1)&quot;)) &quot;Elapsed time: 0.772357 msecs&quot; =&gt; 2"><y>#</y><d>2020-09-24</d><h>06:35</h><w>ikitommi</w>also, sci is now loaded when it’s first used. Using preload (cljs) or direct require (cljs, graalvm, jvm) makes it eager. But: having sci on classpath and not needing it, means it wont get loaded by malli, yielding faster startup time:
<pre>(time (require &apos;[malli.core :as m]))
&quot;Elapsed time: 466.76624 msecs&quot;
=&gt; nil
(time (m/eval &quot;(+ 1 1)&quot;))
&quot;Elapsed time: 1591.515317 msecs&quot;
=&gt; 2
(time (m/eval &quot;(+ 1 1)&quot;))
&quot;Elapsed time: 0.587728 msecs&quot;
=&gt; 2
(time (m/eval &quot;(+ 1 1)&quot;))
&quot;Elapsed time: 0.772357 msecs&quot;
=&gt; 2</pre></z><z id="t1600929359" t="ikitommi when clj command line tooling 3rd party library aot caching works, this can be made eager again."><y>#</y><d>2020-09-24</d><h>06:35</h><w>ikitommi</w>when clj command line tooling 3rd party library aot caching works, this can be made eager again.</z><z id="t1600930880" t="Dave Simmons [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] - thank you - seems to be back and working. cheers"><y>#</y><d>2020-09-24</d><h>07:01</h><w>Dave Simmons</w><a>@ikitommi</a> - thank you - seems to be back and working. cheers</z><z id="t1600964960" t="dcj Next change, m/fn-schema went away? How should I change the below.... (def registry (merge (m/predicate-schemas) (m/class-schemas) (m/comparator-schemas) (m/base-schemas) {:zoned-date-time (m/fn-schema :zoned-date-time #&apos;zoned-date-time?) :local-date (m/fn-schema :local-date #&apos;local-date?)})) "><y>#</y><d>2020-09-24</d><h>16:29</h><w>dcj</w>Next change, <code>m/fn-schema</code> went away?
How should I change the below....
<pre>(def registry
  (merge (m/predicate-schemas)
         (m/class-schemas)
         (m/comparator-schemas)
         (m/base-schemas)
         {:zoned-date-time (m/fn-schema :zoned-date-time #&apos;zoned-date-time?)
          :local-date      (m/fn-schema :local-date      #&apos;local-date?)}))</pre>
</z><z id="t1600965587" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] there were 4 variants of the same thing, fn-schema , leaf-schema , predicate-schema , partial-predicate-schena , all replaced by m/-simple-schema . Also, there is way to reset the default registry now. But the schema: (m/-simple-schema {:type :local-date, :pred #&apos;local-date?})"><y>#</y><d>2020-09-24</d><h>16:39</h><w>ikitommi</w><a>@dcj</a> there were 4 variants of the same thing, <code>fn-schema</code>,  <code>leaf-schema</code>,  <code>predicate-schema</code>, <code>partial-predicate-schena</code> , all replaced by <code>m/-simple-schema</code>. Also, there is way to reset the default registry now. But the schema:
<pre>(m/-simple-schema {:type :local-date, :pred #&apos;local-date?})</pre></z><z id="t1600966166" t="ikitommi it also give you a way to read the schema properties and use them for the validation or transformation: (def Date (m/-simple-schema (fn [{:keys [format type min]} children] ;; check props and children here, at schema instance creation time (let [string-&gt;date (create-formatter-somehow format) min-date (string-&gt;date min] {:type :local-date :pred (fn [x] (and (instance? type x) (check-that-is-greater-than min)) :type-properties {:decode/string string-&gt;date :error/message {:en &quot;should be date&quot;} :gen/gen generator-for-date}}))) (def LocalDateThisYear [Date {:format &quot;YYYY-MM-DD&quot;, :min &quot;2020-01-01&quot;, :type java.time.LocalDate}]) (m/validate LocalDateThisYear #time/local-date &quot;2020-12-12&quot;) ; =&gt; true (m/decode LocalDateThisYear &quot;2020-12-12&quot; mt/string-decoder) ; =&gt; #time/local-date &quot;2020-12-12&quot;"><y>#</y><d>2020-09-24</d><h>16:49</h><w>ikitommi</w>it also give you a way to read the schema properties and use them for the validation or transformation:
<pre>(def Date
  (m/-simple-schema 
    (fn [{:keys [format type min]} children]
      ;; check props and children here, at schema instance creation time
      (let [string-&gt;date (create-formatter-somehow format)
            min-date (string-&gt;date min]
        {:type :local-date
         :pred (fn [x] (and (instance? type x) (check-that-is-greater-than min))
         :type-properties {:decode/string string-&gt;date
                           :error/message {:en &quot;should be date&quot;}
                           :gen/gen generator-for-date}})))

(def LocalDateThisYear
  [Date {:format &quot;YYYY-MM-DD&quot;, :min &quot;2020-01-01&quot;, :type java.time.LocalDate}])

(m/validate LocalDateThisYear #time/local-date &quot;2020-12-12&quot;) ; =&gt; true

(m/decode LocalDateThisYear &quot;2020-12-12&quot; mt/string-decoder) ; =&gt; #time/local-date &quot;2020-12-12&quot;</pre></z><z id="t1600966332" t="ikitommi (def registry (merge (m/-predicate-schemas) (m/-class-schemas) (m/-comparator-schemas) (m/-base-schemas) (m/-type-schema) ;; &lt;--- new too {:zoned-date-time (m/-simple-schema {:type :zoned-date-time, :pred #&apos;zoned-date-time?}) :local-date (m/-simple-schema {:type :local-date, :pred #&apos;local-date?})}))"><y>#</y><d>2020-09-24</d><h>16:52</h><w>ikitommi</w><pre>(def registry
  (merge (m/-predicate-schemas)
         (m/-class-schemas)
         (m/-comparator-schemas)
         (m/-base-schemas)
         (m/-type-schema) ;; &lt;--- new too
         {:zoned-date-time (m/-simple-schema {:type :zoned-date-time, :pred #&apos;zoned-date-time?})
          :local-date      (m/-simple-schema {:type :local-date,      :pred #&apos;local-date?})}))</pre></z><z id="t1600966445" t="dcj [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] : Thank you for all this help/context/insight!"><y>#</y><d>2020-09-24</d><h>16:54</h><w>dcj</w><a>@ikitommi</a>: Thank you for all this help/context/insight!</z><z id="t1600974061" t="ikitommi added tests and merged the lazy registries &amp; lazy multi. Here’s the final api: (def registry (mr/lazy-registry (m/default-schemas) (fn [type registry] ;; simulates pulling CloudFormation Schemas when needed (let [lookup {&quot;AWS::ApiGateway::UsagePlan&quot; [:map {:closed true} [:Type [:= &quot;AWS::ApiGateway::UsagePlan&quot;]] [:Description {:optional true} string?] [:UsagePlanName {:optional true} string?]] &quot;AWS::AppSync::ApiKey&quot; [:map {:closed true} [:Type [:= &quot;AWS::AppSync::ApiKey&quot;]] [:ApiId string?] [:Description {:optional true} string?]]}] (println &quot;... loaded&quot; type) (some-&gt; type lookup (m/schema {:registry registry})))))) ;; lazy multi, doesn&apos;t realize the schemas (def CloudFormation (m/schema [:multi {:dispatch :Type, :lazy-refs true} &quot;AWS::ApiGateway::UsagePlan&quot; &quot;AWS::AppSync::ApiKey&quot;] {:registry registry})) (m/validate CloudFormation {:Type &quot;AWS::ApiGateway::UsagePlan&quot; :Description &quot;laiskanlinna&quot;}) ; ... loaded AWS::ApiGateway::UsagePlan ; =&gt; true (m/validate CloudFormation {:Type &quot;AWS::ApiGateway::UsagePlan&quot; :Description &quot;laiskanlinna&quot;}) ; =&gt; true"><y>#</y><d>2020-09-24</d><h>19:01</h><w>ikitommi</w>added tests and merged the lazy registries &amp; lazy multi. Here’s the final api:
<pre>(def registry
  (mr/lazy-registry
    (m/default-schemas)
    (fn [type registry]
      ;; simulates pulling CloudFormation Schemas when needed
      (let [lookup {&quot;AWS::ApiGateway::UsagePlan&quot; [:map {:closed true}
                                                  [:Type [:= &quot;AWS::ApiGateway::UsagePlan&quot;]]
                                                  [:Description {:optional true} string?]
                                                  [:UsagePlanName {:optional true} string?]]
                    &quot;AWS::AppSync::ApiKey&quot; [:map {:closed true}
                                            [:Type [:= &quot;AWS::AppSync::ApiKey&quot;]]
                                            [:ApiId string?]
                                            [:Description {:optional true} string?]]}]
        (println &quot;... loaded&quot; type)
        (some-&gt; type lookup (m/schema {:registry registry}))))))

;; lazy multi, doesn&apos;t realize the schemas
(def CloudFormation
  (m/schema
    [:multi {:dispatch :Type, :lazy-refs true}
     &quot;AWS::ApiGateway::UsagePlan&quot;
     &quot;AWS::AppSync::ApiKey&quot;]
    {:registry registry}))

(m/validate
  CloudFormation
  {:Type &quot;AWS::ApiGateway::UsagePlan&quot;
   :Description &quot;laiskanlinna&quot;})
; ... loaded AWS::ApiGateway::UsagePlan
; =&gt; true

(m/validate
  CloudFormation
  {:Type &quot;AWS::ApiGateway::UsagePlan&quot;
   :Description &quot;laiskanlinna&quot;})
; =&gt; true</pre></z><z id="t1601047157" t="jeroenvandijk Thank you!"><y>#</y><d>2020-09-25</d><h>15:19</h><r>jeroenvandijk</r>Thank you!</z><z id="t1600974198" t="ikitommi has also the :multi key spell-checker: (deftest multi-error-test (let [schema [:multi {:dispatch :type} [&quot;plus&quot; [:map [:value int?]]] [&quot;minus&quot; [:map [:value int?]]]]] (is (= {:type [&quot;invalid dispatch value&quot;]} (-&gt; schema (m/explain {:type &quot;minuz&quot;}) (me/humanize)))) (is (= {:type [&quot;did you mean minus&quot;]} (-&gt; schema (m/explain {:type &quot;minuz&quot;}) (me/with-spell-checking) (me/humanize))))))"><y>#</y><d>2020-09-24</d><h>19:03</h><w>ikitommi</w>has also the <code>:multi</code> key spell-checker:
<pre>(deftest multi-error-test
  (let [schema [:multi {:dispatch :type}
                [&quot;plus&quot; [:map [:value int?]]]
                [&quot;minus&quot; [:map [:value int?]]]]]

    (is (= {:type [&quot;invalid dispatch value&quot;]}
           (-&gt; schema
               (m/explain {:type &quot;minuz&quot;})
               (me/humanize))))

    (is (= {:type [&quot;did you mean minus&quot;]}
           (-&gt; schema
               (m/explain {:type &quot;minuz&quot;})
               (me/with-spell-checking)
               (me/humanize))))))</pre></z><z id="t1601046917" t="borkdude Now I remember how to see all the immutable SNAPSHOTS: http://repo.clojars.org/metosin/malli/0.0.1-SNAPSHOT/ [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2020-09-25</d><h>15:15</h><w>borkdude</w>Now I remember how to see all the immutable SNAPSHOTS:
<a href="http://repo.clojars.org/metosin/malli/0.0.1-SNAPSHOT/" target="_blank">http://repo.clojars.org/metosin/malli/0.0.1-SNAPSHOT/</a>
<a>@ikitommi</a></z><z id="t1601048010" t="dcj How would one specify one of these immutable snapshots in a lein project.clj? I attempted to do exactly that earlier this week, but failed miserably...."><y>#</y><d>2020-09-25</d><h>15:33</h><r>dcj</r>How would one specify one of these immutable snapshots in a lein project.clj?
I attempted to do exactly that earlier this week, but failed miserably....</z><z id="t1601048213" t="borkdude e.g. [metosin/malli &quot;0.0.1-20200924.063109-27&quot;]"><y>#</y><d>2020-09-25</d><h>15:36</h><r>borkdude</r>e.g. <code>[metosin/malli &quot;0.0.1-20200924.063109-27&quot;]</code></z><z id="t1601053568" t="kwrooijen Very handy. Thanks!"><y>#</y><d>2020-09-25</d><h>17:06</h><r>kwrooijen</r>Very handy. Thanks!</z><z id="t1601047384" t="ikitommi great, thanks!"><y>#</y><d>2020-09-25</d><h>15:23</h><w>ikitommi</w>great, thanks!</z><z id="t1601373944" t="ikitommi I must have asked this before, but is there an example how to add tests “works on GraalVM too”?"><y>#</y><d>2020-09-29</d><h>10:05</h><w>ikitommi</w>I must have asked this before, but is there an example how to add tests “works on GraalVM too”?</z><z id="t1601374581" t="ikitommi Current: (m/schema [:tuple int? int?]) ; =&gt; [:tuple int? int?] Should it be: (m/schema [:tuple int? int?]) ; =&gt; #malli/schema[:tuple int? int?] (m/form (m/schema [:tuple int? int?])) ; =&gt; [:tuple int? int?] GOOD: • schemas look like schemas, not forms BAD: • can’t pr-str a schema and read it back with m/schema , would need malli.edn/read-string "><y>#</y><d>2020-09-29</d><h>10:16</h><w>ikitommi</w>Current:
<pre>(m/schema [:tuple int? int?])
; =&gt; [:tuple int? int?]</pre>
Should it be:
<pre>(m/schema [:tuple int? int?])
; =&gt; #malli/schema[:tuple int? int?]

(m/form (m/schema [:tuple int? int?]))
; =&gt; [:tuple int? int?]</pre>
GOOD:
• schemas look like schemas, not forms
BAD:
• can’t <code>pr-str</code> a schema and read it back with <code>m/schema</code>, would need <code>malli.edn/read-string</code> </z><z id="t1601680020" t="dcj Is there a path from Swagger/JSON-Schema -&gt; Malli? I know there are paths the other way.... I don&apos;t expect this would be perfect and require no thought, but imagine I encounter something described by Swagger/JSON-Schema I need/want to deal with from Clojure, Some sort of malli translator that generated a best-effort malli schema, and also included the &quot;and here is how to get back to JSON-Schema/Swagger&quot; properties, and then I would edit away on the Clojure/Mailli side of the schema to make it how I want..."><y>#</y><d>2020-10-02</d><h>23:07</h><w>dcj</w>Is there a path from Swagger/JSON-Schema -&gt; Malli?  I know there are paths the other way....
I don&apos;t expect this would be perfect and require no thought,
but imagine I encounter something described by Swagger/JSON-Schema I need/want to deal with from Clojure,
Some sort of malli translator that generated a best-effort malli schema, and also included the &quot;and here is how to get back to JSON-Schema/Swagger&quot; properties, and then I would edit away on the Clojure/Mailli side of the schema to make it how I want...</z><z id="t1601802877" t="ikitommi [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] not yet, but there is https://github.com/metosin/malli/pull/211 and I recall other people trying that too. Don&apos;t have time to dig in to this yet, but would love to get that to work with malli"><y>#</y><d>2020-10-04</d><h>09:14</h><w>ikitommi</w><a>@dcj</a> not yet, but there is <a href="https://github.com/metosin/malli/pull/211" target="_blank">https://github.com/metosin/malli/pull/211</a> and I recall other people trying that too. Don&apos;t have time to dig in to this yet, but would love to get that to work with malli</z><z id="t1601802976" t="ikitommi someone was doing this for spec and I believe https://github.com/oliyh/martian has partial impl for plumatic schema."><y>#</y><d>2020-10-04</d><h>09:16</h><w>ikitommi</w>someone was doing this for spec and I believe <a href="https://github.com/oliyh/martian" target="_blank">https://github.com/oliyh/martian</a> has partial impl for plumatic schema.</z><z id="t1602031878" t="steveb8n Q: is there a typo in the readme in the custom registry section? :post-int"><y>#</y><d>2020-10-07</d><h>00:51</h><w>steveb8n</w>Q: is there a typo in the readme in the custom registry section? <code>:post-int</code></z><z id="t1602032319" t="steveb8n Another one: is m/s-simple-schema a typo? This fn doesn’t exit"><y>#</y><d>2020-10-07</d><h>00:58</h><w>steveb8n</w>Another one: is <code>m/s-simple-schema</code> a typo? This fn doesn’t exit</z><z id="t1602045922" t="ikitommi welcome [:attrs {:href &quot;/_/_/users/U76D9RZRR&quot;}] ! first one definitely a typo, could not find the latter. But PR welcome to fix any typos."><y>#</y><d>2020-10-07</d><h>04:45</h><w>ikitommi</w>welcome <a>@kari.marttila</a>! first one definitely a typo, could not find the latter. But PR welcome to fix any typos.</z><z id="t1602046404" t="steveb8n ok. I’ll make a PR for both"><y>#</y><d>2020-10-07</d><h>04:53</h><w>steveb8n</w>ok. I’ll make a PR for both</z><z id="t1602046500" t="steveb8n scratch that. I don’t know what you would use to replace the second one. I’ll PR for the typo"><y>#</y><d>2020-10-07</d><h>04:55</h><w>steveb8n</w>scratch that. I don’t know what you would use to replace the second one. I’ll PR for the typo</z><z id="t1602046523" t="steveb8n here’s the second one… Custom registry Example to create a custom registry without the default core predicates and with :bool and :pos-int Schemas: (def registry (merge (m/class-schemas) (m/comparator-schemas) (m/base-schemas) {:bool (m/-simple-schema {:type :bool, :pred boolean?}) :pos-int (m/-simple-schema {:type :pos-int, :pred pos-int?})})) (m/validate [:or :bool :pos-int] &apos;kikka {:registry registry}) ; =&gt; false (m/validate [:or :bool :post-int] 123 {:registry registry}) ; =&gt; true"><y>#</y><d>2020-10-07</d><h>04:55</h><w>steveb8n</w>here’s the second one…
<pre>Custom registry
Example to create a custom registry without the default core predicates and with :bool and :pos-int Schemas:

(def registry
  (merge
    (m/class-schemas)
    (m/comparator-schemas)
    (m/base-schemas)
    {:bool (m/-simple-schema {:type :bool, :pred boolean?})
     :pos-int (m/-simple-schema {:type :pos-int, :pred pos-int?})}))

(m/validate [:or :bool :pos-int] &apos;kikka {:registry registry})
; =&gt; false

(m/validate [:or :bool :post-int] 123 {:registry registry})
; =&gt; true</pre></z><z id="t1602046567" t="steveb8n m/-simple-schema doesn’t exist as a fn. I’m not sure what you would use instead"><y>#</y><d>2020-10-07</d><h>04:56</h><w>steveb8n</w><code>m/-simple-schema</code> doesn’t exist as a fn. I’m not sure what you would use instead</z><z id="t1602047409" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L211"><y>#</y><d>2020-10-07</d><h>05:10</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L211" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L211</a></z><z id="t1602047419" t="ikitommi are you using the latest version?"><y>#</y><d>2020-10-07</d><h>05:10</h><r>ikitommi</r>are you using the latest version?</z><z id="t1602049638" t="steveb8n ah, no. I’m not. sorry. my mistake"><y>#</y><d>2020-10-07</d><h>05:47</h><r>steveb8n</r>ah, no. I’m not. sorry. my mistake</z><z id="t1602075125" t="ikitommi ok, plan is to ship 0.1.0 tomorrow. going to clean up some internals and polish some docs, but anything relevant missing? the GraalVM tests? https://github.com/metosin/malli/pull/272"><y>#</y><d>2020-10-07</d><h>12:52</h><w>ikitommi</w>ok, plan is to ship 0.1.0 tomorrow. going to clean up some internals and polish some docs, but anything relevant missing? the GraalVM tests? <a href="https://github.com/metosin/malli/pull/272" target="_blank">https://github.com/metosin/malli/pull/272</a></z><z id="t1602075215" t="ikitommi also, removing :list as it’s not very useful, right?"><y>#</y><d>2020-10-07</d><h>12:53</h><w>ikitommi</w>also, removing <code>:list</code> as it’s not very useful, right?</z><z id="t1602143536" t="steveb8n I haven’t used it fwiw"><y>#</y><d>2020-10-08</d><h>07:52</h><r>steveb8n</r>I haven’t used it fwiw</z><z id="t1602140983" t="ikitommi"><y>#</y><d>2020-10-08</d><h>07:09</h><w>ikitommi</w></z><z id="t1602146874" t="borkdude What&apos;s the binary size?"><y>#</y><d>2020-10-08</d><h>08:47</h><w>borkdude</w>What&apos;s the binary size?</z><z id="t1602151037" t="ikitommi 18mb, with sci"><y>#</y><d>2020-10-08</d><h>09:57</h><w>ikitommi</w>18mb, with sci</z><z id="t1602151228" t="borkdude Sounds about right "><y>#</y><d>2020-10-08</d><h>10:00</h><w>borkdude</w>Sounds about right </z><z id="t1602151231" t="ikitommi 11mb without"><y>#</y><d>2020-10-08</d><h>10:00</h><w>ikitommi</w>11mb without</z><z id="t1602151239" t="borkdude Also sounds right!"><y>#</y><d>2020-10-08</d><h>10:00</h><w>borkdude</w>Also sounds right!</z><z id="t1602177428" t="ikitommi [metosin/malli &quot;0.1.0&quot;] • clojars ✅ • clojureverse ✅ • metosin blog ✅ • #malli ✅ • reddit ✅ • twitter ✅ • #announcements ✅"><y>#</y><d>2020-10-08</d><h>17:17</h><w>ikitommi</w><code>[metosin/malli &quot;0.1.0&quot;]</code>

• clojars <b>✅</b> 
• clojureverse <b>✅</b> 
• metosin blog <b>✅</b> 
• #malli <b>✅</b> 
• reddit <b>✅</b> 
• twitter <b>✅</b> 
• #announcements <b>✅</b></z><z id="t1602177991" t="ikitommi ok, thank you everyone, Malli is officially out! if there are more places to share, please do."><y>#</y><d>2020-10-08</d><h>17:26</h><w>ikitommi</w>ok, thank you everyone, Malli is officially out! if there are more places to share, please do.</z><z id="t1602180202" t="dcj Congrats! And thank you for your amazing work on this!"><y>#</y><d>2020-10-08</d><h>18:03</h><r>dcj</r>Congrats!  And thank you for your amazing work on this!</z><z id="t1602226142" t="ikitommi thanks!"><y>#</y><d>2020-10-09</d><h>06:49</h><r>ikitommi</r>thanks!</z><z id="t1602179937" t="dharrigan Is it still alpha ?"><y>#</y><d>2020-10-08</d><h>17:58</h><w>dharrigan</w>Is it still <code>alpha</code>?</z><z id="t1602180482" t="borkdude [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] I think it went from pre-alpha to alpha now. So in Clojure world, it&apos;s production time? 😆"><y>#</y><d>2020-10-08</d><h>18:08</h><w>borkdude</w><a>@dharrigan</a> I think it went from pre-alpha to alpha now. So in Clojure world, it&apos;s production time? <b>😆</b></z><z id="t1602180552" t="dharrigan Yeah, that&apos;s what I think. I think, given what happened a few weeks/months ago, about the push from the core team to move away from eternal alpha to better versions, and given that malli is now out, then perhaps alpha isn&apos;t the right term here?"><y>#</y><d>2020-10-08</d><h>18:09</h><w>dharrigan</w>Yeah, that&apos;s what I think. I think, given what happened a few weeks/months ago, about the push from the core team to move away from eternal alpha to better versions, and given that malli is now out, then perhaps <code>alpha</code> isn&apos;t the right term here?</z><z id="t1602180578" t="dharrigan It&apos;s not even beta anymore"><y>#</y><d>2020-10-08</d><h>18:09</h><w>dharrigan</w>It&apos;s not even beta anymore</z><z id="t1602180674" t="borkdude What move away from eternal alpha? spec has been in alpha since it&apos;s existence"><y>#</y><d>2020-10-08</d><h>18:11</h><w>borkdude</w>What move away from eternal alpha? spec has been in alpha since it&apos;s existence</z><z id="t1602180821" t="dharrigan Yeah, there are exceptions of course"><y>#</y><d>2020-10-08</d><h>18:13</h><w>dharrigan</w>Yeah, there are exceptions of course</z><z id="t1602180875" t="dharrigan "><y>#</y><d>2020-10-08</d><h>18:14</h><w>dharrigan</w><code></code></z><z id="t1602180877" t="dharrigan there you go"><y>#</y><d>2020-10-08</d><h>18:14</h><w>dharrigan</w>there you go</z><z id="t1602180924" t="dharrigan After that blog post on Febrary, quite a few libraries moved away from alpha, the eternal alpha."><y>#</y><d>2020-10-08</d><h>18:15</h><w>dharrigan</w>After that blog post on Febrary, quite a few libraries moved away from alpha, the eternal alpha.</z><z id="t1602180970" t="dharrigan From first-hand experience trying to introduce Clojure (and libraries into the application), seeing things as alpha can be off-putting to others in the teams."><y>#</y><d>2020-10-08</d><h>18:16</h><w>dharrigan</w>From first-hand experience trying to introduce Clojure (and libraries into the application), seeing things as <code>alpha</code> can be off-putting to others in the teams.</z><z id="t1602180970" t="dharrigan ."><y>#</y><d>2020-10-08</d><h>18:16</h><w>dharrigan</w>.</z><z id="t1602189942" t="katox It&apos;s Clojure we use it in production since June. And it&apos;s great."><y>#</y><d>2020-10-08</d><h>20:45</h><w>katox</w>It&apos;s Clojure we use it in production since June. And it&apos;s great.</z><z id="t1602191183" t="dharrigan I&apos;ve been using malli now for a few months, stable, featureful and works brilliantly 🙂"><y>#</y><d>2020-10-08</d><h>21:06</h><w>dharrigan</w>I&apos;ve been using malli now for a few months, stable, featureful and works brilliantly <b>🙂</b></z><z id="t1602191823" t="schmee [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] is it of interest to have a Schema -&gt; Postgres DDL transformation in Malli? 🙂"><y>#</y><d>2020-10-08</d><h>21:17</h><w>schmee</w><a>@ikitommi</a> is it of interest to have a Schema -&gt; Postgres DDL transformation in Malli? <b>🙂</b></z><z id="t1602192065" t="dcj I&apos;m interested.... I have a simple prototype that handles only what I need, and &quot;works for me&quot;...."><y>#</y><d>2020-10-08</d><h>21:21</h><r>dcj</r>I&apos;m interested.... I have a simple prototype that handles only what I need, and &quot;works for me&quot;....</z><z id="t1602194478" t="kwrooijen I actually wrote a library that does that https://github.com/kwrooijen/gungnir"><y>#</y><d>2020-10-08</d><h>22:01</h><r>kwrooijen</r>I actually wrote a library that does that <a href="https://github.com/kwrooijen/gungnir" target="_blank">https://github.com/kwrooijen/gungnir</a></z><z id="t1602194499" t="kwrooijen In combination with HoneySQL / next.jdbc"><y>#</y><d>2020-10-08</d><h>22:01</h><r>kwrooijen</r>In combination with HoneySQL / next.jdbc</z><z id="t1602194577" t="kwrooijen It allows you to define your table structure, with transformations / validations, using Malli"><y>#</y><d>2020-10-08</d><h>22:02</h><r>kwrooijen</r>It allows you to define your table structure, with transformations / validations, using Malli</z><z id="t1602194992" t="dcj [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] Wow, that looks cool! I will definitely try that out."><y>#</y><d>2020-10-08</d><h>22:09</h><r>dcj</r><a>@UG9U7TPDZ</a> Wow, that looks cool!  I will definitely try that out.</z><z id="t1602199156" t="mac Is it correctly understood that malli does not support sets as predicates? if so is there then an alternative?"><y>#</y><d>2020-10-08</d><h>23:19</h><w>mac</w>Is it correctly understood that malli does not support sets as predicates? if so is there then an alternative?</z><z id="t1602201985" t="schmee [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] the equivalent is [:enum ...]"><y>#</y><d>2020-10-09</d><h>00:06</h><w>schmee</w><a>@mac</a> the equivalent is <code>[:enum ...]</code></z><z id="t1602225538" t="mac [:attrs {:href &quot;/_/_/users/U3L6TFEJF&quot;}] Ah, thanks."><y>#</y><d>2020-10-09</d><h>06:38</h><w>mac</w><a>@schmee</a> Ah, thanks.</z><z id="t1602226554" t="ikitommi [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] could have been a non-alpha, but was busy getting it out, so just alpha now. Grand goal is to get 1.0.0 out as soon as possible, after the final pieces (sequences, parsing, functions, default options) have been implemented, might effect the public api so that need to bump MAJOR. Most likely something that is easily migrated from pre-1.0.0."><y>#</y><d>2020-10-09</d><h>06:55</h><w>ikitommi</w><a>@dharrigan</a> could have been a non-alpha, but was busy getting it out, so just alpha now. Grand goal is to get 1.0.0 out as soon as possible, after the final pieces (sequences, parsing, functions, default options) have been implemented, might effect the public api so that need to bump MAJOR. Most likely something that is easily migrated from pre-1.0.0.</z><z id="t1602226851" t="ikitommi [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] there is a special type-schemas mechanism which would allow using using plain sets, but having too much shortcuts might make things harder to understand. There is already a such type shortcut for regexs, not sure if that was the right call: #&quot;\d+kikka&quot; ;; using the type-shortcut [:re #&quot;\d+kikka&quot;] ;; explicit sets - besides :enum , there is :fn for any function. [:enum &quot;a&quot; &quot;b&quot; &quot;c&quot;] [:fn #{&quot;a&quot; &quot;b&quot; &quot;c&quot;}] :enum doesn’t do type inferring atm, so you can hint the type so that JSON Schema, value transformation etc. work correctly: [:and keyword? [:enum :kikka :kukka]]"><y>#</y><d>2020-10-09</d><h>07:00</h><w>ikitommi</w><a>@mac</a> there is a special <code>type-schemas</code> mechanism which would allow using using plain sets, but having too much shortcuts might make things harder to understand. There is already a such type shortcut for regexs, not sure if that was the right call:
<pre>#&quot;\d+kikka&quot;        ;; using the type-shortcut
[:re #&quot;\d+kikka&quot;]  ;; explicit</pre>
sets - besides <code>:enum</code>, there is <code>:fn</code> for any function.
<pre>[:enum &quot;a&quot; &quot;b&quot; &quot;c&quot;]
[:fn #{&quot;a&quot; &quot;b&quot; &quot;c&quot;}]</pre>
<code>:enum</code> doesn’t do type inferring atm, so you can hint the type so that JSON Schema, value transformation etc. work correctly:
<pre>[:and keyword? [:enum :kikka :kukka]]</pre></z><z id="t1602226945" t="dharrigan [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] fantastic! Thank you for the update (and also the libraries, reitit and malli - super awesome sauce!)"><y>#</y><d>2020-10-09</d><h>07:02</h><w>dharrigan</w><a>@ikitommi</a> fantastic! Thank you for the update (and also the libraries, reitit and malli - super awesome sauce!)</z><z id="t1602228221" t="mac [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks, the reg-ex shortcut looks pretty idiomatic to me."><y>#</y><d>2020-10-09</d><h>07:23</h><w>mac</w><a>@ikitommi</a> Thanks, the reg-ex shortcut looks pretty idiomatic to me.</z><z id="t1602234597" t="borkdude Are there any libs like cli-matic that use malli instead of spec for arg parsing/validation?"><y>#</y><d>2020-10-09</d><h>09:09</h><w>borkdude</w>Are there any libs like cli-matic that use malli instead of spec for arg parsing/validation?</z><z id="t1602245900" t="Toni Vanhala Today was supposed to be ClojuTRE 2020, but what we got was t-shirts with malli validation errors. Just put these fun little items to Metosin shop: https://shop.spreadshirt.net/metosin/"><y>#</y><d>2020-10-09</d><h>12:18</h><w>Toni Vanhala</w>Today was supposed to be ClojuTRE 2020, but what we got was t-shirts with <code>malli</code> validation errors. Just put these fun little items to Metosin shop:
<a href="https://shop.spreadshirt.net/metosin/" target="_blank">https://shop.spreadshirt.net/metosin/</a></z><z id="t1602266250" t="Lucas Félix hi! - sorry for my english - is there something like spec functions ( https://clojure.org/guides/spec#_specing_functions ) in malli? if not, what’s the motivation?"><y>#</y><d>2020-10-09</d><h>17:57</h><w>Lucas Félix</w>hi! - sorry for my english - is there something like spec functions (<a href="https://clojure.org/guides/spec#_specing_functions" target="_blank">https://clojure.org/guides/spec#_specing_functions</a>) in malli? if not, what’s the motivation?</z><z id="t1602267743" t="borkdude [:attrs {:href &quot;/_/_/users/UNHSP4EKD&quot;}] https://github.com/metosin/malli/issues/125"><y>#</y><d>2020-10-09</d><h>18:22</h><w>borkdude</w><a>@lfelixsampaio</a> <a href="https://github.com/metosin/malli/issues/125" target="_blank">https://github.com/metosin/malli/issues/125</a></z><z id="t1602267867" t="Lucas Félix thanks! [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}]"><y>#</y><d>2020-10-09</d><h>18:24</h><r>Lucas Félix</r>thanks! <a>@U04V15CAJ</a></z><z id="t1602284212" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I’m curious why you’ve stopped mentioning the multi-tenant validation capabilities of Malli. for me, this was the original reason for using it and the registry design is very well done"><y>#</y><d>2020-10-09</d><h>22:56</h><w>steveb8n</w><a>@ikitommi</a> I’m curious why you’ve stopped mentioning the multi-tenant validation capabilities of Malli. for me, this was the original reason for using it and the registry design is very well done</z><z id="t1602316119" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;m reading through the Malli README and found a couple of spelling improvements: Homogenous -&gt; Homogeneous"><y>#</y><d>2020-10-10</d><h>07:48</h><w>borkdude</w><a>@ikitommi</a> I&apos;m reading through the Malli README and found a couple of spelling improvements:
Homogenous -&gt; Homogeneous</z><z id="t1602316147" t="borkdude And this sentence: &gt; You can also decomplected maps keys and values using registry references. seems to be grammatically a bit off"><y>#</y><d>2020-10-10</d><h>07:49</h><w>borkdude</w>And this sentence:
&gt; You can also decomplected maps keys and values using registry references.
seems to be grammatically a bit off</z><z id="t1602317605" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] fixes are most welcome."><y>#</y><d>2020-10-10</d><h>08:13</h><w>ikitommi</w><a>@borkdude</a> fixes are most welcome.</z><z id="t1602317636" t="borkdude Just passing it here, do what you want with it :)"><y>#</y><d>2020-10-10</d><h>08:13</h><w>borkdude</w>Just passing it here, do what you want with it :)</z><z id="t1602317713" t="ikitommi will fix"><y>#</y><d>2020-10-10</d><h>08:15</h><w>ikitommi</w>will fix</z><z id="t1602317847" t="ikitommi fixed"><y>#</y><d>2020-10-10</d><h>08:17</h><w>ikitommi</w>fixed</z><z id="t1602317888" t="ikitommi toyed with the declarative schema transformations, which might be useful when defining schemas in EDN: (require &apos;[malli.core :as m]) (require &apos;[malli.util :as mu]) (require &apos;[malli.error :as me]) (def registry (merge (m/default-schemas) (mu/schemas))) (def XZ (m/schema [:select-keys [:merge [:map [:x int?]] [:map [:y int?]] [:map [:z int?]]] [:x :z]] {:registry registry})) XZ ; [:select-keys ; [:merge ; [:map [:x int?]] ; [:map [:y int?]] ; [:map [:z int?]]] ; [:x :z]] ;; get the effective schema (m/deref XZ) ; [:map [:x int?] [:z int?]] ;; internally uses the pre-computed effective schema (-&gt; XZ (m/explain {:x 1}) (me/humanize)) ; {:z [&quot;missing required key&quot;]}"><y>#</y><d>2020-10-10</d><h>08:18</h><w>ikitommi</w>toyed with the declarative schema transformations, which might be useful when defining schemas in EDN:
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.util :as mu])
(require &apos;[malli.error :as me])

(def registry (merge (m/default-schemas) (mu/schemas)))

(def XZ
  (m/schema
    [:select-keys
     [:merge
      [:map [:x int?]]
      [:map [:y int?]]
      [:map [:z int?]]]
     [:x :z]]
    {:registry registry}))

XZ
; [:select-keys
;  [:merge
;   [:map [:x int?]]
;   [:map [:y int?]]
;   [:map [:z int?]]]
;  [:x :z]]

;; get the effective schema
(m/deref XZ)
; [:map [:x int?] [:z int?]]

;; internally uses the pre-computed effective schema
(-&gt; XZ
    (m/explain {:x 1})
    (me/humanize))
; {:z [&quot;missing required key&quot;]}</pre></z><z id="t1602318068" t="borkdude I was wondering, does malli also do the destructuring that spec does e.g. on a sequential regex schema? (s/cat etc)"><y>#</y><d>2020-10-10</d><h>08:21</h><w>borkdude</w>I was wondering, does malli also do the destructuring that spec does e.g. on a sequential regex schema? (s/cat etc)</z><z id="t1602318087" t="borkdude or s/or, etc"><y>#</y><d>2020-10-10</d><h>08:21</h><w>borkdude</w>or s/or, etc</z><z id="t1602318121" t="borkdude someone should probably write a comparison/migration page for malli &lt;-&gt; spec :)"><y>#</y><d>2020-10-10</d><h>08:22</h><w>borkdude</w>someone should probably write a comparison/migration page for malli &lt;-&gt; spec :)</z><z id="t1602318165" t="ikitommi not yet, the internal api works, but not integrated into malli.core: https://github.com/metosin/malli/issues/180"><y>#</y><d>2020-10-10</d><h>08:22</h><w>ikitommi</w>not yet, the internal api works, but not integrated into malli.core: <a href="https://github.com/metosin/malli/issues/180" target="_blank">https://github.com/metosin/malli/issues/180</a></z><z id="t1602318213" t="ikitommi … and https://github.com/metosin/malli/issues/241 after that."><y>#</y><d>2020-10-10</d><h>08:23</h><w>ikitommi</w>… and <a href="https://github.com/metosin/malli/issues/241" target="_blank">https://github.com/metosin/malli/issues/241</a> after that.</z><z id="t1602318241" t="borkdude exactly! thanks!"><y>#</y><d>2020-10-10</d><h>08:24</h><w>borkdude</w>exactly! thanks!</z><z id="t1602356031" t="zilti When creating a validator, how do I use non-core functions in a :fn ? Specifically, I want to use clojure.string/blank?"><y>#</y><d>2020-10-10</d><h>18:53</h><w>zilti</w>When creating a validator, how do I use non-core functions in a <code>:fn</code>? Specifically, I want to use <code>clojure.string/blank?</code></z><z id="t1602359322" t="ikitommi [:attrs {:href &quot;/_/_/users/U2APCNHCN&quot;}] :fn takes any function as unquoted, so [:fn clojure.string/blank?] . They don&apos;t serialize correctly, but work on the same runtime. If you use sci, you need to add custom bindings for the function for all runtimes. I believe str/blank? is part of sci default bindings, so [:fn &apos;str/blank?] should work too."><y>#</y><d>2020-10-10</d><h>19:48</h><w>ikitommi</w><a>@zilti</a> <code>:fn</code> takes any function as unquoted, so <code>[:fn clojure.string/blank?]</code>. They don&apos;t serialize correctly, but work on the same runtime. If you use sci, you need to add custom bindings for the function for all runtimes. I believe <code>str/blank?</code> is part of sci default bindings, so <code>[:fn &apos;str/blank?]</code> should work too.</z><z id="t1602359347" t="ikitommi also, you can say [:string {:min 1}] ."><y>#</y><d>2020-10-10</d><h>19:49</h><w>ikitommi</w>also, you can say <code>[:string {:min 1}]</code>.</z><z id="t1602359367" t="borkdude clojure.string/blank? works in sci by default"><y>#</y><d>2020-10-10</d><h>19:49</h><w>borkdude</w><code>clojure.string/blank?</code> works in sci by default</z><z id="t1602359383" t="zilti Oh, that :min seems to be the most straightforward for my usecase, I&apos;ll use that!"><y>#</y><d>2020-10-10</d><h>19:49</h><w>zilti</w>Oh, that <code>:min</code> seems to be the most straightforward for my usecase, I&apos;ll use that!</z><z id="t1602359537" t="ikitommi :string has good default error messages: https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L262-L283"><y>#</y><d>2020-10-10</d><h>19:52</h><w>ikitommi</w><code>:string</code> has  good default error messages: <a href="https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L262-L283" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L262-L283</a></z><z id="t1602411704" t="Lucy Wang Fixed a bunch of typos https://github.com/metosin/malli/pull/275"><y>#</y><d>2020-10-11</d><h>10:21</h><w>Lucy Wang</w>Fixed a bunch of typos <a href="https://github.com/metosin/malli/pull/275" target="_blank">https://github.com/metosin/malli/pull/275</a></z><z id="t1602414029" t="ikitommi merged, thanks!"><y>#</y><d>2020-10-11</d><h>11:00</h><w>ikitommi</w>merged, thanks!</z><z id="t1602418235" t="ikitommi would like to make sci explicitly optional. either via a flag (non-breaking) or via explicit option (breaking, but for the better): https://github.com/metosin/malli/issues/276 . Two days ago would have just done the latter, but now malli is released and goal has been not to break things. What do you think? save the breaking change for 1.0.0? just do it? something else?"><y>#</y><d>2020-10-11</d><h>12:10</h><w>ikitommi</w>would like to make sci explicitly optional. either via a flag (non-breaking) or via explicit option (breaking, but for the better): <a href="https://github.com/metosin/malli/issues/276" target="_blank">https://github.com/metosin/malli/issues/276</a>. Two days ago would have just done the latter, but now malli is released and goal has been not to break things. What do you think? save the breaking change for 1.0.0? just do it? something else?</z><z id="t1602418409" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Maybe sci could be one of many possible evaluators?"><y>#</y><d>2020-10-11</d><h>12:13</h><w>borkdude</w><a>@ikitommi</a> Maybe sci could be one of many possible evaluators?</z><z id="t1602470007" t="steveb8n I think a breaking change for the 1.0 release is ok. We know you plan to accrete only from 1.0"><y>#</y><d>2020-10-12</d><h>02:33</h><r>steveb8n</r>I think a breaking change for the 1.0 release is ok. We know you plan to accrete only from 1.0</z><z id="t1602470043" t="steveb8n optional sci is great for the browser use case. making that the default is a good idea imho"><y>#</y><d>2020-10-12</d><h>02:34</h><r>steveb8n</r>optional sci is great for the browser use case. making that the default is a good idea imho</z><z id="t1602470056" t="steveb8n I’m gonna use it server side also"><y>#</y><d>2020-10-12</d><h>02:34</h><r>steveb8n</r>I’m gonna use it server side also</z><z id="t1602481695" t="ikitommi good reason not yet to read sci-powered schemas from untrusted sources: https://github.com/borkdude/sci/issues/348"><y>#</y><d>2020-10-12</d><h>05:48</h><r>ikitommi</r>good reason not yet to read sci-powered schemas from untrusted sources: <a href="https://github.com/borkdude/sci/issues/348" target="_blank">https://github.com/borkdude/sci/issues/348</a></z><z id="t1602481727" t="ikitommi that&apos;s now linked in Malli Readme."><y>#</y><d>2020-10-12</d><h>05:48</h><r>ikitommi</r>that&apos;s now linked in Malli Readme.</z><z id="t1602418417" t="borkdude like clojure.core/eval is another one"><y>#</y><d>2020-10-11</d><h>12:13</h><w>borkdude</w>like clojure.core/eval is another one</z><z id="t1602418424" t="borkdude and maybe the user should specify that"><y>#</y><d>2020-10-11</d><h>12:13</h><w>borkdude</w>and maybe the user should specify that</z><z id="t1602418449" t="borkdude breaking would be ok I think"><y>#</y><d>2020-10-11</d><h>12:14</h><w>borkdude</w>breaking would be ok I think</z><z id="t1602418455" t="borkdude since the project is explicitly alpha"><y>#</y><d>2020-10-11</d><h>12:14</h><w>borkdude</w>since the project is explicitly alpha</z><z id="t1602418461" t="ikitommi yes, the option1 would allow that: (require &apos;[malli.sci :as ms]) (require &apos;[malli.core :as m]) (def options {:evaluator (ms/evaluator) :registry (ms/default-registry)}) (def Schema (m/schema [:fn &apos;(fn [x] (string? x))] options)) (m/validate Schema &quot;kikka&quot;) ; =&gt; true"><y>#</y><d>2020-10-11</d><h>12:14</h><w>ikitommi</w>yes, the option1 would allow that:
<pre>(require &apos;[malli.sci :as ms])
(require &apos;[malli.core :as m])

(def options
  {:evaluator (ms/evaluator)
   :registry (ms/default-registry)})

(def Schema (m/schema [:fn &apos;(fn [x] (string? x))] options))

(m/validate Schema &quot;kikka&quot;)
; =&gt; true</pre></z><z id="t1602418517" t="ikitommi .. would also remove need of :preloads etc, as you actually need to require the code to make it work."><y>#</y><d>2020-10-11</d><h>12:15</h><w>ikitommi</w>.. would also remove need of <code>:preloads</code> etc, as you actually need to require the code to make it work.</z><z id="t1602418551" t="borkdude I think that&apos;s reasonable as long as it&apos;s documented well"><y>#</y><d>2020-10-11</d><h>12:15</h><w>borkdude</w>I think that&apos;s reasonable as long as it&apos;s documented well</z><z id="t1602418567" t="borkdude and keep a list of breaking changes in CHANGELOG.md"><y>#</y><d>2020-10-11</d><h>12:16</h><w>borkdude</w>and keep a list of breaking changes in CHANGELOG.md</z><z id="t1602418683" t="borkdude malli.sci would still require sci for you right. so then there&apos;s no need for preloads"><y>#</y><d>2020-10-11</d><h>12:18</h><w>borkdude</w>malli.sci would still require sci for you right. so then there&apos;s no need for preloads</z><z id="t1602418747" t="ikitommi also, currently you can swap the default registry using the JVM/clj-compiler options, but not the default options. if you want to enable sci globally, that should be changed to swap the default options . I did a spike on that, but had too much open issues to think that through. Now, it seems like it would have been a right call."><y>#</y><d>2020-10-11</d><h>12:19</h><w>ikitommi</w>also, currently you can <code>swap the default registry</code> using the JVM/clj-compiler options, but not the default options. if you want to enable sci globally, that should be changed to <code>swap the default options</code>. I did a spike on that, but had too much open issues to think that through. Now, it seems like it would have been a right call.</z><z id="t1602418789" t="ikitommi https://github.com/metosin/malli/pull/235"><y>#</y><d>2020-10-11</d><h>12:19</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/235" target="_blank">https://github.com/metosin/malli/pull/235</a></z><z id="t1602418866" t="ikitommi that would be big breaking change, but something that could be documented and migrated easily too."><y>#</y><d>2020-10-11</d><h>12:21</h><w>ikitommi</w>that would be big breaking change, but something that could be documented and migrated easily too.</z><z id="t1602418896" t="ikitommi maybe all roads lead for quick 1.0.0 🙂"><y>#</y><d>2020-10-11</d><h>12:21</h><w>ikitommi</w>maybe all roads lead for quick 1.0.0 <b>🙂</b></z><z id="t1602418949" t="ikitommi thanks for you thoughts on this."><y>#</y><d>2020-10-11</d><h>12:22</h><w>ikitommi</w>thanks for you thoughts on this.</z><z id="t1602424834" t="motform Hi! does anyone have any experience using malli to validate/define the re-frame app-db?"><y>#</y><d>2020-10-11</d><h>14:00</h><w>motform</w>Hi! does anyone have any experience using malli to validate/define the re-frame app-db?</z><z id="t1602454423" t="steveb8n [:attrs {:href &quot;/_/_/users/UUPC4CHEZ&quot;}] I’m doing this for forms currently https://github.com/stevebuik/fork-malli-ideas"><y>#</y><d>2020-10-11</d><h>22:13</h><w>steveb8n</w><a>@love.lagerkvist</a> I’m doing this for forms currently <a href="https://github.com/stevebuik/fork-malli-ideas" target="_blank">https://github.com/stevebuik/fork-malli-ideas</a></z><z id="t1602454458" t="steveb8n works great. have not moved the app-db level validations from spec to Malli yet but I certainly plan to do so"><y>#</y><d>2020-10-11</d><h>22:14</h><w>steveb8n</w>works great. have not moved the app-db level validations from spec to Malli yet but I certainly plan to do so</z><z id="t1602474902" t="Lucy Wang [:attrs {:href &quot;/_/_/users/UUPC4CHEZ&quot;}] I&apos;m using re-frame.core/reg-global-interceptor to verify the app-db matches my schema in every change, and prints an console warning if it doesn&apos;t conform. But re-frame.app-db is just a normal map (live inside an reagent.atom), so it&apos;s nothing special when using it with malli IMO."><y>#</y><d>2020-10-12</d><h>03:55</h><w>Lucy Wang</w><a>@love.lagerkvist</a> I&apos;m using <code>re-frame.core/reg-global-interceptor</code> to verify the app-db matches my schema in every change, and prints an console warning if it doesn&apos;t conform. But re-frame.app-db is just a normal map (live inside an reagent.atom), so it&apos;s nothing special when using it with malli IMO.</z><z id="t1602480949" t="ikitommi merged #277, non-breaking disabling &amp; configuration of sci. Will make a 1.0.0 issue with suggestion to make swappable &amp; explicit evaluator. Thanks [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}]"><y>#</y><d>2020-10-12</d><h>05:35</h><w>ikitommi</w>merged #277, non-breaking disabling &amp; configuration of sci. Will make a 1.0.0 issue with suggestion to make swappable &amp; explicit evaluator. Thanks <a>@borkdude</a> <a>@steveb8n</a></z><z id="t1602486012" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] note that termination safe does have impact on performance of realizing seqs (since it’s checked). I’m not sure if the issue about execution time is fundamentally solvable."><y>#</y><d>2020-10-12</d><h>07:00</h><w>borkdude</w><a>@ikitommi</a> note that termination safe does have impact on performance of realizing seqs (since it’s checked). I’m not sure if the issue about execution time is fundamentally solvable.</z><z id="t1602492269" t="ikitommi It is one of the harder problems in comp.sci ;) With Malli &amp; sci, I concider safety as more important. Following the issue &amp; pr on sci-side, happy to incorporate anything that is found for this."><y>#</y><d>2020-10-12</d><h>08:44</h><r>ikitommi</r>It is one of the harder problems in comp.sci ;) With Malli &amp; sci, I concider safety as more important. Following the issue &amp; pr on sci-side, happy to incorporate anything that is found for this.</z><z id="t1602492662" t="borkdude I think the fundamental solution would be to run the sci expression in a thread on the JVM and kill it if it takes too long or in a webworker in the browser and do the same."><y>#</y><d>2020-10-12</d><h>08:51</h><r>borkdude</r>I think the fundamental solution would be to run the sci expression in a thread on the JVM and kill it if it takes too long or in a webworker in the browser and do the same.</z><z id="t1602492680" t="borkdude Maybe I should drop the termination-safe option as well - not sure."><y>#</y><d>2020-10-12</d><h>08:51</h><r>borkdude</r>Maybe I should drop the termination-safe option as well - not sure.</z><z id="t1602489280" t="motform [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] that sounds about right, I’ll do that. However, I was also thinking if it was possible to co-locate/generate/properly infer an inital app-db directly from malli. It would be really nice to have a single source of truth, kind of like a reitit router with views, coercion and controllers. (it’s probably super possible and I have to dig more into malli or a very bad idea)"><y>#</y><d>2020-10-12</d><h>07:54</h><w>motform</w><a>@wxitb2017</a> that sounds about right, I’ll do that. However, I was also thinking if it was possible to co-locate/generate/properly infer an inital app-db directly from malli. It would be really nice to have a single source of truth, kind of like a reitit router with views, coercion and controllers. (it’s probably super possible and I have to dig more into malli or a very bad idea)</z><z id="t1602515759" t="ikitommi You could have a Malli schema defined for the app-db, with default and create the initial state from those, e.g. (defn create [?schema] {:validator (m/validator ?schema) :explainer (m/explainer ?schema) :initial (m/decode ?schema nil (mt/default-value-transformer))}) (create [:map {:default {}} [:user [:map {:default {}} [:first-name [:string {:min 1, :default &quot;&quot;}]] [:last-name [:string {:min 1, :default &quot;&quot;}]]]]]) ;{:validator #object[...], ; :explainer #object[...], ; :initial {:user {:first-name &quot;&quot;, :last-name &quot;&quot;}}} inferring is powerful, but not fully accurate, e.g. is something a vector of things of a tuple of always 2."><y>#</y><d>2020-10-12</d><h>15:15</h><w>ikitommi</w>You could have a Malli schema defined for the app-db, with default and create the initial state from those, e.g.
<pre>(defn create [?schema]
  {:validator (m/validator ?schema)
   :explainer (m/explainer ?schema)
   :initial (m/decode ?schema nil (mt/default-value-transformer))})

(create [:map {:default {}}
         [:user [:map {:default {}}
                 [:first-name [:string {:min 1, :default &quot;&quot;}]]
                 [:last-name [:string {:min 1, :default &quot;&quot;}]]]]])
;{:validator #object[...],
; :explainer #object[...],
; :initial {:user {:first-name &quot;&quot;, :last-name &quot;&quot;}}}</pre>
inferring is powerful, but not fully accurate, e.g. is something a vector of things of a tuple of always 2.</z><z id="t1602515787" t="ikitommi (the mt/default-transformer could have an option to create empty maps by default…)"><y>#</y><d>2020-10-12</d><h>15:16</h><w>ikitommi</w>(the <code>mt/default-transformer</code> could have an option to create empty maps by default…)</z><z id="t1602574003" t="ikitommi https://github.com/metosin/malli/pull/278 , added :key and :defaults to mt/default-value-transformer to make it easier to create empty/default values with it: (m/decode [:map [:user [:map [:name :string] [:description {:ui/default &quot;-&quot;} :string]]]] nil (mt/default-value-transformer {:key :ui/default :defaults {:map (constantly {}) :string (constantly &quot;&quot;)}})) ; =&gt; {:user {:name &quot;&quot;, :description &quot;-&quot;}}"><y>#</y><d>2020-10-13</d><h>07:26</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/278" target="_blank">https://github.com/metosin/malli/pull/278</a>, added <code>:key</code> and <code>:defaults</code> to <code>mt/default-value-transformer</code> to make it easier to create empty/default values with it:
<pre>(m/decode
  [:map
   [:user [:map
           [:name :string]
           [:description {:ui/default &quot;-&quot;} :string]]]]
  nil
  (mt/default-value-transformer
    {:key :ui/default
     :defaults {:map (constantly {})
                :string (constantly &quot;&quot;)}}))
; =&gt; {:user {:name &quot;&quot;, :description &quot;-&quot;}}</pre></z><z id="t1602574067" t="ikitommi the values in :defaults can access the Schema instance, so can use any information from it to create the default, e.g. schema -&gt; default function."><y>#</y><d>2020-10-13</d><h>07:27</h><w>ikitommi</w>the values in <code>:defaults</code> can access the Schema instance, so can use any information from it to create the default, e.g.  <code>schema -&gt; default</code> function.</z><z id="t1602578176" t="dangercoder Is it possible to override the default error message for :re ?"><y>#</y><d>2020-10-13</d><h>08:36</h><w>dangercoder</w>Is it possible to override the default error message for <code>:re</code>?</z><z id="t1602580012" t="kwrooijen [:re {:error/message &quot;Invalid email&quot;} #&quot; Something like this?"><y>#</y><d>2020-10-13</d><h>09:06</h><r>kwrooijen</r><pre>[:re {:error/message &quot;Invalid email&quot;}
     #&quot;</pre>
Something like this?</z><z id="t1602581565" t="dangercoder I would like it to be general"><y>#</y><d>2020-10-13</d><h>09:32</h><r>dangercoder</r>I would like it to be general</z><z id="t1602581566" t="dangercoder Like, for all regexp errors I apply a custom message"><y>#</y><d>2020-10-13</d><h>09:32</h><r>dangercoder</r>Like, for all regexp errors I apply a custom message</z><z id="t1602581806" t="kwrooijen Ah like that. I&apos;m not familiar with a solution for that"><y>#</y><d>2020-10-13</d><h>09:36</h><r>kwrooijen</r>Ah like that. I&apos;m not familiar with a solution for that</z><z id="t1602586718" t="ikitommi not a good way to do that, but one can override the :errors from malli.error like this: (-&gt; #&quot;\d+&quot; (m/explain &quot;kikka&quot;) (me/humanize {:errors {:re {:error/message &quot;not a number&quot;}}})) ; =&gt; [&quot;not a number&quot;]"><y>#</y><d>2020-10-13</d><h>10:58</h><r>ikitommi</r>not a good way to do that, but one can override the <code>:errors</code> from <code>malli.error</code> like this:
<pre>(-&gt; #&quot;\d+&quot;
    (m/explain &quot;kikka&quot;)
    (me/humanize {:errors {:re {:error/message &quot;not a number&quot;}}}))
; =&gt; [&quot;not a number&quot;]</pre></z><z id="t1602595618" t="dangercoder My goal is to have an error message like this: &quot;Value: %s does not comply with regexp: %s&quot; 🙂"><y>#</y><d>2020-10-13</d><h>13:26</h><r>dangercoder</r>My goal is to have an error message like this:

&quot;Value: %s does not comply with regexp: %s&quot; <b>🙂</b></z><z id="t1602596088" t="ikitommi maybe: (defn regex-error [{:keys [value schema]} _] (str &quot;Value: &quot; value &quot; does not comply with regexp: &quot; (first (m/children schema)))) (-&gt; #&quot;\d+&quot; (m/explain &quot;kikka&quot;) (me/humanize {:errors {:re {:error/fn regex-error}}})) ; =&gt; [&quot;Value: kikka does not comply with regexp: \\d+&quot;]"><y>#</y><d>2020-10-13</d><h>13:34</h><r>ikitommi</r>maybe:
<pre>(defn regex-error [{:keys [value schema]} _]
  (str &quot;Value: &quot; value &quot; does not comply with regexp: &quot; (first (m/children schema))))

(-&gt; #&quot;\d+&quot;
    (m/explain &quot;kikka&quot;)
    (me/humanize {:errors {:re {:error/fn regex-error}}}))
; =&gt; [&quot;Value: kikka does not comply with regexp: \\d+&quot;]</pre></z><z id="t1602596450" t="dangercoder I&apos;ll check it out. Thanks for the inspiration [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2020-10-13</d><h>13:40</h><r>dangercoder</r>I&apos;ll check it out. Thanks for the inspiration <a>@ikitommi</a></z><z id="t1602580542" t="raymcdermott I am hitting a dumb problem with references"><y>#</y><d>2020-10-13</d><h>09:15</h><w>raymcdermott</w>I am hitting a dumb problem with references</z><z id="t1602580547" t="raymcdermott (ns data.recursive-case (:require [malli.util :as mu])) (def asset [:map [:asset/id string?] [:asset/status [:enum :initialized :accepted :active :revoked :failed]] [:asset/asset {:optional true} asset]]) (def org-asset (mu/merge asset [:map [:asset/org :org]])) (def user-asset (mu/merge asset [:map [:asset/user :user]]))"><y>#</y><d>2020-10-13</d><h>09:15</h><w>raymcdermott</w><pre>(ns data.recursive-case
  (:require [malli.util :as mu]))

(def asset
  [:map
   [:asset/id string?]
   [:asset/status [:enum :initialized :accepted :active :revoked :failed]]
   [:asset/asset {:optional true} asset]])

(def org-asset
  (mu/merge
    asset
    [:map
     [:asset/org :org]]))

(def user-asset
  (mu/merge
    asset
    [:map
     [:asset/user :user]]))</pre></z><z id="t1602580572" t="raymcdermott asset works OK but merge fails"><y>#</y><d>2020-10-13</d><h>09:16</h><w>raymcdermott</w><code>asset</code> works OK but merge fails</z><z id="t1602580578" t="raymcdermott Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema #object[clojure.lang.Var$Unbound 0x4bcbe824 &quot;Unbound: #&apos;data.recursive-case/asset&quot;]}"><y>#</y><d>2020-10-13</d><h>09:16</h><w>raymcdermott</w><pre>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema #object[clojure.lang.Var$Unbound 0x4bcbe824 &quot;Unbound: #&apos;data.recursive-case/asset&quot;]}</pre></z><z id="t1602580631" t="raymcdermott pretty sure I&apos;ve misunderstood something to do with registries so would appreciate if anyone can suggest what&apos;s up this"><y>#</y><d>2020-10-13</d><h>09:17</h><w>raymcdermott</w>pretty sure I&apos;ve misunderstood something to do with registries so would appreciate if anyone can suggest what&apos;s up this</z><z id="t1602581227" t="kwrooijen I think this line is wrong in the asset def? [:asset/asset {:optional true} asset]]"><y>#</y><d>2020-10-13</d><h>09:27</h><r>kwrooijen</r>I think this line is wrong in the <code>asset</code> def?
<pre>[:asset/asset {:optional true} asset]]</pre></z><z id="t1602581247" t="kwrooijen You&apos;re referring to asset , but it&apos;s in the definition itself"><y>#</y><d>2020-10-13</d><h>09:27</h><r>kwrooijen</r>You&apos;re referring to <code>asset</code>, but it&apos;s in the definition itself</z><z id="t1602581301" t="kwrooijen Judging from the naming, you actually want it to be recursive?"><y>#</y><d>2020-10-13</d><h>09:28</h><r>kwrooijen</r>Judging from the naming, you actually want it to be recursive?</z><z id="t1602581591" t="kwrooijen You might need to add asset into a registry which you actually want to use it in. e.g. something like this: {::asset [:map [:asset/id string?] [:asset/status [:enum :initialized :accepted :active :revoked :failed]] [:asset/asset {:optional true} [:ref ::asset]]]} https://github.com/metosin/malli#recursive-schemas"><y>#</y><d>2020-10-13</d><h>09:33</h><r>kwrooijen</r>You might need to add <code>asset</code> into a registry which you actually want to use it in. e.g. something like this:
<pre>{::asset
 [:map
  [:asset/id string?]
  [:asset/status [:enum :initialized :accepted :active :revoked :failed]]
  [:asset/asset {:optional true} [:ref ::asset]]]}</pre>
<a href="https://github.com/metosin/malli#recursive-schemas" target="_blank">https://github.com/metosin/malli#recursive-schemas</a></z><z id="t1602593681" t="raymcdermott yes ... I figured it was a registry thing. Thanks for the advice"><y>#</y><d>2020-10-13</d><h>12:54</h><r>raymcdermott</r>yes ... I figured it was a registry thing. Thanks for the advice</z><z id="t1602589977" t="katox [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I have been bitten by round-trip java.time.Instant -&gt; string -&gt; malli -&gt; #inst. The problem manifests in java9+ because of increased precision from miliseconds to microseconds. I noticed there is a bigger plan for time handling code but in the meantime I patched the string-&gt;date transformer. Should I do a PR for that? See https://github.com/metosin/malli/compare/master...katox:timestamp-frac-precision"><y>#</y><d>2020-10-13</d><h>11:52</h><w>katox</w><a>@ikitommi</a> I have been bitten by round-trip java.time.Instant -&gt; string -&gt; malli -&gt; #inst. The problem manifests in java9+ because of increased precision from miliseconds to microseconds. I noticed there is a bigger plan for time handling code but in the meantime I patched the <code>string-&gt;date</code> transformer. Should I do a PR for that? See <a href="https://github.com/metosin/malli/compare/master...katox:timestamp-frac-precision" target="_blank">https://github.com/metosin/malli/compare/master...katox:timestamp-frac-precision</a></z><z id="t1602595496" t="miikka Seems like a good idea (as long as the code still works on Java8 to the extent that it can work)"><y>#</y><d>2020-10-13</d><h>13:24</h><r>miikka</r>Seems like a good idea (as long as the code still works on Java8 to the extent that it can work)</z><z id="t1602661801" t="katox I tested the change in both j8 and j11. It works the same. Issuing PR."><y>#</y><d>2020-10-14</d><h>07:50</h><r>katox</r>I tested the change in both j8 and j11. It works the same. Issuing PR.</z><z id="t1602603267" t="shem i have JSON data that has entries like &quot;Start&quot;:new Date(1413147600000) . clojure JSON parsers (at least Cheshire and Jsonista) choke on this. i wonder if it&apos;s possible to use malli.core/decode with the :enter interceptor to parse this and transform it to &quot;Start&quot;: 1413147600000 ? my first attempt produces an exception"><y>#</y><d>2020-10-13</d><h>15:34</h><w>shem</w>i have JSON data that has entries like &quot;Start&quot;:new Date(1413147600000) . clojure JSON parsers (at least Cheshire and Jsonista) choke on this. i wonder if it&apos;s possible to use malli.core/decode with the :enter interceptor to parse this and transform it to &quot;Start&quot;: 1413147600000 ? my first attempt produces an exception</z><z id="t1602603298" t="shem"><y>#</y><d>2020-10-13</d><h>15:34</h><w>shem</w></z><z id="t1602613172" t="sparkofreason Schema inference is awesome going to save me a tone of time. Before I start reinventing a wheel, is anybody working on transforming malli schema to Datomic schema?"><y>#</y><d>2020-10-13</d><h>18:19</h><w>sparkofreason</w>Schema inference is awesome going to save me a tone of time. Before I start reinventing a wheel, is anybody working on transforming malli schema to Datomic schema?</z><z id="t1602778999" t="ikitommi haven’t seen anything for this, looking forward to your example 🙂"><y>#</y><d>2020-10-15</d><h>16:23</h><r>ikitommi</r>haven’t seen anything for this, looking forward to your example <b>🙂</b></z><z id="t1602944676" t="sparkofreason Looks to be pretty straightforward. I&apos;ve done this with spec before. There were two headaches there, one being the lack of a public data representation for specs, second being opaque predicates. In the latter case we used test.check to generate examples and tried to infer from that. I think you do the same thing here, but leveraging malli&apos;s inference."><y>#</y><d>2020-10-17</d><h>14:24</h><r>sparkofreason</r>Looks to be pretty straightforward. I&apos;ve done this with spec before. There were two headaches there, one being the lack of a public data representation for specs, second being opaque predicates. In the latter case we used test.check to generate examples and tried to infer from that. I think you do the same thing here, but leveraging malli&apos;s inference.</z><z id="t1602776959" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] noticed that none of the malli.util helpers deref the refernce schemas, wrote an https://github.com/metosin/malli/issues/281 . Before that, to use registry references, one needs to deref those manually, one option being: (require &apos;[malli.core :as m]) (require &apos;[malli.registry :as mr]) (require &apos;[malli.util :as mu]) (mr/set-default-registry! (mr/composite-registry (m/default-schemas) {:asset/id string? :asset/status [:enum :initialized :accepted :active :revoked :failed] :asset/asset [:map :asset/id :asset/status [:asset/asset {:optional true} [:ref :asset/asset]]]})) (def org-asset (mu/merge (m/deref :asset/asset) [:map [:asset/org [:= &quot;org&quot;]]])) org-asset ;[:map ; [:asset/id :asset/id] ; [:asset/status :asset/status] ; [:asset/asset {:optional true} [:ref :asset/asset]] ; [:asset/org [:= &quot;org&quot;]]] (def user-asset (mu/merge (m/deref :asset/asset) [:map [:asset/user [:= &quot;user&quot;]]])) user-asset ;[:map ; [:asset/id :asset/id] ; [:asset/status :asset/status] ; [:asset/asset {:optional true} [:ref :asset/asset]] ; [:asset/user [:= &quot;user&quot;]]] "><y>#</y><d>2020-10-15</d><h>15:49</h><w>ikitommi</w><a>@raymcdermott</a> noticed that none of the <code>malli.util</code> helpers deref the refernce schemas, wrote an <a href="https://github.com/metosin/malli/issues/281" target="_blank">https://github.com/metosin/malli/issues/281</a>. Before that, to use registry references, one needs to deref those manually, one option being:
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.registry :as mr])
(require &apos;[malli.util :as mu])

(mr/set-default-registry!
  (mr/composite-registry
    (m/default-schemas)
    {:asset/id string?
     :asset/status [:enum :initialized :accepted :active :revoked :failed]
     :asset/asset [:map
                   :asset/id
                   :asset/status
                   [:asset/asset {:optional true} [:ref :asset/asset]]]}))

(def org-asset
  (mu/merge
    (m/deref :asset/asset)
    [:map [:asset/org [:= &quot;org&quot;]]]))

org-asset
;[:map
; [:asset/id :asset/id]
; [:asset/status :asset/status]
; [:asset/asset {:optional true} [:ref :asset/asset]]
; [:asset/org [:= &quot;org&quot;]]]

(def user-asset
  (mu/merge
    (m/deref :asset/asset)
    [:map [:asset/user [:= &quot;user&quot;]]]))

user-asset
;[:map
; [:asset/id :asset/id]
; [:asset/status :asset/status]
; [:asset/asset {:optional true} [:ref :asset/asset]]
; [:asset/user [:= &quot;user&quot;]]] </pre></z><z id="t1602777095" t="ikitommi also, the declarative :merge would allow registries like this: {:asset/id string? :asset/status [:enum :initialized :accepted :active :revoked :failed] :asset/asset [:map :asset/id :asset/status [:asset/asset {:optional true} [:ref :asset/asset]]] :asset/org-asset [:merge :asset/asset [:map [:asset/org [:= &quot;org&quot;]]]] :asset/user-asset [:merge :asset/asset [:map [:asset/user [:= &quot;user&quot;]]]]}"><y>#</y><d>2020-10-15</d><h>15:51</h><w>ikitommi</w>also, the declarative <code>:merge</code> would allow registries like this:
<pre>{:asset/id string?
 :asset/status [:enum :initialized :accepted :active :revoked :failed]
 :asset/asset [:map
               :asset/id
               :asset/status
               [:asset/asset {:optional true} [:ref :asset/asset]]]
 :asset/org-asset [:merge :asset/asset [:map [:asset/org [:= &quot;org&quot;]]]]
 :asset/user-asset [:merge :asset/asset [:map [:asset/user [:= &quot;user&quot;]]]]}</pre></z><z id="t1602778905" t="ikitommi [:attrs {:href &quot;/_/_/users/U067EQZL4&quot;}] , you example doesn’t seem legit syntax. But for JSON, you need to defin :decode/json key. Something like: (m/decode [:map [:Duration string?] [:Start {:decode/json (fn [x] (mt/-string-&gt;long (last (re-find #&quot;(\d+)&quot; x))))} string?]] {:Duration &quot;kikka&quot; :Start &quot;new Date(1413147600000)&quot;} (mt/json-transformer)) ;{:Duration &quot;kikka&quot; ; :Start 1413147600000}"><y>#</y><d>2020-10-15</d><h>16:21</h><w>ikitommi</w><a>@shem</a>, you example doesn’t seem legit syntax. But for JSON, you need to defin <code>:decode/json</code> key. Something like:
<pre>(m/decode
  [:map
   [:Duration string?]
   [:Start {:decode/json (fn [x] (mt/-string-&gt;long (last (re-find #&quot;(\d+)&quot; x))))} string?]]
  {:Duration &quot;kikka&quot;
   :Start &quot;new Date(1413147600000)&quot;}
  (mt/json-transformer))
;{:Duration &quot;kikka&quot;
; :Start 1413147600000}</pre></z><z id="t1602778980" t="ikitommi if your new Date is coming from js, it’s a string of Mon Oct 13 2014 00:00:00 GMT+0300 (Eastern European Summer Time) {} , and you need to run it via some date-transforming fn. hope this helps."><y>#</y><d>2020-10-15</d><h>16:23</h><w>ikitommi</w>if your <code>new Date</code> is coming from js, it’s a string of <code>Mon Oct 13 2014 00:00:00 GMT+0300 (Eastern European Summer Time) {}</code>, and you need to run it via some date-transforming fn. hope this helps.</z><z id="t1602779837" t="ikitommi Would it be a breaking change if m/deref was recursive and would would return the input schema in case it was not a RefSchema ? I would like it to be: (require &apos;[malli.core :as m]) (m/schema [:schema [:schema [:schema [:map [:x int?]]]]]) ; =&gt; [:schema [:schema [:schema [:map [:x int?]]]]] (m/deref (m/schema [:schema [:schema [:schema [:map [:x int?]]]]])) ; =&gt; [:map [:x int?]] , instead of: (m/deref (m/schema [:schema [:schema [:schema [:map [:x int?]]]]])) ; =&gt; [:schema [:schema [:map [:x int?]]]]"><y>#</y><d>2020-10-15</d><h>16:37</h><w>ikitommi</w>Would it be a breaking change if <code>m/deref</code> was recursive and would would return the input schema in case it was not a <code>RefSchema</code>? I would like it to be:
<pre>(require &apos;[malli.core :as m])

(m/schema [:schema [:schema [:schema [:map [:x int?]]]]])
; =&gt; [:schema [:schema [:schema [:map [:x int?]]]]]

(m/deref (m/schema [:schema [:schema [:schema [:map [:x int?]]]]]))
; =&gt; [:map [:x int?]]</pre>
, instead of:
<pre>(m/deref (m/schema [:schema [:schema [:schema [:map [:x int?]]]]]))
; =&gt; [:schema [:schema [:map [:x int?]]]]</pre></z><z id="t1602779916" t="ikitommi also: (m/deref [:map [:x int?]]) ; =&gt; [:map [:x int?]] instead of: (m/deref [:map [:x int?]]) ; Execution error (IllegalArgumentException) ; No implementation of method: :-deref of protocol: #&apos;malli.core/RefSchema found for class: malli.core$_map_schema$reify$reify__4587"><y>#</y><d>2020-10-15</d><h>16:38</h><w>ikitommi</w>also:
<pre>(m/deref [:map [:x int?]])
; =&gt; [:map [:x int?]]</pre>
instead of:
<pre>(m/deref [:map [:x int?]])
; Execution error (IllegalArgumentException)
; No implementation of method: :-deref of protocol: #&apos;malli.core/RefSchema found for class: malli.core$_map_schema$reify$reify__4587</pre></z><z id="t1602782709" t="eraad Hi guys! I’m looking for any pointers on how to transform keys (ie snake to kebab) in nested schemas. I have the following schema: (def Invoice [:map {:registry {::address Address ::tax-line TaxLine}} [:issue_date [string? epoch]] [:series string?] [:sequence [string? {:decode/string mt/-string-&gt;long}]] [:currency [string? (lookup-ref :currency/code)]] [:customer_legal_name string?] [:customer_tax_id string?] [:customer_tax_id_type [string? (lookup-ref :tax-id/type)]] [:customer_email {:optional true} string?] [:customer_address {:optional true} ::address] [:tax_lines [:vector ::tax-line]] [:subtotal [string? {:decode/string mt/-string-&gt;double}]] [:tax [string? {:decode/string mt/-string-&gt;double}]] [:total [string? {:decode/string mt/-string-&gt;double}]]]) When i do: (defn coerce-request [schema req] (if (m/validate schema req) (m/decode schema req nil (mt/transformer mt/json-transformer mt/string-transformer {:name :epoch} {:name :lookup-ref} (mt/key-transformer {:decode k/-&gt;kebab-case}))) (-&gt; schema (m/explain req) (me/humanize))))"><y>#</y><d>2020-10-15</d><h>17:25</h><w>eraad</w>Hi guys! I’m looking for any pointers on how to transform keys (ie snake to kebab) in nested schemas. I have the following schema:

<pre>(def Invoice
  [:map {:registry {::address Address
                    ::tax-line TaxLine}}
   [:issue_date [string? epoch]]
   [:series string?]
   [:sequence [string? {:decode/string mt/-string-&gt;long}]]
   [:currency [string? (lookup-ref :currency/code)]]
   [:customer_legal_name string?]
   [:customer_tax_id string?]
   [:customer_tax_id_type [string? (lookup-ref :tax-id/type)]]
   [:customer_email {:optional true} string?]
   [:customer_address {:optional true} ::address]
   [:tax_lines [:vector ::tax-line]]
   [:subtotal [string? {:decode/string mt/-string-&gt;double}]]
   [:tax [string? {:decode/string mt/-string-&gt;double}]]
   [:total [string? {:decode/string mt/-string-&gt;double}]]])</pre>
When i do:

<pre>(defn coerce-request
  [schema req]
  (if (m/validate schema req)
    (m/decode schema
              req
              nil
              (mt/transformer
               mt/json-transformer
               mt/string-transformer
               {:name :epoch}
               {:name :lookup-ref}
               (mt/key-transformer {:decode k/-&gt;kebab-case})))
    (-&gt; schema
        (m/explain req)
        (me/humanize))))</pre></z><z id="t1602782731" t="eraad customer_address map keys are not affected"><y>#</y><d>2020-10-15</d><h>17:25</h><w>eraad</w><code>customer_address</code> map keys are not affected</z><z id="t1602785209" t="ikitommi [:attrs {:href &quot;/_/_/users/U061BSX36&quot;}] decoding is a process of taking an invalid value and transforming it to a valid (EDN) value. Because of this, the key-transformer runs the transformations on :enter phase. All the top-level map keys are transformed into invalid (kebab)-values and the :customer_address gets a value of :customer-value . After this, the keys don’t match the schema and the child decoders are no-op."><y>#</y><d>2020-10-15</d><h>18:06</h><w>ikitommi</w><a>@eraad</a> decoding is a process of taking an invalid value and transforming it to a valid (EDN) value. Because of this, the <code>key-transformer</code> runs the transformations on <code>:enter</code> phase. All the top-level map keys are transformed into invalid (kebab)-values and the <code>:customer_address</code> gets a value of <code>:customer-value</code>. After this, the keys don’t match the schema and the child decoders are no-op.</z><z id="t1602785307" t="ikitommi if you need to transform values out from the valid (EDN) definitions, you can use m/encode . the key-transformer runs in :leave phase there, in your case as the last thing as it’s also last transformer in the chain."><y>#</y><d>2020-10-15</d><h>18:08</h><w>ikitommi</w>if you need to transform values out from the valid (EDN) definitions, you can use <code>m/encode</code>. the <code>key-transformer</code> runs in <code>:leave</code> phase there, in your case as the last thing as it’s also last transformer in the chain.</z><z id="t1602785368" t="eraad Hi [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thank you for the response :thumbsup:"><y>#</y><d>2020-10-15</d><h>18:09</h><w>eraad</w>Hi <a>@ikitommi</a> thank you for the response <b>:thumbsup:</b></z><z id="t1602785442" t="ikitommi here’s a minimal sample: (m/decode [:map {:registry {::address [:map [:street string?]]}} [:customer_address ::address]] {:customer_address {:street &quot;hämeenkatu&quot;}} (mt/transformer (mt/key-transformer {:decode #(-&gt; % name str/upper-case keyword)}))) ; =&gt; {:CUSTOMER_ADDRESS {:street &quot;hämeenkatu&quot;}} (m/encode [:map {:registry {::address [:map [:street string?]]}} [:customer_address ::address]] {:customer_address {:street &quot;hämeenkatu&quot;}} (mt/transformer (mt/key-transformer {:encode #(-&gt; % name str/upper-case keyword)}))) ; =&gt; {:CUSTOMER_ADDRESS {:STREET &quot;hämeenkatu&quot;}}"><y>#</y><d>2020-10-15</d><h>18:10</h><w>ikitommi</w>here’s a minimal sample:
<pre>(m/decode
  [:map {:registry {::address [:map [:street string?]]}}
   [:customer_address ::address]]
  {:customer_address {:street &quot;hämeenkatu&quot;}}
  (mt/transformer
    (mt/key-transformer {:decode #(-&gt; % name str/upper-case keyword)})))
; =&gt; {:CUSTOMER_ADDRESS {:street &quot;hämeenkatu&quot;}}

(m/encode
  [:map {:registry {::address [:map [:street string?]]}}
   [:customer_address ::address]]
  {:customer_address {:street &quot;hämeenkatu&quot;}}
  (mt/transformer
    (mt/key-transformer {:encode #(-&gt; % name str/upper-case keyword)})))
; =&gt; {:CUSTOMER_ADDRESS {:STREET &quot;hämeenkatu&quot;}}</pre></z><z id="t1602785561" t="eraad Nice, thanks!"><y>#</y><d>2020-10-15</d><h>18:12</h><w>eraad</w>Nice, thanks!</z><z id="t1602785592" t="eraad I’m really loving Malli, tried Spec+Spec-tools for a bit but then tried Malli and its great"><y>#</y><d>2020-10-15</d><h>18:13</h><w>eraad</w>I’m really loving Malli, tried Spec+Spec-tools for a bit but then tried Malli and its great</z><z id="t1602785616" t="ikitommi in your case, you can write your own rename-keys like this (running on :leave in decode): (m/decode [:map {:registry {::address [:map [:street string?]]}} [:customer_address ::address]] {:customer_address {:street &quot;hämeenkatu&quot;}} (mt/transformer {:decoders {:map {:leave (mt/-transform-map-keys #(-&gt; % name str/upper-case keyword))}}})) ; =&gt; {:CUSTOMER_ADDRESS {:STREET &quot;hämeenkatu&quot;}}"><y>#</y><d>2020-10-15</d><h>18:13</h><w>ikitommi</w>in your case, you can write your own rename-keys like this (running on <code>:leave</code> in decode):
<pre>(m/decode
  [:map {:registry {::address [:map [:street string?]]}}
   [:customer_address ::address]]
  {:customer_address {:street &quot;hämeenkatu&quot;}}
  (mt/transformer
    {:decoders {:map {:leave (mt/-transform-map-keys #(-&gt; % name str/upper-case keyword))}}}))
; =&gt; {:CUSTOMER_ADDRESS {:STREET &quot;hämeenkatu&quot;}}</pre></z><z id="t1602785704" t="ikitommi “on :decode , for :map s run this function f on :leave ”. transformers are quite simple in the end 😉"><y>#</y><d>2020-10-15</d><h>18:15</h><w>ikitommi</w>“on <code>:decode</code>, for <code>:map</code>s run this function <code>f</code> on <code>:leave</code>”. transformers are quite simple in the end <b>😉</b></z><z id="t1602785728" t="eraad Coo, I was not being aware of :enter and :leave, that’s the missing part"><y>#</y><d>2020-10-15</d><h>18:15</h><w>eraad</w>Coo, I was not being aware of :enter and :leave, that’s the missing part</z><z id="t1602861815" t="ikitommi Did a PR on making :schema and :ref schemas behave better: https://github.com/metosin/malli/pull/282 . It has a BREAKING CHANGE as m/deref would be recursive and does not throw."><y>#</y><d>2020-10-16</d><h>15:23</h><w>ikitommi</w>Did a PR on making <code>:schema</code> and <code>:ref</code> schemas behave better: <a href="https://github.com/metosin/malli/pull/282" target="_blank">https://github.com/metosin/malli/pull/282</a>. It has a BREAKING CHANGE as <code>m/deref</code> would be recursive and does not throw.</z><z id="t1602862008" t="ikitommi these work after the PR: 1. mu/merge and mu/union with references: (mu/merge [:schema [:map [:x int?]]] [:map [:y int?]]) ; =&gt; [:map [:x int?] [:y int?]] 2. mu/subschemas with both :ref &amp; :schema s: (mu/subschemas [:ref {:registry {&quot;Address&quot; [:map [:street :string] [:address [:ref &quot;Address&quot;]] [:neighbor [:ref &quot;Neighbor&quot;]]] &quot;Country&quot; [:map [:name [:= &quot;finland&quot;]]] &quot;Neighbor&quot; [:ref &quot;Address&quot;]}} &quot;Address&quot;]) ;[{:path [], :in [], :schema [:ref {:registry {&quot;Address&quot; [:map ; [:street :string] ; [:address [:ref &quot;Address&quot;]] ; [:neighbor [:ref &quot;Neighbor&quot;]]] ; &quot;Country&quot; [:map [:name [:= &quot;finland&quot;]]] ; &quot;Neighbor&quot; [:ref &quot;Address&quot;]}} ; &quot;Address&quot;]} ; {:path [0 0], :in [], :schema [:map ; [:street :string] ; [:address [:ref &quot;Address&quot;]] ; [:neighbor [:ref &quot;Neighbor&quot;]]]} ; {:path [0 0 :street], :in [:street], :schema :string} ; {:path [0 0 :address], :in [:address], :schema [:ref &quot;Address&quot;]} ; {:path [0 0 :neighbor], :in [:neighbor], :schema [:ref &quot;Neighbor&quot;]}]"><y>#</y><d>2020-10-16</d><h>15:26</h><w>ikitommi</w>these work after the PR:

1. <code>mu/merge</code> and <code>mu/union</code> with references:
<pre>(mu/merge
  [:schema [:map [:x int?]]]
  [:map [:y int?]])
; =&gt; [:map [:x int?] [:y int?]]</pre>
2. <code>mu/subschemas</code> with both <code>:ref</code> &amp; <code>:schema</code>s:
<pre>(mu/subschemas
  [:ref {:registry {&quot;Address&quot; [:map
                               [:street :string]
                               [:address [:ref &quot;Address&quot;]]
                               [:neighbor [:ref &quot;Neighbor&quot;]]]
                    &quot;Country&quot; [:map [:name [:= &quot;finland&quot;]]]
                    &quot;Neighbor&quot; [:ref &quot;Address&quot;]}}
   &quot;Address&quot;])
;[{:path [], :in [], :schema [:ref {:registry {&quot;Address&quot; [:map
;                                                         [:street :string]
;                                                         [:address [:ref &quot;Address&quot;]]
;                                                         [:neighbor [:ref &quot;Neighbor&quot;]]]
;                                              &quot;Country&quot; [:map [:name [:= &quot;finland&quot;]]]
;                                              &quot;Neighbor&quot; [:ref &quot;Address&quot;]}}
;                             &quot;Address&quot;]}
; {:path [0 0], :in [], :schema [:map
;                                [:street :string]
;                                [:address [:ref &quot;Address&quot;]]
;                                [:neighbor [:ref &quot;Neighbor&quot;]]]}
; {:path [0 0 :street], :in [:street], :schema :string}
; {:path [0 0 :address], :in [:address], :schema [:ref &quot;Address&quot;]}
; {:path [0 0 :neighbor], :in [:neighbor], :schema [:ref &quot;Neighbor&quot;]}]</pre></z><z id="t1602862089" t="ikitommi if you are in business of generating forms from schemas, mu/subschemas is your best friend."><y>#</y><d>2020-10-16</d><h>15:28</h><w>ikitommi</w>if you are in business of generating forms from schemas, <code>mu/subschemas</code> is your best friend.</z><z id="t1602862163" t="ikitommi m/walk can be configured with ::m/walk-refs and ::m/walk-schema-refs to walk over none, some of all references. Does not StackOverFlow, walks a given reference just once. cheers."><y>#</y><d>2020-10-16</d><h>15:29</h><w>ikitommi</w><code>m/walk</code> can be configured with <code>::m/walk-refs</code> and <code>::m/walk-schema-refs</code> to walk over none, some of all references. Does not StackOverFlow, walks a given reference just once. cheers.</z><z id="t1602882136" t="dangercoder is there some kind of way to speed up m/validate ? I have a real edge case, I automatically generated a schema for a structure that potentially can contain 1294 fields (a tree structure...) when I ran validate it took a few seconds on a empty map."><y>#</y><d>2020-10-16</d><h>21:02</h><w>dangercoder</w>is there some kind of way to speed up  <code>m/validate</code>?

I have a real edge case,  I automatically generated a schema for a structure that potentially can contain 1294 fields (a tree structure...) when I ran validate it took a few seconds on a empty map.</z><z id="t1602882221" t="dangercoder would it run quicker if I used a registry for things that are &quot;common&quot;?"><y>#</y><d>2020-10-16</d><h>21:03</h><w>dangercoder</w>would it run quicker if I used a registry for things that are &quot;common&quot;?</z><z id="t1602882242" t="borkdude I think malli supports something like lazy validation and/or lazy schemas - I&apos;ve seen this being mentioned in a conversation with ikitommi and jeroenvandijk"><y>#</y><d>2020-10-16</d><h>21:04</h><w>borkdude</w>I think malli supports something like lazy validation and/or lazy schemas - I&apos;ve seen this being mentioned in a conversation with ikitommi and jeroenvandijk</z><z id="t1602891678" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/UBN9SNVB4&quot;}] not sure if it is still idiomatic Malli and it can be more optimized, but here is how you could do lazy loading (see lookup-type) https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj"><y>#</y><d>2020-10-16</d><h>23:41</h><w>jeroenvandijk</w><a>@jarvinenemil</a> not sure if it is still idiomatic Malli and it can be more optimized, but here is how you could do lazy loading (see lookup-type) <a href="https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj" target="_blank">https://github.com/jeroenvandijk/aws.cloudformation.malli/blob/master/src/adgoji/aws/cloudformation/malli/validation.clj</a></z><z id="t1602898751" t="ikitommi [:attrs {:href &quot;/_/_/users/UBN9SNVB4&quot;}] are you using m/validator or m/validate ? the latter is a convenience fn for one-shot things: if given schema syntax, for every call, it parses it, creates the Schema instance tree and creates a pure validator for it and runs it once and throws it away. m/validator returns that pure validation function of x -&gt; boolean , so if you can keep that, you pay for the parsing &amp; optimizing just once."><y>#</y><d>2020-10-17</d><h>01:39</h><w>ikitommi</w><a>@jarvinenemil</a> are you using <code>m/validator</code> or <code>m/validate</code>? the latter is a convenience fn for one-shot things: if given schema syntax, for every call, it parses it, creates the Schema instance tree and creates a pure validator for it and runs it once and throws it away. <code>m/validator</code> returns that pure validation function of <code>x -&gt; boolean</code> , so if you can keep that, you pay for the parsing &amp; optimizing just once.</z><z id="t1602898818" t="ikitommi same applies to m/explain vs m/explainer , m/decode vs m/decoder etc."><y>#</y><d>2020-10-17</d><h>01:40</h><w>ikitommi</w>same applies to <code>m/explain</code> vs <code>m/explainer</code>,  <code>m/decode</code> vs <code>m/decoder</code> etc.</z><z id="t1602898880" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1079-L1085"><y>#</y><d>2020-10-17</d><h>01:41</h><w>ikitommi</w><a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1079-L1085" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1079-L1085</a></z><z id="t1602899148" t="ikitommi at best, given a deeply nested schema with 1k fields, the m/decoder can return a indentity function if there are no decoding functions mapped to any of the fields or structure in general. Can&apos;t get much faster than that 😉"><y>#</y><d>2020-10-17</d><h>01:45</h><w>ikitommi</w>at best, given a deeply nested schema with 1k fields, the <code>m/decoder</code> can return a <code>indentity</code> function if there are no decoding functions mapped to any of the fields or structure in general. Can&apos;t get much faster than that <b>😉</b></z><z id="t1602928512" t="dangercoder [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I did a one off using validate. validator was just what I was looking for, thanks!"><y>#</y><d>2020-10-17</d><h>09:55</h><w>dangercoder</w><a>@ikitommi</a> I did a one off using validate. validator was just what I was looking for, thanks!</z><z id="t1602944134" t="ikitommi curious about the perceived perf gains, hopefully many orders of magnitude.."><y>#</y><d>2020-10-17</d><h>14:15</h><r>ikitommi</r>curious about the perceived perf gains, hopefully many orders of magnitude..</z><z id="t1602946951" t="dangercoder Using validate (cc/quick-bench (m/validate schema {})) Evaluation count : 6 in 6 samples of 1 calls. Execution time mean : 21.971360 sec Execution time std-deviation : 2.848014 sec Execution time lower quantile : 20.065855 sec ( 2.5%) Execution time upper quantile : 26.840086 sec (97.5%) Overhead used : 7.984810 ns Using validator (cc/quick-bench (validator {})) Evaluation count : 31504632 in 6 samples of 5250772 calls. Execution time mean : 12.055681 ns Execution time std-deviation : 0.575152 ns Execution time lower quantile : 11.599548 ns ( 2.5%) Execution time upper quantile : 12.803005 ns (97.5%) Overhead used : 7.984810 ns"><y>#</y><d>2020-10-17</d><h>15:02</h><r>dangercoder</r>Using validate
<code>(cc/quick-bench (m/validate schema {}))</code>
<code>Evaluation count : 6 in 6 samples of 1 calls.</code>
             <code>Execution time mean : 21.971360 sec</code>
    <code>Execution time std-deviation : 2.848014 sec</code>
   <code>Execution time lower quantile : 20.065855 sec ( 2.5%)</code>
   <code>Execution time upper quantile : 26.840086 sec (97.5%)</code>
                   <code>Overhead used : 7.984810 ns</code>

Using validator
  <code>(cc/quick-bench (validator {}))</code> 
<code>Evaluation count : 31504632 in 6 samples of 5250772 calls.</code>
             <code>Execution time mean : 12.055681 ns</code>
    <code>Execution time std-deviation : 0.575152 ns</code>
   <code>Execution time lower quantile : 11.599548 ns ( 2.5%)</code>
   <code>Execution time upper quantile : 12.803005 ns (97.5%)</code>
                   <code>Overhead used : 7.984810 ns</code></z><z id="t1602947948" t="ikitommi that&apos;s 9 orders of magnitude 😮 😮 😮 . Are you starting a power plan while creating the schema as it takes 20 seconds???"><y>#</y><d>2020-10-17</d><h>15:19</h><r>ikitommi</r>that&apos;s 9 orders of magnitude <b>😮</b><b>😮</b><b>😮</b> . Are you starting a power plan while creating the schema as it takes 20 seconds???</z><z id="t1602948104" t="ikitommi anyway, good reason to cache the validator :)"><y>#</y><d>2020-10-17</d><h>15:21</h><r>ikitommi</r>anyway, good reason to cache the validator :)</z><z id="t1602948105" t="dangercoder I converted a excel-sheet from business people to a malli schema so I can convert the malli schema to a json-schema that can be used from several languages 😄"><y>#</y><d>2020-10-17</d><h>15:21</h><r>dangercoder</r>I converted a excel-sheet from business people to a malli schema so I can convert the malli schema to a json-schema that can be used from several languages <b>😄</b></z><z id="t1602948526" t="dangercoder I anonymized the fields and havent added regexp yet but just to give u an idea on how big this thing is. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I did not decide this, the real world is sometimes a bit messy 😄 ."><y>#</y><d>2020-10-17</d><h>15:28</h><r>dangercoder</r>I anonymized the fields and havent added regexp yet but just to give u an idea on how big this thing is.  <a>@ikitommi</a>

I did not decide this, the real world is sometimes a bit messy <b>😄</b>.</z><z id="t1602944199" t="ikitommi WIP, https://github.com/metosin/malli/pull/283 : (def registry (merge (m/default-schemas) (mu/schemas))) (def Merged (m/schema [:merge [:map [:x :string]] [:map [:y :int]]] {:registry registry})) Merged ;[:merge ; [:map [:x :string]] ; [:map [:y :int]]] (m/deref Merged) ;[:map ; [:x :string] ; [:y :int]] (m/validate Merged {:x &quot;kikka&quot;, :y 6}) ; =&gt; true"><y>#</y><d>2020-10-17</d><h>14:16</h><w>ikitommi</w>WIP, <a href="https://github.com/metosin/malli/pull/283" target="_blank">https://github.com/metosin/malli/pull/283</a>:
<pre>(def registry (merge (m/default-schemas) (mu/schemas)))

(def Merged
  (m/schema
    [:merge
     [:map [:x :string]]
     [:map [:y :int]]]
    {:registry registry}))

Merged
;[:merge
; [:map [:x :string]]
; [:map [:y :int]]]

(m/deref Merged)
;[:map 
; [:x :string] 
; [:y :int]]

(m/validate Merged {:x &quot;kikka&quot;, :y 6})
; =&gt; true</pre></z><z id="t1602944382" t="ikitommi just :merge , :union and :select-keys now, should be easy to add more, with the util helpers. current Schema impls in malli.util : (defn -merge [] (-util-schema {:type :merge, :f (-reducing merge)})) (defn -union [] (-util-schema {:type :union, :f (-reducing union)})) (defn -select-keys [] (-util-schema {:type :select-keys, :min 2, :max 2, :f (-applying select-keys)}))"><y>#</y><d>2020-10-17</d><h>14:19</h><w>ikitommi</w>just <code>:merge</code> , <code>:union</code> and <code>:select-keys</code> now, should be easy to add more, with the util helpers. current Schema impls in <code>malli.util</code>:
<pre>(defn -merge [] (-util-schema {:type :merge, :f (-reducing merge)}))
(defn -union [] (-util-schema {:type :union, :f (-reducing union)}))
(defn -select-keys [] (-util-schema {:type :select-keys, :min 2, :max 2, :f (-applying select-keys)}))</pre></z><z id="t1602954263" t="jfntn 👋 I’m looking for a way to use an accumulator during a schema walk."><y>#</y><d>2020-10-17</d><h>17:04</h><w>jfntn</w><b>👋</b> I’m looking for a way to use an accumulator during a schema walk.</z><z id="t1602954273" t="jfntn That’s easy to hack from the outside in with say an atom but I was wondering if there is cleaner way to do this from the inside out instead?"><y>#</y><d>2020-10-17</d><h>17:04</h><r>jfntn</r>That’s easy to hack from the outside in with say an atom but I was wondering if there is cleaner way to do this from the inside out instead?</z><z id="t1602954331" t="jfntn It seems like it’d be possible to reify a Walker that expects the walk fn to return [schema context] and merges the returned context into the options to pass to the next step…"><y>#</y><d>2020-10-17</d><h>17:05</h><r>jfntn</r>It seems like it’d be possible to reify a Walker that expects the walk fn to return <code>[schema context]</code> and merges the returned context into the options to pass to the next step…</z><z id="t1602956450" t="ikitommi yes, you should implement a custom Walker . find-first might be a good example for that: https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51"><y>#</y><d>2020-10-17</d><h>17:40</h><r>ikitommi</r>yes, you should implement a custom <code>Walker</code>. <code>find-first</code> might be a good example for that: <a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51</a></z><z id="t1602956499" t="ikitommi or: subschemas : https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L150-L163"><y>#</y><d>2020-10-17</d><h>17:41</h><r>ikitommi</r>or: <code>subschemas</code>: <a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L150-L163" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L150-L163</a></z><z id="t1602957932" t="jfntn Thanks for the pointers!"><y>#</y><d>2020-10-17</d><h>18:05</h><r>jfntn</r>Thanks for the pointers!</z><z id="t1602957961" t="jfntn I guess doing this without some atom would require some kind of state monad so I think I’ll stick with your examples 😂"><y>#</y><d>2020-10-17</d><h>18:06</h><r>jfntn</r>I guess doing this without some atom would require some kind of state monad so I think I’ll stick with your examples <b>😂</b></z><z id="t1602958874" t="ikitommi if you get a generic accumulating walker, might be a good example in https://github.com/metosin/malli/blob/master/docs/tips.md ."><y>#</y><d>2020-10-17</d><h>18:21</h><r>ikitommi</r>if you get a generic accumulating walker, might be a good example in <a href="https://github.com/metosin/malli/blob/master/docs/tips.md" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md</a>.</z><z id="t1603119547" t="Vincent Cantin There might be a way to bridge Specter and Malli for that purpose."><y>#</y><d>2020-10-19</d><h>14:59</h><r>Vincent Cantin</r>There might be a way to bridge Specter and Malli for that purpose.</z><z id="t1602960302" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] can I have docstring for spec in swagger output?"><y>#</y><d>2020-10-17</d><h>18:45</h><w>mike_ananev</w><a>@ikitommi</a> can I have docstring for spec in swagger output?</z><z id="t1602962496" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] what kind of docstring are you looking for? :title , :description and :default are automatically copied to both JSON Schema and Swagger."><y>#</y><d>2020-10-17</d><h>19:21</h><w>ikitommi</w><a>@mike1452</a> what kind of docstring are you looking for? <code>:title</code>,  <code>:description</code> and <code>:default</code> are automatically copied to both JSON Schema and Swagger.</z><z id="t1602962582" t="ikitommi JSON Schema references"><y>#</y><d>2020-10-17</d><h>19:23</h><w>ikitommi</w>JSON Schema references</z><z id="t1603005674" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks! this example is what I need."><y>#</y><d>2020-10-18</d><h>07:21</h><w>mike_ananev</w><a>@ikitommi</a> thanks! this example is what I need.</z><z id="t1603030234" t="ikitommi I think declarative schema transformations is done now: https://github.com/metosin/malli/pull/283 ."><y>#</y><d>2020-10-18</d><h>14:10</h><w>ikitommi</w>I think declarative schema transformations is done now: <a href="https://github.com/metosin/malli/pull/283" target="_blank">https://github.com/metosin/malli/pull/283</a>.</z><z id="t1603087779" t="ikitommi 🎉"><y>#</y><d>2020-10-19</d><h>06:09</h><w>ikitommi</w><b>🎉</b></z><z id="t1603091826" t="dharrigan Fantastic! Going to try these out now!"><y>#</y><d>2020-10-19</d><h>07:17</h><w>dharrigan</w>Fantastic! Going to try these out now!</z><z id="t1603093726" t="ikitommi https://malli.io/?value=%7B%3Atype%20%22Cat%22%2C%20%3Aname%20%22Viivi%22%2C%20%3AhuntingSkill%20%3Aadventurous%7D&amp;amp;schema=%5B%3Aschema%20%7B%3Aregistry%20%7B%22Pet%22%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Cat%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Cat%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3AhuntingSkill%20%5B%3Aenum%20%7B%3Adescription%20%22The%20measured%20skill%20for%20hunting%22%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aclueless%2C%20%3Alazy%2C%20%3Aadventurous%2C%20%3Aaggressive%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Dog%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Dog%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3ApackSize%20%5B%3Aint%20%7B%3Amin%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adefault%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22the%20size%20of%20the%20pack%20the%20dog%20is%20from%22%7D%5D%5D%5D%5D%7D%7D%0A%20%5B%3Amulti%20%7B%3Adispatch%20%3Atype%7D%20%22Cat%22%20%22Dog%22%5D%5D"><y>#</y><d>2020-10-19</d><h>07:48</h><w>ikitommi</w><a href="https://malli.io/?value=%7B%3Atype%20%22Cat%22%2C%20%3Aname%20%22Viivi%22%2C%20%3AhuntingSkill%20%3Aadventurous%7D&amp;amp;schema=%5B%3Aschema%20%7B%3Aregistry%20%7B%22Pet%22%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Cat%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Cat%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3AhuntingSkill%20%5B%3Aenum%20%7B%3Adescription%20%22The%20measured%20skill%20for%20hunting%22%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aclueless%2C%20%3Alazy%2C%20%3Aadventurous%2C%20%3Aaggressive%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Dog%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Dog%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3ApackSize%20%5B%3Aint%20%7B%3Amin%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adefault%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22the%20size%20of%20the%20pack%20the%20dog%20is%20from%22%7D%5D%5D%5D%5D%7D%7D%0A%20%5B%3Amulti%20%7B%3Adispatch%20%3Atype%7D%20%22Cat%22%20%22Dog%22%5D%5D" target="_blank">https://malli.io/?value=%7B%3Atype%20%22Cat%22%2C%20%3Aname%20%22Viivi%22%2C%20%3AhuntingSkill%20%3Aadventurous%7D&amp;amp;schema=%5B%3Aschema%20%7B%3Aregistry%20%7B%22Pet%22%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20string%3F%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Cat%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Cat%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3AhuntingSkill%20%5B%3Aenum%20%7B%3Adescription%20%22The%20measured%20skill%20for%20hunting%22%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Aclueless%2C%20%3Alazy%2C%20%3Aadventurous%2C%20%3Aaggressive%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Dog%22%20%5B%3Amerge%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%22Pet%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atype%20%5B%3A%3D%20%22Dog%22%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3ApackSize%20%5B%3Aint%20%7B%3Amin%200%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adefault%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Adescription%20%22the%20size%20of%20the%20pack%20the%20dog%20is%20from%22%7D%5D%5D%5D%5D%7D%7D%0A%20%5B%3Amulti%20%7B%3Adispatch%20%3Atype%7D%20%22Cat%22%20%22Dog%22%5D%5D</a></z><z id="t1603114370" t="ikitommi what a brilliant/horrible idea: add optional :object schema, which allows maps to be described using clojure maps. Kinda like data-specs but for malli: [:object {&quot;name&quot; [:required :string] &quot;age&quot; [:required :number :positive :integer] &quot;email&quot; [:string :email] &quot;website&quot; [:string :url] &quot;createdOn&quot; [[:date {:default &quot;2020-18-10&quot;}]] &quot;address&quot; [:object {&quot;street&quot; [[:string {:min 1}]] &quot;zip&quot; [:int]}]}]"><y>#</y><d>2020-10-19</d><h>13:32</h><w>ikitommi</w>what a brilliant/horrible idea: add optional <code>:object</code> schema, which allows maps to be described using clojure maps. Kinda like data-specs but for malli:
<pre>[:object
 {&quot;name&quot; [:required :string]
  &quot;age&quot; [:required :number :positive :integer]
  &quot;email&quot; [:string :email]
  &quot;website&quot; [:string :url]
  &quot;createdOn&quot; [[:date {:default &quot;2020-18-10&quot;}]]
  &quot;address&quot; [:object
             {&quot;street&quot; [[:string {:min 1}]]
              &quot;zip&quot; [:int]}]}]</pre></z><z id="t1603114528" t="ikitommi or: [:object {&quot;name&quot; [:and :required :string] &quot;age&quot; [:and :required :number :positive :integer] &quot;email&quot; [:and :string :email] &quot;website&quot; [:and :string :url] &quot;createdOn&quot; [:date {:default &quot;2020-18-10&quot;}] &quot;address&quot; {:street [:string {:min 1}] :zip :int}}]"><y>#</y><d>2020-10-19</d><h>13:35</h><w>ikitommi</w>or:
<pre>[:object
 {&quot;name&quot; [:and :required :string]
  &quot;age&quot; [:and :required :number :positive :integer]
  &quot;email&quot; [:and :string :email]
  &quot;website&quot; [:and :string :url]
  &quot;createdOn&quot; [:date {:default &quot;2020-18-10&quot;}]
  &quot;address&quot; {:street [:string {:min 1}]
             :zip :int}}]</pre></z><z id="t1603117069" t="borkdude a bit like Schema, but more EDN-like"><y>#</y><d>2020-10-19</d><h>14:17</h><w>borkdude</w>a bit like Schema, but more EDN-like</z><z id="t1603118253" t="ikitommi ☝️ . simple formats like Schema and data-spec are kinda easy, but not simple: the core utilties (`select-keys`, assoc etc.) almost work, unless you have a wrapper for keys like ds/opt or s/optional-key in case they don’t. Also, value wrappers are needed to add visible properties/meta-data to schemas. And there is no order for keys. But, super nice for many things like defining inlined route parameters: [&quot;/plus&quot; {:get {:summary &quot;plus with spec query parameters&quot; :parameters {:query {:x int?, :y int?}} :responses {200 {:body {:total int?}}} :handler handle-plus}]"><y>#</y><d>2020-10-19</d><h>14:37</h><w>ikitommi</w><b>☝️</b>. simple formats like Schema and data-spec are kinda easy, but not simple: the core utilties (`select-keys`, <code>assoc</code> etc.) almost work, unless you have a wrapper for keys like <code>ds/opt</code> or <code>s/optional-key</code> in case they don’t. Also, value wrappers are needed to add visible properties/meta-data to schemas. And there is no order for keys. But, super nice for many things like defining inlined route parameters:
<pre>[&quot;/plus&quot;
 {:get {:summary &quot;plus with spec query parameters&quot;
        :parameters {:query {:x int?, :y int?}}
        :responses {200 {:body {:total int?}}}
        :handler handle-plus}]</pre></z><z id="t1603118427" t="ikitommi if there was a litemalli coercion in reitit, one could swap the data-spec apps almost 1:1 to it."><y>#</y><d>2020-10-19</d><h>14:40</h><w>ikitommi</w>if there was a <code>litemalli</code> coercion in reitit, one could swap the data-spec apps almost 1:1 to it.</z><z id="t1603118849" t="pithyless I prefer #1 to #2; the latter is making nested map notation implicit and special for :object and I don&apos;t know if it&apos;s worth it."><y>#</y><d>2020-10-19</d><h>14:47</h><w>pithyless</w>I prefer #1 to #2; the latter is making nested map notation implicit and special for <code>:object</code> and I don&apos;t know if it&apos;s worth it.</z><z id="t1603119112" t="pithyless That reitit example could just as easily be solved by a utility function that takes the concise nested map notation and converts it to a tree of :object"><y>#</y><d>2020-10-19</d><h>14:51</h><w>pithyless</w>That reitit example could just as easily be solved by a utility function that takes the concise nested map notation and converts it to a tree of <code>:object</code></z><z id="t1603119133" t="borkdude someone should write malli-tools ;)"><y>#</y><d>2020-10-19</d><h>14:52</h><w>borkdude</w>someone should write <code>malli-tools</code> ;)</z><z id="t1603119163" t="ikitommi :grinning_face_with_one_large_and_one_small_eye:"><y>#</y><d>2020-10-19</d><h>14:52</h><w>ikitommi</w><b>:grinning_face_with_one_large_and_one_small_eye:</b></z><z id="t1603119491" t="pithyless Does :object offer different semantics or tradeoffs than :map ? Or would it deref/merge down to a :map schema? Or would we have two things that are the same but different? :]"><y>#</y><d>2020-10-19</d><h>14:58</h><w>pithyless</w>Does <code>:object</code> offer different semantics or tradeoffs than <code>:map</code>? Or would it deref/merge down to a <code>:map</code> schema? Or would we have two things that are the same but different? :]</z><z id="t1603119596" t="pithyless To be clear, I prefer writing the map notation and was always confused why :map used vectors; but that ship has sailed... or has it?"><y>#</y><d>2020-10-19</d><h>14:59</h><w>pithyless</w>To be clear, I prefer writing the map notation and was always confused why <code>:map</code> used vectors; but that ship has sailed... or has it?</z><z id="t1603119674" t="borkdude we&apos;re in a dynlang, we can do everything we want ;)"><y>#</y><d>2020-10-19</d><h>15:01</h><w>borkdude</w>we&apos;re in a dynlang, we can do everything we want ;)</z><z id="t1603119823" t="pithyless I&apos;m thinking :object could be just a nice alternative syntax that would &quot;compile down&quot; to a :map . But maybe I&apos;m just missing the point. :)"><y>#</y><d>2020-10-19</d><h>15:03</h><w>pithyless</w>I&apos;m thinking <code>:object</code> could be just a nice alternative syntax that would &quot;compile down&quot; to a <code>:map</code>. But maybe I&apos;m just missing the point. :)</z><z id="t1603119896" t="ikitommi https://github.com/metosin/malli/issues/286"><y>#</y><d>2020-10-19</d><h>15:04</h><w>ikitommi</w><a href="https://github.com/metosin/malli/issues/286" target="_blank">https://github.com/metosin/malli/issues/286</a></z><z id="t1603119981" t="borkdude why it is called object though?"><y>#</y><d>2020-10-19</d><h>15:06</h><w>borkdude</w>why it is called object though?</z><z id="t1603120004" t="borkdude like JavaScript object?"><y>#</y><d>2020-10-19</d><h>15:06</h><w>borkdude</w>like JavaScript object?</z><z id="t1603120103" t="borkdude I was thinking like: wow, is this a schema to describe Java objects like bean-stuff?"><y>#</y><d>2020-10-19</d><h>15:08</h><w>borkdude</w>I was thinking like: wow, is this a schema to describe Java objects like bean-stuff?</z><z id="t1603120116" t="borkdude anyone not working on front-ends might think the same"><y>#</y><d>2020-10-19</d><h>15:08</h><w>borkdude</w>anyone not working on front-ends might think the same</z><z id="t1603120171" t="ikitommi vector syntax for :map allows simple way to define properties for it and retains the order of keys. But yes, we can add more schemas to build things in different ways. Could have also optional :`json-schema` that allows any JSON Schema in it etc."><y>#</y><d>2020-10-19</d><h>15:09</h><w>ikitommi</w>vector syntax for <code>:map</code> allows simple way to define properties for it and retains the order of keys.  But yes, we can add more schemas to build things in different ways. Could have also optional :`json-schema` that allows any JSON Schema in it etc.</z><z id="t1603120411" t="ikitommi the name could be anything, just flushing stuff from my brain (after a vacation)."><y>#</y><d>2020-10-19</d><h>15:13</h><w>ikitommi</w>the name could be anything, just flushing stuff from my brain (after a vacation).</z><z id="t1603120796" t="pithyless IMO, it would be confusing to see both :map and :object somewhere in my system output and they were semantically the same thing (a representation of known key-value mapping); so the way I see it: 1. if we want an alternative writing notation, why not just make it a utility function? (instead of introducing a new kind of schema) 2. if we want an alternative notation that is a data-literal (utility functions need runtime support), then we could introduce an alternative name (like :object ); but it could just as easily be :kv or :map2 ; or even why not extend existing :map to support both kinds of notations (vectors or maps) 3. if this is something similar to :map but offers possibly different semantics, than currently those semantics aren&apos;t clear to me; otherwise it&apos;d be great if we didn&apos;t have two things that represent essentially the same thing (this would make merging, etc. more complicated to deal with later on)"><y>#</y><d>2020-10-19</d><h>15:19</h><w>pithyless</w>IMO, it would be confusing to see both <code>:map</code> and <code>:object</code> somewhere in my system output and they were semantically the same thing (a representation of known key-value mapping); so the way I see it:
1. if we want an alternative writing notation, why not just make it a utility function? (instead of introducing a new kind of schema)
2. if we want an alternative notation that is a data-literal (utility functions need runtime support), then we could introduce an alternative name (like <code>:object</code> ); but it could just as easily be <code>:kv</code> or <code>:map2</code> ; or even why not extend existing <code>:map</code> to support both kinds of notations (vectors or maps)
3. if this is something similar to <code>:map</code> but offers possibly different semantics, than currently those semantics aren&apos;t clear to me; otherwise it&apos;d be great if we didn&apos;t have two things that represent essentially the same thing (this would make merging, etc. more complicated to deal with later on)</z><z id="t1603120905" t="pithyless (This is also why I like having :map and :map-of , because they represent different semantics; even though they are using the same internal datastructure)"><y>#</y><d>2020-10-19</d><h>15:21</h><w>pithyless</w>(This is also why I like having <code>:map</code> and <code>:map-of</code> , because they represent different semantics; even though they are using the same internal datastructure)</z><z id="t1603121913" t="ikitommi Related to 2, I think they should be kept separate (if implemented). If :map supported both syntax, there would be ambiguity issues: [:map {:id :int :title :string}] is that empty map with props? or map with no props but with keys?"><y>#</y><d>2020-10-19</d><h>15:38</h><w>ikitommi</w>Related to 2, I think they should be kept separate (if implemented). If <code>:map</code> supported both syntax, there would be ambiguity issues:
<pre>[:map
 {:id :int
  :title :string}]</pre>
is that empty map with props? or map with no props but with keys?</z><z id="t1603122208" t="ikitommi If I would implement that today, it would be a separate ns, malli.object etc, with a Schema impl, a helper and a extra registry snipplet so one can merge the schemas into a registry easily: (require &apos;[malli.core :as m]) (require &apos;[malli.object :as mo]) (def registry (merge (m/default-schemas) (mo/schemas))) (m/schema [:object {:id int? :address [:object {:street string?}]}] {:registry registry})"><y>#</y><d>2020-10-19</d><h>15:43</h><w>ikitommi</w>If I would implement that today, it would be a separate ns, <code>malli.object</code> etc, with a <code>Schema</code> impl, a helper and a extra registry snipplet so one can merge the schemas into a registry easily:
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.object :as mo])

(def registry (merge (m/default-schemas) (mo/schemas)))

(m/schema
  [:object 
   {:id int?
    :address [:object {:street string?}]}]
  {:registry registry})</pre></z><z id="t1603283292" t="salva-xf Hello, I found malli a couple of days ago and I&apos;m liking it although I don&apos;t know if I really understand it well, is malli suitable for defining state machines for example? In general, it is suitable for defining data structures to go through and generate code? generate the models for the orientdb and the datascript for example? Would it be suitable for, for example, defining IFML structures and generating the user interfaces from them? These are the questions that I try to answer while I see the documentation, thank you very much"><y>#</y><d>2020-10-21</d><h>12:28</h><w>salva-xf</w>Hello, I found malli a couple of days ago and I&apos;m liking it although I don&apos;t know if I really understand it well, is malli suitable for defining state machines for example? In general, it is suitable for defining data structures to go through and generate code? generate the models for the orientdb and the datascript for example? Would it be suitable for, for example, defining IFML structures and generating the user interfaces from them? These are the questions that I try to answer while I see the documentation, thank you very much</z><z id="t1603297151" t="Lucy Wang Malli could do most what spec could do, data validation, data transform/coercion, data generation etc. This might be a good refererence https://www.pixelated-noise.com/blog/2020/09/10/what-spec-is/"><y>#</y><d>2020-10-21</d><h>16:19</h><r>Lucy Wang</r>Malli could do most what spec could do, data validation, data transform/coercion, data generation etc. This might be a good refererence <a href="https://www.pixelated-noise.com/blog/2020/09/10/what-spec-is/" target="_blank">https://www.pixelated-noise.com/blog/2020/09/10/what-spec-is/</a></z><z id="t1603309008" t="ikitommi we have done separate definitions for state machines, as pure data too. signals to the state machine have (input) schemas, guards, actions and arbitrary other control data to them and the uis are derived from the combination of fme + schema definitions: form can be derived from schemas, available actions (and popovers why they are not available) from guards and the available actions in from the fme step definitions. lot’s of ui-stuff like extra re-frame action definitions, button texts and model guidees in the process definitions too."><y>#</y><d>2020-10-21</d><h>19:36</h><r>ikitommi</r>we have done separate definitions for state machines, as pure data too. signals to the state machine have (input) schemas, guards, actions and arbitrary other control data to them and the uis are derived from the combination of fme + schema definitions: form can be derived from schemas, available actions (and popovers why they are not available) from guards and the available actions in from the fme step definitions. lot’s of ui-stuff like extra re-frame action definitions, button texts and model guidees in the process definitions too.</z><z id="t1603309148" t="ikitommi most real uis need more that “automatically derived from schema”, but, it seems good for many cases like erp’ish internal stuff. Finland is the land of forms, great to have some extra leverage to build those ;)"><y>#</y><d>2020-10-21</d><h>19:39</h><r>ikitommi</r>most real uis need more that “automatically derived from schema”, but, it seems good for many cases like erp’ish internal stuff. Finland is the land of forms, great to have some extra leverage to build those ;)</z><z id="t1603309268" t="ikitommi great talk by [:attrs {:href &quot;/_/_/users/U050CBXUZ&quot;}] &amp; [:attrs {:href &quot;/_/_/users/U0DJK1VH6&quot;}] on building declarative uis with clj: https://www.youtube.com/watch?v=IekPZpfbdaI"><y>#</y><d>2020-10-21</d><h>19:41</h><r>ikitommi</r>great talk by <a>@U050CBXUZ</a> &amp; <a>@U0DJK1VH6</a> on building declarative uis with clj: <a href="https://www.youtube.com/watch?v=IekPZpfbdaI" target="_blank">https://www.youtube.com/watch?v=IekPZpfbdaI</a></z><z id="t1603363185" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I was noticing a regex/parse function in one of the examples. Why is there a special regex/parse function: shouldn&apos;t all schema&apos;s support parse - not only regex schemas? And maybe parse is just a special case of a transformer?"><y>#</y><d>2020-10-22</d><h>10:39</h><w>borkdude</w><a>@ikitommi</a> I was noticing a regex/parse function in one of the examples. Why is there a special regex/parse function: shouldn&apos;t all schema&apos;s support parse - not only regex schemas?
And maybe parse is just a special case of a transformer?</z><z id="t1603363299" t="borkdude Note: this question is coming from a relatively inexperienced user of malli"><y>#</y><d>2020-10-22</d><h>10:41</h><w>borkdude</w>Note: this question is coming from a relatively inexperienced user of malli</z><z id="t1603363904" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] good question! it’s the internal api, not yet integrated into malli.core. after it’s integrated, there will ne a`-destructure` or -parse method in Schema . My first guess was that there is no need to have a reverse function for that in Schema (like spec has conform and unform ), but not 100% sure."><y>#</y><d>2020-10-22</d><h>10:51</h><w>ikitommi</w><a>@borkdude</a> good question! it’s the internal api, not yet integrated into malli.core. after it’s integrated, there will ne a`-destructure` or <code>-parse</code> method in <code>Schema</code>. My first guess was that there is no need to have a reverse function for that in <code>Schema</code> (like spec has <code>conform</code> and <code>unform</code>), but not 100% sure.</z><z id="t1603364049" t="ikitommi oh, haven’t pushed the current draft into github. will have time tomorrow for this, will push the stuff out."><y>#</y><d>2020-10-22</d><h>10:54</h><w>ikitommi</w>oh, haven’t pushed the current draft into github. will have time tomorrow for this, will push the stuff out.</z><z id="t1603619375" t="borkdude https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/"><y>#</y><d>2020-10-25</d><h>09:49</h><w>borkdude</w><a href="https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/" target="_blank">https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/</a></z><z id="t1603620858" t="jeroenvandijk I did, yes it is more involved 🙂"><y>#</y><d>2020-10-25</d><h>10:14</h><w>jeroenvandijk</w>I did, yes it is more involved <b>🙂</b></z><z id="t1603621035" t="jeroenvandijk To be more specific, this project is a (conceptual) port from a clojure.spec project https://github.com/jeroenvandijk/aws.cloudformation.malli"><y>#</y><d>2020-10-25</d><h>10:17</h><r>jeroenvandijk</r>To be more specific, this project is a (conceptual) port from a clojure.spec project <a href="https://github.com/jeroenvandijk/aws.cloudformation.malli" target="_blank">https://github.com/jeroenvandijk/aws.cloudformation.malli</a></z><z id="t1603621123" t="jeroenvandijk I was generating the clojure.spec definitions from the AWS Cloudformation spec. This generation part was much easier with Malli"><y>#</y><d>2020-10-25</d><h>10:18</h><r>jeroenvandijk</r>I was generating the clojure.spec definitions from the AWS Cloudformation spec. This generation part was much easier with Malli</z></g><g id="s8"><z id="t1603621145" t="jeroenvandijk There are enough differences that I cannot consider it as a 1 on 1 port"><y>#</y><d>2020-10-25</d><h>10:19</h><r>jeroenvandijk</r>There are enough differences that I cannot consider it as a 1 on 1 port</z><z id="t1603622413" t="borkdude Feel free to respond on Reddit as this was not my own question, just forwarded it here"><y>#</y><d>2020-10-25</d><h>10:40</h><r>borkdude</r>Feel free to respond on Reddit as this was not my own question, just forwarded it here</z><z id="t1603623094" t="jeroenvandijk yeah thanks. I’m not using reddit. I hope the reddit user finds it here 😅"><y>#</y><d>2020-10-25</d><h>10:51</h><r>jeroenvandijk</r>yeah thanks. I’m not using reddit. I hope the reddit user finds it here <b>😅</b></z><z id="t1603643322" t="borkdude Is there any guidance on how to write your own transformer?"><y>#</y><d>2020-10-25</d><h>16:28</h><w>borkdude</w>Is there any guidance on how to write your own transformer?</z><z id="t1603643743" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] there is no guide yet, but lot of tests and some samples in the README."><y>#</y><d>2020-10-25</d><h>16:35</h><w>ikitommi</w><a>@borkdude</a> there is no guide yet, but lot of tests and some samples in the README.</z><z id="t1603643780" t="ikitommi happy to help if you need any."><y>#</y><d>2020-10-25</d><h>16:36</h><w>ikitommi</w>happy to help if you need any.</z><z id="t1603643913" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think I asked this before, but I can&apos;t find any docs on this, nor can I find the conversation on Zulip. So here it goes: (def Schema [:map [:x int?]]) (defrecord Wrapper [obj loc]) parsed ;;=&gt; {#script.Wrapper{:obj :x, :loc {:row 1, :col 2, :end-row 1, :end-col 4}} #script.Wrapper{:obj 1, :loc {:row 1, :col 5, :end-row 1, :end-col 6}}} (defn wrapper-transformer [] (mt/transformer {:name :wrapper :default-decoder :obj :default-encoder (fn [obj] (-&gt;Wrapper obj nil))})) (prn (m/decode Schema parsed wrapper-transformer)) ;;=&gt; nil ... ??? "><y>#</y><d>2020-10-25</d><h>16:38</h><w>borkdude</w><a>@ikitommi</a> I think I asked this before, but I can&apos;t find any docs on this, nor can I find the conversation on Zulip. So here it goes:
<pre>(def Schema
  [:map [:x int?]])

(defrecord Wrapper [obj loc])

parsed 
;;=&gt; {#script.Wrapper{:obj :x, :loc {:row 1, :col 2, :end-row 1, :end-col 4}} #script.Wrapper{:obj 1, :loc {:row 1, :col 5, :end-row 1, :end-col 6}}}

(defn wrapper-transformer []
  (mt/transformer
   {:name :wrapper
    :default-decoder :obj
    :default-encoder (fn [obj]
                       (-&gt;Wrapper obj nil))}))

(prn (m/decode Schema parsed wrapper-transformer)) ;;=&gt; nil ... ???</pre>
</z><z id="t1603644014" t="borkdude so I want to validate/transform the wrapped value according to the schema"><y>#</y><d>2020-10-25</d><h>16:40</h><w>borkdude</w>so I want to validate/transform the wrapped value according to the schema</z><z id="t1603644088" t="borkdude any value that is not Wrapped should just be transformed as is"><y>#</y><d>2020-10-25</d><h>16:41</h><w>borkdude</w>any value that is not Wrapped should just be transformed as is</z><z id="t1603644102" t="borkdude but a value that is wrapped should be unpacked using :obj"><y>#</y><d>2020-10-25</d><h>16:41</h><w>borkdude</w>but a value that is wrapped should be unpacked using <code>:obj</code></z><z id="t1603644125" t="borkdude and I want to give an error message based on :loc"><y>#</y><d>2020-10-25</d><h>16:42</h><w>borkdude</w>and I want to give an error message based on <code>:loc</code></z><z id="t1603644251" t="ikitommi oh, i recall. need to dig in my histories too if there was/is a good answer."><y>#</y><d>2020-10-25</d><h>16:44</h><w>ikitommi</w>oh, i recall. need to dig in my histories too if there was/is a good answer.</z><z id="t1603644340" t="borkdude I tried this: (defn unwrap [x] (if (instance? Wrapper x) (:obj x) x)) (defn wrapper-transformer [] (mt/transformer {:name :wrapper :default-decoder unwrap :default-encoder (fn [obj] (-&gt;Wrapper obj nil))})) but this just returns the entire object itself"><y>#</y><d>2020-10-25</d><h>16:45</h><w>borkdude</w>I tried this:
<pre>(defn unwrap [x]
  (if (instance? Wrapper x)
    (:obj x)
    x))

(defn wrapper-transformer []
  (mt/transformer
   {:name :wrapper
    :default-decoder unwrap
    :default-encoder (fn [obj]
                       (-&gt;Wrapper obj nil))}))</pre>
but this just returns the entire object itself</z><z id="t1603644439" t="borkdude it seems it doesn&apos;t handle the value recursively"><y>#</y><d>2020-10-25</d><h>16:47</h><w>borkdude</w>it seems it doesn&apos;t handle the value recursively</z><z id="t1603644640" t="ikitommi the problem is that the decoder is first given a map, it calls :obj on it, which return nil."><y>#</y><d>2020-10-25</d><h>16:50</h><w>ikitommi</w>the problem is that the decoder is first given a map, it calls <code>:obj</code> on it, which return nil.</z><z id="t1603644665" t="ikitommi I would use clojure.walk/pre-walk for first sweep of decoding."><y>#</y><d>2020-10-25</d><h>16:51</h><w>ikitommi</w>I would use <code>clojure.walk/pre-walk</code> for first sweep of decoding.</z><z id="t1603644746" t="ikitommi the decoding here walks: 1. the :map 2. the keys (`:x`)"><y>#</y><d>2020-10-25</d><h>16:52</h><w>ikitommi</w>the decoding here walks:
1. the :map
2. the keys (`:x`)</z><z id="t1603644778" t="ikitommi unless the Wrapped is already decoded on 1, there is no :x and the decoding stops."><y>#</y><d>2020-10-25</d><h>16:52</h><w>ikitommi</w>unless the <code>Wrapped</code>is already decoded on 1, there is no <code>:x</code> and the decoding stops.</z><z id="t1603644813" t="ikitommi so, with malli, you would need to decode all the keys &amp; values on :map step also. doable, but extra noise 😞"><y>#</y><d>2020-10-25</d><h>16:53</h><w>ikitommi</w>so, with malli, you would need to decode all the keys &amp; values on <code>:map</code> step also. doable, but extra noise <b>😞</b></z><z id="t1603644940" t="ikitommi (ns user (:require [malli.core :as m] [malli.transform :as mt])) (def Schema [:map [:x int?]]) (defrecord Wrapper [obj loc]) (def parsed {(map-&gt;Wrapper {:obj :x, :loc {:row 1, :col 2, :end-row 1, :end-col 4}}) (map-&gt;Wrapper {:obj 1, :loc {:row 1, :col 5, :end-row 1, :end-col 6}})}) (defn unwrap [x] (if (instance? Wrapper x) (:obj x) x)) (defn wrapper-transformer [] (mt/transformer {:name :wrapper :decoders {:map (fn [x] (reduce-kv (fn [acc k v] (assoc acc (unwrap k) (unwrap v))) {} x))} :default-decoder unwrap :default-encoder (fn [obj] (-&gt;Wrapper obj nil))})) (m/decode Schema parsed wrapper-transformer) ;;=&gt; nil ... ??? ; =&gt; {:x 1}"><y>#</y><d>2020-10-25</d><h>16:55</h><w>ikitommi</w><pre>(ns user
  (:require [malli.core :as m]
            [malli.transform :as mt]))

(def Schema
  [:map [:x int?]])

(defrecord Wrapper [obj loc])

(def parsed {(map-&gt;Wrapper {:obj :x, :loc {:row 1, :col 2, :end-row 1, :end-col 4}})
             (map-&gt;Wrapper {:obj 1, :loc {:row 1, :col 5, :end-row 1, :end-col 6}})})

(defn unwrap [x]
  (if (instance? Wrapper x) (:obj x) x))

(defn wrapper-transformer []
  (mt/transformer
    {:name :wrapper
     :decoders {:map (fn [x] (reduce-kv (fn [acc k v] (assoc acc (unwrap k) (unwrap v))) {} x))}
     :default-decoder unwrap
     :default-encoder (fn [obj] (-&gt;Wrapper obj nil))}))

(m/decode Schema parsed wrapper-transformer) ;;=&gt; nil ... ???
; =&gt; {:x 1}</pre></z><z id="t1603644949" t="ikitommi but, this is much simpler: (clojure.walk/prewalk unwrap parsed) ; =&gt; {:x 1}"><y>#</y><d>2020-10-25</d><h>16:55</h><w>ikitommi</w>but, this is much simpler:
<pre>(clojure.walk/prewalk unwrap parsed)
; =&gt; {:x 1}</pre></z><z id="t1603645071" t="borkdude Yes, but how do I get validation errors if I first call prewalk on this thing?"><y>#</y><d>2020-10-25</d><h>16:57</h><w>borkdude</w>Yes, but how do I get validation errors if I first call prewalk on this thing?</z><z id="t1603645086" t="borkdude based on :loc"><y>#</y><d>2020-10-25</d><h>16:58</h><w>borkdude</w>based on <code>:loc</code></z><z id="t1603645090" t="ikitommi I’ll check more of this later."><y>#</y><d>2020-10-25</d><h>16:58</h><w>ikitommi</w>I’ll check more of this later.</z><z id="t1603645366" t="borkdude Thanks. Me too, cooking dinner :)"><y>#</y><d>2020-10-25</d><h>17:02</h><w>borkdude</w>Thanks. Me too, cooking dinner :)</z><z id="t1603645672" t="borkdude Hmm, in spec I would maybe have to spec a key as ::wrapped-int and then coerce it after it was checked?"><y>#</y><d>2020-10-25</d><h>17:07</h><w>borkdude</w>Hmm, in spec I would maybe have to spec a key as <code>::wrapped-int</code> and then coerce it after it was checked?</z><z id="t1603645991" t="borkdude which is not ideal"><y>#</y><d>2020-10-25</d><h>17:13</h><w>borkdude</w>which is not ideal</z><z id="t1603646740" t="ikitommi can the wrapped by anywhere? Wrapped map/vector/set? All values are wrapped (any nested edn value)? Or just keys and values in the map?"><y>#</y><d>2020-10-25</d><h>17:25</h><w>ikitommi</w>can the wrapped by anywhere? Wrapped map/vector/set? All values are wrapped (any nested edn value)? Or just keys and values in the map?</z><z id="t1603646767" t="ikitommi I have an idea, but would like to understand the case first."><y>#</y><d>2020-10-25</d><h>17:26</h><w>ikitommi</w>I have an idea, but would like to understand the case first.</z><z id="t1603648453" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] The use case is preserving location information for non-iobjs and using that for error messages while validating malli schemas"><y>#</y><d>2020-10-25</d><h>17:54</h><w>borkdude</w><a>@ikitommi</a> The use case is preserving location information for non-iobjs and using that for error messages while validating malli schemas</z><z id="t1603648476" t="borkdude e.g. you want to validate an EDN file and you get an error: this should be an int, on line 5, row 12"><y>#</y><d>2020-10-25</d><h>17:54</h><w>borkdude</w>e.g. you want to validate an EDN file and you get an error: this should be an int, on line 5, row 12</z><z id="t1603649798" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] This is the complete code: deps.edn: {:deps {metosin/malli {:mvn/version &quot;0.2.1&quot;} borkdude/edamame {:git/url &quot;&quot; :sha &quot;ba93fcfca1a0fff1f68d5137b98606b82797a17a&quot;}}} (ns script (:require [edamame.core :as e] [malli.core :as m] [malli.transform :as mt])) (def Schema [:map [:x int?]]) (defrecord Wrapper [obj loc]) (defn iobj? [x] (instance? clojure.lang.IObj x)) (def parsed (e/parse-string &quot;{:x 1}&quot; {:postprocess (fn [{:keys [:obj :loc]}] (if (iobj? obj) (vary-meta obj merge loc) (-&gt;Wrapper obj loc)))})) (defn unwrap [x] (if (instance? Wrapper x) (:obj x) x)) (defn wrapper-transformer [] (mt/transformer {:name :wrapper :default-decoder unwrap :default-encoder (fn [obj] (-&gt;Wrapper obj nil))})) ;; (prn parsed) (prn (m/decode Schema parsed wrapper-transformer))"><y>#</y><d>2020-10-25</d><h>18:16</h><w>borkdude</w><a>@ikitommi</a> This is the complete code:

deps.edn:
<pre>{:deps {metosin/malli {:mvn/version &quot;0.2.1&quot;}
        borkdude/edamame {:git/url &quot;&quot;
                          :sha &quot;ba93fcfca1a0fff1f68d5137b98606b82797a17a&quot;}}}</pre>
<pre>(ns script
  (:require [edamame.core :as e]
            [malli.core :as m]
            [malli.transform :as mt]))

(def Schema
  [:map [:x int?]])

(defrecord Wrapper [obj loc])

(defn iobj? [x]
  (instance? clojure.lang.IObj x))

(def parsed
  (e/parse-string &quot;{:x 1}&quot;
                  {:postprocess
                   (fn [{:keys [:obj :loc]}]
                     (if (iobj? obj)
                       (vary-meta obj merge loc)
                       (-&gt;Wrapper obj loc)))}))

(defn unwrap [x]
  (if (instance? Wrapper x)
    (:obj x)
    x))

(defn wrapper-transformer []
  (mt/transformer
   {:name :wrapper
    :default-decoder unwrap
    :default-encoder (fn [obj]
                       (-&gt;Wrapper obj nil))}))

;; (prn parsed)
(prn (m/decode Schema parsed wrapper-transformer))</pre></z><z id="t1603654508" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Found the conversation here: https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli/near/206235546"><y>#</y><d>2020-10-25</d><h>19:35</h><w>borkdude</w><a>@ikitommi</a> Found the conversation here: <a href="https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli/near/206235546" target="_blank">https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/malli/near/206235546</a></z><z id="t1603655537" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] So the way it can work is: (defn fail! [schema {:keys [:obj :loc]}] (throw (ex-info (str obj &quot; did not satisfy &quot; schema &quot; [at &quot; (str (:col loc)&quot;:&quot;(:row loc)) &quot;]&quot;) {}))) (def &lt;42 [:and &apos;int? [:&lt; 42]]) (defn lift-non-iobj-schema [schema] [:map {:encode/success :obj, :encode/failure (partial fail! schema)} [:obj schema]]) (def Schema [:map [:a (lift-non-iobj-schema &lt;42)]]) (def valid? (m/validator Schema)) (def success (m/encoder Schema (mt/transformer {:name :success}))) (def failure (m/encoder Schema (mt/transformer {:name :failure})))"><y>#</y><d>2020-10-25</d><h>19:52</h><w>borkdude</w><a>@ikitommi</a> So the way it can work is:
<pre>(defn fail! [schema {:keys [:obj :loc]}]
  (throw (ex-info (str obj &quot; did not satisfy &quot; schema
                       &quot; [at &quot; (str (:col loc)&quot;:&quot;(:row loc)) &quot;]&quot;) {})))

(def &lt;42 [:and &apos;int? [:&lt; 42]])

(defn lift-non-iobj-schema [schema]
  [:map {:encode/success :obj,
         :encode/failure (partial fail! schema)} [:obj schema]])

(def Schema [:map [:a (lift-non-iobj-schema &lt;42)]])

(def valid? (m/validator Schema))
(def success (m/encoder Schema (mt/transformer {:name :success})))
(def failure (m/encoder Schema (mt/transformer {:name :failure})))</pre></z><z id="t1603655553" t="borkdude E.g. this will print: (prn (parse-validate-and-transform &quot;{:a 42}&quot;))"><y>#</y><d>2020-10-25</d><h>19:52</h><w>borkdude</w>E.g. this will print:
<pre>(prn (parse-validate-and-transform &quot;{:a 42}&quot;))</pre></z><z id="t1603655565" t="borkdude Syntax error (ExceptionInfo) compiling at (script.clj:32:1). 42 did not satisfy [:and int? [:&lt; 42]] [at 5:1]"><y>#</y><d>2020-10-25</d><h>19:52</h><w>borkdude</w><pre>Syntax error (ExceptionInfo) compiling at (script.clj:32:1).
42 did not satisfy [:and int? [:&lt; 42]] [at 5:1]</pre></z><z id="t1603655629" t="borkdude The downsize of this is that I have to wrap schemas myself in case I want to check something non-iobj-ish (strings, keywords, numbers)"><y>#</y><d>2020-10-25</d><h>19:53</h><w>borkdude</w>The downsize of this is that I have to wrap schemas myself in case I want to check something non-iobj-ish (strings, keywords, numbers)</z><z id="t1603655845" t="borkdude And this doesn&apos;t seem to work for keywords for example: (def &lt;42 [:and &apos;int? [:&lt; 42]]) (defn lift-non-iobj-schema [schema] [:map {:encode/success :obj, :encode/failure (partial fail! schema)} [:obj schema]]) (def Schema [:map [(lift-non-iobj-schema :a) (lift-non-iobj-schema &lt;42)]])"><y>#</y><d>2020-10-25</d><h>19:57</h><w>borkdude</w>And this doesn&apos;t seem to work for keywords for example:
<pre>(def &lt;42 [:and &apos;int? [:&lt; 42]])

(defn lift-non-iobj-schema [schema]
  [:map {:encode/success :obj,
         :encode/failure (partial fail! schema)}
   [:obj schema]])

(def Schema [:map [(lift-non-iobj-schema :a) (lift-non-iobj-schema &lt;42)]])</pre></z><z id="t1603655889" t="borkdude anyway, maybe this is a too niche use case"><y>#</y><d>2020-10-25</d><h>19:58</h><w>borkdude</w>anyway, maybe this is a too niche use case</z><z id="t1603656201" t="ikitommi have an idea, need 30min to test &amp; play"><y>#</y><d>2020-10-25</d><h>20:03</h><w>ikitommi</w>have an idea, need 30min to test &amp; play</z><z id="t1603656334" t="borkdude take yer time"><y>#</y><d>2020-10-25</d><h>20:05</h><w>borkdude</w>take yer time</z><z id="t1603656396" t="borkdude if this can be fixed, potentially it would also work for rewrite-cljc structures: normal malli specs, but they run over the rewrite-cljc nodes using a simple function that looks at the actual value"><y>#</y><d>2020-10-25</d><h>20:06</h><w>borkdude</w>if this can be fixed, potentially it would also work for rewrite-cljc structures: normal malli specs, but they run over the rewrite-cljc nodes using a simple function that looks at the actual value</z><z id="t1603656463" t="borkdude it&apos;s basically a projection from wrapped thing to the essential value while the wrapped thing has more info to produce useful output in case of failure to parse/validate"><y>#</y><d>2020-10-25</d><h>20:07</h><w>borkdude</w>it&apos;s basically a projection from wrapped thing to the essential value while the wrapped thing has more info to produce useful output in case of failure to parse/validate</z><z id="t1603707408" t="ikitommi [:attrs {:href &quot;/_/_/users/UBN9SNVB4&quot;}] the huge schema creation perf issue: culprit is satisfies? , which can be removed using a special extending protocols to protocols pattern. With quick test it’s 22sec -&gt; 2sec. With some tuning, 0.8sec. Fix is on the backlog."><y>#</y><d>2020-10-26</d><h>10:16</h><w>ikitommi</w><a>@jarvinenemil</a> the huge schema creation perf issue: culprit is <code>satisfies?</code>, which can be removed using a special <code>extending protocols to protocols</code> pattern. With quick test it’s 22sec -&gt; 2sec. With some tuning, 0.8sec. Fix is on the backlog.</z><z id="t1603707464" t="dangercoder awesome [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , good find!"><y>#</y><d>2020-10-26</d><h>10:17</h><w>dangercoder</w>awesome <a>@ikitommi</a>, good find!</z><z id="t1603747590" t="mruzekw Hi all, what are the options currently to use Malli like you can with clojure.spec and ghostwheel or orchestra? So far I&apos;ve found teknql/aave, but I wondered if there were others"><y>#</y><d>2020-10-26</d><h>21:26</h><w>mruzekw</w>Hi all, what are the options currently to use Malli like you can with clojure.spec and ghostwheel or orchestra? So far I&apos;ve found teknql/aave, but I wondered if there were others</z><z id="t1603753488" t="rschmukler [:attrs {:href &quot;/_/_/users/U1RCQD0UE&quot;}] I think aave is the only one right now. It&apos;s definitely been on my backburner though so happy to accept PRs if you feel like hacking on it. Otherwise I wouldn&apos;t be surprised if ikitommi ends up releasing his own thing. Happy to update aave to 0.2.0 if that&apos;s what is keeping you back from it. (No pressure to use it either!)"><y>#</y><d>2020-10-26</d><h>23:04</h><w>rschmukler</w><a>@mruzekw</a> I think aave is the only one right now. It&apos;s definitely been on my backburner though so happy to accept PRs if you feel like hacking on it. Otherwise I wouldn&apos;t be surprised if ikitommi ends up releasing his own thing. Happy to update aave to 0.2.0 if that&apos;s what is keeping you back from it. (No pressure to use it either!)</z><z id="t1603817025" t="lmergen just a shout-out that i&apos;m biting the bullet and migrating our project with 4k+ LoC full of specs to malli and i&apos;m totally loving it -- the fact that it&apos;s just plain symbols + data makes thing so much easier to reason about. thanks a lot for this monumental effort of making malli work!"><y>#</y><d>2020-10-27</d><h>16:43</h><w>lmergen</w>just a shout-out that i&apos;m biting the bullet and migrating our project with 4k+ LoC full of specs to malli and i&apos;m totally loving it -- the fact that it&apos;s just plain symbols + data makes thing so much easier to reason about. thanks a lot for this monumental effort of making malli work!</z><z id="t1603817330" t="lmergen just a sanity check, but it seems to me that using &quot;plain data&quot; for all the schemas (i.e. not wrapping them in m/schema), and then at a later point use a compile-time m/validator and m/explainer is a decent approach, right ? i&apos;ve just whipped up this macro to perform assertions, which allocates the explainer at compile time, but does the actual validations at runtime (defmacro assert [s v] (when *assert* (let [explainer# `(m/explainer ~s)] `(when-let [ed# (~explainer# ~v)] (throw (ex-info &quot;Validation failed&quot; (merge {::v ~v} (me/humanize ed#)))))))) "><y>#</y><d>2020-10-27</d><h>16:48</h><w>lmergen</w>just a sanity check, but it seems to me that using &quot;plain data&quot; for all the schemas (i.e. not wrapping them in m/schema), and then at a later point use a compile-time <code>m/validator</code> and <code>m/explainer</code> is a decent approach, right ?

i&apos;ve just whipped up this macro to perform assertions, which allocates the explainer at compile time, but does the actual validations at runtime
<pre>(defmacro assert
  [s v]
  (when *assert*
    (let [explainer# `(m/explainer ~s)]
      `(when-let [ed# (~explainer# ~v)]
         (throw (ex-info &quot;Validation failed&quot;
                         (merge {::v ~v}
                                (me/humanize ed#))))))))</pre>
</z><z id="t1663894338" t="marciol Hey, [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] thanks for this snippet. I wonder if this can be part of the default malli distribution [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2022-09-23</d><h>00:52</h><r>marciol</r>Hey, <a>@lmergen</a> thanks for this snippet.

I wonder if this can be part of the default malli distribution <a>@U055NJ5CC</a></z><z id="t1663939442" t="ikitommi I think that m/assert would be good, but it should work in all situations, so I believe the schema creation should happen at runtime."><y>#</y><d>2022-09-23</d><h>13:24</h><r>ikitommi</r>I think that <code>m/assert</code> would be good, but it should work in all situations, so I believe the schema creation should happen at runtime.</z><z id="t1603817487" t="borkdude [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] I&apos;m curious about your experience report. There is a thread on Reddit about exactly this. Feel free to comment there if you want."><y>#</y><d>2020-10-27</d><h>16:51</h><w>borkdude</w><a>@lmergen</a> I&apos;m curious about your experience report. There is a thread on Reddit about exactly this. Feel free to comment there if you want.</z><z id="t1603817516" t="borkdude ( https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/ )"><y>#</y><d>2020-10-27</d><h>16:51</h><w>borkdude</w>(<a href="https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/" target="_blank">https://www.reddit.com/r/Clojure/comments/jhq899/did_anyone_migrate_a_nontrivial_project_from_spec/</a>)</z><z id="t1603817573" t="rschmukler [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] that&apos;s exactly what I do. Most (all?) of the malli public API will coerce to a compiled schema, which lets you keep your schema definitions nice and focused. Then compile-time m/validator and m/explainer . Also there are the short hands of m/explain (and m/validate ) which create a temporary explainer for you. This isn&apos;t performant, but, for use-cases like your macro, it saves you having to create it yourself."><y>#</y><d>2020-10-27</d><h>16:52</h><w>rschmukler</w><a>@lmergen</a> that&apos;s exactly what I do. Most (all?) of the malli public API will coerce to a compiled schema, which lets you keep your schema definitions nice and focused. Then compile-time <code>m/validator</code> and <code>m/explainer</code>. Also there are the short hands of <code>m/explain</code> (and <code>m/validate</code>) which create a temporary explainer for you. This isn&apos;t performant, but, for use-cases like your macro, it saves you having to create it yourself.</z><z id="t1603817618" t="rschmukler I suppose a slight difference is that your macro will create the explainer at compile time, so up to you if you want that difference!"><y>#</y><d>2020-10-27</d><h>16:53</h><w>rschmukler</w>I suppose a slight difference is that your macro will create the explainer at compile time, so up to you if you want that difference!</z><z id="t1603817624" t="lmergen [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] i started that thread 🙂"><y>#</y><d>2020-10-27</d><h>16:53</h><w>lmergen</w><a>@borkdude</a> i started that thread <b>🙂</b></z><z id="t1603817646" t="borkdude aaah! :)"><y>#</y><d>2020-10-27</d><h>16:54</h><w>borkdude</w>aaah! :)</z><z id="t1603817829" t="lmergen but yes so far so good -- of course there&apos;s a &quot;second system&quot; benefit here, because i have a much better understanding of the model and taking the opportunity to refactor a few things. one of the big changes is that rather than one humongous specs.cljc , i&apos;m now creating many more namespaces, and each of the malli schemas live within those namespaces. the reason for this is that spec works with (namespaced) keywords, so you can get away with putting them in a single namespace, where malli seems to map more natural if you split things up in different namespaces."><y>#</y><d>2020-10-27</d><h>16:57</h><w>lmergen</w>but yes so far so good -- of course there&apos;s a &quot;second system&quot; benefit here, because i have a much better understanding of the model and taking the opportunity to refactor a few things. one of the big changes is that rather than one humongous <code>specs.cljc</code>, i&apos;m now creating many more namespaces, and each of the malli schemas live within those namespaces. the reason for this is that spec works with (namespaced) keywords, so you can get away with putting them in a single namespace, where malli seems to map more natural if you split things up in different namespaces.</z><z id="t1603818294" t="rschmukler [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] that was exactly my experience as well! One benefit that you get is if you make use of def or defn to return those data schemas, you get the added benefit of having the compiler help check that those things still exist. In spec you can delete / mistype a keyword and get bit, but here, you can get the compiler (or clj-kondo) to help you"><y>#</y><d>2020-10-27</d><h>17:04</h><w>rschmukler</w><a>@lmergen</a> that was exactly my experience as well! One benefit that you get is if you make use of <code>def</code> or <code>defn</code> to return those data schemas, you get the added benefit of having the compiler help check that those things still exist. In spec you can delete / mistype a keyword and get bit, but here, you can get the compiler (or clj-kondo) to help you</z><z id="t1603879975" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think I would have a real good use of sequence schemas. Spec is painful to work for command line usage with due to macros, malli is a pleasure because it&apos;s data and also compatible with Graal. Context: https://gist.github.com/borkdude/a391146ad81a06c28fb97ccdc1f64d44"><y>#</y><d>2020-10-28</d><h>10:12</h><w>borkdude</w><a>@ikitommi</a> I think I would have a real good use of sequence schemas. Spec is painful to work for command line usage with due to macros, malli is a pleasure because it&apos;s data and also compatible with Graal.

Context: <a href="https://gist.github.com/borkdude/a391146ad81a06c28fb97ccdc1f64d44" target="_blank">https://gist.github.com/borkdude/a391146ad81a06c28fb97ccdc1f64d44</a></z><z id="t1603881702" t="jeroenvandijk I was thinking about this too. To find duplicated or similar code etc"><y>#</y><d>2020-10-28</d><h>10:41</h><r>jeroenvandijk</r>I was thinking about this too. To find duplicated or similar code etc</z><z id="t1603880013" t="borkdude Imagine that the user can specify a schema on the command line to search for code patterns."><y>#</y><d>2020-10-28</d><h>10:13</h><w>borkdude</w>Imagine that the user can specify a schema on the command line to search for code patterns.</z><z id="t1604016353" t="eraad Hi! I’m using Malli schemas to generate a Swagger spec using Reitit (ie. “issue_date”). These schemas have encoding fns so “issue_date” is coerced to :document/issue-date so it can be saved into Datomic. I want to confirm if the Reitit coercers do validation after coercion right? Because I’m not getting it to validate as “issue_date” but :document/issue-date"><y>#</y><d>2020-10-30</d><h>00:05</h><w>eraad</w>Hi! I’m using Malli schemas to generate a Swagger spec using Reitit (ie. “issue_date”). These schemas have encoding fns so “issue_date” is coerced to :document/issue-date so it can be saved into Datomic.

I want to confirm if the Reitit coercers do validation after coercion right? Because I’m not getting it to validate as “issue_date” but :document/issue-date</z><z id="t1604016470" t="eraad It is what I can see from the code and from the behaviour. If I want to keep the json-like schemas for Swagger generation AND validate using those, I need to do coercion after all that manually right?"><y>#</y><d>2020-10-30</d><h>00:07</h><w>eraad</w>It is what I can see from the code and from the behaviour. If I want to keep the json-like schemas for Swagger generation AND validate using those, I need to do coercion after all that manually right?</z><z id="t1604016498" t="eraad Or of course write my own Malli coercer that always decodes."><y>#</y><d>2020-10-30</d><h>00:08</h><w>eraad</w>Or of course write my own Malli coercer that always decodes.</z><z id="t1604016721" t="eraad I would appreciate any pointers on this"><y>#</y><d>2020-10-30</d><h>00:12</h><w>eraad</w>I would appreciate any pointers on this</z><z id="t1604073667" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] should there be m/assert ?"><y>#</y><d>2020-10-30</d><h>16:01</h><w>ikitommi</w><a>@lmergen</a> <a>@rschmukler</a> should there be <code>m/assert</code>?</z><z id="t1604221189" t="lmergen i think there should be -- i have two functions myself actually, assert and have , where have is inspired by ptaoussanis&apos; truss -- https://github.com/ptaoussanis/truss effectively, have does the assertion + also returns the input value if no failure was detected. this allows for a pattern such as (let [foo (m/have foo-schema (get x :foo))] ...) it&apos;s very effective. i would be happy to send a PR for the assert and/or have implementations i have right now (which seem to be doing the right thing)"><y>#</y><d>2020-11-01</d><h>08:59</h><r>lmergen</r>i think there should be -- i have two functions myself actually, <code>assert</code> and <code>have</code>, where <code>have</code> is inspired by ptaoussanis&apos; truss -- <a href="https://github.com/ptaoussanis/truss" target="_blank">https://github.com/ptaoussanis/truss</a>

effectively, <code>have</code> does the assertion + also returns the input value if no failure was detected. this allows for a pattern such as

<pre>(let [foo (m/have foo-schema (get x :foo))]
  ...)</pre>
it&apos;s very effective.

i would be happy to send a PR for the <code>assert</code> and/or <code>have</code> implementations i have right now (which seem to be doing the right thing)</z><z id="t1604073739" t="ikitommi [:attrs {:href &quot;/_/_/users/U061BSX36&quot;}] coercion is decode + validate in reitit-malli"><y>#</y><d>2020-10-30</d><h>16:02</h><w>ikitommi</w><a>@eraad</a> coercion is decode + validate in reitit-malli</z><z id="t1604073802" t="ikitommi for responses, I recall it&apos;s validate + encode"><y>#</y><d>2020-10-30</d><h>16:03</h><w>ikitommi</w>for responses, I recall it&apos;s validate + encode</z><z id="t1604073863" t="ikitommi have had a super busy two weeks, should have few full days of malli after next wed."><y>#</y><d>2020-10-30</d><h>16:04</h><w>ikitommi</w>have had a super busy two weeks, should have few full days of malli after next wed.</z><z id="t1604074898" t="eraad Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] got you"><y>#</y><d>2020-10-30</d><h>16:21</h><w>eraad</w>Thanks <a>@ikitommi</a> got you</z><z id="t1604075440" t="ikitommi the m/defn , currently have a separate malli.schema ns, and few helper ns&apos;s under it. Will have the 1:1 Plumatic Schema m/defn for Malli. Once done, will do the real full malli-&gt;clj-kondo integration, that can be used with both malli-defn and aave, and a standard fdef -kinda way to annotate existing functions like in spec."><y>#</y><d>2020-10-30</d><h>16:30</h><w>ikitommi</w>the <code>m/defn</code>, currently have a separate <code>malli.schema</code> ns, and few helper ns&apos;s under it. Will have the 1:1 Plumatic Schema <code>m/defn</code> for Malli. Once done, will do the real full malli-&gt;clj-kondo integration, that can be used with both malli-defn and aave, and a standard <code>fdef</code> -kinda way to annotate existing functions like in spec.</z><z id="t1604075463" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] exciting!"><y>#</y><d>2020-10-30</d><h>16:31</h><w>borkdude</w><a>@ikitommi</a> exciting!</z><z id="t1604075567" t="ikitommi might be worth trying to write spec-&gt;malli conversion, so we could reuse all the existing fdef s out there. Also, zillion little things to do :)"><y>#</y><d>2020-10-30</d><h>16:32</h><w>ikitommi</w>might be worth trying to write spec-&gt;malli conversion, so we could reuse all the existing <code>fdef</code>s out there. Also, zillion little things to do :)</z><z id="t1604087747" t="rschmukler [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] once we have that I may take a crack at some nrepl middleware and cider integration. Right now you can spec generate and see spec definitions in documentation lookup in emacs. Only thing I miss from spec."><y>#</y><d>2020-10-30</d><h>19:55</h><w>rschmukler</w><a>@ikitommi</a> once we have that I may take a crack at some nrepl middleware and cider integration. Right now you can spec generate and see spec definitions in documentation lookup in emacs. Only thing I miss from spec.</z><z id="t1604087783" t="rschmukler Re: m/assert - why not? I think it&apos;ll be attractive for some of those migrating from spec"><y>#</y><d>2020-10-30</d><h>19:56</h><w>rschmukler</w>Re: <code>m/assert</code> - why not? I think it&apos;ll be attractive for some of those migrating from spec</z><z id="t1604103849" t="hoppy just for funzies, this warning is coming out of shadow-cljs in a node-js release build. I&apos;ll be happy to chase it if somebody wants me to. Oh, and p.s., malli running on AM335x embedded device, in case somebody is keeping score."><y>#</y><d>2020-10-31</d><h>00:24</h><w>hoppy</w>just for funzies, this warning is coming out of shadow-cljs in a node-js release build.  I&apos;ll be happy to chase it if somebody wants me to.  Oh, and p.s., malli running on AM335x embedded device, in case somebody is keeping score.</z><z id="t1604244391" t="ikitommi [:attrs {:href &quot;/_/_/users/U19EVCEBV&quot;}] https://github.com/metosin/malli/issues/87 help welcome!"><y>#</y><d>2020-11-01</d><h>15:26</h><w>ikitommi</w><a>@hoppy</a> <a href="https://github.com/metosin/malli/issues/87" target="_blank">https://github.com/metosin/malli/issues/87</a> help welcome!</z><z id="t1604255350" t="lmergen is it correct that (at least currently), transforming enums from json does not yet correctly transform them to keywords if necessary ?"><y>#</y><d>2020-11-01</d><h>18:29</h><w>lmergen</w>is it correct that (at least currently), transforming enums from json does not yet correctly transform them to keywords if necessary ?</z><z id="t1604256883" t="borkdude [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] Should enums always be keywords?"><y>#</y><d>2020-11-01</d><h>18:54</h><w>borkdude</w><a>@lmergen</a> Should enums always be keywords?</z><z id="t1604257052" t="lmergen well I wouldn’t say always — but at least I would expect it to convert it if that leads to a valid enum value"><y>#</y><d>2020-11-01</d><h>18:57</h><w>lmergen</w>well I wouldn’t say always — but at least I would expect it to convert it if that leads to a valid enum value</z><z id="t1604257103" t="borkdude right"><y>#</y><d>2020-11-01</d><h>18:58</h><w>borkdude</w>right</z><z id="t1604258168" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] right. There is no type inferrer with enums. They could be anything [:enum 1 &quot;2&quot; :3 &apos;4] . If you know the type, you can hint it: [:and keyword? [:enum :a :b :c]] and they transform correctly"><y>#</y><d>2020-11-01</d><h>19:16</h><w>ikitommi</w><a>@lmergen</a> right. There is no type inferrer with enums. They could be anything <code>[:enum 1 &quot;2&quot; :3 &apos;4]</code>. If you know the type, you can hint it: <code>[:and keyword? [:enum :a :b :c]]</code> and they transform correctly</z><z id="t1604258214" t="lmergen oh that works well enough for now "><y>#</y><d>2020-11-01</d><h>19:16</h><w>lmergen</w>oh that works well enough for now </z><z id="t1604258383" t="ikitommi the generated JSON Schema with :and is bit off, it creates :allOf out of that. Should merge the results instead if there is just one district :type found."><y>#</y><d>2020-11-01</d><h>19:19</h><w>ikitommi</w>the generated JSON Schema with <code>:and</code> is bit off, it creates <code>:allOf</code> out of that. Should merge the results instead if there is just one district <code>:type</code> found.</z><z id="t1604258415" t="ikitommi (correct, but not practical)"><y>#</y><d>2020-11-01</d><h>19:20</h><w>ikitommi</w>(correct, but not practical)</z><z id="t1604316550" t="lmergen is this a valid instant? it can be represented by Instant, but it appears to not be parsable by malli.transform: (pr-str (mt/-string-&gt;date &quot;0000-12-31T23:59:59.999Z&quot;)) =&gt; &quot;0000-12-31T23:59:59.999Z&quot;"><y>#</y><d>2020-11-02</d><h>11:29</h><w>lmergen</w>is this a valid instant? it can be represented by Instant, but it appears to not be parsable by malli.transform:

<pre>(pr-str (mt/-string-&gt;date &quot;0000-12-31T23:59:59.999Z&quot;))
=&gt; &quot;0000-12-31T23:59:59.999Z&quot;</pre></z><z id="t1604316668" t="lmergen 1. Caused by java.time.DateTimeException Invalid value for YearOfEra (valid values 1 - 999999999/1000000000): 0 apparently that&apos;s the issue"><y>#</y><d>2020-11-02</d><h>11:31</h><w>lmergen</w><pre>1. Caused by java.time.DateTimeException
   Invalid value for YearOfEra (valid values 1 -
   999999999/1000000000): 0</pre>
apparently that&apos;s the issue</z><z id="t1604316792" t="lmergen seems like a inconsistency to me to what Instant can represent and DateTime can parse"><y>#</y><d>2020-11-02</d><h>11:33</h><w>lmergen</w>seems like a inconsistency to me to what Instant can represent and DateTime can parse</z><z id="t1604349624" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] inst? should be companioned with set of date-types, the issue is here: https://github.com/metosin/malli/issues/49 . That said, we just merged an enhancement to inst? transformation, happy to take another one, if there is something still missing. See https://github.com/metosin/malli/pull/280"><y>#</y><d>2020-11-02</d><h>20:40</h><w>ikitommi</w><a>@lmergen</a> <code>inst?</code> should be companioned with set of date-types, the issue is here: <a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a>. That said, we just merged an enhancement to  <code>inst?</code> transformation, happy to take another one, if there is something still missing. See <a href="https://github.com/metosin/malli/pull/280" target="_blank">https://github.com/metosin/malli/pull/280</a></z><z id="t1604349677" t="lmergen I’ll take a look, thanks! This is a corner case anyway"><y>#</y><d>2020-11-02</d><h>20:41</h><w>lmergen</w>I’ll take a look, thanks! This is a corner case anyway</z><z id="t1604349742" t="lmergen looks like this may indeed fix my issue as it’s the same instant -&gt; date -&gt; instant round trip, I’ll give it a try "><y>#</y><d>2020-11-02</d><h>20:42</h><w>lmergen</w>looks like this may indeed fix my issue as it’s the same instant -&gt; date -&gt; instant round trip, I’ll give it a try </z><z id="t1604403171" t="Markus Str Hi, I&apos;m getting started with malli and this migh be a noob question, but why is this an invalid schema error? (I took the source of string? in cljs and changed it to str2? Weirdly string? is valid and the alias isn&apos;t (defn ^boolean str2? &quot;Returns true if x is a JavaScript string.&quot; [x] (goog/isString x)) (def Test [:map [:url str2?] [:det map?] ] ) (-&gt; Test (m/explain {:url &quot;sa&quot; :det {:a 5}}) (me/humanize) )"><y>#</y><d>2020-11-03</d><h>11:32</h><w>Markus Str</w>Hi, I&apos;m getting started with malli and this migh be a noob question, but why is this an invalid schema error? (I took the source of <code>string?</code> in cljs and changed it to <code>str2?</code>  Weirdly string? is valid and the alias isn&apos;t
<pre>(defn ^boolean str2?
  &quot;Returns true if x is a JavaScript string.&quot;
  [x]
  (goog/isString x))
(def Test
  [:map
   [:url str2?]
   [:det map?]
   ]
  )

(-&gt; Test
    (m/explain {:url &quot;sa&quot; :det {:a 5}})
    (me/humanize)
    )</pre></z><z id="t1604403284" t="Markus Str Why can&apos;t I define a boolean predicate function there?"><y>#</y><d>2020-11-03</d><h>11:34</h><r>Markus Str</r>Why can&apos;t I define a boolean predicate function there?</z><z id="t1604403675" t="borkdude [:attrs {:href &quot;/_/_/users/US22FPMPX&quot;}] Any reason you&apos;re not using string?"><y>#</y><d>2020-11-03</d><h>11:41</h><r>borkdude</r><a>@US22FPMPX</a> Any reason you&apos;re not using <code>string?</code></z><z id="t1604403841" t="Lucy Wang [:attrs {:href &quot;/_/_/users/US22FPMPX&quot;}] try [:fn str2]"><y>#</y><d>2020-11-03</d><h>11:44</h><r>Lucy Wang</r><a>@US22FPMPX</a> try <code>[:fn str2]</code></z><z id="t1604404309" t="ikitommi the default shemas are listed here: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1223-L1269"><y>#</y><d>2020-11-03</d><h>11:51</h><r>ikitommi</r>the default shemas are listed here: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1223-L1269" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1223-L1269</a></z><z id="t1604404423" t="borkdude FWIW string? on CLJS is: (defn ^boolean string? &quot;Returns true if x is a JavaScript string.&quot; [x] (goog/isString x))"><y>#</y><d>2020-11-03</d><h>11:53</h><r>borkdude</r>FWIW <code>string?</code> on CLJS is:
<pre>(defn ^boolean string?
  &quot;Returns true if x is a JavaScript string.&quot;
  [x]
  (goog/isString x))</pre></z><z id="t1604404434" t="Markus Str thanks for the quick repsonse [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] , str2? was just for figuring out if my function was the issue"><y>#</y><d>2020-11-03</d><h>11:53</h><r>Markus Str</r>thanks for the quick repsonse
<a>@U04V15CAJ</a>, str2? was just for figuring out if my function was the issue</z><z id="t1604404448" t="borkdude ah ok"><y>#</y><d>2020-11-03</d><h>11:54</h><r>borkdude</r>ah ok</z><z id="t1604404453" t="Markus Str [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] thanks that works actually, but error messages are not defined then"><y>#</y><d>2020-11-03</d><h>11:54</h><r>Markus Str</r><a>@UP90Q48J3</a> thanks that works actually, but error messages are not defined then</z><z id="t1604404459" t="Markus Str example: (defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s)) (def Test [:map [:url [:fn twitter-url?]] [:det map?] ] ) (-&gt; Test (m/explain {:url &quot;&quot; :det {:a 5}}) (me/humanize) )"><y>#</y><d>2020-11-03</d><h>11:54</h><r>Markus Str</r>example:
<pre>(defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s))
(def Test
  [:map
   [:url [:fn twitter-url?]]
   [:det map?]
   ]
  )
(-&gt; Test
    (m/explain {:url &quot;&quot; :det {:a 5}})
    (me/humanize)
    )</pre></z><z id="t1604404526" t="Markus Str (-&gt; Test (m/explain {:url &quot;&quot; :det {:a 5}}) (me/humanize) )"><y>#</y><d>2020-11-03</d><h>11:55</h><r>Markus Str</r><pre>(-&gt; Test
    (m/explain {:url &quot;&quot; :det {:a 5}})
    (me/humanize)
    )</pre></z><z id="t1604404532" t="Markus Str {:url [&quot;unknown error&quot;]} then"><y>#</y><d>2020-11-03</d><h>11:55</h><r>Markus Str</r>{:url [&quot;unknown error&quot;]} then</z><z id="t1604404541" t="borkdude [:attrs {:href &quot;/_/_/users/US22FPMPX&quot;}] Have you tried https://github.com/metosin/malli#custom-error-messages ?"><y>#</y><d>2020-11-03</d><h>11:55</h><r>borkdude</r><a>@US22FPMPX</a> Have you tried <a href="https://github.com/metosin/malli#custom-error-messages" target="_blank">https://github.com/metosin/malli#custom-error-messages</a>?</z><z id="t1604404599" t="borkdude Maybe malli expects the function to return a boolean instead of nil? don&apos;t know"><y>#</y><d>2020-11-03</d><h>11:56</h><r>borkdude</r>Maybe malli expects the function to return a boolean instead of nil? don&apos;t know</z><z id="t1604404700" t="Markus Str Thanks for the pointer"><y>#</y><d>2020-11-03</d><h>11:58</h><r>Markus Str</r>Thanks for the pointer</z><z id="t1604404762" t="ikitommi nils should be ok, also regexs: [:map [:x #&quot;http[s]?://twitter.*\d+&quot;] [:y [:fn {:error/message &quot;invalid&quot;} (constantly false)]]"><y>#</y><d>2020-11-03</d><h>11:59</h><r>ikitommi</r>nils should be ok, also regexs:
<pre>[:map
 [:x #&quot;http[s]?://twitter.*\d+&quot;]
 [:y [:fn {:error/message &quot;invalid&quot;} (constantly false)]]</pre></z><z id="t1604405287" t="Markus Str Ah interesting, so regex work, but I can&apos;t have something like: [:x #(re-find #&quot;http[s]?://twitter.*\d+&quot; %)] Probably have to add to the default schema registry then, to have it work naturally like, [:x twitter-url?] I guess?"><y>#</y><d>2020-11-03</d><h>12:08</h><r>Markus Str</r>Ah interesting, so regex work, but I can&apos;t have something like:
<pre>[:x #(re-find #&quot;http[s]?://twitter.*\d+&quot; %)]</pre>
Probably have to add to the default schema registry then, to have it work naturally like, [:x twitter-url?] I guess?</z><z id="t1604405402" t="Markus Str I&apos;m going to read the docs for the third time; seems my mental model is not there yet!"><y>#</y><d>2020-11-03</d><h>12:10</h><r>Markus Str</r>I&apos;m going to read the docs for the third time; seems my mental model is not there yet!</z><z id="t1604405580" t="Markus Str (defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s)) (def -twitter-url? [:fn {:error/message &quot;invalid twitter url&quot;} twitter-url?]) (def Test [:map [:url -twitter-url?] [:det map?] ] ) (-&gt; Test (m/explain {:url &quot;&quot; :det {:a 5}}) (me/humanize) ) So this is how I could do it; only backdraw is that I have two functions now; one for normal use, the other specifically for validation"><y>#</y><d>2020-11-03</d><h>12:13</h><r>Markus Str</r><pre>(defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s))
(def -twitter-url? [:fn {:error/message &quot;invalid twitter url&quot;} twitter-url?])

(def Test
  [:map
   [:url -twitter-url?]
   [:det map?]
   ]
  )
(-&gt; Test
    (m/explain {:url &quot;&quot; :det {:a 5}})
    (me/humanize)
    )</pre>
So this is how I could do it; only backdraw is that I have two functions now; one for normal use, the other specifically for validation</z><z id="t1604405761" t="ikitommi could make the predicate schemas implement IFn , so you could: (def twitter-url? (m/schema [:re {:error/message &quot;invalid twitter url&quot;} #&quot;http[s]?://twitter.*\d+&quot;])) (twitter-url? &quot;&quot;) ; =&gt; true (m/validat twitter-url? &quot;&quot;) ; =&gt; true"><y>#</y><d>2020-11-03</d><h>12:16</h><r>ikitommi</r>could make the predicate schemas implement <code>IFn</code>, so you could:
<pre>(def twitter-url?
  (m/schema 
    [:re {:error/message &quot;invalid twitter url&quot;}
       #&quot;http[s]?://twitter.*\d+&quot;]))

(twitter-url? &quot;&quot;)
; =&gt; true

(m/validat twitter-url? &quot;&quot;)
; =&gt; true</pre></z><z id="t1604406481" t="Markus Str Looks promising. For me personally (and I might be totally off) it could be nice for malli to also accept predicate functions directly inside the spec-vector (defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s)) (def Test [:map [:url twitter-url?] ] ) For now I&apos;ll read up on the registry and how to add it there"><y>#</y><d>2020-11-03</d><h>12:28</h><r>Markus Str</r>Looks promising. For me personally (and I might be totally off) it could be nice for malli to also accept predicate functions directly inside the spec-vector
<pre>(defn twitter-url? [s] (re-find #&quot;http[s]?://twitter.*\d+&quot; s))
(def Test
  [:map
   [:url twitter-url?]
   ]
  )</pre>
For now I&apos;ll read up on the registry and how to add it there</z><z id="t1604406852" t="borkdude What&apos;s the reason it requires [:fn ..] right now [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ?"><y>#</y><d>2020-11-03</d><h>12:34</h><r>borkdude</r>What&apos;s the reason it requires <code>[:fn ..]</code> right now <a>@U055NJ5CC</a>?</z><z id="t1604420463" t="ikitommi could add an option to allow that shortcut (as there is regexs), but in short: it’s too easy to write schemas which do not serialize."><y>#</y><d>2020-11-03</d><h>16:21</h><r>ikitommi</r>could add an option to allow that shortcut (as there is regexs), but in short: it’s too easy to write schemas which do not serialize.</z><z id="t1604420544" t="ikitommi but if one is not looking for serialization, it would be easier for sure."><y>#</y><d>2020-11-03</d><h>16:22</h><r>ikitommi</r>but if one is not looking for serialization, it would be easier for sure.</z><z id="t1604420550" t="borkdude good point. maybe for some people serializing a schema is not important?"><y>#</y><d>2020-11-03</d><h>16:22</h><r>borkdude</r>good point. maybe for some people serializing a schema is not important?</z><z id="t1604420556" t="borkdude jinx"><y>#</y><d>2020-11-03</d><h>16:22</h><r>borkdude</r>jinx</z><z id="t1604420607" t="ikitommi need to revisit these for 1.0.0. but will add optional support for plain functions."><y>#</y><d>2020-11-03</d><h>16:23</h><r>ikitommi</r>need to revisit these for 1.0.0. but will add optional support for plain functions.</z><z id="t1604420679" t="ikitommi also, the default registry being immutable. it’s currently easy to use immutable registries, but hard to get a global mutable registry. both could be easy."><y>#</y><d>2020-11-03</d><h>16:24</h><r>ikitommi</r>also, the default registry being immutable. it’s currently easy to use immutable registries, but hard to get a global mutable registry. both could be easy.</z><z id="t1604420808" t="borkdude Do you think malli will be able to do something like grasp?"><y>#</y><d>2020-11-03</d><h>16:26</h><r>borkdude</r>Do you think malli will be able to do something like grasp?</z><z id="t1604420823" t="borkdude as in, support the things that spec does to match s-expressions"><y>#</y><d>2020-11-03</d><h>16:27</h><r>borkdude</r>as in, support the things that spec does to match s-expressions</z><z id="t1604420861" t="ikitommi I believe so, as soon as there are the sequence schemas."><y>#</y><d>2020-11-03</d><h>16:27</h><r>ikitommi</r>I believe so, as soon as there are the sequence schemas.</z><z id="t1604492012" t="Lucy Wang &gt; good point. maybe for some people serializing a schema is not important? to be frank I think quite some (if not most) people don&apos;t need that ..."><y>#</y><d>2020-11-04</d><h>12:13</h><r>Lucy Wang</r>&gt;  good point. maybe for some people serializing a schema is not important?
to be frank I think quite some (if not most) people don&apos;t need that ...</z><z id="t1604409219" t="lmergen is there something off with generators and the [:and] clause ? (def schema [:and map? [:map [:foo string?]]]) (mg/generate schema) throws an error (&quot;Couldn&apos;t satisfy such-that predicate after 100 tries.&quot;) this, however, works: (def schema [:and [:map [:foo string?]] map?]) (mg/generate schema) my hunch is that it&apos;s unable to &quot;deduce&quot; that it should first try to generate the :map , and starts by generating a completely random map which of course never qualifies the [:map [:foo string?]] schema?"><y>#</y><d>2020-11-03</d><h>13:13</h><w>lmergen</w>is there something off with generators and the <code>[:and]</code>  clause ?

<pre>(def schema [:and map?
             [:map
              [:foo string?]]])

(mg/generate schema)</pre>
throws an error (&quot;Couldn&apos;t satisfy such-that predicate after 100 tries.&quot;)

this, however, works:

<pre>(def schema [:and
             [:map
              [:foo string?]]
             map?])

(mg/generate schema)</pre>
my hunch is that it&apos;s unable to &quot;deduce&quot; that it should first try to generate the <code>:map</code> , and starts by generating a completely random map which of course never qualifies the <code>[:map [:foo string?]]</code> schema?</z><z id="t1604409428" t="ikitommi yes, the order matters"><y>#</y><d>2020-11-03</d><h>13:17</h><w>ikitommi</w>yes, the order matters</z><z id="t1604410275" t="lmergen still seems like there&apos;s something off with :and :thinking_face: (def base [:map [:foo [:enum :a :b]]]) (def x [:and base [:multi {:dispatch :foo} [:a [:map [:i string?]]] [:b [:map [:j pos-int?]]]]]) seems like mg/generate is unable to generate values for this schema as well"><y>#</y><d>2020-11-03</d><h>13:31</h><w>lmergen</w>still seems like there&apos;s something off with <code>:and</code> <b>:thinking_face:</b>

<pre>(def base [:map
           [:foo [:enum :a :b]]])
(def x [:and base
        [:multi {:dispatch :foo}
         [:a [:map [:i string?]]]
         [:b [:map [:j pos-int?]]]]])</pre>
seems like mg/generate is unable to generate values for this schema as well</z><z id="t1604413534" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] (defmethod -schema-generator :and [schema options] (gen/such-that (m/validator schema options) (-&gt; schema (m/children options) first (generator options)) 100))"><y>#</y><d>2020-11-03</d><h>14:25</h><w>ikitommi</w><a>@lmergen</a>
<pre>(defmethod -schema-generator :and [schema options] (gen/such-that (m/validator schema options) (-&gt; schema (m/children options) first (generator options)) 100))</pre></z><z id="t1604413563" t="ikitommi ^:-- the first one is used for the generator."><y>#</y><d>2020-11-03</d><h>14:26</h><w>ikitommi</w>^:-- the first one is used for the generator.</z><z id="t1604413570" t="lmergen aha!"><y>#</y><d>2020-11-03</d><h>14:26</h><w>lmergen</w>aha!</z><z id="t1604413614" t="lmergen but that means there isn&apos;t really a way for me to work around it except writing a custom generator, right ?"><y>#</y><d>2020-11-03</d><h>14:26</h><w>lmergen</w>but that means there isn&apos;t really a way for me to work around it except writing a custom generator, right ?</z><z id="t1604413738" t="lmergen (which is what i just did)"><y>#</y><d>2020-11-03</d><h>14:28</h><w>lmergen</w>(which is what i just did)</z><z id="t1604413760" t="ikitommi you could merge the base schemas, but merge might not work with :multi . but, there are options, like: (mg/generate [:and [:multi {:dispatch :foo} [:a [:merge ::base [:map [:i string?]]]] [:b [:merge ::base [:map [:j pos-int?]]]]]] {:registry (merge (m/default-schemas) (mu/schemas) {::base [:map [:foo [:enum :a :b]]]})})"><y>#</y><d>2020-11-03</d><h>14:29</h><w>ikitommi</w>you could merge the base schemas, but merge might not work with <code>:multi</code>. but, there are options, like:
<pre>(mg/generate
  [:and
   [:multi {:dispatch :foo}
    [:a [:merge ::base [:map [:i string?]]]]
    [:b [:merge ::base [:map [:j pos-int?]]]]]]
  {:registry (merge
               (m/default-schemas)
               (mu/schemas)
               {::base [:map [:foo [:enum :a :b]]]})})</pre></z><z id="t1604413801" t="lmergen i see"><y>#</y><d>2020-11-03</d><h>14:30</h><w>lmergen</w>i see</z><z id="t1604413896" t="ikitommi merge doesn’t work with :multi currently, this would be best way to do it (if it worked): (mu/merge [:map [:foo [:enum :a :b]]] [:multi {:dispatch :foo} [:a [:map [:i string?]]] [:b [:map [:j pos-int?]]]]) ;[:multi {:dispatch :foo} ; [:a [:map [:i string?]]] ; [:b [:map [:j pos-int?]]]]"><y>#</y><d>2020-11-03</d><h>14:31</h><w>ikitommi</w>merge doesn’t work with <code>:multi</code> currently, this would be best way to do it (if it worked):
<pre>(mu/merge
  [:map [:foo [:enum :a :b]]]
  [:multi {:dispatch :foo}
   [:a [:map [:i string?]]]
   [:b [:map [:j pos-int?]]]])
;[:multi {:dispatch :foo}
; [:a [:map [:i string?]]]
; [:b [:map [:j pos-int?]]]]</pre></z><z id="t1604413926" t="lmergen i just wrote a helper function which just does this: (defn merged &quot;Given a list of generators, returns a generator that applies `merge` to all the generator results.&quot; [&amp; gens] (gen/fmap (fn [args] (reduce merge {} args)) (apply gen/tuple gens))) (def schema [:and {:gen/gen (merged (mg/geneator a) (mg/generator b)} a b]) "><y>#</y><d>2020-11-03</d><h>14:32</h><w>lmergen</w>i just wrote a helper function which just does this:

<pre>(defn merged
  &quot;Given a list of generators, returns a generator that applies `merge`
  to all the generator results.&quot;
  [&amp; gens]
  (gen/fmap (fn [args]
              (reduce merge {} args))
            (apply gen/tuple gens)))

(def schema [:and {:gen/gen (merged (mg/geneator a) (mg/generator b)} a b])</pre>
</z><z id="t1604413931" t="ikitommi :multi should do type-inferring, so that all map-like :multi s act like a map."><y>#</y><d>2020-11-03</d><h>14:32</h><w>ikitommi</w><code>:multi</code> should do type-inferring, so that all map-like <code>:multi</code>s act like a map.</z><z id="t1604413938" t="lmergen yes"><y>#</y><d>2020-11-03</d><h>14:32</h><w>lmergen</w>yes</z><z id="t1604413943" t="lmergen that&apos;s what i was going to say"><y>#</y><d>2020-11-03</d><h>14:32</h><w>lmergen</w>that&apos;s what i was going to say</z><z id="t1604413951" t="lmergen :multi is pretty much always a map anyway"><y>#</y><d>2020-11-03</d><h>14:32</h><w>lmergen</w><code>:multi</code> is pretty much always a map anyway</z><z id="t1604414051" t="ikitommi unless it’s a tuple / sequence: (m/validate [:multi {:dispatch &apos;first} [:sized [:tuple keyword? [:map [:size int?]]]] [:human [:tuple keyword? [:map [:name string?] [:address [:map [:country keyword?]]]]]]] [:human {:name &quot;seppo&quot;, :address {:country :sweden}}]) ; true"><y>#</y><d>2020-11-03</d><h>14:34</h><w>ikitommi</w>unless it’s a tuple / sequence:
<pre>(m/validate
  [:multi {:dispatch &apos;first}
   [:sized [:tuple keyword? [:map [:size int?]]]]
   [:human [:tuple keyword? [:map [:name string?] [:address [:map [:country keyword?]]]]]]]
  [:human {:name &quot;seppo&quot;, :address {:country :sweden}}])
; true</pre></z><z id="t1604414070" t="lmergen right"><y>#</y><d>2020-11-03</d><h>14:34</h><w>lmergen</w>right</z><z id="t1604414104" t="ikitommi but, it’s easy to figure out if it looks like a map and could be merged."><y>#</y><d>2020-11-03</d><h>14:35</h><w>ikitommi</w>but, it’s easy to figure out if it looks like a map and could be merged.</z><z id="t1604430130" t="Maciej Falski Hi, I’ve just started with malli , and I’m spiking converting our spec definitions to malli-based. Among others, we’ve defined specs with generators and json decoding for java-time (aka java8) types , like instant , duration , and interval . It’s easy with spec-tools . Now I’m trying to do the same with malli and this is what I came up with: (def Instant (m/-simple-schema {:pred t/instant? :type-properties {:error/message &quot;should be an instant&quot; :decode/json t/instant :encode/json str :gen/gen (gen/fmap (fn [[d h m s]] (t/plus (t/instant) (t/days d) (t/hours h) (t/minutes m) (t/seconds s))) (gen/tuple gen/int gen/int gen/int gen/int))}})) Does it makes sense? Would there be a better way? I’m aware of this https://github.com/metosin/malli/issues/49 , but it’s still open."><y>#</y><d>2020-11-03</d><h>19:02</h><w>Maciej Falski</w>Hi, I’ve just started with <code>malli</code>, and I’m spiking converting our <code>spec</code> definitions to malli-based. Among others, we’ve defined specs with generators and json decoding for <code>java-time</code> (aka java8) types , like <code>instant</code>, <code>duration</code> , and <code>interval</code>. It’s easy with <code>spec-tools</code>. Now I’m trying to do the same with <code>malli</code> and this is what I came up with:
<pre>(def Instant
  (m/-simple-schema
    {:pred            t/instant?
     :type-properties {:error/message &quot;should be an instant&quot;
                       :decode/json   t/instant
                       :encode/json   str
                       :gen/gen       (gen/fmap (fn [[d h m s]] (t/plus (t/instant) (t/days d) (t/hours h) (t/minutes m) (t/seconds s)))
                                                (gen/tuple gen/int gen/int gen/int gen/int))}}))</pre>
Does it makes sense? Would there be a better way? I’m aware of this <a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a>, but it’s still open.</z><z id="t1604470425" t="ikitommi [:attrs {:href &quot;/_/_/users/U018FH8HU6A&quot;}] looks good! few small things: • if you want to support also string-&gt;edn &amp; edn-&gt;string, you should add :decode/string and :encode/string keys. Needed if you use the dates in header/path/yaml/query-params • you could add :type key, .e.g. &apos;Instant so that the schema forms render correctly • with :type , you could also add the new schmas into registry and they are available for de/serialization too."><y>#</y><d>2020-11-04</d><h>06:13</h><w>ikitommi</w><a>@maciej.falski</a> looks good! few small things:
• if you want to support also string-&gt;edn &amp; edn-&gt;string, you should add <code>:decode/string</code> and <code>:encode/string</code> keys. Needed if you use the dates in header/path/yaml/query-params
• you could add <code>:type</code> key, .e.g. <code>&apos;Instant</code> so that the schema forms render correctly
• with <code>:type</code>,  you could also add the new schmas into registry and they are available for de/serialization too.</z><z id="t1604470600" t="ikitommi oh, and &apos;going to talk about mallin in London Clojurians in 8.12. https://www.meetup.com/London-Clojurians/events/274367598/"><y>#</y><d>2020-11-04</d><h>06:16</h><w>ikitommi</w>oh, and &apos;going to talk about mallin in London Clojurians in 8.12. <a href="https://www.meetup.com/London-Clojurians/events/274367598/" target="_blank">https://www.meetup.com/London-Clojurians/events/274367598/</a></z><z id="t1604566273" t="ikitommi back to function schemas. basics kinda work without varargs, as it requires sequence schemas. todo: emit clj-kondo annotations for real."><y>#</y><d>2020-11-05</d><h>08:51</h><w>ikitommi</w>back to function schemas. basics kinda work without varargs, as it requires sequence schemas. todo: emit clj-kondo annotations for real.</z><z id="t1604566328" t="ikitommi"><y>#</y><d>2020-11-05</d><h>08:52</h><w>ikitommi</w></z><z id="t1604566458" t="ikitommi also todo: pretty errors, e.g. https://github.com/metosin/virhe"><y>#</y><d>2020-11-05</d><h>08:54</h><w>ikitommi</w>also todo: pretty errors, e.g. <a href="https://github.com/metosin/virhe" target="_blank">https://github.com/metosin/virhe</a></z><z id="t1604904423" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] tested the malli + edamame with location preserving metadata. Few notes: • current impl of transform is not aware of the path where the transformation happens. If it did, the solution would be almost trivial • good thing is that we have other tools to go around the limitation: we can walk the schema and inject :in to all subschema properties and use :compile in a transformer to read this info at decoder creation time and to collect all value path -&gt; loc into a request-scoped atom as we decode the Wrapped values • transformers compose, so we can also do string-&gt;edn etc in a single sweep • for the transformed value, we call explain and in case of errors, attach the loc s from the atom, as explain errors know already both schema and value paths • solution has lot of boilerplate, and found a :set explain bug (wrote https://github.com/metosin/malli/issues/294 ), with that, this could even work 😎 • https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3"><y>#</y><d>2020-11-09</d><h>06:47</h><w>ikitommi</w><a>@borkdude</a> tested the malli + edamame with location preserving metadata. Few notes:
• current impl of <code>transform</code> is not aware of the path where the transformation happens. If it did, the solution would be almost trivial
• good thing is that we have other tools to go around the limitation: we can walk the schema and inject <code>:in</code> to all subschema properties and use <code>:compile</code> in a transformer to read this info at decoder creation time and to collect all <code>value path</code> -&gt; <code>loc</code> into a request-scoped atom as we decode the <code>Wrapped</code> values
• transformers compose, so we can also do <code>string-&gt;edn</code> etc in a single sweep
• for the transformed value,  we call <code>explain</code> and in case of errors, attach the <code>loc</code>s from the atom, as <code>explain</code> errors know already both schema and value paths
• solution has lot of boilerplate, and found a <code>:set</code> explain bug (wrote <a href="https://github.com/metosin/malli/issues/294" target="_blank">https://github.com/metosin/malli/issues/294</a> ), with that, this could even work <b>😎</b> 
• <a href="https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3" target="_blank">https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3</a></z><z id="t1604904507" t="ikitommi good thing about using a lookup-table is that it doesn’t need to throw and reports all errors."><y>#</y><d>2020-11-09</d><h>06:48</h><w>ikitommi</w>good thing about using a lookup-table is that it doesn’t need to throw and reports all errors.</z><z id="t1604904715" t="ikitommi also, if edamame could accumulate and provide the full path to a given element in :postprocess , it could be used here too, e.g. extra key + value in Wrapped like :in [:tags &quot;address&quot;] ."><y>#</y><d>2020-11-09</d><h>06:51</h><w>ikitommi</w>also, if edamame could accumulate and provide the full path to a given element in <code>:postprocess</code>, it could be used here too, e.g. extra key + value in Wrapped like <code>:in [:tags &quot;address&quot;]</code>.</z><z id="t1604904819" t="ikitommi (def Address [:map [:id string?] [:tags [:set keyword?]] [:address [:map [:street string?] [:city string?] [:zip int?] [:lonlat [:tuple double? double?]]]]]) ;; string-&gt;edn, no coercion (let [coerce (coercer Address)] (coerce (slurp &quot;schema.edn&quot;))) ;{:schema [:map ; [:id string?] ; [:tags [:set keyword?]] ; [:address ; [:map ; [:street string?] ; [:city string?] ; [:zip int?] ; [:lonlat [:tuple double? double?]]]]], ; :value {:id &quot;Lillan&quot;, ; :tags #{&quot;:hotel&quot; :coffee :artesan}, ; :address {:lonlat [61.4858322 23.7854658], ; :city &quot;Tampere&quot;, ; :street &quot;Ahlmanintie 29&quot;, ; :zip &quot;33100&quot;}}, ; :errors (#Error{:path [:tags 0], ; :in [:tags 0], ;; &lt;--- the set value paths are incorrect #294 ; :schema keyword?, ; :value &quot;:hotel&quot;, ; :loc {:row 2, :col 10, :end-row 2, :end-col 18}} ; #Error{:path [:address :zip], ; :in [:address :zip], ; :schema int?, ; :value &quot;33100&quot;, ; :loc {:row 5, :col 17, :end-row 5, :end-col 24}}) ; :string &quot;{:id \&quot;Lillan\&quot; ; :tags #{:artesan :coffee \&quot;:hotel\&quot;} ; :address {:street \&quot;Ahlmanintie 29\&quot; ; :city \&quot;Tampere\&quot; ; :zip \&quot;33100\&quot; ; :lonlat [61.4858322, 23.7854658]}} ; &quot;} ;; string-&gt;edn, with malli string-coercion (let [coerce (coercer Address (mt/string-transformer))] (coerce (slurp &quot;schema.edn&quot;))) ; =&gt; nil"><y>#</y><d>2020-11-09</d><h>06:53</h><w>ikitommi</w><pre>(def Address
  [:map
   [:id string?]
   [:tags [:set keyword?]]
   [:address
    [:map
     [:street string?]
     [:city string?]
     [:zip int?]
     [:lonlat [:tuple double? double?]]]]])

;; string-&gt;edn, no coercion
(let [coerce (coercer Address)]
  (coerce (slurp &quot;schema.edn&quot;)))
;{:schema [:map
;          [:id string?]
;          [:tags [:set keyword?]]
;          [:address
;           [:map
;            [:street string?]
;            [:city string?]
;            [:zip int?]
;            [:lonlat [:tuple double? double?]]]]],
; :value {:id &quot;Lillan&quot;,
;         :tags #{&quot;:hotel&quot; :coffee :artesan},
;         :address {:lonlat [61.4858322 23.7854658],
;                   :city &quot;Tampere&quot;,
;                   :street &quot;Ahlmanintie 29&quot;,
;                   :zip &quot;33100&quot;}},
; :errors (#Error{:path [:tags 0], 
;                 :in [:tags 0], ;; &lt;--- the set value paths are incorrect #294
;                 :schema keyword?,
;                 :value &quot;:hotel&quot;,
;                 :loc {:row 2, :col 10, :end-row 2, :end-col 18}}
;           #Error{:path [:address :zip],
;                  :in [:address :zip],
;                  :schema int?,
;                  :value &quot;33100&quot;,
;                  :loc {:row 5, :col 17, :end-row 5, :end-col 24}})
; :string &quot;{:id \&quot;Lillan\&quot;
;           :tags #{:artesan :coffee \&quot;:hotel\&quot;}
;           :address {:street \&quot;Ahlmanintie 29\&quot;
;                     :city \&quot;Tampere\&quot;
;                     :zip \&quot;33100\&quot;
;                     :lonlat [61.4858322, 23.7854658]}}
;          &quot;}

;; string-&gt;edn, with malli string-coercion
(let [coerce (coercer Address (mt/string-transformer))]
  (coerce (slurp &quot;schema.edn&quot;)))
; =&gt; nil</pre></z><z id="t1604930537" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] #294 is fixed in master and the edamame-walking works now and is bit simpler: 1. parse with edamame 2. prewalk twice to get both the original EDN and the path-vec -&gt; loc lookup table 3. glue things together 4. kudos to [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] for a working walker 5. https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3"><y>#</y><d>2020-11-09</d><h>14:02</h><w>ikitommi</w><a>@borkdude</a> #294 is fixed in master and the edamame-walking works now and is bit simpler:
1. parse with edamame
2. prewalk twice to get both the original EDN and the path-vec -&gt; loc lookup table
3. glue things together
4. kudos to <a>@nilern</a> for a working walker
5. <a href="https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3" target="_blank">https://gist.github.com/ikitommi/e3229a0bcef532d1fa032321713227d3</a></z><z id="t1604930585" t="ikitommi"><y>#</y><d>2020-11-09</d><h>14:03</h><w>ikitommi</w></z><z id="t1604930721" t="ikitommi it automatically binds a transformer named :edamame , so you can add custom decoding hints to schemas: [:string {:decode/edamame str/upper-case}] … and if sci is enabled, the schemas can be read from files too."><y>#</y><d>2020-11-09</d><h>14:05</h><w>ikitommi</w>it automatically binds a transformer named <code>:edamame</code>, so you can add custom decoding hints to schemas:
<pre>[:string {:decode/edamame str/upper-case}]</pre>
… and if sci is enabled, the schemas can be read from files too.</z><z id="t1604947994" t="lmergen i have a particularly complex schema where the initialization of e.g. (m/validator) or (m/transformer) is fairly slow -- about 300ms. one way to deal with this would be to cache these -- is my understanding correct that using a registry will effectively do this ? or will i need to write my own caching layer on top of it ?"><y>#</y><d>2020-11-09</d><h>18:53</h><w>lmergen</w>i have a particularly complex schema where the initialization of e.g. <code>(m/validator)</code> or <code>(m/transformer)</code> is fairly slow -- about 300ms. one way to deal with this would be to cache these -- is my understanding correct that using a registry will effectively do this ? or will i need to write my own caching layer on top of it ?</z><z id="t1604948063" t="lmergen or are registries just a very simple way of organizing stuff, without any pre-parsing going on ?"><y>#</y><d>2020-11-09</d><h>18:54</h><w>lmergen</w>or are registries just a very simple way of organizing stuff, without any pre-parsing going on ?</z><z id="t1604948983" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] the schema creation will get a 10x boost soon, the slow part being m/schema . If you add Schema instances into registry, it happends just once. Or you can just use a var: (def Address (m/schema [:map [:street :string]]))"><y>#</y><d>2020-11-09</d><h>19:09</h><w>ikitommi</w><a>@lmergen</a> the schema creation will get a 10x boost soon, the slow part being <code>m/schema</code>. If you add Schema instances into registry, it happends just once. Or you can just use a var:
<pre>(def Address (m/schema [:map [:street :string]]))</pre></z><z id="t1604949034" t="ikitommi … but, for super fast validation, you should just create the m/validator once and reuse that. it returns a pure and optimized function."><y>#</y><d>2020-11-09</d><h>19:10</h><w>ikitommi</w>… but, for super fast validation, you should just create the <code>m/validator</code> once and reuse that. it returns a pure and optimized function.</z><z id="t1604949145" t="lmergen right, I think I’ll just go for that last option. fairly often various of these validators are used in hot code paths, so I’ll probably write something to cache validators instead. "><y>#</y><d>2020-11-09</d><h>19:12</h><w>lmergen</w>right, I think I’ll just go for that last option. fairly often various of these validators are used in hot code paths, so I’ll probably write something to cache validators instead. </z><z id="t1604949232" t="lmergen but if I wrap things in an m/schema call, it’ll already do a lot of preprocessing, right?"><y>#</y><d>2020-11-09</d><h>19:13</h><w>lmergen</w>but if I wrap things in an m/schema call, it’ll already do a lot of preprocessing, right?</z><z id="t1604949344" t="ikitommi right. I’ll run some flamegraphs. just a sec."><y>#</y><d>2020-11-09</d><h>19:15</h><w>ikitommi</w>right. I’ll run some flamegraphs. just a sec.</z><z id="t1604949870" t="ikitommi (time (prof/profile (dotimes [_ 50000] (m/validate [:map [:street :string]] {:street &quot;hämeenkatu&quot;})))) ;; &quot;Elapsed time: 10472.153783 msecs&quot; (let [schema (m/schema [:map [:street :string]])] (time (prof/profile (dotimes [_ 500000] (m/validate schema {:street &quot;hämeenkatu&quot;}))))) ;; &quot;Elapsed time: 231.093848 msecs&quot; (let [validate (m/validator [:map [:street :string]])] (time (prof/profile (dotimes [_ 500000] (validate {:street &quot;hämeenkatu&quot;}))))) ;; &quot;Elapsed time: 59.743646 msecs&quot;"><y>#</y><d>2020-11-09</d><h>19:24</h><w>ikitommi</w><pre>(time
  (prof/profile
    (dotimes [_ 50000]
      (m/validate [:map [:street :string]] {:street &quot;hämeenkatu&quot;}))))
;; &quot;Elapsed time: 10472.153783 msecs&quot;

(let [schema (m/schema [:map [:street :string]])]
  (time
    (prof/profile
      (dotimes [_ 500000]
        (m/validate schema {:street &quot;hämeenkatu&quot;})))))
;; &quot;Elapsed time: 231.093848 msecs&quot;

(let [validate (m/validator [:map [:street :string]])]
  (time
    (prof/profile
      (dotimes [_ 500000]
        (validate {:street &quot;hämeenkatu&quot;})))))
;; &quot;Elapsed time: 59.743646 msecs&quot;</pre></z><z id="t1605290538" t="hoynk May I ask what profile lib you are using?"><y>#</y><d>2020-11-13</d><h>18:02</h><r>hoynk</r>May I ask what profile lib you are using?</z><z id="t1605291680" t="ikitommi mostly https://github.com/clojure-goes-fast/clj-async-profiler g https://github.com/hugoduncan/criterium"><y>#</y><d>2020-11-13</d><h>18:21</h><r>ikitommi</r>mostly <a href="https://github.com/clojure-goes-fast/clj-async-profiler" target="_blank">https://github.com/clojure-goes-fast/clj-async-profiler</a> g <a href="https://github.com/hugoduncan/criterium" target="_blank">https://github.com/hugoduncan/criterium</a></z><z id="t1605293459" t="hoynk thx"><y>#</y><d>2020-11-13</d><h>18:50</h><r>hoynk</r>thx</z><z id="t1604949906" t="lmergen right, this makes a lot of sense. "><y>#</y><d>2020-11-09</d><h>19:25</h><w>lmergen</w>right, this makes a lot of sense. </z><z id="t1604949951" t="ikitommi"><y>#</y><d>2020-11-09</d><h>19:25</h><w>ikitommi</w></z><z id="t1604950015" t="ikitommi m/schema uses satisfies? which has a perf issue, most of the time spent there."><y>#</y><d>2020-11-09</d><h>19:26</h><w>ikitommi</w><code>m/schema</code> uses <code>satisfies?</code> which has a perf issue, most of the time spent there.</z><z id="t1604950210" t="ikitommi or was it two orders of magnitude? satisfies? seems to take at least 95% of the time."><y>#</y><d>2020-11-09</d><h>19:30</h><w>ikitommi</w>or was it two orders of magnitude? <code>satisfies?</code> seems to take at least 95% of the time.</z><z id="t1604950220" t="ikitommi"><y>#</y><d>2020-11-09</d><h>19:30</h><w>ikitommi</w></z><z id="t1604950660" t="lmergen ok, this is very helpful"><y>#</y><d>2020-11-09</d><h>19:37</h><w>lmergen</w>ok, this is very helpful</z><z id="t1604950909" t="lmergen I really do find the validators to be significantly faster than spec validate — it’s about 3x faster for my fairly insane schema (the same that takes 300ms to parse). better yet, and this was unexpected: the generators are also much faster. I’m not 100% certain yet because whether this is because maybe Malli takes some shortcuts, but i seem to be able to avoid a few annoying gen/such-that? generators with Malli that causes a very large speed up. "><y>#</y><d>2020-11-09</d><h>19:41</h><w>lmergen</w>I really do find the validators to be significantly faster than spec validate — it’s about 3x faster for my fairly insane schema (the same that takes 300ms to parse). 

better yet, and this was unexpected: the generators are also much faster. I’m not 100% certain yet because whether this is because maybe Malli takes some shortcuts, but i seem to be able to avoid a few annoying gen/such-that? generators with Malli that causes a very large speed up. </z><z id="t1605000093" t="ikitommi this is interesting. tried to avoid such-that? , e.g. setting min &amp; max when known, but have not tested against spec gen."><y>#</y><d>2020-11-10</d><h>09:21</h><r>ikitommi</r>this is interesting. tried to avoid <code>such-that?</code>, e.g. setting min &amp; max when known,  but have not tested against spec gen.</z><z id="t1604958227" t="ikitommi new flames with cache"><y>#</y><d>2020-11-09</d><h>21:43</h><w>ikitommi</w>new flames with cache</z><z id="t1604958304" t="ikitommi 10472ms =&gt; 568ms (18x faster)"><y>#</y><d>2020-11-09</d><h>21:45</h><w>ikitommi</w><pre>10472ms =&gt; 568ms (18x faster)</pre></z><z id="t1604992734" t="lmergen [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] for what it&apos;s worth, i still got a huge performance increase by actually caching the validators as well. (crit/with-progress-reporting (crit/quick-bench (m/validate schema value))) ;; =&gt; Execution time mean : 297.880813 ms (def schema&apos; (m/schema schema)) (crit/with-progress-reporting (crit/quick-bench (m/validate schema&apos; value))) ;; =&gt; Execution time mean : 533.885193 µs (def validator (m/validator schema)) (crit/with-progress-reporting (crit/quick-bench (validator value))) ;; =&gt; Execution time mean : 1.830348 µs so it looks like about a 500x improvement by caching schemas, and then another 300x improvement by caching the validators"><y>#</y><d>2020-11-10</d><h>07:18</h><w>lmergen</w><a>@ikitommi</a> for what it&apos;s worth, i still got a huge performance increase by actually caching the validators as well.

<pre>(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema value)))
;; =&gt; Execution time mean : 297.880813 ms

(def schema&apos; (m/schema schema))
(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema&apos; value)))
;; =&gt; Execution time mean : 533.885193 µs

(def validator (m/validator schema))
(crit/with-progress-reporting
  (crit/quick-bench (validator value)))
;; =&gt; Execution time mean : 1.830348 µs</pre>
so it looks like about a 500x improvement by caching schemas, and then another 300x improvement by caching the validators</z><z id="t1604992885" t="lmergen i suspect in your specific benchmark, the schema is fairly simple so then a larger share of the benchmark is actually about performing the validation"><y>#</y><d>2020-11-10</d><h>07:21</h><w>lmergen</w>i suspect in your specific benchmark, the schema is fairly simple so then a larger share of the benchmark is actually about performing the validation</z><z id="t1604999937" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] there was a cljs-issue, just merged the cached satisfies. could you retry with the latest master?"><y>#</y><d>2020-11-10</d><h>09:18</h><w>ikitommi</w><a>@lmergen</a> there was a cljs-issue, just merged the cached satisfies. could you retry with the latest master?</z><z id="t1604999952" t="lmergen sure!"><y>#</y><d>2020-11-10</d><h>09:19</h><w>lmergen</w>sure!</z><z id="t1604999969" t="lmergen 1 minute"><y>#</y><d>2020-11-10</d><h>09:19</h><w>lmergen</w>1 minute</z><z id="t1605000040" t="ikitommi there is still a lot of room for improvement for maps (`-parse-entries` is really slow) and for handling property-based registries. I would guess can make schema creation 2-5 times faster. But then again, after malli is used to validate schema properties &amp; children, it will slow things down again."><y>#</y><d>2020-11-10</d><h>09:20</h><w>ikitommi</w>there is still a lot of room for improvement for maps (`-parse-entries` is really slow) and for handling property-based registries. I would guess can make schema creation 2-5 times faster. But then again, after malli is used to validate schema properties &amp; children, it will slow things down again.</z><z id="t1605000575" t="lmergen (crit/with-progress-reporting (crit/quick-bench (m/validate schema value))) ;; before: =&gt; Execution time mean : 297.880813 ms ;; after: =&gt; Execution time mean : 12.194964 ms (def schema&apos; (m/schema schema)) (crit/with-progress-reporting (crit/quick-bench (m/validate schema&apos; value))) ;; before: =&gt; Execution time mean : 533.885193 µs ;; after: =&gt; Execution time mean : 517.890217 µs (def validator (m/validator schema)) (crit/with-progress-reporting (crit/quick-bench (validator value))) ;; before: =&gt; Execution time mean : 1.830348 µs ;; after: =&gt; Execution time mean : 1.952607 µs so while m/validate got ~ 20x faster, caching the actual validator is still much, much faster"><y>#</y><d>2020-11-10</d><h>09:29</h><w>lmergen</w><pre>(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema value)))
;; before: =&gt; Execution time mean : 297.880813 ms
;; after:  =&gt; Execution time mean : 12.194964 ms

(def schema&apos; (m/schema schema))
(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema&apos; value)))
;; before: =&gt; Execution time mean : 533.885193 µs
;; after:  =&gt; Execution time mean : 517.890217 µs


(def validator (m/validator schema))
(crit/with-progress-reporting
  (crit/quick-bench (validator value)))
;; before: =&gt; Execution time mean : 1.830348 µs
;; after:  =&gt; Execution time mean : 1.952607 µs</pre>

so while <code>m/validate</code> got ~ 20x faster, caching the actual validator is still much, much faster</z><z id="t1605001209" t="lmergen i&apos;m caching the explainers in my own defn macro, but it requires quite a bit of macro magic to make this work, so i was looking for a more generic way to make this happen -- possibly some kind of registry"><y>#</y><d>2020-11-10</d><h>09:40</h><w>lmergen</w>i&apos;m caching the explainers in my own <code>defn</code> macro, but it requires quite a bit of macro magic to make this work, so i was looking for a more generic way to make this happen -- possibly some kind of registry</z><z id="t1605001430" t="ikitommi what should be in the registry? validator + explainer + generator + decoder(s) + encoder(s) + …?"><y>#</y><d>2020-11-10</d><h>09:43</h><w>ikitommi</w>what should be in the registry? validator + explainer + generator + decoder(s) + encoder(s) + …?</z><z id="t1605001458" t="lmergen if possible, i&apos;d say all of them yes"><y>#</y><d>2020-11-10</d><h>09:44</h><w>lmergen</w>if possible, i&apos;d say all of them yes</z><z id="t1605001463" t="ikitommi in reitit, there is a Coercion protocol to cache things relevant there: https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc"><y>#</y><d>2020-11-10</d><h>09:44</h><w>ikitommi</w>in reitit, there is a <code>Coercion</code> protocol to cache things relevant there: <a href="https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc" target="_blank">https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/coercion/malli.cljc</a></z><z id="t1605001520" t="lmergen right, so then you lazily cache things"><y>#</y><d>2020-11-10</d><h>09:45</h><w>lmergen</w>right, so then you lazily cache things</z><z id="t1605001531" t="lmergen which would be the best middle-ground"><y>#</y><d>2020-11-10</d><h>09:45</h><w>lmergen</w>which would be the best middle-ground</z><z id="t1605001620" t="ikitommi one would be to add a wrapper Schema impl, that is returned from registry instead of the real one. And that impl would have a cache -&gt; first call to -validate would store the validator."><y>#</y><d>2020-11-10</d><h>09:47</h><w>ikitommi</w>one would be to add a wrapper <code>Schema</code> impl, that is returned from registry instead of the real one. And that impl would have a cache -&gt; first call to <code>-validate</code> would store the validator.</z><z id="t1605001650" t="lmergen oh i see"><y>#</y><d>2020-11-10</d><h>09:47</h><w>lmergen</w>oh i see</z><z id="t1605001650" t="ikitommi could be just an option to the registry to return caching proxys instead of normal ones…"><y>#</y><d>2020-11-10</d><h>09:47</h><w>ikitommi</w>could be just an option to the registry to return caching proxys instead of normal ones…</z><z id="t1605001661" t="lmergen yes"><y>#</y><d>2020-11-10</d><h>09:47</h><w>lmergen</w>yes</z><z id="t1605001665" t="lmergen this would be very effective"><y>#</y><d>2020-11-10</d><h>09:47</h><w>lmergen</w>this would be very effective</z><z id="t1605001700" t="lmergen i&apos;ll experiment with this approach"><y>#</y><d>2020-11-10</d><h>09:48</h><w>lmergen</w>i&apos;ll experiment with this approach</z><z id="t1605001815" t="ikitommi … actually, just a new option key that m/schema uses would do fine (to wrap the returned thing if the option is present)"><y>#</y><d>2020-11-10</d><h>09:50</h><w>ikitommi</w>… actually, just a new option key that <code>m/schema</code> uses would do fine (to wrap the returned thing if the option is present)</z><z id="t1605002534" t="lmergen so then you cache it inside the actual schema, rather than a wrapper around it ?"><y>#</y><d>2020-11-10</d><h>10:02</h><w>lmergen</w>so then you cache it inside the actual schema, rather than a wrapper around it ?</z><z id="t1605002769" t="ikitommi I would wrap it outside, e.g. the return value wrapped"><y>#</y><d>2020-11-10</d><h>10:06</h><w>ikitommi</w>I would wrap it outside, e.g. the return value wrapped</z><z id="t1605002807" t="lmergen ah, right -- and the option to m/schema would then tell it whether to return the wrapped schema or the &quot;regular&quot; schema"><y>#</y><d>2020-11-10</d><h>10:06</h><w>lmergen</w>ah, right -- and the option to <code>m/schema</code> would then tell it whether to return the wrapped schema or the &quot;regular&quot; schema</z><z id="t1605002941" t="ikitommi yes. Or there could be a memoized-schema etc. as a separate fn? (-&gt; :string m/schema m/memoized)"><y>#</y><d>2020-11-10</d><h>10:09</h><w>ikitommi</w>yes. Or there could be a <code>memoized-schema</code> etc. as a separate fn? <code>(-&gt; :string m/schema m/memoized)</code></z><z id="t1605002952" t="lmergen yes"><y>#</y><d>2020-11-10</d><h>10:09</h><w>lmergen</w>yes</z><z id="t1605002958" t="lmergen well that&apos;s a detail"><y>#</y><d>2020-11-10</d><h>10:09</h><w>lmergen</w>well that&apos;s a detail</z><z id="t1605002978" t="lmergen let me experiment with creating that memoized / cached schema in the first place"><y>#</y><d>2020-11-10</d><h>10:09</h><w>lmergen</w>let me experiment with creating that memoized / cached schema in the first place</z><z id="t1605027149" t="lmergen (crit/with-progress-reporting (crit/quick-bench (m/validate schema value))) ;; =&gt; Execution time mean : 11.782073 ms (def schema&apos; (memoized-schema (m/schema schema))) (crit/with-progress-reporting (crit/quick-bench (m/validate schema&apos; value))) ;; =&gt; Execution time mean : 2.095245 µs [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] conceptually it seems to be working like a charm"><y>#</y><d>2020-11-10</d><h>16:52</h><w>lmergen</w><pre>(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema value)))
;; =&gt; Execution time mean : 11.782073 ms

(def schema&apos; (memoized-schema (m/schema schema)))
(crit/with-progress-reporting
  (crit/quick-bench (m/validate schema&apos; value)))
;; =&gt; Execution time mean : 2.095245 µs</pre>
<a>@ikitommi</a> conceptually it seems to be working like a charm</z><z id="t1605027343" t="lmergen exactly which schema am i supposed to wrap here -- it&apos;s just the regular malli.core/Schema, right ? the into-schema is meant more for building a hierarchy of parent/child schemas ?"><y>#</y><d>2020-11-10</d><h>16:55</h><w>lmergen</w>exactly which schema am i supposed to wrap here -- it&apos;s just the regular malli.core/Schema, right ? the into-schema is meant more for building a hierarchy of parent/child schemas ?</z><z id="t1605027428" t="ikitommi yes Schema . IntoSchema is the factory-protocol for creating a Schema out of the Schema AST, each Schema is responsible for it’s own props &amp; children."><y>#</y><d>2020-11-10</d><h>16:57</h><w>ikitommi</w>yes <code>Schema</code>.  <code>IntoSchema</code> is the factory-protocol for creating a <code>Schema</code> out of the Schema AST, each Schema is responsible for it’s own props &amp; children.</z><z id="t1605027435" t="lmergen right"><y>#</y><d>2020-11-10</d><h>16:57</h><w>lmergen</w>right</z><z id="t1605027437" t="lmergen awesome"><y>#</y><d>2020-11-10</d><h>16:57</h><w>lmergen</w>awesome</z><z id="t1605027455" t="lmergen i&apos;ll send a PR once i have all the functions working"><y>#</y><d>2020-11-10</d><h>16:57</h><w>lmergen</w>i&apos;ll send a PR once i have all the functions working</z><z id="t1605110075" t="Maciej Falski Hey, I think I found a bug while trying to get malli coercion working with reitit. Basically it comes to this: ; based on example (def Over6 (m/-simple-schema {:type :user/over6 :pred #(and (int? %) (&gt; % 6)) :type-properties {:error/message &quot;should be over 6&quot; :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum 6 :gen/gen (gen/large-integer* {:min 7})}})) (mu/closed-schema Over6) =&gt; #&apos;user/Over6 Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema :user/over6} I can raise an issue in GH if you can confirm it."><y>#</y><d>2020-11-11</d><h>15:54</h><w>Maciej Falski</w>Hey, I think I found a bug while trying to get malli coercion working with reitit. Basically it comes to this:
<pre>; based on  example
(def Over6
  (m/-simple-schema
    {:type :user/over6
     :pred #(and (int? %) (&gt; % 6))
     :type-properties {:error/message &quot;should be over 6&quot;
                       :decode/string mt/-string-&gt;long
                       :json-schema/type &quot;integer&quot;
                       :json-schema/format &quot;int64&quot;
                       :json-schema/minimum 6
                       :gen/gen (gen/large-integer* {:min 7})}}))

(mu/closed-schema Over6)

=&gt; #&apos;user/Over6
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema :user/over6}</pre>
I can raise an issue in GH if you can confirm it.</z><z id="t1605191049" t="Rodrigo A. Roveri Folks, I have a begginer&apos;s question. I would like to test Malli, so I created a new lein project and included malli in the dependencies. I was able to run lein repl, but was unable to follow the examples on the doc page. (see image below) Am I missing something? Some pre-requisite? I tested on these two versions &quot;0.0.1-SNAPSHOT&quot;, &quot;0.2.1&quot;."><y>#</y><d>2020-11-12</d><h>14:24</h><w>Rodrigo A. Roveri</w>Folks, I have a begginer&apos;s question.
I would like to test Malli, so I created a new lein project and included malli in the dependencies.
I was able to run lein repl, but was unable to follow the examples on the doc page. (see image below)
Am I missing something? Some pre-requisite? I tested on these two versions &quot;0.0.1-SNAPSHOT&quot;, &quot;0.2.1&quot;.</z><z id="t1605191054" t="Rodrigo A. Roveri"><y>#</y><d>2020-11-12</d><h>14:24</h><w>Rodrigo A. Roveri</w></z><z id="t1605191648" t="borkdude What does the exception preceding your REPL expressions say?"><y>#</y><d>2020-11-12</d><h>14:34</h><w>borkdude</w>What does the exception preceding your REPL expressions say?</z><z id="t1605192806" t="Rodrigo A. Roveri"><y>#</y><d>2020-11-12</d><h>14:53</h><w>Rodrigo A. Roveri</w></z><z id="t1605192824" t="Rodrigo A. Roveri [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}]"><y>#</y><d>2020-11-12</d><h>14:53</h><w>Rodrigo A. Roveri</w><a>@borkdude</a></z><z id="t1605192842" t="borkdude How are you starting this repl? what is in your project.clj?"><y>#</y><d>2020-11-12</d><h>14:54</h><w>borkdude</w>How are you starting this repl? what is in your project.clj?</z><z id="t1605192982" t="Rodrigo A. Roveri Oh oh. I think maybe I know the answer. My project is also named &quot;malli&quot; :man-facepalming:"><y>#</y><d>2020-11-12</d><h>14:56</h><w>Rodrigo A. Roveri</w>Oh oh. I think maybe I know the answer. My project is also named &quot;malli&quot;<b>:man-facepalming:</b></z><z id="t1605193024" t="Rodrigo A. Roveri #inception"><y>#</y><d>2020-11-12</d><h>14:57</h><w>Rodrigo A. Roveri</w>#inception</z><z id="t1605193087" t="Rodrigo A. Roveri Thank you very much. Keep up the good work. I will run some tests. The project seems really interesting!"><y>#</y><d>2020-11-12</d><h>14:58</h><w>Rodrigo A. Roveri</w>Thank you very much. Keep up the good work. I will run some tests. The project seems really interesting!</z><z id="t1605201190" t="ikitommi [:attrs {:href &quot;/_/_/users/U018FH8HU6A&quot;}] oh, that’s bad, didn’t realize that unregistered Schemas can’t be walked with the current impl of m/schema-walker , as it tries to recreate the schmas using m/type , which in this case is :user/over6 and not found in the registry."><y>#</y><d>2020-11-12</d><h>17:13</h><w>ikitommi</w><a>@maciej.falski</a> oh, that’s bad, didn’t realize that unregistered Schemas can’t be walked with the current impl of <code>m/schema-walker</code>, as it tries to recreate the schmas using <code>m/type</code>, which in this case is <code>:user/over6</code> and not found in the registry.</z><z id="t1605201213" t="ikitommi Might need to add a -copy method into Schema protocol."><y>#</y><d>2020-11-12</d><h>17:13</h><w>ikitommi</w>Might need to add a <code>-copy</code> method into <code>Schema</code> protocol.</z><z id="t1605201282" t="ikitommi good thing is, that a per-schema -copy is most likely near to no-op, which makes Schema walking easily order(s) of magnitude faster."><y>#</y><d>2020-11-12</d><h>17:14</h><w>ikitommi</w>good thing is, that a per-schema <code>-copy</code> is most likely near to no-op, which makes Schema walking easily order(s) of magnitude faster.</z><z id="t1605202622" t="Maciej Falski Not sure if it’s about the registry, ie: (mr/set-default-registry! {:string (m/-string-schema) :over6 Over6}) =&gt; #object[malli.registry$simple_registry$reify__4072 0x1f74f3fd &quot;"><y>#</y><d>2020-11-12</d><h>17:37</h><w>Maciej Falski</w>Not sure if it’s about the registry, ie:
<pre>(mr/set-default-registry!
  {:string (m/-string-schema)
   :over6 Over6})
=&gt; #object[malli.registry$simple_registry$reify__4072 0x1f74f3fd &quot;</pre></z><z id="t1605202930" t="ikitommi [:attrs {:href &quot;/_/_/users/U018FH8HU6A&quot;}] you should register it with :user/over6 so it matches the Schema definition"><y>#</y><d>2020-11-12</d><h>17:42</h><w>ikitommi</w><a>@maciej.falski</a> you should register it with <code>:user/over6</code> so it matches the Schema definition</z><z id="t1605374810" t="ikitommi Schema knows now the IntoSchema that creates it. Fixes the issue [:attrs {:href &quot;/_/_/users/U018FH8HU6A&quot;}] and makes schema copying (= all utils) faster."><y>#</y><d>2020-11-14</d><h>17:26</h><w>ikitommi</w><code>Schema</code> knows now the <code>IntoSchema</code> that creates it. Fixes the issue <a>@maciej.falski</a> and makes schema copying (= all utils) faster.</z><z id="t1605383274" t="ikitommi two ways to create reusable rules for mutually exclusive keys for maps: 1. just data: (defn exclusive-keys [keys] [:fn {:error/message (str &quot;the following keys are mutually exclusive: &quot; (str/join &quot;, &quot; keys))} (fn [m] (not (every? (partial contains? m) keys)))]) (-&gt; [:and [:map [:foo {:optional true} :int] [:blabla {:optional true} :int] [:hah {:optional true} :int] [:bar {:optional true} :int]] (exclusive-keys [:hah :bar]) (exclusive-keys [:hah :foo])] (m/explain {:foo 1 :hah 2}) (me/humanize)) ; =&gt; #:malli{:error [&quot;the following keys are mutually exclusive: :hah, :foo&quot;]} 2. new Schema impl (with pretty form): (def Exclusive (m/-simple-schema (fn [_ [keys]] {:type &apos;Exclusive :min 1 :max 1 :pred (fn [m] (not (every? (partial contains? m) keys))) :type-properties {:error/message (str &quot;the following keys are mutually exclusive: &quot; (str/join &quot;, &quot; keys))}}))) (-&gt; [:and [:map [:foo {:optional true} :int] [:blabla {:optional true} :int] [:hah {:optional true} :int] [:bar {:optional true} :int]] [Exclusive #{:hah :bar}] [Exclusive #{:hah :foo}]] (m/explain {:foo 1 :hah 2}) (me/humanize)) ; =&gt; #:malli{:error [&quot;the following keys are mutually exclusive: :hah, :foo&quot;]}"><y>#</y><d>2020-11-14</d><h>19:47</h><w>ikitommi</w>two ways to create reusable rules for mutually exclusive keys for maps:

1. just data:
<pre>(defn exclusive-keys [keys]
  [:fn {:error/message (str &quot;the following keys are mutually exclusive: &quot; (str/join &quot;, &quot; keys))}
   (fn [m] (not (every? (partial contains? m) keys)))])

(-&gt; [:and
     [:map
      [:foo {:optional true} :int]
      [:blabla {:optional true} :int]
      [:hah {:optional true} :int]
      [:bar {:optional true} :int]]
     (exclusive-keys [:hah :bar])
     (exclusive-keys [:hah :foo])]
    (m/explain {:foo 1 :hah 2})
    (me/humanize))
; =&gt; #:malli{:error [&quot;the following keys are mutually exclusive: :hah, :foo&quot;]}</pre>
2. new <code>Schema</code> impl (with pretty form):
<pre>(def Exclusive
  (m/-simple-schema
    (fn [_ [keys]]
      {:type &apos;Exclusive
       :min 1
       :max 1
       :pred (fn [m] (not (every? (partial contains? m) keys)))
       :type-properties {:error/message (str &quot;the following keys are mutually exclusive: &quot; (str/join &quot;, &quot; keys))}})))

(-&gt; [:and
     [:map
      [:foo {:optional true} :int]
      [:blabla {:optional true} :int]
      [:hah {:optional true} :int]
      [:bar {:optional true} :int]]
     [Exclusive #{:hah :bar}]
     [Exclusive #{:hah :foo}]]
    (m/explain {:foo 1 :hah 2})
    (me/humanize))
; =&gt; #:malli{:error [&quot;the following keys are mutually exclusive: :hah, :foo&quot;]}</pre></z><z id="t1605383368" t="ikitommi no macros = awesome"><y>#</y><d>2020-11-14</d><h>19:49</h><w>ikitommi</w>no macros = <b>awesome</b></z><z id="t1605383540" t="ikitommi the latter is the not-well-documented reagent-style thing, any IntoSchema can be used in first position in Schema AST and -simple-schema allows one to read the properties &amp; children at creation time and return a Schema instance based on those."><y>#</y><d>2020-11-14</d><h>19:52</h><w>ikitommi</w>the latter is the not-well-documented reagent-style thing, any <code>IntoSchema</code> can be used in first position in Schema AST and <code>-simple-schema</code> allows one to read the properties &amp; children at creation time and return a Schema instance based on those.</z><z id="t1605383575" t="ikitommi it’s bit like derived [:attrs nil] schemas?"><y>#</y><d>2020-11-14</d><h>19:52</h><w>ikitommi</w>it’s bit like derived <del>types</del> schemas?</z><z id="t1605432652" t="ikitommi wrote an issue for discussing about auto-updating with container schemas: https://github.com/metosin/malli/issues/304 . Comments most welcome."><y>#</y><d>2020-11-15</d><h>09:30</h><w>ikitommi</w>wrote an issue for discussing about auto-updating with container schemas: <a href="https://github.com/metosin/malli/issues/304" target="_blank">https://github.com/metosin/malli/issues/304</a>. Comments most welcome.</z><z id="t1605440248" t="ikitommi function schemas, comments welcome: https://github.com/metosin/malli/issues/125#issuecomment-727555388"><y>#</y><d>2020-11-15</d><h>11:37</h><w>ikitommi</w>function schemas, comments welcome: <a href="https://github.com/metosin/malli/issues/125#issuecomment-727555388" target="_blank">https://github.com/metosin/malli/issues/125#issuecomment-727555388</a></z><z id="t1605440434" t="borkdude I think you are ignoring the fact that different arities can have different return types/schemas"><y>#</y><d>2020-11-15</d><h>11:40</h><w>borkdude</w>I think you are ignoring the fact that different arities can have different return types/schemas</z><z id="t1605440464" t="borkdude I think clojure.spec is also making this too difficult. In clj-kondo I chose to define the spec per arity"><y>#</y><d>2020-11-15</d><h>11:41</h><w>borkdude</w>I think clojure.spec is also making this too difficult. In clj-kondo I chose to define the spec per arity</z><z id="t1605440477" t="borkdude It is more verbose, but at least easy to verify"><y>#</y><d>2020-11-15</d><h>11:41</h><w>borkdude</w>It is more verbose, but at least easy to verify</z><z id="t1605440543" t="ikitommi good point, the schema also forces the return to be the same for all arities."><y>#</y><d>2020-11-15</d><h>11:42</h><w>ikitommi</w>good point, the schema also forces the return to be the same for all arities.</z><z id="t1605440562" t="borkdude really?"><y>#</y><d>2020-11-15</d><h>11:42</h><w>borkdude</w>really?</z><z id="t1605440584" t="ikitommi I guess there are lot of examples in the core where the different arities return different things?"><y>#</y><d>2020-11-15</d><h>11:43</h><w>ikitommi</w>I guess there are lot of examples in the core where the different arities return different things?</z><z id="t1605440594" t="ikitommi yes."><y>#</y><d>2020-11-15</d><h>11:43</h><w>ikitommi</w>yes.</z><z id="t1605440653" t="borkdude confirmed: &gt; - The output schema always goes on the fn name, not the arg vector. This means that all arities must share the same output schema."><y>#</y><d>2020-11-15</d><h>11:44</h><w>borkdude</w>confirmed:
&gt; - The output schema always goes on the fn name, not the arg vector. This
   means that all arities must share the same output schema.</z><z id="t1605440702" t="borkdude well, clojure.core/map, filter, etc, is an example that have different return types for different arities. I kinda wish that the transducer arity was just a different version like clojure.core/mapping but that ship has sailed. I often make mistakes with this"><y>#</y><d>2020-11-15</d><h>11:45</h><w>borkdude</w>well, clojure.core/map, filter, etc, is an example that have different return types for different arities. I kinda wish that the transducer arity was just a different version like <code>clojure.core/mapping</code> but that ship has sailed. I often make mistakes with this</z><z id="t1605440740" t="borkdude look at the spec that will result from this: https://github.com/borkdude/speculative/blob/master/src/speculative/core.cljc#L297-L302"><y>#</y><d>2020-11-15</d><h>11:45</h><w>borkdude</w>look at the spec that will result from this:
<a href="https://github.com/borkdude/speculative/blob/master/src/speculative/core.cljc#L297-L302" target="_blank">https://github.com/borkdude/speculative/blob/master/src/speculative/core.cljc#L297-L302</a></z><z id="t1605440782" t="borkdude I think this is not ergonomic at all. spec has to do backtracking etc, to match the right arity."><y>#</y><d>2020-11-15</d><h>11:46</h><w>borkdude</w>I think this is not ergonomic at all. spec has to do backtracking etc, to match the right arity.</z><z id="t1605440808" t="borkdude imo the fn spec should match the structure of the defn args+bodies"><y>#</y><d>2020-11-15</d><h>11:46</h><w>borkdude</w>imo the fn spec should match the structure of the defn args+bodies</z><z id="t1605440984" t="ikitommi good point. what would be a good malli definition for this: (defn fun ([x] x) ([x y] [x (* x x)]))"><y>#</y><d>2020-11-15</d><h>11:49</h><w>ikitommi</w>good point. what would be a good malli definition for this:
<pre>(defn fun
  ([x] x)
  ([x y] [x (* x x)]))</pre></z><z id="t1605441014" t="ikitommi clj-kondo has a good syntax for the different arities, use that’ish?"><y>#</y><d>2020-11-15</d><h>11:50</h><w>ikitommi</w>clj-kondo has a good syntax for the different arities, use that’ish?</z><z id="t1605441053" t="ikitommi something like: (m/=&gt; fun {:arities {1 {:output int? :input [:tuple int?]} 2 {:output [:tuple int? pos-int?] :input [:tuple int? int?]}}})"><y>#</y><d>2020-11-15</d><h>11:50</h><w>ikitommi</w>something like:
<pre>(m/=&gt; fun {:arities {1 {:output int?
                        :input [:tuple int?]}
                     2 {:output [:tuple int? pos-int?]
                        :input [:tuple int? int?]}}})</pre></z><z id="t1605441090" t="borkdude That&apos;s how I do it in clj-kondo yes."><y>#</y><d>2020-11-15</d><h>11:51</h><w>borkdude</w>That&apos;s how I do it in clj-kondo yes.</z><z id="t1605441131" t="borkdude Not sure if that&apos;s the best, but I optimized for matching speed, so clj-kondo can find the right arg types fast"><y>#</y><d>2020-11-15</d><h>11:52</h><w>borkdude</w>Not sure if that&apos;s the best, but I optimized for matching speed, so clj-kondo can find the right arg types fast</z><z id="t1605441202" t="borkdude as for defn syntax, maybe: (defn fun ([x :- int?] :- int? x) ([x :- int? y :- string?] :- [:tuple string? int?] [y (* x x)]))"><y>#</y><d>2020-11-15</d><h>11:53</h><w>borkdude</w>as for defn syntax, maybe:
<pre>(defn fun
  ([x :- int?] :- int?
   x)
  ([x :- int? y :- string?] :- [:tuple string? int?]
   [y (* x x)]))</pre></z><z id="t1605441220" t="borkdude so the return type directly after the arg vec"><y>#</y><d>2020-11-15</d><h>11:53</h><w>borkdude</w>so the return type directly after the arg vec</z><z id="t1605441289" t="ikitommi 👍"><y>#</y><d>2020-11-15</d><h>11:54</h><w>ikitommi</w><b>👍</b></z><z id="t1605441478" t="ikitommi the extracted schemas could be in the compact/short :=&gt; format, which is always 1-arity: (defn fun1 [x] (* x x)) ;; short (m/=&gt; fun1 [:=&gt; int? [:tuple pos-int?]]) (defn fun ([x] (fun x x)) ([x y] [x (* x x)])) ;; short (m/=&gt; fun [:or [:=&gt; int? [:tuple int?]] [:=&gt; [:tuple int? pos-int?] [:tuple int?]]]) "><y>#</y><d>2020-11-15</d><h>11:57</h><w>ikitommi</w>the extracted schemas could be in the compact/short <code>:=&gt;</code> format, which is always 1-arity:

<pre>(defn fun1 [x] (* x x))

;; short
(m/=&gt; fun1 [:=&gt; int? [:tuple pos-int?]])</pre>
<pre>(defn fun
  ([x] (fun x x))
  ([x y] [x (* x x)]))

;; short
(m/=&gt; fun [:or
           [:=&gt; int? [:tuple int?]]
           [:=&gt; [:tuple int? pos-int?] [:tuple int?]]])</pre>
</z><z id="t1605441540" t="ikitommi the long versions: (defn fun1 [x] (* x x)) ;; long (m/=&gt; fun1 {:arities {1 {:input int? :output [:tuple pos-int?]}}}) (defn fun ([x] (fun x x)) ([x y] [x (* x x)])) ;; long (m/=&gt; fun {:arities {1 {:output int? :input [:tuple int?]} 2 {:output [:tuple int? pos-int?] :input [:tuple int? int?]}}}) "><y>#</y><d>2020-11-15</d><h>11:59</h><w>ikitommi</w>the long versions:

<pre>(defn fun1 [x] (* x x))

;; long
(m/=&gt; fun1 {:arities {1 {:input int?
                         :output [:tuple pos-int?]}}})</pre>
<pre>(defn fun
  ([x] (fun x x))
  ([x y] [x (* x x)]))

;; long
(m/=&gt; fun {:arities {1 {:output int?
                        :input [:tuple int?]}
                     2 {:output [:tuple int? pos-int?]
                        :input [:tuple int? int?]}}})</pre>
</z><z id="t1605441540" t="borkdude could work yes"><y>#</y><d>2020-11-15</d><h>11:59</h><w>borkdude</w>could work yes</z><z id="t1605441588" t="borkdude doesn&apos;t fn spec hinge on sequence specs which are not exposed yet?"><y>#</y><d>2020-11-15</d><h>11:59</h><w>borkdude</w>doesn&apos;t fn spec hinge on sequence specs which are not exposed yet?</z><z id="t1605441674" t="ikitommi yes, those are needed for varags. we just had an internal tech-talk on friday, did a plan how to get the sequence schemas &amp; schema parsing out. takes few days to make that good."><y>#</y><d>2020-11-15</d><h>12:01</h><w>ikitommi</w>yes, those are needed for varags. we just had an internal tech-talk on friday, did a plan how to get the sequence schemas &amp; schema parsing out. takes few days to make that good.</z><z id="t1605441717" t="ikitommi first demo of the function schemas will be with non-vargargs. enough to get feedback &amp; start with the clj-kondo integration."><y>#</y><d>2020-11-15</d><h>12:01</h><w>ikitommi</w>first demo of the function schemas will be with non-vargargs. enough to get feedback &amp; start with the clj-kondo integration.</z><z id="t1605456577" t="ikitommi (require &apos;[malli.schema :as ms]) (ms/defn ^:always-validate fun :- [:tuple int? pos-int?] &quot;returns a tuple of a number and it&apos;s value squared&quot; ([x :- int?] :- any? ;; arity-level override (fun x x)) ([x :- int?, y :- int?] ;; uses the default return [x (* x x)])) (clojure.repl/doc fun) ; ------------------------- ; demo/fun ; ([x] [x y]) ; ; [:-&gt; [:tuple int?] any?] ; [:-&gt; [:tuple int? int?] [:tuple int? pos-int?]] ; ; returns a tuple of a number and it&apos;s value squared"><y>#</y><d>2020-11-15</d><h>16:09</h><w>ikitommi</w><pre>(require &apos;[malli.schema :as ms])

(ms/defn ^:always-validate fun :- [:tuple int? pos-int?]
  &quot;returns a tuple of a number and it&apos;s value squared&quot;
  ([x :- int?] :- any? ;; arity-level override
   (fun x x))
  ([x :- int?, y :- int?] ;; uses the default return
   [x (* x x)]))

(clojure.repl/doc fun)
; -------------------------
; demo/fun
; ([x] [x y])
;   
;   [:-&gt; [:tuple int?] any?]
;   [:-&gt; [:tuple int? int?] [:tuple int? pos-int?]]
; 
;   returns a tuple of a number and it&apos;s value squared</pre></z><z id="t1605457012" t="ikitommi full meta: (ms/defn square :- pos-int? [x :- int?] (* x x)) (meta #&apos;square) ;{:schema [:or [:-&gt; [:tuple int?] pos-int?]], ; :ns #object[clojure.lang.Namespace 0x3c5f3ba8 &quot;demo&quot;], ; :name square, ; :file &quot;/Users/tommi/projects/metosin/malli/src/malli/schema.cljc&quot;, ; :column 1, ; :raw-arglists ([x :- int?]), ; :line 64, ; :arglists ([x]), ; :doc &quot;\n[:or\n [:-&gt; [:tuple int?] pos-int?]]&quot;}"><y>#</y><d>2020-11-15</d><h>16:16</h><w>ikitommi</w>full meta:
<pre>(ms/defn square :- pos-int?
  [x :- int?]
  (* x x))

(meta #&apos;square)
;{:schema [:or [:-&gt; [:tuple int?] pos-int?]],
; :ns #object[clojure.lang.Namespace 0x3c5f3ba8 &quot;demo&quot;],
; :name square,
; :file &quot;/Users/tommi/projects/metosin/malli/src/malli/schema.cljc&quot;,
; :column 1,
; :raw-arglists ([x :- int?]),
; :line 64,
; :arglists ([x]),
; :doc &quot;\n[:or\n [:-&gt; [:tuple int?] pos-int?]]&quot;}</pre></z><z id="t1605472120" t="ikitommi"><y>#</y><d>2020-11-15</d><h>20:28</h><w>ikitommi</w></z><z id="t1605506661" t="ikitommi first draft of m/=&gt; , to annotate existing functions. now - just with the compact/mallli notation, could support the map-version too. Kinda like it as it’s as long as defn , to the two can be aligned."><y>#</y><d>2020-11-16</d><h>06:04</h><w>ikitommi</w>first draft of <code>m/=&gt;</code>, to annotate existing functions. now - just with the compact/mallli notation, could support the map-version too. Kinda like it as it’s as long as <code>defn</code>,  to the two can be aligned.</z><z id="t1605506701" t="ikitommi … supports multi-artities with different return for each."><y>#</y><d>2020-11-16</d><h>06:05</h><w>ikitommi</w>… supports multi-artities with different return for each.</z><z id="t1605523832" t="ordnungswidrig magic"><y>#</y><d>2020-11-16</d><h>10:50</h><w>ordnungswidrig</w>magic</z><z id="t1605602706" t="ikitommi there are some gaps in the malli-&gt;clj-kondo integration, any insights welcome: https://github.com/metosin/malli/blob/cde74871ee5edc1525344f7a6e62d54fb1b00f5b/src/malli/clj_kondo.cljc . marked with ;;??"><y>#</y><d>2020-11-17</d><h>08:45</h><w>ikitommi</w>there are some gaps in the malli-&gt;clj-kondo integration, any insights welcome: <a href="https://github.com/metosin/malli/blob/cde74871ee5edc1525344f7a6e62d54fb1b00f5b/src/malli/clj_kondo.cljc" target="_blank">https://github.com/metosin/malli/blob/cde74871ee5edc1525344f7a6e62d54fb1b00f5b/src/malli/clj_kondo.cljc</a>. marked with <code>;;??</code></z><z id="t1605602734" t="ikitommi currently: (require &apos;[malli.clj-kondo :as mc]) (mc/transform [:map [:id string?] [:tags {:optional true} [:set keyword?]] [:address [:map [:street string?] [:city string?] [:zip {:optional true} int?] [:lonlat [:tuple double? double?]]]]]) ;{:op :keys ; :opt {:tags :set} ; :req {:id :string ; :address {:op :keys ; :opt {:zip :int} ; :req {:street :string ; :city :string ; :lonlat [:double :double]}}}}"><y>#</y><d>2020-11-17</d><h>08:45</h><w>ikitommi</w>currently:
<pre>(require &apos;[malli.clj-kondo :as mc])

(mc/transform
  [:map
   [:id string?]
   [:tags {:optional true} [:set keyword?]]
   [:address
    [:map
     [:street string?]
     [:city string?]
     [:zip {:optional true} int?]
     [:lonlat [:tuple double? double?]]]]])
;{:op :keys
; :opt {:tags :set}
; :req {:id :string
;       :address {:op :keys
;                 :opt {:zip :int}
;                 :req {:street :string
;                       :city :string
;                       :lonlat [:double :double]}}}}</pre></z><z id="t1605603095" t="ikitommi btw, would be great if clj-kondo supported :min and :max for numbers &amp; collections. nice demo about “more than types”, something like: (ms/defn times :- :int &quot;times&quot; [x :- [:int {:min 3}]] (* x x)) (times 2) ;; ^:--- clj-kondo error of &quot;number should be at least 3&quot;"><y>#</y><d>2020-11-17</d><h>08:51</h><w>ikitommi</w>btw, would be great if clj-kondo supported <code>:min</code> and <code>:max</code> for numbers &amp; collections. nice demo about “more than types”, something like:

<pre>(ms/defn times :- :int
  &quot;times&quot;
  [x :- [:int {:min 3}]]
  (* x x))

(times 2)
;; ^:--- clj-kondo error of &quot;number should be at least 3&quot;</pre></z><z id="t1605605149" t="borkdude Don&apos;t know if this a common enough problem in function calls. I haven&apos;t encountered this much I think. If there&apos;s a domain specific need to check this, one can also write a hook"><y>#</y><d>2020-11-17</d><h>09:25</h><w>borkdude</w>Don&apos;t know if this a common enough problem in function calls. I haven&apos;t encountered this much I think. If there&apos;s a domain specific need to check this, one can also write a hook</z><z id="t1605605526" t="ikitommi ok. just wondering as clj-kondo already supports map-op-syntax, so if :int could be defined as {:op :int} , it would allow adding easily new keys that would be easy to check, e.g. malli could emit {:opt :int, :min 3} from the example. Not sure how useful that would be, but: • number min &amp; max might be easy to implement on clj-kondo side? • would be a great demo, as you can’t easily present these with simple typed langs liike Java"><y>#</y><d>2020-11-17</d><h>09:32</h><w>ikitommi</w>ok. just wondering as clj-kondo already supports map-op-syntax, so if <code>:int</code> could be defined as <code>{:op :int}</code>, it would allow adding easily new keys that would be easy to check, e.g. malli could emit <code>{:opt :int, :min 3}</code> from the example. Not sure how useful that would be, but:
• number min &amp; max might be easy to implement on clj-kondo side?
• would be a great demo, as you can’t easily present these with simple typed langs liike Java</z><z id="t1605605574" t="ikitommi but, I don’t need this for real, just thinking aloud about a kick-ass demo 🙂"><y>#</y><d>2020-11-17</d><h>09:32</h><w>ikitommi</w>but, I don’t need this for real, just thinking aloud about a kick-ass demo <b>🙂</b></z><z id="t1605605606" t="borkdude it has :pos-int and :nat-int which map to the clojure predicates. it basically only has that which exists as predicates in clojure 1.9+"><y>#</y><d>2020-11-17</d><h>09:33</h><w>borkdude</w>it has <code>:pos-int</code> and <code>:nat-int</code> which map to the clojure predicates. it basically only has that which exists as predicates in clojure 1.9+</z><z id="t1605605780" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Feel free to try out things with the clj-kondo type system. You can build a custom clj-kondo for your demo possibly"><y>#</y><d>2020-11-17</d><h>09:36</h><w>borkdude</w><a>@ikitommi</a> Feel free to try out things with the clj-kondo type system. You can build a custom clj-kondo for your demo possibly</z><z id="t1605605793" t="borkdude it&apos;s all in clj-kondo.impl.types"><y>#</y><d>2020-11-17</d><h>09:36</h><w>borkdude</w>it&apos;s all in clj-kondo.impl.types</z><z id="t1605605811" t="ikitommi thanks, might give it a shot."><y>#</y><d>2020-11-17</d><h>09:36</h><w>ikitommi</w>thanks, might give it a shot.</z><z id="t1605606171" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Ah, I can see why your approach might be problematic: https://github.com/borkdude/clj-kondo/blob/master/src/clj_kondo/impl/types.clj#L157-L163 So the literal value is mapped to a type tag. And then during checking that is resolved very cheaply, not executing any predicates, but just checking a keyword identity or a super simple graph, e.g. a pos-int is also an int"><y>#</y><d>2020-11-17</d><h>09:42</h><w>borkdude</w><a>@ikitommi</a> Ah, I can see why your approach might be problematic:
<a href="https://github.com/borkdude/clj-kondo/blob/master/src/clj_kondo/impl/types.clj#L157-L163" target="_blank">https://github.com/borkdude/clj-kondo/blob/master/src/clj_kondo/impl/types.clj#L157-L163</a>
So the literal value is mapped to a type tag. And then during checking that is resolved very cheaply, not executing any predicates, but just checking a keyword identity or a super simple graph, e.g. a pos-int is also an int</z><z id="t1605606257" t="borkdude so the literal value is erased as it were"><y>#</y><d>2020-11-17</d><h>09:44</h><w>borkdude</w>so the literal value is erased as it were</z><z id="t1605638875" t="Hankstenberg Hi guys, just getting my feet wet with malli. Quick question: when I try to transform a map to JSON-Schema, all the map&apos;s keywords are still Clojure keywords and thus invalid syntax in JSON-Schema. Sure, I could post-process it, but is this on purpose? What&apos;s the best way to get proper JSON-Schema?"><y>#</y><d>2020-11-17</d><h>18:47</h><w>Hankstenberg</w>Hi guys, just getting my feet wet with malli. Quick question: when I try to transform a map to JSON-Schema, all the map&apos;s keywords are still Clojure keywords and thus invalid syntax in JSON-Schema. Sure, I could post-process it, but is this on purpose? What&apos;s the best way to get proper JSON-Schema?</z><z id="t1605639823" t="ikitommi [:attrs {:href &quot;/_/_/users/UDCUACM4M&quot;}] I think it would be better to emit strings directly. PR Welcome."><y>#</y><d>2020-11-17</d><h>19:03</h><w>ikitommi</w><a>@marcus.poparcus</a> I think it would be better to emit strings directly. PR Welcome.</z><z id="t1605731687" t="Hankstenberg The simplest way to do it would probably be to wrap the output in clojure.data.json/write-str, looks pretty ugly of course and becomes useless in clojureland. I guess it really depends on what consumes the output afterwards. Maybe that should be handled case by case. How about an additional function &quot;transform-json-str&quot;? Comes with the new dependency of clojure.data.json, though. Looking at the source code of clojure.data.json it&apos;s not trivial to generate valid JSON manually."><y>#</y><d>2020-11-18</d><h>20:34</h><w>Hankstenberg</w>The simplest way to do it would probably be to wrap the output in clojure.data.json/write-str, looks pretty ugly of course and becomes useless in clojureland. I guess it really depends on what consumes the output afterwards. Maybe that should be handled case by case. How about an additional function &quot;transform-json-str&quot;? Comes with the new dependency of clojure.data.json, though. Looking at the source code of clojure.data.json it&apos;s not trivial to generate valid JSON manually.</z><z id="t1605836173" t="fmn Hi guys, is there any way to get all of the values defined in :enum ? I&apos;m trying to do some testing and it would be great if I could just iterate through it rather than hard-coded it. I guess I could just (next (malli.core/form my-enums)) . Just trying to find a more consistent way since this breaks if I add options to it."><y>#</y><d>2020-11-20</d><h>01:36</h><w>fmn</w>Hi guys, is there any way to get all of the values defined in <code>:enum</code> ? I&apos;m trying to do some testing and it would be great if I could just iterate through it rather than hard-coded it. I guess I could just <code>(next (malli.core/form my-enums))</code> . Just trying to find a more consistent way since this breaks if I add options to it.</z><z id="t1605847607" t="ikitommi [:attrs {:href &quot;/_/_/users/U97FB4VEE&quot;}] try (m/children MyEnun)"><y>#</y><d>2020-11-20</d><h>04:46</h><w>ikitommi</w><a>@funyako.funyao156</a> try <code>(m/children MyEnun)</code></z><z id="t1606060722" t="ikitommi hi all. comments on the function schema syntax? some alternatives: ;; ;; many ways to present function schemas ;; - 2 ints to int ;; - int to int ;; - no args to int ;; - no args to irrelevant ;; ;; 1: current [:=&gt; [:tuple int? int?] int?] [:=&gt; [:tuple int?] int?] [:=&gt; [:tuple] int?] [:=&gt; [:tuple]] ;; 2: shortcut [:=&gt; [int? int?] int?] [:=&gt; [int?] int?] [:=&gt; [] int?] [:=&gt; []] ;; 3: separator [:fn int? int? :=&gt; int?] [:fn int? :=&gt; int?] [:fn :=&gt; int?] [:fn :=&gt;]"><y>#</y><d>2020-11-22</d><h>15:58</h><w>ikitommi</w>hi all. comments on the function schema syntax? some alternatives:
<pre>;;
;; many ways to present function schemas
;; - 2 ints to int
;; - int to int
;; - no args to int
;; - no args to irrelevant
;;

;; 1: current
[:=&gt; [:tuple int? int?] int?]
[:=&gt; [:tuple int?] int?]
[:=&gt; [:tuple] int?]
[:=&gt; [:tuple]]

;; 2: shortcut
[:=&gt; [int? int?] int?]
[:=&gt; [int?] int?]
[:=&gt; [] int?]
[:=&gt; []]

;; 3: separator
[:fn int? int? :=&gt; int?]
[:fn int? :=&gt; int?]
[:fn :=&gt; int?]
[:fn :=&gt;]</pre></z><z id="t1606103909" t="rutledgepaulv I personally do not mind the more verbose version. I am wary of adding too many syntactic shortcuts since sometimes they begin to collide in unfortunate ways that make it more difficult to write correct tooling. But maybe you already have easy ways to quickly convert them into a normal form?"><y>#</y><d>2020-11-23</d><h>03:58</h><r>rutledgepaulv</r>I personally do not mind the more verbose version. I am wary of adding too many syntactic shortcuts since sometimes they begin to collide in unfortunate ways that make it more difficult to write correct tooling. But maybe you already have easy ways to quickly convert them into a normal form?</z><z id="t1606114296" t="ikitommi no tools to convert, totally agree that there should not be extra syntaxes in malli core."><y>#</y><d>2020-11-23</d><h>06:51</h><r>ikitommi</r>no tools to convert, totally agree that there should not be extra syntaxes in malli core.</z><z id="t1606115289" t="Martín Varela I like the 3rd version best, seems easier to read than the other ones."><y>#</y><d>2020-11-23</d><h>07:08</h><r>Martín Varela</r>I like the 3rd version best, seems easier to read than the other ones.</z><z id="t1606115874" t="ikitommi [:attrs {:href &quot;/_/_/users/U95NTJT4H&quot;}] that is basically Ghostwheel (spec) / Aave (malli) do: (&gt;defn bad-return-val [x y] [int? int? =&gt; string?] (+ x y))"><y>#</y><d>2020-11-23</d><h>07:17</h><r>ikitommi</r><a>@U95NTJT4H</a> that is basically Ghostwheel (spec) / Aave (malli) do:
<pre>(&gt;defn bad-return-val
  [x y]
  [int? int? =&gt; string?]
  (+ x y))</pre></z><z id="t1606115987" t="ikitommi one more: ;; 4: via properties [:=&gt; {:input [:tuple int? int?] :outut int?}] [:=&gt; {:input [:tuple int?] :output int?}] [:=&gt; {:output int?}] :=&gt;"><y>#</y><d>2020-11-23</d><h>07:19</h><r>ikitommi</r>one more:
<pre>;; 4: via properties
[:=&gt; {:input [:tuple int? int?]
      :outut int?}]
[:=&gt; {:input [:tuple int?]
      :output int?}]
[:=&gt; {:output int?}]
:=&gt;</pre></z><z id="t1606116042" t="Martín Varela I haven&apos;t used those, but it does seem more readable than the alternatives (I guess this is a very subjective thing, anyway). I guess I&apos;m also with [:attrs {:href &quot;/_/_/users/U5RCSJ6BB&quot;}] in not minding a bit more verbosity"><y>#</y><d>2020-11-23</d><h>07:20</h><r>Martín Varela</r>I haven&apos;t used those, but it does seem more readable than the alternatives (I guess this is a very subjective thing, anyway). I guess I&apos;m also with <a>@U5RCSJ6BB</a> in not minding a bit more verbosity</z><z id="t1606116058" t="Martín Varela terse is really cool, until it isn&apos;t... 🙂"><y>#</y><d>2020-11-23</d><h>07:20</h><r>Martín Varela</r>terse is really cool, until it isn&apos;t... <b>🙂</b></z><z id="t1606116218" t="ikitommi data-specs for spec-tools for a great idea for really simple things. But as soon as one needed something non-trivial, it became a burden. Same with spec2, s/select syntax is awesome, until you need something inlined specs in it."><y>#</y><d>2020-11-23</d><h>07:23</h><r>ikitommi</r>data-specs for spec-tools for a great idea for really simple things. But as soon as one needed something non-trivial, it became a burden. Same with spec2, <code>s/select</code> syntax is awesome, until you need something inlined specs in it.</z><z id="t1606116236" t="Martín Varela BTW, is the idea to provide the full power of malli for these? If I think of my use cases, the most likely ones would probably be rather complicated crap data (nested, with constraints, etc..), so it&apos;d be cool to be able to use a registry or similar"><y>#</y><d>2020-11-23</d><h>07:23</h><r>Martín Varela</r>BTW, is the idea to provide the full power of malli for these? If I think of my use cases, the most likely ones would probably be rather complicated crap data (nested, with constraints, etc..), so it&apos;d be cool to be able to use a registry or similar</z><z id="t1606116293" t="Martín Varela they may become rather unreadable very fast, if inlined as such"><y>#</y><d>2020-11-23</d><h>07:24</h><r>Martín Varela</r>they may become rather unreadable very fast, if inlined as such</z><z id="t1606116305" t="ikitommi :=&gt; is just a normal Schema , so generators, validators etc. work normally"><y>#</y><d>2020-11-23</d><h>07:25</h><r>ikitommi</r><code>:=&gt;</code> is just a normal <code>Schema</code>, so generators, validators etc. work normally</z><z id="t1606116310" t="Martín Varela ok"><y>#</y><d>2020-11-23</d><h>07:25</h><r>Martín Varela</r>ok</z><z id="t1606116682" t="Martín Varela Not entirely unrelated to this, the other day, while trying to figure out that reitit issue, I thought the problem was that reitit wasn&apos;t picking up the registry, so I ended up writing a bit of meander term rewriting code that allows you to define schemas based on other schemas (where you&apos;d normally use a registry), and compile those to malli &quot;primitives&quot;. So you get both the concision and explicitness, in a way."><y>#</y><d>2020-11-23</d><h>07:31</h><r>Martín Varela</r>Not entirely unrelated to this, the other day, while trying to figure out that reitit issue, I thought the problem was that reitit wasn&apos;t picking up the registry, so I ended up writing a bit of meander term rewriting code that allows you to define schemas based on other schemas (where you&apos;d normally use a registry), and compile those to malli &quot;primitives&quot;. So you get both the concision and explicitness, in a way.</z><z id="t1606132033" t="rutledgepaulv Suppose another question is should a &quot;irrelevant&quot; return be a special case or should you just use a &apos;any? schema"><y>#</y><d>2020-11-23</d><h>11:47</h><r>rutledgepaulv</r>Suppose another question is should a &quot;irrelevant&quot; return be a special case or should you just use a &apos;any? schema</z><z id="t1606061022" t="ikitommi I think as Aave already provides the short variant, so the official (malli-like) syntax doesn’t have to be that terse, just formal. But the 1 is still.. ugly."><y>#</y><d>2020-11-22</d><h>16:03</h><w>ikitommi</w>I think as Aave already provides the short variant, so the official (malli-like) syntax doesn’t have to be that terse, just formal. But the 1 is still.. ugly.</z><z id="t1606114405" t="ikitommi playing with :=&gt; generators. also good peek at the syntax options (using children vs properties): (def Age [:int {:min 18, :max 100}]) (def User [:map [:name string?] [:age Age] [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot; &quot;rust&quot; &quot;go&quot; &quot;cobol&quot;]]]]) ;; option1: childs (def create-user [:=&gt; {:gen/=&gt; &apos;(fn [[age] user] (assoc user :age age))} [:tuple Age] User]) ;; option2: properties (def create-user [:=&gt; {:gen/=&gt; &apos;(fn [[age] user] (assoc user :age age)) :input [:tuple Age] :output User}]) (mg/generate User {:size 10}) ; =&gt; {:name &quot;Szf5sN&quot;, :age 21, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}} (def create-user-gen (mg/generate create-user {:size 10})) (create-user-gen 46) ; =&gt; {:name &quot;Itu96&quot;, :age 46, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}}"><y>#</y><d>2020-11-23</d><h>06:53</h><w>ikitommi</w>playing with <code>:=&gt;</code> generators. also  good peek at the syntax options (using children vs properties):
<pre>(def Age
  [:int {:min 18, :max 100}])

(def User
  [:map
   [:name string?]
   [:age Age]
   [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot; &quot;rust&quot; &quot;go&quot; &quot;cobol&quot;]]]])

;; option1: childs
(def create-user
  [:=&gt; {:gen/=&gt; &apos;(fn [[age] user] (assoc user :age age))}
   [:tuple Age] User])

;; option2: properties
(def create-user
  [:=&gt; {:gen/=&gt; &apos;(fn [[age] user] (assoc user :age age))
        :input [:tuple Age]
        :output User}])

(mg/generate User {:size 10})
; =&gt; {:name &quot;Szf5sN&quot;, :age 21, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}}

(def create-user-gen (mg/generate create-user {:size 10}))

(create-user-gen 46)
; =&gt; {:name &quot;Itu96&quot;, :age 46, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}}</pre></z><z id="t1606167086" t="ikitommi also, validating functions against malli definitions: (def Age [:int {:min 18, :max 100}]) (def User [:map [:name string?] [:age Age] [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot; &quot;rust&quot; &quot;go&quot; &quot;cobol&quot;]]]]) (mg/generate User {:size 10}) ; =&gt; {:name &quot;Szf5sN&quot;, :age 21, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}} (def create-user [:=&gt; [:tuple Age] User]) (m/validate create-user (fn [age] {:name &quot;elephant&quot;, :age age, :skills #{&quot;cobol&quot;}}) {::m/=&gt;validator mg/=&gt;validator}) ; =&gt; true ;; invalid return (m/validate create-user (fn [age] {:name &quot;elephant&quot;, :age age, :skills #{&quot;PERL&quot;}}) {::m/=&gt;validator mg/=&gt;validator}) ; =&gt; false ;; invalid arity (m/validate create-user (fn [age _extra] {:name &quot;elephant&quot;, :age age, :skills #{&quot;cobol&quot;}}) {::m/=&gt;validator mg/=&gt;validator}) ; =&gt; false"><y>#</y><d>2020-11-23</d><h>21:31</h><w>ikitommi</w>also, validating functions against <b>malli</b>definitions:
<pre>(def Age
  [:int {:min 18, :max 100}])

(def User
  [:map
   [:name string?]
   [:age Age]
   [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot; &quot;rust&quot; &quot;go&quot; &quot;cobol&quot;]]]])

(mg/generate User {:size 10})
; =&gt; {:name &quot;Szf5sN&quot;, :age 21, :skills #{&quot;cobol&quot; &quot;rust&quot; &quot;cljs&quot; &quot;clj&quot; &quot;go&quot;}}

(def create-user [:=&gt; [:tuple Age] User])

(m/validate
  create-user
  (fn [age] {:name &quot;elephant&quot;, :age age, :skills #{&quot;cobol&quot;}})
  {::m/=&gt;validator mg/=&gt;validator})
; =&gt; true

;; invalid return
(m/validate
  create-user
  (fn [age] {:name &quot;elephant&quot;, :age age, :skills #{&quot;PERL&quot;}})
  {::m/=&gt;validator mg/=&gt;validator})
; =&gt; false

;; invalid arity
(m/validate
  create-user
  (fn [age _extra] {:name &quot;elephant&quot;, :age age, :skills #{&quot;cobol&quot;}})
  {::m/=&gt;validator mg/=&gt;validator})
; =&gt; false</pre></z></g><g id="s9"><z id="t1606231086" t="helios It&apos;s not clear how i could say that i want a non-empty map in my schema, that also works with generators 🙂"><y>#</y><d>2020-11-24</d><h>15:18</h><w>helios</w>It&apos;s not clear how i could say that i want a non-empty map in my schema, that also works with generators <b>🙂</b></z><z id="t1606231679" t="helios (mg/generate [:and [:fn not-empty] [:map-of [:string {:gen/gen gen/string-ascii}] [:string {:gen/gen gen/string-ascii}]]]) this ofc works for validation but not with generators"><y>#</y><d>2020-11-24</d><h>15:27</h><r>helios</r><pre>(mg/generate [:and
              [:fn not-empty]
              [:map-of
               [:string {:gen/gen gen/string-ascii}]
               [:string {:gen/gen gen/string-ascii}]]])</pre>
this ofc works for validation but not with generators</z><z id="t1606233213" t="ikitommi [:attrs {:href &quot;/_/_/users/U0AD3JSHL&quot;}] try reversing that, :map-of as first child. :and generates based on first, and narrows with the rest."><y>#</y><d>2020-11-24</d><h>15:53</h><r>ikitommi</r><a>@U0AD3JSHL</a> try reversing that, <code>:map-of</code> as first child. <code>:and</code> generates based on first, and narrows with the rest.</z><z id="t1606233260" t="helios uh, nice one 🙂"><y>#</y><d>2020-11-24</d><h>15:54</h><r>helios</r>uh, nice one <b>🙂</b></z><z id="t1606252745" t="Hankstenberg malli is absolutely awesome, thanks a lot guys! 👍"><y>#</y><d>2020-11-24</d><h>21:19</h><w>Hankstenberg</w>malli is absolutely awesome, thanks a lot guys! <b>👍</b></z><z id="t1606253382" t="ordnungswidrig Is there a “canonical representation” for malli? I guess it’s the “vector” syntax as opposed to the “map” syntax, right?"><y>#</y><d>2020-11-24</d><h>21:29</h><w>ordnungswidrig</w>Is there a “canonical representation” for malli? I guess it’s the “vector” syntax as opposed to the “map” syntax, right?</z><z id="t1606283102" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] is :: keys in this line a bug? https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L337"><y>#</y><d>2020-11-25</d><h>05:45</h><w>steveb8n</w><a>@ikitommi</a> is <b>::</b>keys in this line a bug? <a href="https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L337" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L337</a></z><z id="t1606283319" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] not a bug, it uses qualified keys for configuration: https://github.com/metosin/malli/blob/master/test/malli/transform_test.cljc#L207"><y>#</y><d>2020-11-25</d><h>05:48</h><r>ikitommi</r><a>@U0510KXTU</a> not a bug, it uses qualified keys for configuration: <a href="https://github.com/metosin/malli/blob/master/test/malli/transform_test.cljc#L207" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/transform_test.cljc#L207</a></z><z id="t1606283359" t="steveb8n ok. TIL a new destructing syntax 🙂"><y>#</y><d>2020-11-25</d><h>05:49</h><r>steveb8n</r>ok. TIL a new destructing syntax <b>🙂</b></z><z id="t1606283430" t="ikitommi yes, a handy way to do that. Also, {:keys [::json-vectors]} would work."><y>#</y><d>2020-11-25</d><h>05:50</h><r>ikitommi</r>yes, a handy way to do that. Also,
<code>{:keys [::json-vectors]}</code> would work.</z><z id="t1606283614" t="ikitommi [:attrs {:href &quot;/_/_/users/U054UD60U&quot;}] right, it the vector syntax for now."><y>#</y><d>2020-11-25</d><h>05:53</h><w>ikitommi</w><a>@ordnungswidrig</a> right, it the vector syntax for now.</z><z id="t1606304278" t="Elso is there something like a best-effort implementation of a json-schema to malli converter out there?"><y>#</y><d>2020-11-25</d><h>11:37</h><w>Elso</w>is there something like a best-effort implementation of a json-schema to malli converter out there?</z><z id="t1606317546" t="ikitommi [:attrs {:href &quot;/_/_/users/UU5KDUCBT&quot;}] don&apos;t think so, there is an old PR, but lot&apos;s of todos and last update from jul."><y>#</y><d>2020-11-25</d><h>15:19</h><w>ikitommi</w><a>@d.eltzner012</a> don&apos;t think so, there is an old PR, but lot&apos;s of todos and last update from jul.</z><z id="t1606317553" t="ikitommi https://github.com/metosin/malli/pull/211"><y>#</y><d>2020-11-25</d><h>15:19</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/211" target="_blank">https://github.com/metosin/malli/pull/211</a></z><z id="t1606317752" t="rutledgepaulv I have a half-baked implementation of this for converting kubernetes swagger into malli. I&apos;m using malli to write a clojure kubernetes client with client side validation of operations (similar to aws-api). It handles recursive schemas at least but some of the kubernetes swagger is on the janky side so i&apos;m sure it&apos;s not properly general. The whole library is still early stages. https://github.com/RutledgePaulV/kube-api/blob/master/kube-api-core/src/kube_api/core/swagger/malli.clj"><y>#</y><d>2020-11-25</d><h>15:22</h><r>rutledgepaulv</r>I have a half-baked implementation of this for converting kubernetes swagger into malli. I&apos;m using malli to write a clojure kubernetes client with client side validation of operations (similar to aws-api). It handles recursive schemas at least but some of the kubernetes swagger is on the janky side so i&apos;m sure it&apos;s not properly general. The whole library is still early stages. <a href="https://github.com/RutledgePaulV/kube-api/blob/master/kube-api-core/src/kube_api/core/swagger/malli.clj" target="_blank">https://github.com/RutledgePaulV/kube-api/blob/master/kube-api-core/src/kube_api/core/swagger/malli.clj</a></z><z id="t1606415600" t="ikitommi 👍"><y>#</y><d>2020-11-26</d><h>18:33</h><r>ikitommi</r><b>👍</b></z><z id="t1606724646" t="Elso 👍 very cool still, I&apos;ll have a look at it"><y>#</y><d>2020-11-30</d><h>08:24</h><r>Elso</r><b>👍</b> very cool still, I&apos;ll have a look at it</z><z id="t1606388546" t="Hankstenberg The more I look at it the more I want to use malli schemas as a single source of truth for everything. Are there any resources about generating ui models from malli schemas? I think the idea to integrate it with Domino was floating around once, but the current version doesn&apos;t mention malli. How else could it be done? My go-to framework for UI stuff is usually re-frame. Malli could be integrated so that re-frame&apos;s db is generated from it. And to validate state changes, of course. It could also be bound to visual representations of actual components I guess. Would be grateful for any reference to existing work in this area."><y>#</y><d>2020-11-26</d><h>11:02</h><w>Hankstenberg</w>The more I look at it the more I want to use malli schemas as a single source of truth for everything. Are there any resources about generating ui models from malli schemas? I think the idea to integrate it with Domino was floating around once, but the current version doesn&apos;t mention malli. How else could it be done? My go-to framework for UI stuff is usually re-frame. Malli could be integrated so that re-frame&apos;s db is generated from it. And to validate state changes, of course. It could also be bound to visual representations of actual components I guess. Would be grateful for any reference to existing work in this area.</z><z id="t1606401154" t="rutledgepaulv I have played with this a bit. I eventually came to a realization that I should first transform malli into an intermediate representation prior to generating the UI state because there are additional things you&apos;ll want to know about each node, like whether the field is &quot;dirty&quot; and has been &quot;visited&quot;, etc. So in other words.. first I would go through the work of figuring out a sensible IR and generating forms from that, and then work backwards and generate that initial IR from malli."><y>#</y><d>2020-11-26</d><h>14:32</h><r>rutledgepaulv</r>I have played with this a bit. I eventually came to a realization that I should first transform malli into an intermediate representation prior to generating the UI state because there are additional things you&apos;ll want to know about each node, like whether the field is &quot;dirty&quot; and has been &quot;visited&quot;, etc. So in other words.. first I would go through the work of figuring out a sensible IR and generating forms from that, and then work backwards and generate that initial IR from malli.</z><z id="t1606401313" t="rutledgepaulv That said, my initial attempt of using malli directly (and still struggling with how to do the reagent cursors) is here: https://rutledgepaulv.github.io/ui-kit/#!/ui_kit.forms https://github.com/RutledgePaulV/ui-kit/blob/master/src/cljs/ui_kit/visitors.cljs"><y>#</y><d>2020-11-26</d><h>14:35</h><r>rutledgepaulv</r>That said, my initial attempt of using malli directly (and still struggling with how to do the reagent cursors) is here: <a href="https://rutledgepaulv.github.io/ui-kit/#!/ui_kit.forms" target="_blank">https://rutledgepaulv.github.io/ui-kit/#!/ui_kit.forms</a> <a href="https://github.com/RutledgePaulV/ui-kit/blob/master/src/cljs/ui_kit/visitors.cljs" target="_blank">https://github.com/RutledgePaulV/ui-kit/blob/master/src/cljs/ui_kit/visitors.cljs</a></z><z id="t1606416799" t="ikitommi Have seen multiple prototypes. Did also a demo into on of our projects. There is malli.util/subschemas helper which takes a Schema and returns an ordered list of all the schema paths and Schemas in those, handling also collection schemas. One place to start. Also, one can post-walk the Schemas and wrap all schmas into something that can be used to strore the form state (dirty, pristine, etc). hope this helps."><y>#</y><d>2020-11-26</d><h>18:53</h><r>ikitommi</r>Have seen multiple prototypes. Did also a demo into on of our projects. There is <code>malli.util/subschemas</code> helper which takes a Schema and returns an ordered list of all the schema paths and Schemas in those, handling also collection schemas. One place to start. Also, one can post-walk the Schemas and wrap all schmas into something that can be used to strore the form state (dirty, pristine, etc). hope this helps.</z><z id="t1606417151" t="ikitommi"><y>#</y><d>2020-11-26</d><h>18:59</h><r>ikitommi</r></z><z id="t1606719231" t="Hankstenberg Thanks a lot for the input! I&apos;m still trying to wrap my head around everything. I think Datascript (re-posh)+datasync are the right tools to connect front-end state and back-end state, I think I will try to find a way to make this stack (malli-)schema-driven."><y>#</y><d>2020-11-30</d><h>06:53</h><r>Hankstenberg</r>Thanks a lot for the input! I&apos;m still trying to wrap my head around everything. I think Datascript (re-posh)+datasync are the right tools to connect front-end state and back-end state, I think I will try to find a way to make this stack (malli-)schema-driven.</z><z id="t1606416799" t="ikitommi Have seen multiple prototypes. Did also a demo into on of our projects. There is malli.util/subschemas helper which takes a Schema and returns an ordered list of all the schema paths and Schemas in those, handling also collection schemas. One place to start. Also, one can post-walk the Schemas and wrap all schmas into something that can be used to strore the form state (dirty, pristine, etc). hope this helps."><y>#</y><d>2020-11-26</d><h>18:53</h><w>ikitommi</w>Have seen multiple prototypes. Did also a demo into on of our projects. There is <code>malli.util/subschemas</code> helper which takes a Schema and returns an ordered list of all the schema paths and Schemas in those, handling also collection schemas. One place to start. Also, one can post-walk the Schemas and wrap all schmas into something that can be used to strore the form state (dirty, pristine, etc). hope this helps.</z><z id="t1606417425" t="rutledgepaulv Wonder if there&apos;s an opportunity to improve error messages here:"><y>#</y><d>2020-11-26</d><h>19:03</h><w>rutledgepaulv</w>Wonder if there&apos;s an opportunity to improve error messages here:</z><z id="t1606417431" t="rutledgepaulv (def stream (logs client {:operation &quot;readCoreV1NamespacedPodLog&quot;} {})) Execution error (ExceptionInfo) at kube-api.utils/validation-error (utils.clj:87). Invalid request. {:path-params [&quot;missing required key&quot;]} (def stream (logs client {:operation &quot;readCoreV1NamespacedPodLog&quot;} {:path-params {}})) Execution error (ExceptionInfo) at kube-api.utils/validation-error (utils.clj:87). Invalid request. {:path-params {:name [&quot;missing required key&quot;], :namespace [&quot;missing required key&quot;]}} "><y>#</y><d>2020-11-26</d><h>19:03</h><w>rutledgepaulv</w><pre>(def stream
  (logs client
        {:operation &quot;readCoreV1NamespacedPodLog&quot;}
        {}))
Execution error (ExceptionInfo) at kube-api.utils/validation-error (utils.clj:87).
Invalid request.
{:path-params [&quot;missing required key&quot;]}

(def stream
  (logs client
        {:operation &quot;readCoreV1NamespacedPodLog&quot;}
        {:path-params {}}))
Execution error (ExceptionInfo) at kube-api.utils/validation-error (utils.clj:87).
Invalid request.
{:path-params
 {:name [&quot;missing required key&quot;], :namespace [&quot;missing required key&quot;]}}</pre>
</z><z id="t1606417476" t="rutledgepaulv if there&apos;s a missing key, insert the key with an empty value and run validation on that empty value too so you can report not only the missing collection but also what needs to be in the collection?"><y>#</y><d>2020-11-26</d><h>19:04</h><w>rutledgepaulv</w>if there&apos;s a missing key, insert the key with an empty value and run validation on that empty value too so you can report not only the missing collection but also what needs to be in the collection?</z><z id="t1606417492" t="rutledgepaulv probably breaks down in some edge cases.. thinking"><y>#</y><d>2020-11-26</d><h>19:04</h><w>rutledgepaulv</w>probably breaks down in some edge cases.. thinking</z><z id="t1606417583" t="ikitommi you could run default-value-transformer to add empty maps first."><y>#</y><d>2020-11-26</d><h>19:06</h><w>ikitommi</w>you could run <code>default-value-transformer</code> to add empty maps first.</z><z id="t1606417708" t="ikitommi (m/decode [:map [:path-params [:map [:name :string] [:description :string]]]] nil (mt/default-value-transformer {:defaults {:map (constantly {}) :string (constantly &quot;&quot;)}})) ; =&gt; {:path-params {:name &quot;&quot;, :description &quot;&quot;}}"><y>#</y><d>2020-11-26</d><h>19:08</h><w>ikitommi</w><pre>(m/decode
  [:map
   [:path-params [:map
                  [:name :string]
                  [:description :string]]]]
  nil
  (mt/default-value-transformer
    {:defaults {:map (constantly {})
                :string (constantly &quot;&quot;)}}))
; =&gt; {:path-params {:name &quot;&quot;, :description &quot;&quot;}}</pre></z><z id="t1606418078" t="rutledgepaulv thanks! yes, that&apos;s working for me"><y>#</y><d>2020-11-26</d><h>19:14</h><w>rutledgepaulv</w>thanks! yes, that&apos;s working for me</z><z id="t1606658717" t="joshkh noob question, but how can i validate/generate non-blank strings? with spec i would use (complement clojure.string/blank?) . (m/validate [:map [:name [:and string? (complement clojure.string/blank?)]]] {:name &quot;&quot;}) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema #object[clojure.core$complement$fn__5669 0x394ebe0b &quot; "><y>#</y><d>2020-11-29</d><h>14:05</h><w>joshkh</w>noob question, but how can i validate/generate non-blank strings? with spec i would use <code>(complement clojure.string/blank?)</code> .
<pre>(m/validate [:map [:name [:and string? (complement clojure.string/blank?)]]] {:name &quot;&quot;})
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema #object[clojure.core$complement$fn__5669 0x394ebe0b &quot;</pre>
</z><z id="t1606660784" t="joshkh this validates, but fails on generation (m/validate [:map [:name [:fn (complement clojure.string/blank?)]]] {:name &quot;test&quot;})"><y>#</y><d>2020-11-29</d><h>14:39</h><r>joshkh</r>this validates, but fails on generation
<pre>(m/validate [:map [:name [:fn (complement clojure.string/blank?)]]] {:name &quot;test&quot;})</pre></z><z id="t1606662819" t="eval2020 [:attrs {:href &quot;/_/_/users/U0GC1C09L&quot;}] the README has [:string {:min 1}] as example."><y>#</y><d>2020-11-29</d><h>15:13</h><r>eval2020</r><a>@U0GC1C09L</a> the README has <code>[:string {:min 1}]</code>  as example.</z><z id="t1606663091" t="joshkh not sure how i missed that. thanks eval2020."><y>#</y><d>2020-11-29</d><h>15:18</h><r>joshkh</r>not sure how i missed that. thanks eval2020.</z><z id="t1606664128" t="ikitommi I think there should be a built-in complement."><y>#</y><d>2020-11-29</d><h>15:35</h><r>ikitommi</r>I think there should be a built-in complement.</z><z id="t1606664137" t="ikitommi doesn’t exist, but should."><y>#</y><d>2020-11-29</d><h>15:35</h><r>ikitommi</r>doesn’t exist, but should.</z><z id="t1656751974" t="Eric Dvorsak [:string {:min 1}] isn&apos;t the same, the string could still be blank, eg &quot; &quot;"><y>#</y><d>2022-07-02</d><h>08:52</h><r>Eric Dvorsak</r>[:string {:min 1}] isn&apos;t the same, the string could still be blank, eg <code>&quot;      &quot;</code></z><z id="t1606664203" t="ikitommi merged into master the current status of function schemas, alpha, feedback welcome! the guide is here: https://github.com/metosin/malli#function-schemas"><y>#</y><d>2020-11-29</d><h>15:36</h><w>ikitommi</w>merged into master the current status of function schemas, alpha, feedback welcome! the guide is here: <a href="https://github.com/metosin/malli#function-schemas" target="_blank">https://github.com/metosin/malli#function-schemas</a></z><z id="t1606664216" t="ikitommi and the PR https://github.com/metosin/malli/pull/306"><y>#</y><d>2020-11-29</d><h>15:36</h><r>ikitommi</r>and the PR <a href="https://github.com/metosin/malli/pull/306" target="_blank">https://github.com/metosin/malli/pull/306</a></z><z id="t1606664252" t="ikitommi also has now the full clj-kondo integration !!"><y>#</y><d>2020-11-29</d><h>15:37</h><w>ikitommi</w>also has now the full <b>clj-kondo</b>  integration !!</z><z id="t1606664305" t="ikitommi will make a separate PR of the optional plumatic-style helpers."><y>#</y><d>2020-11-29</d><h>15:38</h><w>ikitommi</w>will make a separate PR of the optional plumatic-style helpers.</z><z id="t1606664405" t="ikitommi there are now var instrumentation helpers atm, only shipped use case is the clj-kondo type checker integration. Any ideas what would be a good api to instrument functions in dev to run the input &amp; output checks?"><y>#</y><d>2020-11-29</d><h>15:40</h><w>ikitommi</w>there are now var instrumentation helpers atm, only shipped use case is the clj-kondo type checker integration. Any ideas what would be a good api to instrument functions in dev to run the input &amp; output checks?</z><z id="t1606664425" t="ikitommi any ideas about clojure.test helpers for malli?"><y>#</y><d>2020-11-29</d><h>15:40</h><w>ikitommi</w>any ideas about <code>clojure.test</code> helpers for malli?</z><z id="t1606664511" t="ikitommi dev-time tooling has not been the goal for malli (as it’s the primary goal for spec already), but happy to add things to that direction too."><y>#</y><d>2020-11-29</d><h>15:41</h><w>ikitommi</w>dev-time tooling has not been the goal for malli (as it’s the primary goal for spec already), but happy to add things to that direction too.</z><z id="t1606664549" t="ikitommi with spec, have used https://github.com/jeaye/orchestra , I guess like everyone else 🙂"><y>#</y><d>2020-11-29</d><h>15:42</h><w>ikitommi</w>with spec, have used <a href="https://github.com/jeaye/orchestra" target="_blank">https://github.com/jeaye/orchestra</a>, I guess like everyone else <b>🙂</b></z><z id="t1606720958" t="Hankstenberg Quick question: Is is possible to combine malli and spec-tools in order to get both, the JSON schema and the API schema? Do you plan to extend spec-tools or malli? Actually it has to be malli right? Yesterday I realized how awesome programatically updating malli specs is. You can have a complex user schema with an &quot;:active&quot; boolean in in and all you need to do to specify an inactive user is to say (def inactive-user (mu/assoc user :active [:enum false]). It&apos;s like a language-agnostic type that would be perfectly exportable to e.g. openapi3 and JSON form to make use of the tools available for these standards. (trying to find good reasons to introduce clojure with malli as a way to generate openapi/json schema in our company that uses them)."><y>#</y><d>2020-11-30</d><h>07:22</h><w>Hankstenberg</w>Quick question: Is is possible to combine malli and spec-tools in order to get both, the JSON schema and the API schema? Do you plan to extend spec-tools or malli? Actually it has to be malli right? Yesterday I realized how awesome programatically updating malli specs is. You can have a complex user schema with an &quot;:active&quot; boolean in in and all you need to do to specify an inactive user is to say (def inactive-user (mu/assoc user :active [:enum false]). It&apos;s like a language-agnostic type that would be perfectly exportable to e.g. openapi3 and JSON form to make use of the tools available for these standards. (trying to find good reasons to introduce clojure with malli as a way to generate openapi/json schema in our company that uses them).</z><z id="t1607192083" t="ikitommi Slow answer 😉 : I’m not sure I understand the question, but you can generate JSON Schema from malli. Glad you like it."><y>#</y><d>2020-12-05</d><h>18:14</h><r>ikitommi</r>Slow answer <b>😉</b> : I’m not sure I understand the question, but you can generate JSON Schema from malli. Glad you like it.</z><z id="t1607324834" t="Hankstenberg Yea, I know and I&apos;m loving it. I&apos;d like to experiment a bit with API-Driven development at our company. OpenApi is nice, but who wants to write JSON/YAML by hand when you can write edn instead and programmatically create JSON Schema and OpenAPI-Specs from that. The JSON Schema part is covered nicely by malli, which is wonderful, because we can utilize the nice ecosystem that uses JSON Schema already AND have the power of property-based testing. But what about speccing the endpoints? There is spec-tools, but spec-tools uses clojure.spec instead of malli. I imagine that I could e.g. specify an &quot;Order&quot; schema and a &quot;Processed Order&quot; schema in order to specify an entity and an entity in a certain state (with &quot;processed&quot; set to &quot;true&quot; and a &quot;processed-on&quot; field set to some date and so on. With the ability to even spec functions with malli, we have all the building blocks to extend malli&apos;s capabilities to also specify the actual API: (def =&gt;process-oder [:=&gt; [:tuple entities/order events/process-order] entities/processed-order]) Now all that&apos;s missing is to map this to e.g. a POST request and generate a complete openapi-spec from it (schema+end points), so that e.g. a REST-Client can be generated from this code. At least that&apos;s how I would imagine it. Maybe I&apos;m on the wrong track here, though."><y>#</y><d>2020-12-07</d><h>07:07</h><r>Hankstenberg</r>Yea, I know and I&apos;m loving it. I&apos;d like to experiment a bit with API-Driven development at our company. OpenApi is nice, but who wants to write JSON/YAML by hand when you can write edn instead and programmatically create JSON Schema and OpenAPI-Specs from that. The JSON Schema part is covered nicely by malli, which is wonderful, because we can utilize the nice ecosystem that uses JSON Schema already AND have the power of property-based testing.

But what about speccing the endpoints? There is spec-tools, but spec-tools uses clojure.spec instead of malli. I imagine that I could e.g. specify an &quot;Order&quot; schema and a &quot;Processed Order&quot; schema in order to specify an entity and an entity in a certain state (with &quot;processed&quot; set to &quot;true&quot; and a &quot;processed-on&quot; field set to some date and so on.

With the ability to even spec functions with malli, we have all the building blocks to extend malli&apos;s capabilities to also specify the actual API:

(def =&gt;process-oder [:=&gt; [:tuple entities/order events/process-order] entities/processed-order])

Now all that&apos;s missing is to map this to e.g. a POST request and generate a complete openapi-spec from it (schema+end points), so that e.g. a REST-Client can be generated from this code.

At least that&apos;s how I would imagine it. Maybe I&apos;m on the wrong track here, though.</z><z id="t1607326605" t="ikitommi have you looked at reitit-malli ? here’s an example: https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger"><y>#</y><d>2020-12-07</d><h>07:36</h><r>ikitommi</r>have you looked at <code>reitit-malli</code>? here’s an example: <a href="https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger" target="_blank">https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger</a></z><z id="t1607331555" t="Hankstenberg That&apos;s the best possible reply. Yes, there already is something and btw it&apos;s even better than what you had in mind. Thanks a bunch! 👍"><y>#</y><d>2020-12-07</d><h>08:59</h><r>Hankstenberg</r>That&apos;s the best possible reply. Yes, there already is something and btw it&apos;s even better than what you had in mind. Thanks a bunch! <b>👍</b></z><z id="t1606835136" t="mynomoto About the clj-kondo integration, is malli annotations compatible with the clj-kondo ones? As in if something is typed string on malli and is passed to a core function that only accepts numbers, will it show as a warning?"><y>#</y><d>2020-12-01</d><h>15:05</h><w>mynomoto</w>About the <b>clj-kondo</b> integration, is malli annotations compatible with the clj-kondo ones? As in if something is typed string on malli and is passed to a core function that only accepts numbers, will it show as a warning?</z><z id="t1606835193" t="borkdude [:attrs {:href &quot;/_/_/users/U05094X3J&quot;}] this doesn&apos;t work automatically, you should execute some code to make malli spit out type information to a clj-kondo config directory and you should opt in to this config dir via :config-paths"><y>#</y><d>2020-12-01</d><h>15:06</h><w>borkdude</w><a>@mynomoto</a> this doesn&apos;t work automatically, you should execute some code to make malli spit out type information to a clj-kondo config directory and you should opt in to this config dir via :config-paths</z><z id="t1606835346" t="mynomoto I&apos;m assuming that the developer did the correct project configuration. The question is more about if a malli string is a clj-kondo string when doing the type inference."><y>#</y><d>2020-12-01</d><h>15:09</h><r>mynomoto</r>I&apos;m assuming that the developer did the correct project configuration.
The question is more about if a malli string is a clj-kondo string when doing the type inference.</z><z id="t1606835434" t="borkdude [:attrs {:href &quot;/_/_/users/U05094X3J&quot;}] it should: https://github.com/metosin/malli/blob/23772defaa6223529edc316fd1ba8fb0c87ae3f0/src/malli/clj_kondo.cljc#L23"><y>#</y><d>2020-12-01</d><h>15:10</h><r>borkdude</r><a>@mynomoto</a> it should:
<a href="https://github.com/metosin/malli/blob/23772defaa6223529edc316fd1ba8fb0c87ae3f0/src/malli/clj_kondo.cljc#L23" target="_blank">https://github.com/metosin/malli/blob/23772defaa6223529edc316fd1ba8fb0c87ae3f0/src/malli/clj_kondo.cljc#L23</a></z><z id="t1606835634" t="mynomoto This is great, thanks! I was wondering if a project to add malli type annotations to core functions would be useful for type inference but I&apos;m glad that it is not necessary."><y>#</y><d>2020-12-01</d><h>15:13</h><r>mynomoto</r>This is great, thanks! I was wondering if a project to add malli type annotations to core functions would be useful for type inference but I&apos;m glad that it is not necessary.</z><z id="t1607089157" t="Adrian Smith Hey I&apos;m trying out the clj-kondo integration, I&apos;ve used the latest sha for malli in my deps.edn and have a working clj-kondo installation, I can see some clj-kondo configuration has been emitted by malli but the plus example doesn&apos;t appear to be erroring, is this ready for looking at?"><y>#</y><d>2020-12-04</d><h>13:39</h><w>Adrian Smith</w>Hey I&apos;m trying out the clj-kondo integration, I&apos;ve used the latest sha for malli in my deps.edn and have a working clj-kondo installation, I can see some clj-kondo configuration has been emitted by malli but the plus example doesn&apos;t appear to be erroring, is this ready for looking at?</z><z id="t1607182413" t="rutledgepaulv is there a recommended way to write a function that will dispatch to an implementation according to which of several schemas match my input arguments? I can construct my own of course that just does a linear search, and i could create a multi schema to compose them together (though i would need to use a compound discriminator for my case). I guess what i&apos;m wondering is if there&apos;s a way to do pattern matching using malli schemas, but preferably in an open way like multimethods so i can just accrete new cases instead of modifying a case expression."><y>#</y><d>2020-12-05</d><h>15:33</h><w>rutledgepaulv</w>is there a recommended way to write a function that will dispatch to an implementation according to which of several schemas match my input arguments? I can construct my own of course that just does a linear search, and i could create a multi schema to compose them together (though i would need to use a compound discriminator for my case). I guess what i&apos;m wondering is if there&apos;s a way to do pattern matching using malli schemas, but preferably in an open way like multimethods so i can just accrete new cases instead of modifying a case expression.</z><z id="t1607182548" t="rutledgepaulv maybe i&apos;m just rubbing up against open arbitrary predicate dispatch at that point. hm"><y>#</y><d>2020-12-05</d><h>15:35</h><w>rutledgepaulv</w>maybe i&apos;m just rubbing up against open arbitrary predicate dispatch at that point. hm</z><z id="t1607182629" t="rutledgepaulv perhaps i could add an optional attribute on each schema (in my case they are open maps so this is fine) and supply a :default attribute. then i can run a default transformer on my inbound value to inject a &quot;type&quot; and from there just use regular multimethods to dispatch on that attribute."><y>#</y><d>2020-12-05</d><h>15:37</h><w>rutledgepaulv</w>perhaps i could add an optional attribute on each schema (in my case they are open maps so this is fine) and supply a :default attribute. then i can run a default transformer on my inbound value to inject a &quot;type&quot; and from there just use regular multimethods to dispatch on that attribute.</z><z id="t1607183823" t="rutledgepaulv yeah that works. sorta rough and not sure the macro is a good idea but in case anyone is curious:"><y>#</y><d>2020-12-05</d><h>15:57</h><w>rutledgepaulv</w>yeah that works. sorta rough and not sure the macro is a good idea but in case anyone is curious:</z><z id="t1607183827" t="rutledgepaulv (defn dispatchable [dispatch-key schema] (mu/update-properties schema (fn [props] (let [dispatch-decoder (fn [value] (with-meta value {:dispatch dispatch-key}))] (assoc-in props [:decode/dispatch] {:leave dispatch-decoder}))))) (defn dispatch-key [schema value] (some-&gt; (m/decode schema value (mt/transformer {:name :dispatch})) meta :dispatch)) (defmacro defdispatchable [symbol &amp; body] `(def ~symbol (dispatchable ~(name symbol) (do "><y>#</y><d>2020-12-05</d><h>15:57</h><w>rutledgepaulv</w><pre>(defn dispatchable [dispatch-key schema]
  (mu/update-properties
    schema
    (fn [props]
      (let [dispatch-decoder (fn [value] (with-meta value {:dispatch dispatch-key}))]
        (assoc-in props [:decode/dispatch] {:leave dispatch-decoder})))))

(defn dispatch-key [schema value]
  (some-&gt; (m/decode schema value (mt/transformer {:name :dispatch})) meta :dispatch))

(defmacro defdispatchable [symbol &amp; body]
  `(def ~symbol (dispatchable ~(name symbol) (do </pre>
</z><z id="t1607183839" t="rutledgepaulv (handle-auth {:tokenFile &quot;st&quot;}) token file! =&gt; nil (handle-auth {:client-key-data &quot;st&quot; :client-certificate-data &quot;sfd&quot;}) client key! "><y>#</y><d>2020-12-05</d><h>15:57</h><w>rutledgepaulv</w><pre>(handle-auth {:tokenFile &quot;st&quot;})
token file!
=&gt; nil
(handle-auth {:client-key-data &quot;st&quot; 
              :client-certificate-data &quot;sfd&quot;})
client key!</pre>
</z><z id="t1607185231" t="rutledgepaulv Actually, i think this is much better:"><y>#</y><d>2020-12-05</d><h>16:20</h><w>rutledgepaulv</w>Actually, i think this is much better:</z><z id="t1607185234" t="rutledgepaulv (def schema-resolver-transformer (mt/transformer {:default-decoder {:compile (fn [schema _] (fn [value] (if (instance? IObj value) (vary-meta value assoc :resolved schema) value)))}})) (defn resolve-schema [schema value] (some-&gt; (m/decode schema value schema-resolver-transformer) (meta) :resolved)) (def token-file-auth [:map {:dispatch :token-file} [:tokenFile :string]]) (def client-key-auth [:map {:dispatch :client-key} [:client-key-data :string] [:client-certificate-data :string]]) (def combined [:or token-file-auth client-key-auth]) (defn dispatch-fn [context] (let [schema (resolve-schema combined context)] (:dispatch (m/properties schema)))) (defmulti handle-auth #&apos;dispatch-fn) (defmethod handle-auth :token-file [context] (println &quot;token file!&quot;)) (defmethod handle-auth :client-key [context] (println &quot;client key!&quot;))"><y>#</y><d>2020-12-05</d><h>16:20</h><w>rutledgepaulv</w><pre>(def schema-resolver-transformer
  (mt/transformer
    {:default-decoder
     {:compile (fn [schema _]
                 (fn [value]
                   (if (instance? IObj value)
                     (vary-meta value assoc :resolved schema)
                     value)))}}))

(defn resolve-schema [schema value]
  (some-&gt; (m/decode schema value schema-resolver-transformer) (meta) :resolved))

(def token-file-auth
  [:map {:dispatch :token-file}
   [:tokenFile :string]])

(def client-key-auth
  [:map {:dispatch :client-key}
   [:client-key-data :string]
   [:client-certificate-data :string]])

(def combined
  [:or token-file-auth client-key-auth])

(defn dispatch-fn [context]
  (let [schema (resolve-schema combined context)]
    (:dispatch (m/properties schema))))

(defmulti handle-auth #&apos;dispatch-fn)

(defmethod handle-auth :token-file [context]
  (println &quot;token file!&quot;))

(defmethod handle-auth :client-key [context]
  (println &quot;client key!&quot;))</pre></z><z id="t1607185850" t="rutledgepaulv Tommi, let me know if there&apos;s a better way to do this ^. Providing a way to resolve the concrete schema that is used for each node in a tree of data allows me to put useful data into the schema properties and recover that data for a given value so that i can act on it (like dispatching to different functions in my code based on which schema matched). Here i am attaching the schema to the data as metadata (which makes sense but will not work for values that don&apos;t implement IObj)"><y>#</y><d>2020-12-05</d><h>16:30</h><w>rutledgepaulv</w>Tommi, let me know if there&apos;s a better way to do this ^. Providing a way to resolve the concrete schema that is used for each node in a tree of data allows me to put useful data into the schema properties and recover that data for a given value so that i can act on it (like dispatching to different functions in my code based on which schema matched). Here i am attaching the schema to the data as metadata (which makes sense but will not work for values that don&apos;t implement IObj)</z><z id="t1607191697" t="ikitommi [:attrs {:href &quot;/_/_/users/UCJCPTW8J&quot;}] [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I think one needs to add extra entry into :config-paths into .clj-kondo/config.edn . I have the following: ✗ cat .clj-kondo/config.edn {:config-paths [&quot;configs/malli&quot;]} forgot all about that, will add it to README if that is the required glue here."><y>#</y><d>2020-12-05</d><h>18:08</h><w>ikitommi</w><a>@sfyire</a> <a>@borkdude</a> I think one needs to add extra entry into <code>:config-paths</code> into <code>.clj-kondo/config.edn</code>. I have the following:
<pre>✗ cat .clj-kondo/config.edn
{:config-paths [&quot;configs/malli&quot;]}</pre>
forgot all about that, will add it to README if that is the required glue here.</z><z id="t1607191967" t="ikitommi https://github.com/metosin/malli/commit/da45eceaea3e5b34426027bf7836e7cbe841cc97"><y>#</y><d>2020-12-05</d><h>18:12</h><r>ikitommi</r><a href="https://github.com/metosin/malli/commit/da45eceaea3e5b34426027bf7836e7cbe841cc97" target="_blank">https://github.com/metosin/malli/commit/da45eceaea3e5b34426027bf7836e7cbe841cc97</a></z><z id="t1607191724" t="ikitommi would be great if that was not needed and it would just work."><y>#</y><d>2020-12-05</d><h>18:08</h><w>ikitommi</w>would be great if that was not needed and it would just work.</z><z id="t1607191759" t="ikitommi e.g. with that, clj-kondo pics up the emitted file, looking something like this: ✗ cat .clj-kondo/configs/malli/config.edn {:lint-as #:malli.schema{defn schema.core/defn} :linters {:type-mismatch {:namespaces {user {square {:arities {1 {:args [:int], :ret :nat-int}}} plus {:arities {1 {:args [:int], :ret :int} 2 {:args [:int :int], :ret :int}}}}}}}}"><y>#</y><d>2020-12-05</d><h>18:09</h><w>ikitommi</w>e.g. with that, clj-kondo pics up the emitted file, looking something like this:
<pre>✗ cat .clj-kondo/configs/malli/config.edn
{:lint-as #:malli.schema{defn schema.core/defn}
 :linters {:type-mismatch {:namespaces {user {square {:arities {1 {:args [:int], :ret :nat-int}}}
                                              plus {:arities {1 {:args [:int], :ret :int}
                                                              2 {:args [:int :int], :ret :int}}}}}}}}</pre></z><z id="t1607193084" t="ikitommi [:attrs {:href &quot;/_/_/users/U5RCSJ6BB&quot;}] your second options looks interesting, tagging values. I most likely would do it like that. One problem I see with this approach is that the meta-data can get out-of-sync: if your say (dissoc data :tokenFile) , it still is tagged as :token-file , but it not anymore valid against that schema. Might not be a problem if you just use it once, but relying of :resolved meta in general has not guarantees. The Schema parsing is currently WIP (first release coming soon), with that, you will have a variant to :or (and :alt ), which will have named branches, like spec does, so you can say ~about this: (def token-file-auth [:map [:tokenFile :string]]) (def client-key-auth [:map [:client-key-data :string] [:client-certificate-data :string]]) ;; using named :or variant (def combined [:or* [:token-file token-file-auth] [:client-key client-key-auth]]) (m/parse combined {:token-file &quot;kikka&quot;}) ; =&gt; #Branch{:key :token-file :value {:token-file &quot;kikka&quot;}} "><y>#</y><d>2020-12-05</d><h>18:31</h><w>ikitommi</w><a>@rutledgepaulv</a> your second options looks interesting, tagging values. I most likely would do it like that. One problem I see with this approach is that the meta-data can get out-of-sync: if your say <code>(dissoc data :tokenFile)</code> , it still is tagged as <code>:token-file</code>, but it not anymore valid against that schema. Might not be a problem if you just use it once, but relying of <code>:resolved</code> meta in general has not guarantees.

The Schema parsing is currently WIP (first release coming soon), with that, you will have a variant to <code>:or</code> (and <code>:alt</code>), which will have named branches, like spec does, so you can say ~about this:

<pre>(def token-file-auth
  [:map
   [:tokenFile :string]])

(def client-key-auth
  [:map
   [:client-key-data :string]
   [:client-certificate-data :string]])

;; using named :or variant
(def combined
  [:or*
    [:token-file token-file-auth]
    [:client-key client-key-auth]])

(m/parse combined {:token-file &quot;kikka&quot;})
; =&gt; #Branch{:key :token-file 
             :value {:token-file &quot;kikka&quot;}}</pre>
</z><z id="t1607193255" t="rutledgepaulv thanks! the schema parsing stuff looks like that would address my issue too"><y>#</y><d>2020-12-05</d><h>18:34</h><w>rutledgepaulv</w>thanks! the schema parsing stuff looks like that would address my issue too</z><z id="t1607193264" t="ikitommi you could also use m/encode and return a tuple yourself, with both the schema/name and the value."><y>#</y><d>2020-12-05</d><h>18:34</h><w>ikitommi</w>you could also use <code>m/encode</code> and return a tuple yourself, with both the schema/name and the value.</z><z id="t1607193314" t="rutledgepaulv yeah. in my case i only need to know the concrete version of the top level schema so tuples would be fine"><y>#</y><d>2020-12-05</d><h>18:35</h><w>rutledgepaulv</w>yeah. in my case i only need to know the concrete version of the top level schema so tuples would be fine</z><z id="t1607588630" t="Kari Marttila https://www.youtube.com/watch?v=bQDkuF6-py4 , Tommi’s presentation in London Clojurians. This is a great presentation. The presentation does a great job explaining the differences between different data validation libraries and the various ways you can utilize the malli library for data validation."><y>#</y><d>2020-12-10</d><h>08:23</h><w>Kari Marttila</w><a href="https://www.youtube.com/watch?v=bQDkuF6-py4" target="_blank">https://www.youtube.com/watch?v=bQDkuF6-py4</a>, Tommi’s presentation in London Clojurians. This is a great presentation. The presentation does a great job explaining the differences between different data validation libraries and the various ways you can utilize the malli library for data validation.</z><z id="t1607588790" t="Kari Marttila I found particularly interesting the beginning of the presentation. Tommi does a good job visualizing how Plumatic Schema, Spec and Malli specify an example data."><y>#</y><d>2020-12-10</d><h>08:26</h><r>Kari Marttila</r>I found particularly interesting the beginning of the presentation. Tommi does a good job visualizing how Plumatic Schema, Spec and Malli specify an example data.</z><z id="t1607589849" t="borkdude Are the slides available publically?"><y>#</y><d>2020-12-10</d><h>08:44</h><w>borkdude</w>Are the slides available publically?</z><z id="t1607590039" t="dharrigan That was a great talk btw. I use malli (with Reitit) a lot!"><y>#</y><d>2020-12-10</d><h>08:47</h><w>dharrigan</w>That was a great talk btw. I use malli (with Reitit) a lot!</z><z id="t1607591021" t="ikitommi thanks!"><y>#</y><d>2020-12-10</d><h>09:03</h><w>ikitommi</w>thanks!</z><z id="t1607591027" t="ikitommi slides are here: https://www2.slideshare.net/metosin/designing-with-malli"><y>#</y><d>2020-12-10</d><h>09:03</h><w>ikitommi</w>slides are here: <a href="https://www2.slideshare.net/metosin/designing-with-malli" target="_blank">https://www2.slideshare.net/metosin/designing-with-malli</a></z><z id="t1607908261" t="rutledgepaulv I am a little confused by map entries in malli. I see that i can use malli.core/entries to get k/v tuples where the v is a reified :malli.core/val schema that contains the entry&apos;s properties, but i sort of expected the map entry itself to also be a reified schema node that I could interrogate properties from. For now I am listing all entries and seeking to find the one that matches my key since malli.util/get returns the value not wrapped in a :malli.core/val and so is missing entry properties"><y>#</y><d>2020-12-14</d><h>01:11</h><w>rutledgepaulv</w>I am a little confused by map entries in malli. I see that i can use <code>malli.core/entries</code> to get k/v tuples where the v is a reified <code>:malli.core/val</code> schema that contains the entry&apos;s properties, but i sort of expected the map entry itself to also be a reified schema node that I could interrogate properties from. For now I am listing all entries and seeking to find the one that matches my key since <code>malli.util/get</code> returns the value not wrapped in a <code>:malli.core/val</code>  and so is missing entry properties</z><z id="t1607908281" t="rutledgepaulv It might be nice if malli.util contained a &quot;find&quot; like &quot;clojure.core/find&quot; for getting a map entry given a key in constant time"><y>#</y><d>2020-12-14</d><h>01:11</h><w>rutledgepaulv</w>It might be nice if malli.util contained a &quot;find&quot; like &quot;clojure.core/find&quot; for getting a map entry given a key in constant time</z><z id="t1607908340" t="rutledgepaulv am i missing something? i&apos;m sure map entries are some of the clunkier things to deal with"><y>#</y><d>2020-12-14</d><h>01:12</h><w>rutledgepaulv</w>am i missing something? i&apos;m sure map entries are some of the clunkier things to deal with</z><z id="t1607908438" t="rutledgepaulv Maybe what i am missing is that my property is really about the &quot;value&quot; and not about the map entry and so i put it in the wrong place."><y>#</y><d>2020-12-14</d><h>01:13</h><w>rutledgepaulv</w>Maybe what i am missing is that my property is really about the &quot;value&quot; and not about the map entry and so i put it in the wrong place.</z><z id="t1608376423" t="raymcdermott Hey [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] we recently had [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] on defn and he took issue with my pronunciation of Malli. But just listened to your excellent talk at re:Clojure and your pronunciation matches my own. He thinks you’re wrong 😂"><y>#</y><d>2020-12-19</d><h>11:13</h><w>raymcdermott</w>Hey <a>@ikitommi</a> we recently had <a>@dominicm</a> on defn and he took issue with my pronunciation of Malli. But just listened to your excellent talk at re:Clojure and your pronunciation matches my own. He thinks you’re wrong <b>😂</b></z><z id="t1608376459" t="raymcdermott Is it your Tampere accent?"><y>#</y><d>2020-12-19</d><h>11:14</h><w>raymcdermott</w>Is it your Tampere accent?</z><z id="t1608376510" t="dominicm Oh no, ousted! I don&apos;t even remember disagreeing. Maybe I just like contradicting you [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}]"><y>#</y><d>2020-12-19</d><h>11:15</h><w>dominicm</w>Oh no, ousted!  I don&apos;t even remember disagreeing.  Maybe I just like contradicting you <a>@raymcdermott</a></z><z id="t1608376528" t="raymcdermott Oh no you don’t "><y>#</y><d>2020-12-19</d><h>11:15</h><w>raymcdermott</w>Oh no you don’t </z><z id="t1608376555" t="raymcdermott [ sorry it’s Pantomime season ]"><y>#</y><d>2020-12-19</d><h>11:15</h><w>raymcdermott</w>[ sorry it’s Pantomime season ]</z><z id="t1608376583" t="raymcdermott Anyway we’ll let you get on with more interesting topics :)"><y>#</y><d>2020-12-19</d><h>11:16</h><w>raymcdermott</w>Anyway we’ll let you get on with more interesting topics :)</z><z id="t1608376932" t="borkdude Btw, I enjoyed the podcast, but I&apos;m now also aware of how dominicm manipulated me and Alex to do stuff for him!"><y>#</y><d>2020-12-19</d><h>11:22</h><w>borkdude</w>Btw, I enjoyed the podcast, but I&apos;m now also aware of how dominicm manipulated me and Alex to do stuff for him!</z><z id="t1608561212" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] listened that defn, good stuff. Finnish is simple, just pronounce the way you write it, right? 😉"><y>#</y><d>2020-12-21</d><h>14:33</h><w>ikitommi</w><a>@raymcdermott</a> listened that defn, good stuff. Finnish is simple, just pronounce the way you write it, right? <b>😉</b></z><z id="t1608561328" t="ikitommi but, reitit is pronounced ray-tit ."><y>#</y><d>2020-12-21</d><h>14:35</h><w>ikitommi</w>but, reitit is pronounced <code>ray-tit</code>.</z><z id="t1608571601" t="dominicm Can confirm, Ray is a tit ;) [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}]"><y>#</y><d>2020-12-21</d><h>17:26</h><r>dominicm</r>Can confirm, Ray is a tit ;) <a>@raymcdermott</a></z><z id="t1608561380" t="ikitommi [:attrs {:href &quot;/_/_/users/U5RCSJ6BB&quot;}] the entry handling is bit too hard atm, but not sure what woud be a simpler way."><y>#</y><d>2020-12-21</d><h>14:36</h><w>ikitommi</w><a>@rutledgepaulv</a> the entry handling is bit too hard atm, but not sure what woud be a simpler way.</z><z id="t1608561402" t="ikitommi there is a way to ask for the entry instead of the value, just a sec."><y>#</y><d>2020-12-21</d><h>14:36</h><w>ikitommi</w>there is a way to ask for the entry instead of the value, just a sec.</z><z id="t1608564712" t="ikitommi oh, undocumeted, untested and had a bug, but maybe something like this? (mu/find [:map [:b {:optional true} int?]] :b) ; =&gt; [:b {:optional true} int?] (-&gt; [:map [:a [:map [:b {:optional true} int?]]]] (mu/get :a) (mu/find :b)) ; =&gt; [:b {:optional true} int?]"><y>#</y><d>2020-12-21</d><h>15:31</h><w>ikitommi</w>oh, undocumeted, untested and had a bug, but maybe something like this?
<pre>(mu/find
  [:map [:b {:optional true} int?]]
  :b)
; =&gt; [:b {:optional true} int?]

(-&gt; [:map [:a [:map [:b {:optional true} int?]]]]
    (mu/get :a)
    (mu/find :b))
; =&gt; [:b {:optional true} int?]</pre></z><z id="t1608564791" t="ikitommi where mu/find is just sugar on top of the hidden feature of “give me the entry tuple” of: (-&gt; [:map [:a [:map [:b {:optional true} int?]]]] (mu/get-in [:a [::m/find :b]])) ; =&gt; [:b {:optional true} int?]"><y>#</y><d>2020-12-21</d><h>15:33</h><w>ikitommi</w>where <code>mu/find</code> is just sugar on top of the hidden feature of “give me the entry tuple” of:
<pre>(-&gt; [:map [:a [:map [:b {:optional true} int?]]]]
    (mu/get-in [:a [::m/find :b]]))
; =&gt; [:b {:optional true} int?]</pre></z><z id="t1608567135" t="ikitommi https://github.com/metosin/malli/pull/322"><y>#</y><d>2020-12-21</d><h>16:12</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/322" target="_blank">https://github.com/metosin/malli/pull/322</a></z><z id="t1608567233" t="ikitommi btw, those interested in the sequence schemas, here’s the PR (draft): https://github.com/metosin/malli/pull/317"><y>#</y><d>2020-12-21</d><h>16:13</h><w>ikitommi</w>btw, those interested in the sequence schemas, here’s the PR (draft): <a href="https://github.com/metosin/malli/pull/317" target="_blank">https://github.com/metosin/malli/pull/317</a></z><z id="t1608567469" t="ikitommi (m/explain [:+ [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]] [&quot;-server&quot; :foo &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;]) =&gt; {:schema [:+ [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]], :value [&quot;-server&quot; :foo &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;], :errors (#Error{:path [0 :val :s], :in [1], :schema string?, :value :foo} #Error{:path [0 :val :b], :in [1], :schema boolean?, :value :foo})}"><y>#</y><d>2020-12-21</d><h>16:17</h><w>ikitommi</w><pre>(m/explain
  [:+ [:cat*
       [:prop string?]
       [:val [:alt* [:s string?] [:b boolean?]]]]]
  [&quot;-server&quot; :foo &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;])
=&gt;
{:schema [:+ [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]],
 :value [&quot;-server&quot; :foo &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;],
 :errors (#Error{:path [0 :val :s], :in [1], :schema string?, :value :foo}
          #Error{:path [0 :val :b], :in [1], :schema boolean?, :value :foo})}</pre></z><z id="t1608676907" t="elarouss Hi, Is it possible to write a schema for this vector: [{:type :work :value &quot; the vector should only contain those 2 items, where the type is kind of static, the value can change. i thought about using this schema: [:vector [:map [:type keyword?] [:value string?]]] but it’s not enough for my use case, because i want when i inspect the schema to know how many items i can have in the vector, and their types (the :type ) is this possible? Thank you for the great lib 🙏"><y>#</y><d>2020-12-22</d><h>22:41</h><w>elarouss</w>Hi, Is it possible to write a schema for this vector:
<pre>[{:type :work
  :value &quot;</pre>
the vector should only contain those 2 items, where the type is kind of static, the value can change.
i thought about using  this schema:
<pre>[:vector [:map [:type keyword?] [:value string?]]]</pre>
but it’s not enough for my use case, because i want when i inspect the schema to know how many items i can have in the vector, and their types (the <code>:type</code> )

is this possible?

Thank you for the great lib <b>🙏</b></z><z id="t1608678883" t="alpox [:attrs {:href &quot;/_/_/users/U6AE62UCT&quot;}] I can think of two ways: (def data-schema [:map [:type [:enum :work :personal]] [:value string?]]) for the maps and then (def schema [:vector {:min 2 :max 2} data-schema]) or maybe (def schema [:tuple data-schema data-schema]) for putting together the schema for the vector"><y>#</y><d>2020-12-22</d><h>23:14</h><r>alpox</r><a>@U6AE62UCT</a> I can think of two ways:
<pre>(def data-schema [:map
                   [:type [:enum :work :personal]]
                   [:value string?]])</pre>
for the maps and then
<pre>(def schema [:vector {:min 2 :max 2} data-schema])</pre>
or maybe
<pre>(def schema [:tuple data-schema data-schema])</pre>
for putting together the schema for the vector</z><z id="t1608707521" t="elarouss I was thinking about something like [:vector [:map [:type :work] [:value string?]] [:map [:type :personal] [:value string?]]] but it didn’t work Thank you [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] i’ll probably go with your first suggestion"><y>#</y><d>2020-12-23</d><h>07:12</h><r>elarouss</r>I was thinking about something like
<pre>[:vector
     [:map [:type :work] [:value string?]]
     [:map [:type :personal] [:value string?]]]</pre>
but it didn’t work

Thank you <a>@U6JS7B99S</a> i’ll probably go with your first suggestion</z><z id="t1608710927" t="ikitommi if the :type defines the shape of the data, you can try :multi : (require &apos;[malli.generator :as mg]) (mg/sample [:vector {:min 2, :max 2} [:multi {:dispatch :type} [:work [:map [:type [:= :work]] [:value string?]]] [:personal [:map [:type [:= :personal]] [:value string?]]]]]) (mg/sample [:tuple {:registry {::element [:multi {:dispatch :type} [:work [:map [:type [:= :work]] [:value string?]]] [:personal [:map [:type [:= :personal]] [:value string?]]]]}} ::element ::element])"><y>#</y><d>2020-12-23</d><h>08:08</h><r>ikitommi</r>if the <code>:type</code> defines the shape of the data, you can try <code>:multi</code>:

<pre>(require &apos;[malli.generator :as mg])

(mg/sample
  [:vector {:min 2, :max 2}
   [:multi {:dispatch :type}
    [:work [:map [:type [:= :work]] [:value string?]]]
    [:personal [:map [:type [:= :personal]] [:value string?]]]]])

(mg/sample
  [:tuple {:registry
           {::element
            [:multi {:dispatch :type}
             [:work [:map [:type [:= :work]] [:value string?]]]
             [:personal [:map [:type [:= :personal]] [:value string?]]]]}}
   ::element ::element])</pre></z><z id="t1608710950" t="ikitommi both emit results like: ([{:type :personal, :value &quot;&quot;} {:type :work, :value &quot;&quot;}] [{:type :work, :value &quot;l&quot;} {:type :personal, :value &quot;&quot;}] [{:type :personal, :value &quot;z1&quot;} {:type :personal, :value &quot;&quot;}] [{:type :personal, :value &quot;ZG&quot;} {:type :personal, :value &quot;N&quot;}] [{:type :personal, :value &quot;qQ6&quot;} {:type :work, :value &quot;A8h&quot;}] [{:type :personal, :value &quot;2588&quot;} {:type :personal, :value &quot;Djv12&quot;}] [{:type :work, :value &quot;&quot;} {:type :personal, :value &quot;c&quot;}] [{:type :work, :value &quot;U2uHMI&quot;} {:type :personal, :value &quot;376ihr&quot;}] [{:type :personal, :value &quot;n6Ct4d&quot;} {:type :personal, :value &quot;V09xL8&quot;}] [{:type :work, :value &quot;9&quot;} {:type :personal, :value &quot;&quot;}])"><y>#</y><d>2020-12-23</d><h>08:09</h><r>ikitommi</r>both emit results like:
<pre>([{:type :personal, :value &quot;&quot;} {:type :work, :value &quot;&quot;}]
 [{:type :work, :value &quot;l&quot;} {:type :personal, :value &quot;&quot;}]
 [{:type :personal, :value &quot;z1&quot;} {:type :personal, :value &quot;&quot;}]
 [{:type :personal, :value &quot;ZG&quot;} {:type :personal, :value &quot;N&quot;}]
 [{:type :personal, :value &quot;qQ6&quot;} {:type :work, :value &quot;A8h&quot;}]
 [{:type :personal, :value &quot;2588&quot;} {:type :personal, :value &quot;Djv12&quot;}]
 [{:type :work, :value &quot;&quot;} {:type :personal, :value &quot;c&quot;}]
 [{:type :work, :value &quot;U2uHMI&quot;} {:type :personal, :value &quot;376ihr&quot;}]
 [{:type :personal, :value &quot;n6Ct4d&quot;} {:type :personal, :value &quot;V09xL8&quot;}]
 [{:type :work, :value &quot;9&quot;} {:type :personal, :value &quot;&quot;}])</pre></z><z id="t1608711055" t="ikitommi if the first map is always work and second personal, :tuple for the win: [:tuple [:map [:type :work] [:value string?]] [:map [:type :personal] [:value string?]]]"><y>#</y><d>2020-12-23</d><h>08:10</h><r>ikitommi</r>if the first map is always work and second personal, <code>:tuple</code> for the win:
<pre>[:tuple
 [:map [:type :work] [:value string?]]
 [:map [:type :personal] [:value string?]]]</pre></z><z id="t1608711772" t="elarouss Thank you, the :multi works for my use case 🙏"><y>#</y><d>2020-12-23</d><h>08:22</h><r>elarouss</r>Thank you, the <code>:multi</code> works for my use case <b>🙏</b></z><z id="t1608710927" t="ikitommi if the :type defines the shape of the data, you can try :multi : (require &apos;[malli.generator :as mg]) (mg/sample [:vector {:min 2, :max 2} [:multi {:dispatch :type} [:work [:map [:type [:= :work]] [:value string?]]] [:personal [:map [:type [:= :personal]] [:value string?]]]]]) (mg/sample [:tuple {:registry {::element [:multi {:dispatch :type} [:work [:map [:type [:= :work]] [:value string?]]] [:personal [:map [:type [:= :personal]] [:value string?]]]]}} ::element ::element])"><y>#</y><d>2020-12-23</d><h>08:08</h><w>ikitommi</w>if the <code>:type</code> defines the shape of the data, you can try <code>:multi</code>:

<pre>(require &apos;[malli.generator :as mg])

(mg/sample
  [:vector {:min 2, :max 2}
   [:multi {:dispatch :type}
    [:work [:map [:type [:= :work]] [:value string?]]]
    [:personal [:map [:type [:= :personal]] [:value string?]]]]])

(mg/sample
  [:tuple {:registry
           {::element
            [:multi {:dispatch :type}
             [:work [:map [:type [:= :work]] [:value string?]]]
             [:personal [:map [:type [:= :personal]] [:value string?]]]]}}
   ::element ::element])</pre></z><z id="t1608712975" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] In other languages people usually define this as an ADT. Maybe :enum can also be used for this?"><y>#</y><d>2020-12-23</d><h>08:42</h><w>borkdude</w><a>@ikitommi</a> In other languages people usually define this as an ADT. Maybe <code>:enum</code> can also be used for this?</z><z id="t1608712996" t="borkdude (I didn&apos;t see any docs about :enum in the README, only examples)"><y>#</y><d>2020-12-23</d><h>08:43</h><w>borkdude</w>(I didn&apos;t see any docs about <code>:enum</code> in the README, only examples)</z><z id="t1608713039" t="ikitommi :enum is about values, :or is about schemas: [:or [:map [:type [:= :work]] [:value string?]] [:map [:type [:= :personal]] [:value string?]]] fixed, thanks to [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}]"><y>#</y><d>2020-12-23</d><h>08:43</h><w>ikitommi</w><code>:enum</code> is about values, <code>:or</code> is about schemas:
<pre>[:or
 [:map [:type [:= :work]] [:value string?]]
 [:map [:type [:= :personal]] [:value string?]]]</pre>
fixed, thanks to <a>@borkdude</a></z><z id="t1608713061" t="borkdude right, that&apos;s what I was thinking"><y>#</y><d>2020-12-23</d><h>08:44</h><w>borkdude</w>right, that&apos;s what I was thinking</z><z id="t1608713073" t="ikitommi but, :or does a linear scan over schema, :multi can be much more efficient."><y>#</y><d>2020-12-23</d><h>08:44</h><w>ikitommi</w>but, <code>:or</code> does a linear scan over schema, <code>:multi</code> can be much more efficient.</z><z id="t1608713141" t="borkdude why did you have to write [:work [:map [:type [:= :work]] [:value string?]]] with :multi but [:map [:type :work] [:value string?]] with :or ?"><y>#</y><d>2020-12-23</d><h>08:45</h><w>borkdude</w>why did you have to write <code>[:work [:map [:type [:= :work]] [:value string?]]]</code> with <code>:multi</code> but <code>[:map [:type :work] [:value string?]]</code> with <code>:or</code>?</z><z id="t1608713142" t="ikitommi (`either` was deprecated in Plumatic Schema because of this, malli supports that as it’s usefull to describe the real world, despite being slow)"><y>#</y><d>2020-12-23</d><h>08:45</h><w>ikitommi</w>(`either` was deprecated in Plumatic Schema because of this, malli supports that as it’s usefull to describe the real world, despite being slow)</z><z id="t1608713174" t="ikitommi could be: [:work [:map [:type string?] [:value string?]]]"><y>#</y><d>2020-12-23</d><h>08:46</h><w>ikitommi</w>could be:
<pre>[:work [:map [:type string?] [:value string?]]]</pre></z><z id="t1608713187" t="borkdude if you support :case for a closed world of possibilities it could possibly be even faster?"><y>#</y><d>2020-12-23</d><h>08:46</h><w>borkdude</w>if you support <code>:case</code> for a closed world of possibilities it could possibly be even faster?</z><z id="t1608713194" t="ikitommi … but the generator would then just generate any keyword for the :a: "><y>#</y><d>2020-12-23</d><h>08:46</h><w>ikitommi</w>… but the generator would then just generate any keyword for the <code>:a:</code> </z><z id="t1608713225" t="ikitommi what kind of code would the :case emit?"><y>#</y><d>2020-12-23</d><h>08:47</h><w>ikitommi</w>what kind of code would the <code>:case</code> emit?</z><z id="t1608713228" t="borkdude I was referring to [:type [:= work]] vs [:type :work]"><y>#</y><d>2020-12-23</d><h>08:47</h><w>borkdude</w>I was referring to <code>[:type [:= work]]</code> vs <code>[:type :work]</code></z><z id="t1608713264" t="ikitommi oh, that’s my bug. [:type :work] doesn’t work."><y>#</y><d>2020-12-23</d><h>08:47</h><w>ikitommi</w>oh, that’s my bug. <code>[:type :work]</code> doesn’t work.</z><z id="t1608713279" t="ikitommi looks for :work from the registry, which doesn’t exist."><y>#</y><d>2020-12-23</d><h>08:47</h><w>ikitommi</w>looks for <code>:work</code> from the registry, which doesn’t exist.</z><z id="t1608713289" t="borkdude ah ok then"><y>#</y><d>2020-12-23</d><h>08:48</h><w>borkdude</w>ah ok then</z><z id="t1608713312" t="borkdude (I have no idea what :case would emit, just bouncing an idea)"><y>#</y><d>2020-12-23</d><h>08:48</h><w>borkdude</w>(I have no idea what <code>:case</code> would emit, just bouncing an idea)</z><z id="t1608713313" t="ikitommi [:= :work] is basically same as [:enum :work]"><y>#</y><d>2020-12-23</d><h>08:48</h><w>ikitommi</w><code>[:= :work]</code> is basically same as <code>[:enum :work]</code></z><z id="t1608713338" t="borkdude so [:map [:enum :work :personal] [:value string?]] would also work"><y>#</y><d>2020-12-23</d><h>08:48</h><w>borkdude</w>so <code>[:map [:enum :work :personal] [:value string?]]</code> would also work</z><z id="t1608713378" t="ikitommi [:map [:type [:enum :work :personal]] [:value string?]] yes"><y>#</y><d>2020-12-23</d><h>08:49</h><w>ikitommi</w><code>[:map [:type [:enum :work :personal]] [:value string?]]</code> yes</z><z id="t1608713407" t="ikitommi but if the :type effects the :value , or any other parts of the schema, then :multi is the way."><y>#</y><d>2020-12-23</d><h>08:50</h><w>ikitommi</w>but if the <code>:type</code> effects the <code>:value</code> , or any other parts of the schema, then <code>:multi</code> is the way.</z><z id="t1608713478" t="borkdude does it generate a multi-method behind the scenes?"><y>#</y><d>2020-12-23</d><h>08:51</h><w>borkdude</w>does it generate a multi-method behind the scenes?</z><z id="t1608713495" t="ikitommi no, it’s closed and immutable by design."><y>#</y><d>2020-12-23</d><h>08:51</h><w>ikitommi</w>no, it’s closed and immutable by design.</z><z id="t1608713522" t="ikitommi just a dispatch map from key -&gt; schema. and the key is looked up using the :dispatch function."><y>#</y><d>2020-12-23</d><h>08:52</h><w>ikitommi</w>just a dispatch map from key -&gt; schema. and the key is looked up using the <code>:dispatch</code> function.</z><z id="t1608713548" t="ikitommi :dispatch function is applied to value, which returns the :multi key, which selects the schema"><y>#</y><d>2020-12-23</d><h>08:52</h><w>ikitommi</w><code>:dispatch</code> function is applied to value, which returns the <code>:multi</code> key, which selects the schema</z><z id="t1608713589" t="ikitommi and, :dispatch can be a sci-function, of course 🙂"><y>#</y><d>2020-12-23</d><h>08:53</h><w>ikitommi</w>and, <code>:dispatch</code> can be a sci-function, of course <b>🙂</b></z><z id="t1608713605" t="ikitommi (m/validate [:multi {:dispatch &apos;first} [:sized [:tuple keyword? [:map [:size int?]]]] [:human [:tuple keyword? [:map [:name string?] [:address [:map [:country keyword?]]]]]]] [:human {:name &quot;seppo&quot;, :address {:country :sweden}}]) ; true"><y>#</y><d>2020-12-23</d><h>08:53</h><w>ikitommi</w><pre>(m/validate
  [:multi {:dispatch &apos;first}
   [:sized [:tuple keyword? [:map [:size int?]]]]
   [:human [:tuple keyword? [:map [:name string?] [:address [:map [:country keyword?]]]]]]]
  [:human {:name &quot;seppo&quot;, :address {:country :sweden}}])
; true</pre></z><z id="t1608713652" t="ikitommi so, there is always a map-lookup, so not as fast as case , but it would require code-generation, which would mean a macro."><y>#</y><d>2020-12-23</d><h>08:54</h><w>ikitommi</w>so, there is always a map-lookup, so not as fast as <code>case</code>, but it would require code-generation, which would mean a macro.</z><z id="t1608713715" t="borkdude yeah, that makes sense"><y>#</y><d>2020-12-23</d><h>08:55</h><w>borkdude</w>yeah, that makes sense</z><z id="t1608713850" t="ikitommi could add a :conditional , where the entry keys are functions, and the first one will match. Like :or , but more explicit and short-circuits on first match: [:conditional [map? [:map [:x int?]]] [int? [:int {:min 1, :max 2}]]]"><y>#</y><d>2020-12-23</d><h>08:57</h><w>ikitommi</w>could add a <code>:conditional</code>, where the entry keys are functions, and the first one will match. Like <code>:or</code>, but more explicit and short-circuits on first match:
<pre>[:conditional
 [map? [:map [:x int?]]]
 [int? [:int {:min 1, :max 2}]]]</pre></z><z id="t1608713908" t="ikitommi malli.core is distilled into tons of helper functions to build new schemas, really easy to add things like this atm."><y>#</y><d>2020-12-23</d><h>08:58</h><w>ikitommi</w>malli.core is distilled into tons of helper functions to build new schemas, really easy to add things like this atm.</z><z id="t1608713988" t="borkdude doesn&apos;t :or short-circuit?"><y>#</y><d>2020-12-23</d><h>08:59</h><w>borkdude</w>doesn&apos;t <code>:or</code> short-circuit?</z><z id="t1608714111" t="borkdude btw, I also implemented case as a map-lookup in sci, same problem ;)"><y>#</y><d>2020-12-23</d><h>09:01</h><w>borkdude</w>btw, I also implemented <code>case</code> as a map-lookup in sci, same problem ;)</z><z id="t1608714245" t="ikitommi sorry, it does. I think the issue is that you can have multiple branches that would match, making the rest effectively unreachable."><y>#</y><d>2020-12-23</d><h>09:04</h><w>ikitommi</w>sorry, it does. I think the issue is that you can have multiple branches that would match, making the rest effectively unreachable.</z><z id="t1608714367" t="ikitommi also, the :or tranformation is bit hacky, depending whether you are doing decoding or encoding, we need to check if the transformation turned the value valid or not. that’s slow."><y>#</y><d>2020-12-23</d><h>09:06</h><w>ikitommi</w>also, the <code>:or</code> tranformation is bit hacky, depending whether you are doing decoding or encoding, we need to check if the transformation turned the value valid or not. that’s slow.</z><z id="t1608714384" t="ikitommi … but, works 🙂"><y>#</y><d>2020-12-23</d><h>09:06</h><w>ikitommi</w>… but, works <b>🙂</b></z><z id="t1608949423" t="steveb8n I’ve started switching out Spec for Malli to improve performance in hot code. it works great except when using recursive schemas. I’ve created a gist to illustrate https://gist.github.com/stevebuik/e4f3475e46dd5ebb1de7707438fa073f"><y>#</y><d>2020-12-26</d><h>02:23</h><w>steveb8n</w>I’ve started switching out Spec for Malli to improve performance in hot code. it works great except when using recursive schemas. I’ve created a gist to illustrate <a href="https://gist.github.com/stevebuik/e4f3475e46dd5ebb1de7707438fa073f" target="_blank">https://gist.github.com/stevebuik/e4f3475e46dd5ebb1de7707438fa073f</a></z><z id="t1608949446" t="steveb8n anyone seen this before? Or am I making a mistake somehow?"><y>#</y><d>2020-12-26</d><h>02:24</h><r>steveb8n</r>anyone seen this before? Or am I making a mistake somehow?</z><z id="t1608976565" t="ikitommi [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] you are using :and , which composes the two maps - in validation it runs two validations, one for each map. If you use malli.util/merge , the end result is one schema, and validation runs it just once. tested the first example, it’s 90ns vs 97ns, which is the cost of iterating over 2 MapEntrys instead of just one. (require &apos;[malli.util :as mu]) (def simple-tree-node (mu/merge simple-node [:map {:registry {::child simple-node}} [:children {:optional true} [:vector [:ref ::child]]]]))"><y>#</y><d>2020-12-26</d><h>09:56</h><w>ikitommi</w><a>@steveb8n</a> you are using <code>:and</code>, which composes the two maps - in validation it runs two validations, one for each map. If you use <code>malli.util/merge</code>, the end result is one schema, and validation runs it just once. tested the first example, it’s 90ns vs 97ns, which is the cost of iterating over 2 MapEntrys instead of just one.
<pre>(require &apos;[malli.util :as mu])

(def simple-tree-node
  (mu/merge
    simple-node
    [:map {:registry {::child simple-node}}
     [:children {:optional true} [:vector [:ref ::child]]]]))</pre></z><z id="t1608982558" t="steveb8n Now that&apos;s a Xmas gift! I&apos;ll try it tomorrow. Thanks"><y>#</y><d>2020-12-26</d><h>11:35</h><r>steveb8n</r>Now that&apos;s a Xmas gift! I&apos;ll try it tomorrow. Thanks</z><z id="t1608976862" t="ikitommi one note about merge: both the properties and children are merged (no deep merge atm), so the last :registry property wins. hadn’t thought of that :thinking_face:"><y>#</y><d>2020-12-26</d><h>10:01</h><w>ikitommi</w>one note about merge: both the properties and children are merged (no deep merge atm), so the last <code>:registry</code> property wins. hadn’t thought of that <b>:thinking_face:</b></z><z id="t1608976892" t="ikitommi but, here, it’s: simple-tree-node ;[:map ; {:registry #:recursive-malli-perf{:child [:map [:name string?]]}} ; [:name string?] ; [:children {:optional true} [:vector [:ref :recursive-malli-perf/child]]]]"><y>#</y><d>2020-12-26</d><h>10:01</h><w>ikitommi</w>but, here, it’s:
<pre>simple-tree-node
;[:map
; {:registry #:recursive-malli-perf{:child [:map [:name string?]]}}
; [:name string?]
; [:children {:optional true} [:vector [:ref :recursive-malli-perf/child]]]]</pre></z><z id="t1609037000" t="euccastro sorry if I missed something basic, but is there a way to specify that a string field should match a regular expression, without resorting to SCI functions?"><y>#</y><d>2021-12-27</d><h>02:43</h><w>euccastro</w>sorry if I missed something basic, but is there a way to specify that a string field should match a regular expression, without resorting to SCI functions?</z><z id="t1609055513" t="steveb8n have you considered using :fn without using sci? why is that not a good solution?"><y>#</y><d>2021-12-27</d><h>07:51</h><r>steveb8n</r>have you considered using :fn without using sci? why is that not a good solution?</z><z id="t1609075210" t="ikitommi https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L484-L509"><y>#</y><d>2021-12-27</d><h>13:20</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L484-L509" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L484-L509</a></z><z id="t1609075244" t="ikitommi any documentation PRs most welcome"><y>#</y><d>2021-12-27</d><h>13:20</h><r>ikitommi</r>any documentation PRs most welcome</z><z id="t1609082604" t="euccastro PR here: https://github.com/metosin/malli/pull/323/files"><y>#</y><d>2021-12-27</d><h>15:23</h><r>euccastro</r>PR here:  <a href="https://github.com/metosin/malli/pull/323/files" target="_blank">https://github.com/metosin/malli/pull/323/files</a></z><z id="t1609083694" t="ikitommi thanks!"><y>#</y><d>2021-12-27</d><h>15:41</h><r>ikitommi</r>thanks!</z><z id="t1609044401" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] can I trouble you for one more gist comment? this is not urgent so I’m happy to wait until your status is not “vacationing” 🙂 https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d"><y>#</y><d>2021-12-27</d><h>04:46</h><w>steveb8n</w><a>@ikitommi</a> can I trouble you for one more gist comment? this is not urgent so I’m happy to wait until your status is not “vacationing” <b>🙂</b> <a href="https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d" target="_blank">https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d</a></z><z id="t1609045510" t="steveb8n not urgent because I can work around the perf by not using recursion in my initial spec replacements. full recursion will be useful but can come later"><y>#</y><d>2021-12-27</d><h>05:05</h><r>steveb8n</r>not urgent because I can work around the perf by not using recursion in my initial spec replacements. full recursion will be useful but can come later</z><z id="t1609045544" t="steveb8n and because OSS should never be urgent 🙂"><y>#</y><d>2021-12-27</d><h>05:05</h><r>steveb8n</r>and because OSS should never be urgent <b>🙂</b></z><z id="t1609050224" t="steveb8n I wonder if I/we could turn this into a useful sample for others to learn from? happy to do this if you agree it would be useful"><y>#</y><d>2021-12-27</d><h>06:23</h><r>steveb8n</r>I wonder if I/we could turn this into a useful sample for others to learn from? happy to do this if you agree it would be useful</z><z id="t1609075450" t="ikitommi thanks for the awesome repro, easy to dig in to this when have the extra time."><y>#</y><d>2021-12-27</d><h>13:24</h><r>ikitommi</r>thanks for the awesome repro, easy to dig in to this when have the extra time.</z><z id="t1609118691" t="steveb8n Thank you for such a big upgrade to Spec 🙂 BTW I’m also noticing some very slow perf when compiling medium complexity nested schemas. Are you interested in test cases for that as well?"><y>#</y><d>2021-12-28</d><h>01:24</h><r>steveb8n</r>Thank you for such a big upgrade to Spec <b>🙂</b> BTW I’m also noticing some very slow perf when compiling medium complexity nested schemas. Are you interested in test cases for that as well?</z><z id="t1609130536" t="steveb8n The compilation slowness appears to be caused by liberal use of :merge. when I remove it and just compose maps (i.e. inline) I see compile speeds improve by 10x"><y>#</y><d>2021-12-28</d><h>04:42</h><r>steveb8n</r>The compilation slowness appears to be caused by liberal use of :merge. when I remove it and just compose maps (i.e. inline) I see compile speeds improve by 10x</z><z id="t1609131781" t="steveb8n I’ve worked around both the compilation (i.e. validator) and runtime perf issues so this is not urgent for me. I’ll be happy to provide more test cases if you need them"><y>#</y><d>2021-12-28</d><h>05:03</h><r>steveb8n</r>I’ve worked around both the compilation (i.e. validator) and runtime perf issues so this is not urgent for me. I’ll be happy to provide more test cases if you need them</z><z id="t1609093638" t="borkdude How does malli expect bytes? to be delivered e.g. when you have a JSON api"><y>#</y><d>2021-12-27</d><h>18:27</h><w>borkdude</w>How does malli expect <code>bytes?</code> to be delivered e.g. when you have a JSON api</z><z id="t1609093659" t="borkdude as base64? (that would seem random)"><y>#</y><d>2021-12-27</d><h>18:27</h><w>borkdude</w>as base64? (that would seem random)</z><z id="t1609093689" t="borkdude or would one do a pass over the json, deserialize the base64 manually?"><y>#</y><d>2021-12-27</d><h>18:28</h><w>borkdude</w>or would one do a pass over the json, deserialize the base64 manually?</z><z id="t1609093716" t="borkdude I&apos;m asking this since babashka pods communicate via edn or json, which doesn&apos;t have a built-in way to represent bytes. transit does have it"><y>#</y><d>2021-12-27</d><h>18:28</h><w>borkdude</w>I&apos;m asking this since babashka pods communicate via edn or json, which doesn&apos;t have a built-in way to represent bytes. transit does have it</z><z id="t1609097276" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] atm, there is no default encoding/decoding bytes and strings. Looking at OpenAPI docs, the guide is: &gt; base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw=="><y>#</y><d>2021-12-27</d><h>19:27</h><w>ikitommi</w><a>@borkdude</a> atm, there is no default encoding/decoding bytes and strings. Looking at OpenAPI docs, the guide is:
&gt; base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==</z><z id="t1609097299" t="ikitommi https://swagger.io/docs/specification/data-models/data-types/"><y>#</y><d>2021-12-27</d><h>19:28</h><r>ikitommi</r><a href="https://swagger.io/docs/specification/data-models/data-types/" target="_blank">https://swagger.io/docs/specification/data-models/data-types/</a></z><z id="t1609097318" t="borkdude for now I went with transit. it does it for me.. I should look into how it does it"><y>#</y><d>2021-12-27</d><h>19:28</h><r>borkdude</r>for now I went with transit. it does it for me.. I should look into how it does it</z><z id="t1609097407" t="borkdude"><y>#</y><d>2021-12-27</d><h>19:30</h><r>borkdude</r></z><z id="t1609097351" t="ikitommi so, there could be a byte&lt;-&gt;string transformers in malli.transform to make this a default"><y>#</y><d>2021-12-27</d><h>19:29</h><w>ikitommi</w>so, there could be a byte&lt;-&gt;string transformers in <code>malli.transform</code> to make this a default</z><z id="t1609110767" t="steveb8n Is this a bug? If so, I will log it…. (m/validator [:schema {:registry (merge (m/base-schemas) {:person [:multi {:dispatch :person/gender}]})} :person]) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1}"><y>#</y><d>2021-12-27</d><h>23:12</h><w>steveb8n</w>Is this a bug? If so, I will log it….
<code>(m/validator [:schema</code>
                <code>{:registry (merge</code>
                             <code>(m/base-schemas)</code>
                             <code>{:person [:multi {:dispatch :person/gender}]})}</code>
                <code>:person])</code>
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1}</z><z id="t1609111010" t="steveb8n workaround…."><y>#</y><d>2021-12-27</d><h>23:16</h><r>steveb8n</r>workaround….</z><z id="t1609111020" t="steveb8n (m/validator [:schema {:registry {:person [:multi {:dispatch :person/gender}]}} :person])"><y>#</y><d>2021-12-27</d><h>23:17</h><r>steveb8n</r><pre>(m/validator [:schema
              {:registry {:person [:multi {:dispatch :person/gender}]}}
              :person])</pre></z><z id="t1609258578" t="aaron51 How do I describe keywords with a certain namespace? Something like [:qualified-keyword {:namespace :asdf}] to match :asdf/x and :asdf/y"><y>#</y><d>2021-12-29</d><h>16:16</h><w>aaron51</w>How do I describe keywords with a certain namespace? Something like <code>[:qualified-keyword {:namespace :asdf}]</code> to match <code>:asdf/x</code> and <code>:asdf/y</code></z><z id="t1609260940" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH0P5LJ&quot;}] something like [:and :qualified-keyword [:fn (fn [x] (= :asdf (namespace x))]] ?"><y>#</y><d>2021-12-29</d><h>16:55</h><w>ikitommi</w><a>@aaron51</a> something like <code>[:and :qualified-keyword [:fn (fn [x] (= :asdf (namespace x))]]</code>?</z><z id="t1609260967" t="aaron51 yes! thank you"><y>#</y><d>2021-12-29</d><h>16:56</h><w>aaron51</w>yes! thank you</z><z id="t1609261139" t="ikitommi You can also create your own :qualified-keyword impl quite easily, on top of malli.core/-simple-schema , which would read the :namespace property and validate it behind the scenes. e.g. the syntax you proposed. Not near computer, but there are examples how to do that kind of stuff in the user space."><y>#</y><d>2021-12-29</d><h>16:58</h><w>ikitommi</w>You can also  create your own <code>:qualified-keyword</code> impl quite easily, on top of <code>malli.core/-simple-schema</code>, which would read the <code>:namespace</code> property and validate it behind the scenes. e.g. the syntax you proposed. Not near computer, but there are examples how to do that kind of stuff in the user space.</z><z id="t1609261184" t="ikitommi Also, sounds useful enough, so you could do a PR of that."><y>#</y><d>2021-12-29</d><h>16:59</h><w>ikitommi</w>Also, sounds useful enough, so you could do a PR of that.</z><z id="t1609261225" t="aaron51 thank you, I’ll give it a try 👍"><y>#</y><d>2021-12-29</d><h>17:00</h><w>aaron51</w>thank you, I’ll give it a try <b>👍</b></z><z id="t1609261463" t="ikitommi Some examples how to build custom s (simple) schemas: https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L1392-L1470"><y>#</y><d>2021-12-29</d><h>17:04</h><w>ikitommi</w>Some examples how to build custom s
(simple) schemas: <a href="https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L1392-L1470" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/core_test.cljc#L1392-L1470</a></z><z id="t1609354566" t="Michael W Is it possible to take a swagger file and generate a malli schema? I see how to convert schema to swagger, but not the reverse in the docs."><y>#</y><d>2021-12-30</d><h>18:56</h><w>Michael W</w>Is it possible to take a swagger file and generate a malli schema?  I see how to convert schema to swagger, but not the reverse in the docs.</z><z id="t1609359791" t="ikitommi [:attrs {:href &quot;/_/_/users/UAB2NMK25&quot;}] currently, no. There is a stalled PR of JSON Schema -&gt; malli conversion. I would guess it takes days / weeks to make it complete enough, don&apos;t have the time myself for that. But, contributions most welcome."><y>#</y><d>2021-12-30</d><h>20:23</h><w>ikitommi</w><a>@michael819</a> currently, no. There is a stalled PR of  JSON Schema -&gt; malli conversion. I would guess it takes days / weeks to make it complete enough, don&apos;t have the time myself for that. But, contributions most welcome.</z><z id="t1609361058" t="Michael W I think it&apos;s a chicken and egg problem. Should I create a malli schema for openapi to validate the files, then work from there? Just trying to gauge the amount of work necessary and a general idea of where to start."><y>#</y><d>2021-12-30</d><h>20:44</h><w>Michael W</w>I think it&apos;s a chicken and egg problem.  Should I create a malli schema for openapi to validate the files, then work from there?  Just trying to gauge the amount of work necessary and a general idea of where to start.</z><z id="t1609445859" t="eoliphant Hi, I’m using malli ‘spec’ishly’ with the mutable custom schema suggested in the readme. One annoyance I’m running into is the need to set the malli.registry/type to custom as a JVM property in quite a few places. I’n the current case, I’m running a Fulcro app as a Datomic ion. I ended up needing to set the property to run shadow-cljs itself (not just setting it as a closure define), the ion cmd line tools, etc, and I’m calling System/setProperty directly in code in the server entry points to try to make sure it’s set there as you can’t really set system props for the server runtime. Just wondering if longer term there might be a better way to handle this"><y>#</y><d>2021-12-31</d><h>20:17</h><w>eoliphant</w>Hi, I’m using malli ‘spec’ishly’ with the mutable custom schema suggested in the readme.  One annoyance I’m running into is the need to set the <code>malli.registry/type</code>  to custom as a JVM property in quite a few places.   I’n the current case, I’m running a Fulcro app as a Datomic ion.  I ended up needing to set the property to run shadow-cljs itself (not just setting it as a closure define), the ion cmd line tools, etc, and I’m calling System/setProperty directly in code in the server entry points to try to make sure it’s set there as you can’t really set system props for the  server runtime.  Just wondering if longer term there might be a better way to handle this</z><z id="t1609520252" t="ikitommi [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] the first alpha wanted to be immutable by default. We could revisit that for 1.0.0, starting to think it would be ok if malli was optionally immutable: the JVM/compiler option could be to close things up."><y>#</y><d>2021-01-01</d><h>16:57</h><w>ikitommi</w><a>@eoliphant</a> the first alpha wanted to be immutable by default. We could revisit that for 1.0.0, starting to think it would be ok if malli was optionally immutable: the JVM/compiler option could be to close things up.</z><z id="t1609520463" t="ikitommi when one does multi-tenant schema systems, anyway the registry is either local or passed as option -&gt; one can have already full control of the registries in places where it matters. The system default registry is just for your own core app, not the tenants."><y>#</y><d>2021-01-01</d><h>17:01</h><w>ikitommi</w>when one does multi-tenant schema systems, anyway the registry is either local or passed as option -&gt; one can have already full control of the registries in places where it matters. The system default registry is just for your own core app, not the tenants.</z><z id="t1609520502" t="ikitommi maybe have a up-to-date branch of malli with the option reversed?"><y>#</y><d>2021-01-01</d><h>17:01</h><w>ikitommi</w>maybe have a up-to-date branch of malli with the option reversed?</z><z id="t1609520642" t="ikitommi also, comments welcome on having an optional global registry. Something like (malli.mutable/register! :user/name :string)"><y>#</y><d>2021-01-01</d><h>17:04</h><w>ikitommi</w>also, comments welcome on having an optional global registry. Something like <code>(malli.mutable/register! :user/name :string)</code></z><z id="t1609554902" t="y.khmelevskii Hi! I would like to ask about feature request for malli.generator . It would be great to support relations and constrains like in https://github.com/reifyhealth/specmonstah For example (def schema {:user {:prefix :u :spec ::user} :post {:prefix :p :spec ::post :relations {:created-by-id [:user :id]}} :like {:prefix :l :spec ::like :relations {:post-id [:post :id] :created-by-id [:user :id]} :constraints {:created-by-id #{:uniq}}}}) Is it make sense for malli roadmap?"><y>#</y><d>2021-01-02</d><h>02:35</h><w>y.khmelevskii</w>Hi! I would like to ask about feature request for <code>malli.generator</code>.
It would be great to support relations and constrains like in <a href="https://github.com/reifyhealth/specmonstah" target="_blank">https://github.com/reifyhealth/specmonstah</a>
For example
<pre>(def schema
  {:user {:prefix :u
          :spec   ::user}
   :post {:prefix    :p
          :spec      ::post
          :relations {:created-by-id [:user :id]}}
   :like {:prefix      :l
          :spec        ::like
          :relations   {:post-id       [:post :id]
                        :created-by-id [:user :id]}
          :constraints {:created-by-id #{:uniq}}}})</pre>
Is it make sense for malli roadmap?</z><z id="t1609580498" t="ikitommi [:attrs {:href &quot;/_/_/users/U1GTUPAVB&quot;}] specmonstah does a lot of things and it might be generic enough to support malli easily. Would you like to investigate / suggest that to specmonstah maintainers?"><y>#</y><d>2021-01-02</d><h>09:41</h><r>ikitommi</r><a>@U1GTUPAVB</a> specmonstah does a lot of things and it might be generic enough to support malli easily. Would you like to investigate / suggest that to specmonstah maintainers?</z><z id="t1609580658" t="ikitommi but, please write the issue to malli repo, so it&apos;s on potential backlog. The idea is good, would use that myself."><y>#</y><d>2021-01-02</d><h>09:44</h><r>ikitommi</r>but, please write the issue to malli repo, so it&apos;s on potential backlog. The idea is good, would use that myself.</z><z id="t1609580729" t="ikitommi Related: https://github.com/metosin/malli/issues/53"><y>#</y><d>2021-01-02</d><h>09:45</h><r>ikitommi</r>Related: <a href="https://github.com/metosin/malli/issues/53" target="_blank">https://github.com/metosin/malli/issues/53</a></z><z id="t1609972647" t="steveb8n I use specmonstah so I&apos;m interested in this issue as well"><y>#</y><d>2021-01-06</d><h>22:37</h><r>steveb8n</r>I use specmonstah so I&apos;m interested in this issue as well</z><z id="t1609978356" t="pithyless FYI - There is a fork of specmonstah meant to support malli, but I haven’t been tracking it so not sure how baked it is: https://github.com/lambdaisland/specmonstah-malli"><y>#</y><d>2021-01-07</d><h>00:12</h><r>pithyless</r>FYI - There is a fork of specmonstah meant to support malli, but I haven’t been tracking it so not sure how baked it is:  <a href="https://github.com/lambdaisland/specmonstah-malli" target="_blank">https://github.com/lambdaisland/specmonstah-malli</a></z><z id="t1609978789" t="steveb8n maybe we should suggest a name change for the fork 🙂"><y>#</y><d>2021-01-07</d><h>00:19</h><r>steveb8n</r>maybe we should suggest a name change for the fork <b>🙂</b></z><z id="t1609932010" t="ordnungswidrig Give a definition like (def Foo [:schema {:registry {&quot;Foo&quot; [:map [:bar pos-int?} &quot;Foo&quot;]) Is there a way to “resolve” that schema to the actual schema referenced by “Foo”? I want to programatically access the actual definition of “Foo”, e.g. to enumerate the map fields. I’ve look through the properties, options, children and reference of the schema created by (m/schema Foo) but I’m a little lost."><y>#</y><d>2021-01-06</d><h>11:20</h><w>ordnungswidrig</w>Give a definition like
<pre>(def Foo [:schema {:registry {&quot;Foo&quot; [:map [:bar pos-int?}  &quot;Foo&quot;])</pre>
Is there a way to “resolve” that schema to the actual schema referenced by “Foo”?

I want to programatically access the actual definition of “Foo”, e.g. to enumerate the map fields. I’ve look through the properties, options, children and reference of the schema created by <code>(m/schema Foo)</code> but I’m a little lost.</z><z id="t1609952462" t="ikitommi [:attrs {:href &quot;/_/_/users/U054UD60U&quot;}] try (m/deref Foo)"><y>#</y><d>2021-01-06</d><h>17:01</h><w>ikitommi</w><a>@ordnungswidrig</a> try <code>(m/deref Foo)</code></z><z id="t1609952535" t="ikitommi there is also m/deref-all, which peels all top-level RefSchema s."><y>#</y><d>2021-01-06</d><h>17:02</h><w>ikitommi</w>there is also <code>m/deref-all,</code> which peels all top-level <code>RefSchema</code>s.</z><z id="t1609952680" t="ikitommi also, you can always m/walk the schema with option :malli.core/walk-refs , which walks over all refs. Not sure of that one blows up with recursive schemas..."><y>#</y><d>2021-01-06</d><h>17:04</h><w>ikitommi</w>also, you can always <code>m/walk</code> the schema with option <code>:malli.core/walk-refs</code>, which walks over all refs. Not sure of that one blows up with recursive schemas...</z><z id="t1609954786" t="ordnungswidrig Oh, i had tried ref but not deref."><y>#</y><d>2021-01-06</d><h>17:39</h><w>ordnungswidrig</w>Oh, i had tried ref but not deref.</z><z id="t1610377889" t="hansbugge None of the comparator schemas have default error messages, e.g., (-&gt; (m/explain [:&gt; 0] -1) :errors first me/error-message) ;; =&gt; &quot;unknown error&quot; Is there a good reason why some simple error functions haven&apos;t been added to malli.error/default-errors other than &quot;no-one has done it yet&quot;? 🙂"><y>#</y><d>2021-01-11</d><h>15:11</h><w>hansbugge</w>None of the comparator schemas have default error messages, e.g.,
<pre>(-&gt; (m/explain [:&gt; 0] -1)
    :errors first me/error-message)
;; =&gt; &quot;unknown error&quot;</pre>
Is there a good reason why some simple error functions haven&apos;t been added to <code>malli.error/default-errors</code> other than &quot;no-one has done it yet&quot;? <b>🙂</b></z><z id="t1610379653" t="hansbugge I&apos;ve opened a PR with suggestions for some simple error functions https://github.com/metosin/malli/pull/332"><y>#</y><d>2021-01-11</d><h>15:40</h><r>hansbugge</r>I&apos;ve opened a PR with suggestions for some simple error functions <a href="https://github.com/metosin/malli/pull/332" target="_blank">https://github.com/metosin/malli/pull/332</a></z><z id="t1610390453" t="ikitommi Merged the PR, thanks!"><y>#</y><d>2021-01-11</d><h>18:40</h><r>ikitommi</r>Merged the PR, thanks!</z><z id="t1610736431" t="ikitommi 🚀 🚀 🚀 regex schemas merged in master! feel free to test: validate, explain, transform and generate - parsing/conform still wip."><y>#</y><d>2021-01-15</d><h>18:47</h><w>ikitommi</w><b>🚀</b> <b>🚀</b> <b>🚀</b>  regex schemas merged in master! feel free to test: validate, explain, transform and generate - parsing/conform still wip.</z><z id="t1610736946" t="ikitommi thanks to [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] , the impl is quite snappy, currently order(s) of magnitude faster than spec &amp; seqexp."><y>#</y><d>2021-01-15</d><h>18:55</h><w>ikitommi</w>thanks to <a>@nilern</a>, the impl is quite snappy, currently order(s) of magnitude faster than spec &amp; seqexp.</z><z id="t1610841849" t="lread I’m trying out malli for the first time. I’m using it to validate user entered options. I really like the humanize spell check support. Check out this helpful error message! Invalid inline options: #:test-doc-blocks{:read-cond [&quot;should be spelled :test-doc-blocks/reader-cond&quot;]} file: doc/design/namespaced-elements.adoc line: 277"><y>#</y><d>2021-01-17</d><h>00:04</h><w>lread</w>I’m trying out malli for the first time.  I’m using it to validate user entered options. I really like the humanize spell check support.  Check out this helpful error message!
<pre>Invalid inline options: #:test-doc-blocks{:read-cond [&quot;should be spelled :test-doc-blocks/reader-cond&quot;]}
 file: doc/design/namespaced-elements.adoc line: 277</pre></z><z id="t1610841871" t="lread Anyhoo, thanks!"><y>#</y><d>2021-01-17</d><h>00:04</h><w>lread</w>Anyhoo, thanks!</z><z id="t1610909426" t="naomarik I&apos;ve yet to update malli since before it had an actual version number. Looks way more feature rich now."><y>#</y><d>2021-01-17</d><h>18:50</h><w>naomarik</w>I&apos;ve yet to update malli since before it had an actual version number. Looks way more feature rich now.</z><z id="t1610910805" t="ikitommi the function schemas are in master, but not released. there is a bug with generating multi-arity functions and as the sequence/regex schemas are in, will add support for varags. Then good to release a new version. Hopefully much more and smaller releases after that."><y>#</y><d>2021-01-17</d><h>19:13</h><w>ikitommi</w>the function schemas are in master, but not released. there is a bug with generating multi-arity functions and as the sequence/regex schemas are in, will add support for varags. Then good to release a new version. Hopefully much more and smaller releases after that.</z><z id="t1610910870" t="ikitommi btw, comments welcome on the malli.error/humanize output: few options how to fix that: https://github.com/metosin/malli/pull/333#discussion_r559224770"><y>#</y><d>2021-01-17</d><h>19:14</h><w>ikitommi</w>btw, comments welcome on the <code>malli.error/humanize</code> output: few options how to fix that: <a href="https://github.com/metosin/malli/pull/333#discussion_r559224770" target="_blank">https://github.com/metosin/malli/pull/333#discussion_r559224770</a></z><z id="t1610999301" t="Samuel McHugh Hello, I&apos;m trying out Malli and I&apos;m wondering what is the idiomatic approach to spec&apos;ing a finit explicit set of values. Here&apos;s an example of a schema which works. (m/validate [:or [:= :foo] [:= :bar] [:= :baz]] :foo) ;=&gt; true The syntax isn&apos;t as compact as I&apos;d expect though. I&apos;d hope something like (m/validate #{:foo :bar :baz} :foo) could work but I haven&apos;t seen this in the docs anywhere. Do I have to set up a custom registry for this?"><y>#</y><d>2021-01-18</d><h>19:48</h><w>Samuel McHugh</w>Hello, I&apos;m trying out Malli and I&apos;m wondering what is the idiomatic approach to spec&apos;ing a finit explicit set of values. Here&apos;s an example of a schema which works.

<pre>(m/validate
  [:or [:= :foo]
       [:= :bar]
       [:= :baz]]
  :foo)
;=&gt; true</pre>
The syntax isn&apos;t as compact as I&apos;d expect though. I&apos;d hope something like
<pre>(m/validate
  #{:foo :bar :baz}
  :foo)</pre>
could work but I haven&apos;t seen this in the docs anywhere. Do I have to set up a custom registry for this?</z><z id="t1611000161" t="ikitommi [:attrs {:href &quot;/_/_/users/U0151JJA3FT&quot;}] try [:enum :foo :bar :baz] . Doc PRs welcome!"><y>#</y><d>2021-01-18</d><h>20:02</h><w>ikitommi</w><a>@smchugh230395</a> try <code>[:enum :foo :bar :baz]</code>. Doc PRs welcome!</z><z id="t1611047201" t="Samuel McHugh I will have a look after work today and make a doc PR. Thanks!"><y>#</y><d>2021-01-19</d><h>09:06</h><r>Samuel McHugh</r>I will have a look after work today and make a doc PR. Thanks!</z><z id="t1611079008" t="Samuel McHugh I&apos;m going to spend more time understanding what&apos;s available and possible before I submit any doc changes. There is a lot to chew on! Is there a native capacity to enforce uniqueness of items in a collection?"><y>#</y><d>2021-01-19</d><h>17:56</h><w>Samuel McHugh</w>I&apos;m going to spend more time understanding what&apos;s available and possible before I submit any doc changes. There is a lot to chew on!

Is there a native capacity to enforce uniqueness of items in a collection?</z><z id="t1611134321" t="ordnungswidrig [:attrs {:href &quot;/_/_/users/U0151JJA3FT&quot;}] can you use a set as the collection type?"><y>#</y><d>2021-01-20</d><h>09:18</h><w>ordnungswidrig</w><a>@smchugh230395</a> can you use a set as the collection type?</z><z id="t1611134454" t="Samuel McHugh That&apos;s a good idea but there is an order on the elements of the collection in my particular use-case. I can set up other ways of ensuring that only unique items enter the collection though so it isn&apos;t critical that Malli supports it out of the box."><y>#</y><d>2021-01-20</d><h>09:20</h><w>Samuel McHugh</w>That&apos;s a good idea but there is an order on the elements of the collection in my particular use-case. I can set up other ways of ensuring that only unique items enter the collection though so it isn&apos;t critical that Malli supports it out of the box.</z><z id="t1611135999" t="ordnungswidrig I see. So “ordered set” is what you need I guess."><y>#</y><d>2021-01-20</d><h>09:46</h><w>ordnungswidrig</w>I see. So “ordered set”  is what you need I guess.</z><z id="t1611136339" t="ordnungswidrig (m/validate [:and [:sequential any?] (fn [c] (= (count c) (count (set c)))) something like this?"><y>#</y><d>2021-01-20</d><h>09:52</h><w>ordnungswidrig</w><code>(m/validate [:and [:sequential any?] (fn [c] (= (count c) (count (set c))))</code> something like this?</z><z id="t1611152531" t="Samuel McHugh good one, I think i&apos;ll go with this"><y>#</y><d>2021-01-20</d><h>14:22</h><r>Samuel McHugh</r>good one, I think i&apos;ll go with this</z><z id="t1611154295" t="ordnungswidrig Pretty sure this one of the least optimized way to check for distinct elements (reduce (fn [xs x] (if (xs s) (reduced false) (conj xs s))) #{} coll) might be faster."><y>#</y><d>2021-01-20</d><h>14:51</h><r>ordnungswidrig</r>Pretty sure this one of the least optimized way to check for distinct elements <code>(reduce (fn [xs x] (if (xs s) (reduced false) (conj xs s))) #{} coll)</code> might be faster.</z><z id="t1611139582" t="ikitommi JSON Schema has “uniqueItems” attribute, I guess sequences could have :distict boolean property?"><y>#</y><d>2021-01-20</d><h>10:46</h><w>ikitommi</w>JSON Schema has “uniqueItems” attribute, I guess sequences could have <code>:distict</code> boolean property?</z><z id="t1611139589" t="ikitommi https://json-schema.org/understanding-json-schema/reference/array.html#uniqueness"><y>#</y><d>2021-01-20</d><h>10:46</h><r>ikitommi</r><a href="https://json-schema.org/understanding-json-schema/reference/array.html#uniqueness" target="_blank">https://json-schema.org/understanding-json-schema/reference/array.html#uniqueness</a></z><z id="t1611139666" t="ikitommi … would be [:sequential {:distinct true} any?]"><y>#</y><d>2021-01-20</d><h>10:47</h><r>ikitommi</r>… would be <code>[:sequential {:distinct true} any?]</code></z><z id="t1611142342" t="ordnungswidrig interesting"><y>#</y><d>2021-01-20</d><h>11:32</h><r>ordnungswidrig</r>interesting</z><z id="t1611151761" t="emccue I am somewhat meh on the coupling to json schema"><y>#</y><d>2021-01-20</d><h>14:09</h><r>emccue</r>I am somewhat meh on the coupling to json schema</z><z id="t1611151839" t="emccue is there some usecase or justification i am missing?"><y>#</y><d>2021-01-20</d><h>14:10</h><r>emccue</r>is there some usecase or justification i am missing?</z><z id="t1611255960" t="Daniel Miladinov Hi everyone, long-time listener, first-time caller here. I’m still kind of new to malli and I’m trying to develop a spec to validate a vector of strings, but some of the strings have different validations than the others. Looking at the https://github.com/metosin/malli#sequence-schemas , it seemed to me that I should use a sequence schema with something like [:cat …] ."><y>#</y><d>2021-01-21</d><h>19:06</h><w>Daniel Miladinov</w>Hi everyone, long-time listener, first-time caller here.
I’m still kind of new to malli and I’m trying to develop a spec to validate a vector of strings, but some of the strings have different validations than the others. Looking at the <a href="https://github.com/metosin/malli#sequence-schemas" target="_blank">https://github.com/metosin/malli#sequence-schemas</a>, it seemed to me that I should use a sequence schema with something like <code>[:cat …]</code>.</z><z id="t1611256028" t="Daniel Miladinov But I’m having a problem. According to the README, I should be able to do this: (m/validate [:cat string? int?] [&quot;foo&quot; 0]) ; =&gt; true But in my repl, I get this: (require &apos;[malli.core :as m]) =&gt; nil (m/validate [:cat string? int?] [&quot;foo&quot; 0]) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema :cat}"><y>#</y><d>2021-01-21</d><h>19:07</h><w>Daniel Miladinov</w>But I’m having a problem. According to the README, I should be able to do this:
<pre>(m/validate [:cat string? int?] [&quot;foo&quot; 0]) ; =&gt; true</pre>
But in my repl, I get this:
<pre>(require &apos;[malli.core :as m])
=&gt; nil
(m/validate [:cat string? int?] [&quot;foo&quot; 0])
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema :cat}</pre></z><z id="t1611257026" t="Daniel Miladinov The project I’m working in has reitit 0.5.11 as a direct dependency, which appears to pull in malli 0.2.1 as a transitive dependency."><y>#</y><d>2021-01-21</d><h>19:23</h><r>Daniel Miladinov</r>The project I’m working in has <code>reitit 0.5.11</code> as a direct dependency, which appears to pull in <code>malli 0.2.1</code> as a transitive dependency.</z><z id="t1611259342" t="ikitommi if you use deps, you can take a dependency to the latest commit of Malli, which has the sequence schemas. Will try to ship a Big 0.3.0 out within few weeks with those officially in."><y>#</y><d>2021-01-21</d><h>20:02</h><r>ikitommi</r>if you use deps, you can take a dependency to the latest commit of Malli, which has the sequence schemas. Will try to ship a Big 0.3.0 out within few weeks with those officially in.</z><z id="t1611259394" t="ikitommi There is also [:tuple string? int?] for fixed length vectors with schema for each element"><y>#</y><d>2021-01-21</d><h>20:03</h><r>ikitommi</r>There is also <code>[:tuple string? int?]</code> for fixed length vectors with schema for each element</z><z id="t1611259415" t="Daniel Miladinov Thank you!!!"><y>#</y><d>2021-01-21</d><h>20:03</h><r>Daniel Miladinov</r>Thank you!!!</z><z id="t1611259430" t="Daniel Miladinov That will serve my purposes in the meantime"><y>#</y><d>2021-01-21</d><h>20:03</h><r>Daniel Miladinov</r>That will serve my purposes in the meantime</z><z id="t1611414862" t="ikitommi m/conform landed in master by [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] ! #343 will change the names to m/parse and m/parser : (m/parse [:* [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]] [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;]) ;[{:prop &quot;-server&quot;, :val [:s &quot;foo&quot;]} ; {:prop &quot;-verbose&quot;, :val [:b true]} ; {:prop &quot;-user&quot;, :val [:s &quot;joe&quot;]}]"><y>#</y><d>2021-01-23</d><h>15:14</h><w>ikitommi</w><code>m/conform</code> landed in master by <a>@nilern</a>! #343 will change the names to <code>m/parse</code> and <code>m/parser</code>:
<pre>(m/parse
  [:* [:cat*
       [:prop string?]
       [:val [:alt*
              [:s string?]
              [:b boolean?]]]]]
  [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;])
;[{:prop &quot;-server&quot;, :val [:s &quot;foo&quot;]}
; {:prop &quot;-verbose&quot;, :val [:b true]}
; {:prop &quot;-user&quot;, :val [:s &quot;joe&quot;]}]</pre></z><z id="t1611483355" t="ikitommi by the power of generic schema walking (answer to #343): (require &apos;[malli.core :as m]) (defn normalize-properties [?schema] (m/walk ?schema (fn [schema _ children _] (if (vector? (m/form schema)) (into [(m/type schema) (m/properties schema)] children) (m/form schema))))) (normalize-properties [:map [:x int?] [:y [:tuple int? int?]] [:z [:set [:map [:x [:enum 1 2 3]]]]]]) ;[:map nil ; [:x nil int?] ; [:y nil [:tuple nil int? int?]] ; [:z nil [:set nil ; [:map nil ; [:x nil [:enum nil 1 2 3]]]]]]"><y>#</y><d>2021-01-24</d><h>10:15</h><w>ikitommi</w>by the power of generic schema walking (answer to #343):
<pre>(require &apos;[malli.core :as m])

(defn normalize-properties [?schema]
  (m/walk
    ?schema
    (fn [schema _ children _]
      (if (vector? (m/form schema))
        (into [(m/type schema) (m/properties schema)] children)
        (m/form schema)))))

(normalize-properties
  [:map
   [:x int?]
   [:y [:tuple int? int?]]
   [:z [:set [:map [:x [:enum 1 2 3]]]]]])
;[:map nil
; [:x nil int?]
; [:y nil [:tuple nil int? int?]]
; [:z nil [:set nil
;          [:map nil
;           [:x nil [:enum nil 1 2 3]]]]]]</pre></z><z id="t1611571410" t="ikitommi m/parse and m/parser now in master. Feedback and test reports most welcome."><y>#</y><d>2021-01-25</d><h>10:43</h><w>ikitommi</w><code>m/parse</code> and <code>m/parser</code> now in master. Feedback and test reports most welcome.</z><z id="t1611585957" t="kwrooijen m/parse looks great! I think that&apos;s going to clean up a lot of my code once I get a chance to use it"><y>#</y><d>2021-01-25</d><h>14:45</h><w>kwrooijen</w><code>m/parse</code> looks great! I think that&apos;s going to clean up a lot of my code once I get a chance to use it</z><z id="t1611599647" t="ikitommi updated README with parsing examples: https://github.com/metosin/malli#parsing-values"><y>#</y><d>2021-01-25</d><h>18:34</h><w>ikitommi</w>updated README with parsing examples: <a href="https://github.com/metosin/malli#parsing-values" target="_blank">https://github.com/metosin/malli#parsing-values</a></z><z id="t1611599819" t="ikitommi the hiccup example is from minimallist, thanks to [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] for the original example 🙂"><y>#</y><d>2021-01-25</d><h>18:36</h><r>ikitommi</r>the hiccup example is from minimallist, thanks to <a>@U8MJBRSR5</a> for the original example <b>🙂</b></z><z id="t1611599980" t="Vincent Cantin I like it 🙂"><y>#</y><d>2021-01-25</d><h>18:39</h><r>Vincent Cantin</r>I like it <b>🙂</b></z><z id="t1611601015" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] in Malli’s version, there is no indication that the :node is a vector. Was it intentional?"><y>#</y><d>2021-01-25</d><h>18:56</h><r>Vincent Cantin</r><a>@U055NJ5CC</a> in Malli’s version, there is no indication that the <code>:node</code> is a vector. Was it intentional?</z><z id="t1611602632" t="ikitommi Oh, that is missing. It accepts all sequences"><y>#</y><d>2021-01-25</d><h>19:23</h><r>ikitommi</r>Oh, that is missing. It accepts all sequences</z><z id="t1611602693" t="ikitommi can&apos;t compose with :and here, need to constraint in some other way"><y>#</y><d>2021-01-25</d><h>19:24</h><r>ikitommi</r>can&apos;t compose with <code>:and</code> here, need to constraint in some other way</z><z id="t1611603344" t="Vincent Cantin without the vector indication, the generator might create a list, that&apos;s a problem."><y>#</y><d>2021-01-25</d><h>19:35</h><r>Vincent Cantin</r>without the vector indication, the generator might create a list, that&apos;s a problem.</z><z id="t1611603472" t="ikitommi you can add :gen/fmap vec to gen a vec, but having a :kind etc. property would make it work in all the places (validate, gen, transform)"><y>#</y><d>2021-01-25</d><h>19:37</h><r>ikitommi</r>you can add <code>:gen/fmap vec</code> to gen a vec, but having a <code>:kind</code> etc. property would make it work in all the places (validate, gen, transform)</z><z id="t1611599751" t="ikitommi :or , :cat and :alt all use non-named branches, :or* , :cat* and :alt* are the named variants."><y>#</y><d>2021-01-25</d><h>18:35</h><w>ikitommi</w><code>:or</code>, <code>:cat</code> and <code>:alt</code> all use non-named branches, <code>:or*</code> , <code>:cat*</code> and <code>:alt*</code> are the named variants.</z><z id="t1611599766" t="ikitommi if somenone has better names for those, please suggest."><y>#</y><d>2021-01-25</d><h>18:36</h><w>ikitommi</w>if somenone has better names for those, please suggest.</z><z id="t1611600167" t="Vincent Cantin Naming things is hard, indeed."><y>#</y><d>2021-01-25</d><h>18:42</h><r>Vincent Cantin</r>Naming things is hard, indeed.</z><z id="t1611601758" t="oliver Hi! I&apos;m using malli for the first time on a project where I have to derive HTML-Forms from the body-structure of http-requests. So far the experience has been great – and much more natural than with spec. Now I feel the need for something I was unable to find in the Readme. Say I have the following schema definition: [:map {:closed true} [:a int? :b int?]] I would like to further constrain :b depending on :a , e.g.: - :b must be greater than :a — or — - :b should only be present iff :a is greater than 3 (nil otherwise) Is there a way to express this without recourse to [:fn ] schemas? I&apos;ll be thankful for any hints on this!"><y>#</y><d>2021-01-25</d><h>19:09</h><w>oliver</w>Hi! I&apos;m using malli for the first time on a project where I have to derive HTML-Forms from the body-structure of http-requests. So far the experience has been great – and much more natural than with spec.
Now I feel the need for something I was unable to find in the Readme. Say I have the following schema definition:

<code>[:map {:closed true} [:a int? :b int?]]</code>

I would like to further constrain <code>:b</code> depending on <code>:a</code>, e.g.:
- <code>:b</code> must be greater than <code>:a</code>
      — or —
- <code>:b</code> should only be present iff <code>:a</code> is greater than 3 (nil otherwise)

Is there a way to express this without recourse to <code>[:fn ]</code> schemas?

I&apos;ll be thankful for any hints on this!</z><z id="t1611608213" t="emccue how would I annotate a function for runtime checking at dev time?"><y>#</y><d>2021-01-25</d><h>20:56</h><w>emccue</w>how would I annotate a function for runtime checking at dev time?</z><z id="t1611609559" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] no such thing yet, but should be easy to add. contributions welcome. https://github.com/metosin/malli/issues/349"><y>#</y><d>2021-01-25</d><h>21:19</h><w>ikitommi</w><a>@emccue</a> no such thing yet, but should be easy to add. contributions welcome. <a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a></z><z id="t1611609655" t="ikitommi [:attrs {:href &quot;/_/_/users/UMWM02TED&quot;}] :and &amp; :fn is the way to do it now."><y>#</y><d>2021-01-25</d><h>21:20</h><w>ikitommi</w><a>@services</a> <code>:and</code> &amp; <code>:fn</code> is the way to do it now.</z><z id="t1611609664" t="ikitommi https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D"><y>#</y><d>2021-01-25</d><h>21:21</h><r>ikitommi</r><a href="https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D</a></z><z id="t1611770355" t="oliver Hi, sorry for taking so long to respond… many thanks for the playground example… I wasn&apos;t even aware that existed. I&apos;ll be using [:fn …] then. straightforward!"><y>#</y><d>2021-01-27</d><h>17:59</h><r>oliver</r>Hi, sorry for taking so long to respond… many thanks for the playground example… I wasn&apos;t even aware that existed. I&apos;ll be using [:fn …] then. straightforward!</z><z id="t1611838212" t="danielneal Is there a way of converting malli definitions to swagger 3 format?"><y>#</y><d>2021-01-28</d><h>12:50</h><w>danielneal</w>Is there a way of converting malli definitions to swagger 3 format?</z><z id="t1611848783" t="juhoteperi Not sure about Swagger 3, malli.swagger might be do Swagger 2, but not sure if there is difference in this level. It is just JSON Schema with a few extensions."><y>#</y><d>2021-01-28</d><h>15:46</h><r>juhoteperi</r>Not sure about Swagger 3, <code>malli.swagger</code> might be do Swagger 2, but not sure if there is difference in this level. It is just JSON Schema with a few extensions.</z><z id="t1611852690" t="danielneal I&apos;ve been reading the swagger specification and it&apos;s massive"><y>#</y><d>2021-01-28</d><h>16:51</h><r>danielneal</r>I&apos;ve been reading the swagger specification and it&apos;s massive</z><z id="t1611852701" t="danielneal https://swagger.io/specification/"><y>#</y><d>2021-01-28</d><h>16:51</h><r>danielneal</r><a href="https://swagger.io/specification/" target="_blank">https://swagger.io/specification/</a></z><z id="t1611852818" t="danielneal The most obvious difference is that in JSON Schema and Swagger 2, there is a &quot;definitions&quot; key for common objects, whereas this doesn&apos;t exist in OpenAPI 3"><y>#</y><d>2021-01-28</d><h>16:53</h><r>danielneal</r>The most obvious difference is that in JSON Schema and Swagger 2, there is a &quot;definitions&quot; key for common objects, whereas this doesn&apos;t exist in OpenAPI 3</z><z id="t1611852859" t="danielneal I think it&apos;s replaced by the components object, or the schemas property on the components object"><y>#</y><d>2021-01-28</d><h>16:54</h><r>danielneal</r>I think it&apos;s replaced by the components object, or the schemas property on the components object</z><z id="t1611852961" t="juhoteperi With currently implementation, Malli only handles the schema -&gt; properties part. Reitit/Ring-swagger/Compojure-api does the higher level Swagger2 generation."><y>#</y><d>2021-01-28</d><h>16:56</h><r>juhoteperi</r>With currently implementation, Malli only handles the schema -&gt; properties part. Reitit/Ring-swagger/Compojure-api does the higher level Swagger2 generation.</z><z id="t1611853066" t="juhoteperi The properties part (JSON Schema) probably doesn&apos;t change much if at all between Swagger2 / OpenAPI 3."><y>#</y><d>2021-01-28</d><h>16:57</h><r>juhoteperi</r>The properties part (JSON Schema) probably doesn&apos;t change much if at all between Swagger2 / OpenAPI 3.</z><z id="t1611853669" t="danielneal do you know if there are plans to support OpenAPI 3 in reitit?"><y>#</y><d>2021-01-28</d><h>17:07</h><r>danielneal</r>do you know if there are plans to support OpenAPI 3 in reitit?</z><z id="t1611853692" t="danielneal ah yeah, there&apos;s an open issue https://github.com/metosin/reitit/issues/84"><y>#</y><d>2021-01-28</d><h>17:08</h><r>danielneal</r>ah yeah, there&apos;s an open issue <a href="https://github.com/metosin/reitit/issues/84" target="_blank">https://github.com/metosin/reitit/issues/84</a></z><z id="t1611838843" t="ikitommi Just chatted with [:attrs {:href &quot;/_/_/users/U061V0GG2&quot;}] on Metosin internal about that. should be, not atm. should be a thin layer on top of malli.json-schema ."><y>#</y><d>2021-01-28</d><h>13:00</h><w>ikitommi</w>Just chatted with <a>@juhoteperi</a> on Metosin internal about that. should be, not atm. should be a thin layer on top of <code>malli.json-schema</code>.</z><z id="t1611838879" t="ikitommi who would like to contribute those?"><y>#</y><d>2021-01-28</d><h>13:01</h><w>ikitommi</w>who would like to contribute those?</z><z id="t1611839544" t="danielneal haha great timing"><y>#</y><d>2021-01-28</d><h>13:12</h><w>danielneal</w>haha great timing</z><z id="t1611841140" t="danielneal ah oh you mean you chatted with him after my comment 🙂"><y>#</y><d>2021-01-28</d><h>13:39</h><w>danielneal</w>ah oh you mean you chatted with him after my comment <b>🙂</b></z><z id="t1611841159" t="danielneal I could have a look at it I guess, but swagger and malli are both completely new to me"><y>#</y><d>2021-01-28</d><h>13:39</h><w>danielneal</w>I could have a look at it I guess, but swagger and malli are both completely new to me</z><z id="t1611841218" t="ikitommi Just = yesterday. https://github.com/metosin/malli/pull/354"><y>#</y><d>2021-01-28</d><h>13:40</h><w>ikitommi</w>Just = yesterday. <a href="https://github.com/metosin/malli/pull/354" target="_blank">https://github.com/metosin/malli/pull/354</a></z><z id="t1611846651" t="ikitommi this is going to be so good."><y>#</y><d>2021-01-28</d><h>15:10</h><w>ikitommi</w>this is going to be so good.</z><z id="t1611846704" t="ikitommi"><y>#</y><d>2021-01-28</d><h>15:11</h><w>ikitommi</w></z><z id="t1611848783" t="juhoteperi Not sure about Swagger 3, malli.swagger might be do Swagger 2, but not sure if there is difference in this level. It is just JSON Schema with a few extensions."><y>#</y><d>2021-01-28</d><h>15:46</h><w>juhoteperi</w>Not sure about Swagger 3, <code>malli.swagger</code> might be do Swagger 2, but not sure if there is difference in this level. It is just JSON Schema with a few extensions.</z><z id="t1611917021" t="danielneal what order do :and schemas operate in"><y>#</y><d>2021-01-29</d><h>10:43</h><w>danielneal</w>what order do <code>:and</code> schemas operate in</z><z id="t1611917033" t="danielneal is it possible to do (m/explain [:and int? (m/-simple-schema {:pred #(&gt; % 3)})] &quot;asdf&quot;)"><y>#</y><d>2021-01-29</d><h>10:43</h><w>danielneal</w>is it possible to do
<pre>(m/explain [:and
              int?
              (m/-simple-schema
                {:pred #(&gt; % 3)})] &quot;asdf&quot;)</pre></z><z id="t1611917070" t="danielneal and have the int? check prevent the pred from running and erroring?"><y>#</y><d>2021-01-29</d><h>10:44</h><w>danielneal</w>and have the <code>int?</code> check prevent the pred from running and erroring?</z><z id="t1611918173" t="danielneal like in spec (s/def ::greater-than-3 (s/and int? #(&gt; % 3)))"><y>#</y><d>2021-01-29</d><h>11:02</h><w>danielneal</w>like in spec
<pre>(s/def ::greater-than-3
    (s/and int? #(&gt; % 3)))</pre></z><z id="t1611918803" t="dharrigan This will work..."><y>#</y><d>2021-01-29</d><h>11:13</h><w>dharrigan</w>This will work...</z><z id="t1611918810" t="dharrigan (def foo [:and int? [:fn (fn [x] (&gt; x 3))]])"><y>#</y><d>2021-01-29</d><h>11:13</h><w>dharrigan</w><code>(def foo [:and int? [:fn (fn [x] (&gt; x 3))]])</code></z><z id="t1611918819" t="dharrigan #&apos;user/foo user=&gt; (m/validate foo &quot;abcd&quot;) false user=&gt; (m/validate foo 1) false user=&gt; (m/validate foo 3) false user=&gt; (m/validate foo 4) true"><y>#</y><d>2021-01-29</d><h>11:13</h><w>dharrigan</w><pre>#&apos;user/foo
user=&gt; (m/validate foo &quot;abcd&quot;)
false
user=&gt; (m/validate foo 1)
false
user=&gt; (m/validate foo 3)
false
user=&gt; (m/validate foo 4)
true</pre></z><z id="t1611919001" t="dharrigan You can, of course, shorten it, i.e., (def foo [:and int? [:fn #(&gt; % 3)]])"><y>#</y><d>2021-01-29</d><h>11:16</h><w>dharrigan</w>You can, of course, shorten it, i.e., <code>(def foo [:and int? [:fn #(&gt; % 3)]])</code></z><z id="t1611919083" t="danielneal interesting, I wonder why :fn works but -simple-schema doesn&apos;t"><y>#</y><d>2021-01-29</d><h>11:18</h><w>danielneal</w>interesting, I wonder why <code>:fn</code> works but <code>-simple-schema</code> doesn&apos;t</z><z id="t1611919140" t="dharrigan It&apos;s in the documentation to use that 🙂"><y>#</y><d>2021-01-29</d><h>11:19</h><w>dharrigan</w>It&apos;s in the documentation to use that <b>🙂</b></z><z id="t1611919146" t="dharrigan You can try it out here as well "><y>#</y><d>2021-01-29</d><h>11:19</h><w>dharrigan</w>You can try it out here as well <code></code></z><z id="t1611919606" t="danielneal cool, I&apos;ll use :fn 🙂"><y>#</y><d>2021-01-29</d><h>11:26</h><w>danielneal</w>cool, I&apos;ll use <code>:fn</code> <b>🙂</b></z><z id="t1611919796" t="dharrigan Actually, it works with simple-schema too"><y>#</y><d>2021-01-29</d><h>11:29</h><w>dharrigan</w>Actually, it works with simple-schema too</z><z id="t1611919809" t="dharrigan user=&gt; (def foo2 [:and int? (m/-simple-schema {:pred #(&gt; % 3)})]) #&apos;user/foo2 user=&gt; (m/validate foo2 4) true user=&gt; (m/validate foo2 3) false user=&gt; (m/validate foo2 1) false user=&gt; (m/validate foo2 &quot;and&quot;) false user=&gt; "><y>#</y><d>2021-01-29</d><h>11:30</h><w>dharrigan</w><pre>user=&gt; (def foo2 [:and int? (m/-simple-schema {:pred #(&gt; % 3)})])
#&apos;user/foo2
user=&gt; (m/validate foo2 4)
true
user=&gt; (m/validate foo2 3)
false
user=&gt; (m/validate foo2 1)
false
user=&gt; (m/validate foo2 &quot;and&quot;)
false
user=&gt; </pre></z><z id="t1611919839" t="dharrigan I missed that, so I suppose you can use that as well 🙂"><y>#</y><d>2021-01-29</d><h>11:30</h><w>dharrigan</w>I missed that, so I suppose you can use that as well <b>🙂</b></z><z id="t1611919882" t="dharrigan choices...choices..."><y>#</y><d>2021-01-29</d><h>11:31</h><w>dharrigan</w>choices...choices...</z><z id="t1611920474" t="danielneal [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] , validate succeeds, but explain fails"><y>#</y><d>2021-01-29</d><h>11:41</h><w>danielneal</w><a>@dharrigan</a>, validate succeeds, but explain fails</z><z id="t1611920480" t="danielneal could be a bug perhaps?"><y>#</y><d>2021-01-29</d><h>11:41</h><w>danielneal</w>could be a bug perhaps?</z><z id="t1611920499" t="danielneal (m/explain foo2 &quot;and&quot;) =&gt; java.lang.ClassCastException"><y>#</y><d>2021-01-29</d><h>11:41</h><w>danielneal</w><code>(m/explain foo2 &quot;and&quot;)</code> =&gt; java.lang.ClassCastException</z><z id="t1611922104" t="danielneal I guess it does makes sense that explain on an :and would give all the reasons something fails, but it doesn&apos;t make sense -simple-schema fails where :fn doesn&apos;t."><y>#</y><d>2021-01-29</d><h>12:08</h><w>danielneal</w>I guess it does makes sense that explain on an <code>:and</code> would give all the reasons something fails, but it doesn&apos;t make sense <code>-simple-schema</code> fails where <code>:fn</code> doesn&apos;t.</z><z id="t1611922172" t="juhoteperi If you are just checking &gt; you could also use [:int {:min 3}] or [:and int? [:&gt;= 3]] ."><y>#</y><d>2021-01-29</d><h>12:09</h><w>juhoteperi</w>If you are just checking <code>&gt;</code> you could also use <code>[:int {:min 3}]</code> or <code>[:and int? [:&gt;= 3]]</code>.</z><z id="t1611922186" t="juhoteperi First one works best with JSON Schema"><y>#</y><d>2021-01-29</d><h>12:09</h><w>juhoteperi</w>First one works best with JSON Schema</z><z id="t1611922345" t="danielneal ah, the actual example here is a bit different, it&apos;s for a kebab case keyword"><y>#</y><d>2021-01-29</d><h>12:12</h><w>danielneal</w>ah, the actual example here is a bit different, it&apos;s for a kebab case keyword</z><z id="t1611922425" t="danielneal [:and {:description &quot;A keyword joined by hyphens&quot; :swagger/description &quot;A string joined by hyphens&quot; :swagger/example &quot;kebab-case-string&quot; :error/message &quot;should be a kebab-case keyword&quot;} keyword? [:fn kebab-case-keyword?]]"><y>#</y><d>2021-01-29</d><h>12:13</h><w>danielneal</w><pre>[:and
    {:description &quot;A keyword joined by hyphens&quot;
     :swagger/description &quot;A string joined by hyphens&quot;
     :swagger/example &quot;kebab-case-string&quot;
     :error/message &quot;should be a kebab-case keyword&quot;}
     keyword?
    [:fn kebab-case-keyword?]]</pre></z></g><g id="s10"><z id="t1611922476" t="danielneal (where in this case kebab-case-keyword? fails on non-keywords)"><y>#</y><d>2021-01-29</d><h>12:14</h><w>danielneal</w>(where in this case kebab-case-keyword? fails on non-keywords)</z><z id="t1611932922" t="ikitommi WIP: Schemas of Schemas: (-&gt; (m/-simple-schema {:type :int :pred string? :properties-schema [:map [:min nat-int?] [:max nat-int?]] :property-pred (m/-min-max-pred nil)}) (m/properties-schema)) ; =&gt; [:map [:min nat-int?] [:max nat-int?]] also: (let [OneOf (m/-simple-schema (fn [{:keys [count]} values] (let [value? (set values)] {:type :user/over :pred value? :properties-schema [:map [:count [:= count]]] :children-schema (into [:tuple] (map (fn [x] [:= x]) values)) :type-properties {:error/message (str &quot;should be one of &quot; values) :json-schema {:type &quot;oneOf&quot;, :values values}}}))) schema (m/schema [OneOf {:count 6} 1 2 3 4 5 6])] {:properties-schema (m/properties-schema schema) :children-schema (m/children-schema schema)}) ;{:properties-schema [:map [:count [:= 6]]] ; :children-schema [:tuple [:= 1] [:= 2] [:= 3] [:= 4] [:= 5] [:= 6]]}"><y>#</y><d>2021-01-29</d><h>15:08</h><w>ikitommi</w>WIP: Schemas of Schemas:
<pre>(-&gt; (m/-simple-schema
      {:type :int
       :pred string?
       :properties-schema [:map [:min nat-int?] [:max nat-int?]]
       :property-pred (m/-min-max-pred nil)})
    (m/properties-schema))
; =&gt; [:map [:min nat-int?] [:max nat-int?]]</pre>
also:
<pre>(let [OneOf (m/-simple-schema
              (fn [{:keys [count]} values]
                (let [value? (set values)]
                  {:type :user/over
                   :pred value?
                   :properties-schema [:map [:count [:= count]]]
                   :children-schema (into [:tuple] (map (fn [x] [:= x]) values))
                   :type-properties {:error/message (str &quot;should be one of &quot; values)
                                     :json-schema {:type &quot;oneOf&quot;, :values values}}})))
      schema (m/schema [OneOf {:count 6} 1 2 3 4 5 6])]
  {:properties-schema (m/properties-schema schema)
   :children-schema (m/children-schema schema)})
;{:properties-schema [:map [:count [:= 6]]]
; :children-schema [:tuple [:= 1] [:= 2] [:= 3] [:= 4] [:= 5] [:= 6]]}</pre></z><z id="t1612357508" t="danielneal lol, trolling hard rich"><y>#</y><d>2021-02-03</d><h>13:05</h><w>danielneal</w>lol, trolling hard <b>rich</b></z><z id="t1612367520" t="pbaille Hi, i&apos;m playing with malli and am confused by this example from the README: (m/validate [:? int?] [1 2]) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema :?}"><y>#</y><d>2021-02-03</d><h>15:52</h><w>pbaille</w>Hi, i&apos;m playing with malli and am confused by this example from the README:
<pre>(m/validate [:? int?] [1 2])</pre>
<code>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).</code>
<code>:malli.core/invalid-schema {:schema :?}</code></z><z id="t1612369400" t="ikitommi [:attrs {:href &quot;/_/_/users/U0A7SU3FS&quot;}] README describes what is in the master, sequence/regex schemas are not in official release. If you take the latest commit as dependency via deps, there are there"><y>#</y><d>2021-02-03</d><h>16:23</h><w>ikitommi</w><a>@pbaille</a> README describes what is in the master, sequence/regex schemas are not in official release. If you take the latest commit as dependency via deps, there are there</z><z id="t1612369445" t="ikitommi will cut a release soon, work needed for the function schemas still"><y>#</y><d>2021-02-03</d><h>16:24</h><w>ikitommi</w>will cut a release soon, work needed for the function schemas still</z><z id="t1612369895" t="pbaille [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thank you a lot 🙂"><y>#</y><d>2021-02-03</d><h>16:31</h><w>pbaille</w><a>@ikitommi</a> thank you a lot <b>🙂</b></z><z id="t1612448864" t="dakra How can I read the properties of attributes in a map. E.g. the description of one-attr in this example (def test-schema (malli/schema [:map {:description &quot;test schema desc.&quot;} [:one-attr {:description &quot;attr description&quot;} string?]])) (malli/properties test-schema) ;; =&gt; {:description &quot;test schema desc.&quot;} (malli/properties (mu/get test-schema :one-attr)) ;; =&gt; nil "><y>#</y><d>2021-02-04</d><h>14:27</h><w>dakra</w>How can I read the properties of attributes in a map. E.g. the description of one-attr in this example
<pre>(def test-schema
    (malli/schema [:map {:description &quot;test schema desc.&quot;}
                   [:one-attr {:description &quot;attr description&quot;} string?]]))

  (malli/properties test-schema)  ;; =&gt; {:description &quot;test schema desc.&quot;}
  
  (malli/properties (mu/get test-schema :one-attr))  ;; =&gt; nil</pre>
</z><z id="t1612455929" t="ikitommi [:attrs {:href &quot;/_/_/users/UFAP0C8KU&quot;}] try (mu/find schema key) and you can iterate the child entries with m/children"><y>#</y><d>2021-02-04</d><h>16:25</h><w>ikitommi</w><a>@daniel415</a> try <code>(mu/find schema key)</code> and you can iterate the child entries with <code>m/children</code></z><z id="t1612456256" t="dakra The mu/get does work and gives me the correct schema back but just m/properties is not returning anything. (only for maps) And m/children is not working in my example? (-&gt; (malli/schema [:map {:description &quot;test schema desc.&quot;} [:one-attr {:description &quot;attr description&quot;} string?]]) (mu/find :one-attr) malli/children) return this error Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:12). :malli.core/invalid-schema {:schema :one-attr}"><y>#</y><d>2021-02-04</d><h>16:30</h><w>dakra</w>The <code>mu/get</code> does work and gives me the correct schema back but just <code>m/properties</code> is not returning anything. (only for maps)

And <code>m/children</code> is not working in my example?
<pre>(-&gt; (malli/schema [:map {:description &quot;test schema desc.&quot;}
                     [:one-attr {:description &quot;attr description&quot;} string?]])
      (mu/find :one-attr)
      malli/children)</pre>
return this error
<pre>Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:12).
:malli.core/invalid-schema {:schema :one-attr}</pre></z><z id="t1612456344" t="ikitommi try removing the last m/children"><y>#</y><d>2021-02-04</d><h>16:32</h><r>ikitommi</r>try removing the last m/children</z><z id="t1612456380" t="ikitommi mu/find should return the entry tuple, props being the second value"><y>#</y><d>2021-02-04</d><h>16:33</h><r>ikitommi</r><code>mu/find</code> should return the entry tuple, props being the second value</z><z id="t1612456501" t="ikitommi also, this should hold: (-&gt; [:map [:x [:int {:default 1}]]] (m/get :x) (m/properties)) ;; -&gt; {:default 1}"><y>#</y><d>2021-02-04</d><h>16:35</h><r>ikitommi</r>also, this should hold:
<pre>(-&gt; [:map [:x [:int {:default 1}]]]
    (m/get :x)
    (m/properties))
;; -&gt; {:default 1}</pre></z><z id="t1612456519" t="ikitommi coding blind from a phone, might contain errors :)"><y>#</y><d>2021-02-04</d><h>16:35</h><r>ikitommi</r>coding blind from a phone, might contain errors :)</z><z id="t1612456573" t="ikitommi but: maps, map entries and map entry values can all have properties"><y>#</y><d>2021-02-04</d><h>16:36</h><r>ikitommi</r>but: maps, map entries and map entry values can  all have properties</z><z id="t1612456655" t="dakra Hmm, your example works. But when I simply have string? or so it doesn&apos;t work. (-&gt; [:map [:x {:default 1} string?]] (mu/get :x) (m/properties)) ;; =&gt; nil"><y>#</y><d>2021-02-04</d><h>16:37</h><r>dakra</r>Hmm, your example works. But when I simply have <code>string?</code> or so it doesn&apos;t work.
<pre>(-&gt; [:map [:x {:default 1} string?]]
      (mu/get :x)
      (m/properties))
  ;; =&gt; nil</pre></z><z id="t1612456734" t="dakra So this is the equivalent that works: (-&gt; [:map [:x [:string {:default 1}]]] (mu/get :x) (m/properties)) ;; =&gt; {:default 1}"><y>#</y><d>2021-02-04</d><h>16:38</h><r>dakra</r>So this is the equivalent that works:
<pre>(-&gt; [:map [:x [:string {:default 1}]]]
      (mu/get :x)
      (m/properties))
  ;; =&gt; {:default 1}</pre></z><z id="t1612464749" t="ikitommi string? doesn’t have properties. is is short format for [string?] . You can add properties to it too, e.g. [string? {:default 1}] . Full example: (-&gt; [:map [:x [string? {:default 1}]]] (mu/get :x) (m/properties)) ;; =&gt; {:default 1} (still not at malli repl, just guessing what it returns)"><y>#</y><d>2021-02-04</d><h>18:52</h><r>ikitommi</r><code>string?</code> doesn’t have properties. is is short format for <code>[string?]</code>. You can add properties to it too, e.g. <code>[string? {:default 1}]</code>. Full example:
<pre>(-&gt; [:map [:x [string? {:default 1}]]]
      (mu/get :x)
      (m/properties))
  ;; =&gt; {:default 1}</pre>
(still not at malli repl, just guessing what it returns)</z><z id="t1612465085" t="ikitommi now at the repl: (def Schema [:map {:in &quot;map&quot;} [:x {:in &quot;entry&quot;} [:string {:in &quot;value&quot;}]]]) (m/properties Schema) ;; =&gt; {:in &quot;map&quot;} (-&gt; Schema (mu/find :x) (second)) ;; =&gt; {:in &quot;entry&quot;} (-&gt; Schema (mu/get :x) (m/properties)) ;; =&gt; {:in &quot;value&quot;}&apos;"><y>#</y><d>2021-02-04</d><h>18:58</h><r>ikitommi</r>now at the repl:
<pre>(def Schema
  [:map {:in &quot;map&quot;}
   [:x {:in &quot;entry&quot;} [:string {:in &quot;value&quot;}]]])

(m/properties Schema)
;; =&gt; {:in &quot;map&quot;}

(-&gt; Schema
    (mu/find :x)
    (second))
;; =&gt; {:in &quot;entry&quot;}

(-&gt; Schema
    (mu/get :x)
    (m/properties))
;; =&gt; {:in &quot;value&quot;}&apos;</pre></z><z id="t1612465209" t="ikitommi some helpers: (defn entry-properties [schema key] (-&gt; schema (mu/find key) (second))) (defn value-properties [schema key] (-&gt; schema (mu/get key) (m/properties))) (m/properties Schema) ;; =&gt; {:in &quot;map&quot;} (entry-properties Schema :x) ;; =&gt; {:in &quot;entry&quot;} (value-properties Schema :x) ;; =&gt; {:in &quot;value}"><y>#</y><d>2021-02-04</d><h>19:00</h><r>ikitommi</r>some helpers:
<pre>(defn entry-properties [schema key]
  (-&gt; schema (mu/find key) (second)))

(defn value-properties [schema key]
  (-&gt; schema (mu/get key) (m/properties)))

(m/properties Schema) ;; =&gt; {:in &quot;map&quot;}
(entry-properties Schema :x) ;; =&gt; {:in &quot;entry&quot;}
(value-properties Schema :x) ;; =&gt; {:in &quot;value}</pre></z><z id="t1612467895" t="dakra OK, thank you very much. Now it&apos;s clear. I wasn&apos;t aware that string? is shorthand for [string?] and also didn&apos;t really think about the difference between entry and value properties. Makes sense now 🙂"><y>#</y><d>2021-02-04</d><h>19:44</h><r>dakra</r>OK, thank you very much. Now it&apos;s clear. I wasn&apos;t aware that <code>string?</code> is shorthand for <code>[string?]</code> and also didn&apos;t really think about the difference between entry and value properties. Makes sense now <b>🙂</b></z><z id="t1612604728" t="ikitommi m/unparse and m/unparser landed in master! parse + unparse with hiccup: (def Hiccup [:schema {:registry {&quot;hiccup&quot; [:or* [:node [:cat* [:name keyword?] [:props [:? [:map-of keyword? any?]]] [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]] [:primitive [:or* [:nil nil?] [:boolean boolean?] [:number number?] [:text string?]]]]}} &quot;hiccup&quot;]) (m/parse Hiccup [:div {:class [:foo :bar]} [:p &quot;Hello, world of data&quot;]]) ;[:node ; {:name :div, ; :props {:class [:foo :bar]}, ; :children [[:node ; {:name :p ; :props nil ; :children [[:primitive [:text &quot;Hello, world of data&quot;]]]}]]}] (-&gt;&gt; [:div {:class [:foo :bar]} [:p &quot;Hello, world of data&quot;]] (m/parse Hiccup) (m/unparse Hiccup)) ;[:div {:class [:foo :bar]} ; [:p &quot;Hello, world of data&quot;]]"><y>#</y><d>2021-02-06</d><h>09:45</h><w>ikitommi</w><code>m/unparse</code> and <code>m/unparser</code> landed in master!  parse + unparse with hiccup:
<pre>(def Hiccup
  [:schema
   {:registry {&quot;hiccup&quot; [:or*
                         [:node [:cat*
                                 [:name keyword?]
                                 [:props [:? [:map-of keyword? any?]]]
                                 [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]]
                         [:primitive [:or*
                                      [:nil nil?]
                                      [:boolean boolean?]
                                      [:number number?]
                                      [:text string?]]]]}}
   &quot;hiccup&quot;])

(m/parse
  Hiccup
  [:div {:class [:foo :bar]}
   [:p &quot;Hello, world of data&quot;]])
;[:node
; {:name :div,
;  :props {:class [:foo :bar]},
;  :children [[:node
;              {:name :p
;               :props nil
;               :children [[:primitive [:text &quot;Hello, world of data&quot;]]]}]]}]


(-&gt;&gt; [:div {:class [:foo :bar]}
      [:p &quot;Hello, world of data&quot;]]
     (m/parse Hiccup)
     (m/unparse Hiccup))
;[:div {:class [:foo :bar]}
; [:p &quot;Hello, world of data&quot;]]</pre></z><z id="t1612604976" t="ikitommi two small things for 0.3.0 with all the stuff in."><y>#</y><d>2021-02-06</d><h>09:49</h><w>ikitommi</w>two small things for 0.3.0 with all the stuff in.</z><z id="t1612606828" t="borkdude nice!"><y>#</y><d>2021-02-06</d><h>10:20</h><w>borkdude</w>nice!</z><z id="t1612606838" t="borkdude this is like conform right?"><y>#</y><d>2021-02-06</d><h>10:20</h><w>borkdude</w>this is like conform right?</z><z id="t1612608022" t="ikitommi yes, same as s/confom and s/unform . At the moment, there are no property-based custom parsers/unparsers that a user could add (like custom property based transformers) and in case of error, just ::m/invalid is returned. I think we can later combine -parse , -unparse and -explain implementations together, so that one can see partially parsed results and get more details when parsing/unparsing fails (same output as in -explain )."><y>#</y><d>2021-02-06</d><h>10:40</h><w>ikitommi</w>yes, same as <code>s/confom</code> and  <code>s/unform</code>. At the moment, there are no property-based custom parsers/unparsers that a user could add (like custom property based transformers) and in case of error, just <code>::m/invalid</code> is returned. I think we can later combine <code>-parse</code>, <code>-unparse</code> and <code>-explain</code> implementations together, so that one can see partially parsed results and get more details when parsing/unparsing fails (same output as in <code>-explain</code>).</z><z id="t1612687309" t="ikitommi Not sure how useful the function schema checking is in real life (maybe for tooling?), but here’s the wip: (require &apos;[malli.generator :as mg]) (def check (mg/function-checker [:function [1 [:=&gt; [:cat :int] :int]] [2 [:=&gt; [:cat :int :int] [:int {:max 10}]]]])) (check (fn ([x] x) ([x y] (mod (+ x y) 10)))) ; =&gt; nil (check (fn ([x] x) ([x y] (+ x y)))) ;({:total-nodes-visited 18, ; :depth 6, ; :pass? false, ; :result false, ; :result-data nil, ; :time-shrinking-ms 0, ; :smallest [(0 11)], ; :malli.core/schema [:=&gt; [:cat :int :int] [:int {:max 10}]]}) (check (fn ([x y] (mod (+ x y) 10)))) ;({:total-nodes-visited 0, ; :depth 0, ; :pass? false, ; :result &quot;Wrong number of args (1) passed to: user/eval97462/fn--97463&quot;, ; :time-shrinking-ms 0, ; :smallest [(0)], ; :malli.core/schema [:=&gt; [:cat :int] :int]})"><y>#</y><d>2021-02-07</d><h>08:41</h><w>ikitommi</w>Not sure how useful the function schema checking is in real life (maybe for tooling?), but here’s the wip:
<pre>(require &apos;[malli.generator :as mg])

(def check
  (mg/function-checker
    [:function
     [1 [:=&gt; [:cat :int] :int]]
     [2 [:=&gt; [:cat :int :int] [:int {:max 10}]]]]))

(check
  (fn
    ([x] x)
    ([x y] (mod (+ x y) 10))))
; =&gt; nil

(check
  (fn
    ([x] x)
    ([x y] (+ x y))))
;({:total-nodes-visited 18,
;  :depth 6,
;  :pass? false,
;  :result false,
;  :result-data nil,
;  :time-shrinking-ms 0,
;  :smallest [(0 11)],
;  :malli.core/schema [:=&gt; [:cat :int :int] [:int {:max 10}]]})

(check
  (fn
    ([x y] (mod (+ x y) 10))))
;({:total-nodes-visited 0,
;  :depth 0,
;  :pass? false,
;  :result &quot;Wrong number of args (1) passed to: user/eval97462/fn--97463&quot;,
;  :time-shrinking-ms 0,
;  :smallest [(0)],
;  :malli.core/schema [:=&gt; [:cat :int] :int]})</pre></z><z id="t1612768585" t="ikitommi this [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] , in master, will be released soon."><y>#</y><d>2021-02-08</d><h>07:16</h><r>ikitommi</r>this <a>@UG9U7TPDZ</a>, in master, will be released soon.</z><z id="t1612688493" t="caumond hi, I search a little bit long before finding that representing date in malli could be easily done with inst? Is it a recommended approach? I have a doubt as I would expect to find a reference of that in the malli doc which I did not."><y>#</y><d>2021-02-07</d><h>09:01</h><w>caumond</w>hi, I search a little bit long before finding that representing date in malli could be easily done with inst? Is it a recommended approach? I have a doubt as I would expect to find a reference of that in the malli doc which I did not.</z><z id="t1612696856" t="ikitommi inst? is ok, but see https://github.com/metosin/malli/issues/49"><y>#</y><d>2021-02-07</d><h>11:20</h><w>ikitommi</w><code>inst?</code> is ok, but see <a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a></z><z id="t1612717950" t="caumond Yes, I saw the PR, it was not completely enlightening. I understood something is missing, some of the proposal, but I did not understand there what is the recommend approach awaiting for that PR to be merged."><y>#</y><d>2021-02-07</d><h>17:12</h><r>caumond</r>Yes, I saw the PR, it was not completely enlightening. I understood something is missing, some of the proposal, but I did not understand there what is the recommend approach awaiting for that PR to be merged.</z><z id="t1612718033" t="caumond I keep the &quot;`inst` is ok&quot; part !"><y>#</y><d>2021-02-07</d><h>17:13</h><r>caumond</r>I keep the &quot;`inst` is ok&quot; part !</z><z id="t1612696920" t="ikitommi :not merged in master: (mg/sample [:not :string]) ;([] ; #{} ; nil ; \$ ; nil ; nil ; {#uuid&quot;3565d7f3-5561-439f-9368-5bfdbd03fc8e&quot; -2/3} ; () ; [\^] ; [[-110317951337N \:] #{2.15625 R+3/qfp}])"><y>#</y><d>2021-02-07</d><h>11:22</h><w>ikitommi</w><code>:not</code> merged in master:
<pre>(mg/sample [:not :string])
;([]
; #{}
; nil
; \$
; nil
; nil
; {#uuid&quot;3565d7f3-5561-439f-9368-5bfdbd03fc8e&quot; -2/3}
; ()
; [\^]
; [[-110317951337N \:] #{2.15625 R+3/qfp}])</pre></z><z id="t1612768207" t="kwrooijen How do you spec a function? e.g. I&apos;d like to do this: [:map [:component/foo &apos;fn?]]"><y>#</y><d>2021-02-08</d><h>07:10</h><w>kwrooijen</w>How do you spec a function? e.g. I&apos;d like to do this:
<pre>[:map
 [:component/foo &apos;fn?]]</pre></z><z id="t1612768230" t="kwrooijen But that results in :malli.core/invalid-schema {:schema fn?}"><y>#</y><d>2021-02-08</d><h>07:10</h><w>kwrooijen</w>But that results in <code>:malli.core/invalid-schema {:schema fn?}</code></z><z id="t1612768463" t="ikitommi [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] you can say: [:map [:component/foo [:fn fn?]] or &apos;fn? to keep it serializable"><y>#</y><d>2021-02-08</d><h>07:14</h><w>ikitommi</w><a>@kevin.van.rooijen</a> you can say: <code>[:map [:component/foo [:fn fn?]]</code> or <code>&apos;fn?</code> to keep it serializable</z><z id="t1612768519" t="ikitommi my code sniplet from yesterday show how one can enforce input &amp; output params and arities too."><y>#</y><d>2021-02-08</d><h>07:15</h><w>ikitommi</w>my code sniplet from yesterday show how one can enforce input &amp; output params and arities too.</z><z id="t1612768800" t="kwrooijen Cool, [:fn &apos;fn] works like a charm"><y>#</y><d>2021-02-08</d><h>07:20</h><w>kwrooijen</w>Cool, <code>[:fn &apos;fn]</code> works like a charm</z><z id="t1612768820" t="kwrooijen Thanks, looking forward to the next release 🙂 Will be replacing all my specs with Malli once that happens"><y>#</y><d>2021-02-08</d><h>07:20</h><w>kwrooijen</w>Thanks, looking forward to the next release <b>🙂</b> Will be replacing all my specs with Malli once that happens</z><z id="t1612791666" t="ikitommi nice. would be great if some non-metosinian blogged about the goods and bads of spec, schema and malli - from real life experience. happy to try fix all the bads in malli 😉"><y>#</y><d>2021-02-08</d><h>13:41</h><w>ikitommi</w>nice. would be great if some non-metosinian blogged about the goods and bads of spec, schema and malli - from real life experience. happy to try fix all the bads in malli <b>😉</b></z><z id="t1612814495" t="kwrooijen I might do that eventually, although I have a hard time thinking of bad things about Malli, so it&apos;ll probably only be success stories 🙂"><y>#</y><d>2021-02-08</d><h>20:01</h><w>kwrooijen</w>I might do that eventually, although I have a hard time thinking of bad things about Malli, so it&apos;ll probably only be success stories <b>🙂</b></z><z id="t1612814590" t="kwrooijen I&apos;m currently using it for Gungnir, and working on integrating it for Duct / some web development stuff. At my job we heavily use Malli as well (As well as serialized through an API)"><y>#</y><d>2021-02-08</d><h>20:03</h><w>kwrooijen</w>I&apos;m currently using it for Gungnir, and working on integrating it for Duct / some web development stuff. At my job we heavily use Malli as well (As well as serialized through an API)</z><z id="t1612814669" t="kwrooijen I might use the new parser for a (hiccup) templating language that I&apos;m building. So that&apos;s pretty cool timing of the new feature 😄"><y>#</y><d>2021-02-08</d><h>20:04</h><w>kwrooijen</w>I might use the new parser for a (hiccup) templating language that I&apos;m building. So that&apos;s pretty cool timing of the new feature <b>😄</b></z><z id="t1612871326" t="danielneal What&apos;s the best way to define a string format so that it comes through to swagger"><y>#</y><d>2021-02-09</d><h>11:48</h><w>danielneal</w>What&apos;s the best way to define a string format so that it comes through to swagger</z><z id="t1612871358" t="danielneal (swagger/transform [:map [:a {:swagger/format &quot;date-time&quot;} string?]]) ; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]}"><y>#</y><d>2021-02-09</d><h>11:49</h><w>danielneal</w><pre>(swagger/transform [:map
                    [:a {:swagger/format &quot;date-time&quot;} string?]])
; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]}</pre></z><z id="t1612871379" t="danielneal this works, but I&apos;m wondering if there&apos;s a better way that also has validation"><y>#</y><d>2021-02-09</d><h>11:49</h><w>danielneal</w>this works, but I&apos;m wondering if there&apos;s a better way that also has validation</z><z id="t1612871460" t="ikitommi maybe split it: (def DateTimeString [:string {:swagger/format &quot;date-time&quot;}]) (swagger/transform [:map [:a DateTimeString]]) ; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]}"><y>#</y><d>2021-02-09</d><h>11:51</h><w>ikitommi</w>maybe split it:
<pre>(def DateTimeString [:string {:swagger/format &quot;date-time&quot;}])

(swagger/transform [:map [:a DateTimeString]])
; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]}</pre></z><z id="t1612871757" t="ikitommi what do you mean by “also has validation”?"><y>#</y><d>2021-02-09</d><h>11:55</h><w>ikitommi</w>what do you mean by “also has validation”?</z><z id="t1612871816" t="danielneal like maybe a [:fn #(java.time.Instant/parse %)] or something?"><y>#</y><d>2021-02-09</d><h>11:56</h><w>danielneal</w>like maybe a <code>[:fn #(java.time.Instant/parse %)]</code> or something?</z><z id="t1612871865" t="ikitommi that would return an Instant , not string."><y>#</y><d>2021-02-09</d><h>11:57</h><w>ikitommi</w>that would return an <code>Instant</code>, not string.</z><z id="t1612871955" t="ikitommi after the date schemas are implemented, it would be: (swagger/transform [:map [:a :instant]]) ; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]} "><y>#</y><d>2021-02-09</d><h>11:59</h><w>ikitommi</w>after the date schemas are implemented, it would be:
<pre>(swagger/transform [:map [:a :instant]])
; =&gt; {:type &quot;object&quot;, :properties {:a {:type &quot;string&quot;, :format &quot;date-time&quot;}}, :required [:a]}</pre>
</z><z id="t1612871986" t="danielneal ah, that would be ideal"><y>#</y><d>2021-02-09</d><h>11:59</h><w>danielneal</w>ah, that would be ideal</z><z id="t1612872015" t="ikitommi but, do you want Instant as a result or just a string that is formatted like an instant?"><y>#</y><d>2021-02-09</d><h>12:00</h><w>ikitommi</w>but, do you want <code>Instant</code> as a result or just a string that is formatted like an instant?</z><z id="t1612872256" t="danielneal haha that&apos;s a good question. For consumers of the api, and in the docs etc it should be a string that is formatted like an instant. It would be nice if when we coerce parameters, we could get back a real instant."><y>#</y><d>2021-02-09</d><h>12:04</h><w>danielneal</w>haha that&apos;s a good question. For consumers of the api, and in the docs etc it should be a string that is formatted like an instant. It would be nice if when we coerce parameters, we could get back a real instant.</z><z id="t1612872281" t="danielneal Is what :string/decode is used for"><y>#</y><d>2021-02-09</d><h>12:04</h><w>danielneal</w>Is what :string/decode is used for</z><z id="t1612878831" t="ikitommi [:attrs {:href &quot;/_/_/users/U051H1KL1&quot;}] if you want a full custom type, here’s a sample: (ns demo (:require [malli.core :as m] [malli.error :as me] [malli.generator :as mg] [malli.transform :as mt] [malli.json-schema :as json-schema] [clojure.test.check.generators :as gen]) (:import [java.time Instant] [java.util Date])) (def instant (let [string-&gt;instant #(if (string? %) (Instant/parse %))] (m/-simple-schema {:type &apos;instant :pred (partial instance? java.time.Instant) :type-properties {:error/message &quot;should be instant&quot; :decode/string string-&gt;instant :decode/json string-&gt;instant :json-schema {:type &quot;string&quot;, :format &quot;date-time&quot;} :gen/gen (gen/fmap #(.toInstant ^Date %) (mg/generator inst?))}}))) (m/form [:map [:x instant]]) ; =&gt; [:map [:x instant]] (m/validate instant (Instant/now)) ;=&gt; true (-&gt; [:map [:x instant]] (m/explain {:x &quot;kikka&quot;}) (me/humanize)) ; =&gt; {:x [&quot;should be instant&quot;]} (json-schema/transform [:map [:x instant]]) ;{:type &quot;object&quot; ; :properties {:x {:type &quot;string&quot; ; :format &quot;date-time&quot;}} ; :required [:x]} (m/decode [:map [:x instant]] {:x &quot;2021-02-09T13:49:44.419Z&quot;} (mt/json-transformer)) ; =&gt; {:x #object[java.time.Instant 0x5aed36d3 &quot;2021-02-09T13:49:44.419Z&quot;]} (mg/generate [:map [:x instant]]) ; =&gt; {:x #object[java.time.Instant 0x4878fa62 &quot;1970-01-01T00:00:00.295Z&quot;]}"><y>#</y><d>2021-02-09</d><h>13:53</h><w>ikitommi</w><a>@danieleneal</a> if you want a full custom type, here’s a sample:
<pre>(ns demo
  (:require [malli.core :as m]
            [malli.error :as me]
            [malli.generator :as mg]
            [malli.transform :as mt]
            [malli.json-schema :as json-schema]
            [clojure.test.check.generators :as gen])
  (:import [java.time Instant]
           [java.util Date]))

(def instant
  (let [string-&gt;instant #(if (string? %) (Instant/parse %))]
    (m/-simple-schema
      {:type &apos;instant
       :pred (partial instance? java.time.Instant)
       :type-properties {:error/message &quot;should be instant&quot;
                         :decode/string string-&gt;instant
                         :decode/json string-&gt;instant
                         :json-schema {:type &quot;string&quot;, :format &quot;date-time&quot;}
                         :gen/gen (gen/fmap #(.toInstant ^Date %) (mg/generator inst?))}})))

(m/form [:map [:x instant]])
; =&gt; [:map [:x instant]]

(m/validate instant (Instant/now))
;=&gt; true

(-&gt; [:map [:x instant]]
    (m/explain {:x &quot;kikka&quot;})
    (me/humanize))
; =&gt; {:x [&quot;should be instant&quot;]}

(json-schema/transform [:map [:x instant]])
;{:type &quot;object&quot;
; :properties {:x {:type &quot;string&quot;
;                  :format &quot;date-time&quot;}}
; :required [:x]}

(m/decode
  [:map [:x instant]]
  {:x &quot;2021-02-09T13:49:44.419Z&quot;}
  (mt/json-transformer))
; =&gt; {:x #object[java.time.Instant 0x5aed36d3 &quot;2021-02-09T13:49:44.419Z&quot;]}

(mg/generate [:map [:x instant]])
; =&gt; {:x #object[java.time.Instant 0x4878fa62 &quot;1970-01-01T00:00:00.295Z&quot;]}</pre></z><z id="t1612878897" t="ikitommi e.g. m/-simple-type allows to (easily?) build custom schemas that cover all the aspect: transforming, humanized errors, generators, json-schema, etc."><y>#</y><d>2021-02-09</d><h>13:54</h><w>ikitommi</w>e.g. <code>m/-simple-type</code>allows to (easily?) build custom schemas that cover all the aspect: transforming, humanized errors, generators, json-schema, etc.</z><z id="t1612878917" t="ikitommi much of the core itself is built on top of that."><y>#</y><d>2021-02-09</d><h>13:55</h><w>ikitommi</w>much of the core itself is built on top of that.</z><z id="t1612878996" t="ikitommi :type-properties allow one to hide implementation details. one could do the same fully using normal schema properties, but all the details would be in your face when you look at the schema form."><y>#</y><d>2021-02-09</d><h>13:56</h><w>ikitommi</w><code>:type-properties</code> allow one to hide implementation details. one could do the same fully using normal schema properties, but all the details would be in your face when you look at the schema form.</z><z id="t1612880339" t="danielneal thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , that looks great"><y>#</y><d>2021-02-09</d><h>14:18</h><w>danielneal</w>thanks <a>@ikitommi</a>, that looks great</z><z id="t1613143011" t="kwrooijen Hi, is this a bug? (def model [:map [:my/field {:default nil} :int]]) (m/decode model params mt/default-value-transformer) ;; =&gt; {} I&apos;m expecting {:my/field nil} here"><y>#</y><d>2021-02-12</d><h>15:16</h><w>kwrooijen</w>Hi, is this a bug?
<pre>(def model
  [:map
   [:my/field {:default nil} :int]])

(m/decode model params mt/default-value-transformer)
;; =&gt; {}</pre>
I&apos;m expecting <code>{:my/field nil}</code> here</z><z id="t1613143260" t="ikitommi [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] a bug, PR welcome"><y>#</y><d>2021-02-12</d><h>15:21</h><w>ikitommi</w><a>@kevin.van.rooijen</a> a bug, PR welcome</z><z id="t1613143269" t="kwrooijen Will do 👍"><y>#</y><d>2021-02-12</d><h>15:21</h><w>kwrooijen</w>Will do <b>👍</b></z><z id="t1613143277" t="kwrooijen Kind of have dejavu with this bug"><y>#</y><d>2021-02-12</d><h>15:21</h><w>kwrooijen</w>Kind of have dejavu with this bug</z><z id="t1613143310" t="kwrooijen https://github.com/metosin/malli/pull/223/files lol 😅"><y>#</y><d>2021-02-12</d><h>15:21</h><w>kwrooijen</w><a href="https://github.com/metosin/malli/pull/223/files" target="_blank">https://github.com/metosin/malli/pull/223/files</a> lol <b>😅</b></z><z id="t1613143448" t="ikitommi falsey is hard."><y>#</y><d>2021-02-12</d><h>15:24</h><w>ikitommi</w>falsey is hard.</z><z id="t1613143471" t="kwrooijen Good thing Clojure only has 2 falsey values.. instead of some other languages I won&apos;t name"><y>#</y><d>2021-02-12</d><h>15:24</h><w>kwrooijen</w>Good thing Clojure only has 2 falsey values.. instead of some other languages I won&apos;t name</z><z id="t1613341758" t="caumond Hi guys, I have tried to draw malli&apos;s dot representation. Everything&apos;s fine until I try to print a [:&lt;= 20] or [:&lt; 20] . In both case, it seems to be an invalid sequence. At least tangle doesn&apos;t know how to handle it. Everything&apos;s fine if I replace [:&lt;= 20 in the string built by transform."><y>#</y><d>2021-02-14</d><h>22:29</h><w>caumond</w>Hi guys, I have tried to draw malli&apos;s dot representation. Everything&apos;s fine until I try to print a <code>[:&lt;= 20]</code>or <code>[:&lt; 20]</code> . In both case, it seems to be an invalid sequence. At least tangle doesn&apos;t know how to handle it. Everything&apos;s fine if I replace <code>[:&lt;= 20</code> in the string built by transform.</z><z id="t1613341767" t="caumond Is it a PR?"><y>#</y><d>2021-02-14</d><h>22:29</h><w>caumond</w>Is it a PR?</z><z id="t1613359417" t="aaron51 Is there an easy way to use Malli in clojure.test/is ? I’d like to assert that m/validate returns true, and show m/explain output when it fails."><y>#</y><d>2021-02-15</d><h>03:23</h><w>aaron51</w>Is there an easy way to use Malli in <code>clojure.test/is</code>?
I’d like to assert that <code>m/validate</code> returns true, and show <code>m/explain</code> output when it fails.</z><z id="t1613363254" t="aaron51 (is (validate schema data) (humanize (explain schema data))) — anything like this built in? Or just validate! that throws on failure?"><y>#</y><d>2021-02-15</d><h>04:27</h><r>aaron51</r><code>(is (validate schema data) (humanize (explain schema data)))</code> — anything like this built in? Or just <code>validate!</code> that throws on failure?</z><z id="t1613375747" t="borkdude Write a function?"><y>#</y><d>2021-02-15</d><h>07:55</h><r>borkdude</r>Write a function?</z><z id="t1613378416" t="ikitommi there are no test helpers atm, but should be easy to do in user space as borkdude suggests, Are there good helpers / utilities for this (testing) in spec? in schema?"><y>#</y><d>2021-02-15</d><h>08:40</h><r>ikitommi</r>there are no test helpers atm, but should be easy to do in user space as borkdude suggests, Are there good helpers / utilities for this (testing) in spec? in schema?</z><z id="t1613428725" t="aaron51 Yes, it is straightforward enough to write it in user space. But I thought it would be a common case… Found a few similar things: • schema: https://github.com/plumatic/schema/blob/master/test/clj/schema/test_macros.clj • schema: https://github.com/plumatic/schema/blob/master/test/cljx/schema/core_test.cljx • clojure-expectations has “spec expectations” https://github.com/clojure-expectations/clojure-test"><y>#</y><d>2021-02-15</d><h>22:38</h><r>aaron51</r>Yes, it is straightforward enough to write it in user space. But I thought it would be a common case… Found a few similar things:

• schema: <a href="https://github.com/plumatic/schema/blob/master/test/clj/schema/test_macros.clj" target="_blank">https://github.com/plumatic/schema/blob/master/test/clj/schema/test_macros.clj</a>
• schema: <a href="https://github.com/plumatic/schema/blob/master/test/cljx/schema/core_test.cljx" target="_blank">https://github.com/plumatic/schema/blob/master/test/cljx/schema/core_test.cljx</a>
• clojure-expectations has “spec expectations” <a href="https://github.com/clojure-expectations/clojure-test" target="_blank">https://github.com/clojure-expectations/clojure-test</a></z><z id="t1613428842" t="borkdude I also have this one: https://github.com/borkdude/respeced This was written to test fdef specs."><y>#</y><d>2021-02-15</d><h>22:40</h><r>borkdude</r>I also have this one: <a href="https://github.com/borkdude/respeced" target="_blank">https://github.com/borkdude/respeced</a>
This was written to test fdef specs.</z><z id="t1613505845" t="ikitommi wrote an issue out of this: https://github.com/metosin/malli/issues/369 ."><y>#</y><d>2021-02-16</d><h>20:04</h><r>ikitommi</r>wrote an issue out of this: <a href="https://github.com/metosin/malli/issues/369" target="_blank">https://github.com/metosin/malli/issues/369</a>.</z><z id="t1613378064" t="ikitommi [:attrs {:href &quot;/_/_/users/U018QDQGZ9Q&quot;}] PR welcome"><y>#</y><d>2021-02-15</d><h>08:34</h><w>ikitommi</w><a>@caumond</a> PR welcome</z><z id="t1613378526" t="ikitommi wip: function generators generate correctly function with different arities (def f (mg/generate [:function [:=&gt; :cat int?] [:=&gt; [:cat int?] nat-int?]])) (f) ;=&gt; 132816 ;=&gt; -7823115 ;=&gt; -36 ;=&gt; -97 ;=&gt; 13412759 ;=&gt; 1444 (f 1) ;=&gt; 1038018 ;=&gt; 11009747 ;=&gt; 8 ;=&gt; 59186626 ;=&gt; 10 ;=&gt; 5373734 (f &quot;1&quot;) ; =throws=&gt; :malli.generator/invalid-input {:schema [:cat int?], :args [&quot;1&quot;]} (f 1 2) ; =throws=&gt; :malli.generator/invalid-arity {:arity 2, :arities #{0 1}, :args (1 2), :schema [:function [:=&gt; :cat int?] [:=&gt; [:cat int?] nat-int?]]}"><y>#</y><d>2021-02-15</d><h>08:42</h><w>ikitommi</w>wip: function generators generate correctly function with different arities
<pre>(def f
  (mg/generate
    [:function
     [:=&gt; :cat int?]
     [:=&gt; [:cat int?] nat-int?]]))

(f)
;=&gt; 132816
;=&gt; -7823115
;=&gt; -36
;=&gt; -97
;=&gt; 13412759
;=&gt; 1444

(f 1)
;=&gt; 1038018
;=&gt; 11009747
;=&gt; 8
;=&gt; 59186626
;=&gt; 10
;=&gt; 5373734

(f &quot;1&quot;)
; =throws=&gt; :malli.generator/invalid-input {:schema [:cat int?], :args [&quot;1&quot;]}

(f 1 2)
; =throws=&gt; :malli.generator/invalid-arity {:arity 2, :arities #{0 1}, :args (1 2), :schema [:function [:=&gt; :cat int?] [:=&gt; [:cat int?] nat-int?]]}</pre></z><z id="t1613378666" t="borkdude is this in a branch somewhere?"><y>#</y><d>2021-02-15</d><h>08:44</h><r>borkdude</r>is this in a branch somewhere?</z><z id="t1613378752" t="ikitommi not yet, needs a new -min-count protocol method to regex-schma to resolve the arities from :=&gt; schemas. few hours away from a branch."><y>#</y><d>2021-02-15</d><h>08:45</h><r>ikitommi</r>not yet, needs a new <code>-min-count</code> protocol method to regex-schma to resolve the arities from <code>:=&gt;</code> schemas. few hours away from a branch.</z><z id="t1613378986" t="borkdude cool. how are you generating the fn per arity?"><y>#</y><d>2021-02-15</d><h>08:49</h><r>borkdude</r>cool. how are you generating the fn per arity?</z><z id="t1613379220" t="ikitommi pushed the current: https://github.com/metosin/malli/blob/fn_new/src/malli/generator.cljc#L104-L129"><y>#</y><d>2021-02-15</d><h>08:53</h><r>ikitommi</r>pushed the current: <a href="https://github.com/metosin/malli/blob/fn_new/src/malli/generator.cljc#L104-L129" target="_blank">https://github.com/metosin/malli/blob/fn_new/src/malli/generator.cljc#L104-L129</a></z><z id="t1613379274" t="ikitommi but that code doesn’t infer the arity, needs to set manually: (def f (mg/generate [:function [0 [:=&gt; :cat int?]] [1 [:=&gt; [:cat int?] nat-int?]]]))"><y>#</y><d>2021-02-15</d><h>08:54</h><r>ikitommi</r>but that code doesn’t infer the arity, needs to set manually:
<pre>(def f
  (mg/generate
    [:function
     [0 [:=&gt; :cat int?]]
     [1 [:=&gt; [:cat int?] nat-int?]]]))</pre></z><z id="t1613379594" t="borkdude :thumbsup:"><y>#</y><d>2021-02-15</d><h>08:59</h><r>borkdude</r><b>:thumbsup:</b></z><z id="t1613678214" t="Daniel Miladinov Is it possible to use a `[:map …]` spec to describe interactions / interdependencies with map keys / values? Like, “either this key or that key must be set”, or “these two keys must either both have empty values or both be set”"><y>#</y><d>2021-02-18</d><h>19:56</h><w>Daniel Miladinov</w>Is it possible to use a `[:map …]` spec to describe interactions / interdependencies with map keys / values?
Like, “either this key or that key must be set”, or “these two keys must either both have empty values or both be set”</z><z id="t1613678320" t="borkdude This is probably done using a predicate on the map?"><y>#</y><d>2021-02-18</d><h>19:58</h><w>borkdude</w>This is probably done using a predicate on the map?</z><z id="t1613678339" t="borkdude (Guess)"><y>#</y><d>2021-02-18</d><h>19:58</h><w>borkdude</w>(Guess)</z><z id="t1613678389" t="Daniel Miladinov I mean, I know I can write a [:fn …] spec and do whatever I need with the map validation, but I was wondering if there was anything more declarative."><y>#</y><d>2021-02-18</d><h>19:59</h><w>Daniel Miladinov</w>I mean, I know I can write a <code>[:fn …]</code> spec and do whatever I need with the map validation, but I was wondering if there was anything more declarative.</z><z id="t1613681366" t="ikitommi [:attrs {:href &quot;/_/_/users/U01JUTU1308&quot;}] if you can cook up a good declarative syntax for defining the rules, I can try to summon a custom schema to do that. Declarative rule systems are not always simple."><y>#</y><d>2021-02-18</d><h>20:49</h><w>ikitommi</w><a>@daniel.miladinov</a> if you can cook up a good declarative syntax for defining the rules, I can try to summon a custom schema to do that. Declarative rule systems are not always simple.</z><z id="t1613681434" t="ikitommi Not sure if something like meander could be used to declare rules like that. Bridging Malli and Meander might be fun"><y>#</y><d>2021-02-18</d><h>20:50</h><w>ikitommi</w>Not sure if something like meander could be used to declare rules like that. Bridging Malli and Meander might be fun</z><z id="t1613744699" t="dangercoder Hi! According to the docs there is a parse function which im very much interested in. (m/parse [:* [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]] [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;]) In what namespace does this function live? I tried looking through the code and could not find it. Also tried the example (I thought, well, maybe m is bound to malli.core) 🙂"><y>#</y><d>2021-02-19</d><h>14:24</h><w>dangercoder</w>Hi! According to the docs there is a parse function which im very much interested in.


<pre>(m/parse
  [:* [:cat*
       [:prop string?]
       [:val [:alt*
              [:s string?]
              [:b boolean?]]]]]
  [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; true &quot;-user&quot; &quot;joe&quot;])</pre>
In what namespace does this function live? I tried looking through the code and could not find it. Also tried the example (I thought, well, maybe m is bound to malli.core) <b>🙂</b></z><z id="t1613744775" t="ikitommi it’s in master, and it’s malli.core/parse ."><y>#</y><d>2021-02-19</d><h>14:26</h><w>ikitommi</w>it’s in master, and it’s <code>malli.core/parse</code>.</z><z id="t1613744812" t="ikitommi release soon, just need more tests and some docs."><y>#</y><d>2021-02-19</d><h>14:26</h><w>ikitommi</w>release soon, just need more tests and some docs.</z><z id="t1613744838" t="dangercoder I see its me looking in the wrong branch, sorry. I looked in 0.2.1"><y>#</y><d>2021-02-19</d><h>14:27</h><w>dangercoder</w>I see its me looking in the wrong branch, sorry. I looked in 0.2.1</z><z id="t1613921188" t="ikitommi added more info on function schema explain: (def MyFunctionSchema (m/schema [:function [:=&gt; [:cat :int] :int] [:=&gt; [:cat :int :int [:* :int]] :int]] {::m/function-checker mg/function-checker})) (m/explain MyFunctionSchema (fn ([x] x) ([x y &amp; zs] (apply max x y zs)))) ; =&gt; nil (m/explain MyFunctionSchema (fn ([x] x) ([x y &amp; zs] (str (apply max x y zs))))) ;{:schema [:function ; [:=&gt; [:cat :int] :int] ; [:=&gt; [:cat :int :int [:* :int]] :int]], ; :value #object[], ; :errors (#Error{:path [], ; :in [], ; :schema [:function ; [:=&gt; [:cat :int] :int] ; [:=&gt; [:cat :int :int [:* :int]] :int]], ; :value #object[], ; :check ({:total-nodes-visited 2, ; :depth 1, ; :pass? false, ; :result false, ; :result-data nil, ; :time-shrinking-ms 0, ; :smallest [(0 0)], ; :malli.generator/explain-output {:schema :int, ; :value &quot;0&quot;, ; :errors (#Error{:path [] ; :in [] ; :schema :int ; :value &quot;0&quot;})}})})}"><y>#</y><d>2021-02-21</d><h>15:26</h><w>ikitommi</w>added more info on function schema explain:

<pre>(def MyFunctionSchema
  (m/schema
    [:function
     [:=&gt; [:cat :int] :int]
     [:=&gt; [:cat :int :int [:* :int]] :int]]
    {::m/function-checker mg/function-checker}))

(m/explain
  MyFunctionSchema
  (fn
    ([x] x)
    ([x y &amp; zs] (apply max x y zs))))
; =&gt; nil

(m/explain
  MyFunctionSchema
  (fn
    ([x] x)
    ([x y &amp; zs] (str (apply max x y zs)))))
;{:schema [:function 
;          [:=&gt; [:cat :int] :int] 
;          [:=&gt; [:cat :int :int [:* :int]] :int]],
; :value #object[],
; :errors (#Error{:path [],
;                 :in [],
;                 :schema [:function 
;                          [:=&gt; [:cat :int] :int] 
;                          [:=&gt; [:cat :int :int [:* :int]] :int]],
;                 :value #object[],
;                 :check ({:total-nodes-visited 2,
;                          :depth 1,
;                          :pass? false,
;                          :result false,
;                          :result-data nil,
;                          :time-shrinking-ms 0,
;                          :smallest [(0 0)],
;                          :malli.generator/explain-output {:schema :int,
;                                                           :value &quot;0&quot;,
;                                                           :errors (#Error{:path []
;                                                                           :in []
;                                                                           :schema :int
;                                                                           :value &quot;0&quot;})}})})}</pre></z><z id="t1613921356" t="ikitommi really happy how good the function schemas are now, but still - it’s just elegant (and slow) way to verify things at runtime, e.g. not a type system."><y>#</y><d>2021-02-21</d><h>15:29</h><w>ikitommi</w>really happy how good the function schemas are now, but still - it’s just elegant (and slow) way to verify things at runtime, e.g. not a type system.</z><z id="t1613921572" t="ikitommi in master"><y>#</y><d>2021-02-21</d><h>15:32</h><w>ikitommi</w>in master</z><z id="t1613921618" t="borkdude compared to clojure.spec, how slow?"><y>#</y><d>2021-02-21</d><h>15:33</h><w>borkdude</w>compared to clojure.spec, how slow?</z><z id="t1613922253" t="ikitommi the sequence schemas are at least an order of magnitude faster than spec in initial tests. Full function verification uses test.check, I think that dominates, and quess they are about the same."><y>#</y><d>2021-02-21</d><h>15:44</h><w>ikitommi</w>the sequence schemas are at least an order of magnitude faster than spec in initial tests. Full function verification uses test.check, I think that dominates, and quess they are about the same.</z><z id="t1613922429" t="ikitommi but, having arity info available for fn s at runtime (in clojure.core) would help to see that fns are correct on arity, without testing it and getting arityexceptions - costs a lot."><y>#</y><d>2021-02-21</d><h>15:47</h><w>ikitommi</w>but, having arity info available for <code>fn</code>s at runtime (in clojure.core) would help to see that fns are correct on arity, without testing it and getting arityexceptions - costs a lot.</z><z id="t1613923984" t="borkdude Maybe you can combine that with static analysis (e.g. from clj-kondo)?"><y>#</y><d>2021-02-21</d><h>16:13</h><w>borkdude</w>Maybe you can combine that with static analysis (e.g. from clj-kondo)?</z><z id="t1613930990" t="ikitommi I guess it could be done using a clj-kondo hook? with defaults, the test.check runs 19ms for a function on my machine. that’s 500 funcs per sec (on 1 core?). errors are faster, the given example fails fast on invalid return, under 1ms."><y>#</y><d>2021-02-21</d><h>18:09</h><w>ikitommi</w>I guess it could be done using a clj-kondo hook? with defaults, the test.check runs 19ms for a function on my machine. that’s 500 funcs per sec (on 1 core?). errors are faster, the given example fails fast on invalid return, under 1ms.</z><z id="t1613937807" t="borkdude I mean: &gt; but, having arity info available for fns at runtime (in clojure.core) would help to see that fns are correct on arity, without testing it and getting arityexceptions - costs a lot. You could use clj-kondo to find the correct arities perhaps"><y>#</y><d>2021-02-21</d><h>20:03</h><r>borkdude</r>I mean:

&gt; but, having arity info available for fns at runtime (in clojure.core) would help to see that fns are correct on arity, without testing it and getting arityexceptions - costs a lot.
You could use clj-kondo to find the correct arities perhaps</z><z id="t1613931042" t="ikitommi i believe it could be made faster, less iterations on arguments etc."><y>#</y><d>2021-02-21</d><h>18:10</h><w>ikitommi</w>i believe it could be made faster, less iterations on arguments etc.</z><z id="t1613931087" t="ikitommi [metosin/malli &quot;0.3.0-SNAPSHOT&quot;] has the stuff in."><y>#</y><d>2021-02-21</d><h>18:11</h><w>ikitommi</w><code>[metosin/malli &quot;0.3.0-SNAPSHOT&quot;]</code> has the stuff in.</z><z id="t1613937543" t="ikitommi with 10 iterations, it drops to 0.3ms per fn.&apos;"><y>#</y><d>2021-02-21</d><h>19:59</h><w>ikitommi</w>with 10 iterations, it drops to 0.3ms per fn.&apos;</z><z id="t1613940152" t="emccue &gt; e.g. not a type system."><y>#</y><d>2021-02-21</d><h>20:42</h><w>emccue</w>&gt; e.g. not a type system.</z><z id="t1613940165" t="emccue i mean"><y>#</y><d>2021-02-21</d><h>20:42</h><w>emccue</w>i mean</z><z id="t1613940182" t="emccue for me, it would serve much the same purpose i&apos;d think"><y>#</y><d>2021-02-21</d><h>20:43</h><w>emccue</w>for me, it would serve much the same purpose i&apos;d think</z><z id="t1613940219" t="emccue or rather - the same workflow"><y>#</y><d>2021-02-21</d><h>20:43</h><w>emccue</w>or rather - the same workflow</z><z id="t1613940229" t="emccue maybe i&apos;m missing a worldview though"><y>#</y><d>2021-02-21</d><h>20:43</h><w>emccue</w>maybe i&apos;m missing a worldview though</z><z id="t1613941640" t="borkdude Btw, this sounds interesting, but I haven&apos;t heard anything about it yet: https://www.fulcrologic.com/copilot"><y>#</y><d>2021-02-21</d><h>21:07</h><w>borkdude</w>Btw, this sounds interesting, but I haven&apos;t heard anything about it yet: <a href="https://www.fulcrologic.com/copilot" target="_blank">https://www.fulcrologic.com/copilot</a></z><z id="t1613982497" t="ikitommi looking forward for that. I’m watching the guardrails repo, but think that’s going to be much more."><y>#</y><d>2021-02-22</d><h>08:28</h><w>ikitommi</w>looking forward for that. I’m watching the guardrails repo, but think that’s going to be much more.</z><z id="t1613982535" t="ikitommi &gt; (extensible, but starting with Clojure spec)"><y>#</y><d>2021-02-22</d><h>08:28</h><w>ikitommi</w>&gt; (extensible, but starting with Clojure spec)</z><z id="t1613984054" t="borkdude Yeah, but will be a commercial product, so hard to contribute and see what&apos;s going on probably"><y>#</y><d>2021-02-22</d><h>08:54</h><w>borkdude</w>Yeah, but will be a commercial product, so hard to contribute and see what&apos;s going on probably</z><z id="t1613991974" t="dharrigan Looking forward to the new function schema - just saw the tweet!"><y>#</y><d>2021-02-22</d><h>11:06</h><w>dharrigan</w>Looking forward to the new function schema - just saw the tweet!</z><z id="t1613994791" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] Malli is a dynamic schema/type system, it’s not a static type system. tools like clj-kondo and typed clojure can do static analysis, maybe copilot too? Would love to see tooling get better and happy to help, but no time or skills to do anything non-trivial except to integrate into existing tooling. My point was that resolving fn arity using generative testing or 3rd party tools (clj-kondo) is a hard way to do something that would be easy to do in the core language itself. With core clojure: does a ring middleware chain would work for an async (3) arity? run and see if it throws arityexception 😞"><y>#</y><d>2021-02-22</d><h>11:53</h><w>ikitommi</w><a>@emccue</a> Malli is a dynamic schema/type system, it’s not a static type system. tools like clj-kondo and typed clojure can do static analysis, maybe copilot too? Would love to see tooling get better and happy to help, but no time or skills to do anything non-trivial except to integrate into existing tooling. My point was that resolving fn arity using generative testing or 3rd party tools (clj-kondo) is a hard way to do something that would be easy to do in the core language itself. With core clojure: does a ring middleware chain would work for an async (3) arity? run and see if it throws arityexception <b>😞</b></z><z id="t1613994933" t="ikitommi I’m hope and think we’ll see great new developer tooling for clojure in 2021, from the community."><y>#</y><d>2021-02-22</d><h>11:55</h><w>ikitommi</w>I’m hope and think we’ll see great new developer tooling for clojure in 2021, from the community.</z><z id="t1614005069" t="ikitommi added more benchmarks to repo, parsing vs spec: ;; 44µs (let [spec (s/* (s/cat :prop string?, :val (s/alt :s string? :b boolean?))) parse (partial s/conform spec)] (cc/quick-bench (parse [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; &quot;-verbose&quot; &quot;-user&quot; &quot;joe&quot;]))) ;; 2.5µs (let [schema [:* [:cat* [:prop string?] [:val [:alt* [:s string?] [:b boolean?]]]]] parse (m/parser schema)] (cc/quick-bench (parse [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; &quot;-verbose&quot; &quot;-user&quot; &quot;joe&quot;])))"><y>#</y><d>2021-02-22</d><h>14:44</h><w>ikitommi</w>added more benchmarks to repo, parsing vs spec:
<pre>;; 44µs
(let [spec (s/* (s/cat :prop string?,
                       :val (s/alt :s string?
                                   :b boolean?)))
      parse (partial s/conform spec)]
  (cc/quick-bench
    (parse [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; &quot;-verbose&quot; &quot;-user&quot; &quot;joe&quot;])))

;; 2.5µs
(let [schema [:* [:cat*
                  [:prop string?]
                  [:val [:alt*
                         [:s string?]
                         [:b boolean?]]]]]
      parse (m/parser schema)]
  (cc/quick-bench
    (parse [&quot;-server&quot; &quot;foo&quot; &quot;-verbose&quot; &quot;-verbose&quot; &quot;-user&quot; &quot;joe&quot;])))</pre></z><z id="t1614010993" t="Jakub Zika Hi guys, I am trying to generate some random date with (mg/generate inst?) but i am not sure how :seed or :size works here. I am getting 1969 or 1970 in 99% cases. How to get a date like any &gt;1980? Thanka dwh-replicator.database&gt; (mg/generate inst? {:seed 20}) ;; =&gt; #inst &quot;1970-01-01T00:00:00.000-00:00&quot; dwh-replicator.database&gt; (mg/generate inst? {:seed 42}) ;; =&gt; #inst &quot;1970-01-01T00:00:00.000-00:00&quot; "><y>#</y><d>2021-02-22</d><h>16:23</h><w>Jakub Zika</w>Hi guys,
I am trying to generate some random date with <code>(mg/generate inst?)</code>
but i am not sure how :seed or :size works here.
I am getting 1969 or 1970 in 99% cases. How to get a date like any &gt;1980? Thanka
<code>dwh-replicator.database&gt; (mg/generate inst? {:seed 20})</code>
<code>;; =&gt; #inst &quot;1970-01-01T00:00:00.000-00:00&quot;</code>
<code>dwh-replicator.database&gt; (mg/generate inst? {:seed 42})</code>
<code>;; =&gt; #inst &quot;1970-01-01T00:00:00.000-00:00&quot;</code> </z><z id="t1614012221" t="juhoteperi I think in this case Malli just use spec.alpha generator for instants: https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L178 https://github.com/clojure/spec.alpha/blob/31165fec69ff86129a1ada8b3f50864922dfc88a/src/main/clojure/clojure/spec/gen/alpha.clj#L160"><y>#</y><d>2021-02-22</d><h>16:43</h><w>juhoteperi</w>I think in this case Malli just use spec.alpha generator for instants:

<a href="https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L178" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L178</a>
<a href="https://github.com/clojure/spec.alpha/blob/31165fec69ff86129a1ada8b3f50864922dfc88a/src/main/clojure/clojure/spec/gen/alpha.clj#L160" target="_blank">https://github.com/clojure/spec.alpha/blob/31165fec69ff86129a1ada8b3f50864922dfc88a/src/main/clojure/clojure/spec/gen/alpha.clj#L160</a></z><z id="t1614012928" t="pithyless [:attrs {:href &quot;/_/_/users/UL8KUA286&quot;}] there&apos;s a good talk that explains how :seed and :size interact when writing custom generators. It even mentions the datetime problem @ 31:54. https://youtu.be/F4VZPxLZUdA?t=1911 1. The proposed solution in the talk is a custom generator that splits the datetime into separate domain bits (year / month / day / etc.) 2. A different solution (as seen e.g. https://github.com/nasa/Common-Metadata-Repository/blob/master/common-lib/src/cmr/common/test/test_check_ext.clj#L255-L257 ) is to change the way you choose an initial seed integer (that is used to coerce to date)."><y>#</y><d>2021-02-22</d><h>16:55</h><w>pithyless</w><a>@jakub.zika-extern</a> there&apos;s a good talk that explains how <code>:seed</code> and <code>:size</code> interact when writing custom generators. It even mentions the datetime problem @ 31:54. <a href="https://youtu.be/F4VZPxLZUdA?t=1911" target="_blank">https://youtu.be/F4VZPxLZUdA?t=1911</a>

1. The proposed solution in the talk is a custom generator that splits the datetime into separate domain bits (year / month / day / etc.)
2. A different solution (as seen e.g. <a href="https://github.com/nasa/Common-Metadata-Repository/blob/master/common-lib/src/cmr/common/test/test_check_ext.clj#L255-L257" target="_blank">https://github.com/nasa/Common-Metadata-Repository/blob/master/common-lib/src/cmr/common/test/test_check_ext.clj#L255-L257</a>) is to change the way you choose an initial seed integer (that is used to coerce to date).</z><z id="t1614012978" t="Jakub Zika Thank you!"><y>#</y><d>2021-02-22</d><h>16:56</h><r>Jakub Zika</r>Thank you!</z><z id="t1614028457" t="Jakub Zika I am mapping DB types to clojure types, so varchar(255) goes to [string? {:min 0 :max 255}] etc. I am using these derived schemas to: 1. validate data : (malli/validate [string?] &quot;hoy&quot;) 2. generate sample data : (malli.generator/generate [string?]) When I will go for custom generators then I will have to create new validators, correct?"><y>#</y><d>2021-02-22</d><h>21:14</h><r>Jakub Zika</r>I am mapping DB types to clojure types, so <code>varchar(255)</code>  goes to <code>[string? {:min 0 :max 255}]</code> etc.

I am using these derived schemas to:
1. validate data : <code>(malli/validate [string?] &quot;hoy&quot;)</code>
2. generate sample data : <code>(malli.generator/generate [string?])</code>
When I will go for custom generators then I will have to create new validators, correct?</z><z id="t1614028780" t="pithyless You&apos;ll need to pass in the custom generator to the spec (not necessarily when validating, but at the very least wen generating sample data)."><y>#</y><d>2021-02-22</d><h>21:19</h><r>pithyless</r>You&apos;ll need to pass in the custom generator to the spec (not necessarily when validating, but at the very least wen generating sample data).</z><z id="t1614028828" t="pithyless so instead of [string? {:min 0 :max 255}] you&apos;ll have to wrap it, eg: [:and {:gen/elements [&quot;kikka&quot; &quot;kukka&quot; &quot;kakka&quot;]} [string? {:min 0 :max 255}]] "><y>#</y><d>2021-02-22</d><h>21:20</h><r>pithyless</r>so instead of
<pre>[string? {:min 0 :max 255}]</pre>
you&apos;ll have to wrap it, eg:
<pre>[:and {:gen/elements [&quot;kikka&quot; &quot;kukka&quot; &quot;kakka&quot;]} [string? {:min 0 :max 255}]]</pre>
</z><z id="t1614028858" t="pithyless where you use one of :gen/elements , :gen/gen , :gen/fmap , etc."><y>#</y><d>2021-02-22</d><h>21:20</h><r>pithyless</r>where you use one of <code>:gen/elements</code>, <code>:gen/gen</code>, <code>:gen/fmap</code>, etc.</z><z id="t1614029118" t="pithyless ^ I think you might even be able to just change the default :gen/gen of the specific type by modifying the malli registry globally (but then you&apos;re changing it for everything... which has its own issues ;))"><y>#</y><d>2021-02-22</d><h>21:25</h><r>pithyless</r>^ I think you might even be able to just change the default <code>:gen/gen</code> of the specific type by modifying the malli registry globally (but then you&apos;re changing it for everything... which has its own issues ;))</z><z id="t1614029218" t="pithyless OR, perhaps make a custom registry where you override the :gen/gen for the basic types you&apos;re interested in (e.g. instant); and then pass in the custom registry only when generating sample data"><y>#</y><d>2021-02-22</d><h>21:26</h><r>pithyless</r>OR, perhaps make a custom registry where you override the <code>:gen/gen</code> for the basic types you&apos;re interested in (e.g. instant); and then pass in the custom registry only when generating sample data</z><z id="t1614061584" t="ikitommi no need to wrap into :and , this works too: [:string {:min 0, :max 100, :gen/min 10, :gen/max 20, :gen/fmap (partial * 2)}]"><y>#</y><d>2021-02-23</d><h>06:26</h><r>ikitommi</r>no need to wrap into <code>:and</code>, this works too: <code>[:string {:min 0, :max 100, :gen/min 10, :gen/max 20, :gen/fmap (partial * 2)}]</code></z><z id="t1614061656" t="ikitommi the default schema generators are implemented as multimethods, so for global effects, one can just re-mount generator fof &apos;inst? for example. not recommended."><y>#</y><d>2021-02-23</d><h>06:27</h><r>ikitommi</r>the default schema generators are implemented as multimethods, so for global effects, one can just re-mount generator fof <code>&apos;inst?</code> for example. not recommended.</z><z id="t1614017242" t="Alex Whitt Would anyone like to jump on this discussion thread I created on the subreddit? (I&apos;d prefer to keep it there so it doesn&apos;t disappear behind Slack&apos;s paywall) https://www.reddit.com/r/Clojure/comments/lpv8ok/spec_vs_malli/"><y>#</y><d>2021-02-22</d><h>18:07</h><w>Alex Whitt</w>Would anyone like to jump on this discussion thread I created on the subreddit? (I&apos;d prefer to keep it there so it doesn&apos;t disappear behind Slack&apos;s paywall)
<a href="https://www.reddit.com/r/Clojure/comments/lpv8ok/spec_vs_malli/" target="_blank">https://www.reddit.com/r/Clojure/comments/lpv8ok/spec_vs_malli/</a></z><z id="t1614103979" t="ikitommi final change to figure out proper names for named branch -variants for: :cat , :alt and :or . they are currently :cat* , :alt* and :or* :face_with_rolling_eyes: (m/parse [:* [:alt* [:s :string] [:i :int]]] [1 &quot;2&quot; 3 &quot;4&quot;]) ; =&gt; [[:i 1] [:s &quot;2&quot;] [:i 3] [:s &quot;4]]"><y>#</y><d>2021-02-23</d><h>18:12</h><w>ikitommi</w>final change to figure out proper names for named branch -variants for: <code>:cat</code>, <code>:alt</code> and <code>:or</code>. they are currently <code>:cat*</code>, <code>:alt*</code> and  <code>:or*</code> <b>:face_with_rolling_eyes:</b>
<pre>(m/parse
  [:*
   [:alt* 
    [:s :string]
    [:i :int]]]
  [1 &quot;2&quot; 3 &quot;4&quot;])
; =&gt; [[:i 1] [:s &quot;2&quot;] [:i 3] [:s &quot;4]]</pre></z><z id="t1614104060" t="ikitommi :catn , :altn &amp; :orn ?"><y>#</y><d>2021-02-23</d><h>18:14</h><w>ikitommi</w><code>:catn</code>, <code>:altn</code> &amp; <code>:orn</code>?</z><z id="t1614104078" t="ikitommi :cat-named , :alt-named &amp; :or-named ?"><y>#</y><d>2021-02-23</d><h>18:14</h><w>ikitommi</w><code>:cat-named</code>, <code>:alt-named</code> &amp; <code>:or-named</code>?</z><z id="t1614104125" t="ikitommi :alley-cat , :danger-mouse &amp; :skeletor ?"><y>#</y><d>2021-02-23</d><h>18:15</h><w>ikitommi</w><code>:alley-cat</code>, <code>:danger-mouse</code> &amp; <code>:skeletor</code>?</z><z id="t1614151696" t="ordnungswidrig :cat-tag :alt-tag :or-tag ?"><y>#</y><d>2021-02-24</d><h>07:28</h><w>ordnungswidrig</w><code>:cat-tag :alt-tag :or-tag</code> ?</z><z id="t1614171903" t="Vincent Cantin i suggest :named-cat , :named-alt , :named-or"><y>#</y><d>2021-02-24</d><h>13:05</h><w>Vincent Cantin</w>i suggest <code>:named-cat</code>, <code>:named-alt</code>, <code>:named-or</code></z><z id="t1614173031" t="danielneal [:cat {:named? true}] ?"><y>#</y><d>2021-02-24</d><h>13:23</h><w>danielneal</w><code>[:cat {:named? true}]</code>?</z><z id="t1614521352" t="ikitommi using properties would be nice for users, but would make the parser more complex. and updating properties might change the behaviour of the schema silently: [:cat {:named? true} [:tuple int?]]"><y>#</y><d>2021-02-28</d><h>14:09</h><r>ikitommi</r>using properties would be nice for users, but would make the parser more complex. and updating properties might change the behaviour of the schema silently:
<pre>[:cat {:named? true} [:tuple int?]]</pre></z><z id="t1614521381" t="ikitommi [:cat {:named? false} [:tuple int?]] … is a totally diferent thing."><y>#</y><d>2021-02-28</d><h>14:09</h><r>ikitommi</r><pre>[:cat {:named? false} [:tuple int?]]</pre>
… is a totally diferent thing.</z><z id="t1614237443" t="steveb8n Q: can I use Malli inside a babashka script? (i.e. does it run inside sci?)"><y>#</y><d>2021-02-25</d><h>07:17</h><w>steveb8n</w>Q: can I use Malli inside a babashka script? (i.e. does it run inside sci?)</z><z id="t1614237472" t="steveb8n this would be useful for validating tools.cli parsed options"><y>#</y><d>2021-02-25</d><h>07:17</h><r>steveb8n</r>this would be useful for validating tools.cli parsed options</z><z id="t1614238997" t="borkdude Not yet, but feel free to post an issue, so we can gather community feedback. Meanwhile there are two options: spartan.spec and minimallist both work "><y>#</y><d>2021-02-25</d><h>07:43</h><r>borkdude</r>Not yet, but feel free to post an issue, so we can gather community feedback. Meanwhile there are two options: spartan.spec and minimallist both work </z><z id="t1614241937" t="ikitommi there is https://github.com/metosin/malli/issues/302 . Help most welcome"><y>#</y><d>2021-02-25</d><h>08:32</h><r>ikitommi</r>there is <a href="https://github.com/metosin/malli/issues/302" target="_blank">https://github.com/metosin/malli/issues/302</a>. Help most welcome</z><z id="t1614242156" t="borkdude I think it will be quite a lot of work to port malli to bb compatible code. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What is the API stability of malli? At one point we could add it to bb proper perhaps. I want to consider this, but also want some feedback from the &quot;bb community&quot; on this"><y>#</y><d>2021-02-25</d><h>08:35</h><r>borkdude</r>I think it will be quite a lot of work to port malli to bb compatible code. <a>@ikitommi</a> What is the API stability of malli? At one point we could add it to bb proper perhaps. I want to consider this, but also want some feedback from the &quot;bb community&quot; on this</z><z id="t1614242222" t="ikitommi Very stable. the named-schemas will change, but won’t change after release."><y>#</y><d>2021-02-25</d><h>08:37</h><r>ikitommi</r>Very stable. the named-schemas will change, but won’t change after release.</z><z id="t1614242268" t="ikitommi public api has been immutable for 6+ months, no plans on breaking."><y>#</y><d>2021-02-25</d><h>08:37</h><r>ikitommi</r>public api has been immutable for 6+ months, no plans on breaking.</z><z id="t1614242373" t="steveb8n thanks guys. since it’s only tools.cli in CI (i.e. almost never changes), I can write a custom vaildator instead"><y>#</y><d>2021-02-25</d><h>08:39</h><r>steveb8n</r>thanks guys. since it’s only tools.cli in CI (i.e. almost never changes), I can write a custom vaildator instead</z><z id="t1614242433" t="borkdude [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] OK. This lib https://github.com/green-coder/minimallist also works with bb btw"><y>#</y><d>2021-02-25</d><h>08:40</h><r>borkdude</r><a>@U0510KXTU</a> OK. This lib <a href="https://github.com/green-coder/minimallist" target="_blank">https://github.com/green-coder/minimallist</a> also works with bb btw</z><z id="t1614242533" t="steveb8n cool. I’ll give it a try. thx"><y>#</y><d>2021-02-25</d><h>08:42</h><r>steveb8n</r>cool. I’ll give it a try. thx</z><z id="t1614242663" t="steveb8n I like that it explicitely does not try to be fast. probably means they can deliver features faster"><y>#</y><d>2021-02-25</d><h>08:44</h><r>steveb8n</r>I like that it explicitely does not try to be fast. probably means they can deliver features faster</z><z id="t1614242695" t="steveb8n unlike Malli where I’m getting value out of the perf vs spec. perf is a feature"><y>#</y><d>2021-02-25</d><h>08:44</h><r>steveb8n</r>unlike Malli where I’m getting value out of the perf vs spec. perf is a feature</z><z id="t1614242737" t="borkdude perf is a feature and the style of writing code (reifying Java classes) isn&apos;t well supported by bb from source for any Java class :)"><y>#</y><d>2021-02-25</d><h>08:45</h><r>borkdude</r>perf is a feature and the style of writing code (reifying Java classes) isn&apos;t well supported by bb from source for any Java class :)</z><z id="t1614242766" t="borkdude Well, it is supported for records, etc, but definitely not fast"><y>#</y><d>2021-02-25</d><h>08:46</h><r>borkdude</r>Well, it is supported for records, etc, but definitely not fast</z><z id="t1614242792" t="ikitommi malli reifies just protocols, does that work ok?"><y>#</y><d>2021-02-25</d><h>08:46</h><r>ikitommi</r>malli reifies just protocols, does that work ok?</z><z id="t1614242814" t="ikitommi is there something that we could do on malli side to make it work?"><y>#</y><d>2021-02-25</d><h>08:46</h><r>ikitommi</r>is there something that we could do on malli side to make it work?</z><z id="t1614242820" t="steveb8n it’s all tradeoffs. I’m glad Tommi likes fast things 🙂"><y>#</y><d>2021-02-25</d><h>08:47</h><r>steveb8n</r>it’s all tradeoffs. I’m glad Tommi likes fast things <b>🙂</b></z><z id="t1614242842" t="borkdude it does work: $ bb -e &apos;(defprotocol Foo) (instance? Foo (reify Foo))&apos; true"><y>#</y><d>2021-02-25</d><h>08:47</h><r>borkdude</r>it does work:
<pre>$ bb -e &apos;(defprotocol Foo) (instance? Foo (reify Foo))&apos;
true</pre></z><z id="t1614242888" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Maybe using reader conditionals helps, #?(:bb :foo :clj :bar)"><y>#</y><d>2021-02-25</d><h>08:48</h><r>borkdude</r><a>@ikitommi</a> Maybe using reader conditionals helps, <code>#?(:bb :foo :clj :bar)</code></z><z id="t1614242896" t="borkdude for the parts that bb doesn&apos;t support"><y>#</y><d>2021-02-25</d><h>08:48</h><r>borkdude</r>for the parts that bb doesn&apos;t support</z><z id="t1614242914" t="ikitommi sure, happy to add. which parts? 🙂"><y>#</y><d>2021-02-25</d><h>08:48</h><r>ikitommi</r>sure, happy to add. which parts? <b>🙂</b></z><z id="t1614242939" t="borkdude try and you will find out :) happy to comment on those parts"><y>#</y><d>2021-02-25</d><h>08:48</h><r>borkdude</r>try and you will find out :) happy to comment on those parts</z><z id="t1614242945" t="ikitommi the protocol cache thing at least? (hacking over dead slow satisfies? )"><y>#</y><d>2021-02-25</d><h>08:49</h><r>ikitommi</r>the protocol cache thing at least? (hacking over dead slow <code>satisfies?</code>)</z><z id="t1614242971" t="ikitommi just write a bb script of some malli code and see what breaks?"><y>#</y><d>2021-02-25</d><h>08:49</h><r>ikitommi</r>just write a bb script of some malli code and see what breaks?</z><z id="t1614243033" t="borkdude yes. in the malli repo, write a script like: (require &apos;[babashka.classpath :as cp]) (cp/add-classpath &quot;src&quot;) and then (require &apos;[malli.core :as m])"><y>#</y><d>2021-02-25</d><h>08:50</h><r>borkdude</r>yes. in the malli repo, write a script like:

<pre>(require &apos;[babashka.classpath :as cp])
(cp/add-classpath &quot;src&quot;)</pre>
and then
<pre>(require &apos;[malli.core :as m])</pre></z><z id="t1614243034" t="ikitommi example/test-bed most welcome :)"><y>#</y><d>2021-02-25</d><h>08:50</h><r>ikitommi</r>example/test-bed most welcome :)</z><z id="t1614243068" t="ikitommi that simple. cool."><y>#</y><d>2021-02-25</d><h>08:51</h><r>ikitommi</r>that simple. cool.</z><z id="t1614243118" t="ikitommi will add that to our next tech/hack-friday, which is… tomorrow."><y>#</y><d>2021-02-25</d><h>08:51</h><r>ikitommi</r>will add that to our next tech/hack-friday, which is… tomorrow.</z><z id="t1614243202" t="ikitommi so, does the :bb conditional work already?"><y>#</y><d>2021-02-25</d><h>08:53</h><r>ikitommi</r>so, does the <code>:bb</code> conditional work already?</z><z id="t1614243203" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Actually, this is better: (ns bb-script) (require &apos;[babashka.deps :as deps] &apos;[clojure.edn :as edn]) (deps/add-deps (edn/read-string (slurp &quot;deps.edn&quot;))) (require &apos;[malli.core :as m])"><y>#</y><d>2021-02-25</d><h>08:53</h><r>borkdude</r><a>@ikitommi</a> Actually, this is better:
<pre>(ns bb-script)

(require &apos;[babashka.deps :as deps]
         &apos;[clojure.edn :as edn])

(deps/add-deps (edn/read-string (slurp &quot;deps.edn&quot;)))

(require &apos;[malli.core :as m])</pre></z><z id="t1614243222" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Yes, :bb is prioritized over :clj"><y>#</y><d>2021-02-25</d><h>08:53</h><r>borkdude</r><a>@ikitommi</a> Yes, <code>:bb</code> is prioritized over <code>:clj</code></z><z id="t1614243229" t="borkdude it&apos;s order dependent"><y>#</y><d>2021-02-25</d><h>08:53</h><r>borkdude</r>it&apos;s order dependent</z><z id="t1614243360" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] So the first hack I did: (ns malli.sci #"><y>#</y><d>2021-02-25</d><h>08:56</h><r>borkdude</r><a>@ikitommi</a> So the first hack I did:
<pre>(ns malli.sci
  #</pre></z><z id="t1614243393" t="borkdude The nest error: ----- Error -------------------------------------------------------------------- Type: java.lang.Exception Message: Unable to resolve classname: java.util.ArrayDeque Location: /private/tmp/malli/src/malli/impl/regex.cljc:35:3 ----- Context ------------------------------------------------------------------ 31: recognition for `validate`.&quot; 32: 33: (:refer-clojure :exclude [+ * repeat cat]) 34: (:require [malli.impl.util :as miu]) 35: #?(:clj (:import [java.util ArrayDeque]))) ^--- Unable to resolve classname: java.util.ArrayDeque"><y>#</y><d>2021-02-25</d><h>08:56</h><r>borkdude</r>The nest error:
<pre>----- Error --------------------------------------------------------------------
Type:     java.lang.Exception
Message:  Unable to resolve classname: java.util.ArrayDeque
Location: /private/tmp/malli/src/malli/impl/regex.cljc:35:3

----- Context ------------------------------------------------------------------
31:   recognition for `validate`.&quot;
32:
33:   (:refer-clojure :exclude [+ * repeat cat])
34:   (:require [malli.impl.util :as miu])
35:   #?(:clj (:import [java.util ArrayDeque])))
      ^--- Unable to resolve classname: java.util.ArrayDeque</pre></z><z id="t1614243406" t="borkdude So we don&apos;t have that class in bb (yet)"><y>#</y><d>2021-02-25</d><h>08:56</h><r>borkdude</r>So we don&apos;t have that class in bb (yet)</z><z id="t1614243456" t="borkdude I see that for cljs you didn&apos;t use it"><y>#</y><d>2021-02-25</d><h>08:57</h><r>borkdude</r>I see that for cljs you didn&apos;t use it</z><z id="t1614243487" t="borkdude I guess for bb you can take the :cljs branches there"><y>#</y><d>2021-02-25</d><h>08:58</h><r>borkdude</r>I guess for bb you can take the <code>:cljs</code> branches there</z><z id="t1614243587" t="borkdude Then after doing that, I run into: (deftype ^:private CacheEntry [^long hash f ^long pos regs]) "><y>#</y><d>2021-02-25</d><h>08:59</h><r>borkdude</r>Then after doing that, I run into:
<pre>(deftype ^:private CacheEntry [^long hash f ^long pos regs])</pre>
</z><z id="t1614243626" t="borkdude There are other deftypes in regex.cljc"><y>#</y><d>2021-02-25</d><h>09:00</h><r>borkdude</r>There are other <code>deftypes</code> in <code>regex.cljc</code></z><z id="t1614243647" t="ikitommi what would be a good workaround for those?"><y>#</y><d>2021-02-25</d><h>09:00</h><r>ikitommi</r>what would be a good workaround for those?</z><z id="t1614243659" t="ikitommi or, will bb support those at some point?"><y>#</y><d>2021-02-25</d><h>09:00</h><r>ikitommi</r>or, will bb support those at some point?</z><z id="t1614243703" t="ikitommi good to understand how to create bb-compatible code for the future."><y>#</y><d>2021-02-25</d><h>09:01</h><r>ikitommi</r>good to understand how to create bb-compatible code for the future.</z><z id="t1614243713" t="borkdude So these are the types of things that are not supported yet. Classes can be added, but deftype isn&apos;t supported. I don&apos;t know what to do with deftype yet. Records are &quot;faked&quot; using normal maps + metadata."><y>#</y><d>2021-02-25</d><h>09:01</h><r>borkdude</r>So these are the types of things that are not supported yet. Classes can be added, but <code>deftype</code> isn&apos;t supported.
I don&apos;t know what to do with deftype yet. Records are &quot;faked&quot; using normal maps + metadata.</z><z id="t1614243851" t="borkdude I have seen a similar thing with meander vs matchete. Matchete is written in a &quot;simple&quot; Clojure style so it just works with bb out of the box. https://github.com/xapix-io/matchete Where meander focuses on performance and this results in incompatible code."><y>#</y><d>2021-02-25</d><h>09:04</h><r>borkdude</r>I have seen a similar thing with meander vs matchete.

Matchete is written in a &quot;simple&quot; Clojure style so it just works with bb out of the box.

<a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a>

Where meander focuses on performance and this results in incompatible code.</z><z id="t1614243901" t="borkdude Meander now has an &quot;interpreter&quot; which is compatible with bb which also more flexible than the macro style enforced in the main lib"><y>#</y><d>2021-02-25</d><h>09:05</h><r>borkdude</r>Meander now has an &quot;interpreter&quot; which is compatible with bb which also more flexible than the macro style enforced in the main lib</z><z id="t1614255219" t="borkdude Is there a way to get the humanized string for a schema, without any input? (prn (me/humanize [:&lt; 100])) ;;=&gt; &quot;should be smaller than 100&quot;"><y>#</y><d>2021-02-25</d><h>12:13</h><w>borkdude</w>Is there a way to get the humanized string for a schema, without any input?
<pre>(prn (me/humanize [:&lt; 100]))</pre>
<pre>;;=&gt; &quot;should be smaller than 100&quot;</pre></z><z id="t1614263190" t="ikitommi oh, with nil value you mean?"><y>#</y><d>2021-02-25</d><h>14:26</h><r>ikitommi</r>oh, with nil value you mean?</z><z id="t1614263551" t="borkdude with no value at all"><y>#</y><d>2021-02-25</d><h>14:32</h><r>borkdude</r>with no value at all</z><z id="t1614263562" t="borkdude it seems that the returned string doesn&apos;t depend on the input"><y>#</y><d>2021-02-25</d><h>14:32</h><r>borkdude</r>it seems that the returned string doesn&apos;t depend on the input</z><z id="t1614262756" t="ikitommi you can either: [:int {:max 100}] or: [:&lt; {:error/message &quot;should be smaller than 100&quot;} 100]"><y>#</y><d>2021-02-25</d><h>14:19</h><w>ikitommi</w>you can either:

<pre>[:int {:max 100}]
</pre>
or:

<pre>[:&lt; {:error/message &quot;should be smaller than 100&quot;} 100]</pre></z><z id="t1614262827" t="ikitommi there are set of &quot;type&quot; schemas, which read properties: :int, :string , ..."><y>#</y><d>2021-02-25</d><h>14:20</h><w>ikitommi</w>there are set of &quot;type&quot; schemas, which read properties: <code>:int,</code> <code>:string</code> , ...</z><z id="t1614262921" t="ikitommi might map all predicates schemas into these internally, which would make things like JSON Schema transformations &amp; normal transformations simpler, need just to be defined for the base type, not to all predicates."><y>#</y><d>2021-02-25</d><h>14:22</h><w>ikitommi</w>might map all predicates schemas into these internally, which would make things like JSON Schema transformations &amp; normal transformations simpler, need just to be defined for the base type, not to all predicates.</z><z id="t1614262979" t="ikitommi pos-int? -&gt; [:int {:min 1}] ..."><y>#</y><d>2021-02-25</d><h>14:22</h><w>ikitommi</w><code>pos-int?</code> -&gt; <code>[:int {:min 1}]</code>...</z><z id="t1614264794" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What I mean is: you can get a string from humanize but this needs some input too which you first have to validate. However, the resulting string doesn&apos;t seem to be related to the input at all. This made me wonder: is it possible to get some &quot;model&quot; error message from a schema only, without validating anything"><y>#</y><d>2021-02-25</d><h>14:53</h><w>borkdude</w><a>@ikitommi</a> What I mean is: you can get a string from <code>humanize</code> but this needs some input too which you first have to validate. However, the resulting string doesn&apos;t seem to be related to the input at all. This made me wonder: is it possible to get some &quot;model&quot; error message from a schema only, without validating anything</z><z id="t1614264816" t="borkdude This can then be passed to the second arg of the :validate tuple in tools.cli"><y>#</y><d>2021-02-25</d><h>14:53</h><w>borkdude</w>This can then be passed to the second arg of the <code>:validate</code> tuple in tools.cli</z><z id="t1614264854" t="borkdude Not that important, I can make the string itself manually or by validating some dummy input"><y>#</y><d>2021-02-25</d><h>14:54</h><w>borkdude</w>Not that important, I can make the string itself manually or by validating some dummy input</z><z id="t1614269399" t="ikitommi malli supports both fixed error messages and functions generating error messages, the two examples here: https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L62-L68"><y>#</y><d>2021-02-25</d><h>16:09</h><w>ikitommi</w>malli supports both fixed error messages and  functions generating error messages, the two examples here: <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L62-L68" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L62-L68</a></z><z id="t1614269432" t="ikitommi ... and messages can be localized. So, no simple way to do without value."><y>#</y><d>2021-02-25</d><h>16:10</h><w>ikitommi</w>... and messages can be localized. So, no simple way to do without value.</z><z id="t1614269503" t="ikitommi there are helpers in malli.error to pull out the error message/fn out of a schema, but value is needed for the fn case"><y>#</y><d>2021-02-25</d><h>16:11</h><w>ikitommi</w>there are helpers in <code>malli.error</code> to pull out the error message/fn out of a schema, but value is needed for the fn case</z><z id="t1614269676" t="ikitommi also, one schema can emit many different errors, humanized by the error type. Maps emit extra-keys, missing-keys, missspelled-keys, etc."><y>#</y><d>2021-02-25</d><h>16:14</h><w>ikitommi</w>also, one schema can emit many different errors, humanized by the error type. Maps emit extra-keys, missing-keys, missspelled-keys, etc.</z><z id="t1614336566" t="borkdude Did this experiment. It brings malli to babashka via a pod. Due to pod limitations it might not bring you all the features, but might still be useful somehow. Feedback welcome 😊"><y>#</y><d>2021-02-26</d><h>10:49</h><w>borkdude</w>Did this experiment. It brings malli to babashka via a pod. Due to pod limitations it might not bring you all the features, but might still be useful somehow. Feedback welcome <b>😊</b></z><z id="t1614369431" t="bartuka not sure if ask in #malli or #reitit channel, but nesting routes with path params are not merged correctly. I found this issue https://github.com/metosin/reitit/issues/462 there is any update on this?"><y>#</y><d>2021-02-26</d><h>19:57</h><w>bartuka</w>not sure if ask in #malli or #reitit channel, but nesting routes with path params are not merged correctly. I found this issue <a href="https://github.com/metosin/reitit/issues/462" target="_blank">https://github.com/metosin/reitit/issues/462</a> there is any update on this?</z><z id="t1614369951" t="juhoteperi No updates yet. It is Reitit issue, Malli has malli.util/merge function that would work here, but Reitit doesn&apos;t have option to control how the values are merged, and because it is currently done using external library ( https://github.com/weavejester/meta-merge ) it is not simple to change. Might have to copy meta-merge logic to Reitit and extend with controls to use custom function in certain paths."><y>#</y><d>2021-02-26</d><h>20:05</h><r>juhoteperi</r>No updates yet.

It is Reitit issue, Malli has <code>malli.util/merge</code> function that would work here, but Reitit doesn&apos;t have option to control how the values are merged, and because it is currently done using external library (<a href="https://github.com/weavejester/meta-merge" target="_blank">https://github.com/weavejester/meta-merge</a>) it is not simple to change.

Might have to copy meta-merge logic to Reitit and extend with controls to use custom function in certain paths.</z><z id="t1614373015" t="juhoteperi https://github.com/metosin/reitit/pull/474 adds tests and found the place where we could call malli merge"><y>#</y><d>2021-02-26</d><h>20:56</h><r>juhoteperi</r><a href="https://github.com/metosin/reitit/pull/474" target="_blank">https://github.com/metosin/reitit/pull/474</a> adds tests and found the place where we could call malli merge</z><z id="t1614369951" t="juhoteperi No updates yet. It is Reitit issue, Malli has malli.util/merge function that would work here, but Reitit doesn&apos;t have option to control how the values are merged, and because it is currently done using external library ( https://github.com/weavejester/meta-merge ) it is not simple to change. Might have to copy meta-merge logic to Reitit and extend with controls to use custom function in certain paths."><y>#</y><d>2021-02-26</d><h>20:05</h><w>juhoteperi</w>No updates yet.

It is Reitit issue, Malli has <code>malli.util/merge</code> function that would work here, but Reitit doesn&apos;t have option to control how the values are merged, and because it is currently done using external library (<a href="https://github.com/weavejester/meta-merge" target="_blank">https://github.com/weavejester/meta-merge</a>) it is not simple to change.

Might have to copy meta-merge logic to Reitit and extend with controls to use custom function in certain paths.</z><z id="t1614373015" t="juhoteperi https://github.com/metosin/reitit/pull/474 adds tests and found the place where we could call malli merge"><y>#</y><d>2021-02-26</d><h>20:56</h><w>juhoteperi</w><a href="https://github.com/metosin/reitit/pull/474" target="_blank">https://github.com/metosin/reitit/pull/474</a> adds tests and found the place where we could call malli merge</z><z id="t1614373108" t="ikitommi there is also the nil-issue, that won&apos;t be fixed in meta-merge. Would simplify a lot how reitit route data can be used. metosin/ctrl-merge , right?"><y>#</y><d>2021-02-26</d><h>20:58</h><w>ikitommi</w>there is also the nil-issue, that won&apos;t be fixed in meta-merge. Would simplify a lot how reitit route data can be used. <code>metosin/ctrl-merge</code>, right?</z><z id="t1614373115" t="ikitommi https://github.com/weavejester/meta-merge/issues/11"><y>#</y><d>2021-02-26</d><h>20:58</h><r>ikitommi</r><a href="https://github.com/weavejester/meta-merge/issues/11" target="_blank">https://github.com/weavejester/meta-merge/issues/11</a></z><z id="t1614521214" t="ikitommi naming is hard. to merge or not to merge: https://github.com/metosin/malli/pull/378"><y>#</y><d>2021-02-28</d><h>14:06</h><w>ikitommi</w>naming is hard. to merge or not to merge: <a href="https://github.com/metosin/malli/pull/378" target="_blank">https://github.com/metosin/malli/pull/378</a></z><z id="t1614617458" t="Elso Didn&apos;t really know where to put it, more a general metosin issue, but I&apos;m getting Syntax error macroexpanding at (core.clj:152:3). Execution error (ClassNotFoundException) at jdk.internal.loader.BuiltinClassLoader/loadClass (BuiltinClassLoader.java:581). com.fasterxml.jackson.core.util.JacksonFeature when loading metosin/jsonista 0.3.1"><y>#</y><d>2021-03-01</d><h>16:50</h><w>Elso</w>Didn&apos;t really know where to put it, more a general metosin issue, but I&apos;m getting
Syntax error macroexpanding at (core.clj:152:3).
Execution error (ClassNotFoundException) at jdk.internal.loader.BuiltinClassLoader/loadClass (BuiltinClassLoader.java:581).
com.fasterxml.jackson.core.util.JacksonFeature
when loading metosin/jsonista 0.3.1</z><z id="t1614630129" t="mynomoto I&apos;m trying the current master a58e04b265b1b6658bb9fe791fd103cfab452e53 for clj-kondo linting of function specs and it looks like that the configuration is generating the :ret key as shown on the readme. Was that removed on purpose, or am I doing something wrong?"><y>#</y><d>2021-03-01</d><h>20:22</h><w>mynomoto</w>I&apos;m trying the current master <code>a58e04b265b1b6658bb9fe791fd103cfab452e53</code> for clj-kondo linting of function specs and it looks like that the configuration is generating the <code>:ret</code> key as shown on the readme. Was that removed on purpose, or am I doing something wrong?</z><z id="t1614630443" t="mynomoto I think https://github.com/metosin/malli/commit/0a22ccb1036c25b12f4b8c0d0f1dc20682aa6ca1 broke it, will create a pr."><y>#</y><d>2021-03-01</d><h>20:27</h><w>mynomoto</w>I think <a href="https://github.com/metosin/malli/commit/0a22ccb1036c25b12f4b8c0d0f1dc20682aa6ca1" target="_blank">https://github.com/metosin/malli/commit/0a22ccb1036c25b12f4b8c0d0f1dc20682aa6ca1</a> broke it, will create a pr.</z><z id="t1614649316" t="bartuka I am trying to use :* and got this message {:type :malli.core/invalid-schema, :data {:schema :*}} there is some setup to enable regex-like support?"><y>#</y><d>2021-03-02</d><h>01:41</h><w>bartuka</w>I am trying to use <code>:*</code> and got this message <code>{:type :malli.core/invalid-schema, :data {:schema :*}}</code> there is some setup to enable regex-like support?</z><z id="t1614649894" t="bartuka I think https://github.com/metosin/malli/blob/a58e04b265b1b6658bb9fe791fd103cfab452e53/src/malli/core.cljc#L1873 (sequence-schemas) happened after the last release hehe"><y>#</y><d>2021-03-02</d><h>01:51</h><w>bartuka</w>I think <a href="https://github.com/metosin/malli/blob/a58e04b265b1b6658bb9fe791fd103cfab452e53/src/malli/core.cljc#L1873" target="_blank">https://github.com/metosin/malli/blob/a58e04b265b1b6658bb9fe791fd103cfab452e53/src/malli/core.cljc#L1873</a> (sequence-schemas) happened after the last release hehe</z><z id="t1614652201" t="mynomoto If you are using tools-deps you can reference a github commit."><y>#</y><d>2021-03-02</d><h>02:30</h><r>mynomoto</r>If you are using tools-deps you can reference a github commit.</z><z id="t1614672751" t="Yevgeni Tsodikov Hi all, I’m trying to define a map with several optional fields, that at least 1 of them must exist. For example, :a and :b are optional, :c is required. {:a 1 :c 1} ; valid {:b 1 :c 1} ; valid {:a 1 :b 1 :c 1} ; valid {:c 1} ; nope, invalid As a reference, with `spec` , I’d write something like (s/def ::my-map (s/keys :req-un [::c (or ::a ::b)])) "><y>#</y><d>2021-03-02</d><h>08:12</h><w>Yevgeni Tsodikov</w>Hi all,
I’m trying to define a map with several optional fields, that at least 1 of them must exist.
For example, <code>:a</code> and <code>:b</code> are optional, <code>:c</code> is required.
<pre>{:a 1 :c 1}      ; valid
{:b 1 :c 1}      ; valid
{:a 1 :b 1 :c 1} ; valid
{:c 1}           ; nope, invalid</pre>
As a reference, with `spec` , I’d write something like
<pre>(s/def ::my-map
  (s/keys :req-un [::c (or ::a ::b)]))</pre>
</z><z id="t1614676213" t="ikitommi [:attrs {:href &quot;/_/_/users/U01PU4APSKV&quot;}] you can compose with :and , see example here: https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D"><y>#</y><d>2021-03-02</d><h>09:10</h><w>ikitommi</w><a>@evg.tso</a> you can compose with <code>:and</code>, see example here: <a href="https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D</a></z><z id="t1614677970" t="Yevgeni Tsodikov The thing with :and is that is doesn’t survive mu/merge very well. To be more specific, my use case is with reitit . There are several routes with common fields, but each route has specific fields that are different from one another. • POST /share/this would accept either :a or :b and must contain :c (for example {:a 1 :c 1} • POST /share/that would accept either :a or :b and must contain :d (for example {:a 1 :d 1} . └── schema with optional fields (at least one must exist) ├── mu/merge-ed schema with specific fields └── mu/merge-ed schema with specific fields"><y>#</y><d>2021-03-02</d><h>09:39</h><r>Yevgeni Tsodikov</r>The thing with <code>:and</code> is that is doesn’t survive <code>mu/merge</code> very well.
To be more specific, my use case is with <code>reitit</code>.
There are several routes with common fields, but each route has specific fields that are different from one another.
• <code>POST /share/this</code>  would accept either <code>:a</code> or <code>:b</code> and must contain <code>:c</code> (for example <code>{:a 1 :c 1}</code>
• <code>POST /share/that</code> would accept either <code>:a</code> or <code>:b</code> and must contain <code>:d</code> (for example <code>{:a 1 :d 1}</code>
<pre>.
└── schema with optional fields (at least one must exist)
    ├── mu/merge-ed schema with specific fields
    └── mu/merge-ed schema with specific fields</pre></z><z id="t1614678080" t="Yevgeni Tsodikov (mu/merge [:map [:specific-field string?]] [:and [:map [:x int?] [:y int?]]]) =&gt; [:and [:map [:x int?] [:y int?]]]"><y>#</y><d>2021-03-02</d><h>09:41</h><r>Yevgeni Tsodikov</r><pre>(mu/merge 
  [:map [:specific-field string?]]
  [:and
   [:map [:x int?] [:y int?]]])
=&gt; [:and [:map [:x int?] [:y int?]]]</pre></z><z id="t1614678276" t="ikitommi I see. What if :and was considered as a constrained-kinda thing, where the first value is the actual schema and the rest are just extra rules for that. Would solve a lot of things. :thinking_face:"><y>#</y><d>2021-03-02</d><h>09:44</h><r>ikitommi</r>I see. What if <code>:and</code> was considered as a constrained-kinda thing, where the first value is the actual schema and the rest are just extra rules for that. Would solve a lot of things. <b>:thinking_face:</b></z><z id="t1614678324" t="ikitommi need to check would it break existing contracts or not."><y>#</y><d>2021-03-02</d><h>09:45</h><r>ikitommi</r>need to check would it break existing contracts or not.</z><z id="t1614678420" t="ikitommi would this be more correct: (mu/merge [:map [:specific-field string?]] [:and [:map [:x int?] [:y int?]] map?]]) =&gt; [:and [:map [:spesific-field string?] [:x int?] [:y int?]] map?]"><y>#</y><d>2021-03-02</d><h>09:47</h><r>ikitommi</r>would this be more correct:
<pre>(mu/merge 
  [:map [:specific-field string?]]
  [:and
   [:map [:x int?] [:y int?]]
   map?]])
=&gt; [:and [:map [:spesific-field string?] [:x int?] [:y int?]] map?]</pre></z><z id="t1614678472" t="Yevgeni Tsodikov That would be great!"><y>#</y><d>2021-03-02</d><h>09:47</h><r>Yevgeni Tsodikov</r>That would be great!</z><z id="t1614678605" t="Yevgeni Tsodikov In most of my schemas I use :and to add additional data like a :fn or a custom error message."><y>#</y><d>2021-03-02</d><h>09:50</h><r>Yevgeni Tsodikov</r>In most of my schemas I use <code>:and</code> to add additional data like a <code>:fn</code> or a custom error message.</z><z id="t1614686774" t="ikitommi [metosin/malli &quot;0.3.0&quot;] 🥳 🥳 🥳"><y>#</y><d>2021-03-02</d><h>12:06</h><w>ikitommi</w><code>[metosin/malli &quot;0.3.0&quot;]</code> <b>🥳</b> <b>🥳</b> <b>🥳</b></z><z id="t1614688833" t="delaguardo Hi! I’m using malli together with reitit and reitit-swagger and I found a problem when I start using custom malli’s registry. tldr; generated swagger partials for an endpoint contains “definitions” key which is not valid according to swagger2 spec. also it messes up with references trying to point to one of defined schemas. As a workaround I added a middleware to walk throw generated object which will be encoded as json and pull all definitions to the top level but it looks ugly and not generic enough. Also there is a small inconsistency in encoding keywords to json. https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Afoo%2FConsCell%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%3Afoo%2FConsCell%5D%5D%5D%7D%7D%0A%20%3Afoo%2FConsCell%5D here is an illustration — :$ref key contains a string &quot;#/definitions/:foo/ConsCell&quot; with : inside. and there is a key :foo/ConsCell in :definitions after encoding to json this schema will be invalid because of : present in “$ref” key"><y>#</y><d>2021-03-02</d><h>12:40</h><w>delaguardo</w>Hi! I’m using malli together with reitit and reitit-swagger and I found a problem when I start using custom malli’s registry. tldr; generated swagger partials for an endpoint contains “definitions” key which is not valid according to swagger2 spec. also it messes up with references trying to point to one of defined schemas. As a workaround I added a middleware to walk throw generated object which will be encoded as json and pull all definitions to the top level but it looks ugly and not generic enough. Also there is a small inconsistency in encoding keywords to json.
<a href="https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Afoo%2FConsCell%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%3Afoo%2FConsCell%5D%5D%5D%7D%7D%0A%20%3Afoo%2FConsCell%5D" target="_blank">https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%3Afoo%2FConsCell%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%3Afoo%2FConsCell%5D%5D%5D%7D%7D%0A%20%3Afoo%2FConsCell%5D</a>
here is an illustration — :$ref key contains a string <code>&quot;#/definitions/:foo/ConsCell&quot;</code> with <code>:</code> inside. and there is a key <code>:foo/ConsCell</code> in <code>:definitions</code> after encoding to json this schema will be invalid because of <code>:</code> present in “$ref” key</z><z id="t1614690146" t="ikitommi I see. PR would be welcome to fix this. Maybe stringify all reference keys?"><y>#</y><d>2021-03-02</d><h>13:02</h><r>ikitommi</r>I see. PR would be welcome to fix this. Maybe stringify all reference keys?</z><z id="t1614690323" t="delaguardo I would like to try ) where such fix should go? reitit-swagger or malli itself?"><y>#</y><d>2021-03-02</d><h>13:05</h><r>delaguardo</r>I would like to try ) where such fix should go? reitit-swagger or malli itself?</z><z id="t1614690857" t="ikitommi In malli, either malli.json-schema or malli.swagger ns."><y>#</y><d>2021-03-02</d><h>13:14</h><r>ikitommi</r>In malli, either <code>malli.json-schema</code> or <code>malli.swagger</code> ns.</z><z id="t1614690885" t="delaguardo cool, will be back with PR )"><y>#</y><d>2021-03-02</d><h>13:14</h><r>delaguardo</r>cool, will be back with PR )</z><z id="t1614694116" t="stathissideris congrats on the release!"><y>#</y><d>2021-03-02</d><h>14:08</h><w>stathissideris</w>congrats on the release!</z><z id="t1614864264" t="borkdude Nice tweet [:attrs {:href &quot;/_/_/users/U051MTYAB&quot;}] :) https://twitter.com/wazound/status/1367303612028751872"><y>#</y><d>2021-03-04</d><h>13:24</h><w>borkdude</w>Nice tweet <a>@mikethompson</a> :) <a href="https://twitter.com/wazound/status/1367303612028751872" target="_blank">https://twitter.com/wazound/status/1367303612028751872</a></z><z id="t1614864302" t="borkdude I hear similar sentiments in the latest #defnpodcast - there they called it the Osborne effect. https://en.wikipedia.org/wiki/Osborne_effect#:~:text=The%20Osborne%20effect%20is%20a,announcing%20a%20future%20product%20prematurely ."><y>#</y><d>2021-03-04</d><h>13:25</h><w>borkdude</w>I hear similar sentiments in the latest #defnpodcast - there they called it the Osborne effect.
<a href="https://en.wikipedia.org/wiki/Osborne_effect#:~:text=The%20Osborne%20effect%20is%20a,announcing%20a%20future%20product%20prematurely" target="_blank">https://en.wikipedia.org/wiki/Osborne_effect#:~:text=The%20Osborne%20effect%20is%20a,announcing%20a%20future%20product%20prematurely</a>.</z><z id="t1614864626" t="borkdude I have the exact same problem with babashka: waiting for spec2 so not including spec1: and this can result in years of having nothing perhaps"><y>#</y><d>2021-03-04</d><h>13:30</h><w>borkdude</w>I have the exact same problem with babashka: waiting for spec2 so not including spec1: and this can result in years of having nothing perhaps</z><z id="t1614864686" t="mikethompson I didn&apos;t hear that podcast, but yeah, I feel like Clojure needs an outcome. We&apos;re stuck in something of a twilight zone. And this is an important issue. And right now Malli is just better. Unless there is something pending with spec ... it feels like we need permission to get on with making Malli &quot;it&quot;"><y>#</y><d>2021-03-04</d><h>13:31</h><w>mikethompson</w>I didn&apos;t hear that podcast, but yeah, I feel like Clojure needs an outcome.
We&apos;re stuck in something of a twilight zone.  And this is an important issue.
And right now Malli is just better.
Unless there is something pending with spec ... it feels like we need permission to get on with making Malli &quot;it&quot;</z><z id="t1614864833" t="borkdude In some way, no matter how good your library is, you can&apos;t compete with core since people will just believe that &quot;core is better&quot; no matter what you do, which isn&apos;t fair maybe. But &quot;better&quot; is probably not the right way to describe it: spec and malli have different approaches. spec is more of an RDF approach where each unique attribute name describes a schema"><y>#</y><d>2021-03-04</d><h>13:33</h><w>borkdude</w>In some way, no matter how good your library is, you can&apos;t compete with core since people will just believe that &quot;core is better&quot; no matter what you do, which isn&apos;t fair maybe.
But &quot;better&quot; is probably not the right way to describe it: spec and malli have different approaches. spec is more of an RDF approach where each unique attribute name describes a schema</z><z id="t1614864875" t="mikethompson I&apos;m the same as you: should re-frame support spec or Malli. I&apos;ve held off for a long time."><y>#</y><d>2021-03-04</d><h>13:34</h><w>mikethompson</w>I&apos;m the same as you:  should re-frame support spec or Malli.
I&apos;ve held off for a long time.</z><z id="t1614864915" t="borkdude Why should re-frame have to choose here? Can&apos;t this be decided in some add-on lib? Why do you need to address this concern in re-frame itself?"><y>#</y><d>2021-03-04</d><h>13:35</h><w>borkdude</w>Why should re-frame have to choose here? Can&apos;t this be decided in some add-on lib? Why do you need to address this concern in re-frame itself?</z><z id="t1614864932" t="mikethompson I could"><y>#</y><d>2021-03-04</d><h>13:35</h><w>mikethompson</w>I could</z><z id="t1614864947" t="borkdude Re-frame events are already associated with globally namespaced keywords which maybe aligns well with spec"><y>#</y><d>2021-03-04</d><h>13:35</h><w>borkdude</w>Re-frame events are already associated with globally namespaced keywords which maybe aligns well with spec</z><z id="t1614864987" t="mikethompson But if ever spec is ratified as the one true way for Clojure, I&apos;d like for it to be the one true way for re-frame too"><y>#</y><d>2021-03-04</d><h>13:36</h><w>mikethompson</w>But if ever spec is ratified as the one true way for Clojure, I&apos;d like for it to be the one true way for re-frame too</z><z id="t1614865006" t="mikethompson Anyways"><y>#</y><d>2021-03-04</d><h>13:36</h><w>mikethompson</w>Anyways</z><z id="t1614865036" t="borkdude Maybe it can be made pluggable"><y>#</y><d>2021-03-04</d><h>13:37</h><w>borkdude</w>Maybe it can be made pluggable</z><z id="t1614865509" t="juhoteperi Reitit supports all three so the application can choose."><y>#</y><d>2021-03-04</d><h>13:45</h><w>juhoteperi</w>Reitit supports all three so the application can choose.</z><z id="t1614865548" t="juhoteperi Pluggable solution is probably also quite important in Cljs apps, because either Spec or Malli both add about 100KB JS to the output bundle (before gzip)."><y>#</y><d>2021-03-04</d><h>13:45</h><w>juhoteperi</w>Pluggable solution is probably also quite important in Cljs apps, because either Spec or Malli both add about 100KB JS to the output bundle (before gzip).</z><z id="t1614865613" t="juhoteperi I was surprised by this recently when I checked project output report in app that uses Malli, but re-chain uses Spec internally: https://github.com/ingesolvoll/re-chain/issues/6"><y>#</y><d>2021-03-04</d><h>13:46</h><w>juhoteperi</w>I was surprised by this recently when I checked project output report in app that uses Malli, but re-chain uses Spec internally: <a href="https://github.com/ingesolvoll/re-chain/issues/6" target="_blank">https://github.com/ingesolvoll/re-chain/issues/6</a></z><z id="t1614872330" t="ikitommi Interesting discussion. About Malli cljs-size. The core has been developed DCE in mind, you can make a Malli bundle with just validation of strings, numbers, maps, vector and sets and it’s few kilos zipped. Currently, many extensions (humanized errors, generation, json schema etc) are implemented using multimethods, so pulling anything out of those, makes it much bigger."><y>#</y><d>2021-03-04</d><h>15:38</h><w>ikitommi</w>Interesting discussion. About Malli cljs-size. The core has been developed DCE in mind, you can make a Malli bundle with just validation of strings, numbers, maps, vector and sets and it’s few kilos zipped. Currently, many extensions (humanized errors, generation, json schema etc) are implemented using multimethods, so pulling anything out of those, makes it much  bigger.</z><z id="t1614872348" t="ikitommi The Code Size Expression Problem."><y>#</y><d>2021-03-04</d><h>15:39</h><w>ikitommi</w>The Code Size Expression Problem.</z><z id="t1614872445" t="ikitommi"><y>#</y><d>2021-03-04</d><h>15:40</h><w>ikitommi</w></z><z id="t1614872459" t="ikitommi here’s the bare-bones malli."><y>#</y><d>2021-03-04</d><h>15:40</h><w>ikitommi</w>here’s the bare-bones malli.</z><z id="t1614872559" t="ikitommi [:attrs {:href &quot;/_/_/users/U051MTYAB&quot;}] what would the spec/malli integration look like? do you need something?"><y>#</y><d>2021-03-04</d><h>15:42</h><w>ikitommi</w><a>@mikethompson</a> what would the spec/malli integration look like? do you need something?</z><z id="t1614873758" t="juhoteperi And Reitit Malli coercion is built for Ring model, so it includes lots of features that are unnecessary for frontend routing. When we get around to implementing separate frontend coercion, it will drop dependency on some unused parts."><y>#</y><d>2021-03-04</d><h>16:02</h><w>juhoteperi</w>And Reitit Malli coercion is built for Ring model, so it includes lots of features that are unnecessary for frontend routing. When we get around to implementing separate frontend coercion, it will drop dependency on some unused parts.</z><z id="t1614873783" t="juhoteperi Like the json schema generation parts."><y>#</y><d>2021-03-04</d><h>16:03</h><w>juhoteperi</w>Like the json schema generation parts.</z><z id="t1614874360" t="emccue ^i&apos;m not opposed to the json schema stuff but it does feel odd that it isn&apos;t a separate artifact"><y>#</y><d>2021-03-04</d><h>16:12</h><w>emccue</w>^i&apos;m not opposed to the json schema stuff but it does feel odd that it isn&apos;t a separate artifact</z><z id="t1614874515" t="juhoteperi It is separate namespace on Malli. On Reitit coercion impl. the parameter validation and generating the json-schemas for routes is closely related so they are on the same module currently."><y>#</y><d>2021-03-04</d><h>16:15</h><w>juhoteperi</w>It is separate namespace on Malli.

On Reitit coercion impl. the parameter validation and generating the json-schemas for routes is closely related so they are on the same module currently.</z><z id="t1614874630" t="ikitommi yes, there should be a lite-version of reitit coercion, with just the encoding &amp; decoding part - without throwing exceptions. Frontend would use that: simple, pure and small."><y>#</y><d>2021-03-04</d><h>16:17</h><w>ikitommi</w>yes, there should be a lite-version of reitit coercion, with just the encoding &amp; decoding part - without throwing exceptions. Frontend would use that: simple, pure and small.</z><z id="t1614874701" t="ikitommi malli is designed so that malli.core is the essential ns, all others are optional (ok, there is nowadays malli.impl too). It has been easier to optimize the whole as everyhing is in single repo."><y>#</y><d>2021-03-04</d><h>16:18</h><w>ikitommi</w>malli is designed so that <code>malli.core</code> is the essential ns, all others are optional (ok, there is nowadays <code>malli.impl</code> too). It has been easier to optimize the whole as everyhing is in single repo.</z><z id="t1614879575" t="arundilipan Hi everyone, I’m not sure if this is a bug, but I’m running into a quirk with the validation and error reporting of :catn schemas"><y>#</y><d>2021-03-04</d><h>17:39</h><w>arundilipan</w>Hi everyone, I’m not sure if this is a bug, but I’m running into a quirk with the validation and error reporting of <code>:catn</code> schemas</z><z id="t1614879601" t="arundilipan For example if you had a schema like: [:catn [:amount [:fn {:error/fn &apos;(fn [{:keys [value]} _] (str &quot;Received value &quot; value &quot;, should be &gt; 0&quot;)) :decode/string malli.transform/-string-&gt;double} &apos;#(&gt; % 0)]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]"><y>#</y><d>2021-03-04</d><h>17:40</h><w>arundilipan</w>For example if you had a schema like:
<pre>[:catn 
  [:amount [:fn {:error/fn &apos;(fn [{:keys [value]} _] (str &quot;Received value &quot; value &quot;, should be &gt; 0&quot;))
        :decode/string malli.transform/-string-&gt;double}
    &apos;#(&gt; % 0)]]
  [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]</pre></z><z id="t1614879901" t="arundilipan If I try and (malli.core/explain schema [1.0 &quot;D&quot;]) , and humanize it, the error I get back is &quot;Received value 1.0, should be &gt; 0&quot; , rather than &quot;should be one of &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;"><y>#</y><d>2021-03-04</d><h>17:45</h><w>arundilipan</w>If I try and <code>(malli.core/explain schema [1.0 &quot;D&quot;])</code> , and humanize it, the error I get back is <code>&quot;Received value 1.0, should be &gt; 0&quot;</code> , rather than <code>&quot;should be one of &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;</code></z><z id="t1614880067" t="borkdude Isn&apos;t the idea of :catn that you provide names for the schema elements?"><y>#</y><d>2021-03-04</d><h>17:47</h><w>borkdude</w>Isn&apos;t the idea of <code>:catn</code> that you provide names for the schema elements?</z><z id="t1614880076" t="borkdude Else you should just use :cat"><y>#</y><d>2021-03-04</d><h>17:47</h><w>borkdude</w>Else you should just use <code>:cat</code></z><z id="t1614880605" t="arundilipan Fixed the example, I do intend to use :catn to provide names for the schema elements"><y>#</y><d>2021-03-04</d><h>17:56</h><w>arundilipan</w>Fixed the example, I do intend to use <code>:catn</code> to provide names for the schema elements</z><z id="t1614888031" t="ikitommi [:attrs {:href &quot;/_/_/users/U6BEL7FPC&quot;}] seems to work: (-&gt; [:catn [:amount [:fn {:error/fn &apos;(fn [{:keys [value]} _] (str &quot;Received value &quot; value &quot;, should be &gt; 0&quot;)) :decode/string malli.transform/-string-&gt;double} &apos;#(&gt; % 0)]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]] (m/explain [1.0 &quot;D&quot;]) (malli.error/humanize)) ; =&gt; [nil [&quot;should be either A, B or C&quot;]]"><y>#</y><d>2021-03-04</d><h>20:00</h><w>ikitommi</w><a>@arundilipan</a> seems to work:
<pre>(-&gt; [:catn
     [:amount [:fn {:error/fn &apos;(fn [{:keys [value]} _] (str &quot;Received value &quot; value &quot;, should be &gt; 0&quot;))
                    :decode/string malli.transform/-string-&gt;double}
               &apos;#(&gt; % 0)]]
     [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]
    (m/explain [1.0 &quot;D&quot;])
    (malli.error/humanize))
; =&gt; [nil [&quot;should be either A, B or C&quot;]]</pre></z><z id="t1614888719" t="borkdude should :catn not give back error messages by name?"><y>#</y><d>2021-03-04</d><h>20:11</h><w>borkdude</w>should <code>:catn</code> not give back error messages by name?</z><z id="t1614889127" t="ikitommi error messages by name?"><y>#</y><d>2021-03-04</d><h>20:18</h><w>ikitommi</w>error messages by name?</z><z id="t1614889150" t="borkdude {:amount nil :type [&quot;should be ...&quot;]}"><y>#</y><d>2021-03-04</d><h>20:19</h><w>borkdude</w><code>{:amount nil :type [&quot;should be ...&quot;]}</code></z><z id="t1614889174" t="arundilipan That’s for :map i think"><y>#</y><d>2021-03-04</d><h>20:19</h><w>arundilipan</w>That’s for :map i think</z><z id="t1614889194" t="borkdude are the positions in :cat always unambiguous? I know for spec they are certainly not with s/cat"><y>#</y><d>2021-03-04</d><h>20:19</h><w>borkdude</w>are the positions in <code>:cat</code> always unambiguous? I know for spec they are certainly not with <code>s/cat</code></z><z id="t1614889197" t="ikitommi hmm. not sure. the current humanize just mimics the raw result, not parsed one."><y>#</y><d>2021-03-04</d><h>20:19</h><w>ikitommi</w>hmm. not sure. the current <code>humanize</code> just mimics the raw result, not parsed one.</z><z id="t1614889212" t="ikitommi but the info is there:"><y>#</y><d>2021-03-04</d><h>20:20</h><w>ikitommi</w>but the info is there:</z><z id="t1614889217" t="ikitommi (-&gt; [:catn [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]] (m/explain [1.0 &quot;D&quot;])) ;{:schema [:catn [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]], ; :value [1.0 &quot;D&quot;], ; :errors (#Error{:path [:type 0], :in [1], :schema [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;], :value &quot;D&quot;})}"><y>#</y><d>2021-03-04</d><h>20:20</h><w>ikitommi</w><pre>(-&gt; [:catn
     [:amount [:double {:min 0}]]
     [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]
    (m/explain [1.0 &quot;D&quot;]))
;{:schema [:catn [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]],
; :value [1.0 &quot;D&quot;],
; :errors (#Error{:path [:type 0], :in [1], :schema [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;], :value &quot;D&quot;})}</pre></z><z id="t1614889272" t="ikitommi e.g. it’s a sequence, errors are positioned by :in ."><y>#</y><d>2021-03-04</d><h>20:21</h><w>ikitommi</w>e.g. it’s a sequence, errors are positioned by <code>:in</code>.</z><z id="t1614889283" t="borkdude maybe for tools like expound it would be nice to have the humanized error along with the path?"><y>#</y><d>2021-03-04</d><h>20:21</h><w>borkdude</w>maybe for tools like expound it would be nice to have the humanized error along with the path?</z><z id="t1614889294" t="borkdude ah I see"><y>#</y><d>2021-03-04</d><h>20:21</h><w>borkdude</w>ah I see</z><z id="t1614889306" t="borkdude so using the explain output you can get to the error message by path"><y>#</y><d>2021-03-04</d><h>20:21</h><w>borkdude</w>so using the explain output you can get to the error message by path</z><z id="t1614889316" t="borkdude using get-in or so"><y>#</y><d>2021-03-04</d><h>20:21</h><w>borkdude</w>using <code>get-in</code> or so</z><z id="t1614889417" t="ikitommi for map, the explain info is: (-&gt; [:map [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]] (m/explain {:amount 1.0 :type &quot;D&quot;})) ;{:schema [:map [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]], ; :value {:amount 1.0, :type &quot;D&quot;}, ; :errors (#Error{:path [:type 0], :in [:type], :schema [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;], :value &quot;D&quot;})}"><y>#</y><d>2021-03-04</d><h>20:23</h><w>ikitommi</w>for map, the explain info is:
<pre>(-&gt; [:map
     [:amount [:double {:min 0}]]
     [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]
    (m/explain {:amount 1.0
                :type &quot;D&quot;}))
;{:schema [:map [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]],
; :value {:amount 1.0, :type &quot;D&quot;},
; :errors (#Error{:path [:type 0], :in [:type], :schema [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;], :value &quot;D&quot;})}</pre></z><z id="t1614889472" t="ikitommi but yes, the branch name is available in the error data for :catn , to be printed nicely etc."><y>#</y><d>2021-03-04</d><h>20:24</h><w>ikitommi</w>but yes, the branch name is available in the error data for <code>:catn</code>, to be printed nicely etc.</z><z id="t1614889562" t="ikitommi [:attrs {:href &quot;/_/_/users/U6BEL7FPC&quot;}] merged a humanized error for :double , so this works now too: (-&gt; [:catn [:amount [:double {:min 0}]] [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]] (m/explain [1.0 &quot;D&quot;]) (malli.error/humanize)) ; =&gt; =&gt; [nil [&quot;should be either A, B or C&quot;]] "><y>#</y><d>2021-03-04</d><h>20:26</h><w>ikitommi</w><a>@arundilipan</a> merged a humanized error for <code>:double</code>, so this works now too:
<pre>(-&gt; [:catn
     [:amount [:double {:min 0}]]
     [:type [:enum &quot;A&quot; &quot;B&quot; &quot;C&quot;]]]
    (m/explain [1.0 &quot;D&quot;])
    (malli.error/humanize))
; =&gt; =&gt; [nil [&quot;should be either A, B or C&quot;]] </pre></z><z id="t1614892242" t="borkdude user=&gt; (require &apos;[malli.error :as e]) nil user=&gt; (require &apos;[malli.core :as m]) nil user=&gt; (e/humanize (m/explain [:cat int? int? [:? int?] [:? string?]] [1 2 :foo])) [nil nil [&quot;should be an int&quot; &quot;should be a string&quot; &quot;unknown error&quot;]] Looks legit, except maybe for the &quot;unknown error&quot;?"><y>#</y><d>2021-03-04</d><h>21:10</h><w>borkdude</w><pre>user=&gt; (require &apos;[malli.error :as e])
nil
user=&gt; (require &apos;[malli.core :as m])
nil
user=&gt; (e/humanize (m/explain [:cat int? int? [:? int?] [:? string?]] [1 2 :foo]))
[nil nil [&quot;should be an int&quot; &quot;should be a string&quot; &quot;unknown error&quot;]]</pre>
Looks legit, except maybe for the &quot;unknown error&quot;?</z><z id="t1614892427" t="borkdude That&apos;s probably better expressed as: (m/explain [:cat int? int? [:orn [:x int?] [:y string?]]] [1 2 :foo]) Just wanted to see what malli would make of it"><y>#</y><d>2021-03-04</d><h>21:13</h><w>borkdude</w>That&apos;s probably better expressed as:
<pre>(m/explain [:cat int? int? [:orn [:x int?] [:y string?]]] [1 2 :foo])</pre>
Just wanted to see what malli would make of it</z><z id="t1614895473" t="ikitommi good catch  [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] , the regex error types didn’t have humanized forms. fixed in master: (-&gt; [:cat int? int?] (m/explain [1]) (me/humanize)) ; =&gt; [nil [&quot;end of input&quot;]] (-&gt; [:cat int? int?] (m/explain [1 2 3]) (me/humanize)) ; =&gt; [nil nil [&quot;input remaining&quot;]] (-&gt; [:cat int? int? [:? int?] [:? string?]] (m/explain [1 2 :foo]) (me/humanize)) ; =&gt; [nil nil [&quot;should be an int&quot; &quot;should be a string&quot; &quot;input remaining&quot;]]"><y>#</y><d>2021-03-04</d><h>22:04</h><w>ikitommi</w>good catch <a>@borkdude</a>, the regex error types didn’t have humanized forms. fixed in master:
<pre>(-&gt; [:cat int? int?]
    (m/explain [1])
    (me/humanize))
; =&gt; [nil [&quot;end of input&quot;]]

(-&gt; [:cat int? int?]
    (m/explain [1 2 3])
    (me/humanize))
; =&gt; [nil nil [&quot;input remaining&quot;]]

(-&gt; [:cat int? int? [:? int?] [:? string?]]
    (m/explain [1 2 :foo])
    (me/humanize))
; =&gt; [nil nil [&quot;should be an int&quot; &quot;should be a string&quot; &quot;input remaining&quot;]]</pre></z><z id="t1614895557" t="borkdude nice!"><y>#</y><d>2021-03-04</d><h>22:05</h><w>borkdude</w>nice!</z><z id="t1614895697" t="ikitommi with :or : (-&gt; [:cat int? int? [:or int? string?]] (m/explain [1 2 :foo]) (me/humanize)) ; =&gt; [nil nil [&quot;should be an int&quot; &quot;should be a string&quot;]]"><y>#</y><d>2021-03-04</d><h>22:08</h><w>ikitommi</w>with <code>:or</code>:
<pre>(-&gt; [:cat int? int? [:or int? string?]]
    (m/explain [1 2 :foo])
    (me/humanize))
; =&gt; [nil nil [&quot;should be an int&quot; &quot;should be a string&quot;]]</pre></z><z id="t1614896040" t="borkdude yeah, that already worked right?"><y>#</y><d>2021-03-04</d><h>22:14</h><w>borkdude</w>yeah, that already worked right?</z><z id="t1614920251" t="beders quick question with regards to properties. I’m trying to put some properties into my schemas, but can’t seem to be getting them back. What am I doing wrong here? ; malli 0.3.0: ; [malli.registry :as registry] (def registry (registry/composite-registry malli/default-registry {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]})) (malli/properties :common/single-line {:registry registry}) =&gt; nil Expected: {:bubu :lala} "><y>#</y><d>2021-03-05</d><h>04:57</h><w>beders</w>quick question with regards to properties.
I’m trying to put some properties into my schemas, but can’t seem to be getting them back.
What am I doing wrong here?

<pre>; malli 0.3.0:
; [malli.registry :as registry]
(def registry
  (registry/composite-registry
    malli/default-registry
    {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]}))

(malli/properties :common/single-line {:registry registry})
=&gt; nil
Expected: {:bubu :lala}</pre>
</z><z id="t1614929697" t="ikitommi [:attrs {:href &quot;/_/_/users/U628K7XGQ&quot;}] oh, that’s not good. registry interally wraps the registered schema instances into :malli.core/schema , which is an eager reference type. When you pull out an instance schema from a registry, you get the reference back. it mostly a pass-through, e.g. calling -validator to the reference return the validator of the referenced schema. But: for some reason, the current impl returns the reference properties and options if asked. I think it’s a bad feature, should be changed."><y>#</y><d>2021-03-05</d><h>07:34</h><w>ikitommi</w><a>@beders</a> oh, that’s not good. registry interally wraps the registered schema instances into <code>:malli.core/schema</code> , which is an eager reference type. When you pull out an instance schema from a registry, you get the reference back. it mostly a pass-through, e.g. calling <code>-validator</code>to the reference return the validator of the referenced schema. But: for some reason, the current impl returns the reference properties and options if asked. I think it’s a bad feature, should be changed.</z><z id="t1614929818" t="ikitommi need to think how that effects other things. before that, you m/deref safely:"><y>#</y><d>2021-03-05</d><h>07:36</h><w>ikitommi</w>need to think how that effects other things. before that, you <code>m/deref</code> safely:</z><z id="t1614929825" t="ikitommi (def registry (mr/composite-registry m/default-registry {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]})) (-&gt; (m/schema :common/single-line {:registry registry}) (doto prn) (m/deref) (doto prn) (m/properties)) ;:common/single-line ;[:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;] ;=&gt; {:bubu :lala}"><y>#</y><d>2021-03-05</d><h>07:37</h><w>ikitommi</w><pre>(def registry
  (mr/composite-registry
    m/default-registry
    {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]}))

(-&gt; (m/schema :common/single-line {:registry registry})
    (doto prn)
    (m/deref)
    (doto prn)
    (m/properties))
;:common/single-line
;[:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]
;=&gt; {:bubu :lala}</pre></z><z id="t1614929939" t="ikitommi workaround for now: (def registry (mr/composite-registry m/default-registry {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]})) (defn schema [?schema] (m/deref (m/schema ?schema {:registry registry}))) (schema :common/single-line) ; =&gt; [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]"><y>#</y><d>2021-03-05</d><h>07:38</h><w>ikitommi</w>workaround for now:
<pre>(def registry
  (mr/composite-registry
    m/default-registry
    {:common/single-line [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]}))

(defn schema [?schema]
  (m/deref (m/schema ?schema {:registry registry})))

(schema :common/single-line)
; =&gt; [:re {:bubu :lala} #&quot;^[^\r\n]*$&quot;]</pre></z><z id="t1615312182" t="beders Thanks for the help and explanation. It would be good to have some documentation around explaining instances vs. Schema. I’m still confused 🙂"><y>#</y><d>2021-03-09</d><h>17:49</h><r>beders</r>Thanks for the help and explanation. It would be good to have some documentation around explaining instances vs. Schema. I’m still confused <b>🙂</b></z><z id="t1614930091" t="ikitommi comments welcome on how it should work."><y>#</y><d>2021-03-05</d><h>07:41</h><w>ikitommi</w>comments welcome on how it should work.</z><z id="t1614932709" t="ordnungswidrig Is there a standard body of localized error messages for humanize ?"><y>#</y><d>2021-03-05</d><h>08:25</h><w>ordnungswidrig</w>Is there a standard body of localized error messages for <code>humanize</code>?</z><z id="t1614932888" t="dharrigan Only english https://github.com/metosin/malli/blob/master/src/malli/error.cljc"><y>#</y><d>2021-03-05</d><h>08:28</h><w>dharrigan</w>Only english <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc</a></z><z id="t1614932903" t="dharrigan However, the docs do show how to add in other i18n messages"><y>#</y><d>2021-03-05</d><h>08:28</h><w>dharrigan</w>However, the docs do show how to add in other i18n messages</z><z id="t1614932974" t="dharrigan https://github.com/metosin/malli#custom-error-messages"><y>#</y><d>2021-03-05</d><h>08:29</h><w>dharrigan</w><a href="https://github.com/metosin/malli#custom-error-messages" target="_blank">https://github.com/metosin/malli#custom-error-messages</a></z><z id="t1614945061" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What about making a plugin for malli which inspects clojure.spec specs and emits a malli schema from it? ;) Might help people migrating to malli"><y>#</y><d>2021-03-05</d><h>11:51</h><w>borkdude</w><a>@ikitommi</a> What about making a plugin for malli which inspects clojure.spec specs and emits a malli schema from it? ;) Might help people migrating to malli</z><z id="t1614948901" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] brilliant idea. Let&apos;s do it."><y>#</y><d>2021-03-05</d><h>12:55</h><w>ikitommi</w><a>@borkdude</a> brilliant idea. Let&apos;s do it.</z></g><g id="s11"><z id="t1614964365" t="dviramontes Hi, trying to wrap my mind around how these two examples can/will differ over time when it comes to value generation (def CDN1 [:map [:images [:vector string?]]]) (def CDN2 [:map [:images [:sequential string?]]]) (malli.generator/generate CDN1) (malli.generator/generate CDN2) -- i guess the question is - will they defer ? and if so how ? in my testing the generated values are very similar"><y>#</y><d>2021-03-05</d><h>17:12</h><w>dviramontes</w>Hi, trying to wrap my mind around how these two examples can/will differ over time when it comes to value generation
<pre>(def CDN1
  [:map
   [:images [:vector string?]]])

(def CDN2
  [:map
   [:images [:sequential string?]]])

(malli.generator/generate CDN1)
(malli.generator/generate CDN2)</pre>
-- i guess the question is - will they defer ? and if so how ? in my testing the generated values are very similar</z><z id="t1614964536" t="borkdude [:attrs {:href &quot;/_/_/users/U0791FRBN&quot;}] in clojure sequential can also be a list or lazy-seq for example, not always a vector, but that should not affect equality semantics"><y>#</y><d>2021-03-05</d><h>17:15</h><w>borkdude</w><a>@dviramontes</a> in clojure sequential can also be a <code>list</code> or <code>lazy-seq</code> for example, not always a vector, but that should not affect equality semantics</z><z id="t1614964668" t="borkdude it seems the generator doesn&apos;t really generate anything other than vectors at the moment (by experimentation) but it could"><y>#</y><d>2021-03-05</d><h>17:17</h><w>borkdude</w>it seems the generator doesn&apos;t really generate anything other than vectors at the moment (by experimentation) but it could</z><z id="t1614964720" t="dviramontes gotcha, thanks very much!"><y>#</y><d>2021-03-05</d><h>17:18</h><w>dviramontes</w>gotcha, thanks very much!</z><z id="t1614964745" t="borkdude TIL, malli also supports keywords as predicates: (malli.generator/generate [:sequential :int]) I prefer that syntax personally"><y>#</y><d>2021-03-05</d><h>17:19</h><w>borkdude</w>TIL, malli also supports keywords as predicates:
<pre>(malli.generator/generate [:sequential :int])</pre>
I prefer that syntax personally</z><z id="t1614964813" t="borkdude user=&gt; (malli.core/validate :int 1) true"><y>#</y><d>2021-03-05</d><h>17:20</h><w>borkdude</w><pre>user=&gt; (malli.core/validate :int 1)
true</pre></z><z id="t1615061549" t="ikitommi pulling out malli schemas for defn s (Vars): (-var-schema #&apos;+) ;[:function ; [:=&gt; :catn :any] ; [:=&gt; [:catn [x :any]] :any] ; [:=&gt; [:catn [x :any] [y :any]] :any] ; [:=&gt; [:catn [x :any] [y :any] [more [:+ :any]]] :any]] (-var-schema #&apos;println) ; [:=&gt; [:catn [more [:* :any]]] :any]"><y>#</y><d>2021-03-06</d><h>20:12</h><w>ikitommi</w>pulling out malli schemas for <code>defn</code>s (Vars):
<pre>(-var-schema #&apos;+)
;[:function
; [:=&gt; :catn :any]
; [:=&gt; [:catn [x :any]] :any]
; [:=&gt; [:catn [x :any] [y :any]] :any]
; [:=&gt; [:catn [x :any] [y :any] [more [:+ :any]]] :any]]

(-var-schema #&apos;println)
; [:=&gt; [:catn [more [:* :any]]] :any]</pre></z><z id="t1615061856" t="borkdude Is this valid syntax? [:=&gt; :catn :any]"><y>#</y><d>2021-03-06</d><h>20:17</h><w>borkdude</w>Is this valid syntax?
<pre>[:=&gt; :catn :any]</pre></z><z id="t1615061972" t="ikitommi yes, vectors are optional if there are no childs or props, e.g. [:int] can be written as :int ."><y>#</y><d>2021-03-06</d><h>20:19</h><w>ikitommi</w>yes, vectors are optional if there are no childs or props, e.g. <code>[:int]</code> can be written as <code>:int</code>.</z><z id="t1615062001" t="ikitommi same for :catn . “empty sequence with named children”"><y>#</y><d>2021-03-06</d><h>20:20</h><w>ikitommi</w>same for <code>:catn</code>. “empty sequence with named children”</z><z id="t1615062018" t="ikitommi the imp btw: (defn -var-schema [var] (let [-=&gt; (fn [as] (let [[f s [t]] (partition-by #{&apos;&amp;} as) [fas ras rop] (cond t [f t :+], s [nil (first s) :*], :else [f])] [:=&gt; (if (or (seq fas) ras) (vec (concat [:catn] (mapv (fn [a] [a :any]) fas) (when ras [[ras [rop :any]]]))) :catn) :any])) {:keys [arglists]} (meta var) -=&gt;s (mapv -=&gt; arglists)] (if (second arglists) (into [:function] -=&gt;s) (first -=&gt;s))))"><y>#</y><d>2021-03-06</d><h>20:20</h><w>ikitommi</w>the imp btw:
<pre>(defn -var-schema [var]
  (let [-=&gt; (fn [as] (let [[f s [t]] (partition-by #{&apos;&amp;} as)
                           [fas ras rop] (cond t [f t :+], s [nil (first s) :*], :else [f])]
                       [:=&gt; (if (or (seq fas) ras)
                              (vec (concat [:catn] (mapv (fn [a] [a :any]) fas) (when ras [[ras [rop :any]]])))
                              :catn) :any]))
        {:keys [arglists]} (meta var)
        -=&gt;s (mapv -=&gt; arglists)]
    (if (second arglists) (into [:function] -=&gt;s) (first -=&gt;s))))</pre></z><z id="t1615062096" t="ikitommi not sure if it’s a good idea to use :arglists var meta, but, works on my repl just now at least 🙂"><y>#</y><d>2021-03-06</d><h>20:21</h><w>ikitommi</w>not sure if it’s a good idea to use <code>:arglists</code>var meta, but, works on my repl just now at least <b>🙂</b></z><z id="t1615062523" t="borkdude not a bad idea"><y>#</y><d>2021-03-06</d><h>20:28</h><w>borkdude</w>not a bad idea</z><z id="t1615062554" t="borkdude some Clojure vars use something like x* which denotes multiple xs, so the arglist is not always reliable, but in most cases it&apos;s auto-generated from the defn itself"><y>#</y><d>2021-03-06</d><h>20:29</h><w>borkdude</w>some Clojure vars use something like <code>x*</code> which denotes multiple xs, so the arglist is not always reliable, but in most cases it&apos;s auto-generated from the defn itself</z><z id="t1615118551" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] what is the difference between :title and :description in spec? I want to describe my config file using malli and guessing what should I use to describe every field in the config map."><y>#</y><d>2021-03-07</d><h>12:02</h><w>mike_ananev</w><a>@ikitommi</a> what is the difference between <code>:title</code> and <code>:description</code>  in spec? I want to describe my config file using malli and guessing what should I use to describe every field in the config map.</z><z id="t1615118947" t="mike_ananev (def http-server-host [:and {:title &quot;http server host&quot;} ne-string]) ;; or (def http-server-host [:and {:description &quot;http server host&quot;} ne-string])"><y>#</y><d>2021-03-07</d><h>12:09</h><w>mike_ananev</w><pre>(def http-server-host [:and {:title &quot;http server host&quot;} ne-string])
;; or
(def http-server-host [:and {:description &quot;http server host&quot;} ne-string])</pre></z><z id="t1615119893" t="ikitommi [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] those are pulled from JSON Schema convention: &gt; The `title` and `description` keywords must be strings. A “title” will preferably be short, whereas a “description” will provide a more lengthy explanation about the purpose of the data described by the schema. I would use :description there. In OpenAPI &amp; Swagger, title is pulled as the Schema name, e.g. [:map {:title &quot;User&quot;, :description &quot;Describes User of the System&quot;} [:name {:description &quot;Name of the User&quot;} :string] [:age {:description &quot;Age, must be &gt;= 18} [:int {:min 18}]]]"><y>#</y><d>2021-03-07</d><h>12:24</h><w>ikitommi</w><a>@mike1452</a> those are pulled from JSON Schema convention:
&gt; The `title` and `description` keywords must be strings. A “title” will preferably be short, whereas a “description” will provide a more lengthy explanation about the purpose of the data described by the schema.
I would use <code>:description</code> there. In OpenAPI &amp; Swagger, <code>title</code> is pulled as the Schema name, e.g.
<pre>[:map {:title &quot;User&quot;, :description &quot;Describes User of the System&quot;} 
 [:name {:description &quot;Name of the User&quot;} :string] 
 [:age {:description &quot;Age, must be &gt;= 18} [:int {:min 18}]]]</pre></z><z id="t1615120117" t="mike_ananev Thank you."><y>#</y><d>2021-03-07</d><h>12:28</h><w>mike_ananev</w>Thank you.</z><z id="t1615121030" t="ikitommi pulling the return types too: (-var-schema #&apos;str) ;[:function ; [:=&gt; :catn :string] ; [:=&gt; [:catn [x :any]] :string] ; [:=&gt; [:catn [x :any] [ys [:+ :any]]] :string]] (-var-schema #&apos;distinct?) ;[:function ; [:=&gt; [:catn [x :any]] :boolean] ; [:=&gt; [:catn [x :any] [y :any]] :boolean] ; [:=&gt; [:catn [x :any] [y :any] [more [:+ :any]]] :boolean]]"><y>#</y><d>2021-03-07</d><h>12:43</h><w>ikitommi</w>pulling the return types too:
<pre>(-var-schema #&apos;str)
;[:function
; [:=&gt; :catn :string]
; [:=&gt; [:catn [x :any]] :string]
; [:=&gt; [:catn [x :any] [ys [:+ :any]]] :string]]

(-var-schema #&apos;distinct?)
;[:function
; [:=&gt; [:catn [x :any]] :boolean]
; [:=&gt; [:catn [x :any] [y :any]] :boolean]
; [:=&gt; [:catn [x :any] [y :any] [more [:+ :any]]] :boolean]]</pre></z><z id="t1615121591" t="borkdude Clever: user=&gt; (meta (second (:arglists (meta #&apos;str)))) {:tag java.lang.String}"><y>#</y><d>2021-03-07</d><h>12:53</h><w>borkdude</w>Clever:
<pre>user=&gt; (meta (second (:arglists (meta #&apos;str))))
{:tag java.lang.String}</pre></z><z id="t1615122085" t="ikitommi Noticed too that the hand-written arglists seem to have weird syntax."><y>#</y><d>2021-03-07</d><h>13:01</h><w>ikitommi</w>Noticed too that the hand-written arglists seem to have weird syntax.</z><z id="t1615133168" t="joshkh loving malli so far! what&apos;s the idiomatic way of &quot;extending&quot; a schema? for example let&apos;s say i have a Person map with the basic attributes first-name and last-name, and then a ProfessionalPerson that is a Person with an additional required profession attribute. would i create a ProfessionalPerson definition that contains only just [:map [:profession string]] and then mu/merge it on top of the Person map [:map [:first-name string?][:last-name-string?]] ?"><y>#</y><d>2021-03-07</d><h>16:06</h><w>joshkh</w>loving malli so far! what&apos;s the idiomatic way of &quot;extending&quot; a schema? for example let&apos;s say i have a Person map with the basic attributes first-name and last-name, and then a ProfessionalPerson that is a Person with an additional required profession attribute. would i create a ProfessionalPerson definition that contains only just <code>[:map [:profession string]]</code> and then <code>mu/merge</code> it on top of the Person map <code>[:map [:first-name string?][:last-name-string?]]</code>?</z><z id="t1615133578" t="borkdude [:attrs {:href &quot;/_/_/users/U0GC1C09L&quot;}] Or mu/assoc"><y>#</y><d>2021-03-07</d><h>16:12</h><w>borkdude</w><a>@joshkh</a> Or <code>mu/assoc</code></z><z id="t1615133873" t="joshkh cool, thanks borkdude. on a side note it&apos;s too bad that mu/assoc doesn&apos;t allow for &amp; kvs like clojure.core/assoc 😄"><y>#</y><d>2021-03-07</d><h>16:17</h><w>joshkh</w>cool, thanks borkdude. on a side note it&apos;s too bad that <code>mu/assoc</code> doesn&apos;t allow for <code>&amp; kvs</code> like <code>clojure.core/assoc</code> <b>😄</b></z><z id="t1615133945" t="borkdude ;)"><y>#</y><d>2021-03-07</d><h>16:19</h><w>borkdude</w>;)</z><z id="t1615134130" t="juhoteperi Might be possible to implement. The options parameter makes it a bit inconvenient though, we could check that if odd number of params, last param is the options, and for even number of params, no options, just kv pairs. Not sure if worth the complexity."><y>#</y><d>2021-03-07</d><h>16:22</h><w>juhoteperi</w>Might be possible to implement. The options parameter makes it a bit inconvenient though, we could check that if odd number of params, last param is the options, and for even number of params, no options, just kv pairs. Not sure if worth the complexity.</z><z id="t1615134205" t="juhoteperi malli.util/dissoc also takes just one key."><y>#</y><d>2021-03-07</d><h>16:23</h><w>juhoteperi</w><code>malli.util/dissoc</code> also takes just one key.</z><z id="t1615134235" t="borkdude if you need more than one k/v, you can just use mu/merge :)"><y>#</y><d>2021-03-07</d><h>16:23</h><w>borkdude</w>if you need more than one k/v, you can just use <code>mu/merge</code> :)</z><z id="t1615134266" t="borkdude or repeat mu/assoc"><y>#</y><d>2021-03-07</d><h>16:24</h><w>borkdude</w>or repeat mu/assoc</z><z id="t1615134290" t="joshkh yeah, merge is fine by me. i just thought it was funny that my first instinct was to treat it like the assoc i know."><y>#</y><d>2021-03-07</d><h>16:24</h><w>joshkh</w>yeah, merge is fine by me. i just thought it was funny that my first instinct was to treat it like the assoc i know.</z><z id="t1615134402" t="juhoteperi Yeah. Though I think it will be worth to mention the differences to clojure.core functions in the docstrings, now the util fns mention just &quot;like clojure.core/x&quot; but then many of them take a bit different parameters."><y>#</y><d>2021-03-07</d><h>16:26</h><w>juhoteperi</w>Yeah.

Though I think it will be worth to mention the differences to clojure.core functions in the docstrings, now the util fns mention just &quot;like clojure.core/x&quot; but then many of them take a bit different parameters.</z><z id="t1615134715" t="joshkh perhaps. admittedly i just tried it out while completely ignoring the very clear docstring params in my editor. you can lead a horse to water but you can&apos;t make it drink 😉"><y>#</y><d>2021-03-07</d><h>16:31</h><w>joshkh</w>perhaps. admittedly i just tried it out while completely ignoring the very clear docstring params in my editor. you can lead a horse to water but you can&apos;t make it drink <b>😉</b></z><z id="t1615134785" t="borkdude It&apos;s awesome that you can do this with malli btw."><y>#</y><d>2021-03-07</d><h>16:33</h><w>borkdude</w>It&apos;s awesome that you can do this with malli btw.</z><z id="t1615135078" t="joshkh absolutely. and the deep merging is really handy, too"><y>#</y><d>2021-03-07</d><h>16:37</h><w>joshkh</w>absolutely. and the deep merging is really handy, too</z><z id="t1615138494" t="ikitommi there are at least two options to resolve the malli.util varargs issue: 1. make all utilities only work with Schema instances, e.g. no auto-coercion from schema AST =&gt; only place to pass the options would be the m/schema -&gt; simpler, more boilerplate, 2. make a custom type/record/protocol for the options, could be the first argument in all functions, “the schema context” - easy to distinguish it from other args "><y>#</y><d>2021-03-07</d><h>17:34</h><w>ikitommi</w>there are at least two options to resolve the <code>malli.util</code> varargs issue:
1. make all utilities only work with <code>Schema</code> instances, e.g. no auto-coercion from schema AST =&gt; only place to pass the options would be the <code>m/schema</code> -&gt; simpler, more boilerplate, 
2. make a custom type/record/protocol for the options, could be the first argument in all functions, “the schema context” - easy to distinguish it from other args </z><z id="t1615146429" t="schmee do I need to have sci for a spec like this? [:map {:gen/fmap &apos;map-&gt;Point} [:lat [:double {:min -180.0 :max 180}]] [:long [:double {:min -180.0 :max 180}]]]]"><y>#</y><d>2021-03-07</d><h>19:47</h><w>schmee</w>do I need to have sci for a spec like this?
<pre>[:map {:gen/fmap &apos;map-&gt;Point}
       [:lat [:double {:min -180.0 :max 180}]] 
       [:long [:double {:min -180.0 :max 180}]]]]</pre></z><z id="t1615146797" t="schmee seems like it according to the tests: https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L94-L105"><y>#</y><d>2021-03-07</d><h>19:53</h><w>schmee</w>seems like it according to the tests: <a href="https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L94-L105" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L94-L105</a></z><z id="t1615146825" t="schmee can you configure malli to use the clojure compiler for eval instead of sci?"><y>#</y><d>2021-03-07</d><h>19:53</h><w>schmee</w>can you configure malli to use the clojure compiler for eval instead of sci?</z><z id="t1615147592" t="schmee I can’t get this to work with or without sci, can you not use namespace-qualified functions as arguments to :gen/fmap ? :thinking_face:"><y>#</y><d>2021-03-07</d><h>20:06</h><w>schmee</w>I can’t get this to work with or without sci, can you not use namespace-qualified functions as arguments to <code>:gen/fmap</code>? <b>:thinking_face:</b></z><z id="t1615147620" t="ikitommi yes, just don&apos;t quote and it works"><y>#</y><d>2021-03-07</d><h>20:07</h><w>ikitommi</w>yes, just don&apos;t quote and it works</z><z id="t1615147651" t="ikitommi (but, can&apos;t be deserialized if it&apos;s a fn value)"><y>#</y><d>2021-03-07</d><h>20:07</h><w>ikitommi</w>(but, can&apos;t be deserialized if it&apos;s a fn value)</z><z id="t1615147722" t="ikitommi If you wan&apos;t eval, PR welcome. Could be option :malli.core/evaluator a, there could be a -eval-evaualuator in malli.core"><y>#</y><d>2021-03-07</d><h>20:08</h><w>ikitommi</w>If you wan&apos;t eval, PR welcome. Could be option <code>:malli.core/evaluator</code> a, there could be a <code>-eval-evaualuator</code> in malli.core</z><z id="t1615147742" t="ikitommi relevant code: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1739-L1741"><y>#</y><d>2021-03-07</d><h>20:09</h><r>ikitommi</r>relevant code: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1739-L1741" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1739-L1741</a></z><z id="t1615147977" t="schmee ahh, I was fooled by the output of my REPL, it printed the record as a plain map (and skipped the record type)!"><y>#</y><d>2021-03-07</d><h>20:12</h><w>schmee</w>ahh, I was fooled by the output of my REPL, it printed the record as a plain map (and skipped the record type)!</z><z id="t1615147983" t="schmee then all is well, thanks for the help 🙂"><y>#</y><d>2021-03-07</d><h>20:13</h><w>schmee</w>then all is well, thanks for the help <b>🙂</b></z><z id="t1615197836" t="borkdude user=&gt; (time (m/validate [:cat [:+ [:+ [:enum 0]]] [:enum 1]] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]) ) &quot;Elapsed time: 0.582137 msecs&quot; true user=&gt; (time (s/valid? (s/cat :zeroes (s/+ (s/+ #{0})) :one #{1}) [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1])) &quot;Elapsed time: 1265.3679 msecs&quot; (got the example from https://quanttype.net/posts/2021-03-06-clojure-spec-and-untrusted-input.html )"><y>#</y><d>2021-03-08</d><h>10:03</h><w>borkdude</w><pre>user=&gt; (time (m/validate [:cat [:+ [:+ [:enum 0]]] [:enum 1]] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]) )
&quot;Elapsed time: 0.582137 msecs&quot;
true
user=&gt; (time (s/valid? (s/cat :zeroes (s/+ (s/+ #{0})) :one #{1}) [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]))
&quot;Elapsed time: 1265.3679 msecs&quot;</pre>
(got the example from <a href="https://quanttype.net/posts/2021-03-06-clojure-spec-and-untrusted-input.html" target="_blank">https://quanttype.net/posts/2021-03-06-clojure-spec-and-untrusted-input.html</a>)</z><z id="t1615198676" t="borkdude Are there any examples of regexes that are slow in malli too?"><y>#</y><d>2021-03-08</d><h>10:17</h><w>borkdude</w>Are there any examples of regexes that are slow in malli too?</z><z id="t1615199061" t="miikka Malli&apos;s regular expression matching algorithm is fundamentally different, so as far as i know, it does not have the exponential slow down problem. Probably you could still come up with some slow examples, but I don&apos;t have insight into what is slow and what is fast."><y>#</y><d>2021-03-08</d><h>10:24</h><w>miikka</w>Malli&apos;s regular expression matching algorithm is fundamentally different, so as far as i know, it does not have the exponential slow down problem. Probably you could still come up with some slow examples, but I don&apos;t have insight into what is slow and what is fast.</z><z id="t1615199561" t="borkdude Because it doesn&apos;t have backtracking, right?"><y>#</y><d>2021-03-08</d><h>10:32</h><w>borkdude</w>Because it doesn&apos;t have backtracking, right?</z><z id="t1615209161" t="miikka It does use backtracking, but see the ns docstring for discussion: https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc"><y>#</y><d>2021-03-08</d><h>13:12</h><w>miikka</w>It does use backtracking, but see the ns docstring for discussion: <a href="https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc</a></z><z id="t1615214902" t="borkdude"><y>#</y><d>2021-03-08</d><h>14:48</h><w>borkdude</w></z><z id="t1615216989" t="arundilipan Sorry for the late response [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I had an health emergency this week and so I wasn’t able to do anything about it"><y>#</y><d>2021-03-08</d><h>15:23</h><w>arundilipan</w>Sorry for the late response <a>@borkdude</a> <a>@ikitommi</a>, I had an health emergency this week and so I wasn’t able to do anything about it</z><z id="t1615216998" t="arundilipan I did follow up with the example and it did work"><y>#</y><d>2021-03-08</d><h>15:23</h><w>arundilipan</w>I did follow up with the example and it did work</z><z id="t1615217032" t="arundilipan I have a follow-up question, though"><y>#</y><d>2021-03-08</d><h>15:23</h><w>arundilipan</w>I have a follow-up question, though</z><z id="t1615217716" t="arundilipan I’m wondering if m/decode with the above schema is supposed to produce that result, and if so, I was wondering how to solve this so that I return [1.0 &quot;A&quot;] from decode?"><y>#</y><d>2021-03-08</d><h>15:35</h><w>arundilipan</w>I’m wondering if <code>m/decode</code> with the above schema is supposed to produce that result, and if so, I was wondering how to solve this so that I return <code>[1.0 &quot;A&quot;]</code> from decode?</z><z id="t1615225328" t="ikitommi [:attrs {:href &quot;/_/_/users/U6BEL7FPC&quot;}] works on my machine: (ns sample.core (:require [malli.core :as m] [malli.transform :as mt])) (def GreaterThanZero [:fn {:decode/string mt/-string-&gt;double} &apos;#(&gt; % 0)]) (def TestEnum [:enum &quot;A&quot; &quot;B&quot;]) (m/decode [:catn [:amount GreaterThanZero] [:layout TestEnum]] [&quot;1.0&quot; &quot;A&quot;] mt/string-transformer) ; =&gt; [1.0 &quot;A&quot;]"><y>#</y><d>2021-03-08</d><h>17:42</h><w>ikitommi</w><a>@arundilipan</a> works on my machine:
<pre>(ns sample.core
  (:require [malli.core :as m]
            [malli.transform :as mt]))

(def GreaterThanZero
  [:fn {:decode/string mt/-string-&gt;double}
   &apos;#(&gt; % 0)])

(def TestEnum
  [:enum &quot;A&quot; &quot;B&quot;])

(m/decode
  [:catn
   [:amount GreaterThanZero]
   [:layout TestEnum]]
  [&quot;1.0&quot; &quot;A&quot;]
  mt/string-transformer)
; =&gt; [1.0 &quot;A&quot;]</pre></z><z id="t1615225531" t="ikitommi if the result doesn’t match the schema after the transformation, the top-level schema returns the original. this is a feature of the current regex impl, doesn’t support partial transformation: (m/decode [:catn [:amount GreaterThanZero] [:layout TestEnum]] [&quot;1.0&quot; &quot;C&quot;] mt/string-transformer) ; =&gt; [&quot;1.0&quot; &quot;C&quot;]"><y>#</y><d>2021-03-08</d><h>17:45</h><w>ikitommi</w>if the result doesn’t match the schema after the transformation, the top-level schema returns the original. this is a feature of the current regex impl, doesn’t support partial transformation:
<pre>(m/decode
  [:catn
   [:amount GreaterThanZero]
   [:layout TestEnum]]
  [&quot;1.0&quot; &quot;C&quot;]
  mt/string-transformer)
; =&gt; [&quot;1.0&quot; &quot;C&quot;]</pre></z><z id="t1615225583" t="arundilipan Oh that’s it, you’re right"><y>#</y><d>2021-03-08</d><h>17:46</h><w>arundilipan</w>Oh that’s it, you’re right</z><z id="t1615225671" t="arundilipan In that case I guess the thing to do would be do use something like edn/read-string instead of decode ? I’d like to make sure that the number is parsed regardless of the result of the rest of the :catn "><y>#</y><d>2021-03-08</d><h>17:47</h><w>arundilipan</w>In that case I guess the thing to do would be do use something like <code>edn/read-string</code> instead of <code>decode</code>? I’d like to make sure that the number is parsed regardless of the result of the rest of the <code>:catn</code> </z><z id="t1615225737" t="ikitommi or, you could use non-regex schema like :tuple : (m/decode [:tuple GreaterThanZero TestEnum] [&quot;1.0&quot; &quot;C&quot;] mt/string-transformer) ; =&gt; [1.0 &quot;C&quot;]"><y>#</y><d>2021-03-08</d><h>17:48</h><w>ikitommi</w>or, you could use non-regex schema like <code>:tuple</code>:
<pre>(m/decode
  [:tuple GreaterThanZero TestEnum]
  [&quot;1.0&quot; &quot;C&quot;]
  mt/string-transformer)
; =&gt; [1.0 &quot;C&quot;]</pre></z><z id="t1615225750" t="ikitommi no :tuplen atm 😉"><y>#</y><d>2021-03-08</d><h>17:49</h><w>ikitommi</w>no <code>:tuplen</code> atm <b>😉</b></z><z id="t1615225816" t="ikitommi you could write issue about the partial decoding with regex?"><y>#</y><d>2021-03-08</d><h>17:50</h><w>ikitommi</w>you could write issue about the partial decoding with regex?</z><z id="t1615225853" t="ikitommi (might be easy to fix)"><y>#</y><d>2021-03-08</d><h>17:50</h><w>ikitommi</w>(might be easy to fix)</z><z id="t1615225874" t="arundilipan Yea i’ll make an issue on the repo"><y>#</y><d>2021-03-08</d><h>17:51</h><w>arundilipan</w>Yea i’ll make an issue on the repo</z><z id="t1615225891" t="arundilipan Right now I’m trying to use the :catn variants because of the coercion into a map"><y>#</y><d>2021-03-08</d><h>17:51</h><w>arundilipan</w>Right now I’m trying to use the <code>:catn</code> variants because of the coercion into a map</z><z id="t1615226145" t="arundilipan Done!"><y>#</y><d>2021-03-08</d><h>17:55</h><w>arundilipan</w>Done!</z><z id="t1615313214" t="raymcdermott I&apos;m trying to take a simple map like this an make it consumable by reitit-swagger"><y>#</y><d>2021-03-09</d><h>18:06</h><w>raymcdermott</w>I&apos;m trying to take a simple map like this an make it consumable by <code>reitit-swagger</code></z><z id="t1615313229" t="raymcdermott (def Org [:map [:id Id] [:ref string?]])"><y>#</y><d>2021-03-09</d><h>18:07</h><w>raymcdermott</w><pre>(def Org
  [:map
   [:id Id]
   [:ref string?]])</pre></z><z id="t1615313326" t="raymcdermott after swagger/transform I get"><y>#</y><d>2021-03-09</d><h>18:08</h><w>raymcdermott</w>after swagger/transform I get</z><z id="t1615313330" t="raymcdermott {:type &quot;object&quot;, :properties {:id {:type &quot;string&quot;, :pattern #&quot;^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$&quot;}, :ref {:type &quot;string&quot;}}, :required [:id :ref]}"><y>#</y><d>2021-03-09</d><h>18:08</h><w>raymcdermott</w><pre>{:type &quot;object&quot;,
 :properties {:id {:type &quot;string&quot;,
                   :pattern #&quot;^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$&quot;},
              :ref {:type &quot;string&quot;}},
 :required [:id :ref]}</pre></z><z id="t1615313468" t="raymcdermott not sure how / where to plug this in to the reitit.swagger structure"><y>#</y><d>2021-03-09</d><h>18:11</h><w>raymcdermott</w>not sure how / where to plug this in to the <code>reitit.swagger</code> structure</z><z id="t1615313555" t="raymcdermott looking at the example in reitit I see this"><y>#</y><d>2021-03-09</d><h>18:12</h><w>raymcdermott</w>looking at the example in reitit I see this</z><z id="t1615313559" t="raymcdermott [&quot;/plus&quot; {:get {:summary &quot;plus with malli query parameters&quot; :parameters {:query [:map [:x int?] [:y int?]]} :responses {200 {:body [:map [:total int?]]}} :handler (fn [{{{:keys [x y]} :query} :parameters}] {:status 200 :body {:total (+ x y)}})} :post {:summary &quot;plus with malli body parameters&quot; :parameters {:body [:map [:x int?] [:y int?]]} :responses {200 {:body [:map [:total int?]]}} :handler (fn [{{{:keys [x y]} :body} :parameters}] {:status 200 :body {:total (+ x y)}})}}]"><y>#</y><d>2021-03-09</d><h>18:12</h><w>raymcdermott</w><pre>[&quot;/plus&quot;
         {:get {:summary &quot;plus with malli query parameters&quot;
                :parameters {:query [:map [:x int?] [:y int?]]}
                :responses {200 {:body [:map [:total int?]]}}
                :handler (fn [{{{:keys [x y]} :query} :parameters}]
                           {:status 200
                            :body {:total (+ x y)}})}
          :post {:summary &quot;plus with malli body parameters&quot;
                 :parameters {:body [:map [:x int?] [:y int?]]}
                 :responses {200 {:body [:map [:total int?]]}}
                 :handler (fn [{{{:keys [x y]} :body} :parameters}]
                            {:status 200
                             :body {:total (+ x y)}})}}]</pre></z><z id="t1615313665" t="raymcdermott I can see that I should decorate the Org with some swagger but still, I&apos;m being dumb cos I can&apos;t see how to smash everything together"><y>#</y><d>2021-03-09</d><h>18:14</h><w>raymcdermott</w>I can see that I should decorate the <code>Org</code> with some swagger but still, I&apos;m being dumb cos I can&apos;t see how to smash everything together</z><z id="t1615313728" t="raymcdermott any clues if you have done this already would be appreciated"><y>#</y><d>2021-03-09</d><h>18:15</h><w>raymcdermott</w>any clues if you have done this already would be appreciated</z><z id="t1615315680" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] if the swgger-transform output is ok, just use it like {:parameters {:body Org}} and it works. swagger-transformation is done in the reitit.swagger/create-swagger-handler code for all parameters &amp; response schemas automatically, it looks the effective :coercion for a route and asks it to transform the stuff."><y>#</y><d>2021-03-09</d><h>18:48</h><w>ikitommi</w><a>@raymcdermott</a> if the swgger-transform output is ok, just use it like <code>{:parameters {:body Org}}</code> and it works. swagger-transformation is done in the <code>reitit.swagger/create-swagger-handler</code> code for all parameters &amp; response schemas automatically, it looks the effective <code>:coercion</code> for a route and asks it to transform the stuff.</z><z id="t1615315772" t="ikitommi here’s the code: https://github.com/metosin/reitit/blob/master/modules/reitit-swagger/src/reitit/swagger.cljc#L69-L109"><y>#</y><d>2021-03-09</d><h>18:49</h><r>ikitommi</r>here’s the code: <a href="https://github.com/metosin/reitit/blob/master/modules/reitit-swagger/src/reitit/swagger.cljc#L69-L109" target="_blank">https://github.com/metosin/reitit/blob/master/modules/reitit-swagger/src/reitit/swagger.cljc#L69-L109</a></z><z id="t1615315755" t="ikitommi you can add stuff with :swagger namespace or key: (def Org [:map {:title &quot;Org&quot;} [:id {:swagger/description &quot;id&quot;} Id] [:ref {:swagger {:default &quot;kikka&quot;}} string?]])"><y>#</y><d>2021-03-09</d><h>18:49</h><w>ikitommi</w>you can add stuff with <code>:swagger</code> namespace or key:
<pre>(def Org
  [:map {:title &quot;Org&quot;}
   [:id {:swagger/description &quot;id&quot;} Id]
   [:ref {:swagger {:default &quot;kikka&quot;}} string?]])</pre></z><z id="t1615318285" t="raymcdermott ok - great, I&apos;ll give a go. Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2021-03-09</d><h>19:31</h><w>raymcdermott</w>ok - great, I&apos;ll give a go. Thanks <a>@ikitommi</a></z><z id="t1615319471" t="raymcdermott I can report success 🙏 :skin-tone-3:"><y>#</y><d>2021-03-09</d><h>19:51</h><w>raymcdermott</w>I can report success <b>🙏</b><b>:skin-tone-3:</b></z><z id="t1615374670" t="Adam Helins I have written a WebAssembly decompiler/compiler and I would like to &quot;spec&quot; the WASM intermediary representation I am using. After a long while of avoiding clojure.spec, I&apos;ve tried using it for that purpose but it&apos;s just too hard, too limited. So I am trying out Malli. Given how flexible it is, I have high hopes. But I am a Malli noob so here I am. My problem is actually a common one: a data schema were parts of the schema are references (&quot;pointers&quot;) to other parts of the schema. Validation is easy but generation is hard. Spec makes that extra hard by forcing a global registry. Let&apos;s stick to this WASM example to have something concrete to work with. There exists a type section (map of type index to type ) and a function section (map of function index to function where a function holds an existing type index ). Generating a valid representation in pseudo-code would look like: 1. Generate a type section where type index is a nat? 2. Mutate registry so that type index becomes an enum of generated type index 3. Generate a function section , now assured that generated type index exist Solution A. I guess one way would be to do exactly that. Generating things in the right order, step by step, and keep on doing that while successively building a local registry based on what has been previously generated. I am unsure how practical that would be for a more complex example. Solution B. Another way would be to have one schema with a &quot;local mutable registry&quot; and declaring custom generators along the way which would mutate this &quot;local mutable registry&quot; based on what they generate. However I understand that local registries must be concrete maps and do not allow this. On the longer term, I am not sure this would be more pratical than Solution A and it certainly is not very functional. Any better, idiomatic way?"><y>#</y><d>2021-03-10</d><h>11:11</h><w>Adam Helins</w>I have written a WebAssembly decompiler/compiler and I would like to &quot;spec&quot; the WASM intermediary representation I am using. After a long while of avoiding clojure.spec, I&apos;ve tried using it for that purpose but it&apos;s just too hard, too limited. So I am trying out Malli. Given how flexible it is, I have high hopes. But I am a Malli noob so here I am.

My problem is actually a common one: a data schema were parts of the schema are references (&quot;pointers&quot;) to other parts of the schema. Validation is easy but generation is hard. Spec makes that extra hard by forcing a global registry.

Let&apos;s stick to this WASM example to have something concrete to work with. There exists a <code>type section</code> (map of <code>type index</code> to <code>type</code>) and a <code>function section</code> (map of <code>function index</code> to <code>function</code> where a function holds an existing <code>type index</code>). Generating a valid representation in pseudo-code would look like:

1. Generate a <code>type section</code> where <code>type index</code> is a <code>nat?</code>
2. Mutate registry so that <code>type index</code> becomes an <code>enum of generated type index</code> 
3. Generate a <code>function section</code> , now assured that generated <code>type index</code> exist
Solution A. I guess one way would be to do exactly that. Generating things in the right order, step by step, and keep on doing that while successively building a local registry based on what has been previously generated. I am unsure how practical that would be for a more complex example.

Solution B. Another way would be to have one schema with a &quot;local mutable registry&quot; and declaring custom generators along the way which would mutate this &quot;local mutable registry&quot; based on what they generate. However I understand that local registries must be concrete maps and do not allow this. On the longer term, I am not sure this would be more pratical than Solution A and it certainly is not very functional.

Any better, idiomatic way?</z><z id="t1615375640" t="Adam Helins Note regarding Solution B: Unless I am doing it wrong, I cannot manage to use a mutable registry in a local way (ie. using it as an explicit :registry argument throws :malli.core/invalid-schema {:schema :map} )"><y>#</y><d>2021-03-10</d><h>11:27</h><w>Adam Helins</w>Note regarding Solution B: Unless I am doing it wrong, I cannot manage to use a mutable registry in a local way (ie. using it as an explicit <code>:registry</code> argument throws <code>:malli.core/invalid-schema {:schema :map}</code>)</z><z id="t1615384403" t="ikitommi [:attrs {:href &quot;/_/_/users/UCFG3SDFV&quot;}] Sounds really interesting! I can’t recall why the local registries only support maps. Would be most likely a small change it to support the Registry"><y>#</y><d>2021-03-10</d><h>13:53</h><w>ikitommi</w><a>@adam678</a> Sounds really interesting! I can’t recall why the local registries only support maps. Would be most likely a small change it to support the <code>Registry</code></z><z id="t1615384522" t="ikitommi one option woud be to just collect stuff to a mutable registry or an custom atom, use it via (m/schema x {:registry registry}) . when everything is collected and if the schemas are serializable, you could writen them into one local (immutable) registry."><y>#</y><d>2021-03-10</d><h>13:55</h><w>ikitommi</w>one option woud be to just collect stuff to a mutable registry or an custom atom, use it via <code>(m/schema x {:registry registry})</code>. when everything is collected and if the schemas are serializable, you could writen them into one local (immutable) registry.</z><z id="t1615385654" t="nilern There was a similar PR recently https://github.com/metosin/malli/pull/337"><y>#</y><d>2021-03-10</d><h>14:14</h><w>nilern</w>There was a similar PR recently <a href="https://github.com/metosin/malli/pull/337" target="_blank">https://github.com/metosin/malli/pull/337</a></z><z id="t1615386553" t="jjttjj I&apos;m wondering what the &quot;limits&quot; of the malli value transformations should be philosophically. If I&apos;m working with an external api that represents dates as strings, but I want to represent them as Instants in my app, is that a valid use for transformers? What about if the external api provides a nested &quot;address&quot; map that I want to eventually turn into an Address record type? It wouldn&apos;t necessarily be used as a two way transformation very much, I wouldn&apos;t necessarily be sending my addresses back to their api and need to encode them again as strings. Is this just a separate problem, and I should just use a function to get things into my domain records/types?"><y>#</y><d>2021-03-10</d><h>14:29</h><w>jjttjj</w>I&apos;m wondering what the &quot;limits&quot; of the malli value transformations should be philosophically. If I&apos;m working with an external api that represents dates as strings, but I want to represent them as Instants in my app, is that a valid use for transformers? What about if the external api provides a nested &quot;address&quot; map that I want to eventually turn into an Address record type? It wouldn&apos;t necessarily be used as a two way transformation very much, I wouldn&apos;t necessarily be sending my addresses back to their api and need to encode them again as strings.
Is this just a separate problem, and I should just use a function to get things into my domain records/types?</z><z id="t1615386651" t="juhoteperi Coercing stings to proper types at least is fine use. Similar to coercing json or path or query string parameters to booleans, dates etc."><y>#</y><d>2021-03-10</d><h>14:30</h><r>juhoteperi</r>Coercing stings to proper types at least is fine use. Similar to coercing json or path or query string parameters to booleans, dates etc.</z><z id="t1615386679" t="nilern We do those sorts of things all the time, also with Schema and Spec"><y>#</y><d>2021-03-10</d><h>14:31</h><r>nilern</r>We do those sorts of things all the time, also with Schema and Spec</z><z id="t1615386886" t="jjttjj So it&apos;s good to use malli to get from string all the way to our full on domain objects?"><y>#</y><d>2021-03-10</d><h>14:34</h><r>jjttjj</r>So it&apos;s good to use malli to get from string all the way to our full on domain objects?</z><z id="t1615387139" t="ikitommi sure. If it like looks complex, then move the transformation out. I haven&apos;t seen a always valid limit. string-&gt;map map-&gt;record both perfect cases."><y>#</y><d>2021-03-10</d><h>14:38</h><r>ikitommi</r>sure. If it like looks complex, then move the transformation out. I haven&apos;t seen a always valid limit. string-&gt;map map-&gt;record both perfect cases.</z><z id="t1615387190" t="jjttjj by &quot;move the transformation out&quot; you mean separate it into a different transformer?"><y>#</y><d>2021-03-10</d><h>14:39</h><r>jjttjj</r>by &quot;move the transformation out&quot; you mean separate it into a different transformer?</z><z id="t1615387206" t="ikitommi wrote a while back this generic nonsense (on spec): &gt; Domain-specific data-macros are cool, but add some complexity due to the inversion of control. For just this reason, we have pulled out Schema-based domain coercions from some of our client projects. Use them wisely."><y>#</y><d>2021-03-10</d><h>14:40</h><r>ikitommi</r>wrote a while back this generic nonsense (on spec):
&gt; Domain-specific data-macros are cool, but add some complexity due to the inversion of control. For just this reason, we have pulled out Schema-based domain coercions from some of our client projects. Use them wisely.</z><z id="t1615387217" t="ikitommi https://www.metosin.fi/blog/clojure-spec-as-a-runtime-transformation-engine/#data-macros"><y>#</y><d>2021-03-10</d><h>14:40</h><r>ikitommi</r><a href="https://www.metosin.fi/blog/clojure-spec-as-a-runtime-transformation-engine/#data-macros" target="_blank">https://www.metosin.fi/blog/clojure-spec-as-a-runtime-transformation-engine/#data-macros</a></z><z id="t1615387239" t="jjttjj Thanks!"><y>#</y><d>2021-03-10</d><h>14:40</h><r>jjttjj</r>Thanks!</z><z id="t1615387343" t="ikitommi by moving out I meant into a separate function outside of schemas, e.g. (external-&gt;internal data) thing."><y>#</y><d>2021-03-10</d><h>14:42</h><r>ikitommi</r>by moving out I meant into a separate function outside of schemas, e.g. <code>(external-&gt;internal data)</code> thing.</z><z id="t1615387517" t="jjttjj And then do you call that from a transformer still? or do you mean the data goes from json-string-&gt; clojure data -&gt; malli transformers -&gt; external-&gt;internal"><y>#</y><d>2021-03-10</d><h>14:45</h><r>jjttjj</r>And then do you call that from a transformer still? or do you mean the data goes from
<pre>json-string-&gt; clojure data -&gt; malli transformers -&gt; external-&gt;internal</pre></z><z id="t1615390968" t="ikitommi • optimal: json-string + malli -&gt; internal • current good practise: json-string -&gt; EDN -&gt; malli transformers -&gt; internal • if the internal-&gt;external is complex. uses external data etc: json-string -&gt; EDN -&gt; malli transformers -&gt; external-&gt;internal"><y>#</y><d>2021-03-10</d><h>15:42</h><r>ikitommi</r>• optimal: json-string + malli -&gt; internal
• current good practise: json-string -&gt; EDN -&gt; malli transformers -&gt; internal
• if the internal-&gt;external is complex. uses external data etc: json-string -&gt; EDN -&gt; malli transformers -&gt; external-&gt;internal</z><z id="t1615391071" t="ikitommi (did a spike on deriving jackson-decoder from malli schema, but nothing production grade atm, in theory, shoud be much faster)"><y>#</y><d>2021-03-10</d><h>15:44</h><r>ikitommi</r>(did a spike on deriving jackson-decoder from malli schema, but nothing production grade atm, in theory, shoud be much faster)</z><z id="t1615391515" t="jjttjj that makes sense, thanks again!"><y>#</y><d>2021-03-10</d><h>15:51</h><r>jjttjj</r>that makes sense, thanks again!</z><z id="t1615388954" t="Adam Helins [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] All right, thanks, I got a sense of where to start. As a beginner I was mostly troubled by the fact that local registries can be only map-based. Since you are not sure this is intended, I took the liberty of opening an issue: https://github.com/metosin/malli/issues/389"><y>#</y><d>2021-03-10</d><h>15:09</h><w>Adam Helins</w><a>@ikitommi</a> All right, thanks, I got a sense of where to start. As a beginner I was mostly troubled by the fact that local registries can be only map-based. Since you are not sure this is intended, I took the liberty of opening an issue: <a href="https://github.com/metosin/malli/issues/389" target="_blank">https://github.com/metosin/malli/issues/389</a></z><z id="t1615401388" t="Ed Hi. If I have a :dispatch multi-schema, is there an easy way to put a catch-all else clause in the matches?"><y>#</y><d>2021-03-10</d><h>18:36</h><w>Ed</w>Hi. If I have a <code>:dispatch</code> multi-schema, is there an easy way to put a catch-all else clause in the matches?</z><z id="t1615402828" t="ikitommi [:attrs {:href &quot;/_/_/users/U0P0TMEFJ&quot;}] not atm, but could, does [:or [:multi …] :default] work for you?"><y>#</y><d>2021-03-10</d><h>19:00</h><w>ikitommi</w><a>@l0st3d</a> not atm, but could, does <code>[:or [:multi …] :default]</code>work for you?</z><z id="t1615402842" t="ikitommi maybe there could be a :malli/default branch?"><y>#</y><d>2021-03-10</d><h>19:00</h><w>ikitommi</w>maybe there could be a <code>:malli/default</code> branch?</z><z id="t1615404477" t="Ed I think I&apos;ve worked out how to write what I was trying to write in a different way (using :or , but I needed an exclusionary condition instead of :default ), but it might be a useful feature to add ... I quite like the idea of :malli/default . Partly because of the parallel to multimethods. Maybe there&apos;s a clean way of overriding the keyword?"><y>#</y><d>2021-03-10</d><h>19:27</h><w>Ed</w>I think I&apos;ve worked out how to write what I was trying to write in a different way (using <code>:or</code>, but I needed an exclusionary condition instead of <code>:default</code>), but it might be a useful feature to add ... I quite like the idea of <code>:malli/default</code>. Partly because of the parallel to multimethods. Maybe there&apos;s a clean way of overriding the keyword?</z><z id="t1615404746" t="Ed my exclusion clause in the second branch of the or is a bit big, but cos it&apos;s all data it&apos;s ok to write a function to produce the branches 😉"><y>#</y><d>2021-03-10</d><h>19:32</h><w>Ed</w>my exclusion clause in the second branch of the or is a bit big, but cos it&apos;s all data it&apos;s ok to write a function to produce the branches <b>😉</b></z><z id="t1615439680" t="ikitommi [:attrs {:href &quot;/_/_/users/U0P0TMEFJ&quot;}] &amp; everyone else, opinions on :m/default or :malli/default ? [:multi {:dispatch :type} [&quot;object&quot; [:map-of :keyword :string]] [:m/default :string]] vs: [:multi {:dispatch :type} [&quot;object&quot; [:map-of :keyword :string]] [:malli/default :string]] … same could be used for extra-keys in maps, e.g. :m/extra vs :malli/extra . Personally fond of the :m ."><y>#</y><d>2021-03-11</d><h>05:14</h><w>ikitommi</w><a>@l0st3d</a> &amp; everyone else, opinions on <code>:m/default</code> or <code>:malli/default</code>?
<pre>[:multi {:dispatch :type}
 [&quot;object&quot; [:map-of :keyword :string]]
 [:m/default :string]]</pre>
vs:
<pre>[:multi {:dispatch :type}
 [&quot;object&quot; [:map-of :keyword :string]]
 [:malli/default :string]]</pre>
… same could be used for extra-keys in maps, e.g. <code>:m/extra</code> vs <code>:malli/extra</code>. Personally fond of the <code>:m</code>.</z><z id="t1615439690" t="ikitommi https://github.com/metosin/malli/pull/391"><y>#</y><d>2021-03-11</d><h>05:14</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/391" target="_blank">https://github.com/metosin/malli/pull/391</a></z><z id="t1615439718" t="ikitommi (def valid? (m/validator [:multi {:dispatch :type} [&quot;object&quot; [:map-of :keyword :string]] [:m/default :string]])) (valid? {:type &quot;object&quot;, :key &quot;1&quot;, :value &quot;100&quot;}) ; =&gt; true (valid? &quot;SUCCESS!&quot;) ; =&gt; true (valid? :failure) ; =&gt; false"><y>#</y><d>2021-03-11</d><h>05:15</h><r>ikitommi</r><pre>(def valid?
  (m/validator
    [:multi {:dispatch :type}
     [&quot;object&quot; [:map-of :keyword :string]]
     [:m/default :string]]))

(valid? {:type &quot;object&quot;, :key &quot;1&quot;, :value &quot;100&quot;})
; =&gt; true

(valid? &quot;SUCCESS!&quot;)
; =&gt; true

(valid? :failure)
; =&gt; false</pre></z><z id="t1615451875" t="Ed That would definitely solve my problem and make my code easier to read ... it get&apos;s my vote ... many thanks for the impressively fast feedback."><y>#</y><d>2021-03-11</d><h>08:37</h><r>Ed</r>That would definitely solve my problem and make my code easier to read ... it get&apos;s my vote ... many thanks for the impressively fast feedback.</z><z id="t1615452067" t="Ed Although maybe ::m/default might be better"><y>#</y><d>2021-03-11</d><h>08:41</h><r>Ed</r>Although maybe <code>::m/default</code> might be better</z><z id="t1615452093" t="Ed Ah ... I see someone has already commented to that effect on the pr 😉"><y>#</y><d>2021-03-11</d><h>08:41</h><r>Ed</r>Ah ... I see someone has already commented to that effect on the pr <b>😉</b></z><z id="t1615459246" t="Adam Helins Hehe, sometimes I dream about creating a sub-community of &quot;Clojurists against too much abbreviation&quot;"><y>#</y><d>2021-03-11</d><h>10:40</h><r>Adam Helins</r>Hehe, sometimes I dream about creating a sub-community of &quot;Clojurists against too much abbreviation&quot;</z><z id="t1615459739" t="Ed 😉 ... I think it&apos;s not about abbreviation, but scope ... :m/ is a public namespace that may be being used by an application and may well be a target in that multi dispatch, whereas ::m/ is scoped to malli.core and therefore shouldn&apos;t have meaning in your application - so it&apos;s fine to use as a default ... I think where clojure pushes back against brevity it tends to be for reasons of applicability in different contexts - which makes it a more generally useful language"><y>#</y><d>2021-03-11</d><h>10:48</h><r>Ed</r><b>😉</b> ... I think it&apos;s not about abbreviation, but scope ... <code>:m/</code> is a public namespace that may be being used by an application and may well be a target in that multi dispatch, whereas <code>::m/</code> is scoped to <code>malli.core</code> and therefore shouldn&apos;t have meaning in your application - so it&apos;s fine to use as a default ... I think where clojure pushes back against brevity it tends to be for reasons of applicability in different contexts - which makes it a more generally useful language</z><z id="t1615473220" t="armed Hello, how to attach custom error message to seqexp? For example: (malli.error/humanize (malli/explain [:map [:items [:+ {:error/message &quot;Items must not be empty&quot;} [:map [:foo string? :bar int?]]]]] {:items []}))"><y>#</y><d>2021-03-11</d><h>14:33</h><w>armed</w>Hello, how to attach custom error message to seqexp? For example:
<pre>(malli.error/humanize
  (malli/explain
   [:map
    [:items
     [:+
      {:error/message &quot;Items must not be empty&quot;}
      [:map [:foo string?
             :bar int?]]]]]
   {:items []}))</pre></z><z id="t1615484814" t="shan looks like the :error/message is in the wrong place: (me/humanize (m/explain [:map [:items [:+ [:map {:error/message &quot;Items must not be empty&quot;} [:foo string? :bar int?]]]]] {:items []}));; =&gt; {:items [[&quot;Items must not be empty&quot;]]}"><y>#</y><d>2021-03-11</d><h>17:46</h><r>shan</r>looks like the <code>:error/message</code> is in the wrong place:
<pre>(me/humanize
 (m/explain
  [:map
   [:items
    [:+
     [:map {:error/message &quot;Items must not be empty&quot;}
      [:foo string?
       :bar int?]]]]]
  {:items []}));; =&gt; {:items [[&quot;Items must not be empty&quot;]]}</pre></z><z id="t1615488904" t="armed Thanks, thats interesting. My code works if I replace :+ with :vector"><y>#</y><d>2021-03-11</d><h>18:55</h><r>armed</r>Thanks, thats interesting. My code works if I replace <code>:+</code> with <code>:vector</code></z><z id="t1615489075" t="armed And if I put error inside :map, then all other map validation errors replaced with that one, even ‘missing key’ is becomes ‘items must not be empty’. "><y>#</y><d>2021-03-11</d><h>18:57</h><r>armed</r>And if I put error inside :map, then all other map validation errors replaced with that one, even ‘missing key’ is becomes ‘items must not be empty’. </z><z id="t1615473265" t="armed I get {:items [[&quot;unknown error&quot;]]} error"><y>#</y><d>2021-03-11</d><h>14:34</h><w>armed</w>I get <code>{:items [[&quot;unknown error&quot;]]}</code> error</z><z id="t1615485574" t="emccue How would I represent values like this"><y>#</y><d>2021-03-11</d><h>17:59</h><w>emccue</w>How would I represent values like this</z><z id="t1615485598" t="emccue :keyword-a :keyword-b {:map &quot;with&quot; :some &apos;shape}"><y>#</y><d>2021-03-11</d><h>17:59</h><w>emccue</w><pre>:keyword-a
:keyword-b
{:map &quot;with&quot; :some &apos;shape}</pre></z><z id="t1615485612" t="emccue (in the same schema)"><y>#</y><d>2021-03-11</d><h>18:00</h><w>emccue</w>(in the same schema)</z><z id="t1615485773" t="emccue at least with the online tool, alt doesn&apos;t seem to do what I would expect"><y>#</y><d>2021-03-11</d><h>18:02</h><w>emccue</w>at least with the online tool, alt doesn&apos;t seem to do what I would expect</z><z id="t1615485831" t="emccue"><y>#</y><d>2021-03-11</d><h>18:03</h><w>emccue</w></z><z id="t1615487616" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] try https://malli.io/?value=%5B%3Aa%20%3Ab%20%7B%3Aname%20%22kikka%22%7D%5D&amp;amp;schema=%5B%3Avector%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aenum%20%3Aa%20%3Ab%5D%0A%20%20%5B%3Amap%20%5B%3Aname%20%3Astring%5D%5D%5D%5D"><y>#</y><d>2021-03-11</d><h>18:33</h><w>ikitommi</w><a>@emccue</a> try <a href="https://malli.io/?value=%5B%3Aa%20%3Ab%20%7B%3Aname%20%22kikka%22%7D%5D&amp;amp;schema=%5B%3Avector%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aenum%20%3Aa%20%3Ab%5D%0A%20%20%5B%3Amap%20%5B%3Aname%20%3Astring%5D%5D%5D%5D" target="_blank">https://malli.io/?value=%5B%3Aa%20%3Ab%20%7B%3Aname%20%22kikka%22%7D%5D&amp;amp;schema=%5B%3Avector%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aenum%20%3Aa%20%3Ab%5D%0A%20%20%5B%3Amap%20%5B%3Aname%20%3Astring%5D%5D%5D%5D</a></z><z id="t1615487663" t="ikitommi the http://malli.io is not updated for 0.3.0, so no :alt there yet. PR welcome to update deps"><y>#</y><d>2021-03-11</d><h>18:34</h><w>ikitommi</w>the <a href="http://malli.io" target="_blank">http://malli.io</a> is not updated for 0.3.0, so no <code>:alt</code> there yet. PR welcome to update deps</z><z id="t1615487915" t="emccue would alt work in that case?"><y>#</y><d>2021-03-11</d><h>18:38</h><w>emccue</w>would alt work in that case?</z><z id="t1615488212" t="nilern :alt is for sequences only"><y>#</y><d>2021-03-11</d><h>18:43</h><w>nilern</w><code>:alt</code> is for sequences only</z><z id="t1615488459" t="nilern [:alt [:= :a] [:= :b]] matches [:a] and (:b) but not :a"><y>#</y><d>2021-03-11</d><h>18:47</h><w>nilern</w><code>[:alt [:= :a] [:= :b]]</code> matches <code>[:a]</code> and <code>(:b)</code> but not <code>:a</code></z><z id="t1615489711" t="emccue interesting that [:enum :a :b] is different than [:or [:= :a] [:= :b]]"><y>#</y><d>2021-03-11</d><h>19:08</h><w>emccue</w>interesting that <code>[:enum :a :b]</code>  is different than <code>[:or [:= :a] [:= :b]]</code></z><z id="t1615490611" t="ikitommi different, how?"><y>#</y><d>2021-03-11</d><h>19:23</h><r>ikitommi</r>different, how?</z><z id="t1615493196" t="emccue like, they are inferred differently"><y>#</y><d>2021-03-11</d><h>20:06</h><r>emccue</r>like, they are inferred differently</z><z id="t1615509734" t="emccue (looped back to this, i&apos;m probably wrong and got confused by the &quot;inferred schema&quot; part and also my bad memory)"><y>#</y><d>2021-03-12</d><h>00:42</h><r>emccue</r>(looped back to this, i&apos;m probably wrong and got confused by the &quot;inferred schema&quot; part and also my bad memory)</z><z id="t1615490369" t="ikitommi updated http://malli.io , with few sequence samples (args &amp; hiccup)"><y>#</y><d>2021-03-11</d><h>19:19</h><w>ikitommi</w>updated <a href="http://malli.io" target="_blank">http://malli.io</a>, with few sequence samples (args &amp; hiccup)</z><z id="t1615490402" t="ikitommi https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D"><y>#</y><d>2021-03-11</d><h>19:20</h><r>ikitommi</r><a href="https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D" target="_blank">https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D</a></z><z id="t1615490407" t="ikitommi https://malli.io/?value=%5B%22-server%22%20%22foo%22%20%22-verbose%22%20true%20%22-user%22%20%22joe%22%5D&amp;amp;schema=%5B%3A*%20%5B%3Acatn%20%5B%3Aprop%20string%3F%5D%20%5B%3Aval%20%5B%3Aaltn%20%5B%3As%20string%3F%5D%20%5B%3Ab%20boolean%3F%5D%5D%5D%5D%5D"><y>#</y><d>2021-03-11</d><h>19:20</h><r>ikitommi</r><a href="https://malli.io/?value=%5B%22-server%22%20%22foo%22%20%22-verbose%22%20true%20%22-user%22%20%22joe%22%5D&amp;amp;schema=%5B%3A*%20%5B%3Acatn%20%5B%3Aprop%20string%3F%5D%20%5B%3Aval%20%5B%3Aaltn%20%5B%3As%20string%3F%5D%20%5B%3Ab%20boolean%3F%5D%5D%5D%5D%5D" target="_blank">https://malli.io/?value=%5B%22-server%22%20%22foo%22%20%22-verbose%22%20true%20%22-user%22%20%22joe%22%5D&amp;amp;schema=%5B%3A*%20%5B%3Acatn%20%5B%3Aprop%20string%3F%5D%20%5B%3Aval%20%5B%3Aaltn%20%5B%3As%20string%3F%5D%20%5B%3Ab%20boolean%3F%5D%5D%5D%5D%5D</a></z><z id="t1615490491" t="ikitommi the Hiccup in JSON Schema looks fishy: {:$ref &quot;#/definitions/hiccup&quot;, :definitions {&quot;hiccup&quot; {}}}"><y>#</y><d>2021-03-11</d><h>19:21</h><w>ikitommi</w>the Hiccup in JSON Schema looks fishy:
<pre>{:$ref &quot;#/definitions/hiccup&quot;, :definitions {&quot;hiccup&quot; {}}}</pre></z><z id="t1615490533" t="ikitommi but, there are no sequence schemas there, so i guess it’s the best we can do."><y>#</y><d>2021-03-11</d><h>19:22</h><w>ikitommi</w>but, there are no sequence schemas there, so i guess it’s the best we can do.</z><z id="t1615553973" t="raymcdermott I want to protect the swagger doc built from the malli data model using buddy. I have seen the reitit examples which protect routes but it&apos;s not clear how this integrates into the Swagger model ... I will also x post to reitit"><y>#</y><d>2021-03-12</d><h>12:59</h><w>raymcdermott</w>I want to protect the swagger doc built from the malli data model using buddy. I have seen the reitit examples which protect routes but it&apos;s not clear how this integrates into the Swagger model ... I will also x post to reitit</z><z id="t1615564340" t="raymcdermott [ thanks for the answer by [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] in #reitit ]"><y>#</y><d>2021-03-12</d><h>15:52</h><w>raymcdermott</w>[ thanks for the answer by <a>@ikitommi</a> in #reitit ]</z><z id="t1615574385" t="ikitommi many ways of stripping extra keys from maps: https://www.reddit.com/r/Clojure/comments/m3hx1e/how_do_i_walk_a_complex_map_and_remove_keys_based/"><y>#</y><d>2021-03-12</d><h>18:39</h><w>ikitommi</w>many ways of stripping extra keys from maps: <a href="https://www.reddit.com/r/Clojure/comments/m3hx1e/how_do_i_walk_a_complex_map_and_remove_keys_based/" target="_blank">https://www.reddit.com/r/Clojure/comments/m3hx1e/how_do_i_walk_a_complex_map_and_remove_keys_based/</a></z><z id="t1615585012" t="borkdude Just had a thought. Can malli be used in places where currently meander or matchete ( https://github.com/xapix-io/matchete ) are used? Although this works, it is a bit cumbersome: user=&gt; (m/validate [:cat [:enum 1] :any [:enum 3]] &apos;[1 2 3]) true"><y>#</y><d>2021-03-12</d><h>21:36</h><w>borkdude</w>Just had a thought. Can malli be used in places where currently meander or matchete (<a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a>) are used?
Although this works, it is a bit cumbersome:
<pre>user=&gt; (m/validate [:cat [:enum 1] :any [:enum 3]] &apos;[1 2 3])
true</pre></z><z id="t1615585162" t="borkdude And how could I get the destructured value, after validation? user=&gt; (m/explain [:catn [:a [:enum 1]] [:b :any] [:c [:enum 3]]] &apos;[1 2 3]) nil"><y>#</y><d>2021-03-12</d><h>21:39</h><w>borkdude</w>And how could I get the destructured value, after validation?
<pre>user=&gt; (m/explain [:catn [:a [:enum 1]] [:b :any] [:c [:enum 3]]] &apos;[1 2 3])
nil</pre></z><z id="t1615588170" t="borkdude oh of course, parse facepalm user=&gt; (m/parse [:catn [:a [:enum 1]] [:b :any] [:c [:enum 3]]] &apos;[1 2 3]) {:a 1, :b 2, :c 3}"><y>#</y><d>2021-03-12</d><h>22:29</h><w>borkdude</w>oh of course, <code>parse</code> <b>facepalm</b>
<pre>user=&gt; (m/parse [:catn [:a [:enum 1]] [:b :any] [:c [:enum 3]]] &apos;[1 2 3])
{:a 1, :b 2, :c 3}</pre></z><z id="t1615589377" t="borkdude Is there a way to indicate that you want to ignore a certain binding in the parsed output?"><y>#</y><d>2021-03-12</d><h>22:49</h><w>borkdude</w>Is there a way to indicate that you want to ignore a certain binding in the parsed output?</z><z id="t1615621494" t="ikitommi not at the moment. issue welcome."><y>#</y><d>2021-03-13</d><h>07:44</h><r>ikitommi</r>not at the moment. issue welcome.</z><z id="t1615589847" t="borkdude I hacked it like this: https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18"><y>#</y><d>2021-03-12</d><h>22:57</h><w>borkdude</w>I hacked it like this:
<a href="https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18" target="_blank">https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18</a></z><z id="t1615621531" t="ikitommi ::m/default for :multi merged in master: (def valid? (m/validator [:multi {:dispatch :type} [&quot;object&quot; [:map-of :keyword :string]] [::m/default :string]])) (valid? {:type &quot;object&quot;, :key &quot;1&quot;, :value &quot;100&quot;}) ; =&gt; true (valid? &quot;SUCCESS!&quot;) ; =&gt; true (valid? :failure) ; =&gt; false"><y>#</y><d>2021-03-13</d><h>07:45</h><w>ikitommi</w><code>::m/default</code> for <code>:multi</code> merged in master:
<pre>(def valid?
  (m/validator
    [:multi {:dispatch :type}
     [&quot;object&quot; [:map-of :keyword :string]]
     [::m/default :string]]))

(valid? {:type &quot;object&quot;, :key &quot;1&quot;, :value &quot;100&quot;})
; =&gt; true

(valid? &quot;SUCCESS!&quot;)
; =&gt; true

(valid? :failure)
; =&gt; false</pre></z><z id="t1615621804" t="ikitommi Maybe the same could be used for extra keys in maps? ( https://github.com/metosin/malli/issues/43 )"><y>#</y><d>2021-03-13</d><h>07:50</h><w>ikitommi</w>Maybe the same could be used for extra keys in maps? (<a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a>)</z><z id="t1615629200" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I was trying (for fun) to write a core.match like thing with malli. So {:a ?x :b 1} would match on {:a 2 :b 1} and parsing would give you back {?x 1} . This is currently a bit difficult since you cannot change how keys are named in the parsed output from map schemas, can you?"><y>#</y><d>2021-03-13</d><h>09:53</h><w>borkdude</w><a>@ikitommi</a> I was trying (for fun) to write a core.match like thing with malli.
So <code>{:a ?x :b 1}</code> would match on <code>{:a 2 :b 1}</code> and parsing would give you back <code>{?x 1}</code>. This is currently a bit difficult since you cannot change how keys are named in the parsed output from map schemas, can you?</z><z id="t1615629268" t="borkdude So I would generate a schema like {:b [:= 1] :a :any} but then the parsed output loses the name ?x"><y>#</y><d>2021-03-13</d><h>09:54</h><w>borkdude</w>So I would generate a schema like <code>{:b [:= 1] :a :any}</code> but then the parsed output loses the name <code>?x</code></z><z id="t1615630030" t="borkdude Can I influence how things get parsed using an extra predicate similar to s/and in spec? (m/parse [:map [:a [:and :any [:fn (fn [x] [&apos;x? x])]]]] {:a 1}) "><y>#</y><d>2021-03-13</d><h>10:07</h><w>borkdude</w>Can I influence how things get parsed using an extra predicate similar to <code>s/and</code> in spec?
<pre>(m/parse [:map [:a [:and :any
                         [:fn (fn [x]
                                [&apos;x? x])]]]]
              {:a 1})</pre>
</z><z id="t1615630380" t="ikitommi not atm, parsing could have it&apos;s own property key for this, e.g. [:map {:parse ...} ...] . Internally, could be interceptors, so one can do easily pre, post &amp; schema-based parsing with that."><y>#</y><d>2021-03-13</d><h>10:13</h><w>ikitommi</w>not atm, parsing could have it&apos;s own property key for this, e.g. <code>[:map {:parse ...} ...]</code>. Internally, could be interceptors, so one can do easily pre, post &amp; schema-based parsing with that.</z><z id="t1615630426" t="ikitommi We discussed with [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] about combining internally parsing, explain and transform. They are now mostly (optimized) duplicates of each other."><y>#</y><d>2021-03-13</d><h>10:13</h><w>ikitommi</w>We discussed with <a>@nilern</a> about combining internally parsing, explain and transform. They are now mostly (optimized) duplicates of each other.</z><z id="t1615630506" t="ikitommi map keys -&gt; could done with same mechanism. Add custom parse tags to keys as properties and hook a post-parse fn to rename the keys. Or do, whatever."><y>#</y><d>2021-03-13</d><h>10:15</h><w>ikitommi</w>map keys -&gt; could done with same mechanism. Add custom parse tags to keys as properties and hook a post-parse fn to rename the keys. Or do, whatever.</z><z id="t1615633449" t="ikitommi ported the plumatic-style inline schemas for 0.3.0, it kinda works, but no tests and not happy with the original (string-based) error reporting. renamed to ns to malli.experimental.schema as it might not be part of the malli core library. any thoughts on this? add tests, cleanup and ship as experimental add-on?"><y>#</y><d>2021-03-13</d><h>11:04</h><w>ikitommi</w>ported the plumatic-style inline schemas for 0.3.0, it kinda works, but no tests and not happy with the original (string-based) error reporting. renamed to ns to <code>malli.experimental.schema</code> as it might not be part of the malli core library. any thoughts on this? add tests, cleanup and ship as experimental add-on?</z><z id="t1615633480" t="ikitommi https://github.com/metosin/malli/pull/305"><y>#</y><d>2021-03-13</d><h>11:04</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/305" target="_blank">https://github.com/metosin/malli/pull/305</a></z><z id="t1615633602" t="ikitommi the defn now emits a function schema into malli function registry and it can be configured to validate always, never or based on a dynamic var - at runtime."><y>#</y><d>2021-03-13</d><h>11:06</h><r>ikitommi</r>the <code>defn</code> now emits a function schema into malli function registry and it can be configured to validate always, never or based on a dynamic var - at runtime.</z><z id="t1615731509" t="vemv Replied in https://github.com/metosin/malli/issues/125 . Btw I hope I&apos;m not pestering too much - I simply try to make an educated attempt at improving perceived problems (which can last long - for example I use Schema at work and it kinda hurts to use an outdated tech that turned out to not be the best bet)"><y>#</y><d>2021-03-14</d><h>14:18</h><r>vemv</r>Replied in <a href="https://github.com/metosin/malli/issues/125" target="_blank">https://github.com/metosin/malli/issues/125</a> . Btw I hope I&apos;m not pestering too much - I simply try to make an educated attempt at improving perceived problems (which can last long - for example I use Schema at work and it kinda hurts to use an outdated tech that turned out to not be the best bet)</z><z id="t1615640613" t="lmergen what is the validator i can use for &apos;any collection, no matter the type&apos; ? i don&apos;t care whether it&apos;s a sequence or vector or set, just that it&apos;s a collection. what can i use for this? i wasn&apos;t able to find it"><y>#</y><d>2021-03-13</d><h>13:03</h><w>lmergen</w>what is the validator i can use for &apos;any collection, no matter the type&apos; ? i don&apos;t care whether it&apos;s a sequence or vector or set, just that it&apos;s a collection.

what can i use for this? i wasn&apos;t able to find it</z><z id="t1615645591" t="ikitommi [:attrs {:href &quot;/_/_/users/U0M8Y3G6N&quot;}] maybe coll?"><y>#</y><d>2021-03-13</d><h>14:26</h><w>ikitommi</w><a>@lmergen</a> maybe <code>coll?</code></z><z id="t1615645643" t="lmergen i can use that like [:coll pos-int?] ?"><y>#</y><d>2021-03-13</d><h>14:27</h><w>lmergen</w>i can use that like <code>[:coll pos-int?]</code> ?</z><z id="t1615645828" t="lmergen trying to figure out the best way to do this 🙂"><y>#</y><d>2021-03-13</d><h>14:30</h><w>lmergen</w>trying to figure out the best way to do this <b>🙂</b></z><z id="t1615645863" t="ikitommi sadly, it&apos;s just the core predicate, so no child type checking. There is no :coll atm. Would be a oneliner to add"><y>#</y><d>2021-03-13</d><h>14:31</h><w>ikitommi</w>sadly, it&apos;s just the core predicate, so no child type checking. There is no <code>:coll</code> atm. Would be a oneliner to add</z><z id="t1615645870" t="ikitommi See https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1858"><y>#</y><d>2021-03-13</d><h>14:31</h><r>ikitommi</r>See <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1858" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1858</a></z><z id="t1615645932" t="lmergen is there a specific reason why this is not in malli itself? as in, if i would send a PR to add this, would that be useful?"><y>#</y><d>2021-03-13</d><h>14:32</h><r>lmergen</r>is there a specific reason why this is not in malli itself? as in, if i would send a PR to add this, would that be useful?</z><z id="t1615645973" t="ikitommi no-one has asked, PR welcome (tests included)!"><y>#</y><d>2021-03-13</d><h>14:32</h><r>ikitommi</r>no-one has asked, PR welcome (tests included)!</z><z id="t1615645988" t="lmergen of course 👍"><y>#</y><d>2021-03-13</d><h>14:33</h><r>lmergen</r>of course <b>👍</b></z><z id="t1615646010" t="ikitommi it spans to generator, json schema, human errors etc. But, good examples :)"><y>#</y><d>2021-03-13</d><h>14:33</h><r>ikitommi</r>it spans to generator, json schema, human errors etc. But, good examples :)</z><z id="t1615646010" t="lmergen thanks, i&apos;ll see what i can do"><y>#</y><d>2021-03-13</d><h>14:33</h><r>lmergen</r>thanks, i&apos;ll see what i can do</z><z id="t1615646022" t="lmergen yes it touches a lot of surface"><y>#</y><d>2021-03-13</d><h>14:33</h><r>lmergen</r>yes it touches a lot of surface</z><z id="t1615646677" t="juhoteperi coll? also matches maps, that has some effects on JSON-Schema implementation at least"><y>#</y><d>2021-03-13</d><h>14:44</h><w>juhoteperi</w><code>coll?</code> also matches maps, that has some effects on JSON-Schema implementation at least</z><z id="t1615648778" t="ikitommi good point. I guess there is not a predicate for non-map collection."><y>#</y><d>2021-03-13</d><h>15:19</h><w>ikitommi</w>good point. I guess there is not a predicate for non-map collection.</z><z id="t1615649041" t="nilern I imagine maps also having keys can lead to all sorts of confusion when implementing [:coll pos-int?]"><y>#</y><d>2021-03-13</d><h>15:24</h><w>nilern</w>I imagine maps also having keys can lead to all sorts of confusion when implementing <code>[:coll pos-int?]</code></z><z id="t1615649061" t="nilern What about :sequential ?"><y>#</y><d>2021-03-13</d><h>15:24</h><w>nilern</w>What about <code>:sequential</code>?</z><z id="t1615649158" t="nilern Oh that does not take sets"><y>#</y><d>2021-03-13</d><h>15:25</h><w>nilern</w>Oh that does not take sets</z><z id="t1615649502" t="nilern Can always do [:or [:sequential pos-int?] [:set pos-int?]]"><y>#</y><d>2021-03-13</d><h>15:31</h><w>nilern</w>Can always do <code>[:or [:sequential pos-int?] [:set pos-int?]]</code></z><z id="t1615649609" t="nilern That does not support seqs though... and now I see nothing else does either."><y>#</y><d>2021-03-13</d><h>15:33</h><w>nilern</w>That does not support seqs though... and now I see nothing else does either.</z><z id="t1615649836" t="nilern Made some issues about that https://github.com/metosin/malli/issues/393 https://github.com/metosin/malli/issues/394"><y>#</y><d>2021-03-13</d><h>15:37</h><w>nilern</w>Made some issues about that <a href="https://github.com/metosin/malli/issues/393" target="_blank">https://github.com/metosin/malli/issues/393</a> <a href="https://github.com/metosin/malli/issues/394" target="_blank">https://github.com/metosin/malli/issues/394</a></z><z id="t1615789709" t="fmn Currently, is it possible to do this with parse ? (s/def ::name-or-id (s/or :name string? :id int?)) (s/conform ::name-or-id &quot;abc&quot;) ;;=&gt; [:name &quot;abc&quot;] (s/conform ::name-or-id 100) ;;=&gt; [:id 100] "><y>#</y><d>2021-03-15</d><h>06:28</h><w>fmn</w>Currently, is it possible to do this with <code>parse</code> ?

<pre>(s/def ::name-or-id (s/or :name string?
                          :id   int?))
(s/conform ::name-or-id &quot;abc&quot;)
;;=&gt; [:name &quot;abc&quot;]
(s/conform ::name-or-id 100)
;;=&gt; [:id 100]</pre>
</z><z id="t1615795749" t="ikitommi [:attrs {:href &quot;/_/_/users/U97FB4VEE&quot;}] try [:orn [:name string?] [:id int?]] . There are named-branch variants for :or, :alt and :cat with +n in the name."><y>#</y><d>2021-03-15</d><h>08:09</h><w>ikitommi</w><a>@funyako.funyao156</a> try <code>[:orn [:name string?] [:id int?]]</code>. There are named-branch variants for <code>:or,</code> <code>:alt</code> and <code>:cat</code> with +n in the name.</z><z id="t1615806405" t="fmn [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks!"><y>#</y><d>2021-03-15</d><h>11:06</h><w>fmn</w><a>@ikitommi</a> Thanks!</z><z id="t1615917699" t="raymcdermott [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] trying to get the graphviz example working with dorothy but it&apos;s all a string. What do you use to render it?"><y>#</y><d>2021-03-16</d><h>18:01</h><w>raymcdermott</w><a>@ikitommi</a> trying to get the graphviz example working with <code>dorothy</code> but it&apos;s all a string. What do you use to render it?</z><z id="t1615918357" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] try println"><y>#</y><d>2021-03-16</d><h>18:12</h><w>ikitommi</w><a>@raymcdermott</a> try <code>println</code></z><z id="t1615920853" t="raymcdermott I meant to a PNG or whatever ..."><y>#</y><d>2021-03-16</d><h>18:54</h><w>raymcdermott</w>I meant to a PNG or whatever ...</z><z id="t1615923595" t="ikitommi oh, that… 🙂 just dot from command line or the online version, e.g. https://sketchviz.com/"><y>#</y><d>2021-03-16</d><h>19:39</h><w>ikitommi</w>oh, that… <b>🙂</b> just <code>dot</code> from command line or the online version, e.g. <a href="https://sketchviz.com/" target="_blank">https://sketchviz.com/</a></z><z id="t1615923645" t="ikitommi love the sketches"><y>#</y><d>2021-03-16</d><h>19:40</h><w>ikitommi</w>love the sketches</z><z id="t1615924006" t="ikitommi but, with dorothy, this seems to work: (require &apos;[dorothy.core :as d]) (-&gt;&gt; (md/transform Order) (d/show!))"><y>#</y><d>2021-03-16</d><h>19:46</h><w>ikitommi</w>but, with dorothy, this seems to work:
<pre>(require &apos;[dorothy.core :as d])

(-&gt;&gt; (md/transform Order) (d/show!))</pre></z><z id="t1615926366" t="raymcdermott ok ... I was holding it wrong"><y>#</y><d>2021-03-16</d><h>20:26</h><w>raymcdermott</w>ok ... I was holding it wrong</z><z id="t1615929805" t="raymcdermott also m/walk ... thank you!!"><y>#</y><d>2021-03-16</d><h>21:23</h><w>raymcdermott</w>also <code>m/walk</code> ... thank you!!</z><z id="t1615932661" t="raymcdermott having said that"><y>#</y><d>2021-03-16</d><h>22:11</h><w>raymcdermott</w>having said that</z><z id="t1615932680" t="raymcdermott how do I use it to drop or add in Swagger attributes?"><y>#</y><d>2021-03-16</d><h>22:11</h><w>raymcdermott</w>how do I use it to drop or add in Swagger attributes?</z><z id="t1615932726" t="raymcdermott (def Org-Ref [:map {:title &quot;Organisation name&quot;} [:ref {:swagger/description &quot;Reference to the organisation&quot; :swagger/example &quot;Acme floor polish, Houston TX&quot;} Name]])"><y>#</y><d>2021-03-16</d><h>22:12</h><w>raymcdermott</w><pre>(def Org-Ref
  [:map {:title &quot;Organisation name&quot;}
   [:ref {:swagger/description &quot;Reference to the organisation&quot;
          :swagger/example     &quot;Acme floor polish, Houston TX&quot;} Name]])</pre></z><z id="t1615932757" t="raymcdermott I tried mu/update-properties but that only seems to operate at the top level"><y>#</y><d>2021-03-16</d><h>22:12</h><w>raymcdermott</w>I tried <code>mu/update-properties</code> but that only seems to operate at the top level</z><z id="t1615932797" t="raymcdermott [ cos they clutter up the graphics 🙂 ]"><y>#</y><d>2021-03-16</d><h>22:13</h><w>raymcdermott</w>[ cos they clutter up the graphics <b>🙂</b> ]</z><z id="t1615962366" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] you can walk + update-properties, but if you want to walk also the map-entries (not just map values), you should paramertise the walk to walk those too. same for :ref s."><y>#</y><d>2021-03-17</d><h>06:26</h><w>ikitommi</w><a>@raymcdermott</a> you can walk + update-properties, but if you want to walk also the map-entries (not just map values), you should paramertise the walk to walk those too. same for <code>:ref</code>s.</z><z id="t1615962382" t="ikitommi some tests on walking here: https://github.com/metosin/malli/blob/master/test/malli/util_test.cljc#L672-L795"><y>#</y><d>2021-03-17</d><h>06:26</h><r>ikitommi</r>some tests on walking here: <a href="https://github.com/metosin/malli/blob/master/test/malli/util_test.cljc#L672-L795" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/util_test.cljc#L672-L795</a></z><z id="t1615962459" t="ikitommi e.g. ::m/walk-refs &amp; walk-schema-refs &amp; ::m/walk-entry-vals ."><y>#</y><d>2021-03-17</d><h>06:27</h><r>ikitommi</r>e.g. <code>::m/walk-refs</code> &amp; <code>walk-schema-refs</code> &amp; <code>::m/walk-entry-vals</code>.</z><z id="t1615962501" t="ikitommi hopefully not too complex, balancing between “you can do anything with this” and “should be easy to do the simple stuff”"><y>#</y><d>2021-03-17</d><h>06:28</h><r>ikitommi</r>hopefully not too complex, balancing between “you can do anything with this” and “should be easy to do the simple stuff”</z><z id="t1615962577" t="ikitommi also, the dot-printer could have a option with schema-&gt;schema function to manipulate the schemas before printing?"><y>#</y><d>2021-03-17</d><h>06:29</h><r>ikitommi</r>also, the dot-printer could have a option with  schema-&gt;schema function to manipulate the schemas before printing?</z><z id="t1615971844" t="raymcdermott I will have to consider that once I get it all to work 🙂"><y>#</y><d>2021-03-17</d><h>09:04</h><r>raymcdermott</r>I will have to consider that once I get it all to work <b>🙂</b></z><z id="t1616001432" t="raymcdermott I have read the tests and am struggling to see how they help me to drop the swagger entries. I&apos;m not even sure how to address them .... I know they are the the map in slot 1 of the key :ref but can see how to access that. None of them seem to show how to manipulate entries. And, I know it&apos;s my limitation but going to the schema processing itself is quite complex code to read out in my head."><y>#</y><d>2021-03-17</d><h>17:17</h><r>raymcdermott</r>I have read the tests and am struggling to see how they help me to drop the swagger entries. I&apos;m not even sure how to address them .... I know they are the the map in slot 1 of the key <code>:ref</code> but can see how to access that. None of them seem to show how to manipulate entries. And, I know it&apos;s my limitation but going to the schema processing itself is quite complex code to read out in my head.</z><z id="t1616001654" t="raymcdermott I was thinking that - since they are only things defined with maps, I could find a way to drop maps like I would do for some type with walk"><y>#</y><d>2021-03-17</d><h>17:20</h><r>raymcdermott</r>I was thinking that - since they are only things defined with maps, I could find a way to drop maps like I would do for some type with walk</z><z id="t1616002782" t="ikitommi I&apos;ll try it out"><y>#</y><d>2021-03-17</d><h>17:39</h><r>ikitommi</r>I&apos;ll try it out</z><z id="t1616004599" t="ikitommi oh, no easy way for that. will add something."><y>#</y><d>2021-03-17</d><h>18:09</h><r>ikitommi</r>oh, no easy way for that. will add something.</z><z id="t1616006143" t="raymcdermott thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2021-03-17</d><h>18:35</h><r>raymcdermott</r>thanks <a>@U055NJ5CC</a></z><z id="t1616036275" t="yuhan Hi, I&apos;m just working through the Readme tutorial on the latest 0.3.0 and found that this example failed: (m/validate [:map [&quot;status&quot; [:enum &quot;ok&quot;]] [1 any?] [nil any?] [::a string?]] {&quot;status&quot; &quot;ok&quot; 1 &apos;number nil :yay ::a &quot;properly awesome&quot;}) ; =&gt; true Instead I get an exception: 1. Unhandled clojure.lang.ExceptionInfo :malli.core/naked-keys-not-supported nil {:type :malli.core/naked-keys-not-supported, :data nil}"><y>#</y><d>2021-03-18</d><h>02:57</h><w>yuhan</w>Hi, I&apos;m just working through the Readme tutorial on the latest 0.3.0 and found that this example failed:
<pre>(m/validate
  [:map
   [&quot;status&quot; [:enum &quot;ok&quot;]]
   [1 any?]
   [nil any?]
   [::a string?]]
  {&quot;status&quot; &quot;ok&quot;
   1 &apos;number
   nil :yay
   ::a &quot;properly awesome&quot;})
; =&gt; true</pre>
Instead I get an exception:
<pre>1. Unhandled clojure.lang.ExceptionInfo
   :malli.core/naked-keys-not-supported nil
   {:type :malli.core/naked-keys-not-supported, :data nil}</pre></z><z id="t1616036446" t="yuhan Is this a regression or API change? I couldn&apos;t find references to &quot;naked keys&quot; apart from internal impl code"><y>#</y><d>2021-03-18</d><h>03:00</h><w>yuhan</w>Is this a regression or API change? I couldn&apos;t find references to &quot;naked keys&quot; apart from internal impl code</z><z id="t1616045363" t="ikitommi [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] it was a regression, fixed in master"><y>#</y><d>2021-03-18</d><h>05:29</h><w>ikitommi</w><a>@qythium</a> it was a regression, fixed in master</z><z id="t1616055567" t="Hankstenberg Is there a way to filter data by a schema? So if I have data of the form {:a 1 :b 2} and a schema of the form [:map [:a int?]] can I &quot;apply&quot; the schema to the data in order to get {:a 1}? All I can think of right now is to use m/explain then parse the errors."><y>#</y><d>2021-03-18</d><h>08:19</h><w>Hankstenberg</w>Is there a way to filter data by a schema? So if I have data of the form {:a 1 :b 2} and a schema of the form [:map [:a int?]] can I &quot;apply&quot; the schema to the data in order to get {:a 1}?
All I can think of right now is to use m/explain then parse the errors.</z><z id="t1616058087" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] would this be ok: (def Org-Ref [:map {:title &quot;Organisation name&quot;} [:ref {:swagger/description &quot;Reference to the organisation&quot; :swagger/example &quot;Acme floor polish, Houston TX&quot;} :string] [:kikka [:string {:swagger {:title &quot;kukka&quot;}}]]]) (defn remove-swagger-keys [p] (not-empty (apply dissoc p (into #{:swagger} (-&gt;&gt; p (keys) (filter (comp #{:swagger} keyword namespace))))))) (defn walk-properties [schema f] (m/walk schema (fn [s _ c _] (m/into-schema (m/-parent s) (f (m/-properties s)) (cond-&gt;&gt; c (m/entries s) (map (fn [[k p s]] [k (f p) (first (m/children s))]))) (m/options s))) {::m/walk-entry-vals true})) (walk-properties Org-Ref remove-swagger-keys) ;[:map {:title &quot;Organisation name&quot;} ; [:ref :string] ; [:kikka :string]]"><y>#</y><d>2021-03-18</d><h>09:01</h><w>ikitommi</w><a>@raymcdermott</a> would this be ok:
<pre>(def Org-Ref
  [:map {:title &quot;Organisation name&quot;}
   [:ref {:swagger/description &quot;Reference to the organisation&quot;
          :swagger/example &quot;Acme floor polish, Houston TX&quot;} :string]
   [:kikka [:string {:swagger {:title &quot;kukka&quot;}}]]])

(defn remove-swagger-keys [p]
  (not-empty (apply dissoc p (into #{:swagger} (-&gt;&gt; p (keys) (filter (comp #{:swagger} keyword namespace)))))))

(defn walk-properties [schema f]
  (m/walk
    schema
    (fn [s _ c _]
      (m/into-schema
        (m/-parent s)
        (f (m/-properties s))
        (cond-&gt;&gt; c (m/entries s) (map (fn [[k p s]] [k (f p) (first (m/children s))])))
        (m/options s)))
    {::m/walk-entry-vals true}))

(walk-properties Org-Ref remove-swagger-keys)
;[:map {:title &quot;Organisation name&quot;} 
; [:ref :string] 
; [:kikka :string]]</pre></z><z id="t1616058122" t="ikitommi e.g. walk the entrys, un-walk on the way back. apply f on all properties (entrys &amp; schemas)"><y>#</y><d>2021-03-18</d><h>09:02</h><w>ikitommi</w>e.g. walk the entrys, un-walk on the way back. apply <code>f</code> on all properties (entrys &amp; schemas)</z><z id="t1616058236" t="ikitommi [:attrs {:href &quot;/_/_/users/URA5DLFM1&quot;}] you can transform the value using strip-extra-keys-transformer : (m/decode [:map [:a int?]] {:a 1, :b 2} (mt/strip-extra-keys-transformer)) ; =&gt; {:a 1}"><y>#</y><d>2021-03-18</d><h>09:03</h><w>ikitommi</w><a>@roseneck</a> you can transform the value using <code>strip-extra-keys-transformer</code>:
<pre>(m/decode [:map [:a int?]] {:a 1, :b 2} (mt/strip-extra-keys-transformer))
; =&gt; {:a 1}</pre></z><z id="t1616058573" t="Hankstenberg [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] perfect, thank you very much!"><y>#</y><d>2021-03-18</d><h>09:09</h><w>Hankstenberg</w><a>@ikitommi</a> perfect, thank you very much!</z><z id="t1616061002" t="raymcdermott yes [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] that&apos;s very elegant"><y>#</y><d>2021-03-18</d><h>09:50</h><w>raymcdermott</w>yes <a>@ikitommi</a> that&apos;s very elegant</z><z id="t1616061943" t="robert-stuttaford is it possible to introspect the malli schema from inside an :error/fn fn ? i.e. i want to (first (m/children schema)) so i can print out the enum values in the error message"><y>#</y><d>2021-03-18</d><h>10:05</h><w>robert-stuttaford</w>is it possible to introspect the malli schema from inside an <code>:error/fn</code> fn ? i.e. i want to <code>(first (m/children schema))</code> so i can print out the enum values in the error message</z><z id="t1616063670" t="ikitommi [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] sure, the fn takes the explain error map as argument, it has the :schema key."><y>#</y><d>2021-03-18</d><h>10:34</h><w>ikitommi</w><a>@robert-stuttaford</a> sure, the fn takes the explain error map as argument, it has the <code>:schema</code> key.</z><z id="t1616063706" t="ikitommi there are lot of examples in malli.error"><y>#</y><d>2021-03-18</d><h>10:35</h><w>ikitommi</w>there are lot of examples in <code>malli.error</code></z><z id="t1616063923" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L75-L80"><y>#</y><d>2021-03-18</d><h>10:38</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L75-L80" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L75-L80</a></z><z id="t1616065347" t="robert-stuttaford when i try this, i get m/children isn&apos;t a thing, because it&apos;s SCI that&apos;s running this code"><y>#</y><d>2021-03-18</d><h>11:02</h><r>robert-stuttaford</r>when i try this, i get <code>m/children</code> isn&apos;t a thing, because it&apos;s SCI that&apos;s running this code</z><z id="t1616065368" t="robert-stuttaford (thank you for your quick response)"><y>#</y><d>2021-03-18</d><h>11:02</h><r>robert-stuttaford</r>(thank you for your quick response)</z><z id="t1616065508" t="robert-stuttaford Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:51). Could not resolve symbol: m/children"><y>#</y><d>2021-03-18</d><h>11:05</h><r>robert-stuttaford</r><pre>Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:51).
Could not resolve symbol: m/children</pre></z><z id="t1616065521" t="robert-stuttaford is there a trick to get it to see malli?"><y>#</y><d>2021-03-18</d><h>11:05</h><r>robert-stuttaford</r>is there a trick to get it to see malli?</z><z id="t1616065710" t="borkdude [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] just out of curiosity: what is your use case for malli + SCI?"><y>#</y><d>2021-03-18</d><h>11:08</h><r>borkdude</r><a>@robert-stuttaford</a> just out of curiosity: what is your use case for malli + SCI?</z><z id="t1616065724" t="borkdude malli could make this namespace available inside of sci"><y>#</y><d>2021-03-18</d><h>11:08</h><r>borkdude</r>malli could make this namespace available inside of sci</z><z id="t1616065725" t="ikitommi there is ::m/sci-options to override the bindings. The default bindings are: (defn -default-sci-options [] {:preset :termination-safe :bindings {&apos;m/properties properties &apos;m/type type &apos;m/children children &apos;m/entries entries}}) have the sci-options changed? don’t seem to work anymre"><y>#</y><d>2021-03-18</d><h>11:08</h><r>ikitommi</r>there is <code>::m/sci-options</code> to override the bindings. The default bindings are:
<pre>(defn -default-sci-options []
  {:preset :termination-safe
   :bindings {&apos;m/properties properties
              &apos;m/type type
              &apos;m/children children
              &apos;m/entries entries}})</pre>
have the sci-options changed? don’t seem to work anymre</z><z id="t1616065751" t="ikitommi :termination-safe is removed at least"><y>#</y><d>2021-03-18</d><h>11:09</h><r>ikitommi</r><code>:termination-safe</code> is removed at least</z><z id="t1616065768" t="borkdude the options have not been changed, but :bindings are only valid within the user namespace, always have been. it&apos;s better to use explicit :namespaces"><y>#</y><d>2021-03-18</d><h>11:09</h><r>borkdude</r>the options have not been changed, but <code>:bindings</code> are only valid within the <code>user</code> namespace, always have been. it&apos;s better to use explicit <code>:namespaces</code></z><z id="t1616065782" t="robert-stuttaford honestly i&apos;m using sci because malli is"><y>#</y><d>2021-03-18</d><h>11:09</h><r>robert-stuttaford</r>honestly i&apos;m using sci because malli is</z><z id="t1616065790" t="borkdude yes :termination-safe has been removed for a while already, also documented in release notes"><y>#</y><d>2021-03-18</d><h>11:09</h><r>borkdude</r>yes <code>:termination-safe</code> has been removed for a while already, also documented in release notes</z><z id="t1616065810" t="robert-stuttaford all i&apos;m doing is writing malli specs at the repl with :error/fn and i ran into an error &apos;sci not available&apos;, so i put it on the CP and onward i went"><y>#</y><d>2021-03-18</d><h>11:10</h><r>robert-stuttaford</r>all i&apos;m doing is writing malli specs at the repl with :error/fn and i ran into an error &apos;sci not available&apos;, so i put it on the CP and onward i went</z><z id="t1616065820" t="ikitommi [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] if you don’t need the seriaization thing, just pass a real function."><y>#</y><d>2021-03-18</d><h>11:10</h><r>ikitommi</r><a>@robert-stuttaford</a> if you don’t need the seriaization thing, just pass a real function.</z><z id="t1616065841" t="robert-stuttaford oh man. the fn is quoted. shit. sorry for the noise, fellas"><y>#</y><d>2021-03-18</d><h>11:10</h><r>robert-stuttaford</r>oh man. the fn is quoted. shit. sorry for the noise, fellas</z><z id="t1616065850" t="ikitommi 🙂"><y>#</y><d>2021-03-18</d><h>11:10</h><r>ikitommi</r><b>🙂</b></z><z id="t1616065854" t="borkdude that&apos;s what I thought :) maybe the error message should be : use sci for serialized schemas"><y>#</y><d>2021-03-18</d><h>11:10</h><r>borkdude</r>that&apos;s what I thought :) maybe the error message should be : use sci for serialized schemas</z><z id="t1616065856" t="borkdude or something"><y>#</y><d>2021-03-18</d><h>11:10</h><r>borkdude</r>or something</z><z id="t1616065907" t="ikitommi all properties which have functions as values use the malli.eval , which uses sci as default for quoted code."><y>#</y><d>2021-03-18</d><h>11:11</h><r>ikitommi</r>all properties which have functions as values use the <code>malli.eval</code>,  which uses <code>sci</code> as default for quoted code.</z><z id="t1616065928" t="ikitommi e.g.`:gen/fmap &apos;(partial str &quot;kikka_&quot;)`"><y>#</y><d>2021-03-18</d><h>11:12</h><r>ikitommi</r>e.g.`:gen/fmap &apos;(partial str &quot;kikka_&quot;)`</z><z id="t1616065962" t="ikitommi but, what is the right way to bind those m/children into sci via options?"><y>#</y><d>2021-03-18</d><h>11:12</h><r>ikitommi</r>but, what is the right way to bind those <code>m/children</code> into sci via options?</z><z id="t1616065998" t="borkdude {:namespaces {&apos;malli.core {&apos;children m/children}}}"><y>#</y><d>2021-03-18</d><h>11:13</h><r>borkdude</r><code>{:namespaces {&apos;malli.core {&apos;children m/children}}}</code></z><z id="t1616066109" t="ikitommi doesn’t work either."><y>#</y><d>2021-03-18</d><h>11:15</h><r>ikitommi</r>doesn’t work either.</z><z id="t1616066132" t="ikitommi (defn -default-sci-options [] {:namespaces {&apos;malli.core {&apos;properties properties &apos;type type &apos;children children &apos;entries entries}}})"><y>#</y><d>2021-03-18</d><h>11:15</h><r>ikitommi</r><pre>(defn -default-sci-options []
  {:namespaces {&apos;malli.core {&apos;properties properties
                             &apos;type type
                             &apos;children children
                             &apos;entries entries}}})</pre></z><z id="t1616066137" t="borkdude doesn&apos;t work = which error?"><y>#</y><d>2021-03-18</d><h>11:15</h><r>borkdude</r>doesn&apos;t work = which error?</z><z id="t1616066154" t="ikitommi Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:50). Could not resolve symbol: malli.core/chidren [at line 1, column 10]"><y>#</y><d>2021-03-18</d><h>11:15</h><r>ikitommi</r><pre>Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:50).
Could not resolve symbol: malli.core/chidren [at line 1, column 10]</pre></z><z id="t1616066161" t="ikitommi (defn evaluator [options fail!] (let [eval-string* (dynaload/dynaload &apos;sci.core/eval-string* {:default nil}) init (dynaload/dynaload &apos;sci.core/init {:default nil}) fork (dynaload/dynaload &apos;sci.core/fork {:default nil})] (fn [] (if (and @eval-string* @init @fork) (let [ctx (init options)] (fn eval [s] (eval-string* (fork ctx) (str s)))) fail!))))"><y>#</y><d>2021-03-18</d><h>11:16</h><r>ikitommi</r><pre>(defn evaluator [options fail!]
  (let [eval-string* (dynaload/dynaload &apos;sci.core/eval-string* {:default nil})
        init (dynaload/dynaload &apos;sci.core/init {:default nil})
        fork (dynaload/dynaload &apos;sci.core/fork {:default nil})]
    (fn [] (if (and @eval-string* @init @fork)
             (let [ctx (init options)]
               (fn eval [s] (eval-string* (fork ctx) (str s))))
             fail!))))</pre></z><z id="t1616066170" t="borkdude &quot;malli.core/chidren&quot; &lt;- typo?"><y>#</y><d>2021-03-18</d><h>11:16</h><r>borkdude</r>&quot;malli.core/chidren&quot; &lt;- typo?</z><z id="t1616066195" t="ikitommi :face_palm:"><y>#</y><d>2021-03-18</d><h>11:16</h><r>ikitommi</r><b>:face_palm:</b></z><z id="t1616066209" t="ikitommi thanks, works like a charm"><y>#</y><d>2021-03-18</d><h>11:16</h><r>ikitommi</r>thanks, works like a charm</z><z id="t1616066240" t="ikitommi what about binding m -&gt; malli.core for not breaking things?"><y>#</y><d>2021-03-18</d><h>11:17</h><r>ikitommi</r>what about binding <code>m</code> -&gt; <code>malli.core</code> for not breaking things?</z><z id="t1616066972" t="borkdude you can manually insert a (require &apos;[malli.core :as m]) to ensure this works"><y>#</y><d>2021-03-18</d><h>11:29</h><r>borkdude</r>you can manually insert a <code>(require &apos;[malli.core :as m])</code> to ensure this works</z><z id="t1616067002" t="borkdude or (alias &apos;m &apos;malli.core)"><y>#</y><d>2021-03-18</d><h>11:30</h><r>borkdude</r>or <code>(alias &apos;m &apos;malli.core)</code></z><z id="t1616067206" t="ikitommi like: (defn evaluator [options fail!] (let [eval-string* (dynaload/dynaload &apos;sci.core/eval-string* {:default nil}) init (dynaload/dynaload &apos;sci.core/init {:default nil}) fork (dynaload/dynaload &apos;sci.core/fork {:default nil})] (fn [] (if (and @eval-string* @init @fork) (let [ctx (init options)] (eval-string* ctx &quot;(alias &apos;m &apos;malli.core)&quot;) (fn eval [s] (eval-string* (fork ctx) (str s)))) fail!))))"><y>#</y><d>2021-03-18</d><h>11:33</h><r>ikitommi</r>like:
<pre>(defn evaluator [options fail!]
  (let [eval-string* (dynaload/dynaload &apos;sci.core/eval-string* {:default nil})
        init (dynaload/dynaload &apos;sci.core/init {:default nil})
        fork (dynaload/dynaload &apos;sci.core/fork {:default nil})]
    (fn [] (if (and @eval-string* @init @fork)
             (let [ctx (init options)]
               (eval-string* ctx &quot;(alias &apos;m &apos;malli.core)&quot;)
               (fn eval [s] (eval-string* (fork ctx) (str s))))
             fail!))))</pre></z><z id="t1616067229" t="ikitommi seems to work"><y>#</y><d>2021-03-18</d><h>11:33</h><r>ikitommi</r>seems to work</z><z id="t1616067288" t="ikitommi ((m/eval &apos;m/type) :int) ; =&gt; :int"><y>#</y><d>2021-03-18</d><h>11:34</h><r>ikitommi</r><pre>((m/eval &apos;m/type) :int)
; =&gt; :int</pre></z><z id="t1616067292" t="ikitommi 🙇"><y>#</y><d>2021-03-18</d><h>11:34</h><r>ikitommi</r><b>🙇</b></z><z id="t1616064765" t="euccastro how do I transform the keys of a schema? e.g., I have [:map [:a-k string?] [:b-k string?]] and I want to derive a schema that is the same but with snake-case keys: [:map [:a_k string?] [:b_k string?]]"><y>#</y><d>2021-03-18</d><h>10:52</h><w>euccastro</w>how do I transform the keys of a schema?  e.g., I have <code>[:map [:a-k string?] [:b-k string?]]</code> and I want to derive a schema that is the same but with snake-case keys: <code>[:map [:a_k string?] [:b_k string?]]</code></z><z id="t1616066501" t="ikitommi [:attrs {:href &quot;/_/_/users/U65FN6WL9&quot;}] try m/walk with m/schema-walker check that the schema is a :map and recreate the children."><y>#</y><d>2021-03-18</d><h>11:21</h><w>ikitommi</w><a>@euccastro</a> try <code>m/walk</code> with <code>m/schema-walker</code> check that the schema is a <code>:map</code> and recreate the children.</z><z id="t1616066750" t="euccastro thank you!"><y>#</y><d>2021-03-18</d><h>11:25</h><w>euccastro</w>thank you!</z><z id="t1616068040" t="robert-stuttaford is the best way to specify a literal value to use a single-item enum?"><y>#</y><d>2021-03-18</d><h>11:47</h><w>robert-stuttaford</w>is the best way to specify a literal value to use a single-item enum?</z><z id="t1616068158" t="delaguardo [:= value]"><y>#</y><d>2021-03-18</d><h>11:49</h><r>delaguardo</r><code>[:= value]</code></z><z id="t1616068236" t="robert-stuttaford noice!"><y>#</y><d>2021-03-18</d><h>11:50</h><r>robert-stuttaford</r>noice!</z><z id="t1616069752" t="borkdude Tried to use this to build a core.match like this ;) https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18"><y>#</y><d>2021-03-18</d><h>12:15</h><r>borkdude</r>Tried to use this to build a core.match like this ;)

<a href="https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18" target="_blank">https://gist.github.com/borkdude/26906ee15585ed5e1b7a8eda4cc1ee18</a></z><z id="t1616396600" t="robert-stuttaford nice man"><y>#</y><d>2021-03-22</d><h>07:03</h><r>robert-stuttaford</r>nice man</z><z id="t1616085305" t="danielneal dumb question, how do you get a schema from the registry by its key"><y>#</y><d>2021-03-18</d><h>16:35</h><w>danielneal</w>dumb question, how do you get a schema from the registry by its key</z><z id="t1616085315" t="danielneal I was thinking (malli/-schema malli/default-registry ::sq/sqid)"><y>#</y><d>2021-03-18</d><h>16:35</h><w>danielneal</w>I was thinking <code>(malli/-schema malli/default-registry ::sq/sqid)</code></z><z id="t1616085319" t="danielneal but -schema is private"><y>#</y><d>2021-03-18</d><h>16:35</h><w>danielneal</w>but <code>-schema</code> is private</z><z id="t1616085430" t="emccue [:map [:field-a string?] [:field-b [:one-of [:map [:status [:= :not-asked]]] [:map [:status [:= :loading]]] [:map [:status [:= :failed]]] [:map [:status [:= :success] :value [:vector [:map [:id int?]]]]]]] [:field-c [:one-of [:map [:status [:= :not-asked]]] [:map [:status [:= :loading]]] [:map [:status [:= :failed]]] [:map [:status [:= :success] :value [:vector [:map [:id int?]]]]]]] [:field-d [:set [:map [:id int?]]]]]"><y>#</y><d>2021-03-18</d><h>16:37</h><w>emccue</w><pre>[:map
    [:field-a string?]
    [:field-b [:one-of 
               [:map [:status [:= :not-asked]]]
               [:map [:status [:= :loading]]]
               [:map [:status [:= :failed]]]
               [:map [:status [:= :success]
                      :value  [:vector [:map [:id int?]]]]]]]
    [:field-c [:one-of
                [:map [:status [:= :not-asked]]]
                [:map [:status [:= :loading]]]
                [:map [:status [:= :failed]]]
                [:map [:status [:= :success]
                       :value  [:vector [:map [:id int?]]]]]]]
    
    [:field-d [:set [:map [:id int?]]]]]</pre></z><z id="t1616085444" t="emccue what would the idiomatic way to represent this be?"><y>#</y><d>2021-03-18</d><h>16:37</h><w>emccue</w>what would the idiomatic way to represent this be?</z><z id="t1616085557" t="emccue trying on the playground it doesn&apos;t say its wrong"><y>#</y><d>2021-03-18</d><h>16:39</h><w>emccue</w>trying on the playground it doesn&apos;t say its wrong</z><z id="t1616085561" t="emccue"><y>#</y><d>2021-03-18</d><h>16:39</h><w>emccue</w></z><z id="t1616085581" t="emccue but it also doesn&apos;t produce any sample values"><y>#</y><d>2021-03-18</d><h>16:39</h><w>emccue</w>but it also doesn&apos;t produce any sample values</z><z id="t1616085630" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] there is no one-of , you can use :or"><y>#</y><d>2021-03-18</d><h>16:40</h><w>ikitommi</w><a>@emccue</a> there is no <code>one-of</code>, you can use <code>:or</code></z><z id="t1616085702" t="emccue oh."><y>#</y><d>2021-03-18</d><h>16:41</h><w>emccue</w>oh.</z><z id="t1616085706" t="emccue yep that did it"><y>#</y><d>2021-03-18</d><h>16:41</h><w>emccue</w>yep that did it</z><z id="t1616085762" t="ikitommi could also be a :multi dispatching on :type ."><y>#</y><d>2021-03-18</d><h>16:42</h><w>ikitommi</w>could also be a <code>:multi</code> dispatching on <code>:type</code> .</z><z id="t1616085892" t="ikitommi [:attrs {:href &quot;/_/_/users/U051H1KL1&quot;}] try (m/deref (m/schema ::sq/said))"><y>#</y><d>2021-03-18</d><h>16:44</h><w>ikitommi</w><a>@danieleneal</a> try <code>(m/deref (m/schema ::sq/said))</code></z><z id="t1616085944" t="emccue What is the benefit of multi schemas over explicit listing like that?"><y>#</y><d>2021-03-18</d><h>16:45</h><w>emccue</w>What is the benefit of multi schemas over explicit listing like that?</z><z id="t1616085946" t="ikitommi (m/deref ::sq/said) might work too."><y>#</y><d>2021-03-18</d><h>16:45</h><w>ikitommi</w><code>(m/deref ::sq/said)</code> might work too.</z><z id="t1616086063" t="ikitommi might not be big difference, but performance. dispatch does one lookup to find the correct schema, :or does linear scan over all."><y>#</y><d>2021-03-18</d><h>16:47</h><w>ikitommi</w>might not be big difference, but performance. dispatch does one lookup to find the correct schema, <code>:or</code> does linear scan over all.</z><z id="t1616086178" t="emccue I think last question for now - what would be the best way to reuse a structure like this"><y>#</y><d>2021-03-18</d><h>16:49</h><w>emccue</w>I think last question for now - what would be the best way to reuse a structure like this</z><z id="t1616086194" t="emccue just a function that takes in the success value schema and returns the whole thing?"><y>#</y><d>2021-03-18</d><h>16:49</h><w>emccue</w>just a function that takes in the success value schema and returns the whole thing?</z><z id="t1616086601" t="danielneal [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , (m/deref ::sq/sqid) works thanks :thumbsup:"><y>#</y><d>2021-03-18</d><h>16:56</h><w>danielneal</w><a>@ikitommi</a>, <code>(m/deref ::sq/sqid)</code> works thanks <b>:thumbsup:</b></z><z id="t1616088434" t="danielneal is there a way of getting the schema walker to deref while walking? I&apos;ve got a schema which is like [:map [:some-key :some-schema] [:another-key :another-schema]] where :some-schema and :another-schema are in the registry. I want to transform all the keys to snake case, but the schema walker doesn&apos;t descend into schema references."><y>#</y><d>2021-03-18</d><h>17:27</h><w>danielneal</w>is there a way of getting the schema walker to deref while walking? I&apos;ve got a schema which is like <code>[:map [:some-key :some-schema] [:another-key :another-schema]]</code> where <code>:some-schema</code> and <code>:another-schema</code> are in the registry. I want to transform all the keys to snake case, but the schema walker doesn&apos;t descend into schema references.</z><z id="t1616088921" t="ikitommi [:attrs {:href &quot;/_/_/users/U051H1KL1&quot;}] see: &gt; e.g. ::m/walk-refs &amp; ::m/walk-schema-refs &amp; ::m/walk-entry-vals ."><y>#</y><d>2021-03-18</d><h>17:35</h><w>ikitommi</w><a>@danieleneal</a> see:
&gt; e.g. <code>::m/walk-refs</code> &amp; <code>::m/walk-schema-refs</code> &amp; <code>::m/walk-entry-vals</code>.</z><z id="t1616088960" t="ikitommi walking respects those options, can&apos;t recall what does what. Please try, documentation PR welcome"><y>#</y><d>2021-03-18</d><h>17:36</h><w>ikitommi</w>walking respects those options, can&apos;t recall what does what. Please try, documentation PR welcome</z><z id="t1616089019" t="ikitommi I recall those are recursion safe"><y>#</y><d>2021-03-18</d><h>17:36</h><w>ikitommi</w>I recall those are recursion safe</z><z id="t1616089051" t="ikitommi e.g. stop of first deref of already walked reference"><y>#</y><d>2021-03-18</d><h>17:37</h><w>ikitommi</w>e.g. stop of first deref of already walked reference</z><z id="t1616089127" t="danielneal oh cool"><y>#</y><d>2021-03-18</d><h>17:38</h><w>danielneal</w>oh cool</z><z id="t1616089130" t="danielneal thanks again!!!"><y>#</y><d>2021-03-18</d><h>17:38</h><w>danielneal</w>thanks again!!!</z><z id="t1616102503" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] one way to reuse is to use local registry: [:map {:registry {:user/success [:map [:status [:= :success]] [:value [:vector [:map [:id int?]]]]] :user/default [:map [:status [:enum :not-asked :loading :failed]]] :user/field [:multi {:dispatch :status} [:success :user/success] [:malli.core/default :user/default]]}} [:field-a string?] [:field-b :user/field] [:field-c :user/field] [:field-d [:set [:map [:id int?]]]]]"><y>#</y><d>2021-03-18</d><h>21:21</h><w>ikitommi</w><a>@emccue</a> one way to reuse is to use local registry:
<pre>[:map {:registry {:user/success [:map
                                 [:status [:= :success]]
                                 [:value [:vector [:map [:id int?]]]]]
                  :user/default [:map 
                                 [:status [:enum :not-asked :loading :failed]]]
                  :user/field [:multi {:dispatch :status}
                               [:success :user/success]
                               [:malli.core/default :user/default]]}}
 [:field-a string?]
 [:field-b :user/field]
 [:field-c :user/field]
 [:field-d [:set [:map [:id int?]]]]]</pre></z><z id="t1616102512" t="ikitommi https://malli.io/?value=%7B%3Afield-a%20%22kikka%22%2C%0A%20%3Afield-b%20%7B%3Astatus%20%3Aloading%7D%2C%0A%20%3Afield-c%20%7B%3Astatus%20%3Afailed%7D%2C%0A%20%3Afield-d%20%23%7B%7B%3Aid%209807%7D%7D%7D&amp;amp;schema=%5B%3Amap%20%7B%3Aregistry%20%7B%3Auser%2Fsuccess%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3A%3D%20%3Asuccess%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avalue%20%5B%3Avector%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fdefault%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3Aenum%20%3Anot-asked%20%3Aloading%20%3Afailed%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Ffield%20%5B%3Amulti%20%7B%3Adispatch%20%3Astatus%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Asuccess%20%3Auser%2Fsuccess%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amalli.core%2Fdefault%20%3Auser%2Fdefault%5D%5D%7D%7D%0A%20%5B%3Afield-a%20string%3F%5D%0A%20%5B%3Afield-b%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-c%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-d%20%5B%3Aset%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D"><y>#</y><d>2021-03-18</d><h>21:21</h><r>ikitommi</r><a href="https://malli.io/?value=%7B%3Afield-a%20%22kikka%22%2C%0A%20%3Afield-b%20%7B%3Astatus%20%3Aloading%7D%2C%0A%20%3Afield-c%20%7B%3Astatus%20%3Afailed%7D%2C%0A%20%3Afield-d%20%23%7B%7B%3Aid%209807%7D%7D%7D&amp;amp;schema=%5B%3Amap%20%7B%3Aregistry%20%7B%3Auser%2Fsuccess%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3A%3D%20%3Asuccess%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avalue%20%5B%3Avector%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fdefault%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3Aenum%20%3Anot-asked%20%3Aloading%20%3Afailed%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Ffield%20%5B%3Amulti%20%7B%3Adispatch%20%3Astatus%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Asuccess%20%3Auser%2Fsuccess%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amalli.core%2Fdefault%20%3Auser%2Fdefault%5D%5D%7D%7D%0A%20%5B%3Afield-a%20string%3F%5D%0A%20%5B%3Afield-b%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-c%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-d%20%5B%3Aset%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D" target="_blank">https://malli.io/?value=%7B%3Afield-a%20%22kikka%22%2C%0A%20%3Afield-b%20%7B%3Astatus%20%3Aloading%7D%2C%0A%20%3Afield-c%20%7B%3Astatus%20%3Afailed%7D%2C%0A%20%3Afield-d%20%23%7B%7B%3Aid%209807%7D%7D%7D&amp;amp;schema=%5B%3Amap%20%7B%3Aregistry%20%7B%3Auser%2Fsuccess%20%5B%3Amap%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3A%3D%20%3Asuccess%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Avalue%20%5B%3Avector%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Fdefault%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Astatus%20%5B%3Aenum%20%3Anot-asked%20%3Aloading%20%3Afailed%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Auser%2Ffield%20%5B%3Amulti%20%7B%3Adispatch%20%3Astatus%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Asuccess%20%3Auser%2Fsuccess%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Amalli.core%2Fdefault%20%3Auser%2Fdefault%5D%5D%7D%7D%0A%20%5B%3Afield-a%20string%3F%5D%0A%20%5B%3Afield-b%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-c%20%3Auser%2Ffield%5D%0A%20%5B%3Afield-d%20%5B%3Aset%20%5B%3Amap%20%5B%3Aid%20int%3F%5D%5D%5D%5D%5D</a></z><z id="t1616102567" t="ikitommi could be of course global registry too."><y>#</y><d>2021-03-18</d><h>21:22</h><w>ikitommi</w>could be of course global registry too.</z><z id="t1616102588" t="emccue I mean like, this is analagous to a typed enum from other langs"><y>#</y><d>2021-03-18</d><h>21:23</h><w>emccue</w>I mean like, this is analagous to a typed enum from other langs</z><z id="t1616102596" t="emccue so i would in my brain go"><y>#</y><d>2021-03-18</d><h>21:23</h><w>emccue</w>so i would in my brain go</z><z id="t1616102614" t="emccue (remote-data [:map [:id int?]])"><y>#</y><d>2021-03-18</d><h>21:23</h><w>emccue</w>(remote-data [:map [:id int?]])</z><z id="t1616102619" t="emccue and reuse the pattern"><y>#</y><d>2021-03-18</d><h>21:23</h><w>emccue</w>and reuse the pattern</z><z id="t1616102677" t="ikitommi oh, sure. it’s just data, so a function liike that is the way to do it."><y>#</y><d>2021-03-18</d><h>21:24</h><w>ikitommi</w>oh, sure. it’s just data, so a function liike that is the way to do it.</z><z id="t1616102975" t="emccue but by the same token, if i have a spec like this in a namespace"><y>#</y><d>2021-03-18</d><h>21:29</h><w>emccue</w>but by the same token, if i have a spec like this in a namespace</z><z id="t1616102990" t="emccue (def user [:map [:name string?]])"><y>#</y><d>2021-03-18</d><h>21:29</h><w>emccue</w><pre>(def user [:map [:name string?]])</pre></z><z id="t1616102998" t="emccue I shouldn&apos;t use it like this"><y>#</y><d>2021-03-18</d><h>21:29</h><w>emccue</w>I shouldn&apos;t use it like this</z><z id="t1616103014" t="emccue (def school [:vector other.ns/user])"><y>#</y><d>2021-03-18</d><h>21:30</h><w>emccue</w><pre>(def school [:vector other.ns/user])</pre></z></g><g id="s12"><z id="t1616103018" t="emccue right?"><y>#</y><d>2021-03-18</d><h>21:30</h><w>emccue</w>right?</z><z id="t1616103043" t="emccue because then it will get &quot;flattened&quot; and the errors won&apos;t be as good"><y>#</y><d>2021-03-18</d><h>21:30</h><w>emccue</w>because then it will get &quot;flattened&quot; and the errors won&apos;t be as good</z><z id="t1616103147" t="nilern That&apos;s how we used to do it with Plumatic Schema"><y>#</y><d>2021-03-18</d><h>21:32</h><w>nilern</w>That&apos;s how we used to do it with Plumatic Schema</z><z id="t1616103359" t="nilern We wanted to enable that style too, you may give up some serialization benefits but get to use normal def s etc."><y>#</y><d>2021-03-18</d><h>21:35</h><w>nilern</w>We wanted to enable that style too, you may give up some serialization benefits but get to use normal <code>def</code>s etc.</z><z id="t1616103642" t="nilern The registry names don&apos;t play any role in e.g. explainer actually"><y>#</y><d>2021-03-18</d><h>21:40</h><w>nilern</w>The registry names don&apos;t play any role in e.g.  <code>explainer</code> actually</z><z id="t1616104162" t="emccue so then a local registry is basically equivalent to a let?"><y>#</y><d>2021-03-18</d><h>21:49</h><w>emccue</w>so then a local registry is basically equivalent to a let?</z><z id="t1616104176" t="emccue (but &quot;runs&quot; in the schema?)"><y>#</y><d>2021-03-18</d><h>21:49</h><w>emccue</w>(but &quot;runs&quot; in the schema?)</z><z id="t1616123559" t="willier spec-&gt;malli was mentioned here a while ago. is anyone aware if such a thing exists?"><y>#</y><d>2021-03-19</d><h>03:12</h><w>willier</w>spec-&gt;malli was mentioned here a while ago. is anyone aware if such a thing exists?</z><z id="t1616133787" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] currently it’s a let . Could be something else too. What kind of better errors would you expect? The reference information is available over there, just not used I guess in explain: (m/explain [:map {:registry {&quot;ID&quot; :int}} [:id &quot;ID&quot;]] {:id &quot;123&quot;}) ;{:schema [:map {:registry {&quot;ID&quot; :int}} [:id &quot;ID&quot;]], ; :value {:id &quot;123&quot;}, ; :errors (#Error{:path [:id], :in [:id], :schema :int, :value &quot;123&quot;})}"><y>#</y><d>2021-03-19</d><h>06:03</h><w>ikitommi</w><a>@emccue</a> currently it’s a <code>let</code>. Could be something else too. What kind of better errors would you expect? The reference information is available over there, just not used I guess in explain:
<pre>(m/explain
  [:map {:registry {&quot;ID&quot; :int}}
   [:id &quot;ID&quot;]]
  {:id &quot;123&quot;})
;{:schema [:map {:registry {&quot;ID&quot; :int}} [:id &quot;ID&quot;]],
; :value {:id &quot;123&quot;},
; :errors (#Error{:path [:id], :in [:id], :schema :int, :value &quot;123&quot;})}</pre></z><z id="t1616133803" t="ikitommi [:attrs {:href &quot;/_/_/users/U440E3Q0K&quot;}] not yet. interested in doing? 😉"><y>#</y><d>2021-03-19</d><h>06:03</h><w>ikitommi</w><a>@willier</a> not yet. interested in doing? <b>😉</b></z><z id="t1616143381" t="willier hmm, probably need a black belt in macro-fu to do this job"><y>#</y><d>2021-03-19</d><h>08:43</h><w>willier</w>hmm, probably need a black belt in macro-fu to do this job</z><z id="t1616143447" t="nilern Or a spec-tools belt?"><y>#</y><d>2021-03-19</d><h>08:44</h><w>nilern</w>Or a <code>spec-tools</code> belt?</z><z id="t1616144191" t="borkdude [:attrs {:href &quot;/_/_/users/U440E3Q0K&quot;}] you can inspect specs at runtime. spec-tools has something called a walker and coax is a library from exoscale to do coercion based on specs, I think they are doing something similar"><y>#</y><d>2021-03-19</d><h>08:56</h><w>borkdude</w><a>@willier</a> you can inspect specs at runtime. spec-tools has something called a walker and coax is a library from exoscale to do coercion based on specs, I think they are doing something similar</z><z id="t1616144281" t="ikitommi spec-tools has both walker and a visitor 🙂 visitor is the right tool for the job i believe: https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/spec-visitor"><y>#</y><d>2021-03-19</d><h>08:58</h><w>ikitommi</w>spec-tools has both walker and a visitor <b>🙂</b> visitor is the right tool for the job i believe: <a href="https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/spec-visitor" target="_blank">https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/spec-visitor</a></z><z id="t1616144327" t="ikitommi json schma with it: https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/json-schemas"><y>#</y><d>2021-03-19</d><h>08:58</h><r>ikitommi</r>json schma with it: <a href="https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/json-schemas" target="_blank">https://cljdoc.org/d/metosin/spec-tools/0.10.5/doc/json-schemas</a></z><z id="t1616144458" t="willier oh interesting... i will have a look into it - thanks!"><y>#</y><d>2021-03-19</d><h>09:00</h><r>willier</r>oh interesting... i will have a look into it - thanks!</z><z id="t1616144490" t="ikitommi also, there are [:attrs nil] in spec-tools for broken forms: if the core would be fixed: https://github.com/metosin/spec-tools/blob/master/test/cljc/spec_tools/visitor_all_test.cljc"><y>#</y><d>2021-03-19</d><h>09:01</h><w>ikitommi</w>also, there are <b>progression tests</b> in spec-tools for broken forms: if the core would be fixed: <a href="https://github.com/metosin/spec-tools/blob/master/test/cljc/spec_tools/visitor_all_test.cljc" target="_blank">https://github.com/metosin/spec-tools/blob/master/test/cljc/spec_tools/visitor_all_test.cljc</a></z><z id="t1616144612" t="ikitommi oh, no more, tests disabled and the last form is fixed. great!"><y>#</y><d>2021-03-19</d><h>09:03</h><r>ikitommi</r>oh, no more, tests disabled and the last form is fixed. great!</z><z id="t1616146999" t="danielneal If you have a map that references other schemas, like this [:map ::some/ref ::some-other/ref] how do you make ::some/ref and ::some-other/ref optional?"><y>#</y><d>2021-03-19</d><h>09:43</h><w>danielneal</w>If you have a map that references other schemas, like this <code>[:map ::some/ref ::some-other/ref]</code> how do you make <code>::some/ref</code> and <code>::some-other/ref</code> optional?</z><z id="t1616147270" t="danielneal I tried [:and {:optional true} ::some/ref] but that was invalid"><y>#</y><d>2021-03-19</d><h>09:47</h><w>danielneal</w>I tried <code>[:and {:optional true} ::some/ref]</code> but that was invalid</z><z id="t1616147363" t="nilern You just have to use the sugar-free [:map [::some/ref {:optional true} ::some/ref]] You could get clever and [:map (#(vector % {:optional true} %) ::some/ref)] or name and reuse that little fn"><y>#</y><d>2021-03-19</d><h>09:49</h><w>nilern</w>You just have to use the sugar-free <code>[:map [::some/ref {:optional true} ::some/ref]]</code>
You could get clever and <code>[:map (#(vector % {:optional true} %) ::some/ref)]</code> or name and reuse that little fn</z><z id="t1616147577" t="nilern [:map ::some/ref] is just some sugar in :map , we don&apos;t have &quot;first-class properties&quot; beyond that. And :optional is specific to map entries while :maybe does something else."><y>#</y><d>2021-03-19</d><h>09:52</h><w>nilern</w><code>[:map ::some/ref]</code> is just some sugar in <code>:map</code>, we don&apos;t have &quot;first-class properties&quot; beyond that. And <code>:optional</code> is specific to map entries while <code>:maybe</code> does something else.</z><z id="t1616147594" t="danielneal aha ok thanks 🙂"><y>#</y><d>2021-03-19</d><h>09:53</h><w>danielneal</w>aha ok thanks <b>🙂</b></z><z id="t1616148329" t="ikitommi this should also work: [:map [::some/ref {:optional true}]] , no need to repeat the schema for refs."><y>#</y><d>2021-03-19</d><h>10:05</h><w>ikitommi</w>this should also work: <code>[:map [::some/ref {:optional true}]]</code>, no need to repeat the schema for refs.</z><z id="t1616149262" t="danielneal nice!"><y>#</y><d>2021-03-19</d><h>10:21</h><w>danielneal</w>nice!</z><z id="t1616151544" t="danielneal If I&apos;m walking a schema and want to convert all schemas of type ::sq/ref into :string, but I also want to deref all other refs, how do I do this/ This is what I&apos;ve got so far: (defn output-schema [schema] (malli/walk schema (malli/schema-walker (fn [schema] (malli/type schema) (cond (= schema ::sq/ref) :string (= (malli/type schema) :map) .... do some other stuff :else schema))) {::malli/walk-schema-refs true ::malli/walk-refs true})) But the schema is expanded by the time the check happens, so it fails"><y>#</y><d>2021-03-19</d><h>10:59</h><w>danielneal</w>If I&apos;m walking a schema and want to convert all schemas of type <code>::sq/ref</code> into :string, but I also want to deref all other refs, how do I do this/
This is what I&apos;ve got so far:
<pre>(defn output-schema
  [schema]
  (malli/walk
   schema
   (malli/schema-walker
    (fn [schema]
      (malli/type schema)
      (cond
        (= schema ::sq/ref) :string
        (= (malli/type schema) :map)
        .... do some other stuff
        :else schema)))
   {::malli/walk-schema-refs true
    ::malli/walk-refs true}))</pre>
But the schema is expanded by the time the check happens, so it fails</z><z id="t1616151648" t="ikitommi what does (malli/walk schema (malli/schema-walker identity) {::malli/walk-schema-refs true, ::malli/walk-refs true}) do?"><y>#</y><d>2021-03-19</d><h>11:00</h><w>ikitommi</w>what does <code>(malli/walk schema (malli/schema-walker identity) {::malli/walk-schema-refs true, ::malli/walk-refs true})</code> do?</z><z id="t1616152293" t="danielneal yep, that expands all"><y>#</y><d>2021-03-19</d><h>11:11</h><r>danielneal</r>yep, that expands all</z><z id="t1616151676" t="ikitommi that might expand all automatically"><y>#</y><d>2021-03-19</d><h>11:01</h><w>ikitommi</w>that might expand all automatically</z><z id="t1616152177" t="ikitommi (m/walk [:schema {:registry {&quot;Country&quot; [:map [:name [:enum :FI :PO]] [:neighbors [:vector [:ref &quot;Country&quot;]]]] &quot;Burger&quot; [:map [:name string?] [:description {:optional true} string?] [:origin [:maybe &quot;Country&quot;]] [:price pos-int?]] &quot;OrderLine&quot; [:map [:burger &quot;Burger&quot;] [:amount int?]] &quot;Order&quot; [:map [:lines [:vector &quot;OrderLine&quot;]] [:delivery [:map [:delivered boolean?] [:address [:map [:street string?] [:zip int?] [:country &quot;Country&quot;]]]]]]}} &quot;Order&quot;] (m/schema-walker #(mu/update-properties % assoc :type (m/type %))) {::m/walk-schema-refs true}) ;[:schema ; {:registry {&quot;Country&quot; [:map [:name [:enum :FI :PO]] [:neighbors [:vector [:ref &quot;Country&quot;]]]], ; &quot;Burger&quot; [:map ; [:name string?] ; [:description {:optional true} string?] ; [:origin [:maybe &quot;Country&quot;]] ; [:price pos-int?]], ; &quot;OrderLine&quot; [:map [:burger &quot;Burger&quot;] [:amount int?]], ; &quot;Order&quot; [:map ; [:lines [:vector &quot;OrderLine&quot;]] ; [:delivery ; [:map [:delivered boolean?] [:address [:map [:street string?] [:zip int?] [:country &quot;Country&quot;]]]]]]}, ; :type :schema} ; [:malli.core/schema ; {:type :malli.core/schema} ; [:map ; {:type :map} ; [:lines ; [:vector ; {:type :vector} ; [:malli.core/schema ; {:type :malli.core/schema} ; [:map ; {:type :map} ; [:burger ; [:malli.core/schema ; {:type :malli.core/schema} ; [:map ; {:type :map} ; [:name [string? {:type string?}]] ; [:description {:optional true} [string? {:type string?}]] ; [:origin ; [:maybe ; {:type :maybe} ; [:malli.core/schema ; {:type :malli.core/schema} ; [:map ; {:type :map} ; [:name [:enum {:type :enum} :FI :PO]] ; [:neighbors [:vector {:type :vector} [:ref {:type :ref} &quot;Country&quot;]]]]]]] ; [:price [pos-int? {:type pos-int?}]]]]] ; [:amount [int? {:type int?}]]]]]] ; [:delivery ; [:map ; {:type :map} ; [:delivered [boolean? {:type boolean?}]] ; [:address ; [:map ; {:type :map} ; [:street [string? {:type string?}]] ; [:zip [int? {:type int?}]] ; [:country ; [:malli.core/schema ; {:type :malli.core/schema} ; [:map ; {:type :map} ; [:name [:enum {:type :enum} :FI :PO]] ; [:neighbors [:vector {:type :vector} [:ref {:type :ref} &quot;Country&quot;]]]]]]]]]]]]]"><y>#</y><d>2021-03-19</d><h>11:09</h><w>ikitommi</w><pre>(m/walk
  [:schema
   {:registry {&quot;Country&quot; [:map
                          [:name [:enum :FI :PO]]
                          [:neighbors [:vector [:ref &quot;Country&quot;]]]]
               &quot;Burger&quot; [:map
                         [:name string?]
                         [:description {:optional true} string?]
                         [:origin [:maybe &quot;Country&quot;]]
                         [:price pos-int?]]
               &quot;OrderLine&quot; [:map
                            [:burger &quot;Burger&quot;]
                            [:amount int?]]
               &quot;Order&quot; [:map
                        [:lines [:vector &quot;OrderLine&quot;]]
                        [:delivery [:map
                                    [:delivered boolean?]
                                    [:address [:map
                                               [:street string?]
                                               [:zip int?]
                                               [:country &quot;Country&quot;]]]]]]}}
   &quot;Order&quot;]
  (m/schema-walker #(mu/update-properties % assoc :type (m/type %)))
  {::m/walk-schema-refs true})
;[:schema
; {:registry {&quot;Country&quot; [:map [:name [:enum :FI :PO]] [:neighbors [:vector [:ref &quot;Country&quot;]]]],
;             &quot;Burger&quot; [:map
;                       [:name string?]
;                       [:description {:optional true} string?]
;                       [:origin [:maybe &quot;Country&quot;]]
;                       [:price pos-int?]],
;             &quot;OrderLine&quot; [:map [:burger &quot;Burger&quot;] [:amount int?]],
;             &quot;Order&quot; [:map
;                      [:lines [:vector &quot;OrderLine&quot;]]
;                      [:delivery
;                       [:map [:delivered boolean?] [:address [:map [:street string?] [:zip int?] [:country &quot;Country&quot;]]]]]]},
;  :type :schema}
; [:malli.core/schema
;  {:type :malli.core/schema}
;  [:map
;   {:type :map}
;   [:lines
;    [:vector
;     {:type :vector}
;     [:malli.core/schema
;      {:type :malli.core/schema}
;      [:map
;       {:type :map}
;       [:burger
;        [:malli.core/schema
;         {:type :malli.core/schema}
;         [:map
;          {:type :map}
;          [:name [string? {:type string?}]]
;          [:description {:optional true} [string? {:type string?}]]
;          [:origin
;           [:maybe
;            {:type :maybe}
;            [:malli.core/schema
;             {:type :malli.core/schema}
;             [:map
;              {:type :map}
;              [:name [:enum {:type :enum} :FI :PO]]
;              [:neighbors [:vector {:type :vector} [:ref {:type :ref} &quot;Country&quot;]]]]]]]
;          [:price [pos-int? {:type pos-int?}]]]]]
;       [:amount [int? {:type int?}]]]]]]
;   [:delivery
;    [:map
;     {:type :map}
;     [:delivered [boolean? {:type boolean?}]]
;     [:address
;      [:map
;       {:type :map}
;       [:street [string? {:type string?}]]
;       [:zip [int? {:type int?}]]
;       [:country
;        [:malli.core/schema
;         {:type :malli.core/schema}
;         [:map
;          {:type :map}
;          [:name [:enum {:type :enum} :FI :PO]]
;          [:neighbors [:vector {:type :vector} [:ref {:type :ref} &quot;Country&quot;]]]]]]]]]]]]]</pre></z><z id="t1616152253" t="ikitommi not sure if that’s near what you want to do."><y>#</y><d>2021-03-19</d><h>11:10</h><w>ikitommi</w>not sure if that’s near what you want to do.</z><z id="t1616152432" t="danielneal Ah I think I said :type wrong, the type is :malli.core/schema , what I&apos;m checking for is the schema itself to be ::sq/ref"><y>#</y><d>2021-03-19</d><h>11:13</h><w>danielneal</w>Ah I think I said <code>:type</code> wrong, the type is <code>:malli.core/schema</code>, what I&apos;m checking for is the schema itself to be <code>::sq/ref</code></z><z id="t1616152465" t="danielneal So is what you&apos;re suggesting to do two walks, one to capture information and put it in the properties, and then a second to do the other transformations?"><y>#</y><d>2021-03-19</d><h>11:14</h><w>danielneal</w>So is what you&apos;re suggesting to do two walks, one to capture information and put it in the properties, and then a second to do the other transformations?</z><z id="t1616152728" t="danielneal hmm"><y>#</y><d>2021-03-19</d><h>11:18</h><w>danielneal</w>hmm</z><z id="t1616152801" t="danielneal I suppose I could put some property on the ::sq/ref schema itself, but it feels like I&apos;m missing a trick"><y>#</y><d>2021-03-19</d><h>11:20</h><w>danielneal</w>I suppose I could put some property on the <code>::sq/ref</code> schema itself, but it feels like I&apos;m missing a trick</z><z id="t1616153334" t="nilern To do it in one traversal you would need a more Visitor-like prewalk where you manually deref the ones you want. I think that can be done with -walk and Walker but only schema-walker and walk are documented and stable ATM"><y>#</y><d>2021-03-19</d><h>11:28</h><w>nilern</w>To do it in one traversal you would need a more Visitor-like prewalk where you manually deref the ones you want.
I think that can be done with <code>-walk</code> and <code>Walker</code> but only <code>schema-walker</code> and <code>walk</code> are documented and stable ATM</z><z id="t1616153519" t="danielneal yeah that makes sense, you kind of prewalk it and choose whether to deref or swap as you descend"><y>#</y><d>2021-03-19</d><h>11:31</h><r>danielneal</r>yeah that makes sense, you kind of prewalk it and choose whether to deref or swap as you descend</z><z id="t1616157511" t="ikitommi ok, I guess I missed the original point. But there are public walkers like https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51"><y>#</y><d>2021-03-19</d><h>12:38</h><r>ikitommi</r>ok, I guess I missed the original point. But there are public walkers like <a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L37-L51</a></z><z id="t1616166029" t="danielneal is it safe to use those functions and protocols?"><y>#</y><d>2021-03-19</d><h>15:00</h><r>danielneal</r>is it safe to use those functions and protocols?</z><z id="t1616166182" t="nilern https://github.com/metosin/malli/#alpha"><y>#</y><d>2021-03-19</d><h>15:03</h><r>nilern</r><a href="https://github.com/metosin/malli/#alpha" target="_blank">https://github.com/metosin/malli/#alpha</a></z><z id="t1616166192" t="nilern &gt; extender api: public vars, name starts with - , e.g. malli.core/-collection-schema . Not needed with basic use cases, might evolve during the alpha, follow https://github.com/metosin/malli/blob/master/CHANGELOG.md for details"><y>#</y><d>2021-03-19</d><h>15:03</h><r>nilern</r>&gt; extender api: public vars, name starts with <code>-</code>, e.g. <code>malli.core/-collection-schema</code>. Not needed with basic use cases, might evolve during the alpha, follow <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md</a> for details</z><z id="t1616167660" t="danielneal nice, i see"><y>#</y><d>2021-03-19</d><h>15:27</h><r>danielneal</r>nice, i see</z><z id="t1616153519" t="danielneal yeah that makes sense, you kind of prewalk it and choose whether to deref or swap as you descend"><y>#</y><d>2021-03-19</d><h>11:31</h><w>danielneal</w>yeah that makes sense, you kind of prewalk it and choose whether to deref or swap as you descend</z><z id="t1616153540" t="danielneal thanks"><y>#</y><d>2021-03-19</d><h>11:32</h><w>danielneal</w>thanks</z><z id="t1616175381" t="raymcdermott doing the graphviz thing is a bit whack it turns out cos it passes through all of the constraints to be visualised and it soon gets ugly"><y>#</y><d>2021-03-19</d><h>17:36</h><w>raymcdermott</w>doing the graphviz thing is a bit whack it turns out cos it passes through all of the constraints to be visualised and it soon gets ugly</z><z id="t1616175385" t="raymcdermott"><y>#</y><d>2021-03-19</d><h>17:36</h><w>raymcdermott</w></z><z id="t1616175522" t="raymcdermott So I guess you really have to pare back everything to the simplest of all possible models for nice visuals 🙂"><y>#</y><d>2021-03-19</d><h>17:38</h><w>raymcdermott</w>So I guess you really have to pare back everything to the simplest of all possible models for nice visuals <b>🙂</b></z><z id="t1616175726" t="nilern Maybe we could have custom visualization props like we have :error/message ?"><y>#</y><d>2021-03-19</d><h>17:42</h><w>nilern</w>Maybe we could have custom visualization props like we have <code>:error/message</code>?</z><z id="t1616179505" t="raymcdermott yes, or like {:swagger}"><y>#</y><d>2021-03-19</d><h>18:45</h><w>raymcdermott</w>yes, or like <code>{:swagger}</code></z><z id="t1616179699" t="raymcdermott if one had a Member, it would be nice for example to have {:viz/parent Org} on the map and {:viz/type string} on the name property"><y>#</y><d>2021-03-19</d><h>18:48</h><w>raymcdermott</w>if one had a Member, it would be nice for example to have <code>{:viz/parent Org}</code> on the map and <code>{:viz/type string}</code> on the name property</z><z id="t1616179772" t="raymcdermott and then one could select for those properties when transforming to DOT"><y>#</y><d>2021-03-19</d><h>18:49</h><w>raymcdermott</w>and then one could select for those properties when transforming to DOT</z><z id="t1616190887" t="raymcdermott [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I might have been going about this wrong, so maybe this is now a better explanation of what I would like to have ..."><y>#</y><d>2021-03-19</d><h>21:54</h><w>raymcdermott</w><a>@ikitommi</a> I might have been going about this wrong, so maybe this is now a better explanation of what I would like to have ...</z><z id="t1616190909" t="raymcdermott (def Id [:re #&quot;^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$&quot;]) (def Name [:string {:min 3 :max 255}]) (def org-ref :ref) (def org-ref-viz [:map [org-ref :string]]) (def org-ref-description &quot;Reference (name or ID) of the organisation&quot;) (def org-ref-valid [:map {:title org-ref-description} [org-ref Name]]) (def org-ref-swagger {:swagger {:description org-ref-description :example &quot;Acme tech, Houston TX&quot;}}) (def Org-Ref [:map {:title (name org-ref)} [org-ref org-ref-swagger Name]]) (def org-id :id) (def org-id-viz [:map [org-id :string]]) (def org-id-description &quot;The organisation ID&quot;) (def org-id-valid [:map [org-id Id]]) (def org-id-swagger {:swagger {:description org-id-description :example (-&gt;id)}}) (def Org-Id [:map {:title (name org-id)} [org-id org-id-swagger Id]]) (def org-viz {&quot;Org&quot; (mu/merge org-id-viz org-ref-viz)}) (def Org (mu/merge Org-Id Org-Ref))"><y>#</y><d>2021-03-19</d><h>21:55</h><w>raymcdermott</w><pre>(def Id [:re #&quot;^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$&quot;])
(def Name [:string {:min 3 :max 255}])

(def org-ref :ref)
(def org-ref-viz [:map [org-ref :string]])
(def org-ref-description &quot;Reference (name or ID) of the organisation&quot;)
(def org-ref-valid [:map {:title org-ref-description} [org-ref Name]])
(def org-ref-swagger {:swagger {:description org-ref-description
                                :example     &quot;Acme tech, Houston TX&quot;}})
(def Org-Ref [:map {:title (name org-ref)}
              [org-ref org-ref-swagger Name]])

(def org-id :id)
(def org-id-viz [:map [org-id :string]])
(def org-id-description &quot;The organisation ID&quot;)
(def org-id-valid [:map [org-id Id]])
(def org-id-swagger {:swagger {:description org-id-description
                               :example     (-&gt;id)}})

(def Org-Id [:map {:title (name org-id)}
             [org-id org-id-swagger Id]])

(def org-viz {&quot;Org&quot; (mu/merge org-id-viz org-ref-viz)})
(def Org (mu/merge Org-Id Org-Ref))</pre></z><z id="t1616191010" t="raymcdermott I can&apos;t find a way to create org-ref-full by combining org-ref-valid with org-ref-swagger"><y>#</y><d>2021-03-19</d><h>21:56</h><w>raymcdermott</w>I can&apos;t find a way to create <code>org-ref-full</code> by combining <code>org-ref-valid</code> with <code>org-ref-swagger</code></z><z id="t1616191070" t="raymcdermott I have added org-ref-viz as that&apos;s what I would like to derive from org-ref-valid"><y>#</y><d>2021-03-19</d><h>21:57</h><w>raymcdermott</w>I have added org-ref-viz as that&apos;s what I would like to derive from <code>org-ref-valid</code></z><z id="t1616191173" t="raymcdermott At the moment I am OK with doing it the way as it is above cos there is still a lot of value but obviously there seems to be quite a bit of boiler-plate"><y>#</y><d>2021-03-19</d><h>21:59</h><w>raymcdermott</w>At the moment I am OK with doing it the way as it is above cos there is still a lot of value but obviously there seems to be quite a bit of boiler-plate</z><z id="t1616324530" t="Yevgeni Tsodikov Hey, This might be a silly question. Is it possible to validate a map while ignoring optional fields if they are invalid? for example it would return false here: (m/validate [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;}) =&gt; false But there would be a way to conform a map with invalid optional fields and “sanitize” the map ; This made-up function would return {:a &quot;Hey&quot;} (m/conform [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;})"><y>#</y><d>2021-03-21</d><h>11:02</h><w>Yevgeni Tsodikov</w>Hey,
This might be a silly question.
Is it possible to validate a map while ignoring optional fields if they are invalid?
for example it would return <code>false</code>  here:
<pre>(m/validate [:map 
             [:a string?]
             [:b {:optional true} int?]]
            {:a &quot;Hey&quot; :b &quot;Nope&quot;})
=&gt; false</pre>
But there would be a way to conform a map with invalid optional fields and “sanitize” the map
<pre>; This made-up function would return {:a &quot;Hey&quot;}
(m/conform [:map 
            [:a string?] 
            [:b {:optional true} int?]]
           {:a &quot;Hey&quot; :b &quot;Nope&quot;})</pre></z><z id="t1616325327" t="ikitommi Do you mean the first should return true ?"><y>#</y><d>2021-03-21</d><h>11:15</h><r>ikitommi</r>Do you mean the first should return <code>true</code>?</z><z id="t1616328010" t="Hankstenberg Hm, shouldn&apos;t a validation with an open map that just containts the schema for :a do the trick? Or let b be any? Under what circumstances should b be an int?"><y>#</y><d>2021-03-21</d><h>12:00</h><r>Hankstenberg</r>Hm, shouldn&apos;t a validation with an open map that just containts the schema for :a do the trick? Or let b be any? Under what circumstances should b be an int?</z><z id="t1616330721" t="ikitommi &gt; Is it possible to validate a map while ignoring optional fields if they are invalid? for that, yes, you can transform the schema before validation, just convert optional values to :any . but if you would like to strip away invalid values, you could: 1. run m/explain on data 2. recursively remove all values in :errors :in path. the invalid paths are part of the explain result: (m/explain [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;}) ;{:schema [:map [:a string?] [:b {:optional true} int?]], ; :value {:a &quot;Hey&quot;, :b &quot;Nope&quot;}, ; :errors (#Error{:path [:b], :in [:b], :schema int?, :value &quot;Nope&quot;})}"><y>#</y><d>2021-03-21</d><h>12:45</h><r>ikitommi</r>&gt; Is it possible to validate a map while ignoring optional fields if they are invalid?
for that, yes, you can transform the schema before validation, just convert optional values to <code>:any</code>. but if you would like to strip away invalid values, you could:
1. run <code>m/explain</code> on data
2. recursively remove all values in <code>:errors</code> <code>:in</code> path. the invalid paths are part of the explain result:
<pre>(m/explain
  [:map
   [:a string?]
   [:b {:optional true} int?]]
  {:a &quot;Hey&quot; :b &quot;Nope&quot;})
;{:schema [:map [:a string?] [:b {:optional true} int?]],
; :value {:a &quot;Hey&quot;, :b &quot;Nope&quot;},
; :errors (#Error{:path [:b], :in [:b], :schema int?, :value &quot;Nope&quot;})}</pre></z><z id="t1616332306" t="Hankstenberg [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] That&apos;s something I&apos;d like to be able to do too. Is there an idiomatic way to do that?"><y>#</y><d>2021-03-21</d><h>13:11</h><r>Hankstenberg</r><a>@U055NJ5CC</a> That&apos;s something I&apos;d like to be able to do too. Is there an idiomatic way to do that?</z><z id="t1616332539" t="Yevgeni Tsodikov &gt; Do you mean the first should return `true`? Yes 🙂 &gt; recursively remove all values in `:errors` `:in` path. the invalid paths are part of the explain result: The :optional data is missing from the :schema field, how can I know which field is safe to remove and which field makes the map actually invalid?"><y>#</y><d>2021-03-21</d><h>13:15</h><r>Yevgeni Tsodikov</r>&gt; Do you mean the first should return `true`?
Yes <b>🙂</b>

&gt; recursively remove all values in `:errors` `:in` path. the invalid paths are part of the explain result:
The <code>:optional</code> data is missing from the <code>:schema</code> field, how can I know which field is safe to remove and which field makes the map actually invalid?</z><z id="t1616332795" t="Yevgeni Tsodikov My scenario is an API with some optional fields. If the client doesn’t send then -&gt; no worries. If the client sent some invalid optional fields, in some cases I’d like to pass the request and not fail it. (Such cases may be that the client is a mobile device with a crappy sdk, which might report invalid data for optional fields)"><y>#</y><d>2021-03-21</d><h>13:19</h><r>Yevgeni Tsodikov</r>My scenario is an API with some optional fields.
If the client doesn’t send then -&gt; no worries.
If the client sent some invalid optional fields, in some cases I’d like to pass the request and not fail it.
(Such cases may be that the client is a mobile device with a crappy sdk, which might report invalid data for optional fields)</z><z id="t1616333689" t="Yevgeni Tsodikov Also - &gt; Do you mean the first should return `true`? Not without some hints or options. ; This is correct (m/validate [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;}) =&gt; false ; Additional options (m/validate [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;} {:fail-on-optional? false) =&gt; true"><y>#</y><d>2021-03-21</d><h>13:34</h><r>Yevgeni Tsodikov</r>Also -
&gt; Do you mean the first should return `true`?
Not without some hints or options.

<pre>; This is correct
(m/validate [:map 
             [:a string?]
             [:b {:optional true} int?]]
            {:a &quot;Hey&quot; :b &quot;Nope&quot;})
=&gt; false

; Additional options
(m/validate [:map 
             [:a string?]
             [:b {:optional true} int?]]
            {:a &quot;Hey&quot; :b &quot;Nope&quot;}
            {:fail-on-optional? false)
=&gt; true</pre></z><z id="t1616330721" t="ikitommi &gt; Is it possible to validate a map while ignoring optional fields if they are invalid? for that, yes, you can transform the schema before validation, just convert optional values to :any . but if you would like to strip away invalid values, you could: 1. run m/explain on data 2. recursively remove all values in :errors :in path. the invalid paths are part of the explain result: (m/explain [:map [:a string?] [:b {:optional true} int?]] {:a &quot;Hey&quot; :b &quot;Nope&quot;}) ;{:schema [:map [:a string?] [:b {:optional true} int?]], ; :value {:a &quot;Hey&quot;, :b &quot;Nope&quot;}, ; :errors (#Error{:path [:b], :in [:b], :schema int?, :value &quot;Nope&quot;})}"><y>#</y><d>2021-03-21</d><h>12:45</h><w>ikitommi</w>&gt; Is it possible to validate a map while ignoring optional fields if they are invalid?
for that, yes, you can transform the schema before validation, just convert optional values to <code>:any</code>. but if you would like to strip away invalid values, you could:
1. run <code>m/explain</code> on data
2. recursively remove all values in <code>:errors</code> <code>:in</code> path. the invalid paths are part of the explain result:
<pre>(m/explain
  [:map
   [:a string?]
   [:b {:optional true} int?]]
  {:a &quot;Hey&quot; :b &quot;Nope&quot;})
;{:schema [:map [:a string?] [:b {:optional true} int?]],
; :value {:a &quot;Hey&quot;, :b &quot;Nope&quot;},
; :errors (#Error{:path [:b], :in [:b], :schema int?, :value &quot;Nope&quot;})}</pre></z><z id="t1616335619" t="ikitommi"><y>#</y><d>2021-03-21</d><h>14:06</h><w>ikitommi</w></z><z id="t1616335646" t="ikitommi ping [:attrs {:href &quot;/_/_/users/U01PU4APSKV&quot;}]"><y>#</y><d>2021-03-21</d><h>14:07</h><r>ikitommi</r>ping <a>@U01PU4APSKV</a></z><z id="t1616336555" t="Yevgeni Tsodikov That’s great, thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2021-03-21</d><h>14:22</h><r>Yevgeni Tsodikov</r>That’s great, thanks <a>@U055NJ5CC</a>!</z><z id="t1616337311" t="Yevgeni Tsodikov Is there a way to conform/remove the invalid optional fields?"><y>#</y><d>2021-03-21</d><h>14:35</h><r>Yevgeni Tsodikov</r>Is there a way to conform/remove the invalid optional fields?</z><z id="t1616338285" t="ikitommi yes. Many ways to do that : 1) attach a custom transformer to the new :any fields to strip those away 2) in case of error, call m/explain and remove all values from paths that have error"><y>#</y><d>2021-03-21</d><h>14:51</h><r>ikitommi</r>yes. Many ways to do that :
1) attach a custom transformer to the new <code>:any</code> fields to strip those away
2) in case of error, call <code>m/explain</code> and remove all values from paths that have error</z><z id="t1616338316" t="ikitommi don&apos;t have time to write an example, but definitely doable 😉"><y>#</y><d>2021-03-21</d><h>14:51</h><r>ikitommi</r>don&apos;t have time to write an example, but definitely doable <b>😉</b></z><z id="t1616343482" t="Yevgeni Tsodikov What’s your opinion on something like: (defn allow-invalid-optional-values [schema] (m/walk schema (m/schema-walker (fn [s] (cond-&gt; s (m/entries s) (mu/transform-entries (partial map (fn [[k {:keys [optional] :as p} s]] (if optional [k (assoc p :original-spec s :decode/remove-invalid-fields {:compile (fn [schema _] (fn [x] (if-let [original-spec (:original-spec (m/properties schema))] (when (m/validate original-spec x) x) x)))}) :any] [k p s]))) (m/options s))))))) (-&gt; [:map [:a string?] [:b {:optional true} int?]] allow-invalid-optional-values (m/decode {:a &quot;Hey&quot; :b &quot;Nope&quot;} (mt/transformer {:name :remove-invalid-fields}))) =&gt; {:a &quot;Hey&quot;, :b nil} I don’t like having multiple transformers, though. How can I unify them? Similarly to what malli offers with mt/strip-extra-keys-transformer ?"><y>#</y><d>2021-03-21</d><h>16:18</h><r>Yevgeni Tsodikov</r>What’s your opinion on something like:
<pre>(defn allow-invalid-optional-values [schema]
  (m/walk
    schema
    (m/schema-walker
      (fn [s]
        (cond-&gt; s
                (m/entries s)
                (mu/transform-entries
                  (partial map (fn [[k {:keys [optional] :as p} s]]
                                 (if optional
                                   [k
                                    (assoc p :original-spec s
                                             :decode/remove-invalid-fields {:compile (fn [schema _]
                                                                                       (fn [x]
                                                                                         (if-let [original-spec (:original-spec (m/properties schema))]
                                                                                           (when (m/validate original-spec x)
                                                                                             x)
                                                                                           x)))})
                                    :any]
                                   [k p s])))
                  (m/options s)))))))

(-&gt; [:map
     [:a string?]
     [:b {:optional true} int?]]
    allow-invalid-optional-values
    (m/decode
      {:a &quot;Hey&quot; :b &quot;Nope&quot;}
      (mt/transformer {:name :remove-invalid-fields})))
=&gt; {:a &quot;Hey&quot;, :b nil}</pre>
I don’t like having multiple transformers, though.
How can I unify them? Similarly to what <code>malli</code> offers with <code>mt/strip-extra-keys-transformer</code> ?</z><z id="t1616335956" t="ikitommi as the slack history rolls out fast, pasted the example into https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys"><y>#</y><d>2021-03-21</d><h>14:12</h><w>ikitommi</w>as the slack history rolls out fast, pasted the example into <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys</a></z><z id="t1616341027" t="Yevgeni Tsodikov The allow-invalid-optional-values function is missing the (m/options s) arg of mu/transform-entries"><y>#</y><d>2021-03-21</d><h>15:37</h><r>Yevgeni Tsodikov</r>The <code>allow-invalid-optional-values</code> function is missing the <code>(m/options s)</code> arg of <code>mu/transform-entries</code></z><z id="t1616344303" t="ikitommi https://github.com/metosin/malli/commit/da6366dd845b300923a5aec28eae96f15a8c9f71"><y>#</y><d>2021-03-21</d><h>16:31</h><r>ikitommi</r><a href="https://github.com/metosin/malli/commit/da6366dd845b300923a5aec28eae96f15a8c9f71" target="_blank">https://github.com/metosin/malli/commit/da6366dd845b300923a5aec28eae96f15a8c9f71</a></z><z id="t1616343317" t="respatialized hi! I&apos;ve been really impressed with malli so far. really appreciate all the work you&apos;ve put into it. I&apos;m trying to generate sample values from a schema, and I&apos;m encountering a case where :orn fails and :altn succeeds: (mg/generate [:altn [:bool boolean?] [:num int?]] {:seed 20}) =&gt; [true] (mg/generate [:orn [:bool boolean?] [:num int?]] {:seed 20}) =&gt; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:16). :malli.generator/no-generator {:schema [:orn [:bool boolean?] [:num int?]], :options {:seed 20}} Is this expected at this stage? Is there additional implementation for :orn generators that still needs to be done, or is this a bug?"><y>#</y><d>2021-03-21</d><h>16:15</h><w>respatialized</w>hi! I&apos;ve been really impressed with <code>malli</code> so far. really appreciate all the work you&apos;ve put into it.

I&apos;m trying to generate sample values from a schema, and I&apos;m encountering a case where <code>:orn</code> fails and <code>:altn</code> succeeds:
<pre>(mg/generate [:altn [:bool boolean?] [:num int?]] {:seed 20})
=&gt; [true]
(mg/generate [:orn [:bool boolean?] [:num int?]] {:seed 20})
=&gt; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:16).
:malli.generator/no-generator {:schema [:orn [:bool boolean?] [:num int?]], :options {:seed 20}}</pre>
Is this expected at this stage? Is there additional implementation for <code>:orn</code> generators that still needs to be done, or is this a bug?</z><z id="t1616343452" t="respatialized simple :or also succeeds on this case: (mg/generate [:or boolean? int?] {:seed 20}) =&gt; true "><y>#</y><d>2021-03-21</d><h>16:17</h><w>respatialized</w>simple <code>:or</code> also succeeds on this case:
<pre>(mg/generate [:or boolean?  int?] {:seed 20})
=&gt; true</pre>
</z><z id="t1616345359" t="ikitommi [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] 🙇 , see https://github.com/metosin/malli/pull/400"><y>#</y><d>2021-03-21</d><h>16:49</h><w>ikitommi</w><a>@afoltzm</a> <b>🙇</b> , see <a href="https://github.com/metosin/malli/pull/400" target="_blank">https://github.com/metosin/malli/pull/400</a></z><z id="t1616345673" t="ikitommi merged in master"><y>#</y><d>2021-03-21</d><h>16:54</h><w>ikitommi</w>merged in master</z><z id="t1616346297" t="respatialized wow, that was fast! thanks!"><y>#</y><d>2021-03-21</d><h>17:04</h><w>respatialized</w>wow, that was fast! thanks!</z><z id="t1616346313" t="borkdude it&apos;s weekend, the time where magic OSS happens"><y>#</y><d>2021-03-21</d><h>17:05</h><w>borkdude</w>it&apos;s weekend, the time where magic OSS happens</z><z id="t1616350191" t="ikitommi pushed out [metosin/malli &quot;0.3.1&quot;] , finally with a working cljdoc - https://cljdoc.org/d/metosin/malli/0.3.1/doc/changelog ."><y>#</y><d>2021-03-21</d><h>18:09</h><w>ikitommi</w>pushed out <code>[metosin/malli &quot;0.3.1&quot;]</code>, finally with a working cljdoc - <a href="https://cljdoc.org/d/metosin/malli/0.3.1/doc/changelog" target="_blank">https://cljdoc.org/d/metosin/malli/0.3.1/doc/changelog</a>.</z><z id="t1616396421" t="robert-stuttaford haha just my luck, a week after i get started, the docs improve 😆 it looks great!"><y>#</y><d>2021-03-22</d><h>07:00</h><w>robert-stuttaford</w>haha just my luck, a week after i get started, the docs improve <b>😆</b> it looks great!</z><z id="t1616396493" t="robert-stuttaford btw [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] i ended up chunking the results of sets of 100 item m/provide into an atom and then m/union ing them together afterward. i ended up with a fair bit of [:or [:or [:or ....]]] but that was easy to remedy with a postwalk 🙂"><y>#</y><d>2021-03-22</d><h>07:01</h><w>robert-stuttaford</w>btw <a>@ikitommi</a> i ended up chunking the results of sets of 100 item <code>m/provide</code>  into an atom and then <code>m/union</code> ing them together afterward. i ended up with a fair bit of <code>[:or [:or [:or ....]]]</code> but that was easy to remedy with a postwalk <b>🙂</b></z><z id="t1616398402" t="ikitommi [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] good to hear. the right solution is to add few new Protocols (e.g. Inferrer and Provider ) and attach the latter to the reified IntoSchema s: each instance know how to construct itself given a value and options. Internally using type/class-based lookup tables, it should be 2-4 orders of magnitude faster, and pluggable. Have an pre-initial draft somewhere 🙂"><y>#</y><d>2021-03-22</d><h>07:33</h><w>ikitommi</w><a>@robert-stuttaford</a> good to hear. the right solution is to add few new Protocols (e.g. <code>Inferrer</code> and <code>Provider</code>) and attach the latter to the reified <code>IntoSchema</code>s: each instance know how to construct itself given a value and options. Internally using type/class-based lookup tables, it should be 2-4 orders of magnitude faster, and pluggable. Have an pre-initial draft somewhere <b>🙂</b></z><z id="t1616399861" t="robert-stuttaford that sounds sane!"><y>#</y><d>2021-03-22</d><h>07:57</h><w>robert-stuttaford</w>that sounds sane!</z><z id="t1616407599" t="Panel (malli/encode [:or [:map [:password string?] [:password2 string?]] [:fn {:error/message &quot;passwords don&apos;t match&quot;} &apos;(fn [{:keys [password password2]}] (= password password2))]] {:password &quot;ok&quot;} (mt/key-transformer {:encode name})) =&gt; {:password &quot;ok&quot;} (malli/encode [:and [:map [:password string?] [:password2 string?]] [:fn {:error/message &quot;passwords don&apos;t match&quot;} &apos;(fn [{:keys [password password2]}] (= password password2))]] {:password &quot;ok&quot;} (mt/key-transformer {:encode name})) =&gt; {&quot;password&quot; &quot;ok&quot;} Why doesn&apos;t encode work on the first one but does on the second, related to using :or instead of :and I guess."><y>#</y><d>2021-03-22</d><h>10:06</h><w>Panel</w><pre>(malli/encode
  [:or [:map
           [:password string?]
           [:password2 string?]]
     [:fn {:error/message &quot;passwords don&apos;t match&quot;}
      &apos;(fn [{:keys [password password2]}]
         (= password password2))]]
  {:password &quot;ok&quot;}
  (mt/key-transformer {:encode  name}))</pre>
=&gt; <code>{:password &quot;ok&quot;}</code>
<pre>(malli/encode
  [:and [:map
           [:password string?]
           [:password2 string?]]
     [:fn {:error/message &quot;passwords don&apos;t match&quot;}
      &apos;(fn [{:keys [password password2]}]
         (= password password2))]]
  {:password &quot;ok&quot;}
  (mt/key-transformer {:encode  name}))</pre>
=&gt; <code>{&quot;password&quot; &quot;ok&quot;}</code>

Why doesn&apos;t encode work on the first one but does on the second, related to using :or instead of :and I guess.</z><z id="t1616407884" t="ikitommi I believe neither of the examples doesn’t do anything, they are just just no-op."><y>#</y><d>2021-03-22</d><h>10:11</h><w>ikitommi</w>I believe neither of the examples doesn’t do anything, they are just just no-op.</z><z id="t1616407928" t="ikitommi oh, wait."><y>#</y><d>2021-03-22</d><h>10:12</h><w>ikitommi</w>oh, wait.</z><z id="t1616408044" t="nilern encode does not validate and those inputs are invalid, so nasal demons"><y>#</y><d>2021-03-22</d><h>10:14</h><w>nilern</w><code>encode</code> does not validate and those inputs are invalid, so nasal demons</z><z id="t1616408124" t="ikitommi actually: (-transformer [this transformer method options] (let [this-transformer (-value-transformer transformer this method options)] (if (seq children) (let [transformers (mapv #(or (-transformer % transformer method options) identity) children) validators (mapv -validator children)] (-intercepting this-transformer (if (= :decode method) (fn [x] (reduce-kv (fn [x i transformer] (let [x* (transformer x)] (if ((nth validators i) x*) (reduced x*) x))) x transformers)) (fn [x] (reduce-kv (fn [x i validator] (if (validator x) (reduced ((nth transformers i) x)) x)) x validators))))) (-intercepting this-transformer))))"><y>#</y><d>2021-03-22</d><h>10:15</h><w>ikitommi</w>actually:
<pre>(-transformer [this transformer method options]
            (let [this-transformer (-value-transformer transformer this method options)]
              (if (seq children)
                (let [transformers (mapv #(or (-transformer % transformer method options) identity) children)
                      validators (mapv -validator children)]
                  (-intercepting this-transformer
                                 (if (= :decode method)
                                   (fn [x]
                                     (reduce-kv
                                       (fn [x i transformer]
                                         (let [x* (transformer x)]
                                           (if ((nth validators i) x*) (reduced x*) x)))
                                       x transformers))
                                   (fn [x]
                                     (reduce-kv
                                       (fn [x i validator] (if (validator x) (reduced ((nth transformers i) x)) x))
                                       x validators)))))
                (-intercepting this-transformer))))</pre></z><z id="t1616408125" t="nilern Although in terms of the implementation I think both of those should be no-ops"><y>#</y><d>2021-03-22</d><h>10:15</h><w>nilern</w>Although in terms of the implementation I think both of those should be no-ops</z><z id="t1616408147" t="ikitommi it does validate and the first one fails -&gt; doesn’t transform"><y>#</y><d>2021-03-22</d><h>10:15</h><w>ikitommi</w>it does validate and the first one fails -&gt; doesn’t transform</z><z id="t1616408281" t="nilern Ah yes so :or and seqex schemas validate when encoding because they have to pick a branch but nothing else (e.g. :and does) But that is implementation detail"><y>#</y><d>2021-03-22</d><h>10:18</h><w>nilern</w>Ah yes so <code>:or</code> and seqex schemas validate when encoding because they have to pick a branch but nothing else (e.g. <code>:and</code> does)
But that is implementation detail</z><z id="t1616408633" t="nilern The recommended flow is first validate , then encode if ok, else explain Ceterum censeo, maybe some day we will have a thing that does all of that in one pass like Plumatic coerce"><y>#</y><d>2021-03-22</d><h>10:23</h><w>nilern</w>The recommended flow is first <code>validate</code>, then <code>encode</code> if ok, else <code>explain</code>
Ceterum censeo, maybe some day we will have a thing that does all of that in one pass like Plumatic <code>coerce</code></z><z id="t1616408723" t="Panel Thanks for the explanations !"><y>#</y><d>2021-03-22</d><h>10:25</h><w>Panel</w>Thanks for the explanations !</z><z id="t1616409924" t="nilern This is my pet peeve and now I finally added an issue https://github.com/metosin/malli/issues/404 But it is a big decision and feature"><y>#</y><d>2021-03-22</d><h>10:45</h><w>nilern</w>This is my pet peeve and now I finally added an issue <a href="https://github.com/metosin/malli/issues/404" target="_blank">https://github.com/metosin/malli/issues/404</a>
But it is a big decision and feature</z><z id="t1616422705" t="robert-stuttaford is it possible for malli to report all errors instead of stopping on the first one?"><y>#</y><d>2021-03-22</d><h>14:18</h><w>robert-stuttaford</w>is it possible for malli to report all errors instead of stopping on the first one?</z><z id="t1616422761" t="nilern explain(er) should report all the errors. What are you seeing / not seeing?"><y>#</y><d>2021-03-22</d><h>14:19</h><w>nilern</w><code>explain(er)</code> should report all the errors. What are you seeing / not seeing?</z><z id="t1616422854" t="robert-stuttaford ah, apologies. i&apos;m using explain -&gt; with-spell-checking -&gt; humanize"><y>#</y><d>2021-03-22</d><h>14:20</h><w>robert-stuttaford</w>ah, apologies. i&apos;m using explain -&gt; with-spell-checking -&gt; humanize</z><z id="t1616422880" t="robert-stuttaford seems humanize is dropping it"><y>#</y><d>2021-03-22</d><h>14:21</h><w>robert-stuttaford</w>seems humanize is dropping it</z><z id="t1616422889" t="ikitommi really? should not."><y>#</y><d>2021-03-22</d><h>14:21</h><w>ikitommi</w>really? should not.</z><z id="t1616422999" t="robert-stuttaford lemme make reaaaal sure first, don&apos;t want to waste your time 😅"><y>#</y><d>2021-03-22</d><h>14:23</h><w>robert-stuttaford</w>lemme make reaaaal sure first, don&apos;t want to waste your time <b>😅</b></z><z id="t1616423391" t="robert-stuttaford ok, it&apos;s not humanize. in the explain, the last error that i get is a :malli.core/input-remaining . when i fix that issue, then i get a new previously unreported error further down (happens to be the same issue: a kv-pair that should be one map level up)"><y>#</y><d>2021-03-22</d><h>14:29</h><w>robert-stuttaford</w>ok, it&apos;s not humanize. in the explain, the last error that i get is a <code>:malli.core/input-remaining</code> . when i fix that issue, then i get a new previously unreported error further down (happens to be the same issue: a kv-pair that should be one map level up)</z><z id="t1616423406" t="robert-stuttaford so, is there some way have the whole sequence reported on at once?"><y>#</y><d>2021-03-22</d><h>14:30</h><w>robert-stuttaford</w>so, is there some way have the whole sequence reported on at once?</z><z id="t1616423501" t="robert-stuttaford basically, i&apos;d like to use malli specs to provide a structural EDN linter in a web-based cms code editor. but for this one thing, it&apos;s working, beautifully"><y>#</y><d>2021-03-22</d><h>14:31</h><w>robert-stuttaford</w>basically, i&apos;d like to use malli specs to provide a structural EDN linter in a web-based cms code editor. but for this one thing, it&apos;s working, beautifully</z><z id="t1616423637" t="robert-stuttaford i am getting other errors from other collections, but the same issue manifests, in that i only get one error per such collection. i guess the question i&apos;m asking is, how do i make :sequential and/or :+ check all elements"><y>#</y><d>2021-03-22</d><h>14:33</h><w>robert-stuttaford</w>i am getting other errors from other collections, but the same issue manifests, in that i only get one error per such collection.

i guess the question i&apos;m asking is, how do i make :sequential and/or :+ check all elements</z><z id="t1616423649" t="ikitommi Oh, the partial seqexp, no reporting / transformation on partially matched sequences atm. https://github.com/metosin/malli/issues/387"><y>#</y><d>2021-03-22</d><h>14:34</h><w>ikitommi</w>Oh, the partial seqexp, no reporting / transformation on partially matched sequences atm. <a href="https://github.com/metosin/malli/issues/387" target="_blank">https://github.com/metosin/malli/issues/387</a></z><z id="t1616423674" t="robert-stuttaford ok so this is because i&apos;m using :+ rather than :sequential?"><y>#</y><d>2021-03-22</d><h>14:34</h><w>robert-stuttaford</w>ok so this is because i&apos;m using :+ rather than :sequential?</z><z id="t1616423740" t="ikitommi not sure, could you give an example with actual and expected result?"><y>#</y><d>2021-03-22</d><h>14:35</h><w>ikitommi</w>not sure, could you give an example with actual and expected result?</z><z id="t1616423784" t="robert-stuttaford ok, i switched to sequential, and this is the reason - thank you!"><y>#</y><d>2021-03-22</d><h>14:36</h><w>robert-stuttaford</w>ok,  i switched to sequential, and this is the reason - thank you!</z><z id="t1616423797" t="nilern You should use e.g. :sequential instead of :* /`:+` if you can"><y>#</y><d>2021-03-22</d><h>14:36</h><w>nilern</w>You should use e.g. <code>:sequential</code> instead of <code>:*</code>/`:+` if you can</z><z id="t1616423806" t="robert-stuttaford i can live without ensuring the sequence has at least one item"><y>#</y><d>2021-03-22</d><h>14:36</h><w>robert-stuttaford</w>i can live without ensuring the sequence has at least one item</z><z id="t1616423824" t="nilern [:sequential {:min 1} :int]"><y>#</y><d>2021-03-22</d><h>14:37</h><w>nilern</w><code>[:sequential {:min 1} :int]</code></z><z id="t1616424043" t="robert-stuttaford ok rad i&apos;ve got what i need. malli is lovely"><y>#</y><d>2021-03-22</d><h>14:40</h><w>robert-stuttaford</w>ok rad i&apos;ve got what i need. malli is lovely</z><z id="t1616424084" t="robert-stuttaford now to use edamame&apos;s edn metadata stuff to wire up go-to-line links"><y>#</y><d>2021-03-22</d><h>14:41</h><w>robert-stuttaford</w>now to use edamame&apos;s edn metadata stuff to wire up go-to-line links</z><z id="t1616424125" t="nilern In general the seqex engine can&apos;t &quot;resynchronize&quot; after an erroneous element. We could have some optimizer that recognizes [:+ :int] and transforms it to [:sequential {:min 1} :int] but it would add complexity and unpredictability..."><y>#</y><d>2021-03-22</d><h>14:42</h><w>nilern</w>In general the seqex engine can&apos;t &quot;resynchronize&quot; after an erroneous element.
We could have some optimizer that recognizes <code>[:+ :int]</code> and transforms it to <code>[:sequential {:min 1} :int]</code> but it would add complexity and unpredictability...</z><z id="t1616424159" t="robert-stuttaford totally fair"><y>#</y><d>2021-03-22</d><h>14:42</h><w>robert-stuttaford</w>totally fair</z><z id="t1616424322" t="ikitommi did a malli + edamame poc some time ago, can’t recall was it any good, but pushed just as a gist: https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5"><y>#</y><d>2021-03-22</d><h>14:45</h><w>ikitommi</w>did a malli + edamame poc some time ago, can’t recall was it any good, but pushed just as a gist: <a href="https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5" target="_blank">https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5</a></z><z id="t1616424352" t="ikitommi something [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] was asking I think."><y>#</y><d>2021-03-22</d><h>14:45</h><w>ikitommi</w>something <a>@borkdude</a> was asking I think.</z><z id="t1616424456" t="borkdude what I tried to do there is &quot;complect&quot; error message with locations directly"><y>#</y><d>2021-03-22</d><h>14:47</h><w>borkdude</w>what I tried to do there is &quot;complect&quot; error message with locations directly</z><z id="t1616424490" t="borkdude but I think you can just do explain and then look up the vals in the paths which have locations (or maybe they are already in the errors) and then postwalk the result to add the locations to the error messages"><y>#</y><d>2021-03-22</d><h>14:48</h><w>borkdude</w>but I think you can just do explain and then look up the vals in the paths which have locations (or maybe they are already in the errors) and then postwalk the result to add the locations to the error messages</z><z id="t1616424637" t="robert-stuttaford that second thing is what i&apos;m doing"><y>#</y><d>2021-03-22</d><h>14:50</h><w>robert-stuttaford</w>that second thing is what i&apos;m doing</z><z id="t1616425008" t="robert-stuttaford yeah [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] your gist is the beautiful general version of the ugly hack i&apos;m busy writing. going to start again with yours, thank you"><y>#</y><d>2021-03-22</d><h>14:56</h><w>robert-stuttaford</w>yeah <a>@ikitommi</a> your gist is the beautiful general version of the ugly hack i&apos;m busy writing. going to start again with yours, thank you</z><z id="t1616425055" t="nilern That code looks familiar :thinking_face:"><y>#</y><d>2021-03-22</d><h>14:57</h><w>nilern</w>That code looks familiar <b>:thinking_face:</b></z><z id="t1616425099" t="borkdude [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] I think the second thing is probably the easiest?"><y>#</y><d>2021-03-22</d><h>14:58</h><w>borkdude</w><a>@robert-stuttaford</a> I think the second thing is probably the easiest?</z><z id="t1616425327" t="ikitommi looking at the code, it has transduce , I never use that. I can’t recall the origins of the code, just from one of the zillion scratch files. could be [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] s work too :thinking_face:"><y>#</y><d>2021-03-22</d><h>15:02</h><w>ikitommi</w>looking at the code, it has <code>transduce</code>,  I never use that. I can’t recall the origins of the code, just from one of the zillion scratch files. could be <a>@nilern</a> s work too <b>:thinking_face:</b></z><z id="t1616425597" t="nilern Looking at the Metosin Slack history I did the unwrap and collect bits and remarked that the prewalk makes it O(n^2) but it only matters if there are large map keys or set members which hardly ever happens..."><y>#</y><d>2021-03-22</d><h>15:06</h><w>nilern</w>Looking at the Metosin Slack history I did the <code>unwrap</code> and <code>collect</code> bits and remarked that the <code>prewalk</code> makes it O(n^2) but it only matters if there are large map keys or set members which hardly ever happens...</z><z id="t1616425708" t="nilern Anyway it took a while to write so it would be cool if it found some use"><y>#</y><d>2021-03-22</d><h>15:08</h><w>nilern</w>Anyway it took a while to write so it would be cool if it found some use</z><z id="t1616480485" t="robert-stuttaford thanks all, i&apos;ll report back on how it goes!"><y>#</y><d>2021-03-23</d><h>06:21</h><w>robert-stuttaford</w>thanks all, i&apos;ll report back on how it goes!</z><z id="t1616488861" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] I can look your thing today/tomorrow."><y>#</y><d>2021-03-23</d><h>08:41</h><w>ikitommi</w><a>@raymcdermott</a> I can look your thing today/tomorrow.</z><z id="t1616499236" t="ikitommi [:attrs {:href &quot;/_/_/users/U9ABG0ERZ&quot;}] no inbuilt mapping for fn? . But, you can: (m/validate [:fn fn?] (partial +)) ; =&gt; true"><y>#</y><d>2021-03-23</d><h>11:33</h><w>ikitommi</w><a>@d.ian.b</a> no inbuilt mapping for <code>fn?</code>. But, you can:
<pre>(m/validate [:fn fn?] (partial +))
; =&gt; true</pre></z><z id="t1616499246" t="Ian Fernandez yeah"><y>#</y><d>2021-03-23</d><h>11:34</h><w>Ian Fernandez</w>yeah</z><z id="t1616499247" t="ikitommi also: (m/explain [:=&gt; [:cat [:* [:int {:gen/min -1000, :gen/max 1000}]]] :int] (partial +) {::m/function-checker mg/function-checker}) ; =&gt; nil"><y>#</y><d>2021-03-23</d><h>11:34</h><w>ikitommi</w>also:
<pre>(m/explain
  [:=&gt; [:cat [:* [:int {:gen/min -1000, :gen/max 1000}]]] :int] 
  (partial +)
  {::m/function-checker mg/function-checker})
; =&gt; nil</pre></z><z id="t1616499258" t="Ian Fernandez I&apos;ve made it right now haha"><y>#</y><d>2021-03-23</d><h>11:34</h><w>Ian Fernandez</w>I&apos;ve made it right now haha</z><z id="t1616499289" t="ikitommi (m/explain [:=&gt; [:cat [:* [:int {:gen/min -1000, :gen/max 1000}]]] [:int {:min 1}]] (partial +) {::m/function-checker mg/function-checker}) ;{:schema [:=&gt; [:cat [:* [:int #:gen{:min -1000, :max 1000}]]] [:int {:min 1}]], ; :value #object[clojure.core$_PLUS_ 0x6edca2b1 &quot;"><y>#</y><d>2021-03-23</d><h>11:34</h><w>ikitommi</w><pre>(m/explain
  [:=&gt; [:cat [:* [:int {:gen/min -1000, :gen/max 1000}]]] [:int {:min 1}]]
  (partial +)
  {::m/function-checker mg/function-checker})
;{:schema [:=&gt; [:cat [:* [:int #:gen{:min -1000, :max 1000}]]] [:int {:min 1}]],
; :value #object[clojure.core$_PLUS_ 0x6edca2b1 &quot;</pre></z><z id="t1616499307" t="Ian Fernandez nice!"><y>#</y><d>2021-03-23</d><h>11:35</h><w>Ian Fernandez</w>nice!</z><z id="t1616500642" t="Ian Fernandez How I can use a register of the (m/function-schemas) registry, onto m/validate ?"><y>#</y><d>2021-03-23</d><h>11:57</h><w>Ian Fernandez</w>How I can use a register of the <code>(m/function-schemas)</code>  registry,  onto <code>m/validate</code>?</z><z id="t1616515601" t="Ian Fernandez (get-in (m/function-schemas) [(quote *ns*) &apos;foo :schema])"><y>#</y><d>2021-03-23</d><h>16:06</h><w>Ian Fernandez</w><code>(get-in (m/function-schemas) [(quote *ns*) &apos;foo :schema])</code></z><z id="t1616516980" t="ikitommi [:attrs {:href &quot;/_/_/users/U9ABG0ERZ&quot;}] good question, atm, no easy way. Idea with the function registry is that there will be a instrument kinda thing, that will wrap a) some b) all registered function schmaas like Orchestra - running input &amp; output validation. Could be also used to emit generated data based only on the function definitions. Ideas and PRs welcome on that."><y>#</y><d>2021-03-23</d><h>16:29</h><w>ikitommi</w><a>@d.ian.b</a> good question, atm, no easy way. Idea with the function registry is that there will be a <code>instrument</code>  kinda thing, that will wrap a) some b) all registered function schmaas like Orchestra - running input &amp; output validation. Could be also used to emit generated data based only on the function definitions. Ideas and PRs welcome on that.</z><z id="t1616517059" t="ikitommi also, did a spike on infferring schemas from normal vars. you get useful guesses pretty easily, better with tools.analyzer &amp; clj-kondo and I guess. really good with core.typed."><y>#</y><d>2021-03-23</d><h>16:30</h><w>ikitommi</w>also, did a spike on infferring schemas from normal vars. you get useful guesses pretty easily, better with tools.analyzer &amp; clj-kondo and I guess. really good with core.typed.</z><z id="t1616517360" t="ikitommi the new kw-varargs thing would work nicely with global registry, my guess is that the core team will plug into that with spec. e.g. given a function: (defn doit [&amp; {:domain.user/keys [id name]}] [id name]) … running (m/collect #&apos;doit) would infer a [:map :domain.user/id :domain.user/name] out of it, register it as a malli function schma, after (m/instrument my-registry) saying: (doit :domain.user/id 1, :domain.user/name &quot;kikka&quot;) would cause it to run validation."><y>#</y><d>2021-03-23</d><h>16:36</h><w>ikitommi</w>the new kw-varargs thing would work nicely with global registry, my guess is that the core team will plug into that with spec. e.g. given a function:
<pre>(defn doit [&amp; {:domain.user/keys [id name]}] [id name])</pre>
… running <code>(m/collect #&apos;doit)</code> would infer a <code>[:map :domain.user/id :domain.user/name]</code> out of it, register it as a malli function schma, after <code>(m/instrument my-registry)</code> saying:
<pre>(doit :domain.user/id 1, :domain.user/name &quot;kikka&quot;)</pre>
would cause it to run validation.</z><z id="t1616517484" t="ikitommi given there is few hours extra time, I would write a sample code so that I could prove a point that it’s doable and awesome ."><y>#</y><d>2021-03-23</d><h>16:38</h><w>ikitommi</w>given there is few hours extra time, I would write a sample code so that I could prove a point that it’s doable and <b>awesome</b>.</z><z id="t1616517939" t="raymcdermott I don&apos;t seem to be able to merge maps with [:and] constraints"><y>#</y><d>2021-03-23</d><h>16:45</h><w>raymcdermott</w>I don&apos;t seem to be able to merge maps with <code>[:and]</code> constraints</z><z id="t1616518053" t="raymcdermott (def x [:and [:map [:start int?] [:end int?]] [:fn (fn [{:keys [start end]}] (&lt; start end))]]) =&gt; #&apos;user/x (def y [:map [:here int?] [:there int?]]) =&gt; #&apos;user/y (require &apos;[malli.util :as mu]) =&gt; nil (mu/merge y x) =&gt; [:and [:map [:start int?] [:end int?]] [:fn #object[user$fn__4910 0x40fa91ef &quot;"><y>#</y><d>2021-03-23</d><h>16:47</h><w>raymcdermott</w><pre>(def x [:and [:map
              [:start int?]
              [:end int?]]
        [:fn (fn [{:keys [start end]}]
               (&lt; start end))]])
=&gt; #&apos;user/x
(def y [:map
        [:here int?]
        [:there int?]])
=&gt; #&apos;user/y
(require &apos;[malli.util :as mu])
=&gt; nil
(mu/merge y x)
=&gt; [:and [:map [:start int?] [:end int?]] [:fn #object[user$fn__4910 0x40fa91ef &quot;</pre></z><z id="t1616518063" t="raymcdermott is this expected?"><y>#</y><d>2021-03-23</d><h>16:47</h><w>raymcdermott</w>is this expected?</z><z id="t1616518455" t="borkdude and should merge combine the predicate in another predicate which and s those if both maps have predicates?"><y>#</y><d>2021-03-23</d><h>16:54</h><w>borkdude</w>and should merge combine the predicate in another predicate which <code>and</code>s those if both maps have predicates?</z><z id="t1616518534" t="raymcdermott it should invoke both functions ... maybe the order would not be predictable but I&apos;ll take that"><y>#</y><d>2021-03-23</d><h>16:55</h><w>raymcdermott</w>it should invoke both functions ... maybe the order would not be predictable but I&apos;ll take that</z><z id="t1616518545" t="borkdude probably the order of merge args"><y>#</y><d>2021-03-23</d><h>16:55</h><w>borkdude</w>probably the order of merge args</z><z id="t1616518605" t="borkdude this could lead to funny problems, like what if you merge in a closed map in an open map, probably the resulting map should be open?"><y>#</y><d>2021-03-23</d><h>16:56</h><w>borkdude</w>this could lead to funny problems, like what if you merge in a closed map in an open map, probably the resulting map should be open?</z><z id="t1616518759" t="borkdude or should merge consider predicates and other properties like metadata, which is ignored in merge args?"><y>#</y><d>2021-03-23</d><h>16:59</h><w>borkdude</w>or should merge consider predicates and other properties like metadata, which is ignored in merge args?</z><z id="t1616518818" t="borkdude (with-properties-of (merge x y) y)"><y>#</y><d>2021-03-23</d><h>17:00</h><w>borkdude</w><code>(with-properties-of (merge x y) y)</code></z><z id="t1616522041" t="raymcdermott merge takes the last as the &apos;winner&apos; so I think that would be the most idiomatic"><y>#</y><d>2021-03-23</d><h>17:54</h><w>raymcdermott</w>merge takes the last as the &apos;winner&apos; so I think that would be the most idiomatic</z><z id="t1616522077" t="raymcdermott but I agree that merging things that are not maps is tricky"><y>#</y><d>2021-03-23</d><h>17:54</h><w>raymcdermott</w>but I agree that merging things that are not maps is tricky</z><z id="t1616527155" t="ikitommi Plumatic dropped s/both in favour of s/constrained just because the first is not a good idea: “apple and fruit and a car” please. Currently :and already kinda means “the first thing constrained with the rest” as we pick the generator from first and then constraint with the rest using gen/such-that . Given that, we could make :and mergable, would merge with the first and keep the rest as extra leaves of :and ? e.g. [:map ::x] [:map ::y] ; =&gt; [:map ::x ::y] [:map ::x] [:and [:map ::y] map?] ; =&gt; [:and [:map ::x ::y] map?] [:and [:map ::x] map?] [:map ::y] ; =&gt; [:and [:map ::x ::y] map?] [:and [:map ::x] map?] [:and [:map ::y] map?] ; =&gt; [:and [:map ::x ::y] map? map?] [:and [:map ::x]] map? ; =&gt; map? would that be … more correct?"><y>#</y><d>2021-03-23</d><h>19:19</h><w>ikitommi</w>Plumatic dropped <code>s/both</code> in favour of <code>s/constrained</code> just because the first is not a good idea: “apple and fruit and a car” please. Currently <code>:and</code> already kinda means “the first thing constrained with the rest” as we pick the generator from first and then constraint with the rest using <code>gen/such-that</code>. Given that, we could make <code>:and</code> mergable, would merge with the first and keep the rest as extra leaves of <code>:and</code>? e.g.
<pre>[:map ::x]
[:map ::y] 
; =&gt; [:map ::x ::y]

[:map ::x]
[:and [:map ::y] map?] 
; =&gt; [:and [:map ::x ::y] map?]

[:and [:map ::x] map?]
[:map ::y] 
; =&gt; [:and [:map ::x ::y] map?]

[:and [:map ::x] map?]
[:and [:map ::y] map?] 
; =&gt; [:and [:map ::x ::y] map? map?]

[:and [:map ::x]]
map? 
; =&gt; map?</pre>
would that be … more correct?</z><z id="t1616527263" t="ikitommi having [:and [:map …] [:fn …]] is quite common, having it non-mergable is a bummer."><y>#</y><d>2021-03-23</d><h>19:21</h><w>ikitommi</w>having <code>[:and [:map …] [:fn …]]</code> is quite common, having it non-mergable is a bummer.</z><z id="t1616620747" t="raymcdermott if both maps have [:and [:map ..][fn...] it could be rejected. If one has an [:and ...] and the other doesn&apos;t can&apos;t you still merge the maps? I am probably under thinking it 🙂"><y>#</y><d>2021-03-24</d><h>21:19</h><r>raymcdermott</r>if both maps have <code>[:and [:map ..][fn...]</code> it could be rejected. If one has an <code>[:and ...]</code> and the other doesn&apos;t can&apos;t you still merge the maps? I am probably under thinking it <b>🙂</b></z><z id="t1616537242" t="Panel Anyway to have a dynamic default ? Like if I want a default timestamp to be generated when runing decode with default-value-transformer ?"><y>#</y><d>2021-03-23</d><h>22:07</h><w>Panel</w>Anyway to have a dynamic default ? Like if I want a default timestamp to be generated when runing decode with default-value-transformer ?</z><z id="t1616541459" t="Panel (malli/decode [:map {:registry {:inst (m/-simple-schema {:type :inst :pred inst?})}} [:time :inst] [:id1 :uuid] [:id2 :uuid]] {} (mt/default-value-transformer {:defaults {:inst (constantly (rand-int 100)) :uuid (constantly (char (rand-int 100)))}})) Found something that works for me, but the default are generated once per type so for example if you need two different uuid it won&apos;t work."><y>#</y><d>2021-03-23</d><h>23:17</h><r>Panel</r><pre>(malli/decode
 [:map {:registry
        {:inst (m/-simple-schema
                {:type :inst
                 :pred inst?})}}
  [:time :inst]
  [:id1 :uuid]
  [:id2 :uuid]]
 {}
 (mt/default-value-transformer
  {:defaults {:inst (constantly (rand-int 100))
              :uuid (constantly (char (rand-int 100)))}}))</pre>
Found something that works for me, but the default are generated once per type so for example if you need two different uuid it won&apos;t work.</z><z id="t1616542462" t="Panel (mu/optional-keys [:map {:registry {:inst (m/-simple-schema {:type :inst :pred inst?})}} [:time :inst] [:id :uuid]]) This throw a java.lang.StackOverflowError"><y>#</y><d>2021-03-23</d><h>23:34</h><w>Panel</w><pre>(mu/optional-keys
 [:map {:registry
        {:inst (m/-simple-schema
                {:type :inst
                 :pred inst?})}}
  [:time :inst]
  [:id :uuid]])</pre>
This throw a java.lang.StackOverflowError</z><z id="t1616550969" t="Panel It does work if the registry is passed in the options map (mu/optional-keys [:map [:time :inst] [:id :uuid]] {:registry (mr/composite-registry m/default-registry {:inst (m/-simple-schema {:type :inst :pred inst?})})})"><y>#</y><d>2021-03-24</d><h>01:56</h><r>Panel</r>It does work if the registry is passed in the options map
<pre>(mu/optional-keys
 [:map
  [:time :inst]
  [:id :uuid]]
 {:registry
  (mr/composite-registry
   m/default-registry
   {:inst (m/-simple-schema
           {:type :inst
            :pred inst?})})})</pre></z><z id="t1616591797" t="respatialized Is there a preferred way to ensure that a seqex schema is a given collection type? right now I can use [:and vector? [:catn [:bool :boolean] [:int :int]]] , but I was wondering if there was a more canonical or performant way of doing it (generators often fail to satisfy the predicate, for example)."><y>#</y><d>2021-03-24</d><h>13:16</h><w>respatialized</w>Is there a preferred way to ensure that a seqex schema is a given collection type? right now I can use <code>[:and vector? [:catn [:bool :boolean] [:int :int]]]</code>, but I was wondering if there was a more canonical or performant way of doing it (generators often fail to satisfy the predicate, for example).</z><z id="t1616592224" t="nilern No. I think it only matters for generators and :and is in general not generator-friendly (currently the generator is a gen/such-that , which is pretty bad but how much better can we even get?)"><y>#</y><d>2021-03-24</d><h>13:23</h><w>nilern</w>No. I think it only matters for generators and <code>:and</code> is in general not generator-friendly (currently the generator is a <code>gen/such-that</code>, which is pretty bad but how much better can we even get?)</z><z id="t1616592319" t="nilern (For that particular example I would probably use [:tuple :boolean :int] but you might really have something that actually needs seqex)"><y>#</y><d>2021-03-24</d><h>13:25</h><w>nilern</w>(For that particular example I would probably use <code>[:tuple :boolean :int]</code> but you might really have something that actually needs seqex)</z><z id="t1616592584" t="respatialized yeah, that was a deliberately simplified example (the actual motivating use case is validation on hiccup forms). I think I&apos;ll need to take a crack at custom generators for this use case."><y>#</y><d>2021-03-24</d><h>13:29</h><w>respatialized</w>yeah, that was a deliberately simplified example (the actual motivating use case is validation on hiccup forms). I think I&apos;ll need to take a crack at custom generators for this use case.</z><z id="t1616592789" t="nilern I think I&apos;ve seen some discussion of this previously and it should be simple to add. So maybe file an issue as well?"><y>#</y><d>2021-03-24</d><h>13:33</h><w>nilern</w>I think I&apos;ve seen some discussion of this previously and it should be simple to add. So maybe file an issue as well?</z><z id="t1616593874" t="nilern It is unfortunate that we have to add non-orthogonal props like [:string {:min 5}] and now maybe [:catn {:type :vector}] to get decent generators"><y>#</y><d>2021-03-24</d><h>13:51</h><w>nilern</w>It is unfortunate that we have to add non-orthogonal props like <code>[:string {:min 5}]</code> and now maybe <code>[:catn {:type :vector}]</code> to get decent generators</z><z id="t1616594665" t="respatialized minimallist has an additional https://github.com/green-coder/minimallist/blob/f10ebbd3c2b93e7579295618a7ed1e870c489bc4/src/minimallist/helper.cljc#L72 that does this, minimallist.helper/in-vector , but it chooses a map-based representation for schemas that allows additional metadata of :coll-type to be assoc&apos;d to the schema. Unclear how something similar would work in malli ."><y>#</y><d>2021-03-24</d><h>14:04</h><w>respatialized</w><code>minimallist</code> has an additional <a href="https://github.com/green-coder/minimallist/blob/f10ebbd3c2b93e7579295618a7ed1e870c489bc4/src/minimallist/helper.cljc#L72" target="_blank">https://github.com/green-coder/minimallist/blob/f10ebbd3c2b93e7579295618a7ed1e870c489bc4/src/minimallist/helper.cljc#L72</a> that does this, <code>minimallist.helper/in-vector</code>, but it chooses a map-based representation for schemas that allows additional metadata of <code>:coll-type</code> to be assoc&apos;d to the schema. Unclear how something similar would work in <code>malli</code>.</z><z id="t1616594930" t="nilern It would just add that to props but the seqex schemas still have to be updated to use that information"><y>#</y><d>2021-03-24</d><h>14:08</h><w>nilern</w>It would just add that to props but the seqex schemas still have to be updated to use that information</z><z id="t1616697480" t="ikitommi first kinda BREAKING change in the public api. m/parse on :multi now returns the branch information. It’s a fix, but still: (def Multi [:multi {:dispatch :type} [:user [:map [:size :int]]] [::m/default :any]]) (m/parse Multi {:type :user, :size 1}) ; =&gt; [:user {:type :user, :size 1}] (m/parse Multi {:type &quot;sized&quot;, :size 1}) ; =&gt; [:malli.core/default {:type &quot;sized&quot;, :size 1}] (-&gt;&gt; {:type :user, :size 1} (m/parse Multi) (m/unparse Multi)) ; =&gt; {:type :user, :size 1}"><y>#</y><d>2021-03-25</d><h>18:38</h><w>ikitommi</w>first kinda BREAKING change in the public api. <code>m/parse</code> on <code>:multi</code> now returns the branch information. It’s a fix, but still:
<pre>(def Multi
  [:multi {:dispatch :type}
   [:user [:map [:size :int]]]
   [::m/default :any]])

(m/parse Multi {:type :user, :size 1})
; =&gt; [:user {:type :user, :size 1}]

(m/parse Multi {:type &quot;sized&quot;, :size 1})
; =&gt; [:malli.core/default {:type &quot;sized&quot;, :size 1}]

(-&gt;&gt; {:type :user, :size 1}
     (m/parse Multi)
     (m/unparse Multi))
; =&gt; {:type :user, :size 1}</pre></z><z id="t1616710907" t="ikitommi +5 loc later (including comments): :and merges on first child! comments welcome on the results - https://github.com/metosin/malli/pull/405"><y>#</y><d>2021-03-25</d><h>22:21</h><w>ikitommi</w>+5 loc later (including comments): <code>:and</code> merges on first child! comments welcome on the results - <a href="https://github.com/metosin/malli/pull/405" target="_blank">https://github.com/metosin/malli/pull/405</a></z><z id="t1616746296" t="ikitommi ping [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}]"><y>#</y><d>2021-03-26</d><h>08:11</h><r>ikitommi</r>ping <a>@U04V5V0V4</a></z><z id="t1616775658" t="raymcdermott I thought it read 5k loc ... so 😅"><y>#</y><d>2021-03-26</d><h>16:20</h><r>raymcdermott</r>I thought it read 5k loc ... so <b>😅</b></z><z id="t1616775675" t="raymcdermott I have added a quick comment. Thanks for the feature"><y>#</y><d>2021-03-26</d><h>16:21</h><r>raymcdermott</r>I have added a quick comment. Thanks for the feature</z><z id="t1617002089" t="Yevgeni Tsodikov Awesome MR! Thanks 🙏"><y>#</y><d>2021-03-29</d><h>07:14</h><r>Yevgeni Tsodikov</r>Awesome MR! Thanks <b>🙏</b></z><z id="t1617014047" t="ikitommi merged in master"><y>#</y><d>2021-03-29</d><h>10:34</h><r>ikitommi</r>merged in master</z><z id="t1616793340" t="borkdude I&apos;m in the process of designing a task-executor DSL. Example: {:tasks {:clean [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}} I want to be able to give a task a description and possibly more options. So I thought I can do: {:tasks {:clean [:shell {:task/description &quot;foo&quot;} &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}} but this reads a bit weird, because I expect :shell to get shell-related options and not some general task options. One alternative I came up with: {:tasks {:clean ^{:task/description &quot;foo&quot;} [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}} A bit ugly maybe, but semantically correct: the metadata is about the task. However, processing EDN with metadata, it can be done, but it might lead to confusion. The other alternative, an explicit :task wrapper if you want to provide options: {:tasks {:clean [:task {:description &quot;foo&quot;} [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]]}} I wonder if you came across similar problems when designing malli, I&apos;d love to hear your feedback."><y>#</y><d>2021-03-26</d><h>21:15</h><w>borkdude</w>I&apos;m in the process of designing a task-executor DSL.
Example:
<code>{:tasks {:clean [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}}</code>
I want to be able to give a task a description and possibly more options. So I thought I can do:
<code>{:tasks {:clean [:shell {:task/description &quot;foo&quot;} &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}}</code>
but this reads a bit weird, because I expect <code>:shell</code> to get shell-related options and not some general task options.
One alternative I came up with:
<pre>{:tasks {:clean ^{:task/description &quot;foo&quot;} [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}}</pre>
A bit ugly maybe, but semantically correct: the metadata is about the task. However, processing EDN with metadata, it can be done, but it might lead to confusion.
The other alternative, an explicit <code>:task</code> wrapper if you want to provide options:
<pre>{:tasks {:clean [:task {:description &quot;foo&quot;} [:shell &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]]}}</pre>
I wonder if you came across similar problems when designing malli, I&apos;d love to hear your feedback.</z><z id="t1616793987" t="borkdude I think malli more or less ended up with: {:tasks {:clean [:shell {:description &quot;Clean all the things&quot;} &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}} right?"><y>#</y><d>2021-03-26</d><h>21:26</h><w>borkdude</w>I think malli more or less ended up with:
<pre>{:tasks {:clean [:shell {:description &quot;Clean all the things&quot;} &quot;rm&quot; &quot;-rf&quot; &quot;target&quot;]}}</pre>
right?</z><z id="t1616840975" t="borkdude I think I&apos;ll land on: {:tasks {:clean [:shell {:description &quot;foo&quot;} &quot;rm -rf target&quot;]}}"><y>#</y><d>2021-03-27</d><h>10:29</h><w>borkdude</w>I think I&apos;ll land on:
<pre>{:tasks {:clean [:shell {:description &quot;foo&quot;} &quot;rm -rf target&quot;]}}</pre></z><z id="t1616840985" t="borkdude thanks duckie :)"><y>#</y><d>2021-03-27</d><h>10:29</h><w>borkdude</w>thanks <b>duckie</b> :)</z><z id="t1616844961" t="Panel Just curious if you are using Malli to make the DSL ?"><y>#</y><d>2021-03-27</d><h>11:36</h><w>Panel</w>Just curious if you are using Malli to make the DSL ?</z><z id="t1616845039" t="borkdude not really no"><y>#</y><d>2021-03-27</d><h>11:37</h><w>borkdude</w>not really no</z><z id="t1616845328" t="borkdude although malli would probably be a good fit for validation"><y>#</y><d>2021-03-27</d><h>11:42</h><w>borkdude</w>although malli would probably be a good fit for validation</z><z id="t1616852086" t="borkdude Landed on this one: {:tasks {:clean {:description &quot;Foo&quot; :task [:shell &quot;rm -rf target&quot;]}}} "><y>#</y><d>2021-03-27</d><h>13:34</h><w>borkdude</w>Landed on this one:
<pre>{:tasks {:clean {:description &quot;Foo&quot; :task [:shell &quot;rm -rf target&quot;]}}}</pre>
</z><z id="t1616852105" t="borkdude Not hiccup as usual, but I think the cleanest so far"><y>#</y><d>2021-03-27</d><h>13:35</h><w>borkdude</w>Not hiccup as usual, but I think the cleanest so far</z><z id="t1616854628" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] looks good, I would have suggested a map too, keeps the concepts separated."><y>#</y><d>2021-03-27</d><h>14:17</h><w>ikitommi</w><a>@borkdude</a> looks good, I would have suggested a map too, keeps the concepts separated.</z><z id="t1616854712" t="ikitommi Malli also has the generic map-syntax and have explored a third, simpler (clj-fx-like) map-syntax."><y>#</y><d>2021-03-27</d><h>14:18</h><w>ikitommi</w>Malli also has the generic map-syntax and have explored a third, simpler (clj-fx-like) map-syntax.</z><z id="t1616854983" t="ikitommi Need to pick a &quot;better&quot; map-syntax for malli 1.0.0, but will be first-class support, in malli.core . One can&apos;t mix syntaxes (terse/hiccup and map) freely, just one allowed per AST fragment."><y>#</y><d>2021-03-27</d><h>14:23</h><w>ikitommi</w>Need to pick a &quot;better&quot; map-syntax for malli 1.0.0, but will be first-class support, in <code>malli.core</code>.  One can&apos;t mix syntaxes (terse/hiccup and map) freely, just one allowed per AST fragment.</z><z id="t1616857013" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] what is clj-fx-like map syntax? would love to see it"><y>#</y><d>2021-03-27</d><h>14:56</h><w>borkdude</w><a>@ikitommi</a> what is clj-fx-like map syntax? would love to see it</z><z id="t1616993894" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] wrote an issue of the syntax, with examples: https://github.com/metosin/malli/issues/406"><y>#</y><d>2021-03-29</d><h>04:58</h><w>ikitommi</w><a>@borkdude</a> wrote an issue of the syntax, with examples: <a href="https://github.com/metosin/malli/issues/406" target="_blank">https://github.com/metosin/malli/issues/406</a></z><z id="t1617088960" t="Adam Helins Is there a way of generating sorted maps using :map-of ? Spec allows that and it is indeed very useful when working with sorted colls."><y>#</y><d>2021-03-30</d><h>07:22</h><w>Adam Helins</w>Is there a way of generating sorted maps using <code>:map-of</code> ? Spec allows that and it is indeed very useful when working with sorted colls.</z><z id="t1617114767" t="nilern I don&apos;t think there is any support for sorted colls specifically"><y>#</y><d>2021-03-30</d><h>14:32</h><r>nilern</r>I don&apos;t think there is any support for sorted colls specifically</z><z id="t1617132253" t="Adam Helins Interesting, i can&apos;t find anything, no issue, nothing in the codebase..."><y>#</y><d>2021-03-30</d><h>19:24</h><r>Adam Helins</r>Interesting, i can&apos;t find anything, no issue, nothing in the codebase...</z><z id="t1617267511" t="nilern It never comes up in input validation and our DbC story is not really there yet. Whereas Spec was basically created for DbC and third party tools are needed for most other things."><y>#</y><d>2021-04-01</d><h>08:58</h><r>nilern</r>It never comes up in input validation and our DbC story is not really there yet. Whereas Spec was basically created for DbC and third party tools are needed for most other things.</z><z id="t1617109978" t="Adam Helins Hmmm, took me a while to realise that was a source of error and I cannot seem to find how to merge such maps: [:merge [:map [:a :int]] [:and [:map [:b int]] [:fn some-pred]]] The problem is that the second map is enclosed by [:and] , and Malli doesn&apos;t seem to understand that it is ultimately a map, meaning that :merge does not behave like it is merging 2 maps. How can I merge them while keeping that custom predicate?"><y>#</y><d>2021-03-30</d><h>13:12</h><w>Adam Helins</w>Hmmm, took me a while to realise that was a source of error and I cannot seem to find how to merge such maps:

<pre>[:merge
 [:map [:a :int]]
 [:and
  [:map [:b int]]
  [:fn some-pred]]]</pre>
The problem is that the second map is enclosed by <code>[:and]</code> , and Malli doesn&apos;t seem to understand that it is ultimately a map, meaning that <code>:merge</code> does not behave like it is merging 2 maps.

How can I merge them while keeping that custom predicate?</z><z id="t1617114659" t="nilern https://github.com/metosin/malli/pull/405 (but still unreleased)"><y>#</y><d>2021-03-30</d><h>14:30</h><r>nilern</r><a href="https://github.com/metosin/malli/pull/405" target="_blank">https://github.com/metosin/malli/pull/405</a> (but still unreleased)</z><z id="t1617132031" t="Adam Helins Excellent, once again [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] saves the day"><y>#</y><d>2021-03-30</d><h>19:20</h><r>Adam Helins</r>Excellent, once again <a>@U055NJ5CC</a> saves the day</z><z id="t1617198387" t="ikitommi shipped in 0.4.0 now"><y>#</y><d>2021-03-31</d><h>13:46</h><r>ikitommi</r>shipped in 0.4.0 now</z><z id="t1617168204" t="valerauko After seeing the #Performance section of malli&apos;s readme I&apos;m quite interested in trying it out. One thing I was wondering is how it fares at compile-time? I&apos;m just assuming that it achieves high runtime speed by offloading as much as possible to macros. Are there any numbers how this affects eg lein startup time?"><y>#</y><d>2021-03-31</d><h>05:23</h><w>valerauko</w>After seeing the #Performance section of malli&apos;s readme I&apos;m quite interested in trying it out. One thing I was wondering is how it fares at compile-time? I&apos;m just assuming that it achieves high runtime speed by offloading as much as possible to macros. Are there any numbers how this affects eg lein startup time?</z><z id="t1617168552" t="ikitommi [:attrs {:href &quot;/_/_/users/UAEH11THP&quot;}] good question. There are no macros in malli (ok, one mandatory). the “schema compile time” is at runtime, you can have a separate step to create an immutable &amp; optimized validator/transformer/parser and reuse that."><y>#</y><d>2021-03-31</d><h>05:29</h><w>ikitommi</w><a>@vale</a> good question. There are no macros in malli (ok, one mandatory). the “schema compile time” is at runtime, you can have a separate step to create an immutable &amp; optimized validator/transformer/parser and reuse that.</z><z id="t1617168641" t="ikitommi in many cases, even without reuse, it’s still faster than with alternatives, e.g. with spec / spec-tools - one-shot “gimme a validator, use it once and forget it”."><y>#</y><d>2021-03-31</d><h>05:30</h><w>ikitommi</w>in many cases, even without reuse, it’s still faster than with alternatives, e.g. with spec / spec-tools - one-shot “gimme a validator, use it once and forget it”.</z><z id="t1617178299" t="valerauko awesome, time to dive in then! thanks for the great work!"><y>#</y><d>2021-03-31</d><h>08:11</h><r>valerauko</r>awesome, time to dive in then! thanks for the great work!</z><z id="t1617168756" t="ikitommi malli.core (without sci) should load under 1sec from source and 0.1sec from classes."><y>#</y><d>2021-03-31</d><h>05:32</h><w>ikitommi</w>malli.core (without sci) should load under 1sec from source and 0.1sec from classes.</z><z id="t1617168897" t="ikitommi (= int? (m/validator [:and int? int? [:and int? [:and int?]]])) ; =&gt; true"><y>#</y><d>2021-03-31</d><h>05:34</h><w>ikitommi</w><pre>(= int? (m/validator [:and int? int? [:and int? [:and int?]]]))
; =&gt; true</pre></z><z id="t1617169600" t="ikitommi (= identity (m/decoder [:map [:id :int] [:name :string] [:tags [:vector :string]]] (mt/json-transformer))) ; =&gt; true"><y>#</y><d>2021-03-31</d><h>05:46</h><w>ikitommi</w><pre>(= identity
   (m/decoder
     [:map
      [:id :int]
      [:name :string]
      [:tags [:vector :string]]]
     (mt/json-transformer)))
; =&gt; true</pre></z><z id="t1617175456" t="robert-stuttaford was hoping that humanize would use language like &apos;at least one string? is required&apos; here, but instead, i get &quot;unknown error&quot;. am i doing it wrong, or is this a TODO for humanize? (m/explain [:sequential {:min 1} string?] ()) ;; {:schema [:sequential {:min 1} string?] ;; :value () ;; :errors (#Error{:path [] ;; :in [] ;; :schema [:sequential {:min 1} string?] ;; :value () ;; :type :malli.core/limits})} (-&gt; (m/explain [:sequential {:min 1} string?] ()) me/humanize) ;; [&quot;unknown error&quot;]"><y>#</y><d>2021-03-31</d><h>07:24</h><w>robert-stuttaford</w>was hoping that humanize would use language like &apos;at least one <code>string?</code> is required&apos; here, but instead, i get &quot;unknown error&quot;. am i doing it wrong, or is this a TODO for humanize?
<pre>(m/explain [:sequential {:min 1} string?] ())

  ;; {:schema [:sequential {:min 1} string?]
  ;;  :value  ()
  ;;  :errors (#Error{:path   []
  ;;                  :in     []
  ;;                  :schema [:sequential {:min 1} string?]
  ;;                  :value  ()
  ;;                  :type   :malli.core/limits})}

  (-&gt; (m/explain [:sequential {:min 1} string?] ())
      me/humanize)

  ;; [&quot;unknown error&quot;]</pre></z><z id="t1617176772" t="ikitommi [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] just missing an error mapping for :malli.core/limits . PR welcome to malli.error ."><y>#</y><d>2021-03-31</d><h>07:46</h><w>ikitommi</w><a>@robert-stuttaford</a> just missing an error mapping for <code>:malli.core/limits</code>. PR welcome to <code>malli.error</code>.</z><z id="t1617176808" t="ikitommi you can also play with the mappings by passing them into me/humanize : (-&gt; (m/explain [:sequential {:min 1} string?] ()) (me/humanize {:errors {::m/limits {:error/message {:en &quot;there&apos;s no limits&quot;}}}})) ; =&gt; [&quot;there&apos;s no limits&quot;]"><y>#</y><d>2021-03-31</d><h>07:46</h><w>ikitommi</w>you can also play with the mappings by passing them into <code>me/humanize</code>:
<pre>(-&gt; (m/explain [:sequential {:min 1} string?] ())
    (me/humanize {:errors {::m/limits {:error/message {:en &quot;there&apos;s no limits&quot;}}}}))
; =&gt; [&quot;there&apos;s no limits&quot;]</pre></z><z id="t1617177165" t="ikitommi uncomplete, but close: (defn min-max-sequence-error-message [error options] (str ((me/-pred-min-max-error-fn {:pred identity}) error options) &quot; elements&quot;)) (-&gt; (m/explain [:sequential {:min 1} string?] ()) (me/humanize {:errors {::m/limits {:error/fn {:en min-max-sequence-error-message}}}})) ; =&gt; [&quot;should be at least 1 elements&quot;]"><y>#</y><d>2021-03-31</d><h>07:52</h><w>ikitommi</w>uncomplete, but close:
<pre>(defn min-max-sequence-error-message [error options]
  (str ((me/-pred-min-max-error-fn {:pred identity}) error options) &quot; elements&quot;))

(-&gt; (m/explain [:sequential {:min 1} string?] ())
    (me/humanize {:errors {::m/limits {:error/fn {:en min-max-sequence-error-message}}}}))
; =&gt; [&quot;should be at least 1 elements&quot;]</pre></z><z id="t1617177945" t="Adam Helins The following scheme systematically produces a stack overflow. It is a recursive definition where one item (`:E`) contains another item (which might be :E as well, or not). I am surprised this stack overflow is that systematic. There must be something wrong somewhere unless I am missing the obvious. Tried with :or instead of :multi , same thing. (def registry {:A [:tuple [:= :A]] :B [:tuple [:= :B]] :C [:tuple [:= :C]] :D [:tuple [:= :D]] :E [:tuple [:= :E] :item] :item [:multi {:dispatch first} [:A :A] [:B :B] [:C :C] [:D :D] [:E :E]]}) (malli.gen/generate [:schema {:registry registry} :item])"><y>#</y><d>2021-03-31</d><h>08:05</h><w>Adam Helins</w>The following scheme systematically produces a stack overflow. It is a recursive definition where one item (`:E`) contains another item (which might be <code>:E</code> as well, or not).

I am surprised this stack overflow is that systematic. There must be something wrong somewhere unless I am missing the obvious. Tried with <code>:or</code> instead of <code>:multi</code>, same thing.

<pre>(def registry
     {:A    [:tuple [:= :A]]
      :B    [:tuple [:= :B]]
      :C    [:tuple [:= :C]]
      :D    [:tuple [:= :D]]
      :E    [:tuple
             [:= :E]
             :item]
      :item [:multi
             {:dispatch first}
             [:A :A]
             [:B :B]
             [:C :C]
             [:D :D]
             [:E :E]]})


(malli.gen/generate [:schema
                     {:registry registry}
                     :item])</pre></z><z id="t1617265988" t="nilern There was https://github.com/metosin/malli/issues/359 also"><y>#</y><d>2021-04-01</d><h>08:33</h><r>nilern</r>There was <a href="https://github.com/metosin/malli/issues/359" target="_blank">https://github.com/metosin/malli/issues/359</a> also</z><z id="t1617178025" t="Adam Helins Execution error (StackOverflowError) at malli.core/-schema (core.cljc:242)."><y>#</y><d>2021-03-31</d><h>08:07</h><w>Adam Helins</w><pre>Execution error (StackOverflowError) at malli.core/-schema (core.cljc:242).</pre></z><z id="t1617178279" t="Adam Helins Validation results in the same, I probably should open an issue actually"><y>#</y><d>2021-03-31</d><h>08:11</h><w>Adam Helins</w>Validation results in the same, I probably should open an issue actually</z><z id="t1617178299" t="valerauko awesome, time to dive in then! thanks for the great work!"><y>#</y><d>2021-03-31</d><h>08:11</h><w>valerauko</w>awesome, time to dive in then! thanks for the great work!</z><z id="t1617179531" t="ikitommi [:attrs {:href &quot;/_/_/users/UCFG3SDFV&quot;}] would [:ref :item] work? It&apos;s a lazy reference type"><y>#</y><d>2021-03-31</d><h>08:32</h><w>ikitommi</w><a>@adam678</a> would <code>[:ref :item]</code> work? It&apos;s a lazy reference type</z><z id="t1617180001" t="Adam Helins In the :E definition? Such as: [:tuple [:= :E] [:ref :item]] I&apos;ve tried it different ways but get an exception: :malli.core/invalid-ref {:ref :item} Sorry, seems I didn&apos;t drink enough coffee today 😅"><y>#</y><d>2021-03-31</d><h>08:40</h><r>Adam Helins</r>In the <code>:E</code> definition? Such as:
<pre>[:tuple
 [:= :E]
 [:ref :item]]</pre>
I&apos;ve tried it different ways but get an exception: <code>:malli.core/invalid-ref {:ref :item}</code>

Sorry, seems I didn&apos;t drink enough coffee today <b>😅</b></z><z id="t1617180119" t="Adam Helins Right, refs must be namespaced..."><y>#</y><d>2021-03-31</d><h>08:41</h><r>Adam Helins</r>Right, refs must be namespaced...</z><z id="t1617181821" t="Adam Helins [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] However, there is still something wrong with generation. Adding another recursive item makes things very slow (eg. 2-3 seconds for generating something like [:E [:E [:A]]] . Adding a third recursive item makes things so slow that my fans are churning and after a couple of minutes there still isn&apos;t any result."><y>#</y><d>2021-03-31</d><h>09:10</h><r>Adam Helins</r><a>@ikitommi</a> However, there is still something wrong with generation. Adding another recursive item makes things very slow (eg. 2-3 seconds for generating something like <code>[:E [:E [:A]]]</code>.

Adding a third recursive item makes things so slow that my fans are churning and after a couple of minutes there still isn&apos;t any result.</z><z id="t1617182795" t="ikitommi please write an issue, malli should lean on https://github.com/clojure/test.check/blob/master/doc/intro.md#recursive-generators , but it does not."><y>#</y><d>2021-03-31</d><h>09:26</h><r>ikitommi</r>please write an issue, malli should lean on <a href="https://github.com/clojure/test.check/blob/master/doc/intro.md#recursive-generators" target="_blank">https://github.com/clojure/test.check/blob/master/doc/intro.md#recursive-generators</a>, but it does not.</z><z id="t1617183934" t="Adam Helins I did: https://github.com/metosin/malli/issues/408 I hope I am not spamming. It&apos;s just I don&apos;t quite remember having that sort of problems with Spec so I am having a bit of a hard time working with that. Not complaining though, so far using Malli has been very comfortable!"><y>#</y><d>2021-03-31</d><h>09:45</h><r>Adam Helins</r>I did: <a href="https://github.com/metosin/malli/issues/408" target="_blank">https://github.com/metosin/malli/issues/408</a>

I hope I am not spamming. It&apos;s just I don&apos;t quite remember having that sort of problems with Spec so I am having a bit of a hard time working with that.

Not complaining though, so far using Malli has been very comfortable!</z><z id="t1617264125" t="ikitommi how about lazy generators? https://github.com/metosin/malli/pull/409"><y>#</y><d>2021-04-01</d><h>08:02</h><r>ikitommi</r>how about lazy generators? <a href="https://github.com/metosin/malli/pull/409" target="_blank">https://github.com/metosin/malli/pull/409</a></z><z id="t1617179601" t="ikitommi there is no recursion detection for eager references."><y>#</y><d>2021-03-31</d><h>08:33</h><w>ikitommi</w>there is no recursion detection for eager references.</z><z id="t1617179697" t="ikitommi I Think StackOverflow is a correct way to fail here"><y>#</y><d>2021-03-31</d><h>08:34</h><r>ikitommi</r>I Think StackOverflow is a correct way to fail here</z><z id="t1617266114" t="nilern It makes sense but does leave something to be desired"><y>#</y><d>2021-04-01</d><h>08:35</h><r>nilern</r>It makes sense but does leave something to be desired</z><z id="t1617181096" t="fugbix Greetings everyone!! Thank so much for this super neat lib, really cool and useful. I have a bit of an issue, whereby requiring malli.core triggers a ClassNotFoundException: nREPL server started on port 55188 on host 127.0.0.1 - REPL-y 0.4.4, nREPL 0.8.3 Clojure 1.10.3 Java HotSpot(TM) 64-Bit Server VM 11.0.9+7-LTS Docs: (doc function-name-here) (find-doc &quot;part-of-name-here&quot;) Source: (source function-name-here) Javadoc: (javadoc java-object-or-class-here) Exit: Control+D or (exit) or (quit) Results: Stored in vars *1, *2, *3, an exception in *e user=&gt; (require &apos;[malli.core :as m]) Execution error (ClassNotFoundException) at java.net.URLClassLoader/findClass (URLClassLoader.java:471). malli.impl.util.SchemaError user=&gt; my project is leiningen and includes many dependencies (including borkdude/sci because I am using multi dispatching, Datomic, Kafka etc). I am using the latest version of malli (`metosin/malli &quot;0.3.1&quot;`), Of course using malli from a toy lean leiningen project works perfectly fine. Although not a Clojure expert, I’ve never seen something similar. And I really can’t imagine why malli.impl.util doesn’t load? Any help would me much appreciated, I’ll keep digging!"><y>#</y><d>2021-03-31</d><h>08:58</h><w>fugbix</w>Greetings everyone!! Thank so much for this super neat lib, really cool and useful.
I have a bit of an issue, whereby requiring <code>malli.core</code> triggers a ClassNotFoundException:
<pre>nREPL server started on port 55188 on host 127.0.0.1 - 
REPL-y 0.4.4, nREPL 0.8.3
Clojure 1.10.3
Java HotSpot(TM) 64-Bit Server VM 11.0.9+7-LTS
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt; (require &apos;[malli.core :as m])
Execution error (ClassNotFoundException) at java.net.URLClassLoader/findClass (URLClassLoader.java:471).
malli.impl.util.SchemaError

user=&gt;</pre>
my project is leiningen and includes many dependencies (including <code>borkdude/sci</code> because I am using multi dispatching,  Datomic, Kafka etc). I am using the latest version of malli (`metosin/malli &quot;0.3.1&quot;`),  Of course using malli from a toy lean leiningen project works perfectly fine.
Although not a Clojure expert, I’ve never seen something similar. And I really can’t imagine why  <code>malli.impl.util</code>  doesn’t  load?
Any help would me much appreciated, I’ll keep digging!</z><z id="t1617266430" t="nilern No idea, I don&apos;t see anything nonstandard going on there"><y>#</y><d>2021-04-01</d><h>08:40</h><r>nilern</r>No idea, I don&apos;t see anything nonstandard going on there</z><z id="t1617281115" t="fugbix Thank you [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] I have removed my target directory and everything’s fine now. Of course I would love to understand what brought it in this state, but I’ll carry on with work for now. Sorry for the fuss, and thanks again for that wicked malli lib, absolutely loving it."><y>#</y><d>2021-04-01</d><h>12:45</h><r>fugbix</r>Thank you <a>@U4MB6UKDL</a> I have removed my <code>target</code> directory and everything’s fine now. Of course I would love to understand what brought it in this state, but I’ll carry on with work for now.  Sorry for the fuss, and thanks again for that wicked <code>malli</code> lib, absolutely loving it.</z><z id="t1617181718" t="robert-stuttaford wonderful thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2021-03-31</d><h>09:08</h><w>robert-stuttaford</w>wonderful thank you <a>@ikitommi</a>!</z><z id="t1617182774" t="dharrigan A little while ago, there was a conversation about stripping nulls from the return back to the client"><y>#</y><d>2021-03-31</d><h>09:26</h><w>dharrigan</w>A little while ago, there was a conversation about stripping nulls from the return back to the client</z><z id="t1617182794" t="dharrigan hjmmm...let me think a bit more..."><y>#</y><d>2021-03-31</d><h>09:26</h><w>dharrigan</w>hjmmm...let me think a bit more...</z><z id="t1617183752" t="dharrigan So, okay, I&apos;m doing this in the setup of the ring/router"><y>#</y><d>2021-03-31</d><h>09:42</h><w>dharrigan</w>So, okay, I&apos;m doing this in the setup of the <code>ring/router</code></z><z id="t1617183755" t="dharrigan :muuntaja (m/create (assoc-in m/default-options [:formats &quot;application/json&quot; :opts] {:mapper (-&gt; (j/object-mapper) (.setSerializationInclusion JsonInclude$Include/NON_EMPTY))}))"><y>#</y><d>2021-03-31</d><h>09:42</h><w>dharrigan</w><pre>:muuntaja (m/create
                      (assoc-in m/default-options
                                [:formats &quot;application/json&quot; :opts]
                                {:mapper (-&gt; (j/object-mapper)
                                             (.setSerializationInclusion JsonInclude$Include/NON_EMPTY))}))</pre></z><z id="t1617183787" t="dharrigan Following throught the code, I believe I&apos;m handed back an instance of the ObjectMapper from jsonista.core when I then set that option"><y>#</y><d>2021-03-31</d><h>09:43</h><w>dharrigan</w>Following throught the code, I believe I&apos;m handed back an instance of the ObjectMapper from <code>jsonista.core</code> when I then set that option</z><z id="t1617183808" t="dharrigan the thing is, if I do this (now!), then all of my coercion fails (using malli)"><y>#</y><d>2021-03-31</d><h>09:43</h><w>dharrigan</w>the thing is, if I do this (now!), then all of my coercion fails (using malli)</z><z id="t1617183824" t="dharrigan i.e.,"><y>#</y><d>2021-03-31</d><h>09:43</h><w>dharrigan</w>i.e.,</z><z id="t1617183834" t="dharrigan &quot;coercion&quot;: &quot;malli&quot;, &quot;errors&quot;: [ { &quot;in&quot;: [ &quot;repId&quot; ], &quot;message&quot;: &quot;missing required key&quot;, &quot;path&quot;: [ &quot;repId&quot; ], .... ...."><y>#</y><d>2021-03-31</d><h>09:43</h><w>dharrigan</w><pre>&quot;coercion&quot;: &quot;malli&quot;,
    &quot;errors&quot;: [
        {
            &quot;in&quot;: [
                &quot;repId&quot;
            ],
            &quot;message&quot;: &quot;missing required key&quot;,
            &quot;path&quot;: [
                &quot;repId&quot;
            ],
....
....</pre></z><z id="t1617183857" t="dharrigan if I put it back to :muuntaja m/instance , then all is well with the world"><y>#</y><d>2021-03-31</d><h>09:44</h><w>dharrigan</w>if I put it back to <code>:muuntaja m/instance</code>, then all is well with the world</z><z id="t1617183888" t="dharrigan I&apos;m a bit lost as to why it fails"><y>#</y><d>2021-03-31</d><h>09:44</h><w>dharrigan</w>I&apos;m a bit lost as to why it fails</z><z id="t1617183924" t="dharrigan it feels like it&apos;s not able to parse the incoming JSON data from the request"><y>#</y><d>2021-03-31</d><h>09:45</h><w>dharrigan</w>it feels like it&apos;s not able to parse the incoming JSON data from the request</z><z id="t1617187065" t="dharrigan I realise this is in the wrong channel (maybe I should put into #reitit)"><y>#</y><d>2021-03-31</d><h>10:37</h><w>dharrigan</w>I realise this is in the wrong channel (maybe I should put into #reitit)</z><z id="t1617198341" t="ikitommi pushed out [metosin/malli &quot;0.4.0&quot;] . It’s a new MINOR as the :multi parse is changed (fixed) and leaning on the old (broken) code can break someone. https://cljdoc.org/d/metosin/malli/0.4.0/doc/changelog"><y>#</y><d>2021-03-31</d><h>13:45</h><w>ikitommi</w>pushed out <code>[metosin/malli &quot;0.4.0&quot;]</code>. It’s a new MINOR as the <code>:multi</code> parse is changed (fixed) and leaning on the old (broken) code can break someone. <a href="https://cljdoc.org/d/metosin/malli/0.4.0/doc/changelog" target="_blank">https://cljdoc.org/d/metosin/malli/0.4.0/doc/changelog</a></z><z id="t1617265988" t="nilern There was https://github.com/metosin/malli/issues/359 also"><y>#</y><d>2021-04-01</d><h>08:33</h><w>nilern</w>There was <a href="https://github.com/metosin/malli/issues/359" target="_blank">https://github.com/metosin/malli/issues/359</a> also</z><z id="t1617265199" t="ikitommi Welcome lazy generators! recursive generators are now orders of magnitude faster, ping [:attrs {:href &quot;/_/_/users/UCFG3SDFV&quot;}] (time (let [schema [:schema {:registry {::A [:tuple [:= :A]] ::B [:tuple [:= :B]] ::C [:tuple [:= :C]] ::D [:tuple [:= :D]] ::E [:tuple [:= :E] [:ref ::item]] ::F [:tuple [:= :F] [:ref ::item]] ::G [:tuple [:= :G] [:ref ::item]] ::item [:multi {:dispatch first} [:A ::A] [:B ::B] [:C ::C] [:D ::D] [:E ::E] [:F ::F] [:G ::G]]}} ::E] valid? (m/validator schema)] (is (every? valid? (mg/sample schema {:size 10000}))))) ; =&gt; &quot;Elapsed time: 230 msecs&quot;"><y>#</y><d>2021-04-01</d><h>08:19</h><w>ikitommi</w>Welcome lazy generators! recursive generators are now orders of magnitude faster, ping <a>@adam678</a>
<pre>(time
  (let [schema [:schema {:registry {::A [:tuple [:= :A]]
                                    ::B [:tuple [:= :B]]
                                    ::C [:tuple [:= :C]]
                                    ::D [:tuple [:= :D]]
                                    ::E [:tuple [:= :E] [:ref ::item]]
                                    ::F [:tuple [:= :F] [:ref ::item]]
                                    ::G [:tuple [:= :G] [:ref ::item]]
                                    ::item [:multi {:dispatch first}
                                            [:A ::A]
                                            [:B ::B]
                                            [:C ::C]
                                            [:D ::D]
                                            [:E ::E]
                                            [:F ::F]
                                            [:G ::G]]}}
                ::E]
        valid? (m/validator schema)]
    (is (every? valid? (mg/sample schema {:size 10000})))))
; =&gt; &quot;Elapsed time: 230 msecs&quot;</pre></z><z id="t1617265655" t="Adam Helins That was fast! Just tested it with my real world example and it seems to work just perfectly. (Generating WASM instructions where an instruction may contain a list of instructions). Thanks a lot!"><y>#</y><d>2021-04-01</d><h>08:27</h><r>Adam Helins</r>That was fast! Just tested it with my real world example and it seems to work just perfectly. (Generating WASM instructions where an instruction may contain a list of instructions).

Thanks a lot!</z><z id="t1617349442" t="Adam Helins I am wondering how Malli is performing in an inheritance-like scenario. Essentially, Malli allows keys to be :optional in :map . This is about having whole sets of keys being optional, in an all-or-none fashion, such as: (def AnimalBase [:map ...]) (def Cat [:merge AnimalBase [:map ...]]) (def Dog [:merge AnimalBase [:map ...]]) (def Animal (m/schema [:multi {:dispatch :type-or-something} :cat Cat :dog Dog])) Does it leverage the fact that the AnimalBase schema is mandatory in all dispatched schemas? Is there maybe an already existing better way of representing inheritance? Also assuming that being able to use generation is mandatory."><y>#</y><d>2021-04-02</d><h>07:44</h><w>Adam Helins</w>I am wondering how Malli is performing in an inheritance-like scenario. Essentially, Malli allows keys to be <code>:optional</code> in <code>:map</code> . This is about having whole sets of keys being optional, in an all-or-none fashion, such as:

<pre>(def AnimalBase
     [:map ...])

(def Cat
     [:merge
      AnimalBase
      [:map ...]])

(def Dog
     [:merge
      AnimalBase
      [:map ...]])

(def Animal
     (m/schema [:multi {:dispatch :type-or-something} :cat Cat :dog Dog]))</pre>
Does it leverage the fact that the <code>AnimalBase</code> schema is mandatory in all dispatched schemas?

Is there maybe an already existing better way of representing inheritance? Also assuming that being able to use generation is mandatory.</z><z id="t1617350964" t="juhoteperi :merge with two map schemas creates a new map schema with keys from both schemas, so Cat and Dog don&apos;t refer to AnimalBase but are instead just map schemas with properties from the inputs"><y>#</y><d>2021-04-02</d><h>08:09</h><r>juhoteperi</r><code>:merge</code> with two map schemas creates a new map schema with keys from both schemas, so Cat and Dog don&apos;t refer to AnimalBase but are instead just map schemas with properties from the inputs</z><z id="t1617350994" t="juhoteperi Or hmph, I might be confusing it with malli.util/merge ... not sure if this works similarly"><y>#</y><d>2021-04-02</d><h>08:09</h><r>juhoteperi</r>Or hmph, I might be confusing it with <code>malli.util/merge</code>... not sure if this works similarly</z><z id="t1617351173" t="juhoteperi :merge should same as malli.util/merge"><y>#</y><d>2021-04-02</d><h>08:12</h><r>juhoteperi</r><code>:merge</code> should same as <code>malli.util/merge</code></z><z id="t1617351178" t="juhoteperi https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L401"><y>#</y><d>2021-04-02</d><h>08:12</h><r>juhoteperi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L401" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L401</a></z><z id="t1617351182" t="Adam Helins I believe malli.util/merge is indeed eager in that sense (creating a new map schema and forgetting about AnimalBase ). But theoretically, since this example relies on data and :merge , that :multi schema could deduce that all dispatched schemas are maps that could have a common set of keys. But it is just the most straightforward way of representing single inheritance IMO, maybe there is something better."><y>#</y><d>2021-04-02</d><h>08:13</h><r>Adam Helins</r>I believe <code>malli.util/merge</code> is indeed eager in that sense (creating a new map schema and forgetting about <code>AnimalBase</code>). But theoretically, since this example relies on data and <code>:merge</code>, that <code>:multi</code>schema could deduce that all dispatched schemas are maps that could have a common set of keys.

But it is just the most straightforward way of representing single inheritance IMO, maybe there is something better.</z><z id="t1617352500" t="Adam Helins Sorry I realized my example was a bit misleading so I deleted it so it doesn&apos;t spam the channel. I&apos;ll work more on this and try to come back with a real-world one."><y>#</y><d>2021-04-02</d><h>08:35</h><r>Adam Helins</r>Sorry I realized my example was a bit misleading so I deleted it so it doesn&apos;t spam the channel. I&apos;ll work more on this and try to come back with a real-world one.</z><z id="t1617447348" t="Setzer22 Hi there! At our startup we&apos;re considering moving from spec to malli for our next project. I&apos;m particularly excited about the clj-kondo integration support. Is there somewhere I could read more about it? Perhaps some of you using it? Did anyone integrate this into their repl/editor workflow (so that annotations are regenerated every time a new schema definition is made)? I&apos;d also like to know how &quot;deep&quot; the static analysis goes. Is it just for elemental types like int or string? Or does the malli+clj-kondo combination understand your own compound types to some degree?"><y>#</y><d>2021-04-03</d><h>10:55</h><w>Setzer22</w>Hi there! At our startup we&apos;re considering moving from spec to malli for our next project. I&apos;m particularly excited about the clj-kondo integration support. Is there somewhere I could read more about it? Perhaps some of you using it? Did anyone integrate this into their repl/editor workflow (so that annotations are regenerated every time a new schema definition is made)? I&apos;d also like to know how &quot;deep&quot; the static analysis goes. Is it just for elemental types like int or string? Or does the malli+clj-kondo combination understand your own compound types to some degree?</z><z id="t1617621879" t="ikitommi https://twitter.com/puredanger/status/1378850899091578881"><y>#</y><d>2021-04-05</d><h>11:24</h><w>ikitommi</w><a href="https://twitter.com/puredanger/status/1378850899091578881" target="_blank">https://twitter.com/puredanger/status/1378850899091578881</a></z><z id="t1617630894" t="emccue Relevant to the above, it feels like you could make spec out of malli but not the other way around"><y>#</y><d>2021-04-05</d><h>13:54</h><w>emccue</w>Relevant to the above, it feels like you could make spec out of malli but not the other way around</z><z id="t1617646860" t="nilern There is more in the box for sure. On the other hand it&apos;s good that Spec does not have all that because it is in core"><y>#</y><d>2021-04-05</d><h>18:21</h><w>nilern</w>There is more in the box for sure. On the other hand it&apos;s good that Spec does not have all that because it is in core</z><z id="t1617647889" t="emccue How much of that &quot;in the box&quot;-ness is just about having a single maven artifact and how much is actual interdependency though?"><y>#</y><d>2021-04-05</d><h>18:38</h><w>emccue</w>How much of that &quot;in the box&quot;-ness is just about having a single maven artifact and how much is actual interdependency though?</z><z id="t1617649229" t="nilern At least in theory we could just have the schema introspection and everything else could use that and live in separate jars"><y>#</y><d>2021-04-05</d><h>19:00</h><w>nilern</w>At least in theory we could just have the schema introspection and everything else could use that and live in separate jars</z><z id="t1617649328" t="nilern But currently there is a monolithic schema protocol which does set a lower bound on the box size"><y>#</y><d>2021-04-05</d><h>19:02</h><w>nilern</w>But currently there is a monolithic schema protocol which does set a lower bound on the box size</z><z id="t1617649518" t="nilern See also https://clojure.atlassian.net/browse/CLJ-2251 but I recall Tommi saying that walking Specs would still be janky"><y>#</y><d>2021-04-05</d><h>19:05</h><w>nilern</w>See also <a href="https://clojure.atlassian.net/browse/CLJ-2251" target="_blank">https://clojure.atlassian.net/browse/CLJ-2251</a> but I recall Tommi saying that walking Specs would still be janky</z><z id="t1617650443" t="marciol There is spec/visitor in spec-tools [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] . I think that the real problem is that it&apos;s impossible to decode serialized specs in runtime."><y>#</y><d>2021-04-05</d><h>19:20</h><w>marciol</w>There is <code>spec/visitor</code> in spec-tools <a>@nilern</a>. I think that the real problem is that it&apos;s impossible to decode serialized specs in runtime.</z><z id="t1617650497" t="marciol You can go only one way without a proper way to reverse"><y>#</y><d>2021-04-05</d><h>19:21</h><w>marciol</w>You can go only one way without a proper way to reverse</z><z id="t1617650963" t="nilern Yes the ticket mentions spec-tools and various details that I know little about since i never touched spec-tools"><y>#</y><d>2021-04-05</d><h>19:29</h><w>nilern</w>Yes the ticket mentions spec-tools and various details that I know little about since i never touched spec-tools</z><z id="t1617727701" t="ribelo Is it possible to create a key in a map using decode ?"><y>#</y><d>2021-04-06</d><h>16:48</h><w>ribelo</w>Is it possible to create a key in a map using <code>decode</code>?</z><z id="t1617727761" t="ribelo something like {:a 1 :b 2} =&gt; {:c 3}"><y>#</y><d>2021-04-06</d><h>16:49</h><w>ribelo</w>something like <code>{:a 1 :b 2} =&gt; {:c 3}</code></z><z id="t1617730074" t="nilern Sure it is"><y>#</y><d>2021-04-06</d><h>17:27</h><w>nilern</w>Sure it is</z><z id="t1617730318" t="nilern (m/decode [:map {:decode/abc (fn [m] (if (and (map? m) (contains? m :a) (contains? m :b)) (-&gt; m (dissoc :a :b) (assoc :c (+ (:a m) (:b m)))) m))} [:a :int] [:b :int]] {:a 1, :b 2} (mt/transformer {:name :abc})) =&gt; {:c 3}"><y>#</y><d>2021-04-06</d><h>17:31</h><w>nilern</w><pre>(m/decode [:map {:decode/abc (fn [m]
                               (if (and (map? m) (contains? m :a) (contains? m :b))
                                 (-&gt; m
                                     (dissoc :a :b)
                                     (assoc :c (+ (:a m) (:b m))))
                                 m))}
           [:a :int] [:b :int]]
          {:a 1, :b 2}
          (mt/transformer {:name :abc}))
=&gt; {:c 3}</pre></z><z id="t1617730460" t="nilern https://github.com/metosin/malli#value-transformation does have this info although the explanations are a bit sparse"><y>#</y><d>2021-04-06</d><h>17:34</h><w>nilern</w><a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a> does have this info although the explanations are a bit sparse</z><z id="t1617732434" t="ribelo I&apos;ve read it, but somehow it didn&apos;t occur to me that I could use decode/encode on the whole map and not on an individual key"><y>#</y><d>2021-04-06</d><h>18:07</h><w>ribelo</w>I&apos;ve read it, but somehow it didn&apos;t occur to me that I could use decode/encode on the whole map and not on an individual key</z><z id="t1617732447" t="ribelo great!"><y>#</y><d>2021-04-06</d><h>18:07</h><w>ribelo</w>great!</z><z id="t1617732545" t="nilern Yes that is the &quot;key&quot; to changing keys :drum_with_drumsticks:"><y>#</y><d>2021-04-06</d><h>18:09</h><w>nilern</w>Yes that is the &quot;key&quot; to changing keys <b>:drum_with_drumsticks:</b></z><z id="t1617734600" t="ikitommi 👍 small nitpick: the example could be encode as it transforms the value out of schema. Or the schema should not require :a &amp; :b as they are not in the result."><y>#</y><d>2021-04-06</d><h>18:43</h><w>ikitommi</w><b>👍</b> small nitpick: the example could be <code>encode</code> as it transforms the value out of schema. Or the schema should not require <code>:a</code> &amp; <code>:b</code> as they are not in the result.</z><z id="t1617735132" t="nilern Indeed"><y>#</y><d>2021-04-06</d><h>18:52</h><w>nilern</w>Indeed</z><z id="t1617803047" t="armed Hey, have issue with malli.error/humanize , here is minimal example (cljs): (let [Schema2 [:map [:field keyword?]] Schema [:map [:foo int?] [:bar [:or nil? Schema2]]]] (malli.error/humanize (malli/explain Schema {:foo 1 :bar {:field &quot;test&quot;}}))) Throws error: #object[Error Error: Vector&apos;s key for assoc must be a number.]"><y>#</y><d>2021-04-07</d><h>13:44</h><w>armed</w>Hey, have issue with <code>malli.error/humanize</code>, here is minimal example (cljs):
<pre>(let [Schema2 [:map
              [:field keyword?]]
      Schema [:map
              [:foo int?]
              [:bar [:or nil? Schema2]]]]
  (malli.error/humanize
   (malli/explain Schema {:foo 1
                          :bar {:field &quot;test&quot;}})))</pre>
Throws error: <code>#object[Error Error: Vector&apos;s key for assoc must be a number.]</code></z><z id="t1617803192" t="armed What I&apos;m missing here?"><y>#</y><d>2021-04-07</d><h>13:46</h><w>armed</w>What I&apos;m missing here?</z><z id="t1617803339" t="armed By the way, in clojure I get another error for same snippet: Execution error (ClassCastException) at malli.error/-ensure (error.cljc:124). class clojure.lang.Keyword cannot be cast to class java.lang.Number (clojure.lang.Keyword is in unnamed module of loader &apos;app&apos;; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;)"><y>#</y><d>2021-04-07</d><h>13:48</h><w>armed</w>By the way, in clojure I get another error for same snippet:
<pre>Execution error (ClassCastException) at malli.error/-ensure (error.cljc:124).
class clojure.lang.Keyword cannot be cast to class java.lang.Number (clojure.lang.Keyword is in unnamed module of loader &apos;app&apos;; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;)</pre></z><z id="t1617803422" t="ikitommi [:attrs {:href &quot;/_/_/users/U34K4458X&quot;}] it’s a known issue, see https://github.com/metosin/malli/pull/333"><y>#</y><d>2021-04-07</d><h>13:50</h><w>ikitommi</w><a>@armed</a> it’s a known issue, see <a href="https://github.com/metosin/malli/pull/333" target="_blank">https://github.com/metosin/malli/pull/333</a></z><z id="t1617803449" t="ikitommi you could say [:maybe Schema2] and it should work."><y>#</y><d>2021-04-07</d><h>13:50</h><w>ikitommi</w>you could say <code>[:maybe Schema2]</code> and it should work.</z><z id="t1617803468" t="ikitommi but, need to be fixed to be always robust."><y>#</y><d>2021-04-07</d><h>13:51</h><w>ikitommi</w>but, need to be fixed to be always robust.</z><z id="t1617803520" t="armed [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks for explanation, going to use :maybe"><y>#</y><d>2021-04-07</d><h>13:52</h><w>armed</w><a>@ikitommi</a> thanks for explanation, going to use <code>:maybe</code></z><z id="t1617808978" t="danielneal When I call malli.util/update on a schema, the properties of the key I update are dropped, is there any way to preserve them?"><y>#</y><d>2021-04-07</d><h>15:22</h><w>danielneal</w>When I call <code>malli.util/update</code> on a schema, the properties of the key I update are dropped, is there any way to preserve them?</z><z id="t1617809042" t="danielneal (malli.util/update (malli.core/schema [:map [:a {:optional true} int?] [:b {:optional true} int?]]) :a identity)"><y>#</y><d>2021-04-07</d><h>15:24</h><w>danielneal</w><pre>(malli.util/update
    (malli.core/schema
      [:map
       [:a {:optional true}
        int?]
       [:b {:optional true} int?]])
    :a identity)</pre></z><z id="t1617809049" t="danielneal ;=&gt; [:map [:a int?] [:b {:optional true} int?]]"><y>#</y><d>2021-04-07</d><h>15:24</h><w>danielneal</w><pre>;=&gt; [:map [:a int?] [:b {:optional true} int?]]</pre></z><z id="t1617809179" t="nilern Looks like a bug to me :thinking_face:"><y>#</y><d>2021-04-07</d><h>15:26</h><w>nilern</w>Looks like a bug to me <b>:thinking_face:</b></z><z id="t1617809271" t="danielneal Shall I open an issue?"><y>#</y><d>2021-04-07</d><h>15:27</h><w>danielneal</w>Shall I open an issue?</z><z id="t1617809709" t="nilern thinking-face util/update is implemented by getting the value, then setting it But it would be reasonable to expect that update preserves the properties even if get + assoc would not"><y>#</y><d>2021-04-07</d><h>15:35</h><w>nilern</w><b>thinking-face</b> <code>util/update</code> is implemented by getting the value, then setting it
But it would be reasonable to expect that <code>update</code> preserves the properties even if <code>get</code> + <code>assoc</code> would not</z><z id="t1617809867" t="danielneal I agree"><y>#</y><d>2021-04-07</d><h>15:37</h><w>danielneal</w>I agree</z><z id="t1617809880" t="nilern I think an issue would at the very least be a better place to discuss how that should work"><y>#</y><d>2021-04-07</d><h>15:38</h><w>nilern</w>I think an issue would at the very least be a better place to discuss how that should work</z><z id="t1617810246" t="danielneal cool, added one here https://github.com/metosin/malli/issues/412"><y>#</y><d>2021-04-07</d><h>15:44</h><w>danielneal</w>cool, added one here <a href="https://github.com/metosin/malli/issues/412" target="_blank">https://github.com/metosin/malli/issues/412</a></z><z id="t1617826290" t="Hankstenberg What would be a good way to &quot;cut&quot; a data structure using a schema that it partially adheres to? To keep what conforms to the schema and discard the rest? The best approach I can think of is to use m/explain and then use the data from :errors to run an update-in on the data. Is there a better way to do that? It seems to me like there should be."><y>#</y><d>2021-04-07</d><h>20:11</h><w>Hankstenberg</w>What would be a good way to &quot;cut&quot; a data structure using a schema that it partially adheres to? To keep what conforms to the schema and discard the rest? The best approach I can think of is to use m/explain and then use the data from :errors to run an update-in on the data. Is there a better way to do that? It seems to me like there should be.</z><z id="t1617826899" t="nilern Sounds like a more general version of strip-extra-keys-transformer"><y>#</y><d>2021-04-07</d><h>20:21</h><w>nilern</w>Sounds like a more general version of <code>strip-extra-keys-transformer</code></z><z id="t1617826988" t="nilern Or perhaps the tentative coercer https://github.com/metosin/malli/issues/404"><y>#</y><d>2021-04-07</d><h>20:23</h><w>nilern</w>Or perhaps the tentative <code>coercer</code> <a href="https://github.com/metosin/malli/issues/404" target="_blank">https://github.com/metosin/malli/issues/404</a></z><z id="t1617868154" t="ikitommi [:attrs {:href &quot;/_/_/users/URA5DLFM1&quot;}] if the strip-extra-keys-transformer is not enough (just map keys), please provide an example with schema, input and expected output."><y>#</y><d>2021-04-08</d><h>07:49</h><w>ikitommi</w><a>@roseneck</a> if the <code>strip-extra-keys-transformer</code> is not enough (just map keys),  please provide an example with schema, input and expected output.</z><z id="t1617886607" t="jeremie Hi all, just wonder if there is a malli schema for validating reitit route? like the reitit.spec namespace in reitit.core but for malli. My use case is describing API endpoints and referencing the reitit route for each endpoint would be great. Thanks."><y>#</y><d>2021-04-08</d><h>12:56</h><w>jeremie</w>Hi all, just wonder if there is a malli schema for validating reitit route?
like the <code>reitit.spec</code> namespace in <code>reitit.core</code> but for malli. My use case is describing API endpoints and referencing the reitit route for each endpoint would be great. Thanks.</z><z id="t1617889037" t="ikitommi not yet. One of the initial reasons for creating malli was to have a tool where one can deep-merge nested schemas without tears, to be used in reitir route data validation."><y>#</y><d>2021-04-08</d><h>13:37</h><r>ikitommi</r>not yet. One of the initial reasons for creating malli was to have a tool where one can deep-merge nested schemas without tears, to be used in reitir route data validation.</z><z id="t1617889057" t="ikitommi would you be interested in a PR?"><y>#</y><d>2021-04-08</d><h>13:37</h><r>ikitommi</r>would you be interested in a PR?</z><z id="t1617900982" t="Setzer22 Hi there! Missing spec&apos;s validation now that I&apos;ve migrated to malli, I rolled my own thing: https://github.com/setzer22/malli-instrument Let me know what you think! 😄"><y>#</y><d>2021-04-08</d><h>16:56</h><w>Setzer22</w>Hi there! Missing spec&apos;s validation now that I&apos;ve migrated to malli, I rolled my own thing: <a href="https://github.com/setzer22/malli-instrument" target="_blank">https://github.com/setzer22/malli-instrument</a>  Let me know what you think! <b>😄</b></z><z id="t1617902967" t="borkdude I wonder, didn&apos;t malli already have something to instrument functions with malli schemas? if not so, how were the function specs intended to be used?"><y>#</y><d>2021-04-08</d><h>17:29</h><w>borkdude</w>I wonder, didn&apos;t malli already have something to instrument functions with malli schemas? if not so, how were the function specs intended to be used?</z><z id="t1617903503" t="Setzer22 If there is, I couldn&apos;t find it anywhere 🤷 What&apos;s there, besides function schema syntax, is a global function registry and a macro, m/=&gt; to add functions to that registry. I just built a super simple thing on top of all this"><y>#</y><d>2021-04-08</d><h>17:38</h><w>Setzer22</w>If there is, I couldn&apos;t find it anywhere <b>🤷</b>  What&apos;s there, besides function schema syntax, is a global function registry and a macro, <code>m/=&gt;</code> to add functions to that registry. I just built a super simple thing on top of all this</z><z id="t1617903662" t="ikitommi [:attrs {:href &quot;/_/_/users/U70027S0N&quot;}] looks good. Plan is to have the instrumentation in malli core lib, but just not there yet, see: https://github.com/metosin/malli/issues/349"><y>#</y><d>2021-04-08</d><h>17:41</h><w>ikitommi</w><a>@setzer22</a> looks good. Plan is to have the instrumentation in malli core lib, but just not there yet, see: <a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a></z><z id="t1617903709" t="ikitommi Also related: https://github.com/metosin/malli/issues/369"><y>#</y><d>2021-04-08</d><h>17:41</h><r>ikitommi</r>Also related: <a href="https://github.com/metosin/malli/issues/369" target="_blank">https://github.com/metosin/malli/issues/369</a></z></g><g id="s13"><z id="t1618402857" t="Ian Fernandez I&apos;ve made some questions asking about Intrument impl"><y>#</y><d>2021-04-14</d><h>12:20</h><r>Ian Fernandez</r>I&apos;ve made some questions asking about Intrument impl</z><z id="t1618402869" t="Ian Fernandez what malli expects for it"><y>#</y><d>2021-04-14</d><h>12:21</h><r>Ian Fernandez</r>what malli expects for it</z><z id="t1618405909" t="ikitommi noticed, thanks! need to think it over before answering."><y>#</y><d>2021-04-14</d><h>13:11</h><r>ikitommi</r>noticed, thanks! need to think it over before answering.</z><z id="t1617903947" t="ikitommi ... but the idea seems exactly what you have already implemented. Maybe the lib could be just a new ns under malli?"><y>#</y><d>2021-04-08</d><h>17:45</h><w>ikitommi</w>... but the idea seems exactly what you have already implemented. Maybe the lib could be just a new ns under malli?</z><z id="t1617910215" t="Setzer22 [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Oh, I&apos;d be glad to contribute if you think it fits! 👍"><y>#</y><d>2021-04-08</d><h>19:30</h><w>Setzer22</w><a>@ikitommi</a> Oh, I&apos;d be glad to contribute if you think it fits! <b>👍</b></z><z id="t1617910505" t="Setzer22 let me know if you&apos;d like me to submit a PR with this"><y>#</y><d>2021-04-08</d><h>19:35</h><w>Setzer22</w>let me know if you&apos;d like me to submit a PR with this</z><z id="t1617965874" t="ikitommi [:attrs {:href &quot;/_/_/users/U70027S0N&quot;}] I’ll draft my vision to the issue and then it’s all yours if you have time, planning to integrate the normal defn schema inferrer into it, needs var filtering etc. But, busy atm, I’ll link your lib to Malli README meanwhile, so people can pick it up."><y>#</y><d>2021-04-09</d><h>10:57</h><w>ikitommi</w><a>@setzer22</a> I’ll draft my vision to the issue and then it’s all yours if you have time, planning to integrate the normal defn schema inferrer into it, needs var filtering etc. But, busy atm, I’ll link your lib to Malli README meanwhile, so people can pick it up.</z><z id="t1617965944" t="ikitommi https://github.com/metosin/malli/commit/e57e0f546c096b8cb39b6b0d83c0ed3f9d555552"><y>#</y><d>2021-04-09</d><h>10:59</h><r>ikitommi</r><a href="https://github.com/metosin/malli/commit/e57e0f546c096b8cb39b6b0d83c0ed3f9d555552" target="_blank">https://github.com/metosin/malli/commit/e57e0f546c096b8cb39b6b0d83c0ed3f9d555552</a></z><z id="t1617973416" t="Setzer22 cool! I&apos;ll keep an eye on that, definitely interested 😄"><y>#</y><d>2021-04-09</d><h>13:03</h><r>Setzer22</r>cool! I&apos;ll keep an eye on that, definitely interested <b>😄</b></z><z id="t1617973429" t="Setzer22 also thanks for mentioning my lib in the readme 👍"><y>#</y><d>2021-04-09</d><h>13:03</h><r>Setzer22</r>also thanks for mentioning my lib in the readme <b>👍</b></z><z id="t1618076512" t="ikitommi Some breaking changes coming to the extender-api, moving -type and -type-properties from Schema to IntoSchema . And some new methods so that we can describe the Malli schemas with Malli: (defprotocol IntoSchema (-type [this] &quot;returns type of the schema&quot;) (-type-properties [this] &quot;returns schema type properties&quot;) (-properties-schema [this] &quot;maybe returns :map schema describing schema properties&quot;) (-children-schema [this] &quot;maybe returns sequence schema describing schema children&quot;) (-into-schema [this properties children options] &quot;creates a new schema instance&quot;))"><y>#</y><d>2021-04-10</d><h>17:41</h><w>ikitommi</w>Some breaking changes coming to the extender-api, moving <code>-type</code> and <code>-type-properties</code> from <code>Schema</code> to <code>IntoSchema</code>. And some new methods so that we can describe the Malli schemas with Malli:
<pre>(defprotocol IntoSchema
  (-type [this] &quot;returns type of the schema&quot;)
  (-type-properties [this] &quot;returns schema type properties&quot;)
  (-properties-schema [this] &quot;maybe returns :map schema describing schema properties&quot;)
  (-children-schema [this] &quot;maybe returns sequence schema describing schema children&quot;)
  (-into-schema [this properties children options] &quot;creates a new schema instance&quot;))</pre></z><z id="t1618076887" t="ikitommi https://github.com/metosin/malli/pull/414"><y>#</y><d>2021-04-10</d><h>17:48</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/414" target="_blank">https://github.com/metosin/malli/pull/414</a></z><z id="t1618077683" t="ikitommi also, much better print presentations now: (m/-enum-schema) ; =&gt; #IntoSchema{:type :enum} (m/schema [*1 &quot;A&quot; &quot;B&quot;]) ; =&gt; [:enum &quot;A&quot; &quot;B&quot;] (type *1) ; =&gt; :malli.core/schema"><y>#</y><d>2021-04-10</d><h>18:01</h><w>ikitommi</w>also, much better print presentations now:
<pre>(m/-enum-schema)
; =&gt; #IntoSchema{:type :enum}

(m/schema [*1 &quot;A&quot; &quot;B&quot;])
; =&gt; [:enum &quot;A&quot; &quot;B&quot;]

(type *1)
; =&gt; :malli.core/schema</pre></z><z id="t1618085753" t="Hankstenberg If I want to generate valid malli schemas of the form: [:map [:key1 int?] [:key2 int?] .... [:keyn int?]] using another malli schema - a meta-schema so to speak - what would that meta-schema look like? I&apos;ve tried: [:tuple [:= :map] [:+ [:tuple simple-keyword? [:= :int]]]]) But it has a flaw: it e.g. generates: [:map [[:key1 int?] [:key2 int?] .... [:keyn int?]]] one pair of square brackets too much around the key-value-tuples. Does anybody know how to solve this using malli?"><y>#</y><d>2021-04-10</d><h>20:15</h><w>Hankstenberg</w>If I want to generate valid malli schemas of the form:
 [:map
    [:key1 int?]
    [:key2 int?]
    ....
    [:keyn int?]]

using another malli schema - a meta-schema so to speak - what would that meta-schema look like? I&apos;ve tried:

[:tuple [:= :map] [:+ [:tuple simple-keyword? [:= :int]]]])

But it has a flaw: it e.g. generates:

 [:map
   [[:key1 int?]
    [:key2 int?]
    ....
    [:keyn int?]]]

one pair of square brackets too much around the key-value-tuples. Does anybody know how to solve this using malli?</z><z id="t1618088457" t="ikitommi [:attrs {:href &quot;/_/_/users/URA5DLFM1&quot;}] it’s a sequence: (mg/generate [:cat {:gen/fmap vec} [:= :map] [:* [:tuple :keyword :int]]] {:size 42, :seed 200}) ;[:map ; [:IjPg2 -5908] ; [:E+:H9l* 287044292] ; [:*vCe._5z 10637946460] ; [:kLq67 -125] ; [:J9?D+FY4G 718] ; [:*_1*Rc+A -908] ; [:?qi 1523] ; [:x.+ -1] ; [:D4*5 -13] ; [:.C4 -80] ; [:r-A 3161894] ; [:rcC 1118] ; [:Q*._k*w8iG 194253522] ; [:o!dfA 21159377159] ; [:nx!h 973119] ; [:C:!Rw 109221] ; [:?N38.*3? -11854145] ; [:lb5Z?9V?_v* -42] ; [:i!M.l?D+ 2026049] ; [:++k43x -141680] ; [:U- -8] ; [:*x 1491554935632] ; [:heX2 1957851783] ; [:_PZ?q3+! -83] ; [:*H*x8N:.! 1452] ; [:k_Oy2+LXD -864224065] ; [:p 55] ; [:*o+1ul*5?? -1766412] ; [:W7:-61 -17174129950] ; [:qv79TTj_+ 21380662] ; [:h -30089]]"><y>#</y><d>2021-04-10</d><h>21:00</h><w>ikitommi</w><a>@roseneck</a> it’s a sequence:
<pre>(mg/generate
  [:cat {:gen/fmap vec}
   [:= :map]
   [:* [:tuple :keyword :int]]]
  {:size 42, :seed 200})
;[:map
; [:IjPg2 -5908]
; [:E+:H9l* 287044292]
; [:*vCe._5z 10637946460]
; [:kLq67 -125]
; [:J9?D+FY4G 718]
; [:*_1*Rc+A -908]
; [:?qi 1523]
; [:x.+ -1]
; [:D4*5 -13]
; [:.C4 -80]
; [:r-A 3161894]
; [:rcC 1118]
; [:Q*._k*w8iG 194253522]
; [:o!dfA 21159377159]
; [:nx!h 973119]
; [:C:!Rw 109221]
; [:?N38.*3? -11854145]
; [:lb5Z?9V?_v* -42]
; [:i!M.l?D+ 2026049]
; [:++k43x -141680]
; [:U- -8]
; [:*x 1491554935632]
; [:heX2 1957851783]
; [:_PZ?q3+! -83]
; [:*H*x8N:.! 1452]
; [:k_Oy2+LXD -864224065]
; [:p 55]
; [:*o+1ul*5?? -1766412]
; [:W7:-61 -17174129950]
; [:qv79TTj_+ 21380662]
; [:h -30089]]</pre></z><z id="t1618088671" t="Hankstenberg Thanks a lot! 🙂"><y>#</y><d>2021-04-10</d><h>21:04</h><w>Hankstenberg</w>Thanks a  lot! <b>🙂</b></z><z id="t1618222614" t="Ian Fernandez Hi, I&apos;ve asked some questions at a malli issue to understand some design motivations 🙂 https://github.com/metosin/malli/issues/349"><y>#</y><d>2021-04-12</d><h>10:16</h><w>Ian Fernandez</w>Hi, I&apos;ve asked some questions at a malli issue to understand some design motivations <b>🙂</b>
<a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a></z><z id="t1618222638" t="Ian Fernandez Should be good if anyone here could contribute 🙂"><y>#</y><d>2021-04-12</d><h>10:17</h><w>Ian Fernandez</w>Should be good if anyone here could contribute <b>🙂</b></z><z id="t1618257034" t="jcf Hi all! 👋 I&apos;m looking into specifying higher-order functions, and wonder if there&apos;s a schema that resembles Clojure&apos;s ifn? . I notice there&apos;s no ifn? predicate in the predicate-schemas (nor does fn? make an appearance), so I&apos;m leaning towards defining something in user space (assuming there&apos;s nothing in Malli that I&apos;ve missed?). I&apos;m hesitant to do something like [:alt keyword? [:=&gt; :cat any?]] because I&apos;m creating a closed schema that would need to be extended for any IFn that might crop up in future… thinking of a custom IntoSchema or similar maybe. Any tips are much appreciated!!"><y>#</y><d>2021-04-12</d><h>19:50</h><w>jcf</w>Hi all! <b>👋</b>

I&apos;m looking into specifying higher-order functions, and wonder if there&apos;s a schema that resembles Clojure&apos;s <code>ifn?</code>.

I notice there&apos;s no <code>ifn?</code> predicate in the <code>predicate-schemas</code> (nor does <code>fn?</code> make an appearance), so I&apos;m leaning towards defining something in user space (assuming there&apos;s nothing in Malli that I&apos;ve missed?). I&apos;m hesitant to do something like <code>[:alt keyword? [:=&gt; :cat any?]]</code> because I&apos;m creating a closed schema that would need to be extended for any IFn that might crop up in future… thinking of a custom <code>IntoSchema</code> or similar maybe.

Any tips are much appreciated!!</z><z id="t1618258094" t="jcf I can do this: [:fn ifn?]"><y>#</y><d>2021-04-12</d><h>20:08</h><r>jcf</r>I can do this:

<pre>[:fn ifn?]</pre></z><z id="t1618258104" t="jcf I&apos;m just not sure if that&apos;s a bad way to go. 🙂"><y>#</y><d>2021-04-12</d><h>20:08</h><r>jcf</r>I&apos;m just not sure if that&apos;s a bad way to go. <b>🙂</b></z><z id="t1618287318" t="ikitommi that&apos;s the way to do it now."><y>#</y><d>2021-04-13</d><h>04:15</h><r>ikitommi</r>that&apos;s the way to do it now.</z><z id="t1618309402" t="jcf Thanks, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2021-04-13</d><h>10:23</h><r>jcf</r>Thanks, <a>@U055NJ5CC</a>!</z><z id="t1618301853" t="Ben Sless Is it by design that schema transformations like mu/assoc don&apos;t play well with an unregistered schema?"><y>#</y><d>2021-04-13</d><h>08:17</h><w>Ben Sless</w>Is it by design that schema transformations like <code>mu/assoc</code> don&apos;t play well with an unregistered schema?</z><z id="t1618304816" t="ikitommi not by design, could you repro if there is something that doesn’t work?"><y>#</y><d>2021-04-13</d><h>09:06</h><r>ikitommi</r>not by design, could you repro if there is something that doesn’t work?</z><z id="t1618306107" t="Ben Sless (def Foo [:map [:a int?]]) (mu/assoc Foo :b ::bar) Minimal example"><y>#</y><d>2021-04-13</d><h>09:28</h><r>Ben Sless</r><pre>(def Foo
  [:map
   [:a int?]])

(mu/assoc Foo :b ::bar)</pre>
Minimal example</z><z id="t1618307245" t="ikitommi you should declare the ::bar so that is is visible, either: 1. override the default registry 2. pass the registry into Foo when creting it (it closes over the creation time registry) 3. pass the registry into mu/assoc (def registry (merge (m/default-schemas) {::bar int?})) (def Foo (m/schema [:map [:a int?]] {:registry registry})) (mu/assoc Foo :b ::bar) ;[:map ; [:a int?] ; [:b :user/bar]] (mu/assoc [:map [:a int?]] :b ::bar {:registry registry}) ;[:map ; [:a int?] ; [:b :user/bar]]"><y>#</y><d>2021-04-13</d><h>09:47</h><r>ikitommi</r>you should declare the <code>::bar</code> so that is is visible, either:
1. override the default registry
2. pass the registry into <code>Foo</code> when creting it (it closes over the creation time registry)
3. pass the registry into <code>mu/assoc</code>
<pre>(def registry
  (merge (m/default-schemas) {::bar int?}))

(def Foo
  (m/schema
    [:map
     [:a int?]]
    {:registry registry}))

(mu/assoc Foo :b ::bar)
;[:map 
; [:a int?] 
; [:b :user/bar]]

(mu/assoc [:map [:a int?]] :b ::bar {:registry registry})
;[:map 
; [:a int?] 
; [:b :user/bar]]</pre></z><z id="t1618307697" t="Ben Sless I managed to get myself into this corner like so: • wanted content dependent schema • wanted to parametrize the schema (makes it extensible) • figured out I&apos;d do it by delaying registry building and schema compilation to run-time. • With registry I need ::my-schema • Can&apos;t transform anything with ::my-schema at compile time I can create a placeholder registry for it but it seems like it would lead to errors down the line"><y>#</y><d>2021-04-13</d><h>09:54</h><r>Ben Sless</r>I managed to get myself into this corner like so:
• wanted content dependent schema
• wanted to parametrize the schema (makes it extensible)
• figured out I&apos;d do it by delaying registry building and schema compilation to run-time.
• With registry I need <code>::my-schema</code>
• Can&apos;t transform anything with <code>::my-schema</code> at compile time
I can create a placeholder registry for it but it seems like it would lead to errors down the line</z><z id="t1618307860" t="Ben Sless I&apos;d be happy to adopt a better idea"><y>#</y><d>2021-04-13</d><h>09:57</h><r>Ben Sless</r>I&apos;d be happy to adopt a better idea</z><z id="t1618308034" t="ikitommi me too 🙂 spec partially checks the references eagerly, partially lazily (e.g. s/keys ), malli is currently eager."><y>#</y><d>2021-04-13</d><h>10:00</h><r>ikitommi</r>me too <b>🙂</b> spec partially checks the references eagerly, partially lazily (e.g. <code>s/keys</code>), malli is currently eager.</z><z id="t1618308094" t="ikitommi there is an internal escape hatch: :ref doesn’t check the reference if :malli.core/allow-invalid-refs option is truthy."><y>#</y><d>2021-04-13</d><h>10:01</h><r>ikitommi</r>there is an internal escape hatch: <code>:ref</code> doesn’t check the reference if <code>:malli.core/allow-invalid-refs</code> option is truthy.</z><z id="t1618308104" t="ikitommi it is used with local registries, which can have… holes."><y>#</y><d>2021-04-13</d><h>10:01</h><r>ikitommi</r>it is used with local registries, which can have… holes.</z><z id="t1618308219" t="ikitommi (m/validate [:schema {:registry {::foo [:ref ::bar]}} ;; incomplete registry [:tuple {:registry {::bar int?}} ::bar ::foo]] [1 2]) ; =&gt; true"><y>#</y><d>2021-04-13</d><h>10:03</h><r>ikitommi</r><pre>(m/validate
  [:schema {:registry {::foo [:ref ::bar]}} ;; incomplete registry
   [:tuple {:registry {::bar int?}}
    ::bar ::foo]]
  [1 2])
; =&gt; true</pre></z><z id="t1618308393" t="ikitommi ideas welcome how to make this good."><y>#</y><d>2021-04-13</d><h>10:06</h><r>ikitommi</r>ideas welcome how to make this good.</z><z id="t1618308745" t="Ben Sless I don&apos;t know if it&apos;s good, but perhaps a :delay or :defer schema, which delays registry lookup to validation, with ample warning, care, etc."><y>#</y><d>2021-04-13</d><h>10:12</h><r>Ben Sless</r>I don&apos;t know if it&apos;s good, but perhaps a <code>:delay</code> or <code>:defer</code> schema, which delays registry lookup to validation, with ample warning, care, etc.</z><z id="t1618309104" t="Ben Sless Perhaps even wrap it in a function which will always emit warnings when it&apos;s called, i.e. (mu/assoc Foo :b (m/schema (m/defer ::bar))) STDERR: Deferred Warning *at* - instances of deferred schema must be provided with a registry at run time! You can also throw when instantiating an explainer, transformer, or validator from it, which is when you actually need the registry"><y>#</y><d>2021-04-13</d><h>10:18</h><r>Ben Sless</r>Perhaps even wrap it in a function which will always emit warnings when it&apos;s called, i.e.
<pre>(mu/assoc Foo :b (m/schema (m/defer ::bar)))
STDERR: Deferred Warning *at* - instances of deferred schema must be provided with a registry at run time!</pre>
You can also throw when instantiating an explainer, transformer, or validator from it, which is when you actually need the registry</z><z id="t1618309274" t="ikitommi could it be just [:ref {:lazy true} ::bar] ?"><y>#</y><d>2021-04-13</d><h>10:21</h><r>ikitommi</r>could it be just <code>[:ref {:lazy true} ::bar]</code>?</z><z id="t1618309300" t="Ben Sless Ah, laziness has to be explicit"><y>#</y><d>2021-04-13</d><h>10:21</h><r>Ben Sless</r>Ah, laziness has to be explicit</z><z id="t1618309309" t="ikitommi oh, ref’s are lazy already :thinking_face:"><y>#</y><d>2021-04-13</d><h>10:21</h><r>ikitommi</r>oh, ref’s are lazy already <b>:thinking_face:</b></z><z id="t1618309335" t="Ben Sless yeah, this didn&apos;t work 🙂"><y>#</y><d>2021-04-13</d><h>10:22</h><r>Ben Sless</r>yeah, this didn&apos;t work <b>🙂</b></z><z id="t1618309340" t="Ben Sless we need lazier laziness"><y>#</y><d>2021-04-13</d><h>10:22</h><r>Ben Sless</r>we need lazier laziness</z><z id="t1618309422" t="ikitommi try (m/-lazy ::bar options)"><y>#</y><d>2021-04-13</d><h>10:23</h><r>ikitommi</r>try <code>(m/-lazy ::bar options)</code></z><z id="t1618309445" t="ikitommi refs resolve eager by default, but one can create lazy refs with that."><y>#</y><d>2021-04-13</d><h>10:24</h><r>ikitommi</r>refs resolve eager by default, but one can create lazy refs with that.</z><z id="t1618309476" t="ikitommi (let [-ref (or (and lazy (-memoize (fn [] (schema (mr/-schema (-registry options) ref) options)))) (if-let [s (mr/-schema (-registry options) ref)] (-memoize (fn [] (schema s options)))) (when-not allow-invalid-refs (miu/-fail! ::invalid-ref {:type :ref, :ref ref})))"><y>#</y><d>2021-04-13</d><h>10:24</h><r>ikitommi</r><pre>(let [-ref (or (and lazy (-memoize (fn [] (schema (mr/-schema (-registry options) ref) options))))
                      (if-let [s (mr/-schema (-registry options) ref)] (-memoize (fn [] (schema s options))))
                      (when-not allow-invalid-refs
                        (miu/-fail! ::invalid-ref {:type :ref, :ref ref})))</pre></z><z id="t1618309480" t="Ben Sless Cool, it worked 🙂"><y>#</y><d>2021-04-13</d><h>10:24</h><r>Ben Sless</r>Cool, it worked <b>🙂</b></z><z id="t1618309489" t="Ben Sless Always good to know some black magic"><y>#</y><d>2021-04-13</d><h>10:24</h><r>Ben Sless</r>Always good to know some black magic</z><z id="t1618309506" t="ikitommi could make a version of that which doesn’t require the options."><y>#</y><d>2021-04-13</d><h>10:25</h><r>ikitommi</r>could make a version of that which doesn’t require the options.</z><z id="t1618309535" t="Ben Sless It makes me wonder why [:ref {:lazy true} ::bar] didn&apos;t work"><y>#</y><d>2021-04-13</d><h>10:25</h><r>Ben Sless</r>It makes me wonder why <code>[:ref {:lazy true} ::bar]</code> didn&apos;t work</z><z id="t1618309560" t="ikitommi it’s a property of the IntoSchema , not Schema instance."><y>#</y><d>2021-04-13</d><h>10:26</h><r>ikitommi</r>it’s a property of the <code>IntoSchema</code>, not <code>Schema</code> instance.</z><z id="t1618309625" t="ikitommi by design, all the IntoSchema s are crated using a function, which can take properties how the IntoSchema works. Easy to extend the system that way and DCE drops all the unneeded schemas."><y>#</y><d>2021-04-13</d><h>10:27</h><r>ikitommi</r>by design, all the <code>IntoSchema</code>s are crated using a function, which can take properties how the <code>IntoSchema</code> works. Easy to extend the system that way and DCE drops all the unneeded schemas.</z><z id="t1618309673" t="ikitommi for example, it’s reletively easy to create custom collection schema types: (defn -collection-schema [{type :type fpred :pred, fempty :empty, fin :in :or {fin (fn [i _] i)} :as opts}] ...)"><y>#</y><d>2021-04-13</d><h>10:27</h><r>ikitommi</r>for example, it’s reletively easy to create custom collection schema types:
<pre>(defn -collection-schema [{type :type fpred :pred, fempty :empty, fin :in :or {fin (fn [i _] i)} :as opts}] ...)</pre></z><z id="t1618309698" t="ikitommi :ref has: (defn -ref-schema ([] (-ref-schema nil)) ([{:keys [lazy type-properties] :as opts}] ...))"><y>#</y><d>2021-04-13</d><h>10:28</h><r>ikitommi</r><code>:ref</code> has:
<pre>(defn -ref-schema
  ([]
   (-ref-schema nil))
  ([{:keys [lazy type-properties] :as opts}] ...))</pre></z><z id="t1618309736" t="ikitommi but, could lift the lazy into a :ref schema property too. so one can say [:ref {:lazy true} ::bar] as data."><y>#</y><d>2021-04-13</d><h>10:28</h><r>ikitommi</r>but, could lift the <code>lazy</code> into a <code>:ref</code> schema property too. so one can say <code>[:ref {:lazy true} ::bar]</code> as data.</z><z id="t1618309749" t="ikitommi if you need that, please write an issue."><y>#</y><d>2021-04-13</d><h>10:29</h><r>ikitommi</r>if you need that, please write an issue.</z><z id="t1618309961" t="Ben Sless Thank you!"><y>#</y><d>2021-04-13</d><h>10:32</h><r>Ben Sless</r>Thank you!</z><z id="t1618309990" t="Ben Sless I wonder if I should settle for m/-lazy"><y>#</y><d>2021-04-13</d><h>10:33</h><r>Ben Sless</r>I wonder if I should settle for <code>m/-lazy</code></z><z id="t1618310016" t="Ben Sless If I should consider functions prefixed with - as implementation detail, then I&apos;d say that I shouldn&apos;t and open that issue"><y>#</y><d>2021-04-13</d><h>10:33</h><r>Ben Sless</r>If I should consider functions prefixed with <code>-</code> as implementation detail, then I&apos;d say that I shouldn&apos;t and open that issue</z><z id="t1618310073" t="ikitommi things starging with - are ok to use: https://github.com/metosin/malli#alpha"><y>#</y><d>2021-04-13</d><h>10:34</h><r>ikitommi</r>things starging with <code>-</code> are ok to use:  <a href="https://github.com/metosin/malli#alpha" target="_blank">https://github.com/metosin/malli#alpha</a></z><z id="t1618310283" t="Ben Sless &gt; might evolve during the alpha That&apos;s a risk I&apos;m willing to take. I think if m/-lazy develops in any direction it won&apos;t be one which will have friction with what I&apos;m trying to do, on the contrary. Thanks again for the help and guidance, you rock"><y>#</y><d>2021-04-13</d><h>10:38</h><r>Ben Sless</r>&gt; might evolve during the alpha
That&apos;s a risk I&apos;m willing to take. I think if <code>m/-lazy</code> develops in any direction it won&apos;t be one which will have friction with what I&apos;m trying to do, on the contrary.
Thanks again for the help and guidance, you rock</z><z id="t1618306209" t="Ben Sless Another issue I managed to stumble on, I defined a dependent schema like https://github.com/metosin/malli#content-dependent-simple-schema It works well but throws when I pass it to reitit routes when the coercion is compiled"><y>#</y><d>2021-04-13</d><h>09:30</h><w>Ben Sless</w>Another issue I managed to stumble on,  I defined a dependent schema like <a href="https://github.com/metosin/malli#content-dependent-simple-schema" target="_blank">https://github.com/metosin/malli#content-dependent-simple-schema</a>
It works well but throws when I pass it to reitit routes when the coercion is compiled</z><z id="t1618306460" t="Ben Sless Great, now I&apos;m unable to reproduce it 😞"><y>#</y><d>2021-04-13</d><h>09:34</h><r>Ben Sless</r>Great, now I&apos;m unable to reproduce it <b>😞</b></z><z id="t1618307245" t="ikitommi you should declare the ::bar so that is is visible, either: 1. override the default registry 2. pass the registry into Foo when creting it (it closes over the creation time registry) 3. pass the registry into mu/assoc (def registry (merge (m/default-schemas) {::bar int?})) (def Foo (m/schema [:map [:a int?]] {:registry registry})) (mu/assoc Foo :b ::bar) ;[:map ; [:a int?] ; [:b :user/bar]] (mu/assoc [:map [:a int?]] :b ::bar {:registry registry}) ;[:map ; [:a int?] ; [:b :user/bar]]"><y>#</y><d>2021-04-13</d><h>09:47</h><w>ikitommi</w>you should declare the <code>::bar</code> so that is is visible, either:
1. override the default registry
2. pass the registry into <code>Foo</code> when creting it (it closes over the creation time registry)
3. pass the registry into <code>mu/assoc</code>
<pre>(def registry
  (merge (m/default-schemas) {::bar int?}))

(def Foo
  (m/schema
    [:map
     [:a int?]]
    {:registry registry}))

(mu/assoc Foo :b ::bar)
;[:map 
; [:a int?] 
; [:b :user/bar]]

(mu/assoc [:map [:a int?]] :b ::bar {:registry registry})
;[:map 
; [:a int?] 
; [:b :user/bar]]</pre></z><z id="t1618308847" t="yuhan Are there built-in functions to throw errors on invalid input? The plans for instrumentation in the above issue are nice, but I&apos;m looking for something simple like spec/assert"><y>#</y><d>2021-04-13</d><h>10:14</h><w>yuhan</w>Are there built-in functions to throw errors on invalid input? The plans for instrumentation in the above issue are nice, but I&apos;m looking for something simple like <code>spec/assert</code></z><z id="t1618310337" t="nilern Seems not"><y>#</y><d>2021-04-13</d><h>10:38</h><r>nilern</r>Seems not</z><z id="t1618310423" t="nilern You can always (assert (thingy-validator dada)) but the error is not so useful"><y>#</y><d>2021-04-13</d><h>10:40</h><r>nilern</r>You can always <code>(assert (thingy-validator dada))</code> but the error is not so useful</z><z id="t1618310606" t="yuhan Yeah, I wrote my own for now: (defn malli-assert ([schema value] (malli-assert schema value &quot;&quot;)) ([schema value msg] (when-not (malli/validate schema value) (throw (ex-info (clojure.string/join &quot;/n&quot; (cons msg (flatten (malli.error/humanize (malli/explain schema value))))) {:value value}))))) "><y>#</y><d>2021-04-13</d><h>10:43</h><r>yuhan</r>Yeah, I wrote my own for now:
<pre>(defn malli-assert
  ([schema value]
   (malli-assert schema value &quot;&quot;))
  ([schema value msg]
   (when-not (malli/validate schema value)
     (throw (ex-info (clojure.string/join &quot;/n&quot;
                       (cons msg
                         (flatten
                           (malli.error/humanize
                             (malli/explain schema value)))))
              {:value value})))))</pre>
</z><z id="t1618310695" t="nilern Make a PR?"><y>#</y><d>2021-04-13</d><h>10:44</h><r>nilern</r>Make a PR?</z><z id="t1618310697" t="yuhan It&apos;s not ideal because humanize returns nested messages according to the path of the error, which I just flatten into a single string"><y>#</y><d>2021-04-13</d><h>10:44</h><r>yuhan</r>It&apos;s not ideal because humanize returns nested messages according to the path of the error, which I just flatten into a single string</z><z id="t1618310754" t="yuhan Ok I&apos;ll submit an issue, just wanted to check if it was a design decision not to have an assert"><y>#</y><d>2021-04-13</d><h>10:45</h><r>yuhan</r>Ok I&apos;ll submit an issue, just wanted to check if it was a design decision not to have an assert</z><z id="t1618310851" t="nilern Maybe AssertionError would be more appropriate :thinking_face:"><y>#</y><d>2021-04-13</d><h>10:47</h><r>nilern</r>Maybe <code>AssertionError</code> would be more appropriate <b>:thinking_face:</b></z><z id="t1618311023" t="nilern And maybe use *assert* and make it a macro"><y>#</y><d>2021-04-13</d><h>10:50</h><r>nilern</r>And maybe use <code>*assert*</code> and make it a macro</z><z id="t1618311059" t="nilern Spec assert seems to use ex-info and a separate *assert* equivalent var"><y>#</y><d>2021-04-13</d><h>10:50</h><r>nilern</r>Spec assert seems to use <code>ex-info</code> and a separate <code>*assert*</code> equivalent var</z><z id="t1618309722" t="jcf I have a follow up question from https://clojurians.slack.com/archives/CLDK6MFMK/p1618257034389400 regarding emitting configuration for clj-kondo to pick up (which is an awesome feature by the way!). I have schematised the following code: (m/=&gt; hash-map-by [:=&gt; [:catn [:f [:fn ifn?]] [:coll coll?]] map?]) (defn hash-map-by &quot;Returns a map of the items in `coll` keyed by `f`.&quot; [f coll] (into {} (map (juxt f identity)) coll)) The function takes an arbitrary function, f , and a collection that will be converted into a map by applying f and identity to each item in the collection. Pretty standard stuff. 🙂 When I emit clj-kondo config with (mc/emit!) , I get the following EDN: {:lint-as #:malli.schema{defn schema.core/defn}, :linters {:type-mismatch {:namespaces {example.hash-map {hash-map-by {:arities {2 {:args [:fn :coll], :ret :map}}}}}}}} Please note, the 2-arity args say :fn and :coll returning a :map which means I get linting issues with something like (hash-map-by :user/id [{:user/id 1} {:user/id 2}]) . Is this a bug worthy of a pull request or am I once again demonstrating my naivety? 🙈"><y>#</y><d>2021-04-13</d><h>10:28</h><w>jcf</w>I have a follow up question from <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1618257034389400" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1618257034389400</a> regarding emitting configuration for clj-kondo to pick up (which is an awesome feature by the way!).

I have schematised the following code:

<pre>(m/=&gt; hash-map-by
  [:=&gt; [:catn [:f [:fn ifn?]] [:coll coll?]] map?])

(defn hash-map-by
  &quot;Returns a map of the items in `coll` keyed by `f`.&quot;
  [f coll]
  (into {} (map (juxt f identity)) coll))</pre>
The function takes an arbitrary function, <code>f</code>, and a collection that will be converted into a map by applying <code>f</code> and <code>identity</code> to each item in the collection. Pretty standard stuff. <b>🙂</b>

When I emit clj-kondo config with <code>(mc/emit!)</code>, I get the following EDN:

<pre>{:lint-as #:malli.schema{defn schema.core/defn},
 :linters {:type-mismatch {:namespaces {example.hash-map {hash-map-by {:arities {2 {:args [:fn :coll], :ret :map}}}}}}}}</pre>
Please note, the 2-arity args say <code>:fn</code> and <code>:coll</code> returning a <code>:map</code> which means I get linting issues with something like <code>(hash-map-by :user/id [{:user/id 1} {:user/id 2}])</code>.

Is this a bug worthy of a pull request or am I once again demonstrating my naivety? <b>🙈</b></z><z id="t1618309937" t="ikitommi currently there is no way to override per schema instance how the clj-kondo works, but would be easy to add. also, having an ifn? schema built-in, it could have the correct clj-kondo type. interested in a PR?"><y>#</y><d>2021-04-13</d><h>10:32</h><r>ikitommi</r>currently there is no way to override per schema instance how the clj-kondo works, but would be easy to add. also, having an <code>ifn?</code> schema built-in, it could have the correct clj-kondo type. interested in a PR?</z><z id="t1618309947" t="ikitommi for the latter that is."><y>#</y><d>2021-04-13</d><h>10:32</h><r>ikitommi</r>for the latter that is.</z><z id="t1618309958" t="ikitommi for the first, for the second, something like:"><y>#</y><d>2021-04-13</d><h>10:32</h><r>ikitommi</r>for the first, for the second, something like:</z><z id="t1618309992" t="ikitommi [:fn {:clj-kondo/type :ifn} ifn?]"><y>#</y><d>2021-04-13</d><h>10:33</h><r>ikitommi</r><pre>[:fn {:clj-kondo/type :ifn} ifn?]</pre></z><z id="t1618310044" t="jcf I&apos;m very interested in implementing this as we&apos;d need it to complete the replacement of clojure.spec with Malli in our codebase, I think."><y>#</y><d>2021-04-13</d><h>10:34</h><r>jcf</r>I&apos;m very interested in implementing this as we&apos;d need it to complete the replacement of clojure.spec with Malli in our codebase, I think.</z><z id="t1618310091" t="jcf I can create a PR for sure. 💯"><y>#</y><d>2021-04-13</d><h>10:34</h><r>jcf</r>I can create a PR for sure. <b>💯</b></z><z id="t1618311600" t="jcf [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] can I just clarify what you&apos;re thinking in terms of a PR, please? I can add #&apos;ifn? to the predicate-schemas and then these tests pass: (testing &quot;ifn schemas&quot; (let [schema (m/schema ifn?)] (is (true? (m/validate schema (fn [])))) (is (true? (m/validate schema (constantly 1)))) (is (true? (m/validate schema :keyword))) (is (true? (m/validate schema (reify clojure.lang.IFn (invoke [_] &quot;Invoked!&quot;))))))) Is that what you had in mind when you mentioned having an ifn? schema built in?"><y>#</y><d>2021-04-13</d><h>11:00</h><r>jcf</r><a>@U055NJ5CC</a> can I just clarify what you&apos;re thinking in terms of a PR, please?

I can add <code>#&apos;ifn?</code> to the <code>predicate-schemas</code> and then these tests pass:

<pre>(testing &quot;ifn schemas&quot;
    (let [schema (m/schema ifn?)]
      (is (true? (m/validate schema (fn []))))
      (is (true? (m/validate schema (constantly 1))))
      (is (true? (m/validate schema :keyword)))
      (is (true? (m/validate schema (reify clojure.lang.IFn
                                      (invoke [_] &quot;Invoked!&quot;)))))))</pre>
Is that what you had in mind when you mentioned having an <code>ifn?</code> schema built in?</z><z id="t1618312194" t="ikitommi yes, but also mappings for transformers, generators, json-schema, humanized errors and clj-kondo."><y>#</y><d>2021-04-13</d><h>11:09</h><r>ikitommi</r>yes, but also mappings for transformers, generators, json-schema, humanized errors and clj-kondo.</z><z id="t1618312304" t="jcf I&apos;ll take a look at implementing the full feature set for the ifn? domain. 👍"><y>#</y><d>2021-04-13</d><h>11:11</h><r>jcf</r>I&apos;ll take a look at implementing the full feature set for the <code>ifn?</code> domain. <b>👍</b></z><z id="t1618312346" t="jcf I&apos;ll not implement proper generation of interesting functions. Don&apos;t want to put us all out of a job. 😉"><y>#</y><d>2021-04-13</d><h>11:12</h><r>jcf</r>I&apos;ll not implement proper generation of interesting functions. Don&apos;t want to put us all out of a job. <b>😉</b></z><z id="t1618312908" t="jcf Oh, I think I see what you mean. You want ifn? to be parameterised so you can schematize the args and return values…?"><y>#</y><d>2021-04-13</d><h>11:21</h><r>jcf</r>Oh, I think I see what you mean. You want <code>ifn?</code> to be parameterised so you can schematize the args and return values…?</z><z id="t1618312968" t="jcf So in the schema generator you can do something more than this: (defmethod -schema-generator &apos;ifn? [_ _] (gen/return ::ifn))"><y>#</y><d>2021-04-13</d><h>11:22</h><r>jcf</r>So in the schema generator you can do something more than this:

<pre>(defmethod -schema-generator &apos;ifn? [_ _] (gen/return ::ifn))</pre></z><z id="t1618313010" t="jcf I&apos;d need to generate a function that returns valid data given valid arguments."><y>#</y><d>2021-04-13</d><h>11:23</h><r>jcf</r>I&apos;d need to generate a function that returns valid data given valid arguments.</z><z id="t1618313025" t="ikitommi really, why?"><y>#</y><d>2021-04-13</d><h>11:23</h><r>ikitommi</r>really, why?</z><z id="t1618313044" t="ikitommi there is already :=&gt; and :function which have proper input &amp; output generators"><y>#</y><d>2021-04-13</d><h>11:24</h><r>ikitommi</r>there is already <code>:=&gt;</code> and <code>:function</code> which have proper input &amp; output generators</z><z id="t1618313049" t="jcf Because I thought that was what you wanted. 🙂"><y>#</y><d>2021-04-13</d><h>11:24</h><r>jcf</r>Because I thought that was what you wanted. <b>🙂</b></z><z id="t1618313053" t="jcf I think I misunderstood."><y>#</y><d>2021-04-13</d><h>11:24</h><r>jcf</r>I think I misunderstood.</z><z id="t1618313073" t="ikitommi no, just the simple thing, lke fn? but bit different 🙂"><y>#</y><d>2021-04-13</d><h>11:24</h><r>ikitommi</r>no, just the simple thing, lke <code>fn?</code> but bit different <b>🙂</b></z><z id="t1618313076" t="jcf If ifn? can remain a simple predicate, I should be able to have a first pass at a PR before the lunchtime walk. 🙂"><y>#</y><d>2021-04-13</d><h>11:24</h><r>jcf</r>If <code>ifn?</code> can remain a simple predicate, I should be able to have a first pass at a PR before the lunchtime walk. <b>🙂</b></z><z id="t1618313084" t="ikitommi 👍"><y>#</y><d>2021-04-13</d><h>11:24</h><r>ikitommi</r><b>👍</b></z><z id="t1618314447" t="jcf One pull request with my stab at adding ifn? to Malli&apos;s list of supported predicates. Gotta go for a lunchtime stroll with the pup; I&apos;ll check in when I&apos;m back in about an hour. 🙇 https://github.com/metosin/malli/pull/416"><y>#</y><d>2021-04-13</d><h>11:47</h><r>jcf</r>One pull request with my stab at adding <code>ifn?</code> to Malli&apos;s list of supported predicates. Gotta go for a lunchtime stroll with the pup; I&apos;ll check in when I&apos;m back in about an hour. <b>🙇</b>

<a href="https://github.com/metosin/malli/pull/416" target="_blank">https://github.com/metosin/malli/pull/416</a></z><z id="t1618310337" t="nilern Seems not"><y>#</y><d>2021-04-13</d><h>10:38</h><w>nilern</w>Seems not</z><z id="t1618314447" t="jcf One pull request with my stab at adding ifn? to Malli&apos;s list of supported predicates. Gotta go for a lunchtime stroll with the pup; I&apos;ll check in when I&apos;m back in about an hour. 🙇 https://github.com/metosin/malli/pull/416"><y>#</y><d>2021-04-13</d><h>11:47</h><w>jcf</w>One pull request with my stab at adding <code>ifn?</code> to Malli&apos;s list of supported predicates. Gotta go for a lunchtime stroll with the pup; I&apos;ll check in when I&apos;m back in about an hour. <b>🙇</b>

<a href="https://github.com/metosin/malli/pull/416" target="_blank">https://github.com/metosin/malli/pull/416</a></z><z id="t1618340325" t="yuhan Is it possible for schemas to self-reference? Naively trying to make a recursive schema causes a stack overflow: (malli/schema ::tree {:registry (merge (malli/default-schemas) {::node :int ::tree [:or ::node [:tuple ::tree ::tree]]})}) "><y>#</y><d>2021-04-13</d><h>18:58</h><w>yuhan</w>Is it possible for schemas to self-reference? Naively trying to make a recursive schema causes a stack overflow:
<pre>(malli/schema
  ::tree
  {:registry (merge (malli/default-schemas)
               {::node :int
                ::tree [:or
                        ::node
                        [:tuple ::tree ::tree]]})})
 </pre></z><z id="t1618340457" t="ikitommi [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] use the :ref , luke: (mg/generate (m/schema ::tree {:registry (merge (m/default-schemas) {::node :int ::tree [:or ::node [:tuple [:ref ::tree] [:ref ::tree]]]})}) {:seed 3}) ; =&gt; [[-26764 [[1 73136] [13307055 -1]]] [-381 [[-3 587742] -243724556]]]"><y>#</y><d>2021-04-13</d><h>19:00</h><w>ikitommi</w><a>@qythium</a> use the <code>:ref</code>, luke:
<pre>(mg/generate
  (m/schema
    ::tree
    {:registry (merge (m/default-schemas)
                      {::node :int
                       ::tree [:or
                               ::node
                               [:tuple [:ref ::tree] [:ref ::tree]]]})})
  {:seed 3})
; =&gt; [[-26764 [[1 73136] [13307055 -1]]] [-381 [[-3 587742] -243724556]]]</pre></z><z id="t1618340498" t="yuhan awesome, thanks!"><y>#</y><d>2021-04-13</d><h>19:01</h><w>yuhan</w>awesome, thanks!</z><z id="t1618342104" t="yuhan So schema references only in :ref and :map have to be qualified keywords? Strings appear to work too, but not plain keywords"><y>#</y><d>2021-04-13</d><h>19:28</h><w>yuhan</w>So schema references only in <code>:ref</code> and <code>:map</code> have to be qualified keywords? Strings appear to work too, but not plain keywords</z><z id="t1618342560" t="yuhan Seems like it, I found malli.core/-reference? in the source code which checks for qualified-keyword? or string?, but this doesn&apos;t seem to be documented"><y>#</y><d>2021-04-13</d><h>19:36</h><r>yuhan</r>Seems like it, I found  <code>malli.core/-reference?</code> in the source code which checks for qualified-keyword? or string?, but this doesn&apos;t seem to be documented</z><z id="t1618342270" t="yuhan Also it seems that the ::foo shorthand syntax doesn&apos;t work on the http://malli.io playground"><y>#</y><d>2021-04-13</d><h>19:31</h><w>yuhan</w>Also it seems that the <code>::foo</code> shorthand syntax doesn&apos;t work on the <a href="http://malli.io" target="_blank">http://malli.io</a> playground</z><z id="t1618342620" t="ikitommi yes, references should be qualified keywords or strings. http://malli.io … must be a sci-thing."><y>#</y><d>2021-04-13</d><h>19:37</h><w>ikitommi</w>yes, references should be qualified keywords or strings. <a href="http://malli.io" target="_blank">http://malli.io</a> … must be a sci-thing.</z><z id="t1618343107" t="yuhan Ok, filed an issue on the http://malli.io github"><y>#</y><d>2021-04-13</d><h>19:45</h><w>yuhan</w>Ok, filed an issue on the <a href="http://malli.io" target="_blank">http://malli.io</a> github</z><z id="t1618343378" t="yuhan Trying to use unqualified keys as references tripped me up quite a bit at the beginning, since this requirement isn&apos;t documented and the error message just says :malli.core/invalid-schema"><y>#</y><d>2021-04-13</d><h>19:49</h><w>yuhan</w>Trying to use unqualified keys as references tripped me up quite a bit at the beginning, since this requirement isn&apos;t documented and the error message just says <code>:malli.core/invalid-schema</code></z><z id="t1618343448" t="ikitommi doc enhancement PRs are most welcome."><y>#</y><d>2021-04-13</d><h>19:50</h><w>ikitommi</w>doc enhancement PRs are most welcome.</z><z id="t1618343502" t="ikitommi (the error keyword could be better here)"><y>#</y><d>2021-04-13</d><h>19:51</h><w>ikitommi</w>(the error keyword could be better here)</z><z id="t1618343864" t="yuhan I&apos;ll just file issues for now if that&apos;s ok - still in the early stages of experimenting with the library and not confident of writing docs"><y>#</y><d>2021-04-13</d><h>19:57</h><w>yuhan</w>I&apos;ll just file issues for now if that&apos;s ok - still in the early stages of experimenting with the library and not confident of writing docs</z><z id="t1618343998" t="yuhan Another strange thing I encountered: ;; This works as a schema [:map {:registry {::foo :int}} ::foo] ;; so does wrapping the keyword in a vector [:map {:registry {::foo :int}} [::foo]] ;; to pass it options [:map {:registry {::foo :int}} [::foo {:optional true}]] ;; These are ok too [:map {:registry {::foo [:tuple :int :int]}} ::foo] [:map {:registry {::foo [:tuple :int :int]}} [::foo {:optional true}]] ;; But not this?? (malli/schema [:map {:registry {::foo [:tuple :int :int]}} [::foo]]) ;; =&gt; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:16). ;; :malli.core/invalid-schema {:schema [:tuple :int :int]}"><y>#</y><d>2021-04-13</d><h>19:59</h><w>yuhan</w>Another strange thing I encountered:
<pre>;; This works as a schema
[:map {:registry {::foo :int}}
 ::foo]

;; so does wrapping the keyword in a vector
[:map {:registry {::foo :int}}
 [::foo]]
;; to pass it options
[:map {:registry {::foo :int}}
 [::foo {:optional true}]]


;; These are ok too
[:map {:registry {::foo [:tuple :int :int]}}
 ::foo]
[:map {:registry {::foo [:tuple :int :int]}}
 [::foo {:optional true}]]


;; But not this??
(malli/schema
  [:map {:registry {::foo [:tuple :int :int]}}
   [::foo]])
;; =&gt; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:16).
;;    :malli.core/invalid-schema {:schema [:tuple :int :int]}</pre></z><z id="t1618374443" t="ikitommi [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] looks like a bug in parsing entries."><y>#</y><d>2021-04-14</d><h>04:27</h><w>ikitommi</w><a>@qythium</a> looks like a bug in parsing entries.</z><z id="t1618374460" t="ikitommi weird thing that haven’t bumped into it before."><y>#</y><d>2021-04-14</d><h>04:27</h><w>ikitommi</w>weird thing that haven’t bumped into it before.</z><z id="t1618388879" t="Setzer22 I was wondering, is there dedicated support in function schemas to handle things like (fn [a, b, &amp; {:keys [c, d]}) I&apos;d like to be able to do: (m/=&gt; fn-name [:=&gt; [:cat Foo, Bar, [:map?? [:c Baz] [:d Other]]]]"><y>#</y><d>2021-04-14</d><h>08:27</h><w>Setzer22</w>I was wondering, is there dedicated support in function schemas to handle things like <code>(fn [a, b, &amp; {:keys [c, d]})</code>

I&apos;d like to be able to do: <code>(m/=&gt; fn-name [:=&gt; [:cat Foo, Bar, [:map?? [:c Baz] [:d Other]]]]</code></z><z id="t1618388966" t="Setzer22 I couldn&apos;t find something to put in place of :map?? in my example"><y>#</y><d>2021-04-14</d><h>08:29</h><w>Setzer22</w>I couldn&apos;t find something to put in place of <code>:map??</code> in my example</z><z id="t1618391287" t="nilern I don&apos;t think so You could do [:cat Foo, Bar, [:* [:alt [:cat [:= :c] :any] [:cat [:= :d] :any]]]] (permits duplicates, but so does the fn itself)"><y>#</y><d>2021-04-14</d><h>09:08</h><w>nilern</w>I don&apos;t think so
You could do <code>[:cat Foo, Bar, [:* [:alt [:cat [:= :c] :any] [:cat [:= :d] :any]]]]</code> (permits duplicates, but so does the fn itself)</z><z id="t1618391427" t="nilern It would be good to have something more convenient especially with Clojure 1.11: https://clojure.org/news/2021/03/18/apis-serving-people-and-programs"><y>#</y><d>2021-04-14</d><h>09:10</h><w>nilern</w>It would be good to have something more convenient especially with Clojure 1.11: <a href="https://clojure.org/news/2021/03/18/apis-serving-people-and-programs" target="_blank">https://clojure.org/news/2021/03/18/apis-serving-people-and-programs</a></z><z id="t1618391589" t="nilern Like [:cat Foo, Bar, [:alt [:* [:alt [:cat [:= :c] :any] [:cat [:= :d] :any]]] [:map [:c {:optional true} :any] [:d {:optional true} :any]]] or something can handle the 1.11 feature as well but who likes to write it even once"><y>#</y><d>2021-04-14</d><h>09:13</h><w>nilern</w>Like <code>[:cat Foo, Bar, [:alt [:* [:alt [:cat [:= :c] :any] [:cat [:= :d] :any]]] [:map [:c {:optional true} :any] [:d {:optional true} :any]]]</code> or something can handle the 1.11 feature as well but who likes to write it even once</z><z id="t1618391887" t="nilern You could write your own utility fn to generate that but really it should be built in to the fn schemas somehow"><y>#</y><d>2021-04-14</d><h>09:18</h><w>nilern</w>You could write your own utility fn to generate that but really it should be built in to the fn schemas somehow</z><z id="t1618391973" t="ikitommi maybe: [:cat Foo, Bar, [:&amp; [:c Baz] [:d Other]]] ?"><y>#</y><d>2021-04-14</d><h>09:19</h><w>ikitommi</w>maybe: <code>[:cat Foo, Bar, [:&amp; [:c Baz] [:d Other]]]</code>?</z><z id="t1618392472" t="nilern But it does not do normal varargs so :&amp; could be confusing. :&amp;n ?"><y>#</y><d>2021-04-14</d><h>09:27</h><w>nilern</w>But it does not do normal varargs so <code>:&amp;</code> could be confusing. <code>:&amp;n</code>?</z><z id="t1618594508" t="schmee is there a way to use Malli to remove nil values in a map? :thinking_face:"><y>#</y><d>2021-04-16</d><h>17:35</h><w>schmee</w>is there a way to use Malli to remove <code>nil</code> values in a map? <b>:thinking_face:</b></z><z id="t1618605271" t="Leonid Korogodski The oddest thing. I have two projects. Both use malli 0.2.1 (according to `lein deps :tree`). But one of them accepts the syntax `[:map [:a string?] [:b string?]]` just fine, while the other throws an error on `(restart)`: data-spec collection [] should be homogeneous, 3 values found Any idea what could be the cause?"><y>#</y><d>2021-04-16</d><h>20:34</h><w>Leonid Korogodski</w>The oddest thing. I have two projects. Both use malli 0.2.1 (according to `lein deps :tree`). But one of them accepts the syntax `[:map [:a string?] [:b string?]]` just fine, while the other throws an error on `(restart)`:
<pre>data-spec collection [] should be homogeneous, 3 values found</pre>
Any idea what could be the cause?</z><z id="t1618605318" t="borkdude [:attrs {:href &quot;/_/_/users/U01AQEJJ8NS&quot;}] Can you try with lein clean and then run your project again?"><y>#</y><d>2021-04-16</d><h>20:35</h><w>borkdude</w><a>@lkorogodski</a> Can you try with <code>lein clean</code> and then run your project again?</z><z id="t1618605333" t="borkdude You might have some left-overs in your target folder or something"><y>#</y><d>2021-04-16</d><h>20:35</h><w>borkdude</w>You might have some left-overs in your target folder or something</z><z id="t1618605402" t="Leonid Korogodski Same result."><y>#</y><d>2021-04-16</d><h>20:36</h><w>Leonid Korogodski</w>Same result.</z><z id="t1618606626" t="borkdude [:attrs {:href &quot;/_/_/users/U01AQEJJ8NS&quot;}] Please don&apos;t paste such long output into slack but rather use something like github gist"><y>#</y><d>2021-04-16</d><h>20:57</h><w>borkdude</w><a>@lkorogodski</a> Please don&apos;t paste such long output into slack but rather use something like github gist</z><z id="t1618606676" t="borkdude What happens when you do: (require &apos;[ :as io]) (io/resource &quot;malli/core__init.class&quot;)"><y>#</y><d>2021-04-16</d><h>20:57</h><w>borkdude</w>What happens when you do:
<pre>(require &apos;[ :as io])
(io/resource &quot;malli/core__init.class&quot;)</pre></z><z id="t1618606687" t="borkdude just checking if this isn&apos;t an AOT-related problem"><y>#</y><d>2021-04-16</d><h>20:58</h><w>borkdude</w>just checking if this isn&apos;t an AOT-related problem</z><z id="t1618611718" t="Leonid Korogodski Ok, sorry. Just a moment."><y>#</y><d>2021-04-16</d><h>22:21</h><w>Leonid Korogodski</w>Ok, sorry. Just a moment.</z><z id="t1618612052" t="Leonid Korogodski nREPL server started on port 64815 on host 127.0.0.1 - Connecting to local nREPL server... Clojure 1.10.3 (require &apos;[ :as io]) =&gt; nil (io/resource &quot;malli/core__init.class&quot;) =&gt; nil (require &apos;[malli.core :as m]) =&gt; nil (m/validator [:map [:a string?] [:b string?]]) =&gt; #object[malli.core$_map_schema$reify$reify__21001$fn__21022 0x5361e937 &quot; That seems to work. But when I call (restart) , it fails. The usage for the router is as follows: [&quot;/my-route&quot; {:get {:summary &quot;...&quot; :parameters {:header {:authorization string?} :query [:map [:a string?] [:b string?]} ;; other things }}]"><y>#</y><d>2021-04-16</d><h>22:27</h><w>Leonid Korogodski</w><pre>nREPL server started on port 64815 on host 127.0.0.1 - 
Connecting to local nREPL server...
Clojure 1.10.3
(require &apos;[ :as io])
=&gt; nil
(io/resource &quot;malli/core__init.class&quot;)
=&gt; nil
(require &apos;[malli.core :as m])
=&gt; nil
(m/validator [:map [:a string?] [:b string?]])
=&gt;
#object[malli.core$_map_schema$reify$reify__21001$fn__21022
        0x5361e937
        &quot;</pre>
That seems to work. But when I call <code>(restart)</code>, it fails.

The usage for the router is as follows:
<pre>[&quot;/my-route&quot; {:get {:summary    &quot;...&quot;
                    :parameters {:header {:authorization string?}
                                 :query  [:map
                                           [:a string?]
                                           [:b string?]}
                    ;; other things
                   }}]</pre></z><z id="t1618612439" t="Leonid Korogodski map? works in place of [:map ...] but doesn&apos;t check enough, of course."><y>#</y><d>2021-04-16</d><h>22:33</h><w>Leonid Korogodski</w><code>map?</code> works in place of <code>[:map ...]</code>  but doesn&apos;t check enough, of course.</z><z id="t1618626228" t="Leonid Korogodski (defn restart [] (mount.core/stop) (mount.core/start)) "><y>#</y><d>2021-04-17</d><h>02:23</h><w>Leonid Korogodski</w><pre>(defn restart []
  (mount.core/stop)
  (mount.core/start))</pre>
</z><z id="t1618661652" t="ikitommi [:attrs {:href &quot;/_/_/users/U01AQEJJ8NS&quot;}] in your example, there are both clojure specs (`:authorization)` and malli schemas (`:query)`. You should pick either one via :coercion option in the route data and use it in all the places. The error comes from spec-tools, so I believe you have coercion set to clojure.spec."><y>#</y><d>2021-04-17</d><h>12:14</h><w>ikitommi</w><a>@lkorogodski</a> in your example, there are both clojure specs (`:authorization)` and malli schemas (`:query)`. You should pick either one via <code>:coercion</code> option in the route data and use it in all the places. The error comes from spec-tools, so I believe you have coercion set to clojure.spec.</z><z id="t1618661691" t="ikitommi there are malli examples under examples . Hope this helps you to the right direction"><y>#</y><d>2021-04-17</d><h>12:14</h><w>ikitommi</w>there are malli examples under <code>examples</code> . Hope this helps you to the right direction</z><z id="t1618661869" t="ikitommi [:attrs {:href &quot;/_/_/users/U3L6TFEJF&quot;}] sure, nothing built-in I guess, but you can add a custom decoder into the :map schema, reduce over the all map entries and remove nils."><y>#</y><d>2021-04-17</d><h>12:17</h><w>ikitommi</w><a>@schmee</a> sure, nothing built-in I guess, but you can add a custom decoder into the <code>:map</code> schema, reduce over the all map entries and remove nils.</z><z id="t1618661938" t="ikitommi there are similar imps in malli.transform for stripping out extra keys and transforming keys."><y>#</y><d>2021-04-17</d><h>12:18</h><w>ikitommi</w>there are similar imps in <code>malli.transform</code> for stripping out extra keys and transforming keys.</z><z id="t1618663906" t="Leonid Korogodski Thanks!"><y>#</y><d>2021-04-17</d><h>12:51</h><w>Leonid Korogodski</w>Thanks!</z><z id="t1618665141" t="ikitommi looking at GraphQL fragments, would be relatively easy to support those in malli. But not sure if that would be a good idea. Maybe not."><y>#</y><d>2021-04-17</d><h>13:12</h><w>ikitommi</w>looking at GraphQL fragments, would be relatively easy to support those in malli. But not sure if that would be a good idea. Maybe not.</z><z id="t1618686283" t="eskos IIRC they&apos;re very close to Turing complete, so maybe not 🙂"><y>#</y><d>2021-04-17</d><h>19:04</h><r>eskos</r>IIRC they&apos;re very close to Turing complete, so maybe not <b>🙂</b></z><z id="t1618686380" t="eskos There&apos;s https://github.com/Vincit/venia which is data based so maybe have venia/Malli thingy instead? Would save you from implementing your own GraphQL parsing stuff as well."><y>#</y><d>2021-04-17</d><h>19:06</h><r>eskos</r>There&apos;s <a href="https://github.com/Vincit/venia" target="_blank">https://github.com/Vincit/venia</a> which is data based so maybe have venia/Malli thingy instead? Would save you from implementing your own GraphQL parsing stuff as well.</z><z id="t1618665183" t="ikitommi writing GraphQL&lt;-&gt;Malli would be easier with that for sure."><y>#</y><d>2021-04-17</d><h>13:13</h><w>ikitommi</w>writing GraphQL&lt;-&gt;Malli would be easier with that for sure.</z><z id="t1618815469" t="Hugh Powell I&apos;m trying to create a schema for a CSV data structure with defined, case insensitive headers. It must also be able to generate a legal data structure. I&apos;m using the same pattern as clojure.data.csv , a vector of vectors with the first vector representing the headers and the remaining vectors representing the rows. I can create a schema for the headers that checks validity fairly simply (def headers [:cat [:re &quot;(?i)header1&quot;] [:re &quot;(?i)header2&quot;] ... [:re &quot;(?i)headerN&quot;]]) But test.chunk doesn&apos;t handle flags (the (?i) bit), so I don&apos;t have a generator. My next guess is to create a schema that can match a given string case-insensitively and then a generator that will generate a randomly cased version of that string. I can write these two functions, but can&apos;t work out how to create a schema with them. Any thoughts or docs you can point me to?"><y>#</y><d>2021-04-19</d><h>06:57</h><w>Hugh Powell</w>I&apos;m trying to create a schema for a CSV data structure with defined, case insensitive headers. It must also be able to generate a legal data structure. I&apos;m using the same pattern as <code>clojure.data.csv</code>, a vector of vectors with the first vector representing the headers and the remaining vectors representing the rows. I can create a schema for the headers that checks validity fairly simply
<pre>(def headers
  [:cat
    [:re &quot;(?i)header1&quot;]
    [:re &quot;(?i)header2&quot;]
    ...
    [:re &quot;(?i)headerN&quot;]])</pre>
But <code>test.chunk</code> doesn&apos;t handle flags (the <code>(?i)</code> bit), so I don&apos;t have a generator.
My next guess is to create a schema that can match a given string case-insensitively and then a generator that will generate a randomly cased version of that string. I can write these two functions, but can&apos;t work out how to create a schema with them. Any thoughts or docs you can point me to?</z><z id="t1618818593" t="ikitommi [:attrs {:href &quot;/_/_/users/UB2GLDEN8&quot;}] maybe a custom generator? [:re {:gen/gen gen/alphanumric} &quot;(?i)header1&quot;]"><y>#</y><d>2021-04-19</d><h>07:49</h><w>ikitommi</w><a>@hugh336</a> maybe a custom generator? <code>[:re {:gen/gen gen/alphanumric} &quot;(?i)header1&quot;]</code></z><z id="t1618822932" t="Hugh Powell Aha! Awesome, thanks for the quick reply :thumbsup:"><y>#</y><d>2021-04-19</d><h>09:02</h><r>Hugh Powell</r>Aha! Awesome, thanks for the quick reply <b>:thumbsup:</b></z><z id="t1618824121" t="ikitommi here a {:gen/elements [&quot;header1&quot;]} would be good, just data and always correct."><y>#</y><d>2021-04-19</d><h>09:22</h><r>ikitommi</r>here a <code>{:gen/elements [&quot;header1&quot;]}</code> would be good, just data and always correct.</z><z id="t1618824159" t="ikitommi https://github.com/metosin/malli#value-generation"><y>#</y><d>2021-04-19</d><h>09:22</h><r>ikitommi</r><a href="https://github.com/metosin/malli#value-generation" target="_blank">https://github.com/metosin/malli#value-generation</a></z><z id="t1618842682" t="bartuka [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I also have several malli schemas that need to verify for [:fn (complement str/blank)] and I saw an open discussion from some years ago in Malli about adding validation of stripped strings to [:string] base schema"><y>#</y><d>2021-04-19</d><h>14:31</h><w>bartuka</w><a>@ikitommi</a> I also have several malli schemas that need to verify for <code>[:fn (complement str/blank)]</code> and I saw an open discussion from some years ago in Malli about adding validation of stripped strings to <code>[:string]</code> base schema</z><z id="t1618842690" t="bartuka is this still desired?"><y>#</y><d>2021-04-19</d><h>14:31</h><r>bartuka</r>is this still desired?</z><z id="t1618842724" t="bartuka not some years.. last year, sorry. thought was 2019 https://github.com/metosin/malli/pull/205"><y>#</y><d>2021-04-19</d><h>14:32</h><r>bartuka</r>not some years.. last year, sorry. thought was 2019 <a href="https://github.com/metosin/malli/pull/205" target="_blank">https://github.com/metosin/malli/pull/205</a></z><z id="t1618843218" t="ikitommi is the [:string {:min 1}] bad?"><y>#</y><d>2021-04-19</d><h>14:40</h><r>ikitommi</r>is the <code>[:string {:min 1}]</code> bad?</z><z id="t1618843259" t="ikitommi maybe (def NonEmptyString [:string {:min 1}]) liike we would do in Schema?"><y>#</y><d>2021-04-19</d><h>14:40</h><r>ikitommi</r>maybe <code>(def NonEmptyString [:string {:min 1}])</code> liike we would do in Schema?</z><z id="t1618843332" t="ikitommi or: [:map {:registry {::non-blank-string [:string {:min 1}]}} [:name ::non-blank-string] [:address [:map [:street ::non-blank-string]]]]"><y>#</y><d>2021-04-19</d><h>14:42</h><r>ikitommi</r>or:
<pre>[:map {:registry {::non-blank-string [:string {:min 1}]}}
 [:name ::non-blank-string]
 [:address [:map [:street ::non-blank-string]]]]</pre></z><z id="t1618844531" t="bartuka (m/validate [:string {:min 1}] &quot; &quot;) ;; =&gt; true but I expect false if no blank is allowed"><y>#</y><d>2021-04-19</d><h>15:02</h><r>bartuka</r><code>(m/validate [:string {:min 1}] &quot;    &quot;)</code> ;; =&gt;  true  but I expect false if no blank is allowed</z><z id="t1618844590" t="bartuka I like the idea of using {:trim true :min 1 :max 99} .. looks very clean and we dont need to add custom registries"><y>#</y><d>2021-04-19</d><h>15:03</h><r>bartuka</r>I like the idea of using <code>{:trim true :min 1 :max 99}</code> .. looks very clean and we dont need to add custom registries</z><z id="t1618905836" t="Sathiya Is there an option to support blank string in :enum schema. :maybe supports nil but not blank values. currently i used [:or empty? [:enum &quot;foo&quot; &quot;bar&quot;]] to do this validation but is there a way to create a optional-enum registry that supports this scenario. The problem I&apos;m facing using :or is I&apos;m getting two error messages for each options. It would be better to have one message that says, value can be blank or either one of the valid values"><y>#</y><d>2021-04-20</d><h>08:03</h><w>Sathiya</w>Is there an option to support blank string in <code>:enum</code> schema. <code>:maybe</code> supports nil but not blank values. currently i used <code>[:or empty? [:enum &quot;foo&quot; &quot;bar&quot;]]</code> to do this validation but is there a way to create a optional-enum registry that supports this scenario. The problem I&apos;m facing using <code>:or</code> is I&apos;m getting two error messages for each options. It would be better to have one message that says, value can be blank or either one of the valid values</z><z id="t1618906071" t="delaguardo [:enum &quot;&quot; &quot;foo&quot; &quot;bar&quot;] should work https://malli.io/?value=1&amp;amp;schema=%5B%3Aenum%20%22%22%20%22foo%22%20%22bar%22%5D"><y>#</y><d>2021-04-20</d><h>08:07</h><r>delaguardo</r><code>[:enum &quot;&quot; &quot;foo&quot; &quot;bar&quot;]</code> should work
<a href="https://malli.io/?value=1&amp;amp;schema=%5B%3Aenum%20%22%22%20%22foo%22%20%22bar%22%5D" target="_blank">https://malli.io/?value=1&amp;amp;schema=%5B%3Aenum%20%22%22%20%22foo%22%20%22bar%22%5D</a></z><z id="t1618906100" t="delaguardo however error message will hide empty string"><y>#</y><d>2021-04-20</d><h>08:08</h><r>delaguardo</r>however error message will hide empty string</z><z id="t1618906126" t="delaguardo [&quot;should be either , foo or bar&quot;]"><y>#</y><d>2021-04-20</d><h>08:08</h><r>delaguardo</r><code>[&quot;should be either , foo or bar&quot;]</code></z><z id="t1618914252" t="Sathiya Thanks [:attrs {:href &quot;/_/_/users/U04V4KLKC&quot;}]"><y>#</y><d>2021-04-20</d><h>10:24</h><r>Sathiya</r>Thanks <a>@U04V4KLKC</a></z><z id="t1618919742" t="anonimitoraf Hi guys, I came across https://github.com/metosin/malli/issues/125 when looking for ways to &quot;instrument&quot; functions. My question is, how do you guys &quot;instrument&quot; functions with malli at the moment?"><y>#</y><d>2021-04-20</d><h>11:55</h><w>anonimitoraf</w>Hi guys, I came across <a href="https://github.com/metosin/malli/issues/125" target="_blank">https://github.com/metosin/malli/issues/125</a> when looking for ways to &quot;instrument&quot; functions.
My question is, how do you guys &quot;instrument&quot; functions with <code>malli</code> at the moment?</z><z id="t1618942354" t="Ivan Fedorov Hey folks 👋 Are you aware of any generators built on malli ? Interested in crux pull vector, pathom resolvers, entity constructors, fulcro queries"><y>#</y><d>2021-04-20</d><h>18:12</h><w>Ivan Fedorov</w>Hey folks <b>👋</b>
Are you aware of any generators built on malli ?
Interested in crux pull vector, pathom resolvers, entity constructors, fulcro queries</z><z id="t1618952595" t="ikitommi commented on the instrument issue, sorry for the lag."><y>#</y><d>2021-04-20</d><h>21:03</h><w>ikitommi</w>commented on the <code>instrument</code> issue, sorry for the lag.</z><z id="t1618952600" t="ikitommi https://github.com/metosin/malli/issues/349#issuecomment-823596409"><y>#</y><d>2021-04-20</d><h>21:03</h><r>ikitommi</r><a href="https://github.com/metosin/malli/issues/349#issuecomment-823596409" target="_blank">https://github.com/metosin/malli/issues/349#issuecomment-823596409</a></z><z id="t1618987092" t="anonimitoraf Thanks for the update! Looks good!"><y>#</y><d>2021-04-21</d><h>06:38</h><r>anonimitoraf</r>Thanks for the update! Looks good!</z><z id="t1618952692" t="ikitommi [:attrs {:href &quot;/_/_/users/U9ABG0ERZ&quot;}] do you mean value generators or schema generators (providers)? Both would be cool. plan is to support EQL for slicing schemas at some point."><y>#</y><d>2021-04-20</d><h>21:04</h><w>ikitommi</w><a>@d.ian.b</a> do you mean value generators or schema generators (providers)? Both would be cool. plan is to support EQL for slicing schemas at some point.</z><z id="t1618956492" t="refset Uhh, I think the wrong I.F. 🙂 /cc [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}]"><y>#</y><d>2021-04-20</d><h>22:08</h><r>refset</r>Uhh, I think the wrong I.F. <b>🙂</b> /cc <a>@U0A5V8ZR6</a></z><z id="t1618987895" t="Ivan Fedorov I mean codegen. I want to describe malli schema and then have all the goodies (pull vectors, pathom resolvers, etc) generated. I may end up doing it myself, just asking if you have seen anything like this already."><y>#</y><d>2021-04-21</d><h>06:51</h><r>Ivan Fedorov</r>I mean codegen. I want to describe malli schema and then have all the goodies (pull vectors, pathom resolvers, etc) generated.

I may end up doing it myself, just asking if you have seen anything like this already.</z><z id="t1618992216" t="ikitommi don’t think such things exist yet, go for it 🙂 the current malli lib has a lot of optional ns’s for external things (json schema, dot, etc), not sure where the limit should be - what optional things should be in the core lib (as optional namespaces) and which should be separate libs. At least EQL&lt;-&gt;Malli could be in the core. Or then just redesign the code into a monorepo like reitit and make all the extras as separate modules."><y>#</y><d>2021-04-21</d><h>08:03</h><r>ikitommi</r>don’t think such things exist yet, go for it <b>🙂</b> the current malli lib has a lot of optional ns’s for external things (json schema, dot, etc), not sure where the limit should be - what optional things should be in the core lib (as optional namespaces) and which should be separate libs. At least EQL&lt;-&gt;Malli could be in the core. Or then just redesign the code into a monorepo like reitit and make all the extras as separate modules.</z><z id="t1619060345" t="rutledgepaulv I don&apos;t mind things being in core if they don&apos;t require dependencies but if it&apos;s going to bloat the malli dep tree would prefer separate modules so I can keep my projects lean. Maybe that&apos;s an easy way to draw the line?"><y>#</y><d>2021-04-22</d><h>02:59</h><r>rutledgepaulv</r>I don&apos;t mind things being in core if they don&apos;t require dependencies but if it&apos;s going to bloat the malli dep tree would prefer separate modules so I can keep my projects lean. Maybe that&apos;s an easy way to draw the line?</z><z id="t1619447301" t="Ian Fernandez [:attrs {:href &quot;/_/_/users/U28A9C90Q&quot;}] [:attrs {:href &quot;/_/_/users/U3Y18N0UC&quot;}]"><y>#</y><d>2021-04-26</d><h>14:28</h><r>Ian Fernandez</r><a>@U28A9C90Q</a> <a>@U3Y18N0UC</a></z><z id="t1619452079" t="marciol To me seems that at first glance it&apos;d be better to separate all functionality that isn&apos;t essential to make Malli works in separated libs, but if we think about Malli as a full experience in terms of how to deal with schemas - and I hope that it became the best in class tool to work with external data, to such a point that people of other ecosystems really envy the Malli experience - I think that the full-batteries included is a better approach, so I really don&apos;t mind if all those niceties are included on Malli itself."><y>#</y><d>2021-04-26</d><h>15:47</h><r>marciol</r>To me seems that at first glance it&apos;d be better to separate all functionality that isn&apos;t essential to make Malli works in separated libs, but if we think about Malli as a full experience in terms of how to deal with schemas - and I hope that it became the best in class tool to work with external data, to such a point that people of other ecosystems really envy the Malli experience - I think that the full-batteries included is a better approach, so I really don&apos;t mind if all those niceties are included on Malli itself.</z><z id="t1618952840" t="ikitommi oh, and merged 414, breaking change for the extender api. But schemas can now be described with schemas (just need to describe all schemas first :)), the new IntoSchema protocol: (defprotocol IntoSchema (-type [this] &quot;returns type of the schema&quot;) (-type-properties [this] &quot;returns schema type properties&quot;) (-properties-schema [this] &quot;maybe returns :map schema describing schema properties&quot;) (-children-schema [this] &quot;maybe returns sequence schema describing schema children&quot;) (-into-schema [this properties children options] &quot;creates a new schema instance&quot;))"><y>#</y><d>2021-04-20</d><h>21:07</h><w>ikitommi</w>oh, and merged 414, breaking change for the extender api. But schemas can now be described with schemas (just need to describe all schemas first :)), the new <code>IntoSchema</code> protocol:
<pre>(defprotocol IntoSchema
  (-type [this] &quot;returns type of the schema&quot;)
  (-type-properties [this] &quot;returns schema type properties&quot;)
  (-properties-schema [this] &quot;maybe returns :map schema describing schema properties&quot;)
  (-children-schema [this] &quot;maybe returns sequence schema describing schema children&quot;)
  (-into-schema [this properties children options] &quot;creates a new schema instance&quot;))</pre></z><z id="t1618952914" t="ikitommi also, most malli.util functions got bit faster as schema instances now have a direct handle to parent, no need to create new instances. which is nice."><y>#</y><d>2021-04-20</d><h>21:08</h><w>ikitommi</w>also, most <code>malli.util</code>functions got bit faster as schema instances now have a direct handle to parent, no need to create new instances. which is nice.</z><z id="t1618952959" t="ikitommi e.g. ´m/type` is looked via the parent: (defn type &quot;Returns the Schema type.&quot; ([?schema] (type ?schema nil)) ([?schema options] (-type (-parent (schema ?schema options)))))"><y>#</y><d>2021-04-20</d><h>21:09</h><w>ikitommi</w>e.g. ´m/type`  is looked via the parent:
<pre>(defn type
  &quot;Returns the Schema type.&quot;
  ([?schema]
   (type ?schema nil))
  ([?schema options]
   (-type (-parent (schema ?schema options)))))</pre></z><z id="t1618952986" t="ikitommi so, the public api remains the same."><y>#</y><d>2021-04-20</d><h>21:09</h><w>ikitommi</w>so, the public api remains the same.</z><z id="t1618992216" t="ikitommi don’t think such things exist yet, go for it 🙂 the current malli lib has a lot of optional ns’s for external things (json schema, dot, etc), not sure where the limit should be - what optional things should be in the core lib (as optional namespaces) and which should be separate libs. At least EQL&lt;-&gt;Malli could be in the core. Or then just redesign the code into a monorepo like reitit and make all the extras as separate modules."><y>#</y><d>2021-04-21</d><h>08:03</h><w>ikitommi</w>don’t think such things exist yet, go for it <b>🙂</b> the current malli lib has a lot of optional ns’s for external things (json schema, dot, etc), not sure where the limit should be - what optional things should be in the core lib (as optional namespaces) and which should be separate libs. At least EQL&lt;-&gt;Malli could be in the core. Or then just redesign the code into a monorepo like reitit and make all the extras as separate modules.</z><z id="t1618997551" t="nilern Let&apos;s not forget https://github.com/kwrooijen/gungnir"><y>#</y><d>2021-04-21</d><h>09:32</h><w>nilern</w>Let&apos;s not forget <a href="https://github.com/kwrooijen/gungnir" target="_blank">https://github.com/kwrooijen/gungnir</a></z><z id="t1619006445" t="andrea.crotti I&apos;m just trying malli for the first time today, and it looks pretty great already"><y>#</y><d>2021-04-21</d><h>12:00</h><w>andrea.crotti</w>I&apos;m just trying malli for the first time today, and it looks pretty great already</z><z id="t1619006513" t="andrea.crotti one thing I didn&apos;t quite understand though, if I annotate a function with (m/=&gt; ... is there a way to actually force that check at runtime to make it fail when the schema doesn&apos;t match? I only see that related with generating a clj-kondo config, which is great but I thought that run-time assertions would be also there, even if disabled by default maybe"><y>#</y><d>2021-04-21</d><h>12:01</h><w>andrea.crotti</w>one thing I didn&apos;t quite understand though, if I annotate a function with <code>(m/=&gt; ...</code>
is there a way to actually force that check at runtime to make it fail when the schema doesn&apos;t match?
I only see that related with generating a clj-kondo config, which is great but I thought that run-time assertions would be also there, even if disabled by default maybe</z><z id="t1619006793" t="nilern https://github.com/metosin/malli/issues/349 but [:attrs {:href &quot;/_/_/users/U70027S0N&quot;}] has a working implementation https://github.com/setzer22/malli-instrument"><y>#</y><d>2021-04-21</d><h>12:06</h><w>nilern</w><a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a> but <a>@setzer22</a> has a working implementation <a href="https://github.com/setzer22/malli-instrument" target="_blank">https://github.com/setzer22/malli-instrument</a></z><z id="t1619006950" t="Setzer22 Yes, I&apos;ve been using my implementation for a couple of weeks now 👍 The base features are working, but sometimes malli has trouble generating human readable descriptions of errors"><y>#</y><d>2021-04-21</d><h>12:09</h><w>Setzer22</w>Yes, I&apos;ve been using my implementation for a couple of weeks now <b>👍</b> The base features are working, but sometimes malli has trouble generating human readable descriptions of errors</z><z id="t1619006977" t="Setzer22 if you give it a try, please report any issues!"><y>#</y><d>2021-04-21</d><h>12:09</h><w>Setzer22</w>if you give it a try, please report any issues!</z><z id="t1619007267" t="andrea.crotti ah nice, yeah no rush was just wondering if I missed something from the docs"><y>#</y><d>2021-04-21</d><h>12:14</h><w>andrea.crotti</w>ah nice, yeah no rush was just wondering if I missed something from the docs</z><z id="t1619008942" t="ikitommi [:attrs {:href &quot;/_/_/users/U70027S0N&quot;}] yes, there is an open PR about robust humanized errors. Few combinations that don’t work, but the idea to fix it seems legit."><y>#</y><d>2021-04-21</d><h>12:42</h><w>ikitommi</w><a>@setzer22</a> yes, there is an open PR about robust humanized errors. Few combinations that don’t work, but the idea to fix it seems legit.</z><z id="t1619009688" t="Setzer22 [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Good to know!"><y>#</y><d>2021-04-21</d><h>12:54</h><w>Setzer22</w><a>@ikitommi</a> Good to know!</z><z id="t1619010943" t="andrea.crotti another thing I noticed is that there isn&apos;t a way to just throw an exception if something fails to validate. I ended up with something like (let [my-map ... errors (m/explain schema my-map)] (if (nil? errors) my-map (throw (ex-info &quot;validation failed&quot; errors))) but isnt&apos;t there an easier way to do that?"><y>#</y><d>2021-04-21</d><h>13:15</h><w>andrea.crotti</w>another thing I noticed is that there isn&apos;t a way to just throw an exception if something fails to validate. I ended up with something like
<pre>(let [my-map ...
       errors (m/explain schema my-map)]
  (if (nil? errors) my-map (throw (ex-info &quot;validation failed&quot; errors)))</pre>
but isnt&apos;t there an easier way to do that?</z><z id="t1619011343" t="nilern We should have an assert..."><y>#</y><d>2021-04-21</d><h>13:22</h><w>nilern</w>We should have an assert...</z><z id="t1619011625" t="nilern There wasn&apos;t even an issue so I made one https://github.com/metosin/malli/issues/420"><y>#</y><d>2021-04-21</d><h>13:27</h><w>nilern</w>There wasn&apos;t even an issue so I made one <a href="https://github.com/metosin/malli/issues/420" target="_blank">https://github.com/metosin/malli/issues/420</a></z><z id="t1619013408" t="nilern Hmm hard to make an efficient assert that makes the validator and explainer behind the scenes. Especially Cljs would be tricky."><y>#</y><d>2021-04-21</d><h>13:56</h><w>nilern</w>Hmm hard to make an efficient assert that makes the <code>validator</code> and <code>explainer</code> behind the scenes. Especially Cljs would be tricky.</z><z id="t1619020063" t="andrea.crotti mm maybe you don&apos;t always need the explainer"><y>#</y><d>2021-04-21</d><h>15:47</h><r>andrea.crotti</r>mm maybe you don&apos;t always need the explainer</z><z id="t1619020079" t="andrea.crotti would be nice I guess but not sure it needs to be the default"><y>#</y><d>2021-04-21</d><h>15:47</h><r>andrea.crotti</r>would be nice I guess but not sure it needs to be the default</z><z id="t1619020588" t="nilern Dropping the explainer does not make it any easier."><y>#</y><d>2021-04-21</d><h>15:56</h><r>nilern</r>Dropping the <code>explainer</code> does not make it any easier.</z><z id="t1619026446" t="yuhan Thanks for creating the issue! it must have slipped my mind. Do you mean caching a validator at the assert&apos;s compile time? I would be worried about the validator then going out of sync when you redefine the schema during dev time"><y>#</y><d>2021-04-21</d><h>17:34</h><r>yuhan</r>Thanks for creating the issue! it must have slipped my mind.
Do you mean caching a validator at the assert&apos;s compile time? I would be worried about the validator then going out of sync when you redefine the schema during dev time</z><z id="t1619026724" t="yuhan Maybe the *assert* dynamic var could have 3 levels: • runtime validate (slowest but correct) • compile-time validator (more efficient, use if schemas are fixed) • compiles to nil"><y>#</y><d>2021-04-21</d><h>17:38</h><r>yuhan</r>Maybe the <code>*assert*</code> dynamic var could have 3 levels:
• runtime <code>validate</code> (slowest but correct) 
• compile-time <code>validator</code> (more efficient, use if schemas are fixed) 
• compiles to <code>nil</code></z><z id="t1619096898" t="nilern Yeah I figured you just forgot. And I did mean the assert macro would create the validator"><y>#</y><d>2021-04-22</d><h>13:08</h><r>nilern</r>Yeah I figured you just forgot.
And I did mean the assert macro would create the validator</z><z id="t1619097002" t="nilern It is probably ok to not do that in dev mode although sometimes assertion overhead is too much even then"><y>#</y><d>2021-04-22</d><h>13:10</h><r>nilern</r>It is probably ok to not do that in dev mode although sometimes assertion overhead is too much even then</z><z id="t1619053968" t="Zaymon Hey all. I might be missing something essential here but I don’t fundamentally understand why this won’t compile: (defn longer-than-5? [x] (&lt;= 5 (count x))) (def MySchema [:map [:some-key [:and string? longer-than-5?]]]) ; :malli.core/invalid-schema {:schema #function[example/longer-than-5?]} Is there something special about string? , int? ect that makes them more than just a function from a -&gt; bool ?"><y>#</y><d>2021-04-22</d><h>01:12</h><w>Zaymon</w>Hey all. I might be missing something essential here but I don’t fundamentally understand why this won’t compile:

<pre>(defn longer-than-5? [x] (&lt;= 5 (count x)))
(def MySchema [:map [:some-key [:and string? longer-than-5?]]])

; :malli.core/invalid-schema {:schema #function[example/longer-than-5?]}</pre>
Is there something special about <code>string?</code>, <code>int?</code> ect that makes them more than just a function from <code>a -&gt; bool</code> ?</z><z id="t1619055362" t="Zaymon Looks like I need to specify the function with [:fn longer-than-5?] !"><y>#</y><d>2021-04-22</d><h>01:36</h><r>Zaymon</r>Looks like I need to specify the function with <code>[:fn longer-than-5?]</code> !</z><z id="t1619097152" t="nilern What is special is that they are in the m/predicate-schemas registry which is merged into the default registry"><y>#</y><d>2021-04-22</d><h>13:12</h><r>nilern</r>What is special is that they are in the <code>m/predicate-schemas</code> registry which is merged into the default registry</z><z id="t1619141835" t="Zaymon [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] That’s interesting. Thank you"><y>#</y><d>2021-04-23</d><h>01:37</h><r>Zaymon</r><a>@U4MB6UKDL</a> That’s interesting. Thank you</z><z id="t1619083281" t="Yevgeni Tsodikov Hi, I think the strip-extra-keys-transformer removes mandatory fields if there are in an [:or ... ] vector: (def my-schema [:and [:map [:a int?]] [:or [:map [:b int?]] [:map [:c int?]]]]) =&gt; #&apos;... (m/validate my-schema {:a 1}) =&gt; false (m/validate my-schema {:a 1 :b 1 :c 1}) =&gt; true (m/decode my-schema {:a 1 :b 1 :c 1} (mt/transformer mt/strip-extra-keys-transformer)) =&gt; {:a 1} Did I configure the schema wrong? How can I work around it?"><y>#</y><d>2021-04-22</d><h>09:21</h><w>Yevgeni Tsodikov</w>Hi,
I think the <code>strip-extra-keys-transformer</code> removes mandatory fields if there are in an <code>[:or ... ]</code> vector:
<pre>(def my-schema [:and
                [:map [:a int?]]
                [:or
                 [:map [:b int?]]
                 [:map [:c int?]]]])
=&gt; #&apos;...
(m/validate my-schema {:a 1})
=&gt; false
(m/validate my-schema {:a 1 :b 1 :c 1})
=&gt; true
(m/decode my-schema {:a 1 :b 1 :c 1} (mt/transformer mt/strip-extra-keys-transformer))
=&gt; {:a 1}</pre>
Did I configure the schema wrong?
How can I work around it?</z><z id="t1619083512" t="ikitommi maybe: [:and [:map [:a int?] [:b {:optional true} int?] [:c {:optional true} int?]] [:fn {:error/messag &quot;only :a or :b is allowed&quot;} (fn [{:keys [b c]}] (not (and b c)))]] or: [:or [:map [:a int?] [:b int?]] [:map [:a int?] [:c int?]]] would those work for you?"><y>#</y><d>2021-04-22</d><h>09:25</h><w>ikitommi</w>maybe:
<pre>[:and
 [:map 
  [:a int?]
  [:b {:optional true} int?]
  [:c {:optional true} int?]]
 [:fn {:error/messag &quot;only :a or :b is allowed&quot;}
  (fn [{:keys [b c]}] (not (and b c)))]]</pre>
or:
<pre>[:or
 [:map
  [:a int?]
  [:b int?]]
 [:map
  [:a int?]
  [:c int?]]]</pre>
would those work for you?</z><z id="t1619083558" t="Yevgeni Tsodikov Checking, I want to see how they integrate with reitit ’s swagger docs"><y>#</y><d>2021-04-22</d><h>09:25</h><r>Yevgeni Tsodikov</r>Checking, I want to see how they integrate with <code>reitit</code> ’s swagger docs</z><z id="t1619083619" t="ikitommi you can run from repl: (malli.swagger/transform [:and [:map [:a int?] [:b {:optional true} int?] [:c {:optional true} int?]] [:fn {:error/messag &quot;only :a or :b is allowed&quot;} (fn [{:keys [b c]}] (not (and b c)))]]) to see what comes out."><y>#</y><d>2021-04-22</d><h>09:26</h><r>ikitommi</r>you can run from repl:
<pre>(malli.swagger/transform
  [:and
   [:map 
    [:a int?]
    [:b {:optional true} int?]
    [:c {:optional true} int?]]
   [:fn {:error/messag &quot;only :a or :b is allowed&quot;}
    (fn [{:keys [b c]}] (not (and b c)))]])</pre>
to see what comes out.</z><z id="t1619083649" t="ikitommi swagger doesn’t support anyOf JSON Schema, so the latter will not show in swaggr docs."><y>#</y><d>2021-04-22</d><h>09:27</h><r>ikitommi</r>swagger doesn’t support <code>anyOf</code> JSON Schema, so the latter will not show in swaggr docs.</z><z id="t1619083659" t="ikitommi openapi has that, but not integrated into reiti."><y>#</y><d>2021-04-22</d><h>09:27</h><r>ikitommi</r>openapi has that, but not integrated into reiti.</z><z id="t1619087165" t="Yevgeni Tsodikov I’ve used the first option, it worked for me. Thanks!"><y>#</y><d>2021-04-22</d><h>10:26</h><r>Yevgeni Tsodikov</r>I’ve used the first option, it worked for me.
Thanks!</z><z id="t1619085075" t="Dos Hi [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I am facing interesting behavior with explain. I don&apos;t understand why order matters..."><y>#</y><d>2021-04-22</d><h>09:51</h><w>Dos</w>Hi <a>@ikitommi</a>
I am facing interesting behavior with explain. I don&apos;t understand why order matters...</z><z id="t1619085205" t="Dos (def params-function? (malli/schema [:function [:=&gt; [:cat map? [:maybe map?] map?] map?]] {::malli/function-checker malli.generator/function-checker})) (def next-function? (malli/schema [:function [:=&gt; [:cat map? [:maybe map?] map?] keyword?]] {::malli/function-checker malli.generator/function-checker}))"><y>#</y><d>2021-04-22</d><h>09:53</h><r>Dos</r><pre>(def params-function?
  (malli/schema
   [:function
    [:=&gt; [:cat map? [:maybe map?] map?] map?]]
   {::malli/function-checker malli.generator/function-checker}))

(def next-function?
  (malli/schema
   [:function
    [:=&gt; [:cat map? [:maybe map?] map?] keyword?]]
   {::malli/function-checker malli.generator/function-checker}))</pre></z><z id="t1619099220" t="ikitommi [:attrs {:href &quot;/_/_/users/U0D8J9T5K&quot;}] oh, that’s bad. will fix it."><y>#</y><d>2021-04-22</d><h>13:47</h><r>ikitommi</r><a>@U0D8J9T5K</a> oh, that’s bad. will fix it.</z><z id="t1619103153" t="ikitommi Fixed in master: https://github.com/metosin/malli/pull/421"><y>#</y><d>2021-04-22</d><h>14:52</h><r>ikitommi</r>Fixed in master: <a href="https://github.com/metosin/malli/pull/421" target="_blank">https://github.com/metosin/malli/pull/421</a></z><z id="t1619286646" t="ikitommi :gen/schema … this might be useful: (mg/sample [:any {:gen/schema :int}]) ; =&gt; (0 -1 -2 1 0 0 18 1 -3 -1) (mg/sample [:string {:gen/schema [:int {:gen/min 10, :gen/max 100}], :gen/fmap &apos;str}]) ; =&gt; (&quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; &quot;13&quot; &quot;13&quot; &quot;66&quot;)"><y>#</y><d>2021-04-24</d><h>17:50</h><w>ikitommi</w><code>:gen/schema</code> … this might be useful:
<pre>(mg/sample [:any {:gen/schema :int}])
; =&gt; (0 -1 -2 1 0 0 18 1 -3 -1)

(mg/sample [:string {:gen/schema [:int {:gen/min 10, :gen/max 100}], :gen/fmap &apos;str}])
; =&gt; (&quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; &quot;10&quot; &quot;13&quot; &quot;13&quot; &quot;66&quot;)</pre></z><z id="t1619508014" t="Adam Helins After WASM, I am now describing a Lisp using Malli and once again am doing heavy use of recursive generation. I&apos;m probably gonna be spamming a few questions in the following days. That kind of :set are always empty, am I doing something wrong with :ref ? No such problem with :vector . (malli.gen/sample [:set {:registry {::foo :int}} [:ref ::foo]])"><y>#</y><d>2021-04-27</d><h>07:20</h><w>Adam Helins</w>After WASM, I am now describing a Lisp using Malli and once again am doing heavy use of recursive generation. I&apos;m probably gonna be spamming a few questions in the following days.

That kind of <code>:set</code> are always empty, am I doing something wrong with <code>:ref</code>? No such problem with  <code>:vector</code>.

<pre>(malli.gen/sample [:set
                   {:registry {::foo :int}}
                   [:ref ::foo]])</pre></z><z id="t1619523843" t="Adam Helins Is there any design decision behind not generating NaN and Infinity? (defmethod -schema-generator :double [schema options] (gen/double* (merge (-min-max schema options) {:infinite? false, :NaN? false})))"><y>#</y><d>2021-04-27</d><h>11:44</h><w>Adam Helins</w>Is there any design decision behind not generating NaN and Infinity?

<pre>(defmethod -schema-generator :double [schema options] (gen/double* (merge (-min-max schema options) {:infinite? false, :NaN? false})))</pre></z><z id="t1619523949" t="Ivan Fedorov Any good intro? I’m playing with schemas, and can’t see a formal definition of it in README Currently I’m thinking that [:schema] schemas must have a :registry followed by a single root subschema reference. I’ve watched the talk by Tommi Reiman from London Clojurians. It’s helpful, but I’m lacking some formal learning material. Thanks in advance!"><y>#</y><d>2021-04-27</d><h>11:45</h><w>Ivan Fedorov</w>Any good intro? I’m playing with schemas, and can’t see a formal definition of it in README

Currently I’m thinking that <code>[:schema]</code> schemas must have a :registry followed by a single root subschema reference.

I’ve watched the talk by Tommi Reiman from London Clojurians. It’s helpful, but I’m lacking some formal learning material.
Thanks in advance!</z><z id="t1619525414" t="Ivan Fedorov I’m trying to understand the best way to describe the entity types of an app. Probably it’s just a single big registry then and multiple (def schema:entity-type-n) using it."><y>#</y><d>2021-04-27</d><h>12:10</h><w>Ivan Fedorov</w>I’m trying to understand the best way to describe the entity types of an app.
Probably it’s just a single big registry then and multiple <code>(def schema:entity-type-n)</code>  using it.</z><z id="t1619549286" t="ikitommi [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}] most malli-based projects I’ve seen use a mutable global registry with custom register function like spec (README has a guide how to set that up), registering looks like: (register :user/id :int) you can also just define schemas as var in schema style, using the default immutable regisitry: (def Userid :int) there was an Entities and Values guide in the README, but it was removed."><y>#</y><d>2021-04-27</d><h>18:48</h><w>ikitommi</w><a>@ognivo</a> most malli-based projects I’ve seen use a mutable global registry with custom <code>register</code> function like spec (README has a guide how to set that up), registering looks like:
<pre>(register :user/id :int)</pre>
you can also just define schemas as var in schema style, using the default immutable regisitry:
<pre>(def Userid :int)</pre>
there was an <code>Entities and Values</code> guide in the README, but it was removed.</z><z id="t1619623418" t="Ben Sless It&apos;s also possible to delay schema compilation and registry instantiation to start-up time. I built a registry dynamically and injected it into a Component system, the registry itself contained content dependent schemas which depended on input arguments. It was fun. I might cajole my employer to let write something about it"><y>#</y><d>2021-04-28</d><h>15:23</h><r>Ben Sless</r>It&apos;s also possible to delay schema compilation and registry instantiation to start-up time.
I built a registry dynamically and injected it into a Component system, the registry itself contained content dependent schemas which depended on input arguments. It was fun. I might cajole my employer to let write something about it</z><z id="t1619628737" t="ikitommi looking forward to that!"><y>#</y><d>2021-04-28</d><h>16:52</h><r>ikitommi</r>looking forward to that!</z><z id="t1619609992" t="pithyless I’m reworking some error handling - especially dev vs prod. What’s the story with virhe ? Is there a version of that coming soon? Or perhaps even some reflections and retrospectives that we could apply to our own work?"><y>#</y><d>2021-04-28</d><h>11:39</h><w>pithyless</w>I’m reworking some error handling - especially dev vs prod. What’s the story with <code>virhe</code>? Is there a version of that coming soon? Or perhaps even some reflections and retrospectives that we could apply to our own work?</z><z id="t1619629059" t="ikitommi [:attrs {:href &quot;/_/_/users/U05476190&quot;}] there is a unpublished copy of reitit-error-pretty-printer in malli. should extract the common parts of malli + reitit and push out to virhe. to be honest, might be better if virhe was a community owned clj-commons library, not ours. there would be a lot to do with colors, themes, cljs-support etc, which needs work, which needs time, which we don’t have that much extra. happy to contribute code, ideas and requirements to that. For now: just copy the existing reitit thing if you want the looks."><y>#</y><d>2021-04-28</d><h>16:57</h><w>ikitommi</w><a>@pithyless</a> there is a unpublished copy of reitit-error-pretty-printer in malli. should extract the common parts of malli + reitit and push out to virhe. to be honest, might be better if <code>virhe</code> was a community owned clj-commons library, not ours. there would be a lot to do with colors, themes, cljs-support etc, which needs work, which needs time, which we don’t have that much extra. happy to contribute code, ideas and requirements to that. For now: just copy the existing reitit thing if you want the looks.</z><z id="t1619630196" t="pithyless are you referring to this? https://github.com/metosin/reitit/blob/master/modules/reitit-dev/src/reitit/dev/pretty.cljc It&apos;d be great to read about the ideas and lessons learned on the virhe README if you find some free time to catch your breath. Either way, thanks for all the ceaseless work and FOSS publishing! 🙂"><y>#</y><d>2021-04-28</d><h>17:16</h><r>pithyless</r>are you referring to this? <a href="https://github.com/metosin/reitit/blob/master/modules/reitit-dev/src/reitit/dev/pretty.cljc" target="_blank">https://github.com/metosin/reitit/blob/master/modules/reitit-dev/src/reitit/dev/pretty.cljc</a>

It&apos;d be great to read about the ideas and lessons learned on the virhe README if you find some free time to catch your breath. Either way, thanks for all the ceaseless work and FOSS publishing! <b>🙂</b></z><z id="t1619629111" t="ikitommi I’ll write the ideas and lessons learned to virhe README, soon. Might have time to push out first version before summer vacations."><y>#</y><d>2021-04-28</d><h>16:58</h><w>ikitommi</w>I’ll write the ideas and lessons learned to virhe README, soon. Might have time to push out first version before summer vacations.</z><z id="t1619629284" t="ikitommi 🥳 pushed just out [metosin/malli &quot;0.5.0&quot;] - small fixes &amp; improvements and the ability to describe Malli Schema Syntaxes with Malli. Small breaking changes for library extenders, more info in the CHANGELOG: https://github.com/metosin/malli/blob/master/CHANGELOG.md#050-2021-04-28"><y>#</y><d>2021-04-28</d><h>17:01</h><w>ikitommi</w><b>🥳</b>  pushed just out <code>[metosin/malli &quot;0.5.0&quot;]</code> - small fixes &amp; improvements and the ability to describe Malli Schema Syntaxes with Malli. Small breaking changes for library extenders, more info in the CHANGELOG: <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md#050-2021-04-28" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md#050-2021-04-28</a></z><z id="t1619645389" t="eoliphant Hi, dunno if I’m doing something wrong, but I’m having issues with local/custom registries and qualified keyword entries. Validation works fine, but getting properties, the original form back, etc don’t seem to work (def registry* (merge (m/default-schemas) {:testfoo [:string {:a :b}] :test/bar [:string {:c :d}] ::testbaz [:string {:a :b}]})) (m/properties :testfoo {:registry registry*}) ; =&gt; {:a :b} (m/properties ::testbaz {:registry registry*}) ; =&gt; nil"><y>#</y><d>2021-04-28</d><h>21:29</h><w>eoliphant</w>Hi, dunno if I’m doing something wrong, but I’m having issues with local/custom registries and qualified keyword entries.   Validation works fine, but getting properties, the original form back, etc don’t seem to work
<pre>(def registry*
  (merge
    (m/default-schemas)
    {:testfoo [:string {:a :b}]
     :test/bar [:string {:c :d}]
     ::testbaz [:string {:a :b}]}))
(m/properties :testfoo {:registry registry*})
; =&gt; {:a :b}
(m/properties ::testbaz {:registry registry*})
; =&gt; nil</pre></z><z id="t1619671679" t="ikitommi [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] What happens is: • :testfoo is not a qualified key, it’s contents are inlined • ::testbaz is a qualified = schema reference, instead of the inlined contents, you get the reference back. References are internally of type :malli.core/schema , which can also have properties. To get the actual schema behind the reference, you can m/deref the schema. • analogy is to Vars in Clojure, e.g. you get #&apos;inc (var) back, not inc (function value) (def registry* (merge (m/default-schemas) {:testfoo [:string {:a :b}] :test/bar [:string {:c :d}] ::testbaz [:string {:a :b}]})) (m/type :testfoo {:registry registry*}) ; =&gt; :string (m/type ::testbaz {:registry registry*}) ; =&gt; :malli.core/schema (-&gt; ::testbaz (m/schema {:registry registry*}) (m/deref)) ; =&gt; [:string {:a :b}] (-&gt; ::testbaz (m/schema {:registry registry*}) (m/deref) (m/properties)) ; =&gt; {:a :b}"><y>#</y><d>2021-04-29</d><h>04:47</h><w>ikitommi</w><a>@eoliphant</a> What happens is:
• <code>:testfoo</code> is not a qualified key, it’s contents are inlined
• <code>::testbaz</code> is a qualified = schema reference, instead of the inlined contents, you get the reference back. References are internally of type <code>:malli.core/schema</code> , which can also have properties. To get the actual schema behind the reference, you can <code>m/deref</code> the schema. 
• analogy is to Vars in Clojure, e.g. you get <code>#&apos;inc</code> (var) back, not <code>inc</code> (function value)
<pre>(def registry*
  (merge
    (m/default-schemas)
    {:testfoo [:string {:a :b}]
     :test/bar [:string {:c :d}]
     ::testbaz [:string {:a :b}]}))

(m/type :testfoo {:registry registry*})
; =&gt; :string

(m/type ::testbaz {:registry registry*})
; =&gt; :malli.core/schema

(-&gt; ::testbaz
    (m/schema {:registry registry*})
    (m/deref))
; =&gt; [:string {:a :b}]

(-&gt; ::testbaz
    (m/schema {:registry registry*})
    (m/deref)
    (m/properties))
; =&gt; {:a :b}</pre></z><z id="t1619671785" t="ikitommi that said, not happy how the references work atm, in most malli-based codebases I’ve seen, there is a lot of manual m/deref / m/deref-all calls to inline things. Also, the current behavior is not documented properly. Not sure what would be a correct way to handle these. Ideas welcome."><y>#</y><d>2021-04-29</d><h>04:49</h><w>ikitommi</w>that said, not happy how the references work atm, in most malli-based codebases I’ve seen, there is a lot of manual <code>m/deref</code> / <code>m/deref-all</code> calls to inline things. Also, the current behavior is not documented properly. Not sure what would be a correct way to handle these. Ideas welcome.</z><z id="t1619672193" t="ikitommi compared to spec, any lookup to a registry pulls the actual value, but when the reference is part of some other specs form, it’s kept as it is; (require &apos;[clojure.alpha.spec :as s]) (s/def ::kikka int?) (s/form ::kikka) ; =&gt; clojure.core/int? (s/form (s/tuple ::kikka)) ; =&gt; (clojure.alpha.spec/tuple :user/kikka)"><y>#</y><d>2021-04-29</d><h>04:56</h><w>ikitommi</w>compared to spec, any lookup to a registry pulls the actual value, but when the reference is part of some other specs form, it’s kept as it is;
<pre>(require &apos;[clojure.alpha.spec :as s])

(s/def ::kikka int?)

(s/form ::kikka)
; =&gt; clojure.core/int?

(s/form (s/tuple ::kikka))
; =&gt; (clojure.alpha.spec/tuple :user/kikka)</pre></z><z id="t1619672417" t="ikitommi this sums the current functionality: (m/schema [:tuple :testfoo ::testbaz] {:registry registry*}) ; =&gt; [:tuple [:string {:a :b}] :user/testbaz]"><y>#</y><d>2021-04-29</d><h>05:00</h><w>ikitommi</w>this sums the current functionality:
<pre>(m/schema [:tuple :testfoo ::testbaz] {:registry registry*})
; =&gt; [:tuple [:string {:a :b}] :user/testbaz]</pre></z><z id="t1619712779" t="eoliphant ah it was just that? lol. yeah, for now i think just a bit in the docs, maybe in the areas that ref using qualified keys, custom/local registries would be a start just so folks are aware. I just happened to catch Arne’s quick vid on Malli and data modeling, and so gonna just take his approach of my own ‘schema’ name space that limits the surface area, and I can just jack in handling this. will think about what might be a better approach longer term. it does ‘feel’ that something like (m/properties :test vs ::test …) should ‘just work’ from the average user/client’s perspective, returning the same kind of representation. maybe an ‘easy’ 🙂 namespace like reitit?"><y>#</y><d>2021-04-29</d><h>16:12</h><w>eoliphant</w>ah it was just that? lol.  yeah, for now i think just a bit in the docs, maybe in the areas that ref using qualified keys, custom/local registries would be a start just so folks are aware.

    I just happened to catch Arne’s quick vid on Malli and data modeling, and so gonna just take his approach of my own ‘schema’ name space that limits the surface area, and I can just jack in handling this.  will think about what might be a better approach longer term.  it does ‘feel’  that something like <code>(m/properties :test vs ::test …)</code> should ‘just work’ from the average user/client’s perspective, returning the same kind of representation.   maybe an ‘easy’ <b>🙂</b> namespace like reitit?</z><z id="t1619721573" t="ikitommi need to think what would be a good resolution for this. today, my 2 cents are to make it work like spec: • by default defer eager references on m/schema , and add an option not to do that (used in form creation) would be a breaking change."><y>#</y><d>2021-04-29</d><h>18:39</h><w>ikitommi</w>need to think what would be a good resolution for this. today, my 2 cents are to make it work like spec:
• by default defer eager references on <code>m/schema</code>, and add an option not to do that (used in form creation)
would be a breaking change.</z><z id="t1619721671" t="ikitommi unrelated, but, content-dependent collection schemas on coming up. not sure how useful, but possible: (def List (m/-collection-schema (fn [properties [child]] {:type &apos;List :pred list? :empty &apos;() :type-properties {:error/message &quot;should be a list&quot; :gen/schema [:vector properties child] :gen/fmap #(or (list* %) &apos;())}}))) (m/validate [List :int] &apos;(1 2)) ; =&gt; true (-&gt; (m/explain [List :boolean] [1 2 3]) (me/humanize)) ; =&gt; [&quot;should be a list&quot;] (mg/sample [List {:gen/min 4, :gen/max 10} :int]) ;((-1 0 -1 -1 -1 -1 -1 0) ; (-1 -1 -1 0 -1) ; (0 0 1 -2 -1) ; (-1 0 -1 1 -1 0 -4 -1) ; (-2 0 0 -2 1 0) ; (-2 7 2 3 2 -1) ; (-7 -3 -1 7 -1) ; (0 -12 0 8) ; (-5 25 0 -2 -5 1 -1 -25 -10 1) ; (53 221 0 15 1 -42)) (m/form [List :int]) ; =&gt; [List :int] (mu/assoc [List :int] 0 :boolean) ; =&gt; [List :boolean]"><y>#</y><d>2021-04-29</d><h>18:41</h><w>ikitommi</w>unrelated, but, content-dependent collection schemas on coming up. not sure how useful, but possible:
<pre>(def List
  (m/-collection-schema
    (fn [properties [child]]
      {:type &apos;List
       :pred list?
       :empty &apos;()
       :type-properties {:error/message &quot;should be a list&quot;
                         :gen/schema [:vector properties child]
                         :gen/fmap #(or (list* %) &apos;())}})))

(m/validate [List :int] &apos;(1 2))
; =&gt; true

(-&gt; (m/explain [List :boolean] [1 2 3])
    (me/humanize))
; =&gt; [&quot;should be a list&quot;]

(mg/sample [List {:gen/min 4, :gen/max 10} :int])
;((-1 0 -1 -1 -1 -1 -1 0)
; (-1 -1 -1 0 -1)
; (0 0 1 -2 -1)
; (-1 0 -1 1 -1 0 -4 -1)
; (-2 0 0 -2 1 0)
; (-2 7 2 3 2 -1)
; (-7 -3 -1 7 -1)
; (0 -12 0 8)
; (-5 25 0 -2 -5 1 -1 -25 -10 1)
; (53 221 0 15 1 -42))

(m/form [List :int])
; =&gt; [List :int]

(mu/assoc [List :int] 0 :boolean)
; =&gt; [List :boolean]</pre></z><z id="t1619747214" t="pserrano Hello. I&apos;m looking forward to use malli in a project and will be actively learning about it in the next days 🙂"><y>#</y><d>2021-04-30</d><h>01:46</h><w>pserrano</w>Hello. I&apos;m looking forward to use malli in a project and will be actively learning about it in the next days <b>🙂</b></z><z id="t1619781300" t="ikitommi hiccup: [:schema {:registry {&quot;Order&quot; [:map [:items [:vector [:enum &quot;SIM&quot; &quot;SAM&quot;]]] [:delivery [:enum &quot;letter&quot; &quot;email&quot;]]] &quot;SimDeliveryRule&quot; [:fn {:error/message &quot;If the order only includes a SIM card then the delivery method may be &quot;letter&quot;.&quot; :error/path [:delivery]} &apos;(fn [{:keys [items delivery]}] (or (not= items [&quot;SIM&quot;]) (= delivery &quot;letter&quot;)))]}} [:and &quot;Order&quot; &quot;SimDeliveryRule&quot;]] maps (maybe compact syntax via schema parsing): {:type :schema :registry {&quot;Order&quot; {:type :map :entries [[:items {:type :vector :items {:type :enum :values [&quot;SIM&quot; &quot;SAM&quot;]}}] [:delivery {:type :enum :values [&quot;letter&quot; &quot;email&quot;]}]]} &quot;SimDeliveryRule&quot; {:type :fn :error/message &quot;If the order only includes a SIM card then the delivery method may be &quot;letter&quot;.&quot; :error/path [:delivery] :value &apos;(fn [{:keys [items delivery]}] (or (not= items [&quot;SIM&quot;]) (= delivery &quot;letter&quot;)))}} :value {:type :and :values [&quot;Order&quot; &quot;SimDeliveryRule&quot;]}}"><y>#</y><d>2021-04-30</d><h>11:15</h><w>ikitommi</w>hiccup:
<pre>[:schema
 {:registry
  {&quot;Order&quot; [:map
            [:items [:vector [:enum &quot;SIM&quot; &quot;SAM&quot;]]]
            [:delivery [:enum &quot;letter&quot; &quot;email&quot;]]]
   &quot;SimDeliveryRule&quot; [:fn {:error/message &quot;If the order only includes a SIM card then the delivery method may be &quot;letter&quot;.&quot;
                           :error/path [:delivery]}
                      &apos;(fn [{:keys [items delivery]}]
                         (or (not= items [&quot;SIM&quot;])
                             (= delivery &quot;letter&quot;)))]}}
 [:and &quot;Order&quot; &quot;SimDeliveryRule&quot;]]</pre>
maps (maybe compact syntax via schema parsing):
<pre>{:type :schema
 :registry {&quot;Order&quot; {:type :map
                     :entries [[:items {:type :vector
                                        :items {:type :enum
                                                :values [&quot;SIM&quot; &quot;SAM&quot;]}}]
                               [:delivery {:type :enum
                                           :values [&quot;letter&quot; &quot;email&quot;]}]]}
            &quot;SimDeliveryRule&quot; {:type :fn
                               :error/message &quot;If the order only includes a SIM card then the delivery method may be &quot;letter&quot;.&quot;
                               :error/path [:delivery]
                               :value &apos;(fn [{:keys [items delivery]}]
                                         (or (not= items [&quot;SIM&quot;])
                                             (= delivery &quot;letter&quot;)))}}
 :value {:type :and
         :values [&quot;Order&quot; &quot;SimDeliveryRule&quot;]}}</pre></z><z id="t1619784037" t="Yehonathan Sharvit Hello there! Malli is great. A question regarding function validation (a.k.a =&gt; ): Is there a way to automatically validate that all function calls are made with proper args during development time?"><y>#</y><d>2021-04-30</d><h>12:00</h><w>Yehonathan Sharvit</w>Hello there!
Malli is great.
A question regarding function validation (a.k.a <code>=&gt;</code> ):
Is there a way to automatically validate that all function calls are made with proper args during development time?</z><z id="t1619787535" t="borkdude [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] More info here: https://clojurians.slack.com/archives/CLDK6MFMK/p1619006445487300"><y>#</y><d>2021-04-30</d><h>12:58</h><w>borkdude</w><a>@viebel</a> More info here:
<a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1619006445487300" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1619006445487300</a></z><z id="t1619788700" t="Yehonathan Sharvit Thank you [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] !"><y>#</y><d>2021-04-30</d><h>13:18</h><w>Yehonathan Sharvit</w>Thank you <a>@borkdude</a>!</z><z id="t1619788745" t="Yehonathan Sharvit Given that instrumentation is not yet there in malli, what’s the common use case for :=&gt; ?"><y>#</y><d>2021-04-30</d><h>13:19</h><w>Yehonathan Sharvit</w>Given that instrumentation is not yet there in malli, what’s the common use case for <code>:=&gt;</code>?</z><z id="t1619788758" t="Yehonathan Sharvit “Only” generative testing?"><y>#</y><d>2021-04-30</d><h>13:19</h><w>Yehonathan Sharvit</w>“Only” generative testing?</z><z id="t1619788828" t="borkdude It&apos;s a good question, I&apos;ve also wondered myself."><y>#</y><d>2021-04-30</d><h>13:20</h><w>borkdude</w>It&apos;s a good question, I&apos;ve also wondered myself.</z><z id="t1619788845" t="borkdude At least you can generate some clj-kondo type hints with it =)"><y>#</y><d>2021-04-30</d><h>13:20</h><w>borkdude</w>At least you can generate some clj-kondo type hints with it =)</z><z id="t1619788946" t="Yehonathan Sharvit I just tried clj-kondo type hints and it’s awesome. A question related to that: where is the appropriate place for putting the (mc/emit!) function call?"><y>#</y><d>2021-04-30</d><h>13:22</h><w>Yehonathan Sharvit</w>I just tried clj-kondo type hints and it’s awesome.
A question related to that: where is the appropriate place for putting the <code>(mc/emit!)</code> function call?</z><z id="t1619788978" t="borkdude Maybe in &quot;component system du jour&quot; start/reset?"><y>#</y><d>2021-04-30</d><h>13:22</h><w>borkdude</w>Maybe in &quot;component system du jour&quot; start/reset?</z><z id="t1619789014" t="Yehonathan Sharvit I didn’t know you were speaking french. I don’t have any component: I am writing a library"><y>#</y><d>2021-04-30</d><h>13:23</h><w>Yehonathan Sharvit</w>I didn’t know you were speaking french.
I don’t have any component: I am writing a library</z><z id="t1619789046" t="Yehonathan Sharvit I am also wondering how the emitted config from the library is going to be integrated in the application that uses the lib"><y>#</y><d>2021-04-30</d><h>13:24</h><w>Yehonathan Sharvit</w>I am also wondering how the emitted config from the library is going to be integrated in the application that uses the lib</z><z id="t1619789081" t="borkdude you probably shouldn&apos;t do this in your library, it&apos;s something an end user should do"><y>#</y><d>2021-04-30</d><h>13:24</h><w>borkdude</w>you probably shouldn&apos;t do this in your library, it&apos;s something an end user should do</z><z id="t1619789113" t="borkdude Maybe emit it as part of a pre-commit hook or something"><y>#</y><d>2021-04-30</d><h>13:25</h><w>borkdude</w>Maybe emit it as part of a pre-commit hook or something</z><z id="t1619789159" t="Yehonathan Sharvit why wouldn’t my library be responsible for emitting clj-kondo config for the function it provides?"><y>#</y><d>2021-04-30</d><h>13:25</h><w>Yehonathan Sharvit</w>why wouldn’t my library be responsible for emitting clj-kondo config for the function it provides?</z><z id="t1619789184" t="borkdude You can do that, but you should just commit that config into git and not generate it at runtime"><y>#</y><d>2021-04-30</d><h>13:26</h><w>borkdude</w>You can do that, but you should just commit that config into git and not generate it at runtime</z><z id="t1619789206" t="borkdude clj-kondo has a mechanism to pick up on configs from libraries"><y>#</y><d>2021-04-30</d><h>13:26</h><w>borkdude</w>clj-kondo has a mechanism to pick up on configs from libraries</z><z id="t1619789262" t="borkdude Described here: https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#exporting-and-importing-configuration"><y>#</y><d>2021-04-30</d><h>13:27</h><w>borkdude</w>Described here: <a href="https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#exporting-and-importing-configuration" target="_blank">https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#exporting-and-importing-configuration</a></z><z id="t1619789430" t="Yehonathan Sharvit Nice!"><y>#</y><d>2021-04-30</d><h>13:30</h><w>Yehonathan Sharvit</w>Nice!</z><z id="t1619790683" t="Yehonathan Sharvit Is there already a script that generates clj-kondo config from project that uses malli (basically that calls (mc/emit!) ?"><y>#</y><d>2021-04-30</d><h>13:51</h><w>Yehonathan Sharvit</w>Is there already a script that generates clj-kondo config from project that uses malli (basically that calls <code>(mc/emit!)</code>?</z><z id="t1619790703" t="Yehonathan Sharvit Not sure I could use babashka for that as my library might not be babashka compatible"><y>#</y><d>2021-04-30</d><h>13:51</h><w>Yehonathan Sharvit</w>Not sure I could use babashka for that as my library might not be babashka compatible</z><z id="t1619790747" t="borkdude Malli is not babashka compatible either, so you should use a JVM script / function for this. You could just write a function which you can call with clojure -X my.lib/gen-clj-kondo"><y>#</y><d>2021-04-30</d><h>13:52</h><w>borkdude</w>Malli is not babashka compatible either, so you should use a JVM script / function for this. You could just write a function which you can call with <code>clojure -X my.lib/gen-clj-kondo</code></z><z id="t1619790777" t="Yehonathan Sharvit Malli is not babashka compatible. That is a sacrilege!"><y>#</y><d>2021-04-30</d><h>13:52</h><w>Yehonathan Sharvit</w>Malli is not babashka compatible. That is a sacrilege!</z><z id="t1619790808" t="borkdude There is an issue / petition to add malli to bb: https://github.com/babashka/babashka/issues/737 Feel free to upvote."><y>#</y><d>2021-04-30</d><h>13:53</h><w>borkdude</w>There is an issue / petition to add malli to bb:
<a href="https://github.com/babashka/babashka/issues/737" target="_blank">https://github.com/babashka/babashka/issues/737</a>
Feel free to upvote.</z><z id="t1619791290" t="Yehonathan Sharvit It’s not an easy choice: What’s your opinion on that? Did you upvoted or downvoted [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] ?"><y>#</y><d>2021-04-30</d><h>14:01</h><w>Yehonathan Sharvit</w>It’s not an easy choice: What’s your opinion on that? Did you upvoted or downvoted <a>@borkdude</a>?</z><z id="t1619791501" t="Yehonathan Sharvit Another question related to malli’s :=&gt; : Is there a way to automatically generate a doc string?"><y>#</y><d>2021-04-30</d><h>14:05</h><w>Yehonathan Sharvit</w>Another question related to malli’s <code>:=&gt;</code> : Is there a way to automatically generate a doc string?</z><z id="t1619793774" t="ikitommi [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] function instrumentation comes with this: https://github.com/metosin/malli/issues/349"><y>#</y><d>2021-04-30</d><h>14:42</h><w>ikitommi</w><a>@viebel</a> function instrumentation comes with this: <a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a></z><z id="t1619793852" t="ikitommi lot of things are still TODO, help welcome"><y>#</y><d>2021-04-30</d><h>14:44</h><w>ikitommi</w>lot of things are still TODO, help welcome</z><z id="t1619794528" t="Yehonathan Sharvit Yeah. [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] pointed me to this Github issue."><y>#</y><d>2021-04-30</d><h>14:55</h><w>Yehonathan Sharvit</w>Yeah. <a>@borkdude</a> pointed me to this Github issue.</z><z id="t1619794551" t="Yehonathan Sharvit We are starting to embrace malli at work. Hopefully, we’ll be motivated to help"><y>#</y><d>2021-04-30</d><h>14:55</h><w>Yehonathan Sharvit</w>We are starting to embrace malli at work. Hopefully, we’ll be motivated to help</z><z id="t1619794582" t="Yehonathan Sharvit A question related to maps. Is it possible to specify that some combination of fields are forbidden?"><y>#</y><d>2021-04-30</d><h>14:56</h><w>Yehonathan Sharvit</w>A question related to maps. Is it possible to specify that some combination of fields are forbidden?</z><z id="t1619794607" t="borkdude [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] What made you choose malli over spec or both?"><y>#</y><d>2021-04-30</d><h>14:56</h><w>borkdude</w><a>@viebel</a> What made you choose malli over spec or both?</z><z id="t1619794657" t="Yehonathan Sharvit [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] gave us a great talk about Malli at our dev meetup at work 😜"><y>#</y><d>2021-04-30</d><h>14:57</h><w>Yehonathan Sharvit</w><a>@ikitommi</a> gave us a great talk about Malli at our dev meetup at work <b>😜</b></z><z id="t1619794808" t="Yehonathan Sharvit We chose malli mostly because: 1. In malli, schemas are data (not macro required) 2. spec seems stuck. Not sure if spec2 will be compatible with spec 1 3. It’s easier to contribute to malli than to spec "><y>#</y><d>2021-04-30</d><h>15:00</h><w>Yehonathan Sharvit</w>We chose malli mostly because:
1. In malli, schemas are data (not macro required)
2. spec seems stuck. Not sure if spec2 will be compatible with spec 1
3. It’s easier to contribute to malli than to spec
</z><z id="t1619795102" t="borkdude Interesting, thanks for sharing. It seems there are two ways people are choosing libraries: 1) choose core unless ... , because: bundled with clojure (no additional deps), authority (core, cognitect), promoted as &quot;the default&quot; 2) choose community, easier to contribute / freedom, usually more focus/options than core libs"><y>#</y><d>2021-04-30</d><h>15:05</h><w>borkdude</w>Interesting, thanks for sharing. It seems there are two ways people are choosing libraries:
1) choose core unless ... , because: bundled with clojure (no additional deps), authority (core, cognitect), promoted as &quot;the default&quot;
2) choose community, easier to contribute / freedom, usually more focus/options than core libs</z><z id="t1619795674" t="Yehonathan Sharvit Don’t forget the data driven aspect of malli!"><y>#</y><d>2021-04-30</d><h>15:14</h><w>Yehonathan Sharvit</w>Don’t forget the data driven aspect of malli!</z><z id="t1619796180" t="mynomoto Having a version of spec alpha with a replacement in development for years doesn&apos;t exactly inspire confidence."><y>#</y><d>2021-04-30</d><h>15:23</h><w>mynomoto</w>Having a version of spec alpha with a replacement in development for years doesn&apos;t exactly inspire confidence.</z><z id="t1619796237" t="borkdude [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] In the defn podcast you argued that namespaced (fully qualified) keywords are a vital part of data oriented programming. spec promotes this by having specs bound to global keywords so specs describe meaning without context. Is this aspect sufficiently present in malli?"><y>#</y><d>2021-04-30</d><h>15:23</h><w>borkdude</w><a>@viebel</a> In the defn podcast you argued that namespaced (fully qualified) keywords are a vital part of data oriented programming. spec promotes this by having specs bound to global keywords so specs describe meaning without context. Is this aspect sufficiently present in malli?</z><z id="t1619796333" t="borkdude (btw, I liked the podcast :))"><y>#</y><d>2021-04-30</d><h>15:25</h><w>borkdude</w>(btw, I liked the podcast :))</z><z id="t1619796558" t="Yehonathan Sharvit Good question [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] . I need to play more with Malli in order to answer this question. (I am so glad you liked it)"><y>#</y><d>2021-04-30</d><h>15:29</h><w>Yehonathan Sharvit</w>Good question <a>@borkdude</a>. I need to play more with Malli in order to answer this question.
(I am so glad you liked it)</z><z id="t1619797192" t="Yehonathan Sharvit Is there a way to spec a map using a key from a registry but having the key non namespace qualified?"><y>#</y><d>2021-04-30</d><h>15:39</h><w>Yehonathan Sharvit</w>Is there a way to spec a map using a key from a registry but having the key non namespace qualified?</z><z id="t1619801585" t="ikitommi [:map {:registry {::id :int} [:id ::id]]"><y>#</y><d>2021-04-30</d><h>16:53</h><w>ikitommi</w><pre>[:map {:registry {::id :int}
 [:id ::id]]</pre></z><z id="t1619805571" t="borkdude"><y>#</y><d>2021-04-30</d><h>17:59</h><w>borkdude</w></z><z id="t1619805588" t="borkdude The work Jim is doing is maybe interesting for the authors of malli as well"><y>#</y><d>2021-04-30</d><h>17:59</h><w>borkdude</w>The work Jim is doing is maybe interesting for the authors of malli as well</z><z id="t1619967823" t="ikitommi definitely, looks great [:attrs {:href &quot;/_/_/users/U010VP3UY9X&quot;}] . Malli’s primary goal has been to be a data-driven runtime schema engine, but currently bending it for development time tooling to see how far we can go. Some wishes: • a schema-base case-macro, with clj-kondo based error reporting on non-exhaustive matches - for things like :or and :multi . Genus seems to have those already? • schematized fns. so many syntax options, the lisp curse? • as soon as someone builds a pluggable intellisense / code completer for clojure, happy to emit malli-mappings so that one could complete known map keys (and get errors on invalid keys - via clj-kondo)."><y>#</y><d>2021-05-02</d><h>15:03</h><r>ikitommi</r>definitely, looks great <a>@jimka.issy</a>. Malli’s primary goal has been to be a data-driven runtime schema engine, but currently bending it for development time tooling to see how far we can go. Some wishes:
• a schema-base case-macro, with clj-kondo based error reporting on non-exhaustive matches - for things like <code>:or</code> and <code>:multi</code>. Genus seems to have those already?
• schematized fns. so many syntax options, the lisp curse?
• as soon as someone builds a pluggable intellisense / code completer for clojure, happy to emit malli-mappings so that one could complete known map keys (and get errors on invalid keys - via clj-kondo).</z><z id="t1619969381" t="ikitommi current status: https://twitter.com/ikitommi/status/1363753100268421122"><y>#</y><d>2021-05-02</d><h>15:29</h><r>ikitommi</r>current status: <a href="https://twitter.com/ikitommi/status/1363753100268421122" target="_blank">https://twitter.com/ikitommi/status/1363753100268421122</a></z><z id="t1619967823" t="ikitommi definitely, looks great [:attrs {:href &quot;/_/_/users/U010VP3UY9X&quot;}] . Malli’s primary goal has been to be a data-driven runtime schema engine, but currently bending it for development time tooling to see how far we can go. Some wishes: • a schema-base case-macro, with clj-kondo based error reporting on non-exhaustive matches - for things like :or and :multi . Genus seems to have those already? • schematized fns. so many syntax options, the lisp curse? • as soon as someone builds a pluggable intellisense / code completer for clojure, happy to emit malli-mappings so that one could complete known map keys (and get errors on invalid keys - via clj-kondo)."><y>#</y><d>2021-05-02</d><h>15:03</h><w>ikitommi</w>definitely, looks great <a>@jimka.issy</a>. Malli’s primary goal has been to be a data-driven runtime schema engine, but currently bending it for development time tooling to see how far we can go. Some wishes:
• a schema-base case-macro, with clj-kondo based error reporting on non-exhaustive matches - for things like <code>:or</code> and <code>:multi</code>. Genus seems to have those already?
• schematized fns. so many syntax options, the lisp curse?
• as soon as someone builds a pluggable intellisense / code completer for clojure, happy to emit malli-mappings so that one could complete known map keys (and get errors on invalid keys - via clj-kondo).</z><z id="t1619830712" t="Alexis Vincent Are there any projects or examples out there for nifty crux/Malli compat stuff. Schemas or crux helper functions etc"><y>#</y><d>2021-05-01</d><h>00:58</h><w>Alexis Vincent</w>Are there any projects or examples out there for nifty crux/Malli compat stuff. Schemas or crux helper functions etc</z><z id="t1619864272" t="refset Good timing! See [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}] &apos;s new lib https://mobile.twitter.com/spacegangster/status/1388092289084428299"><y>#</y><d>2021-05-01</d><h>10:17</h><r>refset</r>Good timing! See <a>@U0A5V8ZR6</a> &apos;s new lib <a href="https://mobile.twitter.com/spacegangster/status/1388092289084428299" target="_blank">https://mobile.twitter.com/spacegangster/status/1388092289084428299</a></z><z id="t1619864540" t="Ivan Fedorov [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] is the initiator and the sponsor on this one 🙏"><y>#</y><d>2021-05-01</d><h>10:22</h><r>Ivan Fedorov</r><a>@U051V5LLP</a> is the initiator and the sponsor on this one <b>🙏</b></z><z id="t1619867859" t="Alexis Vincent Yeah so cool! I had a 5 min play with this yesterday! Great work!"><y>#</y><d>2021-05-01</d><h>11:17</h><r>Alexis Vincent</r>Yeah so cool! I had a 5 min play with this yesterday! Great work!</z><z id="t1619867904" t="Alexis Vincent Any further examples/projects anyone has seen? [:attrs {:href &quot;/_/_/users/U899JBRPF&quot;}]"><y>#</y><d>2021-05-01</d><h>11:18</h><r>Alexis Vincent</r>Any further examples/projects anyone has seen? <a>@U899JBRPF</a></z><z id="t1619871141" t="refset Nothing else that&apos;s hit my radar yet, but I&apos;m also very interested by the intersection :) Semi-related: I am also curious about the possibility of Malli-&gt;Alloy tooling that could assist with modelling in Crux"><y>#</y><d>2021-05-01</d><h>12:12</h><r>refset</r>Nothing else that&apos;s hit my radar yet, but I&apos;m also very interested by the intersection :) Semi-related: I am also curious about the possibility of Malli-&gt;Alloy tooling that could assist with modelling in Crux</z><z id="t1619874756" t="Alexis Vincent Can connect in a bit and see what we come up with"><y>#</y><d>2021-05-01</d><h>13:12</h><r>Alexis Vincent</r>Can connect in a bit and see what we come up with</z><z id="t1619878820" t="dvingo [:attrs {:href &quot;/_/_/users/UJWLUPW13&quot;}] do you have any use-cases in mind you&apos;re looking for? or dev workflows? I have some of my own ideas for helper code I&apos;d want related to crux, but I&apos;m interested to hear of others."><y>#</y><d>2021-05-01</d><h>14:20</h><r>dvingo</r><a>@UJWLUPW13</a> do you have any use-cases in mind you&apos;re looking for? or dev workflows? I have some of my own ideas for helper code I&apos;d want related to crux, but I&apos;m interested to hear of others.</z><z id="t1619878893" t="dvingo [:attrs {:href &quot;/_/_/users/U899JBRPF&quot;}] do you have any links or materials on alloy as it relates to crux?"><y>#</y><d>2021-05-01</d><h>14:21</h><r>dvingo</r><a>@U899JBRPF</a> do you have any links or materials on alloy as it relates to crux?</z><z id="t1619879551" t="Alexis Vincent Not yet. Just getting started integrating malli and crux (and new to both). Just wrote a transformer that santises crux entities to be passed on to a json api. transforms :crux.db/id -&gt; id and strips out entity type im transacting in. Will get a better feel for what I need as I work with both"><y>#</y><d>2021-05-01</d><h>14:32</h><r>Alexis Vincent</r>Not yet. Just getting started integrating malli and crux (and new to both). Just wrote a transformer that santises crux entities to be passed on to a json api. transforms :crux.db/id -&gt; id and strips out entity type im transacting in. Will get a better feel for what I need as I work with both</z><z id="t1619879762" t="Alexis Vincent Malli coersion for crux database migration is going to be 👌"><y>#</y><d>2021-05-01</d><h>14:36</h><r>Alexis Vincent</r>Malli coersion for crux database migration is going to be <b>👌</b></z><z id="t1619879767" t="Alexis Vincent And UI generation"><y>#</y><d>2021-05-01</d><h>14:36</h><r>Alexis Vincent</r>And UI generation</z><z id="t1619968553" t="Ivan Fedorov Mr Reiman, maybe you could be interested making a video review of the EQL generation I wrote and giving your opinion on a better way to write schema transformers? I think this could be beneficial for those writing transformers based on malli. If yes — we could schedule a video call [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] If no — no worries."><y>#</y><d>2021-05-02</d><h>15:15</h><r>Ivan Fedorov</r>Mr Reiman, maybe you could be interested making a video review of the EQL generation I wrote and giving your opinion on a better way to write schema transformers? I think this could be beneficial for those writing transformers based on malli.

If yes — we could schedule a video call <a>@U055NJ5CC</a> 
If no — no worries.</z><z id="t1620019391" t="ikitommi sure [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}] , would like to do that, just super busy at work atm, between projects. If the code - and the goal - is available somewhere, I could first try to read that, between things."><y>#</y><d>2021-05-03</d><h>05:23</h><r>ikitommi</r>sure <a>@U0A5V8ZR6</a>, would like to do that, just super busy at work atm, between projects. If the code - and the goal - is available somewhere, I could first try to read that, between things.</z><z id="t1620029969" t="Ivan Fedorov Yep, you can look at it here: https://github.com/dvingo/malli-code-gen/blob/main/src/malli_code_gen/gen_eql.clj We have a branch merge pending. If we merge it before you look at the code – we’ll leave you a link in https://github.com/dvingo/malli-code-gen cc [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Not rushing you with the review. If you can say at what period you will be probably available for that (in a week or three) that would help. Good luck with the workload!"><y>#</y><d>2021-05-03</d><h>08:19</h><r>Ivan Fedorov</r>Yep, you can look at it here:
<a href="https://github.com/dvingo/malli-code-gen/blob/main/src/malli_code_gen/gen_eql.clj" target="_blank">https://github.com/dvingo/malli-code-gen/blob/main/src/malli_code_gen/gen_eql.clj</a>

We have a branch merge pending. If we merge it before you look at the code – we’ll leave you a link in
<a href="https://github.com/dvingo/malli-code-gen" target="_blank">https://github.com/dvingo/malli-code-gen</a>
cc <a>@U055NJ5CC</a>

Not rushing you with the review. If you can say at what period you will be probably available for that (in a week or three) that would help.

Good luck with the workload!</z><z id="t1620064968" t="refset Hey [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] &gt; do you have any links or materials on alloy as it relates to crux? Nothing published from me yet, but this is worth a look https://www.hillelwayne.com/post/formally-modeling-migrations/ and, whilst not directly Alloy-related, I think principles of https://en.wikipedia.org/wiki/Object-role_modeling are also relevant"><y>#</y><d>2021-05-03</d><h>18:02</h><r>refset</r>Hey <a>@U051V5LLP</a>
&gt; do you have any links or materials on alloy as it relates to crux?
Nothing published from me yet, but this is worth a look <a href="https://www.hillelwayne.com/post/formally-modeling-migrations/" target="_blank">https://www.hillelwayne.com/post/formally-modeling-migrations/</a> and, whilst not directly Alloy-related, I think principles of <a href="https://en.wikipedia.org/wiki/Object-role_modeling" target="_blank">https://en.wikipedia.org/wiki/Object-role_modeling</a> are also relevant</z><z id="t1620084478" t="dvingo ooohh this looks great, thanks for sharing! I have some reading to do 🙂"><y>#</y><d>2021-05-03</d><h>23:27</h><r>dvingo</r>ooohh this looks great, thanks for sharing! I have some reading to do <b>🙂</b></z><z id="t1619881708" t="Joel i&apos;m mucking with jsonista/malli and would like to use keywords for some map values, eg: { :Nested { :Map { :enums &quot;values&quot; :other &quot;string&quot; }}} How do i get the values for :enums to be keywords, eg :values... yet leave other strings as strings?"><y>#</y><d>2021-05-01</d><h>15:08</h><w>Joel</w>i&apos;m mucking with jsonista/malli and would like to use keywords for some map values, eg:

{ :Nested { :Map { :enums &quot;values&quot; :other &quot;string&quot; }}}

How do i get the values for :enums to be keywords, eg :values... yet leave other strings as strings?</z><z id="t1619892884" t="ikitommi [:attrs {:href &quot;/_/_/users/UH13Y2FSA&quot;}] you need to describe a schema with all the parts that need transformations. in your case, simplest way to do it would be: (require &apos;[malli.provider :as mp] &apos;[malli.core :as m] &apos;[malli.transform :as mt]) ;; infer schema from example value (def schema (mp/provide [{:Nested {:Map {:enums :values}}}])) ;; create json-decoder for the schema (def from-json (m/decoder schema (mt/json-transformer))) ;; apply (from-json {:Nested {:Map {:enums &quot;values&quot; :other &quot;string&quot;}}}) ; =&gt; {:Nested {:Map {:enums :values, :other &quot;string&quot;}}}"><y>#</y><d>2021-05-01</d><h>18:14</h><w>ikitommi</w><a>@joel380</a> you need to describe a schema with all the parts that need transformations. in your case, simplest way to do it would be:
<pre>(require &apos;[malli.provider :as mp]
         &apos;[malli.core :as m]
         &apos;[malli.transform :as mt])

;; infer schema from example value
(def schema (mp/provide [{:Nested {:Map {:enums :values}}}]))

;; create json-decoder for the schema
(def from-json (m/decoder schema (mt/json-transformer)))

;; apply
(from-json {:Nested {:Map {:enums &quot;values&quot; :other &quot;string&quot;}}})
; =&gt; {:Nested {:Map {:enums :values, :other &quot;string&quot;}}}</pre></z><z id="t1619927967" t="Joel Thanks I got that working. I had a schema with [:enum :value1 :value2] I assumed that would do the conversion, but it didn&apos;t work until I added [:and keyword? [:enum ...]]"><y>#</y><d>2021-05-02</d><h>03:59</h><r>Joel</r>Thanks I got that working. I had a schema with [:enum :value1 :value2] I assumed that would do the conversion, but it didn&apos;t work until I added [:and keyword? [:enum ...]]</z><z id="t1619928001" t="Joel makes sense though."><y>#</y><d>2021-05-02</d><h>04:00</h><r>Joel</r>makes sense though.</z></g><g id="s14"><z id="t1619928126" t="Joel How can I validate the length of strings?"><y>#</y><d>2021-05-02</d><h>04:02</h><w>Joel</w>How can I validate the length of strings?</z><z id="t1619935719" t="ikitommi [:string {:min 1, :max 10}]"><y>#</y><d>2021-05-02</d><h>06:08</h><w>ikitommi</w><code>[:string {:min 1, :max 10}]</code></z><z id="t1619981098" t="Joel [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] How do i see the list of keywords I can specify? Is it to look at unit tests? For example, I didn&apos;t know where to find the min/max keywords."><y>#</y><d>2021-05-02</d><h>18:44</h><w>Joel</w><a>@ikitommi</a> How do i see the list of keywords I can specify? Is it to look at unit tests? For example, I didn&apos;t know where to find the min/max keywords.</z><z id="t1620019538" t="ikitommi [:attrs {:href &quot;/_/_/users/UH13Y2FSA&quot;}] not atm. The new malli schemas of malli schemas feature allows us to describe the available properties formally as schemas, but it’s just the mechanism atm, no content shipped. Once all schmas are described (both properties and children), it will be THE documentation. For now, you need to read the sources. Documentation PRs always welcome."><y>#</y><d>2021-05-03</d><h>05:25</h><w>ikitommi</w><a>@joel380</a> not atm. The new <code>malli schemas of malli schemas</code> feature allows us to describe the available properties formally as schemas, but it’s just the mechanism atm, no content shipped. Once all schmas are described (both properties and children), it will be THE documentation. For now, you need to read the sources. Documentation PRs always welcome.</z><z id="t1620019760" t="ikitommi e.g. ;; currently (m/properties-schema :string) ; =&gt; nil ;; after (m/properties-schema :string) ; [:map ; [:min {:description &quot;length must be at least&quot;} :int] ; [:max {:description &quot;length must be at most&quot;} :int]] … different schema applications (e.g. generation) will have their own overlays, which can be merged to get the full set of available keys. Should be easy to generate proper docs out of those."><y>#</y><d>2021-05-03</d><h>05:29</h><w>ikitommi</w>e.g.
<pre>;; currently
(m/properties-schema :string)
; =&gt; nil

;; after
(m/properties-schema :string)
; [:map
;  [:min {:description &quot;length must be at least&quot;} :int]
;  [:max {:description &quot;length must be at most&quot;} :int]]</pre>
… different schema applications (e.g. generation) will have their own overlays, which can be merged to get the full set of available keys. Should be easy to generate proper docs out of those.</z><z id="t1620019820" t="ikitommi after the children &amp; property schemas are done, one can also generate valid schema-hiccup out of a given registry 🙂"><y>#</y><d>2021-05-03</d><h>05:30</h><w>ikitommi</w>after the children &amp; property schemas are done, one can also generate valid schema-hiccup out of a given registry <b>🙂</b></z><z id="t1620045931" t="Yehonathan Sharvit Is there a way to forbid some combination of keys in a map? For instance a map with either :a and :b or :c and :d"><y>#</y><d>2021-05-03</d><h>12:45</h><w>Yehonathan Sharvit</w>Is there a way to forbid some combination of keys in a map?
For instance a map with either <code>:a</code> and <code>:b</code> or <code>:c</code> and <code>:d</code></z><z id="t1620046097" t="borkdude probably using another predicate?"><y>#</y><d>2021-05-03</d><h>12:48</h><w>borkdude</w>probably using another predicate?</z><z id="t1620046118" t="borkdude or using two different maps"><y>#</y><d>2021-05-03</d><h>12:48</h><w>borkdude</w>or using two different maps</z><z id="t1620046301" t="Yehonathan Sharvit What do you mean by “using another predicate”?"><y>#</y><d>2021-05-03</d><h>12:51</h><w>Yehonathan Sharvit</w>What do you mean by “using another predicate”?</z><z id="t1620046432" t="borkdude [:and [:map ...] [:fn (fn [...] ...)]]"><y>#</y><d>2021-05-03</d><h>12:53</h><w>borkdude</w><code>[:and [:map ...] [:fn (fn [...] ...)]]</code></z><z id="t1620046461" t="borkdude Same as with clojure.spec"><y>#</y><d>2021-05-03</d><h>12:54</h><w>borkdude</w>Same as with clojure.spec</z><z id="t1620046490" t="borkdude (def my-schema [:and [:map [:x int?] [:y int?]] [:fn (fn [{:keys [x y]}] (&gt; x y))]])"><y>#</y><d>2021-05-03</d><h>12:54</h><w>borkdude</w><pre>(def my-schema
  [:and
   [:map
    [:x int?]
    [:y int?]]
   [:fn (fn [{:keys [x y]}] (&gt; x y))]])</pre></z><z id="t1620046557" t="Ben Sless I was just going to ask if there&apos;s a way to specify constraints on relations between keys which does not involve defining an ad-hoc function"><y>#</y><d>2021-05-03</d><h>12:55</h><w>Ben Sless</w>I was just going to ask if there&apos;s a way to specify constraints on relations between keys which does not involve defining an ad-hoc function</z><z id="t1620046582" t="borkdude Maybe using two separate closed maps also works. I think it depends on your domain perhaps?"><y>#</y><d>2021-05-03</d><h>12:56</h><w>borkdude</w>Maybe using two separate closed maps also works. I think it depends on your domain perhaps?</z><z id="t1620046634" t="Ben Sless Likely, although I was just thinking of a case like the one you illustrated, a constraint where the value at one key is greater than another"><y>#</y><d>2021-05-03</d><h>12:57</h><w>Ben Sless</w>Likely, although I was just thinking of a case like the one you illustrated, a constraint where the value at one key is greater than another</z><z id="t1620046759" t="Ben Sless This pattern repeats so often, should it be a schema?"><y>#</y><d>2021-05-03</d><h>12:59</h><w>Ben Sless</w>This pattern repeats so often, should it be a schema?</z><z id="t1620047961" t="Ben Sless Something like: (def preds {:&gt; &gt;, :&gt;= &gt;=, :&lt; &lt;, :&lt;= &lt;=, := =, :not= not=}) (defn -rel [] (m/-simple-schema (fn [_ [pred a b]] {:type :rel, :pred (m/-safe-pred #((preds pred) (get % a) (get % b))), :min 3, :max 3}))) (m/validate (m/schema [:and [:map [:x :int] [:y :int]] [:rel :&lt; :x :y]] {:registry (mr/composite-registry m/default-registry {:rel (-rel)})}) #_{:x 1 :y 2} {:x 1 :y 1}) "><y>#</y><d>2021-05-03</d><h>13:19</h><w>Ben Sless</w>Something like:
<pre>(def preds {:&gt; &gt;, :&gt;= &gt;=, :&lt; &lt;, :&lt;= &lt;=, := =, :not= not=})

(defn -rel
  []
  (m/-simple-schema
   (fn [_ [pred a b]]
     {:type :rel,
      :pred (m/-safe-pred #((preds pred) (get % a) (get % b))),
      :min 3,
      :max 3})))

(m/validate
 (m/schema
  [:and
   [:map
    [:x :int]
    [:y :int]]
   [:rel :&lt; :x :y]]
  {:registry
   (mr/composite-registry
    m/default-registry
    {:rel (-rel)})})
 #_{:x 1 :y 2}
 {:x 1 :y 1})</pre>
</z><z id="t1620048198" t="borkdude reminds me of jet :) $ echo &apos;{:a 1 :b 2}&apos; | jet --query &apos;(&lt; :a :b)&apos; true $ echo &apos;{:a 1 :b 2}&apos; | jet --query &apos;(&gt; :a :b)&apos; false"><y>#</y><d>2021-05-03</d><h>13:23</h><w>borkdude</w>reminds me of jet :)
<pre>$ echo  &apos;{:a 1 :b 2}&apos; | jet --query &apos;(&lt; :a :b)&apos;
true
$ echo  &apos;{:a 1 :b 2}&apos; | jet --query &apos;(&gt; :a :b)&apos;
false</pre></z><z id="t1620048527" t="ikitommi I think it’s good idea to experiment new relational schemas in the user space, both -simple-schema &amp; -collection-schma are good ways to make these, like [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] you demoed. The more stuff pushed into these data-languages, the more it looks like a simple sci."><y>#</y><d>2021-05-03</d><h>13:28</h><w>ikitommi</w>I think it’s good idea to experiment new relational schemas in the user space, both <code>-simple-schema</code> &amp; <code>-collection-schma</code> are good ways to make these, like <a>@ben.sless</a> you demoed. The more stuff pushed into these data-languages, the more it looks like a simple sci.</z><z id="t1620048592" t="Ben Sless I also had some thoughts on the subject here https://clojureverse.org/t/declarative-rules-for-relations-between-inputs/7623/5?u=bsless"><y>#</y><d>2021-05-03</d><h>13:29</h><r>Ben Sless</r>I also had some thoughts on the subject here
<a href="https://clojureverse.org/t/declarative-rules-for-relations-between-inputs/7623/5?u=bsless" target="_blank">https://clojureverse.org/t/declarative-rules-for-relations-between-inputs/7623/5?u=bsless</a></z><z id="t1620048632" t="Ben Sless A big plus it could have over sci is getting the benefit of the JIT while still keeping the schema serializable"><y>#</y><d>2021-05-03</d><h>13:30</h><r>Ben Sless</r>A big plus it could have over sci is getting the benefit of the JIT while still keeping the schema serializable</z><z id="t1620048645" t="ikitommi only 👍"><y>#</y><d>2021-05-03</d><h>13:30</h><r>ikitommi</r><code>only</code> <b>👍</b></z><z id="t1620048676" t="ikitommi true, sci introduces a lot of overhead. and is big on cljs."><y>#</y><d>2021-05-03</d><h>13:31</h><r>ikitommi</r>true, sci introduces a lot of overhead. and is big on cljs.</z><z id="t1620048714" t="borkdude much smaller than self-hosted CLJS though"><y>#</y><d>2021-05-03</d><h>13:31</h><r>borkdude</r>much smaller than self-hosted CLJS though</z><z id="t1620048729" t="borkdude but how many people are really using schema serialization?"><y>#</y><d>2021-05-03</d><h>13:32</h><r>borkdude</r>but how many people are really using schema serialization?</z><z id="t1620048735" t="borkdude I think most people are not"><y>#</y><d>2021-05-03</d><h>13:32</h><r>borkdude</r>I think most people are not</z><z id="t1620048743" t="ikitommi i think so too."><y>#</y><d>2021-05-03</d><h>13:32</h><r>ikitommi</r>i think so too.</z><z id="t1620048758" t="Ben Sless Does select-keys translate to mu/get of all the keys then closing the schema?"><y>#</y><d>2021-05-03</d><h>13:32</h><r>Ben Sless</r>Does select-keys translate to <code>mu/get</code> of all the keys then closing the schema?</z><z id="t1620048835" t="ikitommi but a lightweight map key dependency utility might be a good fit for many things. just (somone) needs (to invent) more syntax."><y>#</y><d>2021-05-03</d><h>13:33</h><r>ikitommi</r>but a lightweight map key dependency utility might be a good fit for many things. just (somone) needs (to invent) more syntax.</z><z id="t1620048836" t="Ben Sless The schema serialization isn&apos;t my first (or third) priority here tbh, it&apos;s more about having more expressive schemas for the common 90% of cases and not having to define ad-hoc functions and errors for them, not to mention generators."><y>#</y><d>2021-05-03</d><h>13:33</h><r>Ben Sless</r>The schema serialization isn&apos;t my first (or third) priority here tbh, it&apos;s more about having more expressive schemas for the common 90% of cases and not having to define ad-hoc functions and errors for them, not to mention generators.</z><z id="t1620048849" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239"><y>#</y><d>2021-05-03</d><h>13:34</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239</a></z><z id="t1620048869" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239"><y>#</y><d>2021-05-03</d><h>13:34</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L233-L239</a></z><z id="t1620048875" t="borkdude yeah, I think that&apos;s nice. I think clojure spec also doesn&apos;t have a good answer to this yet and it&apos;s pretty common"><y>#</y><d>2021-05-03</d><h>13:34</h><r>borkdude</r>yeah, I think that&apos;s nice. I think clojure spec also doesn&apos;t have a good answer to this yet and it&apos;s pretty common</z><z id="t1620049540" t="Yehonathan Sharvit Is there an answer to this in TypeScript?"><y>#</y><d>2021-05-03</d><h>13:45</h><r>Yehonathan Sharvit</r>Is there an answer to this in TypeScript?</z><z id="t1620049753" t="ikitommi I think you have to use union types with ts"><y>#</y><d>2021-05-03</d><h>13:49</h><r>ikitommi</r>I think you have to use union types with ts</z><z id="t1620051104" t="Yehonathan Sharvit Does it help to define constraints on map keys"><y>#</y><d>2021-05-03</d><h>14:11</h><r>Yehonathan Sharvit</r>Does it help to define constraints on map keys</z><z id="t1620051106" t="Yehonathan Sharvit ?"><y>#</y><d>2021-05-03</d><h>14:11</h><r>Yehonathan Sharvit</r>?</z><z id="t1620063569" t="Joel I&apos;m surprised that TypeScript is sophisticated enough to be used as inspiration, I guess I need to learn more. I&apos;ve presumed Elm/Haskell are more sophisticated, eg.: https://www.youtube.com/watch?v=IcgmSRJHu_8"><y>#</y><d>2021-05-03</d><h>17:39</h><r>Joel</r>I&apos;m surprised that TypeScript is sophisticated enough to be used as inspiration, I guess I need to learn more. I&apos;ve presumed Elm/Haskell are more sophisticated, eg.: <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8" target="_blank">https://www.youtube.com/watch?v=IcgmSRJHu_8</a></z><z id="t1620614913" t="mynomoto Typescript is way more pragmatic than elm/Haskell. Structural typing almost looks like malli schemas enforced at compile time."><y>#</y><d>2021-05-10</d><h>02:48</h><r>mynomoto</r>Typescript is way more pragmatic than elm/Haskell. Structural typing almost looks like malli schemas enforced at compile time.</z><z id="t1620048583" t="ikitommi there is also things like :select-keys -&gt; https://malli.io/?value=%7B%3Aa%201%2C%20%3Ab%202%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ABCD%22%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aa%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ab%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ac%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ad%20%3Aany%5D%5D%7D%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Aa%20%3Ab%5D%5D%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Ac%20%3Ad%5D%5D%5D%5D ."><y>#</y><d>2021-05-03</d><h>13:29</h><w>ikitommi</w>there is also things like <code>:select-keys</code> -&gt;  <a href="https://malli.io/?value=%7B%3Aa%201%2C%20%3Ab%202%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ABCD%22%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aa%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ab%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ac%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ad%20%3Aany%5D%5D%7D%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Aa%20%3Ab%5D%5D%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Ac%20%3Ad%5D%5D%5D%5D" target="_blank">https://malli.io/?value=%7B%3Aa%201%2C%20%3Ab%202%7D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ABCD%22%20%5B%3Amap%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aa%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ab%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ac%20%3Aany%5D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Ad%20%3Aany%5D%5D%7D%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%5B%3Aor%20%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Aa%20%3Ab%5D%5D%0A%20%20%5B%3Aselect-keys%20%22ABCD%22%20%5B%3Ac%20%3Ad%5D%5D%5D%5D</a>.</z><z id="t1620048705" t="ikitommi would meander be great at describing the relations, as data?"><y>#</y><d>2021-05-03</d><h>13:31</h><w>ikitommi</w>would meander be great at describing the relations, as data?</z><z id="t1620049004" t="borkdude malleander!"><y>#</y><d>2021-05-03</d><h>13:36</h><w>borkdude</w>malleander!</z><z id="t1620049063" t="ikitommi using modified ben’s syntax: [:and [:map [:a :any] [:b :any] [:c :any] [:d :any]] [:rel [:or [:and :a :b] [:and :c :d]]]]"><y>#</y><d>2021-05-03</d><h>13:37</h><w>ikitommi</w>using modified ben’s syntax:
<pre>[:and
 [:map
  [:a :any]
  [:b :any]
  [:c :any]
  [:d :any]]
 [:rel
  [:or
   [:and :a :b]
   [:and :c :d]]]]</pre></z><z id="t1620049080" t="Ben Sless The only objection I can come up with is that meander is too powerful, (i.e. the result will be hard to work with)"><y>#</y><d>2021-05-03</d><h>13:38</h><w>Ben Sless</w>The only objection I can come up with is that meander is too powerful, (i.e. the result will be hard to work with)</z><z id="t1620049164" t="Ben Sless &quot;Here, have this fighter-jet fueled by liquid plutonium&quot; Scary"><y>#</y><d>2021-05-03</d><h>13:39</h><r>Ben Sless</r>&quot;Here, have this fighter-jet fueled by liquid plutonium&quot;
Scary</z><z id="t1620049102" t="borkdude I think it can be confusing to overload the meaning of :or within :rel"><y>#</y><d>2021-05-03</d><h>13:38</h><w>borkdude</w>I think it can be confusing to overload the meaning of <code>:or</code> within <code>:rel</code></z><z id="t1620049174" t="borkdude Maybe just [:and [:map ....] [:or [:required-keys :a :b] [:required-keys :c :d]] [:gtk :a :b]]"><y>#</y><d>2021-05-03</d><h>13:39</h><w>borkdude</w>Maybe just <code>[:and [:map ....] [:or [:required-keys :a :b] [:required-keys :c :d]] [:gtk :a :b]]</code></z><z id="t1620049182" t="borkdude (gtk = greather than for keys, or something)"><y>#</y><d>2021-05-03</d><h>13:39</h><w>borkdude</w>(gtk = greather than for keys, or something)</z><z id="t1620049208" t="Ben Sless The rel syntax needs to be properly thought out, I just invented something ad-hoc to see if it could work"><y>#</y><d>2021-05-03</d><h>13:40</h><w>Ben Sless</w>The rel syntax needs to be properly thought out, I just invented something ad-hoc to see if it could work</z><z id="t1620049214" t="borkdude [:keys/&gt; :a :b]"><y>#</y><d>2021-05-03</d><h>13:40</h><w>borkdude</w><code>[:keys/&gt; :a :b]</code></z><z id="t1620049237" t="Ben Sless How about :constraints ?"><y>#</y><d>2021-05-03</d><h>13:40</h><w>Ben Sless</w>How about <code>:constraints</code>?</z><z id="t1620049243" t="borkdude [:keys/require :a :b]"><y>#</y><d>2021-05-03</d><h>13:40</h><w>borkdude</w><code>[:keys/require :a :b]</code></z><z id="t1620049276" t="Ben Sless Then constraints unify by default (like datalog) or disjoin when specified (via :or )"><y>#</y><d>2021-05-03</d><h>13:41</h><w>Ben Sless</w>Then constraints unify by default (like datalog) or disjoin when specified (via <code>:or</code>)</z><z id="t1620049277" t="borkdude [:k&gt; :a :b] , [:kreq :a :b]"><y>#</y><d>2021-05-03</d><h>13:41</h><w>borkdude</w><code>[:k&gt; :a :b]</code>, <code>[:kreq :a :b]</code></z><z id="t1620049321" t="ikitommi this works already: (m/validate [:schema {:registry {::a :int ::b :int ::c :int ::d :int}} [:or [:map ::a ::b] [:map ::c ::d]]] {::a 1, ::b 2}) ; =&gt; true"><y>#</y><d>2021-05-03</d><h>13:42</h><w>ikitommi</w>this works already:
<pre>(m/validate
  [:schema {:registry {::a :int
                       ::b :int
                       ::c :int
                       ::d :int}}
   [:or
    [:map ::a ::b]
    [:map ::c ::d]]] 
  {::a 1, ::b 2})
; =&gt; true</pre></z><z id="t1620049769" t="Yehonathan Sharvit But it doesn’t scale. When you have other set of constraints you’d need to write down all the combinations of valid keys."><y>#</y><d>2021-05-03</d><h>13:49</h><r>Yehonathan Sharvit</r>But it doesn’t scale. When you have other set of constraints you’d need to write down all the combinations of valid keys.</z><z id="t1620049345" t="borkdude yeah, that&apos;s what I said in the start of the conversation: two disjunct map defs"><y>#</y><d>2021-05-03</d><h>13:42</h><w>borkdude</w>yeah, that&apos;s what I said in the start of the conversation: two disjunct map defs</z><z id="t1620049353" t="ikitommi just not with non-qualified keys (for no good reason)"><y>#</y><d>2021-05-03</d><h>13:42</h><w>ikitommi</w>just not with non-qualified keys (for no good reason)</z><z id="t1620049362" t="Ben Sless [:constraints [:or [:and [:requires :a :b] [:&gt; :a :b]] [:and [:requires :c :d] [:&lt; :c :d]]]]"><y>#</y><d>2021-05-03</d><h>13:42</h><w>Ben Sless</w><pre>[:constraints
 [:or
  [:and
   [:requires :a :b]
   [:&gt; :a :b]]
  [:and
   [:requires :c :d]
   [:&lt; :c :d]]]]</pre></z><z id="t1620049374" t="borkdude but for rels between keys you could just have specialized ops like [:k&gt; :a :b] : the :a key must be greater than the :b key, without introducing some new concept"><y>#</y><d>2021-05-03</d><h>13:42</h><w>borkdude</w>but for rels between keys you could just have specialized ops like <code>[:k&gt; :a :b]</code>: the <code>:a</code> key must be greater than the <code>:b</code> key, without introducing some new concept</z><z id="t1620049426" t="ikitommi i kinda like it."><y>#</y><d>2021-05-03</d><h>13:43</h><w>ikitommi</w>i kinda like it.</z><z id="t1620049458" t="Ben Sless special ops rub me the wrong way, for some reason. What&apos;s wrong with just :&gt; ?"><y>#</y><d>2021-05-03</d><h>13:44</h><w>Ben Sless</w>special ops rub me the wrong way, for some reason. What&apos;s wrong with just <code>:&gt;</code>?</z><z id="t1620049474" t="ikitommi but question is: from whom the declaration are for? schema writer? user? external docs?"><y>#</y><d>2021-05-03</d><h>13:44</h><w>ikitommi</w>but question is: from whom the declaration are for? schema writer? user? external docs?</z><z id="t1620049513" t="ikitommi (m/validate [:&gt; 6] 4) ; =&gt; false"><y>#</y><d>2021-05-03</d><h>13:45</h><w>ikitommi</w><pre>(m/validate [:&gt; 6] 4)
; =&gt; false</pre></z><z id="t1620049519" t="ikitommi it already exists"><y>#</y><d>2021-05-03</d><h>13:45</h><w>ikitommi</w>it already exists</z><z id="t1620049583" t="Ben Sless hm, yes, but as a schema not an argument (if we go back to the [:rel x y z] or [:constraint ,,,] suggestion"><y>#</y><d>2021-05-03</d><h>13:46</h><w>Ben Sless</w>hm, yes, but as a schema not an argument (if we go back to the <code>[:rel x y z]</code> or <code>[:constraint ,,,]</code> suggestion</z><z id="t1620049644" t="borkdude &gt; What&apos;s wrong with just :&gt; That it means different things in different contexts, this can be confusing imo."><y>#</y><d>2021-05-03</d><h>13:47</h><w>borkdude</w>&gt; What&apos;s wrong with just :&gt;
That it means different things in different contexts, this can be confusing imo.</z><z id="t1620049729" t="borkdude What if you want to really do numeric comparison like [:&gt; :a 5] and 5 is also a key in a map?"><y>#</y><d>2021-05-03</d><h>13:48</h><w>borkdude</w>What if you want to really do numeric comparison like <code>[:&gt; :a 5]</code> and 5 is also a key in a map?</z><z id="t1620049743" t="borkdude In jet I chose [:&gt; :a #jet/lit 5]"><y>#</y><d>2021-05-03</d><h>13:49</h><w>borkdude</w>In jet I chose <code>[:&gt; :a #jet/lit 5]</code></z><z id="t1620049753" t="borkdude but quickly this became tedious so I wrote a clojure interpreter"><y>#</y><d>2021-05-03</d><h>13:49</h><w>borkdude</w>but quickly this became tedious so I wrote a clojure interpreter</z><z id="t1620049837" t="Ben Sless The most shorthand constraint syntax I can think of would be :! An alternative which conforms to your suggestion would be :!/&gt;"><y>#</y><d>2021-05-03</d><h>13:50</h><w>Ben Sless</w>The most shorthand constraint syntax I can think of would be <code>:!</code>
An alternative which conforms to your suggestion would be <code>:!/&gt;</code></z><z id="t1620049911" t="Ben Sless Downside - it looks like Perl Upside - concise and unique syntax"><y>#</y><d>2021-05-03</d><h>13:51</h><w>Ben Sless</w>Downside - it looks like Perl
Upside - concise and unique syntax</z><z id="t1620049957" t="borkdude you should always make a good trade-off between adding extra syntax (= complexity) and how much people are really going to use this"><y>#</y><d>2021-05-03</d><h>13:52</h><w>borkdude</w>you should always make a good trade-off between adding extra syntax (= complexity) and how much people are really going to use this</z><z id="t1620049994" t="ikitommi [:and [:map [:a :any] [:b :any] [:c :any] [:d :any]] [:keys/or [:keys/and :a :b] [:keys/and :c :d]]]"><y>#</y><d>2021-05-03</d><h>13:53</h><w>ikitommi</w><pre>[:and
 [:map
  [:a :any]
  [:b :any]
  [:c :any]
  [:d :any]]
 [:keys/or
  [:keys/and :a :b]
  [:keys/and :c :d]]]</pre></z><z id="t1620050006" t="borkdude yeah, I like that a lot better"><y>#</y><d>2021-05-03</d><h>13:53</h><w>borkdude</w>yeah, I like that a lot better</z><z id="t1620050045" t="borkdude why even :keys/or , you can just use the normal :or here?"><y>#</y><d>2021-05-03</d><h>13:54</h><w>borkdude</w>why even <code>:keys/or</code>, you can just use the normal <code>:or</code> here?</z><z id="t1620050132" t="ikitommi true"><y>#</y><d>2021-05-03</d><h>13:55</h><r>ikitommi</r>true</z><z id="t1620050068" t="Yehonathan Sharvit I was about to write the same thing"><y>#</y><d>2021-05-03</d><h>13:54</h><w>Yehonathan Sharvit</w>I was about to write the same thing</z><z id="t1620050077" t="Ben Sless Then adding a predicate function on the keys would look like [:and [:map [:a :any] [:b :any] [:c :any] [:d :any]] [:or [:and [:keys/and :a :b] [:keys/&lt; :a :b]] [:keys/and :c :d]]]"><y>#</y><d>2021-05-03</d><h>13:54</h><w>Ben Sless</w>Then adding a predicate function on the keys would look like
<pre>[:and
 [:map
  [:a :any]
  [:b :any]
  [:c :any]
  [:d :any]]
 [:or
  [:and
   [:keys/and :a :b]
   [:keys/&lt; :a :b]]
  [:keys/and :c :d]]]</pre></z><z id="t1620050081" t="Yehonathan Sharvit The disjunction must not be about the keys"><y>#</y><d>2021-05-03</d><h>13:54</h><w>Yehonathan Sharvit</w>The disjunction must not be about the keys</z><z id="t1620050132" t="Ben Sless :keys/or should mean &quot;at least k1 or k2 should exist&quot;"><y>#</y><d>2021-05-03</d><h>13:55</h><w>Ben Sless</w><code>:keys/or</code> should mean &quot;at least k1 or k2 should exist&quot;</z><z id="t1620050159" t="borkdude what does :keys/and mean: both keys must be present? what does [:keys/and :a] mean then? Maybe [:keys/req :a] is a better name?"><y>#</y><d>2021-05-03</d><h>13:55</h><w>borkdude</w>what does <code>:keys/and</code> mean: both keys must be present? what does <code>[:keys/and :a]</code> mean then? Maybe <code>[:keys/req :a]</code> is a better name?</z><z id="t1620050207" t="Ben Sless Maybe even without a shorthand, keys/require"><y>#</y><d>2021-05-03</d><h>13:56</h><r>Ben Sless</r>Maybe even without a shorthand, <code>keys/require</code></z><z id="t1620050224" t="Yehonathan Sharvit :keys/req doesn’t convey the fact that :a and :b are related"><y>#</y><d>2021-05-03</d><h>13:57</h><r>Yehonathan Sharvit</r><code>:keys/req</code> doesn’t convey the fact that <code>:a</code> and <code>:b</code> are related</z><z id="t1620050255" t="borkdude but what exactly does [:keys/and :a :b] mean then, how are these things related?"><y>#</y><d>2021-05-03</d><h>13:57</h><r>borkdude</r>but what exactly does <code>[:keys/and :a :b]</code> mean then, how are these things related?</z><z id="t1620050328" t="Yehonathan Sharvit I didn’t say I liked :keys/and"><y>#</y><d>2021-05-03</d><h>13:58</h><r>Yehonathan Sharvit</r>I didn’t say I liked <code>:keys/and</code></z><z id="t1620050356" t="Yehonathan Sharvit Maybe [:keys/present :a :b] ?"><y>#</y><d>2021-05-03</d><h>13:59</h><r>Yehonathan Sharvit</r>Maybe <code>[:keys/present :a :b]</code>?</z><z id="t1620050412" t="borkdude but you also didn&apos;t say what the semantic relationship between those keys is according to that op. &gt; :keys/req doesn’t convey the fact that :a and :b are related :present also doesn&apos;t communicate a relationship, just as :required doesn&apos;t, it just means all those keys must be required/present"><y>#</y><d>2021-05-03</d><h>14:00</h><r>borkdude</r>but you also didn&apos;t say what the semantic relationship between those keys is according to that op.

&gt; :keys/req doesn’t convey the fact that :a and :b are related
<code>:present</code> also doesn&apos;t communicate a relationship, just as <code>:required</code> doesn&apos;t, it just means all those keys must be required/present</z><z id="t1620051083" t="Yehonathan Sharvit I was wrong. There is no relationship between the keys. But somehow I find it weird to say “required” inside an or condition"><y>#</y><d>2021-05-03</d><h>14:11</h><r>Yehonathan Sharvit</r>I was wrong. There is no relationship between the keys.
But somehow I find it weird to say “required” inside an <code>or</code>  condition</z><z id="t1620050172" t="Yehonathan Sharvit And now, where would we put a custom predicate [:fn …] ?"><y>#</y><d>2021-05-03</d><h>13:56</h><w>Yehonathan Sharvit</w>And now, where would we put a custom predicate <code>[:fn …]</code>?</z><z id="t1620050222" t="borkdude or :keys/with and :keys/without ;P"><y>#</y><d>2021-05-03</d><h>13:57</h><w>borkdude</w>or <code>:keys/with</code> and <code>:keys/without</code> ;P</z><z id="t1620050226" t="ikitommi off to cook some food. good discussion, as always 👍"><y>#</y><d>2021-05-03</d><h>13:57</h><w>ikitommi</w>off to cook some food. good discussion, as always <b>👍</b></z><z id="t1620050298" t="Ben Sless Thank you, feel like we hit on something useful and needed Bon appetit!"><y>#</y><d>2021-05-03</d><h>13:58</h><r>Ben Sless</r>Thank you, feel like we hit on something useful and needed
Bon appetit!</z><z id="t1620050411" t="Yehonathan Sharvit By the way, my use case is real for a project at work."><y>#</y><d>2021-05-03</d><h>14:00</h><w>Yehonathan Sharvit</w>By the way, my use case is real for a project at work.</z><z id="t1620050416" t="Ben Sless same"><y>#</y><d>2021-05-03</d><h>14:00</h><w>Ben Sless</w>same</z><z id="t1620050429" t="Yehonathan Sharvit We are writing a Hbase driver"><y>#</y><d>2021-05-03</d><h>14:00</h><w>Yehonathan Sharvit</w>We are writing a Hbase driver</z><z id="t1620050458" t="borkdude I guess you can already express required keys like this as well? [:and [:map ...] :a :b :c] or do keywords not behave like predicates in malli?"><y>#</y><d>2021-05-03</d><h>14:00</h><w>borkdude</w>I guess you can already express required keys like this as well? <code>[:and [:map ...] :a :b :c]</code> or do keywords not behave like predicates in malli?</z><z id="t1620050505" t="Ben Sless (m/schema [:and :a :b]) exception"><y>#</y><d>2021-05-03</d><h>14:01</h><r>Ben Sless</r><pre>(m/schema [:and :a :b])</pre>
exception</z><z id="t1620050533" t="borkdude ok, [:and [:fn :a] [:fn :b]] ? :thinking_face:"><y>#</y><d>2021-05-03</d><h>14:02</h><r>borkdude</r>ok, <code>[:and [:fn :a] [:fn :b]]</code> ? <b>:thinking_face:</b></z><z id="t1620050557" t="borkdude (ugly)"><y>#</y><d>2021-05-03</d><h>14:02</h><r>borkdude</r>(ugly)</z><z id="t1620050594" t="Ben Sless And non informative, and useless for generation (me/humanize (m/explain (m/schema [:and [:fn :a]]) {:b 1})) ;; =&gt; #:malli{:error [&quot;unknown error&quot;]} "><y>#</y><d>2021-05-03</d><h>14:03</h><r>Ben Sless</r>And non informative, and useless for generation
<pre>(me/humanize (m/explain (m/schema [:and [:fn :a]]) {:b 1}))
;; =&gt; #:malli{:error [&quot;unknown error&quot;]}</pre>
</z><z id="t1620050612" t="borkdude agreed"><y>#</y><d>2021-05-03</d><h>14:03</h><r>borkdude</r>agreed</z><z id="t1620050490" t="Yehonathan Sharvit The scan function receives a map that could contain either :from and :to or :starts-with"><y>#</y><d>2021-05-03</d><h>14:01</h><w>Yehonathan Sharvit</w>The <code>scan</code> function receives a map that could contain either <code>:from</code> and <code>:to</code> or <code>:starts-with</code></z><z id="t1620050506" t="borkdude It looks like malli is becoming really popular in Israel?"><y>#</y><d>2021-05-03</d><h>14:01</h><w>borkdude</w>It looks like malli is becoming really popular in Israel?</z><z id="t1620050560" t="Yehonathan Sharvit There are not so many Clojure shops i Israel. Therefore, we could already say that 10% of Israeli Clojure shops use malli 😁"><y>#</y><d>2021-05-03</d><h>14:02</h><w>Yehonathan Sharvit</w>There are not so many Clojure shops i Israel. Therefore, we could already say that 10% of Israeli Clojure shops use malli <b>😁</b></z><z id="t1620050776" t="Yehonathan Sharvit I’m struggling to write the schema of the map received by scan [:map [:starts-with :string] [:from :string] [:to :string] [:xor [:keys/req :starts-with] [:keys/req :from :to] [:keys/req :from] [:keys/req :to] ] ] "><y>#</y><d>2021-05-03</d><h>14:06</h><w>Yehonathan Sharvit</w>I’m struggling to write the schema of the map received by <code>scan</code>
<pre>[:map    
   [:starts-with :string]
   [:from :string]
   [:to :string]
 [:xor 
   [:keys/req :starts-with]
   [:keys/req :from :to]
   [:keys/req :from]
   [:keys/req :to]
 ]
]</pre>
</z><z id="t1620050804" t="Yehonathan Sharvit :or is not good in my case. It should be exclusive or"><y>#</y><d>2021-05-03</d><h>14:06</h><w>Yehonathan Sharvit</w><code>:or</code> is not good in my case. It should be exclusive or</z><z id="t1620050832" t="borkdude if it is xor, then why not use disjunct maps?"><y>#</y><d>2021-05-03</d><h>14:07</h><w>borkdude</w>if it is xor, then why not use disjunct maps?</z><z id="t1620050846" t="Yehonathan Sharvit Because there are other keys"><y>#</y><d>2021-05-03</d><h>14:07</h><w>Yehonathan Sharvit</w>Because there are other keys</z><z id="t1620050862" t="borkdude maybe add a :type field or something?"><y>#</y><d>2021-05-03</d><h>14:07</h><w>borkdude</w>maybe add a <code>:type</code> field or something?</z><z id="t1620050879" t="Yehonathan Sharvit :time-range , :limit …"><y>#</y><d>2021-05-03</d><h>14:07</h><w>Yehonathan Sharvit</w><code>:time-range</code> , <code>:limit</code> …</z><z id="t1620050925" t="Yehonathan Sharvit [:map [:starts-with :string] [:from :string] [:to :string] [:limit :number] [:time-range [:map [:from-ms :int] [:to-ms :int]] [:xor [:keys/req :starts-with] [:keys/req :from :to] [:keys/req :from] [:keys/req :to] ] ]"><y>#</y><d>2021-05-03</d><h>14:08</h><w>Yehonathan Sharvit</w><pre>[:map    
   [:starts-with :string]
   [:from :string]
   [:to :string]
   [:limit :number]
   [:time-range [:map [:from-ms :int] [:to-ms :int]]
 [:xor 
   [:keys/req :starts-with]
   [:keys/req :from :to]
   [:keys/req :from]
   [:keys/req :to]
 ]
]</pre></z><z id="t1620050939" t="Yehonathan Sharvit What is a :type field?"><y>#</y><d>2021-05-03</d><h>14:08</h><w>Yehonathan Sharvit</w>What is a <code>:type</code> field?</z><z id="t1620050997" t="borkdude I think you could have different types of ranges"><y>#</y><d>2021-05-03</d><h>14:09</h><w>borkdude</w>I think you could have different types of ranges</z><z id="t1620051063" t="borkdude {:range-type :closed} , {:range-type :open}"><y>#</y><d>2021-05-03</d><h>14:11</h><w>borkdude</w><code>{:range-type :closed}</code>, <code>{:range-type :open}</code></z><z id="t1620051069" t="Ben Sless In this case I&apos;d start with some base schema, merge the different options with it and or between them"><y>#</y><d>2021-05-03</d><h>14:11</h><w>Ben Sless</w>In this case I&apos;d start with some base schema, merge the different options with it and or between them</z><z id="t1620051165" t="Yehonathan Sharvit I don’t get what both of you suggested"><y>#</y><d>2021-05-03</d><h>14:12</h><w>Yehonathan Sharvit</w>I don’t get what both of you suggested</z><z id="t1620051439" t="borkdude [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] I think this requirement is a bit weird: :xor [:keys/req :from :to] [:keys/req :from] if from is present, and to is not, then the second is true. but if to is present, then the first one is true. so to is optional."><y>#</y><d>2021-05-03</d><h>14:17</h><w>borkdude</w><a>@viebel</a> I think this requirement is a bit weird:
<pre>:xor
[:keys/req :from :to]
[:keys/req :from]</pre>
if from is present, and to is not, then the second is true. but if to is present, then the first one is true. so to is optional.</z><z id="t1620051470" t="borkdude I did not look at the other requirements, but I think your logic can be &quot;refactored&quot;"><y>#</y><d>2021-05-03</d><h>14:17</h><w>borkdude</w>I did not look at the other requirements, but I think your logic can be &quot;refactored&quot;</z><z id="t1620051476" t="borkdude by modeling it differently"><y>#</y><d>2021-05-03</d><h>14:17</h><w>borkdude</w>by modeling it differently</z><z id="t1620055708" t="Yehonathan Sharvit I don’t see how to refactor the logic. All the followings are valid • :from 10 :to 20 • :form 10 • :to 20 • :starts-with aaa"><y>#</y><d>2021-05-03</d><h>15:28</h><r>Yehonathan Sharvit</r>I don’t see how to refactor the logic.
All the followings are valid
• :from 10 :to 20 
• :form 10
• :to 20
• :starts-with aaa</z><z id="t1620055734" t="Yehonathan Sharvit The followings are invalid"><y>#</y><d>2021-05-03</d><h>15:28</h><r>Yehonathan Sharvit</r>The followings are invalid</z><z id="t1620055769" t="Yehonathan Sharvit • :from 10 :starts-with aaa • :to 20 :starts-with aaa • “from 10 :to 20 starts-with aaa"><y>#</y><d>2021-05-03</d><h>15:29</h><r>Yehonathan Sharvit</r>• :from 10 :starts-with aaa
• :to 20 :starts-with aaa
• “from 10 :to 20 starts-with aaa</z><z id="t1620051756" t="emccue hmm, this is a tricky one"><y>#</y><d>2021-05-03</d><h>14:22</h><w>emccue</w>hmm, this is a tricky one</z><z id="t1620051836" t="emccue [:or [:map {:closed true} [:from ...] [:to ...]] [:map {:closed true} [:starts-with ...]]]"><y>#</y><d>2021-05-03</d><h>14:23</h><w>emccue</w><pre>[:or [:map {:closed true}
       [:from ...]
       [:to   ...]]
     [:map {:closed true}
       [:starts-with ...]]]</pre></z><z id="t1620051859" t="emccue OR is an exclusive or if the types don&apos;t intersect"><y>#</y><d>2021-05-03</d><h>14:24</h><w>emccue</w>OR is an exclusive or if the types don&apos;t intersect</z><z id="t1620051876" t="emccue [:map [:from ...] [:to ...]]"><y>#</y><d>2021-05-03</d><h>14:24</h><w>emccue</w><pre>[:map 
  [:from ...]
  [:to   ...]]</pre></z><z id="t1620051891" t="emccue but if you have it closed you can&apos;t have anything other than from and to"><y>#</y><d>2021-05-03</d><h>14:24</h><w>emccue</w>but if you have it closed you can&apos;t have anything other than from and to</z><z id="t1620051929" t="emccue and if you have it open you leave open the possibility that :starts-with is in the map as well"><y>#</y><d>2021-05-03</d><h>14:25</h><w>emccue</w>and if you have it open you leave open the possibility that :starts-with is in the map as well</z><z id="t1620051941" t="emccue what you need is basically"><y>#</y><d>2021-05-03</d><h>14:25</h><w>emccue</w>what you need is basically</z><z id="t1620052028" t="emccue [:or [:and [:map [:from ...] [:to ...]] [:not [:map [:starts-with ...]]]] [:and [:map [:starts-with ...]] [:not [:map [:from ...] [:to ...]]]]"><y>#</y><d>2021-05-03</d><h>14:27</h><w>emccue</w><pre>[:or [:and [:map 
             [:from ...]
             [:to ...]]
           [:not [:map 
                   [:starts-with ...]]]]
     [:and [:map 
             [:starts-with ...]]
           [:not [:map 
                   [:from ...]
                   [:to   ...]]]]</pre></z><z id="t1620052034" t="emccue OR"><y>#</y><d>2021-05-03</d><h>14:27</h><w>emccue</w>OR</z><z id="t1620052070" t="emccue [:or [:and [:map [:from ...] [:to ...]] [:not [:map [:starts-with ...]]]] [:and [:map [:starts-with ...]] [:not [:map [:from ...]] [:not [:map [:to ...]]]]] "><y>#</y><d>2021-05-03</d><h>14:27</h><w>emccue</w><pre>[:or [:and [:map 
             [:from ...]
             [:to ...]]
           [:not [:map 
                   [:starts-with ...]]]]
     [:and [:map 
             [:starts-with ...]]
           [:not [:map [:from ...]]
           [:not [:map [:to ...]]]]]</pre>
</z><z id="t1620052107" t="emccue not that not exists, but conceptually thats what you would need to represent the constraint"><y>#</y><d>2021-05-03</d><h>14:28</h><w>emccue</w>not that not exists, but conceptually thats what you would need to represent the constraint</z><z id="t1620052134" t="emccue since you only want to be closed against specific keys"><y>#</y><d>2021-05-03</d><h>14:28</h><w>emccue</w>since you only want to be closed against specific keys</z><z id="t1620052163" t="emccue if you are willing to explicitly enumerate all the keys you can just do the version with {:closed"><y>#</y><d>2021-05-03</d><h>14:29</h><w>emccue</w>if you are willing to explicitly enumerate all the keys you can just do the version with {:closed</z><z id="t1620052192" t="Ben Sless I meant something like (def Base [:map [:limit :number] [:time-range [:map [:from-ms :int] [:to-ms :int]]]]) (def S1 (mu/merge Base [:map [:starts-with :string]])) (def S2 (mu/merge Base [:map [:from :string] [:to :string]])) "><y>#</y><d>2021-05-03</d><h>14:29</h><w>Ben Sless</w>I meant something like
<pre>(def Base
  [:map
   [:limit :number]
   [:time-range [:map [:from-ms :int] [:to-ms :int]]]])

(def S1 (mu/merge Base [:map [:starts-with :string]]))
(def S2 (mu/merge Base [:map [:from :string] [:to :string]]))</pre>
</z><z id="t1620054150" t="Ben Sless Did some generalizing work, still not set on the syntax (defn comparator-relation [sym msg] (let [f @(resolve sym) type (keyword &quot;!&quot; (name sym))] [type (m/-simple-schema (fn [_ [a b]] (let [fa #(get % a) fb #(get % b)] {:type type :pred (m/-safe-pred #(f (fa %) (fb %))), :type-properties {:error/fn {:en (fn [{:keys [schema value]} _] (str &quot;value at key &quot; a &quot;, &quot; (fa value) &quot;, should be &quot; msg &quot; value at key &quot; b &quot;, &quot; (fb value)))}} :min 2, :max 2})))])) (defn -comparator-relation-schemas [] (into {} (map (fn [[sym msg]] (comparator-relation sym msg))) [[&apos;&gt; &quot;greater than&quot;] [&apos;&gt;= &quot;greater than or equal to&quot;] [&apos;= &quot;equal to&quot;] [&apos;== &quot;equal to&quot;] [&apos;&lt;= &quot;lesser than or equal to&quot;] [&apos;&lt; &quot;lesser than&quot;]])) (me/humanize (m/explain (m/schema [:and [:map [:x :int] [:y :int]] [:!/&gt; :x :y]] {:registry (mr/composite-registry m/default-registry (-comparator-relation-schemas))}) {:x 1 :y 1})) "><y>#</y><d>2021-05-03</d><h>15:02</h><w>Ben Sless</w>Did some generalizing work, still not set on the syntax
<pre>(defn comparator-relation
  [sym msg]
  (let [f @(resolve sym)
        type (keyword &quot;!&quot; (name sym))]
    [type
     (m/-simple-schema
      (fn [_ [a b]]
        (let [fa #(get % a)
              fb #(get % b)]
          {:type type
           :pred (m/-safe-pred #(f (fa %) (fb %))),
           :type-properties
           {:error/fn
            {:en (fn [{:keys [schema value]} _]
                   (str
                    &quot;value at key &quot;
                    a &quot;, &quot;
                    (fa value)
                    &quot;, should be &quot;
                    msg
                    &quot; value at key &quot;
                    b
                    &quot;, &quot;
                    (fb value)))}}
           :min 2,
           :max 2})))]))

(defn -comparator-relation-schemas
  []
  (into
   {}
   (map (fn [[sym msg]] (comparator-relation sym msg)))
   [[&apos;&gt;  &quot;greater than&quot;]
    [&apos;&gt;= &quot;greater than or equal to&quot;]
    [&apos;= &quot;equal to&quot;]
    [&apos;== &quot;equal to&quot;]
    [&apos;&lt;= &quot;lesser than or equal to&quot;]
    [&apos;&lt; &quot;lesser than&quot;]]))


(me/humanize
 (m/explain
  (m/schema
   [:and
    [:map
     [:x :int]
     [:y :int]]
    [:!/&gt; :x :y]]
   {:registry
    (mr/composite-registry
     m/default-registry
     (-comparator-relation-schemas))})
  {:x 1 :y 1}))</pre>
</z><z id="t1620109446" t="Ben Sless Next step is figuring out how to derive generators from this"><y>#</y><d>2021-05-04</d><h>06:24</h><w>Ben Sless</w>Next step is figuring out how to derive generators from this</z><z id="t1620112493" t="Ben Sless Most cases just work besides equality"><y>#</y><d>2021-05-04</d><h>07:14</h><w>Ben Sless</w>Most cases just work besides equality</z><z id="t1620116913" t="Ben Sless Here we go: (defn- derive-from-fmap [schema options gen] (let [props (merge (m/type-properties schema) (m/properties schema))] (when-some [fmap (:gen/fmap props)] (gen/fmap (m/eval fmap (or options (m/options schema))) gen)))) (defmethod mg/-schema-generator :and [schema options] (let [[h &amp; t] (m/children schema options) base-gen (mg/generator h options) gen (reduce (fn [gen schema] (if-let [gen (derive-from-fmap schema options gen)] gen gen)) base-gen t)] (gen/such-that (m/validator schema options) gen 100))) "><y>#</y><d>2021-05-04</d><h>08:28</h><w>Ben Sless</w>Here we go:
<pre>(defn- derive-from-fmap
  [schema options gen]
  (let [props (merge (m/type-properties schema)
                     (m/properties schema))]
    (when-some [fmap (:gen/fmap props)]
      (gen/fmap (m/eval fmap (or options (m/options schema)))
                gen))))

(defmethod mg/-schema-generator :and [schema options]
  (let [[h &amp; t] (m/children schema options)
        base-gen (mg/generator h options)
        gen (reduce (fn [gen schema]
                      (if-let [gen (derive-from-fmap schema options gen)]
                        gen
                        gen))
                    base-gen
                    t)]
    (gen/such-that (m/validator schema options) gen 100)))</pre>
</z><z id="t1620125973" t="Ben Sless I collected the proof of concept implementation with some explanations and cleaned up code at a repo https://github.com/bsless/malli-keys-relations"><y>#</y><d>2021-05-04</d><h>10:59</h><w>Ben Sless</w>I collected the proof of concept implementation with some explanations and cleaned up code at a repo <a href="https://github.com/bsless/malli-keys-relations" target="_blank">https://github.com/bsless/malli-keys-relations</a></z><z id="t1620132794" t="Ben Sless Some more thoughts: • should references to paths inside maps be explicit rather than implicit? i.e. [:keys/&gt; :x :y] vs [:keys/&gt; [:path :x] [:path :y]] . The second syntax is more cumbersome but gives more freedom (`[:path :x :z]`) and facilitates more logic (see next points) • Facts about collections. How do I say the value at key k1 must be contained in the collection in k2 , or a number smaller than the size of that collection? Stuff like [:contains? :x :y] (the value at y is in x), or [:&gt; [:count :x] :y] (y is smaller than the count of x)"><y>#</y><d>2021-05-04</d><h>12:53</h><w>Ben Sless</w>Some more thoughts:
• should references to paths inside maps be explicit rather than implicit? i.e. <code>[:keys/&gt; :x :y]</code> vs <code>[:keys/&gt; [:path :x] [:path :y]]</code> . The second syntax is more cumbersome but gives more freedom (`[:path :x :z]`) and facilitates more logic (see next points)
• Facts about collections. How do I say the value at key <code>k1</code> must be contained in the collection in <code>k2</code> , or a number smaller than the size of that collection? Stuff like <code>[:contains? :x :y]</code> (the value at y is in x), or <code>[:&gt; [:count :x] :y]</code> (y is smaller than the count of x)</z><z id="t1620135984" t="dvingo Very cool stuff! I was playing with adding support for cljs yesterday. (resolve sym) ( https://github.com/bsless/malli-keys-relations/blob/master/src/com/github/bsless/malli_keys_relations.clj#L112 ) is not allowed in cljs - I suspect converting this to a macro may get cljs support working. In cljs resolve only allows a literal quoted symbol as an argument: https://cljs.github.io/api/cljs.core/resolve"><y>#</y><d>2021-05-04</d><h>13:46</h><w>dvingo</w>Very cool stuff! I was playing with adding support for cljs yesterday. <code>(resolve sym)</code>(<a href="https://github.com/bsless/malli-keys-relations/blob/master/src/com/github/bsless/malli_keys_relations.clj#L112" target="_blank">https://github.com/bsless/malli-keys-relations/blob/master/src/com/github/bsless/malli_keys_relations.clj#L112</a>) is not allowed in cljs - I suspect converting this to a macro may get cljs support working.
In cljs resolve only allows a literal quoted symbol as an argument: <a href="https://cljs.github.io/api/cljs.core/resolve" target="_blank">https://cljs.github.io/api/cljs.core/resolve</a></z><z id="t1620137245" t="borkdude Note that runtime resolve in general doesn&apos;t play well with GraalVM native-image unless it&apos;s executed at compile time"><y>#</y><d>2021-05-04</d><h>14:07</h><w>borkdude</w>Note that runtime <code>resolve</code> in general doesn&apos;t play well with GraalVM native-image unless it&apos;s executed at compile time</z><z id="t1620138000" t="Ben Sless I&apos;ll replace it with a map or defmulti"><y>#</y><d>2021-05-04</d><h>14:20</h><w>Ben Sless</w>I&apos;ll replace it with a map or defmulti</z><z id="t1620138015" t="Ben Sless I think defmulti will be best, extensible"><y>#</y><d>2021-05-04</d><h>14:20</h><w>Ben Sless</w>I think defmulti will be best, extensible</z><z id="t1620142101" t="Ben Sless done"><y>#</y><d>2021-05-04</d><h>15:28</h><w>Ben Sless</w>done</z><z id="t1620142145" t="Ben Sless What about the alternative syntax?"><y>#</y><d>2021-05-04</d><h>15:29</h><w>Ben Sless</w>What about the alternative syntax?</z><z id="t1620197286" t="ikitommi great work [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] ! need to read the code &amp; think about this a bit. could you check the corresponding features from JSON Schema ( https://json-schema.org/understanding-json-schema/reference/object.html#dependencies ) so that Malli can be as compliant as it’s reasonable with it. I think your suggestion already a superset of what is in JSON Schema…"><y>#</y><d>2021-05-05</d><h>06:48</h><w>ikitommi</w>great work <a>@ben.sless</a>! need to read the code &amp; think about this a bit. could you check the corresponding features from JSON Schema (<a href="https://json-schema.org/understanding-json-schema/reference/object.html#dependencies" target="_blank">https://json-schema.org/understanding-json-schema/reference/object.html#dependencies</a>) so that Malli can be as compliant as it’s reasonable with it. I think your suggestion already a superset of what is in JSON Schema…</z><z id="t1620197378" t="ikitommi meanwhile, a quick poke on the schema inferring / providing: • part1: make it suck less (5x faster on sample dataset): https://github.com/metosin/malli/pull/439 • part2: make inferring first class, most likely 100x faster: https://github.com/metosin/malli/pull/440"><y>#</y><d>2021-05-05</d><h>06:49</h><w>ikitommi</w>meanwhile, a quick poke on the schema inferring / providing:
• part1: make it suck less (5x faster on sample dataset): <a href="https://github.com/metosin/malli/pull/439" target="_blank">https://github.com/metosin/malli/pull/439</a>
• part2: make inferring first class, most likely 100x faster: <a href="https://github.com/metosin/malli/pull/440" target="_blank">https://github.com/metosin/malli/pull/440</a></z><z id="t1620197537" t="ikitommi with part2, all schemas are reponsible for describing how values can/not be described with schemas. This will open up things like inferring types from enums etc, e.g. [:enum &quot;small&quot; &quot;medium&quot; &quot;large&quot;] has a child schema of :string ."><y>#</y><d>2021-05-05</d><h>06:52</h><w>ikitommi</w>with part2, all schemas are reponsible for describing how values can/not be described with schemas. This will open up things like inferring types from enums etc, e.g. <code>[:enum &quot;small&quot; &quot;medium&quot; &quot;large&quot;]</code> has a child schema of <code>:string</code>.</z><z id="t1620197632" t="ikitommi the part1 (5x faster) of new provider is now 68 loc, instead of the old 69. The old was kinda bloated anyways 😉"><y>#</y><d>2021-05-05</d><h>06:53</h><w>ikitommi</w>the part1 (5x faster) of new provider is now 68 loc, instead of the old 69. The old was kinda bloated anyways <b>😉</b></z><z id="t1620197811" t="ikitommi ➜ malli git:(faster-inferrer-part1) ✗ cloc src --by-file 15 text files. 15 unique files. 0 files ignored. v 1.86 T=0.03 s (571.3 files/s, 180498.1 lines/s) ---------------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------------- src/malli/core.cljc 146 46 1779 src/malli/impl/regex.cljc 93 23 508 src/malli/util.cljc 44 15 350 src/malli/transform.cljc 64 22 335 src/malli/generator.cljc 48 13 281 src/malli/error.cljc 24 6 249 src/malli/clj_kondo.cljc 21 3 141 src/malli/json_schema.cljc 23 3 128 src/malli/dot.cljc 7 3 69 src/malli/provider.cljc 10 3 68 src/malli/registry.cljc 15 3 65 src/malli/swagger.cljc 14 4 51 src/malli/impl/util.cljc 7 0 24 src/malli/edn.cljc 3 0 16 src/malli/sci.cljc 1 0 11 ---------------------------------------------------------------------------------------- SUM: 520 144 4075 ----------------------------------------------------------------------------------------"><y>#</y><d>2021-05-05</d><h>06:56</h><w>ikitommi</w><pre>➜  malli git:(faster-inferrer-part1) ✗ cloc src --by-file
      15 text files.
      15 unique files.
       0 files ignored.

 v 1.86  T=0.03 s (571.3 files/s, 180498.1 lines/s)
----------------------------------------------------------------------------------------
File                                      blank        comment           code
----------------------------------------------------------------------------------------
src/malli/core.cljc                         146             46           1779
src/malli/impl/regex.cljc                    93             23            508
src/malli/util.cljc                          44             15            350
src/malli/transform.cljc                     64             22            335
src/malli/generator.cljc                     48             13            281
src/malli/error.cljc                         24              6            249
src/malli/clj_kondo.cljc                     21              3            141
src/malli/json_schema.cljc                   23              3            128
src/malli/dot.cljc                            7              3             69
src/malli/provider.cljc                      10              3             68
src/malli/registry.cljc                      15              3             65
src/malli/swagger.cljc                       14              4             51
src/malli/impl/util.cljc                      7              0             24
src/malli/edn.cljc                            3              0             16
src/malli/sci.cljc                            1              0             11
----------------------------------------------------------------------------------------
SUM:                                        520            144           4075
----------------------------------------------------------------------------------------</pre></z><z id="t1620197842" t="ikitommi ➜ malli git:(faster-inferrer-part1) cloc test --by-file 11 text files. 11 unique files. 0 files ignored. v 1.86 T=0.04 s (264.8 files/s, 133395.9 lines/s) ----------------------------------------------------------------------------------- File blank comment code ----------------------------------------------------------------------------------- test/malli/core_test.cljc 330 6 1902 test/malli/util_test.cljc 115 4 789 test/malli/transform_test.cljc 93 3 714 test/malli/error_test.cljc 42 3 439 test/malli/generator_test.cljc 39 3 266 test/malli/swagger_test.cljc 11 4 258 test/malli/json_schema_test.cljc 14 4 236 test/malli/dot_test.cljc 12 0 73 test/malli/registry_test.cljc 10 2 61 test/malli/clj_kondo_test.cljc 8 0 55 test/malli/provider_test.cljc 4 0 41 ----------------------------------------------------------------------------------- SUM: 678 29 4834 -----------------------------------------------------------------------------------"><y>#</y><d>2021-05-05</d><h>06:57</h><w>ikitommi</w><pre>➜  malli git:(faster-inferrer-part1) cloc test --by-file
      11 text files.
      11 unique files.
       0 files ignored.

 v 1.86  T=0.04 s (264.8 files/s, 133395.9 lines/s)
-----------------------------------------------------------------------------------
File                                            blank        comment           code
-----------------------------------------------------------------------------------
test/malli/core_test.cljc                         330              6           1902
test/malli/util_test.cljc                         115              4            789
test/malli/transform_test.cljc                     93              3            714
test/malli/error_test.cljc                         42              3            439
test/malli/generator_test.cljc                     39              3            266
test/malli/swagger_test.cljc                       11              4            258
test/malli/json_schema_test.cljc                   14              4            236
test/malli/dot_test.cljc                           12              0             73
test/malli/registry_test.cljc                      10              2             61
test/malli/clj_kondo_test.cljc                      8              0             55
test/malli/provider_test.cljc                       4              0             41
-----------------------------------------------------------------------------------
SUM:                                              678             29           4834
-----------------------------------------------------------------------------------</pre></z><z id="t1620199600" t="Ben Sless Regarding part 1, from the profiling I did yesterday it looks like most CPU is based on miu/-fail . I&apos;ll profile again with part1 merged to see what conclusions I can infer"><y>#</y><d>2021-05-05</d><h>07:26</h><w>Ben Sless</w>Regarding part 1, from the profiling I did yesterday it looks like most CPU is based on <code>miu/-fail</code>. I&apos;ll profile again with part1 merged to see what conclusions I can infer</z><z id="t1620202447" t="Ben Sless disregard the last message I had some repl state"><y>#</y><d>2021-05-05</d><h>08:14</h><w>Ben Sless</w>disregard the last message I had some repl state</z><z id="t1620202603" t="Ben Sless ok, see ~2x speedup"><y>#</y><d>2021-05-05</d><h>08:16</h><w>Ben Sless</w>ok, see ~2x speedup</z><z id="t1620202688" t="Ben Sless -fail still dominates CPU, though. Would you like me to prepare a MR for the exception speedup?"><y>#</y><d>2021-05-05</d><h>08:18</h><w>Ben Sless</w><code>-fail</code> still dominates CPU, though.
Would you like me to prepare a MR for the exception speedup?</z><z id="t1620238971" t="Ben Sless Question about Malli&apos;s design - what&apos;s the rationale behind IntoSchema s? Why aren&apos;t Schema s and local bindings sufficient?"><y>#</y><d>2021-05-05</d><h>18:22</h><w>Ben Sless</w>Question about Malli&apos;s design - what&apos;s the rationale behind <code>IntoSchema</code>s? Why aren&apos;t <code>Schema</code>s and local bindings sufficient?</z><z id="t1620250263" t="ikitommi &gt; For internal elegance, Malli is built using protocols. &gt; It,s much easier to program and reason about the system with protocols than against functions / data. IntoSchema is analogous to a Class and Schena to an Object. There is one shared instance of :map IntoSchema (in a registry) which describes how to create :map Schema instances. And soon how to infer schemas from values. Kinda like adding static methods on classes, except it&apos;s all polymorphic."><y>#</y><d>2021-05-05</d><h>21:31</h><w>ikitommi</w>&gt; For internal elegance, Malli is built using protocols.
&gt; 
It,s much easier to program and reason about the system with protocols than against functions / data. <code>IntoSchema</code> is analogous to a <code>Class</code>  and <code>Schena</code> to an <code>Object.</code> There is one shared instance of <code>:map IntoSchema</code> (in a registry) which describes how to create <code>:map Schema</code> instances. And soon how to infer schemas from values. Kinda like adding static methods on classes, except it&apos;s all polymorphic.</z><z id="t1620303560" t="mike_ananev what is the difference between :or and :alt ?"><y>#</y><d>2021-05-06</d><h>12:19</h><w>mike_ananev</w>what is the difference between :or and :alt ?</z><z id="t1620303720" t="mike_ananev found in docs, :alt is for spec inside seq"><y>#</y><d>2021-05-06</d><h>12:22</h><w>mike_ananev</w>found in docs, :alt is for spec inside seq</z><z id="t1620305977" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] how to define string constant in map spec? e.g version api is a constant"><y>#</y><d>2021-05-06</d><h>12:59</h><w>mike_ananev</w><a>@ikitommi</a> how to define string constant in map spec? e.g version api is a constant</z><z id="t1620306005" t="mike_ananev [:enum &quot;v1.0.0&quot;] ?"><y>#</y><d>2021-05-06</d><h>13:00</h><w>mike_ananev</w>[:enum &quot;v1.0.0&quot;] ?</z><z id="t1620306022" t="mike_ananev is there other ways?"><y>#</y><d>2021-05-06</d><h>13:00</h><w>mike_ananev</w>is there other ways?</z><z id="t1620306172" t="mike_ananev and why sets are not supported as spec definition? I cannot put [:abc #{1 2 3}] in map spec"><y>#</y><d>2021-05-06</d><h>13:02</h><w>mike_ananev</w>and why sets are not supported as spec definition? I cannot put
<pre>[:abc #{1 2 3}]</pre>
in map spec</z><z id="t1620306665" t="ikitommi [:= &quot;v1.0.0&quot;] or [:enum &quot;v1.0.0&quot;] , both work."><y>#</y><d>2021-05-06</d><h>13:11</h><w>ikitommi</w><code>[:= &quot;v1.0.0&quot;]</code> or <code>[:enum &quot;v1.0.0&quot;]</code>, both work.</z><z id="t1620306874" t="ikitommi #{1 2 3} doesn’t work as we didn’t want to reserver too much clojure syntax for special purposes. There is a hook to add support for that in the user space, but not documented as it’s not recommended."><y>#</y><d>2021-05-06</d><h>13:14</h><w>ikitommi</w><code>#{1 2 3}</code> doesn’t work as we didn’t want to reserver too much clojure syntax for special purposes. There is a hook to add support for that in the user space, but not documented as it’s not recommended.</z><z id="t1620306909" t="ikitommi also, now I think adding a shortcut syntax for regexps was not a good idea."><y>#</y><d>2021-05-06</d><h>13:15</h><w>ikitommi</w>also, now I think  adding a shortcut syntax for regexps was not a good idea.</z><z id="t1620307016" t="ikitommi why? there is a cljs compiler warning about those, coudn’t fix it, instead of: #&quot;kikka.*&quot; would have been enough to have [:re #&quot;kikka.*] or even [:string {:format &quot;kikka.*&quot;}]"><y>#</y><d>2021-05-06</d><h>13:16</h><w>ikitommi</w>why? there is a cljs compiler warning about those, coudn’t fix it, instead of: <code>#&quot;kikka.*&quot;</code> would have been enough to have <code>[:re #&quot;kikka.*]</code> or even <code>[:string {:format &quot;kikka.*&quot;}]</code></z><z id="t1620307112" t="ikitommi I think in 90%+ cases people add anyway properties to the regexps like :error/message , so the benefit for supporting plain regexps is quite small."><y>#</y><d>2021-05-06</d><h>13:18</h><w>ikitommi</w>I think in 90%+ cases people add anyway properties to the regexps like <code>:error/message</code>,  so the benefit for supporting plain regexps is quite small.</z><z id="t1620307516" t="Ben Sless An enhancement of regex error messages could be an indication at which character the match has failed. &quot;Should match regex&quot; isn&apos;t terribly helpful for humanized errors"><y>#</y><d>2021-05-06</d><h>13:25</h><r>Ben Sless</r>An enhancement of regex error messages could be an indication at which character the match has failed.
&quot;Should match regex&quot; isn&apos;t terribly helpful for humanized errors</z><z id="t1620636541" t="nilern Host regexes don&apos;t support error positions. And I don&apos;t blame them, because the regex can fail in multiple ways at every character (our seqex schemas heuristically give the error the first longest partial match)."><y>#</y><d>2021-05-10</d><h>08:49</h><r>nilern</r>Host regexes don&apos;t support error positions. And I don&apos;t blame them, because the regex can fail in multiple ways at every character (our seqex schemas heuristically give the error the first longest partial match).</z><z id="t1620658752" t="Ben Sless If we can do regex based generators we should theoretically be able to do regex based error reporting No one said it would be easy, or even a good idea. You may not want to expose your regex via error messages"><y>#</y><d>2021-05-10</d><h>14:59</h><r>Ben Sless</r>If we can do regex based generators we should theoretically be able to do regex based error reporting
No one said it would be easy, or even a good idea. You may not want to expose your regex via error messages</z><z id="t1620309078" t="mike_ananev [:= &quot;v1.0.0&quot;] 👍"><y>#</y><d>2021-05-06</d><h>13:51</h><w>mike_ananev</w>[:= &quot;v1.0.0&quot;]<b>👍</b></z><z id="t1620319997" t="Joel Is there a function that would give &quot;:and&quot; instead of &quot;:or&quot;? stricter vs. looser. maybe mu/intersect? (mu/union [:map [:Event keyword?]] [:map [:Event [:enum :A :B]]]) =&gt; [:map [Event [:or keyword? [:enum :A :B]..."><y>#</y><d>2021-05-06</d><h>16:53</h><w>Joel</w>Is there a function that would give &quot;:and&quot; instead of &quot;:or&quot;? stricter vs. looser. maybe mu/intersect?
<pre>(mu/union [:map [:Event keyword?]] [:map [:Event [:enum :A :B]]])
=&gt; [:map [Event [:or keyword? [:enum :A :B]...</pre></z><z id="t1620360097" t="ikitommi you can configure the the mu/merge with few options, see`:merge-default` in mu/union https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L104-L113"><y>#</y><d>2021-05-07</d><h>04:01</h><r>ikitommi</r>you can configure the the <code>mu/merge</code> with few options,  see`:merge-default` in <code>mu/union</code> <a href="https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L104-L113" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/util.cljc#L104-L113</a></z><z id="t1620360205" t="ikitommi Would that be mu/intercect with :and ? If so, PR welcome."><y>#</y><d>2021-05-07</d><h>04:03</h><r>ikitommi</r>Would that be <code>mu/intercect</code> with <code>:and</code> ? If so, PR welcome.</z><z id="t1620384547" t="ikitommi (my set theory skills are rusted on fridays)"><y>#</y><d>2021-05-07</d><h>10:49</h><r>ikitommi</r>(my set theory skills are rusted on fridays)</z><z id="t1620636729" t="nilern Intersection would go with :and (which is a lattice meet)"><y>#</y><d>2021-05-10</d><h>08:52</h><r>nilern</r>Intersection would go with <code>:and</code> (which is a lattice meet)</z><z id="t1620327040" t="Ivan Fedorov any way to get schema name from RefSchema? e.g. I have [:schema {:registry reg} ::task] and it’s already a RefSchema"><y>#</y><d>2021-05-06</d><h>18:50</h><w>Ivan Fedorov</w>any way to get schema name from RefSchema?
e.g. I have <code>[:schema {:registry reg} ::task]</code> and it’s already a RefSchema</z><z id="t1620328940" t="Ben Sless (m/deref schema) ?"><y>#</y><d>2021-05-06</d><h>19:22</h><r>Ben Sless</r><code>(m/deref schema)</code>?</z><z id="t1620328958" t="Ben Sless (let [schema (schema ?schema options)] (cond-&gt; schema (satisfies? RefSchema schema) (-deref)))"><y>#</y><d>2021-05-06</d><h>19:22</h><r>Ben Sless</r><pre>(let [schema (schema ?schema options)]
     (cond-&gt; schema (satisfies? RefSchema schema) (-deref)))</pre></z><z id="t1620328992" t="Ben Sless Looks like just what you need"><y>#</y><d>2021-05-06</d><h>19:23</h><r>Ben Sless</r>Looks like just what you need</z><z id="t1620330189" t="Ivan Fedorov [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] thanks for the input! This gives something that looks like a keyword but in fact is a :malli.core/schema and I don’t understand how to get the keyword out"><y>#</y><d>2021-05-06</d><h>19:43</h><r>Ivan Fedorov</r><a>@UK0810AQ2</a> thanks for the input! This gives something that looks like a keyword but in fact is a <code>:malli.core/schema</code>  and I don’t understand how to get the keyword out</z><z id="t1620330385" t="Ben Sless ah, hold on, let&apos;s dig some more"><y>#</y><d>2021-05-06</d><h>19:46</h><r>Ben Sless</r>ah, hold on, let&apos;s dig some more</z><z id="t1620330574" t="Ben Sless What&apos;s wrong with just calling m/form ?"><y>#</y><d>2021-05-06</d><h>19:49</h><r>Ben Sless</r>What&apos;s wrong with just calling <code>m/form</code>?</z><z id="t1620330839" t="Ben Sless Okay, this is right: (m/form (m/deref S)) You&apos;ll get back a keyword"><y>#</y><d>2021-05-06</d><h>19:53</h><r>Ben Sless</r>Okay, this is right:
<pre>(m/form (m/deref S))</pre>
You&apos;ll get back a keyword</z><z id="t1620330840" t="Ivan Fedorov what you see in m/children is still a schema! but (-&gt; m/form last) cuts it, thanks!"><y>#</y><d>2021-05-06</d><h>19:54</h><r>Ivan Fedorov</r>what you see in m/children is still a schema!
but (-&gt; m/form last) cuts it, thanks!</z><z id="t1620398998" t="Siddharth Jain is there a way I can set all map schema :closed by default? so that don&apos;t need to specify individually."><y>#</y><d>2021-05-07</d><h>14:49</h><w>Siddharth Jain</w>is there a way I can set all map schema :closed by default? so that don&apos;t need to specify individually.</z><z id="t1620399589" t="dharrigan I don&apos;t think there is, however, you could gather up all your schemas and map over them with malli.utils/closed-schema to recursively close them."><y>#</y><d>2021-05-07</d><h>14:59</h><w>dharrigan</w>I don&apos;t think there is, however, you could gather up all your schemas and map over them with <code>malli.utils/closed-schema</code> to recursively close them.</z><z id="t1620399590" t="dharrigan That may work"><y>#</y><d>2021-05-07</d><h>14:59</h><w>dharrigan</w>That may work</z><z id="t1620399977" t="dvingo You could copy the -map-schema definition and make your own -closed-map-schema https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L616 so you could write: [:closed-map [:xyz string?]] not sure if that&apos;s worth it vs just typing {:closed true} though"><y>#</y><d>2021-05-07</d><h>15:06</h><w>dvingo</w>You could copy the <code>-map-schema</code> definition and make your own <code>-closed-map-schema</code> <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L616" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L616</a>
so you could write:
<code>[:closed-map [:xyz string?]]</code>
not sure if that&apos;s worth it vs just typing <code>{:closed true}</code>  though</z><z id="t1620400631" t="Siddharth Jain thanks guys, sounds good, cheers"><y>#</y><d>2021-05-07</d><h>15:17</h><w>Siddharth Jain</w>thanks guys, sounds good, cheers</z><z id="t1620403857" t="ikitommi [:attrs {:href &quot;/_/_/users/U01RYQZLH7X&quot;}] or better: create a PR that allows m/-map-schema to take :closed and then say: (m/-map-schema {:naked-keys true, :closed true}) .. and you have a closed variant."><y>#</y><d>2021-05-07</d><h>16:10</h><w>ikitommi</w><a>@siddharthjain.in</a> or better: create a PR that allows <code>m/-map-schema</code> to take <code>:closed</code> and then say:
<pre>(m/-map-schema {:naked-keys true, :closed true})
</pre>
.. and you have a closed variant.</z><z id="t1620487519" t="cjsauer Is it possible to get malli to coerce blank strings &quot;&quot; into the :default value? Example: (m/decode [:map [:x {:default 0} int?]] {:x &quot;&quot;} (mt/transformer mt/default-value-transformer mt/string-transformer)) Should result in {:x 0}"><y>#</y><d>2021-05-08</d><h>15:25</h><w>cjsauer</w>Is it possible to get malli to coerce blank strings <code>&quot;&quot;</code> into the <code>:default</code> value? Example:
<pre>(m/decode
  [:map [:x {:default 0} int?]]
  {:x &quot;&quot;}
  (mt/transformer
    mt/default-value-transformer
    mt/string-transformer))</pre>
Should result in <code>{:x 0}</code></z><z id="t1620488080" t="cjsauer Eh, never mind. I’m thinking this isn’t a great idea. I can just strip empty strings from my data before sending it into malli for coercion. I think that’s clearer and less error-prone."><y>#</y><d>2021-05-08</d><h>15:34</h><r>cjsauer</r>Eh, never mind. I’m thinking this isn’t a great idea. I can just strip empty strings from my data before sending it into malli for coercion. I think that’s clearer and less error-prone.</z><z id="t1620496415" t="dvingo I noticed that the the schema: [:schema {:registry {::cons [:maybe [:tuple pos-int? [:ref ::cons]]]}} ::cons] doesn&apos;t work on http://malli.io (it doesn&apos;t produce DOT output or JSON schema) while [:schema {:registry {&quot;ConsCell&quot; [:maybe [:tuple :int [:ref &quot;ConsCell&quot;]]]}} &quot;ConsCell&quot;] this one does work. In my applications I would like to use fully qualified keyword schemas (RefSchemas) is there a way to get the transformers to work without walking the schema ahead of time and converting all fully qualified keywords to strings?"><y>#</y><d>2021-05-08</d><h>17:53</h><w>dvingo</w>I noticed that the the schema:
<pre>[:schema {:registry {::cons [:maybe [:tuple pos-int? [:ref ::cons]]]}}
 ::cons]</pre>
doesn&apos;t work on <a href="http://malli.io" target="_blank">http://malli.io</a> (it doesn&apos;t produce DOT output or JSON schema)
while
<pre>[:schema
 {:registry {&quot;ConsCell&quot; [:maybe [:tuple :int [:ref &quot;ConsCell&quot;]]]}}
 &quot;ConsCell&quot;]</pre>
this one does work.

In my applications I would like to use fully qualified keyword schemas (RefSchemas) is there a way to get the transformers to work without walking the schema ahead of time and converting all fully qualified keywords to strings?</z><z id="t1620497165" t="ikitommi [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] it&apos;s a malli-sci-thing. I think one needs to define what is the current ns to sci so that ::cons works. Try :user/cons and it should work. I think [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] knows the answer how to make the :: work with sci..."><y>#</y><d>2021-05-08</d><h>18:06</h><w>ikitommi</w><a>@danvingo</a> it&apos;s a malli-sci-thing. I think one needs to define what is the current ns to sci so that <code>::cons</code> works. Try <code>:user/cons</code> and it should work. I think <a>@borkdude</a> knows the answer how to make the <code>::</code> work with sci...</z><z id="t1620497660" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ::foo resolves to whatever the current namespace is, by default :user/foo"><y>#</y><d>2021-05-08</d><h>18:14</h><w>borkdude</w><a>@ikitommi</a> <code>::foo</code> resolves to whatever the current namespace is, by default <code>:user/foo</code></z><z id="t1620501404" t="dvingo thanks Tommi - using :user/cons worked. I was also seeing some issues in a local repl regarding refschemas and dot. I&apos;ll try to get minimal repro"><y>#</y><d>2021-05-08</d><h>19:16</h><w>dvingo</w>thanks Tommi - using :user/cons worked. I was also seeing some issues in a local repl regarding refschemas and dot. I&apos;ll try to get minimal repro</z><z id="t1620504960" t="borkdude Welcome to xterm-sci. user=&gt; ::foo :user/foo user=&gt; https://babashka.org/xterm-sci/"><y>#</y><d>2021-05-08</d><h>20:16</h><w>borkdude</w><pre>Welcome to xterm-sci.
user=&gt; ::foo
:user/foo
user=&gt; </pre>
<a href="https://babashka.org/xterm-sci/" target="_blank">https://babashka.org/xterm-sci/</a></z><z id="t1620504966" t="ikitommi hmm... Might be a edamame thing?"><y>#</y><d>2021-05-08</d><h>20:16</h><w>ikitommi</w>hmm... Might be a edamame thing?</z><z id="t1620522711" t="dvingo Ok here&apos;s a small sample that I&apos;m perplexed by: (ns my-app.my-ns (:require [malli.core :as m] [malli.dot :as dot])) (def comment-schema {::id :uuid ::content :string ::replies [:vector [:ref ::comment]] ::updated-at inst? ::created-at inst? ::comment [:map ::id ::content [::replies {:optional true}] ::updated-at ::created-at]}) (def reg {:registry (merge (m/default-schemas) comment-schema)}) (def c {::id #uuid&quot;ff43dad0-8007-47d7-845e-0b20a021bedb&quot; ::content &quot;hello&quot; ::created-at (java.time.Instant/now) ::updated-at (java.time.Instant/now)}) (m/validate (m/schema ::comment reg) c) ; =&gt; true (m/schema ::comment reg) ; =&gt; ::comment I&apos;m confused why this fails: (m/schema [:schema reg ::comment] reg) ; =&gt; ; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17). ; :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1} as well as these calls: (dot/transform (m/schema ::comment reg)) ; =&gt; ; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17). ; :malli.core/invalid-schema {:schema ::comment} ;; trace: malli.dot/transform dot.cljc: 58 malli.dot/transform dot.cljc: 60 malli.dot/-collect dot.cljc: 17 malli.core/walk core.cljc: 1655 malli.core/walk core.cljc: 1657 malli.core/-schema-schema/reify/reify/-walk core.cljc: 1276 malli.core/walk/reify/-outer core.cljc: 1662 malli.dot/-collect/fn dot.cljc: 21 malli.core/-properties-and-options core.cljc: 270 malli.core/-property-registry core.cljc: 265 clojure.core/reduce-kv core.clj: 6856 clojure.core.protocols/fn/G protocols.clj: 175 clojure.core/fn core.clj: 6845 ... malli.core/-property-registry/fn core.cljc: 265 malli.core/schema core.cljc: 1610 malli.core/-schema core.cljc: 251 malli.impl.util/-fail! util.cljc: 16 (dot/transform (m/schema ::comment reg) reg) ; =&gt; ; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17). ; :malli.core/invalid-schema {:schema ::comment} ;; same trace as above "><y>#</y><d>2021-05-09</d><h>01:11</h><w>dvingo</w>Ok here&apos;s a small sample that I&apos;m perplexed by:
<pre>(ns my-app.my-ns
  (:require [malli.core :as m]
            [malli.dot :as dot]))

(def comment-schema
  {::id         :uuid
   ::content    :string
   ::replies    [:vector [:ref ::comment]]
   ::updated-at inst?
   ::created-at inst?
   ::comment    [:map
                  ::id
                  ::content
                  [::replies {:optional true}]
                  ::updated-at
                  ::created-at]})

(def reg {:registry (merge (m/default-schemas) comment-schema)})

(def c
  {::id         #uuid&quot;ff43dad0-8007-47d7-845e-0b20a021bedb&quot;
   ::content    &quot;hello&quot;
   ::created-at (java.time.Instant/now)
   ::updated-at (java.time.Instant/now)})

(m/validate (m/schema ::comment reg) c)
; =&gt; true

(m/schema ::comment reg)
; =&gt; ::comment</pre>
I&apos;m confused why this fails:
<pre>(m/schema [:schema reg ::comment] reg)
; =&gt;
; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17).
; :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1}</pre>
as well as these calls:
<pre>(dot/transform (m/schema ::comment reg))
; =&gt;
; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17).
; :malli.core/invalid-schema {:schema ::comment}

;; trace:
                             malli.dot/transform                dot.cljc:   58
                             malli.dot/transform                dot.cljc:   60
                              malli.dot/-collect                dot.cljc:   17
                                 malli.core/walk               core.cljc: 1655
                                 malli.core/walk               core.cljc: 1657
     malli.core/-schema-schema/reify/reify/-walk               core.cljc: 1276
                    malli.core/walk/reify/-outer               core.cljc: 1662
                           malli.dot/-collect/fn                dot.cljc:   21
              malli.core/-properties-and-options               core.cljc:  270
                   malli.core/-property-registry               core.cljc:  265
                          clojure.core/reduce-kv                core.clj: 6856
                     clojure.core.protocols/fn/G           protocols.clj:  175
                                 clojure.core/fn                core.clj: 6845
                                             ...                              
                malli.core/-property-registry/fn               core.cljc:  265
                               malli.core/schema               core.cljc: 1610
                              malli.core/-schema               core.cljc:  251
                          malli.impl.util/-fail!               util.cljc:   16

(dot/transform (m/schema ::comment reg) reg)
; =&gt;
; Execution error (ExceptionInfo) at malli.impl.util/-fail! (util.cljc:17).
; :malli.core/invalid-schema {:schema ::comment}
;; same trace as above</pre>
</z><z id="t1620526932" t="dvingo This one also fails.. (def cons-schema {::cons [:maybe [:tuple pos-int? [:ref ::cons]]]}) (def cons-list [1 [2 [3 [4 [5 nil]]]]]) (def reg {:registry (merge (m/default-schemas) cons-schema)}) (dot/transform (m/schema ::cons reg) reg) ; =&gt; ; :malli.core/invalid-schema {:schema ::cons}"><y>#</y><d>2021-05-09</d><h>02:22</h><w>dvingo</w>This one also fails..
<pre>(def cons-schema {::cons [:maybe [:tuple pos-int? [:ref ::cons]]]})
(def cons-list [1 [2 [3 [4 [5 nil]]]]])
(def reg {:registry (merge (m/default-schemas) cons-schema)})
(dot/transform (m/schema ::cons reg) reg)
; =&gt; 
; :malli.core/invalid-schema {:schema ::cons}</pre></z><z id="t1620526964" t="dvingo but this works: (m/validate (m/schema ::cons reg) cons-list) =&gt; true"><y>#</y><d>2021-05-09</d><h>02:22</h><w>dvingo</w>but this works:
<code>(m/validate (m/schema ::cons reg) cons-list) =&gt; true</code></z><z id="t1620601181" t="dvingo Following up on this, made some further investigations. this works: (dot/transform [:schema {:registry cons-schema} ::cons]) this fails: (dot/transform [:schema {:registry (merge (m/default-schemas) cons-schema)} ::cons]) ; =&gt; :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1} I&apos;m not sure how adding the defaults would affect things. : Related to this, what is the difference between these two?: (m/schema [:schema {:registry cons-schema} ::cons]) ;; works (m/schema ::cons {:registry cons-schema}) ;; fails -&gt; :malli.core/invalid-schema {:schema :maybe}"><y>#</y><d>2021-05-09</d><h>22:59</h><w>dvingo</w>Following up on this, made some further investigations.
this works:
<pre>(dot/transform [:schema {:registry cons-schema} ::cons])</pre>
this fails:
<pre>(dot/transform [:schema {:registry (merge (m/default-schemas) cons-schema)} ::cons])
; =&gt;
:malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1}</pre>
I&apos;m not sure how adding the defaults would affect things. :

Related to this, what is the difference between these two?:
<pre>(m/schema [:schema {:registry cons-schema} ::cons]) ;; works
(m/schema ::cons {:registry cons-schema}) ;; fails -&gt; :malli.core/invalid-schema {:schema :maybe}</pre></z><z id="t1620768500" t="borkdude [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] Hope you guys are ok... don&apos;t know where you live, but it seems some bad stuff was happening in your country today"><y>#</y><d>2021-05-11</d><h>21:28</h><w>borkdude</w><a>@ben.sless</a> <a>@viebel</a> Hope you guys are ok... don&apos;t know where you live, but it seems some bad stuff was happening in your country today</z><z id="t1620806094" t="Ben Sless Thank you 🙂 Been an interesting night, but we&apos;re all fine. Hopefully it will not escalate further"><y>#</y><d>2021-05-12</d><h>07:54</h><r>Ben Sless</r>Thank you <b>🙂</b>
Been an interesting night, but we&apos;re all fine. Hopefully it will not escalate further</z><z id="t1620792614" t="Yehonathan Sharvit Thank you for asking [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] . The situation is tough. Kids don’t go to school. We are a bit scared. Hopefully, we’ll be fine."><y>#</y><d>2021-05-12</d><h>04:10</h><w>Yehonathan Sharvit</w>Thank you for asking <a>@borkdude</a>. The situation is tough. Kids don’t go to school. We are a bit scared. Hopefully, we’ll be fine.</z><z id="t1620891499" t="Adam Helins Is there something in the current design that could prevent implementing that kind of schema salvaging? This is about altering some properties of an existing schema in a direct way: {:int-vec [:vector :int] :small-int-vec [:int-vec {:max 3}]} I often have that kind of situation where I have a common schema (eg. :int-vec ) but once in a while I have to put more constraints in properties or slightly alter generation (eg. {:max 3} ). Is there another obvious way, besides an external function that recreates the schemas with optional properties?"><y>#</y><d>2021-05-13</d><h>07:38</h><w>Adam Helins</w>Is there something in the current design that could prevent implementing that kind of schema salvaging? This is about altering some properties of an existing schema in a direct way:

<pre>{:int-vec [:vector :int]
 :small-int-vec [:int-vec {:max 3}]}</pre>
I often have that kind of situation where I have a common schema (eg. <code>:int-vec</code>) but once in a while I have to put more constraints in properties or slightly alter generation (eg. <code>{:max 3}</code> ).

Is there another obvious way, besides an external function that recreates the schemas with optional properties?</z><z id="t1620892518" t="Adam Helins (and besides directly using malli.util )"><y>#</y><d>2021-05-13</d><h>07:55</h><w>Adam Helins</w>(and besides directly using <code>malli.util</code>)</z><z id="t1620906658" t="caumond Hi everybody, I am looking for the documentation of :ref, I always have a doubt if it is needed or not. I find :ref in the example of the documentation but no sentence explaining why it necessary or not."><y>#</y><d>2021-05-13</d><h>11:50</h><w>caumond</w>Hi everybody, I am looking for the documentation of :ref, I always have a doubt if it is needed or not. I find :ref in the example of the documentation but no sentence explaining why it necessary or not.</z><z id="t1620907285" t="ikitommi [:attrs {:href &quot;/_/_/users/UCFG3SDFV&quot;}] interesting idea. Should the latter fail if it would have children too? Or swap those too, if present?"><y>#</y><d>2021-05-13</d><h>12:01</h><w>ikitommi</w><a>@adam678</a> interesting idea. Should the latter fail if it would have children too? Or swap those too, if present?</z><z id="t1620907468" t="ikitommi [:attrs {:href &quot;/_/_/users/U018QDQGZ9Q&quot;}] :ref is needed for recursion, no other utility I believe. It&apos;s implementation is lazy, so validators, explainers, generators etc. are realized only when needed."><y>#</y><d>2021-05-13</d><h>12:04</h><w>ikitommi</w><a>@caumond</a> <code>:ref</code> is needed for recursion, no other utility I believe. It&apos;s implementation is lazy, so validators, explainers, generators etc. are realized only when needed.</z><z id="t1620907480" t="ikitommi Doc PR welcome"><y>#</y><d>2021-05-13</d><h>12:04</h><r>ikitommi</r>Doc PR welcome</z><z id="t1620907846" t="caumond 😁 I got it !"><y>#</y><d>2021-05-13</d><h>12:10</h><r>caumond</r><b>😁</b> I got it !</z><z id="t1621111128" t="caumond I posted a PR yesterday"><y>#</y><d>2021-05-15</d><h>20:38</h><r>caumond</r>I posted a PR yesterday</z><z id="t1620907630" t="Adam Helins [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I was thinking of altering properties only since this is both useful and not controversial. Altering properties doesn&apos;t change fundamental aspects of a schema (usually, I guess). If we could alter children, the following would look weird, almost evil: {:int-vec [:vector :int] :double-vec [:int-vec :double]}"><y>#</y><d>2021-05-13</d><h>12:07</h><w>Adam Helins</w><a>@ikitommi</a> I was thinking of altering properties only since this is both useful and not controversial. Altering properties doesn&apos;t change fundamental aspects of a schema (usually, I guess).

If we could alter children, the following would look weird, almost evil:

<pre>{:int-vec [:vector :int]
 :double-vec [:int-vec :double]}</pre></z><z id="t1620986892" t="Adam Helins (I opened an issue since it looks like it&apos;s worth having a discussion: https://github.com/metosin/malli/issues/448 )"><y>#</y><d>2021-05-14</d><h>10:08</h><w>Adam Helins</w>(I opened an issue since it looks like it&apos;s worth having a discussion: <a href="https://github.com/metosin/malli/issues/448" target="_blank">https://github.com/metosin/malli/issues/448</a>)</z><z id="t1620990718" t="Adam Helins Did you consider a :multi variant where the function directly returns a schema as opposed to a mere dispatch value? Like Spec does, actually. Once in a while I have to write something like: [:multi {:dispatch first} [::a ::a] [::b ::b] [::c ::c] ...]"><y>#</y><d>2021-05-14</d><h>11:11</h><w>Adam Helins</w>Did you consider a <code>:multi</code> variant where the function directly returns a schema as opposed to a mere dispatch value? Like Spec does, actually. Once in a while I have to write something like:

<pre>[:multi {:dispatch first} [::a ::a] [::b ::b] [::c ::c] ...]</pre></z><z id="t1621005224" t="snorremd Hi. Is there a built in story for validating and coercing Record types? Using [:map [:fieldA :int] [:fieldB :int]] fails when Malli tries to humanise an error and calls the empty function in Clojure core on the record causing an error. Not sure if using the map schema is the correct way of going about this at all, or if it would be better to create a (malli.core/-simple-schema) or something. Any pointers would be appreciated."><y>#</y><d>2021-05-14</d><h>15:13</h><w>snorremd</w>Hi. Is there a built in story for validating and coercing Record types? Using <code>[:map [:fieldA :int] [:fieldB :int]]</code>  fails when Malli tries to humanise an error and calls the <code>empty</code> function in Clojure core on the record causing an error. Not sure if using the map schema is the correct way of going about this at all, or if it would be better to create a <code>(malli.core/-simple-schema)</code> or something. Any pointers would be appreciated.</z><z id="t1621246603" t="nilern I think :map matches the defrecord philosophy so the error you are getting would be a bug in error humanization. Humanization is not a fundamental operation so making records work should not be a big deal."><y>#</y><d>2021-05-17</d><h>10:16</h><r>nilern</r>I think <code>:map</code> matches the <code>defrecord</code> philosophy so the error you are getting would be a bug in error humanization. Humanization is not a fundamental operation so making records work should not be a big deal.</z><z id="t1621015354" t="Ivan Fedorov I’ve gathered some observations about walking malli schemas to transform them into something (eql vector, clojure spec alpha). Critique and additions welcome https://github.com/dvingo/malli-code-gen/blob/main/src/dev/space/matterandvoid/transform_building_ideas.cljc If anyone experienced with malli has 30 minutes – let’s record a youtube video together on writing malli code transformations. I think, this should be valuable for those who want to write their own transformers and consequently the community."><y>#</y><d>2021-05-14</d><h>18:02</h><w>Ivan Fedorov</w>I’ve gathered some observations about walking malli schemas to transform them into something (eql vector, clojure spec alpha).
Critique and additions welcome
<a href="https://github.com/dvingo/malli-code-gen/blob/main/src/dev/space/matterandvoid/transform_building_ideas.cljc" target="_blank">https://github.com/dvingo/malli-code-gen/blob/main/src/dev/space/matterandvoid/transform_building_ideas.cljc</a>

If anyone experienced with malli has 30 minutes – let’s record a youtube video together on writing malli code transformations. I think, this should be valuable for those who want to write their own transformers and consequently the community.</z><z id="t1621257983" t="eoliphant Hi, i’m not 100% clear on how far down the rabbit hole you can go in terms of defining schemas in terms of other schemas. I’m using a mutable custom registry ‘spec’ishly’ per the docs, and i’m running into some issues, but not sure why. Perhaps some ‘type’ v ‘instance’ thing? For something like the following: (register! :bigdec (m/simple-schema ...)) (register! :money [:map {:someprop ..} [::amount :bigdec] [::currency [:enum :USD :CAN ..]]]) (register! ::annual-income [:money {:propa ..}]) (def x {::amount 1.23M ::currency :USD}) (m/validate :money x) ;=&gt; true (m/validate ::annual-income x) ;Exception =&gt; :malli.core/invalid-schema {:schema [:map {:someprop ..} ...."><y>#</y><d>2021-05-17</d><h>13:26</h><w>eoliphant</w>Hi, i’m not 100% clear on how far down the rabbit hole you can go in terms of defining schemas in terms of other schemas.  I’m using a mutable custom registry ‘spec’ishly’ per the docs, and i’m running into some issues, but not sure why.   Perhaps some ‘type’ v ‘instance’ thing?  For something like the following:
<pre>(register! :bigdec (m/simple-schema ...))
(register! :money [:map {:someprop ..}
                     [::amount :bigdec] 
                     [::currency [:enum :USD :CAN ..]]])
(register!  ::annual-income [:money {:propa ..}])

(def x {::amount 1.23M ::currency :USD})
(m/validate :money x)
;=&gt; true
(m/validate ::annual-income x)
;Exception =&gt; :malli.core/invalid-schema {:schema [:map {:someprop ..} ....</pre></z><z id="t1621270412" t="thomascothran Question about the schema walker functionality. I am trying to change all the :optional properties of a nested schema to false with this: (mi/walk schema ;; malli.core aliased as `mi` (mi/schema-walker #(mu/update-properties % assoc :optional false))) However, this only works if maps have a single key. If the schema is something like this: (def schema [:map [:teams [:vector [:map [:team [:map [:id uuid?] [:name string?] [:logoUrl {:optional true} string?]]] [:health {:optional true} [:map [:injuries {:optional true} [:map [:playerInjuries [:vector [:map [:playerName string?] [:position {:optional true} string?] [:status string?]]]]]]]]]]) Only only the values under the :teams key are updated; the :health key and all the values under it are unaffected. Am I using the schema walker incorrectly, or is this possibly a bug? This is on version 0.5.1 Edit: After looking at this more, I think it&apos;s just that update-properties doesn&apos;t work on keys, so I was using it incorrectly."><y>#</y><d>2021-05-17</d><h>16:53</h><w>thomascothran</w>Question about the schema walker functionality. I am trying to change all the <code>:optional</code> properties of a nested schema to <code>false</code> with this:

<pre>(mi/walk schema         ;; malli.core aliased as `mi`
    (mi/schema-walker
      #(mu/update-properties % assoc :optional false)))</pre>
However, this only works if maps have a single key. If the schema is something like this:

<pre>(def schema
    [:map
         [:teams
            [:vector
             [:map
              [:team
                 [:map
                  [:id uuid?]
                  [:name string?]
                  [:logoUrl {:optional true}
                   string?]]]
              [:health {:optional true}
                 [:map
                  [:injuries {:optional true}
                   [:map
                    [:playerInjuries
                     [:vector
                      [:map
                       [:playerName string?]
                       [:position {:optional true}
                        string?]
                       [:status string?]]]]]]]]]])</pre>
Only only the values under the <code>:teams</code> key are updated; the <code>:health</code> key and all the values under it are unaffected. Am I using the schema walker incorrectly, or is this possibly a bug? This is on version <code>0.5.1</code>

Edit: After looking at this more, I think it&apos;s just that <code>update-properties</code> doesn&apos;t work on keys, so I was using it incorrectly.</z><z id="t1621331911" t="Setzer22 The syntax to define multi-arity fns is this one, right? [:function [:=&gt; [:cat int? int?] int?] [:=&gt; [:cat int?] string?]]"><y>#</y><d>2021-05-18</d><h>09:58</h><w>Setzer22</w>The syntax to define multi-arity fns is this one, right?
<pre>[:function
  [:=&gt; [:cat int? int?] int?]
  [:=&gt; [:cat int?] string?]]</pre></z><z id="t1621333441" t="Setzer22 Ok, so I was asking because I&apos;m implementing multi-arity schema support in my malli-instrument library, but I&apos;m unsure how to best deal with instrumenting multi-arity fns with varargs. Due to the way in which varargs are specified, I don&apos;t have a way to know which of the arities under :function corresponds to each of the possible lengths of the arg list, or at least not without some analysis, consider the following: [:function [:=&gt; [:* int?] int?] [:=&gt; [:* string?] string?]] this is a valid schema for: (defn foo ([x y z] (+ x y z)) ([a b c d &amp; _] (str a b c d))) it can be argued that it&apos;s an innacurate schema for the function, but that&apos;s not my point: Regardless of the example, the fact remains that with seqex patterns being used to define arglists, one can&apos;t easily determine which one of the annotated arities to take given an arglist and its length :thinking_face: The only way to do this with the current specification is to test each of the arity specs against the arglist until some validates. This is what I&apos;m implementing now, but I thought it&apos;d be good to bring out this discussion nontheless, in case you think the specification format could be improved 👍"><y>#</y><d>2021-05-18</d><h>10:24</h><w>Setzer22</w>Ok, so I was asking because I&apos;m implementing multi-arity schema support in my malli-instrument library, but I&apos;m unsure how to best deal with instrumenting multi-arity fns with varargs. Due to the way in which varargs are specified, I don&apos;t have a way to know which of the arities under :function corresponds to each of the possible lengths of the arg list, or at least not without some analysis, consider the following:

<pre>[:function 
  [:=&gt; [:* int?] int?]
  [:=&gt; [:* string?] string?]]</pre>
this is a valid schema for:
<pre>(defn foo
  ([x y z] (+ x y z))
  ([a b c d &amp; _] (str a b c d)))</pre>
it can be argued that it&apos;s an innacurate schema for the function, but that&apos;s not my point: Regardless of the example, the fact remains that with seqex patterns being used to define arglists, one can&apos;t easily determine which one of the annotated arities to take given an arglist and its length <b>:thinking_face:</b>

The only way to do this with the current specification is to test each of the arity specs against the arglist until some validates. This is what I&apos;m implementing now, but I thought it&apos;d be good to bring out this discussion nontheless, in case you think the specification format could be improved <b>👍</b></z><z id="t1621336107" t="ikitommi [:attrs {:href &quot;/_/_/users/U70027S0N&quot;}] please check https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L264-L272"><y>#</y><d>2021-05-18</d><h>11:08</h><w>ikitommi</w><a>@setzer22</a> please check <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L264-L272" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L264-L272</a></z><z id="t1621336187" t="ikitommi and; https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc#L134-L154"><y>#</y><d>2021-05-18</d><h>11:09</h><r>ikitommi</r>and; <a href="https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc#L134-L154" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc#L134-L154</a></z><z id="t1621336342" t="Setzer22 I&apos;m confused, what&apos;s this second one doing? 😅"><y>#</y><d>2021-05-18</d><h>11:12</h><r>Setzer22</r>I&apos;m confused, what&apos;s this second one doing? <b>😅</b></z><z id="t1621336231" t="Setzer22 nice, thanks! 👍 I was re-inventing the wheel for some of this work in a more inefficient way so this helps a lot"><y>#</y><d>2021-05-18</d><h>11:10</h><w>Setzer22</w>nice, thanks! <b>👍</b>  I was re-inventing the wheel for some of this work in a more inefficient way so this helps a lot</z><z id="t1621345789" t="Setzer22 just noticed a small inconsistency when writing the instrumentation code: (m/validate :cat nil) returns false, but when calling (fn [&amp; args]) with zero arguments, args is bound to nil"><y>#</y><d>2021-05-18</d><h>13:49</h><w>Setzer22</w>just noticed a small inconsistency when writing the instrumentation code:

<code>(m/validate :cat nil)</code> returns false, but when calling <code>(fn [&amp; args])</code> with zero arguments, <code>args</code> is bound to nil</z><z id="t1621345882" t="Setzer22 I can easily work around it on my side using something like (or args &apos;()) , but I thought that may be something worth looking into"><y>#</y><d>2021-05-18</d><h>13:51</h><w>Setzer22</w>I can easily work around it on my side using something like <code>(or args &apos;())</code>, but I thought that may be something worth looking into</z><z id="t1621346092" t="Setzer22 alright! malli-instrument now supports multi-arity fn schemas 😄 🎉 https://github.com/setzer22/malli-instrument I&apos;ll continue working on this and pushing bugfixes"><y>#</y><d>2021-05-18</d><h>13:54</h><w>Setzer22</w>alright! malli-instrument now supports multi-arity fn schemas <b>😄</b> <b>🎉</b>
<a href="https://github.com/setzer22/malli-instrument" target="_blank">https://github.com/setzer22/malli-instrument</a>

I&apos;ll continue working on this and pushing bugfixes</z><z id="t1621501553" t="Michaël Salihi Hi! Is Malli a good candidate to use for server side form validation in replacement for lib like https://funcool.github.io/struct/latest/ ? Especially thanks to malli.error / humanize?"><y>#</y><d>2021-05-20</d><h>09:05</h><w>Michaël Salihi</w>Hi!
Is Malli a good candidate to use for server side form validation in replacement for lib like <a href="https://funcool.github.io/struct/latest/" target="_blank">https://funcool.github.io/struct/latest/</a>? Especially thanks to malli.error / humanize?</z><z id="t1621501835" t="Michaël Salihi With some hand made regex validators (email, etc) like https://github.com/funcool/struct/blob/master/src/struct/core.cljc#L195 + locale support, I think so, right?"><y>#</y><d>2021-05-20</d><h>09:10</h><w>Michaël Salihi</w>With some hand made regex validators (email, etc) like <a href="https://github.com/funcool/struct/blob/master/src/struct/core.cljc#L195" target="_blank">https://github.com/funcool/struct/blob/master/src/struct/core.cljc#L195</a>
+ locale support, I think so, right?</z><z id="t1621504228" t="ikitommi [:attrs {:href &quot;/_/_/users/UFBL6R4P3&quot;}] definetely"><y>#</y><d>2021-05-20</d><h>09:50</h><w>ikitommi</w><a>@admin055</a> definetely</z><z id="t1621504468" t="Michaël Salihi Perfect, thanks for the confirmation. I&apos;ll toy with Malli in a project and see how to organize this. 👍"><y>#</y><d>2021-05-20</d><h>09:54</h><w>Michaël Salihi</w>Perfect, thanks for the confirmation.
I&apos;ll toy with Malli in a project and see how to organize this. <b>👍</b></z><z id="t1621504542" t="Michaël Salihi is there an example demo project with form validation somewhere?"><y>#</y><d>2021-05-20</d><h>09:55</h><w>Michaël Salihi</w>is there an example demo project with form validation somewhere?</z><z id="t1621504741" t="Michaël Salihi I like very much the Reitit&apos;s example folder, if my tests are successful after a code review, I may be able to contribute with an example PR with form validation on Malli&apos;s Github."><y>#</y><d>2021-05-20</d><h>09:59</h><w>Michaël Salihi</w>I like very much the Reitit&apos;s example folder, if my tests are successful after a code review, I may be able to contribute with an example PR with form validation on Malli&apos;s Github.</z><z id="t1621504781" t="Michaël Salihi What do you think?"><y>#</y><d>2021-05-20</d><h>09:59</h><w>Michaël Salihi</w>What do you think?</z><z id="t1621504847" t="ikitommi sure, examples welcome! I have a malli-form (reagent) demo draft, but nothing serious."><y>#</y><d>2021-05-20</d><h>10:00</h><w>ikitommi</w>sure, examples welcome! I have a malli-form (reagent) demo draft, but nothing serious.</z><z id="t1621504935" t="Michaël Salihi Perfect, let&apos;s do this!"><y>#</y><d>2021-05-20</d><h>10:02</h><w>Michaël Salihi</w>Perfect, let&apos;s do this!</z><z id="t1621505270" t="dharrigan has form validation"><y>#</y><d>2021-05-20</d><h>10:07</h><w>dharrigan</w><code></code> has form validation</z><z id="t1621505281" t="dharrigan "><y>#</y><d>2021-05-20</d><h>10:08</h><w>dharrigan</w><code></code></z><z id="t1621505299" t="dharrigan used here "><y>#</y><d>2021-05-20</d><h>10:08</h><w>dharrigan</w>used here <code></code></z><z id="t1621505421" t="Michaël Salihi Awesome, thanks [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] !"><y>#</y><d>2021-05-20</d><h>10:10</h><w>Michaël Salihi</w>Awesome, thanks <a>@dharrigan</a>!</z><z id="t1621505431" t="dharrigan you&apos;re most welcome"><y>#</y><d>2021-05-20</d><h>10:10</h><w>dharrigan</w>you&apos;re most welcome</z><z id="t1621527513" t="shan hi, Anyone know if Malli has support that allows you to set a default value if the value doesn&apos;t pass the schema check?"><y>#</y><d>2021-05-20</d><h>16:18</h><w>shan</w>hi,
Anyone know if Malli has support that allows you to set a default value if the value doesn&apos;t pass the schema check?</z><z id="t1621527628" t="dharrigan You mean this? "><y>#</y><d>2021-05-20</d><h>16:20</h><w>dharrigan</w>You mean this? <code></code></z><z id="t1621528380" t="shan looks like that just sets a default if the value is missing: (m/parse [:and {:default 42} int?] &quot;test&quot;);; =&gt; :malli.core/invalid (m/decode [:and {:default 42} int?] &quot;test&quot; mt/default-value-transformer);; =&gt; &quot;test&quot; I&apos;ll probably just use m/explain and do something based on if there are errors"><y>#</y><d>2021-05-20</d><h>16:33</h><r>shan</r>looks like that just sets a default if the value is missing:
<pre>(m/parse
 [:and {:default 42} int?]
 &quot;test&quot;);; =&gt; :malli.core/invalid


(m/decode [:and {:default 42} int?]
          &quot;test&quot;
          mt/default-value-transformer);; =&gt; &quot;test&quot;</pre>
I&apos;ll probably just use <code>m/explain</code> and do something based on if there are errors</z><z id="t1621572566" t="ikitommi might not be simple as any fix could change the conditional branch that should be used (with :or and :multi ). But you should be able to use malli.util functions to access the invalid paths and work from there."><y>#</y><d>2021-05-21</d><h>04:49</h><r>ikitommi</r>might not be simple as any fix could change the conditional branch that should be used (with <code>:or</code> and <code>:multi</code>). But you should be able to use <code>malli.util</code> functions to access the invalid paths and work from there.</z><z id="t1621527679" t="shan possibly. Generally I just want to check a map is valid but keep any good values and log out any errors"><y>#</y><d>2021-05-20</d><h>16:21</h><w>shan</w>possibly. Generally I just want to check a map is valid but keep any good values and log out any errors</z><z id="t1621535710" t="Vladislav hi! Deref of [:merge ...] makes :registry with nested schemas of one of merged schemas invisible (but it still works). is it a bug, or feature, or there is some workaround Im missing? point is - registry disappears from any of serialisations after deref, although it contains all information about recursive fields, and i assume there is no other way of define recursive schemas. of course, i still could use underefed schema, but it much complicated"><y>#</y><d>2021-05-20</d><h>18:35</h><w>Vladislav</w>hi! Deref of <code>[:merge ...]</code> makes <code>:registry</code> with nested schemas of one of merged schemas invisible (but it still works). is it a bug, or feature, or there is some workaround Im missing?

point is - registry disappears from any of serialisations after deref, although it contains all information about recursive fields, and i assume there is no other way of define recursive schemas.

of course, i still could use underefed schema, but it much complicated</z><z id="t1621536905" t="ikitommi Can&apos;t recall where it was discussed, but we should clearly separate the locally registered schemas from normal registered ones and with the malli.util fns, expose the accumulated local registry, to be used in schema form. This makes the schemas visible and thus, serializable."><y>#</y><d>2021-05-20</d><h>18:55</h><r>ikitommi</r>Can&apos;t recall where it was discussed, but we should clearly separate the locally registered schemas from normal registered ones and with the malli.util fns, expose the accumulated local registry, to be used in schema form. This makes the schemas visible and thus, serializable.</z><z id="t1621536926" t="ikitommi small change, clears thing a lot."><y>#</y><d>2021-05-20</d><h>18:55</h><r>ikitommi</r>small change, clears thing a lot.</z><z id="t1621537455" t="Vladislav I tried to find some way of extract and then serialize registry from schema (`m/-registry`, and then malli.registry/schemas ), but sadly unsuccess - it still needs more class serialization (may be to deref every schema from it? - leave it for tomorrow)"><y>#</y><d>2021-05-20</d><h>19:04</h><r>Vladislav</r>I tried to find some way of extract and then serialize registry from schema (`m/-registry`, and then <code>malli.registry/schemas</code>
), but sadly unsuccess - it still needs more class serialization (may be to deref every schema from it? - leave it for tomorrow)</z><z id="t1621693448" t="Adam Helins If by any chance you ever had trouble with recursive data, please consider having a look at https://github.com/metosin/malli/issues/452 It is quite a hard problem and I would appreciate ideas, opinions, and reports if you had that kind of problems"><y>#</y><d>2021-05-22</d><h>14:24</h><w>Adam Helins</w>If by any chance you ever had trouble with recursive data, please consider having a look at <a href="https://github.com/metosin/malli/issues/452" target="_blank">https://github.com/metosin/malli/issues/452</a>

It is quite a hard problem and I would appreciate ideas, opinions, and reports if you had that kind of problems</z><z id="t1621706980" t="Adam Helins (and spec doesn&apos;t solve it either)"><y>#</y><d>2021-05-22</d><h>18:09</h><w>Adam Helins</w>(and spec doesn&apos;t solve it either)</z><z id="t1621762480" t="Ben Sless is there a way of providing a transformer for key names? i.e. I expect a key :foo but after transformation the key will be :bar ?"><y>#</y><d>2021-05-23</d><h>09:34</h><w>Ben Sless</w>is there a way of providing a transformer for key names? i.e. I expect a key <code>:foo</code> but after transformation the key will be <code>:bar</code>?</z><z id="t1621868219" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] check out malli.transform/key-transformer"><y>#</y><d>2021-05-24</d><h>14:56</h><w>ikitommi</w><a>@ben.sless</a> check out <code>malli.transform/key-transformer</code></z><z id="t1622139250" t="Ben Sless I&apos;m looking at JSON Schema now and trying to write it out with malli and recursive schemas (with the intention of writing a transformer from it to malli) I&apos;m using this BNF as reference https://cswr.github.io/JsonSchema/spec/grammar/ I&apos;m wondering what&apos;s the best schema to pick for modelling it A lot of it is defined in terms of key-value pairs I thought I&apos;d try modelling it as a union for convenience I defined (defn -ref-u [&amp; args] (into [:union] (map (fn [k] [:ref k])) args)) Then ;; JSDoc := { ( id, )? ( defs, )? JSch } ;; id := &quot;id&quot;: &quot;uri&quot; ;; defs := &quot;definitions&quot;: { kSch (, kSch)*} ;; kSch := kword: { JSch } Becomes ::JSDoc (-ref-u ::id ::defs ::JSch) ::id [:map [:id {:optional true} [:ref ::uri]]] ::defs [:map [:definitions {:optional true} [:map-of :keyword [:ref ::JSch]]]] But when it comes to n&gt;=1 map schemas which are one-of types, I&apos;m stumped ;; JSch := ( res (, res)*) i.e., the map should have at least one res where it&apos;s defined as ;; res := type | strRes | numRes | arrRes | objRes | multRes | refSch | title | description ::res (-ref-u ::type ::strRes ::numRes ::arrRes ::objRes ::multRes ::refSch ::title ::description) Ideally, I&apos;d want some schema between map-of and map I&apos;m also not 100% clear on the difference between union and merge and if they&apos;re even the right choice. Should I perhaps customize a -collection-schema ?"><y>#</y><d>2021-05-27</d><h>18:14</h><w>Ben Sless</w>I&apos;m looking at JSON Schema now and trying to write it out with malli and recursive schemas (with the intention of writing a transformer from it to malli)
I&apos;m using this BNF as reference
<a href="https://cswr.github.io/JsonSchema/spec/grammar/" target="_blank">https://cswr.github.io/JsonSchema/spec/grammar/</a>
I&apos;m wondering what&apos;s the best schema to pick for modelling it
A lot of it is defined in terms of key-value pairs
I thought I&apos;d try modelling it as a union
for convenience I defined
<pre>(defn -ref-u [&amp; args] (into [:union] (map (fn [k] [:ref k])) args))</pre>
Then
<pre>;; JSDoc := { ( id, )? ( defs, )? JSch }
   ;; id := &quot;id&quot;: &quot;uri&quot;
   ;; defs := &quot;definitions&quot;: { kSch (, kSch)*}
   ;; kSch := kword: { JSch }</pre>
Becomes
<pre>::JSDoc (-ref-u ::id ::defs ::JSch)
   ::id [:map [:id {:optional true} [:ref ::uri]]]
   ::defs [:map [:definitions {:optional true} [:map-of :keyword [:ref ::JSch]]]]</pre>
But when it comes to n&gt;=1 map schemas which are one-of types, I&apos;m stumped
<pre>;; JSch := ( res (, res)*)</pre>
i.e., the map should have at least one <code>res</code> where it&apos;s defined as
<pre>;; res := type | strRes | numRes | arrRes | objRes | multRes | refSch | title | description
   ::res (-ref-u ::type ::strRes ::numRes ::arrRes ::objRes ::multRes ::refSch ::title ::description)</pre>
Ideally, I&apos;d want some schema between <code>map-of</code> and <code>map</code>
I&apos;m also not 100% clear on the difference between union and merge and if they&apos;re even the right choice.
Should I perhaps customize a <code>-collection-schema</code>?</z><z id="t1622300566" t="Ben Sless anyone?"><y>#</y><d>2021-05-29</d><h>15:02</h><r>Ben Sless</r>anyone?</z><z id="t1622142665" t="borkdude Is this a standard? https://jsonlogic.com/"><y>#</y><d>2021-05-27</d><h>19:11</h><w>borkdude</w>Is this a standard? <a href="https://jsonlogic.com/" target="_blank">https://jsonlogic.com/</a></z><z id="t1622177845" t="ikitommi have looked at it, but haven’t heard of anyone using. not super popular."><y>#</y><d>2021-05-28</d><h>04:57</h><r>ikitommi</r>have looked at it, but haven’t heard of anyone using. not super popular.</z><z id="t1622177870" t="ikitommi but, I nice idea. not sure how many ways there are to describe such things."><y>#</y><d>2021-05-28</d><h>04:57</h><r>ikitommi</r>but, I nice idea. not sure how many ways there are to describe such things.</z><z id="t1622300566" t="Ben Sless anyone?"><y>#</y><d>2021-05-29</d><h>15:02</h><w>Ben Sless</w>anyone?</z><z id="t1622188210" t="Pragyan Tripathi Is there a way I can use malli to generate datomic schema?"><y>#</y><d>2021-05-28</d><h>07:50</h><w>Pragyan Tripathi</w>Is there a way I can use malli to generate datomic schema?</z><z id="t1622235186" t="eoliphant not ‘out of the box’ per se but it’s pretty straight forward. depends on the way you define your schemas. We use the dynamic registry sort of like spec, so our attributes are first class which sort naturally maps to datomic, and then just map over the registry for our attrs, :{db/ident &lt;attr&gt; :db/valueType (malli-to-datomic …) …} theres of course specific stuff you’ll probably do for enums :my/enum [:enum :a :b] becomes norms for a :my/enum ref and :my.enum/a , etc. :map’s to refs, etc. We have our own custom options for additional customization when we generate."><y>#</y><d>2021-05-28</d><h>20:53</h><w>eoliphant</w>not ‘out of the box’ per se but it’s pretty straight forward.  depends on the way you define your schemas.  We use the dynamic registry sort of like spec, so our attributes are first class which sort naturally maps to datomic, and then just map over the registry for our attrs, <code>:{db/ident &lt;attr&gt; :db/valueType (malli-to-datomic …) …}</code>

theres of course specific stuff you’ll probably do for enums <code>:my/enum [:enum :a :b]</code> becomes norms for a <code>:my/enum</code> ref and  <code>:my.enum/a</code>, etc.  :map’s to refs, etc.   We have our own custom options for additional customization when we generate.</z><z id="t1622235361" t="eoliphant also, this video talks about this in general in terms of using malli to drive a lot of the rest of your app. https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;t=696s"><y>#</y><d>2021-05-28</d><h>20:56</h><w>eoliphant</w>also, this video talks about this in general in terms of using malli to drive a lot of the rest of your app. <a href="https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;t=696s" target="_blank">https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;t=696s</a></z><z id="t1622235908" t="eoliphant is there a way to muck with option values based on a predicate? in pseudo-malli… [:map [:a :boolean] [:b {:optional #(true? :a)} :boolean]]"><y>#</y><d>2021-05-28</d><h>21:05</h><w>eoliphant</w>is there a way to muck with option values based on a predicate? in pseudo-malli…
<pre>[:map 
  [:a :boolean]
  [:b {:optional #(true? :a)} :boolean]]</pre></z><z id="t1622279979" t="Adam Helins Why is :ref not allowed in seqex? Are they truly incompatible or is it a goal implementing it later?"><y>#</y><d>2021-05-29</d><h>09:19</h><w>Adam Helins</w>Why is <code>:ref</code> not allowed in seqex?
Are they truly incompatible or is it a goal implementing it later?</z><z id="t1622280273" t="ikitommi There was a reason, [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] should know thay"><y>#</y><d>2021-05-29</d><h>09:24</h><r>ikitommi</r>There was a reason, <a>@U4MB6UKDL</a> should know thay</z><z id="t1622640593" t="nilern Allowing :ref would incidentally make context-free parsing possible, like in Spec. But that is much harder to specify and implement cleanly and efficiently e.g. I think left recursion drives Spec to a stack overflow. The implementation could be elegantly extended to do GLL parsing, like Instaparse. But supporting all CFG:s means supporting the ambiguous ones as well, so parse would have to return a seq of plausible parse trees etc. One could argue ambiguous schemas are undesirable anyway, but the best way to ban those is (some extension of) LR parsing and nobody wants to deal with shift-reduce conflicts either and many grammars are unambiguous but not LR (without manual mangling) 😩 I would say from a theoretical perspective there are some satisfactory options but it is not simply a matter of allowing :ref . From a UX standpoint it comes down to most programmers happily wielding regex but quickly getting confused with YACC (and even Instaparse when it comes to ambiguous grammars)."><y>#</y><d>2021-06-02</d><h>13:29</h><r>nilern</r>Allowing <code>:ref</code> would incidentally make context-free parsing possible, like in Spec. But that is much harder to specify and implement cleanly and efficiently e.g. I think left recursion drives Spec to a stack overflow. The implementation could be elegantly extended to do GLL parsing, like Instaparse. But supporting all CFG:s means supporting the ambiguous ones as well, so <code>parse</code> would have to return a seq of plausible parse trees etc. One could argue ambiguous schemas are undesirable anyway, but the best way to ban those is (some extension of) LR parsing and nobody wants to deal with shift-reduce conflicts either and many grammars are unambiguous but not LR (without manual mangling) <b>😩</b>

I would say from a theoretical perspective there are some satisfactory options but it is not simply a matter of allowing <code>:ref</code>. From a UX standpoint it comes down to most programmers happily wielding regex but quickly getting confused with YACC (and even Instaparse when it comes to ambiguous grammars).</z><z id="t1622651640" t="Adam Helins [:attrs {:href &quot;/_/_/users/U4MB6UKDL&quot;}] That&apos;s a very thorough answer, thanks!"><y>#</y><d>2021-06-02</d><h>16:34</h><r>Adam Helins</r><a>@U4MB6UKDL</a> That&apos;s a very thorough answer, thanks!</z><z id="t1622280162" t="ikitommi [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] kinda like dependent schemas? I guess we could have a formal way of doing that, e.g. schema value -&gt; schema mapping. There is already content-dependent schemas and some ways to do that at validation time"><y>#</y><d>2021-05-29</d><h>09:22</h><w>ikitommi</w><a>@eoliphant</a> kinda like dependent schemas? I guess we could have a formal way of doing that, e.g.  <code>schema value -&gt; schema</code> mapping. There is already content-dependent schemas and some ways to do that at validation time</z><z id="t1622280332" t="ikitommi See https://github.com/bsless/malli-keys-relations"><y>#</y><d>2021-05-29</d><h>09:25</h><r>ikitommi</r>See <a href="https://github.com/bsless/malli-keys-relations" target="_blank">https://github.com/bsless/malli-keys-relations</a></z><z id="t1622280383" t="ikitommi for the simple key, :or or :multi would work too"><y>#</y><d>2021-05-29</d><h>09:26</h><r>ikitommi</r>for the simple key, <code>:or</code> or <code>:multi</code> would work too</z><z id="t1622280417" t="ikitommi 1. ... or just :and with a :fn constraint"><y>#</y><d>2021-05-29</d><h>09:26</h><r>ikitommi</r>1. ... or just <code>:and</code> with a <code>:fn</code> constraint</z><z id="t1622280513" t="ikitommi but with dependent schemas you could ask &quot;what is the derived schema for this given value, against this (conditional) schema&quot;. Would be great."><y>#</y><d>2021-05-29</d><h>09:28</h><r>ikitommi</r>but with dependent schemas you could ask &quot;what is the derived schema for this given value, against this (conditional) schema&quot;. Would be great.</z><z id="t1622280513" t="ikitommi but with dependent schemas you could ask &quot;what is the derived schema for this given value, against this (conditional) schema&quot;. Would be great."><y>#</y><d>2021-05-29</d><h>09:28</h><w>ikitommi</w>but with dependent schemas you could ask &quot;what is the derived schema for this given value, against this (conditional) schema&quot;. Would be great.</z><z id="t1622294930" t="eoliphant yeah i’d played around with :or and :multi, I guess :fn is the only route, was just trying to still leverage the ‘declared’ type"><y>#</y><d>2021-05-29</d><h>13:28</h><w>eoliphant</w>yeah i’d played around with :or and :multi,  I guess :fn is the only route, was just trying to still leverage the ‘declared’ type</z><z id="t1622476559" t="respatialized Apologies if I missed this while looking through the docs/source, but is there a way to make map schemas (and perhaps other schemas converted to the map syntax) self-documenting by adding something like: (def my-map [:map [:k1 {:doc &quot;A required key, typically used by the program to do foo.&quot;} :string] [:k2 {:optional true :doc &quot;An optional key, typically used by the program for annotation purposes.&quot;} :string]])"><y>#</y><d>2021-05-31</d><h>15:55</h><w>respatialized</w>Apologies if I missed this while looking through the docs/source, but is there a way to make map schemas (and perhaps other schemas converted to the map syntax) self-documenting by adding something like:
<pre>(def my-map [:map [:k1 {:doc &quot;A required key, typically used by the program to do foo.&quot;} :string] [:k2 {:optional true :doc &quot;An optional key, typically used by the program for annotation purposes.&quot;} :string]])</pre></z><z id="t1622476977" t="respatialized It looks like malli.util/to-map-syntax and malli.util/from-map-syntax work just fine on the example I just gave, but I suppose I&apos;m still wondering if the :doc kw in the props map is intended for a different purpose or potentially reserved in some way."><y>#</y><d>2021-05-31</d><h>16:02</h><w>respatialized</w>It looks like <code>malli.util/to-map-syntax</code> and <code>malli.util/from-map-syntax</code> work just fine on the example I just gave, but I suppose I&apos;m still wondering if the <code>:doc</code> kw in the props map is intended for a different purpose or potentially reserved in some way.</z><z id="t1622479380" t="ikitommi [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] using qualified keys is the safest, plain keys could be used for something special, but not going to add anything special for :doc. So, safe in practice. :description is picked up JSON Schema transformer, so that works too and is reserved for docs."><y>#</y><d>2021-05-31</d><h>16:43</h><w>ikitommi</w><a>@afoltzm</a> using qualified keys is the safest, plain keys could be used for something special, but not going to add anything special for <code>:doc.</code> So, safe in practice. <code>:description</code> is picked up JSON Schema transformer, so that works too and is reserved for docs.</z><z id="t1622527212" t="docouto Any idea when the &apos;schema&apos; branch could be merged into master?"><y>#</y><d>2021-06-01</d><h>06:00</h><w>docouto</w>Any idea when the &apos;schema&apos; branch could be merged into master?</z><z id="t1622527267" t="docouto I mean, are there major things preventing this from happening?"><y>#</y><d>2021-06-01</d><h>06:01</h><w>docouto</w>I mean, are there major things preventing this from happening?</z><z id="t1622559119" t="Ben Sless I hate to use the M word, but I think the answer to https://github.com/metosin/malli/issues/304 is yes. If we can say malli is working with types, aren&apos;t container schemas monads, of sorts? maybe is Maybe, or is Either, etc"><y>#</y><d>2021-06-01</d><h>14:51</h><w>Ben Sless</w>I hate to use the M word, but I think the answer to <a href="https://github.com/metosin/malli/issues/304" target="_blank">https://github.com/metosin/malli/issues/304</a> is yes. If we can say malli is working with types, aren&apos;t container schemas monads, of sorts? maybe is Maybe, or is Either, etc</z><z id="t1622559834" t="Ben Sless map and and would be sort of product types?"><y>#</y><d>2021-06-01</d><h>15:03</h><r>Ben Sless</r><code>map</code> and <code>and</code> would be sort of product types?</z><z id="t1622640929" t="nilern I think Functor is more relevant than Monad here. tuple is a product too, or and some other things are sums. But still it is often not possible to jump to conclusions based on category or type theory."><y>#</y><d>2021-06-02</d><h>13:35</h><r>nilern</r>I think Functor is more relevant than Monad here. <code>tuple</code> is a product too, <code>or</code> and some other things are sums. But still it is often not possible to jump to conclusions based on category or type theory.</z><z id="t1622641058" t="nilern I would rather have something like mu/fmap than select-keys automagically working through maybe etc."><y>#</y><d>2021-06-02</d><h>13:37</h><r>nilern</r>I would rather have something like <code>mu/fmap</code> than <code>select-keys</code> automagically working through <code>maybe</code> etc.</z><z id="t1622641182" t="nilern (mu/fmap #(mu/select-keys % [:x]) [:maybe [:map [:x int?] [:y int?]]]) ;=&gt; [:maybe [:map [:x int?]]] "><y>#</y><d>2021-06-02</d><h>13:39</h><r>nilern</r><pre>(mu/fmap #(mu/select-keys % [:x]) [:maybe [:map [:x int?] [:y int?]]])
;=&gt; [:maybe [:map [:x int?]]] </pre></z><z id="t1622645390" t="Ben Sless I agree with the observation, but I think the answer is the other way around - select-keys should work via fmap instead of knowing the implementation details of the container it&apos;s operating on"><y>#</y><d>2021-06-02</d><h>14:49</h><r>Ben Sless</r>I agree with the observation, but I think the answer is the other way around - <code>select-keys</code> should work via <code>fmap</code> instead of knowing the implementation details of the container it&apos;s operating on</z><z id="t1622645565" t="Ben Sless And the reason I thought of Monads and not just Functors is cases like [:maybe [:maybe T]] which could be join ed, and even hairier situations where you have some combinations of containers"><y>#</y><d>2021-06-02</d><h>14:52</h><r>Ben Sless</r>And the reason I thought of Monads and not just Functors is cases like <code>[:maybe [:maybe T]]</code> which could be <code>join</code>ed, and even hairier situations where you have some combinations of containers</z><z id="t1622645662" t="Ben Sless And if schemas are some representation of types, all the schema manipulations in malli.util could be represented as type manipulations which are implemented by the schemas instead of being bespoke data manipulations"><y>#</y><d>2021-06-02</d><h>14:54</h><r>Ben Sless</r>And if schemas are some representation of types, all the schema manipulations in <code>malli.util</code> could be represented as type manipulations which are implemented by the schemas instead of being bespoke data manipulations</z><z id="t1623050063" t="nilern I especially hate it when you run through several layers automagically, like in Cats I think (fmap inc [(just 3) 2]) ;=&gt; [(just 4) 3] or something and JS Promises are not monads because .then tries to be both bind and (flipped) fmap ..."><y>#</y><d>2021-06-07</d><h>07:14</h><r>nilern</r>I especially hate it when you run through several layers automagically, like in Cats I think <code>(fmap inc [(just 3) 2]) ;=&gt; [(just 4) 3]</code> or something and JS Promises are not monads because <code>.then</code> tries to be both <code>bind</code> and (flipped) <code>fmap</code>...</z><z id="t1623050550" t="Ben Sless &gt; anything automagically I can&apos;t disagree with you there. These things should be explicit. And yet, don&apos;t you think malli could benefit from abstracting schema manipulation and composition to interfaces of types manipulation and composition instead of data manipulation? It lends itself to some weird phenomena, such as mu/get-in in a maybe-schema requires explicit reference to the path, so in [:maybe [:map [:a int?]]] int? is in [0 :a] . Is that the right way to go about it?"><y>#</y><d>2021-06-07</d><h>07:22</h><r>Ben Sless</r>&gt; anything automagically
I can&apos;t disagree with you there. These things should be explicit.
And yet, don&apos;t you think malli could benefit from abstracting schema manipulation and composition to interfaces of types manipulation and composition instead of data manipulation?
It lends itself to some weird phenomena, such as <code>mu/get-in</code> in a maybe-schema requires explicit reference to the path, so in <code>[:maybe [:map [:a int?]]]</code> <code>int?</code> is in <code>[0 :a]</code>. Is that the right way to go about it?</z></g><g id="s15"><z id="t1623057294" t="nilern I haven&apos;t thought much about the schema manipulation stuff. But maybe the non-semantic (`[0 :a]` etc.) approach is not that bad and in fact kind of idiomatic. And I think even dependently typed languages like Idris will just pattern match on the type syntax even though it is much more against their philosophy (at least if the kind of the type is Type ). It is hard to say what feels right when there is so little prior art (that I am aware of)."><y>#</y><d>2021-06-07</d><h>09:14</h><r>nilern</r>I haven&apos;t thought much about the schema manipulation stuff. But maybe the non-semantic (`[0 :a]` etc.) approach is not that bad and in fact kind of idiomatic. And I think even dependently typed languages like Idris will just pattern match on the type syntax even though it is much more against their philosophy (at least if the kind of the type is <code>Type</code>). It is hard to say what feels right when there is so little prior art (that I am aware of).</z><z id="t1623057929" t="Ben Sless There&apos;s stuff over in typed land which also seems like leaky implementation and not a correct design choice T1 = A | B T2 = C | T1 Is not equivalent to T3 = A | B | C because unions are tagged, although it&apos;s still just a union of sets of input fields. They should be equivalent"><y>#</y><d>2021-06-07</d><h>09:25</h><r>Ben Sless</r>There&apos;s stuff over in typed land which also seems like leaky implementation and not a correct design choice
<pre>T1 = A | B
T2 = C | T1</pre>
Is not equivalent to
<pre>T3 = A | B | C</pre>
because unions are tagged, although it&apos;s still just a union of sets of input fields. They should be equivalent</z><z id="t1623064613" t="nilern In a language with untagged unions those will be equivalent (or it is a bug). I don&apos;t really regard ADT:s as union types, especially since in most languages each variant can have multiple and even named fields. And you can also do something similar with structural variant types (e.g. OCaml) although as usual type inference complicates that (unification must work etc.)."><y>#</y><d>2021-06-07</d><h>11:16</h><r>nilern</r>In a language with untagged unions those will be equivalent (or it is a bug). I don&apos;t really regard ADT:s as union types, especially since in most languages each variant can have multiple and even named fields.
And you can also do something similar with structural variant types (e.g. OCaml) although as usual type inference complicates that (unification must work etc.).</z><z id="t1623065182" t="nilern By the way one reason lens types are hard is that not all containers have the contained things as type parameters e.g. data Point = Point {x : Int, y : Int} clearly contains Int :s but cannot be made a Functor or otherwise extract that fact on the type level because it&apos;s just an opaque name like :point"><y>#</y><d>2021-06-07</d><h>11:26</h><r>nilern</r>By the way one reason lens types are hard is that not all containers have the contained things as type parameters e.g. <code>data Point = Point {x : Int, y : Int}</code> clearly contains <code>Int</code>:s but cannot be made a <code>Functor</code> or otherwise extract that fact on the type level because it&apos;s just an opaque name like <code>:point</code></z><z id="t1623069018" t="Ben Sless You mean it can be behind a reference?"><y>#</y><d>2021-06-07</d><h>12:30</h><r>Ben Sless</r>You mean it can be behind a reference?</z><z id="t1623143027" t="nilern In SML it would be like a reference but in Haskell/OCaml/Java it is just an abstract type. Even If there was a way to get to the Int part(s) it is different from functors where it is always the first argument and you also have to decide between x, y or both..."><y>#</y><d>2021-06-08</d><h>09:03</h><r>nilern</r>In SML it would be like a reference but in Haskell/OCaml/Java it is just an abstract type. Even If there was a way to get to the <code>Int</code> part(s) it is different from functors where it is always the first argument and you also have to decide between x, y or both...</z><z id="t1623983749" t="Ben Sless https://clojurians.slack.com/archives/CLDK6MFMK/p1623959758175200"><y>#</y><d>2021-06-18</d><h>02:35</h><r>Ben Sless</r><a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1623959758175200" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1623959758175200</a></z><z id="t1622700811" t="ikitommi [:attrs {:href &quot;/_/_/users/URCS5LZ6F&quot;}] need to clean it up first, hopefully before summer vacations"><y>#</y><d>2021-06-03</d><h>06:13</h><w>ikitommi</w><a>@pedroabelleira</a> need to clean it up first, hopefully before summer vacations</z><z id="t1622700840" t="ikitommi a proposed fix to look up errors from parent schemas, finally: https://github.com/metosin/malli/pull/462"><y>#</y><d>2021-06-03</d><h>06:14</h><w>ikitommi</w>a proposed fix to look up errors from parent schemas, finally: <a href="https://github.com/metosin/malli/pull/462" target="_blank">https://github.com/metosin/malli/pull/462</a></z><z id="t1622700884" t="ikitommi fixes #86: (-&gt; [:map [:foo {:error/message &quot;entry-failure&quot;} :int]] (m/explain {:foo &quot;1&quot;}) (me/humanize {:resolve me/resolve-root-error-message-and-path})) ; =&gt; {:foo [&quot;entry-failure&quot;]}"><y>#</y><d>2021-06-03</d><h>06:14</h><w>ikitommi</w>fixes #86:
<pre>(-&gt; [:map
     [:foo {:error/message &quot;entry-failure&quot;} :int]]
    (m/explain {:foo &quot;1&quot;})
    (me/humanize {:resolve me/resolve-root-error-message-and-path}))
; =&gt; {:foo [&quot;entry-failure&quot;]}</pre></z><z id="t1622700956" t="ikitommi the new hook in humanize allows custom collector, here, it just traverses the parents to look for error definitons, which will override the more exact definitions."><y>#</y><d>2021-06-03</d><h>06:15</h><w>ikitommi</w>the new hook in humanize allows custom collector, here, it just traverses the parents to look for error definitons, which will override the more exact definitions.</z><z id="t1622701073" t="ikitommi we could have a m/humanizer that would prepare the humanization and would be much faster, e.g. (def Schema [:map [:foo {:error/message &quot;foo!&quot;} :int] [:bar {:error/message &quot;bar!&quot;} :int]]) (def humanize (me/humanizer Schema) (-&gt; Schema (m/explain {:foo &quot;1&quot;, :bar &quot;1&quot;}) humanize) ; =&gt; {:foo [&quot;foo!&quot;], :bar [&quot;bar!]}"><y>#</y><d>2021-06-03</d><h>06:17</h><w>ikitommi</w>we could have a <code>m/humanizer</code> that would prepare the humanization and would be much faster, e.g.
<pre>(def Schema
  [:map
   [:foo {:error/message &quot;foo!&quot;} :int]
   [:bar {:error/message &quot;bar!&quot;} :int]])

(def humanize (me/humanizer Schema)

(-&gt; Schema 
    (m/explain {:foo &quot;1&quot;, :bar &quot;1&quot;}) 
    humanize)
; =&gt; {:foo [&quot;foo!&quot;], :bar [&quot;bar!]}</pre></z><z id="t1622705503" t="Grigory Shepelev Hello there. Need a little help. How do I malli/get-in with spec with registry? Suppose having the following structure (def registry {&quot;users&quot; [:map [:telegram [:map [:id int? :is_bot boolean?]]]] &quot;messages&quot; [:map [:from {:optional true} [:ref &quot;users&quot;]] [:id int?] [:text {:optional true} string?] [:reply {:optional true} [:ref &quot;messages&quot;]]]}) And I&apos;ve tried a lot of different combinations like: (let [s (malli/schema [:schema {:registry registry} &quot;messages&quot;]) _ (print (malli/schema? s))] (u/get-in s [:id])) true;; =&gt; nil No success."><y>#</y><d>2021-06-03</d><h>07:31</h><w>Grigory Shepelev</w>Hello there. Need a little help. How do I malli/get-in with spec with registry? Suppose having the following structure
<pre>(def registry
  {&quot;users&quot;
   [:map
    [:telegram
     [:map
      [:id int?
       :is_bot boolean?]]]]
   &quot;messages&quot;
   [:map
    [:from {:optional true} [:ref &quot;users&quot;]]
    [:id int?]
    [:text {:optional true} string?]
    [:reply {:optional true} [:ref &quot;messages&quot;]]]})</pre>
And I&apos;ve tried a lot of different combinations like:
<pre>(let [s (malli/schema [:schema {:registry registry} &quot;messages&quot;])
                        _ (print (malli/schema? s))] 
                    (u/get-in s [:id]))
true;; =&gt; nil</pre>
No success.</z><z id="t1622708843" t="Ben Sless You have three mistakes: • syntax error in registry definition (look at the telegram map) • the registry you pass to the schema constructor is incomplete, you need to merge it with the default registry • The path you get-in is wrong, schema-schemas are considered part of the path and their children are at key 0."><y>#</y><d>2021-06-03</d><h>08:27</h><r>Ben Sless</r>You have three mistakes:
• syntax error in registry definition (look at the telegram map)
• the registry you pass to the schema constructor is incomplete, you need to merge it with the default registry
• The path you <code>get-in</code> is wrong, schema-schemas are considered part of the path and their children are at key 0.</z><z id="t1622723936" t="ikitommi should malli default to allowing the default registry o be swapped? e.g. strict mode where it can’t (for those who want to be fully in control)."><y>#</y><d>2021-06-03</d><h>12:38</h><w>ikitommi</w>should malli default to allowing the default registry o be swapped? e.g. <code>strict</code> mode where it can’t (for those who want to be fully in control).</z><z id="t1622730551" t="Ben Sless I think it would be better to merge the provided registry with the default registry be default. I always forget that"><y>#</y><d>2021-06-03</d><h>14:29</h><r>Ben Sless</r>I think it would be better to merge the provided registry with the default registry be default. I always forget that</z><z id="t1622737950" t="ikitommi one option should be not to have defauts schemas, only way to get proper DCE for tiny lib size, e.g. busy frontends."><y>#</y><d>2021-06-03</d><h>16:32</h><r>ikitommi</r>one option should be not to have defauts schemas, only way to get proper DCE for tiny lib size, e.g. busy frontends.</z><z id="t1622737980" t="ikitommi currently the smallest usefull malli-bundle is 2.3kb (gzipped js)"><y>#</y><d>2021-06-03</d><h>16:33</h><r>ikitommi</r>currently the smallest usefull malli-bundle is 2.3kb (gzipped js)</z><z id="t1622738019" t="ikitommi with default registry, it’t 37kb."><y>#</y><d>2021-06-03</d><h>16:33</h><r>ikitommi</r>with default registry, it’t 37kb.</z><z id="t1622742659" t="Ben Sless How is that measured? I never worked with cljs. Does the compiler eliminate dead code?"><y>#</y><d>2021-06-03</d><h>17:50</h><r>Ben Sless</r>How is that measured? I never worked with cljs. Does the compiler eliminate dead code?</z><z id="t1622987806" t="ikitommi there is a guide how to do that (with shadow-cljs) in malli readme. In short: • unsed functions and protocol methods (and definitions) will be DCEd • multimethods and deffed values are not"><y>#</y><d>2021-06-06</d><h>13:56</h><r>ikitommi</r>there is a guide how to do that (with shadow-cljs) in malli readme. In short:
• unsed functions and protocol methods (and definitions) will be DCEd
• multimethods and deffed values are not</z><z id="t1622987844" t="ikitommi this is the reason all malli registry parts are behind a function -&gt; no-one calling it =&gt; get’s eliminated under advanced."><y>#</y><d>2021-06-06</d><h>13:57</h><r>ikitommi</r>this is the reason all malli registry parts are behind a function -&gt; no-one calling it =&gt; get’s eliminated under advanced.</z><z id="t1622989851" t="Ben Sless huh, cool"><y>#</y><d>2021-06-06</d><h>14:30</h><r>Ben Sless</r>huh, cool</z><z id="t1622724004" t="ikitommi seems that all the malli-codebases I have worked with, have introduced a custom mutable registry…"><y>#</y><d>2021-06-03</d><h>12:40</h><w>ikitommi</w>seems that all the malli-codebases I have worked with, have introduced a custom mutable registry…</z><z id="t1622724031" t="ikitommi you can always do evil: (reset! @#&apos;mr/registry* (mr/mutable-registry registry*))"><y>#</y><d>2021-06-03</d><h>12:40</h><w>ikitommi</w>you can always do evil:
<pre>(reset! @#&apos;mr/registry* (mr/mutable-registry registry*))</pre></z><z id="t1622726408" t="ingesol Hi! I want to create a schema for a sequence like this [{:type :type1 :attrs {:type1-prop 1}} {:type :type2 :attrs {:type2-prop 2}}] :attrs schema will be different for different object types. There’s :multi , but the dispatch property :type is on the parent of the object inside :attrs . Is the problem description clear, and does anyone have a good/best practice for solving this with malli?"><y>#</y><d>2021-06-03</d><h>13:20</h><w>ingesol</w>Hi! I want to create a schema for a sequence like this
<pre>[{:type  :type1
  :attrs {:type1-prop 1}}
 {:type  :type2
  :attrs {:type2-prop 2}}]</pre>
<code>:attrs</code> schema will be different for different object types. There’s <code>:multi</code>, but the dispatch property <code>:type</code> is on the parent of the object inside <code>:attrs</code>.

Is the problem description clear, and does anyone have a good/best practice for solving this with malli?</z><z id="t1622735805" t="ikitommi [:attrs {:href &quot;/_/_/users/U21QNFC5C&quot;}] maybe: (require &apos;[malli.generator :as mg]) (mg/sample [:multi {:dispatch :type} [:type1 [:map [:type [:= :type1]] [:attrs [:map [:type1-prop :int]]]]] [:type2 [:map [:type [:= :type2]] [:attrs [:map [:type2-prop :int]]]]]]) ;({:type :type1, :attrs {:type1-prop -1}} ; {:type :type2, :attrs {:type2-prop -1}} ; {:type :type1, :attrs {:type1-prop -1}} ; {:type :type1, :attrs {:type1-prop -1}} ; {:type :type1, :attrs {:type1-prop -2}} ; {:type :type1, :attrs {:type1-prop 0}} ; {:type :type2, :attrs {:type2-prop 12}} ; {:type :type2, :attrs {:type2-prop 4}} ; {:type :type2, :attrs {:type2-prop -26}} ; {:type :type1, :attrs {:type1-prop -14}})"><y>#</y><d>2021-06-03</d><h>15:56</h><w>ikitommi</w><a>@ingesol</a> maybe:
<pre>(require &apos;[malli.generator :as mg])

(mg/sample
  [:multi {:dispatch :type}
   [:type1 [:map
            [:type [:= :type1]]
            [:attrs [:map
                     [:type1-prop :int]]]]]
   [:type2 [:map
            [:type [:= :type2]]
            [:attrs [:map
                     [:type2-prop :int]]]]]])
;({:type :type1, :attrs {:type1-prop -1}}
; {:type :type2, :attrs {:type2-prop -1}}
; {:type :type1, :attrs {:type1-prop -1}}
; {:type :type1, :attrs {:type1-prop -1}}
; {:type :type1, :attrs {:type1-prop -2}}
; {:type :type1, :attrs {:type1-prop 0}}
; {:type :type2, :attrs {:type2-prop 12}}
; {:type :type2, :attrs {:type2-prop 4}}
; {:type :type2, :attrs {:type2-prop -26}}
; {:type :type1, :attrs {:type1-prop -14}})</pre></z><z id="t1622740420" t="ingesol [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks! Yes, I thought about something like that too. My maps are bigger than in this minimal example, but easy enough to create the schemas with a factory function i guess."><y>#</y><d>2021-06-03</d><h>17:13</h><w>ingesol</w><a>@ikitommi</a> Thanks! Yes, I thought about something like that too. My maps are bigger than in this minimal example, but easy enough to create the schemas with a factory function i guess.</z><z id="t1622748994" t="ChillPillzKillzBillz Newbie here... I am trying to run the base code example from the lambdaisland/regal example page https://github.com/lambdaisland/regal . My Deps.edn looks like {:deps {org.clojure/clojure {:mvn/version &quot;1.10.3&quot;}         `org.clojure/core.async {:mvn/version &quot;1.3.618&quot;}`         `org.clojure/test.check {:mvn/version &quot;1.1.0&quot;}`         `lambdaisland/regal {:mvn/version &quot;0.0.97&quot;}`         `metosin/reitit-malli {:mvn/version &quot;0.4.2&quot;}}` and my clojure code is as follows (ns baseClj.core   `(:require [malli.core :as m]`             `[malli.error :as me]`             `[malli.generator :as mg]`             `[lambdaisland.regal.malli :as regal-malli]`             `;; [lambdaisland.regal :as regal]`             `;; [lambdaisland.regal.generator :as regal-gen]`             `))` and first few lines (def malli-opts {:registry {:regal regal-malli/regal-schema}}) (def form [:+ &quot;y&quot;]) (def schema (m/schema [:regal form] malli-opts)) (m/form schema) my namespace definition gives me Error: &quot;No namespace: lambdaisland.regal.malli&quot;... but works when I remove the :as m . Then it fails on the lambdaisland.regal.malli, and again works when :as regal-malli is removed... Finally if fails at (def malli-opts {:registry {:regal lambdaisland.regal.malli/regal-schema}}) with the error ; Syntax error (ClassNotFoundException) compiling at (h:\Work\Clojure\baseClj\src\baseClj\core.clj:55:1). ; lambdaisland.regal.malli . None of this makes any sense... this is just the example code. What am I missing?"><y>#</y><d>2021-06-03</d><h>19:36</h><w>ChillPillzKillzBillz</w>Newbie here... I am trying to run the base code example from the lambdaisland/regal example page <a href="https://github.com/lambdaisland/regal" target="_blank">https://github.com/lambdaisland/regal</a>. My Deps.edn looks like <code>{:deps {org.clojure/clojure {:mvn/version &quot;1.10.3&quot;}</code>
        `org.clojure/core.async {:mvn/version &quot;1.3.618&quot;}`
        `org.clojure/test.check {:mvn/version &quot;1.1.0&quot;}`
        `lambdaisland/regal {:mvn/version &quot;0.0.97&quot;}`
        `metosin/reitit-malli {:mvn/version &quot;0.4.2&quot;}}`  and my clojure code is as follows (ns baseClj.core
  `(:require [malli.core :as m]`
            `[malli.error :as me]`
            `[malli.generator :as mg]`
            `[lambdaisland.regal.malli :as regal-malli]`
            `;; [lambdaisland.regal :as regal]`
            `;; [lambdaisland.regal.generator :as regal-gen]`
            `))` and first few lines  <code>(def malli-opts {:registry {:regal regal-malli/regal-schema}})</code>

<code>(def form [:+ &quot;y&quot;])</code>

<code>(def schema (m/schema [:regal form] malli-opts))</code>

<code>(m/form schema)</code>  my namespace definition gives me Error: &quot;No namespace: lambdaisland.regal.malli&quot;... but works when I remove the <code>:as m</code> . Then it fails on the lambdaisland.regal.malli, and again works when <code>:as regal-malli</code> is removed... Finally if fails at <code>(def malli-opts {:registry {:regal lambdaisland.regal.malli/regal-schema}})</code>  with the error <code>; Syntax error (ClassNotFoundException) compiling at (h:\Work\Clojure\baseClj\src\baseClj\core.clj:55:1).</code>
<code>; lambdaisland.regal.malli</code> . None of this makes any sense... this is just the example code. What am I missing?</z><z id="t1622750517" t="ChillPillzKillzBillz I got a hint... The deps.edn include for malli was incorrect. I should have added metosin/malli {:mvn/version &quot;0.5.1&quot;} . This doesn&apos;t solve the problem tho..."><y>#</y><d>2021-06-03</d><h>20:01</h><r>ChillPillzKillzBillz</r>I got a hint... The deps.edn include for malli was incorrect. I should have added <code>metosin/malli {:mvn/version &quot;0.5.1&quot;}</code> . This doesn&apos;t solve the problem tho...</z><z id="t1622761528" t="ribelo https://github.com/metosin/malli/pull/305 is it dead or waiting for better times?"><y>#</y><d>2021-06-03</d><h>23:05</h><w>ribelo</w><a href="https://github.com/metosin/malli/pull/305" target="_blank">https://github.com/metosin/malli/pull/305</a>
is it dead or waiting for better times?</z><z id="t1622820456" t="ingesol I’ve been trying to get this to work, but cannot figure out what is going on. I’m expecting the :type value to be converted to a string: (m/encode [:schema {:registry {::node [:multi {:dispatch :type :decode/string #(update % :type keyword)} [:malli.core/default [:map [:type :keyword]]]]}} ::node] {:type :doc} mt/string-transformer) =&gt; {:type :doc} If I replace :malli.core/default with :doc , I get the expected string-coerced keyword {:type &quot;doc&quot;} Also, the schema has a local registry in order to be able to have nodes within nodes. If I remove the wrapping, the following also works: (m/encode [:map [:type :keyword]] {:type :doc} mt/string-transformer) =&gt; {:type &quot;doc&quot;}"><y>#</y><d>2021-06-04</d><h>15:27</h><w>ingesol</w>I’ve been trying to get this to work, but cannot figure out what is going on. I’m expecting the <code>:type</code> value to be converted to a string:

<pre>(m/encode
 [:schema {:registry
           {::node [:multi {:dispatch      :type
                            :decode/string #(update % :type keyword)}
                    [:malli.core/default
                     [:map
                      [:type :keyword]]]]}}
  ::node]
 {:type  :doc}
 mt/string-transformer)

=&gt; {:type :doc}</pre>
If I replace <code>:malli.core/default</code> with <code>:doc</code>, I get the expected string-coerced keyword
<pre>{:type &quot;doc&quot;}</pre>
Also, the schema has a local registry in order to be able to have nodes within nodes. If I remove the wrapping, the following also works:

<pre>(m/encode
 [:map
  [:type :keyword]]
 {:type  :doc}
 mt/string-transformer)

=&gt; {:type &quot;doc&quot;}</pre></z><z id="t1622827401" t="datran What&apos;s the difference between parsing data and decoding data? My sense is that parse is similar to spec&apos;s conform , whereas decode is more about transformation - is that generally right?"><y>#</y><d>2021-06-04</d><h>17:23</h><w>datran</w>What&apos;s the difference between parsing data and decoding data? My sense is that <code>parse</code> is similar to spec&apos;s <code>conform</code>, whereas <code>decode</code> is more about transformation - is that generally right?</z><z id="t1622828366" t="ikitommi decoding is a process of transforming values from external formats into valid clojure data. Parsing returns the parse trees."><y>#</y><d>2021-06-04</d><h>17:39</h><w>ikitommi</w>decoding is a process of transforming values from external formats into valid clojure data. Parsing returns the parse trees.</z><z id="t1622828651" t="ikitommi [:attrs {:href &quot;/_/_/users/U21QNFC5C&quot;}] what version are you using. CHANGELOG says it&apos;s fixed in 0.5.0"><y>#</y><d>2021-06-04</d><h>17:44</h><w>ikitommi</w><a>@ingesol</a> what version are you using. CHANGELOG says it&apos;s fixed in 0.5.0</z><z id="t1622828675" t="ikitommi https://github.com/metosin/malli/issues/415"><y>#</y><d>2021-06-04</d><h>17:44</h><r>ikitommi</r><a href="https://github.com/metosin/malli/issues/415" target="_blank">https://github.com/metosin/malli/issues/415</a></z><z id="t1622834245" t="ingesol [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] hmm, I thought I was on 0.5.2 or something, will check"><y>#</y><d>2021-06-04</d><h>19:17</h><r>ingesol</r><a>@U055NJ5CC</a> hmm, I thought I was on 0.5.2 or something, will check</z><z id="t1622834638" t="ingesol Very happy to be wrong, I was on 0.4.0. Thanks  🙂"><y>#</y><d>2021-06-04</d><h>19:23</h><r>ingesol</r>Very happy to be wrong, I was on 0.4.0. Thanks <b>🙂</b></z><z id="t1622834956" t="ingesol Aaaand it works! Thanks for great help, as always"><y>#</y><d>2021-06-04</d><h>19:29</h><r>ingesol</r>Aaaand it works! Thanks for great help, as always</z><z id="t1623478059" t="robert-stuttaford is there a trick to debugging this m/explain exception? Vector&apos;s key for assoc must be a number. at https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L139"><y>#</y><d>2021-06-12</d><h>06:07</h><w>robert-stuttaford</w>is there a trick to debugging this <code>m/explain</code> exception?  <code>Vector&apos;s key for assoc must be a number.</code>  at <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L139" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L139</a></z><z id="t1623482443" t="ikitommi humaize should not throw, ever. There is an open issue/PR, seems stalled: https://github.com/metosin/malli/pull/333#discussion_r588855299"><y>#</y><d>2021-06-12</d><h>07:20</h><r>ikitommi</r>humaize should not throw, ever. There is an open issue/PR, seems stalled: <a href="https://github.com/metosin/malli/pull/333#discussion_r588855299" target="_blank">https://github.com/metosin/malli/pull/333#discussion_r588855299</a></z><z id="t1623565365" t="robert-stuttaford i&apos;ll put together a repro and submit an issue. my problem seems different to the one that you have linked"><y>#</y><d>2021-06-13</d><h>06:22</h><r>robert-stuttaford</r>i&apos;ll put together a repro and submit an issue. my problem seems different to the one that you have linked</z><z id="t1623595596" t="robert-stuttaford turns out i was overwriting instead of adding to the default error message set facepalm"><y>#</y><d>2021-06-13</d><h>14:46</h><r>robert-stuttaford</r>turns out i was overwriting instead of adding to the default error message set <b>facepalm</b></z><z id="t1623510523" t="respatialized I feel like I may have asked this question before, but am having trouble finding the right keywords to search in the slack archive, so apologies for the redundant question: Does malli provide a meta-schema or helper function I can use to programatically validate forms that may or may not be valid malli schemas? Is there a self-describing malli schema for malli schemas? Something like: (m/validate malli-meta-schema [:a]) =&gt; false (m/validate malli-meta-schema [:or [:fn int?] [:fn string?]]) =&gt; true"><y>#</y><d>2021-06-12</d><h>15:08</h><w>respatialized</w>I feel like I may have asked this question before, but am having trouble finding the right keywords to search in the slack archive, so apologies for the redundant question: Does <code>malli</code> provide a meta-schema or helper function I can use to programatically validate forms that may or may not be valid <code>malli</code> schemas? Is there a self-describing malli schema for malli schemas?

Something like:
<code>(m/validate malli-meta-schema [:a])</code>  <code>=&gt; false</code>
<code>(m/validate malli-meta-schema [:or [:fn int?] [:fn string?]])</code> <code>=&gt; true</code></z><z id="t1623512573" t="ikitommi [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] not yet. But since 0.5.0, each IntoSchema can describe it&apos;s properties and children schemas. Once all built-in schemas have described themselves (currently empty impls), one can ask from a registry the accumulated schema for schema AST."><y>#</y><d>2021-06-12</d><h>15:42</h><w>ikitommi</w><a>@afoltzm</a> not yet. But since 0.5.0, each <code>IntoSchema</code> can describe it&apos;s properties and children schemas. Once all built-in schemas have described themselves (currently empty impls), one can ask from a registry the accumulated schema for schema AST.</z><z id="t1623512834" t="ikitommi see m/children-schema and m/properties-schema"><y>#</y><d>2021-06-12</d><h>15:47</h><w>ikitommi</w>see <code>m/children-schema</code> and <code>m/properties-schema</code></z><z id="t1623513989" t="respatialized [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] gotcha, thanks! right now I&apos;m just doing a basic helper predicate that relies on the catching the exception thrown by calling m/schema on the form, which I think suffices for my current use case."><y>#</y><d>2021-06-12</d><h>16:06</h><w>respatialized</w><a>@ikitommi</a> gotcha, thanks! right now I&apos;m just doing a basic helper predicate that relies on the catching the exception thrown by calling <code>m/schema</code> on the form, which I think suffices for my current use case.</z><z id="t1623521682" t="borkdude Enjoyed this podcast: https://twitter.com/JacekSchae/status/1402648727215542272"><y>#</y><d>2021-06-12</d><h>18:14</h><w>borkdude</w>Enjoyed this podcast: <a href="https://twitter.com/JacekSchae/status/1402648727215542272" target="_blank">https://twitter.com/JacekSchae/status/1402648727215542272</a></z><z id="t1623596966" t="robert-stuttaford is there a way to do this :enum {:error/fn entity.validation/malli-humanize-enum-error} for all enums in the spec, perhaps when calling m/humanize ? otherwise i could walk the spec and inject them"><y>#</y><d>2021-06-13</d><h>15:09</h><w>robert-stuttaford</w>is there a way to do this <code>:enum {:error/fn entity.validation/malli-humanize-enum-error}</code> for all enums in the spec, perhaps when calling <code>m/humanize</code> ?

otherwise i could walk the spec and inject them</z><z id="t1623604338" t="ikitommi [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] humanize takes an :errors option, where you can override :enum handling. Walking is another way to do it. There might be others too"><y>#</y><d>2021-06-13</d><h>17:12</h><w>ikitommi</w><a>@robert-stuttaford</a> <code>humanize</code> takes an <code>:errors</code> option, where you can override <code>:enum</code> handling. Walking is another way to do it. There might be others too</z><z id="t1623608748" t="robert-stuttaford thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] - can you point me to example of the :errors option specifically overriding the printing of errors for a specific spec type like :enum that i can work from, please?"><y>#</y><d>2021-06-13</d><h>18:25</h><w>robert-stuttaford</w>thanks <a>@ikitommi</a> - can you point me to example of the <code>:errors</code> option specifically overriding the printing of errors for a specific spec type like <code>:enum</code> that i can work from, please?</z><z id="t1623611299" t="ikitommi sure [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] , https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L177-L188"><y>#</y><d>2021-06-13</d><h>19:08</h><r>ikitommi</r>sure <a>@robert-stuttaford</a>, <a href="https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L177-L188" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L177-L188</a></z><z id="t1623615056" t="robert-stuttaford ah so: (assoc-in me/default-errors [:enum :error/fn :en] my-fn-here)"><y>#</y><d>2021-06-13</d><h>20:10</h><r>robert-stuttaford</r>ah so:
<pre>(assoc-in me/default-errors [:enum :error/fn :en] my-fn-here)</pre></z><z id="t1623615059" t="robert-stuttaford thanks!"><y>#</y><d>2021-06-13</d><h>20:10</h><r>robert-stuttaford</r>thanks!</z><z id="t1623669485" t="ikitommi I would say (assoc me/default-errors :enum {:error/fn {:en my-fn-here}}) just to make sure that the whole :enum map is overridden, can’t recall which one is picked first, :error/fn or :error/message if both are present"><y>#</y><d>2021-06-14</d><h>11:18</h><r>ikitommi</r>I would say <code>(assoc me/default-errors :enum {:error/fn {:en my-fn-here}})</code> just to make sure that the whole <code>:enum</code> map is overridden, can’t recall which one is picked first,  <code>:error/fn</code> or <code>:error/message</code> if both are present</z><z id="t1623707036" t="martinklepsch Hey 🙂 Is there a way to combine multiple schemas to one? Specifically I have a bunch of “base” keys and a few keys that I want to check based on the :type key in the set of “base” keys. I kind of see how I could do that with multi and a bit of repetition but I probably want :merge ? Is there a way to get :merge without getting into registries and all that?"><y>#</y><d>2021-06-14</d><h>21:43</h><w>martinklepsch</w>Hey <b>🙂</b> Is there a way to combine multiple schemas to one? Specifically I have a bunch of “base” keys and a few keys that I want to check based on the <code>:type</code> key in the set of “base” keys. I kind of see how I could do that with multi and a bit of repetition but I probably want <code>:merge</code>? Is there a way to get <code>:merge</code> without getting into registries and all that?</z><z id="t1623707447" t="martinklepsch Duh, I just realized I can just into more key to existing [:map] schemas"><y>#</y><d>2021-06-14</d><h>21:50</h><r>martinklepsch</r>Duh, I just realized I can just <code>into</code> more key to existing <code>[:map]</code>  schemas</z><z id="t1623732345" t="ikitommi yeah. :multi is not currntly mergable, oftenly asked. would allow concise definitions like: [:merge [:map [:id :uuid]] [:multi {:dispatch :type} [:pear [:size :int]] [:boat [:price :int]]]]"><y>#</y><d>2021-06-15</d><h>04:45</h><r>ikitommi</r>yeah. <code>:multi</code> is not currntly mergable, oftenly asked. would allow concise definitions like:
<pre>[:merge
 [:map [:id :uuid]]
 [:multi {:dispatch :type}
  [:pear [:size :int]]
  [:boat [:price :int]]]]</pre></z><z id="t1623855782" t="martinklepsch Is there a “recommended way” to achieve this currently?"><y>#</y><d>2021-06-16</d><h>15:03</h><r>martinklepsch</r>Is there a “recommended way” to achieve this currently?</z><z id="t1623855813" t="martinklepsch It seems like a common need so if there is one I think documenting that could be useful. Happy to open a PR once I know 😄"><y>#</y><d>2021-06-16</d><h>15:03</h><r>martinklepsch</r>It seems like a common need so if there is one I think documenting that could be useful. Happy to open a PR once I know <b>😄</b></z><z id="t1623740842" t="wcalderipe Hey folks 👋 Why explain keeps passing values forward when previous operations in an and condition have already failed? (m/explain [:map [:name [:and string? [:not {:error/message &quot;non empty string&quot;} empty?]]]] {:name 1}) The example above throws Don&apos;t know how to create ISeq from: java.lang.Long . It does at (empty? 1) . The conditions are concatenated with an and operator, so I wasn&apos;t expecting [:not {:error/message &quot;non empty string&quot;} empty?] to run because string? failed in the first place. Note: there are probably better ways to express a non-empty string with Malli 😅"><y>#</y><d>2021-06-15</d><h>07:07</h><w>wcalderipe</w>Hey folks <b>👋</b>

Why <code>explain</code> keeps passing values forward when previous operations in an <code>and</code> condition have already failed?

<pre>(m/explain
   [:map
    [:name
     [:and string?
      [:not {:error/message &quot;non empty string&quot;} empty?]]]]
   {:name 1})</pre>
The example above throws <code>Don&apos;t know how to create ISeq from: java.lang.Long</code>. It does at <code>(empty? 1)</code>. The conditions are concatenated with an <code>and</code> operator, so I wasn&apos;t expecting <code>[:not {:error/message &quot;non empty string&quot;} empty?]</code>  to run because <code>string?</code> failed in the first place.

Note: there are probably better ways to express a non-empty string with Malli <b>😅</b></z><z id="t1623743364" t="Martín Varela [:string {:min 1}] is probably what you&apos;re after..."><y>#</y><d>2021-06-15</d><h>07:49</h><r>Martín Varela</r><code>[:string {:min 1}]</code> is probably what you&apos;re after...</z><z id="t1623745743" t="ikitommi yes, I think it’s better to have keyword types (e.g. :string ) with properties than to use the existing core functions, of which, many throw on invalid input."><y>#</y><d>2021-06-15</d><h>08:29</h><r>ikitommi</r>yes, I think it’s better to have keyword types (e.g. <code>:string</code>) with properties than to use the existing core functions, of which, many throw on invalid input.</z><z id="t1623745787" t="ikitommi e.g. post-int? vs [:int {:min 1}]"><y>#</y><d>2021-06-15</d><h>08:29</h><r>ikitommi</r>e.g. <code>post-int?</code> vs <code>[:int {:min 1}]</code></z><z id="t1623757575" t="wcalderipe [:attrs {:href &quot;/_/_/users/U95NTJT4H&quot;}] thanks for the suggestion – I knew there was a better way to solve that problem."><y>#</y><d>2021-06-15</d><h>11:46</h><r>wcalderipe</r><a>@U95NTJT4H</a> thanks for the suggestion – I knew there was a better way to solve that problem.</z><z id="t1623757632" t="Martín Varela Glad that helped 🙂"><y>#</y><d>2021-06-15</d><h>11:47</h><r>Martín Varela</r>Glad that helped <b>🙂</b></z><z id="t1623757636" t="wcalderipe [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] got it. For custom keyword types, we would have to provide a registry, right?"><y>#</y><d>2021-06-15</d><h>11:47</h><r>wcalderipe</r><a>@U055NJ5CC</a> got it. For custom keyword types, we would have to provide a registry, right?</z><z id="t1623757894" t="wcalderipe So, I assume Malli will check the value against every keyword type of a field, even when using an AND operator and the first check fails, in order to get a complete errors map in the first run :thinking_face:"><y>#</y><d>2021-06-15</d><h>11:51</h><r>wcalderipe</r>So, I assume Malli will check the value against every keyword type of a field, even when using an AND operator and the first check fails, in order to get a complete errors map in the first run <b>:thinking_face:</b></z><z id="t1623767518" t="ikitommi yes, for the last one. See https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D ."><y>#</y><d>2021-06-15</d><h>14:31</h><r>ikitommi</r>yes, for the last one. See <a href="https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D</a>.</z><z id="t1623776689" t="wcalderipe Got it.. thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2021-06-15</d><h>17:04</h><r>wcalderipe</r>Got it.. thanks <a>@U055NJ5CC</a></z><z id="t1623784850" t="Vladislav Hi! I try to use malli as coercion&amp;schemas with swagger ui. If i try serialise recursive schemas with registries, i get some &quot;Could not resolve reference&quot; of keys of recursive values. it is according to plan and swagger bad, or its just undone feature?) looks like there is some missing defs in swagger.json"><y>#</y><d>2021-06-15</d><h>19:20</h><w>Vladislav</w>Hi! I try to use malli as coercion&amp;schemas with swagger ui. If i try serialise recursive schemas with registries, i get some &quot;Could not resolve reference&quot; of keys of recursive values. it is according to plan and swagger bad, or its just undone feature?) looks like there is some missing defs in swagger.json</z><z id="t1623786183" t="ikitommi [:attrs {:href &quot;/_/_/users/UNJE65T24&quot;}] It might be that the references should copied to top-level swagger. If you can provide a minimal repro, would help solving"><y>#</y><d>2021-06-15</d><h>19:43</h><r>ikitommi</r><a>@UNJE65T24</a> It might be that the references should copied to top-level swagger. If you can provide a minimal repro, would help solving</z><z id="t1623786205" t="ikitommi also, what version of swagger-ui are you using?"><y>#</y><d>2021-06-15</d><h>19:43</h><r>ikitommi</r>also, what version of swagger-ui are you using?</z><z id="t1623790043" t="Vladislav [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] i use swagger-ui bundled with [metosin/reitit-swagger-ui &quot;0.5.13&quot;] [metosin/ring-swagger-ui &quot;3.36.0&quot;] guess it 3.XX"><y>#</y><d>2021-06-15</d><h>20:47</h><r>Vladislav</r><a>@U055NJ5CC</a> i use swagger-ui bundled with
<pre>[metosin/reitit-swagger-ui &quot;0.5.13&quot;]
[metosin/ring-swagger-ui &quot;3.36.0&quot;]</pre>
guess it 3.XX</z><z id="t1623790163" t="Vladislav i&apos;v got example of that malli"><y>#</y><d>2021-06-15</d><h>20:49</h><r>Vladislav</r>i&apos;v got example of that malli</z><z id="t1623790449" t="Vladislav if i malli.json-schema/transform this (it is used in swagger gen, right?) i get something like"><y>#</y><d>2021-06-15</d><h>20:54</h><r>Vladislav</r>if i <code>malli.json-schema/transform</code>  this (it is used in swagger gen, right?) i get something like</z><z id="t1623790484" t="Vladislav and it has no valuable #/definitions/Expression as you can see"><y>#</y><d>2021-06-15</d><h>20:54</h><r>Vladislav</r>and it has no valuable
<pre>#/definitions/Expression</pre>
as you can see</z><z id="t1623826847" t="Vladislav should i submit an issue to github?)"><y>#</y><d>2021-06-16</d><h>07:00</h><r>Vladislav</r>should i submit an issue to github?)</z><z id="t1623827105" t="ikitommi please do"><y>#</y><d>2021-06-16</d><h>07:05</h><r>ikitommi</r>please do</z><z id="t1623827503" t="Vladislav voila https://github.com/metosin/malli/issues/464"><y>#</y><d>2021-06-16</d><h>07:11</h><r>Vladislav</r>voila <a href="https://github.com/metosin/malli/issues/464" target="_blank">https://github.com/metosin/malli/issues/464</a></z><z id="t1623830636" t="Yehonathan Sharvit What&apos;s the rationale behind the fact that a set is considered as :sequential ? For instance (validate [:sequential string?] #{&quot;aa&quot;}) ;; false"><y>#</y><d>2021-06-16</d><h>08:03</h><w>Yehonathan Sharvit</w>What&apos;s the rationale behind the fact that a set is considered as <code>:sequential</code> ?
For instance
<pre>(validate [:sequential string?] #{&quot;aa&quot;}) ;; false</pre></z><z id="t1623831578" t="ikitommi it’s following the clojure way: {:sequential (m/-collection-schema {:type :sequential, :pred sequential?})} (sequential? #{}) ; =&gt; false"><y>#</y><d>2021-06-16</d><h>08:19</h><w>ikitommi</w>it’s following the clojure way:
<pre>{:sequential (m/-collection-schema {:type :sequential, :pred sequential?})}

(sequential? #{}) ; =&gt; false</pre></z><z id="t1623831639" t="ikitommi you should be able create custom collections types easily that access both sequentials and sets."><y>#</y><d>2021-06-16</d><h>08:20</h><w>ikitommi</w>you should be able create custom collections types easily that access both sequentials and sets.</z><z id="t1623833403" t="Yehonathan Sharvit [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Could you share a pointer to the documentation about custom collection types?"><y>#</y><d>2021-06-16</d><h>08:50</h><w>Yehonathan Sharvit</w><a>@ikitommi</a> Could you share a pointer to the documentation about custom collection types?</z><z id="t1623834960" t="ikitommi sure: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L813 . Documentation PRs most welcome 🙂"><y>#</y><d>2021-06-16</d><h>09:16</h><r>ikitommi</r>sure: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L813" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L813</a>. Documentation PRs most welcome <b>🙂</b></z><z id="t1623834980" t="ikitommi in use: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1925-L1927"><y>#</y><d>2021-06-16</d><h>09:16</h><r>ikitommi</r>in use: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1925-L1927" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1925-L1927</a></z><z id="t1623837993" t="Yehonathan Sharvit How it would look like to create a custom :sequential-or-set predicate? And where would i put its definition?"><y>#</y><d>2021-06-16</d><h>10:06</h><r>Yehonathan Sharvit</r>How it would look like to create a custom <code>:sequential-or-set</code> predicate?
And where would i put its definition?</z><z id="t1623858307" t="ikitommi 1. def a Var and use it instead of the type (keword), like with Reagent 2. add it to a registry, see README for alternatives"><y>#</y><d>2021-06-16</d><h>15:45</h><r>ikitommi</r>1. def a Var and use it instead of the type (keword), like with Reagent
2. add it to a registry, see README for alternatives</z><z id="t1623858412" t="ikitommi (def SequentialOrSet (m/-col...)) (m/validate [SequentialOrSet :int] [1])"><y>#</y><d>2021-06-16</d><h>15:46</h><r>ikitommi</r><pre>(def SequentialOrSet (m/-col...))

(m/validate [SequentialOrSet :int] [1])</pre></z><z id="t1623909880" t="Yehonathan Sharvit Ok. Thanls"><y>#</y><d>2021-06-17</d><h>06:04</h><r>Yehonathan Sharvit</r>Ok. Thanls</z><z id="t1623842600" t="borkdude [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] sequential means: it has a defined order. sets are not ordered, similar to maps, although you can create sequences out of them"><y>#</y><d>2021-06-16</d><h>11:23</h><w>borkdude</w><a>@viebel</a> sequential means: it has a defined order. sets are not ordered, similar to maps, although you can create sequences out of them</z><z id="t1623852485" t="Yehonathan Sharvit Yeah. It makes sense. But still surprising."><y>#</y><d>2021-06-16</d><h>14:08</h><w>Yehonathan Sharvit</w>Yeah. It makes sense. But still surprising.</z><z id="t1623852521" t="Yehonathan Sharvit I think we need a name and a predicate for a bunch of things that could be either in a set or in a sequence"><y>#</y><d>2021-06-16</d><h>14:08</h><w>Yehonathan Sharvit</w>I think we need a name and a predicate for a bunch of things that could be either in a set or in a sequence</z><z id="t1623852570" t="Yehonathan Sharvit My use case is a function that receives a bunch of ids and return the entities whose id is contained in the bunch"><y>#</y><d>2021-06-16</d><h>14:09</h><w>Yehonathan Sharvit</w>My use case is a function that receives a bunch of ids and return the entities whose id is contained in the bunch</z><z id="t1623865983" t="ikitommi you could always say [:or [:sequential :int] [:set :int]] ."><y>#</y><d>2021-06-16</d><h>17:53</h><w>ikitommi</w>you could always say <code>[:or [:sequential :int] [:set :int]]</code>.</z><z id="t1623866024" t="ikitommi or, one could always transform the values always to sets/vectors."><y>#</y><d>2021-06-16</d><h>17:53</h><w>ikitommi</w>or, one could always transform the values always to sets/vectors.</z><z id="t1623866742" t="eskos coll? works as well, if you don&apos;t mind using predicates directly"><y>#</y><d>2021-06-16</d><h>18:05</h><w>eskos</w><code>coll?</code> works as well, if you don&apos;t mind using predicates directly</z><z id="t1623868210" t="ikitommi (coll? {}) ;=&gt; true"><y>#</y><d>2021-06-16</d><h>18:30</h><w>ikitommi</w><code>(coll? {}) ;=&gt; true</code></z><z id="t1623868431" t="ikitommi coercion is always an option: (m/decode [:set :int] [1 2 3] (mt/collection-transformer)) ; =&gt; #{1 2 3}"><y>#</y><d>2021-06-16</d><h>18:33</h><w>ikitommi</w>coercion is always an option:
<pre>(m/decode
 [:set :int]
 [1 2 3]
 (mt/collection-transformer))
; =&gt; #{1 2 3}</pre></z><z id="t1623877844" t="deadghost Any recommendations on how to approach extracting out a registry from a schema? For example: [:map [::id int] [:name string?] [::country {:optional true} string?]] to {::id int? ::country string?} and as a nice to have, the schema simplified to use the new registry: [:map ::id [:name string?] [::country {:optional true}]] Use cases: • Simplify large schemas • Finding differences in semantics • Refactoring multiple schemas to use a shared registry"><y>#</y><d>2021-06-16</d><h>21:10</h><w>deadghost</w>Any recommendations on how to approach extracting out a registry from a schema? For example:
<pre>[:map
  [::id int]
  [:name string?]
  [::country {:optional true} string?]]

to

{::id int?
 ::country string?}

and as a nice to have, the schema simplified to use the new registry:

[:map
  ::id
  [:name string?]
  [::country {:optional true}]]</pre>
Use cases:
• Simplify large schemas
• Finding differences in semantics
• Refactoring multiple schemas to use a shared registry</z><z id="t1623895677" t="escherize Hello, I want to build a general data-building ui, that takes a description of the datastructure as input (a malli schema, this time around). I couldn’t find much prior work in this regard. I have a half-baked prototype here: https://escherize.com/w/data-desk/ So far, that mostly works for int? string? boolean? :vector and :map and combinations of them. So do you know of anything similar?"><y>#</y><d>2021-06-17</d><h>02:07</h><w>escherize</w>Hello, I want to build a general data-building ui, that takes a description of the datastructure as input (a malli schema, this time around). I couldn’t find much prior work in this regard. I have a half-baked prototype here: <a href="https://escherize.com/w/data-desk/" target="_blank">https://escherize.com/w/data-desk/</a>

So far, that mostly works for <code>int?</code> <code>string?</code> <code>boolean?</code> <code>:vector</code> and <code>:map</code> and combinations of them.

So do you know of anything similar?</z><z id="t1623897838" t="escherize As for the implementation, I’m using a local atom and this multimethod: https://github.com/escherize/data-desk/blob/main/src/data_desk/views.cljs#L37"><y>#</y><d>2021-06-17</d><h>02:43</h><w>escherize</w>As for the implementation, I’m using a local atom and this multimethod: <a href="https://github.com/escherize/data-desk/blob/main/src/data_desk/views.cljs#L37" target="_blank">https://github.com/escherize/data-desk/blob/main/src/data_desk/views.cljs#L37</a></z><z id="t1623909927" t="Yehonathan Sharvit I&apos;d like to validate inside a function that the function is called with valid arguments. Should I use :=&gt; ? How exactly?"><y>#</y><d>2021-06-17</d><h>06:05</h><w>Yehonathan Sharvit</w>I&apos;d like to validate inside a function that the function is called with valid arguments.
Should I use <code>:=&gt;</code> ? How exactly?</z><z id="t1623910860" t="ikitommi README should cover that"><y>#</y><d>2021-06-17</d><h>06:21</h><r>ikitommi</r>README should cover that</z><z id="t1623910861" t="ikitommi https://github.com/metosin/malli#function-schemas"><y>#</y><d>2021-06-17</d><h>06:21</h><r>ikitommi</r><a href="https://github.com/metosin/malli#function-schemas" target="_blank">https://github.com/metosin/malli#function-schemas</a></z><z id="t1623921126" t="Yehonathan Sharvit The readme doens&apos;t cover it"><y>#</y><d>2021-06-17</d><h>09:12</h><r>Yehonathan Sharvit</r>The readme doens&apos;t cover it</z><z id="t1623934134" t="Yehonathan Sharvit Here is what I am doing"><y>#</y><d>2021-06-17</d><h>12:48</h><r>Yehonathan Sharvit</r>Here is what I am doing</z><z id="t1623934278" t="Yehonathan Sharvit (def =&gt;plus [:=&gt; [:cat int? int?] int?]) (defn plus [x y] (when-not (m/validate (second =&gt;plus) [x y]) (throw (ex-info &quot;invalid input&quot; {}))) (+ x y))"><y>#</y><d>2021-06-17</d><h>12:51</h><r>Yehonathan Sharvit</r><pre>(def =&gt;plus [:=&gt; [:cat int? int?] int?])

(defn plus [x y]
  (when-not
      (m/validate (second =&gt;plus) [x y])
    (throw (ex-info &quot;invalid input&quot; {})))
  (+ x y))</pre></z><z id="t1623934288" t="Yehonathan Sharvit Is there a more idiomatic way?"><y>#</y><d>2021-06-17</d><h>12:51</h><r>Yehonathan Sharvit</r>Is there a more idiomatic way?</z><z id="t1623945509" t="ikitommi there will be malli.instrument , while waiting, there is malli-indtrument - https://github.com/setzer22/malli-instrument"><y>#</y><d>2021-06-17</d><h>15:58</h><r>ikitommi</r>there will be <code>malli.instrument</code>, while waiting, there is <code>malli-indtrument</code> - <a href="https://github.com/setzer22/malli-instrument" target="_blank">https://github.com/setzer22/malli-instrument</a></z><z id="t1624173155" t="Yehonathan Sharvit Very cool! Any reason why it&apos;s not yet part of malli?"><y>#</y><d>2021-06-20</d><h>07:12</h><r>Yehonathan Sharvit</r>Very cool!
Any reason why it&apos;s not yet part of malli?</z><z id="t1624173364" t="ikitommi just time to merge &amp; cleanup, the original issue is here: https://github.com/metosin/malli/issues/349"><y>#</y><d>2021-06-20</d><h>07:16</h><r>ikitommi</r>just time to merge &amp; cleanup, the original issue is here: <a href="https://github.com/metosin/malli/issues/349" target="_blank">https://github.com/metosin/malli/issues/349</a></z><z id="t1624173534" t="ikitommi the function checker code shuould be reused between malli.generate and malli.instrument."><y>#</y><d>2021-06-20</d><h>07:18</h><r>ikitommi</r>the function checker code shuould be reused between malli.generate and malli.instrument.</z><z id="t1624261381" t="Yehonathan Sharvit Is someone already working on this consolidation?"><y>#</y><d>2021-06-21</d><h>07:43</h><r>Yehonathan Sharvit</r>Is someone already working on this consolidation?</z><z id="t1624263044" t="ikitommi please ask on the issue. on my summer backlog if no-one has time. need this too after the vacations."><y>#</y><d>2021-06-21</d><h>08:10</h><r>ikitommi</r>please ask on the issue. on my summer backlog if no-one has time. need this too after the vacations.</z><z id="t1624352829" t="Yehonathan Sharvit ok. will do"><y>#</y><d>2021-06-22</d><h>09:07</h><r>Yehonathan Sharvit</r>ok. will do</z><z id="t1623959758" t="deadghost Is there something I can do to make the results of mu/union more condensed? (mu/union (mu/union nil? empty?) empty?) =&gt; [:or [:or nil? empty?] empty?]"><y>#</y><d>2021-06-17</d><h>19:55</h><w>deadghost</w>Is there something I can do to make the results of <code>mu/union</code> more condensed?
<pre>(mu/union (mu/union nil? empty?) empty?)
=&gt; [:or [:or nil? empty?] empty?]</pre></z><z id="t1623992000" t="ikitommi [:attrs {:href &quot;/_/_/users/U051GFP2V&quot;}] looks good! haven’t seen anything library-quality impls of malli-forms. Have done one, but not complete and coupled to the use case."><y>#</y><d>2021-06-18</d><h>04:53</h><w>ikitommi</w><a>@escherize</a> looks good! haven’t seen anything library-quality impls of malli-forms. Have done one, but not complete and coupled to the use case.</z><z id="t1623992148" t="ikitommi [:attrs {:href &quot;/_/_/users/U4QFG68K1&quot;}] there should be an optional optimizer in malli. [:attrs {:href &quot;/_/_/users/U1NDXLDUG&quot;}] did a prototype of such some time ago: https://github.com/miikka/boolean-simplifier"><y>#</y><d>2021-06-18</d><h>04:55</h><w>ikitommi</w><a>@deadghost</a> there should be an optional optimizer in malli. <a>@miikka</a> did a prototype of such some time ago: <a href="https://github.com/miikka/boolean-simplifier" target="_blank">https://github.com/miikka/boolean-simplifier</a></z><z id="t1623992264" t="ikitommi [:or [:int {:min 10}] [:int {:max 5}] [:int {:min 0, :max 20}]] could be just :int ."><y>#</y><d>2021-06-18</d><h>04:57</h><w>ikitommi</w><code>[:or [:int {:min 10}] [:int {:max 5}] [:int {:min 0, :max 20}]]</code> could be just <code>:int</code>.</z><z id="t1624171780" t="ikitommi https://github.com/metosin/malli/blob/master/docs/tips.md#collecting-inlined-reference-definitions-from-schemas , ping [:attrs {:href &quot;/_/_/users/U4QFG68K1&quot;}]"><y>#</y><d>2021-06-20</d><h>06:49</h><w>ikitommi</w><a href="https://github.com/metosin/malli/blob/master/docs/tips.md#collecting-inlined-reference-definitions-from-schemas" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#collecting-inlined-reference-definitions-from-schemas</a>, ping <a>@deadghost</a></z><z id="t1624297964" t="ikitommi malli.plantuml , the 23 loc monster 🙂"><y>#</y><d>2021-06-21</d><h>17:52</h><w>ikitommi</w><code>malli.plantuml</code> , the 23 loc monster <b>🙂</b></z><z id="t1624297982" t="ikitommi https://github.com/metosin/malli/pull/468"><y>#</y><d>2021-06-21</d><h>17:53</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/468" target="_blank">https://github.com/metosin/malli/pull/468</a></z><z id="t1624298444" t="emccue &gt; #(apply println %&amp;)"><y>#</y><d>2021-06-21</d><h>18:00</h><r>emccue</r>&gt; #(apply println %&amp;)</z><z id="t1624298447" t="emccue what is that syntax"><y>#</y><d>2021-06-21</d><h>18:00</h><r>emccue</r>what is that syntax</z><z id="t1624298476" t="emccue %&amp;"><y>#</y><d>2021-06-21</d><h>18:01</h><r>emccue</r>%&amp;</z><z id="t1624298503" t="dvingo https://clojure.org/guides/weird_characters#_n_anonymous_function_arguments"><y>#</y><d>2021-06-21</d><h>18:01</h><r>dvingo</r><a href="https://clojure.org/guides/weird_characters#_n_anonymous_function_arguments" target="_blank">https://clojure.org/guides/weird_characters#_n_anonymous_function_arguments</a></z><z id="t1624379798" t="ikitommi #(apply println %&amp;) = println awesome"><y>#</y><d>2021-06-22</d><h>16:36</h><r>ikitommi</r><code>#(apply println %&amp;)</code> = <code>println</code> <b>awesome</b></z><z id="t1624303743" t="alpox Out of interest: Is there something in malli like a metaschema that can be used to validate a malli schema?"><y>#</y><d>2021-06-21</d><h>19:29</h><w>alpox</w>Out of interest: Is there something in malli like a metaschema that can be used to validate a malli schema?</z><z id="t1624304833" t="Ben Sless Metacircular malli?"><y>#</y><d>2021-06-21</d><h>19:47</h><r>Ben Sless</r>Metacircular malli?</z><z id="t1624305762" t="alpox Metacircular? 😄 You got me confused"><y>#</y><d>2021-06-21</d><h>20:02</h><r>alpox</r>Metacircular? <b>😄</b> You got me confused</z><z id="t1624306711" t="alpox I just read up on Metacircular. I guess I am talking about something in that direction 😉 Basically a Malli schema that can be used to validate if my data at hand is a valid malli schema. If it was just a special keyword to refer to the metaschema while the metaschema is not directly written as a malli schema itself that would probably also be usable enough."><y>#</y><d>2021-06-21</d><h>20:18</h><r>alpox</r>I just read up on Metacircular. I guess I am talking about something in that direction <b>😉</b>
Basically a Malli schema that can be used to validate if my data at hand is a valid malli schema. If it was just a special keyword to refer to the metaschema while the metaschema is not directly written as a malli schema itself that would probably also be usable enough.</z><z id="t1624309100" t="ikitommi ping [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}]"><y>#</y><d>2021-06-21</d><h>20:58</h><w>ikitommi</w>ping <a>@alpox</a></z><z id="t1624309401" t="alpox [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Oh, I really should have seen that in the history.. Thanks, that sounds promising!"><y>#</y><d>2021-06-21</d><h>21:03</h><w>alpox</w><a>@ikitommi</a> Oh, I really should have seen that in the history.. Thanks, that sounds promising!</z><z id="t1624352923" t="Yehonathan Sharvit What&apos;s the recommended location for function schema definition? Should it be on the same namespace as the function or in a separate namespace?"><y>#</y><d>2021-06-22</d><h>09:08</h><w>Yehonathan Sharvit</w>What&apos;s the recommended location for function schema definition?
Should it be on the same namespace as the function or in a separate namespace?</z><z id="t1624372068" t="ikitommi No strong opinions in malli for that. My favourites: 1. Inlined (the plumatic syntax) 2. just before the functions (`m/=&gt;` is as long as defn , looks good"><y>#</y><d>2021-06-22</d><h>14:27</h><w>ikitommi</w>No strong opinions in malli for that. My favourites:
1. Inlined (the plumatic syntax)
2. just before the functions (`m/=&gt;` is as long as <code>defn</code> , looks good</z><z id="t1624372075" t="ikitommi what do you think?"><y>#</y><d>2021-06-22</d><h>14:27</h><w>ikitommi</w>what do you think?</z><z id="t1624373138" t="Yehonathan Sharvit Someone reviewed my code that added m/=&gt; for each and every function in the core namespace of a lib (around 10 functions) and he thought it was polluting the namespace"><y>#</y><d>2021-06-22</d><h>14:45</h><w>Yehonathan Sharvit</w>Someone reviewed my code that added <code>m/=&gt;</code> for each and every function in the core namespace of a lib (around 10 functions) and he thought it was polluting the namespace</z><z id="t1624373214" t="Yehonathan Sharvit I tend to prefer to have the schemas near the code as schemas serve also as documentation"><y>#</y><d>2021-06-22</d><h>14:46</h><w>Yehonathan Sharvit</w>I tend to prefer to have the schemas near the code as schemas serve also as documentation</z><z id="t1624374794" t="eskos I prefer the Plumatic style as it&apos;s more about upfront (meta) data expression, m/=&gt; feels unnecessarily clever and sort of indirect/IoC hellish since it comes after the function declaration. But that&apos;s just my two cents 🙂"><y>#</y><d>2021-06-22</d><h>15:13</h><w>eskos</w>I prefer the Plumatic style as it&apos;s more about upfront (meta) data expression, <code>m/=&gt;</code> feels unnecessarily clever and sort of indirect/IoC hellish since it comes after the function declaration. But that&apos;s just my two cents <b>🙂</b></z><z id="t1624459138" t="Lucy Wang +1 for this. Being able to place the schema right near to the argument is way more intuitive and maintainable than having them separate from each other."><y>#</y><d>2021-06-23</d><h>14:38</h><r>Lucy Wang</r>+1 for this. Being able to place the schema right near to the argument is way more intuitive and maintainable than having them separate from each other.</z><z id="t1624374890" t="emccue One option would be this"><y>#</y><d>2021-06-22</d><h>15:14</h><w>emccue</w>One option would be this</z><z id="t1624374891" t="emccue https://github.com/galdre/morphe"><y>#</y><d>2021-06-22</d><h>15:14</h><w>emccue</w><a href="https://github.com/galdre/morphe" target="_blank">https://github.com/galdre/morphe</a></z><z id="t1624374933" t="emccue make an aspect for it"><y>#</y><d>2021-06-22</d><h>15:15</h><w>emccue</w>make an aspect for it</z><z id="t1624374982" t="emccue ^{::m/aspects [(contract [:=&gt; [:cat int? int?] string?])]} (m/defn some-fn [x y] (str (+ x y))"><y>#</y><d>2021-06-22</d><h>15:16</h><w>emccue</w><pre>^{::m/aspects [(contract [:=&gt; [:cat int? int?] string?])]}
(m/defn some-fn [x y]
  (str (+ x y))</pre></z><z id="t1624375336" t="Yehonathan Sharvit Does malli support plumatic style? how?"><y>#</y><d>2021-06-22</d><h>15:22</h><w>Yehonathan Sharvit</w>Does malli support plumatic style? how?</z><z id="t1624379202" t="ikitommi wip, https://github.com/metosin/malli/pull/305"><y>#</y><d>2021-06-22</d><h>16:26</h><w>ikitommi</w>wip, <a href="https://github.com/metosin/malli/pull/305" target="_blank">https://github.com/metosin/malli/pull/305</a></z><z id="t1624468583" t="respatialized I&apos;m wondering whether function metadata maps may be suited to this purpose, the way spec does with :pre/:post validation inlined in an ordinary defn form, without needing a macro for function definitions. There may be a good reason to not overload the &quot;canonical&quot; keywords and instead use something like :malli/schema to inline it, but having it right in the form using metadata allows tests to be easily derived from a self-describing function with meta . https://clojure.org/guides/spec Was there something in your experience with spec-tools that led you to believe this isn&apos;t a good idea or the optimal solution for malli ?"><y>#</y><d>2021-06-23</d><h>17:16</h><r>respatialized</r>I&apos;m wondering whether function metadata maps may be suited to this purpose, the way <code>spec</code> does with <code>:pre/:post</code> validation inlined in an ordinary <code>defn</code> form, without needing a macro for function definitions. There may be a good reason to not overload the &quot;canonical&quot; keywords and instead use something like <code>:malli/schema</code> to inline it, but having it right in the form using metadata allows tests to be easily derived from a self-describing function with <code>meta</code>.

<a href="https://clojure.org/guides/spec" target="_blank">https://clojure.org/guides/spec</a>

Was there something in your experience with <code>spec-tools</code> that led you to believe this isn&apos;t a good idea or the optimal solution for <code>malli</code>?</z><z id="t1624470676" t="ikitommi the plumatic syntax has been out since 2013 and I believe it&apos;s the most used syntax, by far. I have used it, it&apos;s just good."><y>#</y><d>2021-06-23</d><h>17:51</h><r>ikitommi</r>the plumatic syntax has been out since 2013 and I believe it&apos;s the most used syntax, by far. I have used it, it&apos;s just good.</z><z id="t1624470803" t="ikitommi I like also the`:malli/schema` suggestion, the malli.instrument could be configured to support multiple sources like: 1. the =&gt; registry 2. the :malli/schema metadata 3. plain old function schema inferrer"><y>#</y><d>2021-06-23</d><h>17:53</h><r>ikitommi</r>I like also the`:malli/schema` suggestion, the <code>malli.instrument</code> could be configured to support multiple sources like:
1. the <code>=&gt;</code> registry
2. the <code>:malli/schema</code> metadata
3. plain old function schema inferrer</z><z id="t1624470845" t="ikitommi and, to be compliant: 4. the spec registry"><y>#</y><d>2021-06-23</d><h>17:54</h><r>ikitommi</r>and, to be compliant:
4. the spec registry</z><z id="t1624379365" t="Yehonathan Sharvit Ok"><y>#</y><d>2021-06-22</d><h>16:29</h><w>Yehonathan Sharvit</w>Ok</z><z id="t1624379470" t="Yehonathan Sharvit [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] In your previous message, you wrote: &gt; just before the functions (`m/=&gt;` is as long as `defn` , looks good What do you mean by m/=&gt; before the function? In malli&apos;s README, m/=&gt; comes after the function definition"><y>#</y><d>2021-06-22</d><h>16:31</h><w>Yehonathan Sharvit</w><a>@ikitommi</a> In your previous message, you wrote:
&gt;  just before the functions (`m/=&gt;` is as long as `defn` , looks good
What do you mean by <code>m/=&gt;</code> before the function?
In malli&apos;s README, <code>m/=&gt;</code> comes after the function definition</z><z id="t1624379718" t="ikitommi this works too: (m/=&gt; plus [:=&gt; [:cat [:* :int]] :int]) (defn plus [&amp; ns] (apply + ns)) (plus 1 2 3) ; =&gt; 6"><y>#</y><d>2021-06-22</d><h>16:35</h><w>ikitommi</w>this works too:
<pre>(m/=&gt; plus [:=&gt; [:cat [:* :int]] :int])
(defn plus [&amp; ns] (apply + ns))

(plus 1 2 3)
; =&gt; 6</pre></z><z id="t1624379879" t="Yehonathan Sharvit Nice. In fact malli treats function names as symbols"><y>#</y><d>2021-06-22</d><h>16:37</h><w>Yehonathan Sharvit</w>Nice. In fact malli treats function names as symbols</z><z id="t1624379899" t="Yehonathan Sharvit So it doesn&apos;t matter if you create the schema before the function is defined"><y>#</y><d>2021-06-22</d><h>16:38</h><w>Yehonathan Sharvit</w>So it doesn&apos;t matter if you create the schema before the function is defined</z><z id="t1624459138" t="Lucy Wang +1 for this. Being able to place the schema right near to the argument is way more intuitive and maintainable than having them separate from each other."><y>#</y><d>2021-06-23</d><h>14:38</h><w>Lucy Wang</w>+1 for this. Being able to place the schema right near to the argument is way more intuitive and maintainable than having them separate from each other.</z><z id="t1624468583" t="respatialized I&apos;m wondering whether function metadata maps may be suited to this purpose, the way spec does with :pre/:post validation inlined in an ordinary defn form, without needing a macro for function definitions. There may be a good reason to not overload the &quot;canonical&quot; keywords and instead use something like :malli/schema to inline it, but having it right in the form using metadata allows tests to be easily derived from a self-describing function with meta . https://clojure.org/guides/spec Was there something in your experience with spec-tools that led you to believe this isn&apos;t a good idea or the optimal solution for malli ?"><y>#</y><d>2021-06-23</d><h>17:16</h><w>respatialized</w>I&apos;m wondering whether function metadata maps may be suited to this purpose, the way <code>spec</code> does with <code>:pre/:post</code> validation inlined in an ordinary <code>defn</code> form, without needing a macro for function definitions. There may be a good reason to not overload the &quot;canonical&quot; keywords and instead use something like <code>:malli/schema</code> to inline it, but having it right in the form using metadata allows tests to be easily derived from a self-describing function with <code>meta</code>.

<a href="https://clojure.org/guides/spec" target="_blank">https://clojure.org/guides/spec</a>

Was there something in your experience with <code>spec-tools</code> that led you to believe this isn&apos;t a good idea or the optimal solution for <code>malli</code>?</z><z id="t1624483873" t="escherize I’d like to attach error messages to specific parts of my schema. So far I have the following working, but I’m not sure if it’s the best implementation. (def MySchema [:map [:something/one {:error/message &quot;one&quot;} int?] [:something/two {:error/message &quot;2&quot;} int?] [:something/three {:error/message &quot;three&quot;} int?] [:something/four {:error/message &quot;four&quot;} int?]]) (validate MySchema {}) ;; =&gt; #:something{:one [&quot;one&quot;], :two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}"><y>#</y><d>2021-06-23</d><h>21:31</h><w>escherize</w>I’d like to attach error messages to specific parts of my schema. So far I have the following working, but I’m not sure if it’s the best implementation.
<pre>(def MySchema
  [:map
   [:something/one {:error/message &quot;one&quot;} int?]
   [:something/two {:error/message &quot;2&quot;} int?]
   [:something/three {:error/message &quot;three&quot;} int?]
   [:something/four {:error/message &quot;four&quot;} int?]])

(validate MySchema {})
;; =&gt; #:something{:one [&quot;one&quot;], :two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}</pre></z><z id="t1624484010" t="escherize I am using the following to get this working: (defn find-error-message [schema k] (let [value (atom nil)] (walk/postwalk (fn [x] (when (and x (vector? x) (= (first x) k) (map? (second x))) (reset! value (second x))) x) schema) (:error/message @value))) ;; then, in humanize: (me/humanize ... {:errors (assoc me/default-errors :malli.core/missing-key {:error/fn (fn [{:keys [in]} _] (or (find-error-message schema (last in)) ;; is (last in) reliable here? (str &quot;Missing key: &apos;&quot;(last in)&quot;&apos;&quot;)))})})"><y>#</y><d>2021-06-23</d><h>21:33</h><w>escherize</w>I am using the following to get this working:

<pre>(defn find-error-message [schema k]
  (let [value (atom nil)]
    (walk/postwalk
     (fn [x]
       (when (and x (vector? x) (= (first x) k) (map? (second x)))
         (reset! value (second x)))
       x)
     schema)
    (:error/message @value)))

;; then, in humanize:

(me/humanize ...
 {:errors
  (assoc me/default-errors

   :malli.core/missing-key
   {:error/fn (fn [{:keys [in]} _]
                (or
                 (find-error-message schema (last in)) ;; is (last in) reliable here?
                 (str &quot;Missing key: &apos;&quot;(last in)&quot;&apos;&quot;)))})})</pre></z><z id="t1624484289" t="escherize I’m not sure if using (last in) in the :error/fn is reliable though."><y>#</y><d>2021-06-23</d><h>21:38</h><w>escherize</w>I’m not sure if using <code>(last in)</code>  in the :error/fn is reliable though.</z><z id="t1624510609" t="ikitommi [:attrs {:href &quot;/_/_/users/U051GFP2V&quot;}] maybe: (-&gt; [:map [:something/one {:error/message &quot;one&quot;} int?] [:something/two {:error/message &quot;2&quot;} int?] [:something/three {:error/message &quot;three&quot;} int?] [:something/four {:error/message &quot;four&quot;} int?]] (m/explain {}) (me/humanize {:resolve me/resolve-root-error})) ; =&gt; #:something{:one [&quot;one&quot;]:two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}"><y>#</y><d>2021-06-24</d><h>04:56</h><w>ikitommi</w><a>@escherize</a> maybe:
<pre>(-&gt; [:map
     [:something/one {:error/message &quot;one&quot;} int?]
     [:something/two {:error/message &quot;2&quot;} int?]
     [:something/three {:error/message &quot;three&quot;} int?]
     [:something/four {:error/message &quot;four&quot;} int?]]
    (m/explain {})
    (me/humanize {:resolve me/resolve-root-error}))
; =&gt; #:something{:one [&quot;one&quot;]:two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}</pre></z><z id="t1624510722" t="ikitommi that’s in master, but not released. can be used, but will most likely change it to be a separate step, something like: (-&gt; Schema (m/explain {}) (me/root-causes) (me/humanize)) ; =&gt; #:something{:one [&quot;one&quot;]:two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}"><y>#</y><d>2021-06-24</d><h>04:58</h><w>ikitommi</w>that’s in master, but not released. can be used, but will most likely change it to be a separate step, something like:
<pre>(-&gt; Schema
    (m/explain {})
    (me/root-causes)
    (me/humanize))
; =&gt; #:something{:one [&quot;one&quot;]:two [&quot;2&quot;], :three [&quot;three&quot;], :four [&quot;four&quot;]}</pre></z><z id="t1624510912" t="ikitommi anyway, it’s generic, so will find the top-most error defined: (-&gt; [:cat {:error/message &quot;oh no!&quot;} [:? [:map-of :string :any]] [:* :boolean]] (m/explain 123) (me/humanize {:resolve me/resolve-root-error})) ; =&gt; [&quot;oh no!&quot;]"><y>#</y><d>2021-06-24</d><h>05:01</h><w>ikitommi</w>anyway, it’s generic, so will find the top-most error defined:
<pre>(-&gt; [:cat {:error/message &quot;oh no!&quot;}
     [:? [:map-of :string :any]]
     [:* :boolean]]
    (m/explain 123)
    (me/humanize {:resolve me/resolve-root-error}))
; =&gt; [&quot;oh no!&quot;]</pre></z><z id="t1624510971" t="ikitommi there is a perf hit of recurring all errors towards root, but it can be later removed with an extra step of preparing a me/humanizer ."><y>#</y><d>2021-06-24</d><h>05:02</h><w>ikitommi</w>there is a perf hit of recurring all errors towards root, but it can be later removed with an extra step of preparing a <code>me/humanizer</code>.</z><z id="t1624514267" t="escherize Awesome. I’ll look into this. Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] "><y>#</y><d>2021-06-24</d><h>05:57</h><w>escherize</w>Awesome. I’ll look into this. Thanks <a>@ikitommi</a> </z><z id="t1624586105" t="pinealan Hi there! I’m trying to use malli as a parsing+coercion library for external data. I’m a bit lost on what the schemas should look like and what function should I be using. An example is I want to transform a map with shortened key names like this {&quot;a&quot; &quot;11&quot;, &quot;b&quot; &quot;10.01&quot;} into this {:ask 11.0 :bid 10.01} . Another case is sequential data, which may look like this [&quot;11&quot; &quot;10.01&quot;] , and I would want to get the same data back. I know it’s possible to do some of these steps without malli, i.e. rename-keys or spec/explain with :sequential , but it felt like there should be builtin idioms from the library/schema definitions that helps with the extra transformations that I am performing. Am I just missing something?"><y>#</y><d>2021-06-25</d><h>01:55</h><w>pinealan</w>Hi there! I’m trying to use malli as a parsing+coercion library for external data. I’m a bit lost on what the schemas should look like and what function should I be using.

An example is I want to transform a map with shortened key names like this <code>{&quot;a&quot; &quot;11&quot;, &quot;b&quot; &quot;10.01&quot;}</code> into this <code>{:ask 11.0 :bid 10.01}</code>. Another case is sequential data, which may look like this <code>[&quot;11&quot; &quot;10.01&quot;]</code>, and I would want to get the same data back.

I know it’s possible to do some of these steps without malli, i.e. rename-keys or spec/explain with <code>:sequential</code>, but it felt like there should be builtin idioms from the library/schema definitions that helps with the extra transformations that I am performing. Am I just missing something?</z><z id="t1624604594" t="ingesol I’m no expert, but I think you want encode/decode . See https://github.com/metosin/malli#value-transformation . You could write your own custom key-transformer that maintains a mapping of the abbreviations you want."><y>#</y><d>2021-06-25</d><h>07:03</h><w>ingesol</w>I’m no expert, but I think you want <code>encode/decode</code>. See <a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a>. You could write your own custom <code>key-transformer</code> that maintains a mapping of the abbreviations you want.</z><z id="t1624604686" t="ingesol (mt/key-transformer {:encode your-ns/kw-&gt;abbr :decode your-ns/abbr-&gt;kw}) "><y>#</y><d>2021-06-25</d><h>07:04</h><w>ingesol</w><pre>(mt/key-transformer {:encode your-ns/kw-&gt;abbr
                     :decode your-ns/abbr-&gt;kw})</pre>
</z><z id="t1624604877" t="ingesol Schema for map would be [:map-of :keyword :number] Or whatever more specific number type you want."><y>#</y><d>2021-06-25</d><h>07:07</h><w>ingesol</w>Schema for map would be
<pre>[:map-of :keyword :number]</pre>
Or whatever more specific number type you want.</z><z id="t1624604879" t="ingesol ^^^ [:attrs {:href &quot;/_/_/users/U0112ACBNRM&quot;}]"><y>#</y><d>2021-06-25</d><h>07:07</h><w>ingesol</w>^^^ <a>@achan961117</a></z><z id="t1624605110" t="ingesol Something like this in the end (non-tested code) (m/encode [:map-of :keyword :number] {:ask 11.0 :bid 10.01} (mt/transformer (mt/string-transformer) (mt/key-transformer {:encode your-ns/kw-&gt;abbr :decode your-ns/abbr-&gt;kw}))) ;; =&gt;&gt; {&quot;a&quot; &quot;11&quot;, &quot;b&quot; &quot;10.01&quot;}"><y>#</y><d>2021-06-25</d><h>07:11</h><w>ingesol</w>Something like this in the end (non-tested code)
<pre>(m/encode [:map-of :keyword :number]
          {:ask 11.0 :bid 10.01}
          (mt/transformer
           (mt/string-transformer)
           (mt/key-transformer {:encode your-ns/kw-&gt;abbr
                                :decode your-ns/abbr-&gt;kw})))
;; =&gt;&gt; {&quot;a&quot; &quot;11&quot;, &quot;b&quot; &quot;10.01&quot;}</pre></z><z id="t1624628870" t="Gary Berger Hello when using map syntax is there a way of describing a oneOf relationship such that: [:map [:or [:opt1 integer?] [:opt2 integer?]]] will allow either :opt1 or :opt2?"><y>#</y><d>2021-06-25</d><h>13:47</h><w>Gary Berger</w>Hello when using <code>map</code> syntax is there a way of describing a oneOf relationship such that:
<pre>[:map
  [:or
    [:opt1 integer?]
    [:opt2 integer?]]]  </pre>
will allow either :opt1 or :opt2?</z><z id="t1624629344" t="emccue do you intend that or to be inclusive or exclusive"><y>#</y><d>2021-06-25</d><h>13:55</h><w>emccue</w>do you intend that or to be inclusive or exclusive</z><z id="t1624629460" t="emccue [:and [:or [:map [:a int?]] [:map [:b int?]]] [:map [:x int?] [:y int?]]]"><y>#</y><d>2021-06-25</d><h>13:57</h><w>emccue</w><pre>[:and
 [:or [:map [:a int?]]
      [:map [:b int?]]]
 [:map [:x int?] [:y int?]]]</pre></z><z id="t1624642501" t="Gary Berger Just for clarity and not sure there is an easier way but exclusive or looks like (m/validate [:and [:or [:map [:p integer?]] [:map [:q integer?]]] [:not [:and [:map [:p integer?]] [:map [:q integer?]]]]] {:p 123 :q 123}) =&gt; false"><y>#</y><d>2021-06-25</d><h>17:35</h><r>Gary Berger</r>Just for clarity and not sure there is an easier way but exclusive or looks like
<pre>(m/validate
  [:and
   [:or
    [:map [:p integer?]]
    [:map [:q integer?]]]
   [:not
    [:and
     [:map [:p integer?]]
     [:map [:q integer?]]]]]
  {:p 123 :q 123}) =&gt; false</pre></z><z id="t1624629493" t="emccue i&apos;m curious if there is a better answer that generates gooder, but this would do the right validation"><y>#</y><d>2021-06-25</d><h>13:58</h><w>emccue</w>i&apos;m curious if there is a better answer that generates gooder, but this would do the right validation</z><z id="t1624637734" t="Gary Berger exclusive thanks [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}]"><y>#</y><d>2021-06-25</d><h>16:15</h><w>Gary Berger</w>exclusive thanks <a>@emccue</a></z><z id="t1624640974" t="ikitommi [:attrs {:href &quot;/_/_/users/U01S20S3552&quot;}] Usually, :and and :or are the way to go, see example in http://malli.io but there is also a declarative map-keys-relations poc: https://github.com/bsless/malli-keys-relations"><y>#</y><d>2021-06-25</d><h>17:09</h><w>ikitommi</w><a>@garyberger</a> Usually, <code>:and</code> and <code>:or</code> are the way to go, see example in <a href="http://malli.io" target="_blank">http://malli.io</a> but there is also a declarative map-keys-relations poc: <a href="https://github.com/bsless/malli-keys-relations" target="_blank">https://github.com/bsless/malli-keys-relations</a></z><z id="t1624916671" t="borkdude In case you didn&apos;t see it yet: https://github.com/piotr-yuxuan/malli-cli"><y>#</y><d>2021-06-28</d><h>21:44</h><w>borkdude</w>In case you didn&apos;t see it yet: <a href="https://github.com/piotr-yuxuan/malli-cli" target="_blank">https://github.com/piotr-yuxuan/malli-cli</a></z><z id="t1625153789" t="ikitommi Thanks! Added link to README"><y>#</y><d>2021-07-01</d><h>15:36</h><r>ikitommi</r>Thanks! Added link to README</z><z id="t1624920422" t="Gary Berger I will open an issue but this spec returns NPE with explain (deftest xor-test (is (= false (specs/explain [:and [:or [:map [:network integer?]] [:map [:snapshot integer?]]] [:not [:and [:map [:network integer?]] [:map [:snapshot integer?]]]]] {}))))"><y>#</y><d>2021-06-28</d><h>22:47</h><w>Gary Berger</w>I will open an issue but this spec returns NPE with <code>explain</code>
<pre>(deftest xor-test
  (is (= false
         (specs/explain
          [:and
           [:or
            [:map [:network integer?]]
            [:map [:snapshot integer?]]]
           [:not
            [:and
             [:map [:network integer?]]
             [:map [:snapshot integer?]]]]] {}))))</pre></z><z id="t1625153810" t="ikitommi Answered, could not reproduce with malli 0.5.1"><y>#</y><d>2021-07-01</d><h>15:36</h><r>ikitommi</r>Answered, could not reproduce with malli 0.5.1</z><z id="t1625153789" t="ikitommi Thanks! Added link to README"><y>#</y><d>2021-07-01</d><h>15:36</h><w>ikitommi</w>Thanks! Added link to README</z><z id="t1625045512" t="Richard Hundt Hi everyone. I&apos;ve got a malli schema of around 1500 sloc, with quite a lot of :multi schemas. I&apos;m using it for transformation, and to speed up the runtime, I&apos;m using malli/encoder and malli/decoder , however creating these transformers takes over a minute with version 0.5.1. I&apos;m not sure how to reason about the complexity there, as it seems like I&apos;ve got some combinatorial explosion (start-up time increases non-linearly in the size of the schema). Has anyone else run into this sort of thing? Any tips? EDIT: I don&apos;t really see the need for speculative parsing or backtracking, since all the :multi schemas have discriminators which :dispatch can use to disambiguate, but there must be a lot of that going on, because plain calls to malli/decode without the &quot;compiled&quot; versions returned by malli/decoder take minutes themselves (not using regex schemas at all, either). 😕 (I&apos;m running an Intel(R) Core(TM) i7-10875H)"><y>#</y><d>2021-06-30</d><h>09:31</h><w>Richard Hundt</w>Hi everyone. I&apos;ve got a malli schema of around 1500 sloc, with quite a lot of <code>:multi</code> schemas. I&apos;m using it for transformation, and to speed up the runtime, I&apos;m using <code>malli/encoder</code> and <code>malli/decoder</code> , however creating these transformers takes over a minute with version 0.5.1. I&apos;m not sure how to reason about the complexity there, as it seems like I&apos;ve got some combinatorial explosion (start-up time increases non-linearly in the size of the schema). Has anyone else run into this sort of thing? Any tips?

EDIT: I don&apos;t really see the need for speculative parsing or backtracking, since all the <code>:multi</code> schemas have discriminators which <code>:dispatch</code> can use to disambiguate, but there must be a lot of that going on, because plain calls to <code>malli/decode</code> without the &quot;compiled&quot; versions returned by <code>malli/decoder</code> take minutes themselves (not using regex schemas at all, either). <b>😕</b>
(I&apos;m running an Intel(R) Core(TM) i7-10875H)</z><z id="t1625153943" t="ikitommi that&apos;s not good [:attrs {:href &quot;/_/_/users/U026F3GM8NA&quot;}] . Could you create an issue out of this with a repro code showing the slowness. Thanks"><y>#</y><d>2021-07-01</d><h>15:39</h><r>ikitommi</r>that&apos;s not good <a>@U026F3GM8NA</a>. Could you create an issue out of this with a repro code showing the slowness. Thanks</z><z id="t1625162629" t="Richard Hundt Will do."><y>#</y><d>2021-07-01</d><h>18:03</h><r>Richard Hundt</r>Will do.</z><z id="t1625207395" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] could it be related to into transformer using satisfies? It&apos;s notoriously slow and GC intensive"><y>#</y><d>2021-07-02</d><h>06:29</h><r>Ben Sless</r><a>@U055NJ5CC</a> could it be related to into transformer using satisfies? It&apos;s notoriously slow and GC intensive</z><z id="t1625210208" t="ikitommi it could, easy to see from flamegraphs."><y>#</y><d>2021-07-02</d><h>07:16</h><r>ikitommi</r>it could, easy to see from flamegraphs.</z><z id="t1625211616" t="Ben Sless I can already guess from my experience with recursive calls to satisfies? , you&apos;ll see 95% of CPU is wasted on it"><y>#</y><d>2021-07-02</d><h>07:40</h><r>Ben Sless</r>I can already guess from my experience with recursive calls to <code>satisfies?</code> , you&apos;ll see 95% of CPU is wasted on it</z><z id="t1625225713" t="Ben Sless If -into-transformer was turned into a protocol, how would you make it work with cljs? fn? there is very different from in clj and won&apos;t be covered by a simple extend . Possible to do in cljs what was done for Schemas in clj?"><y>#</y><d>2021-07-02</d><h>11:35</h><r>Ben Sless</r>If <code>-into-transformer</code> was turned into a protocol, how would you make it work with cljs? <code>fn?</code> there is very different from in clj and won&apos;t be covered by a simple <code>extend</code>.
Possible to do in cljs what was done for <code>Schemas</code> in clj?</z><z id="t1625144508" t="pithyless Is there an existing PR or issue related to &quot;dependent schemas&quot; (i.e. returning a derivative schema, based on schema and value) that was mentioned on Jacek&apos;s podcast?"><y>#</y><d>2021-07-01</d><h>13:01</h><w>pithyless</w>Is there an existing PR or issue related to &quot;dependent schemas&quot; (i.e. returning a derivative schema, based on schema and value) that was mentioned on Jacek&apos;s podcast?</z><z id="t1625154598" t="ikitommi I don&apos;t think there is an issue yet."><y>#</y><d>2021-07-01</d><h>15:49</h><r>ikitommi</r>I don&apos;t think there is an issue yet.</z><z id="t1625154691" t="Ben Sless Do you feel like there might be a need for a getting started guide? While the readme is comprehensive, I get the impression new users have a hard time building up beyond the simple examples. Something which starts from a simple base case, expands on it and illustrates malli&apos;s capabilities and features might be useful"><y>#</y><d>2021-07-01</d><h>15:51</h><w>Ben Sless</w>Do you feel like there might be a need for a getting started guide?
While the readme is comprehensive, I get the impression new users have a hard time building up beyond the simple examples. Something which starts from a simple base case, expands on it and illustrates malli&apos;s capabilities and features might be useful</z><z id="t1625155666" t="ikitommi That would be awesome. Everything under docs gets published to cljdoc. Could also be a separate documentation site, if someone has time to work with that."><y>#</y><d>2021-07-01</d><h>16:07</h><w>ikitommi</w>That would be awesome. Everything under <code>docs</code> gets published to cljdoc. Could also be a separate documentation site, if someone has time to work with that.</z><z id="t1625155700" t="ikitommi examples of good doc sites (and tools to create them) would be a good start"><y>#</y><d>2021-07-01</d><h>16:08</h><w>ikitommi</w>examples of good doc sites (and tools to create them) would be a good start</z><z id="t1625156925" t="respatialized stay tuned on that one, I&apos;m working on a heavily malli driven static website generator that uses itself to document itself"><y>#</y><d>2021-07-01</d><h>16:28</h><r>respatialized</r>stay tuned on that one, I&apos;m working on a heavily <code>malli</code> driven static website generator that uses itself to document itself</z><z id="t1625156103" t="Ben Sless Docs and cljdoc are good enough imo, but I&apos;m more of a content over presentation kind of guy"><y>#</y><d>2021-07-01</d><h>16:15</h><w>Ben Sless</w>Docs and cljdoc are good enough imo, but I&apos;m more of a content over presentation kind of guy</z><z id="t1625156299" t="Ben Sless I&apos;ll start writing something. do you prefer adoc or md format?"><y>#</y><d>2021-07-01</d><h>16:18</h><w>Ben Sless</w>I&apos;ll start writing something. do you prefer adoc or md format?</z><z id="t1625156339" t="Ben Sless and on another note, any updates regarding the performance MRs I opened?"><y>#</y><d>2021-07-01</d><h>16:18</h><w>Ben Sless</w>and on another note, any updates regarding the performance MRs I opened?</z><z id="t1625157026" t="ikitommi both formats good, whatever you prefer. Adoc is better, right? The perf PRS (and all others), will check those soon. Just started my vacation, should have more time to invest in malli now."><y>#</y><d>2021-07-01</d><h>16:30</h><w>ikitommi</w>both formats good, whatever you prefer. Adoc is better, right? The perf PRS (and all others), will check those soon. Just started my vacation, should have more time to invest in malli now.</z><z id="t1625158550" t="Ben Sless Aren&apos;t you supposed to take time off on vacation? 🙂"><y>#</y><d>2021-07-01</d><h>16:55</h><w>Ben Sless</w>Aren&apos;t you supposed to take time off on vacation? <b>🙂</b></z><z id="t1625158606" t="Ben Sless who am I kidding if I had time off I don&apos;t think I&apos;d be able to keep away from the computer for more than a day"><y>#</y><d>2021-07-01</d><h>16:56</h><r>Ben Sless</r>who am I kidding if I had time off I don&apos;t think I&apos;d be able to keep away from the computer for more than a day</z><z id="t1625159680" t="ikitommi 6 weeks, should have time for both 😉"><y>#</y><d>2021-07-01</d><h>17:14</h><r>ikitommi</r>6 weeks, should have time for both <b>😉</b></z><z id="t1625160298" t="Ben Sless Looks wonderful. Have fun!"><y>#</y><d>2021-07-01</d><h>17:24</h><r>Ben Sless</r>Looks wonderful. Have fun!</z><z id="t1625161900" t="borkdude 6 weeks, wow"><y>#</y><d>2021-07-01</d><h>17:51</h><r>borkdude</r>6 weeks, wow</z><z id="t1625181167" t="greg Is it possible to write mali, convert it somehow to spec and use it for spec/fdef and orchestration?"><y>#</y><d>2021-07-01</d><h>23:12</h><w>greg</w>Is it possible to write mali, convert it somehow to spec and use it for <code>spec/fdef</code> and orchestration?</z><z id="t1625217548" t="ikitommi no atm, but could be. Thing is that you can present things with malli that are impossible to present as specs, so it would not be complete like malli-&gt;JSON Schema , which is lossy. Still, I think 95% would work ok. There is malli-instrument library for doing the same with malli, if that’s ok for your use case."><y>#</y><d>2021-07-02</d><h>09:19</h><r>ikitommi</r>no atm, but could be. Thing is that you can present things with malli that are impossible to present as specs, so it would not be complete like malli-&gt;JSON Schema , which is lossy. Still, I think 95% would work ok. There is <code>malli-instrument</code> library for doing the same with malli, if that’s ok for your use case.</z><z id="t1625234983" t="greg Makes sense. I wouldn&apos;t mind losing some of the malli features when instrumented as a spec. Some of the libraries (like integrant&apos;s pre-init-spec ) support only spec. Although in my case, I use spec mostly for instrumentation of some bits. I was asking for such a conversion, as it sounds like the non-invasive way of trying malli in an existing project. Anyway, I will take a look at malli-instrument . Thanks."><y>#</y><d>2021-07-02</d><h>14:09</h><r>greg</r>Makes sense. I wouldn&apos;t mind losing some of the malli features when instrumented as a spec.

Some of the libraries (like integrant&apos;s <code>pre-init-spec</code>) support only spec.
Although in my case, I use spec mostly for instrumentation of some bits. I was asking for such a conversion, as it sounds like the non-invasive way of trying malli in an existing project.

Anyway, I will take a look at <code>malli-instrument</code>. Thanks.</z><z id="t1625210325" t="rmcv How do I provide sci options in malli decode? Trying to use java class with no luck. (m/decode [:int {:decode/string &apos;(fn [_] (.toEpochMilli (java.time.Instant/now)))}] &quot;whatever&quot; {:classes {&apos;java.time.Instant java.time.Instant}} mt/string-transformer)"><y>#</y><d>2021-07-02</d><h>07:18</h><w>rmcv</w>How do I provide sci options in malli decode?  Trying to use java class with no luck.
<pre>(m/decode [:int {:decode/string &apos;(fn [_] (.toEpochMilli (java.time.Instant/now)))}]

          &quot;whatever&quot;

          {:classes {&apos;java.time.Instant java.time.Instant}}

          mt/string-transformer)</pre></z><z id="t1625217660" t="ikitommi looking at the code, it’s :malli.core/sci-options key in options, see https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1792-L1813"><y>#</y><d>2021-07-02</d><h>09:21</h><r>ikitommi</r>looking at the code, it’s <code>:malli.core/sci-options</code> key in options, see <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1792-L1813" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L1792-L1813</a></z><z id="t1625237591" t="rmcv tried this (m/decode [:int {:decode/string &apos;(fn [_] (.toEpochMilli (java.time.Instant/now)))}] &quot;whatever&quot; (merge (m/-default-sci-options) {:malli.core/sci-options {:classes {&apos;java.time.Instant java.time.Instant}}}) mt/string-transformer)"><y>#</y><d>2021-07-02</d><h>14:53</h><r>rmcv</r>tried this

<pre>(m/decode [:int {:decode/string &apos;(fn [_] (.toEpochMilli (java.time.Instant/now)))}]
          &quot;whatever&quot;
          (merge
           (m/-default-sci-options)
           {:malli.core/sci-options {:classes {&apos;java.time.Instant java.time.Instant}}})
          mt/string-transformer)</pre></z><z id="t1625237634" t="rmcv but can’t see it in https://github.com/metosin/malli/blob/eea10aa8c668a16f88d9fc66fce0616a7f9137b4/src/malli/sci.cljc#L10"><y>#</y><d>2021-07-02</d><h>14:53</h><r>rmcv</r>but can’t see it in <a href="https://github.com/metosin/malli/blob/eea10aa8c668a16f88d9fc66fce0616a7f9137b4/src/malli/sci.cljc#L10" target="_blank">https://github.com/metosin/malli/blob/eea10aa8c668a16f88d9fc66fce0616a7f9137b4/src/malli/sci.cljc#L10</a></z><z id="t1625218901" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] merged the loop unrolling perf PR, great for common cases and as it’s just clj, doesn’t make the cljs bundle size any bigger, big thanks! ;; 164ns -&gt; 36ns (let [valid? (m/validator [:and [:&gt; 0] [:&gt; 1] [:&gt; 2] [:&gt; 3] [:&gt; 4]])] (cc/quick-bench (valid? 5)))"><y>#</y><d>2021-07-02</d><h>09:41</h><w>ikitommi</w><a>@ben.sless</a> merged the loop unrolling perf PR, great for common cases and as it’s just clj, doesn’t make the cljs bundle size any bigger, big thanks!
<pre>;; 164ns -&gt; 36ns
(let [valid? (m/validator [:and [:&gt; 0] [:&gt; 1] [:&gt; 2] [:&gt; 3] [:&gt; 4]])]
  (cc/quick-bench (valid? 5)))</pre></z><z id="t1625222755" t="ikitommi merged the other perf PR too: ;; 150ns -&gt; 39ns (let [valid? (m/validator [:map [:a :any] [:b :any] [:c :any] [:d :any] [:e :any]]) value {:a 1, :b 2, :c 3, :d 4, :e 5}] (cc/with-progress-reporting (cc/quick-bench (valid? value))))"><y>#</y><d>2021-07-02</d><h>10:45</h><w>ikitommi</w>merged the other perf PR too:
<pre>;; 150ns -&gt; 39ns
(let [valid? (m/validator [:map [:a :any] [:b :any] [:c :any] [:d :any] [:e :any]])
      value {:a 1, :b 2, :c 3, :d 4, :e 5}]
  (cc/with-progress-reporting
    (cc/quick-bench (valid? value))))</pre></z><z id="t1625223291" t="ikitommi"><y>#</y><d>2021-07-02</d><h>10:54</h><r>ikitommi</r></z><z id="t1625224942" t="Ben Sless Nice 😁"><y>#</y><d>2021-07-02</d><h>11:22</h><r>Ben Sless</r>Nice <b>😁</b></z><z id="t1625478424" t="Richard Hundt [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;ve created https://github.com/metosin/malli/issues/472 with a test case which demonstrates the issue."><y>#</y><d>2021-07-05</d><h>09:47</h><r>Richard Hundt</r><a>@U055NJ5CC</a> I&apos;ve created <a href="https://github.com/metosin/malli/issues/472" target="_blank">https://github.com/metosin/malli/issues/472</a> with a test case which demonstrates the issue.</z><z id="t1625482867" t="Ben Sless [:attrs {:href &quot;/_/_/users/U026F3GM8NA&quot;}] I profiled you example, it looks like CPU mostly goes towards parsing the schema. If you wrap every def-ed schema with a schema constructor it seems to be way more efficient, would you mind trying?"><y>#</y><d>2021-07-05</d><h>11:01</h><r>Ben Sless</r><a>@U026F3GM8NA</a> I profiled you example, it looks like CPU mostly goes towards parsing the schema. If you wrap every def-ed schema with a schema constructor it seems to be way more efficient, would you mind trying?</z><z id="t1625482946" t="Richard Hundt D&apos;you mean just wrapping it in a function which returns the structure? (I&apos;m not sure what you mean by &quot;schema constructor&quot;)"><y>#</y><d>2021-07-05</d><h>11:02</h><r>Richard Hundt</r>D&apos;you mean just wrapping it in a function which returns the structure? (I&apos;m not sure what you mean by &quot;schema constructor&quot;)</z><z id="t1625483185" t="Ben Sless like so; (def A1 (m/schema [:map {:encode/test {:leave encode} :decode/test decode} [:type [:= &quot;A1&quot;]] [:value float?] ])) "><y>#</y><d>2021-07-05</d><h>11:06</h><r>Ben Sless</r>like so;
<pre>(def A1
  (m/schema
   [:map
    {:encode/test {:leave encode} :decode/test decode}
    [:type [:= &quot;A1&quot;]]
    [:value float?]
    ]))</pre>
</z><z id="t1625483204" t="Richard Hundt thanks, I&apos;ll try"><y>#</y><d>2021-07-05</d><h>11:06</h><r>Richard Hundt</r>thanks, I&apos;ll try</z><z id="t1625483204" t="Ben Sless m/schema parses the children once"><y>#</y><d>2021-07-05</d><h>11:06</h><r>Ben Sless</r><code>m/schema</code> parses the children once</z><z id="t1625483217" t="Ben Sless your implementation has no way to cache these results"><y>#</y><d>2021-07-05</d><h>11:06</h><r>Ben Sless</r>your implementation has no way to cache these results</z><z id="t1625483251" t="Ben Sless It&apos;s a bother to do from scratch, you can take this"><y>#</y><d>2021-07-05</d><h>11:07</h><r>Ben Sless</r>It&apos;s a bother to do from scratch, you can take this</z><z id="t1625483276" t="Ben Sless"><y>#</y><d>2021-07-05</d><h>11:07</h><r>Ben Sless</r></z><z id="t1625483286" t="Ben Sless thanks slack, very helpful"><y>#</y><d>2021-07-05</d><h>11:08</h><r>Ben Sless</r>thanks slack, very helpful</z><z id="t1625483318" t="Richard Hundt thank you"><y>#</y><d>2021-07-05</d><h>11:08</h><r>Richard Hundt</r>thank you</z><z id="t1625483335" t="Ben Sless https://gist.github.com/bsless/28a20f7e8f21f01fd93a788cf65444d4"><y>#</y><d>2021-07-05</d><h>11:08</h><r>Ben Sless</r><a href="https://gist.github.com/bsless/28a20f7e8f21f01fd93a788cf65444d4" target="_blank">https://gist.github.com/bsless/28a20f7e8f21f01fd93a788cf65444d4</a></z><z id="t1625483342" t="Ben Sless there, more convenient"><y>#</y><d>2021-07-05</d><h>11:09</h><r>Ben Sless</r>there, more convenient</z><z id="t1625483378" t="Richard Hundt yeah, that&apos;s pretty much instant now, I&apos;ll try it on our production code"><y>#</y><d>2021-07-05</d><h>11:09</h><r>Richard Hundt</r>yeah, that&apos;s pretty much instant now, I&apos;ll try it on our production code</z><z id="t1625483992" t="Ben Sless 👍"><y>#</y><d>2021-07-05</d><h>11:19</h><r>Ben Sless</r><b>👍</b></z><z id="t1625484965" t="Richard Hundt Perfect. Thanks Ben! What shall I do with the github issue? Do I close it, or are you planning on making changes to parsing?"><y>#</y><d>2021-07-05</d><h>11:36</h><r>Richard Hundt</r>Perfect. Thanks Ben! What shall I do with the github issue? Do I close it, or are you planning on making changes to parsing?</z><z id="t1625489008" t="ikitommi I closed the issue, no plans on making the parser faster or caching at the moment. Thanks for [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] for digging into this 🙇"><y>#</y><d>2021-07-05</d><h>12:43</h><r>ikitommi</r>I closed the issue, no plans on making the parser faster or caching at the moment. Thanks for <a>@ben.sless</a> for digging into this <b>🙇</b></z><z id="t1625489166" t="Ben Sless I think it is worth to leave a comment on the issue and perhaps a note in the readme regarding references to uncompiled schemas"><y>#</y><d>2021-07-05</d><h>12:46</h><r>Ben Sless</r>I think it is worth to leave a comment on the issue and perhaps a note in the readme regarding references to uncompiled schemas</z><z id="t1625489210" t="Ben Sless And you&apos;re welcome 🙂 Turns out I was completely wrong regarding the transformers and satisfies?"><y>#</y><d>2021-07-05</d><h>12:46</h><r>Ben Sless</r>And you&apos;re welcome <b>🙂</b>
Turns out I was completely wrong regarding the transformers and <code>satisfies?</code></z><z id="t1625489277" t="Ben Sless I see you left a comment with a link to the gist, so that would leave only the readme"><y>#</y><d>2021-07-05</d><h>12:47</h><r>Ben Sless</r>I see you left a comment with a link to the gist, so that would leave only the readme</z><z id="t1625490853" t="ikitommi if you have idea what and where to write this, please do 🙂"><y>#</y><d>2021-07-05</d><h>13:14</h><r>ikitommi</r>if you have idea what and where to write this, please do <b>🙂</b></z><z id="t1625223005" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] , great work. Saw the thread on Clojureverse about compiler optimizations. Would be great if things got automatically or magically faster. While waiting, writing performant code inside the libraries (on the hot perf path) is just being smart."><y>#</y><d>2021-07-02</d><h>10:50</h><w>ikitommi</w><a>@ben.sless</a>, great work. Saw the thread on Clojureverse about compiler optimizations. Would be great if things got automatically or magically faster. While waiting, writing performant code inside the libraries (on the hot perf path) is just being smart.</z><z id="t1625224895" t="Ben Sless Thank you, I appreciate it. Blame it all on the talk you gave on ClojureTRE 2019"><y>#</y><d>2021-07-02</d><h>11:21</h><r>Ben Sless</r>Thank you, I appreciate it.
Blame it all on the talk you gave on ClojureTRE 2019</z><z id="t1625318146" t="ikitommi too hot, quick poke on instrumenting functions. moving functioin wrapping code from malli.generate into malli.core (just one fn) -&gt;`m/-instrument`, can be used to enforce function schmas. First user will be malli.instrument utilities, but could be used directly in client code too: (def pow2 (m/-instrument {:schema [:=&gt; [:cat :int] [:int {:max 6}]]} (fn [x] (* x x)))) (pow2 2) ; =&gt; 4 (pow2 &quot;2&quot;) ; =throws=&gt; :malli.core/invalid-input {:input [:cat :int], :args [&quot;2&quot;], :schema [:=&gt; [:cat :int] [:int {:max 6}]]} (pow2 4) ; =throws=&gt; :malli.core/invalid-output {:output [:int {:max 6}], :value 16, :args [4], :schema [:=&gt; [:cat :int] [:int {:max 6}]]} (pow2 4 2) ; =throws=&gt; :malli.core/invalid-arity {:arity 2, :arities #{{:min 1, :max 1}}, :args [4 2], :input [:cat :int], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}"><y>#</y><d>2021-07-03</d><h>13:15</h><w>ikitommi</w>too hot, quick poke on instrumenting functions. moving functioin wrapping code from <code>malli.generate</code> into <code>malli.core</code> (just one fn) -&gt;`m/-instrument`, can be used to enforce function schmas. First user will be <code>malli.instrument</code> utilities, but could be used directly in client code too:
<pre>(def pow2
  (m/-instrument
    {:schema [:=&gt; [:cat :int] [:int {:max 6}]]}
    (fn [x] (* x x))))

(pow2 2)
; =&gt; 4

(pow2 &quot;2&quot;)
; =throws=&gt; :malli.core/invalid-input {:input [:cat :int], :args [&quot;2&quot;], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}

(pow2 4)
; =throws=&gt; :malli.core/invalid-output {:output [:int {:max 6}], :value 16, :args [4], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}

(pow2 4 2)
; =throws=&gt; :malli.core/invalid-arity {:arity 2, :arities #{{:min 1, :max 1}}, :args [4 2], :input [:cat :int], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}</pre></z><z id="t1625318223" t="ikitommi like everything else, can be configured to behave differently. e.g. just printing out the errors (or to tap ’em): (def multi-arity-pow (m/-instrument {:schema [:function [:=&gt; [:cat :int] [:int {:max 6}]] [:=&gt; [:cat :int :int] [:int {:max 6}]]] :wrap #{:input, :output} :report (fn [error props] (println &quot;\n&quot; error &quot;\n&quot;) (clojure.pprint/pprint props))} (fn ([x] (* x x)) ([x y] (* x y))))) (multi-arity-pow 4) ;:malli.core/invalid-output ; ;{:output [:int {:max 6}], ; :value 16, ; :args [4], ; :schema [:=&gt; [:cat :int] [:int {:max 6}]]} ; =&gt; 16 (multi-arity-pow 5 0.1) ;:malli.core/invalid-input ; ;{:input [:cat :int :int], ; :args [5 0.1], ; :schema [:=&gt; [:cat :int :int] [:int {:max 6}]]} ; ;:malli.core/invalid-output ; ;{:output [:int {:max 6}], ; :value 0.5, ; :args [5 0.1], ; :schema [:=&gt; [:cat :int :int] [:int {:max 6}]]} ;=&gt; 0.5"><y>#</y><d>2021-07-03</d><h>13:17</h><w>ikitommi</w>like everything else, can be configured to behave differently. e.g. just printing out the errors (or to tap ’em):
<pre>(def multi-arity-pow
  (m/-instrument
    {:schema [:function
              [:=&gt; [:cat :int] [:int {:max 6}]]
              [:=&gt; [:cat :int :int] [:int {:max 6}]]]
     :wrap #{:input, :output}
     :report (fn [error props]
               (println &quot;\n&quot; error &quot;\n&quot;)
               (clojure.pprint/pprint props))}
    (fn
      ([x] (* x x))
      ([x y] (* x y)))))

(multi-arity-pow 4)
;:malli.core/invalid-output
;
;{:output [:int {:max 6}],
; :value 16,
; :args [4],
; :schema [:=&gt; [:cat :int] [:int {:max 6}]]}
; =&gt; 16

(multi-arity-pow 5 0.1)
;:malli.core/invalid-input
;
;{:input [:cat :int :int],
; :args [5 0.1],
; :schema [:=&gt; [:cat :int :int] [:int {:max 6}]]}
;
;:malli.core/invalid-output
;
;{:output [:int {:max 6}],
; :value 0.5,
; :args [5 0.1],
; :schema [:=&gt; [:cat :int :int] [:int {:max 6}]]}
;=&gt; 0.5</pre></z><z id="t1625318747" t="ikitommi oh, and the generators use this too, generator for :=&gt; looks dead simple now: (defn -=&gt;-gen [schema options] (let [output-generator (generator (:output (m/-function-info schema)) options)] (gen/return (m/-instrument {:schema schema} (fn [&amp; _] (generate output-generator options))))))"><y>#</y><d>2021-07-03</d><h>13:25</h><w>ikitommi</w>oh, and the generators use this too, generator for <code>:=&gt;</code> looks dead simple now:
<pre>(defn -=&gt;-gen [schema options]
  (let [output-generator (generator (:output (m/-function-info schema)) options)]
    (gen/return (m/-instrument {:schema schema} (fn [&amp; _] (generate output-generator options))))))</pre></z><z id="t1625321044" t="ikitommi dunno if there is a way to emit clj-kondo annotations from schematized fns, which are not vars :thinking_face:"><y>#</y><d>2021-07-03</d><h>14:04</h><w>ikitommi</w>dunno if there is a way to emit clj-kondo annotations from schematized fns, which are not vars <b>:thinking_face:</b></z><z id="t1625332096" t="respatialized Say I&apos;ve got a :orn schema that I&apos;m matching multiple values against: [:orn [:map1 [:map {:closed true :description &quot;map1&quot;} [:a :string]]] [:map2 [:map {:description &quot;map2&quot;} [:a :string] [:b {:optional true} :string]]]] is there a way to see which of these subschemas were responsible for a given value matching the top-level form - something like m/explain but for values that do conform to the schema?"><y>#</y><d>2021-07-03</d><h>17:08</h><w>respatialized</w>Say I&apos;ve got a <code>:orn</code> schema that I&apos;m matching multiple values against:
<pre>[:orn [:map1 [:map {:closed true
                    :description &quot;map1&quot;}
              [:a :string]]]
     [:map2  [:map {:description &quot;map2&quot;}
              [:a :string]
              [:b {:optional true} :string]]]]</pre>
is there a way to see which of these subschemas were responsible for a given value matching the top-level form - something like <code>m/explain</code> but for values that do conform to the schema?</z><z id="t1625332292" t="ikitommi [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] try m/parse"><y>#</y><d>2021-07-03</d><h>17:11</h><w>ikitommi</w><a>@afoltzm</a> try <code>m/parse</code></z><z id="t1625332591" t="respatialized [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks, I knew there was likely something I was missing. my earlier examples didn&apos;t use :orn - it seems like with an unnamed :or schema only the conforming value is returned by m/parse . is there a way to return the matching schema for unnamed :or subschemas? the use case I&apos;m thinking of here is matching values against some collection of schemas that may not necessarily be known in advance, and so can&apos;t easily be named with :orn ."><y>#</y><d>2021-07-03</d><h>17:16</h><w>respatialized</w><a>@ikitommi</a> thanks, I knew there was likely something I was missing. my earlier examples didn&apos;t use <code>:orn</code> - it seems like with an unnamed <code>:or</code> schema only the conforming value is returned by <code>m/parse</code>. is there a way to return the matching schema for unnamed <code>:or</code> subschemas? the use case I&apos;m thinking of here is matching values against some collection of schemas that may not necessarily be known in advance, and so can&apos;t easily be named with <code>:orn</code>.</z><z id="t1625332637" t="respatialized it seems like I may be able to implement something in terms of m/walk if it&apos;s not built in?"><y>#</y><d>2021-07-03</d><h>17:17</h><w>respatialized</w>it seems like I may be able to implement something in terms of <code>m/walk</code> if it&apos;s not built in?</z><z id="t1625332873" t="ikitommi currrently, no. Could add an property to :or to hint that parse should return the index of the branch or an option to parse like :malli.core/parse-indexes true . Or, you can just create :or with number-indexed branches: (m/parse [:orn [1 :int] [2 :boolean]] true) ; =&gt; [2 true]"><y>#</y><d>2021-07-03</d><h>17:21</h><w>ikitommi</w>currrently, no. Could add an property to <code>:or</code> to hint that parse should return the index of the branch or an option to parse like <code>:malli.core/parse-indexes true</code>. Or, you can just create <code>:or</code> with number-indexed branches:
<pre>(m/parse
  [:orn
   [1 :int]
   [2 :boolean]] 
  true)
; =&gt; [2 true]</pre></z><z id="t1625332910" t="respatialized ah, gotcha. I think numbered branches is likely the easiest workaround for the time being."><y>#</y><d>2021-07-03</d><h>17:21</h><w>respatialized</w>ah, gotcha. I think numbered branches is likely the easiest workaround for the time being.</z><z id="t1625332994" t="ikitommi (defn or-&gt;orn [s] (m/into-schema :orn (m/properties s) (map-indexed vector (m/children s)))) (or-&gt;orn [:or :int :boolean]) ; =&gt; [:orn [0 :int] [1 :boolean]]"><y>#</y><d>2021-07-03</d><h>17:23</h><w>ikitommi</w><pre>(defn or-&gt;orn [s]
  (m/into-schema :orn (m/properties s) (map-indexed vector (m/children s))))

(or-&gt;orn [:or :int :boolean])
; =&gt; [:orn [0 :int] [1 :boolean]]</pre></z><z id="t1625383010" t="ikitommi wip: malli.instrument ( https://github.com/metosin/malli/pull/471 )"><y>#</y><d>2021-07-04</d><h>07:16</h><w>ikitommi</w>wip: <code>malli.instrument</code> (<a href="https://github.com/metosin/malli/pull/471" target="_blank">https://github.com/metosin/malli/pull/471</a>)</z><z id="t1625469269" t="oly is there a way to have different map layouts, I wanted to do something like this [:map [:coord [:or [:map {:closed true}] [:map {:closed true} [:x int? :y int?]]]]] {:coord {}} {:coord {:x 1 :y 1}} I know I can make the whole map optional but what about allowing an empty map or a map with fixed keys, I tried a few things but could not find a way."><y>#</y><d>2021-07-05</d><h>07:14</h><w>oly</w>is there a way to have different map layouts, I wanted to do something like this
<pre>[:map [:coord [:or 
               [:map {:closed true}]
               [:map {:closed true} [:x int? :y int?]]]]]
{:coord {}}
{:coord {:x 1 :y 1}}</pre>
I know I can make the whole map optional but what about allowing an empty map or a map with fixed keys, I tried a few things but could not find a way.</z><z id="t1625471080" t="alpox [:attrs {:href &quot;/_/_/users/UU67HFS2X&quot;}] I think this works if you use for the second :map : [:map {:closed true} [:x int?] [:y int?]]"><y>#</y><d>2021-07-05</d><h>07:44</h><w>alpox</w><a>@oliver.marks</a> I think this works if you use for the second <code>:map</code>:
<pre>[:map {:closed true} [:x int?] [:y int?]]</pre></z><z id="t1625471237" t="oly yeah that works for the second map, just not sure how to make it work also for an empty map I tried putting optional in various places and tried :or and a few other things oh I might have missed some brackets above but its more an an illustration of one of the methods I tried"><y>#</y><d>2021-07-05</d><h>07:47</h><w>oly</w>yeah that works for the second map, just not sure how to make it work also for an empty map I tried putting optional in various places and tried :or and a few other things oh I might have missed some brackets above but its more an an illustration of one of the methods I tried</z><z id="t1625471296" t="oly [:map {:closed true :optional true} [:x int?] [:y int?]] also tried this but that does not work, I know I could make the :x and :y keys optional but really I want an all or nothing method"><y>#</y><d>2021-07-05</d><h>07:48</h><w>oly</w><pre>[:map {:closed true :optional true} [:x int?] [:y int?]]</pre>
also tried this but that does not work, I know I could make the :x and :y keys optional but really I want an all or nothing method</z><z id="t1625471366" t="alpox I tried it with your :or above and that worked (after adding the missing brackets)"><y>#</y><d>2021-07-05</d><h>07:49</h><w>alpox</w>I tried it with your <code>:or</code> above and that worked (after adding the missing brackets)</z><z id="t1625471574" t="alpox"><y>#</y><d>2021-07-05</d><h>07:52</h><w>alpox</w></z><z id="t1625471580" t="oly this passes ? {:coord {}} when I run it through m/valid i get missing keys or I was yesterday when I was testing 😛"><y>#</y><d>2021-07-05</d><h>07:53</h><w>oly</w>this passes ? {:coord {}} when I run it through m/valid i get missing keys or I was yesterday when I was testing <b>😛</b></z><z id="t1625471632" t="oly nice, I will re check what I have maybe there was a different error which I did not spot"><y>#</y><d>2021-07-05</d><h>07:53</h><w>oly</w>nice, I will re check what I have maybe there was a different error which I did not spot</z><z id="t1625471779" t="oly [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] [:map [:coord [:or [:map {:closed true}] [:map {:closed true} [:x {:optional false} int?] [:y {:optional false} int?]]]]]"><y>#</y><d>2021-07-05</d><h>07:56</h><w>oly</w><a>@alpox</a>
<pre>[:map [:coord [:or 
               [:map {:closed true}]
               [:map {:closed true}
               [:x {:optional false} int?]
               [:y {:optional false} int?]]]]]</pre></z><z id="t1625471810" t="oly what about that, I think because the key do not have the optional map the :or is irrelevant anyway"><y>#</y><d>2021-07-05</d><h>07:56</h><w>oly</w>what about that, I think because the key do not have the optional map the :or is irrelevant anyway</z><z id="t1625471907" t="oly although perhaps thats it, perhaps its optional thats messing me up looking at your screenshot again I can see it fails when one of the keys are missing"><y>#</y><d>2021-07-05</d><h>07:58</h><w>oly</w>although perhaps thats it, perhaps its optional thats messing me up looking at your screenshot again I can see it fails when one of the keys are missing</z><z id="t1625472545" t="oly [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] thanks for your rubber ducking, not an issue with malli I had 2 schmeas with similar name and was updating the wrong one 😕"><y>#</y><d>2021-07-05</d><h>08:09</h><w>oly</w><a>@alpox</a> thanks for your rubber ducking, not an issue with malli I had 2 schmeas with similar name and was updating the wrong one <b>😕</b></z><z id="t1625472628" t="alpox Oups 🙂 np"><y>#</y><d>2021-07-05</d><h>08:10</h><w>alpox</w>Oups <b>🙂</b> np</z><z id="t1625473787" t="Ben Sless I constantly get the feeling that I&apos;m missing a schema to talk about map schemas in terms of key-value pairs"><y>#</y><d>2021-07-05</d><h>08:29</h><w>Ben Sless</w>I constantly get the feeling that I&apos;m missing a schema to talk about map schemas in terms of key-value pairs</z><z id="t1625473837" t="Ben Sless an annoying example to implement is mutual exclusion, such as a map which can have x, y and (z or u)"><y>#</y><d>2021-07-05</d><h>08:30</h><w>Ben Sless</w>an annoying example to implement is mutual exclusion, such as a map which can have x, y and (z or u)</z><z id="t1625473848" t="Ben Sless where z and u have different value types, too"><y>#</y><d>2021-07-05</d><h>08:30</h><w>Ben Sless</w>where z and u have different value types, too</z><z id="t1625488443" t="ikitommi Hear hear. I think something like malli-keys-relations should be there. With qualified keywords, it’s less boilerplate (but, still has): [:or [:map ::x ::y ::z] [:map ::x ::y ::u]]"><y>#</y><d>2021-07-05</d><h>12:34</h><w>ikitommi</w>Hear hear. I think something like <code>malli-keys-relations</code> should be there. With qualified keywords, it’s less boilerplate (but, still has):
<pre>[:or 
 [:map ::x ::y ::z]
 [:map ::x ::y ::u]]</pre></z><z id="t1625488491" t="ikitommi spec-style would be: [:map ::x ::y [:keys/or ::y ::u]]"><y>#</y><d>2021-07-05</d><h>12:34</h><w>ikitommi</w>spec-style would be:
<pre>[:map ::x ::y [:keys/or ::y ::u]]</pre></z><z id="t1625488566" t="ikitommi maybe: [:and [:map ::x ::y ::z ::u] [:keys/or ::z ::u]]"><y>#</y><d>2021-07-05</d><h>12:36</h><w>ikitommi</w>maybe:
<pre>[:and
 [:map ::x ::y ::z ::u]
 [:keys/or ::z ::u]]</pre></z><z id="t1625488795" t="ikitommi … and the mandatory JSON Schema way for this: https://json-schema.org/understanding-json-schema/reference/conditionals.html"><y>#</y><d>2021-07-05</d><h>12:39</h><w>ikitommi</w>… and the mandatory JSON Schema way for this: <a href="https://json-schema.org/understanding-json-schema/reference/conditionals.html" target="_blank">https://json-schema.org/understanding-json-schema/reference/conditionals.html</a></z><z id="t1625489373" t="Ben Sless JSON Schema&apos;s BNF was one of the motivations for it"><y>#</y><d>2021-07-05</d><h>12:49</h><w>Ben Sless</w>JSON Schema&apos;s BNF was one of the motivations for it</z><z id="t1625489415" t="Ben Sless &gt; map which contains at least one ::x where ::x is [:or [:x int?] [:y float?]]"><y>#</y><d>2021-07-05</d><h>12:50</h><w>Ben Sless</w>&gt; map which contains at least one <code>::x</code> where <code>::x</code> is <code>[:or [:x int?] [:y float?]]</code></z><z id="t1625489838" t="Ben Sless If we had it we could define JSON Schema with malli (translating the ebnf is straightforward), then define encoders and decoders to transform between the two"><y>#</y><d>2021-07-05</d><h>12:57</h><w>Ben Sless</w>If we had it we could define JSON Schema with malli (translating the ebnf is straightforward), then define encoders and decoders to transform between the two</z><z id="t1625502521" t="ikitommi added a video of the new function instrumention. three apis: advanced, normal users and for the lazy: https://github.com/metosin/malli/pull/471"><y>#</y><d>2021-07-05</d><h>16:28</h><w>ikitommi</w>added a video of the new function instrumention. three apis: advanced, normal users and for the lazy: <a href="https://github.com/metosin/malli/pull/471" target="_blank">https://github.com/metosin/malli/pull/471</a></z><z id="t1625502532" t="ikitommi comments welcome"><y>#</y><d>2021-07-05</d><h>16:28</h><w>ikitommi</w>comments welcome</z><z id="t1625542842" t="emccue Is there a good thing to use for &quot;I make no assumptions about what this is&quot;"><y>#</y><d>2021-07-06</d><h>03:40</h><w>emccue</w>Is there a good thing to use for &quot;I make no assumptions about what this is&quot;</z><z id="t1625542874" t="emccue like any?, but for say something you can pass to next.jdbc"><y>#</y><d>2021-07-06</d><h>03:41</h><w>emccue</w>like any?, but for say something you can pass to next.jdbc</z><z id="t1625542900" t="emccue and won&apos;t be generatable"><y>#</y><d>2021-07-06</d><h>03:41</h><w>emccue</w>and won&apos;t be generatable</z><z id="t1625543161" t="emccue writing a spec for what would count as a &quot;db&quot; has been confusing me, so i want a give up hatch for a second"><y>#</y><d>2021-07-06</d><h>03:46</h><w>emccue</w>writing a spec for what would count as a &quot;db&quot; has been confusing me, so i want a give up hatch for a second</z><z id="t1625564264" t="ikitommi so, :any is not enough? You could say [:any {:gen/elements [&quot;whatever&quot;]}] to generate what you like."><y>#</y><d>2021-07-06</d><h>09:37</h><w>ikitommi</w>so, <code>:any</code> is not enough? You could say <code>[:any {:gen/elements [&quot;whatever&quot;]}]</code> to generate what you like.</z><z id="t1625577091" t="emccue I guess it is with the empty gen elements."><y>#</y><d>2021-07-06</d><h>13:11</h><r>emccue</r>I guess it is with the empty gen elements.</z><z id="t1625573714" t="ikitommi miu/collect! with pluggable collector. anyone interested in doing fspec -&gt; malli collector?"><y>#</y><d>2021-07-06</d><h>12:15</h><w>ikitommi</w><code>miu/collect!</code> with pluggable collector. anyone interested in doing fspec -&gt; malli collector?</z><z id="t1625573918" t="ikitommi the source: (defn -accept-default [v] (let [{:keys [ns name malli/schema] :as meta} (meta v)] (when schema (m/-register-function-schema! (-&gt; ns str symbol) name (miu/-unlift-keys meta &quot;malli&quot;))))) (defn collect! [{:keys [ns accept] :or {accept -accept-default}}] (doseq [[_ v] (ns-publics ns)] (accept v)))"><y>#</y><d>2021-07-06</d><h>12:18</h><w>ikitommi</w>the source:
<pre>(defn -accept-default [v]
  (let [{:keys [ns name malli/schema] :as meta} (meta v)]
    (when schema (m/-register-function-schema! (-&gt; ns str symbol) name (miu/-unlift-keys meta &quot;malli&quot;)))))

(defn collect! [{:keys [ns accept] :or {accept -accept-default}}]
  (doseq [[_ v] (ns-publics ns)] (accept v)))</pre></z><z id="t1625575572" t="ikitommi Idea: an external tool that infers the schemas from vars and adds the needed schema meta into vars (rewrites the source, I recall there are tools for that already, edamame?)."><y>#</y><d>2021-07-06</d><h>12:46</h><w>ikitommi</w>Idea: an external tool that infers the schemas from vars and adds the needed schema meta into vars (rewrites the source, I recall there are tools for that already, edamame?).</z><z id="t1625584235" t="robert-stuttaford i use edamame on the edn that i give to malli, but only because i have the exceptions edamame gives me to tell the user where they typed something wrong when they malform edn"><y>#</y><d>2021-07-06</d><h>15:10</h><r>robert-stuttaford</r>i use edamame on the edn that i give to malli, but only because i have the exceptions edamame gives me to tell the user where they typed something wrong when they malform edn</z><z id="t1625609170" t="borkdude &gt; rewrites the source This would be rewrite-clj"><y>#</y><d>2021-07-06</d><h>22:06</h><r>borkdude</r>&gt; rewrites the source
This would be rewrite-clj</z><z id="t1625751007" t="robert-stuttaford use that too 😄"><y>#</y><d>2021-07-08</d><h>13:30</h><r>robert-stuttaford</r>use that too <b>😄</b></z><z id="t1625584136" t="robert-stuttaford Malli is lovely."><y>#</y><d>2021-07-06</d><h>15:08</h><w>robert-stuttaford</w>Malli is lovely.</z><z id="t1625598411" t="ikitommi generated responses from function schema definitions:"><y>#</y><d>2021-07-06</d><h>19:06</h><w>ikitommi</w>generated responses from function schema definitions:</z><z id="t1625611227" t="emccue [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] I&apos;ll add to that - the malli syntax is solid even without an impl. We don&apos;t use malli at work yet, but we have already started using its syntax for describing data in (comment ...) blocks."><y>#</y><d>2021-07-06</d><h>22:40</h><w>emccue</w><a>@robert-stuttaford</a> I&apos;ll add to that - the malli syntax is solid even without an impl. We don&apos;t use malli at work yet, but we have already started using its syntax for describing data in <code>(comment ...)</code> blocks.</z><z id="t1625750808" t="robert-stuttaford that&apos;s pretty cool [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] ! it has the same property as hiccup - ultra consistent data optimised for human reader"><y>#</y><d>2021-07-08</d><h>13:26</h><w>robert-stuttaford</w>that&apos;s pretty cool <a>@emccue</a>! it has the same property as hiccup - ultra consistent data optimised for human reader</z><z id="t1625825540" t="jeroenvandijk If I want to validate if something is a function, it seems I can’t do (m/validate fn? (fn [])) , but I can do (m/validate ifn? (fn [])) or (m/validate [:=&gt; [:cat] any?] (fn [])) . Is there an easy way to look up what predicates are supported?"><y>#</y><d>2021-07-09</d><h>10:12</h><w>jeroenvandijk</w>If I want to validate if something is a function, it seems I can’t do <code>(m/validate fn? (fn []))</code>, but I can do <code>(m/validate ifn? (fn []))</code> or <code>(m/validate [:=&gt; [:cat] any?] (fn []))</code> . Is there an easy way to look up what predicates are supported?</z><z id="t1625825555" t="jeroenvandijk For now it seems the source is the quickest way? I’m looking into the source now to check it https://github.com/metosin/malli/blob/50c6cf6f6438401d6de2c46a9542f4c10da76a86/src/malli/core.cljc#L1750"><y>#</y><d>2021-07-09</d><h>10:12</h><r>jeroenvandijk</r>For now it seems the source is the quickest way? I’m looking into the source now to check it <a href="https://github.com/metosin/malli/blob/50c6cf6f6438401d6de2c46a9542f4c10da76a86/src/malli/core.cljc#L1750" target="_blank">https://github.com/metosin/malli/blob/50c6cf6f6438401d6de2c46a9542f4c10da76a86/src/malli/core.cljc#L1750</a></z><z id="t1625826960" t="alpox There is the section https://github.com/metosin/malli#mallicorepredicate-schemas in the docs but it appears not to list ifn? :thinking_face:"><y>#</y><d>2021-07-09</d><h>10:36</h><r>alpox</r>There is the section <a href="https://github.com/metosin/malli#mallicorepredicate-schemas" target="_blank">https://github.com/metosin/malli#mallicorepredicate-schemas</a> in the docs but it appears not to list <code>ifn?</code> <b>:thinking_face:</b></z><z id="t1625827372" t="jeroenvandijk yeah I found this through the README https://github.com/metosin/malli#fn-schemas I’m guessing omission in the docs"><y>#</y><d>2021-07-09</d><h>10:42</h><r>jeroenvandijk</r>yeah I found this through the README <a href="https://github.com/metosin/malli#fn-schemas" target="_blank">https://github.com/metosin/malli#fn-schemas</a> I’m guessing omission in the docs</z><z id="t1625849188" t="ikitommi could you [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] update the docs?"><y>#</y><d>2021-07-09</d><h>16:46</h><r>ikitommi</r>could you <a>@U0FT7SRLP</a>  update the docs?</z><z id="t1625849336" t="ikitommi when instrumentation is done, there could be a separate doc for function schemas. Lot&apos;s of different aspects (validation, generative testing, instrumentation, linting, ...) to cover."><y>#</y><d>2021-07-09</d><h>16:48</h><r>ikitommi</r>when instrumentation is done, there could be a separate doc for function schemas. Lot&apos;s of different aspects (validation, generative testing, instrumentation, linting, ...) to cover.</z><z id="t1625931750" t="ikitommi oh, fn? is missing, will add that"><y>#</y><d>2021-07-10</d><h>15:42</h><r>ikitommi</r>oh, <code>fn?</code> is missing, will add that</z></g><g id="s16"><z id="t1625849336" t="ikitommi when instrumentation is done, there could be a separate doc for function schemas. Lot&apos;s of different aspects (validation, generative testing, instrumentation, linting, ...) to cover."><y>#</y><d>2021-07-09</d><h>16:48</h><w>ikitommi</w>when instrumentation is done, there could be a separate doc for function schemas. Lot&apos;s of different aspects (validation, generative testing, instrumentation, linting, ...) to cover.</z><z id="t1625931700" t="greg Hi, I get my feet wet in malli for the first time. I watched a couple of videos, I read some articules and scrolled the malli readme, and I;m still a bit confused about transformers. I&apos;m trying to create a bigdec? pred and transformator for it, so for given data structure I could coerce selected values from string and number to bigdec . I looked for some examples on the internet. There are some examples of using pre-defined transformers but no examples of custom transformers. I mean, I haven&apos;t checked the code of Malli, I guess, that is the ultimate source of info. Questions I&apos;m trying to answer now: • what are the guidelines for writing transformers? • how to define custom predictor (in similar fashion to string? )? • how to marry a custom predictor with a custom transformer (so when coercing a data structure, the transformer can detect properties to coerce for my custom predictor) Any hints, links, would be very helpful. Thank you 🙇"><y>#</y><d>2021-07-10</d><h>15:41</h><w>greg</w>Hi, I get my feet wet in malli for the first time. I watched a couple of videos, I read some articules and scrolled the malli readme, and I;m still a bit confused about transformers.

I&apos;m trying to create a <code>bigdec?</code> pred and transformator for it, so for given data structure I could coerce selected values from <code>string</code> and <code>number</code> to <code>bigdec</code>.

I looked for some examples on the internet. There are some examples of using pre-defined transformers but no examples of custom transformers. I mean, I haven&apos;t checked the code of Malli, I guess, that is the ultimate source of info.

Questions I&apos;m trying to answer now:
• what are the guidelines for writing transformers?
• how to define custom predictor (in similar fashion to <code>string?</code>)?
• how to marry a custom predictor with a custom transformer (so when coercing a data structure, the transformer can detect properties to coerce for my custom predictor)
Any hints, links, would be very helpful. Thank you <b>🙇</b></z><z id="t1625950441" t="ikitommi good place to start could be this: https://github.com/metosin/malli#simple-schema"><y>#</y><d>2021-07-10</d><h>20:54</h><r>ikitommi</r>good place to start could be this: <a href="https://github.com/metosin/malli#simple-schema" target="_blank">https://github.com/metosin/malli#simple-schema</a></z><z id="t1625950484" t="ikitommi has a custom type, with a custom transformer, generator, json-schema mapping &amp; humanized error dedinition"><y>#</y><d>2021-07-10</d><h>20:54</h><r>ikitommi</r>has a custom type, with a custom transformer, generator, json-schema mapping &amp; humanized error dedinition</z><z id="t1626015604" t="greg I had to miss this part. Thank you"><y>#</y><d>2021-07-11</d><h>15:00</h><r>greg</r>I had to miss this part. Thank you</z><z id="t1626016067" t="greg I used to use Clojure Spec before, but I have never used Plumatic Schema before. I know it might sound ridiculously silly, but I haven&apos;t matched in my couscous mind the word &apos;schema&apos; with a data shape definition. I mean, it makes total sense now, just I so get used to the word &apos;spec&apos;. I don&apos;t know how I was watching this videos and reading these posts without that basic vocabulary understanding 😅"><y>#</y><d>2021-07-11</d><h>15:07</h><r>greg</r>I used to use Clojure Spec before, but I have never used Plumatic Schema before. I know it might sound ridiculously silly, but I haven&apos;t matched in my couscous mind the word &apos;schema&apos; with a data shape definition. I mean, it makes total sense now, just I so get used to the word &apos;spec&apos;. I don&apos;t know how I was watching this videos and reading these posts without that basic vocabulary understanding <b>😅</b></z><z id="t1626066378" t="datran What&apos;s the best way to update the properties of a map entry? I&apos;ve got a schema like [:map [:a :string] [:b :string]] , and I want to transform it into something like [:map [:a :string] [:b {:my-date :foo} :string]] . mu/update-properties only works for the :map -level, so I tried combining it with mu/update and giving a path into the map, but that also doesn&apos;t seem to be what I want. Is there a simpler way to achieve this that I&apos;m overlooking?"><y>#</y><d>2021-07-12</d><h>05:06</h><w>datran</w>What&apos;s the best way to update the properties of a map entry? I&apos;ve got a schema like <code>[:map  [:a :string] [:b :string]]</code>, and I want to transform it into something like <code>[:map [:a :string] [:b {:my-date :foo} :string]]</code>.

<code>mu/update-properties</code> only works for the <code>:map</code>-level, so I tried combining it with <code>mu/update</code> and giving a path into the map, but that also doesn&apos;t seem to be what I want. Is there a simpler way to achieve this that I&apos;m overlooking?</z><z id="t1626190930" t="ikitommi You can walk the children or wait for https://github.com/metosin/malli/pull/466 to be merged"><y>#</y><d>2021-07-13</d><h>15:42</h><r>ikitommi</r>You can walk the children or wait for <a href="https://github.com/metosin/malli/pull/466" target="_blank">https://github.com/metosin/malli/pull/466</a> to be merged</z><z id="t1626191133" t="ikitommi (defn map-children [f schema] (m/-into-schema (m/-parent schema) (m/-properties schema) (map f children) (m/-options schema))) "><y>#</y><d>2021-07-13</d><h>15:45</h><r>ikitommi</r><pre>(defn map-children [f schema]
  (m/-into-schema (m/-parent schema) (m/-properties schema) (map f children) (m/-options schema)))
</pre></z><z id="t1626191185" t="ikitommi that&apos;s the idiomatic way to create a copy of a schema with some changes"><y>#</y><d>2021-07-13</d><h>15:46</h><r>ikitommi</r>that&apos;s the idiomatic way to create a copy of a schema with some changes</z><z id="t1626191133" t="ikitommi (defn map-children [f schema] (m/-into-schema (m/-parent schema) (m/-properties schema) (map f children) (m/-options schema))) "><y>#</y><d>2021-07-13</d><h>15:45</h><w>ikitommi</w><pre>(defn map-children [f schema]
  (m/-into-schema (m/-parent schema) (m/-properties schema) (map f children) (m/-options schema)))
</pre></z><z id="t1626171933" t="greg Is it possible to define a default value for a map entry in terms of other map entry, e.g. there are two keys in a map: primary and secondary . Secondary if missing is set based on primary one."><y>#</y><d>2021-07-13</d><h>10:25</h><w>greg</w>Is it possible to define a default value for a map entry in terms of other map entry, e.g.
there are two keys in a map: <code>primary</code> and <code>secondary</code>. Secondary if missing is set based on primary one.</z><z id="t1626171967" t="greg Schema expressing it could look like this: [:map [:primary string?] [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]] "><y>#</y><d>2021-07-13</d><h>10:26</h><r>greg</r>Schema expressing it could look like this:
<pre>[:map
 [:primary string?]
 [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]]</pre>
</z><z id="t1626174163" t="ikitommi out-of-the-box no, but you can implement this is user space, using a custom transformer. I recommend reading the source code of mt/default-value-transformer. My guess is that you should register the transformer for the map-level, peek the entrys and given there is :default-fn , call it with the map value. Should be streightforward. Could be a nice example into docs/tips.md ..."><y>#</y><d>2021-07-13</d><h>11:02</h><r>ikitommi</r>out-of-the-box no, but you can implement this is user space, using a custom transformer. I recommend reading the source code of <code>mt/default-value-transformer.</code> My guess is that you should register the transformer for the map-level, peek the entrys and given there is <code>:default-fn</code> , call it with the map value. Should be streightforward. Could be a nice example into <code>docs/tips.md</code>...</z><z id="t1626174877" t="greg Thank you!"><y>#</y><d>2021-07-13</d><h>11:14</h><r>greg</r>Thank you!</z><z id="t1626456158" t="greg I had a look today in the default value transformer, and based on what you wrote I&apos;ve made an example of a default value exercised by given function instead of default value (in the current impl). I modified the default-value-transformer to do that. But at the end I realised that I could handle this case: [:map [:primary string?] [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]] but I wouldn&apos;t be able to handle this one: [:map [:primary string?] [:nested [:map [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]] because the given fn receives only current map/submap not the root map? How would you tackle that kind of transformation?"><y>#</y><d>2021-07-16</d><h>17:22</h><r>greg</r>I had a look today in the default value transformer, and based on what you wrote I&apos;ve made an example of a default value exercised by given function instead of default value (in the current impl). I modified the <code>default-value-transformer</code> to do that. But at the end I realised that I could handle this case:
<pre>[:map
 [:primary string?]
 [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]]</pre>
but I wouldn&apos;t be able to handle this one:
<pre>[:map
 [:primary string?]
 [:nested 
  [:map 
   [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]]</pre>
because the given fn receives only current map/submap not the root map? How would you tackle that kind of transformation?</z><z id="t1626456876" t="ikitommi simplest would be just to add a normal transformer into the top-map, which would use normal clojure to transform the whole nested map."><y>#</y><d>2021-07-16</d><h>17:34</h><r>ikitommi</r>simplest would be just to add a normal transformer into the top-map, which would use normal clojure to transform the whole nested map.</z><z id="t1626457134" t="ikitommi you could make it declarative thou, but it&apos;s not simple: 1. add the transformer to the top-level 2. add the declarations to any children 3. use the :compile hook to 1 to get access to the full nested schema 4. within it, walk the schema and collect all the declarations and the paths, create a function to transform the child values 5. on transformation, the &quot;compiled&quot; transformation is applied at the top, knows already what to do, is fast"><y>#</y><d>2021-07-16</d><h>17:38</h><r>ikitommi</r>you could make it declarative thou, but it&apos;s not simple:
1. add the transformer to the top-level
2. add the declarations to any children
3. use the <code>:compile</code> hook to 1 to get access to the full nested schema
4. within it, walk the schema and collect all the declarations and the paths, create a function to transform the child values
5. on transformation, the &quot;compiled&quot; transformation is applied at the top, knows already what to do, is fast</z><z id="t1626457361" t="ikitommi (actually, it is simple) 😉"><y>#</y><d>2021-07-16</d><h>17:42</h><r>ikitommi</r>(actually, it is simple) <b>😉</b></z><z id="t1626459835" t="greg &gt; simplest would be just to add a normal transformer into the top-map, which would use normal clojure to transform the whole nested map. you mean, without Malli? I know, that would be the simplest, but I&apos;m trying to understand malli transformers thoroughly and this problem looks like a good one to understand how Malli transformers works. &gt; actually, it is simple)  😉 I believe you it is simple, but at my stage of understanding malli transformers I&apos;m reading each your response 10 times and it is not enough 🙂 I mean i understand briefly some of the bits already, based on the code and docs, but it it still not enough to understand some of the terminology you use. TBH the first three steps are not really clear to me. What do you mean by &quot;add the transformer to the top-level&quot; &quot;add the declarations to any children&quot; &quot;use the `:compile` hook to 1 to get access to the full nested schema&quot; - I briefly know how the compilation works (preprocessing of the schema and passing discovered data within closured fn into interceptor), but I don&apos;t understand the phrase &quot;hook to 1&quot; --- Also, within (transformer) I noticed that interceptors are created from transformers (from :decoders or :encoders ) and default (from :default-decoder or :default-encoder ). default-value-transformer uses both. I mean, I look at the code and I don&apos;t understand what is it about. Looks like something obvious once you know it. Can you tell what is it about?"><y>#</y><d>2021-07-16</d><h>18:23</h><r>greg</r>&gt; simplest would be just to add a normal transformer into the top-map, which would use normal clojure to transform the whole nested map.
you mean, without Malli? I know, that would be the simplest, but I&apos;m trying to understand malli transformers thoroughly and this problem looks like a good one to understand how Malli  transformers works.

&gt; actually, it is simple) <b>😉</b>
I believe you it is simple, but at my stage of understanding malli transformers I&apos;m reading each your response 10 times and it is not enough <b>🙂</b>

I mean i understand briefly some of the bits already, based on the code and docs, but it it still not enough to understand some of the terminology you use.

TBH the first three steps are not really clear to me.
What do you mean by
&quot;add the transformer to the top-level&quot;
&quot;add the declarations to any children&quot;
&quot;use the `:compile` hook to 1 to get access to the full nested schema&quot; - I briefly know how the compilation works (preprocessing of the schema and passing discovered data within closured fn into interceptor), but I don&apos;t understand the phrase &quot;hook to 1&quot;

---

Also, within <code>(transformer)</code> I noticed that interceptors are created from <code>transformers</code> (from <code>:decoders</code> or <code>:encoders</code>) and <code>default</code> (from <code>:default-decoder</code> or <code>:default-encoder</code>). <code>default-value-transformer</code>  uses both.
I mean, I look at the code and I don&apos;t understand what is it about. Looks like something obvious once you know it. Can you tell what is it about?</z><z id="t1627396088" t="greg I got back to the topic, trying to find all answers to my question. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] would you be so kind to read it and correct or complement if something is missing in the notes below. If the notes are correct, I could polish them a bit, maybe add examples, and add it to the Malli docs if you wish. There is a hierarchy of hooks that Malli handle when transforming values (in this order of priority): • from schema properties: :decode/&lt;name&gt; e.g. :decode/math - provides a transforming fn for a schema enclosing it (to enable, transformer specifying the given name need to be applied e.g. (mt/transformer {:name :math}) • from schema type properties: :decode/&lt;name&gt; e.g. :decode/math - provides a transforming fn for a schema type enclosing it (to enable same as above) • from transformer definition: :decoders , :encoders - provides a map of (schema -&gt; transforming fn), so for the every such schema in the given value&apos;s tree, applies the given fn • from transformer definition: :default-decoder , :default-encoder - provides a last resort transforming fn, so if none of the above transforming fn hooks do not apply, it takes this one. This fn just takes the whole schema, so it might be called a top level hook. Moreover: • :enter /`:leave` refers to the interceptor stages, so we can provide separate transforming fn, they hold directly final functor modifying the the value. The map holding :enter/:leave can be provided by either compiling function or directly. • compiling is the technique exercising values closure. To use it, instead of transforming function, a map {:compile &lt;compiling-fn&gt;} needs to be given. Compiling fun it is a fn taking schema and schema options, and returning a transforming fn. That way, processing of schema specifics can be done once at the time of constructing transformer. "><y>#</y><d>2021-07-27</d><h>14:28</h><r>greg</r>I got back to the topic, trying to find all answers to my question.

<a>@U055NJ5CC</a> would you be so kind to read it and correct or complement if something is missing in the notes below. If the notes are correct, I could polish them a bit, maybe add examples, and add it to the Malli docs if you wish.

There is a hierarchy of hooks that Malli handle when transforming values (in this order of priority):
• from schema properties: <code>:decode/&lt;name&gt;</code> e.g. <code>:decode/math</code> - provides a transforming fn for a schema enclosing it (to enable, transformer specifying the given name need to be applied e.g. <code>(mt/transformer {:name :math})</code>
• from schema type properties: <code>:decode/&lt;name&gt;</code> e.g. <code>:decode/math</code> - provides a transforming fn for a schema type enclosing it (to enable same as above)
• from transformer definition: <code>:decoders</code>, <code>:encoders</code> - provides a map of (schema -&gt; transforming fn), so for the every such schema in the given value&apos;s tree, applies the given fn
• from transformer definition: <code>:default-decoder</code>, <code>:default-encoder</code> - provides a last resort transforming fn, so if none of the above transforming fn hooks do not apply, it takes this one. This fn just takes the whole schema, so it might be called a top level hook.
Moreover:
• <code>:enter</code>/`:leave` refers to the interceptor stages, so we can provide separate transforming fn, they hold directly final functor modifying the the value. The map holding :enter/:leave can be provided by either compiling function or directly.
• compiling is the technique exercising values closure. To use it, instead of transforming function, a map {:compile &lt;compiling-fn&gt;} needs to be given. Compiling fun it is a fn taking schema and schema options, and returning a transforming fn. That way, processing of schema specifics can be done once at the time of constructing transformer.
</z><z id="t1626178136" t="ikitommi WIP: function schema guide. Wanted to push all aspects into single page, so that it’s easier to read what is possible and how the things stack up. Is that any good? something missing feature-wise? have time to polish things this week, comments most welcome: https://github.com/metosin/malli/blob/08111040566e2d39ecff62dfccdcb834f7a23140/docs/function-schemas.md"><y>#</y><d>2021-07-13</d><h>12:08</h><w>ikitommi</w>WIP: function schema guide. Wanted to push all aspects into single page, so that it’s easier to read what is possible and how the things stack up. Is that any good? something missing feature-wise? have time to polish things this week, comments most welcome: <a href="https://github.com/metosin/malli/blob/08111040566e2d39ecff62dfccdcb834f7a23140/docs/function-schemas.md" target="_blank">https://github.com/metosin/malli/blob/08111040566e2d39ecff62dfccdcb834f7a23140/docs/function-schemas.md</a></z><z id="t1626178173" t="ikitommi PR is here for comments &amp; fixes: https://github.com/metosin/malli/pull/471"><y>#</y><d>2021-07-13</d><h>12:09</h><r>ikitommi</r>PR is here for comments &amp; fixes: <a href="https://github.com/metosin/malli/pull/471" target="_blank">https://github.com/metosin/malli/pull/471</a></z><z id="t1626179404" t="greg So actually orchestring project could be done in terms of m/=&gt; , (mi/start!) and (mi/stop!) . Am I correct?"><y>#</y><d>2021-07-13</d><h>12:30</h><r>greg</r>So actually orchestring project could be done in terms of <code>m/=&gt;</code>, <code>(mi/start!)</code> and <code>(mi/stop!)</code>. Am I correct?</z><z id="t1626179944" t="ikitommi yes."><y>#</y><d>2021-07-13</d><h>12:39</h><r>ikitommi</r>yes.</z><z id="t1626178888" t="greg Just a note about orchestrating projects using Malli schemas. I wanted to setup orchestration using malli in a way similar I used to do it with Orchestra. I checked out https://github.com/teknql/aave , https://github.com/setzer22/malli-instrument and https://github.com/CrypticButter/snoop . Snoop: I&apos;ve found it the best one for that purpose. Works fine with functions evaluated in REPL, readable error messages. A bit odd way of enabling it (by using JVM flag), on the other hand once set in dev and test aliases, it just works, for REPL and tests. Also &apos; https://github.com/CrypticButter/snoop#inside-the-prepost-map &apos; syntax for adding function schemas is great. malli-instrument: similar syntax to spec (call instrument-all to instrument), but there are problems with orchestration when you modify and evaluate continuously schemas and functions within REPL. aave: I have had several looks at this library, and its README and TBH I have no idea how to use it. I guess I&apos;m missing some relevant piece of information regarding instrumentation with Malli."><y>#</y><d>2021-07-13</d><h>12:21</h><w>greg</w>Just a note about orchestrating projects using Malli schemas.

I wanted to setup orchestration using malli in a way similar I used to do it with Orchestra. I checked out <a href="https://github.com/teknql/aave" target="_blank">https://github.com/teknql/aave</a>, <a href="https://github.com/setzer22/malli-instrument" target="_blank">https://github.com/setzer22/malli-instrument</a> and <a href="https://github.com/CrypticButter/snoop" target="_blank">https://github.com/CrypticButter/snoop</a>.

Snoop: I&apos;ve found it the best one for that purpose. Works fine with functions evaluated in REPL, readable error messages. A bit odd way of enabling it (by using JVM flag), on the other hand once set in dev and test aliases, it just works, for REPL and tests. Also &apos;<a href="https://github.com/CrypticButter/snoop#inside-the-prepost-map" target="_blank">https://github.com/CrypticButter/snoop#inside-the-prepost-map</a>&apos; syntax for adding function schemas is great.

malli-instrument: similar syntax to spec (call instrument-all to instrument), but there are problems with orchestration when you modify and evaluate continuously schemas and functions within REPL.

aave: I have had several looks at this library, and its README and TBH I have no idea how to use it. I guess I&apos;m missing some relevant piece of information regarding instrumentation with Malli.</z><z id="t1627009893" t="Lucy Wang I also find snoop very handy. To keep the schema inline with the arg name is a huge win (&gt;defn xy*2 [(x :int) (y :int)] [=&gt; :int] (* 2 x y))"><y>#</y><d>2021-07-23</d><h>03:11</h><r>Lucy Wang</r>I also find snoop very handy. To keep the schema inline with the arg name is a huge win
<pre>(&gt;defn xy*2
    [(x :int) (y :int)]
    [=&gt; :int]
    (* 2 x y))</pre></z><z id="t1627039703" t="greg At first it was weird to me that Snoop supports so many options for providing inline schemas, but at the end I used 3 variants and at the 3rd time I found my flavour (just plain [:input :output] ). So I&apos;m kinda glad that Snoop doesn&apos;t enforce to use one particular syntax 🙂 I&apos;m surprised that not that many people use orchestration. Seriously, it is one of the killer features of Clojure. And with Malli and its data-driven approach, it is so pleasant and concise to write and modify specs/schemas. I&apos;m aspiring to deliver to market an accounting software and when refactoring some of the code that does calculations or refactoring, the code orchestration is such a helper, always watching and keeping that invariants are valid."><y>#</y><d>2021-07-23</d><h>11:28</h><r>greg</r>At first it was weird to me that Snoop supports so many options for providing inline schemas, but at the end I used 3 variants and at the 3rd time I found my flavour (just plain <code>[:input :output]</code>). So I&apos;m kinda glad that Snoop doesn&apos;t enforce to use one particular syntax <b>🙂</b>

I&apos;m surprised that not that many people use orchestration. Seriously, it is one of the killer features of Clojure. And with Malli and its data-driven approach, it is so pleasant and concise to write and modify specs/schemas.
I&apos;m aspiring to deliver to market an accounting software and when refactoring some of the code that does calculations or refactoring, the code orchestration is such a helper, always watching and keeping that invariants are valid.</z><z id="t1627100145" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U023TQF5FM3&quot;}] By &quot;orchestration&quot; do you mean https://github.com/jeaye/orchestra ?"><y>#</y><d>2021-07-24</d><h>04:15</h><r>Lucy Wang</r><a>@U023TQF5FM3</a> By &quot;orchestration&quot; do you mean <a href="https://github.com/jeaye/orchestra" target="_blank">https://github.com/jeaye/orchestra</a> ?</z><z id="t1627100291" t="Lucy Wang &gt; at the 3rd time I found my flavour (just plain `[:input :output]`). Which flavor are you talking about?"><y>#</y><d>2021-07-24</d><h>04:18</h><r>Lucy Wang</r>&gt;  at the 3rd time I found my flavour (just plain `[:input :output]`).
Which flavor are you talking about?</z><z id="t1627145279" t="greg I prefer providing schemas in a two elements vector following the params vector. (&gt;defn add [x y] [[:cat int? int?] int?] ...) I found it the nicest to read 🙂 Here is an example: https://github.com/CrypticButter/snoop#more-convenient-notations-that-work-when-using-defn"><y>#</y><d>2021-07-24</d><h>16:47</h><r>greg</r>I prefer providing schemas in a two elements vector following the params vector.
<pre>(&gt;defn add [x y]
  [[:cat int? int?] int?]
  ...)</pre>
I found it the nicest to read <b>🙂</b>

Here is an example:
<a href="https://github.com/CrypticButter/snoop#more-convenient-notations-that-work-when-using-defn" target="_blank">https://github.com/CrypticButter/snoop#more-convenient-notations-that-work-when-using-defn</a></z><z id="t1627145311" t="greg &gt; By &quot;orchestration&quot; do you mean  https://github.com/jeaye/orchestra  ? I use the &quot;orchestration&quot; term for instrumentation of selected methods in a project, so you provide specs/preds/invariants and the tool using instrumentation watches the instrumented functions, either using Orchestra &amp; spec or Snoop &amp; Malli, within your REPL and tests. I think the distinction between these two, is that instrumentation is a technique, while orchestration is a practice that leverages instrumentation."><y>#</y><d>2021-07-24</d><h>16:48</h><r>greg</r>&gt; By &quot;orchestration&quot; do you mean <a href="https://github.com/jeaye/orchestra" target="_blank">https://github.com/jeaye/orchestra</a> ?
I use the &quot;orchestration&quot; term for instrumentation of selected methods in a project, so you provide specs/preds/invariants and the tool using instrumentation watches the instrumented functions, either using Orchestra &amp; spec or Snoop &amp; Malli, within your REPL and tests.

I think the distinction between these two, is that instrumentation is a technique, while orchestration is a practice that leverages instrumentation.</z><z id="t1626179774" t="ikitommi [:attrs {:href &quot;/_/_/users/UBVL1LR5F&quot;}] did you check the guide I just posted? There will be a malli.instrument ns, with common utilities for spec/orchestra-style usage. It&apos;s all built on existing function (var) registry, so no new macros/defn-syntax. It would be great if all defn-wrapping libs could use malli.instrument internally, would keep thing more coherent. Not sure if that is possible thou. All existing libs (aave, Snoop, malli.instrument) are great, just that the core instrumentation belong to the core. Better defn wrappers more welcomed outside."><y>#</y><d>2021-07-13</d><h>12:36</h><w>ikitommi</w><a>@grzegorzrynkowski_clo</a>  did you check the guide I just posted? There will be a <code>malli.instrument</code> ns, with common utilities for spec/orchestra-style usage. It&apos;s all built on existing function (var) registry, so no new macros/defn-syntax. It would be great if all defn-wrapping libs could use malli.instrument internally, would keep thing more coherent. Not sure if that is possible thou. All existing  libs (aave, Snoop, malli.instrument) are great, just that the core instrumentation belong to the core. Better defn wrappers more welcomed outside.</z><z id="t1626180319" t="greg I&apos;ve seen it, just was looking for some ready to go solution right now. When malli.instrument  ns comes, most probably I will reevaluate my setup 🙂"><y>#</y><d>2021-07-13</d><h>12:45</h><r>greg</r>I&apos;ve seen it, just was looking for some ready to go solution right now. When <code>malli.instrument</code> ns comes, most probably I will reevaluate my setup <b>🙂</b></z><z id="t1626182370" t="greg Is there a function to validate schemas&apos; data structures? I was playing with Malli and transformers and I was trying to figure out what is wrong with my custom schema. I tired to coerce data using string-transformer and it didn&apos;t work. It turned out the schema of my schema was wrong. Here is an example showing my problem: (def Order [:map [:qty number?] [:price string? float?]]) (comment (m/validate Order {:qty &quot;1&quot; :price &quot;1.1&quot;}) ; =&gt; false (m/validate Order {:qty 1 :price &quot;1.1&quot;}) ; =&gt; true (m/decode Order {:qty &quot;1&quot; :price &quot;1.1&quot;} mt/string-transformer) ; =&gt; {:qty 1.0, :price &quot;1.1&quot;}, but I expected {:qty 1.0, :price 1.1} (-&gt;&gt; (m/decode Order {:qty &quot;1&quot; :price &quot;1.1&quot;} mt/string-transformer) (m/validate Order))) ; =&gt; true Schema [:price string? float?] is wrong. Unintentionally I forgot to remove string? . Still it is fairly small example, but within complex examples might be difficult to spot it. Would be nice to have a method checking schemas data structures. Is there something like that?"><y>#</y><d>2021-07-13</d><h>13:19</h><w>greg</w>Is there a function to validate schemas&apos; data structures? I was playing with Malli and transformers and I was trying to figure out what is wrong with my custom schema. I tired to coerce data using string-transformer and it didn&apos;t work. It turned out the schema of my schema was wrong.

Here is an example showing my problem:
<pre>(def Order
  [:map
   [:qty number?]
   [:price string? float?]])

(comment
 (m/validate Order {:qty &quot;1&quot; :price &quot;1.1&quot;}) ; =&gt; false
 (m/validate Order {:qty 1 :price &quot;1.1&quot;}) ; =&gt; true
 (m/decode Order {:qty &quot;1&quot; :price &quot;1.1&quot;} mt/string-transformer) ; =&gt; {:qty 1.0, :price &quot;1.1&quot;}, but I expected {:qty 1.0, :price 1.1}
 (-&gt;&gt; (m/decode Order {:qty &quot;1&quot; :price &quot;1.1&quot;} mt/string-transformer)
      (m/validate Order))) ; =&gt; true</pre>
Schema <code>[:price string? float?]</code> is wrong. Unintentionally I forgot to remove <code>string?</code> . Still it is fairly small example, but within complex examples might be difficult to spot it. Would be nice to have a method checking schemas data structures. Is there something like that?</z><z id="t1626183885" t="emccue Sounds like you want a schema for your schemas"><y>#</y><d>2021-07-13</d><h>13:44</h><r>emccue</r>Sounds like you want a schema for your schemas</z><z id="t1626184665" t="ikitommi someone needs to define those for all schemas. Malli supports them already"><y>#</y><d>2021-07-13</d><h>13:57</h><r>ikitommi</r>someone needs to define those for all schemas. Malli supports them already</z><z id="t1626456158" t="greg I had a look today in the default value transformer, and based on what you wrote I&apos;ve made an example of a default value exercised by given function instead of default value (in the current impl). I modified the default-value-transformer to do that. But at the end I realised that I could handle this case: [:map [:primary string?] [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]] but I wouldn&apos;t be able to handle this one: [:map [:primary string?] [:nested [:map [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]] because the given fn receives only current map/submap not the root map? How would you tackle that kind of transformation?"><y>#</y><d>2021-07-16</d><h>17:22</h><w>greg</w>I had a look today in the default value transformer, and based on what you wrote I&apos;ve made an example of a default value exercised by given function instead of default value (in the current impl). I modified the <code>default-value-transformer</code> to do that. But at the end I realised that I could handle this case:
<pre>[:map
 [:primary string?]
 [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]]</pre>
but I wouldn&apos;t be able to handle this one:
<pre>[:map
 [:primary string?]
 [:nested 
  [:map 
   [:secondary {:default-fn &apos;(fn [m] (:primary m))} string?]]</pre>
because the given fn receives only current map/submap not the root map? How would you tackle that kind of transformation?</z><z id="t1627009893" t="Lucy Wang I also find snoop very handy. To keep the schema inline with the arg name is a huge win (&gt;defn xy*2 [(x :int) (y :int)] [=&gt; :int] (* 2 x y))"><y>#</y><d>2021-07-23</d><h>03:11</h><w>Lucy Wang</w>I also find snoop very handy. To keep the schema inline with the arg name is a huge win
<pre>(&gt;defn xy*2
    [(x :int) (y :int)]
    [=&gt; :int]
    (* 2 x y))</pre></z><z id="t1626280537" t="wcalderipe Hey folks, I&apos;m trying to use Malli to parse keys and values of a map to something else but I&apos;m having a bit of difficulty understanding how and what function to use. I&apos;ve tried m/decode and m/parse so far but not with much success. How can I achieve a transformation like the one below using Malli? ;; input {:foobar &quot;baz&quot; :qux &quot;999&quot;} ;; output {:foo :baz ;; Changes the key from :foobar to :foo :qux 999 ;; Coerces the value from string to integer } For context, the use case I have in mind is parsing the response of an API to something else. I&apos;m sharing it because maybe there&apos;s a better way to use Malli for schema checking of services we don&apos;t control plus parsing the data to something else."><y>#</y><d>2021-07-14</d><h>16:35</h><w>wcalderipe</w>Hey folks, I&apos;m trying to use Malli to parse keys and values of a map to something else but I&apos;m having a bit of difficulty understanding how and what function to use. I&apos;ve tried <code>m/decode</code> and <code>m/parse</code> so far but not with much success.

How can I achieve a transformation like the one below using Malli?

<pre>;; input
  {:foobar &quot;baz&quot; 
   :qux    &quot;999&quot;}

;; output
  {:foo :baz ;; Changes the key from :foobar to :foo
   :qux 999  ;; Coerces the value from string to integer 
   }</pre>
For context, the use case I have in mind is parsing the response of an API to something else. I&apos;m sharing it because maybe there&apos;s a better way to use Malli for schema checking of services we don&apos;t control plus parsing the data to something else.</z><z id="t1626282472" t="ikitommi [:attrs {:href &quot;/_/_/users/UHD67JRL4&quot;}] maybe: (def decode (m/decoder [:map [:foo :keyword] [:qux :int]] (mt/transformer (mt/key-transformer {:decode #(get {:foobar :foo} % %)}) (mt/string-transformer)))) (decode {:foobar &quot;baz&quot; :qux &quot;999&quot;}) ; =&gt; {:foo :baz, :qux 999}"><y>#</y><d>2021-07-14</d><h>17:07</h><w>ikitommi</w><a>@wcalderipe</a> maybe:
<pre>(def decode
  (m/decoder
    [:map
     [:foo :keyword]
     [:qux :int]]
    (mt/transformer
      (mt/key-transformer {:decode #(get {:foobar :foo} % %)})
      (mt/string-transformer))))

(decode
  {:foobar &quot;baz&quot;
   :qux &quot;999&quot;})
; =&gt; {:foo :baz, :qux 999}</pre></z><z id="t1626283251" t="wcalderipe Got it.. thanks for taking the time to reply 🙌 I have another question between these lines. Can I reuse the same schema for validating the API response and do the whole transformation? Let&apos;s say we&apos;re integrating a Todo API and we need to do some transformation on their response. ;; Todo API schema as it is (def todo-api [:map [:name [:string {:min 1}]] [:done [:boolean]] [:create_at [:string]]]) (malli/validate todo-api {:name &quot;Ask for help at #malli channel&quot; :done true :create_at &quot;1615007456&quot;}) ;; =&gt; true 1. Validate if responses are following the schema 2. Parse the response to something else as you&apos;ve shown ;; Output {:name &quot;Ask for help at #malli channel&quot; :done true :timestamp 1615007456} ;; Rename the key and transform the value Do I need two schemas 1 for the input and 1 for the output in a scenario like this? :thinking_face:"><y>#</y><d>2021-07-14</d><h>17:20</h><r>wcalderipe</r>Got it.. thanks for taking the time to reply <b>🙌</b>

I have another question between these lines. Can I reuse the same schema for validating the API response and do the whole transformation?

Let&apos;s say we&apos;re integrating a Todo API and we need to do some transformation on their response.

<pre>;; Todo API schema as it is
(def todo-api
  [:map
   [:name [:string {:min 1}]]
   [:done [:boolean]]
   [:create_at [:string]]])

(malli/validate todo-api {:name      &quot;Ask for help at #malli channel&quot;
                          :done      true
                          :create_at &quot;1615007456&quot;})
;; =&gt; true</pre>
1. Validate if responses are following the schema
2. Parse the response to something else as you&apos;ve shown

<pre>;; Output
{:name      &quot;Ask for help at #malli channel&quot;
 :done      true
 :timestamp 1615007456} ;; Rename the key and transform the value</pre>
Do I need two schemas 1 for the input and 1 for the output in a scenario like this? <b>:thinking_face:</b></z><z id="t1626344058" t="greg My understanding is that Malli encourage to transform first and validate next. For example, let&apos;s say data you are receiving are invalid. You decode, validate it. It turned out something is wrong you might want to return an original piece of data by transforming it back (using m/encode) and adding some info what&apos;s wrong. If the response has a different schema by its identity, make sense to have a different schema. Disclaimer, I&apos;m not an expert in Malli 🙂"><y>#</y><d>2021-07-15</d><h>10:14</h><r>greg</r>My understanding is that Malli encourage to transform first and validate next.

For example, let&apos;s say data you are receiving are invalid. You decode, validate it. It turned out something is wrong you might want to return an original piece of data by transforming it back (using m/encode) and adding some info what&apos;s wrong.

If the response has a different schema by its identity, make sense to have a different schema.

Disclaimer, I&apos;m not an expert in Malli <b>🙂</b></z><z id="t1626344652" t="greg So should you have one schema or two, is question are these data same thing or two different things. And answer is not always clear. E.g. In layered architectures, like MVP, depends on implementation you might have several schemas (representation) of the same data."><y>#</y><d>2021-07-15</d><h>10:24</h><r>greg</r>So should you have one schema or two, is question are these data same thing or two different things. And answer is not always clear. E.g. In layered architectures, like MVP, depends on implementation you might have several schemas (representation) of the same data.</z><z id="t1626351481" t="ikitommi if the web-facing values can be mapped automatically to internal values, you should be able to do the same transformation for the schemas too, e.g. define just one and generate the other. Reason for wanting to have two schemas could be apidocs: they should be generated from “web-facing” schemas, not the internal model."><y>#</y><d>2021-07-15</d><h>12:18</h><r>ikitommi</r>if the web-facing values can be mapped automatically to internal values, you should be able to do the same transformation for the schemas too, e.g. define just one and generate the other. Reason for wanting to have two schemas could be apidocs: they should be generated from “web-facing” schemas, not the internal model.</z><z id="t1626351493" t="ikitommi related: https://www.metosin.fi/blog/malli/#schema-transformation"><y>#</y><d>2021-07-15</d><h>12:18</h><r>ikitommi</r>related: <a href="https://www.metosin.fi/blog/malli/#schema-transformation" target="_blank">https://www.metosin.fi/blog/malli/#schema-transformation</a></z><z id="t1626351612" t="ikitommi not sure if there are all the needed helpers in malli.util , but easy to add if something is missing."><y>#</y><d>2021-07-15</d><h>12:20</h><r>ikitommi</r>not sure if there are all the needed helpers in <code>malli.util</code> , but easy to add if something is missing.</z><z id="t1626415242" t="wcalderipe Thanks for taking the time [:attrs {:href &quot;/_/_/users/UBVL1LR5F&quot;}] &gt; E.g. In layered architectures, like MVP, depends on implementation you might have several schemas (representation) of the same data. I think the problem I have in mind, the data means the same thing but it has a different shape inside the boundaries of my app. Malli will be used near to the edges of the app into something like an anti-corruption layer to translate an external concept to an internal one. That&apos;s renaming some keys and coerce some of the values too."><y>#</y><d>2021-07-16</d><h>06:00</h><r>wcalderipe</r>Thanks for taking the time <a>@UBVL1LR5F</a>

&gt; E.g. In layered architectures, like MVP, depends on implementation you might have several schemas (representation) of the same data.
I think the problem I have in mind, the data means the same thing but it has a different shape inside the boundaries of my app.  Malli will be used near to the edges of the app into something like an anti-corruption layer to translate an external concept to an internal one. That&apos;s renaming some keys and coerce some of the values too.</z><z id="t1626441768" t="greg If the Malli resides only on the one side of the ACL architecture, on the internal one, I think you could work with one schema. If both would use Malli, then I would go with two. Going back to you question &gt; Can I reuse the same schema for validating the API response and do the whole transformation? I think yes, you could use one. You received response from external (behind ACL) system, you transform (including the keys) and then validate."><y>#</y><d>2021-07-16</d><h>13:22</h><r>greg</r>If the Malli resides only on the one side of the ACL architecture, on the internal one, I think you could work with one schema. If both would use Malli, then I would go with two.

Going back to you question
&gt;  Can I reuse the same schema for validating the API response and do the whole transformation?
I think yes, you could use one. You received response from external (behind ACL) system, you transform (including the keys) and then validate.</z><z id="t1626441850" t="greg If you want validate first for some reason, you might need two."><y>#</y><d>2021-07-16</d><h>13:24</h><r>greg</r>If you want validate first for some reason, you might need two.</z><z id="t1626510245" t="wcalderipe Thanks for sharing [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] My doubt is more a question of design than which functions to use. [:attrs {:href &quot;/_/_/users/UBVL1LR5F&quot;}] got it... &gt; If you want validate first for some reason, you might need two. Yeah, I think I&apos;ll end up with two instead of one because I was thinking of doing validations as well in development mode. Thanks a bunch for the help!"><y>#</y><d>2021-07-17</d><h>08:24</h><r>wcalderipe</r>Thanks for sharing <a>@U055NJ5CC</a>

My doubt is more a question of design than which functions to use.

<a>@UBVL1LR5F</a> got it...

&gt; If you want validate first for some reason, you might need two.
Yeah, I think I&apos;ll end up with two instead of one because I was thinking of doing validations as well in development mode.

Thanks a bunch for the help!</z><z id="t1626353105" t="ikitommi merged malli.instrument PR into master. will be released as part of 0.6.0 later. test reports, feedback, improvements welcome! the new function guide is here: https://github.com/metosin/malli/blob/master/docs/function-schemas.md 😎"><y>#</y><d>2021-07-15</d><h>12:45</h><w>ikitommi</w>merged <code>malli.instrument</code> PR into master. will be released as part of 0.6.0 later. test reports, feedback, improvements welcome! the new function guide is here: <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md</a> <b>😎</b></z><z id="t1626428797" t="hansbugge Hi, I&apos;m experiencing something funny with humanize in Malli 0.5.1. When the wrapper function returns a string, then the :malli/error key gets an entry for each error, but when it returns anything but a string then there will be only one error under :malli/error . (-&gt; (m/explain [:and [:fn (constantly false)] [:fn (constantly false)]] {:a :map}) (me/humanize {:wrap (constantly &quot;a string&quot;)})) ;; =&gt; #:malli{:error [&quot;a string&quot; &quot;a string&quot;]} (-&gt; (m/explain [:and [:fn (constantly false)] [:fn (constantly false)]] {:a :map}) (me/humanize {:wrap (constantly :not-a-string)})) ;; =&gt; #:malli{:error [:not-a-string]}"><y>#</y><d>2021-07-16</d><h>09:46</h><w>hansbugge</w>Hi, I&apos;m experiencing something funny with humanize in Malli 0.5.1.  When the wrapper function returns a string, then the <code>:malli/error</code> key gets an entry for each error, but when it returns anything but a string then there will be only one error under <code>:malli/error</code>.
<pre>(-&gt; (m/explain [:and
                [:fn (constantly false)]
                [:fn (constantly false)]]
               {:a :map})
    (me/humanize {:wrap (constantly &quot;a string&quot;)}))
;; =&gt; #:malli{:error [&quot;a string&quot; &quot;a string&quot;]}

(-&gt; (m/explain [:and
                [:fn (constantly false)]
                [:fn (constantly false)]]
               {:a :map})
    (me/humanize {:wrap (constantly :not-a-string)}))
;; =&gt; #:malli{:error [:not-a-string]}</pre></z><z id="t1626428886" t="hansbugge And I&apos;m having a hard time understanding why from looking at the source. Am I right that this is a bug?"><y>#</y><d>2021-07-16</d><h>09:48</h><r>hansbugge</r>And I&apos;m having a hard time understanding why from looking at the source.  Am I right that this is a bug?</z><z id="t1626429390" t="hansbugge It seems to be the form (if (-just-error? v) (into (vec e) v) v) in malli.error/-put , where -just-error? only returns true if the value is exactly a vector with one string"><y>#</y><d>2021-07-16</d><h>09:56</h><r>hansbugge</r>It seems to be the form <code>(if (-just-error? v) (into (vec e) v) v)</code> in <code>malli.error/-put</code>, where <code>-just-error?</code> only returns true if the value is exactly a vector with one string</z><z id="t1626429689" t="hansbugge My problem is that we&apos;re using explainers and humanize to generate structured form validation output, where the wrapper passed to humanize generates a map with the error message and a couple of other fields. But this means we get at most one error in :malli/error ."><y>#</y><d>2021-07-16</d><h>10:01</h><r>hansbugge</r>My problem is that we&apos;re using explainers and humanize to generate structured form validation output, where the wrapper passed to humanize generates a map with the error message and a couple of other fields.  But this means we get at most one error in <code>:malli/error</code>.</z><z id="t1626443287" t="ikitommi just wrote a issue based on old PR to make the :and error handling more robust, e.g. take the first error form and accumulate to that. Not sure if that would help here, but coming anyway: https://github.com/metosin/malli/issues/476"><y>#</y><d>2021-07-16</d><h>13:48</h><r>ikitommi</r>just wrote a issue based on old PR to make the <code>:and</code> error handling more robust, e.g. take the first error form and accumulate to that. Not sure if that would help here, but coming anyway: <a href="https://github.com/metosin/malli/issues/476" target="_blank">https://github.com/metosin/malli/issues/476</a></z><z id="t1626450322" t="ikitommi nice to see how things click while developing malli. • in spec1, s/and flows conformed values, which is IMO not intutive, but needed for special cases (e.g. parsing sequential input), source of much confusion • in spec1, s/cat forced things to be named, need you it or not • in spec2, there might be a non-conforming variant and&apos; , most likely no cat&apos; thou. with malli, the simple syntax is the default and you can detail it (named branches, parsed childs) [:attrs nil] Spec has amazing ideas and personally is a big source of inspiration. The Malli evolution: Given: (defn distance [min max] (- max min) Simplest description: ;; int int -&gt; int [:=&gt; [:cat :int :int] :int] Adding names: ;; min:int max:int -&gt; int [:=&gt; [:catn [:min :int] [:max :int]] :int] Adding constraints on input (with new parsed utility schema): ;; min:int max:int [min &lt; max] -&gt; int [:=&gt; [:and [:catn [:min :int] [:max :int]] ;; here we want to used parsed values instead of orginal sequence [:parsed [:fn {:error/message &quot;min should be lass than max&quot;} (fn [{:keys [min max]}] (&lt; min max))]]] :int]"><y>#</y><d>2021-07-16</d><h>15:45</h><w>ikitommi</w>nice to see how things click while developing malli.
• in spec1, <code>s/and</code> flows conformed values, which is IMO not intutive, but needed for special cases (e.g. parsing sequential input), source of much confusion
• in spec1, <code>s/cat</code> forced things to be named, need you it or not
• in spec2, there might be a non-conforming variant <code>and&apos;</code>,  most likely no <code>cat&apos;</code> thou.
with malli, the simple syntax is the default and you can detail it (named branches, parsed childs) <b>if needed.</b> Spec has amazing ideas and personally is a big source of inspiration. The Malli evolution:

Given:
<pre>(defn distance [min max] 
  (- max min)</pre>
Simplest description:
<pre>;; int int -&gt; int
[:=&gt; [:cat :int :int] :int]</pre>
Adding names:
<pre>;; min:int max:int -&gt; int
[:=&gt; [:catn [:min :int] [:max :int]] :int]</pre>
Adding constraints on input (with new <code>parsed</code> utility schema):
<pre>;; min:int max:int [min &lt; max] -&gt; int
[:=&gt;
 [:and
  [:catn
   [:min :int]
   [:max :int]]
  ;; here we want to used parsed values instead of orginal sequence
  [:parsed
   [:fn
    {:error/message &quot;min should be lass than max&quot;}
    (fn [{:keys [min max]}] (&lt; min max))]]]
 :int]</pre></z><z id="t1626457167" t="greg Haha, I&apos;ve spend a couple of hours trying to understand the logic behind it recursive traversal of transformers until I discovered it is at the Schema implementation, in the transformer- fn 😄"><y>#</y><d>2021-07-16</d><h>17:39</h><w>greg</w>Haha, I&apos;ve spend a couple of hours trying to understand the logic behind it recursive traversal of transformers until I discovered it is at the Schema implementation, in the <code>transformer-</code>  fn <b>😄</b></z><z id="t1626498421" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , hi! I&apos;ve tried to run static type checking using FileWatchers + clj-kondo. Can&apos;t see any effect for plus1 . clj-kondo works well. malli version 0.6.0-snapshot"><y>#</y><d>2021-07-17</d><h>05:07</h><w>mike_ananev</w><a>@ikitommi</a> , hi! I&apos;ve tried to run static type checking using FileWatchers + clj-kondo.  Can&apos;t see any effect for <code>plus1</code>. clj-kondo works well. malli version 0.6.0-snapshot</z><z id="t1626512762" t="ikitommi did you add the clj-kondo configs for malli? Not sure if that could be automatic in the future? Maybe [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] knows? https://github.com/metosin/malli#clj-kondo"><y>#</y><d>2021-07-17</d><h>09:06</h><r>ikitommi</r>did you add the clj-kondo configs for malli? Not sure if that could be automatic in the future? Maybe <a>@U04V15CAJ</a> knows? <a href="https://github.com/metosin/malli#clj-kondo" target="_blank">https://github.com/metosin/malli#clj-kondo</a></z><z id="t1626513078" t="ikitommi e.g. ✗ cat .clj-kondo/config.edn {:config-paths [&quot;configs/malli&quot;]}"><y>#</y><d>2021-07-17</d><h>09:11</h><r>ikitommi</r>e.g.
<pre>✗ cat .clj-kondo/config.edn
{:config-paths [&quot;configs/malli&quot;]}</pre></z><z id="t1626514965" t="borkdude configs are never opted into automatically"><y>#</y><d>2021-07-17</d><h>09:42</h><r>borkdude</r>configs are never opted into automatically</z><z id="t1626514982" t="borkdude by design, you should opt into those manually, for safety and consistency reasons"><y>#</y><d>2021-07-17</d><h>09:43</h><r>borkdude</r>by design, you should opt into those manually, for safety and consistency reasons</z><z id="t1626516467" t="ikitommi Sounds right. But is there a default directory I could write the config file to, without breaking anything?"><y>#</y><d>2021-07-17</d><h>10:07</h><r>ikitommi</r>Sounds right. But is there a default directory I could write the config file to, without breaking anything?</z><z id="t1626516509" t="borkdude it&apos;s best to write into a directory with a fully qualified name like com.metosin.malli or so"><y>#</y><d>2021-07-17</d><h>10:08</h><r>borkdude</r>it&apos;s best to write into a directory with a fully qualified name like <code>com.metosin.malli</code> or so</z><z id="t1626516516" t="borkdude to avoid conflicts"><y>#</y><d>2021-07-17</d><h>10:08</h><r>borkdude</r>to avoid conflicts</z><z id="t1626516530" t="borkdude or just the domain name of your library"><y>#</y><d>2021-07-17</d><h>10:08</h><r>borkdude</r>or just the domain name of your library</z><z id="t1626516972" t="ikitommi good idea. but despite being fully qualified, users need to enable that config in their projects, right? no option to &quot;trust &apos;em all&quot;?"><y>#</y><d>2021-07-17</d><h>10:16</h><r>ikitommi</r>good idea. but despite being fully qualified, users need to enable that config in their projects, right? no option to &quot;trust &apos;em all&quot;?</z><z id="t1626517060" t="borkdude &gt; by design, you should opt into those manually, for safety and consistency reasons"><y>#</y><d>2021-07-17</d><h>10:17</h><r>borkdude</r>&gt; by design, you should opt into those manually, for safety and consistency reasons</z><z id="t1626517065" t="borkdude ;)"><y>#</y><d>2021-07-17</d><h>10:17</h><r>borkdude</r>;)</z><z id="t1626517094" t="borkdude you should just add that dir to your config paths, that&apos;s it"><y>#</y><d>2021-07-17</d><h>10:18</h><r>borkdude</r>you should just add that dir to your config paths, that&apos;s it</z><z id="t1626517114" t="borkdude any tool can dump any config into the dir, but it&apos;s not always something a user wants to opt into"><y>#</y><d>2021-07-17</d><h>10:18</h><r>borkdude</r>any tool can dump any config into the dir, but it&apos;s not always something a user wants to opt into</z><z id="t1626517162" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] you was right! I added {:config-paths [&quot;configs/malli&quot;]} to .clj-kondo/config.edn and now clj-kondo works well with malli static type checking"><y>#</y><d>2021-07-17</d><h>10:19</h><r>mike_ananev</r><a>@ikitommi</a> you was right! I added <code>{:config-paths [&quot;configs/malli&quot;]}</code> to .clj-kondo/config.edn and now clj-kondo works well with malli static type checking</z><z id="t1626517163" t="borkdude yesterday I had such a report where clojure-lsp dumped a config into the dir, but a user did not want to have this config"><y>#</y><d>2021-07-17</d><h>10:19</h><r>borkdude</r>yesterday I had such a report where clojure-lsp dumped a config into the dir, but a user did not want to have this config</z><z id="t1626498430" t="mike_ananev"><y>#</y><d>2021-07-17</d><h>05:07</h><w>mike_ananev</w></z><z id="t1626603846" t="Vincent Cantin I have a schema that parses a value correctly but then the unparse operation returns :malli.core/invalid . Is it a known problem for some kind of schema or should I post a bug report?"><y>#</y><d>2021-07-18</d><h>10:24</h><w>Vincent Cantin</w>I have a schema that parses a value correctly but then the unparse operation returns <code>:malli.core/invalid</code>. Is it a known problem for some kind of schema or should I post a bug report?</z><z id="t1626608362" t="Vincent Cantin To reproduce: (let [my-schema (m/schema [:and list? [:catn [:wrapper [:= &apos;value]] [:wrapped int?]]])] (-&gt;&gt; (m/parse my-schema &apos;(value 5)) (m/unparse my-schema)))"><y>#</y><d>2021-07-18</d><h>11:39</h><r>Vincent Cantin</r>To reproduce:
<pre>(let [my-schema (m/schema
                  [:and
                   list?
                   [:catn
                    [:wrapper [:= &apos;value]]
                    [:wrapped int?]]])]
  (-&gt;&gt; (m/parse my-schema &apos;(value 5))
       (m/unparse my-schema)))</pre></z><z id="t1626608430" t="Vincent Cantin m/unparse works if I remove list? from the schema, but then it&apos;s not the schema I need."><y>#</y><d>2021-07-18</d><h>11:40</h><r>Vincent Cantin</r><code>m/unparse</code> works if I remove <code>list?</code> from the schema, but then it&apos;s not the schema I need.</z><z id="t1626609277" t="Vincent Cantin Is there an option in catn to specify the list of container of the sequence?"><y>#</y><d>2021-07-18</d><h>11:54</h><r>Vincent Cantin</r>Is there an option in <code>catn</code> to specify the list of container of the sequence?</z><z id="t1626613031" t="ikitommi currently no, but definetely it should."><y>#</y><d>2021-07-18</d><h>12:57</h><r>ikitommi</r>currently no, but definetely it should.</z><z id="t1626613079" t="ikitommi maybe something like? [:cat {:type :vector} :int :int]"><y>#</y><d>2021-07-18</d><h>12:57</h><r>ikitommi</r>maybe something like?
<pre>[:cat {:type :vector} :int :int]</pre></z><z id="t1626613163" t="Vincent Cantin yes, but the name &quot;type&quot; is not descriptive enough as it relates to the container&apos;s type and not the sequence itself."><y>#</y><d>2021-07-18</d><h>12:59</h><r>Vincent Cantin</r>yes, but the name &quot;type&quot; is not descriptive enough as it relates to the container&apos;s type and not the sequence itself.</z><z id="t1626613251" t="Vincent Cantin In minimallist, I named it &quot;coll-type&quot; https://github.com/green-coder/minimallist/blob/all-work-and-no-play/src/minimallist/helper.cljc#L72-L76"><y>#</y><d>2021-07-18</d><h>13:00</h><r>Vincent Cantin</r>In minimallist, I named it &quot;coll-type&quot; <a href="https://github.com/green-coder/minimallist/blob/all-work-and-no-play/src/minimallist/helper.cljc#L72-L76" target="_blank">https://github.com/green-coder/minimallist/blob/all-work-and-no-play/src/minimallist/helper.cljc#L72-L76</a></z><z id="t1626613329" t="Vincent Cantin Right now, I am trying to port my model from minimallist to malli in the Vrac project, so I have less things to maintain and it&apos;s better for the users if they face a mainstream library like Malli."><y>#</y><d>2021-07-18</d><h>13:02</h><r>Vincent Cantin</r>Right now, I am trying to port my model from minimallist to malli in the Vrac project, so I have less things to maintain and it&apos;s better for the users if they face a mainstream library like Malli.</z><z id="t1626614061" t="ikitommi have you checked the bundle size? malli starts from ~2kb (just the minimal working set of schemas), but is quite big if all schemas are used (40kb?). with all the bells &amp; whistles, it can be &gt;100kb."><y>#</y><d>2021-07-18</d><h>13:14</h><r>ikitommi</r>have you checked the bundle size? malli starts from ~2kb (just the minimal working set of schemas), but is quite big if all schemas are used (40kb?). with all the bells &amp; whistles, it can be &gt;100kb.</z><z id="t1626614121" t="ikitommi I’m not sure how :type and :coll-type are that different, but something like that would be good."><y>#</y><d>2021-07-18</d><h>13:15</h><r>ikitommi</r>I’m not sure how <code>:type</code> and <code>:coll-type</code> are that different, but something like that would be good.</z><z id="t1626614243" t="Vincent Cantin :type will be fine"><y>#</y><d>2021-07-18</d><h>13:17</h><r>Vincent Cantin</r><code>:type</code> will be fine</z><z id="t1626614930" t="Vincent Cantin the bundle size won&apos;t be a problem, I can parse things offline."><y>#</y><d>2021-07-18</d><h>13:28</h><r>Vincent Cantin</r>the bundle size won&apos;t be a problem, I can parse things offline.</z><z id="t1626632181" t="Vincent Cantin :tuple would also need to have the {:type :list} option."><y>#</y><d>2021-07-18</d><h>18:16</h><r>Vincent Cantin</r><code>:tuple</code> would also need to have the <code>{:type :list}</code> option.</z><z id="t1626604225" t="Vincent Cantin While chaining parse and unparse , I realized that the API would be more friendly to -&gt; if the parameter order of ?schema and value were exchanged."><y>#</y><d>2021-07-18</d><h>10:30</h><w>Vincent Cantin</w>While chaining <code>parse</code> and <code>unparse</code>, I realized that the API would be more friendly to <code>-&gt;</code> if the parameter order of <code>?schema</code> and <code>value</code> were exchanged.</z><z id="t1626613331" t="ikitommi did a quick run on improving performance of collection transformations, got easy x5 for CLJ in simple test: (let [schema [:map [:id :string] [:type :keyword] [:address [:map [:street :string] [:lonlat [:tuple :double :double]]]]] decode (m/decoder schema (mt/json-transformer)) json {:id &quot;pulla&quot; :type &quot;herkku&quot; :address {:street &quot;hämeenkatu 14&quot; :lonlat [61 23.7644223]}}] ;; 920ns =&gt; 160ns (cc/quick-bench (decode json)))"><y>#</y><d>2021-07-18</d><h>13:02</h><w>ikitommi</w>did a quick run on improving performance of collection transformations, got easy x5 for CLJ in simple test:
<pre>(let [schema [:map
              [:id :string]
              [:type :keyword]
              [:address
               [:map
                [:street :string]
                [:lonlat [:tuple :double :double]]]]]
      decode (m/decoder schema (mt/json-transformer))
      json {:id &quot;pulla&quot;
            :type &quot;herkku&quot;
            :address {:street &quot;hämeenkatu 14&quot;
                      :lonlat [61 23.7644223]}}]
  ;; 920ns =&gt; 160ns
  (cc/quick-bench
    (decode json)))</pre></z><z id="t1626613504" t="ikitommi also, coercion (transform + validate) is 5x faster with that data compared to Plumatic Schema. Which is kinda nice as have considered (the awesome) Plumatic as a performance reference."><y>#</y><d>2021-07-18</d><h>13:05</h><w>ikitommi</w>also, coercion (transform + validate) is 5x faster with that data compared to Plumatic Schema. Which is kinda nice as have considered (the awesome) Plumatic as a performance reference.</z><z id="t1626613525" t="ikitommi merged in master."><y>#</y><d>2021-07-18</d><h>13:05</h><w>ikitommi</w>merged in master.</z><z id="t1626613556" t="ikitommi https://github.com/metosin/malli/pull/478"><y>#</y><d>2021-07-18</d><h>13:05</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/478" target="_blank">https://github.com/metosin/malli/pull/478</a></z><z id="t1626614058" t="Ben Sless I think you can close over the iteration completely"><y>#</y><d>2021-07-18</d><h>13:14</h><r>Ben Sless</r>I think you can close over the iteration completely</z><z id="t1626615749" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] you can gain at least 10% and probably gain some mechanical sympathy by closing over the transforms: (map (fn [[k v]] (fn [^Associative x] (if-let [xe (.entryAt x k)] (.assoc x k (v (.val xe))) x))) ts) then reduce over them with -comp"><y>#</y><d>2021-07-18</d><h>13:42</h><r>Ben Sless</r><a>@U055NJ5CC</a> you can gain at least 10% and probably gain some mechanical sympathy by closing over the transforms:
<pre>(map
 (fn [[k v]]
   (fn [^Associative x]
     (if-let [xe (.entryAt x k)]
       (.assoc x k (v (.val xe)))
       x)))
 ts)</pre>
then reduce over them with <code>-comp</code></z><z id="t1626616037" t="Ben Sless I can PR this if you&apos;d like"><y>#</y><d>2021-07-18</d><h>13:47</h><r>Ben Sless</r>I can PR this if you&apos;d like</z><z id="t1626634723" t="ikitommi looks good. But, I thing the varargs version of -comp is actually slow as it uses the sequence abstraction, could be rewritten to use iterator? PR (and perf test before &amp; after) most welcome."><y>#</y><d>2021-07-18</d><h>18:58</h><r>ikitommi</r>looks good. But, I thing the varargs version of <code>-comp</code> is actually slow as it uses the sequence abstraction, could be rewritten to use iterator? PR (and perf test before &amp; after) most welcome.</z><z id="t1626634907" t="Ben Sless I unrolled it to 16 args"><y>#</y><d>2021-07-18</d><h>19:01</h><r>Ben Sless</r>I unrolled it to 16 args</z><z id="t1626636110" t="ikitommi 👍"><y>#</y><d>2021-07-18</d><h>19:21</h><r>ikitommi</r><b>👍</b></z><z id="t1626636159" t="ikitommi already this is much faster that the current: (defn -comp ([] identity) ([f] f) ([f g] (fn [x] (f (g x)))) ([f g h] (fn [x] (f (g (h x))))) ([f1 f2 f3 &amp; fs] (let [fs (into [f1 f2 f3] fs)] (fn [x] (let [i (.iterator ^Iterable fs)] (loop [x x] (if (.hasNext i) (recur ((.next i) x)) x)))))))"><y>#</y><d>2021-07-18</d><h>19:22</h><r>ikitommi</r>already this is much faster that the current:
<pre>(defn -comp
  ([] identity)
  ([f] f)
  ([f g] (fn [x] (f (g x))))
  ([f g h] (fn [x] (f (g (h x)))))
  ([f1 f2 f3 &amp; fs]
   (let [fs (into [f1 f2 f3] fs)]
     (fn [x] (let [i (.iterator ^Iterable fs)]
               (loop [x x] (if (.hasNext i) (recur ((.next i) x)) x)))))))</pre></z><z id="t1626637532" t="Ben Sless I&apos;ll send an organized PR tomorrow, today is getting late"><y>#</y><d>2021-07-18</d><h>19:45</h><r>Ben Sless</r>I&apos;ll send an organized PR tomorrow, today is getting late</z><z id="t1626680477" t="Ben Sless I wonder if there&apos;s an optimal maximum arity"><y>#</y><d>2021-07-19</d><h>07:41</h><r>Ben Sless</r>I wonder if there&apos;s an optimal maximum arity</z><z id="t1626613527" t="Ben Sless 👀"><y>#</y><d>2021-07-18</d><h>13:05</h><w>Ben Sless</w><b>👀</b></z><z id="t1626613652" t="ikitommi My initial thought was that having transform and validation as separate steps can actually make it faster - as the created transformation chain is usually small enough to fit into the JVM inlining budget - while validation is always “complete” and generated more code. Having those in one sweep means more code. Haven’t looked at the perf profile, so just quessing."><y>#</y><d>2021-07-18</d><h>13:07</h><w>ikitommi</w>My initial thought was that having transform and validation as separate steps can actually make it faster - as the created transformation chain is usually small enough to fit into the JVM inlining budget - while validation is always “complete” and generated more code. Having those in one sweep means more code. Haven’t looked at the perf profile, so just quessing.</z><z id="t1626613816" t="Ben Sless I was just thinking about this recently - would interleaving transform and validation be faster? Since it involves lots of iteration and allocation, we can&apos;t necessarily assume JIT friendly code would be faster than a single pass over two passes"><y>#</y><d>2021-07-18</d><h>13:10</h><r>Ben Sless</r>I was just thinking about this recently - would interleaving transform and validation be faster? Since it involves lots of iteration and allocation, we can&apos;t necessarily assume JIT friendly code would be faster than a single pass over two passes</z><z id="t1626613692" t="Ben Sless &gt; entryAt 😄"><y>#</y><d>2021-07-18</d><h>13:08</h><w>Ben Sless</w>&gt; <code>entryAt</code>
<b>😄</b></z><z id="t1626613759" t="ikitommi"><y>#</y><d>2021-07-18</d><h>13:09</h><w>ikitommi</w></z><z id="t1626613799" t="ikitommi the initial code was using reduce for all, which does a lot of things."><y>#</y><d>2021-07-18</d><h>13:09</h><w>ikitommi</w>the initial code was using <code>reduce</code> for all, which does a lot of things.</z><z id="t1626613847" t="ikitommi stack size from 36 -&gt; 6 (on malli side)."><y>#</y><d>2021-07-18</d><h>13:10</h><w>ikitommi</w>stack size from 36 -&gt; 6 (on malli side).</z><z id="t1626613914" t="ikitommi but thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] for the validation perf, mostly same optimizations for transformers 🙇"><y>#</y><d>2021-07-18</d><h>13:11</h><w>ikitommi</w>but thanks <a>@ben.sless</a> for the validation perf, mostly same optimizations for transformers <b>🙇</b></z><z id="t1626613957" t="Ben Sless I thought it looked familiar :thinking_face:"><y>#</y><d>2021-07-18</d><h>13:12</h><r>Ben Sless</r>I thought it looked familiar <b>:thinking_face:</b></z><z id="t1626613977" t="Ben Sless 😄"><y>#</y><d>2021-07-18</d><h>13:12</h><r>Ben Sless</r><b>😄</b></z><z id="t1626614226" t="ikitommi reduce-kv should be fast, but for some reason, it’s not always used instead of reduce . Recall there was a related bug in clojure for this. writing by hand is always fast 🙂"><y>#</y><d>2021-07-18</d><h>13:17</h><r>ikitommi</r><code>reduce-kv</code> should be fast, but for some reason, it’s not always used instead of <code>reduce</code>. Recall there was a related bug in clojure for this. writing by hand is always fast <b>🙂</b></z><z id="t1626614843" t="Ben Sless Have you had a chance to look at my proposal on https://github.com/metosin/malli/issues/474 ?"><y>#</y><d>2021-07-18</d><h>13:27</h><w>Ben Sless</w>Have you had a chance to look at my proposal on <a href="https://github.com/metosin/malli/issues/474" target="_blank">https://github.com/metosin/malli/issues/474</a>?</z><z id="t1626615974" t="Ben Sless I have no idea how to compile my proposal to something efficient, though I assume it is possible and someone clever like nilern could do it"><y>#</y><d>2021-07-18</d><h>13:46</h><r>Ben Sless</r>I have no idea how to compile my proposal to something efficient, though I assume it is possible and someone clever like nilern could do it</z><z id="t1626638820" t="Vincent Cantin It is possible in Malli to write a schema which represent Clojure&apos;s destructurations of a map? For example, something which would parse this kind of data: {a :a b :b :keys [c d] :e/keys [f g] :as h}"><y>#</y><d>2021-07-18</d><h>20:07</h><w>Vincent Cantin</w>It is possible in Malli to write a schema which represent Clojure&apos;s destructurations of a map? For example, something which would parse this kind of data:
<pre>{a :a
 b :b
 :keys [c d]
 :e/keys [f g]
 :as h}</pre></z><z id="t1626680946" t="ikitommi I don&apos;t think there is. Does spec have something for this?"><y>#</y><d>2021-07-19</d><h>07:49</h><r>ikitommi</r>I don&apos;t think there is. Does spec have something for this?</z><z id="t1626680973" t="ikitommi and what would be the expected parse result?"><y>#</y><d>2021-07-19</d><h>07:49</h><r>ikitommi</r>and what would be the expected parse result?</z><z id="t1626681119" t="Vincent Cantin I don&apos;t know if spec can do something like that. In minimallist, I approach this problem by having map-of taking a schema of a pair [key value], so I am able to use :alt on the pair to valid multiple different cases where the key and the value are correlated."><y>#</y><d>2021-07-19</d><h>07:51</h><r>Vincent Cantin</r>I don&apos;t know if spec can do something like that. In minimallist, I approach this problem by having <code>map-of</code> taking a schema of a pair [key value], so I am able to use :alt on the pair to valid multiple different cases where the key and the value are correlated.</z><z id="t1626681135" t="ikitommi maybe m/parse could have a custom user-defined property to allow users to give the parse &amp; unparse functions for the given schema."><y>#</y><d>2021-07-19</d><h>07:52</h><r>ikitommi</r>maybe  <code>m/parse</code> could have a custom user-defined property to allow users to give the parse &amp; unparse functions for the given schema.</z><z id="t1626681205" t="Vincent Cantin An escape hatch, yes it would work, but the hardship would be on the user."><y>#</y><d>2021-07-19</d><h>07:53</h><r>Vincent Cantin</r>An escape hatch, yes it would work, but the hardship would be on the user.</z><z id="t1626681211" t="ikitommi could you write a minimallist sample for that case? Sounds interesting"><y>#</y><d>2021-07-19</d><h>07:53</h><r>ikitommi</r>could you write a minimallist sample for that case? Sounds interesting</z><z id="t1626681219" t="Vincent Cantin Here it is: https://github.com/green-coder/vrac/blob/diy-furry/src/vrac/model.cljc#L25-L30"><y>#</y><d>2021-07-19</d><h>07:53</h><r>Vincent Cantin</r>Here it is: <a href="https://github.com/green-coder/vrac/blob/diy-furry/src/vrac/model.cljc#L25-L30" target="_blank">https://github.com/green-coder/vrac/blob/diy-furry/src/vrac/model.cljc#L25-L30</a></z><z id="t1626681388" t="Vincent Cantin The escape hatch may not work well for the user in the case the model is using recursion, like in this example. That would become Malli -&gt; fn -&gt; Malli -&gt; fn ..."><y>#</y><d>2021-07-19</d><h>07:56</h><r>Vincent Cantin</r>The escape hatch may not work well for the user in the case the model is using recursion, like in this example. That would become Malli -&gt; fn -&gt; Malli -&gt; fn ...</z><z id="t1626639304" t="respatialized Hi all! I&apos;ve been working for a while on fabricate , a static website generator that takes advantage of malli in order to both provide a model for semantically valid HTML/Hiccup forms and to define its own order of operations. I wrote a post about my experience using malli schemas to define a finite state machine that dispatches functions on the basis of the schemas matched by the data passed in to them, which I have taken to calling &quot;finite schema machines.&quot; https://fabricate-site.github.io/fabricate/finite-schema-machines.html I&apos;d be really interested in what other users of malli think about this concept. It&apos;s highly experimental, but I&apos;ve already found it quite interesting and useful."><y>#</y><d>2021-07-18</d><h>20:15</h><w>respatialized</w>Hi all! I&apos;ve been working for a while on <code>fabricate</code>, a static website generator that takes advantage of <code>malli</code> in order to both provide a model for semantically valid HTML/Hiccup forms and to define its own order of operations.  I wrote a post about my experience using <code>malli</code> schemas to define a finite state machine that dispatches functions on the basis of the schemas matched by the data passed in to them, which I have taken to calling &quot;finite schema machines.&quot;

<a href="https://fabricate-site.github.io/fabricate/finite-schema-machines.html" target="_blank">https://fabricate-site.github.io/fabricate/finite-schema-machines.html</a>

I&apos;d be really interested in what other users of <code>malli</code> think about this concept. It&apos;s highly experimental, but I&apos;ve already found it quite interesting and useful.</z><z id="t1626687057" t="Ben Sless This looks very interesting and I&apos;ve had FSMs on my mind recently. Will need to give a deeper look"><y>#</y><d>2021-07-19</d><h>09:30</h><r>Ben Sless</r>This  looks very interesting and I&apos;ve had FSMs on my mind recently. Will need to give a deeper look</z><z id="t1626689059" t="Ben Sless Wonder how this relates to dependent types"><y>#</y><d>2021-07-19</d><h>10:04</h><r>Ben Sless</r>Wonder how this relates to dependent types</z><z id="t1626699058" t="respatialized I&apos;ve never worked with dependent types, but my impression of malli is that you get a lot of the benefits of dependent types without a static type system. that said, when I think about how to validate/check these FSM definitions for cycles or non-termination at definition/compile time, I wonder how close I&apos;m actually getting to reinventing a type system."><y>#</y><d>2021-07-19</d><h>12:50</h><r>respatialized</r>I&apos;ve never worked with dependent types, but my impression of <code>malli</code> is that you get a lot of the benefits of dependent types without a static type system. that said, when I think about how to validate/check these FSM definitions for cycles or non-termination at definition/compile time, I wonder how close I&apos;m actually getting to reinventing a type system.</z><z id="t1626680859" t="ikitommi [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] looks awesome!"><y>#</y><d>2021-07-19</d><h>07:47</h><w>ikitommi</w><a>@afoltzm</a> looks awesome!</z><z id="t1626726002" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , do you have any plans to release malli 0.6.0 soon? Malli 0.6.0-snapshot has very exciting functionality about function schemas and instrumentation."><y>#</y><d>2021-07-19</d><h>20:20</h><w>mike_ananev</w><a>@ikitommi</a>, do you have any plans to release malli 0.6.0 soon? Malli 0.6.0-snapshot has very exciting functionality about function schemas and instrumentation.</z><z id="t1626772404" t="ikitommi no plans, but for the instrumentation part, the latest immutable SNAPSHOT version should be stable&apos;ish (or depend on latest commit via deps)"><y>#</y><d>2021-07-20</d><h>09:13</h><r>ikitommi</r>no plans, but for the instrumentation part, the latest immutable SNAPSHOT version should be stable&apos;ish (or depend on latest commit via deps)</z><z id="t1626772404" t="ikitommi no plans, but for the instrumentation part, the latest immutable SNAPSHOT version should be stable&apos;ish (or depend on latest commit via deps)"><y>#</y><d>2021-07-20</d><h>09:13</h><w>ikitommi</w>no plans, but for the instrumentation part, the latest immutable SNAPSHOT version should be stable&apos;ish (or depend on latest commit via deps)</z><z id="t1626750215" t="escherize Is there a malli schema for the clojure.core/defn form?"><y>#</y><d>2021-07-20</d><h>03:03</h><w>escherize</w>Is there a malli schema for the clojure.core/defn form?</z><z id="t1626756613" t="mike_ananev [:attrs {:href &quot;/_/_/users/U051GFP2V&quot;}] https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-schemas-via-metadata"><y>#</y><d>2021-07-20</d><h>04:50</h><w>mike_ananev</w><a>@escherize</a> <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-schemas-via-metadata" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-schemas-via-metadata</a></z><z id="t1626759903" t="escherize thanks for your response [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] . What I am looking for is a malli schema that will say “that clojure.core/defn form you have is good and not malformed” or not."><y>#</y><d>2021-07-20</d><h>05:45</h><w>escherize</w>thanks for your response <a>@mike1452</a>. What I am looking for is a malli schema that will say “that clojure.core/defn form you have is good and not malformed” or not.</z><z id="t1626760062" t="escherize I think the schema should match these, but there may be more: [&apos;(defn f [a] 1) &apos;(defn g [a] (+ a a)) &apos;(defn ^:ok g &quot;hi&quot; [a] (+ a a)) &apos;(defn ^:ok g &quot;hi&quot; ([a] (+ a a))) &apos;(defn ^:ok g &quot;hi&quot; ([a] 1) ([a b] 2))]"><y>#</y><d>2021-07-20</d><h>05:47</h><w>escherize</w>I think the schema should match these, but there may be more:
<pre>[&apos;(defn f [a] 1)
 &apos;(defn g [a] (+ a a))
 &apos;(defn ^:ok g &quot;hi&quot; [a] (+ a a))
 &apos;(defn ^:ok g &quot;hi&quot; ([a] (+ a a)))
 &apos;(defn ^:ok g &quot;hi&quot; ([a] 1) ([a b] 2))]</pre></z><z id="t1626760836" t="escherize I thought I was getting close, but can’t quite get it for all cases. Maybe someone here can figure it out (def DefnSchema [:cat [:enum &apos;defn &apos;-defn] symbol? [:? string?] [:alt [:cat [:vector symbol?] [:* any?]] [:* [:sequential [:cat [:vector symbol?] [:* any?]]]]]]) (mapv #(m/explain DefnSchema %) [&apos;(defn f [a] 1) ;;&lt;- good &apos;(defn g [b] (+ b b)) ;;&lt;- good &apos;(defn ^:ok g &quot;hi&quot; [c] (+ c c)) ;;&lt;- good &apos;(defn ^:ok g &quot;hi&quot; ([d] (+ d d))) ;;&lt;- fail &apos;(defn ^:ok g &quot;hi&quot; ([e] 1) ([e e] 2))]);;&lt;- fail"><y>#</y><d>2021-07-20</d><h>06:00</h><w>escherize</w>I thought I was getting close, but can’t quite get it for all cases. Maybe someone here can figure it out

<pre>(def DefnSchema
  [:cat
   [:enum &apos;defn &apos;-defn]
   symbol?
   [:? string?]
   [:alt
    [:cat [:vector symbol?] [:* any?]]
    [:* [:sequential [:cat [:vector symbol?] [:* any?]]]]]])

(mapv #(m/explain DefnSchema %)
      [&apos;(defn f [a] 1) ;;&lt;- good
       &apos;(defn g [b] (+ b b))  ;;&lt;- good
       &apos;(defn ^:ok g &quot;hi&quot; [c] (+ c c))  ;;&lt;- good
       &apos;(defn ^:ok g &quot;hi&quot; ([d] (+ d d))) ;;&lt;- fail
       &apos;(defn ^:ok g &quot;hi&quot; ([e] 1) ([e e] 2))]);;&lt;- fail</pre></z><z id="t1626779438" t="ikitommi m/explain might hint why it&apos;s not right"><y>#</y><d>2021-07-20</d><h>11:10</h><r>ikitommi</r><code>m/explain</code> might hint why it&apos;s not right</z><z id="t1626779459" t="ikitommi oh, you had that."><y>#</y><d>2021-07-20</d><h>11:10</h><r>ikitommi</r>oh, you had that.</z><z id="t1626779497" t="ikitommi any hint about why they failed? (not near computer myself)"><y>#</y><d>2021-07-20</d><h>11:11</h><r>ikitommi</r>any hint about why they failed? (not near computer myself)</z><z id="t1626788831" t="danielneal Is there already a transformer that will work with query parameters - specifically to convert single values into vectors where the schema specifies a vector. i.e. (malli.core/decode [:map [:a [:vector int?]]] {:a &quot;1&quot;} some-transformer) =&gt; {:a [1]} (as opposed to {:a &quot;1&quot;}) (malli.core/decode [:map [:a [:vector int?]]] {:a [&quot;1&quot; &quot;2&quot;]} some-transformer) =&gt; {:a [1 2]} This seems to work - but is it right? (defn collection-transformer [] (malli.transform/transformer {:decoders {:vector {:compile (fn [schema _] (fn [x] (if (vector? x) x [x])))}}}))"><y>#</y><d>2021-07-20</d><h>13:47</h><w>danielneal</w>Is there already a transformer that will work with query parameters - specifically to convert single values into vectors where the schema specifies a vector.

i.e.

<pre>(malli.core/decode [:map
                    [:a [:vector int?]]]
                   {:a &quot;1&quot;}
                   some-transformer) =&gt; {:a [1]} (as opposed to {:a &quot;1&quot;})

(malli.core/decode [:map
                    [:a [:vector int?]]]
                   {:a [&quot;1&quot; &quot;2&quot;]}
                   some-transformer) =&gt; {:a [1 2]}</pre>
This seems to work - but is it right?
<pre>(defn collection-transformer []
  (malli.transform/transformer
    {:decoders
     {:vector
      {:compile (fn [schema _]
                  (fn [x]
                    (if (vector? x) x [x])))}}}))</pre></z><z id="t1626789139" t="ikitommi [:attrs {:href &quot;/_/_/users/U051GFP2V&quot;}] it should be: (def DefnSchema [:cat [:enum &apos;defn &apos;-defn] symbol? [:? string?] [:alt [:cat [:vector symbol?] [:* any?]] [:+ [:schema [:cat [:vector symbol?] [:* any?]]]]]])"><y>#</y><d>2021-07-20</d><h>13:52</h><w>ikitommi</w><a>@escherize</a> it should be:
<pre>(def DefnSchema
  [:cat
   [:enum &apos;defn &apos;-defn]
   symbol?
   [:? string?]
   [:alt
    [:cat [:vector symbol?] [:* any?]]
    [:+ [:schema [:cat [:vector symbol?] [:* any?]]]]]])</pre></z><z id="t1626789210" t="ikitommi e.g. not sequence :+ of sequence :sequence of sequences :cat , just sequence (`:+`) of sequences :cat ."><y>#</y><d>2021-07-20</d><h>13:53</h><w>ikitommi</w>e.g. not sequence <code>:+</code> of sequence <code>:sequence</code> of sequences <code>:cat</code>, just sequence (`:+`) of sequences <code>:cat</code>.</z><z id="t1626789482" t="ikitommi [:attrs {:href &quot;/_/_/users/U051H1KL1&quot;}] maybe something like: (m/decode [:map [:a [:vector int?]]] {:a &quot;1&quot;} (mt/transformer (mt/transformer {:decoders {:vector (fn [x] (if (string? x) [x] x))}}) (mt/string-transformer))) ; =&gt; {:a [1]}"><y>#</y><d>2021-07-20</d><h>13:58</h><w>ikitommi</w><a>@danieleneal</a> maybe something like:
<pre>(m/decode
  [:map
   [:a [:vector int?]]]
  {:a &quot;1&quot;}
  (mt/transformer
    (mt/transformer
      {:decoders {:vector (fn [x] (if (string? x) [x] x))}})
    (mt/string-transformer)))
; =&gt; {:a [1]}</pre></z><z id="t1626790015" t="danielneal ah cool, thanks, looks like I’m on the right lines 🙂"><y>#</y><d>2021-07-20</d><h>14:06</h><w>danielneal</w>ah cool, thanks, looks like I’m on the right lines <b>🙂</b></z><z id="t1626790198" t="ikitommi you can use :compile if you want to access the schema ahead of time, like reading the separator per schma: (def decode (m/decoder [:map [:a [:vector {:separator &quot;;&quot;} int?]]] (mt/transformer (mt/transformer {:decoders {:vector {:compile (fn [schema _] (let [separator (-&gt; schema m/properties :separator (or &quot;,&quot;))] (fn [x] (cond (not (string? x)) x (str/includes? x separator) (into [] (.split ^String x ^String separator)) :else [x]))))}}}) (mt/string-transformer)))) (decode {:a &quot;2&quot;}) ; =&gt; {:a [2]} (decode {:a &quot;1;2&quot;}) ; =&gt; {:a [1 2]}"><y>#</y><d>2021-07-20</d><h>14:09</h><w>ikitommi</w>you can use <code>:compile</code> if you want to access the schema ahead of time, like reading the separator per schma:
<pre>(def decode
  (m/decoder
    [:map
     [:a [:vector {:separator &quot;;&quot;} int?]]]
    (mt/transformer
      (mt/transformer
        {:decoders
         {:vector
          {:compile (fn [schema _]
                      (let [separator (-&gt; schema m/properties :separator (or &quot;,&quot;))]
                        (fn [x]
                          (cond
                            (not (string? x)) x
                            (str/includes? x separator) (into [] (.split ^String x ^String separator))
                            :else [x]))))}}})
      (mt/string-transformer))))

(decode {:a &quot;2&quot;})
; =&gt; {:a [2]}

(decode {:a &quot;1;2&quot;})
; =&gt; {:a [1 2]}</pre></z><z id="t1626791122" t="ikitommi [:attrs {:href &quot;/_/_/users/U051H1KL1&quot;}] https://github.com/metosin/malli/blob/master/docs/tips.md#decoding-collections"><y>#</y><d>2021-07-20</d><h>14:25</h><w>ikitommi</w><a>@danieleneal</a> <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#decoding-collections" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#decoding-collections</a></z><z id="t1626791725" t="danielneal nice!! Thanks :))))"><y>#</y><d>2021-07-20</d><h>14:35</h><r>danielneal</r>nice!! Thanks :))))</z><z id="t1626791380" t="kenny I&apos;m curious if Malli has considered allowing the default registry to be set in a less invasive way (i.e., not through jvm props)? The requirement to set a jvm prop touches many places in a large application and, I imagine, will cause future developer confusion by requiring every repl to be launched with that prop."><y>#</y><d>2021-07-20</d><h>14:29</h><w>kenny</w>I&apos;m curious if Malli has considered allowing the default registry to be set in a less invasive way (i.e., not through jvm props)? The requirement to set a jvm prop touches many places in a large application and, I imagine, will cause future developer confusion by requiring every repl to be launched with that prop.</z><z id="t1626792219" t="ikitommi totally agree. the current way to enable custom registry is too much work and one can always define an immutable registry for the cases (multi-tenant env) when it matters. Just not sure what would be a best possible compromise between simple &amp; easy here. Imperative programming with global state is not good either. Ideas?"><y>#</y><d>2021-07-20</d><h>14:43</h><w>ikitommi</w>totally agree. the current way to enable custom registry is too much work and one can always define an immutable registry for the cases (multi-tenant env) when it matters. Just not sure what would be a best possible compromise between simple &amp; easy here. Imperative programming with global state is not good either. Ideas?</z><z id="t1626792285" t="ikitommi there was a discussion somewhere some time ago.."><y>#</y><d>2021-07-20</d><h>14:44</h><w>ikitommi</w>there was a discussion somewhere some time ago..</z><z id="t1626792385" t="ikitommi 1. immutable by default, swapping needs a custom jvm/compiler option 2. mutable registry by default, spec-like 3. immutable by default, but mr/set-default-registry! available without jvm options 4. something else"><y>#</y><d>2021-07-20</d><h>14:46</h><w>ikitommi</w>1. immutable by default, swapping needs a custom jvm/compiler option
2. mutable registry by default, spec-like
3. immutable by default, but <code>mr/set-default-registry!</code> available without jvm options
4. something else</z><z id="t1626793842" t="kenny We are very early in our usage of Malli, coming from a large use of Spec, so take anything I say with that grain of salt. I quite like the default mutable registry. Over the years, we have built up a large library of domain specs that are used all over the place. It&apos;s handy to be able to simply reference these specs by their keyword name. Of course, Malli may encourage different conventions (e.g., just write functions returning custom schema). I started down the path of creating our own immutable registry, but started to feel pain when I needed to pass my registry to every single Malli api call."><y>#</y><d>2021-07-20</d><h>15:10</h><w>kenny</w>We are very early in our usage of Malli, coming from a large use of Spec, so take anything I say with that grain of salt. I quite like the default mutable registry. Over the years, we have built up a large library of domain specs that are used all over the place. It&apos;s handy to be able to simply reference these specs by their keyword name. Of course, Malli may encourage different conventions (e.g., just write functions returning custom schema). I started down the path of creating our own immutable registry, but started to feel pain when I needed to pass my registry to every single Malli api call.</z><z id="t1626794759" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I found breaking changes between 0.5.1 and 0.6.0-snapshot in a function m/validate In 0.5.1, function m/validate returns true if data corresponds to spec. In 0.6.0-snapshot, function m/validate returns data, not boolean value true . In 0.5.1, If data is not corresponds to spec, then function m/validate returns false. In 0.6.0-snapshot, function m/validate returns in some cases value false , in some cases returns value nil (for strings for example)."><y>#</y><d>2021-07-20</d><h>15:25</h><w>mike_ananev</w><a>@ikitommi</a> I found breaking changes between 0.5.1 and 0.6.0-snapshot in a function <code>m/validate</code>
In 0.5.1, function <code>m/validate</code> returns <code>true</code> if data corresponds to spec. In 0.6.0-snapshot, function <code>m/validate</code> returns data, not boolean value <code>true</code>.
In 0.5.1, If data is not corresponds to spec, then function  <code>m/validate</code> returns false.  In 0.6.0-snapshot, function <code>m/validate</code> returns in some cases value <code>false</code>, in some cases  returns value <code>nil</code> (for strings for example).</z><z id="t1626852113" t="ikitommi oh, that’s not good [:attrs {:href &quot;/_/_/users/U097654L8&quot;}] . These might be related: • https://github.com/metosin/malli/commit/ae12531aede1ad936af7d7bde80543572cc907ae • https://github.com/metosin/malli/pull/479 … could you retest with the new SNAPSHOT (`metosin/malli-0.6.0-20210721.071739-2`) and if the problem persists, please write an issue."><y>#</y><d>2021-07-21</d><h>07:21</h><r>ikitommi</r>oh, that’s not good <a>@mike1452</a>. These might be related:
• <a href="https://github.com/metosin/malli/commit/ae12531aede1ad936af7d7bde80543572cc907ae" target="_blank">https://github.com/metosin/malli/commit/ae12531aede1ad936af7d7bde80543572cc907ae</a>
• <a href="https://github.com/metosin/malli/pull/479" target="_blank">https://github.com/metosin/malli/pull/479</a>
… could you retest with the new SNAPSHOT (`metosin/malli-0.6.0-20210721.071739-2`) and if the problem persists, please write an issue.</z><z id="t1626855965" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thank you for quick reply! I&apos;ll check my tests and return soon. You can use malli spec to spec your functions to catch errors, while you are developing malli.spec. 😂"><y>#</y><d>2021-07-21</d><h>08:26</h><r>mike_ananev</r><a>@ikitommi</a> thank you for quick reply! I&apos;ll check my tests and return soon.
You can use malli spec to spec your functions to catch errors, while you are developing malli.spec. <b>😂</b></z><z id="t1626862316" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I found new strange behaviour during this cycle: edn1 -&gt; encode-value -&gt; json -&gt; decode-value -&gt; edn2 In v 0.5.1, edn1 = edn2. All uuids and zoned-date-time encoded/decoded correctly, they are data of the same type. In v 0.6.0-20210721.071739-2, edn1 != edn2 broken data for uuid and zoned-date-time - they are strings after decoding. Can&apos;t reproduce this error on a simple schema. I&apos;ve more complicated schemas, but cannot publish them here. But in my code I do something like that."><y>#</y><d>2021-07-21</d><h>10:11</h><r>mike_ananev</r><a>@ikitommi</a> I found new strange behaviour during this cycle:

<code>edn1 -&gt; encode-value -&gt; json -&gt; decode-value -&gt; edn2</code>

In v 0.5.1, edn1 = edn2. All uuids and zoned-date-time encoded/decoded correctly, they are data of the same type.

In v 0.6.0-20210721.071739-2, edn1 != edn2
broken data for uuid and zoned-date-time - they are strings after decoding.

Can&apos;t reproduce this error on a simple schema. I&apos;ve more complicated schemas, but cannot publish them here.
But in my code I do something like that.</z><z id="t1626862376" t="mike_ananev (do (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer)) (def my-spec1 [:map [:a :zoned-date-time] [:b :string] [:c :uuid] [:d :int]]) (def my-spec [:map [:s1 my-spec1] [:s2 my-spec1]]) (def edn-value (mg/generate my-spec)) (def encoded-value (m/encode my-spec edn-value custom-json-transformer)) (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper)) (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper)) (def edn-value2 (m/decode my-spec encoded-value2 custom-json-transformer)) (is (m/validate my-spec edn-value2))) "><y>#</y><d>2021-07-21</d><h>10:12</h><r>mike_ananev</r><pre>(do (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer))
    (def my-spec1 [:map
                   [:a :zoned-date-time]
                   [:b :string]
                   [:c :uuid]
                   [:d :int]])
    (def my-spec [:map [:s1 my-spec1] [:s2 my-spec1]])
    (def edn-value (mg/generate my-spec))
    (def encoded-value (m/encode my-spec edn-value custom-json-transformer))
    (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper))
    (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper))
    (def edn-value2 (m/decode my-spec encoded-value2 custom-json-transformer))
    (is (m/validate my-spec edn-value2)))</pre>
</z><z id="t1626870404" t="Ben Sless Is this example sufficient for reproduction or is it just illustrative?"><y>#</y><d>2021-07-21</d><h>12:26</h><r>Ben Sless</r>Is this example sufficient for reproduction or is it just illustrative?</z><z id="t1626872603" t="Ben Sless Some schemas are missing from the example, too"><y>#</y><d>2021-07-21</d><h>13:03</h><r>Ben Sless</r>Some schemas are missing from the example, too</z><z id="t1626874072" t="mike_ananev [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] it is illustrative"><y>#</y><d>2021-07-21</d><h>13:27</h><r>mike_ananev</r><a>@UK0810AQ2</a> it is illustrative</z><z id="t1626885373" t="Ben Sless I MANAGED TO RECREATE IT (do (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer)) (def my-spec1 [:map [:a/c1 {:optional true} :uuid] [:a/c2 :uuid] [:a/c3 :uuid] [:a/c4 :uuid] [:a/c5 :uuid] [:a/c6 :uuid] [:a/c7 :uuid] [:a/c8 :uuid] [:a/c9 :uuid] [:a/c10 :uuid] [:a/c11 :uuid] [:a/c12 :uuid] [:a/c13 :uuid] [:a/c14 :uuid] [:a/c15 :uuid] [:a/c16 :uuid] [:a/c17 :uuid] [:a/c18 :uuid] [:a/c19 :uuid] [:a/c20 :uuid] [:a/c21 :uuid] [:a/c22 :uuid] [:d :int]]) (def my-spec [:map [:x/y [:map [:b/foo [:map [:a/s1 my-spec1]]]]]]) (def edn-value (mg/generate my-spec)) (def encoded-value (m/encode my-spec edn-value custom-json-transformer)) (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper)) (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper)) (def edn-value2 (m/decode my-spec encoded-value2 custom-json-transformer)) (m/validate my-spec edn-value2)) "><y>#</y><d>2021-07-21</d><h>16:36</h><r>Ben Sless</r>I MANAGED TO RECREATE IT
<pre>(do
  (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer))
  (def my-spec1 [:map
                 [:a/c1  {:optional true} :uuid]
                 [:a/c2  :uuid]
                 [:a/c3  :uuid]
                 [:a/c4  :uuid]
                 [:a/c5  :uuid]
                 [:a/c6  :uuid]
                 [:a/c7  :uuid]
                 [:a/c8  :uuid]
                 [:a/c9  :uuid]
                 [:a/c10 :uuid]
                 [:a/c11 :uuid]
                 [:a/c12 :uuid]
                 [:a/c13 :uuid]
                 [:a/c14 :uuid]
                 [:a/c15 :uuid]
                 [:a/c16 :uuid]
                 [:a/c17 :uuid]
                 [:a/c18 :uuid]
                 [:a/c19 :uuid]
                 [:a/c20 :uuid]
                 [:a/c21 :uuid]
                 [:a/c22 :uuid]
                 [:d :int]])
  (def my-spec [:map [:x/y [:map [:b/foo [:map  [:a/s1 my-spec1]]]]]])
  (def edn-value (mg/generate my-spec))
  (def encoded-value (m/encode my-spec edn-value custom-json-transformer))
  (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper))
  (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper))
  (def edn-value2 (m/decode my-spec encoded-value2 custom-json-transformer))
  (m/validate my-spec edn-value2))</pre>
</z><z id="t1626886042" t="mike_ananev [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] yeah! This code reproduces the bug. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] do you have any suggestions?"><y>#</y><d>2021-07-21</d><h>16:47</h><r>mike_ananev</r><a>@UK0810AQ2</a> yeah! This code reproduces the bug. <a>@ikitommi</a> do you have any suggestions?</z><z id="t1626886170" t="Ben Sless Now I can debug and investigate"><y>#</y><d>2021-07-21</d><h>16:49</h><r>Ben Sless</r>Now I can debug and investigate</z><z id="t1626886196" t="mike_ananev The bug is when we have optional attribute in a map then process edn -&gt; encode -&gt; json -&gt; decode -&gt;edn2 is broken, edn != edn2 . This behavior is in version 0.6.0-20210721.071739-2. In 0.5.1 version all is working as expected."><y>#</y><d>2021-07-21</d><h>16:49</h><r>mike_ananev</r>The bug is when we have optional attribute in a map then process <code>edn -&gt; encode -&gt; json -&gt; decode -&gt;edn2</code> is broken, <code>edn != edn2</code> . This behavior is in version 0.6.0-20210721.071739-2. In 0.5.1 version all is working as expected.</z><z id="t1626889353" t="Ben Sless Managed to narrow the example down a bit: (do (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer)) (def my-spec1 [:map [:a/c1 {:optional true} :uuid] [:a/c2 :uuid]]) (def s (m/schema my-spec1)) (def my-spec (m/schema [:map [:x s]])) (def g (mg/generator my-spec)) (def edn-value (mg/generate g {:seed 9999})) (def e (m/encoder my-spec custom-json-transformer)) (def encoded-value (e edn-value)) (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper)) (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper)) (def d (m/decoder my-spec custom-json-transformer)) (def edn-value2 (d encoded-value2)) (m/validate my-spec edn-value2))"><y>#</y><d>2021-07-21</d><h>17:42</h><r>Ben Sless</r>Managed to narrow the example down a bit:
<pre>(do
  (def custom-json-transformer (mt/transformer mt/string-transformer mt/json-transformer))
  (def my-spec1 [:map
                 [:a/c1  {:optional true} :uuid]
                 [:a/c2  :uuid]])
  (def s (m/schema my-spec1))
  (def my-spec (m/schema [:map [:x s]]))
  (def g (mg/generator my-spec))
  (def edn-value (mg/generate g {:seed 9999}))
  (def e (m/encoder my-spec custom-json-transformer))
  (def encoded-value (e edn-value))
  (def json-string-value (json/write-value-as-string encoded-value json/keyword-keys-object-mapper))
  (def encoded-value2 (json/read-value json-string-value json/keyword-keys-object-mapper))
  (def d (m/decoder my-spec custom-json-transformer))
  (def edn-value2 (d encoded-value2))
  (m/validate my-spec edn-value2))</pre></z><z id="t1626889370" t="Ben Sless This returns false consistently"><y>#</y><d>2021-07-21</d><h>17:42</h><r>Ben Sless</r>This returns <code>false</code> consistently</z><z id="t1626891976" t="Ben Sless I managed to find the commit which caused the change: 9dc8da7a0649ed93554c1fe16ea48c2bebd724ad fast collection transformers"><y>#</y><d>2021-07-21</d><h>18:26</h><r>Ben Sless</r>I managed to find the commit which caused the change:
9dc8da7a0649ed93554c1fe16ea48c2bebd724ad
fast collection transformers</z><z id="t1626892327" t="Ben Sless I am not sure where the bug is, but changing the implementation of -map-transformer to (reduce -comp (map (fn [[k t]] (fn [x] (if-let [e (.entryAt x k)] (.assoc x k (t (.val e))) x))) ts)) Fixes it"><y>#</y><d>2021-07-21</d><h>18:32</h><r>Ben Sless</r>I am not sure where the bug is, but changing the implementation of <code>-map-transformer</code> to
<pre>(reduce
      -comp
      (map
       (fn [[k t]]
         (fn [x]
           (if-let [e (.entryAt x k)]
             (.assoc x k (t (.val e)))
             x)))
       ts))</pre>
Fixes it</z><z id="t1626892363" t="mike_ananev 👍"><y>#</y><d>2021-07-21</d><h>18:32</h><r>mike_ananev</r><b>👍</b></z><z id="t1626940283" t="Ben Sless https://github.com/metosin/malli/issues/480"><y>#</y><d>2021-07-22</d><h>07:51</h><r>Ben Sless</r><a href="https://github.com/metosin/malli/issues/480" target="_blank">https://github.com/metosin/malli/issues/480</a></z><z id="t1626944096" t="ikitommi thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] . I hate it when there is test to cover this. My bad. The minimal repro: (deftest regression-480-test (let [value {:b #uuid&quot;f5a54a8f-7d78-4495-9138-e810885d1cdb&quot;} schema [:map [:a :int] [:b :uuid]]] (is (= value (as-&gt; value $ (m/encode schema $ mt/string-transformer) (m/decode schema $ mt/string-transformer))))))"><y>#</y><d>2021-07-22</d><h>08:54</h><r>ikitommi</r>thanks <a>@UK0810AQ2</a>. I hate it when there is test to cover this. My bad.  The minimal repro:
<pre>(deftest regression-480-test
  (let [value {:b #uuid&quot;f5a54a8f-7d78-4495-9138-e810885d1cdb&quot;}
        schema [:map [:a :int] [:b :uuid]]]
    (is (= value
           (as-&gt; value $
                 (m/encode schema $ mt/string-transformer)
                 (m/decode schema $ mt/string-transformer))))))</pre></z><z id="t1626944424" t="ikitommi updated clojars; ➜ ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.0-SNAPSHOT&quot;}}}&apos; Downloading: metosin/malli/0.6.0-SNAPSHOT/malli-0.6.0-20210722.085801-3.pom from clojars"><y>#</y><d>2021-07-22</d><h>09:00</h><r>ikitommi</r>updated clojars;
<pre>➜  ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.0-SNAPSHOT&quot;}}}&apos;
Downloading: metosin/malli/0.6.0-SNAPSHOT/malli-0.6.0-20210722.085801-3.pom from clojars</pre></z><z id="t1626944591" t="ikitommi bare minmial repro btw was: (m/decode [:map [:a :int] [:b :int]] {:b &quot;1&quot;} mt/string-transformer) ; =&gt; {:b &quot;1&quot;}"><y>#</y><d>2021-07-22</d><h>09:03</h><r>ikitommi</r>bare minmial repro btw was:
<pre>(m/decode
  [:map [:a :int] [:b :int]]
  {:b &quot;1&quot;}
  mt/string-transformer)
; =&gt; {:b &quot;1&quot;}</pre></z><z id="t1626950244" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] thank you! Now, all test are passed. We will try to take version 0.6.0-20210722.085801-3 in our production."><y>#</y><d>2021-07-22</d><h>10:37</h><r>mike_ananev</r><a>@ikitommi</a> <a>@UK0810AQ2</a> thank you! Now, all test are passed. We will try to take version <code>0.6.0-20210722.085801-3</code> in our production.</z><z id="t1626794841" t="mike_ananev This new behaviour of m/validate breaks some tests in my code."><y>#</y><d>2021-07-20</d><h>15:27</h><w>mike_ananev</w>This new behaviour of  <code>m/validate</code> breaks some tests in my code.</z><z id="t1626794895" t="mike_ananev What behaviour is expected in 0.6.0 release? Should we adapt our tests for this new behaviour of m/validate ?"><y>#</y><d>2021-07-20</d><h>15:28</h><w>mike_ananev</w>What behaviour is expected in 0.6.0 release? Should we adapt our tests for this new behaviour of  <code>m/validate</code> ?</z><z id="t1626796890" t="greg I&apos;ve just found out that mu/update-in can take a path that includes also catn options. It&apos;s so easy and concise to alter sequential schema with Malli! :grinning_face_with_star_eyes:"><y>#</y><d>2021-07-20</d><h>16:01</h><w>greg</w>I&apos;ve just found out that <code>mu/update-in</code> can take a path that includes also <code>catn</code> options. It&apos;s so easy and concise to alter sequential schema with Malli! <b>:grinning_face_with_star_eyes:</b></z><z id="t1626849863" t="Oliver George Having my first look at Malli today. Is there a s/assert equivalent? This is a CLJS project. I&apos;d like nice errors while developing and elided asserts in production."><y>#</y><d>2021-07-21</d><h>06:44</h><w>Oliver George</w>Having my first look at Malli today.  Is there a s/assert equivalent?  This is a CLJS project.  I&apos;d like nice errors while developing and elided asserts in production.</z><z id="t1626851735" t="ikitommi [:attrs {:href &quot;/_/_/users/U055DUUFS&quot;}] no, there is not. would it make sense to make the instrumentation work with cljs? it’s just clj ATM. If someone has mad skills at cljs-interop, clj-kondo emitting and malli.dev could be ported to cljs."><y>#</y><d>2021-07-21</d><h>07:15</h><w>ikitommi</w><a>@olivergeorge</a> no, there is not. would it make sense to make the instrumentation work with cljs? it’s just clj ATM. If someone has mad skills at cljs-interop, clj-kondo emitting and malli.dev could be ported to cljs.</z><z id="t1626860030" t="Oliver George It&apos;s all new to me but I&apos;ll keep it in mind as I get more familiar with Malli."><y>#</y><d>2021-07-21</d><h>09:33</h><w>Oliver George</w>It&apos;s all new to me but I&apos;ll keep it in mind as I get more familiar with Malli.</z><z id="t1626860187" t="Oliver George Adding a s/assert macro might be close to a copy/paste of cljs.spec.alpha/assert code. If it&apos;s considered useful/desirable."><y>#</y><d>2021-07-21</d><h>09:36</h><w>Oliver George</w>Adding a s/assert macro might be close to a copy/paste of cljs.spec.alpha/assert code.  If it&apos;s considered useful/desirable.</z><z id="t1626861252" t="alpox I was looking for an s/assert equivalent as well - me in Clojure though, not CLJS"><y>#</y><d>2021-07-21</d><h>09:54</h><w>alpox</w>I was looking for an <code>s/assert</code> equivalent as well - me in Clojure though, not CLJS</z><z id="t1626861375" t="alpox So from the little hint to malli.dev i gather there is some similar functionality in there? I guess I&apos;ll have to look at it a bit closer"><y>#</y><d>2021-07-21</d><h>09:56</h><w>alpox</w>So from the little hint to <code>malli.dev</code> i gather there is some similar functionality in there? I guess I&apos;ll have to look at it a bit closer</z><z id="t1626956574" t="David Levinov Hey guys, very quick and simple question, I want to combine two schemas to validate for case a and case b, and I’d rather not involve regexes, and have one of the validation schemas to have the values not be of a certain set. How would I rewrite this in a correct manner? (def NotABC (m/schema [:map [:field [:not [:enum &quot;a&quot; &quot;b&quot; &quot;c&quot;]]]])) Thanks!"><y>#</y><d>2021-07-22</d><h>12:22</h><w>David Levinov</w>Hey guys, very quick and simple question, I want to combine two schemas to validate for case a and case b, and I’d rather not involve regexes, and have one of the validation schemas to have the values not be of a certain set.
How would I rewrite this in a correct manner?
<pre>(def NotABC
  (m/schema
    [:map
     [:field [:not [:enum &quot;a&quot; &quot;b&quot; &quot;c&quot;]]]]))</pre>
Thanks!</z><z id="t1626967033" t="ikitommi looks legit to me."><y>#</y><d>2021-07-22</d><h>15:17</h><r>ikitommi</r>looks legit to me.</z><z id="t1626969228" t="David Levinov [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] that’s exactly what I thought as well, but in the REPL: Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema :not} thanks for the response 👌"><y>#</y><d>2021-07-22</d><h>15:53</h><r>David Levinov</r><a>@ikitommi</a> that’s exactly what I thought as well, but in the REPL:
<pre>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema :not}</pre>
thanks for the response <b>👌</b></z><z id="t1626969543" t="ikitommi oh, what. Try updating the malli dependency."><y>#</y><d>2021-07-22</d><h>15:59</h><r>ikitommi</r>oh, what. Try updating the malli dependency.</z><z id="t1626970410" t="David Levinov welp, that does indeed solve the issue, thanks haha"><y>#</y><d>2021-07-22</d><h>16:13</h><r>David Levinov</r>welp, that does indeed solve the issue, thanks haha</z><z id="t1626963092" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Looks like the new function instrumentation only works for clj, but not for cljs yet. E.g. mi/instrument! and dev/start would throw when I use them in cljs. Is there any plan to add cljs support?"><y>#</y><d>2021-07-22</d><h>14:11</h><w>Lucy Wang</w><a>@ikitommi</a> Looks like the new function instrumentation only works for clj, but not for cljs yet. E.g. <code>mi/instrument!</code> and <code>dev/start</code> would throw when I use them in cljs. Is there any plan to add cljs support?</z><z id="t1626965179" t="ikitommi [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] help most welcome on cljs-support."><y>#</y><d>2021-07-22</d><h>14:46</h><w>ikitommi</w><a>@wxitb2017</a> help most welcome on cljs-support.</z><z id="t1626966846" t="ikitommi https://github.com/metosin/malli/issues/482"><y>#</y><d>2021-07-22</d><h>15:14</h><r>ikitommi</r><a href="https://github.com/metosin/malli/issues/482" target="_blank">https://github.com/metosin/malli/issues/482</a></z><z id="t1627006595" t="Lucy Wang Cool!"><y>#</y><d>2021-07-23</d><h>02:16</h><r>Lucy Wang</r>Cool!</z><z id="t1626981271" t="Ben Sless Initial attempt at writing a malli based parser for EDN datalog syntax https://gist.github.com/bsless/632b4040a2b2ad7469369f52cd610c06 Can&apos;t figure out why ::clause breaks and it&apos;s getting late here. Feel free to poke at the code, suggest improvements, feedback, etc."><y>#</y><d>2021-07-22</d><h>19:14</h><w>Ben Sless</w>Initial attempt at writing a malli based parser for EDN datalog syntax
<a href="https://gist.github.com/bsless/632b4040a2b2ad7469369f52cd610c06" target="_blank">https://gist.github.com/bsless/632b4040a2b2ad7469369f52cd610c06</a>
Can&apos;t figure out why <code>::clause</code> breaks and it&apos;s getting late here. Feel free to poke at the code, suggest improvements, feedback, etc.</z><z id="t1627052019" t="Ben Sless Direct translation to spec works for parsing the forms, insights as to why it didn&apos;t work with malli most welcome, updated the gist"><y>#</y><d>2021-07-23</d><h>14:53</h><r>Ben Sless</r>Direct translation to spec works for parsing the forms, insights as to why it didn&apos;t work with malli most welcome, updated the gist</z><z id="t1627052019" t="Ben Sless Direct translation to spec works for parsing the forms, insights as to why it didn&apos;t work with malli most welcome, updated the gist"><y>#</y><d>2021-07-23</d><h>14:53</h><w>Ben Sless</w>Direct translation to spec works for parsing the forms, insights as to why it didn&apos;t work with malli most welcome, updated the gist</z><z id="t1627046312" t="robert-stuttaford does #malli work with #babashka ? (just did a demo for my team and our infra human is curious)"><y>#</y><d>2021-07-23</d><h>13:18</h><w>robert-stuttaford</w>does #malli work with #babashka ? (just did a demo for my team and our infra human is curious)</z><z id="t1627060159" t="borkdude malli currently doesn&apos;t work (from source) in babashka"><y>#</y><d>2021-07-23</d><h>17:09</h><r>borkdude</r>malli currently doesn&apos;t work (from source) in babashka</z><z id="t1627060182" t="borkdude we have an issue here: https://github.com/babashka/babashka/discussions/906 to consider including it"><y>#</y><d>2021-07-23</d><h>17:09</h><r>borkdude</r>we have an issue here: <a href="https://github.com/babashka/babashka/discussions/906" target="_blank">https://github.com/babashka/babashka/discussions/906</a> to consider including it</z><z id="t1627061203" t="borkdude [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] there are alternatives which currently work, such as spartan.spec (a spec drop-in replacement) and minimallist"><y>#</y><d>2021-07-23</d><h>17:26</h><r>borkdude</r><a>@U0509NKGK</a> there are alternatives which currently work, such as spartan.spec (a spec drop-in replacement) and minimallist</z><z id="t1627061229" t="borkdude if you could tell me how exactly malli would be useful for infra, please discuss in the issue, it could be an argument to include it"><y>#</y><d>2021-07-23</d><h>17:27</h><r>borkdude</r>if you could tell me how exactly malli would be useful for infra, please discuss in the issue, it could be an argument to include it</z><z id="t1627574143" t="robert-stuttaford truly just pure curiosity at this point 🙂"><y>#</y><d>2021-07-29</d><h>15:55</h><r>robert-stuttaford</r>truly just pure curiosity at this point <b>🙂</b></z><z id="t1627052338" t="Ben Sless Is there a reason :ref schemas just die for regex parsing? Why do they have to be surrounded by :maybe ?"><y>#</y><d>2021-07-23</d><h>14:58</h><w>Ben Sless</w>Is there a reason <code>:ref</code> schemas just die for regex parsing? Why do they have to be surrounded by <code>:maybe</code>?</z><z id="t1627053606" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] refs directly in sequence schemas are disallowed, rationale: https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc#L1-L34"><y>#</y><d>2021-07-23</d><h>15:20</h><w>ikitommi</w><a>@ben.sless</a> refs directly in sequence schemas are disallowed, rationale: <a href="https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc#L1-L34" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc#L1-L34</a></z><z id="t1627053691" t="ikitommi you can wrap anything in :schema to push it outside of the sequence."><y>#</y><d>2021-07-23</d><h>15:21</h><w>ikitommi</w>you can wrap anything in <code>:schema</code> to push it outside of the sequence.</z><z id="t1627057159" t="Ben Sless It would be good to add in the readme that recursive seqexp reference schemas have to have another level of indirection via either maybe or schema"><y>#</y><d>2021-07-23</d><h>16:19</h><r>Ben Sless</r>It would be good to add in the readme that recursive seqexp reference schemas have to have another level of indirection via either maybe or schema</z><z id="t1627126606" t="ikitommi doc PRs always welcome"><y>#</y><d>2021-07-24</d><h>11:36</h><r>ikitommi</r>doc PRs always welcome</z><z id="t1627053763" t="ikitommi Here&apos;s an example with hiccup, which is recursive: (def Hiccup [:schema {:registry {&quot;hiccup&quot; [:orn [:node [:catn [:name keyword?] [:props [:? [:map-of keyword? any?]]] [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]] [:primitive [:orn [:nil nil?] [:boolean boolean?] [:number number?] [:text string?]]]]}} &quot;hiccup&quot;]) (def parse-hiccup (m/parser Hiccup))"><y>#</y><d>2021-07-23</d><h>15:22</h><w>ikitommi</w>Here&apos;s an example with hiccup, which is recursive:
<pre>(def Hiccup
  [:schema {:registry {&quot;hiccup&quot; [:orn
                                 [:node [:catn
                                         [:name keyword?]
                                         [:props [:? [:map-of keyword? any?]]]
                                         [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]]
                                 [:primitive [:orn
                                              [:nil nil?]
                                              [:boolean boolean?]
                                              [:number number?]
                                              [:text string?]]]]}}
   &quot;hiccup&quot;])

(def parse-hiccup (m/parser Hiccup))</pre></z><z id="t1627054407" t="Ben Sless I&apos;ll try. I got the parser working besides ref which I just hacked around for now"><y>#</y><d>2021-07-23</d><h>15:33</h><w>Ben Sless</w>I&apos;ll try. I got the parser working besides ref which I just hacked around for now</z><z id="t1627056907" t="Ben Sless It works!"><y>#</y><d>2021-07-23</d><h>16:15</h><w>Ben Sless</w>It works!</z><z id="t1627056990" t="Ben Sless Updated the gist with working version, next step is a dynamic interpreter, followed by a compiler. It&apos;s pretty cool I can use the library to define new syntax. It extends itself"><y>#</y><d>2021-07-23</d><h>16:16</h><w>Ben Sless</w>Updated the gist with working version, next step is a dynamic interpreter, followed by a compiler.
It&apos;s pretty cool I can use the library to define new syntax. It extends itself</z><z id="t1627167478" t="nivekuil is there a way to work with bigints in cljs? trying to coerce a string (reitit route) to one"><y>#</y><d>2021-07-24</d><h>22:57</h><w>nivekuil</w>is there a way to work with bigints in cljs? trying to coerce a string (reitit route) to one</z><z id="t1627185928" t="nivekuil bigints are a headache with transit, just ended up using Long (defn -string-&gt;bigint [x] (if (string? x) (try #?(:clj (Long/parseLong x) :cljs (let [x&apos; (js/parseInt x)] (if (&gt; x&apos; js/Number.MAX_SAFE_INTEGER) (goog.math.Long/fromString x 10) x&apos;))) (catch #?(:clj Exception, :cljs js/Error) _ x)) x)) (defn string-transformer [] (mt/transformer {:name :string :decoders (assoc (mt/-string-decoders) :i64 -string-&gt;bigint) :encoders (assoc (mt/-string-encoders) :i64 mt/-any-&gt;string)})) "><y>#</y><d>2021-07-25</d><h>04:05</h><r>nivekuil</r>bigints are a headache with transit, just ended up using Long
<pre>(defn -string-&gt;bigint [x]
  (if (string? x)
    (try
      #?(:clj  (Long/parseLong x)
         :cljs (let [x&apos; (js/parseInt x)]
                 (if (&gt; x&apos; js/Number.MAX_SAFE_INTEGER)
                   (goog.math.Long/fromString x 10)
                   x&apos;)))
      (catch #?(:clj Exception, :cljs js/Error) _ x))
    x))

(defn string-transformer []
  (mt/transformer
   {:name     :string
    :decoders (assoc (mt/-string-decoders)
                     :i64 -string-&gt;bigint)
    :encoders (assoc (mt/-string-encoders)
                     :i64 mt/-any-&gt;string)}))</pre>
</z><z id="t1627208918" t="Ben Sless In providing a custom registry to a schema schema, what gets compiled? when?"><y>#</y><d>2021-07-25</d><h>10:28</h><w>Ben Sless</w>In providing a custom registry to a schema schema, what gets compiled? when?</z><z id="t1627565853" t="ikitommi ugh. can’t recall. you need to follow the code."><y>#</y><d>2021-07-29</d><h>13:37</h><r>ikitommi</r>ugh. can’t recall. you need to follow the code.</z><z id="t1627338536" t="greg [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] do you expect introducing :andn ? In my schema some of the properties have relations that could be verified. I do it by adding a top level :and and then modify/navigate it using indices (0 for the schema, 1... for predicates). Not a bit deal to use indices, still, the case looks similar to catn ."><y>#</y><d>2021-07-26</d><h>22:28</h><w>greg</w><a>@ikitommi</a> do you expect introducing <code>:andn</code>? In my schema some of the properties have relations that could be verified. I do it by adding a top level <code>:and</code> and then modify/navigate it using indices (0 for the schema, 1... for predicates). Not a bit deal to use indices, still, the case looks similar to <code>catn</code> .</z><z id="t1627565805" t="ikitommi sure, PR welcome."><y>#</y><d>2021-07-29</d><h>13:36</h><r>ikitommi</r>sure, PR welcome.</z><z id="t1627375984" t="Ben Sless I think this level of understanding the JIT is slightly above my pay grade. If someone here has expertise on the subject it would be most welcome https://github.com/metosin/malli/pull/485"><y>#</y><d>2021-07-27</d><h>08:53</h><w>Ben Sless</w>I think this level of understanding the JIT is slightly above my pay grade.
If someone here has expertise on the subject it would be most welcome
<a href="https://github.com/metosin/malli/pull/485" target="_blank">https://github.com/metosin/malli/pull/485</a></z><z id="t1627408840" t="greg I&apos;ve added a tip demonstrating that transformer, the one that calculates default value based on given fn in :default-fn PR: https://github.com/metosin/malli/pull/487"><y>#</y><d>2021-07-27</d><h>18:00</h><w>greg</w>I&apos;ve added a tip demonstrating that transformer, the one that calculates default value based on given fn in <code>:default-fn</code>
PR: <a href="https://github.com/metosin/malli/pull/487" target="_blank">https://github.com/metosin/malli/pull/487</a></z><z id="t1627435833" t="greg (def Schema (m/schema [:map [:y {:limit 20} int?]])) Given the above schema schema: 1. How to access properties of :y ? I tried 2. How to update :x to double it, e.g by passing #(* % 2) ? m/update combined with m/update-properties doesn&apos;t work for the same reason as above. 3. How to convert [:y {:limit 20} int?] to [:y {:limit 20} [:and int? [:&gt; 0]] without loosing properties. (mu/update Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]] ; I expected: [:map [:y {:limit 20} [:and int? [:&gt; 0]]]] Calling the update removes the original properties. Some workaround I think would be writing custom get &amp; update based on m/children . Doesn&apos;t look a difficult taks, just thought about asking before reinventing a wheel 🙂"><y>#</y><d>2021-07-28</d><h>01:30</h><w>greg</w><pre>(def Schema (m/schema [:map
                        [:y {:limit 20} int?]]))</pre>
 Given the above schema schema:

1. How to access properties of <code>:y</code>?
I tried 

2. How to update :x to double it, e.g by passing <code>#(* % 2)</code>?
m/update combined with m/update-properties doesn&apos;t work for the same reason as above.

3. How to convert <code>[:y {:limit 20} int?]</code> to <code>[:y {:limit 20} [:and int? [:&gt; 0]]</code> without loosing properties.
<pre>(mu/update Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]]
                                      ; I expected:  [:map [:y {:limit 20} [:and int? [:&gt; 0]]]]</pre>
Calling the update removes the original properties.

Some workaround I think would be writing custom <code>get</code> &amp; <code>update</code> based on <code>m/children</code>. Doesn&apos;t look a difficult taks, just thought about asking before reinventing a wheel <b>🙂</b></z><z id="t1627462121" t="Tuomas I had a similar issue and went with an approach like (def Schema (m/schema [:map [:y [int? {:limit 20}]]])) (m/validate Schema {:y &quot;1&quot;}) (m/validate Schema {:y 1}) (m/properties (mu/get Schema :y)) But I&apos;m a novice and not really sure how this should be done"><y>#</y><d>2021-07-28</d><h>08:48</h><r>Tuomas</r>I had a similar issue and went with an approach like
<pre>(def Schema (m/schema [:map
                       [:y [int? {:limit 20}]]]))
(m/validate Schema {:y &quot;1&quot;})
(m/validate Schema {:y 1})
(m/properties (mu/get Schema :y))</pre>
But I&apos;m a novice and not really sure how this should be done</z><z id="t1627467232" t="greg I think it would work for some cases, but it might be not a good idea to store child-owned props at schema level. Let&apos;s say I got this Schema (def Schema (m/schema [:map [:x number?] [:y [number? {:default 0}]]) If I do the simple :y update to ensure its &gt;= 0 I will get this: (-&gt; Schema (mu/update :y (fn [s] [:and s [:&gt;= 0]]))) ; =&gt; =&gt; [:map [:x number?] [:y [:and [number? {:default 0}] [:&gt;= 0]]]] And I think this kind of properties, to work properly, they need to be kept in top level of schema for given child, e.g.: [:map [:x number?] [:y [:and {:default 0} number? [:&gt;= 0]]] So to make this work you need both: • moving props from child (`[:y]`) to schema (`[number?]`) • adding custom update anyway (to move properties from original schema (`[number?]`) to a new enclosing schema (`[:and]`) But when doing this properties maneuver, how do you know which are owned by child and which by schema? You don&apos;t unless you explicitly specify it e.g. in update method. Conceptually I think it makes more sense to keep child-owned properties at child level, and schema-owned properties at schema level."><y>#</y><d>2021-07-28</d><h>10:13</h><r>greg</r>I think it would work for some cases, but it might be not a good idea to store child-owned props at schema level.

Let&apos;s say I got this Schema
<pre>(def Schema (m/schema [:map
                       [:x number?]
                       [:y [number? {:default 0}]])</pre>
If I do the simple :y update to ensure its &gt;= 0 I will get this:
<pre>(-&gt; Schema
    (mu/update :y (fn [s] [:and s [:&gt;= 0]])))
; =&gt; =&gt; [:map 
         [:x number?] 
         [:y [:and [number? {:default 0}] [:&gt;= 0]]]]</pre>
And I think this kind of properties, to work properly, they need to be kept in top level of schema for given child, e.g.:
<pre>[:map 
 [:x number?] 
 [:y [:and {:default 0} number? [:&gt;= 0]]]</pre>
So to make this work you need both:
• moving props from child (`[:y]`) to schema (`[number?]`)
• adding custom update anyway (to move properties from original schema (`[number?]`) to a new enclosing schema (`[:and]`) 
But when doing this properties maneuver, how do you know which are owned by child and which by schema? You don&apos;t unless you explicitly specify it e.g. in update method.

Conceptually I think it makes more sense to keep child-owned properties at child level, and schema-owned properties at schema level.</z><z id="t1627468052" t="greg Actually I went this path, and I implemented this custom update for properties manouver when updating a schema (e.g. moving from [number?] to [:and] ), but as I wrote, I don&apos;t think it is good idea. As I think now, it really makes more sense to just add a few new utility methods: get-child , get-child-props , update-child , update-child-props , update-child-schema . It is a bit weird that child properties disappear on child&apos;s schema update. It might be a bug. Who is John Galt? :man-shrugging:"><y>#</y><d>2021-07-28</d><h>10:27</h><r>greg</r>Actually I went this path, and I implemented this custom update for properties manouver when updating a schema (e.g. moving from <code>[number?]</code> to <code>[:and]</code> ), but as I wrote, I don&apos;t think it is good idea. As I think now, it really makes more sense to just add a few new utility methods: <code>get-child</code>, <code>get-child-props</code>, <code>update-child</code>, <code>update-child-props</code>, <code>update-child-schema</code>.

It is a bit weird that child properties disappear on child&apos;s schema update. It might be a bug. Who is John Galt? <b>:man-shrugging:</b></z><z id="t1627471982" t="greg I wrote a few utils fns to sort out my problems with manipulating map schemas: (defn get-child [s k] (-&gt;&gt; (m/children s) (filter #(= k (first %))) (first))) (defn get-child-props [s k] (-&gt; (get-child s k) second)) (defn get-child-schema [s k] (-&gt; (get-child s k) (nth 2))) (defn update-child [s key f &amp; args] (let [new-children (-&gt;&gt; (m/children s) (map (fn [child] (let [[k _p _v] child] (if (= key k) (apply f child args) child)))))] (m/into-schema (m/type s) (m/properties s) new-children))) (defn update-child-props [s k f &amp; args] (update-child s k (fn [c] (let [[k p v] c] [k (apply f p args) v])))) (defn update-child-schema [s k f &amp; args] (update-child s k (fn [c] (let [[k p v] c] [k p (apply f v args)])))) (comment (def Schema (m/schema [:map [:y {:default 20} int?]])) (get-child-schema Schema :y) ;; =&gt; int? (get-child-props Schema :y) ;; =&gt; {:default 20} ;; updates of child props (update-child-props Schema :y update :default dec) ;; =&gt; [:map [:y {:default 19} int?]] (update-child-props Schema :y assoc :limit 50) ;; =&gt; [:map [:y {:default 20, :limit 50} int?]] ;; update of child schema preserving child props (update-child-schema Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y {:default 20} [:and int? [:&gt; 0]]]] ;; update of child schema removing the props (mu/update Schema :y (fn [s] [:and s [:&gt; 0]]))) ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]] what do you think?"><y>#</y><d>2021-07-28</d><h>11:33</h><r>greg</r>I wrote a few utils fns to sort out my problems with manipulating map schemas:
<pre>(defn get-child [s k] (-&gt;&gt; (m/children s) (filter #(= k (first %))) (first)))
(defn get-child-props [s k] (-&gt; (get-child s k) second))
(defn get-child-schema [s k] (-&gt; (get-child s k) (nth 2)))

(defn update-child [s key f &amp; args]
  (let [new-children (-&gt;&gt; (m/children s)
                          (map (fn [child]
                                 (let [[k _p _v] child]
                                   (if (= key k) (apply f child args) child)))))]
    (m/into-schema (m/type s) (m/properties s) new-children)))

(defn update-child-props [s k f &amp; args]
  (update-child s k (fn [c]
                      (let [[k p v] c]
                        [k (apply f p args) v]))))

(defn update-child-schema [s k f &amp; args]
  (update-child s k (fn [c]
                      (let [[k p v] c]
                        [k p (apply f v args)]))))

(comment
 (def Schema (m/schema [:map [:y {:default 20} int?]]))
 (get-child-schema Schema :y)                             ;; =&gt; int?
 (get-child-props Schema :y)                              ;; =&gt; {:default 20}
 ;; updates of child props
 (update-child-props Schema :y update :default dec)       ;; =&gt; [:map [:y {:default 19} int?]]
 (update-child-props Schema :y assoc :limit 50)           ;; =&gt; [:map [:y {:default 20, :limit 50} int?]]
 ;; update of child schema preserving child props
 (update-child-schema Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y {:default 20} [:and int? [:&gt; 0]]]]
 ;; update of child schema removing the props
 (mu/update Schema :y (fn [s] [:and s [:&gt; 0]])))          ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]]</pre>
what do you think?</z><z id="t1627565517" t="ikitommi Looks good. Few comments: • mu/find gets the entry: (def Schema (m/schema [:map [:y {:limit 20} int?]])) (mu/find Schema :y) ; =&gt; [:y {:limit 20} int?] • when calling m/into-schema you should always use m/parent instead of m/type as first argument - m/type makes a registry lookup, m/parent points directly to the IntoSchema instance that created the schema. Faster AND adds support for non-registered schemas, e.g. (def Over6 (m/-simple-schema {:type :user/over6 ;; dummy-type, not registered :pred #(and (int? %) (&gt; % 6)) :type-properties {:error/message &quot;should be over 6&quot; :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum 6 :gen/gen generate-over6}})) (= Over6 (m/parent [Over6 {:json-schema/example 42}])) ; =&gt; true • for now, we could have a mu/-update-entry-properties helper, PR welcome • for future (1.0.0), the entry design should be revisited, not happy how it is now"><y>#</y><d>2021-07-29</d><h>13:31</h><r>ikitommi</r>Looks good. Few comments:

• <code>mu/find</code> gets the entry:
<pre>(def Schema (m/schema [:map [:y {:limit 20} int?]]))

(mu/find Schema :y)
; =&gt; [:y {:limit 20} int?]</pre>
• when calling <code>m/into-schema</code> you should always use <code>m/parent</code> instead of <code>m/type</code> as first argument - <code>m/type</code> makes a registry lookup, <code>m/parent</code> points directly to the <code>IntoSchema</code> instance that created the schema. Faster AND adds support for non-registered schemas, e.g.
<pre>(def Over6
  (m/-simple-schema
    {:type :user/over6 ;; dummy-type, not registered
     :pred #(and (int? %) (&gt; % 6))
     :type-properties {:error/message &quot;should be over 6&quot;
                       :decode/string mt/-string-&gt;long
                       :json-schema/type &quot;integer&quot;
                       :json-schema/format &quot;int64&quot;
                       :json-schema/minimum 6
                       :gen/gen generate-over6}}))

(= Over6 (m/parent [Over6 {:json-schema/example 42}]))
; =&gt; true</pre>
• for now, we could have a <code>mu/-update-entry-properties</code> helper, PR welcome
• for future (1.0.0), the entry design should be revisited, not happy how it is now</z><z id="t1627569107" t="greg thanks a lot for the comments, I&apos;ll prepare a PR when I find spare time"><y>#</y><d>2021-07-29</d><h>14:31</h><r>greg</r>thanks a lot for the comments, I&apos;ll prepare a PR when I find spare time</z><z id="t1627468647" t="Ben Sless Figured out today a decoder can be used to reject wrong values: {:compile (fn [schema _] (let [s (set (m/children schema))] (fn [v] (s v))))}"><y>#</y><d>2021-07-28</d><h>10:37</h><w>Ben Sless</w>Figured out today a decoder can be used to reject wrong values: <code>{:compile (fn [schema _] (let [s (set (m/children schema))] (fn [v] (s v))))}</code></z><z id="t1627565778" t="ikitommi bit like mt/strip-extra-keys-transformer 😉"><y>#</y><d>2021-07-29</d><h>13:36</h><r>ikitommi</r>bit like <code>mt/strip-extra-keys-transformer</code> <b>😉</b></z><z id="t1627635249" t="Ben Sless Similar, but just &quot;forces&quot; invalid enum values to be nil."><y>#</y><d>2021-07-30</d><h>08:54</h><r>Ben Sless</r>Similar, but just &quot;forces&quot; invalid enum values to be nil.</z><z id="t1627468666" t="Ben Sless Sort of coercion"><y>#</y><d>2021-07-28</d><h>10:37</h><w>Ben Sless</w>Sort of coercion</z><z id="t1627471982" t="greg I wrote a few utils fns to sort out my problems with manipulating map schemas: (defn get-child [s k] (-&gt;&gt; (m/children s) (filter #(= k (first %))) (first))) (defn get-child-props [s k] (-&gt; (get-child s k) second)) (defn get-child-schema [s k] (-&gt; (get-child s k) (nth 2))) (defn update-child [s key f &amp; args] (let [new-children (-&gt;&gt; (m/children s) (map (fn [child] (let [[k _p _v] child] (if (= key k) (apply f child args) child)))))] (m/into-schema (m/type s) (m/properties s) new-children))) (defn update-child-props [s k f &amp; args] (update-child s k (fn [c] (let [[k p v] c] [k (apply f p args) v])))) (defn update-child-schema [s k f &amp; args] (update-child s k (fn [c] (let [[k p v] c] [k p (apply f v args)])))) (comment (def Schema (m/schema [:map [:y {:default 20} int?]])) (get-child-schema Schema :y) ;; =&gt; int? (get-child-props Schema :y) ;; =&gt; {:default 20} ;; updates of child props (update-child-props Schema :y update :default dec) ;; =&gt; [:map [:y {:default 19} int?]] (update-child-props Schema :y assoc :limit 50) ;; =&gt; [:map [:y {:default 20, :limit 50} int?]] ;; update of child schema preserving child props (update-child-schema Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y {:default 20} [:and int? [:&gt; 0]]]] ;; update of child schema removing the props (mu/update Schema :y (fn [s] [:and s [:&gt; 0]]))) ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]] what do you think?"><y>#</y><d>2021-07-28</d><h>11:33</h><w>greg</w>I wrote a few utils fns to sort out my problems with manipulating map schemas:
<pre>(defn get-child [s k] (-&gt;&gt; (m/children s) (filter #(= k (first %))) (first)))
(defn get-child-props [s k] (-&gt; (get-child s k) second))
(defn get-child-schema [s k] (-&gt; (get-child s k) (nth 2)))

(defn update-child [s key f &amp; args]
  (let [new-children (-&gt;&gt; (m/children s)
                          (map (fn [child]
                                 (let [[k _p _v] child]
                                   (if (= key k) (apply f child args) child)))))]
    (m/into-schema (m/type s) (m/properties s) new-children)))

(defn update-child-props [s k f &amp; args]
  (update-child s k (fn [c]
                      (let [[k p v] c]
                        [k (apply f p args) v]))))

(defn update-child-schema [s k f &amp; args]
  (update-child s k (fn [c]
                      (let [[k p v] c]
                        [k p (apply f v args)]))))

(comment
 (def Schema (m/schema [:map [:y {:default 20} int?]]))
 (get-child-schema Schema :y)                             ;; =&gt; int?
 (get-child-props Schema :y)                              ;; =&gt; {:default 20}
 ;; updates of child props
 (update-child-props Schema :y update :default dec)       ;; =&gt; [:map [:y {:default 19} int?]]
 (update-child-props Schema :y assoc :limit 50)           ;; =&gt; [:map [:y {:default 20, :limit 50} int?]]
 ;; update of child schema preserving child props
 (update-child-schema Schema :y (fn [s] [:and s [:&gt; 0]])) ;; =&gt; [:map [:y {:default 20} [:and int? [:&gt; 0]]]]
 ;; update of child schema removing the props
 (mu/update Schema :y (fn [s] [:and s [:&gt; 0]])))          ;; =&gt; [:map [:y [:and int? [:&gt; 0]]]]</pre>
what do you think?</z><z id="t1627565517" t="ikitommi Looks good. Few comments: • mu/find gets the entry: (def Schema (m/schema [:map [:y {:limit 20} int?]])) (mu/find Schema :y) ; =&gt; [:y {:limit 20} int?] • when calling m/into-schema you should always use m/parent instead of m/type as first argument - m/type makes a registry lookup, m/parent points directly to the IntoSchema instance that created the schema. Faster AND adds support for non-registered schemas, e.g. (def Over6 (m/-simple-schema {:type :user/over6 ;; dummy-type, not registered :pred #(and (int? %) (&gt; % 6)) :type-properties {:error/message &quot;should be over 6&quot; :decode/string mt/-string-&gt;long :json-schema/type &quot;integer&quot; :json-schema/format &quot;int64&quot; :json-schema/minimum 6 :gen/gen generate-over6}})) (= Over6 (m/parent [Over6 {:json-schema/example 42}])) ; =&gt; true • for now, we could have a mu/-update-entry-properties helper, PR welcome • for future (1.0.0), the entry design should be revisited, not happy how it is now"><y>#</y><d>2021-07-29</d><h>13:31</h><w>ikitommi</w>Looks good. Few comments:

• <code>mu/find</code> gets the entry:
<pre>(def Schema (m/schema [:map [:y {:limit 20} int?]]))

(mu/find Schema :y)
; =&gt; [:y {:limit 20} int?]</pre>
• when calling <code>m/into-schema</code> you should always use <code>m/parent</code> instead of <code>m/type</code> as first argument - <code>m/type</code> makes a registry lookup, <code>m/parent</code> points directly to the <code>IntoSchema</code> instance that created the schema. Faster AND adds support for non-registered schemas, e.g.
<pre>(def Over6
  (m/-simple-schema
    {:type :user/over6 ;; dummy-type, not registered
     :pred #(and (int? %) (&gt; % 6))
     :type-properties {:error/message &quot;should be over 6&quot;
                       :decode/string mt/-string-&gt;long
                       :json-schema/type &quot;integer&quot;
                       :json-schema/format &quot;int64&quot;
                       :json-schema/minimum 6
                       :gen/gen generate-over6}}))

(= Over6 (m/parent [Over6 {:json-schema/example 42}]))
; =&gt; true</pre>
• for now, we could have a <code>mu/-update-entry-properties</code> helper, PR welcome
• for future (1.0.0), the entry design should be revisited, not happy how it is now</z><z id="t1627551782" t="danielneal is there an malli.util/assoc that will allow to set the properties and schema of a key"><y>#</y><d>2021-07-29</d><h>09:43</h><w>danielneal</w>is there an <code>malli.util/assoc</code> that will allow to set the properties and schema of a key</z><z id="t1627551788" t="danielneal or a different function?"><y>#</y><d>2021-07-29</d><h>09:43</h><w>danielneal</w>or a different function?</z><z id="t1627553081" t="greg That was part my question I posted https://clojurians.slack.com/archives/CLDK6MFMK/p1627435833075200 . I did not found a way of doing it at Malli. But it is fairly easy to do using m/children . If you have a look at my other https://clojurians.slack.com/archives/CLDK6MFMK/p1627471982078700?thread_ts=1627435833.075200&amp;amp;cid=CLDK6MFMK on this channel, I wrote a few utility methods. One of them is update-child-props . It was a first draft, I modified them since then, but even with it, you can do what you want, e.g. (update-child-props (m/schema [:map [:y {:default 20} int?]]) :y update :default dec) ;; =&gt; [:map [:y {:default 19} int?]] (update-child-props (m/schema [:map [:y {:default 20} int?]]) :y assoc :limit 50) ;; =&gt; [:map [:y {:default 20, :limit 50} int?]] "><y>#</y><d>2021-07-29</d><h>10:04</h><r>greg</r>That was part my question I posted <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1627435833075200" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1627435833075200</a>. I did not found a way of doing it at Malli.
But it is fairly easy to do using <code>m/children</code>.

If you have a look at my other <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1627471982078700?thread_ts=1627435833.075200&amp;amp;cid=CLDK6MFMK" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1627471982078700?thread_ts=1627435833.075200&amp;amp;cid=CLDK6MFMK</a> on this channel, I wrote a few utility methods.
One of them is <code>update-child-props</code>.

It was a first draft, I modified them since then, but even with it, you can do what you want, e.g.
<pre>(update-child-props (m/schema [:map [:y {:default 20} int?]]) :y update :default dec) 
;; =&gt; [:map [:y {:default 19} int?]]

(update-child-props (m/schema [:map [:y {:default 20} int?]]) :y assoc :limit 50)           
;; =&gt; [:map [:y {:default 20, :limit 50} int?]]</pre>
</z><z id="t1627563430" t="greg Unless I misunderstood &quot;allow to set the properties and schema of a key&quot; 😅"><y>#</y><d>2021-07-29</d><h>12:57</h><r>greg</r>Unless I misunderstood &quot;allow to set the properties and schema of a key&quot; <b>😅</b></z><z id="t1627565694" t="ikitommi maybe: (mu/assoc [:map [:y {:old true} int?]] [:y {:new true}] string?) ; =&gt; [:map [:y {:new true} string?]]"><y>#</y><d>2021-07-29</d><h>13:34</h><r>ikitommi</r>maybe:
<pre>(mu/assoc 
  [:map [:y {:old true} int?]] 
  [:y {:new true}] string?)
; =&gt; [:map [:y {:new true} string?]]</pre></z><z id="t1627568915" t="danielneal aha, thanks!"><y>#</y><d>2021-07-29</d><h>14:28</h><r>danielneal</r>aha, thanks!</z><z id="t1627566238" t="Itay Hi, I posted this in the #reitit channel but still did not get any response. No reply on the issue I opened either. Since it is Malli related, I thought perhaps I could get some feedback here. Thanks."><y>#</y><d>2021-07-29</d><h>13:43</h><w>Itay</w>Hi,

I posted this in the #reitit channel but still did not get any response.
No reply on the issue I opened either.

Since it is Malli related, I thought perhaps I could get some feedback here.

Thanks.</z><z id="t1627566278" t="ikitommi [:attrs {:href &quot;/_/_/users/U015CL9NSLE&quot;}] I can take a look at that today/tomorrow"><y>#</y><d>2021-07-29</d><h>13:44</h><w>ikitommi</w><a>@itaysabato</a> I can take a look at that today/tomorrow</z><z id="t1627892576" t="Itay Good morning 🙂 Any news regarding this issue?"><y>#</y><d>2021-08-02</d><h>08:22</h><r>Itay</r>Good morning <b>🙂</b>
Any news regarding this issue?</z><z id="t1627909335" t="ikitommi totally forgot, sorry. will try to look later today."><y>#</y><d>2021-08-02</d><h>13:02</h><r>ikitommi</r>totally forgot, sorry. will try to look later today.</z><z id="t1627970465" t="ikitommi did a PR, might fix it. Depending on the exceptations"><y>#</y><d>2021-08-03</d><h>06:01</h><r>ikitommi</r>did a PR, might fix it. Depending on the exceptations</z><z id="t1627978627" t="Itay Thank you for this! Looks like it did. I commented on one line that I didn&apos;t get, but the rest looks solid to me."><y>#</y><d>2021-08-03</d><h>08:17</h><r>Itay</r>Thank you for this!
Looks like it did.
I commented on one line that I didn&apos;t get, but the rest looks solid to me.</z><z id="t1627982827" t="ikitommi answered. I&apos;m not near computer, if you could verify the old behavior (does it strip extras or not), would help. Thanks."><y>#</y><d>2021-08-03</d><h>09:27</h><r>ikitommi</r>answered. I&apos;m not near computer, if you could verify the old behavior (does it strip extras or not), would help. Thanks.</z><z id="t1628418843" t="Itay Sorry, I was away for a few days. Is it still relevant to test the old strip keys behavior? I will soon try the fixed version"><y>#</y><d>2021-08-08</d><h>10:34</h><r>Itay</r>Sorry, I was away for a few days.
Is it still relevant to test the old strip keys behavior?
I will soon try the fixed version</z><z id="t1627566304" t="Itay [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] That would be lovely, thank you!"><y>#</y><d>2021-07-29</d><h>13:45</h><w>Itay</w><a>@ikitommi</a> That would be lovely, thank you!</z><z id="t1627566919" t="ikitommi quick poke on instrumentation: malli.dev/start! will now collect function schemas from all public vars from all loaded namespaces."><y>#</y><d>2021-07-29</d><h>13:55</h><w>ikitommi</w>quick poke on instrumentation: <code>malli.dev/start!</code> will now collect function schemas from all public vars from all loaded namespaces.</z><z id="t1627566969" t="ikitommi I would like to add Var-watches too, so any Var change would re-trigger instrumentation of that Var. But didn’t work in the 30min timebox I had for it."><y>#</y><d>2021-07-29</d><h>13:56</h><w>ikitommi</w>I would like to add Var-watches too, so any Var change would re-trigger instrumentation of that Var. But didn’t work in the 30min timebox I had for it.</z><z id="t1627567031" t="ikitommi anyway, dx should be better than before. feedback welcome on the instrumention. If anyone has tried that…"><y>#</y><d>2021-07-29</d><h>13:57</h><w>ikitommi</w>anyway, dx should be better than before. feedback welcome on the instrumention. If anyone has tried that…</z><z id="t1627567040" t="ikitommi"><y>#</y><d>2021-07-29</d><h>13:57</h><w>ikitommi</w></z><z id="t1627567366" t="ikitommi goal is to do the first version of pretty error reporting for 0.6.0, to celebrate the two year birthday of the initial demo of that ( https://github.com/metosin/malli/issues/19 ). Making open source 1h here and there isn’t the fastest way to finish stuff 😎 "><y>#</y><d>2021-07-29</d><h>14:02</h><w>ikitommi</w>goal is to do the first version of pretty error reporting for 0.6.0, to celebrate the two year birthday of the initial demo of that (<a href="https://github.com/metosin/malli/issues/19" target="_blank">https://github.com/metosin/malli/issues/19</a>). Making open source 1h here and there  isn’t the fastest way to finish stuff <b>😎</b> </z><z id="t1627567371" t="NoahTheDuke hey all, just started using malli in a new part of my project, and i’m struggling to check if a value is a function"><y>#</y><d>2021-07-29</d><h>14:02</h><w>NoahTheDuke</w>hey all, just started using malli in a new part of my project, and i’m struggling to check if a value is a function</z><z id="t1627567386" t="NoahTheDuke (def Step [:map {:closed true} [:uuid uuid?] [:continue-fn fn?] [:complete? boolean?] [:phase keyword?]]) "><y>#</y><d>2021-07-29</d><h>14:03</h><w>NoahTheDuke</w><pre>(def Step
  [:map {:closed true}
   [:uuid uuid?]
   [:continue-fn fn?]
   [:complete? boolean?]
   [:phase keyword?]])</pre>
</z><z id="t1627567396" t="ikitommi should work"><y>#</y><d>2021-07-29</d><h>14:03</h><w>ikitommi</w>should work</z><z id="t1627567431" t="ikitommi fn? was added few days ago thou, it was missing. you should depend on the latest sha"><y>#</y><d>2021-07-29</d><h>14:03</h><w>ikitommi</w><code>fn?</code> was added few days ago thou, it was missing. you should depend on the latest sha</z><z id="t1627567442" t="NoahTheDuke ah that’s probably it, i’m using the clojars version"><y>#</y><d>2021-07-29</d><h>14:04</h><w>NoahTheDuke</w>ah that’s probably it, i’m using the clojars version</z><z id="t1627567463" t="ikitommi [:fn fn?] works also. :fn is the escape hatch, “any function”"><y>#</y><d>2021-07-29</d><h>14:04</h><w>ikitommi</w><code>[:fn fn?]</code> works also. <code>:fn</code> is the escape hatch, “any function”</z><z id="t1627567643" t="NoahTheDuke that works! thanks so much"><y>#</y><d>2021-07-29</d><h>14:07</h><w>NoahTheDuke</w>that works! thanks so much</z><z id="t1627568199" t="ikitommi immutable clojars-snapshot of the latest stuff: ➜ ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.0-SNAPSHOT&quot;}}}&apos; Downloading: metosin/malli/0.6.0-SNAPSHOT/malli-0.6.0-20210729.141459-4.pom from clojars"><y>#</y><d>2021-07-29</d><h>14:16</h><w>ikitommi</w>immutable clojars-snapshot of the latest stuff:
<pre>➜  ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.0-SNAPSHOT&quot;}}}&apos;
Downloading: metosin/malli/0.6.0-SNAPSHOT/malli-0.6.0-20210729.141459-4.pom from clojars</pre></z><z id="t1627568265" t="ikitommi btw, [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] there is a new guide for function schmemas at https://github.com/metosin/malli/blob/master/docs/function-schemas.md"><y>#</y><d>2021-07-29</d><h>14:17</h><w>ikitommi</w>btw, <a>@nbtheduke</a> there is a new guide for function schmemas at <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md</a></z><z id="t1627568298" t="NoahTheDuke missed that there were further docs, i’ll read over that now"><y>#</y><d>2021-07-29</d><h>14:18</h><w>NoahTheDuke</w>missed that there were further docs, i’ll read over that now</z><z id="t1627639547" t="Ben Sless Curious why change from ArrayList to LinkedList in the transformers&apos; implementation. Aren&apos;t arrays better for iteration and cache?"><y>#</y><d>2021-07-30</d><h>10:05</h><w>Ben Sless</w>Curious why change from ArrayList to LinkedList in the transformers&apos; implementation. Aren&apos;t arrays better for iteration and cache?</z><z id="t1627640795" t="ikitommi LinkedList has much simpler iterator impl. Didn&apos;t see any visible perf difference thou."><y>#</y><d>2021-07-30</d><h>10:26</h><w>ikitommi</w>LinkedList has much simpler iterator impl. Didn&apos;t see any visible perf difference thou.</z><z id="t1627643104" t="Ben Sless This is slightly theoretical, but ArrayLists have a smaller memory footprint and their backing array is contiguous in memory which ought to give better performance. Also, although the iterator implementation is simpler, ArrayLists would probably benefit from branch predictions, while pointer-chasing with linked lists gives you no guarantees"><y>#</y><d>2021-07-30</d><h>11:05</h><w>Ben Sless</w>This is slightly theoretical, but ArrayLists have a smaller memory footprint and their backing array is contiguous in memory which ought to give better performance. Also, although the iterator implementation is simpler, ArrayLists would probably benefit from branch predictions, while pointer-chasing with linked lists gives you no guarantees</z><z id="t1627643204" t="Ben Sless https://stackoverflow.com/questions/8436489/using-a-linkedlist-or-arraylist-for-iteration"><y>#</y><d>2021-07-30</d><h>11:06</h><w>Ben Sless</w><a href="https://stackoverflow.com/questions/8436489/using-a-linkedlist-or-arraylist-for-iteration" target="_blank">https://stackoverflow.com/questions/8436489/using-a-linkedlist-or-arraylist-for-iteration</a></z><z id="t1627643244" t="Ben Sless Modern CPUs like arrays 😞"><y>#</y><d>2021-07-30</d><h>11:07</h><w>Ben Sless</w>Modern CPUs like arrays <b>😞</b></z><z id="t1627659375" t="greg I guess you talk about https://github.com/metosin/malli/commit/dd19b9e . I, same as [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] , would choose ArrayList, especially that we know the size of data. Theoretically it should be faster in allocation of memory and further iteration, but well, always good to see relevant data. Personally I don&apos;t care about performance that much so I don&apos;t mind either of them. Still, I&apos;m curious, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] why the iterator&apos;s impl matters to you since its interface is the same?"><y>#</y><d>2021-07-30</d><h>15:36</h><r>greg</r>I guess you talk about <a href="https://github.com/metosin/malli/commit/dd19b9e" target="_blank">https://github.com/metosin/malli/commit/dd19b9e</a>.
I, same as <a>@UK0810AQ2</a>, would choose ArrayList, especially that we know the size of data. Theoretically it should be faster in allocation of memory and further iteration, but well, always good to see relevant data.

Personally I don&apos;t care about performance that much so I don&apos;t mind either of them. Still, I&apos;m curious, <a>@U055NJ5CC</a> why the iterator&apos;s impl matters to you since its interface is the same?</z><z id="t1627661063" t="ikitommi Collection transformers will be rewritten by [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] to remove all iteration. But, perf comes from impl, not perf. Was really iteresting read, I still think the iteration is faster on LL, but, irrelevant here. As a generic data structure AL is much better."><y>#</y><d>2021-07-30</d><h>16:04</h><r>ikitommi</r>Collection transformers will be rewritten by <a>@UK0810AQ2</a> to remove all iteration. But, perf comes from impl, not perf. Was really iteresting read, I still think the iteration is faster on LL, but, irrelevant here. As a generic data structure AL is much better.</z><z id="t1627667496" t="Ben Sless I don&apos;t know if the composition based solution will be faster. Will try to poke at it with jmh"><y>#</y><d>2021-07-30</d><h>17:51</h><r>Ben Sless</r>I don&apos;t know if the composition based solution will be faster. Will try to poke at it with jmh</z><z id="t1627731582" t="Ben Sless Right, jmh is running, results in a few hours"><y>#</y><d>2021-07-31</d><h>11:39</h><r>Ben Sless</r>Right, jmh is running, results in a few hours</z><z id="t1627739768" t="Ben Sless ([:map-transformer/linked-list {:count 1} [6.156812627775496E7 &quot;ops/s&quot;]] [:map-transformer/linked-list {:count 2} [3.2994990990360465E7 &quot;ops/s&quot;]] [:map-transformer/linked-list {:count 4} [1.7037915234624855E7 &quot;ops/s&quot;]] [:map-transformer/linked-list {:count 8} [7557295.433684901 &quot;ops/s&quot;]] [:map-transformer/linked-list {:count 16} [1566793.27656629 &quot;ops/s&quot;]] [:map-transformer/linked-list {:count 32} [704492.6211734915 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 1} [6.3440679176932156E7 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 2} [3.439043251403162E7 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 4} [1.689684037729955E7 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 8} [7481296.308118063 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 16} [1550320.2392137954 &quot;ops/s&quot;]] [:map-transformer/array-list {:count 32} [713659.2962506406 &quot;ops/s&quot;]] [:map-transformer/comp {:count 1} [8.510126517455931E7 &quot;ops/s&quot;]] [:map-transformer/comp {:count 2} [4.2607291886022285E7 &quot;ops/s&quot;]] [:map-transformer/comp {:count 4} [1.9971178945141207E7 &quot;ops/s&quot;]] [:map-transformer/comp {:count 8} [8451028.653528532 &quot;ops/s&quot;]] [:map-transformer/comp {:count 16} [1599471.9346010373 &quot;ops/s&quot;]] [:map-transformer/comp {:count 32} [737048.961960025 &quot;ops/s&quot;]]) "><y>#</y><d>2021-07-31</d><h>13:56</h><r>Ben Sless</r><pre>([:map-transformer/linked-list {:count 1} [6.156812627775496E7 &quot;ops/s&quot;]]
 [:map-transformer/linked-list {:count 2} [3.2994990990360465E7 &quot;ops/s&quot;]]
 [:map-transformer/linked-list {:count 4} [1.7037915234624855E7 &quot;ops/s&quot;]]
 [:map-transformer/linked-list {:count 8} [7557295.433684901 &quot;ops/s&quot;]]
 [:map-transformer/linked-list {:count 16} [1566793.27656629 &quot;ops/s&quot;]]
 [:map-transformer/linked-list {:count 32} [704492.6211734915 &quot;ops/s&quot;]]

 [:map-transformer/array-list {:count 1} [6.3440679176932156E7 &quot;ops/s&quot;]]
 [:map-transformer/array-list {:count 2} [3.439043251403162E7 &quot;ops/s&quot;]]
 [:map-transformer/array-list {:count 4} [1.689684037729955E7 &quot;ops/s&quot;]]
 [:map-transformer/array-list {:count 8} [7481296.308118063 &quot;ops/s&quot;]]
 [:map-transformer/array-list {:count 16} [1550320.2392137954 &quot;ops/s&quot;]]
 [:map-transformer/array-list {:count 32} [713659.2962506406 &quot;ops/s&quot;]]

 [:map-transformer/comp {:count 1} [8.510126517455931E7 &quot;ops/s&quot;]]
 [:map-transformer/comp {:count 2} [4.2607291886022285E7 &quot;ops/s&quot;]]
 [:map-transformer/comp {:count 4} [1.9971178945141207E7 &quot;ops/s&quot;]]
 [:map-transformer/comp {:count 8} [8451028.653528532 &quot;ops/s&quot;]]
 [:map-transformer/comp {:count 16} [1599471.9346010373 &quot;ops/s&quot;]]
 [:map-transformer/comp {:count 32} [737048.961960025 &quot;ops/s&quot;]])</pre>
</z><z id="t1627742486" t="Ben Sless Another avenue I want to explore is creating from an array. Can&apos;t avoid an array copy anyway, so why not copy just once?"><y>#</y><d>2021-07-31</d><h>14:41</h><r>Ben Sless</r>Another avenue I want to explore is creating from an array. Can&apos;t avoid an array copy anyway, so why not copy just once?</z><z id="t1627759489" t="Ben Sless more plausible to achieve with a tuple transformer, don&apos;t know if can be done with map"><y>#</y><d>2021-07-31</d><h>19:24</h><r>Ben Sless</r>more plausible to achieve with a tuple transformer, don&apos;t know if can be done with map</z><z id="t1627795924" t="Ben Sless I think I found a faster way to transform a tuple: (defn -tuple-transformer [ts] (let [ts (map (fn [[k t]] (let [i (int k)] (fn [^objects arr] (aset arr i (t (aget arr i))) arr))) ts) t (apply -comp ts)] (fn [^clojure.lang.APersistentVector x] (clojure.lang.LazilyPersistentVector/createOwning (t (.toArray x)))))) Will check some arities combinations, initial tests look promising"><y>#</y><d>2021-08-01</d><h>05:32</h><r>Ben Sless</r>I think I found a faster way to transform a tuple:
<pre>(defn -tuple-transformer [ts]
  (let [ts (map (fn [[k t]] (let [i (int k)] (fn [^objects arr] (aset arr i (t (aget arr i))) arr))) ts)
        t (apply -comp ts)]
    (fn [^clojure.lang.APersistentVector x]
      (clojure.lang.LazilyPersistentVector/createOwning (t (.toArray x))))))</pre>
Will check some arities combinations, initial tests look promising</z><z id="t1627644321" t="danielneal If you want to have different error messages for different predicates in a malli schema, would it be wrong to do this"><y>#</y><d>2021-07-30</d><h>11:25</h><w>danielneal</w>If you want to have different error messages for different predicates in a malli schema, would it be wrong to do this</z><z id="t1627644342" t="danielneal [:and [:fn {:error/message &quot;error 1&quot;} some-constraint] [:fn {:error/message &quot;error 2&quot;} some-other-constraint]]"><y>#</y><d>2021-07-30</d><h>11:25</h><w>danielneal</w><pre>[:and [:fn {:error/message &quot;error 1&quot;} some-constraint]
[:fn {:error/message &quot;error 2&quot;} some-other-constraint]]</pre></z><z id="t1627653390" t="danielneal what’s the schema for a malli schema? e.g. for a key in a map there’s a key in a map that can be a schema [:map [:a int?] [:spec :???schema???]]"><y>#</y><d>2021-07-30</d><h>13:56</h><w>danielneal</w>what’s the schema for a malli schema? e.g. for a key in a map there’s a key in a map that can be a schema <code>[:map [:a int?] [:spec :???schema???]]</code></z><z id="t1627655702" t="respatialized The term I&apos;ve used to describe this is alternately &quot;meta-schema&quot; or &quot;self-describing schema&quot; - there isn&apos;t one yet for malli schemas."><y>#</y><d>2021-07-30</d><h>14:35</h><r>respatialized</r>The term I&apos;ve used to describe this is alternately &quot;meta-schema&quot; or &quot;self-describing schema&quot; - there isn&apos;t one yet for <code>malli</code> schemas.</z><z id="t1627656237" t="danielneal ah ok, thanks"><y>#</y><d>2021-07-30</d><h>14:43</h><r>danielneal</r>ah ok, thanks</z><z id="t1627656241" t="danielneal I’ll just use any? I guess"><y>#</y><d>2021-07-30</d><h>14:44</h><r>danielneal</r>I’ll just use any? I guess</z><z id="t1627653414" t="danielneal couldn’t figure out what to search for"><y>#</y><d>2021-07-30</d><h>13:56</h><w>danielneal</w>couldn’t figure out what to search for</z><z id="t1627653447" t="danielneal the word schema appears a lot 😉"><y>#</y><d>2021-07-30</d><h>13:57</h><w>danielneal</w>the word schema appears a lot <b>😉</b></z><z id="t1627653828" t="danielneal is it just malli/schema? ?"><y>#</y><d>2021-07-30</d><h>14:03</h><w>danielneal</w>is it just <code>malli/schema?</code>?</z><z id="t1627653868" t="danielneal hm no that doesn’t seem to work"><y>#</y><d>2021-07-30</d><h>14:04</h><w>danielneal</w>hm no that doesn’t seem to work</z><z id="t1627654420" t="NoahTheDuke does malli care about stuff like volatile! ? I have a schema for a map and i’m thinking of changing it to a volatile, so how do I put that in my schema? I changed the schema to [:volatile [:map …]] but that didn’t work"><y>#</y><d>2021-07-30</d><h>14:13</h><w>NoahTheDuke</w>does malli care about stuff like <code>volatile!</code>? I have a schema for a map and i’m thinking of changing it to a volatile, so how do I put that in my schema? I changed the schema to <code>[:volatile [:map …]]</code> but that didn’t work</z><z id="t1627655702" t="respatialized The term I&apos;ve used to describe this is alternately &quot;meta-schema&quot; or &quot;self-describing schema&quot; - there isn&apos;t one yet for malli schemas."><y>#</y><d>2021-07-30</d><h>14:35</h><w>respatialized</w>The term I&apos;ve used to describe this is alternately &quot;meta-schema&quot; or &quot;self-describing schema&quot; - there isn&apos;t one yet for <code>malli</code> schemas.</z><z id="t1627806679" t="Ben Sless hot take: :fn schema should be deprecated"><y>#</y><d>2021-08-01</d><h>08:31</h><w>Ben Sless</w>hot take: <code>:fn</code> schema should be deprecated</z><z id="t1627807784" t="ikitommi why is that?"><y>#</y><d>2021-08-01</d><h>08:49</h><w>ikitommi</w>why is that?</z><z id="t1627809172" t="Ben Sless 95% of the instances I saw it used the programmer should have used properties or defined a -simple-schema"><y>#</y><d>2021-08-01</d><h>09:12</h><w>Ben Sless</w>95% of the instances I saw it used the programmer should have used properties or defined a -simple-schema</z><z id="t1627809271" t="Ben Sless It is used in a way too general manner, usually one which impairs serialization and generation"><y>#</y><d>2021-08-01</d><h>09:14</h><w>Ben Sless</w>It is used in a way too general manner, usually one which impairs serialization and generation</z><z id="t1627809356" t="Ben Sless We can write guides and improve documentation and give workshops and do backflips and pay for ads on the superbowl, people will still use :fn because it&apos;s easy"><y>#</y><d>2021-08-01</d><h>09:15</h><w>Ben Sless</w>We can write guides and improve documentation and give workshops and do backflips and pay for ads on the superbowl, people will still use <code>:fn</code> because it&apos;s easy</z><z id="t1627809658" t="Ben Sless generators and transformers suffer from this, big time"><y>#</y><d>2021-08-01</d><h>09:20</h><w>Ben Sless</w>generators and transformers suffer from this, big time</z><z id="t1627809673" t="Ben Sless And it makes the code opaque"><y>#</y><d>2021-08-01</d><h>09:21</h><w>Ben Sless</w>And it makes the code opaque</z><z id="t1627815397" t="Ben Sless I did say this was a hot take 🙃"><y>#</y><d>2021-08-01</d><h>10:56</h><w>Ben Sless</w>I did say this was a hot take <b>🙃</b></z><z id="t1627816849" t="greg I think -simple-schema is not always what you want to do. And yes :fn is pretty handy, especially if you don&apos;t need transformers and generators but only validation. I&apos;m not sure it would be a good move to force people to use -simple-schema just for validation (e.g. involving two or more map entries)."><y>#</y><d>2021-08-01</d><h>11:20</h><w>greg</w>I think -simple-schema is not always what you want to do. And yes :fn is pretty handy, especially if you don&apos;t need transformers and generators but only validation. I&apos;m not sure it would be a good move to force people to use -simple-schema just for validation (e.g. involving two or more map entries).</z><z id="t1627818023" t="Ben Sless This is absolutely me speaking from frustration, not a definitive or proscriptive solution"><y>#</y><d>2021-08-01</d><h>11:40</h><w>Ben Sless</w>This is absolutely me speaking from frustration, not a definitive or proscriptive solution</z><z id="t1627818353" t="Ben Sless The problem isn&apos;t using fn but using it where [:string {:max 10 }] would do"><y>#</y><d>2021-08-01</d><h>11:45</h><w>Ben Sless</w>The problem isn&apos;t using <code>fn</code> but using it where <code>[:string {:max 10 }]</code> would do</z></g><g id="s17"><z id="t1627818611" t="Ben Sless I also see predicate functions used a lot where decoders would be better"><y>#</y><d>2021-08-01</d><h>11:50</h><w>Ben Sless</w>I also see predicate functions used a lot where decoders would be better</z><z id="t1627829783" t="greg Ok, make total sense now. I just took it as a proposal of change. I need to develop a sense of humour I guess 😅"><y>#</y><d>2021-08-01</d><h>14:56</h><w>greg</w>Ok, make total sense now. I just took it as a proposal of change. I need to develop a sense of humour I guess <b>😅</b></z><z id="t1627830516" t="Ben Sless See the &quot;hot take&quot; prefix"><y>#</y><d>2021-08-01</d><h>15:08</h><w>Ben Sless</w>See the &quot;hot take&quot; prefix</z><z id="t1627832278" t="greg I missed that :face_palm: 😅"><y>#</y><d>2021-08-01</d><h>15:37</h><r>greg</r>I missed that <b>:face_palm:</b><b>😅</b></z><z id="t1627830618" t="Ben Sless Frustrated by half a day fighting with badly written and used malli schemas Everything can and will be abused"><y>#</y><d>2021-08-01</d><h>15:10</h><w>Ben Sless</w>Frustrated by half a day fighting with badly written and used malli schemas
Everything can and will be abused</z><z id="t1627832465" t="greg I don&apos;t know you particular case, so just guessing... Maybe organising some internal training showing how to use Malli could avoid that kind of tool misuse in the future 😉 🚀"><y>#</y><d>2021-08-01</d><h>15:41</h><r>greg</r>I don&apos;t know you particular case, so just guessing... Maybe organising some internal training showing how to use Malli could avoid that kind of tool misuse in the future <b>😉</b><b>🚀</b></z><z id="t1627835285" t="Ben Sless I am actually working on internal training which I hope I&apos;ll be able to release mostly as a contributed getting started guide"><y>#</y><d>2021-08-01</d><h>16:28</h><r>Ben Sless</r>I am actually working on internal training which I hope I&apos;ll be able to release mostly as a contributed getting started guide</z><z id="t1627830811" t="NoahTheDuke I suspect this also has to do with docs. It can be hard to fully enumerate the possibilities of a given API, and something like :fn just works. "><y>#</y><d>2021-08-01</d><h>15:13</h><w>NoahTheDuke</w>I suspect this also has to do with docs. It can be hard to fully enumerate the possibilities of a given API, and something like <code>:fn</code> just works. </z><z id="t1627832208" t="greg I agree with this point. [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] tbh with you, I understand the points that frustrates you, but I wouldn&apos;t be two weeks ago. The thing is that Malli is nice to use once you know it, but it is fairly confusing when you start. I think that it might be the source of the problem, that people are using the simplest solutions they know, because they simply don&apos;t know all the features of the tool. Let&apos;s take my example. I used spec before, but haven&apos;t used spec.tools nor prismatic schema. Some of the concepts were simply new to me. E.g. transformers, there are at least four ways of transforming values with Malli, and it is not obvious what they are and how they work. I discovered it by reading the docs, examples, Malli impl and reading the Tommis answers here. I don&apos;t have daily job and I could invest a bit of time, still not everyone can afford that much of investment, so most of the time, I guess, people pragmatically makes things done 🙂 In this particular topic, using Malli transformers, I intend to make a comprehensive writing at some point to make the process easier for others. I think in case of :fn and simple-schema case is the same, people might not be aware when/where to use what 🙂"><y>#</y><d>2021-08-01</d><h>15:36</h><r>greg</r>I agree with this point.

<a>@UK0810AQ2</a> tbh with you, I understand the points that frustrates you, but I wouldn&apos;t be two weeks ago. The thing is that Malli is nice to use once you know it, but it is fairly confusing when you start. I think that it might be the source of the problem, that people are using the simplest solutions they know, because they simply don&apos;t know all the features of the tool.
Let&apos;s take my example. I used spec before, but haven&apos;t used spec.tools nor prismatic schema. Some of the concepts were simply new to me. E.g. transformers, there are at least four ways of transforming values with Malli, and it is not obvious what they are and how they work. I discovered it by reading the docs, examples, Malli impl and reading the Tommis answers here. I don&apos;t have daily job and I could invest a bit of time, still not everyone can afford that much of investment, so most of the time, I guess, people pragmatically makes things done <b>🙂</b>

In this particular topic, using Malli transformers, I intend to make a comprehensive writing at some point to make the process easier for others. I think in case of <code>:fn</code> and <code>simple-schema</code> case is the same, people might not be aware when/where to use what <b>🙂</b></z><z id="t1627835408" t="Ben Sless I agree. Malli&apos;s docs are comprehensive but like man pages they don&apos;t tell you where to start, they don&apos;t guide you towards &quot;I want to do X&quot;"><y>#</y><d>2021-08-01</d><h>16:30</h><r>Ben Sless</r>I agree. Malli&apos;s docs are comprehensive but like man pages they don&apos;t tell you where to start, they don&apos;t guide you towards &quot;I want to do X&quot;</z><z id="t1627834482" t="zxspectrr is there a more idomatic way of defining a map that must have a key but the value can be nullable. Here&apos;s what I&apos;ve currently got: (defn ? [predicate] [:or predicate nil?]) (def MyThing [:map [:someValue (? string?)]])"><y>#</y><d>2021-08-01</d><h>16:14</h><w>zxspectrr</w>is there a more idomatic way of defining a map that must have a key but the value can be nullable. Here&apos;s what I&apos;ve currently got:

<pre>(defn ? [predicate] [:or predicate nil?])

(def MyThing
     [:map      
      [:someValue (? string?)]])</pre></z><z id="t1627834508" t="zxspectrr Only reason I want to force the existence of a key so it appears in a JSON response with null as it&apos;s value"><y>#</y><d>2021-08-01</d><h>16:15</h><w>zxspectrr</w>Only reason I want to force the existence of a key so it appears in a JSON response with <code>null</code> as it&apos;s value</z><z id="t1627836710" t="alpox I&apos;m not 100% sure but would that not be [:someValue [:maybe string?]]"><y>#</y><d>2021-08-01</d><h>16:51</h><w>alpox</w>I&apos;m not 100% sure but would that not be <code>[:someValue [:maybe string?]]</code></z><z id="t1627837445" t="zxspectrr oh, I didn&apos;t realise there&apos;s a [:maybe]"><y>#</y><d>2021-08-01</d><h>17:04</h><w>zxspectrr</w>oh, I didn&apos;t realise there&apos;s a [:maybe]</z><z id="t1627837446" t="zxspectrr nice"><y>#</y><d>2021-08-01</d><h>17:04</h><w>zxspectrr</w>nice</z><z id="t1627837494" t="zxspectrr yep that works, ty 🙂"><y>#</y><d>2021-08-01</d><h>17:04</h><w>zxspectrr</w>yep that works, ty <b>🙂</b></z><z id="t1627837555" t="zxspectrr my experience with malli so far has been quite positive"><y>#</y><d>2021-08-01</d><h>17:05</h><w>zxspectrr</w>my experience with malli so far has been quite positive</z><z id="t1627909555" t="ikitommi wip"><y>#</y><d>2021-08-02</d><h>13:05</h><w>ikitommi</w>wip</z><z id="t1627930466" t="Ben Sless Is it integrated with kondo as well?"><y>#</y><d>2021-08-02</d><h>18:54</h><r>Ben Sless</r>Is it integrated with kondo as well?</z><z id="t1627933919" t="ikitommi malli.dev is, the red underline &amp; bump are from kondo. The pretty printer is currently just for runtime errors."><y>#</y><d>2021-08-02</d><h>19:51</h><r>ikitommi</r><code>malli.dev</code> is, the red underline &amp; bump are from kondo. The pretty printer is currently just for runtime errors.</z><z id="t1627909606" t="ikitommi the error formatters use fipp, look like this: (defmethod v/-format ::m/invalid-input [_ _ {:keys [args input]} printer] {:body [:group (-block &quot;Invalid function arguments:&quot; (v/-visit args printer) printer) :break :break (-block &quot;Input Schema:&quot; (v/-visit input printer) printer) :break :break (-block &quot;Errors:&quot; (-errors input args printer) printer) :break :break (-block &quot;More information:&quot; (v/-color :link &quot;&quot; printer) printer)]})"><y>#</y><d>2021-08-02</d><h>13:06</h><w>ikitommi</w>the error formatters use fipp, look like this:
<pre>(defmethod v/-format ::m/invalid-input [_ _ {:keys [args input]} printer]
  {:body
   [:group
    (-block &quot;Invalid function arguments:&quot; (v/-visit args printer) printer) :break :break
    (-block &quot;Input Schema:&quot; (v/-visit input printer) printer) :break :break
    (-block &quot;Errors:&quot; (-errors input args printer) printer) :break :break
    (-block &quot;More information:&quot; (v/-color :link &quot;&quot; printer) printer)]})</pre></z><z id="t1627909681" t="ikitommi there will be pretty/reporter to just prints the errors and pretty/thrower to throw ’em."><y>#</y><d>2021-08-02</d><h>13:08</h><w>ikitommi</w>there will be <code>pretty/reporter</code> to just prints the errors and <code>pretty/thrower</code> to throw ’em.</z><z id="t1627910000" t="NoahTheDuke that looks great"><y>#</y><d>2021-08-02</d><h>13:13</h><w>NoahTheDuke</w>that looks great</z><z id="t1627910016" t="NoahTheDuke is there a better idiom for this? (defn Step? [step] (if (m/validate Step step) step (throw (Exception. (-&gt;&gt; step (m/explain Step) (me/humanize)))))) "><y>#</y><d>2021-08-02</d><h>13:13</h><w>NoahTheDuke</w>is there a better idiom for this?
<pre>(defn Step? [step]
  (if (m/validate Step step)
    step
    (throw (Exception.
             (-&gt;&gt; step
                  (m/explain Step)
                  (me/humanize))))))</pre>
</z><z id="t1627910377" t="danielneal haha I literally wrote that exact function 5 mins ago and was wondering the same thing"><y>#</y><d>2021-08-02</d><h>13:19</h><w>danielneal</w>haha I literally wrote that exact function 5 mins ago and was wondering the same thing</z><z id="t1627912667" t="ikitommi • you could create a validator &amp; explainer before, if perf matters • I recommend throwing ex-imfo with :type , easier to catalog the errors • humanize can fail in some corner cases, should be robust, fixes welcome • there could be a helper for this in the future in malli, using m/-fail! which works well with the upcoming pretty printer"><y>#</y><d>2021-08-02</d><h>13:57</h><w>ikitommi</w>• you could create a validator &amp; explainer before, if perf matters
• I recommend throwing <code>ex-imfo</code> with <code>:type</code> , easier to catalog the errors
• humanize can fail in some corner cases, should be robust, fixes welcome
• there could be a helper for this in the future in malli, using <code>m/-fail!</code> which works well with the upcoming pretty printer</z><z id="t1627912936" t="ikitommi Malli internal errors just throw the minimum set of data (to be fast), to be post-processed when rendering the error. e.g. explain and humanize are pure, can be done on rendering, if the value &amp; schema are present at ex-data . Might not be relevant on actual projects."><y>#</y><d>2021-08-02</d><h>14:02</h><w>ikitommi</w>Malli internal errors just throw the minimum set of data (to be fast), to be post-processed when rendering the error. e.g. <code>explain</code> and <code>humanize</code> are pure, can be done on rendering, if the value &amp; schema are present at <code>ex-data</code>. Might not be relevant on actual projects.</z><z id="t1627913045" t="ikitommi I haven&apos;t heard of a robust way to override the repl default exception handler (from the repl) - would allow pretty errors for all Clojure: just throw data and add custom renderers for all :type s &amp; exception classes"><y>#</y><d>2021-08-02</d><h>14:04</h><w>ikitommi</w>I haven&apos;t heard of a robust way to override the  repl default exception handler (from the repl) - would allow pretty errors for all Clojure: just throw data and add custom renderers for all <code>:type</code>s &amp; exception classes</z><z id="t1627913165" t="NoahTheDuke so something like this? (defn SimpleStep? [step] (if (validate-step @step) step (throw (ex-info &quot;Step isn&apos;t valid&quot; {:type (explain-step @step)})))) "><y>#</y><d>2021-08-02</d><h>14:06</h><w>NoahTheDuke</w>so something like this?
<pre>(defn SimpleStep? [step]
  (if (validate-step @step)
    step
    (throw (ex-info &quot;Step isn&apos;t valid&quot; {:type (explain-step @step)}))))</pre>
</z><z id="t1627913270" t="NoahTheDuke good point about the validator and explainer, thanks"><y>#</y><d>2021-08-02</d><h>14:07</h><w>NoahTheDuke</w>good point about the validator and explainer, thanks</z><z id="t1627930711" t="Ben Sless I&apos;m leaning towards this form: (defn needs-a-good-name [s] (let [s (m/schema s) v (m/validator s) d (m/decoder s ,,,) ;; optional? e (m/explainer s)] (fn [x] (let [x (d x)] (if (v x) x (throw (ex-info &quot;invalid something&quot; (e x)))))))) More generally, you can pass two functions, on-success and on-fail, then you can decide if you want to throw or drop or invalid data"><y>#</y><d>2021-08-02</d><h>18:58</h><w>Ben Sless</w>I&apos;m leaning towards this form:
<pre>(defn needs-a-good-name
  [s]
  (let [s (m/schema s)
        v (m/validator s)
        d (m/decoder s ,,,) ;; optional?
        e (m/explainer s)]
    (fn [x]
      (let [x (d x)]
        (if (v x)
          x
          (throw (ex-info &quot;invalid something&quot; (e x))))))))</pre>
More generally, you can pass two functions, on-success and on-fail, then you can decide if you want to throw or drop or invalid data</z><z id="t1627930752" t="Ben Sless Something like (defn needs-a-good-name [s respond raise] (let [s (m/schema s) v (m/validator s) d (m/decoder s ,,,) ;; optional? e (m/explainer s)] (fn [x] (let [x (d x)] (if (v x) (respond x) (raise e x)))))) "><y>#</y><d>2021-08-02</d><h>18:59</h><w>Ben Sless</w>Something like
<pre>(defn needs-a-good-name
  [s respond raise]
  (let [s (m/schema s)
        v (m/validator s)
        d (m/decoder s ,,,) ;; optional?
        e (m/explainer s)]
    (fn [x]
      (let [x (d x)]
        (if (v x)
          (respond x)
          (raise e x))))))</pre>
</z><z id="t1627988596" t="greg I think these two examples could be posted somewhere"><y>#</y><d>2021-08-03</d><h>11:03</h><r>greg</r>I think these two examples could be posted somewhere</z><z id="t1627989203" t="Ben Sless I&apos;ll clean it up a bit and PR it to the tips? Maybe we should add a cookbook"><y>#</y><d>2021-08-03</d><h>11:13</h><r>Ben Sless</r>I&apos;ll clean it up a bit and PR it to the tips?
Maybe we should add a cookbook</z><z id="t1627933630" t="ikitommi coercer ? did you mean (raise (e x)) ? Look good anyway 👍 👍 👍"><y>#</y><d>2021-08-02</d><h>19:47</h><w>ikitommi</w><code>coercer</code>? did you mean <code>(raise (e x))</code>? Look good anyway <b>👍</b> <b>👍</b> <b>👍</b></z><z id="t1627936556" t="Ben Sless coercer is probably good. Wasn&apos;t sure about passing the original value or just the report to raise"><y>#</y><d>2021-08-02</d><h>20:35</h><w>Ben Sless</w><code>coercer</code> is probably good. Wasn&apos;t sure about passing the original value or just the report to <code>raise</code></z><z id="t1627977678" t="vlaaad Hi! Is there a malli equivalent of s/keys* ?"><y>#</y><d>2021-08-03</d><h>08:01</h><w>vlaaad</w>Hi! Is there a malli equivalent of <code>s/keys*</code> ?</z><z id="t1627982334" t="ikitommi Not yet, I guess the could be..."><y>#</y><d>2021-08-03</d><h>09:18</h><r>ikitommi</r>Not yet, I guess the could be...</z><z id="t1627978029" t="vlaaad side note: (let [s [:catn [:rest [:? any?]]]] (m/unparse s (m/parse s []))) =&gt; [nil] ;; should be []"><y>#</y><d>2021-08-03</d><h>08:07</h><w>vlaaad</w>side note:
<pre>(let [s [:catn [:rest [:? any?]]]]
  (m/unparse s (m/parse s [])))
=&gt; [nil] ;; should be []</pre></z><z id="t1627982281" t="ikitommi Oh, it&apos;s a bug, issue /&amp; PR welcome!"><y>#</y><d>2021-08-03</d><h>09:18</h><r>ikitommi</r>Oh, it&apos;s a bug, issue /&amp; PR welcome!</z><z id="t1627980861" t="Ben Sless Any idea how to make the transformer tests not rely on map order? https://github.com/metosin/malli/pull/497"><y>#</y><d>2021-08-03</d><h>08:54</h><w>Ben Sless</w>Any idea how to make the transformer tests not rely on map order?
<a href="https://github.com/metosin/malli/pull/497" target="_blank">https://github.com/metosin/malli/pull/497</a></z><z id="t1627982243" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] looks great! Commented the PR, ideas about the order &amp; stuff"><y>#</y><d>2021-08-03</d><h>09:17</h><w>ikitommi</w><a>@ben.sless</a> looks great! Commented the PR, ideas about the order &amp; stuff</z><z id="t1628004045" t="NoahTheDuke how do i do this? (def PhaseStepSchema (mu/merge BaseStepSchema [:map {:closed true} [:phase qualified-keyword? {:namespace :phase}]]))"><y>#</y><d>2021-08-03</d><h>15:20</h><w>NoahTheDuke</w>how do i do this?
<pre>(def PhaseStepSchema
  (mu/merge
    BaseStepSchema
    [:map {:closed true}
     [:phase qualified-keyword? {:namespace :phase}]]))</pre></z><z id="t1628004097" t="NoahTheDuke i want the :phase value to be a namespace-qualified keyword, with the namespace :phase , aka :phase/action"><y>#</y><d>2021-08-03</d><h>15:21</h><w>NoahTheDuke</w>i want the <code>:phase</code> value to be a namespace-qualified keyword, with the namespace <code>:phase</code> , aka <code>:phase/action</code></z><z id="t1628009079" t="NoahTheDuke solution i found: [:phase [:qualified-keyword {:namespace :phase}]]"><y>#</y><d>2021-08-03</d><h>16:44</h><w>NoahTheDuke</w>solution i found: <code>[:phase [:qualified-keyword {:namespace :phase}]]</code></z><z id="t1628012525" t="Ben Sless I came across an extremely weird phenomenon which I don&apos;t think should happen 1. Unhandled java.lang.VerifyError Stack map does not match the one at exception handler 1251 Exception Details: Location: malli/core_test$fn__30148$fn__32525.invoke()Ljava/lang/Object; @1251: astore_3 Reason: Type &apos;java/lang/Throwable&apos; (current frame, locals[6]) is not assignable to &apos;clojure/lang/Keyword&apos; (stack map, locals[6]) Current Frame: bci: @1175 flags: { } locals: { &apos;malli/core_test$fn__30148$fn__32525&apos;, &apos;clojure/lang/IPersistentVector&apos;, null, null, &apos;java/lang/Object&apos;, null, &apos;java/lang/Throwable&apos; } stack: { &apos;java/lang/Throwable&apos; } Stackmap Frame: bci: @1251 flags: { } locals: { &apos;malli/core_test$fn__30148$fn__32525&apos;, &apos;clojure/lang/IPersistentVector&apos;, &apos;java/lang/Object&apos;, null, in accumulating errors #84 Will try another JVM version"><y>#</y><d>2021-08-03</d><h>17:42</h><w>Ben Sless</w>I came across an extremely weird phenomenon which I don&apos;t think should happen
<pre>1. Unhandled java.lang.VerifyError
   Stack map does not match the one at exception handler 1251 Exception
   Details: Location:
   malli/core_test$fn__30148$fn__32525.invoke()Ljava/lang/Object; @1251:
   astore_3 Reason: Type &apos;java/lang/Throwable&apos; (current frame,
   locals[6]) is not assignable to &apos;clojure/lang/Keyword&apos; (stack map,
   locals[6]) Current Frame: bci: @1175 flags: { } locals: {
   &apos;malli/core_test$fn__30148$fn__32525&apos;,
   &apos;clojure/lang/IPersistentVector&apos;, null, null, &apos;java/lang/Object&apos;,
   null, &apos;java/lang/Throwable&apos; } stack: { &apos;java/lang/Throwable&apos; }
   Stackmap Frame: bci: @1251 flags: { } locals: {
   &apos;malli/core_test$fn__30148$fn__32525&apos;,
   &apos;clojure/lang/IPersistentVector&apos;, &apos;java/lang/Object&apos;, null,</pre>
in <code>accumulating errors #84</code>
Will try another JVM version</z><z id="t1628012586" t="Ben Sless This happens in the same test, on both Java 15 and 11, only after I run it twice"><y>#</y><d>2021-08-03</d><h>17:43</h><w>Ben Sless</w>This happens in the same test, on both Java 15 and 11, only after I run it twice</z><z id="t1628012689" t="Ben Sless Happens on java 8, too"><y>#</y><d>2021-08-03</d><h>17:44</h><w>Ben Sless</w>Happens on java 8, too</z><z id="t1628068263" t="Ben Sless I managed to narrow it down to multi-schemas"><y>#</y><d>2021-08-04</d><h>09:11</h><w>Ben Sless</w>I managed to narrow it down to multi-schemas</z><z id="t1628068321" t="Ben Sless Specifically, the last bit"><y>#</y><d>2021-08-04</d><h>09:12</h><w>Ben Sless</w>Specifically, the last bit</z><z id="t1628068336" t="Ben Sless (let [schema [:multi {:dispatch first} [:human [:cat [:= :human]]] [:bear [:cat [:= :bear] [:* :int]]] [::m/default [:tuple :string :string]]]] (testing &quot;validate&quot; (is (m/validate schema [:human])) (is (m/validate schema [:bear 1 2 3])) (is (m/validate schema [&quot;defaultit&quot; &quot;toimii&quot;])) (is (not (m/validate schema [:so :invalid])))) (testing &quot;explain&quot; (is (not (m/explain schema [:human]))) (is (not (m/explain schema [:bear 1 2 3]))) (is (not (m/explain schema [&quot;defaultit&quot; &quot;toimii&quot;]))) (is (results= {:schema schema, :value [:so :invalid], :errors [{:path [::m/default 0], :in [0], :schema :string, :value :so} {:path [::m/default 1], :in [1], :schema :string, :value :invalid}]} (m/explain schema [:so :invalid])))) (testing &quot;parser&quot; (is (= (miu/-tagged :human [:human]) (m/parse schema [:human]))) (is (= (miu/-tagged :bear [:bear [1 2 3]]) (m/parse schema [:bear 1 2 3]))) (is (= (miu/-tagged ::m/default [&quot;defaultit&quot; &quot;toimii&quot;]) (m/parse schema [&quot;defaultit&quot; &quot;toimii&quot;]))) (is (= ::m/invalid (m/parse schema [:so :invalid]))))) "><y>#</y><d>2021-08-04</d><h>09:12</h><w>Ben Sless</w><pre>(let [schema [:multi {:dispatch first}
                  [:human [:cat [:= :human]]]
                  [:bear [:cat [:= :bear] [:* :int]]]
                  [::m/default [:tuple :string :string]]]]

      (testing &quot;validate&quot;
        (is (m/validate schema [:human]))
        (is (m/validate schema [:bear 1 2 3]))
        (is (m/validate schema [&quot;defaultit&quot; &quot;toimii&quot;]))
        (is (not (m/validate schema [:so :invalid]))))

      (testing &quot;explain&quot;
        (is (not (m/explain schema [:human])))
        (is (not (m/explain schema [:bear 1 2 3])))
        (is (not (m/explain schema [&quot;defaultit&quot; &quot;toimii&quot;])))
        (is (results= {:schema schema,
                       :value [:so :invalid],
                       :errors [{:path [::m/default 0], :in [0], :schema :string, :value :so}
                                {:path [::m/default 1], :in [1], :schema :string, :value :invalid}]}
                      (m/explain schema [:so :invalid]))))

      (testing &quot;parser&quot;
        (is (= (miu/-tagged :human [:human]) (m/parse schema [:human])))
        (is (= (miu/-tagged :bear [:bear [1 2 3]]) (m/parse schema [:bear 1 2 3])))
        (is (= (miu/-tagged ::m/default [&quot;defaultit&quot; &quot;toimii&quot;]) (m/parse schema [&quot;defaultit&quot; &quot;toimii&quot;])))
        (is (= ::m/invalid (m/parse schema [:so :invalid])))))</pre>
</z><z id="t1628068346" t="Ben Sless Something here is very wrong"><y>#</y><d>2021-08-04</d><h>09:12</h><w>Ben Sless</w>Something here is very wrong</z><z id="t1628068395" t="Ben Sless Even more specifically, it&apos;s the parser"><y>#</y><d>2021-08-04</d><h>09:13</h><w>Ben Sless</w>Even more specifically, it&apos;s the parser</z><z id="t1628068494" t="greg I&apos;ve been using REBL recently and I noticed that Malli schemas are printed as regular one line strings, which is annoying. Although I found it is possible to provide custom viewer to REBL. Example: (defn schema? [s] (m/schema? (try (m/schema s) (catch Exception _)))) (defn setup-rebl-viewers [] (require &apos;[cognitect.rebl]) (cognitect.rebl/update-viewers {:malli/schema {:pred #&apos;schema? :ctor (fn [v] (-&gt; (m/form (m/schema v)) (fipp.edn/pprint {:width 80}) (with-out-str) (cognitect.rebl.renderers/string-code-viewer)))}})) #_(setup-rebl-viewers) This is just a simple pretty print, but we could apply other strategies for formatting. If you have an idea what&apos;s the best way of formatting Malli schemas, please let me know in the comment."><y>#</y><d>2021-08-04</d><h>09:14</h><w>greg</w>I&apos;ve been using REBL recently and I noticed that Malli schemas are printed as regular one line strings, which is annoying.
Although I found it is possible to provide custom viewer to REBL. Example:
<pre>(defn schema? [s]
  (m/schema? (try (m/schema s) (catch Exception _))))

(defn setup-rebl-viewers []
  (require &apos;[cognitect.rebl])
  (cognitect.rebl/update-viewers
   {:malli/schema {:pred #&apos;schema?
                   :ctor (fn [v]
                           (-&gt; (m/form (m/schema v))
                               (fipp.edn/pprint {:width 80})
                               (with-out-str)
                               (cognitect.rebl.renderers/string-code-viewer)))}}))
#_(setup-rebl-viewers)</pre>
This is just a simple pretty print, but we could apply other strategies for formatting.
If you have an idea what&apos;s the best way of formatting Malli schemas, please let me know in the comment.</z><z id="t1628068536" t="Ben Sless datafy?"><y>#</y><d>2021-08-04</d><h>09:15</h><r>Ben Sless</r>datafy?</z><z id="t1628068679" t="Ben Sless Extend datafy to schemas and return form?"><y>#</y><d>2021-08-04</d><h>09:17</h><r>Ben Sless</r>Extend datafy to schemas and return form?</z><z id="t1628072234" t="greg Hmm, I&apos;ll give it a try later :thinking_face:"><y>#</y><d>2021-08-04</d><h>10:17</h><r>greg</r>Hmm, I&apos;ll give it a try later <b>:thinking_face:</b></z><z id="t1628072262" t="greg Do you datafy malli schemas? Could you post an example?"><y>#</y><d>2021-08-04</d><h>10:17</h><r>greg</r>Do you datafy malli schemas? Could you post an example?</z><z id="t1628074263" t="Ben Sless Bit of black magic: (require &apos;[clojure.core.protocols :as p] &apos;[malli.core :as m]) (extend-protocol p/Datafiable Object (datafy [x] (cond (satisfies? m/Schema x) (do (extend-protocol p/Datafiable (class x) (datafy [y] (m/-form y))) (p/datafy x)) (satisfies? m/IntoSchema x) (do (extend-protocol p/Datafiable (class x) (datafy [y] (m/-form (m/schema y)))) (p/datafy x)) :else x))) "><y>#</y><d>2021-08-04</d><h>10:51</h><r>Ben Sless</r>Bit of black magic:
<pre>(require &apos;[clojure.core.protocols :as p]
         &apos;[malli.core :as m])


(extend-protocol p/Datafiable
  Object
  (datafy [x]
    (cond
      (satisfies? m/Schema x)
      (do
        (extend-protocol p/Datafiable
          (class x)
          (datafy [y] (m/-form y)))
        (p/datafy x))

      (satisfies? m/IntoSchema x)
      (do
        (extend-protocol p/Datafiable
          (class x)
          (datafy [y] (m/-form (m/schema y))))
        (p/datafy x))

      :else x)))</pre>
</z><z id="t1628085344" t="greg I think it could be simplified to (extend-protocol p/Datafiable Object (datafy [x] (cond (satisfies? m/Schema x) (p/datafy (m/form x)) (satisfies? m/IntoSchema x) (p/datafy (m/form (m/schema x))) :else x))) Still as I mentioned in the other post ( https://clojurians.slack.com/archives/C03S1KBA2/p1628084493261600?thread_ts=1628082589.258900&amp;amp;cid=C03S1KBA2 ), I&apos;ve got a feeling extending Object is not a good idea 😬"><y>#</y><d>2021-08-04</d><h>13:55</h><r>greg</r>I think it could be simplified to
<pre>(extend-protocol p/Datafiable
  Object
  (datafy [x]
    (cond
      (satisfies? m/Schema x) (p/datafy (m/form x))
      (satisfies? m/IntoSchema x) (p/datafy (m/form (m/schema x)))
      :else x)))</pre>
Still as I mentioned in the other post (<a href="https://clojurians.slack.com/archives/C03S1KBA2/p1628084493261600?thread_ts=1628082589.258900&amp;amp;cid=C03S1KBA2" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1628084493261600?thread_ts=1628082589.258900&amp;amp;cid=C03S1KBA2</a>), I&apos;ve got a feeling extending Object is not a good idea <b>😬</b></z><z id="t1628125285" t="emccue or, add some metadata to your schemas that extends the protocol"><y>#</y><d>2021-08-05</d><h>01:01</h><r>emccue</r>or, add some metadata to your schemas that extends the protocol</z><z id="t1628125362" t="emccue thats probably the best way"><y>#</y><d>2021-08-05</d><h>01:02</h><r>emccue</r>thats probably the best way</z><z id="t1628125466" t="emccue (with-meta [:map [:x int?]] ^{`p/datafy (fn [this] (p/datafy (m/form this)))})"><y>#</y><d>2021-08-05</d><h>01:04</h><r>emccue</r>(with-meta [:map [:x int?]] ^{`p/datafy (fn [this] (p/datafy (m/form this)))})</z><z id="t1628635000" t="greg Thanks for posting example. Still I think that would be yet another extreme if I add my own m/schema to keep it everywhere..."><y>#</y><d>2021-08-10</d><h>22:36</h><r>greg</r>Thanks for posting example. Still I think that would be yet another extreme if I add my own m/schema to keep it everywhere...</z><z id="t1628635335" t="greg Actually, maybe this should be added to Malli itself, to m/schema :thinking_face: What do you think [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] about making Malli schemas datafy-able? (it is just an idea, I&apos;m not sure is it good or bad, i&apos;m just trying to figure out best practices of using these new protocols for my own and in this very thread it stroke me Malli could be a good place to define that datafy behaviour)"><y>#</y><d>2021-08-10</d><h>22:42</h><r>greg</r>Actually, maybe this should be added to Malli itself, to <code>m/schema</code> <b>:thinking_face:</b>
What do you think <a>@U055NJ5CC</a> about making Malli schemas datafy-able?
(it is just an idea, I&apos;m not sure is it good or bad, i&apos;m just trying to figure out best practices of using these new protocols for my own and in this very thread it stroke me Malli could be a good place to define that datafy behaviour)</z><z id="t1628070904" t="danielneal I’m trying to make a recursive schema"><y>#</y><d>2021-08-04</d><h>09:55</h><w>danielneal</w>I’m trying to make a recursive schema</z><z id="t1628070910" t="danielneal doing something like this (simplified)"><y>#</y><d>2021-08-04</d><h>09:55</h><w>danielneal</w>doing something like this (simplified)</z><z id="t1628070914" t="danielneal (malli/validate [:vector {:registry {::property [:map [:property/type keyword?] [:property/group {:optional true} [:vector ::property]]]}} ::property] [{:property/type :string} {:property/type :key}])"><y>#</y><d>2021-08-04</d><h>09:55</h><w>danielneal</w><pre>(malli/validate 
  [:vector {:registry {::property
                       [:map
                        [:property/type keyword?]
                        [:property/group {:optional true}
                         [:vector ::property]]]}}
   ::property]
  [{:property/type :string}
   {:property/type :key}])</pre></z><z id="t1628070920" t="danielneal but I get a stackoverflowerror"><y>#</y><d>2021-08-04</d><h>09:55</h><w>danielneal</w>but I get a stackoverflowerror</z><z id="t1628070973" t="danielneal I’m not sure model this kind of thing correctly"><y>#</y><d>2021-08-04</d><h>09:56</h><w>danielneal</w>I’m not sure model this kind of thing correctly</z><z id="t1628071039" t="danielneal oh I see it, i need :ref ?"><y>#</y><d>2021-08-04</d><h>09:57</h><w>danielneal</w>oh I see it, i need <code>:ref</code> ?</z><z id="t1628071599" t="delaguardo yes"><y>#</y><d>2021-08-04</d><h>10:06</h><r>delaguardo</r>yes</z><z id="t1628074263" t="Ben Sless Bit of black magic: (require &apos;[clojure.core.protocols :as p] &apos;[malli.core :as m]) (extend-protocol p/Datafiable Object (datafy [x] (cond (satisfies? m/Schema x) (do (extend-protocol p/Datafiable (class x) (datafy [y] (m/-form y))) (p/datafy x)) (satisfies? m/IntoSchema x) (do (extend-protocol p/Datafiable (class x) (datafy [y] (m/-form (m/schema y)))) (p/datafy x)) :else x))) "><y>#</y><d>2021-08-04</d><h>10:51</h><w>Ben Sless</w>Bit of black magic:
<pre>(require &apos;[clojure.core.protocols :as p]
         &apos;[malli.core :as m])


(extend-protocol p/Datafiable
  Object
  (datafy [x]
    (cond
      (satisfies? m/Schema x)
      (do
        (extend-protocol p/Datafiable
          (class x)
          (datafy [y] (m/-form y)))
        (p/datafy x))

      (satisfies? m/IntoSchema x)
      (do
        (extend-protocol p/Datafiable
          (class x)
          (datafy [y] (m/-form (m/schema y))))
        (p/datafy x))

      :else x)))</pre>
</z><z id="t1628183051" t="Ben Sless I forgot dealing with time was such a pain in the"><y>#</y><d>2021-08-05</d><h>17:04</h><w>Ben Sless</w>I forgot dealing with time was such a pain in the</z><z id="t1628265320" t="richiardiandrea Hello there, I know this is not the right channel but I have a question about spec-tools Is there out there a library for creating graphviz svg from a spec by any chance?"><y>#</y><d>2021-08-06</d><h>15:55</h><w>richiardiandrea</w>Hello there, I know this is not the right channel but I have a question about <code>spec-tools</code>
Is there out there a library for creating graphviz svg from a spec by any chance?</z><z id="t1628269612" t="ikitommi I recall there is. Haven&apos;t used thou."><y>#</y><d>2021-08-06</d><h>17:06</h><r>ikitommi</r>I recall there is. Haven&apos;t used thou.</z><z id="t1628289901" t="richiardiandrea ok thanks I&apos;ll google it better, could not find it"><y>#</y><d>2021-08-06</d><h>22:45</h><r>richiardiandrea</r>ok thanks I&apos;ll google it better, could not find it</z><z id="t1628406242" t="ikitommi maybe https://github.com/jebberjeb/specviz ?"><y>#</y><d>2021-08-08</d><h>07:04</h><r>ikitommi</r>maybe <a href="https://github.com/jebberjeb/specviz" target="_blank">https://github.com/jebberjeb/specviz</a>?</z><z id="t1628523375" t="richiardiandrea Ah yeah I tried that one, no dice, I thought I saw a spec-tools specific one...however Malli looks super cool and I should try it out 😄 Thanks for the link anyways!"><y>#</y><d>2021-08-09</d><h>15:36</h><r>richiardiandrea</r>Ah yeah I tried that one, no dice, I thought I saw a <code>spec-tools</code> specific one...however Malli looks super cool and I should try it out <b>😄</b>
Thanks for the link anyways!</z><z id="t1628280002" t="ikitommi Humanized errors might finally work as expected. Fixes all known issues and is much simpler implementation. If someone can still crash it with some input, I’m all 👂 s. Maybe we can now remove the safe-humanize from projects 🙂 https://github.com/metosin/malli/pull/502"><y>#</y><d>2021-08-06</d><h>20:00</h><w>ikitommi</w>Humanized errors might finally work as expected. Fixes all known issues and is much simpler implementation. If someone can still crash it with some input, I’m all <b>👂</b>s. Maybe we can now remove the <code>safe-humanize</code> from projects <b>🙂</b> <a href="https://github.com/metosin/malli/pull/502" target="_blank">https://github.com/metosin/malli/pull/502</a></z><z id="t1628280199" t="ikitommi big change is that the humanized form is taken from the first failure. e.g. (-&gt; [:map [:x [:and [:map [:y :any]] seq?]]] (m/explain {:x {}}) (me/humanize)) ;{:x {:y [&quot;missing required key&quot;] ; :malli/error [&quot;should be a seq&quot;]}} (-&gt; [:map [:x [:and seq? [:map [:y :any]]]]] (m/explain {:x {}}) (me/humanize)) ; {:x [&quot;should be a seq&quot;]}"><y>#</y><d>2021-08-06</d><h>20:03</h><w>ikitommi</w>big change is that the humanized form is taken from the first failure. e.g.
<pre>(-&gt; [:map [:x [:and [:map [:y :any]] seq?]]]
    (m/explain {:x {}})
    (me/humanize))
;{:x {:y [&quot;missing required key&quot;]
;     :malli/error [&quot;should be a seq&quot;]}}

(-&gt; [:map [:x [:and seq? [:map [:y :any]]]]]
    (m/explain {:x {}})
    (me/humanize))
; {:x [&quot;should be a seq&quot;]}</pre></z><z id="t1628281884" t="naomarik that&apos;s awesome, really needed that!"><y>#</y><d>2021-08-06</d><h>20:31</h><r>naomarik</r>that&apos;s awesome, really needed that!</z><z id="t1628280221" t="ikitommi same with sequences &amp; sets."><y>#</y><d>2021-08-06</d><h>20:03</h><w>ikitommi</w>same with sequences &amp; sets.</z><z id="t1628280326" t="NoahTheDuke does humanize work with records now?"><y>#</y><d>2021-08-06</d><h>20:05</h><w>NoahTheDuke</w>does humanize work with records now?</z><z id="t1628280358" t="NoahTheDuke well, i guess i should say that that’s part of explain , not humanize so nvm lol"><y>#</y><d>2021-08-06</d><h>20:05</h><w>NoahTheDuke</w>well, i guess i should say that that’s part of <code>explain</code>, not humanize so nvm lol</z><z id="t1628280406" t="ikitommi records, good question, will test"><y>#</y><d>2021-08-06</d><h>20:06</h><w>ikitommi</w>records, good question, will test</z><z id="t1628280503" t="ikitommi nope: actual: java.lang.UnsupportedOperationException: Can&apos;t create empty: malli.error_test.Horror at malli.error_test.Horror.empty (error_test.cljc:549) clojure.core$empty.invokeStatic (core.clj:5236) malli.error$_assoc_in.invokeStatic (error.cljc:147)"><y>#</y><d>2021-08-06</d><h>20:08</h><w>ikitommi</w>nope:
<pre>actual: java.lang.UnsupportedOperationException: Can&apos;t create empty: malli.error_test.Horror
 at malli.error_test.Horror.empty (error_test.cljc:549)
    clojure.core$empty.invokeStatic (core.clj:5236)
    malli.error$_assoc_in.invokeStatic (error.cljc:147)</pre></z><z id="t1628280520" t="NoahTheDuke a simple (into {} rec) works for me right now"><y>#</y><d>2021-08-06</d><h>20:08</h><w>NoahTheDuke</w>a simple <code>(into {} rec)</code> works for me right now</z><z id="t1628280521" t="ikitommi idea how to create empty records?"><y>#</y><d>2021-08-06</d><h>20:08</h><w>ikitommi</w>idea how to create empty records?</z><z id="t1628280542" t="NoahTheDuke i don’t believe you can, lol"><y>#</y><d>2021-08-06</d><h>20:09</h><w>NoahTheDuke</w>i don’t believe you can, lol</z><z id="t1628280573" t="NoahTheDuke https://clojure.atlassian.net/browse/CLJ-1975"><y>#</y><d>2021-08-06</d><h>20:09</h><w>NoahTheDuke</w><a href="https://clojure.atlassian.net/browse/CLJ-1975" target="_blank">https://clojure.atlassian.net/browse/CLJ-1975</a></z><z id="t1628280594" t="NoahTheDuke that’s for spec but discusses the issue"><y>#</y><d>2021-08-06</d><h>20:09</h><w>NoahTheDuke</w>that’s for spec but discusses the issue</z><z id="t1628280851" t="ikitommi https://github.com/metosin/malli/pull/502/commits/19c3bbe34d2d0831ba6d4a3138debd36f3642267"><y>#</y><d>2021-08-06</d><h>20:14</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/502/commits/19c3bbe34d2d0831ba6d4a3138debd36f3642267" target="_blank">https://github.com/metosin/malli/pull/502/commits/19c3bbe34d2d0831ba6d4a3138debd36f3642267</a></z><z id="t1628280898" t="ikitommi the humanized for doesn’t preserve the Records, but then again, it forces all sequences to vectors. it’s for… humans."><y>#</y><d>2021-08-06</d><h>20:14</h><w>ikitommi</w>the humanized for doesn’t preserve the Records, but then again, it forces all sequences to vectors. it’s for… humans.</z><z id="t1628280907" t="NoahTheDuke hell yeah, thank you so much"><y>#</y><d>2021-08-06</d><h>20:15</h><w>NoahTheDuke</w>hell yeah, thank you so much</z><z id="t1628281443" t="ikitommi merged in master"><y>#</y><d>2021-08-06</d><h>20:24</h><w>ikitommi</w>merged in master</z><z id="t1628282394" t="ikitommi merged also the new pretty (schema error) printer into master. Not expound, but one could build such on top of this."><y>#</y><d>2021-08-06</d><h>20:39</h><w>ikitommi</w>merged also the new pretty (schema error) printer into master. Not expound, but one could build such on top of this.</z><z id="t1628442144" t="ikitommi it’s out! (actually 0.6.1 as there was a missing dependency)"><y>#</y><d>2021-08-08</d><h>17:02</h><w>ikitommi</w>it’s out! (actually 0.6.1 as there was a missing dependency)</z><z id="t1628445353" t="emccue Getting what is perhaps a simple error, but"><y>#</y><d>2021-08-08</d><h>17:55</h><w>emccue</w>Getting what is perhaps a simple error, but</z><z id="t1628445369" t="emccue (ns dev.mccue.domain.user (:require [malli.instrument :as instrument])) ;; ---------------------------------------------------------------------------- (def User [:and [:map [:user/email :string] [:user/password-hash :string]] [:fn {:error/message &quot;should have user metadata&quot;} (fn [o] (= (type o) ::user))]]) ;; ---------------------------------------------------------------------------- (defn create {:malli/schema [:=&gt; [:cat [:map [:email :string] [:password-hash :string]]] User]} [{:keys [email password-hash]}] ^{:type ::user} {:user/email email :user/password-hash password-hash}) ;; ---------------------------------------------------------------------------- (def ^{:malli/schema [:=&gt; [:cat User] :string]} email :user/email) ;; ---------------------------------------------------------------------------- (def ^{:malli/schema [:=&gt; [:cat User] :string]} password-hash :user/password-hash) ;; ---------------------------------------------------------------------------- (instrument/collect!) ;; .... (malli.dev/start! {:report (malli.dev.pretty/reporter)})"><y>#</y><d>2021-08-08</d><h>17:56</h><w>emccue</w><pre>(ns dev.mccue.domain.user
  (:require
    [malli.instrument :as instrument]))

;; ----------------------------------------------------------------------------
(def User [:and [:map
                 [:user/email :string]
                 [:user/password-hash :string]]
           [:fn {:error/message &quot;should have user metadata&quot;}
            (fn [o] (= (type o) ::user))]])

;; ----------------------------------------------------------------------------
(defn create
  {:malli/schema [:=&gt;
                  [:cat [:map
                         [:email :string]
                         [:password-hash :string]]]
                  User]}
  [{:keys [email password-hash]}]
  ^{:type ::user}
  {:user/email         email
   :user/password-hash password-hash})

;; ----------------------------------------------------------------------------
(def ^{:malli/schema [:=&gt; [:cat User] :string]}
  email
  :user/email)

;; ----------------------------------------------------------------------------
(def
  ^{:malli/schema [:=&gt; [:cat User] :string]}
  password-hash
  :user/password-hash)

;; ----------------------------------------------------------------------------
(instrument/collect!)

;; ....
(malli.dev/start! {:report (malli.dev.pretty/reporter)})</pre></z><z id="t1628485424" t="Tuomas I could reduce it down to be about malli.dev.pretty/reporter and :fn but couldn&apos;t figure out the reason for overflow. (defn identity-42 {:malli/schema [:=&gt; [:cat [:fn (fn [n] (= 42 n))]] :int]} [a] a) (instrument/collect!) (malli.dev/start! {:report (malli.dev.pretty/reporter)}) (identity-42 41) ; Execution error (StackOverflowError) at fipp.ednize/override? (ednize.clj:12) (malli.dev/stop!) (malli.dev/start!) (identity-42 41) ; :malli.core/invalid-input {:input [:cat [:fn #funct ..."><y>#</y><d>2021-08-09</d><h>05:03</h><r>Tuomas</r>I could reduce it down to be about <code>malli.dev.pretty/reporter</code>  and <code>:fn</code> but couldn&apos;t figure out the reason for overflow.

<pre>(defn identity-42
  {:malli/schema [:=&gt; [:cat [:fn (fn [n] (= 42 n))]] :int]}
  [a] a)

(instrument/collect!)
(malli.dev/start! {:report (malli.dev.pretty/reporter)})
(identity-42 41) ; Execution error (StackOverflowError) at fipp.ednize/override? (ednize.clj:12)

(malli.dev/stop!)
(malli.dev/start!)
(identity-42 41) ; :malli.core/invalid-input {:input [:cat [:fn #funct ...</pre></z><z id="t1628445384" t="emccue this is what i load in (requiring malli dev and malli pretty in repl)"><y>#</y><d>2021-08-08</d><h>17:56</h><w>emccue</w>this is what i load in (requiring malli dev and malli pretty in repl)</z><z id="t1628445391" t="emccue (password-hash {}) Execution error (StackOverflowError) at fipp.ednize/override? (ednize.clj:12). null"><y>#</y><d>2021-08-08</d><h>17:56</h><w>emccue</w><pre>(password-hash {})
Execution error (StackOverflowError) at fipp.ednize/override? (ednize.clj:12).
null</pre></z><z id="t1628445444" t="emccue and this is what happens when i try invalid input"><y>#</y><d>2021-08-08</d><h>17:57</h><w>emccue</w>and this is what happens when i try invalid input</z><z id="t1628445454" t="emccue (password-hash (create {:email &quot;A&quot; :password-hash &quot;a&quot;})) =&gt; &quot;a&quot;"><y>#</y><d>2021-08-08</d><h>17:57</h><w>emccue</w><pre>(password-hash (create {:email &quot;A&quot; :password-hash &quot;a&quot;}))
=&gt; &quot;a&quot;</pre></z><z id="t1628445459" t="emccue valid input works fine though"><y>#</y><d>2021-08-08</d><h>17:57</h><w>emccue</w>valid input works fine though</z><z id="t1628445471" t="emccue just changed to [metosin/malli &quot;0.6.1&quot;]"><y>#</y><d>2021-08-08</d><h>17:57</h><w>emccue</w>just changed to <code>[metosin/malli &quot;0.6.1&quot;]</code></z><z id="t1628504487" t="ikitommi oh, it&apos;s the function values, need to short-circuit on them. Should be easy to fix."><y>#</y><d>2021-08-09</d><h>10:21</h><w>ikitommi</w>oh, it&apos;s the function values, need to short-circuit on them. Should be easy to fix.</z><z id="t1628504744" t="ikitommi though experiment: • persist function schemas into edn/file (var-&gt;schema) • write a clj-kondo plugin/hook that looks from afile if a Var has a malli schema defined. If it has runs that validation (inputs &amp; outputs) to it and reports. Static analysis with full malli :thinking_face: 🚀 parrot "><y>#</y><d>2021-08-09</d><h>10:25</h><w>ikitommi</w>though experiment: 
• persist function schemas into edn/file (var-&gt;schema)
• write a clj-kondo plugin/hook that looks from afile if a Var has a malli schema defined. If it has runs that validation (inputs &amp; outputs) to it and reports. Static analysis with full malli <b>:thinking_face:</b> <b>🚀</b> <b>parrot</b> </z><z id="t1628504940" t="Ben Sless separating type and code for functions seems like a footgun waiting to go off"><y>#</y><d>2021-08-09</d><h>10:29</h><r>Ben Sless</r>separating type and code for functions seems like a footgun waiting to go off</z><z id="t1628504995" t="Ben Sless someone will change one and not the other"><y>#</y><d>2021-08-09</d><h>10:29</h><r>Ben Sless</r>someone will change one and not the other</z><z id="t1628505033" t="borkdude I think you could have some kind of development runtime hook that writes clj-kondo type config as you go. But if I understand correctly malli already has this"><y>#</y><d>2021-08-09</d><h>10:30</h><r>borkdude</r>I think you could have some kind of development runtime hook that writes clj-kondo type config as you go. But if I understand correctly malli already has this</z><z id="t1628505090" t="borkdude one issue is that statically visible values are not the runtime values, so validating on those has different behavior"><y>#</y><d>2021-08-09</d><h>10:31</h><r>borkdude</r>one issue is that statically visible values are not the runtime values, so validating on those has different behavior</z><z id="t1628505097" t="ikitommi yes, malli.dev/start! re-writes the the clj-kondo config on any change to the function registry"><y>#</y><d>2021-08-09</d><h>10:31</h><r>ikitommi</r>yes, <code>malli.dev/start!</code> re-writes the the clj-kondo config on any change to the function registry</z><z id="t1628505111" t="ikitommi could emit the new var-&gt;malli-schema file too at the same time."><y>#</y><d>2021-08-09</d><h>10:31</h><r>ikitommi</r>could emit the new var-&gt;malli-schema file too at the same time.</z><z id="t1628505123" t="ikitommi (and malli.dev/stop! removes the file(s))"><y>#</y><d>2021-08-09</d><h>10:32</h><r>ikitommi</r>(and <code>malli.dev/stop!</code> removes the file(s))</z><z id="t1628505242" t="ikitommi yes, that works with simple/demo cases. would need typedclojure to follow the types for real? and actual runtime to track the values for real?"><y>#</y><d>2021-08-09</d><h>10:34</h><r>ikitommi</r>yes, that works with simple/demo cases. would need typedclojure to follow the types for real? and actual runtime to track the values for real?</z><z id="t1628505392" t="ikitommi I guess one could just add new keys to the clj-kondo config too? e.g. :malli/schema [:=&gt; [:cat :int] :int]]"><y>#</y><d>2021-08-09</d><h>10:36</h><r>ikitommi</r>I guess one could just add new keys to the clj-kondo config too? e.g. <code>:malli/schema [:=&gt; [:cat :int] :int]]</code></z><z id="t1628505431" t="ikitommi would be just one config file then, always up-to-date."><y>#</y><d>2021-08-09</d><h>10:37</h><r>ikitommi</r>would be just one config file then, always up-to-date.</z><z id="t1628505529" t="borkdude you mean type aliases?"><y>#</y><d>2021-08-09</d><h>10:38</h><r>borkdude</r>you mean type aliases?</z><z id="t1628505653" t="ikitommi {:linters {:type-mismatch {:namespaces {malli.demo {plus {:arities {1 {:args [:int] :ret :int :malli/schema [:=&gt; [:cat int?] pos-int?]}}}}}}}}"><y>#</y><d>2021-08-09</d><h>10:40</h><r>ikitommi</r><pre>{:linters 
	{:type-mismatch 
		{:namespaces 
			{malli.demo 
				{plus 
					{:arities 
						{1 {:args [:int]
				            :ret :int
				            :malli/schema [:=&gt; [:cat int?] pos-int?]}}}}}}}}</pre></z><z id="t1628505688" t="ikitommi … for the plugin to read from."><y>#</y><d>2021-08-09</d><h>10:41</h><r>ikitommi</r>… for the plugin to read from.</z><z id="t1628505896" t="borkdude but when your plugin is called with the input types, it would have to do something similar to the clj-kondo &quot;type&quot; system right"><y>#</y><d>2021-08-09</d><h>10:44</h><r>borkdude</r>but when your plugin is called with the input types, it would have to do something similar to the clj-kondo &quot;type&quot; system right</z><z id="t1628505906" t="borkdude so why not convert the schema to the clj-kondo type system immediately"><y>#</y><d>2021-08-09</d><h>10:45</h><r>borkdude</r>so why not convert the schema to the clj-kondo type system immediately</z><z id="t1628507908" t="ikitommi it is converted already to clj-kondo type system. In top of that, using second round of malli-vqlidation, one could catch more, like integer min&amp;max sizes, collection limits, closed maps, multis, sequences etc. The code would require access to: 1. function arguments 2. the :malli/schema value (from linter config). "><y>#</y><d>2021-08-09</d><h>11:18</h><r>ikitommi</r>it is converted already to clj-kondo type system. In top of that, using second round of malli-vqlidation, one could catch more, like integer min&amp;max sizes, collection limits, closed maps, multis, sequences etc. The code would require access to:
1. function arguments
2. the <code>:malli/schema</code> value (from linter config). </z><z id="t1628507979" t="borkdude and you would need to invoke malli itself as well right?"><y>#</y><d>2021-08-09</d><h>11:19</h><r>borkdude</r>and you would need to invoke malli itself as well right?</z><z id="t1628507980" t="ikitommi not sure if this is anyhow useful, but might be doable? At least emitting the malli-schema to the linter config would be a +1loc in malli."><y>#</y><d>2021-08-09</d><h>11:19</h><r>ikitommi</r>not sure if this is anyhow useful, but might be doable? At least emitting the malli-schema to the linter config would be a +1loc in malli.</z><z id="t1628507986" t="ikitommi yes"><y>#</y><d>2021-08-09</d><h>11:19</h><r>ikitommi</r>yes</z><z id="t1628508012" t="borkdude in that case malli would have to be built into the clj-kondo or clojure-lsp binary, unless you run it on the JVM"><y>#</y><d>2021-08-09</d><h>11:20</h><r>borkdude</r>in that case malli would have to be built into the clj-kondo or clojure-lsp binary, unless you run it on the JVM</z><z id="t1628508079" t="borkdude what you could do, as it is now, is programmatically generate hooks for each var that has a malli spec"><y>#</y><d>2021-08-09</d><h>11:21</h><r>borkdude</r>what you could do, as it is now, is programmatically generate hooks for each var that has a malli spec</z><z id="t1628508105" t="borkdude there you can have access to the arguments and do whatever you like, throw exceptions. The hooks already have access to the linter config"><y>#</y><d>2021-08-09</d><h>11:21</h><r>borkdude</r>there you can have access to the arguments and do whatever you like, throw exceptions. The hooks already have access to the linter config</z><z id="t1628508124" t="borkdude and then you could write some validations like malli but in user space, just as a proof of concept"><y>#</y><d>2021-08-09</d><h>11:22</h><r>borkdude</r>and then you could write some validations like malli but in user space, just as a proof of concept</z><z id="t1628508153" t="borkdude or you can fork clj-kondo and add malli to the type system and explore until you reach some interesting conclusions"><y>#</y><d>2021-08-09</d><h>11:22</h><r>borkdude</r>or you can fork clj-kondo and add malli to the type system and explore until you reach some interesting conclusions</z><z id="t1628508172" t="ikitommi sounds fun"><y>#</y><d>2021-08-09</d><h>11:22</h><r>ikitommi</r>sounds fun</z><z id="t1628508202" t="borkdude I&apos;m also open to clj-kondo type system improvements, there are a few low hanging fruits perhaps"><y>#</y><d>2021-08-09</d><h>11:23</h><r>borkdude</r>I&apos;m also open to clj-kondo type system improvements, there are a few low hanging fruits perhaps</z><z id="t1628521338" t="ikitommi ... also, if the config-file could be used as a.simple database, the tool could run Malli&apos;s check once for each var (gen-test) and mark :malli/check with the result (nil or error) - &quot;function does not conform to it&apos;s schema, with arguments [0 -1], the result is -1, which is not a positive integer&quot;"><y>#</y><d>2021-08-09</d><h>15:02</h><r>ikitommi</r>... also, if the config-file could be used as a.simple database, the tool could run Malli&apos;s <code>check</code> once for each var (gen-test) and mark <code>:malli/check</code> with the result (nil or error) - &quot;function does not conform to it&apos;s schema, with arguments [0 -1], the result is -1, which is  not a positive integer&quot;</z><z id="t1628522690" t="NoahTheDuke is it possible to enable generative testing (`{ :: m/function-checker mg/function-checker}`) for all function schemas during test runs without adding a (when (= :test (:env app)) ...) to every schema manually?"><y>#</y><d>2021-08-09</d><h>15:24</h><w>NoahTheDuke</w>is it possible to enable generative testing (`{<b>::</b>m/function-checker mg/function-checker}`) for all function schemas during test runs without adding a <code>(when (= :test (:env app)) ...)</code> to every schema manually?</z><z id="t1628526916" t="ikitommi there is an issue to allow setting default options. Before that, you could redefine the var where it&apos;s read / defined?"><y>#</y><d>2021-08-09</d><h>16:35</h><r>ikitommi</r>there is an issue to allow setting default options. Before that, you could redefine the var where it&apos;s read / defined?</z><z id="t1628526931" t="ikitommi dirty, but works"><y>#</y><d>2021-08-09</d><h>16:35</h><r>ikitommi</r>dirty, but works</z><z id="t1628526937" t="NoahTheDuke yeah, maybe i’ll try that"><y>#</y><d>2021-08-09</d><h>16:35</h><r>NoahTheDuke</r>yeah, maybe i’ll try that</z><z id="t1628526942" t="ikitommi And please write an issue"><y>#</y><d>2021-08-09</d><h>16:35</h><r>ikitommi</r>And please write an issue</z><z id="t1628523546" t="richiardiandrea Question, say I want to try Malli but I don&apos;t have the fire power to rewrite all the specs...What would be the best &quot;migration strategy&quot; there? We instrument every function in dev mode and tests and we use specs for our domain model and http param validation at the moment. What I am worried about the former and the following - how can I instrument a function that has been partially covered with spec and partially with Malli?"><y>#</y><d>2021-08-09</d><h>15:39</h><w>richiardiandrea</w>Question, say I want to try Malli but I don&apos;t have the fire power to rewrite all the specs...What would be the best &quot;migration strategy&quot; there?
We instrument every function in dev mode and tests and we use specs for our domain model and http param validation at the moment.
What I am worried about the former and the following - how can I instrument a function that has been partially covered with spec and partially with Malli?</z><z id="t1628527028" t="ikitommi create a spec-&gt;malli converter, PR that and enjoy the ride? :face_with_cowboy_hat:"><y>#</y><d>2021-08-09</d><h>16:37</h><r>ikitommi</r>create a spec-&gt;malli converter, PR that and enjoy the ride? <b>:face_with_cowboy_hat:</b></z><z id="t1628527085" t="ikitommi Not sure if the intstrumentatons stack, could just work?"><y>#</y><d>2021-08-09</d><h>16:38</h><r>ikitommi</r>Not sure if the intstrumentatons stack, could just work?</z><z id="t1628566476" t="Joel I would think &apos;:b&apos; could be in square brackets: [:a {:x &quot;s&quot;} [:b]], but it doesn&apos;t work, i&apos;d like to be able to nest :cat/n (-&gt; [:cat [:enum :a] [:map [:x string?]] [:cat [:enum :b]]] (mc/explain [:a {:x &quot;s&quot;} :b]) (me/humanize))"><y>#</y><d>2021-08-10</d><h>03:34</h><w>Joel</w>I would think &apos;:b&apos; could be in square brackets: [:a {:x &quot;s&quot;} [:b]], but it doesn&apos;t work, i&apos;d like to be able to nest :cat/n
<pre>(-&gt; [:cat
       [:enum :a]
       [:map [:x string?]]
       [:cat [:enum :b]]]
      (mc/explain
        [:a {:x &quot;s&quot;} :b])
      (me/humanize))</pre></z><z id="t1628570645" t="ikitommi [:attrs {:href &quot;/_/_/users/UH13Y2FSA&quot;}] from the README: As all these examples show, the &quot;seqex&quot; operators take any non-seqex child schema to mean a sequence of one element that matches that schema. To force that behaviour for a seqex child :schema can be used: (m/validate [:cat [:= :names] [:schema [:* string?]] [:= :nums] [:schema [:* number?]]] [:names [&quot;a&quot; &quot;b&quot;] :nums [1 2 3]]) ; =&gt; true ;; whereas (m/validate [:cat [:= :names] [:* string?] [:= :nums] [:* number?]] [:names &quot;a&quot; &quot;b&quot; :nums 1 2 3]) ; =&gt; true"><y>#</y><d>2021-08-10</d><h>04:44</h><w>ikitommi</w><a>@joel380</a> from the README:
<pre>As all these examples show, the &quot;seqex&quot; operators take any non-seqex child schema to mean a sequence of one element that matches that schema. To force that behaviour for a seqex child :schema can be used:

(m/validate
  [:cat [:= :names] [:schema [:* string?]] [:= :nums] [:schema [:* number?]]]
  [:names [&quot;a&quot; &quot;b&quot;] :nums [1 2 3]])
; =&gt; true

;; whereas
(m/validate
  [:cat [:= :names] [:* string?] [:= :nums] [:* number?]]
  [:names &quot;a&quot; &quot;b&quot; :nums 1 2 3]) 
; =&gt; true</pre></z><z id="t1628570693" t="ikitommi e.g. [:cat [:enum :a] [:map [:x string?]] [:schema [:cat [:enum :b]]]]"><y>#</y><d>2021-08-10</d><h>04:44</h><w>ikitommi</w>e.g.
<pre>[:cat
 [:enum :a]
 [:map [:x string?]]
 [:schema [:cat [:enum :b]]]]</pre></z><z id="t1628574341" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] fixed in master. Also, you don’t need the malli.instrument/collect! , malli.dev/start! calls that."><y>#</y><d>2021-08-10</d><h>05:45</h><w>ikitommi</w><a>@emccue</a> fixed in master. Also, you don’t need the <code>malli.instrument/collect!</code>, <code>malli.dev/start!</code> calls that.</z><z id="t1628574345" t="ikitommi https://github.com/metosin/malli/pull/509"><y>#</y><d>2021-08-10</d><h>05:45</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/509" target="_blank">https://github.com/metosin/malli/pull/509</a></z><z id="t1628599772" t="emccue But it won&apos;t call it on reload if i&apos;m using the metadata form for the schema right?"><y>#</y><d>2021-08-10</d><h>12:49</h><r>emccue</r>But it won&apos;t call it on reload if i&apos;m using the metadata form for the schema right?</z><z id="t1628601094" t="ikitommi currently only on start! . I tried to add var-watching to the once-registered vars, but didn&apos;t have the skills to do that. start! &amp; stop! should play nice with reloaded repl thou."><y>#</y><d>2021-08-10</d><h>13:11</h><r>ikitommi</r>currently only on <code>start!</code>. I tried to add var-watching to the once-registered vars, but didn&apos;t have the skills to do that. <code>start!</code> &amp; <code>stop!</code> should play nice with reloaded repl thou.</z><z id="t1628596882" t="Darnaroth Darnarowth Question, is it possible to add sci options on a custom decoder, or any ability to set sci options globally?"><y>#</y><d>2021-08-10</d><h>12:01</h><w>Darnaroth Darnarowth</w>Question, is it possible to add <code>sci</code> options on a custom decoder, or any ability to set sci options globally?</z><z id="t1628598042" t="Karol Wójcik Hi! How can I check if x satisfies the protocol y in malli metadata schema?"><y>#</y><d>2021-08-10</d><h>12:20</h><w>Karol Wójcik</w>Hi! How can I check if x satisfies the protocol y in malli metadata schema?</z><z id="t1628602530" t="Karol Wójcik Ok I found the answer!"><y>#</y><d>2021-08-10</d><h>13:35</h><r>Karol Wójcik</r>Ok I found the answer!</z><z id="t1639036331" t="amithgeorge I found this thread via Slack search. Please share the answer!!"><y>#</y><d>2021-12-09</d><h>07:52</h><r>amithgeorge</r>I found this thread via Slack search. Please share the answer!!</z><z id="t1639060091" t="Karol Wójcik Create a schema from a -simple-schema (def proto-schema (-simple-schema {:pred (fn [x] (satisfies? PROTO x)}))"><y>#</y><d>2021-12-09</d><h>14:28</h><r>Karol Wójcik</r>Create a schema from a <code>-simple-schema</code>

<pre>(def proto-schema (-simple-schema {:pred (fn [x] (satisfies? PROTO x)}))</pre></z><z id="t1639060901" t="amithgeorge Thank you! Will try this. :thumbsup:"><y>#</y><d>2021-12-09</d><h>14:41</h><r>amithgeorge</r>Thank you! Will try this. <b>:thumbsup:</b></z><z id="t1628601094" t="ikitommi currently only on start! . I tried to add var-watching to the once-registered vars, but didn&apos;t have the skills to do that. start! &amp; stop! should play nice with reloaded repl thou."><y>#</y><d>2021-08-10</d><h>13:11</h><w>ikitommi</w>currently only on <code>start!</code>. I tried to add var-watching to the once-registered vars, but didn&apos;t have the skills to do that. <code>start!</code> &amp; <code>stop!</code> should play nice with reloaded repl thou.</z><z id="t1628602752" t="ikitommi silly-hacky-var-watching-diy-horror: (defn plus1 &quot;adds 1 to number&quot; {:malli/schma [:=&gt; [:cat :int] :int]} [x] (inc x)) (add-watch #&apos;plus1 ::watch (fn [_ v _ _] (future (println v &quot;=&gt;&quot; (-&gt; v meta :malli/schema))))) (defn plus1 &quot;adds 1 to number&quot; {:malli/schema [:=&gt; [:cat [:int {:min 0}]] :int]} [x] (inc x)) ; =prints=&gt; #&apos;user/plus1 =&gt; [:=&gt; [:cat [:int {:min 0}]] :int]"><y>#</y><d>2021-08-10</d><h>13:39</h><w>ikitommi</w>silly-hacky-var-watching-diy-horror:
<pre>(defn plus1
  &quot;adds 1 to number&quot;
  {:malli/schma [:=&gt; [:cat :int] :int]}
  [x] (inc x))

(add-watch #&apos;plus1 ::watch (fn [_ v _ _] (future (println v &quot;=&gt;&quot; (-&gt; v meta :malli/schema)))))

(defn plus1
  &quot;adds 1 to number&quot;
  {:malli/schema [:=&gt; [:cat [:int {:min 0}]] :int]}
  [x] (inc x))
; =prints=&gt; #&apos;user/plus1 =&gt; [:=&gt; [:cat [:int {:min 0}]] :int]</pre></z><z id="t1628602788" t="ikitommi if that could be made robust, could just re-define schmatized vars and the clj-kondo + instrumentation would follow instantly."><y>#</y><d>2021-08-10</d><h>13:39</h><w>ikitommi</w>if that could be made robust, could just re-define schmatized vars and the clj-kondo + instrumentation would follow instantly.</z><z id="t1628602803" t="ikitommi ideas welcome (asked on #clojure too)"><y>#</y><d>2021-08-10</d><h>13:40</h><w>ikitommi</w>ideas welcome (asked on #clojure too)</z><z id="t1628604020" t="emccue well, if it needs to be &quot;scheduled to fetch later&quot; you could have something like"><y>#</y><d>2021-08-10</d><h>14:00</h><w>emccue</w>well, if it needs to be &quot;scheduled to fetch later&quot; you could have something like</z><z id="t1628604189" t="emccue (defn schedule-to-refresh [var] (set! some-flag-another-thread-is-waiting-on true) ;; Or (.push some-array-blocking-queue-another-thread-is-waiting-on ...)) (add-watch #&apos;plus1 (fn [_ v _ _] (schedule-to-refresh v)))"><y>#</y><d>2021-08-10</d><h>14:03</h><w>emccue</w><pre>(defn schedule-to-refresh 
  [var]
  (set! some-flag-another-thread-is-waiting-on true)
  ;; Or
  (.push some-array-blocking-queue-another-thread-is-waiting-on ...))

(add-watch #&apos;plus1 
  (fn [_ v _ _]
    (schedule-to-refresh v)))</pre></z><z id="t1628604249" t="emccue so at least you don&apos;t necessarily interact with the future threadpool"><y>#</y><d>2021-08-10</d><h>14:04</h><w>emccue</w>so at least you don&apos;t necessarily interact with the future threadpool</z><z id="t1628604323" t="emccue and it isn&apos;t a race condition"><y>#</y><d>2021-08-10</d><h>14:05</h><w>emccue</w>and it isn&apos;t a race condition</z><z id="t1628613209" t="robert-stuttaford [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks for the humanize buffs 🙂"><y>#</y><d>2021-08-10</d><h>16:33</h><w>robert-stuttaford</w><a>@ikitommi</a> thanks for the humanize buffs <b>🙂</b></z><z id="t1628640500" t="steveb8n [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I haven’t tested but would the new release be likely to improve this perf issue? https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d"><y>#</y><d>2021-08-11</d><h>00:08</h><w>steveb8n</w><a>@ikitommi</a> I haven’t tested but would the new release be likely to improve this perf issue? <a href="https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d" target="_blank">https://gist.github.com/stevebuik/e63735d99fca94041120f9b0e25b616d</a></z><z id="t1628658197" t="Ben Sless tried it out of curiosity, looks like it was improved"><y>#</y><d>2021-08-11</d><h>05:03</h><r>Ben Sless</r>tried it out of curiosity, looks like it was improved</z><z id="t1628669986" t="Karol Wójcik What is wrong with this schema? (def logger-pairs-schema [:+ [:tuple keyword? string?]]) (defn pairs-conforms! {:malli/schema [:=&gt; [:cat [logger-pairs-schema]] nil? ;; [:or [nil? logger-pairs-schema]] ]} [pairs] )"><y>#</y><d>2021-08-11</d><h>08:19</h><w>Karol Wójcik</w>What is wrong with this schema?

<pre>(def logger-pairs-schema
  [:+ [:tuple keyword? string?]])

(defn pairs-conforms!
  {:malli/schema [:=&gt;
                  [:cat [logger-pairs-schema]]
                  nil?
                  ;; [:or [nil? logger-pairs-schema]]
                  ]}
  [pairs]


  )</pre></z><z id="t1628670049" t="Karol Wójcik :malli.core/invalid-schema {:schema [:+ [:tuple #function[clojure.core/keyword?] #function[clojure.core/string?--5427]]]} I don&apos;t understand why this throws an error"><y>#</y><d>2021-08-11</d><h>08:20</h><r>Karol Wójcik</r><pre>:malli.core/invalid-schema {:schema [:+ [:tuple #function[clojure.core/keyword?] #function[clojure.core/string?--5427]]]}</pre>
I don&apos;t understand why this throws an error</z><z id="t1628670362" t="Karol Wójcik This is thrown from the new reported (ns dev (:require [malli.dev :as dev] [malli.dev.pretty :as pretty])) (dev/start! {:report (pretty/reporter)})"><y>#</y><d>2021-08-11</d><h>08:26</h><r>Karol Wójcik</r>This is thrown from the new reported

<pre>(ns dev                                 
  (:require                             
   [malli.dev :as dev]                  
   [malli.dev.pretty :as pretty]))      
                                        
(dev/start! {:report (pretty/reporter)})</pre></z><z id="t1628673093" t="Ben Sless Try not wrapping logger pairs schema in a vector?"><y>#</y><d>2021-08-11</d><h>09:11</h><r>Ben Sless</r>Try not wrapping logger pairs schema in a vector?</z><z id="t1628676431" t="Karol Wójcik I don&apos;t get it. (m/validate logger-pairs-schema [[:x &quot;something&quot;]]) =&gt; true [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] isn&apos;t it a bug?"><y>#</y><d>2021-08-11</d><h>10:07</h><r>Karol Wójcik</r>I don&apos;t get it.
<pre>(m/validate logger-pairs-schema [[:x &quot;something&quot;]]) =&gt; true </pre>
<a>@ikitommi</a> isn&apos;t it a bug?</z><z id="t1628681168" t="ikitommi no, just an extra vector: (m/schema [:cat [[:+ [:tuple keyword? string?]]]]) ; =throws=&gt; :malli.core/invalid-schema (m/schema [:cat [:+ [:tuple keyword? string?]]]) ; =&gt; =&gt; [:cat [:+ [:tuple keyword? string?]]]"><y>#</y><d>2021-08-11</d><h>11:26</h><r>ikitommi</r>no, just an extra vector:
<pre>(m/schema [:cat [[:+ [:tuple keyword? string?]]]])
; =throws=&gt; :malli.core/invalid-schema 

(m/schema [:cat [:+ [:tuple keyword? string?]]])
; =&gt; =&gt; [:cat [:+ [:tuple keyword? string?]]]</pre></z><z id="t1628681229" t="ikitommi we could make the pretty printer capture schema-creation errors too in dev."><y>#</y><d>2021-08-11</d><h>11:27</h><r>ikitommi</r>we could make the pretty printer capture schema-creation errors too in dev.</z><z id="t1628681260" t="ikitommi same result thou, just more fun with colors 🌈 !"><y>#</y><d>2021-08-11</d><h>11:27</h><r>ikitommi</r>same result thou, just more fun with colors <b>🌈</b> !</z><z id="t1628684441" t="Karol Wójcik Ahh. Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] :3"><y>#</y><d>2021-08-11</d><h>12:20</h><r>Karol Wójcik</r>Ahh. Thank you <a>@ikitommi</a> :3</z><z id="t1628701928" t="emccue (mg/generate [:cat string? int?]) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79). :malli.core/invalid-schema {:schema :cat}"><y>#</y><d>2021-08-11</d><h>17:12</h><w>emccue</w><pre>(mg/generate [:cat string? int?])
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:79).
:malli.core/invalid-schema {:schema :cat}</pre></z><z id="t1628701936" t="emccue is there some context i&apos;m missing?"><y>#</y><d>2021-08-11</d><h>17:12</h><w>emccue</w>is there some context i&apos;m missing?</z><z id="t1628701942" t="emccue cat doesn&apos;t seem to want to be a valid schema"><y>#</y><d>2021-08-11</d><h>17:12</h><w>emccue</w>cat doesn&apos;t seem to want to be a valid schema</z><z id="t1628702457" t="emccue nvm - seem to have had a really old version floating around the classpath"><y>#</y><d>2021-08-11</d><h>17:20</h><w>emccue</w>nvm - seem to have had a really old version floating around the classpath</z><z id="t1628863467" t="emccue It also just dawned on me that the metadata schemas mean I can publish a library with malli schemas and no dependency on malli"><y>#</y><d>2021-08-13</d><h>14:04</h><w>emccue</w>It also just dawned on me that the metadata schemas mean I can publish a library with malli schemas and no dependency on malli</z><z id="t1628863503" t="emccue i have no doubt that was part of the intent and its silly I just realized it, but its still really cool"><y>#</y><d>2021-08-13</d><h>14:05</h><w>emccue</w>i have no doubt that was part of the intent and its silly I just realized it, but its still really cool</z><z id="t1628863895" t="NoahTheDuke that is cool!"><y>#</y><d>2021-08-13</d><h>14:11</h><w>NoahTheDuke</w>that is cool!</z><z id="t1628935378" t="andre.richards Hi, :uuid schema does not produce correct humanized error: (me/humanize (m/explain :uuid &quot;foo&quot;)) =&gt; [&quot;unknown error&quot;] uuid? produces this: (me/humanize (m/explain uuid? &quot;foo&quot;)) =&gt; [&quot;should be a uuid&quot;] uuid? has an entry in malli.error but :uuid does not, so it looks like an easy fix. Should I log a issue and raise a pull request?"><y>#</y><d>2021-08-14</d><h>10:02</h><w>andre.richards</w>Hi, <code>:uuid</code> schema does not produce correct humanized error:

<pre>(me/humanize (m/explain :uuid &quot;foo&quot;))
=&gt; [&quot;unknown error&quot;]</pre>
<code>uuid?</code> produces this:
<pre>(me/humanize (m/explain uuid? &quot;foo&quot;))
=&gt; [&quot;should be a uuid&quot;]</pre>
<code>uuid?</code> has an entry in <code>malli.error</code> but <code>:uuid</code> does not, so it looks like an easy fix.

Should I log a issue and raise a pull request?</z><z id="t1628936449" t="ikitommi Please do!"><y>#</y><d>2021-08-14</d><h>10:20</h><r>ikitommi</r>Please do!</z><z id="t1628937642" t="andre.richards Done: https://github.com/metosin/malli/pull/512 Thanks for Malli!"><y>#</y><d>2021-08-14</d><h>10:40</h><r>andre.richards</r>Done: <a href="https://github.com/metosin/malli/pull/512" target="_blank">https://github.com/metosin/malli/pull/512</a>

Thanks for Malli!</z><z id="t1628938295" t="ikitommi merged, thanks!"><y>#</y><d>2021-08-14</d><h>10:51</h><r>ikitommi</r>merged, thanks!</z><z id="t1628941187" t="Vladislav Hi! It’s no option to assoc key with parameters (optional etc.) to schema hm for now, i’m right? I’m forced to use merge for that"><y>#</y><d>2021-08-14</d><h>11:39</h><w>Vladislav</w>Hi! It’s no option to assoc key with parameters (optional etc.) to schema hm for now, i’m right? I’m forced to use merge for that</z><z id="t1628949025" t="ikitommi [:attrs {:href &quot;/_/_/users/UNJE65T24&quot;}] You can use a vector to assoc full entry, not at computer, but this should work: (mu/assoc :map [:x {:optional true}] :int)"><y>#</y><d>2021-08-14</d><h>13:50</h><w>ikitommi</w><a>@shishkov61</a> You can use a vector to assoc full entry, not at computer, but this should work:
<code>(mu/assoc :map [:x {:optional true}] :int)</code></z><z id="t1628949361" t="Vladislav i’ll try it. thanks!"><y>#</y><d>2021-08-14</d><h>13:56</h><r>Vladislav</r>i’ll try it. thanks!</z><z id="t1628974745" t="Vladislav (m/validate [:map [[:set string?] number?]] {#{&quot;a&quot;} 1}) =&gt; false should it be like this?"><y>#</y><d>2021-08-14</d><h>20:59</h><w>Vladislav</w><pre>(m/validate 
  [:map [[:set string?] number?]] 
  {#{&quot;a&quot;} 1})
=&gt; false</pre>
should it be like this?</z><z id="t1628975328" t="Vladislav actually, i don&apos;t see no docs about maps with keys which is not static values"><y>#</y><d>2021-08-14</d><h>21:08</h><r>Vladislav</r>actually, i don&apos;t see no docs about maps with keys which is not static values</z><z id="t1628975497" t="Vladislav should i use :registry specified schemas for keys? :thinking_face:"><y>#</y><d>2021-08-14</d><h>21:11</h><r>Vladislav</r>should i use :registry specified schemas for keys?<b>:thinking_face:</b></z><z id="t1628975749" t="Vladislav no, guess i&apos;d found it, but it works another way https://github.com/metosin/malli#qualified-keys-in-a-map"><y>#</y><d>2021-08-14</d><h>21:15</h><r>Vladislav</r>no, guess i&apos;d found it, but it works another way
<a href="https://github.com/metosin/malli#qualified-keys-in-a-map" target="_blank">https://github.com/metosin/malli#qualified-keys-in-a-map</a></z><z id="t1628976481" t="Vladislav o! map-of kinda work for that. but it will be complicated if there is no homogeneous keys needed"><y>#</y><d>2021-08-14</d><h>21:28</h><r>Vladislav</r>o! map-of kinda work for that. but it will be complicated if there is no homogeneous keys needed</z><z id="t1629056690" t="Asko Nōmm Hi! I found a interesting issue in CLJS where Malli fails with &quot;Invalid schema&quot; when checking for object? , for example: (m/validate [:or map? object?] input) Fails. However whenever I remove the object? , it starts working. How do I validate a JS object with Malli if object? makes Malli fail?"><y>#</y><d>2021-08-15</d><h>19:44</h><w>Asko Nōmm</w>Hi! I found a interesting issue in CLJS where Malli fails with &quot;Invalid schema&quot; when checking for <code>object?</code> , for example:

<pre>(m/validate [:or map? object?] input)</pre>
Fails. However whenever I remove the <code>object?</code>, it starts working. How do I validate a JS object with Malli if <code>object?</code> makes Malli fail?</z><z id="t1629058070" t="emccue only certain predicates are &quot;built in&quot; - i.e. have an implicit mapping to something. map? gets swapped with [:map] , effectively"><y>#</y><d>2021-08-15</d><h>20:07</h><r>emccue</r>only certain predicates are &quot;built in&quot; - i.e. have an implicit mapping to something. map? gets swapped with <code>[:map]</code>, effectively</z><z id="t1629058122" t="emccue if you want to use a custom predicate you can either use [:fn object?] - which won&apos;t have generation semantics if you use that for your project"><y>#</y><d>2021-08-15</d><h>20:08</h><r>emccue</r>if you want to use a custom predicate you can either use <code>[:fn object?]</code> - which won&apos;t have generation semantics if you use that for your project</z><z id="t1629058200" t="emccue there is also a way to make a custom schema key/generator/etc. I just don&apos;t know it offhand"><y>#</y><d>2021-08-15</d><h>20:10</h><r>emccue</r>there is also a way to make a custom schema key/generator/etc. I just don&apos;t know it offhand</z><z id="t1629058220" t="emccue https://github.com/metosin/malli#custom-schema-types"><y>#</y><d>2021-08-15</d><h>20:10</h><r>emccue</r><a href="https://github.com/metosin/malli#custom-schema-types" target="_blank">https://github.com/metosin/malli#custom-schema-types</a></z><z id="t1629058225" t="emccue it is documented here though"><y>#</y><d>2021-08-15</d><h>20:10</h><r>emccue</r>it is documented here though</z><z id="t1629060377" t="Asko Nōmm Cheers [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] , this solved it perfectly. I didn&apos;t know that it swapped the predicates, this makes sense now!"><y>#</y><d>2021-08-15</d><h>20:46</h><r>Asko Nōmm</r>Cheers <a>@U3JH98J4R</a>, this solved it perfectly. I didn&apos;t know that it swapped the predicates, this makes sense now!</z><z id="t1629101961" t="pithyless I&apos;m working with the malli schema functions (the new dev error reporting is nice!) and I seem to be at a crossroads: 1. If I choose to use m/=&gt; at the top-level: a. I need to an explicit dependency on malli (not generally a problem with applications, but this is probably a no-go for libraries) b. I cannot use non-standard registry schemas, since it is evaled at compile time. c. I think even if I could force some preload logic to make sure my global malli registry is updated before other namespaces are loaded, this is both prone to errors and probably would still not work with external tools that work per-file (clj-kondo, etc) 2. If I choose to use :malli/schema metadata: a. I am free to include it optionally without directly requiring malli b. I can use non-standard registry schemas c. The malli.dev/start! does not pick up var changes (need to force a refresh) d. The metadata approach sometimes makes the function feel &quot;verbose&quot;. This is a obviously a subjective feeling, but if the specs are verbose and the function body is short, sometimes the separate m/=&gt; looks nicer. Because of the problems with (1), I&apos;m thinking of still focusing on (2). I can workaround (2c) and perhaps (2d) can be mitigated in certain cases with a (def foo-schema [:=&gt; ...]) and then using (defn foo {:malli/schema #&apos;foo-schema} ..) ?"><y>#</y><d>2021-08-16</d><h>08:19</h><w>pithyless</w>I&apos;m working with the malli schema functions (the new dev error reporting is nice!) and I seem to be at a crossroads:
1. If I choose to use <code>m/=&gt;</code> at the top-level:
    a. I need to an explicit dependency on malli (not generally a problem with applications, but this is probably a no-go for libraries)
    b. I cannot use non-standard registry schemas, since it is evaled at compile time.
    c. I think even if I could force some preload logic to make sure my global malli registry is updated before other namespaces are loaded, this is both prone to errors and probably would still not work with external tools that work per-file (clj-kondo, etc)
2. If I choose to use <code>:malli/schema</code> metadata:
    a. I am free to include it optionally without directly requiring malli
    b. I can use non-standard registry schemas
    c. The <code>malli.dev/start!</code> does not pick up var changes (need to force a refresh)
    d. The metadata approach sometimes makes the function feel &quot;verbose&quot;. This is a obviously a subjective feeling, but if the specs are verbose and the function body is short, sometimes the separate <code>m/=&gt;</code> looks nicer. 
Because of the problems with (1), I&apos;m thinking of still focusing on (2). I can workaround (2c) and perhaps (2d) can be mitigated in certain cases with a <code>(def foo-schema [:=&gt; ...])</code> and then using <code>(defn foo {:malli/schema #&apos;foo-schema} ..)</code> ?</z><z id="t1629101999" t="pithyless Posting these observations, in hopes that someone can set me straight on my misunderstanding; or perhaps suggest a better approach? :)"><y>#</y><d>2021-08-16</d><h>08:19</h><r>pithyless</r>Posting these observations, in hopes that someone can set me straight on my misunderstanding; or perhaps suggest a better approach? :)</z><z id="t1629105136" t="ikitommi • 1b&amp;c -&gt; this should be resolved somehow, please write an issue • 2c -&gt; can be fixed (look up for var changes automatically) • d -&gt; true that what might help if malli could pick up the function schemas from the actual functions behind the vars. it would allow one to say: (defn kikka []) ;; just clojure (defn =&gt; [v schema] (alter-var-root v vary-meta assoc :malli/schema schema)) ;; add a function schemas without deps to malli (=&gt; #&apos;kikka [:=&gt; :cat :any]) ;; reading from function (-&gt; kikka meta :malli/schema) ; =&gt; [:=&gt; :cat :any]"><y>#</y><d>2021-08-16</d><h>09:12</h><r>ikitommi</r>• 1b&amp;c -&gt; this should be resolved somehow, please write an issue
• 2c -&gt; can be fixed (look up for var changes automatically)
• d -&gt; true that
what might help if malli could pick up the function schemas from the actual functions behind the vars. it would allow one to say:
<pre>(defn kikka [])

;; just clojure
(defn =&gt; [v schema]
  (alter-var-root v vary-meta assoc :malli/schema schema))

;; add a function schemas without deps to malli
(=&gt; #&apos;kikka [:=&gt; :cat :any])

;; reading from function
(-&gt; kikka meta :malli/schema) ; =&gt; [:=&gt; :cat :any]</pre></z><z id="t1629106841" t="pithyless That looks promising; I will try it out today and submit an issue later. Thanks!"><y>#</y><d>2021-08-16</d><h>09:40</h><r>pithyless</r>That looks promising; I will try it out today and submit an issue later. Thanks!</z><z id="t1629105136" t="ikitommi • 1b&amp;c -&gt; this should be resolved somehow, please write an issue • 2c -&gt; can be fixed (look up for var changes automatically) • d -&gt; true that what might help if malli could pick up the function schemas from the actual functions behind the vars. it would allow one to say: (defn kikka []) ;; just clojure (defn =&gt; [v schema] (alter-var-root v vary-meta assoc :malli/schema schema)) ;; add a function schemas without deps to malli (=&gt; #&apos;kikka [:=&gt; :cat :any]) ;; reading from function (-&gt; kikka meta :malli/schema) ; =&gt; [:=&gt; :cat :any]"><y>#</y><d>2021-08-16</d><h>09:12</h><w>ikitommi</w>• 1b&amp;c -&gt; this should be resolved somehow, please write an issue
• 2c -&gt; can be fixed (look up for var changes automatically)
• d -&gt; true that
what might help if malli could pick up the function schemas from the actual functions behind the vars. it would allow one to say:
<pre>(defn kikka [])

;; just clojure
(defn =&gt; [v schema]
  (alter-var-root v vary-meta assoc :malli/schema schema))

;; add a function schemas without deps to malli
(=&gt; #&apos;kikka [:=&gt; :cat :any])

;; reading from function
(-&gt; kikka meta :malli/schema) ; =&gt; [:=&gt; :cat :any]</pre></z><z id="t1629106858" t="Tiago Dall&apos;Oca Hello there"><y>#</y><d>2021-08-16</d><h>09:40</h><w>Tiago Dall'Oca</w>Hello there</z><z id="t1629107205" t="Tiago Dall&apos;Oca I&apos;m trying to create a parser for converting malli&apos;s schemas to DTS files (typescript&apos;s type definitions file). One of the situations I&apos;m running into is reading malli&apos;s schemas correctly, as they&apos;re plain data structures with semantic meaning, so I have to check for some options maps when parsing :map or even cases like https://github.com/metosin/malli#qualified-keys-in-a-map . I was thinking of writing a https://github.com/metosin/malli#parsing-values for helping me out with that, but maybe it already exists? Or is there an easier way?"><y>#</y><d>2021-08-16</d><h>09:46</h><w>Tiago Dall'Oca</w>I&apos;m trying to create a parser for converting malli&apos;s schemas to DTS files (typescript&apos;s type definitions file). One of the situations I&apos;m running into is reading malli&apos;s schemas correctly, as they&apos;re plain data structures with semantic meaning, so I have to check for some options maps when parsing :map or even cases like <a href="https://github.com/metosin/malli#qualified-keys-in-a-map" target="_blank">https://github.com/metosin/malli#qualified-keys-in-a-map</a>. I was thinking of writing a <a href="https://github.com/metosin/malli#parsing-values" target="_blank">https://github.com/metosin/malli#parsing-values</a> for helping me out with that, but maybe it already exists? Or is there an easier way?</z><z id="t1629107981" t="ikitommi Sounds great, looking forward to this! You can as m/children and m/properties from a Schema instance. The first one returns the parsed enty-tuples [key properties value] if that helps."><y>#</y><d>2021-08-16</d><h>09:59</h><r>ikitommi</r>Sounds great, looking forward to this! You can as <code>m/children</code> and <code>m/properties</code> from a Schema instance. The first one returns the parsed enty-tuples <code>[key properties value]</code> if that helps.</z><z id="t1629118397" t="Tiago Dall&apos;Oca m/children is exactly what I was looking for! Thanks :D"><y>#</y><d>2021-08-16</d><h>12:53</h><r>Tiago Dall'Oca</r><code>m/children</code> is exactly what I was looking for! Thanks :D</z><z id="t1629126238" t="richiardiandrea Will monitor this - we have TypeScript as frontend and indeed sharing the API specs would be super cool 🙂"><y>#</y><d>2021-08-16</d><h>15:03</h><r>richiardiandrea</r>Will monitor this - we have TypeScript as  frontend and indeed sharing the API specs would be super cool <b>🙂</b></z><z id="t1629134538" t="ikitommi Btw, the JSON Schema converter is a good example of generic transformer of malli-&gt;xyz, https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc"><y>#</y><d>2021-08-16</d><h>17:22</h><r>ikitommi</r>Btw, the JSON Schema converter is a good example of generic transformer of malli-&gt;xyz, <a href="https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc</a></z><z id="t1659652274" t="richiardiandrea [:attrs {:href &quot;/_/_/users/U4U6BDQTE&quot;}] how far did you get with this project? Do you need/would you accept any help? 😄"><y>#</y><d>2022-08-04</d><h>22:31</h><r>richiardiandrea</r><a>@U4U6BDQTE</a> how far did you get with this project? Do you need/would you accept any help? <b>😄</b></z><z id="t1659652308" t="Tiago Dall&apos;Oca hey there"><y>#</y><d>2022-08-04</d><h>22:31</h><r>Tiago Dall'Oca</r>hey there</z><z id="t1659652326" t="Tiago Dall&apos;Oca at the company I work for we started testing it in production actually"><y>#</y><d>2022-08-04</d><h>22:32</h><r>Tiago Dall'Oca</r>at the company I work for we started testing it in production actually</z><z id="t1659652341" t="Tiago Dall&apos;Oca the api is not stable"><y>#</y><d>2022-08-04</d><h>22:32</h><r>Tiago Dall'Oca</r>the api is not stable</z><z id="t1659652347" t="Tiago Dall&apos;Oca the code is not pretty"><y>#</y><d>2022-08-04</d><h>22:32</h><r>Tiago Dall'Oca</r>the code is not pretty</z><z id="t1659652352" t="Tiago Dall&apos;Oca but it works for us haha"><y>#</y><d>2022-08-04</d><h>22:32</h><r>Tiago Dall'Oca</r>but it works for us haha</z><z id="t1659652377" t="Tiago Dall&apos;Oca go check it out at flowyoumoney/malli-ts"><y>#</y><d>2022-08-04</d><h>22:32</h><r>Tiago Dall'Oca</r>go check it out at flowyoumoney/malli-ts</z><z id="t1659652416" t="Tiago Dall&apos;Oca we didn&apos;t setup a collaboration structure just yet, but I think help is welcome!"><y>#</y><d>2022-08-04</d><h>22:33</h><r>Tiago Dall'Oca</r>we didn&apos;t setup a collaboration structure just yet, but I think help is welcome!</z><z id="t1659652418" t="Tiago Dall&apos;Oca [:attrs {:href &quot;/_/_/users/U0P7M2VHR&quot;}]"><y>#</y><d>2022-08-04</d><h>22:33</h><r>Tiago Dall'Oca</r><a>@U0P7M2VHR</a></z><z id="t1659652463" t="Danny 🙌"><y>#</y><d>2022-08-04</d><h>22:34</h><r>Danny</r><b>🙌</b></z><z id="t1659652912" t="richiardiandrea nice that looks great! I think my company would greatly benefit from it and we&apos;ll try to give back 😄"><y>#</y><d>2022-08-04</d><h>22:41</h><r>richiardiandrea</r>nice that looks great! I think my company would greatly benefit from it and we&apos;ll try to give back <b>😄</b></z><z id="t1659654523" t="Danny Any idea yet how/where you would use it? 🙃"><y>#</y><d>2022-08-04</d><h>23:08</h><r>Danny</r>Any idea yet how/where you would use it? <b>🙃</b></z><z id="t1629182283" t="ikitommi Analysis about Malli Schema creation performance: https://github.com/metosin/malli/issues/513"><y>#</y><d>2021-08-17</d><h>06:38</h><w>ikitommi</w>Analysis about Malli Schema creation performance: <a href="https://github.com/metosin/malli/issues/513" target="_blank">https://github.com/metosin/malli/issues/513</a></z><z id="t1629188673" t="Ben Sless woohoo, more performance"><y>#</y><d>2021-08-17</d><h>08:24</h><r>Ben Sless</r>woohoo, more performance</z><z id="t1629189289" t="Ben Sless can you uplooad the raw svgs?"><y>#</y><d>2021-08-17</d><h>08:34</h><r>Ben Sless</r>can you uplooad the raw svgs?</z><z id="t1629189397" t="ikitommi cleared them up already, sorry."><y>#</y><d>2021-08-17</d><h>08:36</h><r>ikitommi</r>cleared them up already, sorry.</z><z id="t1629190112" t="Ben Sless no biggy, I can repro"><y>#</y><d>2021-08-17</d><h>08:48</h><r>Ben Sless</r>no biggy, I can repro</z><z id="t1629190327" t="Ben Sless Btw, regarding the memoization idea I floated #?(:clj (defn memoize! [] (doseq [v [#&apos;-validator #&apos;-explainer #&apos;-parser #&apos;-unparser #&apos;-transformer #&apos;-walk #&apos;-into-schema #&apos;-safe-pred]] (alter-var-root v memoize)))) #?(:clj (defonce _memoized (memoize!))) Is this sufficient?"><y>#</y><d>2021-08-17</d><h>08:52</h><r>Ben Sless</r>Btw, regarding the memoization idea I floated
<pre>#?(:clj
   (defn memoize!
     []
     (doseq [v
             [#&apos;-validator
              #&apos;-explainer
              #&apos;-parser
              #&apos;-unparser
              #&apos;-transformer
              #&apos;-walk
              #&apos;-into-schema
              #&apos;-safe-pred]]
       (alter-var-root v memoize))))

#?(:clj (defonce _memoized (memoize!)))</pre>
Is this sufficient?</z><z id="t1629209661" t="ikitommi unbounded cache? as Schemas don’t have custom equality defined, all instances are different. That would leak memory, a lot. But, interesting idea. Could use that in malli.dev to swap top-level functions into version that pretty print exceptions."><y>#</y><d>2021-08-17</d><h>14:14</h><r>ikitommi</r>unbounded cache? as Schemas don’t have custom equality defined, all instances are different. That would leak memory, a lot. But, interesting idea. Could use that in <code>malli.dev</code> to swap top-level functions into version that pretty print exceptions.</z><z id="t1629209764" t="ikitommi Safe thing might be to put the cache into options, so the user can control it. For schema instances, could be bolted into a registry?"><y>#</y><d>2021-08-17</d><h>14:16</h><r>ikitommi</r>Safe thing might be to put the cache into options, so the user can control it. For schema instances, could be bolted into a registry?</z><z id="t1629209935" t="ikitommi e.g. a registry that returns cached Schemas instead of IntoSchemas in cases it would benefit from caching, e.g. all immutable schmas like leaves without properties and children: :int could be cached, [:int {:title &quot;wadawoksei, kuvavideo&quot;}] is a bad candidate."><y>#</y><d>2021-08-17</d><h>14:18</h><r>ikitommi</r>e.g. a registry that returns cached Schemas instead of IntoSchemas in cases it would benefit from caching, e.g. all immutable schmas like leaves without properties and children: <code>:int</code> could be cached, <code>[:int {:title &quot;wadawoksei, kuvavideo&quot;}]</code> is a bad candidate.</z><z id="t1629214206" t="Ben Sless What is the largest number of schemas you&apos;ve seen defined? I wonder if an unbounded cache will be good enough in most cases"><y>#</y><d>2021-08-17</d><h>15:30</h><r>Ben Sless</r>What is the largest number of schemas you&apos;ve seen defined?
I wonder if an unbounded cache will be good enough in most cases</z><z id="t1629223090" t="ikitommi infinite. sending [:re #&quot;.*&quot;] over the wire will always result in a new schema. Regexs don’t implement equality. (= #&quot;.*&quot; #&quot;.*&quot;) ; =&gt; false"><y>#</y><d>2021-08-17</d><h>17:58</h><r>ikitommi</r>infinite. sending <code>[:re #&quot;.*&quot;]</code> over the wire will always result in a new schema. Regexs don’t implement equality.
<pre>(= #&quot;.*&quot; #&quot;.*&quot;) ; =&gt; false</pre></z><z id="t1629223502" t="Ben Sless Would it be worth implementing equality semantics for schemas?"><y>#</y><d>2021-08-17</d><h>18:05</h><r>Ben Sless</r>Would it be worth implementing equality semantics for schemas?</z><z id="t1629223563" t="ikitommi maybe, there is malli.util/equals already, but it doesn’t take into account the possible different local registry bindings."><y>#</y><d>2021-08-17</d><h>18:06</h><r>ikitommi</r>maybe, there is <code>malli.util/equals</code> already, but it doesn’t take into account the possible different local registry bindings.</z><z id="t1629223603" t="ikitommi I recall there is an issue about pushing the local schema binding into “full”-form…"><y>#</y><d>2021-08-17</d><h>18:06</h><r>ikitommi</r>I recall there is an issue about pushing the local schema binding into “full”-form…</z><z id="t1629223670" t="ikitommi I think any option could effect how the schema works, so the equality might be heavy to calculate, might be wrong."><y>#</y><d>2021-08-17</d><h>18:07</h><r>ikitommi</r>I think any option could effect how the schema works, so the equality might be heavy to calculate, might be wrong.</z><z id="t1629223811" t="ikitommi btw, thanks again for you efforts on perf, really appreciate it 🙇"><y>#</y><d>2021-08-17</d><h>18:10</h><r>ikitommi</r>btw, thanks again for you efforts on perf, really appreciate it <b>🙇</b></z><z id="t1629223839" t="Ben Sless I&apos;m just having lots of fun with it"><y>#</y><d>2021-08-17</d><h>18:10</h><r>Ben Sless</r>I&apos;m just having lots of fun with it</z><z id="t1629223859" t="Ben Sless And it&apos;s all your fault for giving the perf talk at ClojureTRE 2019"><y>#</y><d>2021-08-17</d><h>18:10</h><r>Ben Sless</r>And it&apos;s all your fault for giving the perf talk at ClojureTRE 2019</z><z id="t1629223862" t="Ben Sless 😄"><y>#</y><d>2021-08-17</d><h>18:11</h><r>Ben Sless</r><b>😄</b></z><z id="t1629302605" t="ikitommi"><y>#</y><d>2021-08-18</d><h>16:03</h><r>ikitommi</r></z><z id="t1629220673" t="Ben Sless Is it possible to use regex schema to say something like &quot;I don&apos;t know what these two consecutive elements are but they should be identical&quot;?, i.e. [1 1 1] would be valid but [1 2 1] would not?"><y>#</y><d>2021-08-17</d><h>17:17</h><w>Ben Sless</w>Is it possible to use regex schema to say something like &quot;I don&apos;t know what these two consecutive elements are but they should be identical&quot;?, i.e. <code>[1 1 1]</code> would be valid but <code>[1 2 1]</code> would not?</z><z id="t1629244766" t="lsenjov So all elements should be identical?"><y>#</y><d>2021-08-17</d><h>23:59</h><w>lsenjov</w>So all elements should be identical?</z><z id="t1629254829" t="lsenjov Or just certain positional elements?"><y>#</y><d>2021-08-18</d><h>02:47</h><w>lsenjov</w>Or just certain positional elements?</z><z id="t1629262229" t="Ben Sless I gave a really bad example, sorry Better example, for N=2 and T=int: [1 1 7 7 8 8 2 2 3 3]"><y>#</y><d>2021-08-18</d><h>04:50</h><w>Ben Sless</w>I gave a really bad example, sorry
Better example, for N=2 and T=int:
<code>[1 1 7 7 8 8 2 2 3 3]</code></z><z id="t1629262346" t="ikitommi don&apos;t think so, :and would be the way to do this, but it currently pushes you out of the sequence."><y>#</y><d>2021-08-18</d><h>04:52</h><w>ikitommi</w>don&apos;t think so, <code>:and</code> would be the way to do this, but it currently pushes you out of the sequence.</z><z id="t1629262579" t="ikitommi also noticed that function schemas expect a :cat , which is bad as one can&apos;t wrap it like [:and [:catn [:min :int] [:max :int]] [:fn (fn [min max] (&lt; min max))]]"><y>#</y><d>2021-08-18</d><h>04:56</h><w>ikitommi</w>also noticed that function schemas expect a <code>:cat</code>, which is bad as one can&apos;t wrap it like <code>[:and [:catn [:min :int] [:max :int]] [:fn (fn [min max] (&lt; min max))]]</code></z><z id="t1629265416" t="Ben Sless Could it be done with textual regular expressions using capture groups?"><y>#</y><d>2021-08-18</d><h>05:43</h><w>Ben Sless</w>Could it be done with textual regular expressions using capture groups?</z><z id="t1629267203" t="Ben Sless Something like (P)\1"><y>#</y><d>2021-08-18</d><h>06:13</h><w>Ben Sless</w>Something like <code>(P)\1</code></z><z id="t1629352266" t="ikitommi an inline/hidden :and would be my first guess, something like: [:* [:and [:repeat {:min 2, :max 2} :int] [:fn (fn [[x y]] (= x y))]]]"><y>#</y><d>2021-08-19</d><h>05:51</h><w>ikitommi</w>an inline/hidden <code>:and</code> would be my first guess, something like:
<pre>[:* [:and [:repeat {:min 2, :max 2} :int] [:fn (fn [[x y]] (= x y))]]]</pre></z><z id="t1629352357" t="ikitommi :and is already weird, as the first thing is used in utilities. I guess this is the reason why Schema named it constrained . One Schema + constraints. Not “all the schmas”"><y>#</y><d>2021-08-19</d><h>05:52</h><w>ikitommi</w><code>:and</code> is already weird, as the first thing is used in utilities. I guess this is the reason why Schema named it <code>constrained</code>.  One Schema + constraints. Not “all the schmas”</z><z id="t1629378532" t="Ben Sless was hoping to avoid fn"><y>#</y><d>2021-08-19</d><h>13:08</h><w>Ben Sless</w>was hoping to avoid <code>fn</code></z><z id="t1629378939" t="ikitommi I think it’s the same thing as key-relations for maps, but… sequence relations instead."><y>#</y><d>2021-08-19</d><h>13:15</h><w>ikitommi</w>I think it’s the same thing as key-relations for maps, but… sequence relations instead.</z><z id="t1629379042" t="ikitommi malli + meander here could look like: [:* [:and [:repeat {:min 2, :max 2} :int] [:relations &apos;[?min ?max] &apos;[:= ?min ?max]]"><y>#</y><d>2021-08-19</d><h>13:17</h><w>ikitommi</w>malli + meander here could look like:
<pre>[:* 
 [:and 
  [:repeat {:min 2, :max 2} :int] 
  [:relations 
   &apos;[?min ?max] 
   &apos;[:= ?min ?max]]</pre></z><z id="t1629379159" t="ikitommi and maps: [:and [:map [:min :int] [:max :int]] [:relations &apos;{:min ?min, :max ?max} &apos;[:&gt; ?min ?max]]]"><y>#</y><d>2021-08-19</d><h>13:19</h><w>ikitommi</w>and maps:
<pre>[:and
 [:map
  [:min :int]
  [:max :int]]
 [:relations 
  &apos;{:min ?min, :max ?max} 
  &apos;[:&gt; ?min ?max]]]</pre></z><z id="t1629380055" t="Ben Sless with catn it&apos;s exactly the same"><y>#</y><d>2021-08-19</d><h>13:34</h><w>Ben Sless</w>with <code>catn</code> it&apos;s exactly the same</z><z id="t1629386995" t="kenny Malli often prefixes function names with - . Often this implies a private or internal function, yet lots of - functions are used and encouraged. What is the meaning behind the - prefix in the Malli codebase?"><y>#</y><d>2021-08-19</d><h>15:29</h><w>kenny</w>Malli often prefixes function names with <code>-</code>. Often this implies a private or internal function, yet lots of <code>-</code> functions are used and encouraged. What is the meaning behind the <code>-</code> prefix in the Malli codebase?</z><z id="t1629387038" t="emccue &quot;read the docs&quot;/&quot;experts only&quot;"><y>#</y><d>2021-08-19</d><h>15:30</h><r>emccue</r>&quot;read the docs&quot;/&quot;experts only&quot;</z><z id="t1629387285" t="kenny I&apos;ve read the docs several times and missed that section each time 🙂 Thanks. fwiw, those functions do not seem like &quot;experts only.&quot; They have been critical to our use of Malli."><y>#</y><d>2021-08-19</d><h>15:34</h><r>kenny</r>I&apos;ve read the docs several times and missed that section each time <b>🙂</b> Thanks. fwiw, those functions do not seem like &quot;experts only.&quot; They have been critical to our use of Malli.</z><z id="t1629488617" t="dominicm Is there anything higher level than m/type for determining, e.g. sequences? I&apos;d like to lump :* ,`:+`, :tuple , etc. together for my purposes when doing programmatic work on schemas. Same idea for pos-int? int? , etc."><y>#</y><d>2021-08-20</d><h>19:43</h><w>dominicm</w>Is there anything higher level than m/type for determining, e.g. sequences? I&apos;d like to lump <code>:*</code> ,`:+`, <code>:tuple</code>, etc. together for my purposes when doing programmatic work on schemas.  Same idea for <code>pos-int?</code> <code>int?</code>, etc.</z><z id="t1629489520" t="ikitommi [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] currently no, ideas welcome. There is an issue about derived types. int? is actually just a :`int`, silly to have to declare humanized error messages, generators, JSON schema mappings, transformers for both."><y>#</y><d>2021-08-20</d><h>19:58</h><w>ikitommi</w><a>@dominicm</a> currently no, ideas welcome. There is an issue about derived types. <code>int?</code> is actually just a :`int`, silly to have to declare humanized error messages, generators, JSON schema mappings, transformers for both.</z><z id="t1629489527" t="ikitommi https://github.com/metosin/malli/issues/264"><y>#</y><d>2021-08-20</d><h>19:58</h><r>ikitommi</r><a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a></z><z id="t1629489750" t="dominicm [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] For sure. My use-case is along those lines. I&apos;m trying to determine if a schema is, e.g. valid JSON (without transforms). Pairs nicely with Muuntaja 😉"><y>#</y><d>2021-08-20</d><h>20:02</h><w>dominicm</w><a>@ikitommi</a> For sure.  My use-case is along those lines.  I&apos;m trying to determine if a schema is, e.g. valid JSON (without transforms).  Pairs nicely with Muuntaja <b>😉</b></z><z id="t1629489810" t="dominicm I&apos;ll have a look at the source of those features for my solution"><y>#</y><d>2021-08-20</d><h>20:03</h><w>dominicm</w>I&apos;ll have a look at the source of those features for my solution</z><z id="t1629518502" t="ikitommi yes, transformers know that, quick hack would be to loop the registered keys of json-transformer or even ask if there is anything to do: (= identity (m/decoder schema (mt/json-transformer))"><y>#</y><d>2021-08-21</d><h>04:01</h><w>ikitommi</w>yes, transformers know that, quick hack would be to loop the registered keys of json-transformer or even ask if there is anything to do:

<pre>(= identity
   (m/decoder
    schema
    (mt/json-transformer))</pre></z><z id="t1629543002" t="Ben Sless Some perf finding: invoking map on arguments is the shortest path to .valAt without interop. Faster than get"><y>#</y><d>2021-08-21</d><h>10:50</h><w>Ben Sless</w>Some perf finding:
invoking map on arguments is the shortest path to <code>.valAt</code> without interop. Faster than <code>get</code></z><z id="t1629555877" t="dominicm [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] That doesn&apos;t quite work: (m/decoder [:map [{&quot;type&quot; &quot;foo&quot;} string?]] (malli.transform/json-transformer)) Which can&apos;t be encoded as valid JSON."><y>#</y><d>2021-08-21</d><h>14:24</h><w>dominicm</w><a>@ikitommi</a> That doesn&apos;t quite work:

<pre>(m/decoder
    [:map [{&quot;type&quot; &quot;foo&quot;} string?]]
    (malli.transform/json-transformer))</pre>
Which can&apos;t be encoded as valid JSON.</z><z id="t1629556010" t="dominicm heh, jsonista converts the key to a edn string in that case: &quot;{\&quot;{\\\&quot;type\\\&quot; \\\&quot;foo\\\&quot;}\&quot;:\&quot;bar\&quot;}&quot;"><y>#</y><d>2021-08-21</d><h>14:26</h><w>dominicm</w>heh, jsonista converts the key to a edn string in that case: <code>&quot;{\&quot;{\\\&quot;type\\\&quot; \\\&quot;foo\\\&quot;}\&quot;:\&quot;bar\&quot;}&quot;</code></z><z id="t1629557207" t="ikitommi [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] right, there is no decoders registered for keys in json-transformer , it&apos;s expected to come clean from actual JSON decoder. And same for encoding, malli doesn&apos;t have JSON encoders for all schemas, as in the actual encoder (jsonista, Cheshire etc) already does that."><y>#</y><d>2021-08-21</d><h>14:46</h><w>ikitommi</w><a>@dominicm</a> right, there is no decoders registered for keys in <code>json-transformer</code>, it&apos;s expected to come clean from actual JSON decoder. And same for encoding, malli doesn&apos;t have JSON encoders for all schemas, as in the actual encoder (jsonista, Cheshire etc) already does that.</z><z id="t1629563585" t="Ben Sless Opened a bunch of small PRs relating to https://github.com/metosin/malli/issues/513 . I broke them down as much as possible to find the best performance gains for each change and to cover enough use cases in the benchmarks. Didn&apos;t want to end up accidentally slowing down one while speeding up the other (which I did, initially)"><y>#</y><d>2021-08-21</d><h>16:33</h><w>Ben Sless</w>Opened a bunch of small PRs relating to <a href="https://github.com/metosin/malli/issues/513" target="_blank">https://github.com/metosin/malli/issues/513</a> . I broke them down as much as possible to find the best performance gains for each change and to cover enough use cases in the benchmarks. Didn&apos;t want to end up accidentally slowing down one while speeding up the other (which I did, initially)</z><z id="t1629632990" t="anonimitoraf Hi guys, I&apos;m looking to use malli for the following use cases... Context: • I&apos;m working on a system that takes in data from various 3rd party sources (think scraping). • The &quot;scraped&quot; data get transformed into an internal, universal data format that then get saved to DB Problems to be solved: • Validating that the 3rd party data are of some expected shape Obvious how malli gets utilized here • Mapping the 3rd party to the internal, universal data format Is this possible to be done via custom transformers on each property of the scraped data? I can give examples if needed"><y>#</y><d>2021-08-22</d><h>11:49</h><w>anonimitoraf</w>Hi guys, I&apos;m looking to use <code>malli</code> for the following use cases...

Context:
• I&apos;m working on a system that takes in data from various 3rd party sources (think scraping).
• The &quot;scraped&quot; data get transformed into an internal, universal data format that then get saved to DB
Problems to be solved:
• Validating that the 3rd party data are of some expected shape
Obvious how <code>malli</code> gets utilized here
• Mapping the 3rd party to the internal, universal data format
Is this possible to be done via custom transformers on each property of the scraped data?

I can give examples if needed</z><z id="t1629633186" t="Ben Sless Definitely possible"><y>#</y><d>2021-08-22</d><h>11:53</h><r>Ben Sless</r>Definitely possible</z><z id="t1629633229" t="anonimitoraf Awesome! I&apos;ll write up some dummy examples"><y>#</y><d>2021-08-22</d><h>11:53</h><r>anonimitoraf</r>Awesome! I&apos;ll write up some dummy examples</z><z id="t1629633234" t="Ben Sless probably more than one way for how you could do it, too"><y>#</y><d>2021-08-22</d><h>11:53</h><r>Ben Sless</r>probably more than one way for how you could do it, too</z><z id="t1629633499" t="anonimitoraf Actually, I&apos;m finding it a bit hard to quickly write up dummy examples. Do you mind linking docs on possible ways to do it [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] ?"><y>#</y><d>2021-08-22</d><h>11:58</h><r>anonimitoraf</r>Actually, I&apos;m finding it a bit hard to quickly write up dummy examples.
Do you mind linking docs on possible ways to do it <a>@UK0810AQ2</a>?</z><z id="t1629633705" t="anonimitoraf Actually here&apos;s an example: (def source-shape [:map [:events [:sequential [:map [:id int?] [:desc string?] [:details-id int?]]]] [:details [:sequential [:map [:id int?] [:content string?]]]]]) Sample data: {:events {:id 1 :desc &quot;Blah&quot; :details-id 11} :details [{:id 11 :content &quot;Blargh&quot;}]} mapped to [{:id 1 :description &quot;Blah&quot; :details &quot;Blargh&quot;}]"><y>#</y><d>2021-08-22</d><h>12:01</h><r>anonimitoraf</r>Actually here&apos;s an example:
<pre>(def source-shape
  [:map
   [:events [:sequential
             [:map
              [:id int?]
              [:desc string?]
              [:details-id int?]]]]
   [:details [:sequential
                [:map
                 [:id int?]
                 [:content string?]]]]])</pre>
Sample data:
<pre>{:events {:id 1
          :desc &quot;Blah&quot;
          :details-id 11}
 :details [{:id 11
            :content &quot;Blargh&quot;}]}</pre>
mapped to
<pre>[{:id 1
  :description &quot;Blah&quot;
  :details &quot;Blargh&quot;}]</pre></z><z id="t1629634116" t="Ben Sless Should events be a sequence of maps?"><y>#</y><d>2021-08-22</d><h>12:08</h><r>Ben Sless</r>Should events be a sequence of maps?</z><z id="t1629634523" t="anonimitoraf Ah whoops yes. I&apos;ll correct my example"><y>#</y><d>2021-08-22</d><h>12:15</h><r>anonimitoraf</r>Ah whoops yes. I&apos;ll correct my example</z><z id="t1629638105" t="Ben Sless Very roughly: (defn index-by [f xs] (reduce (fn [acc x] (assoc acc (f x) x)) {} xs)) (defn join [{:keys [events details]}] (let [details (index-by :id details)] (reduce (fn [acc {:keys [details-id] :as event}] (conj acc (-&gt; event (dissoc :details-id) (assoc :details (get (get details details-id) :content))))) [] events))) (def source-shape [:map {:decode/fun join} [:events [:sequential [:map [:id int?] [:desc string?] [:details-id int?]]]] [:details [:sequential [:map [:id int?] [:content string?]]]]]) (def data {:events [{:id 1 :desc &quot;Blah&quot; :details-id 11}] :details [{:id 11 :content &quot;Blargh&quot;}]}) (m/decode source-shape data (mt/transformer {:name :fun})) "><y>#</y><d>2021-08-22</d><h>13:15</h><r>Ben Sless</r>Very roughly:
<pre>(defn index-by
  [f xs]
  (reduce (fn [acc x] (assoc acc (f x) x)) {} xs))

(defn join
  [{:keys [events details]}]
  (let [details (index-by :id details)]
    (reduce
     (fn [acc {:keys [details-id] :as event}]
       (conj acc (-&gt; event
                     (dissoc :details-id)
                     (assoc :details (get (get details details-id) :content)))))
     []
     events)))

(def source-shape
  [:map
   {:decode/fun join}
   [:events [:sequential
             [:map
              [:id int?]
              [:desc string?]
              [:details-id int?]]]]
   [:details [:sequential
              [:map
               [:id int?]
               [:content string?]]]]])

(def data
  {:events [{:id 1
             :desc &quot;Blah&quot;
             :details-id 11}]
   :details [{:id 11
              :content &quot;Blargh&quot;}]})

(m/decode
 source-shape
 data
 (mt/transformer {:name :fun}))</pre>
</z><z id="t1629638128" t="Ben Sless but there should be a better day to do it"><y>#</y><d>2021-08-22</d><h>13:15</h><r>Ben Sless</r>but there should be a better day to do it</z><z id="t1629642557" t="pithyless IMO, things to be aware of: 1. decode is best-effort and will not throw errors if the validation does not pass 2. the transformation functions are expected to handle bad input without throwing errors 3. I think it&apos;s best to split the decode-validate-transform into several steps (each can have it&apos;s own validation)"><y>#</y><d>2021-08-22</d><h>14:29</h><r>pithyless</r>IMO, things to be aware of:
1. decode is best-effort and will not throw errors if the validation does not pass
2. the transformation functions are expected to handle bad input without throwing errors
3. I think it&apos;s best to split the decode-validate-transform into several steps (each can have it&apos;s own validation)</z><z id="t1629642602" t="pithyless This is how I&apos;d approach it: (def source-shape [:map [:events [:sequential [:map [:id int?] [:desc string?] [:details-id int?]]]] [:details [:sequential [:map [:id int?] [:content string?]]]]]) (def destination-shape [:sequential [:map [:id int?] [:description string?] [:details string?]]])"><y>#</y><d>2021-08-22</d><h>14:30</h><r>pithyless</r>This is how I&apos;d approach it:
<pre>(def source-shape
  [:map
   [:events [:sequential
             [:map
              [:id int?]
              [:desc string?]
              [:details-id int?]]]]
   [:details [:sequential
              [:map
               [:id int?]
               [:content string?]]]]])


(def destination-shape
  [:sequential
   [:map
    [:id int?]
    [:description string?]
    [:details string?]]])</pre></z><z id="t1629642627" t="pithyless (def sample-data {:events [{:id &quot;1&quot; :desc &quot;Blah&quot; :details-id &quot;11&quot;} {:id &quot;2&quot; :desc &quot;Blah 2&quot; :details-id &quot;12&quot;}] :details [{:id &quot;11&quot; :content &quot;Blargh&quot;} {:id &quot;12&quot; :content &quot;Blargh 2&quot;}]}) ;; Example broken input (def sample-data2 {:events [{:id nil :desc &quot;Blah&quot; :details-id 11}] :details [{:id &quot;11&quot; :content &quot;Blargh&quot;}]})"><y>#</y><d>2021-08-22</d><h>14:30</h><r>pithyless</r><pre>(def sample-data
  {:events  [{:id         &quot;1&quot;
              :desc       &quot;Blah&quot;
              :details-id &quot;11&quot;}
             {:id         &quot;2&quot;
              :desc       &quot;Blah 2&quot;
              :details-id &quot;12&quot;}]
   :details [{:id      &quot;11&quot;
              :content &quot;Blargh&quot;}
             {:id      &quot;12&quot;
              :content &quot;Blargh 2&quot;}]})

;; Example broken input
(def sample-data2
  {:events [{:id nil
             :desc &quot;Blah&quot;
             :details-id 11}]
   :details [{:id &quot;11&quot;
              :content &quot;Blargh&quot;}]})</pre></z><z id="t1629642651" t="pithyless (let [raw-data sample-data ;; First, normalize input (this is best-effort and does not throw errors). ;; This can take care of things like converting strings to integers, because ;; the serialization protocol could not represent integers, etc. decoded (m/decode source-shape raw-data mt/string-transformer) ;; Second, validate that the normalized input matches our expectations. ;; NOTE: you can use m/validate instead of m/parse if schema has branching logic, ;; but you don&apos;t want to take advantage of the extra information at this point. ;; NOTE 2: you could use a different, more strict schema at this point. parsed (m/parse source-shape decoded) _ (when (identical? parsed ::m/invalid) (throw (ex-info &quot;Invalid Input&quot; (m/explain source-shape decoded)))) ;; At this point we&apos;ve validated input and want to do transformation transformed (custom-transform-logic parsed) ;; And would be good idea to validate transformation worked... _ (when-not (m/validate destination-shape transformed) (throw (ex-info &quot;Invalid Transformation&quot; (m/explain destination-shape transformed))))] transformed)"><y>#</y><d>2021-08-22</d><h>14:30</h><r>pithyless</r><pre>(let [raw-data sample-data

        ;; First, normalize input (this is best-effort and does not throw errors).
        ;; This can take care of things like converting strings to integers, because
        ;; the serialization protocol could not represent integers, etc.
        decoded (m/decode source-shape raw-data mt/string-transformer)

        ;; Second, validate that the normalized input matches our expectations.
        ;; NOTE: you can use m/validate instead of m/parse if schema has branching logic,
        ;; but you don&apos;t want to take advantage of the extra information at this point.
        ;; NOTE 2: you could use a different, more strict schema at this point.
        parsed (m/parse source-shape decoded)
        _ (when (identical? parsed ::m/invalid)
            (throw (ex-info &quot;Invalid Input&quot; (m/explain source-shape decoded))))

        ;; At this point we&apos;ve validated input and want to do transformation
        transformed (custom-transform-logic parsed)

        ;; And would be good idea to validate transformation worked...
        _ (when-not (m/validate destination-shape transformed)
            (throw (ex-info &quot;Invalid Transformation&quot; (m/explain destination-shape transformed))))]
    transformed)</pre></z><z id="t1629642736" t="pithyless The custom-transform-logic could be the approach [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] mentioned; but if we&apos;re doing these kind of map/join transformations, it might be worth it to checkout meander (especially when the cases become more complicated to grok): (defn custom-transform-logic [data] (-&gt; data (meander/search {:events (meander/scan {:id ?event-id :desc ?description :details-id ?details-id}) :details (meander/scan {:id ?details-id :content ?details})} {:id ?event-id :description ?description :details ?details}) vec))"><y>#</y><d>2021-08-22</d><h>14:32</h><r>pithyless</r>The <code>custom-transform-logic</code> could be the approach <a>@UK0810AQ2</a> mentioned; but if we&apos;re doing these kind of map/join transformations, it might be worth it to checkout meander (especially when the cases become more complicated to grok):

<pre>(defn custom-transform-logic
  [data]
  (-&gt; data
      (meander/search
        {:events  (meander/scan
                   {:id         ?event-id
                    :desc       ?description
                    :details-id ?details-id})
         :details (meander/scan
                   {:id      ?details-id
                    :content ?details})}
        {:id          ?event-id
         :description ?description
         :details     ?details})
      vec))</pre></z><z id="t1629642776" t="pithyless ^ FYI [:attrs {:href &quot;/_/_/users/UR37CBF8D&quot;}] :)"><y>#</y><d>2021-08-22</d><h>14:32</h><r>pithyless</r>^ FYI <a>@UR37CBF8D</a> :)</z><z id="t1629642832" t="pithyless Also important to mention I used m/validate m/parse etc., but these should all be replaced with m/validator , m/parser etc. in production code"><y>#</y><d>2021-08-22</d><h>14:33</h><r>pithyless</r>Also important to mention I used <code>m/validate</code> <code>m/parse</code> etc., but these should all be replaced with <code>m/validator</code>, <code>m/parser</code> etc. in production code</z><z id="t1629643038" t="pithyless I apologize for pasting so much code into slack; here&apos;s a gist: https://gist.github.com/pithyless/0be222e1b1b3bca0239a9ca07d1b34c2"><y>#</y><d>2021-08-22</d><h>14:37</h><r>pithyless</r>I apologize for pasting so much code into slack; here&apos;s a gist: <a href="https://gist.github.com/pithyless/0be222e1b1b3bca0239a9ca07d1b34c2" target="_blank">https://gist.github.com/pithyless/0be222e1b1b3bca0239a9ca07d1b34c2</a></z><z id="t1629652672" t="schmee I second the recommendation for Meander, perfect use-case for it: https://github.com/noprompt/meander"><y>#</y><d>2021-08-22</d><h>17:17</h><r>schmee</r>I second the recommendation for Meander, perfect use-case for it: <a href="https://github.com/noprompt/meander" target="_blank">https://github.com/noprompt/meander</a></z><z id="t1629673910" t="anonimitoraf Thanks for the replies guys! I&apos;ll check them out after work 🙂"><y>#</y><d>2021-08-22</d><h>23:11</h><r>anonimitoraf</r>Thanks for the replies guys! I&apos;ll check them out after work <b>🙂</b></z><z id="t1629724806" t="ikitommi Yes, meander is the king in complex transformations and works nicely with malli. Great example [:attrs {:href &quot;/_/_/users/U05476190&quot;}] !"><y>#</y><d>2021-08-23</d><h>13:20</h><r>ikitommi</r>Yes, meander is the king in complex transformations and works nicely with malli. Great example <a>@U05476190</a>!</z><z id="t1629729541" t="pithyless Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I was hoping someone more experienced would confirm if the approach was reasonable."><y>#</y><d>2021-08-23</d><h>14:39</h><r>pithyless</r>Thanks <a>@U055NJ5CC</a>, I was hoping someone more experienced would confirm if the approach was reasonable.</z><z id="t1629809929" t="anonimitoraf Hey guys, again, thanks for these! I somewhat understand how they work. Follow up question: Is there a way to do it via metadata on the malli &apos;s schema fields and I somehow manipulate those metadata? I&apos;m thinking something like (def source-shape [:map [:events [:sequential [:map [:id int?] [:desc {:custom/map-to :description} ;; &lt;----- like this string?] [:details-id int?]]]] [:details [:sequential [:map [:id int?] [:content string?]]]]]) ?"><y>#</y><d>2021-08-24</d><h>12:58</h><r>anonimitoraf</r>Hey guys, again, thanks for these! I somewhat understand how they work.
Follow up question:
Is there a way to do it via metadata on the <code>malli</code>&apos;s schema fields and I somehow manipulate those metadata?

I&apos;m thinking something like
<pre>(def source-shape
  [:map
   [:events [:sequential
             [:map
              [:id int?]
              [:desc
               {:custom/map-to :description}  ;; &lt;----- like this
               string?]
              [:details-id int?]]]]
   [:details [:sequential
              [:map
               [:id int?]
               [:content string?]]]]])</pre>
?</z><z id="t1629655770" t="Ben Sless Wrote a mutable entries parser just to see if it was possible. Eliminated almost all the overhead related to parsing entries. It&apos;s a disgustingly ugly direct translation of the code, but it works and cut down about 1us / entry"><y>#</y><d>2021-08-22</d><h>18:09</h><w>Ben Sless</w>Wrote a mutable entries parser just to see if it was possible.
Eliminated almost all the overhead related to parsing entries.
It&apos;s a disgustingly ugly direct translation of the code, but it works and cut down about 1us / entry</z><z id="t1629657817" t="Ben Sless Behold, my horrible creation"><y>#</y><d>2021-08-22</d><h>18:43</h><r>Ben Sless</r>Behold, my horrible creation</z></g><g id="s18"><z id="t1629657819" t="Ben Sless https://gist.github.com/bsless/c21995e5702c2fa6d954312786da197b"><y>#</y><d>2021-08-22</d><h>18:43</h><r>Ben Sless</r><a href="https://gist.github.com/bsless/c21995e5702c2fa6d954312786da197b" target="_blank">https://gist.github.com/bsless/c21995e5702c2fa6d954312786da197b</a></z><z id="t1629661381" t="ikitommi :smiling_face_with_3_hearts:"><y>#</y><d>2021-08-22</d><h>19:43</h><r>ikitommi</r><b>:smiling_face_with_3_hearts:</b></z><z id="t1629661435" t="ikitommi my current project use case is on cljs-side btw."><y>#</y><d>2021-08-22</d><h>19:43</h><r>ikitommi</r>my current project use case is on cljs-side btw.</z><z id="t1629661634" t="Ben Sless 😄"><y>#</y><d>2021-08-22</d><h>19:47</h><r>Ben Sless</r><b>😄</b></z><z id="t1629661740" t="Ben Sless I&apos;m just surprised it works For cljs we can do what I started with which was propagating the bindings for every case, it should save some, too"><y>#</y><d>2021-08-22</d><h>19:49</h><r>Ben Sless</r>I&apos;m just surprised it works
For cljs we can do what I started with which was propagating the bindings for every case, it should save some, too</z><z id="t1629659828" t="respatialized is there a more idiomatic way of testing two schemas for equality than comparing them with malli.util/to-map-syntax ?"><y>#</y><d>2021-08-22</d><h>19:17</h><w>respatialized</w>is there a more idiomatic way of testing two schemas for equality than comparing them with <code>malli.util/to-map-syntax</code>?</z><z id="t1629659894" t="respatialized lol, just noticed malli.util/equals , please disregard"><y>#</y><d>2021-08-22</d><h>19:18</h><w>respatialized</w>lol, just noticed <code>malli.util/equals</code>, please disregard</z><z id="t1629660420" t="Ben Sless Caveat emptor (mu/equals (m/schema [:re #&quot;hi&quot;]) (m/schema [:re #&quot;hi&quot;])) false "><y>#</y><d>2021-08-22</d><h>19:27</h><r>Ben Sless</r>Caveat emptor
<pre>(mu/equals (m/schema [:re #&quot;hi&quot;]) (m/schema [:re #&quot;hi&quot;]))
false</pre>
</z><z id="t1629661302" t="ikitommi regexp schemas should be thrown away, could be just a property in :string schema"><y>#</y><d>2021-08-22</d><h>19:41</h><r>ikitommi</r>regexp schemas should be thrown away, could be just a property in <code>:string</code> schema</z><z id="t1629661337" t="ikitommi [:string {:pattern &quot;hi&quot;}]"><y>#</y><d>2021-08-22</d><h>19:42</h><r>ikitommi</r><code>[:string {:pattern &quot;hi&quot;}]</code></z><z id="t1629737953" t="pithyless I&apos;m seeing some weird behavior that may (or may not) be related to the intersection of using defprotocol m/=&gt; and malli.dev/start! where I&apos;m getting a StackOverflow exception when running an instrumented function. If I comment out the m/=&gt; everything works fine. Before I go down a rabbit hole of trying to come up with a minimal repro, does this sound familiar to someone?"><y>#</y><d>2021-08-23</d><h>16:59</h><w>pithyless</w>I&apos;m seeing some weird behavior that may (or may not) be related to the intersection of using <code>defprotocol</code>  <code>m/=&gt;</code> and <code>malli.dev/start!</code> where I&apos;m getting a StackOverflow exception when running an instrumented function. If I comment out the <code>m/=&gt;</code> everything works fine. Before I go down a rabbit hole of trying to come up with a minimal repro, does this sound familiar to someone?</z><z id="t1629754696" t="winsome [:attrs {:href &quot;/_/_/users/U4U6BDQTE&quot;}] , I see up above that you&apos;re exploring using malli to generate typescript definitions! I&apos;m just starting to look into that as well, are you open to sharing what you&apos;ve learned so far? I&apos;m happy to help"><y>#</y><d>2021-08-23</d><h>21:38</h><w>winsome</w><a>@mrdalloca</a>, I see up above that you&apos;re exploring using malli to generate typescript definitions! I&apos;m just starting to look into that as well, are you open to sharing what you&apos;ve learned so far? I&apos;m happy to help</z><z id="t1629754952" t="Tiago Dall&apos;Oca heyy"><y>#</y><d>2021-08-23</d><h>21:42</h><r>Tiago Dall'Oca</r>heyy</z><z id="t1629754974" t="Tiago Dall&apos;Oca sure! I&apos;ve progressed quite a bit actually"><y>#</y><d>2021-08-23</d><h>21:42</h><r>Tiago Dall'Oca</r>sure! I&apos;ve progressed quite a bit actually</z><z id="t1629754996" t="Tiago Dall&apos;Oca I&apos;m working with a draft of it by now"><y>#</y><d>2021-08-23</d><h>21:43</h><r>Tiago Dall'Oca</r>I&apos;m working with a draft of it by now</z><z id="t1629755007" t="Tiago Dall&apos;Oca so I&apos;m not happy with the code organization and naming in general"><y>#</y><d>2021-08-23</d><h>21:43</h><r>Tiago Dall'Oca</r>so I&apos;m not happy with the code organization and naming in general</z><z id="t1629755013" t="Tiago Dall&apos;Oca very early stages"><y>#</y><d>2021-08-23</d><h>21:43</h><r>Tiago Dall'Oca</r>very early stages</z><z id="t1629755015" t="Tiago Dall&apos;Oca BUT"><y>#</y><d>2021-08-23</d><h>21:43</h><r>Tiago Dall'Oca</r>BUT</z><z id="t1629755038" t="Tiago Dall&apos;Oca I&apos;m already generating type definitions"><y>#</y><d>2021-08-23</d><h>21:43</h><r>Tiago Dall'Oca</r>I&apos;m already generating type definitions</z><z id="t1629755069" t="winsome Fantastic! I&apos;ve got to hop off for other life things in a minute, but do you mind if I message you later? I&apos;d love to try the basics"><y>#</y><d>2021-08-23</d><h>21:44</h><r>winsome</r>Fantastic! I&apos;ve got to hop off for other life things in a minute, but do you mind if I message you later? I&apos;d love to try the basics</z><z id="t1629755470" t="Tiago Dall&apos;Oca"><y>#</y><d>2021-08-23</d><h>21:51</h><r>Tiago Dall'Oca</r></z><z id="t1629755587" t="Tiago Dall&apos;Oca I don&apos;t have time left for today, but we can go into details about this tomorrow :))"><y>#</y><d>2021-08-23</d><h>21:53</h><r>Tiago Dall'Oca</r>I don&apos;t have time left for today, but we can go into details about this tomorrow :))</z><z id="t1629755645" t="Tiago Dall&apos;Oca I wake up at 09:00 UTC"><y>#</y><d>2021-08-23</d><h>21:54</h><r>Tiago Dall'Oca</r>I wake up at 09:00 UTC</z><z id="t1629775912" t="datran I won&apos;t be about until 14:00 UTC, but I&apos;ll ping you then :thumbsup:"><y>#</y><d>2021-08-24</d><h>03:31</h><r>datran</r>I won&apos;t be about until 14:00 UTC, but I&apos;ll ping you then <b>:thumbsup:</b></z><z id="t1629759654" t="respatialized I&apos;m hitting a wall trying to write a schema walker that recursively transforms :altn to :alt , :catn to :cat , etc. The implementation is straightforward for simple schemas, but I encounter failures when I use :refs and try to transform the registry along with the values - the registry doesn&apos;t get passed down when the walker descends into the :ref schemas. I&apos;m not sure about the best way to proceed. Rebinding mr/*registry* with a dynamic registry that contains the top-level schema registry seems expedient, but I don&apos;t really understand the registry code that well yet which seems perilous."><y>#</y><d>2021-08-23</d><h>23:00</h><w>respatialized</w>I&apos;m hitting a wall trying to write a schema walker that recursively transforms <code>:altn</code> to <code>:alt</code>, <code>:catn</code> to <code>:cat</code>, etc. The implementation is straightforward for simple schemas, but I encounter failures when I use <code>:refs</code> and try to transform the registry along with the values - the registry doesn&apos;t get passed down when the walker descends into the <code>:ref</code> schemas.

I&apos;m not sure about the best way to proceed. Rebinding <code>mr/*registry*</code> with a dynamic registry that contains the top-level schema registry seems expedient, but I don&apos;t really understand the registry code that well yet which seems perilous.</z><z id="t1629759761" t="respatialized Here&apos;s what I&apos;ve got so far. It fails on the call to mu/to-map-syntax in the inner forms because of an invalid :ref error."><y>#</y><d>2021-08-23</d><h>23:02</h><w>respatialized</w>Here&apos;s what I&apos;ve got so far. It fails on the call to <code>mu/to-map-syntax</code> in the inner forms because of an invalid <code>:ref</code> error.</z><z id="t1629813817" t="Akiz Hi, do you know what is happening here? bq2pg.config&gt; (m/validator [:map [:export? boolean?] [:import? boolean?] [:gcs-name string?]]) #function[malli.core/-map-schema/reify/reify--9403/fn--9419] But using &gt; 3 elements fails… bq2pg.config&gt; (m/validator [:map [:export? boolean?] [:import? boolean?] [:gcs-name string?] [:extra string?]]) Execution error (NoClassDefFoundError) at malli.impl.util/f (util.cljc:54). malli/impl/util$f__7020__7021$fn__7045 "><y>#</y><d>2021-08-24</d><h>14:03</h><w>Akiz</w>Hi, do you know what is happening here?
<code>bq2pg.config&gt; (m/validator [:map [:export? boolean?] [:import? boolean?] [:gcs-name string?]])</code>
<pre>#function[malli.core/-map-schema/reify/reify--9403/fn--9419]</pre>
But using &gt; 3 elements fails…
<code>bq2pg.config&gt; (m/validator [:map [:export? boolean?] [:import? boolean?] [:gcs-name string?] [:extra string?]])</code>
<pre>Execution error (NoClassDefFoundError) at malli.impl.util/f (util.cljc:54).
malli/impl/util$f__7020__7021$fn__7045</pre>
</z><z id="t1629816324" t="Akiz [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] This happens only when I use malli.clj-kondo + (-&gt; (mc/collect *ns*) (mc/linter-config)) (mc/emit!) (md/start!) after some time… I can not reproduce it well enough 😞"><y>#</y><d>2021-08-24</d><h>14:45</h><w>Akiz</w><a>@zikajk</a> This happens only when I use
malli.clj-kondo +
<pre>(-&gt; (mc/collect *ns*) (mc/linter-config))
(mc/emit!)
(md/start!)</pre>
 after some time… I can not reproduce it well enough <b>😞</b></z><z id="t1629839229" t="niclasnilsson I’m trying out the instrumentation, and I’m probably doing something wrong, but I just can’t see it right now. The simple cases with primitives from the docs works, but when I try to validate a more “normal” schema, I can’t get it to work. This is an example: (def coord-schema [:map [:x :int] [:y :int]]) (defn down {:malli/schema [:=&gt; [:cat coord-schema] [coord-schema]]} [coord] (update coord :y dec)) When I then do (dev/start!) I get the error Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:119). :malli.core/invalid-schema {:schema [:map [:x :int] [:y :int]]} What am I missing?"><y>#</y><d>2021-08-24</d><h>21:07</h><w>niclasnilsson</w>I’m trying out the instrumentation, and I’m probably doing something wrong, but I just can’t see it right now. The simple cases with primitives from the docs works, but when I try to validate a more “normal” schema, I can’t get it to work. This is an example:

<pre>(def coord-schema
  [:map
   [:x :int]
   [:y :int]])


(defn down
  {:malli/schema [:=&gt; [:cat coord-schema] [coord-schema]]}
  [coord]
  (update coord :y dec))</pre>
When I then do <code>(dev/start!)</code> I get the error
<pre>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:119).
:malli.core/invalid-schema {:schema [:map [:x :int] [:y :int]]}</pre>
What am I missing?</z><z id="t1629842129" t="niclasnilsson Looks like I was missing [:schema …]. This works. (defn down &quot;Some docstring&quot; {:malli/schema [:=&gt; [:cat [:schema coord-schema]] [:schema coord-schema]]} [coord] (update coord :y dec)) "><y>#</y><d>2021-08-24</d><h>21:55</h><r>niclasnilsson</r>Looks like I was missing [:schema …]. This works.

<pre>(defn down
  &quot;Some docstring&quot;
  {:malli/schema [:=&gt; [:cat [:schema coord-schema]] [:schema coord-schema]]}
  [coord]
  (update coord :y dec))</pre>
</z><z id="t1629872366" t="Akiz Do you have to use schema when you do not use instrumentation?"><y>#</y><d>2021-08-25</d><h>06:19</h><r>Akiz</r>Do you have to use schema when you do not use instrumentation?</z><z id="t1629873514" t="ikitommi [:attrs {:href &quot;/_/_/users/U48DE3SHM&quot;}] it should be: (defn down {:malli/schema [:=&gt; [:cat coord-schema] coord-schema]} [coord] (update coord :y dec)) e.g. don’t wrap schema in empty vector, invalid malli syntax."><y>#</y><d>2021-08-25</d><h>06:38</h><r>ikitommi</r><a>@U48DE3SHM</a> it should be:
<pre>(defn down
  {:malli/schema [:=&gt; [:cat coord-schema] coord-schema]}
  [coord]
  (update coord :y dec))</pre>
e.g. don’t wrap schema in empty vector, invalid malli syntax.</z><z id="t1629888114" t="niclasnilsson Ah, so my initial problem was the vector on the output all along. I see. Thanks, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ."><y>#</y><d>2021-08-25</d><h>10:41</h><r>niclasnilsson</r>Ah, so my initial problem was the vector on the output all along. I see. Thanks, <a>@U055NJ5CC</a>.</z><z id="t1629888231" t="niclasnilsson [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] , I don’t know, but my goal was to use the devevelopment instrumentation, using (dev/start!)"><y>#</y><d>2021-08-25</d><h>10:43</h><r>niclasnilsson</r><a>@zikajk</a>, I don’t know, but my goal was to use the devevelopment instrumentation, using <code>(dev/start!)</code></z><z id="t1629889151" t="ikitommi the error message was really bad btw: ` malli.core/invalid-schema {:schema [:map [:x :int] [:y :int]]} could have been something like: malli.core/invalid-schema {:type [:map [:x :int] [:y :int]] :schema [[:map [:x :int] [:y :int]]]} "><y>#</y><d>2021-08-25</d><h>10:59</h><r>ikitommi</r>the error message was really bad btw: `
<pre>malli.core/invalid-schema {:schema [:map [:x :int] [:y :int]]}</pre>
could have been something like:
<pre>malli.core/invalid-schema {:type [:map [:x :int] [:y :int]]
                           :schema [[:map [:x :int] [:y :int]]]}</pre>
</z><z id="t1629892272" t="Akiz [:attrs {:href &quot;/_/_/users/U48DE3SHM&quot;}] I experienced two different errors during schema validation when using instrumentation. Restarting helped though…"><y>#</y><d>2021-08-25</d><h>11:51</h><r>Akiz</r><a>@U48DE3SHM</a> I experienced two different errors during schema validation when using instrumentation. Restarting helped though…</z><z id="t1629956972" t="niclasnilsson [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] , ah, thanks, I’ll keep that in mind going forward."><y>#</y><d>2021-08-26</d><h>05:49</h><r>niclasnilsson</r><a>@zikajk</a>, ah, thanks, I’ll keep that in mind going forward.</z><z id="t1629873614" t="ikitommi [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] looks weird. md/start! btw calls the clj-kondo too, so just md/start! and you are done"><y>#</y><d>2021-08-25</d><h>06:40</h><w>ikitommi</w><a>@zikajk</a> looks weird. <code>md/start!</code> btw calls the clj-kondo too, so just <code>md/start!</code> and you are done</z><z id="t1629873627" t="ikitommi if you can repro, I can take a look"><y>#</y><d>2021-08-25</d><h>06:40</h><r>ikitommi</r>if you can repro, I can take a look</z><z id="t1629877017" t="Akiz [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I will try, I experienced this after long running repl session so there could be a lot of reasons. After restarting - everything is working great."><y>#</y><d>2021-08-25</d><h>07:36</h><r>Akiz</r><a>@ikitommi</a> I will try, I experienced this after long running repl session so there could be a lot of reasons.
After restarting - everything is working great.</z><z id="t1629873720" t="ikitommi works here: (def valid? (m/validator [:map [:export? boolean?] [:import? boolean?] [:gcs-name string?] [:extra string?]])) (valid? {:export? true :import? true :gcs-name &quot;kikka&quot; :extra &quot;foo&quot;}) ; =&gt; true"><y>#</y><d>2021-08-25</d><h>06:42</h><w>ikitommi</w>works here:
<pre>(def valid?
  (m/validator
    [:map
     [:export? boolean?]
     [:import? boolean?]
     [:gcs-name string?]
     [:extra string?]]))

(valid? 
  {:export? true
   :import? true
   :gcs-name &quot;kikka&quot;
   :extra &quot;foo&quot;})
; =&gt; true</pre></z><z id="t1629874510" t="Karol Wójcik I&apos;m trying to use reitit-malli coercion with malli 0.6.1. When evaling [reitit.coercion.malli :as rss] I&apos;m getting ------ WARNING - :fn-arity ----------------------------------------------------- Resource: &lt;eval&gt;:2007:43 Wrong number of args (3) passed to malli.core/-fail! -------------------------------------------------------------------------------- Can someone reproduce?"><y>#</y><d>2021-08-25</d><h>06:55</h><w>Karol Wójcik</w>I&apos;m trying to use reitit-malli coercion with malli 0.6.1. When evaling
[reitit.coercion.malli :as rss] I&apos;m getting
<pre>------ WARNING - :fn-arity -----------------------------------------------------
 Resource: &lt;eval&gt;:2007:43
 Wrong number of args (3) passed to malli.core/-fail!
--------------------------------------------------------------------------------</pre>
Can someone reproduce?</z><z id="t1629875720" t="ikitommi [:attrs {:href &quot;/_/_/users/UJ1339K2B&quot;}] that’s a bug, the 3-arity was removed. please write an issue, need to fix reitit (or revert the change if it’s really needed)"><y>#</y><d>2021-08-25</d><h>07:15</h><w>ikitommi</w><a>@karol.wojcik</a> that’s a bug, the 3-arity was removed. please write an issue, need to fix reitit (or revert the change if it’s really needed)</z><z id="t1629876624" t="Karol Wójcik Done: https://github.com/metosin/reitit/issues/504"><y>#</y><d>2021-08-25</d><h>07:30</h><r>Karol Wójcik</r>Done: <a href="https://github.com/metosin/reitit/issues/504" target="_blank">https://github.com/metosin/reitit/issues/504</a></z><z id="t1629876445" t="Karol Wójcik Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] for blazing fast response. I will write an issue! No worries I can wait 🙂"><y>#</y><d>2021-08-25</d><h>07:27</h><w>Karol Wójcik</w>Thank you <a>@ikitommi</a> for blazing fast response. I will write an issue! No worries I can wait <b>🙂</b></z><z id="t1629879406" t="ikitommi Everyone: malli master has massive performance improvements related to Schema creation and transformation performance. If you are using malli especially with cljs, you might see order of magnitude improvements to startup-times. Please try and report both gains and bugs. Big thanks for [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] for much of the hard work. (def ?schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]]) ;; 44µs =&gt; 8.5µs (5x) (def schema (m/schema ?schema)) ;; 26µs =&gt; 1.3µs (20x) (m/walk schema (m/schema-walker identity)) ;; 51µs =&gt; 6.5µs (8x) (mu/closed-schema schema) … there is still a lot of room for improvements, but would like to release these soon. Issue tracking, alternative ways to build large schema systems described and comment welcome on https://github.com/metosin/malli/issues/513 ."><y>#</y><d>2021-08-25</d><h>08:16</h><w>ikitommi</w>Everyone: malli master has massive performance improvements related to Schema creation and transformation performance. If you are using malli especially with cljs, you might see order of magnitude improvements to startup-times. Please try and report both gains and bugs. Big thanks for <a>@ben.sless</a> for much of the hard work.
<pre>(def ?schema
  [:map
   [:x boolean?]
   [:y {:optional true} int?]
   [:z [:map
        [:x boolean?]
        [:y {:optional true} int?]]]])
        
;; 44µs =&gt; 8.5µs (5x)
(def schema (m/schema ?schema))

;; 26µs =&gt; 1.3µs (20x)
(m/walk schema (m/schema-walker identity))

;; 51µs =&gt; 6.5µs (8x)
(mu/closed-schema schema)</pre>
… there is still a lot of room for improvements, but would like to release these soon. Issue tracking, alternative ways to build large schema systems described and comment welcome on <a href="https://github.com/metosin/malli/issues/513" target="_blank">https://github.com/metosin/malli/issues/513</a>.</z><z id="t1629886857" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Here&apos;s a riddle I can&apos;t find a good answer to, how come this is significantly faster than a PersistentHashMap backed registry (defn fast-registry [m] (let [pred (comp keyword? key) im (doto (new IdentityHashMap 1000) (.putAll (into {} (filter pred) m))) -m (doto (new HashMap 1000 0.25) (.putAll (into {} (remove pred) m)))] (reify mr/Registry (-schema [_ k] (let [^Map m (if (instance? Keyword k) im (if (instance? Var k) im -m))] (.get ^Map m k))) (-schemas [_] m)))) By about 35 ns for keyword lookup compare (cc/quick-bench (m/schema :int {:registry r})) (cc/quick-bench (m/schema :int)) But the registry lookup isn&apos;t that much faster, only ~7 ns (cc/quick-bench (mr/-schema r :int)) (cc/quick-bench (mr/-schema m/default-registry :int)) "><y>#</y><d>2021-08-25</d><h>10:20</h><w>Ben Sless</w><a>@ikitommi</a> Here&apos;s a riddle I can&apos;t find a good answer to, how come this is significantly faster than a PersistentHashMap backed registry
<pre>(defn fast-registry
  [m]
  (let [pred (comp keyword? key)
        im (doto (new IdentityHashMap 1000) (.putAll (into {} (filter pred) m)))
        -m (doto (new HashMap 1000 0.25) (.putAll (into {} (remove pred) m)))]
    (reify mr/Registry
      (-schema [_ k]
        (let [^Map m (if (instance? Keyword k) im (if (instance? Var k) im -m))]
          (.get ^Map m k)))
      (-schemas [_] m))))</pre>
By about 35 ns for keyword lookup
compare
<pre>(cc/quick-bench (m/schema :int {:registry r}))
  (cc/quick-bench (m/schema :int))</pre>
But the registry lookup isn&apos;t that much faster, only ~7 ns
<pre>(cc/quick-bench (mr/-schema r :int))
  (cc/quick-bench (mr/-schema m/default-registry :int))</pre>
</z><z id="t1629888656" t="ikitommi 🤷 micro benchmarks are hard. I would ask JMH how they really differ. Just swapping order of the tests, you might get different results. Also, more code, JIT behaves differently."><y>#</y><d>2021-08-25</d><h>10:50</h><w>ikitommi</w><b>🤷</b>  micro benchmarks are hard. I would ask JMH how they really differ. Just swapping order of the tests, you might get different results. Also, more code, JIT behaves differently.</z><z id="t1629888677" t="ikitommi Super quick googling: https://www.oracle.com/technical-resources/articles/java/architect-benchmarking.html"><y>#</y><d>2021-08-25</d><h>10:51</h><r>ikitommi</r>Super quick googling: <a href="https://www.oracle.com/technical-resources/articles/java/architect-benchmarking.html" target="_blank">https://www.oracle.com/technical-resources/articles/java/architect-benchmarking.html</a></z><z id="t1629893562" t="Ben Sless Interesting, JMH gives opposite results"><y>#</y><d>2021-08-25</d><h>12:12</h><r>Ben Sless</r>Interesting, JMH gives opposite results</z><z id="t1629889387" t="lread The malli readme might be a good candidate for https://github.com/lread/test-doc-blocks . I could take a whirl at it if there is any interest."><y>#</y><d>2021-08-25</d><h>11:03</h><w>lread</w>The malli readme might be a good candidate for <a href="https://github.com/lread/test-doc-blocks" target="_blank">https://github.com/lread/test-doc-blocks</a>.  I could take a whirl at it if there is any interest.</z><z id="t1629924234" t="lread [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I won’t proceed unless you indicate an interest. Might be your cup of tea and might not! Happy to do the PR for you to evaluate then decide if you like - or not."><y>#</y><d>2021-08-25</d><h>20:43</h><r>lread</r><a>@ikitommi</a> I won’t proceed unless you indicate an interest.  Might be your cup of tea and might not!  Happy to do the PR for you to evaluate then decide if you like - or not.</z><z id="t1629892511" t="martinklepsch I’m getting an fn-arity warning when requiring malli.core in a cljs repl: ; eval (current-form): (require &apos;malli.core) ; (err) ------ WARNING - :fn-arity ----------------------------------------------------- ; (err) Resource: &lt;eval&gt;:2007:43 ; (err) Wrong number of args (3) passed to malli.core/-fail! ; (err) --------------------------------------------------------------------------------"><y>#</y><d>2021-08-25</d><h>11:55</h><w>martinklepsch</w>I’m getting an <code>fn-arity</code> warning when requiring <code>malli.core</code> in a cljs repl:

<pre>; eval (current-form): (require &apos;malli.core)
; (err) ------ WARNING - :fn-arity -----------------------------------------------------
; (err)  Resource: &lt;eval&gt;:2007:43
; (err)  Wrong number of args (3) passed to malli.core/-fail!
; (err) --------------------------------------------------------------------------------</pre></z><z id="t1629909748" t="Karol Wójcik Had the same issue. It&apos;s fixed in master"><y>#</y><d>2021-08-25</d><h>16:42</h><r>Karol Wójcik</r>Had the same issue. It&apos;s fixed in master</z><z id="t1629914179" t="martinklepsch thanks Karol!"><y>#</y><d>2021-08-25</d><h>17:56</h><r>martinklepsch</r>thanks Karol!</z><z id="t1629921816" t="Karol Wójcik You welcome Martin! 🙂"><y>#</y><d>2021-08-25</d><h>20:03</h><r>Karol Wójcik</r>You welcome Martin! <b>🙂</b></z><z id="t1629984878" t="martinklepsch [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] do you think it’s worth documenting this in the changelog for 0.7?"><y>#</y><d>2021-08-26</d><h>13:34</h><r>martinklepsch</r><a>@ikitommi</a> do you think it’s worth documenting this in the changelog for 0.7?</z><z id="t1629987205" t="ikitommi PR welcome [:attrs {:href &quot;/_/_/users/U050TNB9F&quot;}] , but there is a a already this line: &gt; * fixed arity error in `m/function-schema`"><y>#</y><d>2021-08-26</d><h>14:13</h><r>ikitommi</r>PR welcome <a>@U050TNB9F</a>, but there is a a already this line:
&gt; * fixed arity error in `m/function-schema`</z><z id="t1629987236" t="ikitommi does not pinpoint the problem very well :thinking_face:"><y>#</y><d>2021-08-26</d><h>14:13</h><r>ikitommi</r>does not pinpoint the problem very well <b>:thinking_face:</b></z><z id="t1629895062" t="Akiz Hi, I am getting Expected: regular expression, received: string. in clj-kondo lsp / Emacs combo with instrumentation for : (def gcs-uri &quot;&quot;) (gcs/get-blob-moddate gcs-uri) and these are my schemas: (m/=&gt; get-blob-moddate [:=&gt; [:cat Gcs-uri] [:or [:fn #(= (type %) org.joda.time.DateTime)] nil?]]) (def Gcs-uri [:re #&quot;gs:\/\/.*&quot;])"><y>#</y><d>2021-08-25</d><h>12:37</h><w>Akiz</w>Hi, I am getting
<code>Expected: regular expression, received: string.</code>
in clj-kondo lsp / Emacs combo with instrumentation
for :
<code>(def gcs-uri &quot;&quot;)</code>
<code>(gcs/get-blob-moddate gcs-uri)</code>

and these are my schemas:
<pre>(m/=&gt; get-blob-moddate [:=&gt;
                         [:cat Gcs-uri]
                         [:or
                          [:fn #(= (type %) org.joda.time.DateTime)]
                          nil?]])
(def Gcs-uri
  [:re #&quot;gs:\/\/.*&quot;])</pre></z><z id="t1629909778" t="Karol Wójcik Is it possible to instrument function via metadata in Clojurescript?"><y>#</y><d>2021-08-25</d><h>16:42</h><w>Karol Wójcik</w>Is it possible to instrument function via metadata in Clojurescript?</z><z id="t1629911384" t="ikitommi someone needs to port the tooling to support cljs. I suck at macro+interop, so not going to do that any time soon. help most welcome."><y>#</y><d>2021-08-25</d><h>17:09</h><r>ikitommi</r>someone needs to port the tooling to support cljs. I suck at macro+interop, so not going to do that any time soon.  help most welcome.</z><z id="t1629911424" t="Karol Wójcik I will take a look into it when I have some time 🙂"><y>#</y><d>2021-08-25</d><h>17:10</h><r>Karol Wójcik</r>I will take a look into it when I have some time <b>🙂</b></z><z id="t1629912174" t="lread Am having a great time experimenting with malli to validate cljdoc’s cljdoc.edn . The docs and demos are great in helping me to understand how things work. Thank you for all that effort. As a newb, I was wondering about the following: 1. The https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ConsCell%22%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%22ConsCell%22%5D%5D%5D%7D%7D%0A%20%22ConsCell%22%5D uses [:ref &quot;ConsCell&quot;] but the https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D uses [:schema [:ref &quot;hiccup&quot;]] . Are [:ref x] and [:schema [:ref x]] equivalent? 2. I was unfamiliar with :maybe and was not confident what it did. From the examples it seems that [:maybe x] validates for x or nil ? 3. I was unfamiliar with :tuple and now think I understand it just fine. But maybe a sentence contrasting it with :vector (if that makes sense) would be helpful to newcomers. 4. Very subjective, but I would put the motivation section before examples. As a newbie, this kind of info would be helpful to me up front. If updates to docs and demos for any the above would be helpful I am happy to make those wee changes. Also once I’ve finalized my cljdoc.edn validation I would be happy to add that as a, perhaps familiar, example to docs, demos or both."><y>#</y><d>2021-08-25</d><h>17:22</h><w>lread</w>Am having a great time experimenting with malli to validate cljdoc’s <code>cljdoc.edn</code> . The docs and demos are great in helping me to understand how things work. Thank  you for all that effort.  As a newb, I was wondering about the following:
1. The <a href="https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ConsCell%22%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%22ConsCell%22%5D%5D%5D%7D%7D%0A%20%22ConsCell%22%5D" target="_blank">https://malli.io/?value=%5B1%20%5B2%20%5B3%20%5B4%20nil%5D%5D%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22ConsCell%22%20%5B%3Amaybe%20%5B%3Atuple%20%3Aint%20%5B%3Aref%20%22ConsCell%22%5D%5D%5D%7D%7D%0A%20%22ConsCell%22%5D</a> uses <code>[:ref &quot;ConsCell&quot;]</code> but the <a href="https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D" target="_blank">https://malli.io/?value=%5B%3Adiv%20%7B%3Aclass%20%5B%3Afoo%20%3Abar%5D%7D%20%5B%3Ap%20%22Hello%2C%20world%20of%20data%22%5D%5D&amp;amp;schema=%5B%3Aschema%0A%20%7B%3Aregistry%20%7B%22hiccup%22%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anode%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Acatn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aname%20keyword%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprops%20%5B%3A%3F%20%5B%3Amap-of%20keyword%3F%20any%3F%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Achildren%20%5B%3A*%20%5B%3Aschema%20%5B%3Aref%20%22hiccup%22%5D%5D%5D%5D%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aprimitive%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aorn%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anil%20nil%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Aboolean%20boolean%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Anumber%20number%3F%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5B%3Atext%20string%3F%5D%5D%5D%5D%7D%7D%0A%20%22hiccup%22%5D</a> uses <code>[:schema [:ref &quot;hiccup&quot;]]</code>. Are <code>[:ref x]</code> and <code>[:schema [:ref x]]</code> equivalent?
2. I was unfamiliar with <code>:maybe</code> and was not confident what it did. From the examples it seems that <code>[:maybe x]</code> validates for <code>x</code> or <code>nil</code>?
3. I was unfamiliar with <code>:tuple</code>  and now think I understand it just fine. But maybe a sentence contrasting it with <code>:vector</code> (if that makes sense) would be helpful to newcomers.
4. Very subjective, but I would put the motivation section before examples.  As a newbie, this kind of info would be helpful to me up front.
If updates to docs and demos for any the above would be helpful I am happy to make those wee changes.
Also once I’ve finalized my cljdoc.edn validation I would be happy to add that as a, perhaps familiar, example to docs, demos or both.</z><z id="t1629913608" t="Ben Sless I think schema of ref cannot be derefed. This lets you write things like recursive sequence schemas"><y>#</y><d>2021-08-25</d><h>17:46</h><r>Ben Sless</r>I think schema of ref cannot be derefed. This lets you write things like recursive sequence schemas</z><z id="t1629914918" t="lread Thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] ! - Are you suggesting maybe the hiccup demo might be a bit off?"><y>#</y><d>2021-08-25</d><h>18:08</h><r>lread</r>Thanks <a>@ben.sless</a>! - Are you suggesting maybe the hiccup demo might be a bit off?</z><z id="t1629914997" t="Ben Sless Can&apos;t say without giving it a deeper look. I bumped by head against it separately trying to port the datalog BNF to malli"><y>#</y><d>2021-08-25</d><h>18:09</h><r>Ben Sless</r>Can&apos;t say without giving it a deeper look. I bumped by head against it separately trying to port the datalog BNF to malli</z><z id="t1629915045" t="Ben Sless Schema schemas create a &quot;hard&quot; boundary when schemas are compiled and you don&apos;t get deref-ed recursively ad inifinitum"><y>#</y><d>2021-08-25</d><h>18:10</h><r>Ben Sless</r>Schema schemas create a &quot;hard&quot; boundary when schemas are compiled and you don&apos;t get deref-ed recursively ad inifinitum</z><z id="t1629915059" t="Ben Sless your understanding of :maybe is correct"><y>#</y><d>2021-08-25</d><h>18:10</h><r>Ben Sless</r>your understanding of <code>:maybe</code> is correct</z><z id="t1629915098" t="Ben Sless with touple, just making sure, it is a heterogeneous fixed length product type"><y>#</y><d>2021-08-25</d><h>18:11</h><r>Ben Sless</r>with touple, just making sure, it is a heterogeneous fixed length product type</z><z id="t1629915132" t="lread is a tuple necessarily a vector?"><y>#</y><d>2021-08-25</d><h>18:12</h><r>lread</r>is a tuple necessarily a vector?</z><z id="t1629915172" t="Ben Sless It seems so"><y>#</y><d>2021-08-25</d><h>18:12</h><r>Ben Sless</r>It seems so</z><z id="t1629915196" t="lread Coolio, so I think I get it and could maybe add a sentence in the README."><y>#</y><d>2021-08-25</d><h>18:13</h><r>lread</r>Coolio, so I think I get it and could maybe add a sentence in the README.</z><z id="t1629915224" t="Ben Sless I&apos;m working on a getting started guide 🙃"><y>#</y><d>2021-08-25</d><h>18:13</h><r>Ben Sless</r>I&apos;m working on a getting started guide <b>🙃</b></z><z id="t1629915251" t="lread Oh cool! Maybe I don’t need to update README then."><y>#</y><d>2021-08-25</d><h>18:14</h><r>lread</r>Oh cool! Maybe I don’t need to update README then.</z><z id="t1629915275" t="Ben Sless It&apos;s a good idea to do so anyway, it&apos;s a small change you can do now, the guide will take some time"><y>#</y><d>2021-08-25</d><h>18:14</h><r>Ben Sless</r>It&apos;s a good idea to do so anyway, it&apos;s a small change you can do now, the guide will take some time</z><z id="t1629915290" t="lread Ping me if you want a reviewer. I’m a newb!"><y>#</y><d>2021-08-25</d><h>18:14</h><r>lread</r>Ping me if you want a reviewer. I’m a newb!</z><z id="t1629915327" t="Ben Sless I have a bunch of guinea pigs at work 😛"><y>#</y><d>2021-08-25</d><h>18:15</h><r>Ben Sless</r>I have a bunch of guinea pigs at work <b>😛</b></z><z id="t1629915363" t="Ben Sless But once it&apos;s sorta baked I&apos;ll go hunting for external perspectives"><y>#</y><d>2021-08-25</d><h>18:16</h><r>Ben Sless</r>But once it&apos;s sorta baked I&apos;ll go hunting for external perspectives</z><z id="t1629915373" t="Ben Sless so expect a ping in your future!"><y>#</y><d>2021-08-25</d><h>18:16</h><r>Ben Sless</r>so expect a ping in your future!</z><z id="t1629915415" t="Ben Sless Just, you know, don&apos;t deref it or anything"><y>#</y><d>2021-08-25</d><h>18:16</h><r>Ben Sless</r>Just, you know, don&apos;t <code>deref</code> it or anything</z><z id="t1629915570" t="lread When working on your datalog BNF were you able to generate and sample without sporadic StackOverflowError exceptions?"><y>#</y><d>2021-08-25</d><h>18:19</h><r>lread</r>When working on your datalog BNF were you able to <code>generate</code> and <code>sample</code> without sporadic StackOverflowError exceptions?</z><z id="t1629915611" t="Ben Sless Yes, let me check if it&apos;s public I&apos;ll send it"><y>#</y><d>2021-08-25</d><h>18:20</h><r>Ben Sless</r>Yes, let me check if it&apos;s public I&apos;ll send it</z><z id="t1629915770" t="lread tx"><y>#</y><d>2021-08-25</d><h>18:22</h><r>lread</r>tx</z><z id="t1629915827" t="Ben Sless here you go https://github.com/bsless/mallilog/blob/master/src/mallilog/impl/schema.clj"><y>#</y><d>2021-08-25</d><h>18:23</h><r>Ben Sless</r>here you go <a href="https://github.com/bsless/mallilog/blob/master/src/mallilog/impl/schema.clj" target="_blank">https://github.com/bsless/mallilog/blob/master/src/mallilog/impl/schema.clj</a></z><z id="t1629915890" t="Ben Sless Note the abundance of [:schema [:ref ,,,]]"><y>#</y><d>2021-08-25</d><h>18:24</h><r>Ben Sless</r>Note the abundance of <code>[:schema [:ref ,,,]]</code></z><z id="t1629916001" t="lread Yeah! So maybe that tells us something about my first question(?). You don’t seem to use :ref without it wrapped in :schema ."><y>#</y><d>2021-08-25</d><h>18:26</h><r>lread</r>Yeah! So maybe that tells us something about my first question(?).  You don’t seem to use <code>:ref</code> without it wrapped in <code>:schema</code>.</z><z id="t1629916111" t="Ben Sless That&apos;s because my schemas are mostly recursive but I probably don&apos;t need to do it everywhere"><y>#</y><d>2021-08-25</d><h>18:28</h><r>Ben Sless</r>That&apos;s because my schemas are mostly recursive but I probably don&apos;t need to do it everywhere</z><z id="t1629916160" t="Ben Sless I can try by process of elimination to knock it out and see what&apos;s up but it&apos;s pedantic and didn&apos;t really feel like fighting with it"><y>#</y><d>2021-08-25</d><h>18:29</h><r>Ben Sless</r>I can try by process of elimination to knock it out and see what&apos;s up but it&apos;s pedantic and didn&apos;t really feel like fighting with it</z><z id="t1629916194" t="Ben Sless besides, I consider it a bit of an anti-feature"><y>#</y><d>2021-08-25</d><h>18:29</h><r>Ben Sless</r>besides, I consider it a bit of an anti-feature</z><z id="t1629916986" t="lread the having to do something special for the recursive case?"><y>#</y><d>2021-08-25</d><h>18:43</h><r>lread</r>the having to do something special for the recursive case?</z><z id="t1629917002" t="Ben Sless Yeah, I&apos;d expect a ref to be enough"><y>#</y><d>2021-08-25</d><h>18:43</h><r>Ben Sless</r>Yeah, I&apos;d expect a <code>ref</code> to be enough</z><z id="t1630439225" t="lread Took a stab at https://github.com/metosin/malli/pull/537 ."><y>#</y><d>2021-08-31</d><h>19:47</h><r>lread</r>Took a stab at <a href="https://github.com/metosin/malli/pull/537" target="_blank">https://github.com/metosin/malli/pull/537</a>.</z><z id="t1629926572" t="lread Hiya mallians! I’m making some good progress with my cljdoc.edn malli schema. I am, though, getting some StackOverflowError exceptions when generating samples. This might be normal, I’m new, what do I know? simple_smile Rather than share and diagnose my cljdoc.edn schema, it might be more fruitful to work from the familiar. The Hiccup schema from the malli README seems to have-ish the pattern of recursion I want for cljdoc.edn. If I take the Hiccup schema unchanged from the README I do not seem to suffer StackOverflowError exceptions. (def Hiccup [:schema {:registry {&quot;hiccup&quot; [:orn [:node [:catn [:name keyword?] [:props [:? [:map-of keyword? any?]]] [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]] [:primitive [:orn [:nil nil?] [:boolean boolean?] [:number number?] [:text string?]]]]}} &quot;hiccup&quot;]) (mg/sample Hiccup) But if I yank out some stuff and make the schema look a little more like my cljdoc.edn schema usage, I can easily trigger StackOverflowError exceptions by re-evaluating (mg/sample Hiccup2) a handful of times: (def Hiccup2 [:schema {:registry {&quot;hiccup&quot; [:catn [:name keyword?] [:props [:? [:map-of keyword? any?]]] [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]}} &quot;hiccup&quot;]) (mg/sample Hiccup2) I am likely quite naive in my understanding here. I’m guessing if I somehow limited the maximum tree depth (which would be reasonable thing to do anyway for my use case) that would help but I am not sure how to express that. I am using malli 0.6.1."><y>#</y><d>2021-08-25</d><h>21:22</h><w>lread</w>Hiya mallians!  I’m making some good progress with my cljdoc.edn malli schema. I am, though, getting some StackOverflowError exceptions when generating samples.  This might be normal, I’m new, what do I know? <b>simple_smile</b>

Rather than share and diagnose my cljdoc.edn schema, it might be more fruitful to work from the familiar.
The Hiccup schema from the malli README seems to have-ish the pattern of recursion I want for cljdoc.edn.

If I take the Hiccup schema unchanged from the README I do not seem to suffer StackOverflowError exceptions.
<pre>(def Hiccup
  [:schema {:registry {&quot;hiccup&quot; [:orn
                                 [:node [:catn
                                         [:name keyword?]
                                         [:props [:? [:map-of keyword? any?]]]
                                         [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]]
                                 [:primitive [:orn
                                              [:nil nil?]
                                              [:boolean boolean?]
                                              [:number number?]
                                              [:text string?]]]]}}
   &quot;hiccup&quot;])

(mg/sample Hiccup)</pre>
But if I yank out some stuff and make the schema look a little more like my cljdoc.edn schema usage, I can easily trigger StackOverflowError exceptions by re-evaluating <code>(mg/sample Hiccup2)</code> a handful of times:
<pre>(def Hiccup2
  [:schema {:registry {&quot;hiccup&quot; [:catn
                                 [:name keyword?]
                                 [:props [:? [:map-of keyword? any?]]]
                                 [:children [:* [:schema [:ref &quot;hiccup&quot;]]]]]}}
   &quot;hiccup&quot;])

(mg/sample Hiccup2)</pre>
I am likely quite naive in my understanding here. I’m guessing if I somehow limited the maximum tree depth (which would be reasonable thing to do anyway for my use case) that would help but I am not sure how to express that.
I am using malli 0.6.1.</z><z id="t1629976510" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/UE21H2HHD&quot;}] Without saying i’m an authority here, it seems that your schema doesn’t have a stop condition? So endless recursion? Whereas the hiccup one has an alternative which stops the recursion. Makes sense?"><y>#</y><d>2021-08-26</d><h>11:15</h><r>jeroenvandijk</r><a>@UE21H2HHD</a> Without saying i’m an authority here, it seems that your schema doesn’t have a stop condition? So endless recursion? Whereas the hiccup one has an alternative which stops the recursion. Makes sense?</z><z id="t1629976558" t="jeroenvandijk The only stop condition you have is when there are 0 children for one node"><y>#</y><d>2021-08-26</d><h>11:15</h><r>jeroenvandijk</r>The only stop condition you have is when there are 0 children for one node</z><z id="t1629988973" t="lread Ah right… thanks [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] ! That makes perfect sense. For the generator, the :orn is probably a 50/50 coin toss for termination whereas hitting 0 children for termination is much less likely."><y>#</y><d>2021-08-26</d><h>14:42</h><r>lread</r>Ah right… thanks <a>@U0FT7SRLP</a>!  That makes perfect sense. For the generator, the <code>:orn</code> is probably a 50/50 coin toss for termination whereas hitting 0 children for termination is much less likely.</z><z id="t1629989186" t="jeroenvandijk Yeah and then there is the branching of the children 😅 1 child still ok, but 2 or more and there you go"><y>#</y><d>2021-08-26</d><h>14:46</h><r>jeroenvandijk</r>Yeah and then there is the branching of the children <b>😅</b> 1 child still ok, but 2 or more and there you go</z><z id="t1629989316" t="lread So constructing a schema for validation is one thing and then adapting it to to support sensible generation is another consideration."><y>#</y><d>2021-08-26</d><h>14:48</h><r>lread</r>So constructing a schema for validation is one thing and then adapting it to to support sensible generation is another consideration.</z><z id="t1629989377" t="lread Or maybe folks write custom generators?"><y>#</y><d>2021-08-26</d><h>14:49</h><r>lread</r>Or maybe folks write custom generators?</z><z id="t1629990031" t="lread Oh I see :gen/* stuff can influence generation, I’ll poke around more."><y>#</y><d>2021-08-26</d><h>15:00</h><r>lread</r>Oh I see <code>:gen/*</code> stuff can influence generation, I’ll poke around more.</z><z id="t1629993733" t="jeroenvandijk With clojure.spec https://clojure.org/guides/spec#_custom_generators , so I’m guessing this would make sense for Malli too. (I haven’t done it yet with Malli)"><y>#</y><d>2021-08-26</d><h>16:02</h><r>jeroenvandijk</r>With clojure.spec <a href="https://clojure.org/guides/spec#_custom_generators" target="_blank">https://clojure.org/guides/spec#_custom_generators</a>, so I’m guessing this would make sense for Malli too. (I haven’t done it yet with Malli)</z><z id="t1630065784" t="martinklepsch How would I express that a schema can only have key :a OR key :b but not both? "><y>#</y><d>2021-08-27</d><h>12:03</h><w>martinklepsch</w>How would I express that a schema can only have key <code>:a</code> OR key <code>:b</code> but not both? </z><z id="t1630069764" t="lread Would something like this work?: [:and [:map [:x {:optional true} int?] [:y {:optional true} int?]] [:fn {:error/message &quot;Only one of :x or :y allowed&quot;} (fn [{:keys [x y]}] (not (and x y)))]]"><y>#</y><d>2021-08-27</d><h>13:09</h><r>lread</r>Would something like this work?:
<pre>[:and
   [:map
    [:x {:optional true} int?]
    [:y {:optional true} int?]]
   [:fn {:error/message &quot;Only one of :x or :y allowed&quot;} (fn [{:keys [x y]}] (not (and x y)))]]</pre></z><z id="t1630070077" t="lread In https://malli.io/?value=%7B%3Ax%201%20%3Ay%202%7D&amp;amp;schema=%20%5B%3Aand%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Ax%20%7B%3Aoptional%20true%7D%20int%3F%5D%0A%20%20%20%20%5B%3Ay%20%7B%3Aoptional%20true%7D%20int%3F%5D%5D%0A%20%20%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22Only%20one%20of%20%3Ax%20or%20%3Ay%20allowed%22%7D%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(not%20(and%20x%20y)))%5D%5D"><y>#</y><d>2021-08-27</d><h>13:14</h><r>lread</r>In <a href="https://malli.io/?value=%7B%3Ax%201%20%3Ay%202%7D&amp;amp;schema=%20%5B%3Aand%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Ax%20%7B%3Aoptional%20true%7D%20int%3F%5D%0A%20%20%20%20%5B%3Ay%20%7B%3Aoptional%20true%7D%20int%3F%5D%5D%0A%20%20%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22Only%20one%20of%20%3Ax%20or%20%3Ay%20allowed%22%7D%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(not%20(and%20x%20y)))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%20%3Ay%202%7D&amp;amp;schema=%20%5B%3Aand%0A%20%20%20%5B%3Amap%0A%20%20%20%20%5B%3Ax%20%7B%3Aoptional%20true%7D%20int%3F%5D%0A%20%20%20%20%5B%3Ay%20%7B%3Aoptional%20true%7D%20int%3F%5D%5D%0A%20%20%20%5B%3Afn%20%7B%3Aerror%2Fmessage%20%22Only%20one%20of%20%3Ax%20or%20%3Ay%20allowed%22%7D%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(not%20(and%20x%20y)))%5D%5D</a></z><z id="t1630072775" t="ikitommi there are ideas around declarative way of doing that in the future, either using datascript or meander syntax."><y>#</y><d>2021-08-27</d><h>13:59</h><r>ikitommi</r>there are ideas around declarative way of doing that in the future, either using datascript or meander syntax.</z><z id="t1630071089" t="mike_ananev Hello! I&apos;m trying to use an example from malli docs. Why I got an error? (defn plus1 [x] (inc x)) (m/=&gt; plus1 [:=&gt; [:cat [:int {:max 5}]] [:int {:max 6}]]) ;; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:119). :malli.core/invalid-schema {:schema :=&gt;}"><y>#</y><d>2021-08-27</d><h>13:31</h><w>mike_ananev</w>Hello! I&apos;m trying to use an example from malli docs. Why I got an error?
<pre>(defn plus1 [x] (inc x))
(m/=&gt; plus1 [:=&gt; [:cat [:int {:max 5}]] [:int {:max 6}]])
;; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:119). :malli.core/invalid-schema {:schema :=&gt;}</pre></z><z id="t1630244892" t="mike_ananev hmm, I see a strange behaviour. If I run in terminal repl, everything woks fine. If I run via Idea+Cursive then I see this error. Btw, I deleted .cpcache completely."><y>#</y><d>2021-08-29</d><h>13:48</h><r>mike_ananev</r>hmm, I see a strange behaviour. If I run in terminal repl, everything woks fine. If I run via Idea+Cursive then I see this error. Btw, I deleted  .cpcache completely.</z><z id="t1630245045" t="mike_ananev In Emacs I see the same error"><y>#</y><d>2021-08-29</d><h>13:50</h><r>mike_ananev</r>In Emacs I see the same error</z><z id="t1630246843" t="mike_ananev [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;ve found the reason of that error. If I add ` :jvm-opts [&quot;-Dmalli.registry/type=custom&quot;] to deps.end alias, then I see this behaviour. Is it normal?"><y>#</y><d>2021-08-29</d><h>14:20</h><r>mike_ananev</r><a>@U055NJ5CC</a> I&apos;ve found the reason of that error.
If I add `
<pre>:jvm-opts    [&quot;-Dmalli.registry/type=custom&quot;]</pre>
to deps.end alias, then I see this behaviour. Is it normal?</z><z id="t1630253832" t="mike_ananev found solution for this: ` (mr/set-default-registry! (m/default-schemas)) "><y>#</y><d>2021-08-29</d><h>16:17</h><r>mike_ananev</r>found solution for this: `
<pre>(mr/set-default-registry! (m/default-schemas))</pre>
</z><z id="t1630256287" t="ikitommi good to hear you got it reaolved"><y>#</y><d>2021-08-29</d><h>16:58</h><r>ikitommi</r>good to hear you got it reaolved</z><z id="t1630071109" t="mike_ananev malli version 0.6.1"><y>#</y><d>2021-08-27</d><h>13:31</h><w>mike_ananev</w>malli version 0.6.1</z><z id="t1630073764" t="Brett Rowberry I think the answer to this question is probably going to be &quot;just use reitit &quot;. Anyway, compojure.api has support for coercion and validation via Schema and spec . Are there examples on how to use malli instead?"><y>#</y><d>2021-08-27</d><h>14:16</h><w>Brett Rowberry</w>I think the answer to this question is probably going to be &quot;just use <code>reitit</code>&quot;.
Anyway, <code>compojure.api</code> has support for coercion and validation via <code>Schema</code> and <code>spec</code>. Are there examples on how to use <code>malli</code> instead?</z><z id="t1630074150" t="Tiago Dall&apos;Oca MALLI-&amp;gt;TS - a sneak peek"><y>#</y><d>2021-08-27</d><h>14:22</h><w>Tiago Dall'Oca</w>MALLI-&amp;gt;TS - a sneak peek</z><z id="t1630132712" t="anonimitoraf Hi guys (kinda new to malli), when walking the schema, how would I walk the schema and transform the value of each node with custom logic? I&apos;ve looked at the src of the json-transformer, etc but they go over my head at the moment 😞 e.g. (def my-schema [:map [:a [string? {:custom/upper}]] [:b [int? {:custom/square}]]]) (def my-data {:a &quot;a&quot;, :b 2}) ;; Transform, key :a to be upper-cased and :b squared {:a &quot;a&quot;, :b 5} =&gt; {:a &quot;A&quot;, :b 25} "><y>#</y><d>2021-08-28</d><h>06:38</h><w>anonimitoraf</w>Hi guys (kinda new to malli), when walking the schema, how would I walk the schema and transform the value of each node with custom logic?
I&apos;ve looked at the src of the json-transformer, etc but they go over my head at the moment <b>😞</b>
e.g.
<pre>(def my-schema [:map 
                 [:a [string? {:custom/upper}]]
                 [:b [int? {:custom/square}]]])

(def my-data {:a &quot;a&quot;, :b 2})

;; Transform, key :a to be upper-cased and :b squared
{:a &quot;a&quot;, :b 5} =&gt; {:a &quot;A&quot;, :b 25} </pre></z><z id="t1630141184" t="pithyless But that&apos;s just my opinion; perhaps other #malli users will weigh-in with their own perspectives :)"><y>#</y><d>2021-08-28</d><h>08:59</h><r>pithyless</r>But that&apos;s just my opinion; perhaps other #malli users will weigh-in with their own perspectives :)</z><z id="t1630422796" t="oly nice I came to ask pretty much this, I have a malli spec which takes keywords and goes through the default json transformer and failes because its a string, looks like I can just add :decode/json {:leave keyword} to the spec and it should transform to the correct format"><y>#</y><d>2021-08-31</d><h>15:13</h><r>oly</r>nice I came to ask pretty much this, I have a malli spec which takes keywords and goes through the default json transformer and failes because its a string, looks like I can just add :decode/json {:leave keyword} to the spec and it should transform to the correct format</z><z id="t1630138565" t="pithyless Hmmm, the default interceptor transformers (which I admit I have not tried to customize) do not behave as I would have expected: (m/decode [int? {:decode/json {:leave &apos;inc}}] 5 (mt/json-transformer)) ;; =&gt; 6 (m/decode [int? {:decode/json {:leave &apos;inc}}] &quot;5&quot; (mt/json-transformer)) ;; (expected) error! int is a valid json value, so should not have been represented as string (m/decode [int? {:decode/string {:leave &apos;inc}}] 5 (mt/string-transformer)) ;; =&gt; 6 (m/decode [int? {:decode/string {:leave &apos;inc}}] &quot;5&quot; (mt/string-transformer)) ;; (unexpected) error! I would have expected the default string enter/leave interceptors to run by now, so we can `(inc 5) `"><y>#</y><d>2021-08-28</d><h>08:16</h><w>pithyless</w>Hmmm, the default interceptor transformers (which I admit I have not tried to customize) do not behave as I would have expected:
<pre>(m/decode [int? {:decode/json {:leave &apos;inc}}] 5 (mt/json-transformer))
  ;; =&gt; 6

  (m/decode [int? {:decode/json {:leave &apos;inc}}] &quot;5&quot; (mt/json-transformer))
  ;; (expected) error! int is a valid json value, so should not have been represented as string

  (m/decode [int? {:decode/string {:leave &apos;inc}}] 5 (mt/string-transformer))
  ;; =&gt; 6
  
  (m/decode [int? {:decode/string {:leave &apos;inc}}] &quot;5&quot; (mt/string-transformer))
  ;; (unexpected) error! I would have expected the default string enter/leave interceptors to run by now, so we can `(inc 5)</pre>`</z><z id="t1630141184" t="pithyless But that&apos;s just my opinion; perhaps other #malli users will weigh-in with their own perspectives :)"><y>#</y><d>2021-08-28</d><h>08:59</h><w>pithyless</w>But that&apos;s just my opinion; perhaps other #malli users will weigh-in with their own perspectives :)</z><z id="t1630312579" t="andre.richards Is there a way to pass custom registry to function schemas (metadata function schemas specifically)? I.e. when calling m/validate you can specify :registry key in options map, but not sure how to do this for functions. I tried to add :registry to options map passed to m.dev/start! but that seems to be ignored."><y>#</y><d>2021-08-30</d><h>08:36</h><w>andre.richards</w>Is there a way to pass custom registry to function schemas (metadata function schemas specifically)?

I.e. when calling <code>m/validate</code> you can specify <code>:registry</code> key in options map, but not sure how to do this for functions. I tried to add <code>:registry</code> to options map passed to <code>m.dev/start!</code> but that seems to be ignored.</z><z id="t1630507998" t="Célio Is there a way to customize the “missing required key” error message? For example, the code below returns the default missing key error message instead of something&apos;s wrong which makes sense because :error/message relates to the contents of :something , not to whether the key is present. It would be great if we could customize missing key errors. (me/humanize (m/explain [:map [:something [:string {:error/message &quot;something&apos;s wrong&quot;}]]] {}))"><y>#</y><d>2021-09-01</d><h>14:53</h><w>Célio</w>Is there a way to customize the “missing required key” error message? For example, the code below returns the default missing key error message instead of <code>something&apos;s wrong</code> which makes sense because <code>:error/message</code> relates to the contents of <code>:something</code>, not to whether the key is present.  It would be great if we could customize missing key errors.

<pre>(me/humanize (m/explain
              [:map
               [:something
                [:string {:error/message &quot;something&apos;s wrong&quot;}]]]
              {}))</pre></z><z id="t1630509383" t="dergutemoritz Have you tried putting it on the entry&apos;s props?"><y>#</y><d>2021-09-01</d><h>15:16</h><r>dergutemoritz</r>Have you tried putting it on the entry&apos;s props?</z><z id="t1630509409" t="dergutemoritz as in: [:something {:error/message &quot;something&apos;s wrong&quot;} :string]"><y>#</y><d>2021-09-01</d><h>15:16</h><r>dergutemoritz</r>as in:
<pre>[:something {:error/message &quot;something&apos;s wrong&quot;} :string]</pre></z><z id="t1630602112" t="Célio [:attrs {:href &quot;/_/_/users/U06GVE6NR&quot;}] Yes, the result is the same."><y>#</y><d>2021-09-02</d><h>17:01</h><r>Célio</r><a>@U06GVE6NR</a> Yes, the result is the same.</z><z id="t1630519587" t="kirked What&apos;s the best way to specify a schema for a map with both fixed keys and dynamic keys? Conceptually what I&apos;d like is something like this schema to specify that a step has a :run keyword and some dynamic keys, and a workflow has :name and :start keywords and some dynamic keys: (def step [:and [:map [:run :qualified-keyword]] [:map-of :keyword [:map [:next :keyword]]]]) (def workflow [:and [:map [:name :string] [:start :keyword]] [:map-of :keyword step]]) The data has this shape: {:name &quot;my-workflow&quot; :start :begin :begin {:run :app/init :ok {:next :do-work} :fail {:next :done}} :do-work {:run :app/process-queue :ok {:next :done}} :done {:run :app/cleanup}}} The problem I&apos;ve run into is that I need to #(apply dissoc % fixed-keys) before the :map-of schema is evaluated for any map matching this pattern. Maybe there&apos;s a better way?"><y>#</y><d>2021-09-01</d><h>18:06</h><w>kirked</w>What&apos;s the best way to specify a schema for a map with both fixed keys and dynamic keys? Conceptually what I&apos;d like is something like this schema to specify that a step has a <code>:run</code> keyword and some dynamic keys, and a workflow has <code>:name</code> and <code>:start</code> keywords and some dynamic keys:
<pre>(def step
  [:and [:map [:run :qualified-keyword]]
        [:map-of :keyword [:map [:next :keyword]]]])

(def workflow
  [:and [:map [:name :string]
              [:start :keyword]]
        [:map-of :keyword step]])</pre>
The data has this shape:
<pre>{:name &quot;my-workflow&quot;
 :start :begin

 :begin
 {:run :app/init
  :ok {:next :do-work}
  :fail {:next :done}}

 :do-work
 {:run :app/process-queue
  :ok {:next :done}}

 :done
 {:run :app/cleanup}}}</pre>
The problem I&apos;ve run into is that I need to <code>#(apply dissoc % fixed-keys)</code> before the <code>:map-of</code> schema is evaluated for any map matching this pattern.

Maybe there&apos;s a better way?</z><z id="t1631121654" t="ikitommi sorry, no, but there is an issue for that: https://github.com/metosin/malli/issues/43 [:attrs {:href &quot;/_/_/users/U09EGLJLB&quot;}]"><y>#</y><d>2021-09-08</d><h>17:20</h><r>ikitommi</r>sorry, no, but there is an issue for that: <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a> <a>@U09EGLJLB</a></z><z id="t1630581685" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Congrats on the CT funding!"><y>#</y><d>2021-09-02</d><h>11:21</h><w>borkdude</w><a>@ikitommi</a> Congrats on the CT funding!</z><z id="t1630588307" t="ikitommi thanks! and congrats on you [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] too on the full year! (the application on the page is the old one, those are all done, send email to update that)"><y>#</y><d>2021-09-02</d><h>13:11</h><w>ikitommi</w>thanks! and congrats on you <a>@borkdude</a> too on the full year! (the application on the page is the old one, those are all done, send email to update that)</z><z id="t1630904393" t="emccue remembering typescript has https://github.com/DefinitelyTyped/DefinitelyTyped and wondering if it would be sensible to do something similar for clj* libraries and malli"><y>#</y><d>2021-09-06</d><h>04:59</h><w>emccue</w>remembering typescript has <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank">https://github.com/DefinitelyTyped/DefinitelyTyped</a> and wondering if it would be sensible to do something similar for clj* libraries and malli</z><z id="t1630904453" t="emccue Motivating example for me most recently is datomic&apos;s api - it gives annoying and obtuse errors if you pass bad data and spec&apos;ing inputs at dev time would be helpful"><y>#</y><d>2021-09-06</d><h>05:00</h><w>emccue</w>Motivating example for me most recently is datomic&apos;s api - it gives annoying and obtuse errors if you pass bad data and spec&apos;ing inputs at dev time would be helpful</z><z id="t1630904465" t="emccue (alter-meta! #&apos;d/transact assoc :malli/schema [:=&gt; [:cat some? [:map [:tx-data some?]]] [:map [:db-before any?] [:db-after any?] [:tx-data any?] [:tempids any?]]])"><y>#</y><d>2021-09-06</d><h>05:01</h><w>emccue</w><pre>(alter-meta!
  #&apos;d/transact
  assoc
  :malli/schema
  [:=&gt;
   [:cat some? [:map [:tx-data some?]]]
   [:map
    [:db-before any?]
    [:db-after any?]
    [:tx-data  any?]
    [:tempids any?]]])</pre></z><z id="t1630904582" t="emccue idk what the best approach is - maybe artificially associate with a namespace at first instead of the metadata?"><y>#</y><d>2021-09-06</d><h>05:03</h><w>emccue</w>idk what the best approach is - maybe artificially associate with a namespace at first instead of the metadata?</z><z id="t1630904720" t="emccue (defn register-possibly-nonexistant-schema [var-path schema] (m/-register-function-schema! (symbol (namespace var-path)) (symbol (name var-path)) schema nil)) (register-possibly-nonexistant-schema &apos;datomic.client.api/transact [:=&gt; [:cat some? [:map [:tx-data some?]]] [:map [:db-before any?] [:db-after any?] [:tx-data any?] [:tempids any?]]])"><y>#</y><d>2021-09-06</d><h>05:05</h><w>emccue</w><pre>(defn register-possibly-nonexistant-schema
  [var-path schema]
  (m/-register-function-schema! (symbol (namespace var-path))
                                (symbol (name var-path))
                                schema
                                nil))

(register-possibly-nonexistant-schema
  &apos;datomic.client.api/transact
  [:=&gt;
   [:cat some? [:map [:tx-data some?]]]
   [:map
    [:db-before any?]
    [:db-after any?]
    [:tx-data  any?]
    [:tempids any?]]])</pre></z><z id="t1630904738" t="emccue or maybe just ignore it and let library authors do it themselves"><y>#</y><d>2021-09-06</d><h>05:05</h><w>emccue</w>or maybe just ignore it and let library authors do it themselves</z><z id="t1630904750" t="emccue and fight the inevitable war with whatever is finally christened spec 2"><y>#</y><d>2021-09-06</d><h>05:05</h><w>emccue</w>and fight the inevitable war with whatever is finally christened spec 2</z><z id="t1630905197" t="emccue or maybe the library has its own registry you can select from and merge into your own / the global registry"><y>#</y><d>2021-09-06</d><h>05:13</h><w>emccue</w>or maybe the library has its own registry you can select from and merge into your own / the global registry</z><z id="t1630905198" t="emccue idk"><y>#</y><d>2021-09-06</d><h>05:13</h><w>emccue</w>idk</z><z id="t1630905467" t="lsenjov Pick a top level namespaces that does all the (m/=&gt; ...) declarations, and they can include it themselves if they feel so inclined?"><y>#</y><d>2021-09-06</d><h>05:17</h><w>lsenjov</w>Pick a top level namespaces that does all the <code>(m/=&gt; ...)</code> declarations, and they can include it themselves if they feel so inclined?</z><z id="t1630948663" t="NoahTheDuke Clj-kondo has this for linting. Maybe malli could adopt a similar pattern? "><y>#</y><d>2021-09-06</d><h>17:17</h><w>NoahTheDuke</w>Clj-kondo has this for linting. Maybe malli could adopt a similar pattern? </z><z id="t1630949465" t="ikitommi that would be interesting. One of my goals with clojurists-together is to get a robust schema inferrer: for runtime for inferring from schemas from samples, but could be used to pull out schemas from tests (annotate functions in dev-mode to infer input &amp; output) schemas. Not a silver bullet, but would be “for free”. Manually writing functios schmas is always better, but also, a lot of work."><y>#</y><d>2021-09-06</d><h>17:31</h><w>ikitommi</w>that would be interesting. One of my goals with <b>clojurists-together</b> is to get a robust schema inferrer: for runtime for inferring from schemas from samples, but could be used to pull out schemas from tests (annotate functions in dev-mode to infer input &amp; output) schemas. Not a silver bullet, but would be “for free”. Manually writing functios schmas is always better, but also, a lot of work.</z><z id="t1631102565" t="aaron51 Is there a malli helper that converts a map to a := schema? Input is {:a 1 :b 2} Output is [:map [:a [:= 1]] [:b [:= 2]]] I’m trying to validate a subset of a map (and the input is the sub map)"><y>#</y><d>2021-09-08</d><h>12:02</h><w>aaron51</w>Is there a malli helper that converts a map to a <code>:=</code> schema?

Input is <code>{:a 1 :b 2}</code>
Output is <code>[:map [:a [:= 1]] [:b [:= 2]]]</code>

I’m trying to validate a subset of a map (and the input is the sub map)</z><z id="t1631102815" t="ikitommi [:attrs {:href &quot;/_/_/users/U3JH0P5LJ&quot;}] not yet. but plan is to build both a first-class inferrer and re-visit the type hierarchies so we could narrow down things. before that, you could hack the malli.provider , it’s quite small and relatively simple."><y>#</y><d>2021-09-08</d><h>12:06</h><w>ikitommi</w><a>@aaron51</a> not yet. but plan is to build both a first-class inferrer and re-visit the type hierarchies so we could narrow down things. before that, you could hack the <code>malli.provider</code>, it’s quite small and relatively simple.</z><z id="t1631103804" t="aaron51 Understood, thank you 👍"><y>#</y><d>2021-09-08</d><h>12:23</h><w>aaron51</w>Understood, thank you <b>👍</b></z><z id="t1631444850" t="Ben Sless This is somewhere between malli and #reitit, is there a way to know the schema with which validation passed in cases of or and multi ?"><y>#</y><d>2021-09-12</d><h>11:07</h><w>Ben Sless</w>This is somewhere between malli and #reitit, is there a way to know the schema with which validation passed in cases of <code>or</code> and <code>multi</code>?</z><z id="t1631458402" t="respatialized I asked this question a while back; there&apos;s not a good way to do this without orn . If you know all the validation paths at compile time they can be enumerated. But the use case I was thinking about, of sum types that are created at runtime, was still tricky to match on. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] suggested a simple function for converting the or to orn with numbers as the keys so that I could know which was matched. Not sure if anything has changed in the library since I asked about it, so this solution may be out of date."><y>#</y><d>2021-09-12</d><h>14:53</h><r>respatialized</r>I asked this question a while back; there&apos;s not a good way to do this without <code>orn</code>. If you know all the validation paths at compile time they can be enumerated. But the use case I was thinking about, of sum types that are created at runtime, was still tricky to match on. <a>@U055NJ5CC</a> suggested a simple function for converting the <code>or</code> to <code>orn</code> with numbers as the keys so that I could know which was matched.

Not sure if anything has changed in the library since I asked about it, so this solution may be out of date.</z><z id="t1631458658" t="Ben Sless Ended up going with orn and parse in the end I wonder how it interacts with decoding. Are conflicts possible?"><y>#</y><d>2021-09-12</d><h>14:57</h><r>Ben Sless</r>Ended up going with orn and parse in the end
I wonder how it interacts with decoding. Are conflicts possible?</z><z id="t1631470302" t="rutledgepaulv I&apos;ve used a custom decoder for this that attaches the schema to the value as metadata"><y>#</y><d>2021-09-12</d><h>18:11</h><r>rutledgepaulv</r>I&apos;ve used a custom decoder for this that attaches the schema to the value as metadata</z><z id="t1631823199" t="Yehonathan Sharvit Are there some tools out there that generate a data model diagram (in a format like DOT or PlantUML) from a JSON Schema?"><y>#</y><d>2021-09-16</d><h>20:13</h><w>Yehonathan Sharvit</w>Are there some tools out there that generate a data model diagram (in a format like DOT or PlantUML) from a JSON Schema?</z><z id="t1631880615" t="emccue malli can make uml from its own schema"><y>#</y><d>2021-09-17</d><h>12:10</h><r>emccue</r>malli can make uml from its own schema</z><z id="t1631997139" t="Yehonathan Sharvit I know. But my question is about JSON schema"><y>#</y><d>2021-09-18</d><h>20:32</h><r>Yehonathan Sharvit</r>I know. But my question is about JSON schema</z><z id="t1631997160" t="Yehonathan Sharvit Is there a way to transform a JSON schema into a Malli schema?"><y>#</y><d>2021-09-18</d><h>20:32</h><r>Yehonathan Sharvit</r>Is there a way to transform a JSON schema into a Malli schema?</z><z id="t1631998714" t="emccue Maybe an equivalent question is &quot;are all things representable in JSON schema representable in malli&quot;?"><y>#</y><d>2021-09-18</d><h>20:58</h><r>emccue</r>Maybe an equivalent question is &quot;are all things representable in JSON schema representable in malli&quot;?</z><z id="t1631998789" t="emccue Because i don&apos;t think anyone has done that transformation yet"><y>#</y><d>2021-09-18</d><h>20:59</h><r>emccue</r>Because i don&apos;t think anyone has done that transformation yet</z><z id="t1631999418" t="nivekuil could you infer a malli schema from the corresponding json object?"><y>#</y><d>2021-09-18</d><h>21:10</h><r>nivekuil</r>could you infer a malli schema from the corresponding json object?</z><z id="t1632068659" t="ikitommi I noticed you got already some answer on Twitter [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] , could you share those here too?"><y>#</y><d>2021-09-19</d><h>16:24</h><r>ikitommi</r>I noticed you got already some answer on Twitter <a>@U0L91U7A8</a>,  could you share those here too?</z><z id="t1632072572" t="Yehonathan Sharvit Unfortunately, none of the answers were satisfactory."><y>#</y><d>2021-09-19</d><h>17:29</h><r>Yehonathan Sharvit</r>Unfortunately, none of the answers were satisfactory.</z><z id="t1632072607" t="Yehonathan Sharvit The best I could do is to manually convert the JSON schema into Malli and use Malli to generate a plantuml diagram"><y>#</y><d>2021-09-19</d><h>17:30</h><r>Yehonathan Sharvit</r>The best I could do is to manually convert the JSON schema into Malli and use Malli to generate a plantuml diagram</z><z id="t1632072763" t="ikitommi Ok. The new map-syntax is quite close to JSON Schema, which should make the JSON Schema -&gt; Malli streightworward."><y>#</y><d>2021-09-19</d><h>17:32</h><r>ikitommi</r>Ok. The new map-syntax is quite close to JSON Schema, which should make the JSON Schema -&gt; Malli streightworward.</z><z id="t1632299371" t="Yehonathan Sharvit Indeed. [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] What was the motivation for adding the new map-syntax?"><y>#</y><d>2021-09-22</d><h>08:29</h><r>Yehonathan Sharvit</r>Indeed.
<a>@U055NJ5CC</a> What was the motivation for adding the new map-syntax?</z><z id="t1632306244" t="ikitommi 1. order of magnitude faster way to instantiate schemas (e.g. ast IS the parsed results, no need to parse hiccup) -&gt; matters on js &amp; mobile 2. the old map-syntax was too generic to be useful 3. creating schemas programmatically behind the scenes is easier with maps (e.g. when inferring schemas from data) 4. it’s good to have options 😎"><y>#</y><d>2021-09-22</d><h>10:24</h><r>ikitommi</r>1. order of magnitude faster way to instantiate schemas (e.g. ast IS the parsed results, no need to parse hiccup) -&gt; matters on js &amp; mobile
2. the old map-syntax was too generic to be useful
3. creating schemas programmatically behind the scenes is easier with maps (e.g. when inferring schemas from data)
4. it’s good to have options <b>😎</b></z><z id="t1632322865" t="Yehonathan Sharvit Makes sense. Thanks"><y>#</y><d>2021-09-22</d><h>15:01</h><r>Yehonathan Sharvit</r>Makes sense. Thanks</z><z id="t1631997160" t="Yehonathan Sharvit Is there a way to transform a JSON schema into a Malli schema?"><y>#</y><d>2021-09-18</d><h>20:32</h><w>Yehonathan Sharvit</w>Is there a way to transform a JSON schema into a Malli schema?</z><z id="t1632306244" t="ikitommi 1. order of magnitude faster way to instantiate schemas (e.g. ast IS the parsed results, no need to parse hiccup) -&gt; matters on js &amp; mobile 2. the old map-syntax was too generic to be useful 3. creating schemas programmatically behind the scenes is easier with maps (e.g. when inferring schemas from data) 4. it’s good to have options 😎"><y>#</y><d>2021-09-22</d><h>10:24</h><w>ikitommi</w>1. order of magnitude faster way to instantiate schemas (e.g. ast IS the parsed results, no need to parse hiccup) -&gt; matters on js &amp; mobile
2. the old map-syntax was too generic to be useful
3. creating schemas programmatically behind the scenes is easier with maps (e.g. when inferring schemas from data)
4. it’s good to have options <b>😎</b></z><z id="t1632061855" t="WonderLastking Hi there, i&apos;m using malli 0.6.1 to do some validation in a front-end (cljs)/back-end(clj) application. So I have a .cljc namespace where I do the validations. While this works right with clj, when I use it in cljs I see a warning message Wrong number of args (3) passed to malli.core/-fail!"><y>#</y><d>2021-09-19</d><h>14:30</h><w>WonderLastking</w>Hi there, i&apos;m using malli 0.6.1 to do some validation in a front-end (cljs)/back-end(clj) application.
So I have a .cljc namespace where I do the validations. While this works right with clj, when I use it in cljs I see a warning message
<pre>Wrong number of args (3) passed to malli.core/-fail!</pre></z><z id="t1632069265" t="ikitommi fixed in master"><y>#</y><d>2021-09-19</d><h>16:34</h><r>ikitommi</r>fixed in master</z><z id="t1632068933" t="ikitommi closed the performance Issue ( https://github.com/metosin/malli/issues/513 ) - schema creation &amp; transformation is now mostly an order of magnitude faster: (def schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]]) (def schema (m/schema ?schema)) ;; 44µs -&gt; 3.4µs (13x) (bench (m/schema ?schema)) ;; 4.2µs -&gt; 830ns (4.5x) (bench (mu/assoc schema :w :string)) ;; 134µs -&gt; 15µs (9x) (bench (mu/merge schema schema)) ;; 51µs -&gt; 3.9µs (13x) (bench (mu/closed-schema schema))"><y>#</y><d>2021-09-19</d><h>16:28</h><w>ikitommi</w>closed the performance Issue (<a href="https://github.com/metosin/malli/issues/513" target="_blank">https://github.com/metosin/malli/issues/513</a>) - schema creation &amp; transformation is now mostly an order of magnitude faster:
<pre>(def schema
  [:map
   [:x boolean?]
   [:y {:optional true} int?]
   [:z [:map
        [:x boolean?]
        [:y {:optional true} int?]]]])

(def schema (m/schema ?schema))

;; 44µs -&gt; 3.4µs (13x)
(bench (m/schema ?schema))

;; 4.2µs -&gt; 830ns (4.5x)
(bench (mu/assoc schema :w :string))

;; 134µs -&gt; 15µs (9x)
(bench (mu/merge schema schema))

;; 51µs -&gt; 3.9µs (13x)
(bench (mu/closed-schema schema))</pre></z><z id="t1632069096" t="ikitommi … and opened a new one, to add first-class support for the (compact) map-syntax: https://github.com/metosin/malli/issues/543 . This is really important in for building large schema systems a) via inferring or b) to be run on slow js-runtimes. Initial design (which is already 15x faster 🚀 ) (def ?schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]]) (m/form ?schema) ;[:map ; [:x boolean?] ; [:y {:optional true} int?] ; [:z [:map ; [:x boolean?] ; [:y {:optional true} int?]]]] (m/ast ?schema) ;{:type :map, ; :keys {:x {:order 0 ; :value {:type boolean?}}, ; :y {:order 1, :value {:type int?} ; :properties {:optional true}}, ; :z {:order 2, ; :value {:type :map, ; :keys {:x {:order 0 ; :value {:type boolean?}}, ; :y {:order 1 ; :value {:type int?} ; :properties {:optional true}}}}}}} (-&gt; ?schema (m/schema) ;; 3.7µs (m/ast) ;; 1.1µs (m/schema) ;; 250ns (15x) (m/form) (= (m/form ?schema))) ; =&gt; true"><y>#</y><d>2021-09-19</d><h>16:31</h><w>ikitommi</w>… and opened a new one, to add first-class support for the (compact) map-syntax: <a href="https://github.com/metosin/malli/issues/543" target="_blank">https://github.com/metosin/malli/issues/543</a>. This is really important in for building large schema systems a) via inferring or b) to be run on slow js-runtimes. Initial design (which is already 15x faster <b>🚀</b>)
<pre>(def ?schema
  [:map
   [:x boolean?]
   [:y {:optional true} int?]
   [:z [:map
        [:x boolean?]
        [:y {:optional true} int?]]]])

(m/form ?schema)
;[:map
; [:x boolean?]
; [:y {:optional true} int?]
; [:z [:map
;      [:x boolean?]
;      [:y {:optional true} int?]]]]

(m/ast ?schema)
;{:type :map,
; :keys {:x {:order 0
;            :value {:type boolean?}},
;        :y {:order 1, :value {:type int?}
;            :properties {:optional true}},
;        :z {:order 2,
;            :value {:type :map,
;                    :keys {:x {:order 0
;                               :value {:type boolean?}},
;                           :y {:order 1
;                               :value {:type int?}
;                               :properties {:optional true}}}}}}}

(-&gt; ?schema
    (m/schema) ;; 3.7µs
    (m/ast) ;; 1.1µs
    (m/schema) ;; 250ns (15x)
    (m/form)
    (= (m/form ?schema)))
; =&gt; true</pre></z><z id="t1632069242" t="ikitommi it’s still fully generic, like the mu/to-map-syntax &amp; mu/from-map-syntax , but using a new support protocol, schemas can do whatever they want. The new ast can be used as “I know what I’m doing” kinda way =&gt; no parsing &amp; checks needed."><y>#</y><d>2021-09-19</d><h>16:34</h><w>ikitommi</w>it’s still fully generic, like the <code>mu/to-map-syntax</code> &amp; <code>mu/from-map-syntax</code> , but using a new support protocol, schemas can do whatever they want. The new ast can be used as “I know what I’m doing” kinda way =&gt; no parsing &amp; checks needed.</z><z id="t1632153859" t="ikitommi (assert (= (m/form [:=&gt; [:cat :int] :int]) (m/form {:type :=&gt; :input {:type :cat :children [{:type :int}]} :output {:type :int}})) &quot;malli supports both hiccup &amp; map syntax&quot;)"><y>#</y><d>2021-09-20</d><h>16:04</h><w>ikitommi</w><pre>(assert
  (= (m/form [:=&gt; [:cat :int] :int])
     (m/form {:type :=&gt;
              :input {:type :cat
                      :children [{:type :int}]}
              :output {:type :int}}))
  &quot;malli supports both hiccup &amp; map syntax&quot;)</pre></z><z id="t1632153965" t="ikitommi https://github.com/metosin/malli/pull/544/commits/e44f8c027699a63f73b941137151e5a489501587"><y>#</y><d>2021-09-20</d><h>16:06</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/544/commits/e44f8c027699a63f73b941137151e5a489501587" target="_blank">https://github.com/metosin/malli/pull/544/commits/e44f8c027699a63f73b941137151e5a489501587</a></z><z id="t1632209742" t="eskos Is this unified in the sense that all hiccup gets internally turned into maps and then whatnot or two separate paths? Just trying to think onwards whether this could actually be a cause of sneaky conversion bugs in the long run…"><y>#</y><d>2021-09-21</d><h>07:35</h><r>eskos</r>Is this unified in the sense that all hiccup gets internally turned into maps and then whatnot or two separate paths? Just trying to think onwards whether this could actually be a cause of sneaky conversion bugs in the long run…</z><z id="t1632209765" t="eskos (I haven’t looked into malli internals in ages so judging a single commit diff doesn’t answer that to me)"><y>#</y><d>2021-09-21</d><h>07:36</h><r>eskos</r>(I haven’t looked into malli internals in ages so judging a single commit diff doesn’t answer that to me)</z><z id="t1632288616" t="ikitommi there is just one path, currently the map-syntax (the new ast) is transformed into properties children and thus, the old code path is used."><y>#</y><d>2021-09-22</d><h>05:30</h><r>ikitommi</r>there is just one path, currently the map-syntax (the new ast) is transformed into <code>properties children</code> and thus, the old code path is used.</z><z id="t1632288762" t="ikitommi I’ll most likely reverse that, so the default path is the AST, just a hiccup-&gt;ast converter is just mechanical."><y>#</y><d>2021-09-22</d><h>05:32</h><r>ikitommi</r>I’ll most likely reverse that, so the default path is the AST, just a hiccup-&gt;ast converter is just mechanical.</z><z id="t1632288850" t="ikitommi why? the ast-path is much faster (with maps), as there is no parsing needed. if real life projects, seen 10x diffrence, 100ms vs 1sec to load all the hundreds of schemas in a slow device."><y>#</y><d>2021-09-22</d><h>05:34</h><r>ikitommi</r>why? the ast-path is much faster (with maps), as there is no parsing needed. if real life projects, seen 10x diffrence, 100ms vs 1sec to load all the hundreds of schemas in a slow device.</z><z id="t1632288914" t="ikitommi also, the example was broken, the conversion was nor recursive, fixed inline."><y>#</y><d>2021-09-22</d><h>05:35</h><r>ikitommi</r>also, the example was broken, the conversion was nor recursive, fixed inline.</z><z id="t1632377566" t="Ben Sless I know there&apos;s a lot of focus on performance at the moment but what&apos;s the status of json-schema and the missing bits, especially date/time?"><y>#</y><d>2021-09-23</d><h>06:12</h><w>Ben Sless</w>I know there&apos;s a lot of focus on performance at the moment but what&apos;s the status of json-schema and the missing bits, especially date/time?</z><z id="t1632386184" t="ikitommi good question. • JSON Schema -&gt; malli, have been waiting for the PR to progress, might be stalled • Date/time, [:attrs {:href &quot;/_/_/users/U051B9FU1&quot;}] might have an insight on the new js/temporal lib status. If there would be a good set of abstractions for clj/s, malli should use them. Or, just a new alpha ns from the existing clj-time things • others: recursive generation, proper inferring, schematized defn, typescript-compat, map+map-of, local registries refined, ... lot of things to do, some things are started by various contributors, many just ideas. After the ast-cleanup, have clojurists-together -time to work on many things, but we (all) could do design for the missing features and mark them as &quot;PR welcome&quot;."><y>#</y><d>2021-09-23</d><h>08:36</h><w>ikitommi</w>good question. 
• JSON Schema -&gt; malli, have been waiting for the PR to progress, might be stalled
• Date/time, <a>@henryw374</a> might have an insight on the new js/temporal lib status. If there would be a good set of abstractions for clj/s, malli should use them. Or, just a new alpha ns from the existing clj-time things
• others: recursive generation, proper inferring, schematized defn, typescript-compat, map+map-of, local registries refined, ... lot of things to do, some things are started by various contributors, many just ideas. After the ast-cleanup, have <b>clojurists-together</b> -time to work on many things, but we (all) could do design for the missing features and mark them as &quot;PR welcome&quot;.</z><z id="t1632397065" t="Ben Sless I hope you don&apos;t mind, I went ahead and opened a draft PR to add time schemas in clj. I think it&apos;s 90% there and I&apos;d rather have 90% to work with vs. 100% in time t &gt; T"><y>#</y><d>2021-09-23</d><h>11:37</h><r>Ben Sless</r>I hope you don&apos;t mind, I went ahead and opened a draft PR to add time schemas in clj. I think it&apos;s 90% there and I&apos;d rather have 90% to work with vs. 100% in time t &gt; T</z><z id="t1632397105" t="Ben Sless looking at json-schema -&gt; malli gave me a headache, because the schema is versioned! do you want to support &quot;everything&quot; or just latest?"><y>#</y><d>2021-09-23</d><h>11:38</h><r>Ben Sless</r>looking at json-schema -&gt; malli gave me a headache, because the schema is versioned! do you want to support &quot;everything&quot; or just latest?</z><z id="t1632397164" t="Ben Sless This has real implications, for example, when I was wrangling vega in #datavis malli could have been a great help but vega uses an old version of json schema"><y>#</y><d>2021-09-23</d><h>11:39</h><r>Ben Sless</r>This has real implications, for example, when I was wrangling vega in #datavis malli could have been a great help but vega uses an old version of json schema</z><z id="t1632386376" t="ikitommi I tried to categorize the issues, but could add more explicit tags on those that are discussed already and would be ready to be picked up for anyone wanting to contribute."><y>#</y><d>2021-09-23</d><h>08:39</h><w>ikitommi</w>I tried to categorize the issues, but could add more explicit tags on those that are discussed already and would be ready to be picked up for anyone wanting to contribute.</z><z id="t1632386445" t="ikitommi the ast-change is fundamental, planning to finish a first version of that now. Few days of work I would guess, mainly tests."><y>#</y><d>2021-09-23</d><h>08:40</h><w>ikitommi</w>the ast-change is fundamental, planning to finish a first version of that now. Few days of work I would guess, mainly tests.</z><z id="t1632397316" t="Carlo I know of aave and snoop for instrumentation, is there a library in the malli ecosystem that does automatic generative testing of functions?"><y>#</y><d>2021-09-23</d><h>11:41</h><w>Carlo</w>I know of <code>aave</code> and <code>snoop</code> for instrumentation, is there a library in the malli ecosystem that does automatic generative testing of functions?</z><z id="t1632509362" t="Tiago Dall&apos;Oca How to get the original form of a schema-id? Details in the thread"><y>#</y><d>2021-09-24</d><h>18:49</h><w>Tiago Dall'Oca</w>How to get the original form of a schema-id? Details in the thread</z><z id="t1632509379" t="Tiago Dall&apos;Oca"><y>#</y><d>2021-09-24</d><h>18:49</h><r>Tiago Dall'Oca</r></z><z id="t1632509407" t="Tiago Dall&apos;Oca"><y>#</y><d>2021-09-24</d><h>18:50</h><r>Tiago Dall'Oca</r></z><z id="t1632509440" t="Tiago Dall&apos;Oca It&apos;s strange to me that m/form works for unqualified keys"><y>#</y><d>2021-09-24</d><h>18:50</h><r>Tiago Dall'Oca</r>It&apos;s strange to me that <code>m/form</code> works for unqualified keys</z><z id="t1632509451" t="Tiago Dall&apos;Oca How do I get this to work for qualified keys too?"><y>#</y><d>2021-09-24</d><h>18:50</h><r>Tiago Dall'Oca</r>How do I get this to work for qualified keys too?</z><z id="t1632510416" t="Tiago Dall&apos;Oca"><y>#</y><d>2021-09-24</d><h>19:06</h><r>Tiago Dall'Oca</r></z><z id="t1632510643" t="Tiago Dall&apos;Oca Ok, some more source code reading did it haha"><y>#</y><d>2021-09-24</d><h>19:10</h><r>Tiago Dall'Oca</r>Ok, some more source code reading did it haha</z><z id="t1632510684" t="Tiago Dall&apos;Oca options for adding malli schemas to jsdoc"><y>#</y><d>2021-09-24</d><h>19:11</h><w>Tiago Dall'Oca</w>options for adding malli schemas to jsdoc</z><z id="t1632572246" t="ikitommi looks good imo. what is the status of the ts-mappings [:attrs {:href &quot;/_/_/users/U4U6BDQTE&quot;}] ? Is there something you need help with?"><y>#</y><d>2021-09-25</d><h>12:17</h><w>ikitommi</w>looks good imo. what is the status of the ts-mappings <a>@mrdalloca</a>? Is there something you need help with?</z><z id="t1632574984" t="Tiago Dall&apos;Oca I&apos;m currently focused on function typing and figuring how to make malli&apos;s functions (explain, validate, etc) available to js consumers"><y>#</y><d>2021-09-25</d><h>13:03</h><r>Tiago Dall'Oca</r>I&apos;m currently focused on function typing and figuring how to make malli&apos;s functions (explain, validate, etc) available to js consumers</z><z id="t1632575061" t="Tiago Dall&apos;Oca Then there&apos;s some refactoring to do, to make the source code more presentable"><y>#</y><d>2021-09-25</d><h>13:04</h><r>Tiago Dall'Oca</r>Then there&apos;s some refactoring to do, to make the source code more presentable</z><z id="t1632575109" t="Tiago Dall&apos;Oca External types (from other libs) will soon become a priority"><y>#</y><d>2021-09-25</d><h>13:05</h><r>Tiago Dall'Oca</r>External types (from other libs) will soon become a priority</z><z id="t1632622311" t="Carlo using malli/core , is there a way to spec a plus function over positive numbers, asserting that that the result is &gt;= of any of the arguments?"><y>#</y><d>2021-09-26</d><h>02:11</h><w>Carlo</w>using <code>malli/core</code>, is there a way to spec a <code>plus</code> function over positive numbers, asserting that that the result is &gt;= of any of the arguments?</z><z id="t1632651272" t="Carlo the closest thing I saw is using the :fn spec to relate the arguments, but I&apos;m not sure how to involve the result of the function"><y>#</y><d>2021-09-26</d><h>10:14</h><r>Carlo</r>the closest thing I saw is using the <code>:fn</code> spec to relate the arguments, but I&apos;m not sure how to involve the result of the function</z><z id="t1632654020" t="lsenjov I’m not sure you actually can, off the top of my head. You could use pre-post maps in core clojure to test these contracts"><y>#</y><d>2021-09-26</d><h>11:00</h><r>lsenjov</r>I’m not sure you actually can, off the top of my head. You could use pre-post maps in core clojure to test these contracts</z><z id="t1632654154" t="lsenjov (If there’s a way to do it I’m sure someone will have a peek when the working week starts)"><y>#</y><d>2021-09-26</d><h>11:02</h><r>lsenjov</r>(If there’s a way to do it I’m sure someone will have a peek when the working week starts)</z><z id="t1632655409" t="ikitommi [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] no, there is no :fn , like there is for spec: (s/fdef ranged-rand :args (s/and (s/cat :start int? :end int?) #(&lt; (:start %) (:end %))) :ret int? :fn (s/and #(&gt;= (:ret %) (-&gt; % :args :start)) #(&lt; (:ret %) (-&gt; % :args :end)))) , but I don’t see any reason why it would not be supported."><y>#</y><d>2021-09-26</d><h>11:23</h><r>ikitommi</r><a>@UA7E6DU04</a> no, there is no <code>:fn</code>, like there is for spec:
<pre>(s/fdef ranged-rand
  :args (s/and (s/cat :start int? :end int?)
               #(&lt; (:start %) (:end %)))
  :ret int?
  :fn (s/and #(&gt;= (:ret %) (-&gt; % :args :start))
             #(&lt; (:ret %) (-&gt; % :args :end))))</pre>
, but I don’t see any reason why it would not be supported.</z><z id="t1632655471" t="ikitommi please write an Issue, so it’s on the backlog."><y>#</y><d>2021-09-26</d><h>11:24</h><r>ikitommi</r>please write an Issue, so it’s on the backlog.</z><z id="t1632655534" t="ikitommi also. there is silly assert inside malli.core that the :input (`:args` in spec) need to be a :cat , so :and doesn’t work. Easy to fix."><y>#</y><d>2021-09-26</d><h>11:25</h><r>ikitommi</r>also. there is silly assert inside malli.core that the <code>:input</code> (`:args` in spec) need to be a <code>:cat</code>, so <code>:and</code> doesn’t work. Easy to fix.</z><z id="t1632655935" t="ikitommi ast-options for eager references, this: [:and {:registry {::a ::b ::b ::c ::c [:schema pos-int?]}} ::a ::b ::c] ast options: 1️⃣ current: {:type :and, :children [{:type ::m/schema, :value ::a} {:type ::m/schema, :value ::b} {:type ::m/schema, :value ::c}] :registry {::a {:type ::m/schema, :value ::b} ::b {:type ::m/schema, :value ::c} ::c {:type :schema, :child {:type &apos;pos-int?}}}} 2️⃣ less noicy: {:type :and, :children [{:type ::a} {:type ::b} {:type ::c}] :registry {::a {:type ::b} ::b {:type ::c} ::c {:type :schema :child {:type &apos;pos-int?}}}} 3️⃣ compact: {:type :and, :children [::a ::b ::c] :registry {::a ::b ::b ::c ::c {:type :schema :child {:type &apos;pos-int?}}}}"><y>#</y><d>2021-09-26</d><h>11:32</h><w>ikitommi</w>ast-options for eager references, this:
<pre>[:and
 {:registry {::a ::b
             ::b ::c
             ::c [:schema pos-int?]}}
 ::a ::b ::c]</pre>
ast options:
<b>1️⃣</b> current:
<pre>{:type :and,
 :children [{:type ::m/schema, :value ::a}
            {:type ::m/schema, :value ::b}
            {:type ::m/schema, :value ::c}]
 :registry {::a {:type ::m/schema, :value ::b}
            ::b {:type ::m/schema, :value ::c}
            ::c {:type :schema, :child {:type &apos;pos-int?}}}}</pre>
<b>2️⃣</b> less noicy:
<pre>{:type :and,
 :children [{:type ::a}
            {:type ::b}
            {:type ::c}]
 :registry {::a {:type ::b}
            ::b {:type ::c}
            ::c {:type :schema
                 :child {:type &apos;pos-int?}}}}</pre>
<b>3️⃣</b> compact:
<pre>{:type :and,
 :children [::a ::b ::c]
 :registry {::a ::b
            ::b ::c
            ::c {:type :schema
                 :child {:type &apos;pos-int?}}}}</pre></z><z id="t1632656167" t="Ben Sless 3 looks best"><y>#</y><d>2021-09-26</d><h>11:36</h><r>Ben Sless</r>3 looks best</z><z id="t1632661351" t="Karol Wójcik 3"><y>#</y><d>2021-09-26</d><h>13:02</h><r>Karol Wójcik</r>3</z><z id="t1632664748" t="ikitommi I think 3 is also the fastest, short-circuiting to lookup instead of walking more maps before the lookup. Pushed the registry into it&apos;s own key, it&apos;s also faster to use (one map lookup less) and looks better. So, ast is map with :type , optionally :properties and :registry . Plus any keys Schema wasn&apos;t to lift there. There are few comventions with helpers: • no child&apos;s -&gt; nothing added • one child -&gt; :child • many childs -&gt; :children • same, but not schemas, just values (e.g. [:&gt; 1] , [:enum &quot;small&quot; &quot;large&quot;] -&gt; :value and :values • entries -&gt; :keys with maps with :value , optionally :prooerties and :order ... but, could have anything, like :=&gt; has :input &amp; :output"><y>#</y><d>2021-09-26</d><h>13:59</h><r>ikitommi</r>I think 3 is also the fastest, short-circuiting to lookup instead of walking more maps before the lookup. Pushed the registry into it&apos;s own key, it&apos;s also faster to use (one map lookup less) and looks better. So, ast is map with <code>:type</code>, optionally <code>:properties</code> and <code>:registry</code>. Plus any keys Schema wasn&apos;t to lift there. There are few comventions with helpers:
• no child&apos;s -&gt; nothing added
• one child -&gt; <code>:child</code>
• many childs -&gt; <code>:children</code>
• same, but not schemas, just values (e.g. <code>[:&gt; 1]</code>, <code>[:enum &quot;small&quot; &quot;large&quot;]</code> -&gt; <code>:value</code> and <code>:values</code>
• entries -&gt; <code>:keys</code> with maps with <code>:value</code>, optionally <code>:prooerties</code> and <code>:order</code>
... but, could have anything, like <code>:=&gt;</code> has <code>:input</code> &amp; <code>:output</code></z><z id="t1632664748" t="ikitommi I think 3 is also the fastest, short-circuiting to lookup instead of walking more maps before the lookup. Pushed the registry into it&apos;s own key, it&apos;s also faster to use (one map lookup less) and looks better. So, ast is map with :type , optionally :properties and :registry . Plus any keys Schema wasn&apos;t to lift there. There are few comventions with helpers: • no child&apos;s -&gt; nothing added • one child -&gt; :child • many childs -&gt; :children • same, but not schemas, just values (e.g. [:&gt; 1] , [:enum &quot;small&quot; &quot;large&quot;] -&gt; :value and :values • entries -&gt; :keys with maps with :value , optionally :prooerties and :order ... but, could have anything, like :=&gt; has :input &amp; :output"><y>#</y><d>2021-09-26</d><h>13:59</h><w>ikitommi</w>I think 3 is also the fastest, short-circuiting to lookup instead of walking more maps before the lookup. Pushed the registry into it&apos;s own key, it&apos;s also faster to use (one map lookup less) and looks better. So, ast is map with <code>:type</code>, optionally <code>:properties</code> and <code>:registry</code>. Plus any keys Schema wasn&apos;t to lift there. There are few comventions with helpers:
• no child&apos;s -&gt; nothing added
• one child -&gt; <code>:child</code>
• many childs -&gt; <code>:children</code>
• same, but not schemas, just values (e.g. <code>[:&gt; 1]</code>, <code>[:enum &quot;small&quot; &quot;large&quot;]</code> -&gt; <code>:value</code> and <code>:values</code>
• entries -&gt; <code>:keys</code> with maps with <code>:value</code>, optionally <code>:prooerties</code> and <code>:order</code>
... but, could have anything, like <code>:=&gt;</code> has <code>:input</code> &amp; <code>:output</code></z><z id="t1632749305" t="jkrasnay Hi, I have a schema that looks like this: (def MySchema [:or :string [:and [:vector any?] [:fn {:error/fn (fn [{:keys [value]} _] (str &quot;Not found: &quot; (pr-str value)))} my-lookup]]])"><y>#</y><d>2021-09-27</d><h>13:28</h><w>jkrasnay</w>Hi, I have a schema that looks like this:
<pre>(def MySchema [:or
                 :string
                 [:and
                  [:vector any?]
                  [:fn {:error/fn
                        (fn [{:keys [value]} _]
                          (str &quot;Not found: &quot; (pr-str value)))}
                   my-lookup]]])</pre></z><z id="t1632749386" t="jkrasnay When I run (-&gt; (m/explain MySchema 42) (me/humanize)) the result is [&quot;should be a string&quot; &quot;invalid type&quot; &quot;Not found: 42&quot;]"><y>#</y><d>2021-09-27</d><h>13:29</h><w>jkrasnay</w>When I run <code>(-&gt; (m/explain MySchema 42) (me/humanize))</code> the result is <code>[&quot;should be a string&quot; &quot;invalid type&quot; &quot;Not found: 42&quot;]</code></z><z id="t1632749472" t="jkrasnay What I’m hoping for is a way to organize the schema so that the error is something like “should be a string or a vector”, and if the value is a vector and my-lookup fails the error is simply “Not found: [:whatever]“. Is there a way to do this?"><y>#</y><d>2021-09-27</d><h>13:31</h><w>jkrasnay</w>What I’m hoping for is a way to organize the schema so that the error is something like “should be a string or a vector”, and if the value is a vector and <code>my-lookup</code> fails the error is simply “Not found: [:whatever]“. Is there a way to do this?</z><z id="t1632749901" t="jkrasnay (also it would be nice if my-lookup didn’t get called if the value wasn’t a vector. I suppose [:and] does not short-circuit)"><y>#</y><d>2021-09-27</d><h>13:38</h><w>jkrasnay</w>(also it would be nice if <code>my-lookup</code> didn’t get called if the value wasn’t a vector. I suppose <code>[:and]</code> does not short-circuit)</z><z id="t1632750809" t="jkrasnay I suppose I could replace my-lookup with #(or (not (vector? %)) (my-lookup %)) , then put an :error/fn on the :vector check that returns “should be a vector”."><y>#</y><d>2021-09-27</d><h>13:53</h><w>jkrasnay</w>I suppose I could replace <code>my-lookup</code> with <code>#(or (not (vector? %)) (my-lookup %))</code>, then put an <code>:error/fn</code> on the <code>:vector</code> check that returns “should be a vector”.</z><z id="t1632751496" t="jkrasnay Still interested if there’s a more elegant way to do this, though."><y>#</y><d>2021-09-27</d><h>14:04</h><w>jkrasnay</w>Still interested if there’s a more elegant way to do this, though.</z><z id="t1632753219" t="ikitommi [:attrs {:href &quot;/_/_/users/U0DTSCAUU&quot;}] there is a hidden feature where you can add the error-properties into parent-nodes: in case a child errors, the too-most error is used instead, once for all errors. I was not happy with the impl and didn&apos;t need it in my client project, so decided not to release it."><y>#</y><d>2021-09-27</d><h>14:33</h><w>ikitommi</w><a>@jkrasnay</a> there is a hidden feature where you can add the error-properties into parent-nodes: in case a child errors, the too-most error is used instead, once for all errors. I was not happy with the impl and didn&apos;t need it in my client project, so decided not to release it.</z><z id="t1632753385" t="ikitommi try: https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L499-L524"><y>#</y><d>2021-09-27</d><h>14:36</h><r>ikitommi</r>try: <a href="https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L499-L524" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/error_test.cljc#L499-L524</a></z><z id="t1632754721" t="jkrasnay OK, thanks. I’ll take some time to study these."><y>#</y><d>2021-09-27</d><h>14:58</h><r>jkrasnay</r>OK, thanks. I’ll take some time to study these.</z><z id="t1632753589" t="ikitommi :and and :or short-circuit &amp; collect all errors - it would be easy to inject extra data to those explanations and add options to either schema itself (via properties) or the me/humanize to allow control how to work with them."><y>#</y><d>2021-09-27</d><h>14:39</h><w>ikitommi</w><code>:and</code> and <code>:or</code> short-circuit &amp; collect all errors - it would be easy to inject extra data to those explanations and add options to either schema itself (via properties) or the <code>me/humanize</code> to allow control how to work with them.</z><z id="t1632763524" t="Nicholas Hello there, I&apos;ve just started a very basic template with Shadow-cljs and Malli , but as I run npx shadow-cljs watch :app I get an error saying : *Wrong number of args (3) passed to malli.core/-fail!* . The project itself is just here : https://github.com/bitbot123/shadow-cljs-malli/blob/master/src/core.cljs (on the master branch) , and I&apos;ve stuck [metosin/malli &quot;0.6.1&quot;] in shadow-cljs.edn , is this correct? Any help is much appreciated."><y>#</y><d>2021-09-27</d><h>17:25</h><w>Nicholas</w>Hello there, I&apos;ve just started a very basic template with Shadow-cljs and Malli , but as I run <code>npx shadow-cljs watch :app</code>  I get an error saying : <code>*Wrong number of args (3) passed to malli.core/-fail!*</code> .  The project itself is just here : <a href="https://github.com/bitbot123/shadow-cljs-malli/blob/master/src/core.cljs" target="_blank">https://github.com/bitbot123/shadow-cljs-malli/blob/master/src/core.cljs</a> (on the master branch) , and I&apos;ve stuck <code>[metosin/malli &quot;0.6.1&quot;]</code>  in <code>shadow-cljs.edn</code> , is this correct? Any help is much appreciated.</z><z id="t1632766378" t="ikitommi oh well, released version with just the minimal fixes for that [:attrs {:href &quot;/_/_/users/U02ES7V4PT2&quot;}] : ➜ ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.2&quot;}}}&apos; Downloading: metosin/malli/0.6.2/malli-0.6.2.pom from clojars"><y>#</y><d>2021-09-27</d><h>18:12</h><w>ikitommi</w>oh well, released version with just the minimal fixes for that <a>@shamansandtheprimes</a> :
<pre>➜  ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.6.2&quot;}}}&apos;
Downloading: metosin/malli/0.6.2/malli-0.6.2.pom from clojars</pre></z><z id="t1632766436" t="ikitommi https://github.com/metosin/malli/commit/98167660c841fdf9618974a83e7e7d2fa3acd5b2"><y>#</y><d>2021-09-27</d><h>18:13</h><r>ikitommi</r><a href="https://github.com/metosin/malli/commit/98167660c841fdf9618974a83e7e7d2fa3acd5b2" target="_blank">https://github.com/metosin/malli/commit/98167660c841fdf9618974a83e7e7d2fa3acd5b2</a></z><z id="t1632828630" t="Nicholas The project compiles no problem, thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2021-09-28</d><h>11:30</h><w>Nicholas</w>The project compiles no problem, thank you <a>@ikitommi</a></z><z id="t1632988971" t="Yehonathan Sharvit Malli mentions JSON schema as a source of inspiration (in malli&apos;s https://github.com/metosin/malli#links-and-thanks ). Here is an https://blog.klipse.tech/javascript/2021/09/30/data-validation-with-json-schema.html I wrote about JSON schema validation that mentions Malli. The loop is closed 😎"><y>#</y><d>2021-09-30</d><h>08:02</h><w>Yehonathan Sharvit</w>Malli mentions JSON schema as a source of inspiration (in malli&apos;s <a href="https://github.com/metosin/malli#links-and-thanks" target="_blank">https://github.com/metosin/malli#links-and-thanks</a>).
Here is an <a href="https://blog.klipse.tech/javascript/2021/09/30/data-validation-with-json-schema.html" target="_blank">https://blog.klipse.tech/javascript/2021/09/30/data-validation-with-json-schema.html</a> I wrote about JSON schema validation that mentions Malli.
The loop is closed <b>😎</b></z><z id="t1633095143" t="ikitommi Good article. I think you could implement the Full JSON Schema with malli. Maybe Malli should be rebranded as an library to create schema libraries 👻"><y>#</y><d>2021-10-01</d><h>13:32</h><r>ikitommi</r>Good article. I think you could implement the Full JSON Schema with malli. Maybe Malli should be rebranded as an library to create schema libraries <b>👻</b></z><z id="t1633256872" t="Yehonathan Sharvit What would it take to implement JSON Schema with malli [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ?"><y>#</y><d>2021-10-03</d><h>10:27</h><r>Yehonathan Sharvit</r>What would it take to implement JSON Schema with malli <a>@U055NJ5CC</a>?</z><z id="t1633099432" t="zane What is the meaning of the error :malli.core/potentially-recursive-seqex ?"><y>#</y><d>2021-10-01</d><h>14:43</h><w>zane</w>What is the meaning of the error <code>:malli.core/potentially-recursive-seqex</code>?</z><z id="t1633104555" t="ikitommi I believe it&apos;s documented on README &amp;/ source code."><y>#</y><d>2021-10-01</d><h>16:09</h><r>ikitommi</r>I believe it&apos;s documented on README &amp;/ source code.</z><z id="t1633105309" t="zane I looked through both and it’s not readily apparent to me."><y>#</y><d>2021-10-01</d><h>16:21</h><r>zane</r>I looked through both and it’s not readily apparent to me.</z><z id="t1633106046" t="ikitommi I&apos;ll try: it&apos;s a design choice to keep the parsing fast and simpler: You can&apos;t recur from a sequence itself, but you can recur from a element in the sequence. http://malli.io has an example how hiccup works."><y>#</y><d>2021-10-01</d><h>16:34</h><r>ikitommi</r>I&apos;ll try: it&apos;s a design choice to keep the parsing fast and simpler: You can&apos;t recur from a sequence itself, but you can recur from a element in the sequence. <a href="http://malli.io" target="_blank">http://malli.io</a> has an example how hiccup works.</z><z id="t1633106134" t="ikitommi e.g. wrap the :ref inside a :schema forcing it out of the secuence to it&apos;s own schema."><y>#</y><d>2021-10-01</d><h>16:35</h><r>ikitommi</r>e.g. wrap the <code>:ref</code> inside a :schema forcing it out of the secuence to it&apos;s own schema.</z><z id="t1633106721" t="zane That’s extremely helpful. Thanks!"><y>#</y><d>2021-10-01</d><h>16:45</h><r>zane</r>That’s extremely helpful. Thanks!</z><z id="t1633119666" t="Carsten Behring I am struggling to define a schema as defn metadata, which accepts any values as inpu (as I only one to validate output) How could this look like ?"><y>#</y><d>2021-10-01</d><h>20:21</h><w>Carsten Behring</w>I am struggling to define a schema as defn metadata, which accepts any values as inpu (as I only one to validate output)
How could this look like ?</z><z id="t1633126688" t="respatialized assuming your function is 1-arity, you could do: (defn my-func {:malli/schema [:=&gt; [:cat :any] output-schema]} ... ; body goes here)"><y>#</y><d>2021-10-01</d><h>22:18</h><w>respatialized</w>assuming your function is 1-arity, you could do:
<pre>(defn my-func {:malli/schema [:=&gt; [:cat :any] output-schema]}
  ... ; body goes here)</pre></z><z id="t1633186383" t="respatialized Is there an option for m/parse that disables returning tagged values for :orn / :altn / :multi / etc?"><y>#</y><d>2021-10-02</d><h>14:53</h><w>respatialized</w>Is there an option for <code>m/parse</code> that disables returning tagged values for <code>:orn</code> / <code>:altn</code> / <code>:multi</code> / etc?</z><z id="t1633187376" t="ikitommi currently, no. What is your use case for this?"><y>#</y><d>2021-10-02</d><h>15:09</h><r>ikitommi</r>currently, no. What is your use case for this?</z><z id="t1633187442" t="ikitommi if you want to disable all, just call validate and return the original value in case of success .."><y>#</y><d>2021-10-02</d><h>15:10</h><r>ikitommi</r>if you want to disable all, just call validate and return the original value in case of success ..</z><z id="t1633188363" t="respatialized I have a large, complex schema that implements a https://github.com/fabricate-site/fabricate/blob/c04afeb0ab40b49f1f95bde126333992b25ae644/src/site/fabricate/prototype/html.clj#L150 for Hiccup elements. I leverage :orn throughout to preserve contextual information about elements (such as whether they&apos;re flow content or phrasing content). This is what it looks like when using a parser to parse a small element: (site.fabricate.prototype.html/parse-element [:p &quot;text&quot; [:em &quot;with emphasis&quot;]]) =&gt; [:flow [:p {:tag :p, :attrs nil, :contents [[:atomic-element [:text &quot;text&quot;]] [:node [:em {:tag :em, :attrs nil, :contents [[:atomic-element [:text &quot;with emphasis&quot;]]]}]]]}]] While this contextual information is sometimes useful, I also want the option of returning parsed values without it: just the {:tag t :attrs {} :contents [...]} structure so that every result from m/parse is returned in a uniform way. Perhaps, as you suggest, I&apos;m relying too heavily on m/parse here; there&apos;s not much stopping me from pattern matching on the head &amp; tail of the actual elements (so long as they validate) using ordinary sequence functions."><y>#</y><d>2021-10-02</d><h>15:26</h><r>respatialized</r>I have a large, complex schema that implements a <a href="https://github.com/fabricate-site/fabricate/blob/c04afeb0ab40b49f1f95bde126333992b25ae644/src/site/fabricate/prototype/html.clj#L150" target="_blank">https://github.com/fabricate-site/fabricate/blob/c04afeb0ab40b49f1f95bde126333992b25ae644/src/site/fabricate/prototype/html.clj#L150</a> for Hiccup elements. I leverage <code>:orn</code> throughout to preserve contextual information about elements (such as whether they&apos;re flow content or phrasing content).

This is what it looks like when using a parser to parse a small element:
<pre>(site.fabricate.prototype.html/parse-element [:p &quot;text&quot; [:em &quot;with emphasis&quot;]])
=&gt;
[:flow
 [:p
  {:tag :p,
   :attrs nil,
   :contents
   [[:atomic-element [:text &quot;text&quot;]]
    [:node
     [:em
      {:tag :em,
       :attrs nil,
       :contents [[:atomic-element [:text &quot;with emphasis&quot;]]]}]]]}]]</pre>
While this contextual information is sometimes useful, I also want the option of returning parsed values without it: just the <code>{:tag t :attrs {} :contents [...]}</code> structure so that every result from <code>m/parse</code> is returned in a uniform way.

Perhaps, as you suggest, I&apos;m relying too heavily on <code>m/parse</code> here; there&apos;s not much stopping me from pattern matching on the head &amp; tail of the actual elements (so long as they validate) using ordinary sequence functions.</z><z id="t1633188502" t="respatialized just as an aside, the fact that it&apos;s possible and performant to implement this much contextual information using seqexes speaks to the expressive power of malli . 🔥"><y>#</y><d>2021-10-02</d><h>15:28</h><r>respatialized</r>just as an aside, the fact that it&apos;s  possible and performant to implement this much contextual information using seqexes speaks to the expressive power of <code>malli</code>. <b>🔥</b></z><z id="t1633192191" t="respatialized after rewriting the schema manually, I think I was confused about how tagged entries work. if tagging were disabled for the schema, then I wouldn&apos;t even get the map syntax from the result."><y>#</y><d>2021-10-02</d><h>16:29</h><r>respatialized</r>after rewriting the schema manually, I think I was confused about how tagged entries work. if tagging were disabled for the schema, then I wouldn&apos;t even get the map syntax from the result.</z><z id="t1633192253" t="respatialized my intended result was a mixture of tagged and untagged parse results, so it wouldn&apos;t even have been achieved by disabling tagging for :orn ."><y>#</y><d>2021-10-02</d><h>16:30</h><r>respatialized</r>my intended result was a mixture of tagged and untagged parse results, so it wouldn&apos;t even have been achieved by disabling tagging for <code>:orn</code>.</z><z id="t1633264895" t="andre.richards Edit: I implemented below by overriding malli.json-schema/-schema . In there I can control whether to return the ref (and add it to definitions) or return the deref of the attribute schema. Is there a way to &apos;deref&apos; [:map] children when transforming a schema to Swagger? We use &apos;decomplected&apos; map attributes, e.g.: (def registry (merge (m/default-schemas) {:customer/id :uuid :customer/name :string :Customer [:map [:customer/id] [:customer/name]})) (transform :Customer {:registry registry}) Results in: {:type &quot;object&quot;, :properties {:customer/id {:$ref &quot;#/definitions/:customer/id&quot;}, :customer/name {:$ref &quot;#/definitions/:customer/name&quot;}}, :required [:customer/id :customer/name], :definitions {:customer/id {:type &quot;string&quot;, :format &quot;uuid&quot;}, :customer/name {:type &quot;string&quot;}}} Apart from the fact that this gives an error in Swagger (the extra forward slash after customer in $ref value), we would really like to get Swagger that looks like this (i.e. without a definition for each attribute): {:type &quot;object&quot;, :properties {:customer/id {:type &quot;string&quot;, :format &quot;uuid&quot;}, :customer/name {:type &quot;string&quot;}}, :required [:customer/id :customer/name]} We re-use the attributes in multiple schemas, and really like the fact that we don&apos;t have to re-define the attribute schema every time we use it (which is the point of decomplected attributes), and this is working as expected for all the core Malli operations like validate . We considered calling m/deref-all on the :Customer schema, but [:map] does not deref its children, so this does not help."><y>#</y><d>2021-10-03</d><h>12:41</h><w>andre.richards</w>Edit: I implemented below by overriding <code>malli.json-schema/-schema</code>. In there I can control whether to return the ref (and add it to definitions) or  return the deref of the attribute schema.

Is there a way to &apos;deref&apos; [:map] children when transforming a schema to Swagger?

We use &apos;decomplected&apos; map attributes, e.g.:
<pre>(def registry
    (merge
      (m/default-schemas)
      {:customer/id   :uuid
       :customer/name :string
       :Customer      [:map
                       [:customer/id]
                       [:customer/name]}))

(transform :Customer {:registry registry})</pre>
Results in:
<pre>{:type        &quot;object&quot;,
 :properties  {:customer/id   {:$ref &quot;#/definitions/:customer/id&quot;},
               :customer/name {:$ref &quot;#/definitions/:customer/name&quot;}},
 :required    [:customer/id :customer/name],
 :definitions {:customer/id {:type &quot;string&quot;, :format &quot;uuid&quot;}, 
               :customer/name {:type &quot;string&quot;}}}</pre>
Apart from the fact that this gives an error in Swagger (the extra forward slash after customer in $ref value), we would really like to get Swagger that looks like this (i.e. without a definition for each attribute):
<pre>{:type       &quot;object&quot;,
 :properties {:customer/id {:type &quot;string&quot;, :format &quot;uuid&quot;}, 
              :customer/name {:type &quot;string&quot;}},
 :required   [:customer/id :customer/name]}</pre>
We re-use the attributes in multiple schemas, and really like the fact that we don&apos;t have to re-define the attribute schema every time we use it (which is the point of decomplected attributes), and this is working as expected for all the core Malli operations like <code>validate</code>.

We considered calling <code>m/deref-all</code> on the :Customer schema,  but [:map] does not deref its children, so this does not help.</z><z id="t1633348373" t="Yehonathan Sharvit What is the relationships between decode and validate ? Are we suppose to validate after a value has been successfully decoded?"><y>#</y><d>2021-10-04</d><h>11:52</h><w>Yehonathan Sharvit</w>What is the relationships between <code>decode</code> and <code>validate</code>?
Are we suppose to validate after a value has been successfully decoded?</z><z id="t1633348654" t="Ben Sless Decode never &quot;fails&quot;, it&apos;s a best effort to get data to look like what should be validated. Validation should be done after decode"><y>#</y><d>2021-10-04</d><h>11:57</h><r>Ben Sless</r>Decode never &quot;fails&quot;, it&apos;s a best effort to get data to look like what should be validated.
Validation should be done after decode</z><z id="t1633348706" t="Ben Sless after decode and before validation you can&apos;t really know if the data is valid, yet"><y>#</y><d>2021-10-04</d><h>11:58</h><r>Ben Sless</r>after decode and before validation you can&apos;t really know if the data is valid, yet</z><z id="t1633348981" t="Yehonathan Sharvit Makes sense [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] . Thanks"><y>#</y><d>2021-10-04</d><h>12:03</h><r>Yehonathan Sharvit</r>Makes sense <a>@UK0810AQ2</a> . Thanks</z><z id="t1633363309" t="Carsten Behring How can I do a schema, which allows maps of &quot;any key&quot; of a certain type , string for example (or qualified symbols)"><y>#</y><d>2021-10-04</d><h>16:01</h><w>Carsten Behring</w>How can I do a schema, which allows maps of &quot;any key&quot; of a certain type , string for example (or qualified symbols)</z><z id="t1633363680" t="Carsten Behring found it, :map-of"><y>#</y><d>2021-10-04</d><h>16:08</h><w>Carsten Behring</w>found it, :map-of</z><z id="t1633389786" t="onetom is anyone aware of any work being done on OpenAPI (v2/v3) to Malli conversion? we are using https://github.com/oliyh/martian to talk to many APIs, and we love it, but it&apos;s using Plumatic Schema and we would like to use Malli instead."><y>#</y><d>2021-10-04</d><h>23:23</h><w>onetom</w>is anyone aware of any work being done on OpenAPI (v2/v3) to Malli conversion?
we are using <a href="https://github.com/oliyh/martian" target="_blank">https://github.com/oliyh/martian</a> to talk to many APIs, and we love it, but it&apos;s using Plumatic Schema and we would like to use Malli instead.</z><z id="t1633391592" t="onetom im just watching https://www.youtube.com/watch?v=gMYQ1vDy7d0 and learnt that OpenAPI v3.1 is gonna be fully compatible with JSON Schema draft 8"><y>#</y><d>2021-10-04</d><h>23:53</h><r>onetom</r>im just watching <a href="https://www.youtube.com/watch?v=gMYQ1vDy7d0" target="_blank">https://www.youtube.com/watch?v=gMYQ1vDy7d0</a> and learnt that OpenAPI v3.1 is gonna be fully compatible with JSON Schema draft 8</z><z id="t1633427672" t="Carsten Behring I could not get my head arround the best practices to use Malli for runtime checking of function parameters. I saw the docu about this, but wonder between &quot;instrumentation&quot;, which seems to be dev oriented,"><y>#</y><d>2021-10-05</d><h>09:54</h><w>Carsten Behring</w>I could not get my head arround the best practices to use Malli for runtime checking of function parameters.
I saw the docu about this, but wonder between &quot;instrumentation&quot;, which seems to be dev oriented,</z><z id="t1633427702" t="Carsten Behring vs call validate in the code"><y>#</y><d>2021-10-05</d><h>09:55</h><w>Carsten Behring</w>vs call <code>validate</code> in the code</z><z id="t1633427751" t="Carsten Behring I store my schema as function metadata if this helps."><y>#</y><d>2021-10-05</d><h>09:55</h><w>Carsten Behring</w>I store my schema as function metadata if this helps.</z><z id="t1633427767" t="Carsten Behring How do people do this ?"><y>#</y><d>2021-10-05</d><h>09:56</h><w>Carsten Behring</w>How do people do this ?</z><z id="t1633444803" t="danielglauser When working with Malli we used it to test all API inputs to the system and sometimes the outputs from the system. We didn&apos;t use it to check common function calls. Why do you want to do that?"><y>#</y><d>2021-10-05</d><h>14:40</h><w>danielglauser</w>When working with Malli we used it to test all API inputs to the system and sometimes the outputs from the system. We didn&apos;t use it to check common function calls. Why do you want to do that?</z><z id="t1633445424" t="NoahTheDuke for development it’s very nice to see when you meant to pass in a vec and passed in a map instead, but in prod i feel like those kinds of checks aren’t helpful (especially if the code actually runs how you expect anyways)"><y>#</y><d>2021-10-05</d><h>14:50</h><w>NoahTheDuke</w>for development it’s very nice to see when you meant to pass in a vec and passed in a map instead, but in prod i feel like those kinds of checks aren’t helpful (especially if the code actually runs how you expect anyways)</z><z id="t1633446902" t="danielglauser I can see that though I usually accomplish those types of checks through my tests. It&apos;ll be interesting to see in anyone has a technique for using Malli for environment based assertions."><y>#</y><d>2021-10-05</d><h>15:15</h><w>danielglauser</w>I can see that though I usually accomplish those types of checks through my tests. It&apos;ll be interesting to see in anyone has a technique for using Malli for environment based assertions.</z><z id="t1633447267" t="ikitommi [:attrs {:href &quot;/_/_/users/U086KE6TX&quot;}] it’s layered: malli.instrument can be used in prod too, it doesn’t contain any var-watches, clj-kondo emitting and thanks to it’s filters, you can annotate your functions with meta like {:malli/always-validate true} and instrument those in prod."><y>#</y><d>2021-10-05</d><h>15:21</h><w>ikitommi</w><a>@danielglauser</a> it’s layered: <code>malli.instrument</code> can be used in prod too, it doesn’t contain any var-watches, clj-kondo emitting and thanks to it’s filters, you can annotate your functions with meta like <code>{:malli/always-validate true}</code> and instrument those in prod.</z><z id="t1633447381" t="ikitommi have worked with a lot of codebases with Plumatic Schema where few (important) functions had the :always-validate on. e.g. when reading data from document-db or just Very Important Function (handling money) where the perf penalty is ok."><y>#</y><d>2021-10-05</d><h>15:23</h><w>ikitommi</w>have worked with a lot of codebases with Plumatic Schema where few (important) functions had the <code>:always-validate</code> on. e.g. when reading data from document-db or just Very Important Function (handling money) where the perf penalty is ok.</z><z id="t1633447547" t="ikitommi malli.dev is built on top of malli.instrument with just start! and stop! , which both are stateful. would not use in prod."><y>#</y><d>2021-10-05</d><h>15:25</h><w>ikitommi</w><code>malli.dev</code> is built on top of <code>malli.instrument</code>with just <code>start!</code> and <code>stop!</code> , which both are stateful. would not use in prod.</z><z id="t1633447624" t="ikitommi stateful as in watching the Vars and emitting (clj-kondo) files."><y>#</y><d>2021-10-05</d><h>15:27</h><r>ikitommi</r>stateful as in watching the Vars and emitting (clj-kondo) files.</z><z id="t1633472966" t="Carsten Behring I think &quot;input checking&quot; at runtime can be important for public functions. At the end, I only guarantee that my function works, if the caller does his part (giving valid input only). Failing so, resulst often in very ugly error message deep in Clojure, from which it is impossible to read what I have done wrong (as teh caller)."><y>#</y><d>2021-10-05</d><h>22:29</h><w>Carsten Behring</w>I think &quot;input checking&quot; at runtime can be important for public functions.

At the end, I only guarantee that my function works, if the caller does his part (giving valid input only).

Failing so, resulst often in very ugly error message deep in Clojure, from which it is impossible to read what I have done wrong (as teh caller).</z><z id="t1633473008" t="Carsten Behring &quot;Output&quot; checking is a complete different story. That I probably don&apos;t want to have in production code."><y>#</y><d>2021-10-05</d><h>22:30</h><w>Carsten Behring</w>&quot;Output&quot; checking is a complete different story. That I probably don&apos;t want to have in production code.</z><z id="t1633473085" t="Carsten Behring Is somebody doing this ? I see various way to implement the parameter checking, and was wondering which works best. 1. Instrumenting "><y>#</y><d>2021-10-05</d><h>22:31</h><w>Carsten Behring</w>Is somebody doing this ?
I see various way to implement the parameter checking, and was wondering which works best.
1. Instrumenting
</z><z id="t1633473096" t="Carsten Behring 2. direct calls of format"><y>#</y><d>2021-10-05</d><h>22:31</h><w>Carsten Behring</w>2. direct calls of format</z><z id="t1633473164" t="Carsten Behring Together with this come the different options, where to keep the schema ? as defn metadata or in some vars ? How can we the use those easely for documentation of a function ?"><y>#</y><d>2021-10-05</d><h>22:32</h><w>Carsten Behring</w>Together with this come the different options, where to keep the schema ?
as defn metadata or in some vars ?

How can we the use those easely for documentation of a function ?</z><z id="t1633548745" t="agigao Hey guys, any pointers how can I check/validate a value for bigdec ?"><y>#</y><d>2021-10-06</d><h>19:32</h><w>agigao</w>Hey guys, any pointers how can I check/validate a value for <code>bigdec</code>?</z><z id="t1633549332" t="ribelo https://clojuredocs.org/clojure.core/decimal_q"><y>#</y><d>2021-10-06</d><h>19:42</h><r>ribelo</r><a href="https://clojuredocs.org/clojure.core/decimal_q" target="_blank">https://clojuredocs.org/clojure.core/decimal_q</a></z><z id="t1633549447" t="agigao Oh, thanks!"><y>#</y><d>2021-10-06</d><h>19:44</h><r>agigao</r>Oh, thanks!</z><z id="t1633677563" t="Hukka We didn&apos;t have a test for it, and managed to (of course) put JSON schema example data that didn&apos;t match the schema, so the swagger ui happily offered to make requests that gave an error. I tried to look for it, but couldn&apos;t find any: is there a ready made helper that creates a sample data structure from the embedded :json-schema/example s, or should we just walk through the schema tree and built it ourselves?"><y>#</y><d>2021-10-08</d><h>07:19</h><w>Hukka</w>We didn&apos;t have a test for it, and managed to (of course) put JSON schema example data that didn&apos;t match the schema, so the swagger ui happily offered to make requests that gave an error. I tried to look for it, but couldn&apos;t find any: is there a ready made helper that creates a sample data structure from the embedded <code>:json-schema/example</code>s, or should we just walk through the schema tree and built it ourselves?</z><z id="t1634143001" t="Carsten Behring can I easely declare in a schema that all keys are optional ?"><y>#</y><d>2021-10-13</d><h>16:36</h><w>Carsten Behring</w>can I easely declare in a schema that all keys are optional ?</z><z id="t1634149165" t="Hukka Easily as data, no, but there are helpers that transform a schema recursively to open or closed"><y>#</y><d>2021-10-13</d><h>18:19</h><r>Hukka</r>Easily as data, no, but there are helpers that transform a schema recursively to open or closed</z><z id="t1634149190" t="Hukka Whoops, what am I saying, that&apos;d completely different, of course"><y>#</y><d>2021-10-13</d><h>18:19</h><r>Hukka</r>Whoops, what am I saying, that&apos;d completely different, of course</z><z id="t1634149245" t="Hukka There&apos;s a separate helper for opening and closing"><y>#</y><d>2021-10-13</d><h>18:20</h><r>Hukka</r>There&apos;s a separate helper for opening and closing</z><z id="t1634149272" t="Hukka And then others for optional and required"><y>#</y><d>2021-10-13</d><h>18:21</h><r>Hukka</r>And then others for optional and required</z><z id="t1634151796" t="Carsten Behring ok, thanks"><y>#</y><d>2021-10-13</d><h>19:03</h><r>Carsten Behring</r>ok, thanks</z><z id="t1634164228" t="lsenjov malli.util has basically everything you’ll need"><y>#</y><d>2021-10-13</d><h>22:30</h><r>lsenjov</r>malli.util has basically everything you’ll need</z><z id="t1634164382" t="lsenjov Specifically, optional-keys"><y>#</y><d>2021-10-13</d><h>22:33</h><r>lsenjov</r>Specifically, <code>optional-keys</code></z><z id="t1634164391" t="lsenjov There’s also malli.core/children for getting all keys out"><y>#</y><d>2021-10-13</d><h>22:33</h><r>lsenjov</r>There’s also <code>malli.core/children</code> for getting all keys out</z><z id="t1634211934" t="Ben Sless I&apos;m trying the instrument example from the documentation, while I get the report in the REPL, kondo isn&apos;t emitting the lint warnings for it. Am I missing anything?"><y>#</y><d>2021-10-14</d><h>11:45</h><w>Ben Sless</w>I&apos;m trying the instrument example from the documentation, while I get the report in the REPL, kondo isn&apos;t emitting the lint warnings for it. Am I missing anything?</z><z id="t1634211980" t="borkdude [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Have you added the emitted config to your clj-kondo config?"><y>#</y><d>2021-10-14</d><h>11:46</h><w>borkdude</w><a>@ben.sless</a> Have you added the emitted config to your clj-kondo config?</z><z id="t1634212131" t="Ben Sless Looks like I am missing something. The emitted config is written by malli by default to .clj-kondo/configs/malli/config.edn , do I need to include it somehow?"><y>#</y><d>2021-10-14</d><h>11:48</h><r>Ben Sless</r>Looks like I am missing something. The emitted config is written by malli by default to <code>.clj-kondo/configs/malli/config.edn</code>, do I need to include it somehow?</z><z id="t1634212169" t="borkdude yeah, in .clj-kondo/config.edn you need to write {:config-paths [&quot;configs/malli&quot;]}"><y>#</y><d>2021-10-14</d><h>11:49</h><r>borkdude</r>yeah, in <code>.clj-kondo/config.edn</code> you need to write <code>{:config-paths [&quot;configs/malli&quot;]}</code></z><z id="t1634212256" t="Ben Sless Woohoo!"><y>#</y><d>2021-10-14</d><h>11:50</h><r>Ben Sless</r>Woohoo!</z><z id="t1634212280" t="Ben Sless Thank you 🙂"><y>#</y><d>2021-10-14</d><h>11:51</h><r>Ben Sless</r>Thank you <b>🙂</b></z><z id="t1634562925" t="andre.richards Thanks, this solved it for me as well 🙏 A question on clj-kondo/malli integration: when a function takes a map as parameter, clj-kondo is highlighting if the passed parameter is not a map, but it does not highlight if the value under a certain key is not correct type. Is this expected, and a hard limitation of clj-kondo/malli, or something that just has not been done (because it will require a lot of work, etc.). I just want to know where to set my expection. 😁"><y>#</y><d>2021-10-18</d><h>13:15</h><r>andre.richards</r>Thanks, this solved it for me as well <b>🙏</b>

A question on clj-kondo/malli integration: when a function takes a map as parameter, clj-kondo is highlighting if the passed parameter is not a map, but it does not highlight if the value under a certain key is not correct type. Is this expected, and a hard limitation of clj-kondo/malli, or something that just has not been done (because it will require a lot of work, etc.). I just want to know where to set my expection. <b>😁</b></z><z id="t1634212931" t="jussi Hey, I ran into the following when converting a schema to PlantUML. (def value [:and {:description &quot;Non negative numeric value.&quot; :json-schema/example 780.56} number? [:&gt;= 0]]) (def simple-registry (merge (m/default-schemas) (mu/schemas) {:value value})) (def schema-merged (mu/closed-schema (m/schema [:merge [:map [:name string?] [:age value]] [:map [:address string?]]] {:registry simple-registry}))) (comment (plantuml/transform schema-merged)) Now, trying to render PlantUML results in :malli.core/invalid-schema {:schema :merge} . Does plantuml/transform support stuff outside malli.core ? The schema-merged above expands into following schema: [:merge [:map {:closed true} [:name string?] [:age [:and {:description &quot;Non negative numeric value.&quot;, :json-schema/example 780.56} number? [:&gt;= 0]]]] [:map {:closed true} [:address string?]]]"><y>#</y><d>2021-10-14</d><h>12:02</h><w>jussi</w>Hey, I ran into the following when converting a schema to PlantUML.

<pre>(def value
  [:and
   {:description &quot;Non negative numeric value.&quot;
    :json-schema/example 780.56}
   number?
   [:&gt;= 0]])

(def simple-registry
  (merge
   (m/default-schemas)
   (mu/schemas)
   {:value value}))

(def schema-merged
  (mu/closed-schema
   (m/schema
    [:merge
     [:map 
      [:name string?]
      [:age value]]
     [:map
      [:address string?]]]
    {:registry simple-registry})))

(comment
  (plantuml/transform schema-merged))</pre>
Now, trying to render PlantUML results in <code>:malli.core/invalid-schema {:schema :merge}</code>.

Does <code>plantuml/transform</code> support stuff outside <code>malli.core</code>?

The <code>schema-merged</code> above expands into following schema:

<pre>[:merge [:map {:closed true} [:name string?] [:age [:and {:description &quot;Non negative numeric value.&quot;, :json-schema/example 780.56} number? [:&gt;= 0]]]] [:map {:closed true} [:address string?]]]</pre></z><z id="t1634241091" t="dvingo Not sure why the plantuml transform doesn&apos;t do this but if you deref the schema, it works: (plantuml/transform (m/deref schema-merged))"><y>#</y><d>2021-10-14</d><h>19:51</h><w>dvingo</w>Not sure why the plantuml transform doesn&apos;t do this but if you deref the schema, it works:
<pre>(plantuml/transform (m/deref schema-merged))</pre></z><z id="t1634245859" t="jussi Thanks! Missed that completely 🙈"><y>#</y><d>2021-10-14</d><h>21:10</h><r>jussi</r>Thanks! Missed that completely <b>🙈</b></z><z id="t1634246991" t="Ivan Fedorov What’s the replacement for a set as a predicate in malli? Analogue of (s/def :spec1 #{:a :b}) Is it [:or [:= :a] [:= :b]] ?"><y>#</y><d>2021-10-14</d><h>21:29</h><w>Ivan Fedorov</w>What’s the replacement for a set as a predicate in malli?
Analogue of <code>(s/def :spec1 #{:a :b})</code>
Is it
<code>[:or [:= :a] [:= :b]]</code> ?</z><z id="t1634250382" t="schmee [:enum :a :b] :thumbsup:"><y>#</y><d>2021-10-14</d><h>22:26</h><r>schmee</r><code>[:enum :a :b]</code> <b>:thumbsup:</b></z><z id="t1634251814" t="Ivan Fedorov right! danks [:attrs {:href &quot;/_/_/users/U3L6TFEJF&quot;}]"><y>#</y><d>2021-10-14</d><h>22:50</h><r>Ivan Fedorov</r>right! danks <a>@U3L6TFEJF</a></z><z id="t1634399261" t="chaos Hi, is it possible to restrict the range of values for integer predicates produced by the generator ? For example (malli.generator/generate [:int {:min 0 :max 6}]) reduces the range to [0,6], but (malli.generator/generate [int? {:min 0 :max 6}]) , where int? is an integer predicate, does not. My actual use case is with pos-int? . Thanks"><y>#</y><d>2021-10-16</d><h>15:47</h><w>chaos</w>Hi, is it possible to restrict the range of values for integer predicates produced by the generator ?

For example <code>(malli.generator/generate [:int {:min 0 :max 6}])</code> reduces the range to [0,6], but <code>(malli.generator/generate [int? {:min 0 :max 6}])</code> , where <code>int?</code> is an integer predicate, does not. My actual use case is with <code>pos-int?</code>. Thanks</z><z id="t1634399553" t="Ben Sless pos-int? is equivalent to [:int {:min 1}] Type schemas are more flexible than predicate schemas"><y>#</y><d>2021-10-16</d><h>15:52</h><r>Ben Sless</r>pos-int? is equivalent to [:int {:min 1}]
Type schemas are more flexible than predicate schemas</z><z id="t1634399604" t="Ben Sless You can then add upper boundary with no complications"><y>#</y><d>2021-10-16</d><h>15:53</h><r>Ben Sless</r>You can then add upper boundary with no complications</z><z id="t1634400265" t="chaos Excellent thanks! This is what I was looking for [:int {:min 0 :gen/max 10}] ; i.e. eq to nat-int? for validation and [0,10] for the generated range"><y>#</y><d>2021-10-16</d><h>16:04</h><r>chaos</r>Excellent thanks!  This is what I was looking for <code>[:int {:min 0 :gen/max 10}]</code> ; i.e. eq to nat-int? for validation and [0,10] for the generated range</z><z id="t1634401042" t="Ben Sless yep"><y>#</y><d>2021-10-16</d><h>16:17</h><r>Ben Sless</r>yep</z><z id="t1634401065" t="Ben Sless Where types are concerned, I prefer the type schemas (with keywords) and not the predicate schemas"><y>#</y><d>2021-10-16</d><h>16:17</h><r>Ben Sless</r>Where types are concerned, I prefer the type schemas (with keywords) and not the predicate schemas</z><z id="t1634401096" t="Ben Sless You use case is a perfect example why"><y>#</y><d>2021-10-16</d><h>16:18</h><r>Ben Sless</r>You use case is a perfect example why</z><z id="t1634399434" t="Ben Sless When transforming multi to json schema, how about using implications? https://json-schema.org/understanding-json-schema/reference/conditionals.html#id7"><y>#</y><d>2021-10-16</d><h>15:50</h><w>Ben Sless</w>When transforming multi to json schema, how about using implications?
<a href="https://json-schema.org/understanding-json-schema/reference/conditionals.html#id7" target="_blank">https://json-schema.org/understanding-json-schema/reference/conditionals.html#id7</a></z></g><g id="s19"><z id="t1634417965" t="chaos Is there a generator option to produce distinct values for a vector? for example the following schema generated some values more than once (-&gt;&gt; [:vector {:min 400} string?] malli.generator/generate frequencies (filter (fn [[_ v]] (&gt; v 1)))) ;; =&gt; ([&quot;&quot; 20] [&quot;e&quot; 2] [&quot;7&quot; 2]) Thanks"><y>#</y><d>2021-10-16</d><h>20:59</h><w>chaos</w>Is there a generator option to  produce distinct values for a vector? for example the following  schema generated some values more than once

<pre>(-&gt;&gt; [:vector {:min 400} string?]
       malli.generator/generate 
       frequencies
       (filter (fn [[_ v]] (&gt; v 1))))
;; =&gt; ([&quot;&quot; 20] [&quot;e&quot; 2] [&quot;7&quot; 2])</pre>
Thanks</z><z id="t1634442344" t="Ben Sless Use a set generator then fmap vec"><y>#</y><d>2021-10-17</d><h>03:45</h><r>Ben Sless</r>Use a set generator then fmap vec</z><z id="t1634456562" t="chaos Great thanks! Although this has been a little bit of a mouthful it has done the trick: [:vector {:min 400 :gen/schema [:set {:min 10} string?] :gen/fmap vec} string?]"><y>#</y><d>2021-10-17</d><h>07:42</h><r>chaos</r>Great thanks! Although this has been a little bit of a mouthful it has done the trick:

<pre>[:vector {:min 400 
          :gen/schema [:set {:min 10} string?]
          :gen/fmap vec} 
         string?]</pre></z><z id="t1634456992" t="chaos (perhaps there should be a :gen/distinct option for collections? clojure.test.check.generators does seem to provide list-distinct and`vector-distinct` to this end)"><y>#</y><d>2021-10-17</d><h>07:49</h><r>chaos</r>(perhaps there should be a <code>:gen/distinct</code> option for collections? <code>clojure.test.check.generators</code> does seem to provide <code>list-distinct</code> and`vector-distinct` to this end)</z><z id="t1634504469" t="chaos This unfortunately does not scale very well, because I&apos;d need to repeat the vector predicate twice, one for :vector the other for the generator&apos;s schema, which could easily get out of sync for more complicated schemas, e.g. [:vector {:min 400 :gen/schema [:set {:min 10} [:map [:x int?] [:y string?]]] :gen/fmap vec } [:map [:x int?] [:y string?]]]"><y>#</y><d>2021-10-17</d><h>21:01</h><r>chaos</r>This unfortunately does not scale very well, because I&apos;d need to repeat the vector predicate twice, one for <code>:vector</code> the other for the generator&apos;s schema, which could easily get out of sync for more complicated schemas, e.g.
<pre>[:vector {:min 400
          :gen/schema [:set {:min 10} [:map [:x int?] [:y string?]]]
          :gen/fmap vec
         }
         [:map [:x int?] [:y string?]]]</pre></z><z id="t1634528723" t="Ben Sless At that point you might want to define your own type and use a registry, you could call it distinct vector. Why does it need to be a vector, btw? Why can&apos;t it be. a set?"><y>#</y><d>2021-10-18</d><h>03:45</h><r>Ben Sless</r>At that point you might want to define your own type and use a registry, you could call it distinct vector.
Why does it need to be a vector, btw? Why can&apos;t it be. a set?</z><z id="t1634576445" t="chaos Hi, it has to be a vector because this is how values are coming out from the data source. The distinct values are only needed by the generator to produce some specific values during testing only. I can&apos;t seem to create a custom type with -simple-schema for distinct-vector ... The syntax of the type looks to be in accordance with the section on the readme file, but it gives me a :malli.core/invalid-schema {:schema (#object[cljs$core$string_QMARK_])} error when I try to use it ... (let [vector-distinct (malli.core/-simple-schema (fn [_ schema] (let [schema (first schema)]) {:type :vector-distinct :pred vector? :type-properties {:gen/gen (clojure.test.check.generators/vector-distinct (malli.generator/generator schema))}}))] (-&gt; [vector-distinct {} string?] malli.generator/generate)) Thanks!"><y>#</y><d>2021-10-18</d><h>17:00</h><r>chaos</r>Hi, it has to be a vector because this is how values are coming out from the data source. The distinct values are only needed by the generator to produce some specific values during testing only.

I can&apos;t seem to create a custom type with <code>-simple-schema</code> for distinct-vector ... The syntax of the type looks to be in accordance with the section on the readme file, but  it gives me a <code>:malli.core/invalid-schema {:schema (#object[cljs$core$string_QMARK_])}</code> error when I try to use it ...

<pre>(let [vector-distinct
      (malli.core/-simple-schema
        (fn [_ schema]
          (let [schema (first schema)])
          {:type :vector-distinct
           :pred vector?
           :type-properties
           {:gen/gen (clojure.test.check.generators/vector-distinct (malli.generator/generator schema))}}))]
  (-&gt; [vector-distinct {} string?]
      malli.generator/generate))</pre>
Thanks!</z><z id="t1634581026" t="Ben Sless I think you want a variation on vector-of"><y>#</y><d>2021-10-18</d><h>18:17</h><r>Ben Sless</r>I think you want a variation on vector-of</z><z id="t1634581040" t="Ben Sless the schema itself is incorrect, not the generation"><y>#</y><d>2021-10-18</d><h>18:17</h><r>Ben Sless</r>the schema itself is incorrect, not the generation</z><z id="t1634584543" t="chaos sorry, not sure what you mean by &quot;a variation on vector-of&quot;; but I think I got it this time working, It appears I was missing the number of arguments accepted by the new type, in my case 1 (as in :min and :max ): (let [vector-distinct (malli.core/-simple-schema (fn [_ schema] (let [schema (first schema)] {:type ::vector-distinct :min 1 :max 1 :pred vector? :type-properties {:gen/gen (clojure.test.check.generators/vector-distinct (malli.generator/generator schema))}})))] (-&gt;&gt; [vector-distinct string?] malli.generator/generate)) Does this look sane or is it just too hacky?"><y>#</y><d>2021-10-18</d><h>19:15</h><r>chaos</r>sorry, not sure what you mean by &quot;a variation on vector-of&quot;; but I think I got it this time working, It appears I was missing the number of arguments accepted by the new type, in my case 1 (as in <code>:min</code> and <code>:max</code>):

<pre>(let [vector-distinct
        (malli.core/-simple-schema
         (fn [_ schema]
           (let [schema (first schema)]
             {:type ::vector-distinct
              :min 1
              :max 1
              :pred vector?
              :type-properties
              {:gen/gen (clojure.test.check.generators/vector-distinct (malli.generator/generator schema))}})))]
    (-&gt;&gt; [vector-distinct string?]
        malli.generator/generate))</pre>
Does this look sane or is it just too hacky?</z><z id="t1634624347" t="chaos Actually that is not complete because pred is not going to check the vector values for conformity. I will stick with the following hack which almost does what I want (the only glitch is that generated distinct values are likely to be less than :min ): [:vector {:min 400 :max 400 :gen/fmap #(into [] (set %))} string?]"><y>#</y><d>2021-10-19</d><h>06:19</h><r>chaos</r>Actually that is not complete because <code>pred</code> is not going to check the vector values for conformity. I will stick with the following hack which almost does what I want (the only glitch is that generated distinct values are likely to be less than <code>:min</code>):

<pre>[:vector {:min 400 :max 400
          :gen/fmap #(into [] (set %))} string?]</pre></z><z id="t1634626949" t="Ben Sless ah, you need a collection schema, that&apos;s it"><y>#</y><d>2021-10-19</d><h>07:02</h><r>Ben Sless</r>ah, you need a collection schema, that&apos;s it</z><z id="t1634566583" t="andre.richards The malli pretty printer (virhe) is failing when it tries to print a datomic db. It might not be a defect in malli/virhe (see details below), so is there a way to exclude certain fields from pretty printing as a workaround? I&apos;m starting malli.dev with (malli.dev/start! {:report (pretty/reporter)}) Take for example this function: (defn fetch-user &quot;Fetches a user by its entity `id`. If no entity is found, nil is returned.&quot; {:malli/schema [:=&gt; [:cat :int :any] [:maybe :map]]} [id db] ...) The db (second) parameter is defined as :any - I&apos;m not even interested in checking that it is a valid db right now, I just want to ensure the id is of valid type. When I call the function with a valid id (:int) and db : (fetch-user 96757023244461 db) , it works as expected. However when calling it with a string or anything else in the first position (`id`), it results in this: (fetch-user &quot;96757023244461&quot; (db/current)) Execution error at malli.dev.virhe.EdnPrinter/visit_set (virhe.cljc:80). Unable to convert: class datomic.core.btset.BTSet to Object[] i.e. it is not printing the malli error as it should, but instead it fails with the above. Passing anything else in the second argument, and still the (incorrect type) string in first argument, prints the malli error as expected: -- Schema Error --------------------------------------------------- Invalid function arguments: [&quot;96757023244461&quot; nil] Input Schema: [:cat :int :any] Errors: {:in [0], :message &quot;should be an integer&quot;, :path [0], :schema :int, :type nil, :value &quot;96757023244461&quot;} I have attached the stacktrace for when the error can not be pretty printed (i.e. when an actual datomic db is passed). Presumably it is traversing the db object&apos;s fields(?) and fails when it gets to the datomic.core.btset.BTSet and tries to convert it to an array. It&apos;s not clear to me why datomic&apos;s BTSet is failing at that point, and it might not be a defect in malli, but is there a way to exclude certain fields from pretty printing, in order to work around this issue?"><y>#</y><d>2021-10-18</d><h>14:16</h><w>andre.richards</w>The malli pretty printer (virhe) is failing when it tries to print a datomic db.

It might not be a defect in malli/virhe (see details below), so is there a way to exclude certain fields from pretty printing as a workaround?

I&apos;m starting malli.dev with
<pre>(malli.dev/start! {:report (pretty/reporter)})</pre>
Take for example this function:
<pre>(defn fetch-user
  &quot;Fetches a user by its entity `id`. If no entity is found, nil is returned.&quot;

  {:malli/schema
   [:=&gt; [:cat :int :any]
    [:maybe :map]]}

  [id db]

  ...)</pre>
The db (second) parameter is defined as :any - I&apos;m not even interested in checking that it is a valid db right now, I just want to ensure the id is of valid type.

When I call the function with a valid <code>id</code> (:int) and <code>db</code>: <code>(fetch-user 96757023244461 db)</code>, it works as expected.  However when calling it with a string or anything else in the first position (`id`), it results in this:
<pre>(fetch-user &quot;96757023244461&quot; (db/current))

Execution error at malli.dev.virhe.EdnPrinter/visit_set (virhe.cljc:80).
Unable to convert: class datomic.core.btset.BTSet to Object[]</pre>
i.e. it is not printing the malli error as it should, but instead it fails with the above.

Passing anything else in the second argument, and still the (incorrect type) string in first argument, prints the malli error as expected:
<pre>-- Schema Error ---------------------------------------------------

Invalid function arguments:

  [&quot;96757023244461&quot; nil]

Input Schema:

  [:cat :int :any]

Errors:

  {:in [0],
   :message &quot;should be an integer&quot;,
   :path [0],
   :schema :int,
   :type nil,
   :value &quot;96757023244461&quot;}</pre>

I have attached the stacktrace for when the error can not be pretty printed (i.e. when an actual datomic db is passed).

Presumably it is traversing the <code>db</code> object&apos;s fields(?) and fails when it gets to the <code>datomic.core.btset.BTSet</code> and tries to convert it to an array.

It&apos;s not clear to me why datomic&apos;s BTSet is failing at that point, and it might not be a defect in malli, but is there a way to exclude certain fields from pretty printing, in order to work around this issue?</z><z id="t1634572652" t="ikitommi oh, [malli.dev.virhe.EdnPrinter visit_set &quot;virhe.cljc&quot; 80] &lt;- the datomic.core.btset.BTSet is kinda like set, but not?"><y>#</y><d>2021-10-18</d><h>15:57</h><w>ikitommi</w>oh,  <code>[malli.dev.virhe.EdnPrinter visit_set &quot;virhe.cljc&quot; 80]</code> &lt;- the datomic.core.btset.BTSet is kinda like set, but not?</z><z id="t1634572906" t="andre.richards That&apos;s what it looks like, yeah"><y>#</y><d>2021-10-18</d><h>16:01</h><r>andre.richards</r>That&apos;s what it looks like, yeah</z><z id="t1634572703" t="ikitommi (visit-set [this x] (let [xs (sort-by identity (fn [a b] (arrangement.core/rank a b)) x)] (fipp.edn/pretty-coll this &quot;#{&quot; xs :line &quot;}&quot; fipp.visit/visit)))"><y>#</y><d>2021-10-18</d><h>15:58</h><w>ikitommi</w><pre>(visit-set [this x]
    (let [xs (sort-by identity (fn [a b] (arrangement.core/rank a b)) x)]
      (fipp.edn/pretty-coll this &quot;#{&quot; xs :line &quot;}&quot; fipp.visit/visit)))</pre></z><z id="t1634572794" t="ikitommi [:attrs {:href &quot;/_/_/users/U08AYNSSK&quot;}] if you can make that sort-by wotk with datomic.core.btset.BTSet without extra deps, PR most welcome"><y>#</y><d>2021-10-18</d><h>15:59</h><w>ikitommi</w><a>@andre.richards</a> if you can make that <code>sort-by</code> wotk with <code>datomic.core.btset.BTSet</code> without extra deps, PR most welcome</z><z id="t1634572933" t="andre.richards I will see what I can come up with"><y>#</y><d>2021-10-18</d><h>16:02</h><r>andre.richards</r>I will see what I can come up with</z><z id="t1634572984" t="andre.richards Will maybe ask on Datomic forum what is up with that BTSet"><y>#</y><d>2021-10-18</d><h>16:03</h><r>andre.richards</r>Will maybe ask on Datomic forum what is up with that BTSet</z><z id="t1634578930" t="dominicm Calling seq on your argument might work."><y>#</y><d>2021-10-18</d><h>17:42</h><w>dominicm</w>Calling <code>seq</code> on your argument might work.</z><z id="t1635767565" t="andre.richards This works. I will open an issue and a pull request."><y>#</y><d>2021-11-01</d><h>11:52</h><r>andre.richards</r>This works. I will open an issue and a pull request.</z><z id="t1634722289" t="ikitommi hi all. there is bunch of quality PRs being held in the queue, sorry. I’m working on with the malli internals (schema ast, lifecycle, providers, registries) and want to find a good design before merging anything big in. Will review and pull the queued PRs after that. Any small fixes welcome anytime."><y>#</y><d>2021-10-20</d><h>09:31</h><w>ikitommi</w>hi all. there is bunch of quality PRs being held in the queue, sorry. I’m working on with the malli internals (schema ast, lifecycle, providers, registries) and want to find a good design before merging anything big in. Will review and pull the queued PRs after that. Any small fixes welcome anytime.</z><z id="t1634722356" t="Ben Sless 👍"><y>#</y><d>2021-10-20</d><h>09:32</h><w>Ben Sless</w><b>👍</b></z><z id="t1634722377" t="Ben Sless Necroing a question I asked some time ago, any idea for a transformer which removes invalid keys?"><y>#</y><d>2021-10-20</d><h>09:32</h><w>Ben Sless</w>Necroing a question I asked some time ago, any idea for a transformer which removes invalid keys?</z><z id="t1634722388" t="Ben Sless (given that they&apos;re optional)"><y>#</y><d>2021-10-20</d><h>09:33</h><w>Ben Sless</w>(given that they&apos;re optional)</z><z id="t1634722472" t="ikitommi invalid… you could a) validate the keys when transforming or b) explain and remove based on that."><y>#</y><d>2021-10-20</d><h>09:34</h><w>ikitommi</w>invalid… you could a) validate the keys when transforming or b) explain and remove based on that.</z><z id="t1634723205" t="Ben Sless I think I can build (a), the transformer has access to the parent schema"><y>#</y><d>2021-10-20</d><h>09:46</h><r>Ben Sless</r>I think I can build (a), the transformer has access to the parent schema</z><z id="t1634723241" t="Ben Sless Also reminds me, I think an interleaved transformer/validator will be good"><y>#</y><d>2021-10-20</d><h>09:47</h><r>Ben Sless</r>Also reminds me, I think an interleaved transformer/validator will be good</z><z id="t1634723287" t="ikitommi doing both in a single pipeline?"><y>#</y><d>2021-10-20</d><h>09:48</h><r>ikitommi</r>doing both in a single pipeline?</z><z id="t1634723349" t="Ben Sless yes"><y>#</y><d>2021-10-20</d><h>09:49</h><r>Ben Sless</r>yes</z><z id="t1634723369" t="Ben Sless The decoder can end up doing lots of allocations"><y>#</y><d>2021-10-20</d><h>09:49</h><r>Ben Sless</r>The decoder can end up doing lots of allocations</z><z id="t1634723382" t="Ben Sless you can short circuit on it"><y>#</y><d>2021-10-20</d><h>09:49</h><r>Ben Sless</r>you can short circuit on it</z><z id="t1634723402" t="ikitommi but, you can’t validate before it’s transformed, right?"><y>#</y><d>2021-10-20</d><h>09:50</h><r>ikitommi</r>but, you can’t validate before it’s transformed, right?</z><z id="t1634723412" t="Ben Sless right"><y>#</y><d>2021-10-20</d><h>09:50</h><r>Ben Sless</r>right</z><z id="t1634723424" t="ikitommi so, it would need to happen on :leave -&gt; it’s all transformed already?"><y>#</y><d>2021-10-20</d><h>09:50</h><r>ikitommi</r>so, it would need to happen on <code>:leave</code> -&gt; it’s all transformed already?</z><z id="t1634723427" t="Ben Sless you&apos;ll have something like a coercer which transforms and validates in one pass"><y>#</y><d>2021-10-20</d><h>09:50</h><r>Ben Sless</r>you&apos;ll have something like a <code>coercer</code> which transforms and validates in one pass</z><z id="t1634723437" t="Ben Sless think so"><y>#</y><d>2021-10-20</d><h>09:50</h><r>Ben Sless</r>think so</z><z id="t1634723467" t="ikitommi how would it allocate less if that happens after the transformation?"><y>#</y><d>2021-10-20</d><h>09:51</h><r>ikitommi</r>how would it allocate less if that happens after the transformation?</z><z id="t1634723491" t="ikitommi wouldn’t all the nested childs get re-validated when you are leaving them?"><y>#</y><d>2021-10-20</d><h>09:51</h><r>ikitommi</r>wouldn’t all the nested childs get re-validated when you are leaving them?</z><z id="t1634723532" t="ikitommi [:map [:a [:map [:b [:map [:c [:map [:d :boolean]]]]]"><y>#</y><d>2021-10-20</d><h>09:52</h><r>ikitommi</r><pre>[:map [:a [:map [:b [:map [:c [:map [:d :boolean]]]]]</pre></z><z id="t1634723633" t="ikitommi unless the walking knows which childs are already transformed &amp; validated."><y>#</y><d>2021-10-20</d><h>09:53</h><r>ikitommi</r>unless the walking knows which childs are already transformed &amp; validated.</z><z id="t1634723661" t="Ben Sless hm, generally, you have no way of knowing if you need to re-walk the children"><y>#</y><d>2021-10-20</d><h>09:54</h><r>Ben Sless</r>hm, generally, you have no way of knowing if you need to re-walk the children</z><z id="t1634723673" t="Ben Sless especially if you do interesting transformations"><y>#</y><d>2021-10-20</d><h>09:54</h><r>Ben Sless</r>especially if you do interesting transformations</z><z id="t1634723776" t="ikitommi my assumption is that having validation and transformation as separate steps is the fastest way to do it. 2 simple sweeps instead of one (more complex) sweep."><y>#</y><d>2021-10-20</d><h>09:56</h><r>ikitommi</r>my assumption is that having validation and transformation as separate steps is the fastest way to do it. 2 simple sweeps instead of one (more complex) sweep.</z><z id="t1634723844" t="ikitommi but, all ears if there is a better way."><y>#</y><d>2021-10-20</d><h>09:57</h><r>ikitommi</r>but, all ears if there is a better way.</z><z id="t1634723952" t="ikitommi originally, i though of doing all the workers using just -walk . there would be walker to create a validator, decoder etc. but as all schemas should have all of those and as performance was a one of the primary goals - they got separate (protocol) methods."><y>#</y><d>2021-10-20</d><h>09:59</h><r>ikitommi</r>originally, i though of doing all the workers using just <code>-walk</code>. there would be walker to create a validator, decoder etc. but as all schemas should have all of those and as performance was a one of the primary goals - they got separate (protocol) methods.</z><z id="t1634724010" t="ikitommi the one walker would have allowed to compose a chain of validate + transform in an easier way, I think."><y>#</y><d>2021-10-20</d><h>10:00</h><r>ikitommi</r>the one walker would have allowed to compose a chain of validate + transform in an easier way, I think.</z><z id="t1634724260" t="Ben Sless Figured out how to strip invalid optional keys, feel free to add it to tips, after some beautifying (defn strip-invalid-optional-keys-transformer ([] (let [transform {:compile (fn [schema _] (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema)) fs (map (fn [[k v]] (let [validator (m/validator v)] (fn [m] (if-let [e&apos; (find m k)] (let [v&apos; (val e&apos;)] (if (validator v&apos;) m (dissoc m k))) m)))) entries)] (reduce comp fs)))}] (mt/transformer {:decoders {:map transform} :encoders {:map transform}})))) "><y>#</y><d>2021-10-20</d><h>10:04</h><r>Ben Sless</r>Figured out how to strip invalid optional keys, feel free to add it to tips, after some beautifying
<pre>(defn strip-invalid-optional-keys-transformer
  ([]
   (let [transform
         {:compile
          (fn [schema _]
            (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema))
                  fs (map (fn [[k v]]
                            (let [validator (m/validator v)]
                              (fn [m]
                                (if-let [e&apos; (find m k)]
                                  (let [v&apos; (val e&apos;)]
                                    (if (validator v&apos;)
                                      m
                                      (dissoc m k)))
                                  m))))
                          entries)]
              (reduce comp fs)))}]
     (mt/transformer
      {:decoders {:map transform}
       :encoders {:map transform}}))))</pre>
</z><z id="t1634724282" t="Ben Sless (m/decode [:map [:a {:optional true} int?] [:b {:optional true} int?]] {:a 1 :b 2.2} strip-invalid-optional-keys-transformer) "><y>#</y><d>2021-10-20</d><h>10:04</h><r>Ben Sless</r><pre>(m/decode [:map [:a {:optional true} int?] [:b {:optional true} int?]] {:a 1 :b 2.2} strip-invalid-optional-keys-transformer)</pre>
</z><z id="t1634724337" t="ikitommi 👍"><y>#</y><d>2021-10-20</d><h>10:05</h><r>ikitommi</r><b>👍</b></z><z id="t1634722490" t="ikitommi a) might be cleaner (and faster)?"><y>#</y><d>2021-10-20</d><h>09:34</h><w>ikitommi</w>a) might be cleaner (and faster)?</z><z id="t1634722560" t="ikitommi :or does also validation on transformation, as it needs to find the branch, which is valid after transformation."><y>#</y><d>2021-10-20</d><h>09:36</h><w>ikitommi</w><code>:or</code> does also validation on transformation, as it needs to find the branch, which is valid after transformation.</z><z id="t1634722705" t="ikitommi spike about caching computations (`-form`, -validator etc) with schemas: (def schema (m/schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]])) ;; 1.5µs -&gt; 11ns (130x) (p/bench (m/validator schema) ;; 1.7µs -&gt; 64ns (25x) (p/bench (m/validate schema {:x true, :z {:x true}})) ; =&gt; true"><y>#</y><d>2021-10-20</d><h>09:38</h><w>ikitommi</w>spike about caching computations (`-form`,  <code>-validator</code> etc) with schemas:
<pre>(def schema
  (m/schema
   [:map
    [:x boolean?]
    [:y {:optional true} int?]
    [:z [:map
         [:x boolean?]
         [:y {:optional true} int?]]]]))

;; 1.5µs -&gt; 11ns (130x)
(p/bench
 (m/validator schema)

;; 1.7µs -&gt; 64ns (25x)
(p/bench
 (m/validate schema {:x true, :z {:x true}})) ; =&gt; true</pre></z><z id="t1634722874" t="ikitommi there is the initial cost of creating the thing, but just once opposed to every call. the results are cached with the actual schema instance, so when the schema instance is not needed, the cached results will also be GCd, so not leaking memory."><y>#</y><d>2021-10-20</d><h>09:41</h><w>ikitommi</w>there is the initial cost of creating the thing, but just once opposed to every call. the results are cached with the actual schema instance, so when the schema instance is not needed, the cached results will also be GCd, so not leaking memory.</z><z id="t1634722919" t="ikitommi using computation directly is still fastest, but not much: ;; 55ns (let [validate (m/validator schema)] (p/bench (validate {:x true, :z {:x true}})))"><y>#</y><d>2021-10-20</d><h>09:41</h><w>ikitommi</w>using computation directly is still fastest, but not much:
<pre>;; 55ns
(let [validate (m/validator schema)]
  (p/bench
   (validate {:x true, :z {:x true}})))</pre></z><z id="t1634732860" t="Ben Sless Please disregard last message, user error"><y>#</y><d>2021-10-20</d><h>12:27</h><w>Ben Sless</w>Please disregard last message, user error</z><z id="t1634831636" t="Ivan Fedorov Heyy, do you already have hiccup / reagent form generation on malli?"><y>#</y><d>2021-10-21</d><h>15:53</h><w>Ivan Fedorov</w>Heyy, do you already have hiccup / reagent form generation on malli?</z><z id="t1634842745" t="escherize Hi Ivan, depending on what you mean, I took an experimental crack at something like that a while back. it’s really buggy but you can see it live here: https://escherize.com/w/data-desk/"><y>#</y><d>2021-10-21</d><h>18:59</h><w>escherize</w>Hi Ivan, depending on what you mean, I took an experimental crack at something like that a while back. it’s really buggy but you can see it live here: <a href="https://escherize.com/w/data-desk/" target="_blank">https://escherize.com/w/data-desk/</a></z><z id="t1634843870" t="Ivan Fedorov oh niccceee!"><y>#</y><d>2021-10-21</d><h>19:17</h><r>Ivan Fedorov</r>oh niccceee!</z><z id="t1634843888" t="Ivan Fedorov open source?"><y>#</y><d>2021-10-21</d><h>19:18</h><r>Ivan Fedorov</r>open source?</z><z id="t1634844221" t="Ivan Fedorov Found it! thanks a lot!"><y>#</y><d>2021-10-21</d><h>19:23</h><r>Ivan Fedorov</r>Found it! thanks a lot!</z><z id="t1634896231" t="ikitommi looks great!"><y>#</y><d>2021-10-22</d><h>09:50</h><r>ikitommi</r>looks great!</z><z id="t1634842761" t="escherize [:map [:a-single-int int?] [:a-single-string string?] [:a-single-bool boolean?] [:int-vekdor [:vector int?]] [:string-vekdor [:vector string?]] [:bool-vekdor [:vector boolean?]] [:map-vekdor [:vector [:map [:a-single-int int?] [:a-single-string string?] [:a-single-bool boolean?] [:int-vekdor [:vector int?]] [:string-vekdor [:vector string?]] [:bool-vekdor [:vector boolean?]]]]]]"><y>#</y><d>2021-10-21</d><h>18:59</h><w>escherize</w><pre>[:map [:a-single-int int?]
      [:a-single-string string?]
      [:a-single-bool boolean?]
      [:int-vekdor [:vector int?]]
      [:string-vekdor [:vector string?]]
      [:bool-vekdor [:vector boolean?]]
      [:map-vekdor [:vector [:map [:a-single-int int?]
                                  [:a-single-string string?]
                                  [:a-single-bool boolean?]
                                  [:int-vekdor [:vector int?]]
                                  [:string-vekdor [:vector string?]]
                                  [:bool-vekdor [:vector boolean?]]]]]]</pre></z><z id="t1634842789" t="escherize if you paste that into the box on top, on blur the page should change into a ui to generate data that matches that schema"><y>#</y><d>2021-10-21</d><h>18:59</h><w>escherize</w>if you paste that into the box on top, on blur the page should change into a ui to generate data that matches that schema</z><z id="t1634847539" t="Andrés Rodríguez Is there a transformer to modify a single specific value based on its key path?"><y>#</y><d>2021-10-21</d><h>20:18</h><w>Andrés Rodríguez</w>Is there a transformer to modify a single specific value based on its key path?</z><z id="t1634896215" t="ikitommi [:attrs {:href &quot;/_/_/users/U02FU034U15&quot;}] sure, you could 1. put a transformer into top-level schema using schema properties as do update-in to the value 2. m/walk the schema and add the paths as schema properties to each schema. With this + :compile in transformer, you can select the schemas that need to changed at transformer creation time. There is malli.util.subschemas which could be looked as example imp how to find paths for each (nested) schema element"><y>#</y><d>2021-10-22</d><h>09:50</h><w>ikitommi</w><a>@hello525</a> sure, you could
1. put a transformer into top-level schema using schema properties as do <code>update-in</code> to the value
2. <code>m/walk</code> the schema and add the paths as schema properties to each schema.  With this + <code>:compile</code> in transformer, you can select the schemas that need to changed at transformer creation time. There is <code>malli.util.subschemas</code> which could be looked as example imp how to find paths for each (nested) schema element</z><z id="t1634903764" t="martinklepsch Is there a function like validate that will throw instead of returning a value?"><y>#</y><d>2021-10-22</d><h>11:56</h><w>martinklepsch</w>Is there a function like <code>validate</code> that will throw instead of returning a value?</z><z id="t1634904937" t="ikitommi at the moment, no. If that would he added, there would be a reason to add throwing validator , explain , explainer , parse , parser , transform , transformer too"><y>#</y><d>2021-10-22</d><h>12:15</h><r>ikitommi</r>at the moment, no. If that would he added, there would be a reason to add throwing <code>validator</code>, <code>explain</code>, <code>explainer</code>, <code>parse</code>, <code>parser</code>, <code>transform</code>, <code>transformer</code> too</z><z id="t1634909642" t="martinklepsch Cool, it’s fine really, just wanted to check 🙂"><y>#</y><d>2021-10-22</d><h>13:34</h><r>martinklepsch</r>Cool, it’s fine really, just wanted to check <b>🙂</b></z><z id="t1634911599" t="Karol Wójcik However you can create such function yourself 😄"><y>#</y><d>2021-10-22</d><h>14:06</h><r>Karol Wójcik</r>However you can create such function yourself <b>😄</b></z><z id="t1634911670" t="Karol Wójcik Something like: (defn- explain! [aschema x fn-name] (when-let [info (m/explain aschema x)] (when (or cfg/BROWSER? cfg/TEST_ENV?) (throw (ex-info &quot;[Malli] Schema does not match the argument&quot; {:type :malli-error :x (form-&gt;pprint-str x 3) :fn-name fn-name :info (form-&gt;pprint-str (me/humanize info) 3) :schema-name (schema-name aschema) :schema-doc (schema-doc aschema) :schema (schema-&gt;form-pprint-str (schema-form aschema))})))))"><y>#</y><d>2021-10-22</d><h>14:07</h><r>Karol Wójcik</r>Something like:
<pre>(defn- explain!
     [aschema x fn-name]
     (when-let [info (m/explain aschema x)]
       (when (or cfg/BROWSER? cfg/TEST_ENV?)
         (throw (ex-info &quot;[Malli] Schema does not match the argument&quot;
                         {:type :malli-error
                          :x (form-&gt;pprint-str x 3)
                          :fn-name fn-name
                          :info (form-&gt;pprint-str (me/humanize info) 3)
                          :schema-name (schema-name aschema)
                          :schema-doc (schema-doc aschema)
                          :schema (schema-&gt;form-pprint-str (schema-form aschema))})))))</pre></z><z id="t1634913245" t="ikitommi some perf numbers 0.6.1 vs 0.7.0 (unreleased): (def ?schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]]) ;; 44µs -&gt; 2.9µs (15x) (p/bench (m/schema ?schema)) ;; 240ns (180x, parses entries when actually needed) (p/bench (m/schema ?schema {::m/lazy-entries true})) (def schema (m/schema ?schema)) ;; 1.7µs -&gt; 64ns (25x) (p/bench (m/validate schema {:x true, :z {:x true}}))"><y>#</y><d>2021-10-22</d><h>14:34</h><w>ikitommi</w>some perf numbers 0.6.1 vs 0.7.0 (unreleased):
<pre>(def ?schema
  [:map
   [:x boolean?]
   [:y {:optional true} int?]
   [:z [:map
        [:x boolean?]
        [:y {:optional true} int?]]]])

;; 44µs -&gt; 2.9µs (15x)
(p/bench (m/schema ?schema))

;; 240ns (180x, parses entries when actually needed)
(p/bench (m/schema ?schema {::m/lazy-entries true}))

(def schema (m/schema ?schema))

;; 1.7µs -&gt; 64ns (25x)
(p/bench (m/validate schema {:x true, :z {:x true}}))</pre></z><z id="t1635153664" t="Ben Sless how should I compile a transformer which I want to operate only on leave?"><y>#</y><d>2021-10-25</d><h>09:21</h><w>Ben Sless</w>how should I compile a transformer which I want to operate only on leave?</z><z id="t1635161231" t="Ben Sless It&apos;s pretty terrible but it works. Anything here a bad idea? (defn -strip-invalid-optional-keys-transformer [schema _] (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema)) fs (map (fn [[k v]] (let [validator (m/validator v)] (fn [m] (if-let [e&apos; (find m k)] (let [v&apos; (val e&apos;)] (if (validator v&apos;) m (dissoc m k))) m)))) entries)] (reduce comp fs))) (def strip-invalid-optional-keys-transformer (let [transform {:compile (fn [schema _] {:leave -strip-invalid-optional-keys-transformer})} encoders {:map transform}] (mt/transformer {:decoders encoders :encoders encoders})))"><y>#</y><d>2021-10-25</d><h>11:27</h><r>Ben Sless</r>It&apos;s pretty terrible but it works. Anything here a bad idea?
<pre>(defn -strip-invalid-optional-keys-transformer
  [schema _]
  (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema))
        fs (map (fn [[k v]]
                  (let [validator (m/validator v)]
                    (fn [m]
                      (if-let [e&apos; (find m k)]
                        (let [v&apos; (val e&apos;)]
                          (if (validator v&apos;)
                            m
                            (dissoc m k)))
                        m))))
                entries)]
    (reduce comp fs)))

(def strip-invalid-optional-keys-transformer
  (let [transform {:compile
                   (fn [schema _]
                     {:leave -strip-invalid-optional-keys-transformer})}
        encoders {:map transform}]
    (mt/transformer
     {:decoders encoders
      :encoders encoders})))</pre></z><z id="t1635180669" t="ikitommi with a quick look, looks good. the runtime is bare minimum, everything possible has been pushed to creation time."><y>#</y><d>2021-10-25</d><h>16:51</h><r>ikitommi</r>with a quick look, looks good. the runtime is bare minimum, everything possible has been pushed to creation time.</z><z id="t1635180683" t="ikitommi but, should the encoding happen at enter?"><y>#</y><d>2021-10-25</d><h>16:51</h><r>ikitommi</r>but, should the encoding happen at enter?</z><z id="t1635180727" t="ikitommi e.g. you have valid value, after encoding, the keys could be different, (e.g. stringified) so the transforming functions misses all the keys."><y>#</y><d>2021-10-25</d><h>16:52</h><r>ikitommi</r>e.g. you have valid value, after encoding, the keys could be different, (e.g. stringified) so the transforming functions misses all the keys.</z><z id="t1635187798" t="Ben Sless you&apos;re correct, I didn&apos;t consider the encode case"><y>#</y><d>2021-10-25</d><h>18:49</h><r>Ben Sless</r>you&apos;re correct, I didn&apos;t consider the encode case</z><z id="t1635187821" t="Ben Sless I must say the order where things happen with regards to transformers compilation was very hard to follow 😞"><y>#</y><d>2021-10-25</d><h>18:50</h><r>Ben Sless</r>I must say the order where things happen with regards to transformers compilation was very hard to follow <b>😞</b></z><z id="t1635161231" t="Ben Sless It&apos;s pretty terrible but it works. Anything here a bad idea? (defn -strip-invalid-optional-keys-transformer [schema _] (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema)) fs (map (fn [[k v]] (let [validator (m/validator v)] (fn [m] (if-let [e&apos; (find m k)] (let [v&apos; (val e&apos;)] (if (validator v&apos;) m (dissoc m k))) m)))) entries)] (reduce comp fs))) (def strip-invalid-optional-keys-transformer (let [transform {:compile (fn [schema _] {:leave -strip-invalid-optional-keys-transformer})} encoders {:map transform}] (mt/transformer {:decoders encoders :encoders encoders})))"><y>#</y><d>2021-10-25</d><h>11:27</h><w>Ben Sless</w>It&apos;s pretty terrible but it works. Anything here a bad idea?
<pre>(defn -strip-invalid-optional-keys-transformer
  [schema _]
  (let [entries (filter #(:optional (m/properties (second %))) (m/entries schema))
        fs (map (fn [[k v]]
                  (let [validator (m/validator v)]
                    (fn [m]
                      (if-let [e&apos; (find m k)]
                        (let [v&apos; (val e&apos;)]
                          (if (validator v&apos;)
                            m
                            (dissoc m k)))
                        m))))
                entries)]
    (reduce comp fs)))

(def strip-invalid-optional-keys-transformer
  (let [transform {:compile
                   (fn [schema _]
                     {:leave -strip-invalid-optional-keys-transformer})}
        encoders {:map transform}]
    (mt/transformer
     {:decoders encoders
      :encoders encoders})))</pre></z><z id="t1635176226" t="Ben Sless It seems that most times where relations about map keys are requires by users it is to specify mutual exclusion. Could it be worth it to add a mutex property which takes a collection of keys which are mutually exclusive?"><y>#</y><d>2021-10-25</d><h>15:37</h><w>Ben Sless</w>It seems that most times where relations about map keys are requires by users it is to specify mutual exclusion. Could it be worth it to add a mutex property which takes a collection of keys which are mutually exclusive?</z><z id="t1635180419" t="ikitommi woudn’t the key-relations solve that? havan’t had time to give that much though, but agree something should be there in the core."><y>#</y><d>2021-10-25</d><h>16:46</h><w>ikitommi</w>woudn’t the key-relations solve that? havan’t had time to give that much though, but agree something should be there in the core.</z><z id="t1635187748" t="Ben Sless Getting the key-relations to work correctly and with good performance will be lots of work which I don&apos;t know when I&apos;ll get to. Adding :mutex [[:a :b]] can be done in a couple of hours"><y>#</y><d>2021-10-25</d><h>18:49</h><r>Ben Sless</r>Getting the key-relations to work correctly and with good performance will be lots of work which I don&apos;t know when I&apos;ll get to. Adding <code>:mutex [[:a :b]]</code> can be done in a couple of hours</z><z id="t1635264765" t="Ben Sless FYI regarding JSON schema, might be worth to chime in https://github.com/json-schema-org/community/discussions/70"><y>#</y><d>2021-10-26</d><h>16:12</h><w>Ben Sless</w>FYI regarding JSON schema, might be worth to chime in <a href="https://github.com/json-schema-org/community/discussions/70" target="_blank">https://github.com/json-schema-org/community/discussions/70</a></z><z id="t1635338922" t="ikitommi looks interesting"><y>#</y><d>2021-10-27</d><h>12:48</h><r>ikitommi</r>looks interesting</z><z id="t1635338928" t="ikitommi thanks for sharing."><y>#</y><d>2021-10-27</d><h>12:48</h><r>ikitommi</r>thanks for sharing.</z><z id="t1635339080" t="Ben Sless Might be a good idea to join their slack, too. Maybe spec and malli can give them ideas"><y>#</y><d>2021-10-27</d><h>12:51</h><r>Ben Sless</r>Might be a good idea to join their slack, too. Maybe spec and malli can give them ideas</z><z id="t1635339097" t="ikitommi 👍"><y>#</y><d>2021-10-27</d><h>12:51</h><r>ikitommi</r><b>👍</b></z><z id="t1635338670" t="Ivan Fedorov Has anyone seen malli to datomic schema translation projects?"><y>#</y><d>2021-10-27</d><h>12:44</h><w>Ivan Fedorov</w>Has anyone seen malli to datomic schema translation projects?</z><z id="t1635341468" t="winsome There was a pretty good talk about using malli for this from summer 2020, I think."><y>#</y><d>2021-10-27</d><h>13:31</h><r>winsome</r>There was a pretty good talk about using malli for this from summer 2020, I think.</z><z id="t1635341471" t="winsome https://www.youtube.com/watch?v=ww9yR_rbgQs"><y>#</y><d>2021-10-27</d><h>13:31</h><r>winsome</r><a href="https://www.youtube.com/watch?v=ww9yR_rbgQs" target="_blank">https://www.youtube.com/watch?v=ww9yR_rbgQs</a></z><z id="t1635341511" t="winsome It&apos;s not just malli-&gt;datomic, but IIRC there&apos;s enough information here to figure it out."><y>#</y><d>2021-10-27</d><h>13:31</h><r>winsome</r>It&apos;s not just malli-&gt;datomic, but IIRC there&apos;s enough information here to figure it out.</z><z id="t1635341718" t="Ivan Fedorov [:attrs {:href &quot;/_/_/users/U028BUU1P3R&quot;}] talk is awesome, thanks! Is there any underlying open source?"><y>#</y><d>2021-10-27</d><h>13:35</h><r>Ivan Fedorov</r><a>@U028BUU1P3R</a> talk is awesome, thanks! Is there any underlying open source?</z><z id="t1635341775" t="Ivan Fedorov I have the experience and the will to write such generator, a question is if I’ll be duplicating someone’s efforts"><y>#</y><d>2021-10-27</d><h>13:36</h><r>Ivan Fedorov</r>I have the experience and the will to write such generator, a question is if I’ll be duplicating someone’s efforts</z><z id="t1635342802" t="winsome I don&apos;t think there is any source shared from this talk, but I was able to get something similar working myself but with datahike. I ran into some trouble getting the described &quot;ref&quot; system working, but even so I was able to get a pretty decent result."><y>#</y><d>2021-10-27</d><h>13:53</h><r>winsome</r>I don&apos;t think there is any source shared from this talk, but I was able to get something similar working myself but with datahike. I ran into some trouble getting the described &quot;ref&quot; system working, but even so I was able to get a pretty decent result.</z><z id="t1635356860" t="pithyless Not sure how much is covered, but there has been some work done for eql and specs: https://github.com/dvingo/malli-code-gen"><y>#</y><d>2021-10-27</d><h>17:47</h><r>pithyless</r>Not sure how much is covered, but there has been some work done for eql and specs: <a href="https://github.com/dvingo/malli-code-gen" target="_blank">https://github.com/dvingo/malli-code-gen</a></z><z id="t1635703604" t="ikitommi I guess everyone is bored on the benchmarks, but updating docs, added plumatic schema to the benchmark comparison. The code looks legit :thinking_face: (def data {:x &quot;true&quot;, :y &quot;1&quot;, :z &quot;kikka&quot;}) (def expexted {:x true, :y 1, :z &quot;kikka&quot;}) (spec/def ::x boolean?) (spec/def ::y int?) (spec/def ::z string?) ;; clojure.spec 19µs (let [spec (spec/keys :req-un [::x ::z] :opt-un [::y]) transform #(st/coerce spec % st/string-transformer)] (assert (= expexted (transform data))) (cc/quick-bench (transform data))) ;; plumatic schema 2.2µs (let [schema {:x schema/Bool (schema/optional-key :y) schema/Int :z schema/Str} transform (sc/coercer schema sc/string-coercion-matcher)] (assert (= expexted (transform data))) (cc/quick-bench (transform data))) ;; idiomatic clojure 290ns (let [transform (fn [{:keys [x y] :as m}] (cond-&gt; m (string? x) (update :x #(Boolean/parseBoolean %)) (string? y) (update :y #(Long/parseLong %))))] (assert (= expexted (transform data))) (cc/quick-bench (transform data))) ;; malli 72ns (let [schema [:map [:x :boolean] [:y {:optional true} int?] [:z string?]] transform (m/decoder schema (mt/string-transformer))] (assert (= expexted (transform data))) (cc/quick-bench (transform data)))"><y>#</y><d>2021-10-31</d><h>18:06</h><w>ikitommi</w>I guess everyone is bored on the benchmarks, but updating docs, added plumatic schema to the benchmark comparison. The code looks legit <b>:thinking_face:</b>
<pre>(def data {:x &quot;true&quot;, :y &quot;1&quot;, :z &quot;kikka&quot;})
(def expexted {:x true, :y 1, :z &quot;kikka&quot;})

(spec/def ::x boolean?)
(spec/def ::y int?)
(spec/def ::z string?)

;; clojure.spec 19µs
(let [spec (spec/keys :req-un [::x ::z] :opt-un [::y])
      transform #(st/coerce spec % st/string-transformer)]
  (assert (= expexted (transform data)))
  (cc/quick-bench (transform data)))

;; plumatic schema 2.2µs
(let [schema {:x schema/Bool
              (schema/optional-key :y) schema/Int
              :z schema/Str}
      transform (sc/coercer schema sc/string-coercion-matcher)]
  (assert (= expexted (transform data)))
  (cc/quick-bench (transform data)))

;; idiomatic clojure 290ns
(let [transform (fn [{:keys [x y] :as m}]
                  (cond-&gt; m
                    (string? x) (update :x #(Boolean/parseBoolean %))
                    (string? y) (update :y #(Long/parseLong %))))]
  (assert (= expexted (transform data)))
  (cc/quick-bench (transform data)))

;; malli 72ns
(let [schema [:map
              [:x :boolean]
              [:y {:optional true} int?]
              [:z string?]]
      transform (m/decoder schema (mt/string-transformer))]
  (assert (= expexted (transform data)))
  (cc/quick-bench (transform data)))</pre></z><z id="t1635707337" t="Ben Sless now just waiting for the protocols to move namespace and time schemas 🙂"><y>#</y><d>2021-10-31</d><h>19:08</h><r>Ben Sless</r>now just waiting for the protocols to move namespace and time schemas <b>🙂</b></z><z id="t1635703687" t="ikitommi btw, got the AST registry references working, could push 0.7.0 as soon as have verified it works on real projects. Then, away from perf, back to features."><y>#</y><d>2021-10-31</d><h>18:08</h><w>ikitommi</w>btw, got the AST registry references working, could push 0.7.0 as soon as have verified it works on real projects. Then, away from perf, back to features.</z><z id="t1635708638" t="Ben Sless btw, I have a pretty extensive getting started guide which is probably ready for initial contribution. Which format would you like it in? adoc/md/org?"><y>#</y><d>2021-10-31</d><h>19:30</h><w>Ben Sless</w>btw, I have a pretty extensive getting started guide which is probably ready for initial contribution. Which format would you like it in? adoc/md/org?</z><z id="t1635716207" t="ikitommi looking forward to this! If the docs would be part of the repo, then adoc / md, so that github &amp; cljdoc can render these. I have wanted to move to adoc, but hadn’t had time to learn the syntax differences…."><y>#</y><d>2021-10-31</d><h>21:36</h><r>ikitommi</r>looking forward to this! If the docs would be part of the repo, then adoc / md, so that github &amp; cljdoc can render these. I have wanted to move to adoc, but hadn’t had time to learn the syntax differences….</z><z id="t1635740046" t="Ben Sless I&apos;ll just use pandoc to convert It&apos;s supposed to be a superset of md"><y>#</y><d>2021-11-01</d><h>04:14</h><r>Ben Sless</r>I&apos;ll just use pandoc to convert
It&apos;s supposed to be a superset of md</z><z id="t1635716471" t="ikitommi [metosin/malli &quot;0.7.0-20211031.202317-3&quot;] is out, perf + new Schema AST. Will run it against work projects next week before making a real release. Has breaking changes, mostly in the extender API, so please read the https://github.com/metosin/malli/blob/master/CHANGELOG.md#070-20211031202317-3-2021-10-31 ."><y>#</y><d>2021-10-31</d><h>21:41</h><w>ikitommi</w><code>[metosin/malli &quot;0.7.0-20211031.202317-3&quot;]</code> is out, perf + new Schema AST. Will run it against work projects next week before making a real release. Has breaking changes, mostly in the extender API, so please read the <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md#070-20211031202317-3-2021-10-31" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md#070-20211031202317-3-2021-10-31</a>.</z><z id="t1635785882" t="Felipe Cortez hi! the doc says m/=&gt; can be placed both before or after a defn. when putting it before, clj-kondo complains about the symbol being unresolved. :unresolved-symbol {:exclude [plus]} in clj-kondo&apos;s config.edn silences the error. should that be the default behavior?"><y>#</y><d>2021-11-01</d><h>16:58</h><w>Felipe Cortez</w>hi! the doc says <code>m/=&gt;</code> can be placed both before or after a defn. when putting it before, clj-kondo complains about the symbol being unresolved. <code>:unresolved-symbol {:exclude [plus]}</code> in clj-kondo&apos;s <code>config.edn</code> silences the error. should that be the default behavior?</z><z id="t1635785953" t="borkdude that&apos;s usually not an optimal solution to unresolved symbols in clj-kondo"><y>#</y><d>2021-11-01</d><h>16:59</h><w>borkdude</w>that&apos;s usually not an optimal solution to unresolved symbols in clj-kondo</z><z id="t1635785985" t="borkdude does malli export hooks and/or config as part of the library?"><y>#</y><d>2021-11-01</d><h>16:59</h><w>borkdude</w>does malli export hooks and/or config as part of the library?</z><z id="t1635786048" t="Felipe Cortez it seems to export the stuff that goes to .clj-kondo/configs/malli/config.edn automatically"><y>#</y><d>2021-11-01</d><h>17:00</h><w>Felipe Cortez</w>it seems to export the stuff that goes to <code>.clj-kondo/configs/malli/config.edn</code> automatically</z><z id="t1635786206" t="borkdude I don&apos;t think malli exports any macro config. Does it have macros that clj-kondo doesn&apos;t understand?"><y>#</y><d>2021-11-01</d><h>17:03</h><w>borkdude</w>I don&apos;t think malli exports any macro config. Does it have macros that clj-kondo doesn&apos;t understand?</z><z id="t1635786337" t="Felipe Cortez the only thing it seems to export for m/=&gt; is {:linters {:type-mismatch {:namespaces {brincando {plus {:arities {2 {:args [:int :int], :ret :int}}}}}}}} but since the macro would still be out of order even if defined for clj-kondo, is there any other way to solve this?"><y>#</y><d>2021-11-01</d><h>17:05</h><w>Felipe Cortez</w>the only thing it seems to export for <code>m/=&gt;</code> is

<pre>{:linters
 {:type-mismatch {:namespaces {brincando {plus {:arities {2 {:args [:int :int], :ret :int}}}}}}}}</pre>
but since the macro would still be out of order even if defined for clj-kondo, is there any other way to solve this?</z><z id="t1635786388" t="borkdude Please give an example, I find it hard to imagine what you&apos;re talking about"><y>#</y><d>2021-11-01</d><h>17:06</h><w>borkdude</w>Please give an example, I find it hard to imagine what you&apos;re talking about</z><z id="t1635786453" t="Felipe Cortez sorry! this is the working code (m/=&gt; plus [:=&gt; [:cat [:int {:max 10}] :int] :int]) (defn plus [x y] (+ x y)) but I just noticed that if you &quot;expand&quot; that macro in clj-kondo to declare plus , it solves the undeclared variable warning, right?"><y>#</y><d>2021-11-01</d><h>17:07</h><w>Felipe Cortez</w>sorry! this is the working code

<pre>(m/=&gt; plus [:=&gt; [:cat [:int {:max 10}] :int] :int])
(defn plus [x y] (+ x y))</pre>
but I just noticed that if you &quot;expand&quot; that macro in clj-kondo to declare <code>plus</code>, it solves the undeclared variable warning, right?</z><z id="t1635786497" t="borkdude I think you can just put the m/=&gt; expression after the defn and then clj-kondo will understand that plus is a var"><y>#</y><d>2021-11-01</d><h>17:08</h><w>borkdude</w>I think you can just put the <code>m/=&gt;</code> expression after the <code>defn</code> and then clj-kondo will understand that <code>plus</code> is a var</z><z id="t1635786585" t="Felipe Cortez yep, but you can also put m/=&gt; before the defn and it is supposed to work, and I&apos;d like to have the option to put the function schema close to the top of the defn"><y>#</y><d>2021-11-01</d><h>17:09</h><r>Felipe Cortez</r>yep, but you can also put <code>m/=&gt;</code> before the defn and it is supposed to work, and I&apos;d like to have the option to put the function schema close to the top of the defn</z><z id="t1635786598" t="borkdude I understand"><y>#</y><d>2021-11-01</d><h>17:09</h><r>borkdude</r>I understand</z><z id="t1635786617" t="borkdude In this case it&apos;s better to write a hook. Optimally malli itself would bundle this in the library and export it"><y>#</y><d>2021-11-01</d><h>17:10</h><r>borkdude</r>In this case it&apos;s better to write a hook. Optimally malli itself would bundle this in the library and export it</z><z id="t1635786629" t="Felipe Cortez cool!"><y>#</y><d>2021-11-01</d><h>17:10</h><r>Felipe Cortez</r>cool!</z><z id="t1635786655" t="borkdude alternatively you can use {:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}}}"><y>#</y><d>2021-11-01</d><h>17:10</h><r>borkdude</r>alternatively you can use <code>{:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}}}</code></z><z id="t1635786666" t="borkdude this will suppress all unresolved symbols in =&gt;"><y>#</y><d>2021-11-01</d><h>17:11</h><r>borkdude</r>this will suppress all unresolved symbols in <code>=&gt;</code></z><z id="t1635786687" t="borkdude but that config could also be exported by malli so it would work for everyone. cc [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2021-11-01</d><h>17:11</h><r>borkdude</r>but that config could also be exported by malli so it would work for everyone. cc <a>@ikitommi</a></z><z id="t1635882571" t="ikitommi so, definetely. so, whoever knows better what to put into malli repo so it would work, please do."><y>#</y><d>2021-11-02</d><h>19:49</h><r>ikitommi</r>so, definetely. so, whoever knows better what to put into malli repo so it would work, please do.</z><z id="t1635882581" t="ikitommi oh, that, I can do it"><y>#</y><d>2021-11-02</d><h>19:49</h><r>ikitommi</r>oh, that, I can do it</z><z id="t1635883551" t="ikitommi [:attrs {:href &quot;/_/_/users/UKW2FUL4D&quot;}] https://github.com/metosin/malli/pull/559 . thing is, that if that is merged, clj-kondo will not warn on cases where you define the m/=&gt; , but not the actual function that it points to. Not good either."><y>#</y><d>2021-11-02</d><h>20:05</h><r>ikitommi</r><a>@UKW2FUL4D</a> <a href="https://github.com/metosin/malli/pull/559" target="_blank">https://github.com/metosin/malli/pull/559</a>. thing is, that if that is merged, clj-kondo will not warn on cases where you define the <code>m/=&gt;</code>, but not the actual function that it points to. Not good either.</z><z id="t1635883577" t="ikitommi but, that’s stops the warnings."><y>#</y><d>2021-11-02</d><h>20:06</h><r>ikitommi</r>but, that’s stops the warnings.</z><z id="t1635886585" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] That&apos;s a step in the right direction, but you can make it better using an exported macro hook"><y>#</y><d>2021-11-02</d><h>20:56</h><r>borkdude</r><a>@ikitommi</a> That&apos;s a step in the right direction, but you can make it better using an exported macro hook</z><z id="t1635886600" t="borkdude but this is more time consuming and I understand the trade-offs"><y>#</y><d>2021-11-02</d><h>20:56</h><r>borkdude</r>but this is more time consuming and I understand the trade-offs</z><z id="t1635886627" t="borkdude it would be better to export it as part of the malli library though, then people don&apos;t have to run malli first to get the better linting"><y>#</y><d>2021-11-02</d><h>20:57</h><r>borkdude</r>it would be better to export it as part of the malli library though, then people don&apos;t have to run malli first to get the better linting</z><z id="t1635887165" t="ikitommi a better solution / clj-kondo macro hook would be great, anyone? Just merged the initial fix, thanks [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] for the code to paste in 🙂"><y>#</y><d>2021-11-02</d><h>21:06</h><r>ikitommi</r>a better solution / clj-kondo macro hook would be great, anyone? Just merged the initial fix, thanks <a>@borkdude</a> for the code to paste in <b>🙂</b></z><z id="t1635947489" t="Felipe Cortez nice! what about a hook that interprets m/=&gt; as (fn [sym _schema] (clojure.core/declare %1)) ? kondo doesn&apos;t seem to complain about (def thing) (declare thing) so it works the other way around too"><y>#</y><d>2021-11-03</d><h>13:51</h><r>Felipe Cortez</r>nice! what about a hook that interprets <code>m/=&gt;</code> as <code>(fn [sym _schema] (clojure.core/declare %1))</code>? kondo doesn&apos;t seem to complain about

<pre>(def thing)
(declare thing)</pre>
so it works the other way around too</z><z id="t1635959116" t="borkdude I would say: (do (declare thing) schema) so everything you use in the schema is still seen by clj-kondo."><y>#</y><d>2021-11-03</d><h>17:05</h><r>borkdude</r>I would say:

<pre>(do (declare thing) schema)</pre>
so everything you use in the schema is still seen by clj-kondo.</z><z id="t1636029891" t="Felipe right! I&apos;ll try this 🙂"><y>#</y><d>2021-11-04</d><h>12:44</h><r>Felipe</r>right! I&apos;ll try this <b>🙂</b></z><z id="t1636242023" t="Felipe [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] hmmm, apparently doesn&apos;t seem to catch errors for instrumented functions doing m/=&gt; before the defn: (require &apos;[malli.core :as m]) (require &apos;[malli.dev :as dev]) (dev/start!) (defn plus1 [x] (inc x)) (m/=&gt; plus1 [:=&gt; [:cat :int] [:int {:max 6}]]) (plus1 6) ;; 1. Unhandled clojure.lang.ExceptionInfo ;; :malli.core/invalid-output {:output [:int {:max 6}], :value 7, ;; :args [6], :schema [:=&gt; [:cat :int] [:int {:max 6}]]} (m/=&gt; plus1&apos; [:=&gt; [:cat :int] [:int {:max 6}]]) (defn plus1&apos; [x] (inc x)) (plus1&apos; 6) ;; =&gt; 7"><y>#</y><d>2021-11-06</d><h>23:40</h><r>Felipe</r><a>@ikitommi</a> hmmm, apparently <code></code> doesn&apos;t seem to catch errors for instrumented functions doing m/=&gt; before the defn:

<pre>(require &apos;[malli.core :as m])
  (require &apos;[malli.dev :as dev])
  (dev/start!)

  (defn plus1 [x] (inc x))
  (m/=&gt; plus1 [:=&gt; [:cat :int] [:int {:max 6}]])
  (plus1 6)
  ;; 1. Unhandled clojure.lang.ExceptionInfo
  ;;  :malli.core/invalid-output {:output [:int {:max 6}], :value 7,
  ;;  :args [6], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}

  (m/=&gt; plus1&apos; [:=&gt; [:cat :int] [:int {:max 6}]])
  (defn plus1&apos; [x] (inc x))
  (plus1&apos; 6)
  ;; =&gt; 7</pre></z><z id="t1636280920" t="ikitommi [:attrs {:href &quot;/_/_/users/UA2U3KW0L&quot;}] that’s not good. I guess (re-)calling (dev/start!) after definitions would work."><y>#</y><d>2021-11-07</d><h>10:28</h><r>ikitommi</r><a>@UA2U3KW0L</a> that’s not good. I guess (re-)calling <code>(dev/start!)</code> after definitions would work.</z><z id="t1636280963" t="ikitommi so, that’s just dev-time annoyance, but then again, it’s supposed to be dev-time tooling. Ideas welcome"><y>#</y><d>2021-11-07</d><h>10:29</h><r>ikitommi</r>so, that’s just dev-time annoyance, but then again, it’s supposed to be dev-time tooling. Ideas welcome</z><z id="t1636281009" t="ikitommi I would assume m/=&gt; with dev running, should put a var-watcher that takes care of that, but guess not :thinking_face:"><y>#</y><d>2021-11-07</d><h>10:30</h><r>ikitommi</r>I would assume <code>m/=&gt;</code> with dev running, should put a var-watcher that takes care of that, but guess not <b>:thinking_face:</b></z><z id="t1636287763" t="Felipe it seems to put a watch on the function schema, so what seems to be happening is the watch fn is called, the function gets instrumented properly, but when you eval the defn again you lose the instrumentation"><y>#</y><d>2021-11-07</d><h>12:22</h><r>Felipe</r>it seems to put a watch on the function schema, so what seems to be happening is the watch fn is called, the function gets instrumented properly, but when you eval the defn again you lose the instrumentation</z><z id="t1636287918" t="Felipe yep! as a quick test, I did (defn start! ,,, (let [watch (fn [_ _ old new] (println &quot;watched&quot;) (future ;; &lt;- (Thread/sleep 500) ;; &lt;- (mi/instrument! ,,,))] (add-watch @#&apos;m/-function-schemas* ::watch watch)) (mi/instrument! ,,,) ,,,))"><y>#</y><d>2021-11-07</d><h>12:25</h><r>Felipe</r>yep! as a quick test, I did

<pre>(defn start!
   ,,,
   (let [watch (fn [_ _ old new]
                 (println &quot;watched&quot;)
                 (future ;; &lt;-
                   (Thread/sleep 500) ;; &lt;-
                   (mi/instrument! ,,,))]
     (add-watch @#&apos;m/-function-schemas* ::watch watch))
   (mi/instrument! ,,,)
   ,,,))</pre></z><z id="t1636290228" t="ikitommi so, we should get an event when the var is redefined, e.g. via defn . I guess that&apos;s doable?"><y>#</y><d>2021-11-07</d><h>13:03</h><r>ikitommi</r>so, we should get an event when the var is redefined, e.g. via <code>defn</code>. I guess that&apos;s doable?</z><z id="t1636294998" t="Felipe Cortez add-watch supports this, apparently: (def changes* (atom [])) (def a 1) (add-watch #&apos;a nil (fn [_ _ &amp; old+new] (swap! changes* conj old+new))) (def a 2) (def a 3) @changes* ;; =&gt; [(1 2) (2 3)]"><y>#</y><d>2021-11-07</d><h>14:23</h><r>Felipe Cortez</r>add-watch supports this, apparently:

<pre>(def changes* (atom []))  
  (def a 1)
  (add-watch #&apos;a nil (fn [_ _ &amp; old+new] (swap! changes* conj old+new)))
  (def a 2)
  (def a 3)
  @changes* ;; =&gt; [(1 2) (2 3)]</pre></z><z id="t1636295024" t="Felipe Cortez just noticed I use clojurians through 2 different slack accounts"><y>#</y><d>2021-11-07</d><h>14:23</h><r>Felipe Cortez</r>just noticed I use clojurians through 2 different slack accounts</z><z id="t1635786525" t="borkdude or you can use {:lint-as {malli.core/=&gt; clojure.core/def}}"><y>#</y><d>2021-11-01</d><h>17:08</h><w>borkdude</w>or you can use <code>{:lint-as {malli.core/=&gt; clojure.core/def}}</code></z><z id="t1635786535" t="borkdude which is not entirely semantically correct, but I think it works for linting"><y>#</y><d>2021-11-01</d><h>17:08</h><w>borkdude</w>which is not entirely semantically correct, but I think it works for linting</z><z id="t1635786540" t="borkdude hmm"><y>#</y><d>2021-11-01</d><h>17:09</h><w>borkdude</w>hmm</z><z id="t1635786541" t="borkdude no"><y>#</y><d>2021-11-01</d><h>17:09</h><w>borkdude</w>no</z><z id="t1635786546" t="borkdude then you will get a redefined warning :)"><y>#</y><d>2021-11-01</d><h>17:09</h><w>borkdude</w>then you will get a redefined warning :)</z><z id="t1635786558" t="Felipe Cortez clojure.core/declare, maybe?"><y>#</y><d>2021-11-01</d><h>17:09</h><w>Felipe Cortez</w>clojure.core/declare, maybe?</z><z id="t1635887165" t="ikitommi a better solution / clj-kondo macro hook would be great, anyone? Just merged the initial fix, thanks [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] for the code to paste in 🙂"><y>#</y><d>2021-11-02</d><h>21:06</h><w>ikitommi</w>a better solution / clj-kondo macro hook would be great, anyone? Just merged the initial fix, thanks <a>@borkdude</a> for the code to paste in <b>🙂</b></z><z id="t1636242023" t="Felipe [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] hmmm, apparently doesn&apos;t seem to catch errors for instrumented functions doing m/=&gt; before the defn: (require &apos;[malli.core :as m]) (require &apos;[malli.dev :as dev]) (dev/start!) (defn plus1 [x] (inc x)) (m/=&gt; plus1 [:=&gt; [:cat :int] [:int {:max 6}]]) (plus1 6) ;; 1. Unhandled clojure.lang.ExceptionInfo ;; :malli.core/invalid-output {:output [:int {:max 6}], :value 7, ;; :args [6], :schema [:=&gt; [:cat :int] [:int {:max 6}]]} (m/=&gt; plus1&apos; [:=&gt; [:cat :int] [:int {:max 6}]]) (defn plus1&apos; [x] (inc x)) (plus1&apos; 6) ;; =&gt; 7"><y>#</y><d>2021-11-06</d><h>23:40</h><w>Felipe</w><a>@ikitommi</a> hmmm, apparently <code></code> doesn&apos;t seem to catch errors for instrumented functions doing m/=&gt; before the defn:

<pre>(require &apos;[malli.core :as m])
  (require &apos;[malli.dev :as dev])
  (dev/start!)

  (defn plus1 [x] (inc x))
  (m/=&gt; plus1 [:=&gt; [:cat :int] [:int {:max 6}]])
  (plus1 6)
  ;; 1. Unhandled clojure.lang.ExceptionInfo
  ;;  :malli.core/invalid-output {:output [:int {:max 6}], :value 7,
  ;;  :args [6], :schema [:=&gt; [:cat :int] [:int {:max 6}]]}

  (m/=&gt; plus1&apos; [:=&gt; [:cat :int] [:int {:max 6}]])
  (defn plus1&apos; [x] (inc x))
  (plus1&apos; 6)
  ;; =&gt; 7</pre></z><z id="t1635869770" t="dakra I have a beginner question: I validate incoming JSONs by first stripping extra keys, then validating against a malli schema and then output avro. How can I keep/specify the type of floats/doubles? E.g. (-&gt; [:map [:score double?]] (m/encode {:score 0} mt/strip-extra-keys-transformer) :score type) ;; =&gt; java.lang.Long While I want double."><y>#</y><d>2021-11-02</d><h>16:16</h><w>dakra</w>I have a beginner question:

I validate incoming JSONs by first stripping extra keys,
then validating against a malli schema and then output avro.

How can I keep/specify the type of floats/doubles?

E.g.

<pre>(-&gt; [:map [:score double?]]
      (m/encode {:score 0} mt/strip-extra-keys-transformer)
      :score
      type)
;; =&gt; java.lang.Long</pre>
While I want double.</z><z id="t1635870107" t="Ben Sless Should you use a string transformers first?"><y>#</y><d>2021-11-02</d><h>16:21</h><w>Ben Sless</w>Should you use a string transformers first?</z><z id="t1635870262" t="dakra This seems to work when it&apos;s a string. So (-&gt; [:map [:score double?]] (m/decode {:score &quot;0&quot;} mt/string-transformer) :score type) ;; =&gt; java.lang.Double works.. but I get {:score 0} as input and then it&apos;s still Long."><y>#</y><d>2021-11-02</d><h>16:24</h><w>dakra</w>This seems to work when it&apos;s a string. So
<pre>(-&gt; [:map [:score double?]]
      (m/decode {:score &quot;0&quot;} mt/string-transformer)
      :score
      type)
;; =&gt; java.lang.Double</pre>
works.. but I get <code>{:score 0}</code> as input and then it&apos;s still Long.</z><z id="t1635870834" t="dakra But this lead me to look at the other transformers and decode with json-transformer seems to do the trick 🙂"><y>#</y><d>2021-11-02</d><h>16:33</h><w>dakra</w>But this lead me to look at the other transformers and decode with json-transformer seems to do the trick <b>🙂</b></z><z id="t1635871066" t="Ben Sless Hang on, decode is when reading, encode is when writing"><y>#</y><d>2021-11-02</d><h>16:37</h><w>Ben Sless</w>Hang on, decode is when reading, encode is when writing</z><z id="t1635871095" t="Ben Sless If the json is incoming you should decode"><y>#</y><d>2021-11-02</d><h>16:38</h><w>Ben Sless</w>If the json is incoming you should decode</z><z id="t1635871397" t="dakra Apparently I got that mixed up. But when I only use strip-extra-keys-transformer I can use encode or decode.. In both cases the extra keys got stripped. But for my (new) use-case where I want to have a double where the schema is double I have to use decode like you said."><y>#</y><d>2021-11-02</d><h>16:43</h><w>dakra</w>Apparently I got that mixed up. But when I only use <code>strip-extra-keys-transformer</code> I can use encode or decode.. In both cases the extra keys got stripped. But for my (new) use-case where I want to have a double where the schema is double I have to use decode like you said.</z><z id="t1635872524" t="Ben Sless Yes, where are you getting data in from? Http?"><y>#</y><d>2021-11-02</d><h>17:02</h><w>Ben Sless</w>Yes, where are you getting data in from? Http?</z><z id="t1635872940" t="dakra Kafka"><y>#</y><d>2021-11-02</d><h>17:09</h><w>dakra</w>Kafka</z><z id="t1635873050" t="dakra I write with jackdaw a kstreams app that validates the incoming JSON events, does some simple transformations and outputs to multiple different topics depending on the event content."><y>#</y><d>2021-11-02</d><h>17:10</h><w>dakra</w>I write with jackdaw a kstreams app that validates the incoming JSON events, does some simple transformations and outputs to multiple different topics depending on the event content.</z><z id="t1635893862" t="Paul Santa Clara Hey there. I was just wondering if there were plans to expand malli to include support for openapi 3? Or should i just stick to spec-tools for the immediate future?"><y>#</y><d>2021-11-02</d><h>22:57</h><w>Paul Santa Clara</w>Hey there.  I was just wondering if there were plans to expand malli to include support for openapi 3?  Or should i just stick to spec-tools for the immediate future?</z><z id="t1635921433" t="Hukka There&apos;s an issue for that where somebody was going to work on it, but I haven&apos;t got a reply last month. That said, I heard a rumour that someone else would tackle it by Christmas. Might be that I need it sooner and might have a look too. Didn&apos;t seem terribly difficult, considering that the jsonschema support is already there. At least a simple version that is valid openapi3. Perhaps something that handles all the refs etc. would be more complex."><y>#</y><d>2021-11-03</d><h>06:37</h><r>Hukka</r>There&apos;s an issue for that where somebody was going to work on it, but I haven&apos;t got a reply last month.

That said, I heard a rumour that someone else would tackle it by Christmas. Might be that I need it sooner and might have a look too. Didn&apos;t seem terribly difficult, considering that the jsonschema support is already there. At least a simple version that is valid openapi3. Perhaps something that handles all the refs etc. would be more complex.</z><z id="t1635944654" t="Paul Santa Clara that&apos;s great to hear that it&apos;s tentatively on the roadmap! I&apos;ll keep a close eye on things and switch over ASAP. Thanks!"><y>#</y><d>2021-11-03</d><h>13:04</h><r>Paul Santa Clara</r>that&apos;s great to hear that it&apos;s tentatively on the roadmap!  I&apos;ll keep a close eye on things and switch over ASAP.  Thanks!</z><z id="t1636057867" t="respatialized Is there a recommended way to combine parsing and decoding/transforming operations? I&apos;m trying to parse a value and return the transformed value (there are subschemas with custom transformers) in the parsed structure."><y>#</y><d>2021-11-04</d><h>20:31</h><w>respatialized</w>Is there a recommended way to combine parsing and decoding/transforming operations? I&apos;m trying to parse a value and return the transformed value (there are subschemas with custom transformers) in the parsed structure.</z><z id="t1636094332" t="Ben Sless The tldr is cps transform Have a function which returns a parser Every parser gets two continuations, success and failure On providing two continuations you return the actual parsing function Same with decode (you should validate, too while there)"><y>#</y><d>2021-11-05</d><h>06:38</h><r>Ben Sless</r>The tldr is cps transform
Have a function which returns a parser
Every parser gets two continuations, success and failure 
On providing two continuations you return the actual parsing function
Same with decode (you should validate, too while there)</z><z id="t1636145457" t="Ben Sless Here, it&apos;s a big backwards but it&apos;s the most general way of making small building blocks of it (defn parser [parse-fn] (fn [success fail] (fn [x] (try (success (parse-fn x)) (catch Exception e (fail e x)))))) (defn coercer [schema transformer] (let [schema (m/schema schema) decoder (m/decoder schema transformer) validator (m/validator schema) explainer (m/explainer schema)] (fn [success fail] (fn [x] (let [x (decoder x)] (if (validator x) (success x) (fail (explainer x) x))))))) (def my-parser (parser ,,,)) (def my-coercer (coercer ,,,)) (def work (my-parser (my-coercer identity on-error) on-error)) "><y>#</y><d>2021-11-05</d><h>20:50</h><r>Ben Sless</r>Here, it&apos;s  a big backwards but it&apos;s the most general way of making small building blocks of it
<pre>(defn parser
  [parse-fn]
  (fn [success fail]
    (fn [x]
      (try
        (success (parse-fn x))
        (catch Exception e
          (fail e x))))))

(defn coercer
  [schema transformer]
  (let [schema (m/schema schema)
        decoder (m/decoder schema transformer)
        validator (m/validator schema)
        explainer (m/explainer schema)]
    (fn [success fail]
      (fn [x]
        (let [x (decoder x)]
          (if (validator x)
            (success x)
            (fail (explainer x) x)))))))

(def my-parser (parser ,,,))
(def my-coercer (coercer ,,,))

(def work
  (my-parser
   (my-coercer identity on-error)
   on-error))</pre>
</z><z id="t1636096508" t="robert-stuttaford (def LearningPathItems [:schema {:registry {::items [:map [:items {:optional true} [:vector #_(mu/union LearningPathItemBase) [:ref ::items]]] ;; marker ]}} ::items]) #_ (m/validate LearningPathItems {:items [{:items [{:items []}]}]}) this works. but when i want to introduce another spec to mix into the ref&apos;d spec (to specify lots of other keys that any :items child may have), it fails due to :malli.core/invalid-ref . am i forced to put all of those other key specifications directly in at ;; marker , or is there another way to compose it in? I suppose i could just use Clojure to catenate two vectors but that feels dirty 😅"><y>#</y><d>2021-11-05</d><h>07:15</h><w>robert-stuttaford</w><pre>(def LearningPathItems
  [:schema {:registry
            {::items
             [:map
              [:items
               {:optional true}
               [:vector
                #_(mu/union LearningPathItemBase)
                [:ref ::items]]]
              ;; marker
              ]}}
   ::items])

#_
(m/validate
 LearningPathItems
 {:items [{:items [{:items []}]}]})</pre>
this works. but when i want to introduce another spec to mix into the ref&apos;d spec (to specify lots of other keys that any <code>:items</code> child may have), it fails due to <code>:malli.core/invalid-ref</code>. am i forced to put all of those other key specifications directly in at <code>;; marker</code> , or is there another way to compose it in?

I suppose i could just use Clojure to catenate two vectors but that feels dirty <b>😅</b></z><z id="t1636096670" t="robert-stuttaford this works i guess (def LearningPathItemBase [:map [...]]) (def LearningPathItems [:schema {:registry {::items (vec (concat [:map [:items {:optional true} [:vector [:ref ::items]]]] (rest LearningPathItemBase)))}} ::items])"><y>#</y><d>2021-11-05</d><h>07:17</h><w>robert-stuttaford</w>this works i guess
<pre>(def LearningPathItemBase
  [:map
   [...]])

(def LearningPathItems
  [:schema {:registry
            {::items
             (vec
              (concat
               [:map
                [:items
                 {:optional true}
                 [:vector
                  [:ref ::items]]]]
               (rest LearningPathItemBase)))}}
   ::items])</pre></z><z id="t1636096719" t="robert-stuttaford btw the new faster mp/provider is fantastic [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2021-11-05</d><h>07:18</h><w>robert-stuttaford</w>btw the new faster mp/provider is fantastic <a>@ikitommi</a>!</z><z id="t1636281033" t="ikitommi Discussion about registries here: https://github.com/metosin/malli/discussions/565"><y>#</y><d>2021-11-07</d><h>10:30</h><w>ikitommi</w>Discussion about registries here: <a href="https://github.com/metosin/malli/discussions/565" target="_blank">https://github.com/metosin/malli/discussions/565</a></z><z id="t1636329104" t="jfntn The README mentions malli.core/to-ast in https://github.com/metosin/malli#map-syntax but that function does not seem to be around anymore?"><y>#</y><d>2021-11-07</d><h>23:51</h><w>jfntn</w>The README mentions <code>malli.core/to-ast</code> in <a href="https://github.com/metosin/malli#map-syntax" target="_blank">https://github.com/metosin/malli#map-syntax</a> but that function does not seem to be around anymore?</z><z id="t1636350661" t="ikitommi Added a note that is is unreleased."><y>#</y><d>2021-11-08</d><h>05:51</h><r>ikitommi</r>Added a note that is is unreleased.</z><z id="t1636561049" t="rafd I&apos;m trying to get the properties of a map entry, and struggling. For example, given the following schema, I&apos;d like to access the properties of :widget/id (ie. get back {:foo/bar 123} ): (def Widget [:map [:widget/id {:foo/bar 123} uuid?]]) I thought this would work, but it returns an invalid-schema error: (m/properties (m.util/find Widget :widget/id)) Any suggestions?"><y>#</y><d>2021-11-10</d><h>16:17</h><w>rafd</w>I&apos;m trying to get the properties of a map entry, and struggling.
For example, given the following schema, I&apos;d like to access the properties of <code>:widget/id</code> (ie. get back <code>{:foo/bar 123}</code>):
<pre>(def Widget
  [:map
   [:widget/id {:foo/bar 123} uuid?]])</pre>
I thought this would work, but it returns an invalid-schema error:
<pre>(m/properties (m.util/find Widget :widget/id))</pre>
Any suggestions?</z><z id="t1637259382" t="ikitommi [:attrs {:href &quot;/_/_/users/U0CLNM0N6&quot;}] it returns the vector of [key ?props children] as a vector: (def Widget [:map [:widget/id {:foo/bar 123} uuid?]]) (mu/find Widget :widget/id) ; =&gt; [:widget/id #:foo{:bar 123} uuid?] (m/children Widget) ; =&gt; [[:widget/id #:foo{:bar 123} uuid?]]"><y>#</y><d>2021-11-18</d><h>18:16</h><r>ikitommi</r><a>@U0CLNM0N6</a> it returns the vector of <code>[key ?props children]</code> as a vector:

<pre>(def Widget
  [:map
   [:widget/id {:foo/bar 123} uuid?]])

(mu/find Widget :widget/id)
; =&gt; [:widget/id #:foo{:bar 123} uuid?]

(m/children Widget)
; =&gt; [[:widget/id #:foo{:bar 123} uuid?]]</pre></z><z id="t1637259399" t="ikitommi you can call second on it to get the props."><y>#</y><d>2021-11-18</d><h>18:16</h><r>ikitommi</r>you can call <code>second</code> on it to get the props.</z><z id="t1637261300" t="rafd Thanks Tommi. I did end up using second , but asked to check if there was a &quot;malli-specific&quot; approach."><y>#</y><d>2021-11-18</d><h>18:48</h><r>rafd</r>Thanks Tommi. I did end up using <code>second</code>, but asked to check if there was a &quot;malli-specific&quot; approach.</z><z id="t1637261366" t="ikitommi 👍 there are no helpers for handling entries atm. but they are tuple3 always, quite easy to work with 😉"><y>#</y><d>2021-11-18</d><h>18:49</h><r>ikitommi</r><b>👍</b> there are no helpers for handling entries atm. but they are tuple3 always, quite easy to work with <b>😉</b></z><z id="t1636614450" t="Yehonathan Sharvit Is there a way to create a custom Malli tag that will allow me to write: [:record [:user-id :string] [:num-of-purchases :int]] And it would be the same as: [:and [:map-of :keyword :any] [:map [:user-id :string] [:num-of-purchases :int]] I need this because for the moment JSON decoder doesn&apos;t convert :map key strings to keywords https://github.com/metosin/malli/issues/568"><y>#</y><d>2021-11-11</d><h>07:07</h><w>Yehonathan Sharvit</w>Is there a way to create a custom Malli tag that will allow me to write:

<pre>[:record
   [:user-id :string]
   [:num-of-purchases :int]]</pre>
And it would be the same as:
<pre>[:and
 [:map-of :keyword :any]
 [:map
   [:user-id :string]
   [:num-of-purchases :int]]</pre>
I need this because for the moment JSON decoder doesn&apos;t convert <code>:map</code> key strings to keywords <a href="https://github.com/metosin/malli/issues/568" target="_blank">https://github.com/metosin/malli/issues/568</a></z><z id="t1636614957" t="Ben Sless Why not add your own transformer?"><y>#</y><d>2021-11-11</d><h>07:15</h><r>Ben Sless</r>Why not add your own transformer?</z><z id="t1636620382" t="juhoteperi [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] you could use the json-transformer version I posted on the issue. (You might want to combine with :map-of code from the Malli.transform version)"><y>#</y><d>2021-11-11</d><h>08:46</h><r>juhoteperi</r><a>@U0L91U7A8</a> you could use the json-transformer version I posted on the issue. (You might want to combine with <code>:map-of</code> code from the Malli.transform version)</z><z id="t1636620407" t="juhoteperi But yeah if you create your own registry, you could define :record as :map-of + :map"><y>#</y><d>2021-11-11</d><h>08:46</h><r>juhoteperi</r>But yeah if you create your own registry, you could define <code>:record</code> as <code>:map-of</code> + <code>:map</code></z><z id="t1636624601" t="Yehonathan Sharvit How it would look like?"><y>#</y><d>2021-11-11</d><h>09:56</h><r>Yehonathan Sharvit</r>How it would look like?</z><z id="t1636663470" t="Nikolas Pafitis Does generate cache the generator?"><y>#</y><d>2021-11-11</d><h>20:44</h><w>Nikolas Pafitis</w>Does generate cache the generator?</z><z id="t1636664631" t="respatialized mg/generator is what you&apos;re looking for I think"><y>#</y><d>2021-11-11</d><h>21:03</h><r>respatialized</r><code>mg/generator</code> is what you&apos;re looking for I think</z><z id="t1636665328" t="Nikolas Pafitis Yes but if i skip the mg/generator, generate will create a generator, is that generator cached?"><y>#</y><d>2021-11-11</d><h>21:15</h><r>Nikolas Pafitis</r>Yes but if i skip the mg/generator, generate will create a generator, is that generator cached?</z><z id="t1637259013" t="ikitommi not yet, but in few mins it does - https://github.com/metosin/malli/pull/575/files"><y>#</y><d>2021-11-18</d><h>18:10</h><r>ikitommi</r>not yet, but in few mins it does - <a href="https://github.com/metosin/malli/pull/575/files" target="_blank">https://github.com/metosin/malli/pull/575/files</a></z><z id="t1637259254" t="ikitommi mg/generator is still bit faster, as there is no cache lookup. Caching is done on Schema instance level, so calling generate with just hiccup effectively bypasses the cache."><y>#</y><d>2021-11-18</d><h>18:14</h><r>ikitommi</r><code>mg/generator</code> is still bit faster, as there is no cache lookup. Caching is done on Schema instance level, so calling generate with just hiccup effectively bypasses the cache.</z><z id="t1637259526" t="ikitommi merged, so generators are also cached by default (with the Schema instance): (def schema (m/schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]])) (comment ;; 119µs ;; 16µs (cache generator) (p/bench (mg/generate schema)))"><y>#</y><d>2021-11-18</d><h>18:18</h><r>ikitommi</r>merged, so generators are also cached by default (with the Schema instance):
<pre>(def schema
  (m/schema
    [:map
     [:x boolean?]
     [:y {:optional true} int?]
     [:z [:map
          [:x boolean?]
          [:y {:optional true} int?]]]]))

(comment
  ;; 119µs
  ;; 16µs (cache generator)
  (p/bench (mg/generate schema)))</pre></z><z id="t1637259526" t="ikitommi merged, so generators are also cached by default (with the Schema instance): (def schema (m/schema [:map [:x boolean?] [:y {:optional true} int?] [:z [:map [:x boolean?] [:y {:optional true} int?]]]])) (comment ;; 119µs ;; 16µs (cache generator) (p/bench (mg/generate schema)))"><y>#</y><d>2021-11-18</d><h>18:18</h><w>ikitommi</w>merged, so generators are also cached by default (with the Schema instance):
<pre>(def schema
  (m/schema
    [:map
     [:x boolean?]
     [:y {:optional true} int?]
     [:z [:map
          [:x boolean?]
          [:y {:optional true} int?]]]]))

(comment
  ;; 119µs
  ;; 16µs (cache generator)
  (p/bench (mg/generate schema)))</pre></z><z id="t1636842167" t="Artem Hi folks 👋 is there a way to write a schema for a map that may have any number of string keys, but also a fixed number of keyword keys? (It’s both [:map [:k :type]] and [:map-of :string :type] at the same time)"><y>#</y><d>2021-11-13</d><h>22:22</h><w>Artem</w>Hi folks <b>👋</b> is there a way to write a schema for a map that may have any number of string keys, but also a fixed number of keyword keys? (It’s both [:map [:k :type]] and [:map-of :string :type] at the same time)</z><z id="t1636980469" t="ikitommi comments welcome on https://github.com/metosin/malli/issues/43"><y>#</y><d>2021-11-15</d><h>12:47</h><r>ikitommi</r>comments welcome on <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a></z><z id="t1636972456" t="biscuitpants is it possible to ignore {:optional true} specs when generating values?"><y>#</y><d>2021-11-15</d><h>10:34</h><w>biscuitpants</w>is it possible to ignore <code>{:optional true}</code> specs when generating values?</z><z id="t1636975288" t="biscuitpants for anyone wanting to do this, i found this: https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys which i modified to do what i need!"><y>#</y><d>2021-11-15</d><h>11:21</h><r>biscuitpants</r>for anyone wanting to do this, i found this: <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#allowing-invalid-values-on-optional-keys</a>
which i modified to do what i need!</z><z id="t1636974962" t="Hukka When would I want to use :sequential instead of :repeat without options? Latter would seem simpler to remember, since I have to use :repeat with min and max now and then."><y>#</y><d>2021-11-15</d><h>11:16</h><w>Hukka</w>When would I want to use :sequential instead of :repeat without options? Latter would seem simpler to remember, since I have to use :repeat with min and max now and then.</z><z id="t1636980304" t="ikitommi you can also do [:sequential {:min 1, :max 10}]"><y>#</y><d>2021-11-15</d><h>12:45</h><r>ikitommi</r>you can also do <code>[:sequential {:min 1, :max 10}]</code></z><z id="t1636980375" t="ikitommi I would recommend using :sequential always if possible, it’s much faster and always a standalone schema. having :repeat inside of :cat makes it part of the :cat , not a standalone sequence."><y>#</y><d>2021-11-15</d><h>12:46</h><r>ikitommi</r>I would recommend using <code>:sequential</code> always if possible, it’s much faster and always a standalone schema. having <code>:repeat</code> inside of <code>:cat</code> makes it part of the <code>:cat</code>, not a standalone sequence.</z><z id="t1636982283" t="Hukka Ah, I see, good to know"><y>#</y><d>2021-11-15</d><h>13:18</h><r>Hukka</r>Ah, I see, good to know</z><z id="t1637084190" t="Eddie I am having trouble with mutually recursive schemas raising :malli.core/potentially-recursive-seqex . The intention is for the schemas to be recursive so my question is: why is the exception is being raised? I assume I have expressed recursion in an improper way, but I can’t quite figure it out. https://gist.github.com/erp12/5f7a46ff4a960feeed155da6cf89b0db the schemas and the invocation of m/validate that raises the error. Any help would be much appreciated!"><y>#</y><d>2021-11-16</d><h>17:36</h><w>Eddie</w>I am having trouble with mutually recursive schemas raising <code>:malli.core/potentially-recursive-seqex</code>. The intention is for the schemas to be recursive so my question is: why is the exception is being raised? I assume I have expressed recursion in an improper way, but I can’t quite figure it out. <a href="https://gist.github.com/erp12/5f7a46ff4a960feeed155da6cf89b0db" target="_blank">https://gist.github.com/erp12/5f7a46ff4a960feeed155da6cf89b0db</a> the schemas and the invocation of <code>m/validate</code> that raises the error.  Any help would be much appreciated!</z><z id="t1637084647" t="ikitommi In App , you should wrap the :ref s in :schena , like [:schema [:ref :lit]] so that they are not inlined in the :cat ."><y>#</y><d>2021-11-16</d><h>17:44</h><r>ikitommi</r>In <code>App</code>, you should wrap the <code>:ref</code>s in <code>:schena</code> , like <code>[:schema [:ref :lit]]</code> so that they are not inlined in the <code>:cat</code>.</z><z id="t1637085052" t="Eddie Thanks, that works. I think I understand what you mean by “inlined by the :cat ” but I am surprised that :ref must be wrapped. I thought only seqex schemas (`:cat` , :* , :alt , etc) had to be wrapped to prevent inlining. I am probably not understanding something about seqex in general. I’ll keep reading. Thanks again!"><y>#</y><d>2021-11-16</d><h>17:50</h><r>Eddie</r>Thanks, that works. I think I understand what you mean by “inlined by the <code>:cat</code>” but I am surprised that <code>:ref</code> must be wrapped. I thought only seqex schemas (`:cat` , <code>:*</code>, <code>:alt</code>, etc) had to be wrapped to prevent inlining. I am probably not understanding something about seqex in general. I’ll keep reading. Thanks again!</z><z id="t1637247812" t="rovanion I&apos;m having trouble finding from-ast in malli.core . When I go to source in Emacs I get to 0.7.0-SNAPSHOT, so it should be the right version of the library that&apos;s loaded. But I can only see the name declared, never see it def&apos;d."><y>#</y><d>2021-11-18</d><h>15:03</h><w>rovanion</w>I&apos;m having trouble finding <code>from-ast</code> in <code>malli.core</code>. When I go to source in Emacs I get to 0.7.0-SNAPSHOT, so it should be the right version of the library that&apos;s loaded. But I can only see the name declared, never see it def&apos;d.</z><z id="t1637250816" t="ikitommi released most likely next week. You can take the latest sha from master with deps if you want to test it"><y>#</y><d>2021-11-18</d><h>15:53</h><r>ikitommi</r>released most likely next week. You can take the latest sha from master with deps if you want to test it</z><z id="t1637251337" t="rovanion Sorry, on Leiningen. Will the AST behave like the vector based schemas? That is: Print like a vector/map but not implement ISeq/Associative? What I&apos;m really after is using the Malli schemas I&apos;ve written to generate some Simple HTML forms."><y>#</y><d>2021-11-18</d><h>16:02</h><r>rovanion</r>Sorry, on Leiningen.

Will the AST behave like the vector based schemas? That is: Print like a vector/map but not implement ISeq/Associative?

What I&apos;m really after is using the Malli schemas I&apos;ve written to generate some Simple HTML forms.</z><z id="t1637252108" t="ikitommi Sounds cool, there are multiple ways to walk the schemas for that: 1. use m/walk , look for json schema ns for example how to use it 2. use malli.util/subschemas to get the expanded list of the schema tree. Added that from a malli-&gt;form use case 😉 "><y>#</y><d>2021-11-18</d><h>16:15</h><r>ikitommi</r>Sounds cool, there are multiple ways to walk the schemas for that:
1. use <code>m/walk</code>, look for json schema ns for example how to use it
2. use <code>malli.util/subschemas</code> to get the expanded list of the schema tree. Added that from a malli-&gt;form use case <b>😉</b> </z><z id="t1637252132" t="ikitommi on lein, can&apos;t use AST yet, sorry"><y>#</y><d>2021-11-18</d><h>16:15</h><r>ikitommi</r>on lein, can&apos;t use AST yet, sorry</z><z id="t1637252146" t="ikitommi AST is just clojure maps"><y>#</y><d>2021-11-18</d><h>16:15</h><r>ikitommi</r>AST is just clojure maps</z><z id="t1637303927" t="ikitommi refreshed the latest SNAPSHOT with all stuff in: ➜ ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.7.0-SNAPSHOT&quot;}}}&apos; Downloading: metosin/malli/0.7.0-SNAPSHOT/malli-0.7.0-20211118.202503-4.pom from clojars"><y>#</y><d>2021-11-19</d><h>06:38</h><r>ikitommi</r>refreshed the latest SNAPSHOT with all stuff in:
<pre>➜  ~ clj -Sforce -Sdeps &apos;{:deps {metosin/malli {:mvn/version &quot;0.7.0-SNAPSHOT&quot;}}}&apos;
Downloading: metosin/malli/0.7.0-SNAPSHOT/malli-0.7.0-20211118.202503-4.pom from clojars</pre></z><z id="t1637574533" t="rovanion Hmm, I get an exception thrown at me when loading malli in my project with this latest snapshot: #error { :cause No such var: mr/fast-registry :via [{:type clojure.lang.Compiler$CompilerException :message Syntax error compiling at (tove/core.clj:1:1). :data #:clojure.error{:phase :compile-syntax-check, :line 1, :column 1, :source tove/core.clj} :at [clojure.lang.Compiler load Compiler.java 7652]} {:type java.lang.ExceptionInInitializerError :message nil :at [java.lang.Class forName0 Class.java -2]} {:type clojure.lang.Compiler$CompilerException :message Syntax error compiling at (malli/core.cljc:2362:53). :data #:clojure.error{:phase :compile-syntax-check, :line 2362, :column 53, :source malli/core.cljc} :at [clojure.lang.Compiler analyze Compiler.java 6812]} {:type java.lang.RuntimeException :message No such var: mr/fast-registry :at [clojure.lang.Util runtimeException Util.java 221]}] But I don&apos;t get the same exception when just requiering malli.core in an empty project with just malli and clojure declared as dependencies."><y>#</y><d>2021-11-22</d><h>09:48</h><r>rovanion</r>Hmm, I get an exception thrown at me when loading malli in my project with this latest snapshot:

<pre>#error {
 :cause No such var: mr/fast-registry
 :via
 [{:type clojure.lang.Compiler$CompilerException
   :message Syntax error compiling at (tove/core.clj:1:1).
   :data #:clojure.error{:phase :compile-syntax-check, :line 1, :column 1, :source tove/core.clj}
   :at [clojure.lang.Compiler load Compiler.java 7652]}
  {:type java.lang.ExceptionInInitializerError
   :message nil
   :at [java.lang.Class forName0 Class.java -2]}
  {:type clojure.lang.Compiler$CompilerException
   :message Syntax error compiling at (malli/core.cljc:2362:53).
   :data #:clojure.error{:phase :compile-syntax-check, :line 2362, :column 53, :source malli/core.cljc}
   :at [clojure.lang.Compiler analyze Compiler.java 6812]}
  {:type java.lang.RuntimeException
   :message No such var: mr/fast-registry
   :at [clojure.lang.Util runtimeException Util.java 221]}]</pre>
But I don&apos;t get the same exception when just requiering <code>malli.core</code> in an empty project with just malli and clojure declared as dependencies.</z><z id="t1637250107" t="Yehonathan Sharvit How can I define a custom predicate? E.g. a string of length 5 (or another more advanced logic)."><y>#</y><d>2021-11-18</d><h>15:41</h><w>Yehonathan Sharvit</w>How can I define a custom predicate? E.g. a string of length 5 (or another more advanced logic).</z><z id="t1637250112" t="Yehonathan Sharvit I tried the following"><y>#</y><d>2021-11-18</d><h>15:41</h><w>Yehonathan Sharvit</w>I tried the following</z><z id="t1637250120" t="Yehonathan Sharvit [:map {:registry {:asset-id [:and :string #(= 5 (count %))]}} [:aa :asset-id]]"><y>#</y><d>2021-11-18</d><h>15:42</h><w>Yehonathan Sharvit</w><pre>[:map {:registry {:asset-id [:and :string #(= 5 (count %))]}}
  [:aa :asset-id]]</pre></z><z id="t1637250129" t="Yehonathan Sharvit But malli says that the schema is not valid"><y>#</y><d>2021-11-18</d><h>15:42</h><w>Yehonathan Sharvit</w>But malli says that the schema is not valid</z><z id="t1637250771" t="ikitommi [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] wrap custom fns in :fn"><y>#</y><d>2021-11-18</d><h>15:52</h><w>ikitommi</w><a>@viebel</a> wrap custom fns in <code>:fn</code></z><z id="t1637250841" t="ikitommi also, [:string {:max 6}]"><y>#</y><d>2021-11-18</d><h>15:54</h><r>ikitommi</r>also, <code>[:string {:max 6}]</code></z><z id="t1637313093" t="Yehonathan Sharvit :fn is perfect!"><y>#</y><d>2021-11-19</d><h>09:11</h><r>Yehonathan Sharvit</r><code>:fn</code> is perfect!</z><z id="t1637313634" t="Yehonathan Sharvit How would we write a schema for a string made of two components a and b separated by a / where the schema of b depends on the value of a . The valid values of a are known in advance. For instance: 1. When a is &quot;ip&quot; , b should be a valid ip 2. When a is &quot;domain&quot; , b should be a valid domain Here are a few examples of valid and invalid data: • ip/127.0.0.1 is valid • ip/111 is not valid • domain/cnn.com is valid • domain/aa is not valid • kika/aaa is not valid"><y>#</y><d>2021-11-19</d><h>09:20</h><w>Yehonathan Sharvit</w>How would we write a schema for a string made of two components <code>a</code> and <code>b</code> separated by a <code>/</code> where the schema of <code>b</code> depends on the value of <code>a</code>. The valid values of <code>a</code> are known in advance.
For instance:
1. When <code>a</code> is <code>&quot;ip&quot;</code> , <code>b</code> should be a valid ip
2. When <code>a</code> is <code>&quot;domain&quot;</code>, <code>b</code> should be a valid domain
Here are a few examples of valid and invalid data:
• <code>ip/127.0.0.1</code> is valid
• <code>ip/111</code> is not valid
• <code>domain/cnn.com</code> is valid
• <code>domain/aa</code> is not valid
• <code>kika/aaa</code> is not valid</z><z id="t1637318199" t="Ben Sless Add a decoder which splits the string at the separator. Then it&apos;s a multi schema for a tuple which dispatches of first"><y>#</y><d>2021-11-19</d><h>10:36</h><r>Ben Sless</r>Add a decoder which splits the string at the separator. Then it&apos;s a multi schema for a tuple which dispatches of first</z><z id="t1637325208" t="Yehonathan Sharvit You mean a custom transformer like in https://github.com/metosin/malli/blob/master/docs/tips.md#trimming-strings ? (require &apos;[malli.transform :as mt]) (require &apos;[malli.core :as m]) (require &apos;[clojure.string :as str]) ;; a decoding transformer, only mounting to :string schemas with truthy :string/trim property (defn string-trimmer [] (mt/transformer {:decoders {:string {:compile (fn [schema _] (let [{:string/keys [trim]} (m/properties schema)] (when trim #(cond-&gt; % (string? %) str/trim))))}}})) ;; trim me please (m/decode [:string {:string/trim true, :min 1}] &quot; kikka &quot; string-trimmer) ; =&gt; &quot;kikka&quot;"><y>#</y><d>2021-11-19</d><h>12:33</h><r>Yehonathan Sharvit</r>You mean a custom transformer like in <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#trimming-strings" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#trimming-strings</a> ?
<pre>(require &apos;[malli.transform :as mt])
(require &apos;[malli.core :as m])
(require &apos;[clojure.string :as str])

;; a decoding transformer, only mounting to :string schemas with truthy :string/trim property
(defn string-trimmer []
  (mt/transformer
    {:decoders
     {:string
      {:compile (fn [schema _]
                  (let [{:string/keys [trim]} (m/properties schema)]
                    (when trim #(cond-&gt; % (string? %) str/trim))))}}}))

;; trim me please
(m/decode [:string {:string/trim true, :min 1}] &quot; kikka  &quot; string-trimmer)
; =&gt; &quot;kikka&quot;</pre></z><z id="t1637325411" t="Yehonathan Sharvit But then, it&apos;s the responsibility of the validate callers to explicitly mention my custom transformer. Is there a way to have the custom transformer somehow embedded in the schema?"><y>#</y><d>2021-11-19</d><h>12:36</h><r>Yehonathan Sharvit</r>But then, it&apos;s the responsibility of the <code>validate</code> callers to explicitly mention my custom transformer. Is there a way to have the custom transformer somehow embedded in the schema?</z><z id="t1637325475" t="Ben Sless (def Composite [:tuple {:decode/string #(str/split % #&quot;/&quot;) A B])"><y>#</y><d>2021-11-19</d><h>12:37</h><r>Ben Sless</r><code>(def Composite [:tuple {:decode/string #(str/split % #&quot;/&quot;) A B])</code></z><z id="t1637325622" t="Ben Sless You can do some sort of schema constructor, too: (def Composite (-simple-schema (fn [A B] [:tuple {:decode/string #(str/split % #&quot;/&quot;) A B])))"><y>#</y><d>2021-11-19</d><h>12:40</h><r>Ben Sless</r>You can do some sort of schema constructor, too:
<code>(def Composite (-simple-schema (fn [A B] [:tuple {:decode/string #(str/split % #&quot;/&quot;) A B])))</code></z><z id="t1637325649" t="Ben Sless Then use it like (Composite [:= domain] Domain)"><y>#</y><d>2021-11-19</d><h>12:40</h><r>Ben Sless</r>Then use it like <code>(Composite [:= domain] Domain)</code></z><z id="t1637325696" t="Ben Sless sort of type-constructors"><y>#</y><d>2021-11-19</d><h>12:41</h><r>Ben Sless</r>sort of type-constructors</z><z id="t1637326797" t="Yehonathan Sharvit Thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I&apos;ll give it a try"><y>#</y><d>2021-11-19</d><h>12:59</h><r>Yehonathan Sharvit</r>Thanks <a>@UK0810AQ2</a>
I&apos;ll give it a try</z><z id="t1637327009" t="Ben Sless The way I found works well for me is starting from an ideal representation then working backwards with transformers to get there"><y>#</y><d>2021-11-19</d><h>13:03</h><r>Ben Sless</r>The way I found works well for me is starting from an ideal representation then working backwards with transformers to get there</z><z id="t1637313787" t="Yehonathan Sharvit It would be nice to be able to have a distinct error message when we explain why the data is invalid. The explanation could be either: 1. Unknown value of a 2. b is not a valid ip 3. b is not a valid domain"><y>#</y><d>2021-11-19</d><h>09:23</h><w>Yehonathan Sharvit</w>It would be nice to be able to have a distinct error message when we explain why the data is invalid. The explanation could be either:
1. Unknown value of <code>a</code>
2. <code>b</code> is not a valid ip
3. <code>b</code> is not a valid domain</z><z id="t1637314363" t="rovanion I don&apos;t know how malli works, but if you can use regexes to match strings you could write something like: ((ip)/(:ip-address:)|(domain)/(:domain-name:)) "><y>#</y><d>2021-11-19</d><h>09:32</h><w>rovanion</w>I don&apos;t know how malli works, but if you can use regexes to match strings you could write something like:

<pre>((ip)/(:ip-address:)|(domain)/(:domain-name:)) </pre></z><z id="t1637314385" t="rovanion And then look at capture group 1 to see what a is and capture group 2 to find the value."><y>#</y><d>2021-11-19</d><h>09:33</h><w>rovanion</w>And then look at capture group 1 to see what a is and capture group 2 to find the value.</z><z id="t1637314471" t="rovanion If regexes aren&apos;t available the logic that would be transferrable would be to group a and b together in pairs rather than to have separate specs for a and b."><y>#</y><d>2021-11-19</d><h>09:34</h><w>rovanion</w>If regexes aren&apos;t available the logic that would be transferrable would be to group a and b together in pairs rather than to have separate specs for a and b.</z><z id="t1637587533" t="Yehonathan Sharvit Inside a map, should metadata like title and description be on the field key or in the field value? For instance: [:map [:id {:title &quot;The ID&quot;} :string]] or [:map [:id [:string {:title &quot;The ID&quot;}]] ?"><y>#</y><d>2021-11-22</d><h>13:25</h><w>Yehonathan Sharvit</w>Inside a map, should metadata like title and description be on the field key or in the field value?
For instance:
<code>[:map [:id {:title &quot;The ID&quot;} :string]]</code>
or
<code>[:map [:id [:string {:title &quot;The ID&quot;}]]</code>
?</z><z id="t1637602553" t="ikitommi both work, up to you. If the values are shared, pushing the properties into value seem like a better idea, e.g. (def id (m/schema [:string {:title &quot;The ID&quot;}])) (m/schema [:map [:id id]]) "><y>#</y><d>2021-11-22</d><h>17:35</h><r>ikitommi</r>both work, up to you. If the values are shared, pushing the properties into value seem like a better idea, e.g.

<pre>(def id (m/schema [:string {:title &quot;The ID&quot;}]))

(m/schema [:map [:id id]])</pre>
</z><z id="t1637638137" t="Yehonathan Sharvit In most cases the meaning depends on the context. I think it should be given by the key ."><y>#</y><d>2021-11-23</d><h>03:28</h><r>Yehonathan Sharvit</r>In most cases the meaning depends on the context. I think it should be given by the key .</z><z id="t1637603760" t="ikitommi about the a/b thing… agree with Ben and that’s how we have used it. the actual domain model could be defined as :multi and there would be encode &amp; decode to&amp;from the string-domain. Actual domain-side would be something like: https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas"><y>#</y><d>2021-11-22</d><h>17:56</h><w>ikitommi</w>about the a/b thing… agree with Ben and that’s how we have used it. the actual domain model could be defined as <code>:multi</code> and there would be encode &amp; decode to&amp;from the string-domain. Actual domain-side would be something like: <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas</a></z><z id="t1637604556" t="ikitommi ping [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] ."><y>#</y><d>2021-11-22</d><h>18:09</h><w>ikitommi</w>ping <a>@viebel</a>.</z><z id="t1637657782" t="Yehonathan Sharvit Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] for adding a section about string dependent types in malli documentation."><y>#</y><d>2021-11-23</d><h>08:56</h><r>Yehonathan Sharvit</r>Thank you <a>@U055NJ5CC</a> for adding a section about string dependent types in malli documentation.</z><z id="t1637618702" t="respatialized I&apos;m wondering if there&apos;s something I&apos;m not quite understanding about how m/decode and transformers work in the context of :or : (m/decode [:cat {:decode/get {:leave second}} [:= :txt] :string] [:txt &quot;something&quot;] (mt/transformer {:name :get})) ; =&gt; &quot;something&quot; (m/decode [:or [:cat {:decode/get {:leave second}} [:= :txt] :string] :double] [:txt &quot;something&quot;] (mt/transformer {:name :get})) ; =&gt; [:txt &quot;something&quot;] what I&apos;d like is for the :or to decode its value using the decoder provided by the matching schema. I had assumed that decoding was recursive by default, but it doesn&apos;t seem to be working in the context of the subschema here."><y>#</y><d>2021-11-22</d><h>22:05</h><w>respatialized</w>I&apos;m wondering if there&apos;s something I&apos;m not quite understanding about how <code>m/decode</code> and transformers work in the context of <code>:or</code>:
<pre>(m/decode
   [:cat {:decode/get {:leave second}} [:= :txt] :string]
   [:txt &quot;something&quot;]
   (mt/transformer {:name :get}))
; =&gt; &quot;something&quot;

(m/decode
   [:or [:cat {:decode/get {:leave second}} [:= :txt] :string]
    :double]
   [:txt &quot;something&quot;]
   (mt/transformer {:name :get}))
; =&gt; [:txt &quot;something&quot;]</pre>
what I&apos;d like is for the <code>:or</code> to decode its value using the decoder provided by the matching schema. I had assumed that decoding was recursive by default, but it doesn&apos;t seem to be working in the context of the subschema here.</z><z id="t1637646766" t="Ben Sless I think if you really wanted correct results here you had to write some sort of backtracking search algorithm and end up implementing half of minikanren"><y>#</y><d>2021-11-23</d><h>05:52</h><r>Ben Sless</r>I think if you really wanted correct results here you had to write some sort of backtracking search algorithm and end up implementing half of minikanren</z><z id="t1637682733" t="respatialized interestingly, encode does the right thing here: (m/encode [:or [:cat {:encode/get {:leave second}} [:= :txt] :string] :double] [:txt &quot;something&quot;] (mt/transformer {:name :get})) ;; =&gt; &quot;something&quot; what I may have been confused about was just the respective purposes of encoders and decoders"><y>#</y><d>2021-11-23</d><h>15:52</h><r>respatialized</r>interestingly, <code>encode</code> does the right thing here:
<pre>(m/encode
   [:or [:cat {:encode/get {:leave second}} [:= :txt] :string]
    :double]
   [:txt &quot;something&quot;]
   (mt/transformer {:name :get}))
;; =&gt; &quot;something&quot;</pre>
what I may have been confused about was just the respective purposes of encoders and decoders</z><z id="t1637703895" t="ikitommi It works as expected, despite it looks odd. • Decode is a process of turning (potentially invalid) values from external format (e.g. JSON) into values that are valid in the default/clojure domain. • Encode is the opposite: turning valid values from default domain into (potentially invalid) values in another domain (e.g. JSON). here, your decoder is not working correctly, as it emits invalid values. The :or picks the first branch that produces valid values after the transformation. In the example, both paths produce invalid value, so the original value is returned. See the impl: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724"><y>#</y><d>2021-11-23</d><h>21:44</h><r>ikitommi</r>It works as expected, despite it looks odd.

• Decode is a process of turning (potentially invalid) values from external format (e.g. JSON) into values that are valid in the default/clojure domain. 
• Encode is the opposite: turning valid values from default domain into (potentially invalid) values in another domain (e.g. JSON).
here, your decoder is not working correctly, as it emits invalid values. The <code>:or</code> picks the first branch that produces valid values after the transformation. In the example, both paths produce invalid value, so the original value is returned. See the impl: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724</a></z><z id="t1637703895" t="ikitommi It works as expected, despite it looks odd. • Decode is a process of turning (potentially invalid) values from external format (e.g. JSON) into values that are valid in the default/clojure domain. • Encode is the opposite: turning valid values from default domain into (potentially invalid) values in another domain (e.g. JSON). here, your decoder is not working correctly, as it emits invalid values. The :or picks the first branch that produces valid values after the transformation. In the example, both paths produce invalid value, so the original value is returned. See the impl: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724"><y>#</y><d>2021-11-23</d><h>21:44</h><w>ikitommi</w>It works as expected, despite it looks odd.

• Decode is a process of turning (potentially invalid) values from external format (e.g. JSON) into values that are valid in the default/clojure domain. 
• Encode is the opposite: turning valid values from default domain into (potentially invalid) values in another domain (e.g. JSON).
here, your decoder is not working correctly, as it emits invalid values. The <code>:or</code> picks the first branch that produces valid values after the transformation. In the example, both paths produce invalid value, so the original value is returned. See the impl: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L713-L724</a></z><z id="t1637657968" t="Yehonathan Sharvit Malli decoders are very cool. But as far as I understand, in order to use a schema that relies on decoders, clients have to decode data before validating it. It means that a schema that relies on decoders cannot be used as-is for validating data. Am I correct?"><y>#</y><d>2021-11-23</d><h>08:59</h><w>Yehonathan Sharvit</w>Malli decoders are very cool. But as far as I understand, in order to use a schema that relies on decoders, clients have to decode data before validating it.  It means that a schema that relies on decoders cannot be used as-is for validating data.
Am I correct?</z><z id="t1637659147" t="ikitommi For now, that’s true. There was a discussion some time ago to add :parsed schema element. That would just run m/-parse in before validate, explain, transform etc. like s/conform on spec. Could also be :decoded , so that this would work: (m/validate [:decoded {:decode :string} schema] &quot;ip/127.0.0.1&quot;) ; =&gt; true"><y>#</y><d>2021-11-23</d><h>09:19</h><w>ikitommi</w>For now, that’s true. There was a discussion some time ago to add <code>:parsed</code> schema element. That would just run <code>m/-parse</code> in before validate, explain, transform etc. like <code>s/conform</code> on spec. Could also be <code>:decoded</code>, so that this would work:
<pre>(m/validate [:decoded {:decode :string} schema] &quot;ip/127.0.0.1&quot;) ; =&gt; true</pre></z><z id="t1637659338" t="ikitommi you can do that “easily” in the user space too. Just a wrapper-schema basically."><y>#</y><d>2021-11-23</d><h>09:22</h><w>ikitommi</w>you can do that “easily” in the user space too. Just a wrapper-schema basically.</z><z id="t1637671006" t="Yehonathan Sharvit [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Here is my attempt to write a parser in user space: (defn my-parse [schema data] (let [data&apos; (decode schema data (transformer string-transformer default-value-transformer))] (if (validate schema data&apos;) (encode schema data&apos; (transformer string-transformer default-value-transformer)) (humanize (explain schema data&apos;))))) It does the job with asset ids but the problem is that it transform integer to strings. (def schema [:map [:count :int] [:asset-id [:multi {:dispatch first :decode/string #(str/split % #&quot;/&quot;) :encode/string #(str/join &quot;/&quot; %)} [&quot;domain&quot; [:tuple [:= &quot;domain&quot;] domain]] [&quot;ip&quot; [:tuple {:error/message &quot;Invalid IP&quot;} [:= &quot;ip&quot;] ipv4]]]]]) (my-parse schema {:count 12 :asset-id &quot;ip/127.0.0.1&quot;}) ;; {:count &quot;12&quot;, :asset-id &quot;ip/127.0.0.1&quot;} ;; Oops &quot;12&quot; instead of 12"><y>#</y><d>2021-11-23</d><h>12:36</h><w>Yehonathan Sharvit</w><a>@ikitommi</a> Here is my attempt to write a parser in user space:
<pre>(defn my-parse
  [schema data]
  (let [data&apos; (decode schema data (transformer string-transformer default-value-transformer))]
    (if (validate schema data&apos;)
      (encode schema data&apos; (transformer string-transformer default-value-transformer))
      (humanize (explain schema data&apos;)))))</pre>
It does the job with asset ids but the problem is that it transform integer to strings.

<pre>(def schema 
  [:map
   [:count :int]
   [:asset-id [:multi {:dispatch first
                     :decode/string #(str/split % #&quot;/&quot;)
                     :encode/string #(str/join &quot;/&quot; %)}
             [&quot;domain&quot; [:tuple  [:= &quot;domain&quot;] domain]]
             [&quot;ip&quot; [:tuple {:error/message &quot;Invalid IP&quot;} [:= &quot;ip&quot;] ipv4]]]]])

(my-parse schema {:count 12
                  :asset-id &quot;ip/127.0.0.1&quot;})
;; {:count &quot;12&quot;, :asset-id &quot;ip/127.0.0.1&quot;}
;; Oops &quot;12&quot; instead of 12</pre></z><z id="t1637671471" t="ikitommi just return the original instead of encode the whole value into string-domain?"><y>#</y><d>2021-11-23</d><h>12:44</h><w>ikitommi</w>just return the original instead of encode the whole value into string-domain?</z><z id="t1637671485" t="ikitommi because: (m/encode :int 1 mt/string-transformer) ; =&gt; &quot;1&quot;"><y>#</y><d>2021-11-23</d><h>12:44</h><w>ikitommi</w>because:
<pre>(m/encode :int 1 mt/string-transformer) ; =&gt; &quot;1&quot;</pre></z><z id="t1637671929" t="ikitommi … or create a custom name for the parsing transformer, e.g. :parse - it’s it a name you have defined, it doesn’t transform anything else."><y>#</y><d>2021-11-23</d><h>12:52</h><w>ikitommi</w>… or create a custom name for the parsing transformer, e.g. <code>:parse</code> - it’s it a name you have defined, it doesn’t transform anything else.</z><z id="t1637671931" t="ikitommi (let [schema [:map [:x :int] [:y [:int {:decode/parse (partial + 10) :encode/parse (partial * 2)}]]] t (mt/transformer {:name :parse})] (as-&gt; (m/decode schema {:x 0, :y 0} t) $ (m/encode schema $ t))) ;; =&gt; {:x 0, :y 20}"><y>#</y><d>2021-11-23</d><h>12:52</h><w>ikitommi</w><pre>(let [schema [:map
              [:x :int]
              [:y [:int {:decode/parse (partial + 10)
                         :encode/parse (partial * 2)}]]]
      t (mt/transformer {:name :parse})]
  (as-&gt; (m/decode schema {:x 0, :y 0} t) $
        (m/encode schema $ t)))
;; =&gt; {:x 0, :y 20}</pre></z><z id="t1637673229" t="Yehonathan Sharvit I cannot return the original as I would like the default values to be added by the parser. For instance, with a schema that assigns 42 as a default value to :count (def schema [:map [:count [:int {:default 42}]] [:asset-id [:multi {:dispatch first :decode/string #(str/split % #&quot;/&quot;) :encode/string #(str/join &quot;/&quot; %)} [&quot;domain&quot; [:tuple [:= &quot;domain&quot;] domain]] [&quot;ip&quot; [:tuple {:error/message &quot;Invalid IP&quot;} [:= &quot;ip&quot;] ipv4]]]]]) (my-parse schema {:asset-id &quot;ip/127.0.0.1&quot;}) ;; {:asset-id &quot;ip/127.0.0.1&quot;, :count &quot;42&quot;} "><y>#</y><d>2021-11-23</d><h>13:13</h><w>Yehonathan Sharvit</w>I cannot return the original as I would like the default values to be added by the parser.
For instance, with a schema that assigns 42 as a default value to <code>:count</code>
<pre>(def schema 
  [:map
   [:count [:int {:default 42}]]
   [:asset-id [:multi {:dispatch first
                     :decode/string #(str/split % #&quot;/&quot;)
                     :encode/string #(str/join &quot;/&quot; %)}
             [&quot;domain&quot; [:tuple  [:= &quot;domain&quot;] domain]]
             [&quot;ip&quot; [:tuple {:error/message &quot;Invalid IP&quot;} [:= &quot;ip&quot;] ipv4]]]]])

(my-parse schema {:asset-id &quot;ip/127.0.0.1&quot;})
;; {:asset-id &quot;ip/127.0.0.1&quot;, :count &quot;42&quot;}</pre>
</z><z id="t1637673641" t="Yehonathan Sharvit However, I really like the idea of a custom name"><y>#</y><d>2021-11-23</d><h>13:20</h><w>Yehonathan Sharvit</w>However, I really like the idea of a custom name</z><z id="t1637673679" t="Yehonathan Sharvit We need that as our plan is to have a company wide schema repository to be consumed by all apps"><y>#</y><d>2021-11-23</d><h>13:21</h><w>Yehonathan Sharvit</w>We need that as our plan is to have a company wide schema repository to be consumed by all apps</z><z id="t1637703928" t="Nikolas Pafitis Is there an option for MapSchemas to skip generating specific field/s?"><y>#</y><d>2021-11-23</d><h>21:45</h><w>Nikolas Pafitis</w>Is there an option for MapSchemas  to skip generating specific field/s?</z><z id="t1637704014" t="ikitommi not atm, but could be. Ideas welcome"><y>#</y><d>2021-11-23</d><h>21:46</h><r>ikitommi</r>not atm, but could be. Ideas welcome</z><z id="t1637704128" t="ikitommi here’s two: ;; a) a top-level property? [:map {:gen/fields [:x :y]} [:x :int] [:y :int] [:z :int]] ;; b) entry-level property? [:map [:x :int] [:y :int] [:z {:gen/gen nil} :int]] "><y>#</y><d>2021-11-23</d><h>21:48</h><r>ikitommi</r>here’s two:
<pre>;; a) a top-level property?
[:map {:gen/fields [:x :y]}
 [:x :int]
 [:y :int]
 [:z :int]]

;; b) entry-level property?
[:map
 [:x :int]
 [:y :int]
 [:z {:gen/gen nil} :int]]</pre>
</z><z id="t1637704237" t="ikitommi b would be 1 line change to the current impl."><y>#</y><d>2021-11-23</d><h>21:50</h><r>ikitommi</r>b would be 1 line change to the current impl.</z><z id="t1637705068" t="Nikolas Pafitis i guess mu/select-keys could be used"><y>#</y><d>2021-11-23</d><h>22:04</h><r>Nikolas Pafitis</r>i guess mu/select-keys could be used</z><z id="t1637706308" t="Nikolas Pafitis I might have encountered a bug: {:example/user [:map {:fully/entity? true :fully.entity/id :user/id} [:user/id :uuid] [:user/username :string] [:user/password :string] [:user/email :string]]} I have this map and i merge it with default-schemas and schemas to make my registry. Validate and generate work when I use them against (m/schema type {:registry registry}) but the following returns just nil (m/properties (m/schema type {:registry registry})) "><y>#</y><d>2021-11-23</d><h>22:25</h><w>Nikolas Pafitis</w>I might have encountered a bug:

<pre>{:example/user   [:map {:fully/entity?   true
                        :fully.entity/id :user/id}
                  [:user/id :uuid]
                  [:user/username :string]
                  [:user/password :string]
                  [:user/email :string]]}</pre>
I have this map and i merge it with default-schemas and schemas to make my registry. Validate and generate work when I use them against
<pre>(m/schema type {:registry registry})</pre>
but the following returns just nil
<pre>(m/properties (m/schema type {:registry registry}))</pre>
</z><z id="t1637707210" t="Nikolas Pafitis It seems to work if i do deref before properties"><y>#</y><d>2021-11-23</d><h>22:40</h><r>Nikolas Pafitis</r>It seems to work if i do deref before properties</z><z id="t1637707540" t="Nikolas Pafitis Is this expected behaviour?"><y>#</y><d>2021-11-23</d><h>22:45</h><r>Nikolas Pafitis</r>Is this expected behaviour?</z><z id="t1637785589" t="ikitommi It&apos;s the current behavior and surprises me every time. References are also schemas, and usually without properties. Think like: (def foo (with-meta {} {:a 1})) (meta #&apos;foo) ;=&gt; .. no :a here"><y>#</y><d>2021-11-24</d><h>20:26</h><r>ikitommi</r>It&apos;s the current behavior and surprises me every time. References are also schemas, and usually without properties. Think like:
<pre>(def foo (with-meta {} {:a 1}))
(meta #&apos;foo) ;=&gt; .. no :a here</pre></z><z id="t1637785653" t="ikitommi not 100% happy, but not sure would anything more right than the current behavior"><y>#</y><d>2021-11-24</d><h>20:27</h><r>ikitommi</r>not 100% happy, but not sure would anything more right than the current behavior</z><z id="t1637789486" t="Nikolas Pafitis I guess when passed to malli functions like m/properties the different schema types should be dereffed if required. Like in nil punning where nil &quot;can take the correct shape&quot; depending on context"><y>#</y><d>2021-11-24</d><h>21:31</h><r>Nikolas Pafitis</r>I guess when passed to malli functions like m/properties the different schema types should be dereffed if required. Like in nil punning where nil &quot;can take the correct shape&quot; depending on context</z><z id="t1637865179" t="ikitommi we would assume the references don&apos;t have properties, but they could. We could enforce them not to have, but not sure if that would be a good design decision :thinking_face:"><y>#</y><d>2021-11-25</d><h>18:32</h><r>ikitommi</r>we would assume the references don&apos;t have properties, but they could. We could enforce them not to have, but not sure if that would be a good design decision <b>:thinking_face:</b></z><z id="t1637785589" t="ikitommi It&apos;s the current behavior and surprises me every time. References are also schemas, and usually without properties. Think like: (def foo (with-meta {} {:a 1})) (meta #&apos;foo) ;=&gt; .. no :a here"><y>#</y><d>2021-11-24</d><h>20:26</h><w>ikitommi</w>It&apos;s the current behavior and surprises me every time. References are also schemas, and usually without properties. Think like:
<pre>(def foo (with-meta {} {:a 1}))
(meta #&apos;foo) ;=&gt; .. no :a here</pre></z><z id="t1637865179" t="ikitommi we would assume the references don&apos;t have properties, but they could. We could enforce them not to have, but not sure if that would be a good design decision :thinking_face:"><y>#</y><d>2021-11-25</d><h>18:32</h><w>ikitommi</w>we would assume the references don&apos;t have properties, but they could. We could enforce them not to have, but not sure if that would be a good design decision <b>:thinking_face:</b></z><z id="t1637770550" t="respatialized another encode question: how do I handle subsequences that I want to encode into single values? I&apos;ve got some data like: (let [data [&quot;some text&quot; &quot;ex1.csv - file 1&quot; &quot;ex2.csv - file 2&quot;] expected-result [&quot;some text&quot; {&quot;file 1&quot; &quot;ex1.csv&quot; &quot;file 2&quot; &quot;ex2.csv&quot;}]] (m/encode [:catn [:txt [:= &quot;some text&quot;]] [:subseq [:repeat {:encode/extract {:leave #(apply merge %)}} [:re {:encode/extract {:enter #(let [[id fnum] (clojure.string/split % #&quot;\s-\s&quot;)] {fnum id})}} #&quot;.* - file \d&quot;]]]] data (mt/transformer {:name :extract})) ) ;; =&gt; [&quot;some text&quot; {&quot;file 1&quot; &quot;ex1.csv&quot;} {&quot;file 2&quot; &quot;ex2.csv&quot;}] the #(apply merge %) encoder works to merge the maps extracted if the :repeat schema is a top-level schema, but not if it is a schema for a subsequence of a seqex. am I pushing encode too far here? should I be relying on parse to do this kind of grouping?"><y>#</y><d>2021-11-24</d><h>16:15</h><w>respatialized</w>another <code>encode</code> question: how do I handle subsequences that I want to encode into single values? I&apos;ve got some data like:
<pre>(let [data [&quot;some text&quot; &quot;ex1.csv - file 1&quot; &quot;ex2.csv - file 2&quot;]
      expected-result [&quot;some text&quot; {&quot;file 1&quot; &quot;ex1.csv&quot; &quot;file 2&quot; &quot;ex2.csv&quot;}]]
  (m/encode
    [:catn [:txt [:= &quot;some text&quot;]]
      [:subseq [:repeat {:encode/extract {:leave #(apply merge %)}}
                 [:re {:encode/extract {:enter #(let [[id fnum] (clojure.string/split % #&quot;\s-\s&quot;)]
                                                           {fnum id})}}
                      #&quot;.* - file \d&quot;]]]]
   data
   (mt/transformer {:name :extract}))
 )

;; =&gt; [&quot;some text&quot; {&quot;file 1&quot; &quot;ex1.csv&quot;} {&quot;file 2&quot; &quot;ex2.csv&quot;}]</pre>
the <code>#(apply merge %)</code> encoder works to merge the maps extracted if the <code>:repeat</code> schema is a top-level schema, but not if it is a schema for a subsequence of a seqex.

am I pushing <code>encode</code> too far here? should I be relying on <code>parse</code> to do this kind of grouping?</z><z id="t1637788674" t="respatialized thinking about this a bit more, it doesn&apos;t seem like this is possible, as different values are being encoded depending on whether the sequex is top-level or a subsequence: top-level: (let [data [&quot;ex1.csv - file 1&quot; &quot;ex2.csv - file 2&quot;] expected-result {&quot;file 1&quot; &quot;ex1.csv&quot; &quot;file 2&quot; &quot;ex2.csv&quot;}] (m/encode [:repeat {:encode/extract {:leave #(apply merge %)}} [:re {:encode/extract {:enter #(let [[id fnum] (clojure.string/split % #&quot;\s-\s&quot;)] {fnum id})}} #&quot;.* - file \d&quot;]] data (mt/transformer {:name :extract})) ) ;; =&gt; {&quot;file 1&quot; &quot;ex1.csv&quot;, &quot;file 2&quot; &quot;ex2.csv&quot;} so really the object of encoding is a complete vector, the vector of maps created after each string element gets encoded. whereas with the subsequence, it&apos;s not a clearly delineated individual value: [&quot;some text&quot; #_&quot;start of subsequence in :repeat&quot; {&quot;file 1&quot; &quot;ex1.csv&quot;} {&quot;file 2&quot; &quot;ex2.csv&quot;} ... #_&quot;arbitrary number of additional repeats&quot; #_&quot;end of subsequence in :repeat&quot; ] and thus cannot be passed in as an argument to the function referenced in :encode/extract , even if that function accepts varargs or an input sequence. so I think I need to rely on m/parse to do the grouping I am hoping for here."><y>#</y><d>2021-11-24</d><h>21:17</h><r>respatialized</r>thinking about this a bit more, it doesn&apos;t seem like this is possible, as different values are being encoded depending on whether the sequex is top-level or a subsequence:

top-level:
<pre>(let [data [&quot;ex1.csv - file 1&quot; &quot;ex2.csv - file 2&quot;]
      expected-result {&quot;file 1&quot; &quot;ex1.csv&quot; &quot;file 2&quot; &quot;ex2.csv&quot;}]
  (m/encode
     [:repeat {:encode/extract {:leave #(apply merge %)}}
                 [:re {:encode/extract {:enter #(let [[id fnum] (clojure.string/split % #&quot;\s-\s&quot;)]
                                                           {fnum id})}}
                      #&quot;.* - file \d&quot;]]
   data
   (mt/transformer {:name :extract}))
 )
;; =&gt; {&quot;file 1&quot; &quot;ex1.csv&quot;, &quot;file 2&quot; &quot;ex2.csv&quot;}</pre>
so really the object of encoding is a complete vector, the vector of maps created after each string element gets encoded.

whereas with the subsequence, it&apos;s not a clearly delineated individual value:
<pre>[&quot;some text&quot;
#_&quot;start of subsequence in :repeat&quot;  
 {&quot;file 1&quot; &quot;ex1.csv&quot;} {&quot;file 2&quot; &quot;ex2.csv&quot;}
... #_&quot;arbitrary number of additional repeats&quot;
 #_&quot;end of subsequence in :repeat&quot; ]</pre>
and thus cannot be passed in as an argument to the function referenced in <code>:encode/extract</code> , even if that function accepts varargs or an input sequence. so I think I need to rely on <code>m/parse</code> to do the grouping I am hoping for here.</z><z id="t1637778417" t="Adam Helins Is there some way for having context sensitive transformers? e.g. when transforming a child in a coll, being able to take into account what happened to already transformed children"><y>#</y><d>2021-11-24</d><h>18:26</h><w>Adam Helins</w>Is there some way for having context sensitive transformers?

e.g. when transforming a child in a coll, being able to take into account what happened to already transformed children</z><z id="t1637831465" t="Adam Helins In other words, is transforming strictly context-free?"><y>#</y><d>2021-11-25</d><h>09:11</h><r>Adam Helins</r>In other words, is transforming strictly context-free?</z><z id="t1638273139" t="ikitommi could you provide an minimalistic example when this would be useful. There was a discussion about this long ago, but a) there was no real-life examples for “why?” and b) context-free made performance optimization much easier. Happy to revisit, but need the a) 🙂"><y>#</y><d>2021-11-30</d><h>11:52</h><r>ikitommi</r>could you provide an minimalistic example when this would be useful. There was a discussion about this long ago, but a) there was no real-life examples for “why?” and b) context-free made performance optimization much easier. Happy to revisit, but need the a) <b>🙂</b></z><z id="t1638273294" t="ikitommi there was also a discussion just to implement all applications (validation, transforming) using walk. That was my original idea for Spec too ( https://clojure.atlassian.net/browse/CLJ-2251 )."><y>#</y><d>2021-11-30</d><h>11:54</h><r>ikitommi</r>there was also a discussion just to implement all applications (validation, transforming) using walk. That was my original idea for Spec too (<a href="https://clojure.atlassian.net/browse/CLJ-2251" target="_blank">https://clojure.atlassian.net/browse/CLJ-2251</a>).</z><z id="t1638273317" t="ikitommi 4 years! time flies 🙂"><y>#</y><d>2021-11-30</d><h>11:55</h><r>ikitommi</r>4 years! time flies <b>🙂</b></z><z id="t1638273326" t="ikitommi &gt; Created 11 October 2017, 22:22"><y>#</y><d>2021-11-30</d><h>11:55</h><r>ikitommi</r>&gt; Created 11 October 2017, 22:22</z><z id="t1638273139" t="ikitommi could you provide an minimalistic example when this would be useful. There was a discussion about this long ago, but a) there was no real-life examples for “why?” and b) context-free made performance optimization much easier. Happy to revisit, but need the a) 🙂"><y>#</y><d>2021-11-30</d><h>11:52</h><w>ikitommi</w>could you provide an minimalistic example when this would be useful. There was a discussion about this long ago, but a) there was no real-life examples for “why?” and b) context-free made performance optimization much easier. Happy to revisit, but need the a) <b>🙂</b></z><z id="t1637815734" t="Johan Would malli be a good place to check if value is within a list of ~20k items ? Build a giant [:enum] or custom fn or just not use malli for that ?"><y>#</y><d>2021-11-25</d><h>04:48</h><w>Johan</w>Would malli be a good place to check if value is within a list of ~20k items ?
Build a giant [:enum] or custom fn or just not use malli for that ?</z><z id="t1637833495" t="dangercoder I would put that list of 20k items into a set instead and use clojure.core contains? function. If you want to check that through malli you can always create a custom :fn"><y>#</y><d>2021-11-25</d><h>09:44</h><r>dangercoder</r>I would put that list of 20k items into a <code>set</code> instead and use clojure.core  <code>contains?</code> function.

If you want to check that through malli you can always create a custom <code>:fn</code></z><z id="t1637844761" t="Johan For example I want to check a postcode, would you just use a malli schema to check if the value is a number and then check if it&apos;s part of the country list of postcode ?"><y>#</y><d>2021-11-25</d><h>12:52</h><r>Johan</r>For example I want to check a postcode, would you just use a malli schema to check if the value is a number and then check if it&apos;s part of the country list of postcode ?</z><z id="t1637852630" t="vinurs (def get-categories-req [:map {:title &quot;get-categories-req&quot;} [:categories [:vector {:description &quot;category id&quot; :default [0 1] } int? ]]]) hello, i define the malli schema like this, and call it shows the error { &quot;schema&quot;: &quot;[:map {:title \&quot;get-categories-req\&quot;, :closed true} [:categories [:vector {:description \&quot;category id\&quot;, :default [0 1]} int?]]]&quot;, &quot;errors&quot;: [ { &quot;value&quot;: &quot;0,1&quot;, &quot;in&quot;: [ &quot;categories&quot; ], &quot;message&quot;: &quot;invalid type&quot;, &quot;path&quot;: [ &quot;categories&quot; ], &quot;schema&quot;: &quot;[:vector {:description \&quot;category id\&quot;, :default [0 1]} int?]&quot;, &quot;type&quot;: &quot;malli.core/invalid-type&quot; } ], &quot;value&quot;: { &quot;categories&quot;: &quot;0,1&quot; }, &quot;type&quot;: &quot;reitit.coercion/request-coercion&quot;, &quot;coercion&quot;: &quot;malli&quot;, &quot;in&quot;: [ &quot;request&quot;, &quot;query-params&quot; ], &quot;humanized&quot;: { &quot;categories&quot;: [ &quot;invalid type&quot; ] } } how can i make malli parse this?"><y>#</y><d>2021-11-25</d><h>15:03</h><w>vinurs</w><pre>(def get-categories-req
  [:map {:title &quot;get-categories-req&quot;}
   [:categories  [:vector {:description &quot;category id&quot;
                           :default [0 1]
                           } int? ]]])</pre>
hello, i define the malli schema like this, and call
<code></code>
it shows the error
<pre>{
  &quot;schema&quot;: &quot;[:map {:title \&quot;get-categories-req\&quot;, :closed true} [:categories [:vector {:description \&quot;category id\&quot;, :default [0 1]} int?]]]&quot;,
  &quot;errors&quot;: [
    {
      &quot;value&quot;: &quot;0,1&quot;,
      &quot;in&quot;: [
        &quot;categories&quot;
      ],
      &quot;message&quot;: &quot;invalid type&quot;,
      &quot;path&quot;: [
        &quot;categories&quot;
      ],
      &quot;schema&quot;: &quot;[:vector {:description \&quot;category id\&quot;, :default [0 1]} int?]&quot;,
      &quot;type&quot;: &quot;malli.core/invalid-type&quot;
    }
  ],
  &quot;value&quot;: {
    &quot;categories&quot;: &quot;0,1&quot;
  },
  &quot;type&quot;: &quot;reitit.coercion/request-coercion&quot;,
  &quot;coercion&quot;: &quot;malli&quot;,
  &quot;in&quot;: [
    &quot;request&quot;,
    &quot;query-params&quot;
  ],
  &quot;humanized&quot;: {
    &quot;categories&quot;: [
      &quot;invalid type&quot;
    ]
  }
}</pre>
how can i make malli parse this?</z><z id="t1637859454" t="Ivan Fedorov Can malli’s [:merge] work inside a registry? this fails for me (def registry:shopify {:e.shopify/address1 [:map [:first_name string?]] :e.shopify/address2 [:map [:city string?]] :e.shopify/address-full [:merge :e.shopify/address1 :e.shopify/address2]}) (def schema:address-full (m/schema [:schema {:registry registry:shopify} :e.shopify/address-full])) "><y>#</y><d>2021-11-25</d><h>16:57</h><w>Ivan Fedorov</w>Can malli’s <code>[:merge]</code> work inside a registry?
this fails for me
<pre>(def registry:shopify
  {:e.shopify/address1
   [:map [:first_name string?]]
   :e.shopify/address2
   [:map [:city string?]]
   :e.shopify/address-full
   [:merge
    :e.shopify/address1
    :e.shopify/address2]})

(def schema:address-full
  (m/schema
    [:schema {:registry registry:shopify}
     :e.shopify/address-full]))</pre>
</z><z id="t1637865318" t="ikitommi Do you have the :merge registered? It&apos;s not in the default registry (just yet at least)"><y>#</y><d>2021-11-25</d><h>18:35</h><r>ikitommi</r>Do you have the <code>:merge</code> registered? It&apos;s not in the default registry (just yet at least)</z><z id="t1637927274" t="Ivan Fedorov [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] How would I do this? This doesn’t work at least 🙂 (def registry:shopify-- {:merge mu/merge :e.shopify/address1 [:map [:first_name string?]] :e.shopify/address2 [:map [:city string?]] :e.shopify/address-full [:merge :e.shopify/address1 :e.shopify/address2]})"><y>#</y><d>2021-11-26</d><h>11:47</h><r>Ivan Fedorov</r><a>@U055NJ5CC</a> How would I do this? This doesn’t work at least <b>🙂</b>
<pre>(def registry:shopify--
  {:merge mu/merge
   :e.shopify/address1
          [:map [:first_name string?]]
   :e.shopify/address2
          [:map [:city string?]]
   :e.shopify/address-full
          [:merge
           :e.shopify/address1
           :e.shopify/address2]})</pre></z><z id="t1638002704" t="ikitommi maps do not have order, any of the entries using merge might get resolved before the :merge . I’ll change how the default registry works, so this would be easier. Before that: 1. use mu/merge instead of :merge 2. swap the default registry with one that has the :merge 3. use composite registry, e.g. (mr/composite-registry {:merge mu/merge} {:e.shopify/address1 …}) , in case the :merge should be registered before the actual schemas"><y>#</y><d>2021-11-27</d><h>08:45</h><r>ikitommi</r>maps do not have order, any of the entries using merge might get resolved before the <code>:merge</code>. I’ll change how the default registry works, so this would be easier. Before that:
1. use <code>mu/merge</code> instead of <code>:merge</code>
2. swap the default registry with one that has the <code>:merge</code>
3. use composite registry, e.g. <code>(mr/composite-registry {:merge mu/merge} {:e.shopify/address1 …})</code>, in case the <code>:merge</code> should be registered before the actual schemas</z><z id="t1637942468" t="emccue Whats the best way to add documentation to a schema"><y>#</y><d>2021-11-26</d><h>16:01</h><w>emccue</w>Whats the best way to add documentation to a schema</z><z id="t1637942509" t="emccue [:map {:doc &quot;A position&quot;} [:x {:doc &quot;The x coordinate&quot;} :int] [:y {:doc &quot;The y coordinate&quot;} :int]]"><y>#</y><d>2021-11-26</d><h>16:01</h><w>emccue</w><pre>[:map {:doc &quot;A position&quot;}
  [:x {:doc &quot;The x coordinate&quot;} :int]
  [:y {:doc &quot;The y coordinate&quot;} :int]]</pre></z><z id="t1637942529" t="emccue i’m fine making something up, but if there is a “standard” schema property i would want to use it"><y>#</y><d>2021-11-26</d><h>16:02</h><w>emccue</w>i’m fine making something up, but if there is a “standard” schema property i would want to use it</z><z id="t1637956536" t="ikitommi :title and :description are used for JSON SCHEMA. Kinda long, but current.. standard"><y>#</y><d>2021-11-26</d><h>19:55</h><w>ikitommi</w><code>:title</code> and <code>:description</code> are used for JSON SCHEMA. Kinda long, but current.. standard</z><z id="t1637956546" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc#L16"><y>#</y><d>2021-11-26</d><h>19:55</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc#L16" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc#L16</a></z><z id="t1638018780" t="ikitommi allowing schema registry to be swapped without compiler/jvm-options: https://github.com/metosin/malli/pull/583 . There would be a &quot;strict&quot; mode too, if this is too loose for someone. But might be better for the 90% of cases? (require &apos;[malli.core :as m] &apos;[malli.util :as mu] &apos;[malli.registry :as mr] &apos;[malli.generator :as mg]) ;; look ma, just works (mr/set-default-registry! (mr/composite-registry (m/default-schemas) (mu/schemas))) (mg/generate [:merge [:map [:x :int]] [:map [:y :int]]]) ; =&gt; {:x 0, :y 92} comments welcome."><y>#</y><d>2021-11-27</d><h>13:13</h><w>ikitommi</w>allowing schema registry to be swapped without compiler/jvm-options: <a href="https://github.com/metosin/malli/pull/583" target="_blank">https://github.com/metosin/malli/pull/583</a>. There would be a <code>&quot;strict&quot;</code> mode too, if this is too loose for someone. But might be better for the 90% of cases?
<pre>(require &apos;[malli.core :as m]
         &apos;[malli.util :as mu]
         &apos;[malli.registry :as mr]
         &apos;[malli.generator :as mg])

;; look ma, just works
(mr/set-default-registry!
  (mr/composite-registry
    (m/default-schemas)
    (mu/schemas)))

(mg/generate
  [:merge
   [:map [:x :int]]
   [:map [:y :int]]])
; =&gt; {:x 0, :y 92}</pre>
comments welcome.</z><z id="t1638018855" t="ikitommi ping [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}]"><y>#</y><d>2021-11-27</d><h>13:14</h><r>ikitommi</r>ping <a>@U0A5V8ZR6</a></z><z id="t1638019017" t="ikitommi your sample could be: (mr/set-default-registry! (mr/composite-registry (m/default-schemas) (mu/schemas) {:e.shopify/address1 [:map [:first_name string?]] :e.shopify/address2 [:map [:city string?]] :e.shopify/address-full [:merge :e.shopify/address1 :e.shopify/address2]})) (mg/generate :e.shopify/address-full) ;{:first_name &quot;0GiD&quot; ; :city &quot;DMS5wc6mXcN4JCp9lJ&quot;}"><y>#</y><d>2021-11-27</d><h>13:16</h><r>ikitommi</r>your sample could be:
<pre>(mr/set-default-registry!
  (mr/composite-registry
    (m/default-schemas)
    (mu/schemas)
    {:e.shopify/address1 [:map [:first_name string?]]
     :e.shopify/address2 [:map [:city string?]]
     :e.shopify/address-full [:merge
                              :e.shopify/address1
                              :e.shopify/address2]}))

(mg/generate :e.shopify/address-full)
;{:first_name &quot;0GiD&quot;
; :city &quot;DMS5wc6mXcN4JCp9lJ&quot;}</pre></z><z id="t1638019060" t="ikitommi also, you could inject a mutable-registry as last in the registry-chain and add the schemas using custom register! fn. Mutate like a boss 🙂"><y>#</y><d>2021-11-27</d><h>13:17</h><r>ikitommi</r>also, you could inject a <code>mutable-registry</code> as last in the registry-chain and add the schemas using custom <code>register!</code> fn. Mutate like a boss <b>🙂</b></z><z id="t1638022077" t="Ivan Fedorov Oh this looks sweet! Thank you, mr Reiman!"><y>#</y><d>2021-11-27</d><h>14:07</h><r>Ivan Fedorov</r>Oh this looks sweet! Thank you, mr Reiman!</z><z id="t1638032892" t="pithyless Looking forward to this; I’ve ended up fighting the tooling too often trying to get the compiler options working correctly in a consistent way."><y>#</y><d>2021-11-27</d><h>17:08</h><r>pithyless</r>Looking forward to this; I’ve ended up fighting the tooling too often trying to get the compiler options working correctly in a consistent way.</z><z id="t1638036685" t="ikitommi merged in master. a blog post and shipping 0.7.0 out."><y>#</y><d>2021-11-27</d><h>18:11</h><r>ikitommi</r>merged in master. a blog post and shipping 0.7.0 out.</z><z id="t1638023215" t="Karol Wójcik Will malli support records?"><y>#</y><d>2021-11-27</d><h>14:26</h><w>Karol Wójcik</w>Will malli support records?</z><z id="t1638024308" t="ikitommi what would that look like?"><y>#</y><d>2021-11-27</d><h>14:45</h><r>ikitommi</r>what would that look like?</z><z id="t1638053629" t="emccue [:and [:fn #(instance? RecordType %)] [:map [:x :int] [:y :int]]] Is a basic way if you just need validation and not generation"><y>#</y><d>2021-11-27</d><h>22:53</h><r>emccue</r><pre>[:and [:fn #(instance? RecordType %)]
      [:map [:x :int] [:y :int]]]</pre>
Is a basic way if you just need validation and not generation</z><z id="t1638053740" t="emccue i’m not clever enough to compose the :map generator with map-&gt;RecordType but i assume there is a way"><y>#</y><d>2021-11-27</d><h>22:55</h><r>emccue</r>i’m not clever enough to compose the <code>:map</code> generator with <code>map-&gt;RecordType</code> but i assume there is a way</z><z id="t1638089187" t="Karol Wójcik I was thinking about something like schema is doing."><y>#</y><d>2021-11-28</d><h>08:46</h><r>Karol Wójcik</r>I was thinking about something like schema is doing.</z><z id="t1638093442" t="ikitommi m/defrecord I presume. I think Malli should have that and m/defproticol too."><y>#</y><d>2021-11-28</d><h>09:57</h><r>ikitommi</r><code>m/defrecord</code> I presume. I think Malli should have that and <code>m/defproticol</code> too.</z><z id="t1638109512" t="Karol Wójcik Cool. Looking forward to this."><y>#</y><d>2021-11-28</d><h>14:25</h><r>Karol Wójcik</r>Cool. Looking forward to this.</z><z id="t1638373996" t="wcalderipe Can I get the schema of a :multi by passing the dispatched value to a function? Example: (def Multi [:multi {:dispatch :type} [:foo [:map [:value :int]]] [:bar [:map [:value :string]]]]) (get-schema Multi {:type :foo}) ;; =&gt; [:foo [:map [:value :int]]]"><y>#</y><d>2021-12-01</d><h>15:53</h><w>wcalderipe</w>Can I get the schema of a <code>:multi</code> by passing the dispatched value to a function?

Example:

<pre>(def Multi
    [:multi {:dispatch :type}
     [:foo [:map [:value :int]]]
     [:bar [:map [:value :string]]]])

  (get-schema Multi {:type :foo}) ;; =&gt; [:foo [:map [:value :int]]]</pre></z><z id="t1638378127" t="ikitommi [:attrs {:href &quot;/_/_/users/UHD67JRL4&quot;}] , maybe: (def Multi [:multi {:dispatch :type} [:foo [:map [:value :int]]] [:bar [:map [:value :string]]]]) (defn get-schema [schema value] (some-&gt; schema m/properties :dispatch (apply (list value)) (-&gt;&gt; (mu/get schema)))) (get-schema Multi {:type :foo}) ; =&gt; [:map [:value :int]]"><y>#</y><d>2021-12-01</d><h>17:02</h><w>ikitommi</w><a>@wcalderipe</a>, maybe:
<pre>(def Multi
  [:multi {:dispatch :type}
   [:foo [:map [:value :int]]]
   [:bar [:map [:value :string]]]])

(defn get-schema [schema value]
  (some-&gt; schema
          m/properties
          :dispatch
          (apply (list value))
          (-&gt;&gt; (mu/get schema))))

(get-schema Multi {:type :foo})
; =&gt; [:map [:value :int]]</pre></z></g><g id="s20"><z id="t1638378293" t="ikitommi if you want the whole entry, use mu/find : (defn get-schema [schema value] (some-&gt; schema m/properties :dispatch (apply (list value)) (-&gt;&gt; (mu/find schema)))) (get-schema Multi {:type :foo}) ; =&gt; [:foo nil [:map [:value :int]]]"><y>#</y><d>2021-12-01</d><h>17:04</h><r>ikitommi</r>if you want the whole entry, use <code>mu/find</code>:
<pre>(defn get-schema [schema value]
  (some-&gt; schema
          m/properties
          :dispatch
          (apply (list value))
          (-&gt;&gt; (mu/find schema))))

(get-schema Multi {:type :foo})
; =&gt; [:foo nil [:map [:value :int]]]</pre></z><z id="t1638378309" t="ikitommi it’s always tuple3 of [key properties value]"><y>#</y><d>2021-12-01</d><h>17:05</h><r>ikitommi</r>it’s always tuple3 of <code>[key properties value]</code></z><z id="t1638430719" t="wcalderipe [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks a bunch for the help 🙌"><y>#</y><d>2021-12-02</d><h>07:38</h><r>wcalderipe</r><a>@U055NJ5CC</a> thanks a bunch for the help <b>🙌</b></z><z id="t1638550156" t="Ben Sless Idea - charset predicate for string schemas (alpha, alphanumeric, etc)"><y>#</y><d>2021-12-03</d><h>16:49</h><w>Ben Sless</w>Idea - charset predicate for string schemas (alpha, alphanumeric, etc)</z><z id="t1638695916" t="Ben Sless https://github.com/metosin/malli/pull/587"><y>#</y><d>2021-12-05</d><h>09:18</h><r>Ben Sless</r><a href="https://github.com/metosin/malli/pull/587" target="_blank">https://github.com/metosin/malli/pull/587</a></z><z id="t1638735958" t="ikitommi Look good. The cljs-support would be really good as I think these will be used a lot."><y>#</y><d>2021-12-05</d><h>20:25</h><r>ikitommi</r>Look good. The cljs-support would be really good as I think these will be used a lot.</z><z id="t1638736003" t="ikitommi any change of adding those too?"><y>#</y><d>2021-12-05</d><h>20:26</h><r>ikitommi</r>any change of adding those too?</z><z id="t1638736840" t="Ben Sless Theoretically, yes, practically, my knowledge in cljs is limited and we&apos;ve seen how some of the techniques I&apos;m used to from clj don&apos;t work well for cljs. Also worried about code size This will require more careful review on your end, but I don&apos;t mind giving it a shot"><y>#</y><d>2021-12-05</d><h>20:40</h><r>Ben Sless</r>Theoretically, yes, practically, my knowledge in cljs is limited and we&apos;ve seen how some of the techniques I&apos;m used to from clj don&apos;t work well for cljs.
Also worried about code size
This will require more careful review on your end, but I don&apos;t mind giving it a shot</z><z id="t1638740063" t="Ben Sless Okay, my cljs tests are failing and setting up a REPL environment is a pain. Will leave it to tomorrow"><y>#</y><d>2021-12-05</d><h>21:34</h><r>Ben Sless</r>Okay, my cljs tests are failing and setting up a REPL environment is a pain. Will leave it to tomorrow</z><z id="t1638781875" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] added cljs implementation"><y>#</y><d>2021-12-06</d><h>09:11</h><r>Ben Sless</r><a>@U055NJ5CC</a> added cljs implementation</z><z id="t1638784999" t="ikitommi partywombat commented."><y>#</y><d>2021-12-06</d><h>10:03</h><r>ikitommi</r><b>partywombat</b> commented.</z><z id="t1638785737" t="Ben Sless Agreed with most comments but I think there are some edge cases regarding blankness and nil"><y>#</y><d>2021-12-06</d><h>10:15</h><r>Ben Sless</r>Agreed with most comments but I think there are some edge cases regarding blankness and nil</z><z id="t1638695916" t="Ben Sless https://github.com/metosin/malli/pull/587"><y>#</y><d>2021-12-05</d><h>09:18</h><w>Ben Sless</w><a href="https://github.com/metosin/malli/pull/587" target="_blank">https://github.com/metosin/malli/pull/587</a></z><z id="t1638893708" t="ikitommi ,🥳"><y>#</y><d>2021-12-07</d><h>16:15</h><w>ikitommi</w>,🥳</z><z id="t1638896130" t="dharrigan Amazing! Such a great library to use!"><y>#</y><d>2021-12-07</d><h>16:55</h><w>dharrigan</w>Amazing! Such a great library to use!</z><z id="t1638896433" t="Ben Sless It&apos;s also a pleasure to hack on"><y>#</y><d>2021-12-07</d><h>17:00</h><r>Ben Sless</r>It&apos;s also a pleasure to hack on</z><z id="t1638896433" t="Ben Sless It&apos;s also a pleasure to hack on"><y>#</y><d>2021-12-07</d><h>17:00</h><w>Ben Sless</w>It&apos;s also a pleasure to hack on</z><z id="t1638911790" t="dev-hartmann Hey folks I&apos;m new to malli and really blown away by what it can do. I just have a small question I couldn&apos;t figure out from the readme ( maybe I&apos;m just blind) can I parse a json Schema to a malli schema?"><y>#</y><d>2021-12-07</d><h>21:16</h><w>dev-hartmann</w>Hey folks I&apos;m new to malli and really blown away by what it can do. I just have a small question I couldn&apos;t figure out from the readme ( maybe I&apos;m just blind) can I parse a json Schema to a malli schema?</z><z id="t1638912709" t="Ben Sless Not yet 🙂"><y>#</y><d>2021-12-07</d><h>21:31</h><r>Ben Sless</r>Not yet <b>🙂</b></z><z id="t1638912744" t="Ben Sless I started working in it but it&apos;s missing a few bits and bobs on the JSON schema specification to be happy with"><y>#</y><d>2021-12-07</d><h>21:32</h><r>Ben Sless</r>I started working in it but it&apos;s missing a few bits and bobs on the JSON schema specification to be happy with</z><z id="t1638972206" t="Yevgeni Tsodikov Hey, I see that https://clojars.org/metosin/malli/versions/0.7.0T exists in Clojars. What’s the difference between that and https://clojars.org/metosin/malli/versions/0.7.0 ?"><y>#</y><d>2021-12-08</d><h>14:03</h><w>Yevgeni Tsodikov</w>Hey, I see that <a href="https://clojars.org/metosin/malli/versions/0.7.0T" target="_blank">https://clojars.org/metosin/malli/versions/0.7.0T</a> exists in Clojars.
What’s the difference between that and <a href="https://clojars.org/metosin/malli/versions/0.7.0" target="_blank">https://clojars.org/metosin/malli/versions/0.7.0</a>?</z><z id="t1638973290" t="ikitommi It&apos;s a typo release."><y>#</y><d>2021-12-08</d><h>14:21</h><r>ikitommi</r>It&apos;s a typo release.</z><z id="t1638975966" t="Yevgeni Tsodikov It’s messing up with https://github.com/renovatebot/renovate , it thinks it’s a later release than 0.7.0 😞"><y>#</y><d>2021-12-08</d><h>15:06</h><r>Yevgeni Tsodikov</r>It’s messing up with <a href="https://github.com/renovatebot/renovate" target="_blank">https://github.com/renovatebot/renovate</a>, it thinks it’s a later release than <code>0.7.0</code> <b>😞</b></z><z id="t1638980249" t="ikitommi good thing is that the contents are identical to 0.7.0 ."><y>#</y><d>2021-12-08</d><h>16:17</h><r>ikitommi</r>good thing is that the contents are identical to <code>0.7.0</code>.</z><z id="t1638980275" t="ikitommi good reason to ship the next version soon."><y>#</y><d>2021-12-08</d><h>16:17</h><r>ikitommi</r>good reason to ship the next version soon.</z><z id="t1638980801" t="Ben Sless Even just a point release to park on the latest artifact id"><y>#</y><d>2021-12-08</d><h>16:26</h><r>Ben Sless</r>Even just a point release to park on the latest artifact id</z><z id="t1639034310" t="Ben Sless This is very cool https://github.com/erp12/schema-inference"><y>#</y><d>2021-12-09</d><h>07:18</h><w>Ben Sless</w>This is very cool <a href="https://github.com/erp12/schema-inference" target="_blank">https://github.com/erp12/schema-inference</a></z><z id="t1639050702" t="Ben Sless [:attrs {:href &quot;/_/_/users/U7XR2PZFW&quot;}]"><y>#</y><d>2021-12-09</d><h>11:51</h><r>Ben Sless</r><a>@U7XR2PZFW</a></z><z id="t1639061004" t="Eddie Thanks! I’m surprised you found this so quickly without me doing any advertising. :) I am currently using this prototype in a research project to give a more concrete example of how something like this could be valuable. After I make that work public, I plan to make a wider pitch to the community. That said, if people have any feedback and ideas now, I would love to hear it!"><y>#</y><d>2021-12-09</d><h>14:43</h><r>Eddie</r>Thanks! I’m surprised you found this so quickly without me doing any advertising. :)

I am currently using this prototype in a research project to give a more concrete example of how something like this could be valuable. After I make that work public, I plan to make a wider pitch to the community. That said, if people have any feedback and ideas now, I would love to hear it!</z><z id="t1639061061" t="Ben Sless First of all, you get cool-points 😎"><y>#</y><d>2021-12-09</d><h>14:44</h><r>Ben Sless</r>First of all, you get cool-points <b>😎</b></z><z id="t1639061114" t="Ben Sless Second, can you share some of your design decisions? Why did you choose a bespoke representation rather than use tools.analyzer output?"><y>#</y><d>2021-12-09</d><h>14:45</h><r>Ben Sless</r>Second, can you share some of your design decisions? Why did you choose a bespoke representation rather than use tools.analyzer output?</z><z id="t1639061198" t="Ben Sless Another thing I thought of while reading the code was some impedance mismatch between the type information and the expression encoding which could be unified"><y>#</y><d>2021-12-09</d><h>14:46</h><r>Ben Sless</r>Another thing I thought of while reading the code was some impedance mismatch between the type information and the expression encoding which could be unified</z><z id="t1639061349" t="Ben Sless You could create &quot;big lambda&quot; ;; Type Abstraction &apos;[:FN [:cat T] U] Then the abstraction and environment representations could be shared"><y>#</y><d>2021-12-09</d><h>14:49</h><r>Ben Sless</r>You could create &quot;big lambda&quot;
<pre>;; Type Abstraction
&apos;[:FN [:cat T] U]</pre>
Then the abstraction and environment representations could be shared</z><z id="t1639061456" t="Ben Sless Although =&gt; is pretty much that, already In its context, why do you need to tag s-vars at all? You know it&apos;s a function of type to type"><y>#</y><d>2021-12-09</d><h>14:50</h><r>Ben Sless</r>Although <code>=&gt;</code> is pretty much that, already
In its context, why do you need to tag s-vars at all? You know it&apos;s a function of type to type</z><z id="t1639062127" t="Ben Sless You can blame someone I follow for starring your project 🙂"><y>#</y><d>2021-12-09</d><h>15:02</h><r>Ben Sless</r>You can blame someone I follow for starring your project <b>🙂</b></z><z id="t1639066582" t="Eddie This is all great. I appreciate you taking the time to take a closer look. &gt; Why did you choose a bespoke representation rather than use tools.analyzer output? This is the first I’m hearing of tools.analyzer :) It seems ideal for this kind of thing. I stuck to a representation that was as close to lambda calculus and Hindley–Milner as possible to make the papers easier to translate into code. The thought of expanding the bespoke representation to cover all of Clojure gave me nightmares. Tools.analyzer might save the day. &gt; Another thing I thought of while reading the code was some impedance mismatch between the type information and the expression encoding which could be unified … &gt; Although =&gt; is pretty much that, already Yea, figured it would be nice if everyone’s function schemas “just worked” as function types during inference without any changes, so I used :=&gt; . I’m sure you noticed that only positional args are supported right now (via :cat ). At some point I would like to try to add support for varargs. Also maybe destructuring, but that might be challenging. Still, you raise a good point about the unnecessary separation between expressions trees and type/schema trees. As you mentioned, the tagging of :var and :s-var could be eliminated. Also the logically equivalent functions like substitute-vars and substitute-types could be made into 1 generic function. I went back and forth on this design decision a couple times. In the end, my decision to separate into 2 kinds of trees was motivated by wanting more explicit information about what went wrong when debugging these algorithms. I was brand new to type theory when I started. With hindsight, I wouldn’t choose the same design. Based off of 1 mornings worth of googling, I think a change to tools.analyzer and a unified encoding is a good direction!"><y>#</y><d>2021-12-09</d><h>16:16</h><r>Eddie</r>This is all great. I appreciate you taking the time to take a closer look.

&gt; Why did you choose a bespoke representation rather than use tools.analyzer output?
This is the first I’m hearing of tools.analyzer :) It seems ideal for this kind of thing. I stuck to a representation that was as close to lambda calculus and Hindley–Milner as possible to make the papers easier to translate into code. The thought of expanding the bespoke representation to cover all of Clojure gave me nightmares. Tools.analyzer might save the day.

&gt; Another thing I thought of while reading the code was some impedance mismatch between the type information and the expression encoding which could be unified …
&gt; Although =&gt; is pretty much that, already
Yea, figured it would be nice if everyone’s function schemas “just worked” as function types during inference without any changes, so I used <code>:=&gt;</code>. I’m sure you noticed that only positional args are supported right now (via <code>:cat</code>). At some point I would like to try to add support for varargs. Also maybe destructuring, but that might be challenging.

Still, you raise a good point about the unnecessary separation between expressions trees and type/schema trees. As you mentioned, the tagging of <code>:var</code> and <code>:s-var</code> could be eliminated. Also the logically equivalent functions like <code>substitute-vars</code> and <code>substitute-types</code> could be made into 1 generic function. I went back and forth on this design decision a couple times. In the end, my decision to separate into 2 kinds of trees was motivated by wanting more explicit information about what went wrong when debugging these algorithms. I was brand new to type theory when I started. With hindsight, I wouldn’t choose the same design.

Based off of 1 mornings worth of googling, I think a change to tools.analyzer and a unified encoding is a good direction!</z><z id="t1639067063" t="Ben Sless The only problem with tools analyzer is it has a lot of output which can get unwieldy, there are about 15 node types to parse there instead of 4"><y>#</y><d>2021-12-09</d><h>16:24</h><r>Ben Sless</r>The only problem with tools analyzer is it has a lot of output which can get unwieldy, there are about 15 node types to parse there instead of 4</z><z id="t1639067137" t="Ben Sless Then you might end up needing to use another method to walk the tree, either the analyzer&apos;s walk mechanism with multi methods or something like meander"><y>#</y><d>2021-12-09</d><h>16:25</h><r>Ben Sless</r>Then you might end up needing to use another method to walk the tree, either the analyzer&apos;s walk mechanism with multi methods or something like meander</z><z id="t1639067198" t="Ben Sless If you lift the type representation to ast nodes as well you could then write your own emitter which translates it back down to a schema"><y>#</y><d>2021-12-09</d><h>16:26</h><r>Ben Sless</r>If you lift the type representation to ast nodes as well you could then write your own emitter which translates it back down to a schema</z><z id="t1639035198" t="Nechemya Ungar Hi all, I am new to clojure (using clojurescript) and I come form a static-typing background (typescript), I looked into bringing some order into the code base I got into, and malli was recommended to me over spec. I wanted to say that for newcomers like me it would have been helpful if the readme actually started with introduction of the malli provider - it really helps to create a quick scaffolding for data structures. thanks2"><y>#</y><d>2021-12-09</d><h>07:33</h><w>Nechemya Ungar</w>Hi all, I am new to clojure (using clojurescript) and I come form a static-typing background (typescript), I looked into bringing some order into the code base I got into, and malli was recommended to me over spec.
I wanted to say that for newcomers like me it would have been helpful if the readme actually started with introduction of the malli provider - it really helps to create a quick scaffolding for data structures.
<b>thanks2</b></z><z id="t1639054559" t="amithgeorge In the readme, it mentions decimal? as built-in schema. Checking the relevant https://github.com/metosin/malli/blob/0.7.0/src/malli/core.cljc#L2234 , decimal? is not registered as a schema. decimal? was removed in this https://github.com/metosin/malli/commit/5deae59357b2eb3fb9890282e679bb2d7fa557e3 . Is it possible to add it back? At the moment I am using decimal? in a :fn schema and that works."><y>#</y><d>2021-12-09</d><h>12:55</h><w>amithgeorge</w>In the readme, it mentions <code>decimal?</code> as built-in schema. Checking the relevant <a href="https://github.com/metosin/malli/blob/0.7.0/src/malli/core.cljc#L2234" target="_blank">https://github.com/metosin/malli/blob/0.7.0/src/malli/core.cljc#L2234</a>, <code>decimal?</code> is not registered as a schema. <code>decimal?</code> was removed in this <a href="https://github.com/metosin/malli/commit/5deae59357b2eb3fb9890282e679bb2d7fa557e3" target="_blank">https://github.com/metosin/malli/commit/5deae59357b2eb3fb9890282e679bb2d7fa557e3</a>. Is it possible to add it back?
At the moment I am using <code>decimal?</code> in a <code>:fn</code> schema and that works.</z><z id="t1639063883" t="ikitommi PR welcome to add it back"><y>#</y><d>2021-12-09</d><h>15:31</h><r>ikitommi</r>PR welcome to add it back</z><z id="t1639067051" t="amithgeorge I maybe missing something here. I added decimal? to predicate-schemas . My expectation was after that evaling the file with this change, the following code should work (validate :decimal 10.9M) But that errors out with this message ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137). ; :malli.core/invalid-schema {:schema :decimal} For context, (validate decimal? 10.9M) works fine with the change. What else needs to change to support :decimal . Also, do you think this is needed?"><y>#</y><d>2021-12-09</d><h>16:24</h><r>amithgeorge</r>I maybe missing something here. I added <code>decimal?</code>  to <code>predicate-schemas</code>. My expectation was after that evaling the file with this change, the following code should work
<pre>(validate :decimal 10.9M)</pre>
But that errors out with this message
<pre>; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137).
; :malli.core/invalid-schema {:schema :decimal}</pre>
For context,
<pre>(validate decimal? 10.9M)</pre>
works fine with the change.

What else needs to change to support <code>:decimal</code> . Also, do you think this is needed?</z><z id="t1639067255" t="amithgeorge Found it. If :decimal support is to be added, then I need to add :decimal to type-schemas . I will exclude this change for now and raise a PR for only the inclusion of decimal? ."><y>#</y><d>2021-12-09</d><h>16:27</h><r>amithgeorge</r>Found it. If <code>:decimal</code> support is to be added, then I need to add <code>:decimal</code> to <code>type-schemas</code> . I will exclude this change for now and raise a PR for only the inclusion of <code>decimal?</code> .</z><z id="t1639068672" t="amithgeorge PR - https://github.com/metosin/malli/pull/591"><y>#</y><d>2021-12-09</d><h>16:51</h><r>amithgeorge</r>PR - <a href="https://github.com/metosin/malli/pull/591" target="_blank">https://github.com/metosin/malli/pull/591</a></z><z id="t1639070084" t="ikitommi Merged, thanks!"><y>#</y><d>2021-12-09</d><h>17:14</h><r>ikitommi</r>Merged, thanks!</z><z id="t1639138037" t="Ben Sless Thinking a bit about a workable composition of transformer and validator, will it be be correct to model it via a cps transform where validation is called after leave stage for each element? It is true that a schema could transform its children arbitrarily, so how could this be done in a single pass? Feels like trying to solve the halting problem"><y>#</y><d>2021-12-10</d><h>12:07</h><w>Ben Sless</w>Thinking a bit about a workable composition of transformer and validator, will it be be correct to model it via a cps transform where validation is called after leave stage for each element? It is true that a schema could transform its children arbitrarily, so how could this be done in a single pass? Feels like trying to solve the halting problem</z><z id="t1639142066" t="ikitommi woudn&apos;t the validation be called a lot more that actually needed? e.g. leaf validates itself, one level up needs to re-validate the leaf as part of it&apos;s own validation, etc."><y>#</y><d>2021-12-10</d><h>13:14</h><r>ikitommi</r>woudn&apos;t the validation be called a lot more that actually needed? e.g. leaf validates itself, one level up needs to re-validate the leaf as part of it&apos;s own validation, etc.</z><z id="t1639142288" t="ikitommi the prismatic approach: https://plumatic.github.io//schema-0-2-0-back-with-clojurescript-data-coercion"><y>#</y><d>2021-12-10</d><h>13:18</h><r>ikitommi</r>the prismatic approach: <a href="https://plumatic.github.io//schema-0-2-0-back-with-clojurescript-data-coercion" target="_blank">https://plumatic.github.io//schema-0-2-0-back-with-clojurescript-data-coercion</a></z><z id="t1639143079" t="Ben Sless Ideally, no, you assume the leaves are already correct if you made it to the parent then you just satisfy the parent condition or combinator"><y>#</y><d>2021-12-10</d><h>13:31</h><r>Ben Sless</r>Ideally, no, you assume the leaves are already correct if you made it to the parent then you just satisfy the parent condition or combinator</z><z id="t1639143328" t="Ben Sless Let&apos;s say that each coercer has a success or failure continuation. On failure, we just return, on success, we call the transformation and validation of the next value"><y>#</y><d>2021-12-10</d><h>13:35</h><r>Ben Sless</r>Let&apos;s say that each coercer has a success or failure continuation. On failure, we just return, on success, we call the transformation and validation of the next value</z><z id="t1639143398" t="Ben Sless Then you need to define the combination semantics for map, sequence, vector, tuple, and, or"><y>#</y><d>2021-12-10</d><h>13:36</h><r>Ben Sless</r>Then you need to define the combination semantics for map, sequence, vector, tuple, and, or</z><z id="t1639143427" t="Ben Sless Maybe the validation itself can be split to enter/leave"><y>#</y><d>2021-12-10</d><h>13:37</h><r>Ben Sless</r>Maybe the validation itself can be split to enter/leave</z><z id="t1639143452" t="Ben Sless Map could check on enter that it&apos;s a map, then coerce its children"><y>#</y><d>2021-12-10</d><h>13:37</h><r>Ben Sless</r>Map could check on enter that it&apos;s a map, then coerce its children</z><z id="t1639143608" t="Ben Sless This holds as long as a transformer doesnt modify children recursively"><y>#</y><d>2021-12-10</d><h>13:40</h><r>Ben Sless</r>This holds as long as a transformer doesnt modify children recursively</z><z id="t1639143657" t="Ben Sless Which is true for 99% of cases? So maybe there could be an optimistic coercer which isnt guaranteed to work all the time"><y>#</y><d>2021-12-10</d><h>13:40</h><r>Ben Sless</r>Which is true for 99% of cases? So maybe there could be an optimistic coercer which isnt guaranteed to work all the time</z><z id="t1639180839" t="steveb8n Q: I have a single arg fn that I am trying to generatively test. The single arg is vector that is checked using a :catn schema. when I use the =&gt; syntax, it interprets the nested :catn schema for the fn arity instead of treating it as a single arg. has anyone figured out how to do this?"><y>#</y><d>2021-12-11</d><h>00:00</h><w>steveb8n</w>Q: I have a single arg fn that I am trying to generatively test. The single arg is vector that is checked using a :catn schema. when I use the =&gt; syntax, it interprets the nested :catn schema for the fn arity instead of treating it as a single arg. has anyone figured out how to do this?</z><z id="t1639183395" t="emccue [:cat [:cat :int :int]]"><y>#</y><d>2021-12-11</d><h>00:43</h><r>emccue</r><code>[:cat [:cat :int :int]]</code></z><z id="t1639183399" t="emccue all fn args are cat"><y>#</y><d>2021-12-11</d><h>00:43</h><r>emccue</r>all fn args are cat</z><z id="t1639183425" t="emccue oh wait no i just realized your issue"><y>#</y><d>2021-12-11</d><h>00:43</h><r>emccue</r>oh wait no i just realized your issue</z><z id="t1639193243" t="steveb8n Yeah. Simple but not easy. I can work around it by wrapping with another fn with a map arg."><y>#</y><d>2021-12-11</d><h>03:27</h><r>steveb8n</r>Yeah. Simple but not easy. I can work around it by wrapping with another fn with a map arg.</z><z id="t1639193272" t="steveb8n I&apos;ll log an issue to see if we are missing something"><y>#</y><d>2021-12-11</d><h>03:27</h><r>steveb8n</r>I&apos;ll log an issue to see if we are missing something</z><z id="t1639194798" t="ikitommi wrap in :schema to push out of the sequence"><y>#</y><d>2021-12-11</d><h>03:53</h><r>ikitommi</r>wrap in <code>:schema</code> to push out of the sequence</z><z id="t1639198910" t="steveb8n thx [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I’ll give that a try"><y>#</y><d>2021-12-11</d><h>05:01</h><r>steveb8n</r>thx <a>@U055NJ5CC</a> I’ll give that a try</z><z id="t1639257287" t="steveb8n confirming, using :schema around the vector schema fixes the problem"><y>#</y><d>2021-12-11</d><h>21:14</h><r>steveb8n</r>confirming, using :schema around the vector schema fixes the problem</z><z id="t1639207228" t="Ben Sless Reading [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] FSM post again, I returned to the idea of some sort of schema router / compiler, where an or of schemas will pull out the common denominator then dispatch to the difference Thoughts?"><y>#</y><d>2021-12-11</d><h>07:20</h><w>Ben Sless</w>Reading <a>@afoltzm</a> FSM post again, I returned to the idea of some sort of schema router / compiler, where an <code>or</code> of schemas will pull out the common denominator then dispatch to the difference
Thoughts?</z><z id="t1639215543" t="steveb8n can you explain more? I’ve been using them more in SPA’s so interested in this"><y>#</y><d>2021-12-11</d><h>09:39</h><r>steveb8n</r>can you explain more? I’ve been using them more in SPA’s so interested in this</z><z id="t1639218341" t="Ben Sless Imagine [:or [:map [:a any?] [:b any?]] [:map [:a any?] [:c any?]]] =&gt; [:and [:map [:a any?]] [:or [:map [:b any?]] [:map [:c any?]]]] to start with, even smarter to have a dispatch to the correct schema instead of or"><y>#</y><d>2021-12-11</d><h>10:25</h><r>Ben Sless</r>Imagine <code>[:or [:map [:a any?] [:b any?]] [:map [:a any?] [:c any?]]]</code> =&gt; <code>[:and [:map [:a any?]] [:or [:map [:b any?]] [:map [:c any?]]]]</code> to start with, even smarter to have a dispatch to the correct schema instead of <code>or</code></z><z id="t1639236227" t="respatialized Sounds like a malli.diff namespace might be an interesting idea, because this concept may be applicable beyond just :or schemas – for example, you&apos;d be able to compare two seqex schemas and say things like &quot;sequence B can contain all the same elements as sequence A except for elements X and Y&quot;"><y>#</y><d>2021-12-11</d><h>15:23</h><r>respatialized</r>Sounds like a <code>malli.diff</code> namespace might be an interesting idea, because this concept may be applicable beyond just <code>:or</code> schemas – for example, you&apos;d be able to compare two seqex schemas and say things like &quot;sequence B can contain all the same elements as sequence A except for elements X and Y&quot;</z><z id="t1639236396" t="Ben Sless I&apos;m just getting started, [:or :int :number] =&gt; :number"><y>#</y><d>2021-12-11</d><h>15:26</h><r>Ben Sless</r>I&apos;m just getting started, <code>[:or :int :number]</code> =&gt; <code>:number</code></z><z id="t1639236438" t="Ben Sless schemas as segments and sets"><y>#</y><d>2021-12-11</d><h>15:27</h><r>Ben Sless</r>schemas as segments and sets</z><z id="t1639252934" t="mynomoto Can I have a link for this post? It looks interesting."><y>#</y><d>2021-12-11</d><h>20:02</h><r>mynomoto</r>Can I have a link for this post? It looks interesting.</z><z id="t1639253075" t="Ben Sless Sure, https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml [:attrs {:href &quot;/_/_/users/U05094X3J&quot;}]"><y>#</y><d>2021-12-11</d><h>20:04</h><r>Ben Sless</r>Sure, <a href="https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml" target="_blank">https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml</a>
<a>@mynomoto</a></z><z id="t1639255530" t="mynomoto This is really interesting, both the post and the routing idea 👏"><y>#</y><d>2021-12-11</d><h>20:45</h><r>mynomoto</r>This is really interesting, both the post and the routing idea <b>👏</b></z><z id="t1639257759" t="ikitommi just would have needed an intersection of two map schemas yesterday."><y>#</y><d>2021-12-11</d><h>21:22</h><r>ikitommi</r>just would have needed an <code>intersection</code> of two map schemas yesterday.</z><z id="t1639257857" t="ikitommi pluggable optimizer is a great idea, here&apos;s one stab at it: https://github.com/miikka/boolean-simplifier"><y>#</y><d>2021-12-11</d><h>21:24</h><r>ikitommi</r>pluggable optimizer is a great idea, here&apos;s one stab at it: <a href="https://github.com/miikka/boolean-simplifier" target="_blank">https://github.com/miikka/boolean-simplifier</a></z><z id="t1639301543" t="Ben Sless [:attrs {:href &quot;/_/_/users/U7XR2PZFW&quot;}] &apos;s work on inference could intersect with this as well. Every type of/or schema can represent a set of predicates. A predicate can be a singular predicate, a segment (upper and lower bounds) or finite domain (min max)"><y>#</y><d>2021-12-12</d><h>09:32</h><r>Ben Sless</r><a>@U7XR2PZFW</a>&apos;s work on inference could intersect with this as well.
Every type of/or schema can represent a set of predicates. A predicate can be a singular predicate, a segment (upper and lower bounds) or finite domain (min max)</z><z id="t1639338590" t="Eddie Sounds like roughly equivalent to sub-typing for structural types. If we assume collections are covariant with respect to elements, functions are contravariant with respect to arguments, and a few other assumptions, I suspect small-ish rule system could be used to implement a sub-type predicate."><y>#</y><d>2021-12-12</d><h>19:49</h><r>Eddie</r>Sounds like roughly equivalent to sub-typing for structural types. If we assume collections are covariant with respect to elements, functions are contravariant with respect to arguments, and a few other assumptions, I suspect small-ish rule system could be used to implement a sub-type predicate.</z><z id="t1639338778" t="Ben Sless We can even unpack map schemas to a closed set of predicates, being map? and a set of all the entry predicates. Same for tuples. Then conjunction and disjunction are pretty well defined and we remain in predicate land and not structure. Not sure if it&apos;s good"><y>#</y><d>2021-12-12</d><h>19:52</h><r>Ben Sless</r>We can even unpack map schemas to a closed set of predicates, being map? and a set of all the entry predicates. Same for tuples. Then conjunction and disjunction are pretty well defined and we remain in predicate land and not structure.
Not sure if it&apos;s good</z><z id="t1639339814" t="Ben Sless Roughly: (defprotocol SchemaDomain (-conj [this that]) ;; and (-disj [this that]) ;; or (-isa? [this that]) (-walk [this])) (defrecord EntrySchema [k v] (-conj [this that] (EntrySchema. k (-conj v (:v that)))) (-disj [this that] (EntrySchema. k (-disj v (:v that))))) (defrecord PredicateSchema [p] (-conj [this that] (cond (-isa? this that) this (-isa? that this) that :else (-and this that))) (-disj [this that] (cond (-isa? this that) that (-isa? that this) this :else (-or this that)))) "><y>#</y><d>2021-12-12</d><h>20:10</h><r>Ben Sless</r>Roughly:
<pre>(defprotocol SchemaDomain
  (-conj [this that]) ;; and
  (-disj [this that]) ;; or
  (-isa? [this that])
  (-walk [this]))

(defrecord EntrySchema [k v]
  (-conj [this that]
    (EntrySchema. k (-conj v (:v that))))
  (-disj [this that]
    (EntrySchema. k (-disj v (:v that)))))

(defrecord PredicateSchema [p]
  (-conj [this that]
    (cond
      (-isa? this that) this
      (-isa? that this) that
      :else (-and this that)))
  (-disj [this that]
    (cond
      (-isa? this that) that
      (-isa? that this) this
      :else (-or this that))))</pre>
</z><z id="t1639251831" t="respatialized I&apos;ve encountered an issue where sequence schemas appear not to preserve metadata of input collections: (meta (m/decode [:schema {:decode/get {:enter identity}} [:cat [:= :start] :map]] (with-meta [:start {:a 2}] {:meta true}) (mt/transformer {:name :get}))) ;; =&gt; nil (meta (m/encode [:schema {:encode/get {:enter identity}} [:cat [:= :start] :map]] (with-meta [:start {:a 2}] {:meta true}) (mt/transformer {:name :get}))) ;; =&gt; nil is this expected behavior, or should malli preserve this information?"><y>#</y><d>2021-12-11</d><h>19:43</h><w>respatialized</w>I&apos;ve encountered an issue where sequence schemas appear not to preserve metadata of input collections:
<pre>(meta (m/decode
         [:schema {:decode/get {:enter identity}} [:cat [:= :start] :map]]
         (with-meta [:start {:a 2}] {:meta true})
         (mt/transformer {:name :get})))
;; =&gt; nil

(meta (m/encode
         [:schema {:encode/get {:enter identity}} [:cat [:= :start] :map]]
         (with-meta [:start {:a 2}] {:meta true})
         (mt/transformer {:name :get})))
;; =&gt; nil</pre>
is this expected behavior, or should <code>malli</code> preserve this information?</z><z id="t1639251889" t="respatialized (happy to file an issue on GitHub if it would be helpful)"><y>#</y><d>2021-12-11</d><h>19:44</h><r>respatialized</r>(happy to file an issue on GitHub if it would be helpful)</z><z id="t1639253075" t="Ben Sless Sure, https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml [:attrs {:href &quot;/_/_/users/U05094X3J&quot;}]"><y>#</y><d>2021-12-11</d><h>20:04</h><w>Ben Sless</w>Sure, <a href="https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml" target="_blank">https://fabricate-site.github.io/fabricate/finite-schema-machines.htmlhtml</a>
<a>@mynomoto</a></z><z id="t1639297641" t="ikitommi related to is-a relations, malli should have more concrete type definitions in the core, e.g. pos-int? is not a type, it’s a :int with constraint of being positive. Less types to map in transformers and just better. Related: • https://github.com/metosin/malli/issues/264 • https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L18-L51"><y>#</y><d>2021-12-12</d><h>08:27</h><w>ikitommi</w>related to is-a relations, malli should have more concrete type definitions in the core, e.g. <code>pos-int?</code> is not a type, it’s a <code>:int</code> with constraint of being positive. Less types to map in transformers and just better. Related:
• <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a>
• <a href="https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L18-L51" target="_blank">https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L18-L51</a></z><z id="t1639325427" t="ikitommi on master - adding type-hints for providers, starting with :map-of : (require &apos;[malli.provider :as mp]) (mp/provide [^{::mp/hint :map-of} {:a {:b 1, :c 2} :b {:b 2, :c 1} :c {:b 3} :d nil}]) ;[:map-of ; keyword? ; [:maybe [:map ; [:b int?] ; [:c {:optional true} int?]]]]"><y>#</y><d>2021-12-12</d><h>16:10</h><w>ikitommi</w>on master - adding type-hints for providers, starting with <code>:map-of</code>:
<pre>(require &apos;[malli.provider :as mp])

(mp/provide
  [^{::mp/hint :map-of}
   {:a {:b 1, :c 2}
    :b {:b 2, :c 1}
    :c {:b 3}
    :d nil}])
;[:map-of
; keyword?
; [:maybe [:map
;          [:b int?]
;          [:c {:optional true} int?]]]]</pre></z><z id="t1639325517" t="ikitommi the current threshold with unified key &amp; values schemas is 3, so: (mp/provide [{:a [1] :b [1 2] :c [1 2 3]}]) ; [:map-of keyword? [:vector int?]]"><y>#</y><d>2021-12-12</d><h>16:11</h><w>ikitommi</w>the current threshold with unified key &amp; values schemas is 3, so:
<pre>(mp/provide
  [{:a [1]
    :b [1 2]
    :c [1 2 3]}])
; [:map-of keyword? [:vector int?]]</pre></z><z id="t1639325524" t="ikitommi … can be configured via options."><y>#</y><d>2021-12-12</d><h>16:12</h><w>ikitommi</w>… can be configured via options.</z><z id="t1639325543" t="ikitommi providers start to be useful 🙂"><y>#</y><d>2021-12-12</d><h>16:12</h><w>ikitommi</w>providers start to be useful <b>🙂</b></z><z id="t1639342256" t="ikitommi adding :tuple inferreing, provider already 89 loc 🙀"><y>#</y><d>2021-12-12</d><h>20:50</h><w>ikitommi</w>adding <code>:tuple</code> inferreing, provider already 89 loc <b>🙀</b></z><z id="t1639342369" t="ikitommi with :malli.provider/tuple-threshold defaulting to 3: ;; tuple-like with too few elements [[:vector some?] [[1 &quot;2&quot; true] [2 &quot;2&quot; true]]] ;; tuple-like with enough samples [[:tuple int? string? boolean?] [[1 &quot;2&quot; true] [2 &quot;2&quot; true]] {::mp/tuple-threshold 2}] ;; tuple-like with enough samples [[:tuple int? string? boolean?] [[1 &quot;2&quot; true] [2 &quot;2&quot; true] [3 &quot;3&quot; true]]] ;; tuple-like with non-coherent data [[:vector some?] [[1 &quot;2&quot; true] [2 &quot;2&quot; true] [3 &quot;3&quot; &quot;true&quot;]]] ;; a homogenous hinted tuple [[:tuple int? string? boolean?] [^{::mp/hint :tuple} [1 &quot;2&quot; true] [2 &quot;2&quot; true]]] ;; a hererogenous hinted tuple [[:tuple int? string? some?] [^{::mp/hint :tuple} [1 &quot;2&quot; true] [2 &quot;2&quot; &quot;true&quot;]]] ;; invalid hinted tuple [[:vector some?] [^{::mp/hint :tuple} [1 &quot;2&quot; true] [2 &quot;2&quot; true &quot;invalid tuple&quot;]]]"><y>#</y><d>2021-12-12</d><h>20:52</h><w>ikitommi</w>with <code>:malli.provider/tuple-threshold</code> defaulting to 3:
<pre>;; tuple-like with too few elements
   [[:vector some?]
    [[1 &quot;2&quot; true]
     [2 &quot;2&quot; true]]]

   ;; tuple-like with enough samples
   [[:tuple int? string? boolean?]
    [[1 &quot;2&quot; true]
     [2 &quot;2&quot; true]]
    {::mp/tuple-threshold 2}]

   ;; tuple-like with enough samples
   [[:tuple int? string? boolean?]
    [[1 &quot;2&quot; true]
     [2 &quot;2&quot; true]
     [3 &quot;3&quot; true]]]

   ;; tuple-like with non-coherent data
   [[:vector some?]
    [[1 &quot;2&quot; true]
     [2 &quot;2&quot; true]
     [3 &quot;3&quot; &quot;true&quot;]]]

   ;; a homogenous hinted tuple
   [[:tuple int? string? boolean?]
    [^{::mp/hint :tuple} [1 &quot;2&quot; true]
     [2 &quot;2&quot; true]]]

   ;; a hererogenous hinted tuple
   [[:tuple int? string? some?]
    [^{::mp/hint :tuple} [1 &quot;2&quot; true]
     [2 &quot;2&quot; &quot;true&quot;]]]

   ;; invalid hinted tuple
   [[:vector some?]
    [^{::mp/hint :tuple} [1 &quot;2&quot; true]
     [2 &quot;2&quot; true &quot;invalid tuple&quot;]]]</pre></z><z id="t1639342408" t="ikitommi https://github.com/metosin/malli/pull/593"><y>#</y><d>2021-12-12</d><h>20:53</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/593" target="_blank">https://github.com/metosin/malli/pull/593</a></z><z id="t1639691157" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] The newest clj-kondo (just released) supports automatically loading configs from .clj-kondo/*/*/config.edn - just saying :)"><y>#</y><d>2021-12-16</d><h>21:45</h><w>borkdude</w><a>@ikitommi</a> The newest clj-kondo (just released) supports automatically loading configs from <code>.clj-kondo/*/*/config.edn</code>  - just saying :)</z><z id="t1639823842" t="ikitommi this is great news 🥳 !!"><y>#</y><d>2021-12-18</d><h>10:37</h><r>ikitommi</r>this is great news <b>🥳</b> !!</z><z id="t1639831716" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] so, this looks right? https://github.com/metosin/malli/pull/598"><y>#</y><d>2021-12-18</d><h>12:48</h><r>ikitommi</r><a>@U04V15CAJ</a> so, this looks right? <a href="https://github.com/metosin/malli/pull/598" target="_blank">https://github.com/metosin/malli/pull/598</a></z><z id="t1639831759" t="ikitommi file-writing looks like: #?(:clj (defn save! [config] (let [cfg-file (io/file &quot;.clj-kondo&quot; &quot;configs&quot; &quot;malli&quot; &quot;config.edn&quot;)] (io/make-parents cfg-file) (spit cfg-file config) config)))"><y>#</y><d>2021-12-18</d><h>12:49</h><r>ikitommi</r>file-writing looks like:
<pre>#?(:clj
   (defn save! [config]
     (let [cfg-file (io/file &quot;.clj-kondo&quot; &quot;configs&quot; &quot;malli&quot; &quot;config.edn&quot;)]
       (io/make-parents cfg-file)
       (spit cfg-file config)
       config)))</pre></z><z id="t1639831811" t="borkdude it&apos;s recommended to write a directory that looks like: &lt;org&gt;/&lt;lib&gt;/config.edn"><y>#</y><d>2021-12-18</d><h>12:50</h><r>borkdude</r>it&apos;s recommended to write a directory that looks like:
<pre>&lt;org&gt;/&lt;lib&gt;/config.edn</pre></z><z id="t1639831825" t="borkdude so then it would be: &lt;metosin&gt;/&lt;malli&gt;/config.edn"><y>#</y><d>2021-12-18</d><h>12:50</h><r>borkdude</r>so then it would be:
<pre>&lt;metosin&gt;/&lt;malli&gt;/config.edn</pre></z><z id="t1639831853" t="borkdude but this is usually for configs about malli and not provided by malli about other things"><y>#</y><d>2021-12-18</d><h>12:50</h><r>borkdude</r>but this is usually for configs about malli and not provided by malli about other things</z><z id="t1639831889" t="borkdude so maybe this would be better and would still give room for malli itself to export config for its own macros too: &lt;metosin&gt;/&lt;malli-type-anns&gt;/config.edn "><y>#</y><d>2021-12-18</d><h>12:51</h><r>borkdude</r>so maybe this would be better and would still give room for malli itself to export config for its own macros too:
<pre>&lt;metosin&gt;/&lt;malli-type-anns&gt;/config.edn</pre>
</z><z id="t1639831925" t="borkdude but you are correct that the config isn&apos;t necessary anymore on the user&apos;s behalf"><y>#</y><d>2021-12-18</d><h>12:52</h><r>borkdude</r>but you are correct that the config isn&apos;t necessary anymore on the user&apos;s behalf</z><z id="t1639859008" t="ikitommi for some reason, the auto-loading doesn’t work for me :thinking_face:"><y>#</y><d>2021-12-18</d><h>20:23</h><r>ikitommi</r>for some reason, the auto-loading doesn’t work for me <b>:thinking_face:</b></z><z id="t1639859025" t="ikitommi repro: https://github.com/metosin/malli/pull/598"><y>#</y><d>2021-12-18</d><h>20:23</h><r>ikitommi</r>repro: <a href="https://github.com/metosin/malli/pull/598" target="_blank">https://github.com/metosin/malli/pull/598</a></z><z id="t1639859034" t="borkdude have you upgraded clj-kondo"><y>#</y><d>2021-12-18</d><h>20:23</h><r>borkdude</r>have you upgraded clj-kondo</z><z id="t1639859065" t="ikitommi ➜ malli git:(clj-kondo-config-fix) ./bin/kaocha --focus malli.clj-kondo-test [(.....)] 1 tests, 5 assertions, 0 failures. ➜ malli git:(clj-kondo-config-fix) cat .clj-kondo/configs/metosin/malli/config.edn {:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}, :type-mismatch {:namespaces {malli.clj-kondo-test {kikka {:arities {1 {:args [:int], :ret :int}, :varargs {:args [:int :int {:op :rest, :spec :int}], :ret :int, :min-arity 2}}}, siren {:arities {2 {:args [:ifn :coll], :ret :map}}}}}}}}% ➜ malli git:(clj-kondo-config-fix) clojure -Sdeps &apos;{:deps {clj-kondo/clj-kondo {:mvn/version &quot;2021.12.16&quot;}}}&apos; -M -m clj-kondo.main --lint test/malli/clj_kondo_test.cljc linting took 163ms, errors: 0, warnings: 0 ➜ malli git:(clj-kondo-config-fix) echo &apos;{:config-paths [&quot;configs/metosin/malli&quot;]}&apos; &gt; .clj-kondo/config.edn ➜ malli git:(clj-kondo-config-fix) clojure -Sdeps &apos;{:deps {clj-kondo/clj-kondo {:mvn/version &quot;2021.12.16&quot;}}}&apos; -M -m clj-kondo.main --lint test/malli/clj_kondo_test.cljc test/malli/clj_kondo_test.cljc:80:9: error: Expected: integer, received: string. linting took 200ms, errors: 1, warnings: 0"><y>#</y><d>2021-12-18</d><h>20:24</h><r>ikitommi</r><pre>➜  malli git:(clj-kondo-config-fix) ./bin/kaocha --focus malli.clj-kondo-test
[(.....)]
1 tests, 5 assertions, 0 failures.

➜  malli git:(clj-kondo-config-fix) cat .clj-kondo/configs/metosin/malli/config.edn
{:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}, :type-mismatch {:namespaces {malli.clj-kondo-test {kikka {:arities {1 {:args [:int], :ret :int}, :varargs {:args [:int :int {:op :rest, :spec :int}], :ret :int, :min-arity 2}}}, siren {:arities {2 {:args [:ifn :coll], :ret :map}}}}}}}}%

➜  malli git:(clj-kondo-config-fix) clojure -Sdeps &apos;{:deps {clj-kondo/clj-kondo {:mvn/version &quot;2021.12.16&quot;}}}&apos; -M -m clj-kondo.main --lint test/malli/clj_kondo_test.cljc
linting took 163ms, errors: 0, warnings: 0

➜  malli git:(clj-kondo-config-fix) echo &apos;{:config-paths [&quot;configs/metosin/malli&quot;]}&apos; &gt; .clj-kondo/config.edn

➜  malli git:(clj-kondo-config-fix) clojure -Sdeps &apos;{:deps {clj-kondo/clj-kondo {:mvn/version &quot;2021.12.16&quot;}}}&apos; -M -m clj-kondo.main --lint test/malli/clj_kondo_test.cljc
test/malli/clj_kondo_test.cljc:80:9: error: Expected: integer, received: string.
linting took 200ms, errors: 1, warnings: 0</pre></z><z id="t1639859079" t="ikitommi I think that’s the latest one"><y>#</y><d>2021-12-18</d><h>20:24</h><r>ikitommi</r>I think that’s the latest one</z><z id="t1639859124" t="borkdude you should use the pattern .clj-kondo/*/*/config.edn , you have one dir too many"><y>#</y><d>2021-12-18</d><h>20:25</h><r>borkdude</r>you should use the pattern <code>.clj-kondo/*/*/config.edn</code> , you have one dir too many</z><z id="t1639859154" t="ikitommi oh, it was not ** ! 🙂"><y>#</y><d>2021-12-18</d><h>20:25</h><r>ikitommi</r>oh, it was not <code>**</code>! <b>🙂</b></z><z id="t1639859155" t="borkdude .clj-kondo/metosin/malli"><y>#</y><d>2021-12-18</d><h>20:25</h><r>borkdude</r><code>.clj-kondo/metosin/malli</code></z><z id="t1639859232" t="borkdude but I would rename this dir, as I said"><y>#</y><d>2021-12-18</d><h>20:27</h><r>borkdude</r>but I would rename this dir, as I said</z><z id="t1639859233" t="ikitommi works like a charm, 🙇"><y>#</y><d>2021-12-18</d><h>20:27</h><r>ikitommi</r>works like a charm, <b>🙇</b></z><z id="t1639859242" t="ikitommi yes, I will, just trying it out"><y>#</y><d>2021-12-18</d><h>20:27</h><r>ikitommi</r>yes, I will, just trying it out</z><z id="t1639859243" t="borkdude .clj-kondo/metosin/malli-types or so"><y>#</y><d>2021-12-18</d><h>20:27</h><r>borkdude</r><code>.clj-kondo/metosin/malli-types</code> or so</z><z id="t1639859255" t="borkdude so you can still export config for malli itself at one point"><y>#</y><d>2021-12-18</d><h>20:27</h><r>borkdude</r>so you can still export config for malli itself at one point</z><z id="t1639859428" t="ikitommi yes, changed that, will merge when tests pass. This is a really good change, makes the newbie user experience so much better."><y>#</y><d>2021-12-18</d><h>20:30</h><r>ikitommi</r>yes, changed that, will merge when tests pass. This is a really good change, makes the newbie user experience so much better.</z><z id="t1639859444" t="borkdude I hope so.. :)"><y>#</y><d>2021-12-18</d><h>20:30</h><r>borkdude</r>I hope so.. :)</z><z id="t1639823912" t="ikitommi more batteries for value type inferring ( https://github.com/metosin/malli/pull/597 ): (require &apos;[malli.provider :as mp]) (require &apos;[malli.transform :as mt]) (mp/provide [{:id &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;} {:id &quot;8aadbf5e-5fe3-11ec-bf63-0242ac130002&quot;}]) ; =&gt; [:map [:id string?]] (mp/provide [{:id &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;} {:id &quot;8aadbf5e-5fe3-11ec-bf63-0242ac130002&quot;}] {::mp/value-providers {&apos;string? {:uuid mt/-string-&gt;uuid}}}) ; =&gt; [:map [:id :uuid]] (mp/provide [{&quot;0423191a-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;0423191a-5fee-11ec-bf63-0242ac130002&quot;} &quot;09e59de6-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;09e59de6-5fee-11ec-bf63-0242ac130002&quot;} &quot;15511020-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;15511020-5fee-11ec-bf63-0242ac130002&quot;}}] {::mp/value-providers {&apos;string? {:uuid mt/-string-&gt;uuid}}}) ; =&gt; [:map-of :uuid [:map [:id :uuid]]]"><y>#</y><d>2021-12-18</d><h>10:38</h><w>ikitommi</w>more batteries for value type inferring (<a href="https://github.com/metosin/malli/pull/597" target="_blank">https://github.com/metosin/malli/pull/597</a>):
<pre>(require &apos;[malli.provider :as mp])
(require &apos;[malli.transform :as mt])

(mp/provide
 [{:id &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;}
  {:id &quot;8aadbf5e-5fe3-11ec-bf63-0242ac130002&quot;}])
; =&gt; [:map [:id string?]]

(mp/provide
 [{:id &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;}
  {:id &quot;8aadbf5e-5fe3-11ec-bf63-0242ac130002&quot;}]
 {::mp/value-providers {&apos;string? {:uuid mt/-string-&gt;uuid}}})
; =&gt; [:map [:id :uuid]]

(mp/provide
 [{&quot;0423191a-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;0423191a-5fee-11ec-bf63-0242ac130002&quot;}
   &quot;09e59de6-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;09e59de6-5fee-11ec-bf63-0242ac130002&quot;}
   &quot;15511020-5fee-11ec-bf63-0242ac130002&quot; {:id &quot;15511020-5fee-11ec-bf63-0242ac130002&quot;}}]
 {::mp/value-providers {&apos;string? {:uuid mt/-string-&gt;uuid}}})
; =&gt; [:map-of :uuid [:map [:id :uuid]]]</pre></z><z id="t1639864763" t="respatialized I am encountering an arity error when I try to create a function schema for a multi-arity fn that accepts a vector of a specific type as an input. (m/schema [:function [:=&gt; [:cat [:schema [:* :int]]] :any] [:=&gt; [:cat [:schema [:* :int]] :boolean] :any]]) This produces the following error (I confirmed this with the latest tagged release of malli , 0.7.4 ): {:type :malli.core/duplicate-arities, :message :malli.core/duplicate-arities, :data {:infos [{:min 0, :arity :varargs, :input [:cat [:schema [:* :int]]], :output :any} {:min 1, :arity :varargs, :input [:cat [:schema [:* :int]] :boolean], :output :any}]}} I had figured that wrapping the input sequence schema in :schema would mark it as a distinct sequential value rather than a subcomponent of the input arg vector, but it appears that malli is treating an input vector of an arbitrary size as indicating that the function is supposed to have varargs, resulting in a clash between the arities of the function."><y>#</y><d>2021-12-18</d><h>21:59</h><w>respatialized</w>I am encountering an arity error when I try to create a function schema for a multi-arity fn that accepts a vector of a specific type as an input.
<pre>(m/schema
 [:function
  [:=&gt; [:cat [:schema [:* :int]]] :any]
  [:=&gt; [:cat [:schema [:* :int]] :boolean] :any]])</pre>
This produces the following error (I confirmed this with the latest tagged release of <code>malli</code>, <code>0.7.4</code>):
<pre>{:type :malli.core/duplicate-arities,
    :message :malli.core/duplicate-arities,
    :data
    {:infos
     [{:min 0, :arity :varargs, :input [:cat [:schema [:* :int]]], :output :any}
      {:min 1,
       :arity :varargs,
       :input [:cat [:schema [:* :int]] :boolean],
       :output :any}]}}</pre>
I had figured that wrapping the input sequence schema in <code>:schema</code> would mark it as a distinct sequential value rather than a subcomponent of the input arg vector, but it appears that <code>malli</code> is treating an input vector of an arbitrary size as indicating that the function is supposed to have varargs, resulting in a clash between the arities of the function.</z><z id="t1639865232" t="respatialized running mg/generate on the arity input seqexes independently produces values that I expect to see: (mg/generate [:cat [:schema [:cat [:* :int]]] :boolean]) ;; =&gt; ((-2 2096836 3803 45 -49393) false) (mg/generate [:cat [:schema [:cat [:* :int]]]]) ;; =&gt; ((-1709 -2289 -38 3962880 -8 -948 13075997 77734 -16118422 635358 2 -1 -1))"><y>#</y><d>2021-12-18</d><h>22:07</h><r>respatialized</r>running <code>mg/generate</code> on the arity input seqexes independently produces values that I expect to see:
<pre>(mg/generate [:cat [:schema [:cat [:* :int]]] :boolean])
;; =&gt; ((-2 2096836 3803 45 -49393) false)
(mg/generate [:cat [:schema [:cat [:* :int]]]])
;; =&gt; ((-1709 -2289 -38 3962880 -8 -948 13075997 77734 -16118422 635358 2 -1 -1))</pre></z><z id="t1639903112" t="ikitommi Looks like :schema has a bug related to m/-regex-min-max : (m/-regex-min-max (m/schema [:cat [:schema [:* :int]]])) ; =&gt; {:min 0} could you write an issue out of this?"><y>#</y><d>2021-12-19</d><h>08:38</h><r>ikitommi</r>Looks like <code>:schema</code> has a bug related to <code>m/-regex-min-max</code> :
<pre>(m/-regex-min-max
 (m/schema
  [:cat [:schema [:* :int]]]))
; =&gt; {:min 0}</pre>
could you write an issue out of this?</z><z id="t1639903163" t="ikitommi while waiting, you can try: (m/-regex-min-max (m/schema [:cat [:sequential :int]])) ; =&gt; {:min 1, :max 1}"><y>#</y><d>2021-12-19</d><h>08:39</h><r>ikitommi</r>while waiting, you can try:
<pre>(m/-regex-min-max
 (m/schema
  [:cat [:sequential :int]]))
; =&gt; {:min 1, :max 1}</pre></z><z id="t1639903288" t="ikitommi .. and if it’s a vector, this is a way to describe it: (m/schema [:function [:=&gt; [:cat [:vector :int]] :any] [:=&gt; [:cat [:vector :int] :boolean] :any]]) ping [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}]"><y>#</y><d>2021-12-19</d><h>08:41</h><r>ikitommi</r>.. and if it’s a vector, this is a way to describe it:
<pre>(m/schema
 [:function
  [:=&gt; [:cat [:vector :int]] :any]
  [:=&gt; [:cat [:vector :int] :boolean] :any]])</pre>
ping <a>@UFTRLDZEW</a></z><z id="t1639903305" t="ikitommi but, please issue the original, as it’s a bug."><y>#</y><d>2021-12-19</d><h>08:41</h><r>ikitommi</r>but, please issue the original, as it’s a bug.</z><z id="t1640013098" t="respatialized https://github.com/metosin/malli/issues/601 [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thanks for taking a look."><y>#</y><d>2021-12-20</d><h>15:11</h><r>respatialized</r><a href="https://github.com/metosin/malli/issues/601" target="_blank">https://github.com/metosin/malli/issues/601</a> <a>@U055NJ5CC</a> thanks for taking a look.</z><z id="t1639865232" t="respatialized running mg/generate on the arity input seqexes independently produces values that I expect to see: (mg/generate [:cat [:schema [:cat [:* :int]]] :boolean]) ;; =&gt; ((-2 2096836 3803 45 -49393) false) (mg/generate [:cat [:schema [:cat [:* :int]]]]) ;; =&gt; ((-1709 -2289 -38 3962880 -8 -948 13075997 77734 -16118422 635358 2 -1 -1))"><y>#</y><d>2021-12-18</d><h>22:07</h><w>respatialized</w>running <code>mg/generate</code> on the arity input seqexes independently produces values that I expect to see:
<pre>(mg/generate [:cat [:schema [:cat [:* :int]]] :boolean])
;; =&gt; ((-2 2096836 3803 45 -49393) false)
(mg/generate [:cat [:schema [:cat [:* :int]]]])
;; =&gt; ((-1709 -2289 -38 3962880 -8 -948 13075997 77734 -16118422 635358 2 -1 -1))</pre></z><z id="t1639895919" t="Nechemya Ungar java.lang.RuntimeException: Unable to resolve symbol: qualified-keyword? in this context, compiling:(malli/core.cljc:167:51) Hi all: I have run into this error last week, at the beginning lein clean would resolve the issue but now our clojurescript project would not compile with malli . If we add malli to our dependencies in project.clj and require malli.core the compiler spits out the aforementioned error. Is there a minimum clojure/clojurescript version? this is our versions: [org.clojure/clojurescript &quot;1.10.439&quot;] [org.clojure/clojure &quot;1.8.0&quot;] Thank you 🙏"><y>#</y><d>2021-12-19</d><h>06:38</h><w>Nechemya Ungar</w><code>java.lang.RuntimeException: Unable to resolve symbol: qualified-keyword? in this context, compiling:(malli/core.cljc:167:51)</code>
Hi all:
I have run into this error last week, at the beginning <code>lein clean</code> would  resolve the issue but now our clojurescript project would not compile with <code>malli</code> .
If we add <code>malli</code> to our dependencies in  <code>project.clj</code> and require <code>malli.core</code> the compiler spits out the aforementioned error. Is there a minimum clojure/clojurescript version?
this is our versions:
<pre>[org.clojure/clojurescript &quot;1.10.439&quot;]
[org.clojure/clojure &quot;1.8.0&quot;]</pre>
Thank you <b>🙏</b></z><z id="t1639903497" t="juhoteperi Qualified-keyword? was added in 1.9"><y>#</y><d>2021-12-19</d><h>08:44</h><r>juhoteperi</r>Qualified-keyword? was added in 1.9</z><z id="t1639903645" t="Nechemya Ungar wow, thank you for pointing it out (I am new to clojure) so I wonder why it worked in the 1st place"><y>#</y><d>2021-12-19</d><h>08:47</h><r>Nechemya Ungar</r>wow,
thank you for pointing it out (I am new to clojure)
 so I wonder why it worked in the 1st place</z><z id="t1639904760" t="juhoteperi Well, you have the Cljs 1.10 so that does have qualified-keyword. If you aren&apos;t using Malli in Clojure side, the problem could be macro use from Cljs and perhaps you changed something that caused Malli to be required in Cljs macro compilation time (so in Clj side)?"><y>#</y><d>2021-12-19</d><h>09:06</h><r>juhoteperi</r>Well, you have the Cljs 1.10 so that does have qualified-keyword.

If you aren&apos;t using Malli in Clojure side, the problem could be macro use from Cljs and perhaps you changed something that caused Malli to be required in Cljs macro compilation time (so in Clj side)?</z><z id="t1639904871" t="juhoteperi And btw. Malli requires 1.10, there is another case why 1.9 isn&apos;t enough."><y>#</y><d>2021-12-19</d><h>09:07</h><r>juhoteperi</r>And btw. Malli requires 1.10, there is another case why 1.9 isn&apos;t enough.</z><z id="t1639906386" t="juhoteperi Readme mentions 1.10 now"><y>#</y><d>2021-12-19</d><h>09:33</h><r>juhoteperi</r>Readme mentions 1.10 now</z><z id="t1639910810" t="Ben Sless tangential question, why were you using 1.8 to begin with?"><y>#</y><d>2021-12-19</d><h>10:46</h><r>Ben Sless</r>tangential question, why were you using 1.8 to begin with?</z><z id="t1639911195" t="Nechemya Ungar Well I came into the company half a year ago, I was doing typescript before... So I didn&apos;t touch anything related to the config"><y>#</y><d>2021-12-19</d><h>10:53</h><r>Nechemya Ungar</r>Well I came into the company half a year ago, I was doing typescript before... So I didn&apos;t touch anything related to the config</z><z id="t1639911231" t="Nechemya Ungar The code base is immense I thought using some schemas can help and malli was recommended to me over spec"><y>#</y><d>2021-12-19</d><h>10:53</h><r>Nechemya Ungar</r>The code base is immense I thought using some schemas can help and malli was recommended to me over spec</z><z id="t1639905792" t="ikitommi released [metosin/malli &quot;0.7.5&quot;] , a fifth patch since 0.7.0, accumulated changes: • https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20211216  can load malli type configs automatically from new location (`.clj-kondo/metosin/malli-types/config.edn`), thanks [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] . • use  https://github.com/brandonbloom/fipp  for fast pretty-printing the clj-kondo configs • updated dependencies • schema inferring supports value decoding via options • :map-of  inferring can be forced with `:malli.provider/hint :map-of` meta-data • :tuple  inferring (supports type-hints and threshold options) • FIX Function with Sequential return value cannot define as function schema • FIX `decimal?` predicate schema was removed in 0.7.0"><y>#</y><d>2021-12-19</d><h>09:23</h><w>ikitommi</w>released <code>[metosin/malli &quot;0.7.5&quot;]</code>,  a fifth patch since 0.7.0, accumulated changes:
• <a href="https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20211216" target="_blank">https://github.com/clj-kondo/clj-kondo/blob/master/CHANGELOG.md#20211216</a> can load malli type configs automatically from new location (`.clj-kondo/metosin/malli-types/config.edn`), thanks <a>@borkdude</a>.
• use <a href="https://github.com/brandonbloom/fipp" target="_blank">https://github.com/brandonbloom/fipp</a> for fast pretty-printing the clj-kondo configs
• updated dependencies
• schema inferring supports value decoding via options
• <code>:map-of</code> inferring can be forced with `:malli.provider/hint :map-of` meta-data
• <code>:tuple</code> inferring (supports type-hints and threshold options)
• FIX Function with Sequential return value cannot define as function schema
• FIX `decimal?` predicate schema was removed in 0.7.0</z><z id="t1640140499" t="steveb8n Q: I have a typescript project which can expose react prop types. I’m wondering if there’s a way to convert these types to Malli using some kind of tooling? I don’t mind building the tool and submitting a PR if there is a way. Any typescript experts have ideas for this?"><y>#</y><d>2021-12-22</d><h>02:34</h><w>steveb8n</w>Q: I have a typescript project which can expose react prop types. I’m wondering if there’s a way to convert these types to Malli using some kind of tooling? I don’t mind building the tool and submitting a PR if there is a way. Any typescript experts have ideas for this?</z><z id="t1640143390" t="steveb8n background: I have a contractor building react components in Storybook/typescript which I use in a re-frame app. This workflow is huge win"><y>#</y><d>2021-12-22</d><h>03:23</h><r>steveb8n</r>background: I have a contractor building react components in Storybook/typescript which I use in a re-frame app. This workflow is huge win</z><z id="t1640143420" t="steveb8n if I can figure out types -&gt; Malli, I can enhance the testing story as well"><y>#</y><d>2021-12-22</d><h>03:23</h><r>steveb8n</r>if I can figure out types -&gt; Malli, I can enhance the testing story as well</z><z id="t1640150375" t="steveb8n I’m a typescript/babel noob so I need to figure out how to expose the types and then interop to generate Malli"><y>#</y><d>2021-12-22</d><h>05:19</h><r>steveb8n</r>I’m a typescript/babel noob so I need to figure out how to expose the types and then interop to generate Malli</z><z id="t1640624362" t="ikitommi there is https://github.com/tiagodalloca/malli-ts , is that still worked on [:attrs {:href &quot;/_/_/users/U4U6BDQTE&quot;}] ?"><y>#</y><d>2022-12-27</d><h>16:59</h><r>ikitommi</r>there is <a href="https://github.com/tiagodalloca/malli-ts" target="_blank">https://github.com/tiagodalloca/malli-ts</a>, is that still worked on <a>@U4U6BDQTE</a> ?</z><z id="t1646575667" t="Tiago Dall&apos;Oca hey!"><y>#</y><d>2022-03-06</d><h>14:07</h><r>Tiago Dall'Oca</r>hey!</z><z id="t1646575690" t="Tiago Dall&apos;Oca I need to show up here more often haha"><y>#</y><d>2022-03-06</d><h>14:08</h><r>Tiago Dall'Oca</r>I need to show up here more often haha</z><z id="t1646575720" t="Tiago Dall&apos;Oca yess, I&apos;m working on it 🙂 (slowly)"><y>#</y><d>2022-03-06</d><h>14:08</h><r>Tiago Dall'Oca</r>yess, I&apos;m working on it <b>🙂</b> (slowly)</z><z id="t1640182852" t="Ivan Fedorov Is this normal that :e.order/shipping doesn’t resolve into a schema here? Or maybe I lost some understanding (def registry:case {:e.order/shipping [:map [:address string?]] :e/order [:map [:shipping-lines [:vector [:ref :e.order/shipping]]]]}) (def schema:customer-order-case (m/schema [:schema {:registry registry:case} :e/order])) (comment (-&gt; (m/deref-all schema:customer-order-case) (m/children) (last) (last) (m/children) first ; -&gt; [:ref :e.order/shipping] (m/children) first type)) ;; comment block evals to a keyword"><y>#</y><d>2021-12-22</d><h>14:20</h><w>Ivan Fedorov</w>Is this normal that <code>:e.order/shipping</code> doesn’t resolve into a schema here? Or maybe I lost some understanding
<pre>(def registry:case
  {:e.order/shipping
   [:map [:address string?]]
   :e/order
   [:map
    [:shipping-lines
     [:vector [:ref :e.order/shipping]]]]})

(def schema:customer-order-case
  (m/schema
    [:schema
     {:registry registry:case}
     :e/order]))

(comment
  (-&gt; (m/deref-all schema:customer-order-case)
      (m/children)
      (last) (last)
      (m/children) first ; -&gt; [:ref :e.order/shipping]
      (m/children) first type))

;; comment block evals to a keyword</pre></z><z id="t1640185049" t="Ivan Fedorov ok, I got it, I have to m/deref a [:ref :x] block, not :x itself"><y>#</y><d>2021-12-22</d><h>14:57</h><w>Ivan Fedorov</w>ok, I got it, I have to m/deref a <code>[:ref :x]</code> block, not <code>:x</code> itself</z><z id="t1640273476" t="NoahTheDuke #re-frame has the function -&gt;interceptor which has a parameter list of [&amp; {:as m :keys [id before after]}] , which uses this new feature: https://clojure.org/news/2021/03/18/apis-serving-people-and-programs . how can i represent this in a malli function schema?"><y>#</y><d>2021-12-23</d><h>15:31</h><w>NoahTheDuke</w>#re-frame has the function <code>-&gt;interceptor</code> which has a parameter list of <code>[&amp; {:as m :keys [id before after]}]</code> , which uses this new feature: <a href="https://clojure.org/news/2021/03/18/apis-serving-people-and-programs" target="_blank">https://clojure.org/news/2021/03/18/apis-serving-people-and-programs</a>. how can i represent this in a malli function schema?</z><z id="t1640278065" t="NoahTheDuke i have cobbled together this, but it feels pretty hacky, lol: (m/=&gt; -&gt;interceptor [:=&gt; [:cat [:or [:and [:map [:id qualified-keyword?] [:before {:optional true} fn?] [:after {:optional true} fn?]] [:fn (fn [{:keys [before after]}] (or before after))]] [:and [:catn [:id [:cat [:= :id] qualified-keyword?]] [:before [:? [:cat [:= :before] fn?]]] [:after [:? [:cat [:= :after] fn?]]]] [:fn (fn [[_ &amp; args]] (pos? (count args)))]]]] :any]) "><y>#</y><d>2021-12-23</d><h>16:47</h><w>NoahTheDuke</w>i have cobbled together this, but it feels pretty hacky, lol:
<pre>(m/=&gt; -&gt;interceptor
      [:=&gt;
       [:cat
        [:or
         [:and
          [:map
           [:id qualified-keyword?]
           [:before {:optional true} fn?]
           [:after {:optional true} fn?]]
          [:fn (fn [{:keys [before after]}] (or before after))]]
         [:and [:catn
                [:id [:cat [:= :id] qualified-keyword?]]
                [:before [:? [:cat [:= :before] fn?]]]
                [:after [:? [:cat [:= :after] fn?]]]]
          [:fn (fn [[_ &amp; args]] (pos? (count args)))]]]]
       :any])</pre>
</z><z id="t1640278104" t="NoahTheDuke is there a way to make generative testing work with defn schemas like this? (mi/check) reports there’s no generator attached to this schema"><y>#</y><d>2021-12-23</d><h>16:48</h><w>NoahTheDuke</w>is there a way to make generative testing work with defn schemas like this? <code>(mi/check)</code> reports there’s no generator attached to this schema</z><z id="t1640278283" t="NoahTheDuke Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137). :malli.generator/no-generator {:options {:malli.core/function-checker #function[malli.generator/function-checker], :malli.generator/recursion {[:and [:map [:id qualified-keyword?] [:before {:optional true} fn?] [:after {:optional true} fn?]] [:fn #function[executor.interceptor/eval70188/fn--70190]]] 1, [:map [:id qualified-keyword?] [:before {:optional true} fn?] [:after {:optional true} fn?]] 1}}, :schema fn?} "><y>#</y><d>2021-12-23</d><h>16:51</h><w>NoahTheDuke</w><pre>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137).
:malli.generator/no-generator {:options {:malli.core/function-checker #function[malli.generator/function-checker], :malli.generator/recursion {[:and [:map [:id qualified-keyword?] [:before {:optional true} fn?] [:after {:optional true} fn?]] [:fn #function[executor.interceptor/eval70188/fn--70190]]] 1, [:map [:id qualified-keyword?] [:before {:optional true} fn?] [:after {:optional true} fn?]] 1}}, :schema fn?}</pre>
</z><z id="t1640624105" t="ikitommi [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] bumped into that myself. Need to add proper support for the Keyword argument functions now also accept maps . Could you write an issue of that?"><y>#</y><d>2022-12-27</d><h>16:55</h><w>ikitommi</w><a>@nbtheduke</a> bumped into that myself. Need to add proper support for the <code>Keyword argument functions now also accept maps</code>. Could you write an issue of that?</z><z id="t1640630953" t="NoahTheDuke https://github.com/metosin/malli/issues/605"><y>#</y><d>2022-12-27</d><h>18:49</h><r>NoahTheDuke</r><a href="https://github.com/metosin/malli/issues/605" target="_blank">https://github.com/metosin/malli/issues/605</a></z><z id="t1640624149" t="NoahTheDuke Yep, I can open an issue for it"><y>#</y><d>2022-12-27</d><h>16:55</h><w>NoahTheDuke</w>Yep, I can open an issue for it</z><z id="t1640624444" t="ikitommi is there a full spec for clojure destructuring?"><y>#</y><d>2022-12-27</d><h>17:00</h><w>ikitommi</w>is there a full spec for clojure destructuring?</z><z id="t1640624973" t="ikitommi seems to be that need to add something like :every and the merge of :map and :map-of to get proper support for parsing Clojure syntax."><y>#</y><d>2022-12-27</d><h>17:09</h><w>ikitommi</w>seems to be that need to add something like <code>:every</code> and the merge of <code>:map</code> and <code>:map-of</code> to get proper support for parsing Clojure syntax.</z><z id="t1640625023" t="ikitommi naive 30min parser for extended Plumatic Schama defn syntax: (m/parse Bind &apos;[a :- :int [b :- :int [c :- :string :as d :- [:vector :any]] &amp; e :as f] &amp; {:keys [g h] :as i} :- [:map [:g :int] [:h :int]]]) ;{:args [{:arg {:sym a} ; :- :- ; :schema :int} ; {:arg {:vec {:elems [{:arg {:sym b} ; :- :- ; :schema :int} ; {:arg {:vec {:elems [{:arg {:sym c} ; :- :- ; :schema :string}] ; :rest nil ; :as {:as :as ; :sym d ; :schema {:- :- ; :schema [:vector :any]}}}}}] ; :rest {:amp &amp; :form {:arg {:sym e}}} ; :as {:as :as ; :sym f ; :schema nil}}}}] ; :rest {:amp &amp; ; :arg {:arg {:map {:keys [g h] :as i}} ; :- :- ; :schema [:map [:g :int] [:h :int]]}}}"><y>#</y><d>2022-12-27</d><h>17:10</h><w>ikitommi</w>naive 30min parser for extended Plumatic Schama defn syntax:
<pre>(m/parse
 Bind
 &apos;[a :- :int
   [b :- :int [c :- :string :as d :- [:vector :any]] &amp; e :as f]
   &amp; {:keys [g h] :as i} :- [:map [:g :int] [:h :int]]])
;{:args [{:arg {:sym a}
;         :- :-
;         :schema :int}
;        {:arg {:vec {:elems [{:arg {:sym b}
;                              :- :-
;                              :schema :int}
;                             {:arg {:vec {:elems [{:arg {:sym c}
;                                                   :- :-
;                                                   :schema :string}]
;                                          :rest nil
;                                          :as {:as :as
;                                               :sym d
;                                               :schema {:- :-
;                                                        :schema [:vector :any]}}}}}]
;                     :rest {:amp &amp; :form {:arg {:sym e}}}
;                     :as {:as :as
;                          :sym f
;                          :schema nil}}}}]
; :rest {:amp &amp;
;        :arg {:arg {:map {:keys [g h] :as i}}
;              :- :-
;              :schema [:map [:g :int] [:h :int]]}}}</pre></z><z id="t1640625043" t="ikitommi (def Bind (m/schema [:schema {:registry {&quot;Schema&quot; any? &quot;Amp&quot; [:= &apos;&amp;] &quot;As&quot; [:= :as] &quot;Local&quot; [:and symbol? [:not &quot;Amp&quot;]] &quot;Map&quot; [:map [:keys {:optional true} [:vector ident?]] [:strs {:optional true} [:vector ident?]] [:syms {:optional true} [:vector ident?]] [:or {:optional true} [:map-of simple-symbol? any?]] [:as {:optional true} &quot;Local&quot;] [:- {:optional true} &quot;Schema&quot;]] &quot;Vector&quot; [:catn [:elems [:* &quot;SchematizedArgument&quot;]] [:rest [:? [:catn [:amp &quot;Amp&quot;] [:form &quot;SchematizedArgument&quot;]]]] [:as [:? [:catn [:as &quot;As&quot;] [:sym &quot;Local&quot;] [:schema [:? [:catn [:- &quot;Separator&quot;] [:schema &quot;Schema&quot;]]]]]]]] &quot;Argument&quot; [:alt [:catn [:sym &quot;Local&quot;]] [:catn [:map &quot;Map&quot;]] [:catn [:vec [:schema [:ref &quot;Vector&quot;]]]]] &quot;Separator&quot; [:= :-] &quot;SchematizedArgument&quot; [:alt [:catn [:arg &quot;Argument&quot;]] [:catn [:arg &quot;Argument&quot;] [:- &quot;Separator&quot;] [:schema &quot;Schema&quot;]]] &quot;Bind&quot; [:catn [:args [:* &quot;SchematizedArgument&quot;]] [:rest [:? [:catn [:amp &quot;Amp&quot;] [:arg &quot;SchematizedArgument&quot;]]]]]}} &quot;Bind&quot;]))"><y>#</y><d>2022-12-27</d><h>17:10</h><r>ikitommi</r><pre>(def Bind
  (m/schema
   [:schema
    {:registry
     {&quot;Schema&quot; any?
      &quot;Amp&quot; [:= &apos;&amp;]
      &quot;As&quot; [:= :as]
      &quot;Local&quot; [:and symbol? [:not &quot;Amp&quot;]]
      &quot;Map&quot; [:map
             [:keys {:optional true} [:vector ident?]]
             [:strs {:optional true} [:vector ident?]]
             [:syms {:optional true} [:vector ident?]]
             [:or {:optional true} [:map-of simple-symbol? any?]]
             [:as {:optional true} &quot;Local&quot;]
             [:- {:optional true} &quot;Schema&quot;]]
      &quot;Vector&quot; [:catn
                [:elems [:* &quot;SchematizedArgument&quot;]]
                [:rest [:? [:catn
                            [:amp &quot;Amp&quot;]
                            [:form &quot;SchematizedArgument&quot;]]]]
                [:as [:? [:catn
                          [:as &quot;As&quot;]
                          [:sym &quot;Local&quot;]
                          [:schema [:? [:catn
                                        [:- &quot;Separator&quot;]
                                        [:schema &quot;Schema&quot;]]]]]]]]
      &quot;Argument&quot; [:alt
                  [:catn [:sym &quot;Local&quot;]]
                  [:catn [:map &quot;Map&quot;]]
                  [:catn [:vec [:schema [:ref &quot;Vector&quot;]]]]]
      &quot;Separator&quot; [:= :-]
      &quot;SchematizedArgument&quot; [:alt
                             [:catn
                              [:arg &quot;Argument&quot;]]
                             [:catn
                              [:arg &quot;Argument&quot;]
                              [:- &quot;Separator&quot;]
                              [:schema &quot;Schema&quot;]]]
      &quot;Bind&quot; [:catn
              [:args [:* &quot;SchematizedArgument&quot;]]
              [:rest [:? [:catn
                          [:amp &quot;Amp&quot;]
                          [:arg &quot;SchematizedArgument&quot;]]]]]}}
    &quot;Bind&quot;]))</pre></z><z id="t1640703205" t="ikitommi inferring function schemas, what would be better interpretation for these arguments: &apos;[a [b c]] a) correct: [:cat :any [:maybe [:cat [:? :any] [:? :any] [:* :any]]]] b) strict: [:cat :any [:schema [:cat :any :any]]] I would like to do b, but it’s Clojure and a is what the sequential destructuring does. let the user decide, default to a but allow a`strict` mode?"><y>#</y><d>2022-12-28</d><h>14:53</h><w>ikitommi</w>inferring function schemas, what would be better interpretation for these arguments:
<pre>&apos;[a [b c]]</pre>
a) correct:
<pre>[:cat
 :any
 [:maybe
  [:cat
   [:? :any]
   [:? :any]
   [:* :any]]]]</pre>
b) strict:
<pre>[:cat
 :any
 [:schema 
  [:cat
   :any
   :any]]]</pre>
I would like to do b, but it’s Clojure and a is what the sequential destructuring does. let the user decide, default to <code>a</code> but allow a`strict` mode?</z><z id="t1640703583" t="ikitommi (defn kikka [a [b c]] [a b c]) (infer #&apos;kikka) ;[:=&gt; ; [:cat ; :any ; [:maybe ; [:cat ; [:? :any] ; [:? :any] ; [:* :any]]]] ; :any]"><y>#</y><d>2022-12-28</d><h>14:59</h><r>ikitommi</r><pre>(defn kikka [a [b c]] [a b c])

(infer #&apos;kikka)
;[:=&gt;
; [:cat
;  :any
;  [:maybe
;   [:cat
;    [:? :any]
;    [:? :any]
;    [:* :any]]]]
; :any]</pre></z><z id="t1640703599" t="ikitommi (defn ^:malli/strict strict-kikka [a [b c]] [a b c]) (infer #&apos;strict-kikka) ;[:=&gt; ; [:cat ; :any ; [:schema ; [:cat ; :any ; :any]]] ; :any]"><y>#</y><d>2022-12-28</d><h>14:59</h><r>ikitommi</r><pre>(defn ^:malli/strict strict-kikka [a [b c]] [a b c])

(infer #&apos;strict-kikka)
;[:=&gt;
; [:cat
;  :any
;  [:schema
;   [:cat
;    :any
;    :any]]]
; :any]</pre></z><z id="t1640703662" t="ikitommi well, not doing the strict-mode now, but would be possible &amp; easy"><y>#</y><d>2022-12-28</d><h>15:01</h><r>ikitommi</r>well, not doing the strict-mode now, but would be possible &amp; easy</z><z id="t1640704486" t="Ben Sless What I&apos;m missing most here is future support for named (or captured) type variables"><y>#</y><d>2022-12-28</d><h>15:14</h><r>Ben Sless</r>What I&apos;m missing most here is future support for named (or captured) type variables</z><z id="t1640710501" t="ikitommi what are named (or captured) type variables?"><y>#</y><d>2022-12-28</d><h>16:55</h><r>ikitommi</r>what are named (or captured) type variables?</z><z id="t1640710617" t="ikitommi :cat could be :catn here, just need a good naming scheme for the unnamed things."><y>#</y><d>2022-12-28</d><h>16:56</h><r>ikitommi</r><code>:cat</code> could be <code>:catn</code> here, just need a good naming scheme for the unnamed things.</z><z id="t1640710674" t="ikitommi also, the whole thing is for full support of the plumatic syntax, so one can inline schemas."><y>#</y><d>2022-12-28</d><h>16:57</h><r>ikitommi</r>also, the whole thing is for full support of the plumatic syntax, so one can inline schemas.</z><z id="t1640710737" t="ikitommi (ms/defn kikka :- [:vector :int] [a :- :int [b :- :int, c :- :int]] [a b c])"><y>#</y><d>2022-12-28</d><h>16:58</h><r>ikitommi</r><pre>(ms/defn kikka :- [:vector :int] 
  [a :- :int [b :- :int, c :- :int]] 
  [a b c])</pre></z><z id="t1640710751" t="Ben Sless The type if a signature [a] which is any, but an association that constrains the captured name for a in the body of the expression. This lays the groundwork for type inference engines later. Then you can unify the knowledge about that association with the environment (call site) and body. Essentially, introduce type variables / environment"><y>#</y><d>2022-12-28</d><h>16:59</h><r>Ben Sless</r>The type if a signature [a] which is any, but an association that constrains the captured name for a in the body of the expression. This lays the groundwork for type inference engines later. Then you can unify the knowledge about that association with the environment (call site) and body.
Essentially, introduce type variables / environment</z><z id="t1640710834" t="ikitommi oh, that. I’m not doing that, hopefully smarter people will."><y>#</y><d>2022-12-28</d><h>17:00</h><r>ikitommi</r>oh, that. I’m not doing that, hopefully smarter people will.</z><z id="t1640710885" t="Ben Sless 😅"><y>#</y><d>2022-12-28</d><h>17:01</h><r>Ben Sless</r><b>😅</b></z><z id="t1640711108" t="Ben Sless I want to dive into it but I&apos;m afraid I won&apos;t get anything"><y>#</y><d>2022-12-28</d><h>17:05</h><r>Ben Sless</r>I want to dive into it but I&apos;m afraid I won&apos;t get anything</z><z id="t1640771581" t="ikitommi question: a new schema for &quot;map or a sequence of map entries&quot; or just an new property to :map schema? Relates to https://clojure.org/news/2021/03/18/apis-serving-people-and-programs ."><y>#</y><d>2022-12-29</d><h>09:53</h><w>ikitommi</w>question: a new schema for &quot;map or a sequence of map entries&quot; or just an new property to <code>:map</code> schema? Relates to <a href="https://clojure.org/news/2021/03/18/apis-serving-people-and-programs" target="_blank">https://clojure.org/news/2021/03/18/apis-serving-people-and-programs</a>.</z><z id="t1640771743" t="ikitommi a) (m/validate [:map-like [:a :int]] [[:a 1]]) ;=&gt; true b) (m/validate [:map {:coerce true}: [:a :int]] [[:a 1]]) ;=&gt; true"><y>#</y><d>2022-12-29</d><h>09:55</h><w>ikitommi</w>a) <code>(m/validate [:map-like [:a :int]] [[:a 1]]) ;=&gt; true</code>
b) <code>(m/validate [:map {:coerce true}: [:a :int]] [[:a 1]]) ;=&gt; true</code></z><z id="t1640771875" t="ikitommi I&apos;m currently thinking of going with a, as this is a special case. Both ways, it&apos;s just few lines of extra code I think"><y>#</y><d>2022-12-29</d><h>09:57</h><w>ikitommi</w>I&apos;m currently thinking of going with a, as this is a special case. Both ways, it&apos;s just few lines of extra code I think</z><z id="t1640771923" t="ikitommi also, what would be a good name for a new schema type, :map-like ? :every ?"><y>#</y><d>2022-12-29</d><h>09:58</h><w>ikitommi</w>also, what would be a good name for a new schema type, <code>:map-like</code> ? <code>:every</code> ?</z><z id="t1640771987" t="ikitommi do you [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] the opinion for this?"><y>#</y><d>2022-12-29</d><h>09:59</h><w>ikitommi</w>do you <a>@nbtheduke</a> the opinion for this?</z><z id="t1640771991" t="Ben Sless :entries"><y>#</y><d>2022-12-29</d><h>09:59</h><w>Ben Sless</w><code>:entries</code></z><z id="t1640772048" t="Ben Sless Then :map is :entries + map?"><y>#</y><d>2022-12-29</d><h>10:00</h><w>Ben Sless</w>Then <code>:map</code> is <code>:entries</code> + <code>map?</code></z><z id="t1640772183" t="ikitommi spec seems to have s/keys* for this"><y>#</y><d>2022-12-29</d><h>10:03</h><w>ikitommi</w>spec seems to have <code>s/keys*</code> for this</z><z id="t1640774897" t="ikitommi thing is, transformers, parsers and explainers need separate code if we want to retain the original entry sequence. forcing the data to be a map allows us to reuse the current code."><y>#</y><d>2022-12-29</d><h>10:48</h><w>ikitommi</w>thing is, transformers, parsers and explainers need separate code if we want to retain the original entry sequence. forcing the data to be a map allows us to reuse the current code.</z><z id="t1640774978" t="ikitommi for the Keyword argument functions now also accept maps thing, we just need a map, so a simple new way to coerce the entry sequence into a map would do."><y>#</y><d>2022-12-29</d><h>10:49</h><w>ikitommi</w>for the <code>Keyword argument functions now also accept maps</code> thing, we just need a map, so a simple new way to coerce the entry sequence into a map would do.</z><z id="t1640783097" t="NoahTheDuke One thing to note, the input isn&apos;t a sequence of map entries, but a sequence of alternating keys and values, which can be in any order "><y>#</y><d>2022-12-29</d><h>13:04</h><w>NoahTheDuke</w>One thing to note, the input isn&apos;t a sequence of map entries, but a sequence of alternating keys and values, which can be in any order </z><z id="t1640784598" t="ikitommi yes. I guess this is correct: (require &apos;[malli.destructure :as md]) (require &apos;[malli.generator :as mg]) (defmethod mg/-schema-generator :any [_ _] (mg/generator :string)) (-&gt; &apos;[&amp; {:as m :keys [id before after]}] (md/parse) :schema (mg/sample {:size 10, :seed 42})) ;(({:after &quot;&quot;}) ; (:id &quot;F&quot;) ; () ; ({:after &quot;&quot;}) ; (:before &quot;n&quot; :after &quot;ai2&quot; :id &quot;5FI0&quot; :id &quot;&quot;) ; ({:after &quot;qP3t&quot;}) ; () ; ({:id &quot;j&quot;}) ; () ; (:before ; &quot;2&quot; ; :after ; &quot;HW5Mn3&quot; ; :after ; &quot;gv9m93&quot; ; :before ; &quot;GVDI2b&quot; ; :before ; &quot;fhR&quot; ; :before ; &quot;F8562&quot; ; :after ; &quot;lS&quot; ; :before ; &quot;Z7y0nz&quot; ; :before ; &quot;7G&quot;))"><y>#</y><d>2022-12-29</d><h>13:29</h><w>ikitommi</w>yes. I guess this is correct:
<pre>(require &apos;[malli.destructure :as md])
(require &apos;[malli.generator :as mg])

(defmethod mg/-schema-generator :any [_ _] (mg/generator :string))

(-&gt; &apos;[&amp; {:as m :keys [id before after]}]
    (md/parse)
    :schema
    (mg/sample {:size 10, :seed 42}))
;(({:after &quot;&quot;})
; (:id &quot;F&quot;)
; ()
; ({:after &quot;&quot;})
; (:before &quot;n&quot; :after &quot;ai2&quot; :id &quot;5FI0&quot; :id &quot;&quot;)
; ({:after &quot;qP3t&quot;})
; ()
; ({:id &quot;j&quot;})
; ()
; (:before
;  &quot;2&quot;
;  :after
;  &quot;HW5Mn3&quot;
;  :after
;  &quot;gv9m93&quot;
;  :before
;  &quot;GVDI2b&quot;
;  :before
;  &quot;fhR&quot;
;  :before
;  &quot;F8562&quot;
;  :after
;  &quot;lS&quot;
;  :before
;  &quot;Z7y0nz&quot;
;  :before
;  &quot;7G&quot;))</pre></z><z id="t1640784717" t="ikitommi WIP https://github.com/metosin/malli/pull/606"><y>#</y><d>2022-12-29</d><h>13:31</h><r>ikitommi</r>WIP <a href="https://github.com/metosin/malli/pull/606" target="_blank">https://github.com/metosin/malli/pull/606</a></z><z id="t1640791406" t="NoahTheDuke this matches the implementation, as far as i can tell! very cool"><y>#</y><d>2022-12-29</d><h>15:23</h><r>NoahTheDuke</r>this matches the implementation, as far as i can tell! very cool</z><z id="t1640791977" t="NoahTheDuke looks like you’re missing this from the test suite, i’m not sure if you’re missing it from the schema: user=&gt; (defn example [{:keys [id before after] :as m}] [id before after m]) #&apos;user/example user=&gt; (example &apos;(:id 1 :before 2 :after 3 :missing 4)) [1 2 3 {:id 1, :before 2, :after 3, :missing 4}]"><y>#</y><d>2022-12-29</d><h>15:32</h><r>NoahTheDuke</r>looks like you’re missing this from the test suite, i’m not sure if you’re missing it from the schema:
<pre>user=&gt; (defn example [{:keys [id before after] :as m}] [id before after m])
#&apos;user/example
user=&gt; (example &apos;(:id 1 :before 2 :after 3 :missing 4))
[1 2 3 {:id 1, :before 2, :after 3, :missing 4}]</pre></z><z id="t1640792097" t="NoahTheDuke which is to say, the bind is a destructured map, but the input can be a list of key-value pairs"><y>#</y><d>2022-12-29</d><h>15:34</h><r>NoahTheDuke</r>which is to say, the bind is a destructured map, but the input can be a list of key-value pairs</z><z id="t1640792172" t="NoahTheDuke weird thing, it can’t be a vector: user=&gt; (example [:id 1 :before 2 :after 3 :missing 4]) [nil nil nil [:id 1 :before 2 :after 3 :missing 4]] "><y>#</y><d>2022-12-29</d><h>15:36</h><r>NoahTheDuke</r>weird thing, it can’t be a vector:
<pre>user=&gt; (example [:id 1 :before 2 :after 3 :missing 4])
[nil nil nil [:id 1 :before 2 :after 3 :missing 4]]</pre>
</z><z id="t1640792210" t="ikitommi you can pass in it as a list 🤯 by default???"><y>#</y><d>2022-12-29</d><h>15:36</h><r>ikitommi</r>you can pass in it as a list <b>🤯</b> by default???</z><z id="t1640792333" t="NoahTheDuke hah yeah, it’s not really talked about anywhere, but the current version of clojure.core/destructure allows it: https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha3/src/clj/clojure/core.clj#L4434-L4439"><y>#</y><d>2022-12-29</d><h>15:38</h><r>NoahTheDuke</r>hah yeah, it’s not really talked about anywhere, but the current version of <code>clojure.core/destructure</code> allows it: <a href="https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha3/src/clj/clojure/core.clj#L4434-L4439" target="_blank">https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha3/src/clj/clojure/core.clj#L4434-L4439</a></z><z id="t1640802078" t="ikitommi [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] , added support for it too. starts to smell like a new :map-destructuring Schema, which would hide the sequential part. Ugly, but works(?): (-&gt; &apos;[a {:keys [b c] :strs [d e] :syms [f g] :or {b 0, d 0, f 0} :as map}] (md/parse) :schema) ;[:cat ; :any ; [:altn ; [:map [:map ; [:b {:optional true} :any] ; [:c {:optional true} :any] ; [&quot;d&quot; {:optional true} :any] ; [&quot;e&quot; {:optional true} :any] ; [&apos;f {:optional true} :any] ; [&apos;g {:optional true} :any]]] ; [:args [:schema ; [:* ; [:alt ; [:cat [:= :b] :any] ; [:cat [:= :c] :any] ; [:cat [:= &quot;d&quot;] :any] ; [:cat [:= &quot;e&quot;] :any] ; [:cat [:= &apos;f] :any] ; [:cat [:= &apos;g] :any] ; [:cat :any :any]]]]]]]"><y>#</y><d>2022-12-29</d><h>18:21</h><r>ikitommi</r><a>@nbtheduke</a>, added support for it too. starts to smell like a new <code>:map-destructuring</code> Schema, which would hide the sequential part. Ugly, but works(?):
<pre>(-&gt; &apos;[a {:keys [b c]
         :strs [d e]
         :syms [f g]
         :or {b 0, d 0, f 0} :as map}]
    (md/parse)
    :schema)
;[:cat
; :any
; [:altn
;  [:map [:map
;         [:b {:optional true} :any]
;         [:c {:optional true} :any]
;         [&quot;d&quot; {:optional true} :any]
;         [&quot;e&quot; {:optional true} :any]
;         [&apos;f {:optional true} :any]
;         [&apos;g {:optional true} :any]]]
;  [:args [:schema
;          [:*
;           [:alt
;            [:cat [:= :b] :any]
;            [:cat [:= :c] :any]
;            [:cat [:= &quot;d&quot;] :any]
;            [:cat [:= &quot;e&quot;] :any]
;            [:cat [:= &apos;f] :any]
;            [:cat [:= &apos;g] :any]
;            [:cat :any :any]]]]]]]</pre></z><z id="t1640802116" t="NoahTheDuke amazing. thanks so much for tackling this. destructuring in clojure is really weird haha"><y>#</y><d>2022-12-29</d><h>18:21</h><r>NoahTheDuke</r>amazing. thanks so much for tackling this. destructuring in clojure is really weird haha</z><z id="t1640802262" t="ikitommi (def Schema (-&gt; &apos;[a {:keys [b c] :strs [d e] :syms [f g] :or {b 0, d 0, f 0} :as map}] (md/parse) :schema)) (m/parse Schema [1 {:b 1, &apos;f 3, &quot;e&quot; 2, :extra 42}]) ; =&gt; [1 [:map {:b 1, f 3, &quot;e&quot; 2, :extra 42}]] (m/parse Schema [1 &apos;(:c 1, , f 3, &quot;e&quot; 2, :extra 42)]) ; =&gt; [1 [:args [[:c 1] [f 3] [&quot;e&quot; 2] [:extra 42]]]]"><y>#</y><d>2022-12-29</d><h>18:24</h><r>ikitommi</r><pre>(def Schema
  (-&gt; &apos;[a {:keys [b c]
           :strs [d e]
           :syms [f g]
           :or {b 0, d 0, f 0} :as map}]
      (md/parse)
      :schema))

(m/parse Schema [1 {:b 1, &apos;f 3, &quot;e&quot; 2, :extra 42}])
; =&gt; [1 [:map {:b 1, f 3, &quot;e&quot; 2, :extra 42}]]

(m/parse Schema [1 &apos;(:c 1, , f 3, &quot;e&quot; 2, :extra 42)])
; =&gt; [1 [:args [[:c 1] [f 3] [&quot;e&quot; 2] [:extra 42]]]]</pre></z><z id="t1640789382" t="ikitommi a thought experiment, should we have more argument relationship markers, e.g. :- (is a) and :&lt; (a subset of)? could also go [:attrs nil] and introduce real math symbols like :⊂ 👿 (def User [:map [:id :uuid] [:name :string] [:age :int]]) ;; argument is exactly User [{:keys [id age]} :- User] ; =&gt; [:cat [:map [:id :uuid] [:name :string] [:age :int]]] ;; argument should be subset of user (mark others as optional) [{:keys [id age]} :&lt; User] ; =&gt; [:cat [:map [:id :uuid] [:name {:optional true} :string] [:age :int]]] "><y>#</y><d>2022-12-29</d><h>14:49</h><w>ikitommi</w>a thought experiment, should we have more argument relationship markers, e.g. <code>:-</code> (is a) and <code>:&lt;</code> (a subset of)? could also go <b>EXTREME EVIL</b> and introduce real math symbols like <code>:⊂</code> <b>👿</b>

<pre>(def User 
  [:map 
   [:id :uuid] 
   [:name :string] 
   [:age :int]])

;; argument is exactly User
[{:keys [id age]} :- User]
; =&gt; [:cat [:map [:id :uuid] [:name :string] [:age :int]]]

;; argument should be subset of user (mark others as optional)
[{:keys [id age]} :&lt; User]
; =&gt; [:cat [:map [:id :uuid] [:name {:optional true} :string] [:age :int]]]</pre>
</z><z id="t1640789508" t="ikitommi also, would be awesome if tools like #cursive and #calva would have special markers for the type hints, e.g. dim them out so it’s easier to read."><y>#</y><d>2022-12-29</d><h>14:51</h><w>ikitommi</w>also, would be awesome if tools like #cursive and #calva would have special markers for the type hints, e.g. dim them out so it’s easier to read.</z><z id="t1640789647" t="ikitommi … for fully qualified keys, the key definitions could be pulled from the registry: (mm/def ::id :uuid) (mm/def ::name :string) (mm/def ::age :int) ;; argument is exactly User [{::keys [id age]}] ; =&gt; [:cat [:map ::id ::age]]"><y>#</y><d>2022-12-29</d><h>14:54</h><w>ikitommi</w>… for fully qualified keys, the key definitions could be pulled from the registry:
<pre>(mm/def ::id :uuid)
(mm/def ::name :string)
(mm/def ::age :int)

;; argument is exactly User
[{::keys [id age]}]
; =&gt; [:cat [:map ::id ::age]]</pre></z><z id="t1640789676" t="dharrigan We use (still 😞 ) compojure-sweet for some of our APIs, and I see a lot of :- in the path-params , body.... etc...and well, personally, I found it hard to know what :- meant etc..."><y>#</y><d>2022-12-29</d><h>14:54</h><w>dharrigan</w>We use (still <b>😞</b> ) compojure-sweet for some of our APIs, and I see a lot of <code>:-</code> in the <code>path-params</code>, <code>body....</code> etc...and well, personally, I found it hard to know what <code>:-</code> meant etc...</z><z id="t1640789785" t="ikitommi in compojure-api, there is a lot of extra syntax, also the fnk syntax. sorry for all that 🙂"><y>#</y><d>2022-12-29</d><h>14:56</h><w>ikitommi</w>in compojure-api, there is a lot of extra syntax, also the <code>fnk</code> syntax. sorry for all that <b>🙂</b></z><z id="t1640789809" t="dharrigan I have to deal with it every day 😞 I definitely see lessons where learnt with the new improved reitit library 🙂"><y>#</y><d>2022-12-29</d><h>14:56</h><w>dharrigan</w>I have to deal with it every day <b>😞</b> I definitely see lessons where learnt with the new improved reitit library <b>🙂</b></z><z id="t1640789843" t="dharrigan So, I&apos;m not for, nor against, additional markers, I&apos;m rather on the fence (just more stuff to learn I suppose!)"><y>#</y><d>2022-12-29</d><h>14:57</h><w>dharrigan</w>So, I&apos;m not for, nor against, additional markers, I&apos;m rather on the fence (just more stuff to learn I suppose!)</z><z id="t1640789951" t="ikitommi yeah, any support for inline typehints is a compromise. If IDEs would support that properly and there would be just one way to doing those, would be great."><y>#</y><d>2022-12-29</d><h>14:59</h><w>ikitommi</w>yeah, any support for inline typehints is a compromise. If IDEs would support that properly and there would be just one way to doing those, would be great.</z><z id="t1640791156" t="NoahTheDuke i think i’d prefer words instead of single characters for such things. :exact or :exactly or :is-a are easier to parse than :- in my opinion. subset feels like Typescript-style structural typing, which clojure supports out of the box with open maps"><y>#</y><d>2022-12-29</d><h>15:19</h><w>NoahTheDuke</w>i think i’d prefer words instead of single characters for such things. <code>:exact</code> or <code>:exactly</code> or <code>:is-a</code> are easier to parse than <code>:-</code> in my opinion. subset feels like Typescript-style structural typing, which clojure supports out of the box with open maps</z><z id="t1640791207" t="dharrigan I&apos;m with Noah on this one too, I would have to translate :- into is-a in my head as well. Nothing wrong in being wordy, when it comes to comprehension."><y>#</y><d>2022-12-29</d><h>15:20</h><w>dharrigan</w>I&apos;m with Noah on this one too, I would have to translate <code>:-</code> into <code>is-a</code> in my head as well. Nothing wrong in being wordy, when it comes to comprehension.</z><z id="t1640791249" t="dharrigan my 2c`s 🪙"><y>#</y><d>2022-12-29</d><h>15:20</h><w>dharrigan</w>my 2c`s <b>🪙</b></z><z id="t1640791557" t="ikitommi"><y>#</y><d>2022-12-29</d><h>15:25</h><w>ikitommi</w></z><z id="t1640791597" t="ikitommi ^:-- that’s what I would love to have, to remove the type/schema clutter if used."><y>#</y><d>2022-12-29</d><h>15:26</h><w>ikitommi</w>^:-- that’s what I would love to have, to remove the type/schema clutter if used.</z><z id="t1640791807" t="NoahTheDuke ah, i understand now that :- is supposed to be like static type declarations, that makes more sense"><y>#</y><d>2022-12-29</d><h>15:30</h><w>NoahTheDuke</w>ah, i understand now that <code>:-</code> is supposed to be like static type declarations, that makes more sense</z><z id="t1640794772" t="Yehonathan Sharvit Is there a commonly agreed way to document the meaning of each value in a :enum ?"><y>#</y><d>2022-12-29</d><h>16:19</h><w>Yehonathan Sharvit</w>Is there a commonly agreed way to document the meaning of each value in a <code>:enum</code>?</z><z id="t1640801913" t="ikitommi [:attrs {:href &quot;/_/_/users/U0L91U7A8&quot;}] don’t think there is. ideas welcome"><y>#</y><d>2022-12-29</d><h>18:18</h><w>ikitommi</w><a>@viebel</a> don’t think there is. ideas welcome</z><z id="t1640804287" t="Ben Sless enumn Where the keys are the enumeration and values are properties"><y>#</y><d>2022-12-29</d><h>18:58</h><r>Ben Sless</r>enumn
Where the keys are the enumeration and values are properties</z><z id="t1640850443" t="Yehonathan Sharvit I don&apos;t get what you mean [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}]"><y>#</y><d>2022-12-30</d><h>07:47</h><r>Yehonathan Sharvit</r>I don&apos;t get what you mean <a>@UK0810AQ2</a></z><z id="t1640850946" t="Ben Sless Like the map syntax, where the keys are the enumeration and optionally you could provide a properties map"><y>#</y><d>2022-12-30</d><h>07:55</h><r>Ben Sless</r>Like the map syntax, where the keys are the enumeration and optionally you could provide a properties map</z><z id="t1640854031" t="ikitommi :enumn (or similar) would be good for key-&gt;value pair mappings."><y>#</y><d>2022-12-30</d><h>08:47</h><r>ikitommi</r><code>:enumn</code> (or similar) would be good for key-&gt;value pair mappings.</z><z id="t1640854080" t="ikitommi (def MyEnum [:enumn [:small {:description &quot;so small&quot;} &quot;small&quot;] [:medium {:description &quot;such medium&quot;} &quot;medium&quot;]])"><y>#</y><d>2022-12-30</d><h>08:48</h><r>ikitommi</r><pre>(def MyEnum
  [:enumn
   [:small {:description &quot;so small&quot;} &quot;small&quot;]
   [:medium {:description &quot;such medium&quot;} &quot;medium&quot;]])</pre></z><z id="t1640854168" t="ikitommi (m/validate MyEnum &quot;small&quot;) ; =&gt; true"><y>#</y><d>2022-12-30</d><h>08:49</h><r>ikitommi</r><pre>(m/validate MyEnum &quot;small&quot;) ; =&gt; true</pre></z><z id="t1640854200" t="ikitommi (m/parse MyEnum &quot;small&quot;) ; =&gt; [:small &quot;small&quot;]"><y>#</y><d>2022-12-30</d><h>08:50</h><r>ikitommi</r><pre>(m/parse MyEnum &quot;small&quot;) ; =&gt; [:small &quot;small&quot;]</pre></z><z id="t1640854204" t="ikitommi :thinking_face:"><y>#</y><d>2022-12-30</d><h>08:50</h><r>ikitommi</r><b>:thinking_face:</b></z><z id="t1640854212" t="ikitommi awesome"><y>#</y><d>2022-12-30</d><h>08:50</h><r>ikitommi</r><b>awesome</b></z><z id="t1640854286" t="ikitommi e.g. :cat + :catn , :or + : orn , …"><y>#</y><d>2022-12-30</d><h>08:51</h><r>ikitommi</r>e.g. <code>:cat + :catn</code>, <code>:or + : orn</code>, …</z><z id="t1641111508" t="Yehonathan Sharvit I like the idea of enumn . I am wondering if there is any meaning to the keys (e.g. :small and :medium )."><y>#</y><d>2022-01-02</d><h>08:18</h><r>Yehonathan Sharvit</r>I like the idea of <code>enumn</code> .
I am wondering if there is any meaning to the keys (e.g. <code>:small</code> and <code>:medium</code> ).</z><z id="t1641112068" t="Ben Sless I was thinking of a slightly different semantic, [:enumn [v1 {:doc &quot;foo}] [v2] v3] , where the keys are the enumerations, and the syntax can be value | [value ?properties]"><y>#</y><d>2022-01-02</d><h>08:27</h><r>Ben Sless</r>I was thinking of a slightly different semantic, <code>[:enumn [v1 {:doc &quot;foo}] [v2] v3]</code>, where the keys are the enumerations, and the syntax can be <code>value | [value ?properties]</code></z><z id="t1641360885" t="Yehonathan Sharvit I prefer what you suggested [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] as we don&apos;t have to duplicate the enum values"><y>#</y><d>2022-01-05</d><h>05:34</h><r>Yehonathan Sharvit</r>I prefer what you suggested <a>@UK0810AQ2</a> as we don&apos;t have to duplicate the enum values</z><z id="t1641807309" t="Yehonathan Sharvit Opened an issue about this feature request https://github.com/metosin/malli/issues/613"><y>#</y><d>2022-01-10</d><h>09:35</h><r>Yehonathan Sharvit</r>Opened an issue about this feature request <a href="https://github.com/metosin/malli/issues/613" target="_blank">https://github.com/metosin/malli/issues/613</a></z><z id="t1640854423" t="ikitommi One of the oldest (and annoying) issue is how to describe a map + map-of. Need to take a stab at it, here are the options: 1) ternary closed [:map {:closed [:string :int]} [:x :int] [:y :int]] 2) new extra-keys (or such) [:map {:extra-keys [:string :int]} [:x :int] [:y :int]] 3) ::m/default (like in :multi ) [:map [:x :int] [:y :int] [::m/default [:map-of :string :int]]]"><y>#</y><d>2022-12-30</d><h>08:53</h><w>ikitommi</w>One of the oldest (and annoying) issue is how to describe a map + map-of. Need to take a stab at it, here are the options:

1) ternary <code>closed</code>
<pre>[:map {:closed [:string :int]}
 [:x :int]
 [:y :int]] </pre>
2) new <code>extra-keys</code> (or such)
<pre>[:map {:extra-keys [:string :int]}
 [:x :int]
 [:y :int]]</pre>
3) <code>::m/default</code> (like in <code>:multi</code>)
<pre>[:map
 [:x :int]
 [:y :int]
 [::m/default [:map-of :string :int]]]</pre></z><z id="t1640854596" t="ikitommi leaning on 3, because: • it’s coherent way to describe “default in case none of the defined keys matched” • it’s easy to remove or add the key, e.g. (mu/assoc MyMap ::m/default [:map-of :uuid MyMap]) • :map-of already supports key-decoding so things like :uuid keys just work oob"><y>#</y><d>2022-12-30</d><h>08:56</h><w>ikitommi</w>leaning on 3, because:
• it’s coherent way to describe “default in case none of the defined keys matched”
• it’s easy to remove or add the key, e.g. <code>(mu/assoc MyMap ::m/default [:map-of :uuid MyMap])</code>
• <code>:map-of</code> already supports key-decoding so things like <code>:uuid</code> keys just work oob</z><z id="t1640854619" t="ikitommi comments welcome, original issue here: https://github.com/metosin/malli/issues/43"><y>#</y><d>2022-12-30</d><h>08:56</h><w>ikitommi</w>comments welcome, original issue here: <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a></z><z id="t1640858286" t="Ben Sless 4: [:map ^:of [int? int?]]"><y>#</y><d>2022-12-30</d><h>09:58</h><w>Ben Sless</w>4: <code>[:map ^:of [int? int?]]</code></z><z id="t1640863018" t="ikitommi metadata looks good when writing, not that much when reading / serializing."><y>#</y><d>2022-12-30</d><h>11:16</h><w>ikitommi</w>metadata looks good when writing, not that much when reading / serializing.</z><z id="t1640863352" t="Ben Sless I think this example is confusing because the map of spec and the entries don&apos;t match. A property of of on the map makes the most sense imo"><y>#</y><d>2022-12-30</d><h>11:22</h><w>Ben Sless</w>I think this example is confusing because the map of spec and the entries don&apos;t match.
A property of <code>of</code> on the map makes the most sense imo</z><z id="t1640864216" t="ikitommi :of sounds ok. what do you mean by: &gt; the map of spec and the entries don’t match."><y>#</y><d>2022-12-30</d><h>11:36</h><r>ikitommi</r><code>:of</code> sounds ok. what do you mean by:
&gt; the map of spec and the entries don’t match.</z><z id="t1640864333" t="ikitommi how would a schema in the properties be reported in m/explain ?"><y>#</y><d>2022-12-30</d><h>11:38</h><r>ikitommi</r>how would a schema in the properties be reported in <code>m/explain</code>?</z><z id="t1640864511" t="Ben Sless If its :string then it can&apos;t have a keyword key. It has to be a union and not a superset. Which is confusing"><y>#</y><d>2022-12-30</d><h>11:41</h><r>Ben Sless</r>If its :string then it can&apos;t have a keyword key. It has to be a union and not a superset. Which is confusing</z><z id="t1640864580" t="Ben Sless But I&apos;m not sure map-of and map should be unified"><y>#</y><d>2022-12-30</d><h>11:43</h><r>Ben Sless</r>But I&apos;m not sure map-of and map should be unified</z><z id="t1640864836" t="ikitommi I read it “it’s a map with keyword keys :x and :y , the rest of the keys should be :string -&gt; :int . Same with plumatic: {:x s/Int, :y s/Int, s/Str s/Int}"><y>#</y><d>2022-12-30</d><h>11:47</h><r>ikitommi</r>I read it “it’s a map with keyword keys <code>:x</code> and <code>:y</code>, the rest of the keys should be <code>:string -&gt; :int</code>. Same with plumatic:
<pre>{:x s/Int, :y s/Int, s/Str s/Int}</pre></z><z id="t1640864890" t="ikitommi e.g. {:x 1, :y 2, &quot;z&quot; 3, &quot;å&quot; 4} is valid in it."><y>#</y><d>2022-12-30</d><h>11:48</h><r>ikitommi</r>e.g. <code>{:x 1, :y 2, &quot;z&quot; 3, &quot;å&quot; 4}</code> is valid in it.</z><z id="t1640864982" t="Ben Sless As a user who has to work and communicate with others via code, I wouldn&apos;t want this to be valid"><y>#</y><d>2022-12-30</d><h>11:49</h><r>Ben Sless</r>As a user who has to work and communicate with others via code, I wouldn&apos;t want this to be valid</z><z id="t1640865034" t="Ben Sless I&apos;d prefer that the specific keys will be a subset of the key schema and values be a subset of the value schema, not that the entire map describe a union"><y>#</y><d>2022-12-30</d><h>11:50</h><r>Ben Sless</r>I&apos;d prefer that the specific keys will be a subset of the key schema and values be a subset of the value schema, not that the entire map describe a union</z><z id="t1640865097" t="ikitommi I see you point, would not want to use that myself, but that’s what JSON Schema, Plumatic and many others have atm."><y>#</y><d>2022-12-30</d><h>11:51</h><r>ikitommi</r>I see you point, would not want to use that myself, but that’s what JSON Schema, Plumatic and many others have atm.</z><z id="t1640865125" t="ikitommi for the destructuring, I would like to describe the namespaced keys with that"><y>#</y><d>2022-12-30</d><h>11:52</h><r>ikitommi</r>for the destructuring, I would like to describe the namespaced keys with that</z><z id="t1640865301" t="Ben Sless Json schema has no notion of keywords, though"><y>#</y><d>2022-12-30</d><h>11:55</h><r>Ben Sless</r>Json schema has no notion of keywords, though</z><z id="t1640865502" t="Ben Sless And I don&apos;t mind saying Plumatic made a mistake by allowing it"><y>#</y><d>2022-12-30</d><h>11:58</h><r>Ben Sless</r>And I don&apos;t mind saying Plumatic made a mistake by allowing it</z><z id="t1640865005" t="ikitommi 5) wrap the extra keys with something like :schema to mark it’s a schema, not a real key. [:map [:x :int] [:y :int] [[:schema :string] :int]]"><y>#</y><d>2022-12-30</d><h>11:50</h><w>ikitommi</w>5) wrap the extra keys with something like <code>:schema</code> to mark it’s a schema, not a real key.
<pre>[:map
 [:x :int]
 [:y :int]
 [[:schema :string] :int]]</pre></z><z id="t1640865091" t="Ben Sless Wouldn&apos;t it require a special case in parsing?"><y>#</y><d>2022-12-30</d><h>11:51</h><r>Ben Sless</r>Wouldn&apos;t it require a special case in parsing?</z><z id="t1640865156" t="ikitommi yes"><y>#</y><d>2022-12-30</d><h>11:52</h><r>ikitommi</r>yes</z><z id="t1640865263" t="Ben Sless Leaving surprises to your future self?"><y>#</y><d>2022-12-30</d><h>11:54</h><r>Ben Sless</r>Leaving surprises to your future self?</z><z id="t1640865419" t="ikitommi yes, I don’t think there is a right answer to this, just compromises. Not a fan of those (the reason the issue has been open for so long)"><y>#</y><d>2022-12-30</d><h>11:56</h><r>ikitommi</r>yes, I don’t think there is a right answer to this, just compromises. Not a fan of those (the reason the issue has been open for so long)</z><z id="t1640865154" t="Ben Sless Should map-of and map schemas be unified? One describes nominal tuples, the other a set of tuples"><y>#</y><d>2022-12-30</d><h>11:52</h><w>Ben Sless</w>Should map-of and map schemas be unified? One describes nominal tuples, the other a set of tuples</z><z id="t1640865185" t="ikitommi how could/should they be unified?"><y>#</y><d>2022-12-30</d><h>11:53</h><w>ikitommi</w>how could/should they be unified?</z><z id="t1640865221" t="juhoteperi ::m/default makes sense, but using :map-of together with that seems funny. In :map schema the items are key-value pairs, :map-of describes full map. Something like [::m/default [:map-entry :string :int]] or just [::m/default :string :int] or [::m/default [:string :int]] (just force the :map default entry to always have two items) could be cleaner."><y>#</y><d>2022-12-30</d><h>11:53</h><w>juhoteperi</w><code>::m/default</code> makes sense, but using <code>:map-of</code> together with that seems funny. In <code>:map</code> schema the items are key-value pairs, <code>:map-of</code> describes full map.

Something like <code>[::m/default [:map-entry :string :int]]</code> or just <code>[::m/default :string :int]</code> or <code>[::m/default [:string :int]]</code> (just force the <code>:map</code> default entry to always have two items) could be cleaner.</z><z id="t1640865321" t="ikitommi problem with [::m/default :string :int] is that when you ask for m/children of the map, you get funny results."><y>#</y><d>2022-12-30</d><h>11:55</h><w>ikitommi</w>problem with <code>[::m/default :string :int]</code> is that when you ask for <code>m/children</code> of the map, you get funny results.</z><z id="t1640865386" t="juhoteperi Maybe the :map-of makes sense as there can be multiple &quot;default&quot; / extra keys"><y>#</y><d>2022-12-30</d><h>11:56</h><w>juhoteperi</w>Maybe the <code>:map-of</code> makes sense as there can be multiple &quot;default&quot; / extra keys</z><z id="t1640865444" t="juhoteperi Maybe using ::m/extra name would describe better that this is the schema for those keys that aren&apos;t directly defined in :map schema"><y>#</y><d>2022-12-30</d><h>11:57</h><w>juhoteperi</w>Maybe using <code>::m/extra</code> name would describe better that this is the schema for those keys that aren&apos;t directly defined in <code>:map</code> schema</z><z id="t1640865505" t="ikitommi In JSON Schema -land: { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;number&quot;: { &quot;type&quot;: &quot;number&quot; }, &quot;street_name&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;street_type&quot;: { &quot;enum&quot;: [&quot;Street&quot;, &quot;Avenue&quot;, &quot;Boulevard&quot;] } }, &quot;additionalProperties&quot;: { &quot;type&quot;: &quot;string&quot; } }"><y>#</y><d>2022-12-30</d><h>11:58</h><w>ikitommi</w>In JSON Schema -land:
<pre>{
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;number&quot;: { &quot;type&quot;: &quot;number&quot; },
    &quot;street_name&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;street_type&quot;: { &quot;enum&quot;: [&quot;Street&quot;, &quot;Avenue&quot;, &quot;Boulevard&quot;] }
  },
  &quot;additionalProperties&quot;: { &quot;type&quot;: &quot;string&quot; }
}</pre></z><z id="t1640865784" t="Ben Sless It reads to me like the specified properties and additional properties should have the same key type"><y>#</y><d>2022-12-30</d><h>12:03</h><r>Ben Sless</r>It reads to me like the specified properties and additional properties should have the same key type</z><z id="t1640865820" t="Ben Sless But json is limited"><y>#</y><d>2022-12-30</d><h>12:03</h><r>Ben Sless</r>But json is limited</z><z id="t1640866120" t="ikitommi yes, we do not have that limitation"><y>#</y><d>2022-12-30</d><h>12:08</h><r>ikitommi</r>yes, we do not have that limitation</z><z id="t1640866140" t="ikitommi but, the extra keys are just for the case none of the actual keys hit"><y>#</y><d>2022-12-30</d><h>12:09</h><r>ikitommi</r>but, the extra keys are just for the case none of the actual keys hit</z><z id="t1640866151" t="ikitommi there is also :patternedProperties and other silly things."><y>#</y><d>2022-12-30</d><h>12:09</h><r>ikitommi</r>there is also <code>:patternedProperties</code> and other silly things.</z><z id="t1640867231" t="Ben Sless 😕"><y>#</y><d>2022-12-30</d><h>12:27</h><r>Ben Sless</r><b>😕</b></z><z id="t1640866185" t="ikitommi the root need for this NOW btw is how to describe the namespaced keys in the destructuring syntax, elegantly. e.g. what is the schema for the map here: (ns demo) (let [{:keys [a1] ::keys [a2], :kikka/keys [a3] :syms [b1] ::syms [b2] :kikka/syms [b3] :strs [c1] :or {a1 0} :as map} {:a1 1, ::a2 2, :kikka/a3 3 &apos;b1 4 &apos;demo/b2 5, &apos;kikka/b3 6 &quot;c1&quot; 5}] [a1 a2 a3 b1 b2 b3 c1]) ; =&gt; [1 2 3 4 5 6 5]"><y>#</y><d>2022-12-30</d><h>12:09</h><w>ikitommi</w>the root need for this NOW btw is how to describe the namespaced keys in the destructuring syntax, elegantly. e.g. what is the schema for the map here:
<pre>(ns demo)

(let [{:keys [a1] ::keys [a2], :kikka/keys [a3]
       :syms [b1] ::syms [b2] :kikka/syms [b3]
       :strs [c1]
       :or {a1 0} :as map}
      {:a1 1, ::a2 2, :kikka/a3 3
       &apos;b1 4 &apos;demo/b2 5, &apos;kikka/b3 6
       &quot;c1&quot; 5}]
  [a1 a2 a3 b1 b2 b3 c1])
; =&gt; [1 2 3 4 5 6 5]</pre></z><z id="t1640866286" t="ikitommi thought that would be a good reason to add the “extra keys” here, but not sure if that is needed. could be just :multi with dispatch on key qualification :thinking_face:"><y>#</y><d>2022-12-30</d><h>12:11</h><r>ikitommi</r>thought that would be a good reason to add the “extra keys” here, but not sure if that is needed. could be just <code>:multi</code> with dispatch on key qualification <b>:thinking_face:</b></z><z id="t1640868212" t="Ben Sless Or map of enum to something?"><y>#</y><d>2022-12-30</d><h>12:43</h><r>Ben Sless</r>Or map of enum to something?</z><z id="t1640868306" t="Ben Sless This brings me back to my question about a schema about entries"><y>#</y><d>2022-12-30</d><h>12:45</h><r>Ben Sless</r>This brings me back to my question about a schema about entries</z><z id="t1640868805" t="Ben Sless entry := qualified | simple | or | as qualified := [ns/kind form] simple := [kind form] kind := keys | syms | strs or := [:or map-of,,,] as := [:as symbol] "><y>#</y><d>2022-12-30</d><h>12:53</h><r>Ben Sless</r><pre>entry := qualified | simple | or | as
qualified := [ns/kind form]
simple := [kind form]
kind := keys | syms | strs
or := [:or map-of,,,]
as := [:as symbol]</pre>
</z><z id="t1641056062" t="ikitommi unexpected help for the existing stuff: (defn -map-like [x] (or (map? x) (and (seqable? x) (every? (fn [e] (and (vector? e) (= 2 (count e)))) x)))) (defn -keys-syms-key [k] (-&gt; k name #{&quot;keys&quot; &quot;syms&quot;})) (def MapLike (m/-collection-schema {:type :map-like :empty {} :pred -map-like})) (m/parse [MapLike [:or [:tuple [:= :keys] [:vector ident?]] [:tuple [:= :strs] [:vector ident?]] [:tuple [:= :syms] [:vector ident?]] [:tuple [:= :or] [:map-of simple-symbol? any?]] [:tuple [:= :as] symbol?] [:tuple [:and :qualified-keyword [:fn -keys-syms-key]] [:vector ident?]]]] &apos;{:keys [b] :strs [c] :syms [d] :demo/keys [e] :demo/syms [f] :or {b 0, d 0, f 0} :as map}) ;{:keys [b] ; :strs [c] ; :syms [d] ; :demo/keys [e] ; :demo/syms [f] ; :or {b 0, d 0, f 0} :as map} … not the most performant, but good for the destructuring case 🥳"><y>#</y><d>2022-01-01</d><h>16:54</h><r>ikitommi</r>unexpected help for the existing stuff:
<pre>(defn -map-like [x]
  (or (map? x)
      (and (seqable? x)
           (every? (fn [e] (and (vector? e) (= 2 (count e)))) x))))

(defn -keys-syms-key [k] 
  (-&gt; k name #{&quot;keys&quot; &quot;syms&quot;}))

(def MapLike
  (m/-collection-schema
   {:type :map-like
    :empty {}
    :pred -map-like}))

(m/parse
 [MapLike
  [:or
   [:tuple [:= :keys] [:vector ident?]]
   [:tuple [:= :strs] [:vector ident?]]
   [:tuple [:= :syms] [:vector ident?]]
   [:tuple [:= :or] [:map-of simple-symbol? any?]]
   [:tuple [:= :as] symbol?]
   [:tuple [:and :qualified-keyword [:fn -keys-syms-key]] [:vector ident?]]]]
 &apos;{:keys [b]
   :strs [c]
   :syms [d]
   :demo/keys [e]
   :demo/syms [f]
   :or {b 0, d 0, f 0} :as map})
;{:keys [b]
; :strs [c]
; :syms [d]
; :demo/keys [e]
; :demo/syms [f]
; :or {b 0, d 0, f 0} :as map}</pre>
… not the most performant, but good for the destructuring case <b>🥳</b></z><z id="t1641056062" t="ikitommi unexpected help for the existing stuff: (defn -map-like [x] (or (map? x) (and (seqable? x) (every? (fn [e] (and (vector? e) (= 2 (count e)))) x)))) (defn -keys-syms-key [k] (-&gt; k name #{&quot;keys&quot; &quot;syms&quot;})) (def MapLike (m/-collection-schema {:type :map-like :empty {} :pred -map-like})) (m/parse [MapLike [:or [:tuple [:= :keys] [:vector ident?]] [:tuple [:= :strs] [:vector ident?]] [:tuple [:= :syms] [:vector ident?]] [:tuple [:= :or] [:map-of simple-symbol? any?]] [:tuple [:= :as] symbol?] [:tuple [:and :qualified-keyword [:fn -keys-syms-key]] [:vector ident?]]]] &apos;{:keys [b] :strs [c] :syms [d] :demo/keys [e] :demo/syms [f] :or {b 0, d 0, f 0} :as map}) ;{:keys [b] ; :strs [c] ; :syms [d] ; :demo/keys [e] ; :demo/syms [f] ; :or {b 0, d 0, f 0} :as map} … not the most performant, but good for the destructuring case 🥳"><y>#</y><d>2022-01-01</d><h>16:54</h><w>ikitommi</w>unexpected help for the existing stuff:
<pre>(defn -map-like [x]
  (or (map? x)
      (and (seqable? x)
           (every? (fn [e] (and (vector? e) (= 2 (count e)))) x))))

(defn -keys-syms-key [k] 
  (-&gt; k name #{&quot;keys&quot; &quot;syms&quot;}))

(def MapLike
  (m/-collection-schema
   {:type :map-like
    :empty {}
    :pred -map-like}))

(m/parse
 [MapLike
  [:or
   [:tuple [:= :keys] [:vector ident?]]
   [:tuple [:= :strs] [:vector ident?]]
   [:tuple [:= :syms] [:vector ident?]]
   [:tuple [:= :or] [:map-of simple-symbol? any?]]
   [:tuple [:= :as] symbol?]
   [:tuple [:and :qualified-keyword [:fn -keys-syms-key]] [:vector ident?]]]]
 &apos;{:keys [b]
   :strs [c]
   :syms [d]
   :demo/keys [e]
   :demo/syms [f]
   :or {b 0, d 0, f 0} :as map})
;{:keys [b]
; :strs [c]
; :syms [d]
; :demo/keys [e]
; :demo/syms [f]
; :or {b 0, d 0, f 0} :as map}</pre>
… not the most performant, but good for the destructuring case <b>🥳</b></z><z id="t1640924254" t="Swapneil How does one make a relation between the input and output of a function? For instance, if I had the function (defn dothings [x y] (/ x y)), I want to check that (zero? (mod x :ret)). In spec you can do this with the :fn option in fdef, but I can&apos;t find any way to use malli&apos;s :fn option this way in a :=&gt; schema"><y>#</y><d>2022-12-31</d><h>04:17</h><w>Swapneil</w>How does one make a relation between the input and output of a function? For instance, if I had the function (defn dothings [x y] (/ x y)), I want to check that (zero? (mod x :ret)). In spec you can do this with the :fn option in fdef, but I can&apos;t find any way to use malli&apos;s :fn option this way in a :=&gt; schema</z><z id="t1640936708" t="ikitommi [:attrs {:href &quot;/_/_/users/U02QCB2FHU6&quot;}] currently, no. but would be easy to add. Please write an issue out of that."><y>#</y><d>2022-12-31</d><h>07:45</h><w>ikitommi</w><a>@ss2961</a> currently, no. but would be easy to add. Please write an issue out of that.</z><z id="t1640936822" t="ikitommi e.g. with map-syntax: {:type :=&gt; :input {:type :cat, :children [{:type :int}]} :output :int} =&gt; {:type :=&gt; :input {:type :cat, :children [{:type :int}]} :output :int :fn ...} not sure where that should be in the vector-syntax. optional third element?"><y>#</y><d>2022-12-31</d><h>07:47</h><w>ikitommi</w>e.g. with map-syntax:
<pre>{:type :=&gt;
 :input {:type :cat, :children [{:type :int}]}
 :output :int}</pre>
=&gt;
<pre>{:type :=&gt;
 :input {:type :cat, :children [{:type :int}]}
 :output :int
 :fn ...}  </pre>
not sure where that should be in the vector-syntax. optional third element?</z><z id="t1640937430" t="Ben Sless Properties?"><y>#</y><d>2022-12-31</d><h>07:57</h><r>Ben Sless</r>Properties?</z><z id="t1640938586" t="ikitommi In this case, I think it&apos;s the way to go. The :=&gt; satisfies the SchemaAST so it can read &amp; write them from there. Brilliant!"><y>#</y><d>2022-12-31</d><h>08:16</h><r>ikitommi</r>In this case, I think it&apos;s the way to go. The <code>:=&gt;</code>satisfies the <code>SchemaAST</code> so it can read &amp; write them from there. Brilliant!</z><z id="t1640937293" t="ikitommi added some options to destructuring parser: (defn parse &quot;Takes a destructuring bindings vector (arglist) and returns a map with keys: | key | description | | ---------------|-------------| | `:raw-arglist` | the original arglist (can have type-hints) | `:arglist` | simplified clojure arglist (no type-hints) | `:schema` | extracted malli schema | `:parsed` | full parse results Parsing can be configured using the following options: | key | description | | -----------------------|-------------| | `::md/inline-schemas` | support plumatic-style inline schemas (true) | `::md/sequential-maps` | support sequential maps in non-rest position (true) | `::md/required-keys` | are destructured keys required (false) | `::md/closed-maps` | are destructured maps closed (false) | `::md/references` | are schema references used (false) Examples: (require &apos;[malli.destructure :as md]) (-&gt; &apos;[a b &amp; cs] (md/parse) :schema) ; =&gt; [:cat :any :any [:* :any]] (-&gt; &apos;[a :- :string, b &amp; cs :- [:* :int]] (md/parse) :schema) ; =&gt; [:cat :string :any [:* :int]]&quot;"><y>#</y><d>2022-12-31</d><h>07:54</h><w>ikitommi</w>added some options to destructuring parser:
<pre>(defn parse
  &quot;Takes a destructuring bindings vector (arglist)
   and returns a map with keys:

   | key            | description |
   | ---------------|-------------|
   | `:raw-arglist` | the original arglist (can have type-hints)
   | `:arglist`     | simplified clojure arglist (no type-hints)
   | `:schema`      | extracted malli schema
   | `:parsed`      | full parse results

   Parsing can be configured using the following options:

   | key                    | description |
   | -----------------------|-------------|
   | `::md/inline-schemas`  | support plumatic-style inline schemas (true)
   | `::md/sequential-maps` | support sequential maps in non-rest position (true)
   | `::md/required-keys`   | are destructured keys required (false)
   | `::md/closed-maps`     | are destructured maps closed (false)
   | `::md/references`      | are schema references used (false)

   Examples:

      (require &apos;[malli.destructure :as md])

      (-&gt; &apos;[a b &amp; cs] (md/parse) :schema)
      ; =&gt; [:cat :any :any [:* :any]]

      (-&gt; &apos;[a :- :string, b &amp; cs :- [:* :int]] (md/parse) :schema)
      ; =&gt; [:cat :string :any [:* :int]]&quot;</pre></z><z id="t1640937327" t="ikitommi any comments to https://github.com/metosin/malli/pull/606 ? naming, defaults etc. will ship that… next year 🙂"><y>#</y><d>2022-12-31</d><h>07:55</h><w>ikitommi</w>any comments to <a href="https://github.com/metosin/malli/pull/606" target="_blank">https://github.com/metosin/malli/pull/606</a>? naming, defaults etc. will ship that… next year <b>🙂</b></z><z id="t1641135716" t="ikitommi Updating the README: pulling out malli function schemas from normal clojure functions: (require &apos;[malli.destructure :as md]) (def infer (comp :schema md/parse)) (defn kikka ([a] [a]) ([a b &amp; cs] [a b cs])) (-&gt;&gt; #&apos;kikka meta :arglists (map infer) (map (fn [s] [:=&gt; s :any])) (into [:function])) ;[:function ; [:=&gt; [:cat :any] :any] ; [:=&gt; [:cat :any :any [:* :any]]"><y>#</y><d>2022-01-02</d><h>15:01</h><w>ikitommi</w>Updating the README: pulling out <b>malli</b>  function schemas from normal clojure functions:

<pre>(require &apos;[malli.destructure :as md])

(def infer (comp :schema md/parse))

(defn kikka
  ([a] [a])
  ([a b &amp; cs] [a b cs]))

(-&gt;&gt; #&apos;kikka
     meta
     :arglists
     (map infer)
     (map (fn [s] [:=&gt; s :any]))
     (into [:function]))
;[:function
; [:=&gt; [:cat :any] :any] 
; [:=&gt; [:cat :any :any [:* :any]]</pre></z><z id="t1641135938" t="ikitommi could add a helper to enable that with malli.dev so that one could auto-infer all/interesting Vars at dev-team to get pretty runtime errors + clj-kondo mappings for free too."><y>#</y><d>2022-01-02</d><h>15:05</h><w>ikitommi</w>could add a helper to enable that with <code>malli.dev</code> so that one could auto-infer all/interesting Vars at dev-team to get pretty runtime errors + clj-kondo mappings for free too.</z><z id="t1641148205" t="ikitommi merged. Before jumping into the-next-thing-I-need, I’ll try to address all PRs. Really good stuff there 🙇"><y>#</y><d>2022-01-02</d><h>18:30</h><w>ikitommi</w>merged. Before jumping into the-next-thing-I-need, I’ll try to address all PRs. Really good stuff there <b>🙇</b></z><z id="t1641148334" t="Ben Sless Regarding the string char ranges, [:attrs {:href &quot;/_/_/users/U02AH3D0HEV&quot;}] had a great idea for putting it in a lookup array, great perf"><y>#</y><d>2022-01-02</d><h>18:32</h><r>Ben Sless</r>Regarding the string char ranges, <a>@U02AH3D0HEV</a> had a great idea for putting it in a lookup array, great perf</z><z id="t1641148526" t="Ben Sless Also experimented with emitting a datomic(like) schema from schema"><y>#</y><d>2022-01-02</d><h>18:35</h><r>Ben Sless</r>Also experimented with emitting a datomic(like) schema from schema</z><z id="t1641239081" t="Swapneil How do you make a spec for a :repeat or :sequential with a certain length? I tried adding :count and :length in the properties, but neither seems to have an effect. My current spec is [:repeat {:min 0 :max 9} :int]]"><y>#</y><d>2022-01-03</d><h>19:44</h><w>Swapneil</w>How do you make a spec for a :repeat or :sequential with a certain length? I tried adding :count and :length in the properties, but neither seems to have an effect.
My current spec is [:repeat {:min 0 :max 9} :int]]</z><z id="t1641306740" t="ikitommi try: (m/explain [:repeat {:min 2, :max 2} :int] [1 2]) ; nil (m/explain [:repeat {:min 2, :max 2} :int] [1]) ;{:schema [:repeat {:min 2, :max 2} :int], ; :value [1], ; :errors ({:path [0] ; :in [1] ; :schema :int ; :value nil ; :type :malli.core/end-of-input})}"><y>#</y><d>2022-01-04</d><h>14:32</h><r>ikitommi</r>try:
<pre>(m/explain [:repeat {:min 2, :max 2} :int] [1 2])
; nil

(m/explain [:repeat {:min 2, :max 2} :int] [1])
;{:schema [:repeat {:min 2, :max 2} :int],
; :value [1],
; :errors ({:path [0]
;           :in [1]
;           :schema :int
;           :value nil
;           :type :malli.core/end-of-input})}</pre></z><z id="t1641306199" t="pinkfrog Is the map syntax the recommended way to go? https://github.com/metosin/malli#map-syntax"><y>#</y><d>2022-01-04</d><h>14:23</h><w>pinkfrog</w>Is the map syntax the recommended way to go? <a href="https://github.com/metosin/malli#map-syntax" target="_blank">https://github.com/metosin/malli#map-syntax</a></z><z id="t1641306834" t="ikitommi vector-syntax is the way to go, but map should work too. &gt; NOTE: Map Syntax / SchemaAST is considered as alpha and subject to change."><y>#</y><d>2022-01-04</d><h>14:33</h><r>ikitommi</r>vector-syntax is the way to go, but map should work too.
&gt; NOTE: Map Syntax / SchemaAST is considered as alpha and subject to change.</z><z id="t1641306874" t="ikitommi"><y>#</y><d>2022-01-04</d><h>14:34</h><w>ikitommi</w></z><z id="t1641306924" t="ikitommi with cursive + Clojure Extras + clj-kondo. Looking good 🙂"><y>#</y><d>2022-01-04</d><h>14:35</h><r>ikitommi</r>with cursive + Clojure Extras + clj-kondo. Looking good <b>🙂</b></z><z id="t1641307028" t="dharrigan I am liking the metadata version"><y>#</y><d>2022-01-04</d><h>14:37</h><r>dharrigan</r>I am liking the metadata version</z><z id="t1641307041" t="dharrigan to me, precisely what metadata is all about 🙂"><y>#</y><d>2022-01-04</d><h>14:37</h><r>dharrigan</r>to me, precisely what metadata is all about <b>🙂</b></z><z id="t1641309231" t="emccue i like it too, just not that dev tooling can’t pick it up without a manual refresh"><y>#</y><d>2022-01-04</d><h>15:13</h><r>emccue</r>i like it too, just not that dev tooling can’t pick it up without a manual refresh</z><z id="t1641309304" t="emccue and the m/=&gt; version there doesn’t work because if you load the whole file you load the schema, which triggers wrapping the function, and then load the function which will be unwrapped"><y>#</y><d>2022-01-04</d><h>15:15</h><r>emccue</r>and the <code>m/=&gt;</code> version there doesn’t work because if you load the whole file you load the schema, which triggers wrapping the function, and then load the function which will be unwrapped</z><z id="t1641310260" t="Karol Wójcik Plumatic style. Cant wait to see it released ;3"><y>#</y><d>2022-01-04</d><h>15:31</h><r>Karol Wójcik</r>Plumatic style. Cant wait to see it released ;3</z><z id="t1641311693" t="ikitommi I think we can solve the dev-tooöing issues with first two, with polling and var-watching."><y>#</y><d>2022-01-04</d><h>15:54</h><r>ikitommi</r>I think we can solve the dev-tooöing issues with first two, with polling and var-watching.</z><z id="t1641313898" t="Michael Gardner any progress on the timing problem with metadata? https://clojurians.slack.com/archives/C03S1KBA2/p1628602192164200"><y>#</y><d>2022-01-04</d><h>16:31</h><r>Michael Gardner</r>any progress on the timing problem with metadata?
<a href="https://clojurians.slack.com/archives/C03S1KBA2/p1628602192164200" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1628602192164200</a></z><z id="t1641314501" t="ikitommi I don&apos;t think so, but adding a queue with a small delay should do the trick here."><y>#</y><d>2022-01-04</d><h>16:41</h><r>ikitommi</r>I don&apos;t think so, but adding a queue with a small delay should do the trick here.</z><z id="t1641318153" t="Michael Gardner seems tricky to deal with the case where a var is defined and then immediately used"><y>#</y><d>2022-01-04</d><h>17:42</h><r>Michael Gardner</r>seems tricky to deal with the case where a var is defined and then immediately used</z><z id="t1641320315" t="Ben Sless teaser - how does emitting malli schema fron jackson annotations sound? 😛"><y>#</y><d>2022-01-04</d><h>18:18</h><w>Ben Sless</w>teaser - how does emitting malli schema fron jackson annotations sound? <b>😛</b></z><z id="t1641329752" t="emccue i swear i dislike actual physical people named jackson at this point just by association"><y>#</y><d>2022-01-04</d><h>20:55</h><w>emccue</w>i swear i dislike actual physical people named jackson at this point just by association</z><z id="t1641367365" t="Ben Sless I always think of Daniel Jackson from Stargate which puts me in a more positive mindset"><y>#</y><d>2022-01-05</d><h>07:22</h><r>Ben Sless</r>I always think of Daniel Jackson from Stargate which puts me in a more positive mindset</z><z id="t1641369337" t="Ben Sless Filed under &quot;thanks I hate it&quot; https://github.com/bsless/malli-jackson"><y>#</y><d>2022-01-05</d><h>07:55</h><w>Ben Sless</w>Filed under &quot;thanks I hate it&quot;
<a href="https://github.com/bsless/malli-jackson" target="_blank">https://github.com/bsless/malli-jackson</a></z><z id="t1641376122" t="eskos Can/could malli be used to extract/subselect a structure from a larger data structure? What I’m trying to achieve is that my CLJS app has one huge app-db ratom and from that I’d like to subselect certain parts which gets stored persistently with as little pain and whacking as possible, and I sort of had a thought that hey, it’d be nice to define the subselect as malli schema so that I could validate that the subselect is even persistable, plus malli schema is way easier to document than whatever else I’ve been thinking as solution to this so far. From system integrity’s point of view this could also work quite nicely, as marking specific branches/leaves of the data structure as persistable would mean writing a proper validator for it -&gt; I wouldn’t have to worry someone breaking the, uh, persistability. And of course this is pretty straightforward thing to document to team members, both current and those who’ll join the project later that hey, just update the persistent malli schema if your data needs to be persisted."><y>#</y><d>2022-01-05</d><h>09:48</h><w>eskos</w>Can/could malli be used to extract/subselect a structure from a larger data structure?

What I’m trying to achieve is that my CLJS app has one huge app-db ratom and from that I’d like to subselect certain parts which gets stored persistently with as little pain and whacking as possible, and I sort of had a thought that hey, it’d be nice to define the subselect as malli schema so that I could validate that the subselect is even persistable, plus malli schema is way easier to document than whatever else I’ve been thinking as solution to this so far. From system integrity’s point of view this could also work quite nicely, as marking specific branches/leaves of the data structure as persistable would mean writing a proper validator for it -&gt; I wouldn’t have to worry someone breaking the, uh, persistability. And of course this is pretty straightforward thing to document to team members, both current and those who’ll join the project later that hey, just update the persistent malli schema if your data needs to be persisted.</z><z id="t1641377612" t="ikitommi There is mt/strip-extra-keys-transformer to &quot;select&quot; a sub-schema."><y>#</y><d>2022-01-05</d><h>10:13</h><r>ikitommi</r>There is <code>mt/strip-extra-keys-transformer</code>  to &quot;select&quot; a sub-schema.</z><z id="t1641390578" t="eskos Hmm, interesting. :thinking_face:"><y>#</y><d>2022-01-05</d><h>13:49</h><r>eskos</r>Hmm, interesting. <b>:thinking_face:</b></z><z id="t1641387594" t="lauri The following code snippet works with malli version 0.6.2 : (def instant (m/-simple-schema {:type &apos;instant :pred (partial instance? Instant) :type-properties {:error/message &quot;should be instant&quot;}})) (def Foo [:schema {:registry {::xyz [:map [:baz instant]]}} ::xyz]) (mu/merge [:map [:foo string?]] [:map [:bar Bar]]) =&gt; [:map [:foo [:schema {:registry #:test-namespace{:xyz [:map [:baz instant]]}} :test-namespace/xyz]] [:bar string?]] but fails since version 0.7.0 with: Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137). :malli.core/invalid-schema {:schema instant} How can i execute it with the newest version on malli?"><y>#</y><d>2022-01-05</d><h>12:59</h><w>lauri</w>The following code snippet works with malli version <code>0.6.2</code>:
<pre>(def instant
  (m/-simple-schema
   {:type            &apos;instant
    :pred            (partial instance? Instant)
    :type-properties {:error/message &quot;should be instant&quot;}}))

(def Foo
  [:schema
   {:registry
    {::xyz
     [:map [:baz instant]]}}
   ::xyz])

(mu/merge [:map [:foo string?]]
          [:map [:bar Bar]])
=&gt;
[:map
 [:foo
  [:schema
   {:registry #:test-namespace{:xyz [:map [:baz instant]]}}
   :test-namespace/xyz]]
 [:bar string?]]</pre>
but fails since version <code>0.7.0</code> with:
<pre>Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137).
:malli.core/invalid-schema {:schema instant}</pre>
How can i execute it with the newest version on malli?</z><z id="t1641387910" t="lauri when the type of the :baz field is changed to string? then it also works with the latest version but i’d like to be able to use a custom type.."><y>#</y><d>2022-01-05</d><h>13:05</h><r>lauri</r>when the type of the <code>:baz</code> field is changed to <code>string?</code> then it also works with the latest version but i’d like to be able to use a custom type..</z><z id="t1641391026" t="lauri seems that the malli.core/schema function fails in the newest version: (m/schema Foo) Error printing return value (ExceptionInfo) at malli.core/-fail! (core.cljc:137). :malli.core/invalid-schema {:schema instant}"><y>#</y><d>2022-01-05</d><h>13:57</h><r>lauri</r>seems that the <code>malli.core/schema</code> function fails in the newest version:
<pre>(m/schema Foo)
Error printing return value (ExceptionInfo) at malli.core/-fail! (core.cljc:137).
:malli.core/invalid-schema {:schema instant}</pre></z></g><g id="s21"><z id="t1641464462" t="ikitommi [:attrs {:href &quot;/_/_/users/U082J3TME&quot;}] It was a regression that is should be fixed with https://github.com/metosin/malli/commit/abef62dc682af7e1f61b841e5fed4038a1ccb01c , not released yet"><y>#</y><d>2022-01-06</d><h>10:21</h><r>ikitommi</r><a>@U082J3TME</a> It was a regression that is should be fixed with <a href="https://github.com/metosin/malli/commit/abef62dc682af7e1f61b841e5fed4038a1ccb01c" target="_blank">https://github.com/metosin/malli/commit/abef62dc682af7e1f61b841e5fed4038a1ccb01c</a>, not released yet</z><z id="t1641464474" t="ikitommi could you retest with latest code in master?"><y>#</y><d>2022-01-06</d><h>10:21</h><r>ikitommi</r>could you retest with latest code in master?</z><z id="t1641464540" t="ikitommi e.g. property registries were written as forms, which was a bad idea as there is no way to re-construct non-registered schemas using just the m/type information."><y>#</y><d>2022-01-06</d><h>10:22</h><r>ikitommi</r>e.g. property registries were written as forms, which was a bad idea as there is no way to re-construct non-registered schemas using just the <code>m/type</code> information.</z><z id="t1641471269" t="lauri just checked with master and it works well now. Thanks a lot!"><y>#</y><d>2022-01-06</d><h>12:14</h><r>lauri</r>just checked with master and it works well now. Thanks a lot!</z><z id="t1641416024" t="annapawlicka Hey folks, I’m trying to figure out if there’s a way to merge fields inside of registry. I’ve tried utility functions, tried declarative :merge , they don’t work. Here’s a small example of what I’m trying to do: (def schema-registry-sample {::payment-authorization [:map [:id :string] [:approvalNumber :string] [:authResultDescription :string] [:authorizationDate :string]] ::sales-order-line-item [:map [:id :string] [:authorization [:maybe [:merge ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below [:map [:type :string] [:activationCode :string] [:productCode :string]]]]] [:offer {:optional true} [:multi {:dispatch :offerProgram} [&quot;INSTANTSAVINGS&quot; [:merge ::offer ;; &lt;&lt;&lt;&lt; I want to add required field based on a certain condition [:map [:gtin :string]]]] [::m/default ::offer]]]] :sales-order [:map [:paymentAuthorization ::payment-authorization] [:salesOrderLineItem [:vector ::sales-order-line-item]]]}) (def sales-order-explainer-sample (m/explainer [:schema {:registry schema-registry-sample} ::sales-order])) The example here doesn’t work {:type clojure.lang.ExceptionInfo :message &quot;:malli.core/invalid-schema {:schema :merge}&quot; :data {:type :malli.core/invalid-schema, :message :malli.core/invalid-schema, :data {:schema :merge}} :at [malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 137]} Other merge approaches fail as well. Any ideas? Is this just not doable right now?"><y>#</y><d>2022-01-05</d><h>20:53</h><w>annapawlicka</w>Hey folks, I’m trying to figure out if there’s a way to merge fields inside of registry. I’ve tried utility functions, tried declarative <code>:merge</code> , they don’t work. Here’s a small example of what I’m trying to do:
<pre>(def schema-registry-sample
  {::payment-authorization [:map
                            [:id :string]
                            [:approvalNumber :string]
                            [:authResultDescription :string]
                            [:authorizationDate :string]]

   ::sales-order-line-item [:map
                            [:id :string]
                            [:authorization [:maybe
                                             [:merge
                                              ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below
                                              [:map
                                               [:type :string]
                                               [:activationCode :string]
                                               [:productCode :string]]]]]
                            [:offer {:optional true} [:multi {:dispatch :offerProgram}
                                                      [&quot;INSTANTSAVINGS&quot; [:merge
                                                                         ::offer ;; &lt;&lt;&lt;&lt; I want to add required field based on a certain condition
                                                                         [:map [:gtin :string]]]]
                                                      [::m/default ::offer]]]]

   :sales-order [:map
                 [:paymentAuthorization ::payment-authorization]
                 [:salesOrderLineItem [:vector ::sales-order-line-item]]]})

(def sales-order-explainer-sample
  (m/explainer [:schema {:registry schema-registry-sample}
                ::sales-order]))</pre>
The example here doesn’t work
<pre>{:type clojure.lang.ExceptionInfo
   :message &quot;:malli.core/invalid-schema {:schema :merge}&quot;
   :data {:type :malli.core/invalid-schema, :message :malli.core/invalid-schema, :data {:schema :merge}}
   :at [malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 137]}</pre>
Other merge approaches fail as well. Any ideas? Is this just not doable right now?</z><z id="t1641486645" t="ikitommi hi [:attrs {:href &quot;/_/_/users/U05087MJH&quot;}] ! the :merge is not enabled by default. You can register it globally with: (mr/set-default-registry! (mr/composite-registry (m/default-schemas) ;; malli defaults (mu/schemas))) ;; plus the utility schemas"><y>#</y><d>2022-01-06</d><h>16:30</h><r>ikitommi</r>hi <a>@U05087MJH</a>! the <code>:merge</code> is not enabled by default. You can register it globally with:
<pre>(mr/set-default-registry!
 (mr/composite-registry
  (m/default-schemas) ;; malli defaults
  (mu/schemas))) ;; plus the utility schemas</pre></z><z id="t1641486676" t="ikitommi so, this works: (ns demo (:require [malli.registry :as mr] [malli.core :as m] [malli.util :as mu])) (mr/set-default-registry! (mr/composite-registry (m/default-schemas) ;; malli defaults (mu/schemas))) ;; plus the utility schemas (def schema-registry-sample {::payment-authorization [:map [:id :string] [:approvalNumber :string] [:authResultDescription :string] [:authorizationDate :string]] ::sales-order-line-item [:map [:id :string] [:authorization [:maybe [:merge ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below [:map [:type :string] [:activationCode :string] [:productCode :string]]]]] [:offer {:optional true} [:multi {:dispatch :offerProgram} [&quot;INSTANTSAVINGS&quot; [:merge ::offer [:map [:gtin :string]]]] [::m/default ::offer]]]] ::offer [:map] ::sales-order [:map [:paymentAuthorization ::payment-authorization] [:salesOrderLineItem [:vector ::sales-order-line-item]]]}) (def sales-order-explainer-sample (m/explainer [:schema {:registry schema-registry-sample} ::sales-order]))"><y>#</y><d>2022-01-06</d><h>16:31</h><r>ikitommi</r>so, this works:
<pre>(ns demo
  (:require [malli.registry :as mr]
            [malli.core :as m]
            [malli.util :as mu]))

(mr/set-default-registry!
 (mr/composite-registry
  (m/default-schemas) ;; malli defaults
  (mu/schemas))) ;; plus the utility schemas

(def schema-registry-sample
  {::payment-authorization [:map
                            [:id :string]
                            [:approvalNumber :string]
                            [:authResultDescription :string]
                            [:authorizationDate :string]]

   ::sales-order-line-item [:map
                            [:id :string]
                            [:authorization [:maybe
                                             [:merge
                                              ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below
                                              [:map
                                               [:type :string]
                                               [:activationCode :string]
                                               [:productCode :string]]]]]
                            [:offer {:optional true} [:multi {:dispatch :offerProgram}
                                                      [&quot;INSTANTSAVINGS&quot; [:merge
                                                                         ::offer                                                                  [:map [:gtin :string]]]]
                                                      [::m/default ::offer]]]]
   ::offer [:map]
   ::sales-order [:map
                  [:paymentAuthorization ::payment-authorization]
                  [:salesOrderLineItem [:vector ::sales-order-line-item]]]})

(def sales-order-explainer-sample
  (m/explainer [:schema {:registry schema-registry-sample}
                ::sales-order]))</pre></z><z id="t1641486940" t="ikitommi If you want spec-like custom mutable registry, here’s the thing: (ns demo (:require [malli.registry :as mr] [malli.core :as m] [malli.util :as mu])) (def registry* (atom {})) (defn register! [type ?schema] (swap! registry* assoc type ?schema)) (mr/set-default-registry! (mr/composite-registry (m/default-schemas) (mu/schemas) (mr/mutable-registry registry*))) (register! ::payment-authorization [:map [:id :string] [:approvalNumber :string] [:authResultDescription :string] [:authorizationDate :string]]) (register! ::sales-order-line-item [:map [:id :string] [:authorization [:maybe [:merge ::payment-authorization [:map [:type :string] [:activationCode :string] [:productCode :string]]]]] [:offer {:optional true} [:multi {:dispatch :offerProgram} [&quot;INSTANTSAVINGS&quot; [:merge ::offer [:map [:gtin :string]]]] [::m/default ::offer]]]]) (register! ::offer [:map]) (register! ::sales-order [:map [:paymentAuthorization ::payment-authorization] [:salesOrderLineItem [:vector ::sales-order-line-item]]]) (def sales-order-explainer-sample (m/explainer ::sales-order))"><y>#</y><d>2022-01-06</d><h>16:35</h><r>ikitommi</r>If you want spec-like custom mutable registry, here’s the thing:
<pre>(ns demo
  (:require [malli.registry :as mr]
            [malli.core :as m]
            [malli.util :as mu]))

(def registry* (atom {}))

(defn register! [type ?schema]
  (swap! registry* assoc type ?schema))

(mr/set-default-registry!
 (mr/composite-registry
  (m/default-schemas)
  (mu/schemas)
  (mr/mutable-registry registry*)))

(register!
 ::payment-authorization
 [:map
  [:id :string]
  [:approvalNumber :string]
  [:authResultDescription :string]
  [:authorizationDate :string]])

(register!
 ::sales-order-line-item
 [:map
  [:id :string]
  [:authorization [:maybe
                   [:merge
                    ::payment-authorization
                    [:map
                     [:type :string]
                     [:activationCode :string]
                     [:productCode :string]]]]]
  [:offer {:optional true} [:multi {:dispatch :offerProgram}
                            [&quot;INSTANTSAVINGS&quot; [:merge
                                               ::offer
                                               [:map [:gtin :string]]]]
                            [::m/default ::offer]]]])

(register!
 ::offer
 [:map])

(register!
 ::sales-order
 [:map
  [:paymentAuthorization ::payment-authorization]
  [:salesOrderLineItem [:vector ::sales-order-line-item]]])

(def sales-order-explainer-sample
  (m/explainer ::sales-order))</pre></z><z id="t1641503250" t="annapawlicka Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ! I just realized I posted incomplete example, but you made it work anyway 🙂"><y>#</y><d>2022-01-06</d><h>21:07</h><r>annapawlicka</r>Thank you <a>@U055NJ5CC</a>! I just realized I posted incomplete example, but you made it work anyway <b>🙂</b></z><z id="t1641588576" t="annapawlicka [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Any chance to merge the mu/schemas into my schema? I’d like to make the registry in this ns immutable as we’ll be using a lot of different schemas and there’s always a risk some other ns will set the global registry to something else. Simple merging doesn’t seem to work."><y>#</y><d>2022-01-07</d><h>20:49</h><r>annapawlicka</r><a>@U055NJ5CC</a> Any chance to merge the <code>mu/schemas</code>into my schema? I’d like to make the registry in this ns immutable as we’ll be using a lot of different schemas and there’s always a risk some other ns will set the global registry to something else. Simple merging doesn’t seem to work.</z><z id="t1641673149" t="ikitommi I think it’s possible. Need few minutest to test that one out."><y>#</y><d>2022-01-08</d><h>20:19</h><r>ikitommi</r>I think it’s possible. Need few minutest to test that one out.</z><z id="t1641673592" t="ikitommi here’s one way to do it: https://gist.github.com/ikitommi/af280065df4cb16a17123558e41463d3"><y>#</y><d>2022-01-08</d><h>20:26</h><r>ikitommi</r>here’s one way to do it: <a href="https://gist.github.com/ikitommi/af280065df4cb16a17123558e41463d3" target="_blank">https://gist.github.com/ikitommi/af280065df4cb16a17123558e41463d3</a></z><z id="t1641673637" t="ikitommi e.g. create a common registry for the base-schemas (immutable), pass it as argument to m/schema , can still add local schemas on top of it."><y>#</y><d>2022-01-08</d><h>20:27</h><r>ikitommi</r>e.g. create a common registry for the base-schemas (immutable), pass it as argument to <code>m/schema</code> , can still add local schemas on top of it.</z><z id="t1641673712" t="ikitommi most workers (validators, explainers, parsers, unparsers, generators) are cached to the instance, so first m/validate on the Schema instance will create the validator, next will use the cached one."><y>#</y><d>2022-01-08</d><h>20:28</h><r>ikitommi</r>most workers (validators, explainers, parsers, unparsers, generators) are cached to the instance, so first <code>m/validate</code> on the Schema instance will create the validator, next will use the cached one.</z><z id="t1641674264" t="ikitommi happy to give a tech talk / discussion about malli for you team you are interested. There are lot’s of options of doing things. Also curious on where are you using it."><y>#</y><d>2022-01-08</d><h>20:37</h><r>ikitommi</r>happy to give a tech talk / discussion about malli for you team you are interested. There are lot’s of options of doing things. Also curious on where are you using it.</z><z id="t1641718162" t="ikitommi two more options (added to gist): ;; ;; 3) registering utility schema via local registry (requires latest code from MASTER) ;; (def schema-registry-sample {:merge (mu/-merge) ::payment-authorization [:map [:id :string] [:approvalNumber :string] [:authResultDescription :string] [:authorizationDate :string]] ::sales-order-line-item [:map [:id :string] [:authorization [:maybe [:merge ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below [:map [:type :string] [:activationCode :string] [:productCode :string]]]]] [:offer {:optional true} [:multi {:dispatch :offerProgram} [&quot;INSTANTSAVINGS&quot; [:merge ::offer [:map [:gtin :string]]]] [::m/default ::offer]]]] ::offer [:map] ::sales-order [:map [:paymentAuthorization ::payment-authorization] [:salesOrderLineItem [:vector ::sales-order-line-item]]]}) (def sales-order (m/schema [:schema {:registry schema-registry-sample} ::sales-order]))"><y>#</y><d>2022-01-09</d><h>08:49</h><r>ikitommi</r>two more options (added to gist):
<pre>;;
;; 3) registering utility schema via local registry (requires latest code from MASTER)
;;

(def schema-registry-sample
  {:merge (mu/-merge)
   ::payment-authorization [:map
                            [:id :string]
                            [:approvalNumber :string]
                            [:authResultDescription :string]
                            [:authorizationDate :string]]

   ::sales-order-line-item [:map
                            [:id :string]
                            [:authorization [:maybe
                                             [:merge
                                              ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below
                                              [:map
                                               [:type :string]
                                               [:activationCode :string]
                                               [:productCode :string]]]]]
                            [:offer {:optional true} [:multi {:dispatch :offerProgram}
                                                      [&quot;INSTANTSAVINGS&quot; [:merge
                                                                         ::offer [:map [:gtin :string]]]]
                                                      [::m/default ::offer]]]]
   ::offer [:map]
   ::sales-order [:map
                  [:paymentAuthorization ::payment-authorization]
                  [:salesOrderLineItem [:vector ::sales-order-line-item]]]})

(def sales-order
  (m/schema
   [:schema {:registry schema-registry-sample}
    ::sales-order]))</pre></z><z id="t1641718177" t="ikitommi ;; ;; 4) using local component directly ;; (def Merge (mu/-merge)) (def schema-registry-sample {::payment-authorization [:map [:id :string] [:approvalNumber :string] [:authResultDescription :string] [:authorizationDate :string]] ::sales-order-line-item [:map [:id :string] [:authorization [:maybe [Merge ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below [:map [:type :string] [:activationCode :string] [:productCode :string]]]]] [:offer {:optional true} [:multi {:dispatch :offerProgram} [&quot;INSTANTSAVINGS&quot; [Merge ::offer [:map [:gtin :string]]]] [::m/default ::offer]]]] ::offer [:map] ::sales-order [:map [:paymentAuthorization ::payment-authorization] [:salesOrderLineItem [:vector ::sales-order-line-item]]]}) (def sales-order (m/schema [:schema {:registry schema-registry-sample} ::sales-order]))"><y>#</y><d>2022-01-09</d><h>08:49</h><r>ikitommi</r><pre>;;
;; 4) using local component directly
;;

(def Merge (mu/-merge))

(def schema-registry-sample
  {::payment-authorization [:map
                            [:id :string]
                            [:approvalNumber :string]
                            [:authResultDescription :string]
                            [:authorizationDate :string]]

   ::sales-order-line-item [:map
                            [:id :string]
                            [:authorization [:maybe
                                             [Merge
                                              ::payment-authorization ;; &lt;&lt;&lt;&lt; I want to merge this with the fields below
                                              [:map
                                               [:type :string]
                                               [:activationCode :string]
                                               [:productCode :string]]]]]
                            [:offer {:optional true} [:multi {:dispatch :offerProgram}
                                                      [&quot;INSTANTSAVINGS&quot; [Merge
                                                                         ::offer [:map [:gtin :string]]]]
                                                      [::m/default ::offer]]]]
   ::offer [:map]
   ::sales-order [:map
                  [:paymentAuthorization ::payment-authorization]
                  [:salesOrderLineItem [:vector ::sales-order-line-item]]]})

(def sales-order
  (m/schema
   [:schema {:registry schema-registry-sample}
    ::sales-order]))</pre></z><z id="t1641848235" t="annapawlicka Thank you! It looks like there’s quite a few options. We might take you up on your tech talk offer but we need to gather a list of questions first 🙂 We’ve been slowly replacing Plumatic schema with malli. Plus we started adding malli to a recent project that had no Plumatic schema - we use it to validate payload from services we call, but also to validate data that we send in our requests to them. Generation of test data is there as well but I think validation is the biggest part. And since these are all different data sources that we validate, we’re trying to find the best way to organize it. We’ve just started with it in December IIRC, so it will possibly grow. It also helped us to identify how much of the payload we actually use (it’s a big project, different graphql resolvers using the same source of data in different ways), and helped us make a decision around choosing the right response version. [:attrs {:href &quot;/_/_/users/UEH4D93GS&quot;}] has been looking into it from a different project than I so he might have a different perspective."><y>#</y><d>2022-01-10</d><h>20:57</h><r>annapawlicka</r>Thank you! It looks like there’s quite a few options. We might take you up on your tech talk offer but we need to gather a list of questions first <b>🙂</b>
We’ve been slowly replacing Plumatic schema with malli. Plus we started adding malli to a recent project that had no Plumatic schema - we use it to validate payload from services we call, but also to validate data that we send in our requests to them. Generation of test data is there as well but I think validation is the biggest part. And since these are all different data sources that we validate, we’re trying to find the best way to organize it. We’ve just started with it in December IIRC, so it will possibly grow. It also helped us to identify how much of the payload we actually use (it’s a big project, different graphql resolvers using the same source of data in different ways), and helped us make a decision around choosing the right response version.
<a>@UEH4D93GS</a> has been looking into it from a different project than I so he might have a different perspective.</z><z id="t1641496621" t="Ben Sless After opening this I noticed there&apos;s been a similar request in this channel in the past. Anyone did work on the subject? https://github.com/metosin/malli/issues/609"><y>#</y><d>2022-01-06</d><h>19:17</h><w>Ben Sless</w>After opening this I noticed there&apos;s been a similar request in this channel in the past. Anyone did work on the subject?
<a href="https://github.com/metosin/malli/issues/609" target="_blank">https://github.com/metosin/malli/issues/609</a></z><z id="t1641563059" t="Panel Trying to understand why transformers won&apos;t compose, in this ex, (mt/transformers {:decoders ...}) is compiled but not run when the second transformer (mt/key-transformer ...) is present. If I remove (mt/key-transformer ...) then (mt/transformers {:decoders ...}) run just fine. I&apos;m guessing this is related to interceptor :before and :after clashing for some reason. (ma/decode [:map [&quot;ContactMethodCde&quot; [:enum {:lkp {&quot;pcme&quot; &quot;Email&quot; &quot;pcmp&quot; &quot;Phone&quot; &quot;pcmm&quot; &quot;Mail&quot;}} &quot;Mail&quot; &quot;Phone&quot; &quot;Email&quot;]]] {&quot;ContactMethodCde&quot; &quot;pcme&quot;} (mt/transformer {:decoders {:enum {:compile (fn [schema _] (let [m (:lkp (ma/properties schema))] (fn [x] (prn x) (m x))))}}} (mt/key-transformer {:decode {&quot;ContactMethodCde&quot; :contact-method}}))) This work, notice the :leave interceptor on :map decoders. (ma/decode [:map [&quot;ContactMethodCde&quot; [:enum {:lkp {&quot;pcme&quot; &quot;Email&quot; &quot;pcmp&quot; &quot;Phone&quot; &quot;pcmm&quot; &quot;Mail&quot;}} &quot;Mail&quot; &quot;Phone&quot; &quot;Email&quot;]]] {&quot;ContactMethodCde&quot; &quot;pcme&quot;} (mt/transformer {:decoders {:enum {:compile (fn [schema _] (let [m (:lkp (ma/properties schema))] {:enter(fn [x] (prn x) (m x))}))} :map {:leave (mt/-transform-map-keys {&quot;ContactMethodCde&quot; :contact-method})}}})) It wont work when the decoder is set to :enter :map {:enter ...}"><y>#</y><d>2022-01-07</d><h>13:44</h><w>Panel</w>Trying to understand why transformers won&apos;t compose, in this ex, <code>(mt/transformers {:decoders ...})</code> is compiled but not run when the second transformer (mt/key-transformer ...) is present.
If I remove <code>(mt/key-transformer ...)</code> then  <code>(mt/transformers {:decoders ...})</code> run just fine.
I&apos;m guessing this  is related to interceptor :before and :after clashing for some reason.
<pre>(ma/decode
 [:map [&quot;ContactMethodCde&quot;
        [:enum {:lkp {&quot;pcme&quot; &quot;Email&quot;
                    &quot;pcmp&quot; &quot;Phone&quot;
                    &quot;pcmm&quot; &quot;Mail&quot;}}
         &quot;Mail&quot; &quot;Phone&quot; &quot;Email&quot;]]]
 {&quot;ContactMethodCde&quot; &quot;pcme&quot;}
 (mt/transformer
  {:decoders {:enum {:compile (fn [schema _]
                              (let [m (:lkp (ma/properties schema))]
                                (fn [x]
                                  (prn x)
                                  (m x))))}}}
  (mt/key-transformer
   {:decode {&quot;ContactMethodCde&quot; :contact-method}})))</pre>
This work, notice the :leave interceptor on :map decoders.
<pre>(ma/decode
 [:map [&quot;ContactMethodCde&quot;
        [:enum {:lkp {&quot;pcme&quot; &quot;Email&quot;
                      &quot;pcmp&quot; &quot;Phone&quot;
                      &quot;pcmm&quot; &quot;Mail&quot;}}
         &quot;Mail&quot; &quot;Phone&quot; &quot;Email&quot;]]]
 {&quot;ContactMethodCde&quot; &quot;pcme&quot;}
 (mt/transformer
  {:decoders
   {:enum {:compile (fn [schema _]
                      (let [m (:lkp (ma/properties schema))]
                        {:enter(fn [x]
                                  (prn x)
                                  (m x))}))}
    :map {:leave (mt/-transform-map-keys {&quot;ContactMethodCde&quot; :contact-method})}}}))</pre>
It wont work when the decoder is set to :enter <code>:map {:enter ...}</code></z><z id="t1641570875" t="Grant Horner Is there an equivalent to spec-alpha2&apos;s select in malli? i.e., it takes a :map schema and makes everything optional other than the specified keys?"><y>#</y><d>2022-01-07</d><h>15:54</h><w>Grant Horner</w>Is there an equivalent to spec-alpha2&apos;s <code>select</code> in malli? i.e., it takes a <code>:map</code> schema and makes everything optional other than the specified keys?</z><z id="t1641591707" t="Panel https://cljdoc.org/d/metosin/malli/0.7.5/api/malli.util#required-keys maybe ?"><y>#</y><d>2022-01-07</d><h>21:41</h><r>Panel</r><a href="https://cljdoc.org/d/metosin/malli/0.7.5/api/malli.util#required-keys" target="_blank">https://cljdoc.org/d/metosin/malli/0.7.5/api/malli.util#required-keys</a> maybe ?</z><z id="t1641673040" t="ikitommi something like this? (require &apos;[malli.core :as m]) (require &apos;[malli.util :as mu]) (defn select [schema keys] (-&gt; schema (mu/optional-keys) (mu/required-keys keys))) (select [:schema {:registry {::name :string ::title [:enum &quot;boss&quot; &quot;not-boss&quot;] ::age :int ::skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]}} [:map ::name ::title ::age ::skills]] #{::name ::age}) ;[:map ; [:user/name :user/name] ; [:user/title {:optional true} :user/title] ; [:user/age :user/age] ; [:user/skills {:optional true} :user/skills]]"><y>#</y><d>2022-01-08</d><h>20:17</h><r>ikitommi</r>something like this?
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.util :as mu])

(defn select [schema keys]
  (-&gt; schema
      (mu/optional-keys)
      (mu/required-keys keys)))

(select
 [:schema {:registry {::name :string
                      ::title [:enum &quot;boss&quot; &quot;not-boss&quot;]
                      ::age :int
                      ::skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]}}
  [:map ::name ::title ::age ::skills]]
 #{::name ::age})
;[:map
; [:user/name :user/name]
; [:user/title {:optional true} :user/title]
; [:user/age :user/age]
; [:user/skills {:optional true} :user/skills]]</pre></z><z id="t1641673077" t="ikitommi should be easy to make it recursive, I think there is an issue to add such a tool to malli.util …"><y>#</y><d>2022-01-08</d><h>20:17</h><r>ikitommi</r>should be easy to make it recursive, I think there is an issue to add such a tool to <code>malli.util</code>…</z><z id="t1641769159" t="Grant Horner [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] that&apos;s definitely simpler than my solution… thanks!"><y>#</y><d>2022-01-09</d><h>22:59</h><r>Grant Horner</r><a>@U055NJ5CC</a> that&apos;s definitely simpler than my solution… thanks!</z><z id="t1658265412" t="NoahTheDuke what about this? (defn select [schema ks] (let [schema (m/schema schema) plain-keys (filter keyword? ks) map-keys (-&gt;&gt; ks (filter map?) (apply merge) (not-empty)) req-keys (vec (concat plain-keys (keys map-keys))) changed-schema (-&gt; (mu/optional-keys schema) (mu/required-keys req-keys))] (if-let [paths map-keys] (reduce (fn [schema [path v]] (assert (vector? v) &quot;Nested map vals must be vectors&quot;) (mu/update schema path select v)) changed-schema paths) changed-schema)))"><y>#</y><d>2022-07-19</d><h>21:16</h><r>NoahTheDuke</r>what about this?
<pre>(defn select
  [schema ks]
  (let [schema (m/schema schema)
        plain-keys (filter keyword? ks)
        map-keys (-&gt;&gt; ks
                      (filter map?)
                      (apply merge)
                      (not-empty))
        req-keys (vec (concat plain-keys (keys map-keys)))
        changed-schema (-&gt; (mu/optional-keys schema)
                           (mu/required-keys req-keys))]
    (if-let [paths map-keys]
      (reduce (fn [schema [path v]]
                (assert (vector? v) &quot;Nested map vals must be vectors&quot;)
                (mu/update schema path select v))
              changed-schema
              paths)
      changed-schema)))</pre></z><z id="t1658265484" t="NoahTheDuke works like this: (select (m/schema [:map [:name string?] [:title [:enum &quot;boss&quot; &quot;not-boss&quot;]] [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]] [:base [:map [:this-one [:map [:one uuid?] [:two int?]]] [:not-this-one string?]]]]) [:name {:base [{:this-one [:two]}]}]) ; [:map ; [:name string?] ; [:title {:optional true} [:enum &quot;boss&quot; &quot;not-boss&quot;]] ; [:skills {:optional true} [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]] ; [:base [:map ; [:this-one [:map ; [:one {:optional true} uuid?] ; [:two int?]]] ; [:not-this-one {:optional true} string?]]]]"><y>#</y><d>2022-07-19</d><h>21:18</h><r>NoahTheDuke</r>works like this:
<pre>(select
  (m/schema
    [:map
     [:name string?]
     [:title [:enum &quot;boss&quot; &quot;not-boss&quot;]]
     [:skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]]
     [:base [:map
             [:this-one [:map
                         [:one uuid?]
                         [:two int?]]]
             [:not-this-one string?]]]])
        [:name {:base [{:this-one [:two]}]}])
; [:map
;  [:name string?]
;  [:title {:optional true} [:enum &quot;boss&quot; &quot;not-boss&quot;]]
;  [:skills {:optional true} [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]]
;  [:base [:map
;          [:this-one [:map
;                      [:one {:optional true} uuid?]
;                      [:two int?]]]
;          [:not-this-one {:optional true} string?]]]]</pre></z><z id="t1641673040" t="ikitommi something like this? (require &apos;[malli.core :as m]) (require &apos;[malli.util :as mu]) (defn select [schema keys] (-&gt; schema (mu/optional-keys) (mu/required-keys keys))) (select [:schema {:registry {::name :string ::title [:enum &quot;boss&quot; &quot;not-boss&quot;] ::age :int ::skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]}} [:map ::name ::title ::age ::skills]] #{::name ::age}) ;[:map ; [:user/name :user/name] ; [:user/title {:optional true} :user/title] ; [:user/age :user/age] ; [:user/skills {:optional true} :user/skills]]"><y>#</y><d>2022-01-08</d><h>20:17</h><w>ikitommi</w>something like this?
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.util :as mu])

(defn select [schema keys]
  (-&gt; schema
      (mu/optional-keys)
      (mu/required-keys keys)))

(select
 [:schema {:registry {::name :string
                      ::title [:enum &quot;boss&quot; &quot;not-boss&quot;]
                      ::age :int
                      ::skills [:set [:enum &quot;clj&quot; &quot;cljs&quot;]]}}
  [:map ::name ::title ::age ::skills]]
 #{::name ::age})
;[:map
; [:user/name :user/name]
; [:user/title {:optional true} :user/title]
; [:user/age :user/age]
; [:user/skills {:optional true} :user/skills]]</pre></z><z id="t1658265412" t="NoahTheDuke what about this? (defn select [schema ks] (let [schema (m/schema schema) plain-keys (filter keyword? ks) map-keys (-&gt;&gt; ks (filter map?) (apply merge) (not-empty)) req-keys (vec (concat plain-keys (keys map-keys))) changed-schema (-&gt; (mu/optional-keys schema) (mu/required-keys req-keys))] (if-let [paths map-keys] (reduce (fn [schema [path v]] (assert (vector? v) &quot;Nested map vals must be vectors&quot;) (mu/update schema path select v)) changed-schema paths) changed-schema)))"><y>#</y><d>2022-07-19</d><h>21:16</h><w>NoahTheDuke</w>what about this?
<pre>(defn select
  [schema ks]
  (let [schema (m/schema schema)
        plain-keys (filter keyword? ks)
        map-keys (-&gt;&gt; ks
                      (filter map?)
                      (apply merge)
                      (not-empty))
        req-keys (vec (concat plain-keys (keys map-keys)))
        changed-schema (-&gt; (mu/optional-keys schema)
                           (mu/required-keys req-keys))]
    (if-let [paths map-keys]
      (reduce (fn [schema [path v]]
                (assert (vector? v) &quot;Nested map vals must be vectors&quot;)
                (mu/update schema path select v))
              changed-schema
              paths)
      changed-schema)))</pre></z><z id="t1641674588" t="ikitommi Given a Var: (defn -instrument &quot;Takes an instrumentation properties map and a function and returns a wrapped function, which will validate function arguments and return values based on the function schema definition. The following properties are used: | key | description | | ----------|-------------| | `:schema` | function schema | `:scope` | optional set of scope definitions, defaults to `#{:input :output}` | `:report` | optional side-effecting function of `key data -&gt; any` to report problems, defaults to `m/-fail!` | `:gen` | optional function of `schema -&gt; schema -&gt; value` to be invoked on the args to get the return value&quot; ([props] (-instrument props nil nil)) ([props f] (-instrument props f nil)) ([{:keys [scope report gen] :or {scope #{:input :output}, report -fail!} :as props} f options] ... a simple schema inferrer: (md/infer #&apos;m/-instrument {::md/sequential-maps false}) ;[:function ; [:=&gt; [:cat :any] :any] ; [:=&gt; [:cat :any :any] :any] ; [:=&gt; ; [:cat [:map ; [:scope {:optional true} :any] ; [:report {:optional true} :any] ; [:gen {:optional true} :any]] :any :any] ; :any]]"><y>#</y><d>2022-01-08</d><h>20:43</h><w>ikitommi</w>Given a Var:
<pre>(defn -instrument
  &quot;Takes an instrumentation properties map and a function and returns a wrapped function,
   which will validate function arguments and return values based on the function schema
   definition. The following properties are used:

   | key       | description |
   | ----------|-------------|
   | `:schema` | function schema
   | `:scope`  | optional set of scope definitions, defaults to `#{:input :output}`
   | `:report` | optional side-effecting function of `key data -&gt; any` to report problems, defaults to `m/-fail!`
   | `:gen`    | optional function of `schema -&gt; schema -&gt; value` to be invoked on the args to get the return value&quot;
  ([props]
   (-instrument props nil nil))
  ([props f]
   (-instrument props f nil))
  ([{:keys [scope report gen] :or {scope #{:input :output}, report -fail!} :as props} f options]
   ...</pre>
a simple schema inferrer:
<pre>(md/infer #&apos;m/-instrument {::md/sequential-maps false})
;[:function
; [:=&gt; [:cat :any] :any]
; [:=&gt; [:cat :any :any] :any]
; [:=&gt;
;  [:cat [:map
;         [:scope {:optional true} :any]
;         [:report {:optional true} :any]
;         [:gen {:optional true} :any]] :any :any]
;  :any]]</pre></z><z id="t1641674628" t="ikitommi also can read the plumatic hints. Could add it to read also normal Clojure typehints."><y>#</y><d>2022-01-08</d><h>20:43</h><r>ikitommi</r>also can read the plumatic hints. Could add it to read also normal Clojure typehints.</z><z id="t1641674906" t="ikitommi it can parse both the source code and the :arglists meta (both are described as malli sequence schemas). As we can create clj-kondo hints too, now we can do Var -&gt; Malli -&gt; Clj-kondo for free as in 🍺"><y>#</y><d>2022-01-08</d><h>20:48</h><r>ikitommi</r>it can parse both the source code and the <code>:arglists</code> meta (both are described as malli sequence schemas). As we can create clj-kondo hints too, now we can do <code>Var -&gt; Malli -&gt; Clj-kondo</code> for free as in <b>🍺</b></z><z id="t1641674969" t="ikitommi it also understands the new Clojure keyword-ags-as-maps thing and the maps-as-sequence."><y>#</y><d>2022-01-08</d><h>20:49</h><r>ikitommi</r>it also understands the new Clojure keyword-ags-as-maps thing and the maps-as-sequence.</z><z id="t1641675095" t="ikitommi this is the real schema for it: (md/infer #&apos;m/-instrument) ;[:function ; [:=&gt; [:cat :any] :any] ; [:=&gt; [:cat :any :any] :any] ; [:=&gt; ; [:cat ; [:altn ; [:map [:map ; [:scope {:optional true} :any] ; [:report {:optional true} :any] ; [:gen {:optional true} :any]]] ; [:args ; [:schema [:* [:alt ; [:cat [:= :scope] :any] ; [:cat [:= :report] :any] ; [:cat [:= :gen] :any] ; [:cat :any :any]]]]]] ; :any ; :any] ; :any]]"><y>#</y><d>2022-01-08</d><h>20:51</h><r>ikitommi</r>this is the real schema for it:
<pre>(md/infer #&apos;m/-instrument)
;[:function
; [:=&gt; [:cat :any] :any]
; [:=&gt; [:cat :any :any] :any]
; [:=&gt;
;  [:cat
;   [:altn
;    [:map [:map 
;           [:scope {:optional true} :any] 
;           [:report {:optional true} :any] 
;           [:gen {:optional true} :any]]]
;    [:args
;     [:schema [:* [:alt 
;                   [:cat [:= :scope] :any] 
;                   [:cat [:= :report] :any] 
;                   [:cat [:= :gen] :any] 
;                   [:cat :any :any]]]]]]
;   :any
;   :any]
;  :any]]</pre></z><z id="t1641724975" t="ikitommi the plumatic syntax is merged in master, also better dev-tooling for CLJS (thanks to [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] !). Looking forward to test reports, will release soon/after."><y>#</y><d>2022-01-09</d><h>10:42</h><w>ikitommi</w>the plumatic syntax is merged in master, also better dev-tooling for CLJS (thanks to <a>@danvingo</a>!). Looking forward to test reports, will release soon/after.</z><z id="t1641736720" t="NoahTheDuke That’s so exciting! "><y>#</y><d>2022-01-09</d><h>13:58</h><w>NoahTheDuke</w>That’s so exciting! </z><z id="t1641750241" t="metame I’m interested in using malli with clj-kondo for static type checking. We already have clj-kondo in our project, and I saw in the malli readme on how to generate configs. Wondering if there are any decent examples that would demonstrate how to organize this for a large production code base?"><y>#</y><d>2022-01-09</d><h>17:44</h><w>metame</w>I’m interested in using malli with clj-kondo for static type checking. We already have clj-kondo in our project, and I saw in the malli readme on how to generate configs. Wondering if there are any decent examples that would demonstrate how to organize this for a large production code base?</z><z id="t1641751143" t="Ben Sless Static type checking in Clojure is a bit limited without type inference, which malli and kondo don&apos;t do. You&apos;ll have to specify everything you want checked. A sane middle ground is having a &quot;schema&quot; namespace where you specify the schema of data coming in or out of your code base, then validate at the edges of the system."><y>#</y><d>2022-01-09</d><h>17:59</h><r>Ben Sless</r>Static type checking in Clojure is a bit limited without type inference, which malli and kondo don&apos;t do.
You&apos;ll have to specify everything you want checked.
A sane middle ground is having a &quot;schema&quot; namespace where you specify the schema of data coming in or out of your code base, then validate at the edges of the system.</z><z id="t1641751617" t="borkdude clj-kondo does have some type inference"><y>#</y><d>2022-01-09</d><h>18:06</h><r>borkdude</r>clj-kondo does have some type inference</z><z id="t1641751734" t="Ben Sless (some type-inference? clj-kondo) ;; =&gt; true How much type inference does it do, exactly?"><y>#</y><d>2022-01-09</d><h>18:08</h><r>Ben Sless</r>(some type-inference? clj-kondo) ;; =&gt; true
How much type inference does it do, exactly?</z><z id="t1641752192" t="borkdude it has return type inference and locals inference for example"><y>#</y><d>2022-01-09</d><h>18:16</h><r>borkdude</r>it has return type inference and locals inference for example</z><z id="t1641752219" t="borkdude $ clj-kondo --lint - &lt;&lt;&lt; &apos;(let [x :foo] (inc x))&apos; &lt;stdin&gt;:1:20: error: Expected: number, received: keyword."><y>#</y><d>2022-01-09</d><h>18:16</h><r>borkdude</r><pre>$ clj-kondo --lint - &lt;&lt;&lt; &apos;(let [x :foo] (inc x))&apos;
&lt;stdin&gt;:1:20: error: Expected: number, received: keyword.</pre></z><z id="t1641752257" t="borkdude $ clj-kondo --lint - &lt;&lt;&lt; &apos;(let [x (inc 2)] (assoc x :foo :bar))&apos; &lt;stdin&gt;:1:25: error: Expected: associative collection or nil, received: number."><y>#</y><d>2022-01-09</d><h>18:17</h><r>borkdude</r><pre>$ clj-kondo --lint - &lt;&lt;&lt; &apos;(let [x (inc 2)] (assoc x :foo :bar))&apos;
&lt;stdin&gt;:1:25: error: Expected: associative collection or nil, received: number.</pre></z><z id="t1641752445" t="Ben Sless Do associative collections carry around type information about their keys?"><y>#</y><d>2022-01-09</d><h>18:20</h><r>Ben Sless</r>Do associative collections carry around type information about their keys?</z><z id="t1641752610" t="borkdude there is some of this, don&apos;t remember exactly how much, but probably not a lot"><y>#</y><d>2022-01-09</d><h>18:23</h><r>borkdude</r>there is some of this, don&apos;t remember exactly how much, but probably not a lot</z><z id="t1641752633" t="borkdude there is one open issue by [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] about this, that I haven&apos;t gotten around to yet"><y>#</y><d>2022-01-09</d><h>18:23</h><r>borkdude</r>there is one open issue by <a>@U055NJ5CC</a> about this, that I haven&apos;t gotten around to yet</z><z id="t1641756176" t="metame we already use plumatic.schema for data validation at the edges. I’m primarily talking about this: https://github.com/metosin/malli#clj-kondo I can see how to define the function spec right after with m/=&gt; ."><y>#</y><d>2022-01-09</d><h>19:22</h><r>metame</r>we already use plumatic.schema for data validation at the edges. I’m primarily talking about this:
<a href="https://github.com/metosin/malli#clj-kondo" target="_blank">https://github.com/metosin/malli#clj-kondo</a>

I can see how to define the function spec right after with <code>m/=&gt;</code> .</z><z id="t1641756218" t="metame What I’m wondering is if there’s a best practice for emitting all of the configs for a project after defining the specs in each ns?"><y>#</y><d>2022-01-09</d><h>19:23</h><r>metame</r>What I’m wondering is if there’s a best practice for emitting all of the configs for a project after defining the specs in each ns?</z><z id="t1641756369" t="metame And further than that, would this buy me anything when it comes to associative collections?"><y>#</y><d>2022-01-09</d><h>19:26</h><r>metame</r>And further than that, would this buy me anything when it comes to associative collections?</z><z id="t1641756429" t="metame But even just using it for arg types and return types, it’s still a step up imo"><y>#</y><d>2022-01-09</d><h>19:27</h><r>metame</r>But even just using it for arg types and return types, it’s still a step up imo</z><z id="t1641756637" t="borkdude [:attrs {:href &quot;/_/_/users/U774Z4VJA&quot;}] you get things for free and it might improve over time if you complain enough in the #clj-kondo channel :)"><y>#</y><d>2022-01-09</d><h>19:30</h><r>borkdude</r><a>@U774Z4VJA</a> you get things for free and it might improve over time if you complain enough in the #clj-kondo channel :)</z><z id="t1641756685" t="borkdude associative collections: if you specify a required key as input to a function and you pass a map literal, then clj-kondo will be able to see it"><y>#</y><d>2022-01-09</d><h>19:31</h><r>borkdude</r>associative collections: if you specify a required key as input to a function and you pass a map literal, then clj-kondo will be able to see it</z><z id="t1641756692" t="borkdude but the inference on associative collection needs more love"><y>#</y><d>2022-01-09</d><h>19:31</h><r>borkdude</r>but the inference on associative collection needs more love</z><z id="t1641756696" t="metame ha, ya. Maybe if work stay calm enough, I may even be able to contribute here and there 😉"><y>#</y><d>2022-01-09</d><h>19:31</h><r>metame</r>ha, ya. Maybe if work stay calm enough, I may even be able to contribute here and there <b>😉</b></z><z id="t1641756776" t="metame Any tips on emitting config for a whole project?"><y>#</y><d>2022-01-09</d><h>19:32</h><r>metame</r>Any tips on emitting config for a whole project?</z><z id="t1641756804" t="borkdude for this question I defer to the malli authors!"><y>#</y><d>2022-01-09</d><h>19:33</h><r>borkdude</r>for this question I defer to the malli authors!</z><z id="t1641756815" t="metame ofc thanks"><y>#</y><d>2022-01-09</d><h>19:33</h><r>metame</r>ofc thanks</z><z id="t1641756850" t="metame tl;dr of above thread. One unanswered question: Any tips on emitting clj-kondo config for a whole project?"><y>#</y><d>2022-01-09</d><h>19:34</h><w>metame</w>tl;dr of above thread. One unanswered question:
Any tips on emitting clj-kondo config for a whole project?</z><z id="t1641825394" t="ikitommi There is no guide for that and as there are 3+ ways to declare the schemas for functions, no best practices yet I think. I put the schemas next to the functions (my favourite is the plumatic-syntax, so inlined) and have the ! in the user / dev namespace, so you can do that easily. It instruments all the functions from all loaded namespaces, so should work ok."><y>#</y><d>2022-01-10</d><h>14:36</h><r>ikitommi</r>There is no guide for that and as there are 3+ ways to declare the schemas for functions, no best practices yet I think. I put the schemas next to the functions (my favourite is the plumatic-syntax, so inlined) and have the <code>!</code> in the user / dev namespace, so you can do that easily. It instruments all the functions from all loaded namespaces, so should work ok.</z><z id="t1641825417" t="ikitommi if not, please report 🙂 planning to mallify a large codebase, can comment after that how it works / doesn’t."><y>#</y><d>2022-01-10</d><h>14:36</h><r>ikitommi</r>if not, please report <b>🙂</b> planning to mallify a large codebase, can comment after that how it works / doesn’t.</z><z id="t1641825438" t="ikitommi if you are doing that already, user experience report post &amp; feedback most welcome"><y>#</y><d>2022-01-10</d><h>14:37</h><r>ikitommi</r>if you are doing that already, user experience report post &amp; feedback most welcome</z><z id="t1641825560" t="metame Many thanks for the response! Will ! also emit the clj-kondo config [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ?"><y>#</y><d>2022-01-10</d><h>14:39</h><r>metame</r>Many thanks for the response!

Will <code>!</code> also emit the clj-kondo config <a>@U055NJ5CC</a>?</z><z id="t1641825812" t="ikitommi yes"><y>#</y><d>2022-01-10</d><h>14:43</h><r>ikitommi</r>yes</z><z id="t1641825843" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/dev.clj#L15-L36"><y>#</y><d>2022-01-10</d><h>14:44</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/dev.clj#L15-L36" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/dev.clj#L15-L36</a></z><z id="t1641825851" t="metame That is 🔥"><y>#</y><d>2022-01-10</d><h>14:44</h><r>metame</r>That is <b>🔥</b></z><z id="t1641825854" t="metame Thanks"><y>#</y><d>2022-01-10</d><h>14:44</h><r>metame</r>Thanks</z><z id="t1641825895" t="ikitommi 👍"><y>#</y><d>2022-01-10</d><h>14:44</h><r>ikitommi</r><b>👍</b></z><z id="t1641826092" t="metame I also like the plumatic syntax so very cool that was just added"><y>#</y><d>2022-01-10</d><h>14:48</h><r>metame</r>I also like the plumatic syntax so very cool that was just added</z><z id="t1641806349" t="Jungwoo Kim Hi I’m thinking of using malli with my project and still investigating it. I have a simple question. What do :cat and :catn means? I want to know the full name of cat and catn to understand better . alt and altn too."><y>#</y><d>2022-01-10</d><h>09:19</h><w>Jungwoo Kim</w>Hi I’m thinking of using malli with my project and still investigating it. I have a simple question. What do <code>:cat</code> and <code>:catn</code> means? I want to know the full name of <code>cat</code> and <code>catn</code> to understand better . <code>alt</code> and <code>altn</code> too.</z><z id="t1641807618" t="Ben Sless Cat is a con*cat*enation of sequences Alt is an alternation of sequences The n suffix is &quot;named&quot;, like a named capture group in a regular expression"><y>#</y><d>2022-01-10</d><h>09:40</h><r>Ben Sless</r>Cat is a con*cat*enation of sequences
Alt is an alternation of sequences
The n suffix is &quot;named&quot;, like a named capture group in a regular expression</z><z id="t1641807705" t="Ben Sless I can elaborate if this is unclear"><y>#</y><d>2022-01-10</d><h>09:41</h><r>Ben Sless</r>I can elaborate if this is unclear</z><z id="t1641807875" t="Jungwoo Kim Thanks a lot. I understood!"><y>#</y><d>2022-01-10</d><h>09:44</h><r>Jungwoo Kim</r>Thanks a lot.  I understood!</z><z id="t1641866858" t="Jungwoo Kim Hi! I’m really into malli very recently. thanks! I have a question though. Here’s my example pants-schema. (def pants-schema [:and [:map [:id int?] [:size {:optional true} [:maybe :int]] [:size-alphabet {:optional true} [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]] [:fn {:error/message &quot;size and size alphabet should be nil-matched&quot;} &apos;(fn [{:keys [size size-alphabet]}] (or (and (nil? size) (nil? size-alphabet)) (and (some? size) (some? size-alphabet))))]]) You can see my nil-matched fn schema. I’m trying to use the schema to validate for functions like below, (defn do-something-with-pants {:malli/schema [:=&gt; [:cat pants-schema] :nil]} [pants] (prn pants)) ; do something and then, if i pass the value {:id 1 :size 90} into the do-something-with-pants , I want to extract the error like humanize results but I got the full error messages. ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137). ; :malli.core/invalid-input {:input [:cat [:and [:map [:id int?] [:size [:maybe :int]] [:size-alphabet [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]] [:fn #:error{:message &quot;size and size alphabet should be nil-matched&quot;} (fn [{:keys [size size-alphabet]}] (or (and (nil? size) (nil? size-alphabet)) (and (some? size) (some? size-alphabet))))]]], :args [{:id 1, :size 90}], :schema [:=&gt; [:cat [:and [:map [:id int?] [:size [:maybe :int]] [:size-alphabet [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]] [:fn #:error{:message &quot;size and size alphabet should be nil-matched&quot;} (fn [{:keys [size size-alphabet]}] (or (and (nil? size) (nil? size-alphabet)) (and (some? size) (some? size-alphabet))))]]] :nil]} I know explain + humanize is very useful to see the readable results but as I feel like that’s good for development stage. In the web application, My needs are very important to me. How do I handle errors properly?"><y>#</y><d>2022-01-11</d><h>02:07</h><w>Jungwoo Kim</w>Hi! I’m really into malli very recently. thanks!
I have a question though.

Here’s my example pants-schema.

<pre>(def pants-schema
  [:and
   [:map
    [:id int?]
    [:size {:optional true} [:maybe :int]]
    [:size-alphabet {:optional true} [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]]
   [:fn {:error/message &quot;size and size alphabet should be nil-matched&quot;}
    &apos;(fn [{:keys [size size-alphabet]}]
       (or (and (nil? size) (nil? size-alphabet))
           (and (some? size) (some? size-alphabet))))]])</pre>
You can see my <code>nil-matched</code> fn schema. I’m trying to use the schema to validate for functions like below,
<pre>(defn do-something-with-pants
  {:malli/schema [:=&gt; [:cat pants-schema] :nil]}
  [pants]
  (prn pants)) ; do something</pre>
and then, if i pass the value <code>{:id 1 :size 90}</code> into the <code>do-something-with-pants</code> , I want to extract the error like <code>humanize</code> results but I got the full error messages.
<pre>; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:137).
; :malli.core/invalid-input {:input [:cat [:and [:map [:id int?] [:size [:maybe :int]] [:size-alphabet [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]] [:fn #:error{:message &quot;size and size alphabet should be nil-matched&quot;} (fn [{:keys [size size-alphabet]}] (or (and (nil? size) (nil? size-alphabet)) (and (some? size) (some? size-alphabet))))]]], :args [{:id 1, :size 90}], :schema [:=&gt; [:cat [:and [:map [:id int?] [:size [:maybe :int]] [:size-alphabet [:maybe [:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;]]]] [:fn #:error{:message &quot;size and size alphabet should be nil-matched&quot;} (fn [{:keys [size size-alphabet]}] (or (and (nil? size) (nil? size-alphabet)) (and (some? size) (some? size-alphabet))))]]] :nil]}</pre>
I know explain + humanize is very useful to see the readable results but as I feel like that’s good for development stage. In the web application, My needs are very important to me. How do I handle errors properly?</z><z id="t1641987190" t="rovanion Any recommendation on dealing with time? I&apos;ve got multiple fields that hold LocalDateTime and it&apos;s not clear to me how I should express that."><y>#</y><d>2022-01-12</d><h>11:33</h><w>rovanion</w>Any recommendation on dealing with time? I&apos;ve got multiple fields that hold LocalDateTime and it&apos;s not clear to me how I should express that.</z><z id="t1642001098" t="ikitommi you could c&amp;p code from this https://github.com/metosin/malli/pull/545 , or wait for the PR or just do something like: (def LocalDateTime (m/-simple-schema {:type &apos;LocalDateTime :pred #(instance? LocalDateTime %) :type-properties {:error/message &quot;invalid date-time&quot; :decode/string #(LocalDate/parse %) :json-schema {:type &quot;string&quot; :format &quot;date-time&quot;}})) (m/validate LocalDateTime (LocalDateTime/now)) ; =&gt; true (didn’t run that, might not work, but like that anyways."><y>#</y><d>2022-01-12</d><h>15:24</h><r>ikitommi</r>you could c&amp;p code from this <a href="https://github.com/metosin/malli/pull/545" target="_blank">https://github.com/metosin/malli/pull/545</a>, or wait for the PR or just do something like:
<pre>(def LocalDateTime
  (m/-simple-schema
    {:type &apos;LocalDateTime
     :pred #(instance? LocalDateTime %)
     :type-properties {:error/message &quot;invalid date-time&quot;
                       :decode/string #(LocalDate/parse %)
                       :json-schema {:type &quot;string&quot;
                                     :format &quot;date-time&quot;}}))

(m/validate LocalDateTime (LocalDateTime/now)) ; =&gt; true</pre>
(didn’t run that, might not work, but like that anyways.</z><z id="t1642524919" t="rovanion Thank you!"><y>#</y><d>2022-01-18</d><h>16:55</h><r>rovanion</r>Thank you!</z><z id="t1641989732" t="rovanion When walking a schema, what does the nil that appears as the second entry in all children represent? (def temperaturmätning (malli/schema [:map [:odlingsplats [string? {:min 1}]] [:tidpunkt string?]])) (malli/walk temperaturmätning (fn [schema path children _] (println &quot;Path: &quot; path) (println &quot;Type: &quot; (malli/type schema)) (print &quot;Schema: &quot;) (clojure.pprint/pprint schema) (clojure.pprint/pprint children) (case (malli/type schema) string? [:input {:type &quot;text&quot;} (-&gt; path last name)] :map [:div.input-group children]) )) ;; [:div.input-group ;; [[:odlingsplats nil [:input {:type &quot;text&quot;} &quot;odlingsplats&quot;]] ;; [:tidpunkt nil [:input {:type &quot;text&quot;} &quot;tidpunkt&quot;]]]] "><y>#</y><d>2022-01-12</d><h>12:15</h><w>rovanion</w>When walking a schema, what does the <code>nil</code> that appears as the second entry in all children represent?

<pre>(def temperaturmätning                                                                                                                                                                                        
  (malli/schema                                                                                                                                                                                               
   [:map                                                                                                                                                                                                      
    [:odlingsplats [string? {:min 1}]]                                                                                                                                                                        
    [:tidpunkt     string?]]))

(malli/walk
  temperaturmätning
  (fn [schema path children _]
    (println &quot;Path: &quot; path)
    (println &quot;Type: &quot; (malli/type schema))
    (print &quot;Schema: &quot;)
    (clojure.pprint/pprint schema)
    (clojure.pprint/pprint children)
    (case (malli/type schema)
      string?  [:input {:type &quot;text&quot;} (-&gt; path last name)]
      :map             [:div.input-group children])
    ))

;; [:div.input-group                                                                                                                                                                                          
;;  [[:odlingsplats nil [:input {:type &quot;text&quot;} &quot;odlingsplats&quot;]]                                                                                                                                               
;;  [:tidpunkt nil [:input {:type &quot;text&quot;} &quot;tidpunkt&quot;]]]]   </pre></z><z id="t1641990226" t="ikitommi entry properties, e.g. in`[:map [:x {:optional true} :int]]`"><y>#</y><d>2022-01-12</d><h>12:23</h><r>ikitommi</r>entry properties, e.g. in`[:map [:x {:optional true} :int]]`</z><z id="t1641994323" t="rovanion Ah, of course!"><y>#</y><d>2022-01-12</d><h>13:32</h><r>rovanion</r>Ah, of course!</z><z id="t1642004437" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] since the time PR is back on the agenda, what do you think about tackling the protocols split first?"><y>#</y><d>2022-01-12</d><h>16:20</h><w>Ben Sless</w><a>@ikitommi</a> since the time PR is back on the agenda, what do you think about tackling the protocols split first?</z><z id="t1642010764" t="ikitommi Thanks for reminding. I’ve been thinking about it. Just commented on the issue."><y>#</y><d>2022-01-12</d><h>18:06</h><r>ikitommi</r>Thanks for reminding. I’ve been thinking about it. Just commented on the issue.</z><z id="t1642054501" t="Mutasem Hidmi Hi guys, how are you? I am new to Clojure. I wanted to ask a question about humanizing the errors returned from Malli when used as coercion. I tried to do like below, but it didn&apos;t work. (def custom-coercion (reitit.coercion.malli/create {:transformers {:body {:default reitit.coercion.malli/default-transformer-provider :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider}} :string {:default reitit.coercion.malli/string-transformer-provider} :response {:default reitit.coercion.malli/default-transformer-provider}} :error-keys #{:type :coercion :in :schema :value :errors :humanized #_:transformed} :compile mu/closed-schema :encode-error (fn [error] {:errors (:humanized error)}) :validate true :enabled true :strip-extra-keys true :default-values true :options nil})) "><y>#</y><d>2022-01-13</d><h>06:15</h><w>Mutasem Hidmi</w>Hi guys, how are you? I am new to Clojure. I wanted to ask a question about humanizing the errors returned from Malli when used as coercion. I tried to do like below, but it didn&apos;t work.

<pre>(def custom-coercion (reitit.coercion.malli/create
               {:transformers {:body {:default reitit.coercion.malli/default-transformer-provider
                                      :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider}}
                               :string {:default reitit.coercion.malli/string-transformer-provider}
                               :response {:default reitit.coercion.malli/default-transformer-provider}}
                :error-keys #{:type :coercion :in :schema :value :errors :humanized #_:transformed}
                :compile mu/closed-schema
                :encode-error (fn [error] {:errors (:humanized error)})
                :validate true
                :enabled true
                :strip-extra-keys true
                :default-values true
                :options nil}))</pre>
</z><z id="t1642055278" t="dharrigan I have an example"><y>#</y><d>2022-01-13</d><h>06:27</h><w>dharrigan</w>I have an example</z><z id="t1642055283" t="dharrigan give me a moment and I&apos;ll push it up to github"><y>#</y><d>2022-01-13</d><h>06:28</h><w>dharrigan</w>give me a moment and I&apos;ll push it up to github</z><z id="t1642055702" t="Mutasem Hidmi Thank [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] . I appreciate it."><y>#</y><d>2022-01-13</d><h>06:35</h><w>Mutasem Hidmi</w>Thank <a>@dharrigan</a>. I appreciate it.</z><z id="t1642055986" t="dharrigan Here you go: "><y>#</y><d>2022-01-13</d><h>06:39</h><r>dharrigan</r>Here you go: <code></code></z><z id="t1642055999" t="dharrigan It&apos;s a very simple example, which may help you along the path"><y>#</y><d>2022-01-13</d><h>06:39</h><r>dharrigan</r>It&apos;s a very simple example, which may help you along the path</z><z id="t1642056018" t="dharrigan In particular, look at:"><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r>In particular, look at:</z><z id="t1642056019" t="dharrigan "><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r><code></code></z><z id="t1642056027" t="dharrigan Then"><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r>Then</z><z id="t1642056028" t="dharrigan "><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r><code></code></z><z id="t1642056052" t="dharrigan And here is the malli spec for the API:"><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r>And here is the malli <code>spec</code> for the API:</z><z id="t1642056056" t="dharrigan "><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r><code></code></z><z id="t1642056058" t="dharrigan ."><y>#</y><d>2022-01-13</d><h>06:40</h><r>dharrigan</r>.</z><z id="t1642056128" t="dharrigan The encode-error function can be certainly improved (it assumes only one error, there could be multiple). Treat it like a starting point 😉"><y>#</y><d>2022-01-13</d><h>06:42</h><r>dharrigan</r>The <code>encode-error</code> function can be certainly improved (it assumes only one error, there could be multiple). Treat it like a starting point <b>😉</b></z><z id="t1642056165" t="dharrigan Here is an example of a failure response:"><y>#</y><d>2022-01-13</d><h>06:42</h><r>dharrigan</r>Here is an example of a failure response:</z><z id="t1642056167" t="dharrigan ❯ http :8080/api/foo HTTP/1.1 400 Bad Request Transfer-Encoding: chunked What is going on?? There is a &apos;missing required key&apos;. I was expecting a value for &apos;[:id]&apos; but got &apos;null&apos; instead!"><y>#</y><d>2022-01-13</d><h>06:42</h><r>dharrigan</r><pre>❯ http :8080/api/foo      
HTTP/1.1 400 Bad Request
Transfer-Encoding: chunked

What is going on?? There is a &apos;missing required key&apos;. I was expecting a value for &apos;[:id]&apos; but got &apos;null&apos; instead!</pre></z><z id="t1642056175" t="dharrigan and here is an example of a successful response:"><y>#</y><d>2022-01-13</d><h>06:42</h><r>dharrigan</r>and here is an example of a successful response:</z><z id="t1642056181" t="dharrigan ❯ http :8080/api/foo?id=10 HTTP/1.1 200 OK Content-Length: 14 Content-Type: application/json;charset=utf-8 { &quot;hello&quot;: &quot;10&quot; }"><y>#</y><d>2022-01-13</d><h>06:43</h><r>dharrigan</r><pre>❯ http :8080/api/foo?id=10
HTTP/1.1 200 OK
Content-Length: 14
Content-Type: application/json;charset=utf-8

{
    &quot;hello&quot;: &quot;10&quot;
}</pre></z><z id="t1642056181" t="dharrigan ."><y>#</y><d>2022-01-13</d><h>06:43</h><r>dharrigan</r>.</z><z id="t1642056186" t="Mutasem Hidmi Thank you. I am checking it now"><y>#</y><d>2022-01-13</d><h>06:43</h><r>Mutasem Hidmi</r>Thank you. I am checking it now</z><z id="t1642063724" t="Mutasem Hidmi Thanks buddy. By the way, you can put also this :error-keys #{:type :coercion :in :schema :value :errors :humanized #_:transformed} in order to get a humanized key that you can use in the encode-error"><y>#</y><d>2022-01-13</d><h>08:48</h><r>Mutasem Hidmi</r>Thanks buddy. By the way, you can put also this :error-keys #{:type :coercion :in :schema :value :errors :humanized #_:transformed} in order to get a humanized key that you can use in the encode-error</z><z id="t1642176277" t="metame Anyone have an example of plumatic syntax in the wild (not in docs yet)? (also possible I’ve misunderstood the meaning of adding plumatic syntax) I see it in the Destructuring section of the README for fn type hints. EDIT: looking at the PR, I’m seeing the usage under the experimental ns. So basically we can use in-line plumatic syntax for in-line function types but not anything similar to plumatic syntax for a full schema def. For that we still need to use the vector or map syntax."><y>#</y><d>2022-01-14</d><h>16:04</h><w>metame</w>Anyone have an example of plumatic syntax in the wild (not in docs yet)?

(also possible I’ve misunderstood the meaning of adding plumatic syntax)
I see it in the Destructuring section of the README for fn type hints.

EDIT: looking at the PR, I’m seeing the usage under the experimental ns. So basically we can use in-line plumatic syntax for in-line function types but not anything similar to plumatic syntax for a full schema def. For that we still need to use the vector or map syntax.</z><z id="t1642178085" t="ikitommi no full schema syntax. That would be... interesting."><y>#</y><d>2022-01-14</d><h>16:34</h><r>ikitommi</r>no full schema syntax. That would be... interesting.</z><z id="t1642178890" t="metame thanks 🙇"><y>#</y><d>2022-01-14</d><h>16:48</h><r>metame</r>thanks <b>🙇</b></z><z id="t1642194322" t="mynomoto Is there someplace where the type options are documented? E.g. [:qualified-keyword {:namespace :xxx}] works but [:qualified-namespace {:namespace :xxx}] doesn´t check the namespace."><y>#</y><d>2022-01-14</d><h>21:05</h><w>mynomoto</w>Is there someplace where the type options are documented? E.g. <code>[:qualified-keyword {:namespace :xxx}]</code> works but <code>[:qualified-namespace {:namespace :xxx}]</code> doesn´t check the namespace.</z><z id="t1642539128" t="coltnz Hi, is there a way to default a value even if the key is optional in the schema?"><y>#</y><d>2022-01-18</d><h>20:52</h><w>coltnz</w>Hi, is there a way to default a value even if the key is optional in the schema?</z><z id="t1642539166" t="coltnz I have a map which may or may not have a date entry. In the latter case I want to default it to now"><y>#</y><d>2022-01-18</d><h>20:52</h><w>coltnz</w>I have a map which may or may not have a date entry. In the latter case I want to default it to now</z><z id="t1642539169" t="coltnz (m/decode [:map [:date {:optional true} [:maybe [:string {:decode/string mt/-string-&gt;date :default (tick/now)}]]]] {} (mt/transformer mt/string-transformer mt/default-value-transformer))"><y>#</y><d>2022-01-18</d><h>20:52</h><w>coltnz</w><pre>(m/decode [:map
           [:date {:optional true}
            [:maybe [:string {:decode/string mt/-string-&gt;date :default (tick/now)}]]]]
          {}
          (mt/transformer mt/string-transformer mt/default-value-transformer))</pre></z><z id="t1642539205" t="coltnz returns {} which doesn&apos;t surprise me."><y>#</y><d>2022-01-18</d><h>20:53</h><w>coltnz</w>returns <code>{}</code> which doesn&apos;t surprise me.</z><z id="t1642548008" t="NoahTheDuke What does a default for an optional property even mean?"><y>#</y><d>2022-01-18</d><h>23:20</h><w>NoahTheDuke</w></z><z id="t1642572060" t="ikitommi [:attrs {:href &quot;/_/_/users/U06B56BKP&quot;}] no at the moment. But we could add an option to mt/default-value-transformer to fill those, here’s the code for it: https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L394 . Issue &amp; PR welcome."><y>#</y><d>2022-01-19</d><h>06:01</h><w>ikitommi</w><a>@coltnz</a> no at the moment. But we could add an option to <code>mt/default-value-transformer</code> to fill those, here’s the code for it: <a href="https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L394" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L394</a>. Issue &amp; PR welcome.</z><z id="t1642575982" t="coltnz cool i&apos;ll do a PR"><y>#</y><d>2022-01-19</d><h>07:06</h><w>coltnz</w>cool i&apos;ll do a PR</z><z id="t1642611067" t="rovanion Anyone ever had their data thrown away during coercion in reitit when using their own custom malli schema type? I&apos;ve defined mine like: (defn- -string-gen [{:keys [min max]}] (cond (and min (= min max)) (gen/fmap string/join (gen/vector gen/char min)) (and min max) (gen/fmap string/join (gen/vector gen/char min max)) min (gen/fmap string/join (gen/vector gen/char min (* 2 min))) max (gen/fmap string/join (gen/vector gen/char 0 max)) :else gen/string)) (def postgres-string &quot;Postgres does not allow the null byte \0 in strings. The predicate only forbids null bytes, but the generator only generates ascii characters. This severely limits the range of test strings. The latter should be changed at some later point.&quot; (malli/-simple-schema (fn [opts _] {:type :postgres/string :pred #(and (string? %) (not (string/includes? \0 %))) :type-properties {:error/message &quot;Unable to decode postgres string&quot; :decode/string (fn [x] (prn &quot;We are in the decoder&quot;) x) :json-schema/type &quot;string&quot; :json-schema/format &quot;string&quot; :json-schema/minimum 0 :gen/gen (-string-gen opts)}}))) But when defining a schema with it like (def kasse (malli/schema [:map [:odlingsplats [postgres-string {:foreign-key &quot;odlingsplatser&quot;}]] [:diameter_m int?] [:djup_m int?]])) and then running a request through my router like (tove.handler/app-routes {:request-method :post, :uri &quot;/kassar/-/new&quot; :form-params {:odlingsplats &quot;En bra plats&quot; :diameter_m &quot;1&quot; :djup_m &quot;1&quot;}}) the data is without any error conformed into {:diameter_m 1, :djup_m 1} If I replace postgres-string with string? in the schema the data gets passed on and the conformed map looks like: {:odlingsplats &quot;En bra plats&quot;, :diameter_m 1, :djup_m 1}"><y>#</y><d>2022-01-19</d><h>16:51</h><w>rovanion</w>Anyone ever had their data thrown away during coercion in reitit when using their own custom malli schema type?

I&apos;ve defined mine like:

<pre>(defn- -string-gen [{:keys [min max]}]
  (cond
    (and min (= min max)) (gen/fmap string/join (gen/vector gen/char min))
    (and min max)         (gen/fmap string/join (gen/vector gen/char min max))
    min                   (gen/fmap string/join (gen/vector gen/char min (* 2 min)))
    max                   (gen/fmap string/join (gen/vector gen/char 0 max))
    :else                 gen/string))

(def postgres-string
  &quot;Postgres does not allow the null byte \0 in strings.                                               
                                                                                                      
  The predicate only forbids null bytes, but the generator only generates ascii characters. This      
  severely limits the range of test strings. The latter should be changed at some later point.&quot;
  (malli/-simple-schema
   (fn [opts _]
     {:type            :postgres/string
      :pred            #(and (string? %) (not (string/includes? \0 %)))
      :type-properties {:error/message       &quot;Unable to decode postgres string&quot;
                        :decode/string       (fn [x] (prn &quot;We are in the decoder&quot;) x)
                        :json-schema/type    &quot;string&quot;
                        :json-schema/format  &quot;string&quot;
                        :json-schema/minimum 0
                        :gen/gen             (-string-gen opts)}})))</pre>
But when defining a schema with it like

<pre>(def kasse
  (malli/schema
   [:map
    [:odlingsplats                  [postgres-string {:foreign-key &quot;odlingsplatser&quot;}]]
    [:diameter_m                    int?]
    [:djup_m                        int?]]))</pre>
and then running a request through my router like

<pre>(tove.handler/app-routes {:request-method :post, :uri &quot;/kassar/-/new&quot; :form-params {:odlingsplats &quot;En bra plats&quot; :diameter_m &quot;1&quot; :djup_m &quot;1&quot;}})</pre>
the data is without any error conformed into

<pre>{:diameter_m 1, :djup_m 1} </pre>

If I replace <code>postgres-string</code> with <code>string?</code> in the schema the data gets passed on and the conformed map looks like:

<pre>{:odlingsplats &quot;En bra plats&quot;, :diameter_m 1, :djup_m 1}</pre></z><z id="t1642611290" t="Ben Sless How did you define coercion for the router?"><y>#</y><d>2022-01-19</d><h>16:54</h><r>Ben Sless</r>How did you define coercion for the router?</z><z id="t1642611468" t="rovanion Here&apos;s the relevant section of the router: [&quot;/-/new&quot; {:post {:handler (partial page/create-entry! &quot;kassar&quot; &quot;id&quot;) :coercion mc/coercion :parameters {:form s/kasse-user-data}}}]] I also have this at the very end of the router definition: {:data {:middleware [rrc/coerce-request-middleware]}}"><y>#</y><d>2022-01-19</d><h>16:57</h><r>rovanion</r>Here&apos;s the relevant section of the router:

<pre>[&quot;/-/new&quot;                     {:post {:handler (partial page/create-entry! &quot;kassar&quot; &quot;id&quot;)
                                           :coercion mc/coercion
                                           :parameters {:form s/kasse-user-data}}}]]</pre>
I also have this at the very end of the router definition:

<pre>{:data {:middleware [rrc/coerce-request-middleware]}}</pre></z><z id="t1642611805" t="Ben Sless I think you need to specify it should use string coercion"><y>#</y><d>2022-01-19</d><h>17:03</h><r>Ben Sless</r>I think you need to specify it should use string coercion</z><z id="t1642613565" t="rovanion I&apos;m not sure I understand, where should I tell what what?"><y>#</y><d>2022-01-19</d><h>17:32</h><r>rovanion</r>I&apos;m not sure I understand, where should I tell what what?</z><z id="t1642613599" t="Ben Sless I&apos;ll dig up an example"><y>#</y><d>2022-01-19</d><h>17:33</h><r>Ben Sless</r>I&apos;ll dig up an example</z><z id="t1642613668" t="Ben Sless I think you need something like (mcoercion/create {:transformers {:body {:default string-transformer-provider :formats {&quot;application/json&quot; string-transformer-provider}} :string {:default string-transformer-provider} :response {:default mcoercion/default-transformer-provider}}}) "><y>#</y><d>2022-01-19</d><h>17:34</h><r>Ben Sless</r>I think you need something like
<pre>(mcoercion/create
   {:transformers
    {:body
     {:default string-transformer-provider
      :formats {&quot;application/json&quot; string-transformer-provider}}
     :string
     {:default string-transformer-provider}
     :response
     {:default mcoercion/default-transformer-provider}}})</pre>
</z><z id="t1642613670" t="Ben Sless Roughly"><y>#</y><d>2022-01-19</d><h>17:34</h><r>Ben Sless</r>Roughly</z><z id="t1642613732" t="Ben Sless idea - use string coercion instead of json coercion by default for your params"><y>#</y><d>2022-01-19</d><h>17:35</h><r>Ben Sless</r>idea - use string coercion instead of json coercion by default for your params</z><z id="t1642670572" t="rovanion What seems to have worked is that I set up my own spec-style mutable registry that I set as the default registry. And by referring to the type as a key in kasse instead of as a var it all worked out."><y>#</y><d>2022-01-20</d><h>09:22</h><r>rovanion</r>What seems to have worked is that I set up my own spec-style mutable registry that I set as the default registry. And by referring to the type as a key in kasse instead of as a var it all worked out.</z><z id="t1642670595" t="rovanion Now my &quot;We are in the decoder&quot; message is printed and all is fine!"><y>#</y><d>2022-01-20</d><h>09:23</h><r>rovanion</r>Now my &quot;We are in the decoder&quot; message is printed and all is fine!</z><z id="t1642622113" t="NoahTheDuke Is there a shorter form of (def FxSchema (m/schema [:* [:or nil? [:tuple qualified-keyword?] [:tuple qualified-keyword? [:maybe any?]]]])) "><y>#</y><d>2022-01-19</d><h>19:55</h><w>NoahTheDuke</w>Is there a shorter form of
<pre>(def FxSchema
  (m/schema
    [:* [:or
         nil?
         [:tuple qualified-keyword?]
         [:tuple qualified-keyword? [:maybe any?]]]]))</pre>
</z><z id="t1642624520" t="Ben Sless or nil? T -&gt; maybe T"><y>#</y><d>2022-01-19</d><h>20:35</h><r>Ben Sless</r><code>or nil? T</code> -&gt; <code>maybe T</code></z><z id="t1642624594" t="Ben Sless [:sequence qualified-keyword? [:? any?]]"><y>#</y><d>2022-01-19</d><h>20:36</h><r>Ben Sless</r><code>[:sequence qualified-keyword? [:? any?]]</code></z><z id="t1642624627" t="Ben Sless [:* [:maybe [:sequence qualified-keyword? [:? any?]]]]"><y>#</y><d>2022-01-19</d><h>20:37</h><r>Ben Sless</r><code>[:* [:maybe [:sequence qualified-keyword? [:? any?]]]]</code></z><z id="t1642624636" t="NoahTheDuke very nice, thank you"><y>#</y><d>2022-01-19</d><h>20:37</h><r>NoahTheDuke</r>very nice, thank you</z><z id="t1642624838" t="NoahTheDuke hm, that doesn’t work because :sequential requires homogenous input. maybe i need :cat ?"><y>#</y><d>2022-01-19</d><h>20:40</h><r>NoahTheDuke</r>hm, that doesn’t work because <code>:sequential</code> requires homogenous input. maybe i need <code>:cat</code>?</z><z id="t1642624873" t="NoahTheDuke that’s it: :sequential -&gt; :cat works"><y>#</y><d>2022-01-19</d><h>20:41</h><r>NoahTheDuke</r>that’s it: <code>:sequential</code> -&gt; <code>:cat</code> works</z><z id="t1642624877" t="NoahTheDuke thanks for the help!"><y>#</y><d>2022-01-19</d><h>20:41</h><r>NoahTheDuke</r>thanks for the help!</z><z id="t1642625110" t="Ben Sless 👍"><y>#</y><d>2022-01-19</d><h>20:45</h><r>Ben Sless</r><b>👍</b></z><z id="t1642625132" t="Ben Sless When in doubt, grab a catjam"><y>#</y><d>2022-01-19</d><h>20:45</h><r>Ben Sless</r>When in doubt, grab a <b>catjam</b></z><z id="t1642654668" t="Abhinav how do I express this in a schema? {&quot;hi&quot; {:greeting &quot;hi&quot; :id 1} &quot;hello&quot; {:greeting &quot;hello&quot; :id 2} &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}} I have a function that transforms a map like this [{:greeting &quot;hi&quot; :id 1}{:greeting &quot;hello&quot; :id 2}{:greeting &quot;hiee&quot; :id 3}] into the one above, the values of :greeting aren’t known before hand"><y>#</y><d>2022-01-20</d><h>04:57</h><w>Abhinav</w>how do I express this in a schema?
<pre>{&quot;hi&quot; {:greeting &quot;hi&quot; :id 1} &quot;hello&quot; {:greeting &quot;hello&quot; :id 2} &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}}</pre>
I have a function that transforms a map like this
<pre>[{:greeting &quot;hi&quot; :id 1}{:greeting &quot;hello&quot; :id 2}{:greeting &quot;hiee&quot; :id 3}]</pre>
into the one above, the values of <code>:greeting</code> aren’t known before hand</z><z id="t1642677380" t="ikitommi maybe: [:map-of :string [:map [:id :int] [:greeting :string]]]"><y>#</y><d>2022-01-20</d><h>11:16</h><r>ikitommi</r>maybe: <code>[:map-of :string [:map [:id :int] [:greeting :string]]]</code></z><z id="t1642677816" t="Abhinav That is a good suggestion, but I want to say that the key of the map has to the be equal to the value of the :greeting key. so [:map-of :string [:map [:id :int] [:greeting :string]]] would be valid for {&quot;foostring&quot; {:greeting &quot;hi&quot; :id 3}} but the above won’t be valid"><y>#</y><d>2022-01-20</d><h>11:23</h><r>Abhinav</r>That is a good suggestion, but I want to say that the key of the map has to the be equal to the value of the <code>:greeting</code> key.

so <code>[:map-of :string [:map [:id :int] [:greeting :string]]]</code>
would be valid for
<code>{&quot;foostring&quot; {:greeting &quot;hi&quot; :id 3}}</code>
but the above won’t be valid</z><z id="t1642677850" t="Abhinav I don’t know if what I’m tryign to do is an anti-pattern:sweat_smile:"><y>#</y><d>2022-01-20</d><h>11:24</h><r>Abhinav</r>I don’t know if what I’m tryign to do is an anti-pattern:sweat_smile:</z><z id="t1642678648" t="ikitommi no, it’s all valid, maybe: (def Schema (m/schema [:and [:map-of :string [:map [:id :int] [:greeting :string]]] [:fn (partial every? (fn [[k d]] (= k (:greeting d))))]])) (m/validate Schema {&quot;hi&quot; {:greeting &quot;hi&quot; :id 1} &quot;hello&quot; {:greeting &quot;hello&quot; :id 2} &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}}) ; =&gt; true (m/validate Schema {&quot;hi&quot; {:greeting &quot;&lt;&lt;invalid&gt;&gt;&quot; :id 1} &quot;hello&quot; {:greeting &quot;hello&quot; :id 2} &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}}) ; =&gt; false"><y>#</y><d>2022-01-20</d><h>11:37</h><r>ikitommi</r>no, it’s all valid, maybe:
<pre>(def Schema
  (m/schema
   [:and
    [:map-of :string [:map [:id :int] [:greeting :string]]]
    [:fn (partial every? (fn [[k d]] (= k (:greeting d))))]]))

(m/validate
 Schema
 {&quot;hi&quot; {:greeting &quot;hi&quot; :id 1}
  &quot;hello&quot; {:greeting &quot;hello&quot; :id 2}
  &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}})
; =&gt; true

(m/validate
 Schema
 {&quot;hi&quot; {:greeting &quot;&lt;&lt;invalid&gt;&gt;&quot; :id 1}
  &quot;hello&quot; {:greeting &quot;hello&quot; :id 2}
  &quot;hiee&quot; {:greeting &quot;hiee&quot; :id 3}})
; =&gt; false</pre></z><z id="t1642678790" t="ikitommi m/explain here doesn’t produce correct place of error, [:attrs nil] should do it, we could tune either :fn to support returning custom explain-results, or add support for generic :explain key for keys, or something. Someone should write an issue out of this."><y>#</y><d>2022-01-20</d><h>11:39</h><r>ikitommi</r><code>m/explain</code> here doesn’t produce correct place of error, <del>could</del> should do it, we could tune either <code>:fn</code> to support returning custom explain-results, or add support for generic <code>:explain</code> key for keys, or something. Someone should write an issue out of this.</z><z id="t1642735531" t="Abhinav [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] thank you for your help. that was exactly what I was looking for."><y>#</y><d>2022-01-21</d><h>03:25</h><r>Abhinav</r><a>@U055NJ5CC</a> thank you for your help. that was exactly what I was looking for.</z><z id="t1642682243" t="rovanion I believe I&apos;m just being daft here but I haven&apos;t been able to figure this out for more than an hour so: How do I resolve a keyword to a schema in the registry? (def registry (atom {})) (defn register! [type ?schema] (swap! registry assoc type ?schema)) ;; Combine the default registry with our own mutable registry. (mreg/set-default-registry! (mreg/composite-registry (mreg/fast-registry (malli/default-schemas)) (mreg/mutable-registry registry))) (register! :db/kasse [:map [:id [:int {:primary-key true :db-generated true}]] [:odlingsplats [:string {:foreign-key &quot;odlingsplatser&quot;}]] [:diameter_m :int] [:djup_m :int] [:volym_m2 [:int {:db-generated true}]]]) (malli/walk :db/kasse (malli/schema-walker identity)) ;; =&gt; :db/kasse I&apos;ve tried wrapping :db/kasse in different functions from malli but none seem to do the lookup. The lookup function in the core namespace is private. Just running (:db/kasse malli/default-registry) does not work either. (malli/schema :db/kasse) seems like the obvious choice but it seemingly has no effect. (malli/walk (malli/schema :db/kasse) (malli/schema-walker identity)) ;; =&gt; :db/kasse "><y>#</y><d>2022-01-20</d><h>12:37</h><w>rovanion</w>I believe I&apos;m just being daft here but I haven&apos;t been able to figure this out for more than an hour so: How do I resolve a keyword to a schema in the registry?

<pre>(def registry
  (atom {}))

(defn register! [type ?schema]
  (swap! registry assoc type ?schema))

;; Combine the default registry with our own mutable registry.
(mreg/set-default-registry!
 (mreg/composite-registry
    (mreg/fast-registry (malli/default-schemas))
    (mreg/mutable-registry registry)))

(register! :db/kasse
   [:map
    [:id                            [:int {:primary-key true :db-generated true}]]
    [:odlingsplats                  [:string {:foreign-key &quot;odlingsplatser&quot;}]]
    [:diameter_m                    :int]
    [:djup_m                        :int]
    [:volym_m2                      [:int {:db-generated true}]]])

(malli/walk
 :db/kasse
 (malli/schema-walker identity))
;; =&gt; :db/kasse</pre>
I&apos;ve tried wrapping <code>:db/kasse</code> in different functions from malli but none seem to do the lookup. The lookup function in the core namespace is private. Just running <code>(:db/kasse malli/default-registry)</code> does not work either. <code>(malli/schema :db/kasse)</code> seems like the obvious choice but it seemingly has no effect.

<pre>(malli/walk
 (malli/schema :db/kasse)
 (malli/schema-walker identity))
;; =&gt; :db/kasse</pre>
</z><z id="t1642683536" t="ikitommi the :db/kasse returned is a Malli Schema instance, it’s print output is just the form, so looks like keyword. It’s type is :malli.core/schema , which is the internal eager reference, like a Var in Clojure. If you want to get the schema behind it, you can m/deref it. But, calling m/validate on :db/kasse works too. the :malli.core/schema forwards the calls to the actual instance, like Var . Hope this helps."><y>#</y><d>2022-01-20</d><h>12:58</h><r>ikitommi</r>the <code>:db/kasse</code> returned is a Malli Schema instance, it’s print output is just the form, so looks like keyword. It’s type is <code>:malli.core/schema</code>,  which is the internal eager reference, like a <code>Var</code> in Clojure. If you want to get the schema behind it, you can <code>m/deref</code> it. But, calling <code>m/validate</code> on <code>:db/kasse</code> works too. the <code>:malli.core/schema</code> forwards the calls to the actual instance, like <code>Var</code>. Hope this helps.</z><z id="t1642683573" t="ikitommi also, walking it just work, try something like (m/ast :db/kasse) to verify"><y>#</y><d>2022-01-20</d><h>12:59</h><r>ikitommi</r>also, walking it just work, try something like <code>(m/ast :db/kasse)</code> to verify</z><z id="t1642687090" t="rovanion Thank you, dereffing worked perfectly. Though I&apos;m not sure I understand the latter reply: (let [schema (malli/schema :db/kasse)] (prn (type schema)) (malli/walk schema (malli/schema-walker identity))) ;; =&gt; :db/kasse ;; printed: :malli.core/schema"><y>#</y><d>2022-01-20</d><h>13:58</h><r>rovanion</r>Thank you, dereffing worked perfectly. Though I&apos;m not sure I understand the latter reply:

<pre>(let [schema (malli/schema :db/kasse)]                                                                                
  (prn (type schema))                                                                                                 
  (malli/walk                                                                                                         
   schema                                                                                                             
   (malli/schema-walker identity))) 
;; =&gt; :db/kasse
;; printed: :malli.core/schema</pre></z><z id="t1642697357" t="mafcocinco hi all! Just started using malli and I have what I think is a pretty newbie question: Is there a way, in the context of a :map schema declaration to have mutually exclusive keys? That is “map should contain :a and :b together or :c by itself”."><y>#</y><d>2022-01-20</d><h>16:49</h><w>mafcocinco</w>hi all!  Just started using <code>malli</code> and I have what I think is a pretty newbie question:  Is there a way, in the context of a <code>:map</code> schema declaration to have mutually exclusive keys?  That is “map should contain <code>:a</code> and <code>:b</code> together or <code>:c</code> by itself”.</z><z id="t1642700393" t="Ben Sless Not atm, but it&apos;s an often requested feature"><y>#</y><d>2022-01-20</d><h>17:39</h><r>Ben Sless</r>Not atm, but it&apos;s an often requested feature</z><z id="t1642702875" t="jeroenvandijk Hi, I’ve been playing with the idea of using Malli as a way to define the main data model of an application. Many features are already in Malli I believe. One thing that might be missing is an easy way to generate consistent test and seed data. Maybe something like composite types are an useful addition? (register! :user/first-name [:enum &quot;john&quot; &quot;joe&quot; &quot;alex&quot;]) (register! :user/last-name [:enum &quot;smith&quot; &quot;wood&quot; &quot;lee&quot;]) (register! :user/full-name [:composite {:schema string? :compose (fn [first-name last-name] (str first-name &quot; &quot; last-name)) :fields [:user/first-name :user/last-name]}]) (register-entity! ::user [:user/first-name :user/last-name :user/full-name]) (generate ::user) ;; =&gt; #:user{:first-name &quot;joe&quot;, :last-name &quot;wood&quot;, :full-name &quot;joe wood&quot;} More here https://gist.github.com/jeroenvandijk/5e0785f25f7fdfeac7bc7a0be72cb62a#file-malli_composite_test-clj"><y>#</y><d>2022-01-20</d><h>18:21</h><w>jeroenvandijk</w>Hi, I’ve been playing with the idea of using Malli as a way to define the main data model of an application. Many features are already in Malli I believe. One thing that might be missing is an easy way to generate consistent test and seed data.  Maybe something like composite types are an useful addition?
<pre>(register! :user/first-name [:enum &quot;john&quot; &quot;joe&quot; &quot;alex&quot;])
(register! :user/last-name [:enum &quot;smith&quot; &quot;wood&quot; &quot;lee&quot;])

(register! :user/full-name
           [:composite {:schema string?
                        :compose (fn [first-name last-name]
                                   (str first-name &quot; &quot; last-name))
                        :fields [:user/first-name :user/last-name]}])

(register-entity! ::user
                  [:user/first-name
                   :user/last-name
                   :user/full-name])

(generate ::user)
;; =&gt; #:user{:first-name &quot;joe&quot;, :last-name &quot;wood&quot;, :full-name &quot;joe wood&quot;}</pre>
More here <a href="https://gist.github.com/jeroenvandijk/5e0785f25f7fdfeac7bc7a0be72cb62a#file-malli_composite_test-clj" target="_blank">https://gist.github.com/jeroenvandijk/5e0785f25f7fdfeac7bc7a0be72cb62a#file-malli_composite_test-clj</a></z><z id="t1642707587" t="Ben Sless Did you just implement unification?"><y>#</y><d>2022-01-20</d><h>19:39</h><r>Ben Sless</r>Did you just implement unification?</z><z id="t1642708566" t="jeroenvandijk Not consciously 😅 Maybe accidentally? I was just thinking how do I get meaningful seed and test data when I’m just defining my attributes and entities"><y>#</y><d>2022-01-20</d><h>19:56</h><r>jeroenvandijk</r>Not consciously <b>😅</b> Maybe accidentally? I was just thinking how do I get meaningful seed and test data when I’m just defining my attributes and entities</z><z id="t1642709383" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I see you did some work on unification yourself ( https://github.com/metosin/malli/issues/474 and https://github.com/bsless/malli-keys-relations ). My approach is not that advanced (or complete)"><y>#</y><d>2022-01-20</d><h>20:09</h><r>jeroenvandijk</r><a>@UK0810AQ2</a> I see you did some work on unification yourself (<a href="https://github.com/metosin/malli/issues/474" target="_blank">https://github.com/metosin/malli/issues/474</a> and <a href="https://github.com/bsless/malli-keys-relations" target="_blank">https://github.com/bsless/malli-keys-relations</a>). My approach is not that advanced (or complete)</z><z id="t1642709689" t="Ben Sless It&apos;s okay, my approach sucked anyway I&apos;m becoming convinced the only solution is embedding micro kanren and I&apos;m scared"><y>#</y><d>2022-01-20</d><h>20:14</h><r>Ben Sless</r>It&apos;s okay, my approach sucked anyway
I&apos;m becoming convinced the only solution is embedding micro kanren and I&apos;m scared</z><z id="t1642710070" t="jeroenvandijk Haha I can imagine"><y>#</y><d>2022-01-20</d><h>20:21</h><r>jeroenvandijk</r>Haha I can imagine</z><z id="t1642762012" t="Karol Wójcik Does malli supports inline schemas in map destructuring syntax in defn? e.g., (mx/defn kikka [{:keys [ hello :- :string world :- :string ]}] (println hello world))"><y>#</y><d>2022-01-21</d><h>10:46</h><w>Karol Wójcik</w>Does malli supports inline schemas in map destructuring syntax in defn? e.g.,

<pre>(mx/defn kikka 
  [{:keys [
     hello :- :string
     world :- :string
  ]}]
  (println hello world))</pre></z><z id="t1642762091" t="Karol Wójcik It looks like not. :schema [:=&gt; [:cat [:altn [:map [:map [:hello {:optional true} :any] [:- {:optional true} :any] [:string {:optional true} :any] [:world {:optional true} :any]]] [:args [:schema [:* [:alt [:cat [:= :hello] :any] [:cat [:= :-] :any] [:cat [:= :string] :any] [:cat [:= :world] :any] [:cat :any :any]]]]]]] :any],"><y>#</y><d>2022-01-21</d><h>10:48</h><r>Karol Wójcik</r>It looks like not.
<pre>:schema
 [:=&gt;
  [:cat
   [:altn
    [:map
     [:map
      [:hello {:optional true} :any]
      [:- {:optional true} :any]
      [:string {:optional true} :any]
      [:world {:optional true} :any]]]
    [:args
     [:schema
      [:*
       [:alt
        [:cat [:= :hello] :any]
        [:cat [:= :-] :any]
        [:cat [:= :string] :any]
        [:cat [:= :world] :any]
        [:cat :any :any]]]]]]]
  :any],</pre></z><z id="t1642770379" t="ikitommi didn’t add that as the current support is “plain plumatic”."><y>#</y><d>2022-01-21</d><h>13:06</h><r>ikitommi</r>didn’t add that as the current support is “plain plumatic”.</z><z id="t1642770409" t="ikitommi but, plumatic doesn’t support different returns from arities, so we should extend it anyway"><y>#</y><d>2022-01-21</d><h>13:06</h><r>ikitommi</r>but, plumatic doesn’t support different returns from arities, so we should extend it anyway</z><z id="t1642770439" t="ikitommi but, if that is supported, one can’t have a key named - , right?"><y>#</y><d>2022-01-21</d><h>13:07</h><r>ikitommi</r>but, if that is supported, one can’t have a key named <code>-</code>, right?</z><z id="t1642770860" t="ikitommi (let [{:keys [a :- :int]} {:a 1, :- 2, :int 3}] [a - int]) ; =&gt; [1 2 3]"><y>#</y><d>2022-01-21</d><h>13:14</h><r>ikitommi</r><pre>(let [{:keys [a :- :int]} {:a 1, :- 2, :int 3}] [a - int]) 
; =&gt; [1 2 3]</pre></z><z id="t1642770964" t="ikitommi so, don’t think it’s a good idea to support it, what do you think?"><y>#</y><d>2022-01-21</d><h>13:16</h><r>ikitommi</r>so, don’t think it’s a good idea to support it, what do you think?</z><z id="t1642783438" t="Karol Wójcik Right. After consideration I also think the syntax where the schema is specified in keys destructuring, is pretty hard to understand. "><y>#</y><d>2022-01-21</d><h>16:43</h><r>Karol Wójcik</r>Right. After consideration I also think the syntax where the schema is specified in keys destructuring, is pretty hard to understand. </z><z id="t1642819759" t="jkrasnay Is there a way to get function instrumentation working in CLJS? There seems to be some stuff in malli.instrument.cljs but my CLJS build complains that that ns is not available."><y>#</y><d>2022-01-22</d><h>02:49</h><w>jkrasnay</w>Is there a way to get function instrumentation working in CLJS? There seems to be some stuff in <code>malli.instrument.cljs</code> but my CLJS build complains that that ns is not available.</z><z id="t1642836628" t="ikitommi Haven’t used that myself, but the tests pass. Are you depending on the latest version from master? It’s not released yet"><y>#</y><d>2022-01-22</d><h>07:30</h><r>ikitommi</r>Haven’t used that myself, but the tests pass. Are you depending on the latest version from master? It’s not released yet</z><z id="t1642864954" t="jkrasnay Oh, I was on 0.7.5 . Thanks!"><y>#</y><d>2022-01-22</d><h>15:22</h><r>jkrasnay</r>Oh, I was on <code>0.7.5</code>. Thanks!</z><z id="t1642882773" t="dvingo [:attrs {:href &quot;/_/_/users/U0DTSCAUU&quot;}] feel free to ping me if you run into any issues!"><y>#</y><d>2022-01-22</d><h>20:19</h><r>dvingo</r><a>@U0DTSCAUU</a> feel free to ping me if you run into any issues!</z><z id="t1642836651" t="ikitommi added .pretty/explain"><y>#</y><d>2022-01-22</d><h>07:30</h><w>ikitommi</w>added <code>.pretty/explain</code></z><z id="t1642850548" t="ikitommi from cursive"><y>#</y><d>2022-01-22</d><h>11:22</h><r>ikitommi</r>from cursive</z><z id="t1642850499" t="ikitommi pushed all current stuff for leiningen users as`[metosin/malli &quot;0.8.0-SNAPSHOT&quot;]`"><y>#</y><d>2022-01-22</d><h>11:21</h><w>ikitommi</w>pushed all current stuff for leiningen users as`[metosin/malli &quot;0.8.0-SNAPSHOT&quot;]`</z><z id="t1642858604" t="Karol Wójcik [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] FYI: The CLJ Kondo config has unbalanced bracket 🧵"><y>#</y><d>2022-01-22</d><h>13:36</h><w>Karol Wójcik</w><a>@ikitommi</a> FYI: The CLJ Kondo config has unbalanced bracket <b>🧵</b></z><z id="t1642858618" t="Karol Wójcik A PR with issue fixed https://github.com/metosin/malli/pull/625"><y>#</y><d>2022-01-22</d><h>13:36</h><r>Karol Wójcik</r>A PR with issue fixed <a href="https://github.com/metosin/malli/pull/625" target="_blank">https://github.com/metosin/malli/pull/625</a></z><z id="t1642861971" t="ikitommi Thanks! Merged"><y>#</y><d>2022-01-22</d><h>14:32</h><r>ikitommi</r>Thanks! Merged</z><z id="t1642865336" t="jkrasnay I’m having a problem with instrumenting my functions. I define a function in namespace A and register it with Malli as follows: (m/=&gt; selectable-label [:=&gt; [:cat [:map [:build map?] [:selectable-id id/SelectableId]]] locale/LocalizableString]) Then in namespace B I call (mi/instrument!) This triggers errors when compiling namespace B that namespaces id and locale are not found. These are aliases from the :require block in namespace A. Is there any way around this?"><y>#</y><d>2022-01-22</d><h>15:28</h><w>jkrasnay</w>I’m having a problem with instrumenting my functions. I define a function in namespace A and register it with Malli as follows:
<pre>(m/=&gt; selectable-label [:=&gt; [:cat [:map
                                   [:build map?]
                                   [:selectable-id id/SelectableId]]]
                        locale/LocalizableString])</pre>
Then in namespace B I call
<pre>(mi/instrument!)</pre>
This triggers errors when compiling namespace B that namespaces <code>id</code> and <code>locale</code> are not found. These are aliases from the <code>:require</code> block in namespace A. Is there any way around this?</z><z id="t1642866153" t="jkrasnay BTW namespace A is cljc while namespace B is cljs."><y>#</y><d>2022-01-22</d><h>15:42</h><w>jkrasnay</w>BTW namespace A is cljc while namespace B is cljs.</z><z id="t1642866417" t="jkrasnay It works if I fully qualify id and locale ."><y>#</y><d>2022-01-22</d><h>15:46</h><w>jkrasnay</w>It works if I fully qualify <code>id</code> and <code>locale</code>.</z><z id="t1642868766" t="jkrasnay I think this may be one of those subtle things about CLJS macros, where we can’t qualify the namespace since the macro is running in CLJ."><y>#</y><d>2022-01-22</d><h>16:26</h><w>jkrasnay</w>I think this may be one of those subtle things about CLJS macros, where we can’t qualify the namespace since the macro is running in CLJ.</z><z id="t1642870735" t="Игорь Лисовцов Hi there guys. I&apos;m new to clojure and especially to malli. So, I&apos;m playing around repl and malli, and notices that below example from the documentation doesn&apos;t work (m/decode [string? {:decode {:string &apos;str/upper-case}}] &quot;kerran&quot; mt/string-transformer) ; =&gt; &quot;KERRAN&quot; and instead of &quot;KERRAN&quot; it returns &quot;kerran&quot;. Func at the place {:string func simply not called. Did I do something wrong?"><y>#</y><d>2022-01-22</d><h>16:58</h><w>Игорь Лисовцов</w>Hi there guys. I&apos;m new to clojure and especially to malli.
So, I&apos;m playing around repl and malli, and notices that below example from the documentation doesn&apos;t work
<pre>(m/decode
  [string? {:decode {:string &apos;str/upper-case}}]
  &quot;kerran&quot; mt/string-transformer)
; =&gt; &quot;KERRAN&quot;</pre>
and instead of &quot;KERRAN&quot; it returns &quot;kerran&quot;. Func at the place <code>{:string func</code> simply not called.

Did I do something wrong?</z><z id="t1642871528" t="ikitommi The docs for this part are ahead of the release, plan is to release 0.8.0 n the next few days. If you know how to depend on the latest commit of malli, you can test that too."><y>#</y><d>2022-01-22</d><h>17:12</h><r>ikitommi</r>The docs for this part are ahead of the release, plan is to release 0.8.0 n the next few days. If you know how to depend on the latest commit of malli, you can test that too.</z><z id="t1642871906" t="Игорь Лисовцов Got it. Thank you a lot!"><y>#</y><d>2022-01-22</d><h>17:18</h><r>Игорь Лисовцов</r>Got it. Thank you a lot!</z><z id="t1642928213" t="pithyless I feel I&apos;m missing something obvious; if I&apos;ve got a [:map [:name :string] [:age :int]] schema, what&apos;s the best way to get back the coll of keys [:name :age] ?"><y>#</y><d>2022-01-23</d><h>08:56</h><w>pithyless</w>I feel I&apos;m missing something obvious; if I&apos;ve got a <code>[:map [:name :string] [:age :int]]</code> schema, what&apos;s the best way to get back the coll of keys <code>[:name :age]</code>?</z><z id="t1642929987" t="pithyless Looking at the transformers, I guess it would be: (some-&gt;&gt; schema m/entries (map first) seq)"><y>#</y><d>2022-01-23</d><h>09:26</h><r>pithyless</r>Looking at the transformers, I guess it would be:
<pre>(some-&gt;&gt; schema m/entries (map first) seq)</pre></z><z id="t1642939510" t="ikitommi yes, that&apos;s it."><y>#</y><d>2022-01-23</d><h>12:05</h><r>ikitommi</r>yes, that&apos;s it.</z><z id="t1642953839" t="ikitommi 🥳"><y>#</y><d>2022-01-23</d><h>16:03</h><w>ikitommi</w><b>🥳</b></z><z id="t1643063003" t="lsenjov This is the real Christmas present I’ve been waiting on 🥳"><y>#</y><d>2022-01-24</d><h>22:23</h><r>lsenjov</r>This is the real Christmas present I’ve been waiting on <b>🥳</b></z><z id="t1643506778" t="Grant Horner This is awesome! I never used schema, and I&apos;m loving the new malli.experimental/defn . How do you make it play nicely with Cursive? I&apos;ve been unable configure the cursive resolution to get rid of all the yellow squigglies"><y>#</y><d>2022-01-30</d><h>01:39</h><r>Grant Horner</r>This is awesome! I never used schema, and I&apos;m loving the new <code>malli.experimental/defn</code>. How do you make it play nicely with Cursive? I&apos;ve been unable configure the cursive resolution to get rid of all the yellow squigglies</z><z id="t1643527332" t="ikitommi thanks! You should mark it to be resolved as schrma.core/defn . And go vote up https://github.com/cursive-ide/cursive/issues/2645"><y>#</y><d>2022-01-30</d><h>07:22</h><r>ikitommi</r>thanks! You should mark it to be resolved as <code>schrma.core/defn</code>. And go vote up <a href="https://github.com/cursive-ide/cursive/issues/2645" target="_blank">https://github.com/cursive-ide/cursive/issues/2645</a></z><z id="t1643313351" t="NoahTheDuke I have a map that contains function values, but I want to use a Var (`#&apos;function-name`) to facilitate repl-driven development, however fn? doesn’t consider the Var a function and malli doesn’t recognize var? as a schema function"><y>#</y><d>2022-01-27</d><h>19:55</h><w>NoahTheDuke</w>I have a map that contains function values, but I want to use a Var (`#&apos;function-name`) to facilitate repl-driven development, however <code>fn?</code> doesn’t consider the Var a function and malli doesn’t recognize <code>var?</code> as a schema function</z><z id="t1643314496" t="Ben Sless You want to validate the map itself?"><y>#</y><d>2022-01-27</d><h>20:14</h><r>Ben Sless</r>You want to validate the map itself?</z><z id="t1643314545" t="NoahTheDuke I have the validation for the map, but i’m realizing I need to be able to say [:or fn? var?] instead of just fn?"><y>#</y><d>2022-01-27</d><h>20:15</h><r>NoahTheDuke</r>I have the validation for the map, but i’m realizing I need to be able to say <code>[:or fn? var?]</code> instead of just <code>fn?</code></z><z id="t1643314558" t="Ben Sless You can use a decoder"><y>#</y><d>2022-01-27</d><h>20:15</h><r>Ben Sless</r>You can use a decoder</z><z id="t1643314570" t="Ben Sless And deref the values :)"><y>#</y><d>2022-01-27</d><h>20:16</h><r>Ben Sless</r>And deref the values :)</z><z id="t1643314634" t="Ben Sless I.e. [:map [:k [fn? {:decode/var deref}]]]"><y>#</y><d>2022-01-27</d><h>20:17</h><r>Ben Sless</r>I.e. [:map [:k [fn? {:decode/var deref}]]]</z><z id="t1643314638" t="Ben Sless Approximately"><y>#</y><d>2022-01-27</d><h>20:17</h><r>Ben Sless</r>Approximately</z><z id="t1643314673" t="NoahTheDuke huh interesting. i’ll give that a shot! thanks"><y>#</y><d>2022-01-27</d><h>20:17</h><r>NoahTheDuke</r>huh interesting. i’ll give that a shot! thanks</z><z id="t1643314744" t="Ben Sless Cheers. Make sure to wrap that deref in a try catch"><y>#</y><d>2022-01-27</d><h>20:19</h><r>Ben Sless</r>Cheers. Make sure to wrap that deref in a try catch</z><z id="t1643314799" t="Ben Sless But, why are you validating a map of functions? Especially w/o function schema it isn&apos;t very informative, is it?"><y>#</y><d>2022-01-27</d><h>20:19</h><r>Ben Sless</r>But, why are you validating a map of functions? Especially w/o function schema it isn&apos;t very informative, is it?</z><z id="t1643652454" t="NoahTheDuke just barebones checking that i’m creating the right types, not doing much more than that to start"><y>#</y><d>2022-01-31</d><h>18:07</h><r>NoahTheDuke</r>just barebones checking that i’m creating the right types, not doing much more than that to start</z><z id="t1643313367" t="NoahTheDuke any way to handle this?"><y>#</y><d>2022-01-27</d><h>19:56</h><w>NoahTheDuke</w>any way to handle this?</z><z id="t1643651710" t="Brett Rowberry when inferring malli schemas from data, I can tell it how to handle strings as uuids, for example, as shown here https://github.com/metosin/malli/pull/597 some string values may be inst or other types - is there a way to have it handle those as well?"><y>#</y><d>2022-01-31</d><h>17:55</h><w>Brett Rowberry</w>when inferring malli schemas from data, I can tell it how to handle strings as uuids, for example, as shown here
<a href="https://github.com/metosin/malli/pull/597" target="_blank">https://github.com/metosin/malli/pull/597</a>
some string values may be inst or other types - is there a way to have it handle those as well?</z><z id="t1643652953" t="ikitommi sure, anything you can present transformers works here. Check how inst? is handled in malli.transform"><y>#</y><d>2022-01-31</d><h>18:15</h><r>ikitommi</r>sure, anything you can present transformers works here. Check how <code>inst?</code> is handled in <code>malli.transform</code></z><z id="t1643656561" t="ikitommi https://github.com/metosin/malli/pull/632"><y>#</y><d>2022-01-31</d><h>19:16</h><r>ikitommi</r><a href="https://github.com/metosin/malli/pull/632" target="_blank">https://github.com/metosin/malli/pull/632</a></z><z id="t1643737992" t="Brett Rowberry sorry, I should have given a better example (require &apos;[malli.provider :as mp]) (require &apos;[malli.transform :as mt]) (mp/provide [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot; :my-inst &quot;2021-01-01T00:00:00Z&quot;}] {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid}}}) ;; can I treat :my-uuid as a uuid and :my-inst as an inst?"><y>#</y><d>2022-02-01</d><h>17:53</h><r>Brett Rowberry</r>sorry, I should have given a better example
<pre>(require &apos;[malli.provider :as mp])
(require &apos;[malli.transform :as mt])

(mp/provide
 [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;
   :my-inst &quot;2021-01-01T00:00:00Z&quot;}]
 {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid}}})
;; can I treat :my-uuid as a uuid and :my-inst as an inst?</pre></z><z id="t1643741701" t="ikitommi with master: (require &apos;[malli.provider :as mp]) (require &apos;[malli.transform :as mt]) (mp/provide [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot; :my-inst &quot;2021-01-01T00:00:00Z&quot;}] {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid &apos;inst? mt/-string-&gt;date}}}) ; =&gt; [:map [:my-uuid :uuid] [:my-inst inst?]]"><y>#</y><d>2022-02-01</d><h>18:55</h><r>ikitommi</r>with master:
<pre>(require &apos;[malli.provider :as mp])
(require &apos;[malli.transform :as mt])

(mp/provide
 [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;
   :my-inst &quot;2021-01-01T00:00:00Z&quot;}]
 {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid
                                 &apos;inst? mt/-string-&gt;date}}})
; =&gt; [:map [:my-uuid :uuid] [:my-inst inst?]]</pre></z><z id="t1643751972" t="Brett Rowberry thank you!"><y>#</y><d>2022-02-01</d><h>21:46</h><r>Brett Rowberry</r>thank you!</z><z id="t1643756439" t="Brett Rowberry so this would be after 0.8.0"><y>#</y><d>2022-02-01</d><h>23:00</h><r>Brett Rowberry</r>so this would be after 0.8.0</z><z id="t1643787697" t="ikitommi if you use deps, you can depend on the lastest commit on master to try this out. for leiningen - in the next release."><y>#</y><d>2022-02-02</d><h>07:41</h><r>ikitommi</r>if you use deps, you can depend on the lastest commit on master to try this out. for leiningen - in the next release.</z><z id="t1643811090" t="Brett Rowberry we&apos;re using some custom bazel thing, so I&apos;ll have to wait for the jar. thank you so much for this feature! type providers were so awesome in F# - I really appreciate having something similar in Clojure!"><y>#</y><d>2022-02-02</d><h>14:11</h><r>Brett Rowberry</r>we&apos;re using some custom bazel thing, so I&apos;ll have to wait for the jar. thank you so much for this feature! type providers were so awesome in F# - I really appreciate having something similar in Clojure!</z><z id="t1644066097" t="ikitommi [metosin/malli &quot;0.8.1&quot;]"><y>#</y><d>2022-02-05</d><h>13:01</h><r>ikitommi</r><code>[metosin/malli &quot;0.8.1&quot;]</code></z><z id="t1644066114" t="ikitommi and good to hear, it is useful 🙂"><y>#</y><d>2022-02-05</d><h>13:01</h><r>ikitommi</r>and good to hear, it is useful <b>🙂</b></z><z id="t1643741701" t="ikitommi with master: (require &apos;[malli.provider :as mp]) (require &apos;[malli.transform :as mt]) (mp/provide [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot; :my-inst &quot;2021-01-01T00:00:00Z&quot;}] {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid &apos;inst? mt/-string-&gt;date}}}) ; =&gt; [:map [:my-uuid :uuid] [:my-inst inst?]]"><y>#</y><d>2022-02-01</d><h>18:55</h><w>ikitommi</w>with master:
<pre>(require &apos;[malli.provider :as mp])
(require &apos;[malli.transform :as mt])

(mp/provide
 [{:my-uuid &quot;caa71a26-5fe1-11ec-bf63-0242ac130002&quot;
   :my-inst &quot;2021-01-01T00:00:00Z&quot;}]
 {::mp/value-decoders {&apos;string? {:uuid mt/-string-&gt;uuid
                                 &apos;inst? mt/-string-&gt;date}}})
; =&gt; [:map [:my-uuid :uuid] [:my-inst inst?]]</pre></z><z id="t1643737813" t="Grant Horner Is there a way to truncate the output of the pretty reporter? I’m getting occasional reports for functions that take in vectors of 10,000+ elements and the output is absolutely crushing my poor intellij repl"><y>#</y><d>2022-02-01</d><h>17:50</h><w>Grant Horner</w>Is there a way to truncate the output of the pretty reporter? I’m getting occasional reports for functions that take in vectors of 10,000+ elements and the output is absolutely crushing my poor intellij repl</z><z id="t1643741628" t="ikitommi looking at fipp docs, try setting clojure.core/*print-length* &amp; clojure.core/*print-level* , https://github.com/brandonbloom/fipp#printer-usage ."><y>#</y><d>2022-02-01</d><h>18:53</h><r>ikitommi</r>looking at fipp docs, try setting <code>clojure.core/*print-length*</code> &amp; <code>clojure.core/*print-level*</code>, <a href="https://github.com/brandonbloom/fipp#printer-usage" target="_blank">https://github.com/brandonbloom/fipp#printer-usage</a>.</z><z id="t1643741639" t="ikitommi if that works, doc PR to malli welcome"><y>#</y><d>2022-02-01</d><h>18:53</h><r>ikitommi</r>if that works, doc PR to malli welcome</z><z id="t1643822632" t="Grant Horner Just did! I appreciate the quick response, I could’ve figured it out if I had read the documentation more in-depthly :face_palm:"><y>#</y><d>2022-02-02</d><h>17:23</h><r>Grant Horner</r>Just did! I appreciate the quick response, I could’ve figured it out if I had read the documentation more in-depthly <b>:face_palm:</b></z><z id="t1643822830" t="ikitommi Thanks! Merged"><y>#</y><d>2022-02-02</d><h>17:27</h><r>ikitommi</r>Thanks! Merged</z><z id="t1643898728" t="lread Just noticed this in my vid feed: https://youtu.be/mNpE7cPm-N8"><y>#</y><d>2022-02-03</d><h>14:32</h><w>lread</w>Just noticed this in my vid feed: <a href="https://youtu.be/mNpE7cPm-N8" target="_blank">https://youtu.be/mNpE7cPm-N8</a></z><z id="t1643965055" t="Jacques Is it possible to use registry references for function schema input parameters? Is there an example somewhere to see how this might work?"><y>#</y><d>2022-02-04</d><h>08:57</h><w>Jacques</w>Is it possible to use registry references for function schema input parameters? Is there an example somewhere to see how this might work?</z><z id="t1644066980" t="ikitommi [:attrs {:href &quot;/_/_/users/UT0PK4UVD&quot;}] maybe: (require &apos;[malli.core :as m]) (require &apos;[malli.registry :as mr]) (mr/set-default-registry! (mr/composite-registry (m/default-schemas) {::user-id :int ::user [:map ::user-id [:name :string] [:age :int]]})) (require &apos;[malli.experimental :as mx]) (require &apos;[malli.generator :as mg]) (mx/defn get-user :- ::user [id :- ::user-id] (assoc (mg/generate ::user) ::user-id id)) (get-user 123) ; =&gt; {:kikka/user-id 123, :name &quot;8p28ySz&quot;, :age 2405534}"><y>#</y><d>2022-02-05</d><h>13:16</h><w>ikitommi</w><a>@jacquesdpz</a> maybe:
<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.registry :as mr])

(mr/set-default-registry!
 (mr/composite-registry
  (m/default-schemas)
  {::user-id :int
   ::user [:map
           ::user-id
           [:name :string]
           [:age :int]]}))

(require &apos;[malli.experimental :as mx])
(require &apos;[malli.generator :as mg])

(mx/defn get-user :- ::user [id :- ::user-id]
  (assoc (mg/generate ::user) ::user-id id))

(get-user 123)
; =&gt; {:kikka/user-id 123, :name &quot;8p28ySz&quot;, :age 2405534}</pre></z><z id="t1644225181" t="Jacques thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2022-02-07</d><h>09:13</h><r>Jacques</r>thank you <a>@U055NJ5CC</a></z><z id="t1644121384" t="pinkfrog Is it possible to specify the :min/:max attributes for regular expressions (instead of doing it inside the re pattern)?"><y>#</y><d>2022-02-06</d><h>04:23</h><w>pinkfrog</w>Is it possible to specify the :min/:max attributes for regular expressions (instead of doing it inside the re pattern)?</z><z id="t1644134406" t="ikitommi no. Regal ( https://github.com/lambdaisland/regal ) has malli-support, but not sure it&apos;s up-to-date with the latest version."><y>#</y><d>2022-02-06</d><h>08:00</h><r>ikitommi</r>no. Regal (<a href="https://github.com/lambdaisland/regal" target="_blank">https://github.com/lambdaisland/regal</a>) has malli-support, but not sure it&apos;s up-to-date with the latest version.</z><z id="t1644245064" t="Ben Sless Where does it make sense in your opinion to specify keywords renaming for a transformer? in a map schema&apos;s property or on its entry?"><y>#</y><d>2022-02-07</d><h>14:44</h><w>Ben Sless</w>Where does it make sense in your opinion to specify keywords renaming for a transformer? in a map schema&apos;s property or on its entry?</z><z id="t1644245110" t="Ben Sless [:map {:rename {:a :b}} [:b int?]] vs [:map [:b {:rename :a} int?]]"><y>#</y><d>2022-02-07</d><h>14:45</h><w>Ben Sless</w><code>[:map {:rename {:a :b}} [:b int?]]</code> vs <code>[:map [:b {:rename :a} int?]]</code></z><z id="t1644252005" t="ikitommi My intuition says it belongs to the map. But I guess, it depends. Being part of the entry-tuple, you could for example merge two maps with mapping to same domain and the mappings would be merged automatically"><y>#</y><d>2022-02-07</d><h>16:40</h><r>ikitommi</r>My intuition says it belongs to the map. But I guess, it depends. Being part of the entry-tuple, you could for example merge two maps with mapping to same domain and the mappings would be merged automatically</z><z id="t1644252094" t="ikitommi e.g. [:merge [:map [:a {:rename/SAP &quot;SAP_A&quot;, :rename/SALESFORCE &quot;sf_a&quot;} int?]] [:map [:b {:rename/SAP &quot;SAP_B&quot;} int?]]]"><y>#</y><d>2022-02-07</d><h>16:41</h><r>ikitommi</r>e.g.
<pre>[:merge
 [:map [:a {:rename/SAP &quot;SAP_A&quot;, :rename/SALESFORCE &quot;sf_a&quot;} int?]]
 [:map [:b {:rename/SAP &quot;SAP_B&quot;} int?]]]</pre></z><z id="t1644252173" t="ikitommi not actually sure if the entry properties get merged correctly here, just guessing 🙂"><y>#</y><d>2022-02-07</d><h>16:42</h><r>ikitommi</r>not actually sure if the entry properties get merged correctly here, just guessing <b>🙂</b></z><z id="t1644256457" t="Ben Sless Followup harder question - if I rename in decode it reports error on the wrong key path!"><y>#</y><d>2022-02-07</d><h>17:54</h><r>Ben Sless</r>Followup harder question - if I rename in decode it reports error on the wrong key path!</z><z id="t1644256475" t="Ben Sless I dug myself a deeper hole than expected 😄"><y>#</y><d>2022-02-07</d><h>17:54</h><r>Ben Sless</r>I dug myself a deeper hole than expected <b>😄</b></z><z id="t1644256482" t="Ben Sless How do I get out?"><y>#</y><d>2022-02-07</d><h>17:54</h><r>Ben Sless</r>How do I get out?</z><z id="t1644301642" t="Ben Sless The only way I see around it is attaching as metadata the rename mappings and encode the error report on response"><y>#</y><d>2022-02-08</d><h>06:27</h><r>Ben Sless</r>The only way I see around it is attaching as metadata the rename mappings and encode the error report on response</z><z id="t1644343267" t="Ben Sless Bump / help?"><y>#</y><d>2022-02-08</d><h>18:01</h><r>Ben Sless</r>Bump / help?</z><z id="t1644346811" t="ikitommi could you gist a minimal case, I can try to figure out howto"><y>#</y><d>2022-02-08</d><h>19:00</h><r>ikitommi</r>could you gist a minimal case, I can try to figure out howto</z><z id="t1644347106" t="Ben Sless Sure, I&apos;ll send it over later today / tomorrow morning"><y>#</y><d>2022-02-08</d><h>19:05</h><r>Ben Sless</r>Sure, I&apos;ll send it over later today / tomorrow morning</z><z id="t1644397515" t="Ben Sless (defn key-renamer &quot;Take a tuple of keys [`k1` `k2`] and return a function of a map `m` which will replace `k1` with `k2` if it exists in `m`&quot; [[k1 k2]] (fn -rename [m] (if-let [[_ v] (find m k1)] (dissoc (assoc m k2 v) k1) m))) (defn- -compile-rename-keys-transformer &quot;Takes a map of keys-&gt;keys and returns a function which will rename the keys in LHS to RHS if they exist in a map.&quot; [m] (if (seq m) (reduce comp (map key-renamer m)) identity)) (def rename-keys-transformer (mt/transformer {:decoders {:map {:compile (fn [schema _] (-&gt; schema m/properties :rename -compile-rename-keys-transformer))}}})) (comment (m/decode [:map {:rename {:a :b :c :d :x :y}} [:b int?] [:c int?] [:y int?]] {:a 1 :c 2 :x 3} (mt/transformer rename-keys-transformer))) Given that an input is incorrect post transformation, how do I report the original field name as invalid?"><y>#</y><d>2022-02-09</d><h>09:05</h><r>Ben Sless</r><pre>(defn key-renamer
  &quot;Take a tuple of keys [`k1` `k2`] and return a function of a map `m`
  which will replace `k1` with `k2` if it exists in `m`&quot;
  [[k1 k2]]
  (fn -rename [m]
    (if-let [[_ v] (find m k1)]
      (dissoc (assoc m k2 v) k1)
      m)))

(defn- -compile-rename-keys-transformer
  &quot;Takes a map of keys-&gt;keys and returns a function which will rename the
  keys in LHS to RHS if they exist in a map.&quot;
  [m]
  (if (seq m)
    (reduce comp (map key-renamer m))
    identity))

(def rename-keys-transformer
  (mt/transformer
   {:decoders
    {:map
     {:compile
      (fn [schema _]
        (-&gt; schema m/properties :rename -compile-rename-keys-transformer))}}}))

(comment
  (m/decode
   [:map
    {:rename {:a :b :c :d :x :y}}
    [:b int?]
    [:c int?]
    [:y int?]]
   {:a 1
    :c 2
    :x 3}
   (mt/transformer rename-keys-transformer)))
</pre>
Given that an input is incorrect post transformation, how do I report the original field name as invalid?</z><z id="t1644397527" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2022-02-09</d><h>09:05</h><r>Ben Sless</r><a>@U055NJ5CC</a></z><z id="t1644573929" t="ikitommi had time to look at this. Thing is, you should describe the resulting schema, not the orginal."><y>#</y><d>2022-02-11</d><h>10:05</h><r>ikitommi</r>had time to look at this. Thing is, you should describe the resulting schema, not the orginal.</z><z id="t1644573997" t="ikitommi so, it should be: [:map {:rename {:a :b, :c :d, :x :y}} [:b int?] [:d int?] [:y int?]]"><y>#</y><d>2022-02-11</d><h>10:06</h><r>ikitommi</r>so, it should be:
<pre>[:map 
 {:rename {:a :b, :c :d, :x :y}}
 [:b int?]
 [:d int?]
 [:y int?]]</pre></z><z id="t1644574061" t="Ben Sless The problem is that schemas, being a description of &quot;ought&quot;, can&apos;t report back errors about &quot;is&quot; for any lossy transformation"><y>#</y><d>2022-02-11</d><h>10:07</h><r>Ben Sless</r>The problem is that schemas, being a description of &quot;ought&quot;, can&apos;t report back errors about &quot;is&quot; for any lossy transformation</z><z id="t1644574132" t="Ben Sless I had a typo in the last entry which I can spot now"><y>#</y><d>2022-02-11</d><h>10:08</h><r>Ben Sless</r>I had a typo in the last entry which I can spot now</z><z id="t1644574212" t="Ben Sless Anyway, schema validates b, user gave me a, I want to report back &quot;a should be an integer&quot; if I was given a, even thought I treat it as b. Some sort of alias mechanism"><y>#</y><d>2022-02-11</d><h>10:10</h><r>Ben Sless</r>Anyway, schema validates b, user gave me a, I want to report back &quot;a should be an integer&quot; if I was given a, even thought I treat it as b.
Some sort of alias mechanism</z><z id="t1644574231" t="ikitommi ok, that :thinking_face:"><y>#</y><d>2022-02-11</d><h>10:10</h><r>ikitommi</r>ok, that <b>:thinking_face:</b></z><z id="t1644574278" t="ikitommi what if the rename-map is used to create the target (or source) schema?"><y>#</y><d>2022-02-11</d><h>10:11</h><r>ikitommi</r>what if the rename-map is used to create the target (or source) schema?</z><z id="t1644574281" t="ikitommi e.g. transform keys."><y>#</y><d>2022-02-11</d><h>10:11</h><r>ikitommi</r>e.g. transform keys.</z><z id="t1644574297" t="ikitommi then, you could validate them separately."><y>#</y><d>2022-02-11</d><h>10:11</h><r>ikitommi</r>then, you could validate them separately.</z><z id="t1644574714" t="ikitommi (def Target (m/schema [:map [:b int?] [:d int?] [:y int?]])) (def mappings {:b :a, :d :c, :y :x}) (def Source (mu/transform-entries Target (partial map (fn [[k p v]] [(mappings k k) p v])))) Source ; =&gt; [:map [:a int?] [:c int?] [:x int?]]"><y>#</y><d>2022-02-11</d><h>10:18</h><r>ikitommi</r><pre>(def Target
  (m/schema
   [:map
    [:b int?]
    [:d int?]
    [:y int?]]))

(def mappings {:b :a, :d :c, :y :x})

(def Source
  (mu/transform-entries 
   Target 
   (partial map (fn [[k p v]] [(mappings k k) p v]))))

Source
; =&gt; [:map [:a int?] [:c int?] [:x int?]]</pre></z><z id="t1644574747" t="ikitommi something like that, explicit schemas for both Source and Target."><y>#</y><d>2022-02-11</d><h>10:19</h><r>ikitommi</r>something like that, explicit schemas for both Source and Target.</z><z id="t1644574810" t="ikitommi I would like to see someone cook Meander and Malli together, so that one could write a Malli schema and a Meander transformation for it and infer the target Malli schema from those."><y>#</y><d>2022-02-11</d><h>10:20</h><r>ikitommi</r>I would like to see someone cook Meander and Malli together, so that one could write a Malli schema and a Meander transformation for it and infer the target Malli schema from those.</z><z id="t1644574822" t="ikitommi might be the ultimate data transformation tool 😎"><y>#</y><d>2022-02-11</d><h>10:20</h><r>ikitommi</r>might be the ultimate data transformation tool <b>😎</b></z><z id="t1644574877" t="Ben Sless I started off with a separate schema, I wanted to be clever and unify"><y>#</y><d>2022-02-11</d><h>10:21</h><r>Ben Sless</r>I started off with a separate schema, I wanted to be clever and unify</z><z id="t1644574928" t="Ben Sless Regarding meander, I also thought on using it for the complex unification problems I made for myself"><y>#</y><d>2022-02-11</d><h>10:22</h><r>Ben Sless</r>Regarding meander, I also thought on using it for the complex unification problems I made for myself</z><z id="t1644575009" t="Ben Sless Add a &quot;match&quot; property to schema which binds, then compile that to meander pattern and match on it"><y>#</y><d>2022-02-11</d><h>10:23</h><r>Ben Sless</r>Add a &quot;match&quot; property to schema which binds, then compile that to meander pattern and match on it</z><z id="t1644575070" t="Ben Sless Or going the other way, write a meander to malli compiler"><y>#</y><d>2022-02-11</d><h>10:24</h><r>Ben Sless</r>Or going the other way, write a meander to malli compiler</z><z id="t1644575091" t="Ben Sless Then schemas reflect how data looks"><y>#</y><d>2022-02-11</d><h>10:24</h><r>Ben Sless</r>Then schemas reflect how data looks</z><z id="t1644575101" t="Ben Sless And you can go crazy with unification"><y>#</y><d>2022-02-11</d><h>10:25</h><r>Ben Sless</r>And you can go crazy with unification</z><z id="t1644250145" t="AJ Jaro What is the best way to setup the schema to work with a protocol? We could potentially use the https://github.com/metosin/malli#fn-schemas to work through instance? , but maybe there’s a better solution"><y>#</y><d>2022-02-07</d><h>16:09</h><w>AJ Jaro</w>What is the best way to setup the schema to work with a protocol? We could potentially use the <a href="https://github.com/metosin/malli#fn-schemas" target="_blank">https://github.com/metosin/malli#fn-schemas</a> to work through <code>instance?</code>, but maybe there’s a better solution</z><z id="t1644251461" t="ikitommi See https://github.com/metosin/malli/issues/555"><y>#</y><d>2022-02-07</d><h>16:31</h><r>ikitommi</r>See <a href="https://github.com/metosin/malli/issues/555" target="_blank">https://github.com/metosin/malli/issues/555</a></z><z id="t1644332436" t="AJ Jaro Thanks. We’ll probably implement some fn schema to check for satisfies or instance for now I guess!"><y>#</y><d>2022-02-08</d><h>15:00</h><r>AJ Jaro</r>Thanks. We’ll probably implement some fn schema to check for <code>satisfies</code> or <code>instance</code> for now I guess!</z><z id="t1644265204" t="Ben Wadsworth It is not clear to me what is going on here… its stumped me…"><y>#</y><d>2022-02-07</d><h>20:20</h><w>Ben Wadsworth</w></z><z id="t1644265677" t="Ben Wadsworth doh’ i mean the obvious here is wrong…one sec.."><y>#</y><d>2022-02-07</d><h>20:27</h><r>Ben Wadsworth</r>doh’ i mean the obvious here is wrong…one sec..</z><z id="t1644265712" t="Ben Wadsworth (being the map in one call and string in another) lol…"><y>#</y><d>2022-02-07</d><h>20:28</h><r>Ben Wadsworth</r>(being the map in one call and string in another) lol…</z><z id="t1644266154" t="Ben Wadsworth I compounded a couple of issues but I dont think its Malli…. I think it might be coercion from reitit. Sorry bout that, another pair of eyes found the painfully obvious string where a map should have been in my example 😐"><y>#</y><d>2022-02-07</d><h>20:35</h><r>Ben Wadsworth</r>I compounded a couple of issues but I dont think its Malli…. I think it might be coercion from reitit. Sorry bout that, another pair of eyes found the painfully obvious string where a map should have been in my example <b>😐</b></z><z id="t1644267868" t="Ben Wadsworth yeah no issue… happy monday"><y>#</y><d>2022-02-07</d><h>21:04</h><r>Ben Wadsworth</r>yeah no issue… happy monday</z><z id="t1644343267" t="Ben Sless Bump / help?"><y>#</y><d>2022-02-08</d><h>18:01</h><w>Ben Sless</w>Bump / help?</z><z id="t1644318618" t="Mutasem Hidmi How can set field to be not required in malli Coercion"><y>#</y><d>2022-02-08</d><h>11:10</h><w>Mutasem Hidmi</w>How can set field to be not required in malli Coercion</z><z id="t1644326937" t="dvingo does {:optional true} not work?"><y>#</y><d>2022-02-08</d><h>13:28</h><w>dvingo</w>does <code>{:optional true}</code> not work?</z><z id="t1644331186" t="pinkfrog I am seeing this coercion failure, but dunno why it fails. It claims missing key, however the key is there."><y>#</y><d>2022-02-08</d><h>14:39</h><w>pinkfrog</w>I am seeing this coercion failure, but dunno why it fails. It claims missing key, however the key is there.</z><z id="t1644331191" t="pinkfrog { &quot;schema&quot;: &quot;[:map {:closed true} [:email [:re #\&quot;^"><y>#</y><d>2022-02-08</d><h>14:39</h><r>pinkfrog</r><pre>{
  &quot;schema&quot;: &quot;[:map {:closed true} [:email [:re #\&quot;^</pre></z><z id="t1644333578" t="dvingo value has email as string not a keyword"><y>#</y><d>2022-02-08</d><h>15:19</h><r>dvingo</r>value has email as string not a keyword</z><z id="t1644334638" t="pinkfrog Yes."><y>#</y><d>2022-02-08</d><h>15:37</h><r>pinkfrog</r>Yes.</z><z id="t1644343110" t="Casey Is it possible to instrument multimethods with the existing instrumentation features in malli?"><y>#</y><d>2022-02-08</d><h>17:58</h><w>Casey</w>Is it possible to instrument multimethods with the existing instrumentation features in malli?</z><z id="t1644343252" t="Ben Sless Won&apos;t multi schema with the dispatch fn itself cover it?"><y>#</y><d>2022-02-08</d><h>18:00</h><r>Ben Sless</r>Won&apos;t multi schema with the dispatch fn itself cover it?</z><z id="t1644344688" t="Casey Perhaps yes.. but then I have to define all schemas on multi-schema on the dispatch fn itself. I&apos;d rather keep the schemas with the defmethod rather than defmulti."><y>#</y><d>2022-02-08</d><h>18:24</h><r>Casey</r>Perhaps yes.. but then I have to define all schemas on multi-schema on the dispatch fn itself. I&apos;d rather keep the schemas with the defmethod rather than defmulti.</z><z id="t1644346725" t="ikitommi How would you like to define the schemas with defmethod ?"><y>#</y><d>2022-02-08</d><h>18:58</h><r>ikitommi</r>How would you like to define the schemas with <code>defmethod</code>?</z><z id="t1644357845" t="Casey That&apos;s a good question.. defmethod doesn&apos;t support metadata afair..only the defmulti does. :thinking_face: Hmm"><y>#</y><d>2022-02-08</d><h>22:04</h><r>Casey</r>That&apos;s a good question.. defmethod doesn&apos;t support metadata afair..only the defmulti does. <b>:thinking_face:</b> Hmm</z><z id="t1644357307" t="crimeminister I&apos;ve got a user-supplied value stored in a map that is a malli schema. I would like to validate that the schema itself is valid; is there a predefined way to do so, or should I author my own &quot;meta-schema&quot; for checking my schema data?"><y>#</y><d>2022-02-08</d><h>21:55</h><w>crimeminister</w>I&apos;ve got a user-supplied value stored in a map that is a malli schema. I would like to validate that the schema itself is valid; is there a predefined way to do so, or should I author my own &quot;meta-schema&quot; for checking my schema data?</z><z id="t1644427905" t="bringe Hello. I’m wondering how I can update a schema to dissoc a prop if the schema uses :and at the top-level. For example, if I have the following: (def my-schema [:and [:map [:id uuid?] [:some-prop int?] [:some-prop-2 int?]] [:fn {:error/message &quot;Some prop must be less than some prop 2&quot;} (fn [{:keys [some-prop some-prop-2]}] (&lt; some-prop some-prop-2))]]) and I want to dissoc :id from the map, but keep everything else in the schema the same, how can I do that? I see the malli.util dissoc function and others, but I’m not sure how to use them when :and is involved."><y>#</y><d>2022-02-09</d><h>17:31</h><w>bringe</w>Hello. I’m wondering how I can update a schema to dissoc a prop if the schema uses :and at the top-level. For example, if I have the following:

<pre>(def my-schema
    [:and
     [:map
      [:id uuid?]
      [:some-prop int?]
      [:some-prop-2 int?]]
     [:fn {:error/message &quot;Some prop must be less than some prop 2&quot;}
      (fn [{:keys [some-prop some-prop-2]}]
        (&lt; some-prop some-prop-2))]])</pre>
and I want to dissoc <code>:id</code>  from the map, but keep everything else in the schema the same, how can I do that? I see the malli.util <code>dissoc</code> function and others, but I’m not sure how to use them when :and is involved.</z><z id="t1644428781" t="bringe Ah, it seems that (mu/update my-schema 0 mu/dissoc :id) works, but maybe there is a better way?"><y>#</y><d>2022-02-09</d><h>17:46</h><r>bringe</r>Ah, it seems that <code>(mu/update my-schema 0 mu/dissoc :id)</code> works, but maybe there is a better way?</z><z id="t1644430114" t="crimeminister There&apos;s a function for manipulating properties that might be worth looking at in case it makes intent clearer: (mu/update-properties) ."><y>#</y><d>2022-02-09</d><h>18:08</h><r>crimeminister</r>There&apos;s a function for manipulating properties that might be worth looking at in case it makes intent clearer: <code>(mu/update-properties)</code>.</z><z id="t1644434617" t="pithyless for mu/merge there is a kind of special case: &gt; * for :and schemas, the first child is used in merge, rest kept as-is I wonder if that could (and should) be generalized to other malli.util operations"><y>#</y><d>2022-02-09</d><h>19:23</h><r>pithyless</r>for <code>mu/merge</code> there is a kind of special case:
&gt;  * for :and schemas, the first child is used in merge, rest kept as-is
I wonder if that could (and should) be generalized to other malli.util operations</z><z id="t1644463328" t="bringe [:attrs {:href &quot;/_/_/users/U066SF64X&quot;}] I’m not sure if update-properties can be used directly in this case, given the :and , but maybe there’s a good way to use it in combination with another operation to make intent clearer. [:attrs {:href &quot;/_/_/users/U05476190&quot;}] Yeah :thinking_face: ."><y>#</y><d>2022-02-10</d><h>03:22</h><r>bringe</r><a>@U066SF64X</a> I’m not sure if <code>update-properties</code> can be used directly in this case, given the <code>:and</code> , but maybe there’s a good way to use it in combination with another operation to make intent clearer.

<a>@U05476190</a> Yeah <b>:thinking_face:</b>.</z><z id="t1644437332" t="oliver marks HI, I have this spec which is being used by a reitit route, I am having issues where it fails because the value is a string instead of a keyword, I have been trying to use the json transformer but I think it fails because its not specifically a keyword test, any suggestion on how I could solve this ? [:or [:map {:closed true}] [:map {:closed true} [:start [:enum :january :feburary :march :april :may :june :july :august :september :october :november :december]] [:end [:enum :january :feburary :march :april :may :june :july :august :september :october :november :december]]]] "><y>#</y><d>2022-02-09</d><h>20:08</h><w>oliver marks</w>HI, I have this spec which is being used by a reitit route, I am having issues where it fails because the value is a string instead of a keyword, I have been trying to use the json transformer but I think it fails because its not specifically a keyword test, any suggestion on how I could solve this ?
<pre>[:or
   [:map {:closed true}]
   [:map {:closed true}
    [:start [:enum :january :feburary :march :april :may :june :july :august :september :october :november :december]]
    [:end [:enum :january :feburary :march :april :may :june :july :august :september :october :november :december]]]]</pre>
</z><z id="t1644438139" t="Ben Sless You need to add a decoder"><y>#</y><d>2022-02-09</d><h>20:22</h><r>Ben Sless</r>You need to add a decoder</z><z id="t1644438514" t="oliver marks So i am running the spec through the json-transformer decoder but I dont think it handles this case because its of enum type not keyword"><y>#</y><d>2022-02-09</d><h>20:28</h><r>oliver marks</r>So i am running the spec through the json-transformer decoder but I dont think it handles this case because its of enum type not keyword</z><z id="t1644438541" t="oliver marks I am currently looking at -json-decoders trying to see if I can add to that some how"><y>#</y><d>2022-02-09</d><h>20:29</h><r>oliver marks</r>I am currently looking at -json-decoders trying to see if I can add to that some how</z><z id="t1644438727" t="oliver marks [:category/type {:optional true} keyword?] currently the above is working as intended, feels like i need to extend some where I tried adding [:and keyword? [:enum :one :two]] but that does not trigger the conversion"><y>#</y><d>2022-02-09</d><h>20:32</h><r>oliver marks</r><pre>[:category/type {:optional true} keyword?]</pre>
currently the above is working as intended, feels like i need to extend some where I tried adding [:and keyword? [:enum :one :two]] but that does not trigger the conversion</z><z id="t1644441540" t="Grant Horner Is there a :seqable schema that would allow you to specify the children’s type? I’m running into an issue where I’d like to have a function accept a vector, list or set of a particular entity, but haven’t been able to figure out how to build the correct collection schema for it. I’m assuming I should be using malli.core/-collection-schema to add a custom schema to the registry"><y>#</y><d>2022-02-09</d><h>21:19</h><w>Grant Horner</w>Is there a <code>:seqable</code> schema that would allow you to specify the children’s type? I’m running into an issue where I’d like to have a function accept a vector, list or set of a particular entity, but haven’t been able to figure out how to build the correct collection schema for it. I’m assuming I should be using <code>malli.core/-collection-schema</code> to add a custom schema to the registry</z><z id="t1644567135" t="ikitommi You can also just define the Schema as Var as use it without registering, like Reagent compoents: (def Seqable (m/-collection-schema {:type &apos;Seqable, :pred seqable?})) (m/validate [Seqable :int] &apos;(1 2 3)) ; =&gt; true"><y>#</y><d>2022-02-11</d><h>08:12</h><r>ikitommi</r>You can also just define the Schema as Var as use it without registering, like Reagent compoents:
<pre>(def Seqable (m/-collection-schema {:type &apos;Seqable, :pred seqable?}))

(m/validate [Seqable :int] &apos;(1 2 3)) ; =&gt; true</pre></z><z id="t1644567165" t="ikitommi If you feel that is important, please write an issue to add that to malli."><y>#</y><d>2022-02-11</d><h>08:12</h><r>ikitommi</r>If you feel that is important, please write an issue to add that to malli.</z><z id="t1644567248" t="ikitommi adding new types means the following: • add it to the core • generator for it • JSON Schema (and optionally swagger) mappings • default humanized error message • clj-kondo mappings • + tests"><y>#</y><d>2022-02-11</d><h>08:14</h><r>ikitommi</r>adding new types means the following:
• add it to the core
• generator for it
• JSON Schema (and optionally swagger) mappings
• default humanized error message
• clj-kondo mappings
• + tests</z><z id="t1644567368" t="ikitommi without registering it, you won’t can’t deserialize a serialized schema, but for anything else, it should work normally."><y>#</y><d>2022-02-11</d><h>08:16</h><r>ikitommi</r>without registering it, you won’t can’t deserialize a serialized schema, but for anything else, it should work normally.</z><z id="t1644471747" t="Zaymon Hello. Is there a way to make the exception-info created by Malli coercion less verbose? Currently 500 lines of output to the terminal is a bit hard to parse, mostly because the exception info includes a lot of information about the request. Either that or a better way to print only the relevant parts of the exception would also be appreciated."><y>#</y><d>2022-02-10</d><h>05:42</h><w>Zaymon</w>Hello. Is there a way to make the exception-info created by Malli coercion less verbose? Currently 500 lines of output to the terminal is a bit hard to parse, mostly because the exception info includes a lot of information about the request.

Either that or a better way to print only the relevant parts of the exception would also be appreciated.</z><z id="t1644472001" t="Zaymon"><y>#</y><d>2022-02-10</d><h>05:46</h><r>Zaymon</r></z><z id="t1644472714" t="Zaymon (def malli-coercer (malli-coercion/create {;; set of keys to include in error messages :error-keys #{:humanized ;; :type ;; :coercion ;; :in :schema :value :errors #_:transformed} ;; schema identity function (default: close all map schemas) :compile mu/closed-schema ;; validate request &amp; response :validate true ;; top-level short-circuit to disable request &amp; response coercion :enabled true ;; malli options :options nil :muuntaja formats/instance})) My Coercion is setup like this"><y>#</y><d>2022-02-10</d><h>05:58</h><r>Zaymon</r><pre>(def malli-coercer
  (malli-coercion/create
   {;; set of keys to include in error messages
    :error-keys #{:humanized
              ;;     :type
              ;;     :coercion
              ;;     :in
                  :schema
                  :value
                  :errors
                  #_:transformed}
   ;; schema identity function (default: close all map schemas)
    :compile mu/closed-schema
   ;; validate request &amp; response
    :validate true
   ;; top-level short-circuit to disable request &amp; response coercion
    :enabled true
   ;; malli options
    :options nil
    :muuntaja formats/instance}))</pre>
My Coercion is setup like this</z><z id="t1644521606" t="emccue malli/humanize?"><y>#</y><d>2022-02-10</d><h>19:33</h><r>emccue</r>malli/humanize?</z><z id="t1644543820" t="Zaymon Not sure how to apply that to exception-info"><y>#</y><d>2022-02-11</d><h>01:43</h><r>Zaymon</r>Not sure how to apply that to exception-info</z><z id="t1645099649" t="jussi Pondered the same the other day, ended up with simplistic helpers (defn- path-&gt;str [path] (string/join &quot; -&gt; &quot; (map #(if (number? %) (str &quot;[&quot; % &quot;]&quot;) (name %)) path))) (defn pretty-schema-error &quot;Make schema errors a bit more readable. Handles nil&apos;s and formats path.&quot; [error] (let [path (:path error) type (:type error)] {:path (path-&gt;str path) :type (if (nil? type) &quot;nil&quot; (name type))})) Using it in our reitit API when handling :reitit.coercion/request-coercion errors for example."><y>#</y><d>2022-02-17</d><h>12:07</h><r>jussi</r>Pondered the same the other day, ended up with simplistic helpers

<pre>(defn- path-&gt;str
  [path]
  (string/join &quot; -&gt; &quot; (map #(if (number? %)
                              (str &quot;[&quot; % &quot;]&quot;)
                              (name %))
                           path)))

(defn pretty-schema-error
  &quot;Make schema errors a bit more readable. Handles nil&apos;s and formats path.&quot;
  [error]
  (let [path (:path error)
        type (:type error)]
    {:path (path-&gt;str path)
     :type (if (nil? type) &quot;nil&quot; (name type))})) </pre>
Using it in our <code>reitit</code> API when handling <code>:reitit.coercion/request-coercion</code> errors for example.</z><z id="t1644567457" t="ikitommi would this make sense? https://clojureverse.org/t/using-schema-like-schemas-in-malli/8613/2?u=ikitommi"><y>#</y><d>2022-02-11</d><h>08:17</h><w>ikitommi</w>would this make sense? <a href="https://clojureverse.org/t/using-schema-like-schemas-in-malli/8613/2?u=ikitommi" target="_blank">https://clojureverse.org/t/using-schema-like-schemas-in-malli/8613/2?u=ikitommi</a></z><z id="t1644568652" t="jeroenvandijk Looks useful! - a small step for people acquinted with Plumatic Schema to try Malli - offers potentially a soft migration path from Schema to Malli. Assuming enough/all Schema predicates will be covered - extend existing Schema code bases with the power of Malli (I believe :multi will have better error reporting than schema.core/either for instance). This again assumes that the translation of Schema will be near to perfect"><y>#</y><d>2022-02-11</d><h>08:37</h><r>jeroenvandijk</r>Looks useful!

- a small step for people acquinted with Plumatic Schema to try Malli
- offers potentially a soft migration path from Schema to Malli. Assuming enough/all Schema predicates will be covered
- extend existing Schema code bases with the power of Malli (I believe <code>:multi</code> will have better error reporting than <code>schema.core/either</code> for instance). This again assumes that the translation of Schema will be near to perfect</z><z id="t1644567486" t="ikitommi (require &apos;[malli.experimental.lite :as l]) (def Schema (l/schema {:map1 {:x int? :y [:maybe string?] :z (l/maybe keyword?)} :map2 {:min-max [:int {:min 0 :max 10}] :tuples (l/vector (l/tuple int? string?)) :optional (l/optional (l/maybe :boolean)) :set-of-maps (l/set {:e int? :f string?}) :map-of-int (l/map-of int? {:s string?})}})) ;[:map ; [:map1 ; [:map ; [:x int?] ; [:y [:maybe string?]] ; [:z [:maybe keyword?]]]] ; [:map2 ; [:map ; [:min-max [:int {:min 0, :max 10}]] ; [:tuples [:vector [:tuple int? string?]]] ; [:optional {:optional true} [:maybe :boolean]]"><y>#</y><d>2022-02-11</d><h>08:18</h><w>ikitommi</w><pre>(require &apos;[malli.experimental.lite :as l])

(def Schema
  (l/schema
   {:map1 {:x int?
           :y [:maybe string?]
           :z (l/maybe keyword?)}
    :map2 {:min-max [:int {:min 0 :max 10}]
           :tuples (l/vector (l/tuple int? string?))
           :optional (l/optional (l/maybe :boolean))
           :set-of-maps (l/set {:e int?
                                :f string?})
           :map-of-int (l/map-of int? {:s string?})}}))
;[:map
; [:map1
;  [:map
;   [:x int?]
;   [:y [:maybe string?]]
;   [:z [:maybe keyword?]]]]
; [:map2
;  [:map
;   [:min-max [:int {:min 0, :max 10}]]
;   [:tuples [:vector [:tuple int? string?]]]
;   [:optional {:optional true} [:maybe :boolean]]</pre></z><z id="t1644567595" t="ikitommi 18 lines of optional sugar, for simple cases like defining route parameters with reitit."><y>#</y><d>2022-02-11</d><h>08:19</h><w>ikitommi</w>18 lines of optional sugar, for simple cases like defining route parameters with reitit.</z><z id="t1644569213" t="jeroenvandijk I can imagine this dsl would not cover complex cases of Malli, but sure looks useful to remove some boilerplate. Maybe it becomes confusing if these way of schema writing get mixed, not sure"><y>#</y><d>2022-02-11</d><h>08:46</h><r>jeroenvandijk</r>I can imagine this dsl would not cover complex cases of Malli, but sure looks useful to remove some boilerplate. Maybe it becomes confusing if these way of schema writing get mixed, not sure</z></g><g id="s22"><z id="t1644569754" t="ikitommi yes, I would. not use this for anything “normal”, but for specific / inline cases, good: default reitit+malli: :parameters {:query [:map [:x int?] [:y {:optional true} string?]]} adding reitit+malli support for lite too: :parameters {:query {:x int?, :y (l/optional string?)}}"><y>#</y><d>2022-02-11</d><h>08:55</h><r>ikitommi</r>yes, I would. not use this for anything “normal”, but for specific / inline cases, good:

default reitit+malli:
<pre>:parameters {:query [:map 
                     [:x int?]
                     [:y {:optional true} string?]]}</pre>
adding reitit+malli support for lite too:
<pre>:parameters {:query {:x int?, :y (l/optional string?)}}</pre></z><z id="t1644570942" t="jeroenvandijk I wanted to say maybe instead of supporting lite directly, asking the user to use to dsl themselves might lead to less confusion. But I see malli can go into malli-lite and malli-lite can go into malli :) :parameters {:query {:x int?, :y (l/optional [:map-of string? string?]]} Generates a valid malli schema, and also the other way around: :parameters {:query [:map [:x int?] [:y {:optional true} (map-of string? string?]]} Nice 💪"><y>#</y><d>2022-02-11</d><h>09:15</h><r>jeroenvandijk</r>I wanted to say maybe instead of supporting lite directly, asking the user to use to dsl themselves might lead to less confusion. But I see <code>malli</code> can go into  <code>malli-lite</code> and <code>malli-lite</code> can go into <code>malli</code> :)
<pre>:parameters {:query {:x int?, :y (l/optional [:map-of string? string?]]}</pre>
Generates a valid malli schema, and also the other way around:
<pre>:parameters {:query [:map 
                     [:x int?]
                     [:y {:optional true} (map-of string? string?]]}</pre>
Nice <b>💪</b></z><z id="t1644571138" t="jeroenvandijk So that actually means complex cases are also covered, because normal malli can be used where necessary?"><y>#</y><d>2022-02-11</d><h>09:18</h><r>jeroenvandijk</r>So that actually means complex cases are also covered, because normal malli can be used where necessary?</z><z id="t1644573585" t="ikitommi yes."><y>#</y><d>2022-02-11</d><h>09:59</h><r>ikitommi</r>yes.</z><z id="t1644588923" t="ikitommi malli.experimental.lite now merged in master."><y>#</y><d>2022-02-11</d><h>14:15</h><r>ikitommi</r><code>malli.experimental.lite</code> now merged in master.</z><z id="t1644573554" t="Ben Sless https://www.asyncapi.com/ 👀"><y>#</y><d>2022-02-11</d><h>09:59</h><w>Ben Sless</w><a href="https://www.asyncapi.com/" target="_blank">https://www.asyncapi.com/</a> <b>👀</b></z><z id="t1644774173" t="ikitommi not sure how this relates to malli, but 👍"><y>#</y><d>2022-02-13</d><h>17:42</h><r>ikitommi</r>not sure how this relates to malli, but <b>👍</b></z><z id="t1644774744" t="Ben Sless mostly, thinking about a good way to bring this together with malli, hopefully finding a lossless translation between the two. AsyncAPI looks like a very interesting way to solve the &quot;schema problem&quot; at an organizational level + all the metadata I would have had to reinvent the wheel to specify, which could go beyond interfacing with malli, but further code generation. You could derive reitit routes from it, and more"><y>#</y><d>2022-02-13</d><h>17:52</h><r>Ben Sless</r>mostly, thinking about a good way to bring this together with malli, hopefully finding a lossless translation between the two. AsyncAPI looks like a very interesting way to solve the &quot;schema problem&quot; at an organizational level + all the metadata I would have had to reinvent the wheel to specify, which could go beyond interfacing with malli, but further code generation. You could derive reitit routes from it, and more</z><z id="t1644588923" t="ikitommi malli.experimental.lite now merged in master."><y>#</y><d>2022-02-11</d><h>14:15</h><w>ikitommi</w><code>malli.experimental.lite</code> now merged in master.</z><z id="t1644594864" t="Brett Rowberry Today, when humanizing a value against a map schema, the error message &quot;invalid type&quot; isn&apos;t super useful. I know I can add a custom error message. How could it be more descriptive? (malli.error/humanize (malli.core/explain [:map] &quot;string&quot;)) ;; =&gt; [&quot;invalid type&quot;]"><y>#</y><d>2022-02-11</d><h>15:54</h><w>Brett Rowberry</w>Today, when humanizing a value against a map schema, the error message <code>&quot;invalid type&quot;</code> isn&apos;t super useful. I know I can add a custom error message. How could it be more descriptive?
<pre>(malli.error/humanize (malli.core/explain [:map] &quot;string&quot;))
;; =&gt; [&quot;invalid type&quot;]</pre></z><z id="t1644596291" t="dvingo https://github.com/metosin/malli#custom-error-messages"><y>#</y><d>2022-02-11</d><h>16:18</h><w>dvingo</w><a href="https://github.com/metosin/malli#custom-error-messages" target="_blank">https://github.com/metosin/malli#custom-error-messages</a></z><z id="t1644618151" t="Brett Rowberry Right, I know I can do that for a given schema, but wondered if maybe all maps could say something more specific."><y>#</y><d>2022-02-11</d><h>22:22</h><r>Brett Rowberry</r>Right, I know I can do that for a given schema, but wondered if maybe all maps could say something more specific.</z><z id="t1644666090" t="ikitommi You can override the default error for invalid type, using options to me/humanize ."><y>#</y><d>2022-02-12</d><h>11:41</h><r>ikitommi</r>You can override the default error for invalid type, using options to <code>me/humanize</code>.</z><z id="t1644666133" t="ikitommi there should be an example behind the link.."><y>#</y><d>2022-02-12</d><h>11:42</h><r>ikitommi</r>there should be an example behind the link..</z><z id="t1644669284" t="dvingo oh woops sorry [:attrs {:href &quot;/_/_/users/U021RHDFFHN&quot;}] overlooked that you said that. I learned something, just tried this out and it works: (malli.error/humanize (malli.core/explain [:map] &quot;string&quot;) {:errors (-&gt; default-errors (assoc ::m/invalid-type {:error/fn (fn [{:keys [value schema] :as in} _] (str &quot;The value you provided: &apos;&quot; value &quot;&apos; is not the correct type for the schema: &apos;&quot; (m/form schema) &quot;&apos;&quot;))}))}) =&gt; [&quot;The value you provided: \&quot;string\&quot; is not the correct type for the schema: &apos;:map&apos;&quot;]"><y>#</y><d>2022-02-12</d><h>12:34</h><r>dvingo</r>oh woops sorry <a>@U021RHDFFHN</a> overlooked that you said that.

I learned something, just tried this out and it works:
<pre>(malli.error/humanize
    (malli.core/explain [:map] &quot;string&quot;)
    {:errors (-&gt; default-errors
               (assoc ::m/invalid-type
                      {:error/fn (fn [{:keys [value schema] :as in} _]
                                   (str &quot;The value you provided: &apos;&quot; value &quot;&apos; is not the correct type for the schema: &apos;&quot; (m/form schema) &quot;&apos;&quot;))}))})</pre>
<pre>=&gt; [&quot;The value you provided: \&quot;string\&quot; is not the correct type for the schema: &apos;:map&apos;&quot;]</pre></z><z id="t1644774115" t="ikitommi the (m/form schema) could be (m/type schema) , just report on type, not whole form. otherwise, 💯"><y>#</y><d>2022-02-13</d><h>17:41</h><r>ikitommi</r>the <code>(m/form schema)</code> could be <code>(m/type schema)</code>, just report on type, not whole form. otherwise, <b>💯</b></z><z id="t1644862619" t="Brett Rowberry Thanks! This works best for my use case: (malli.error/humanize (malli.core/explain [:map] nil)) ;; =&gt; [&quot;invalid type&quot;] (malli.error/humanize (malli.core/explain [:map [:hi string?]] nil) {:errors (-&gt; malli.error/default-errors (assoc ::m/invalid-type {:error/fn (fn [{:keys [_value schema]} _] (str &quot;The value provided does not conform to schema: &apos;&quot; (m/form #_m/type schema) &quot;&apos;&quot;))}))}) ;; =&gt; [&quot;The value provided does not conform to schema: &apos;[:map [:hi string?]]&apos;&quot;]"><y>#</y><d>2022-02-14</d><h>18:16</h><r>Brett Rowberry</r>Thanks! This works best for my use case:
<pre>(malli.error/humanize (malli.core/explain [:map] nil))
;; =&gt; [&quot;invalid type&quot;]

(malli.error/humanize
 (malli.core/explain [:map [:hi string?]] nil)
 {:errors (-&gt; malli.error/default-errors
              (assoc ::m/invalid-type
                     {:error/fn (fn [{:keys [_value schema]} _]
                                  (str &quot;The value provided does not conform to schema: &apos;&quot; (m/form #_m/type schema) &quot;&apos;&quot;))}))})
;; =&gt; [&quot;The value provided does not conform to schema: &apos;[:map [:hi string?]]&apos;&quot;]</pre></z><z id="t1644922801" t="Martynas M How does one install sci as an external dependency? I try to run tests of malli and they fail with this error: :malli.core/sci-not-available Should I include it into my ~/.clojure/deps.edn ?"><y>#</y><d>2022-02-15</d><h>11:00</h><w>Martynas M</w>How does one install <code>sci</code> as an external dependency?
I try to run tests of <code>malli</code> and they fail with this error: <code>:malli.core/sci-not-available</code>
Should I include it into my <code>~/.clojure/deps.edn</code>?</z><z id="t1644922853" t="Martynas M This was the info from #babashka channel. But it&apos;s not enough context."><y>#</y><d>2022-02-15</d><h>11:00</h><w>Martynas M</w>This was the info from #babashka channel. But it&apos;s not enough context.</z><z id="t1644922867" t="borkdude https://github.com/metosin/malli#running-tests"><y>#</y><d>2022-02-15</d><h>11:01</h><w>borkdude</w><a href="https://github.com/metosin/malli#running-tests" target="_blank">https://github.com/metosin/malli#running-tests</a></z><z id="t1644922905" t="borkdude It seems you need the :test alias"><y>#</y><d>2022-02-15</d><h>11:01</h><w>borkdude</w>It seems you need the <code>:test</code> alias</z><z id="t1644922961" t="borkdude I recommend upgrading SCI to 0.3.0 for better performance"><y>#</y><d>2022-02-15</d><h>11:02</h><w>borkdude</w>I recommend upgrading SCI to 0.3.0 for better performance</z><z id="t1644923038" t="Martynas M How would one run tests from emacs(spacemacs+CIDER)? If I understand correctly you&apos;d need to run it a JS-Clojure REPL. It failed for me when I used Java-Clojure REPL."><y>#</y><d>2022-02-15</d><h>11:03</h><w>Martynas M</w>How would one run tests from emacs(spacemacs+CIDER)? If I understand correctly you&apos;d need to run it a JS-Clojure REPL. It failed for me when I used Java-Clojure REPL.</z><z id="t1644923225" t="borkdude [:attrs {:href &quot;/_/_/users/U028ART884X&quot;}] You can place a file .dir-locals in the repo: ((clojure-mode (cider-clojure-cli-aliases . &quot;test&quot;)))"><y>#</y><d>2022-02-15</d><h>11:07</h><w>borkdude</w><a>@invertisment_clojuria</a> You can place a file <code>.dir-locals</code> in the repo:
<pre>((clojure-mode
  (cider-clojure-cli-aliases . &quot;test&quot;)))</pre></z><z id="t1644923243" t="borkdude and then cider-jack-in , after that you should be able to run tests from CIDER"><y>#</y><d>2022-02-15</d><h>11:07</h><w>borkdude</w>and then <code>cider-jack-in</code> , after that you should be able to run tests from CIDER</z><z id="t1644923290" t="borkdude if you do not want to add the file, you can do it like this: C-u M-x cider-jack-in"><y>#</y><d>2022-02-15</d><h>11:08</h><w>borkdude</w>if you do not want to add the file, you can do it like this:
<pre>C-u M-x cider-jack-in</pre></z><z id="t1644923325" t="borkdude and then choose clojure-cli and then add the test alias here: -M:test:cider"><y>#</y><d>2022-02-15</d><h>11:08</h><w>borkdude</w>and then choose <code>clojure-cli</code> and then add the test alias here: <code>-M:test:cider</code></z><z id="t1644923327" t="borkdude and press enter"><y>#</y><d>2022-02-15</d><h>11:08</h><w>borkdude</w>and press enter</z><z id="t1644923336" t="Martynas M ok."><y>#</y><d>2022-02-15</d><h>11:08</h><w>Martynas M</w>ok.</z><z id="t1644923497" t="Martynas M What should I choose when it says &quot;connect sibling cljs&quot;? There are many options. node , figwheel , shadow and others"><y>#</y><d>2022-02-15</d><h>11:11</h><w>Martynas M</w>What should I choose when it says &quot;connect sibling cljs&quot;? There are many options. <code>node</code>, <code>figwheel</code>, <code>shadow</code> and others</z><z id="t1644923546" t="borkdude Dunno, I don&apos;t ever use this. If I want to run tests, I do it directly from the Node REPL"><y>#</y><d>2022-02-15</d><h>11:12</h><w>borkdude</w>Dunno, I don&apos;t ever use this. If I want to run tests, I do it directly from the Node REPL</z><z id="t1644923577" t="Martynas M So you develop without a REPL?"><y>#</y><d>2022-02-15</d><h>11:12</h><w>Martynas M</w>So you develop without a REPL?</z><z id="t1644923604" t="Martynas M I&apos;m used to have everything under one process in Java. That&apos;s why I ask. I know that in CLJS it&apos;s different."><y>#</y><d>2022-02-15</d><h>11:13</h><w>Martynas M</w>I&apos;m used to have everything under one process in Java. That&apos;s why I ask. I know that in CLJS it&apos;s different.</z><z id="t1644923665" t="Martynas M So should it be ./bin/node and that&apos;s it? And then you&apos;d proceed to go and change the sources?"><y>#</y><d>2022-02-15</d><h>11:14</h><w>Martynas M</w>So should it be <code>./bin/node</code> and that&apos;s it? And then you&apos;d proceed to go and change the sources?</z><z id="t1644923682" t="Martynas M And have the REPL running just in case?"><y>#</y><d>2022-02-15</d><h>11:14</h><w>Martynas M</w>And have the REPL running just in case?</z><z id="t1644923750" t="borkdude I do use the REPL, but for CLJS I found it too brittle to do it from my editor so I chose to simplify things. I use (require &apos;[ns] :reload) in the REPL when I want to reload changes, and invoke test expressions or files when I want to test something. This is a spartan workflow, but it&apos;s the least time consuming for me personally."><y>#</y><d>2022-02-15</d><h>11:15</h><w>borkdude</w>I do use the REPL, but for CLJS I found it too brittle to do it from my editor so I chose to simplify things. I use <code>(require &apos;[ns] :reload)</code> in the REPL when I want to reload changes, and invoke test expressions or files when I want to test something. This is a spartan workflow, but it&apos;s the least time consuming for me personally.</z><z id="t1644923855" t="Martynas M Should I also add how to start-up the emacs REPL into the README? I&apos;ll make a PR for a bugfix."><y>#</y><d>2022-02-15</d><h>11:17</h><w>Martynas M</w>Should I also add how to start-up the emacs REPL into the README? I&apos;ll make a PR for a bugfix.</z><z id="t1644923927" t="borkdude I was just providing info, I&apos;m not the maintainer of this project, so I&apos;ll let [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] or whoever decide on that :)"><y>#</y><d>2022-02-15</d><h>11:18</h><w>borkdude</w>I was just providing info, I&apos;m not the maintainer of this project, so I&apos;ll let <a>@ikitommi</a> or whoever decide on that :)</z><z id="t1644931646" t="dvingo I&apos;ve had success running the cljs tests in malli repo in a repl, but I augmented the shadow-cljs.edn file to load one of the app targets in a browser, and then when the tests were working in the browser I verified them for node by running ./bin/node this was from cursive though. it should also work with cider with the relevant shadow integration"><y>#</y><d>2022-02-15</d><h>13:27</h><w>dvingo</w>I&apos;ve had success running the cljs tests in malli repo in a repl, but I augmented the <code>shadow-cljs.edn</code> file to load one of the app targets in a browser, and then when the tests were working in the browser I verified them for node by running <code>./bin/node</code> this was from cursive though. it should also work with cider with the relevant <code>shadow</code>  integration</z><z id="t1645094078" t="DrLjótsson Is there a way to specify that a set needs to have at least one element? [:+ ...] only seems to work for sequences"><y>#</y><d>2022-02-17</d><h>10:34</h><w>DrLjótsson</w>Is there a way to specify that a set needs to have at least one element? <code>[:+ ...]</code> only seems to work for sequences</z><z id="t1645094589" t="DrLjótsson This is what I have come up with [:and [:set :int] [:fn (fn [x] (not (empty? x)))]]"><y>#</y><d>2022-02-17</d><h>10:43</h><w>DrLjótsson</w>This is what I have come up with
<pre>[:and
 [:set :int]
 [:fn (fn [x] (not (empty? x)))]]</pre></z><z id="t1645096279" t="ikitommi maybe [:set {:min 1} :int] ?"><y>#</y><d>2022-02-17</d><h>11:11</h><w>ikitommi</w>maybe <code>[:set {:min 1} :int]</code>?</z><z id="t1645097869" t="DrLjótsson That’s it, works!"><y>#</y><d>2022-02-17</d><h>11:37</h><w>DrLjótsson</w>That’s it, works!</z><z id="t1645097875" t="DrLjótsson Thanks"><y>#</y><d>2022-02-17</d><h>11:37</h><w>DrLjótsson</w>Thanks</z><z id="t1645386512" t="oliver marks Hi, hoping someone can point me in the right direction, can you extend json-transformer-provider https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L35 I basically want to convert a specific keys value to a keyword the malli spec is an enum of keywords and the json decoder is not converting the string to a keyword for me so I need some custom logic here I believe, but I am unsure how to inject this ?"><y>#</y><d>2022-02-20</d><h>19:48</h><w>oliver marks</w>Hi, hoping someone can point me in the right direction, can you extend json-transformer-provider <a href="https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L35" target="_blank">https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L35</a> I basically want to convert a specific keys value to a keyword the malli spec is an enum of keywords and the json decoder is not converting the string to a keyword for me so I need some custom logic here I believe, but I am unsure how to inject this ?</z><z id="t1645541319" t="rovanion I&apos;m getting data to a Reitit handler with malli coercion from a simple HTML form. One of the fields should either be a number or be left blank when the form is submitted. I want to translate that to either nil or to remove the key entirely from the map during coercion, is that possible?"><y>#</y><d>2022-02-22</d><h>14:48</h><w>rovanion</w>I&apos;m getting data to a Reitit handler with malli coercion from a simple HTML form. One of the fields should either be a number or be left blank when the form is submitted. I want to translate that to either <code>nil</code> or to remove the key entirely from the map during coercion, is that possible?</z><z id="t1645541427" t="rovanion Right now coersion fails because the feild holds a string when it should hold an int, but just defining the value of the field to be [:or string? int?] means that all other functions have to deal with the possibility of that field being a non-int."><y>#</y><d>2022-02-22</d><h>14:50</h><w>rovanion</w>Right now coersion fails because the feild holds a string when it should hold an int, but just defining the value of the field to be <code>[:or string? int?]</code> means that all other functions have to deal with the possibility of that field being a non-int.</z><z id="t1645543260" t="dvingo you could make your own schema type and then add custom coercion logic there. For example this is a custom schema for local dates: :local-date (m/-simple-schema {:type :local-date :pred tu/date? :type-properties {:gen/gen gen-date :decode/string (fn [v] (log/info &quot;Decoding to local-date: &quot; v) (tu/date v))}}) and add that to your malli registry"><y>#</y><d>2022-02-22</d><h>15:21</h><w>dvingo</w>you could make your own schema type and then add custom coercion logic there. For example this is a custom schema for local dates:
<pre>:local-date (m/-simple-schema
                            {:type            :local-date
                             :pred            tu/date?
                             :type-properties {:gen/gen gen-date
                                               :decode/string (fn [v]
                                                                (log/info &quot;Decoding to local-date: &quot; v)
                                                                (tu/date v))}})</pre>
and add that to your malli registry</z><z id="t1645543437" t="dvingo and to deal with the logic of conditionally removing the key from a map, my guess is that you could change the malli coercer: https://github.com/metosin/reitit/blob/master/doc/coercion/malli_coercion.md#configuring-coercion by changing the transformers"><y>#</y><d>2022-02-22</d><h>15:23</h><w>dvingo</w>and to deal with the logic of conditionally removing the key from a map, my guess is that you could change the malli coercer:
<a href="https://github.com/metosin/reitit/blob/master/doc/coercion/malli_coercion.md#configuring-coercion" target="_blank">https://github.com/metosin/reitit/blob/master/doc/coercion/malli_coercion.md#configuring-coercion</a>
by changing the transformers</z><z id="t1645544599" t="rovanion Interesting, I like that first idea. Make a type with a name like :nilable-form-int, simple enough. Thank you! Writing a coercer would probably be better, but I don&apos;t think I could wrap my head around it fast enough to still please the deadline."><y>#</y><d>2022-02-22</d><h>15:43</h><w>rovanion</w>Interesting, I like that first idea. Make a type with a name like :nilable-form-int, simple enough. Thank you!

Writing a coercer would probably be better, but I don&apos;t think I could wrap my head around it fast enough to still please the deadline.</z><z id="t1645545347" t="ikitommi [:attrs {:href &quot;/_/_/users/U1QMBJY01&quot;}] maybe: (def NilableInt [:maybe {:decode/string (fn [x] (when-not (str/blank? x) (mt/-string-&gt;long x)))} :int]) (m/decode [:map [:x NilableInt] [:y NilableInt]] {:x &quot;&quot; :y &quot;123&quot;} (mt/string-transformer)) ; =&gt; {:x nil, :y 123} (mg/sample [:map [:x NilableInt] [:y NilableInt]]) ;({:x -1, :y nil} ; {:x nil, :y nil} ; {:x 0, :y -1} ; {:x nil, :y nil} ; {:x 2, :y nil} ; {:x -3, :y -1} ; {:x -2, :y nil} ; {:x 3, :y 1} ; {:x nil, :y nil} ; {:x -8, :y -1})"><y>#</y><d>2022-02-22</d><h>15:55</h><w>ikitommi</w><a>@rovanion</a> maybe:
<pre>(def NilableInt
  [:maybe {:decode/string (fn [x] (when-not (str/blank? x) (mt/-string-&gt;long x)))} :int])

(m/decode
 [:map
  [:x NilableInt]
  [:y NilableInt]]
 {:x &quot;&quot;
  :y &quot;123&quot;}
 (mt/string-transformer))
; =&gt; {:x nil, :y 123}

(mg/sample
 [:map
  [:x NilableInt]
  [:y NilableInt]])
;({:x -1, :y nil}
; {:x nil, :y nil}
; {:x 0, :y -1}
; {:x nil, :y nil}
; {:x 2, :y nil}
; {:x -3, :y -1}
; {:x -2, :y nil}
; {:x 3, :y 1}
; {:x nil, :y nil}
; {:x -8, :y -1})</pre></z><z id="t1645545771" t="rovanion Hah, was just writing that exact :decode/string-function in my own simple-schema. But yeah, that fits the bill!"><y>#</y><d>2022-02-22</d><h>16:02</h><w>rovanion</w>Hah, was just writing that exact :decode/string-function in my own simple-schema. But yeah, that fits the bill!</z><z id="t1645545814" t="rovanion I really like that Clojure has functions like when-not in the standard library so I don&apos;t have to make them up in some util library."><y>#</y><d>2022-02-22</d><h>16:03</h><w>rovanion</w>I really like that Clojure has functions like <code>when-not</code> in the standard library so I don&apos;t have to make them up in some util library.</z><z id="t1645546034" t="rovanion s/functions/functions and macros/"><y>#</y><d>2022-02-22</d><h>16:07</h><w>rovanion</w>s/functions/functions and macros/</z><z id="t1645551097" t="rovanion This is where I&apos;m at now: (register! :html/nilable-int (malli/-simple-schema (fn [opts _] {:type :html/nilable-int :pred (some-fn int? nil?) :property-pred (malli/-min-max-pred nil) :description &quot;An int or nil. Empty string is transformed to nil.&quot; :type-properties {:decode/string (fn [x] (when-not (string/blank? x) (mtransform/-string-&gt;long x))) :gen/gen (gen/large-integer* opts)}}))) I just have to write a generator that generates nil sometimes. Sadly :gen/schema [:maybe [int? opts]] doesn&apos;t respect :min passed in opts."><y>#</y><d>2022-02-22</d><h>17:31</h><w>rovanion</w>This is where I&apos;m at now:

<pre>(register! :html/nilable-int                                                                                          
  (malli/-simple-schema                                                                                               
   (fn [opts _]                                                                                                       
     {:type            :html/nilable-int                                                                              
      :pred            (some-fn int? nil?)                                                                            
      :property-pred   (malli/-min-max-pred nil)                                                                      
      :description     &quot;An int or nil. Empty string is transformed to nil.&quot;                                           
      :type-properties {:decode/string (fn [x] (when-not (string/blank? x)                                            
                                                 (mtransform/-string-&gt;long x)))                                       
                        :gen/gen (gen/large-integer* opts)}})))</pre>
I just have to write a generator that generates nil sometimes. Sadly <code>:gen/schema [:maybe [int? opts]]</code> doesn&apos;t respect :min passed in opts.</z><z id="t1645553550" t="ikitommi int? is just a predicate, use :int , which is a real schema"><y>#</y><d>2022-02-22</d><h>18:12</h><r>ikitommi</r><code>int?</code> is just a predicate, use <code>:int</code> , which is a real schema</z><z id="t1645553732" t="rovanion The practical implications of the distinction is lost on me, I thought both were resolved to the exact same schema. Either way it made no difference, setting :gen/schema [:maybe [:int opts]] still generated negative numbers when opts was {:min 0} ."><y>#</y><d>2022-02-22</d><h>18:15</h><r>rovanion</r>The practical implications of the distinction is lost on me, I thought both were resolved to the exact same schema.

Either way it made no difference, setting <code>:gen/schema [:maybe [:int opts]]</code> still generated negative numbers when <code>opts</code> was <code>{:min 0}</code>.</z><z id="t1645556395" t="ikitommi (mg/sample [:any {:gen/schema [:int {:min 100}]}]) ; =&gt; (101 101 101 101 102 108 105 100 111 148)"><y>#</y><d>2022-02-22</d><h>18:59</h><r>ikitommi</r><pre>(mg/sample [:any {:gen/schema [:int {:min 100}]}])
; =&gt; (101 101 101 101 102 108 105 100 111 148)</pre></z><z id="t1645556484" t="ikitommi (mg/sample [:maybe [:any {:gen/schema [:int {:min 100}]}]]) ; =&gt; (nil nil nil 102 nil nil 102 103 111 159)"><y>#</y><d>2022-02-22</d><h>19:01</h><r>ikitommi</r><pre>(mg/sample [:maybe [:any {:gen/schema [:int {:min 100}]}]])
; =&gt; (nil nil nil 102 nil nil 102 103 111 159)</pre></z><z id="t1645557578" t="rovanion Sorry, I must have failed to press C-c C-c or something after switching from int? to :int because it&apos;s working now and I don&apos;t know what else could have caused it to fail. Thank you so much for your time."><y>#</y><d>2022-02-22</d><h>19:19</h><r>rovanion</r>Sorry, I must have failed to press C-c C-c or something after switching from <code>int?</code> to <code>:int</code> because it&apos;s working now and I don&apos;t know what else could have caused it to fail.

Thank you so much for your time.</z><z id="t1645557641" t="rovanion This is the schema I ended up with, does both generate, transform and conform as I want it: (register! :html/nilable-int (malli/-simple-schema (fn [opts _] {:type :html/nilable-int :pred (some-fn int? nil?) :property-pred (malli/-min-max-pred nil) :description &quot;An int or nil. Empty string is transformed to nil.&quot; :type-properties {:decode/string (fn [x] (when-not (string/blank? x) (mtransform/-string-&gt;long x))) :gen/schema [:maybe [:int opts]]}})))"><y>#</y><d>2022-02-22</d><h>19:20</h><w>rovanion</w>This is the schema I ended up with, does both generate, transform and conform as I want it:

<pre>(register! :html/nilable-int                                                                                  
  (malli/-simple-schema                                                                                       
   (fn [opts _]                                                                                               
     {:type            :html/nilable-int                                                                      
      :pred            (some-fn int? nil?)                                                                    
      :property-pred   (malli/-min-max-pred nil)                                                              
      :description     &quot;An int or nil. Empty string is transformed to nil.&quot;                                   
      :type-properties {:decode/string (fn [x] (when-not (string/blank? x)                                    
                                                 (mtransform/-string-&gt;long x)))                               
                        :gen/schema [:maybe [:int opts]]}})))</pre></z><z id="t1645561063" t="oliver marks So been playing a bit more and built up some snippet code to show my issues, the first works as I expect the second part does not seem to transform in the same way and I can not figure out why, can any one lend some assistance ? (def my-spec [:map {:closed true} [:object/type [:keyword {:json-schema/type &quot;keyword&quot; :string-schema/type &quot;keyword&quot;}]]]) (m/decode my-spec {:object/type &quot;test&quot;} mt/json-transformer) ;; =&gt; #:object{:type :test} How ever using this returns an error complaining that objecct/type is not a keyword, I was under the imrpression it should be converted the same as m/decode, so I am obviously missing a trick some where, tried a few things but just can not get it to decode. (reitit.coercion.malli/create {:transformers {:body {:default reitit.coercion.malli/default-transformer-provider :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider &quot;application/transit+json; charset=utf-8&quot; reitit.coercion.malli/json-transformer-provider &quot;application/transit+json&quot; reitit.coercion.malli/json-transformer-provider}} :keyword {:default reitit.coercion.malli/string-transformer-provider} :string {:default reitit.coercion.malli/string-transformer-provider} :response {:default reitit.coercion.malli/default-transformer-provider}}}) "><y>#</y><d>2022-02-22</d><h>20:17</h><w>oliver marks</w>So been playing a bit more and built up some snippet code to show my issues, the first works as I expect the second part does not seem to transform in the same way and I can not figure out why, can any one lend some assistance ?
<pre>(def my-spec
  [:map {:closed true}
   [:object/type [:keyword {:json-schema/type &quot;keyword&quot; :string-schema/type &quot;keyword&quot;}]]])

(m/decode
 my-spec
 {:object/type &quot;test&quot;}
 mt/json-transformer)

;; =&gt; #:object{:type :test}</pre>
How ever using this returns an error complaining that objecct/type is not a keyword, I was under the imrpression it should be converted the same as m/decode, so I am obviously missing a trick some where, tried a few things but just can not get it to decode.
<pre>(reitit.coercion.malli/create
 {:transformers {:body {:default reitit.coercion.malli/default-transformer-provider
                        :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider
                                  &quot;application/transit+json; charset=utf-8&quot; reitit.coercion.malli/json-transformer-provider
                                  &quot;application/transit+json&quot; reitit.coercion.malli/json-transformer-provider}}
                 :keyword {:default reitit.coercion.malli/string-transformer-provider}
                 :string {:default reitit.coercion.malli/string-transformer-provider}
                 :response {:default reitit.coercion.malli/default-transformer-provider}}})</pre>
</z><z id="t1645608314" t="oly just some thoughts in case its related, I am using transit+json because my keys are namespaces this is so they get preserved over the wire"><y>#</y><d>2022-02-23</d><h>09:25</h><w>oly</w>just some thoughts in case its related, I am using transit+json because my keys are namespaces this is so they get preserved over the wire</z><z id="t1645625142" t="lambder hello"><y>#</y><d>2022-02-23</d><h>14:05</h><w>lambder</w>hello</z><z id="t1645625148" t="lambder I tried to apply this https://github.com/metosin/malli/pull/545/files"><y>#</y><d>2022-02-23</d><h>14:05</h><w>lambder</w>I tried to apply this <a href="https://github.com/metosin/malli/pull/545/files" target="_blank">https://github.com/metosin/malli/pull/545/files</a></z><z id="t1645625151" t="lambder in my project"><y>#</y><d>2022-02-23</d><h>14:05</h><w>lambder</w>in my project</z><z id="t1645625174" t="lambder I&apos;ve added zoned-date-time"><y>#</y><d>2022-02-23</d><h>14:06</h><w>lambder</w>I&apos;ve added zoned-date-time</z><z id="t1645625191" t="lambder in some other ns I define schema like: (def ZDT (mt/time-schema :zoned-date-time)) "><y>#</y><d>2022-02-23</d><h>14:06</h><w>lambder</w>in some other ns I define schema like:
<pre>(def ZDT
  (mt/time-schema :zoned-date-time))</pre>
</z><z id="t1645625275" t="lambder then in the reitit router I have malli coercion set and the endpoint has this:"><y>#</y><d>2022-02-23</d><h>14:07</h><w>lambder</w>then in the reitit router I have malli coercion set and the endpoint has this:</z><z id="t1645625304" t="lambder :parameters {:body [:map [:scrape-request [:map [:id int?] [:from-date [:map {:registry #:my-name-space{:zdt :zoned-date-time}} :my-name-space/zdt]]]]]},"><y>#</y><d>2022-02-23</d><h>14:08</h><w>lambder</w><pre>:parameters
  {:body
   [:map
    [:scrape-request
     [:map
      [:id int?]
      [:from-date
       [:map
        {:registry
         #:my-name-space{:zdt :zoned-date-time}}
        :my-name-space/zdt]]]]]},</pre></z><z id="t1645625324" t="lambder but when I try to create the routes I get:"><y>#</y><d>2022-02-23</d><h>14:08</h><w>lambder</w>but when I try to create the routes I get:</z><z id="t1645625344" t="lambder Execution error (ExceptionInfo) at reitit.exception/exception (exception.cljc:19). :malli.core/invalid-schema {:schema :zoned-date-time} {:schema :zoned-date-time}"><y>#</y><d>2022-02-23</d><h>14:09</h><w>lambder</w><pre>Execution error (ExceptionInfo) at reitit.exception/exception (exception.cljc:19).
:malli.core/invalid-schema {:schema :zoned-date-time}

{:schema :zoned-date-time}</pre></z><z id="t1645625349" t="lambder any idea?"><y>#</y><d>2022-02-23</d><h>14:09</h><w>lambder</w>any idea?</z><z id="t1645625441" t="lambder same problem if I don&apos;t use registry"><y>#</y><d>2022-02-23</d><h>14:10</h><w>lambder</w>same problem if I don&apos;t use registry</z><z id="t1645625443" t="lambder :parameters {:body [:map [:scrape-request [:map [:id int?] [:from-date :zoned-date-time]]]]},"><y>#</y><d>2022-02-23</d><h>14:10</h><w>lambder</w><pre>:parameters
  {:body
   [:map
    [:scrape-request
     [:map [:id int?] [:from-date :zoned-date-time]]]]},</pre></z><z id="t1645625465" t="lambder what am I doing wrong?"><y>#</y><d>2022-02-23</d><h>14:11</h><w>lambder</w>what am I doing wrong?</z><z id="t1645625468" t="lambder please?"><y>#</y><d>2022-02-23</d><h>14:11</h><w>lambder</w>please?</z><z id="t1645627531" t="lambder I probably son&apos;t use the default registry correctly. Any hints please?"><y>#</y><d>2022-02-23</d><h>14:45</h><w>lambder</w>I probably son&apos;t use the default registry correctly. Any hints please?</z><z id="t1645628580" t="pithyless Instead of :zoned-date-time try referring directly to your var ZDT"><y>#</y><d>2022-02-23</d><h>15:03</h><r>pithyless</r>Instead of <code>:zoned-date-time</code> try referring directly to your var <code>ZDT</code></z><z id="t1645628671" t="pithyless If you&apos;re using the default registry, you need to make sure it registers :zoned-date-time as a known schema. See: https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/core.cljc#L2371-L2378"><y>#</y><d>2022-02-23</d><h>15:04</h><r>pithyless</r>If you&apos;re using the default registry, you need to make sure it registers <code>:zoned-date-time</code> as a known schema. See:
<a href="https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/core.cljc#L2371-L2378" target="_blank">https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/core.cljc#L2371-L2378</a></z><z id="t1645629699" t="lambder [:attrs {:href &quot;/_/_/users/U05476190&quot;}] thanks, I did small step forward. The route construction no longer fails after I defined the custom registry via :coercion (defn service-routes [] [&quot;/api&quot; {:coercion (reitit.coercion.malli/create (merge reitit.coercion.malli/default-options {:options {:registry (merge (m/default-schemas) (malli-time/time-schemas))}}))"><y>#</y><d>2022-02-23</d><h>15:21</h><r>lambder</r><a>@U05476190</a> thanks, I did small step forward. The route construction no longer fails after I defined the custom registry via <code>:coercion</code>
<pre>(defn service-routes []
  [&quot;/api&quot;
   {:coercion   (reitit.coercion.malli/create
                  (merge reitit.coercion.malli/default-options
                    {:options {:registry (merge
                                           (m/default-schemas)
                                           (malli-time/time-schemas))}}))</pre></z><z id="t1645629713" t="lambder but , on Swagger UI I&apos;m getting:"><y>#</y><d>2022-02-23</d><h>15:21</h><r>lambder</r>but , on Swagger UI I&apos;m getting:</z><z id="t1645629737" t="lambder \"><y>#</y><d>2022-02-23</d><h>15:22</h><r>lambder</r>\</z><z id="t1645629847" t="lambder the swagger.json is: "><y>#</y><d>2022-02-23</d><h>15:24</h><r>lambder</r>the swagger.json is:
<pre></pre></z><z id="t1645629905" t="lambder I &apos;believe it should be: &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;date-time&quot; no?"><y>#</y><d>2022-02-23</d><h>15:25</h><r>lambder</r>I &apos;believe it should be:
<pre>&quot;type&quot;: &quot;string&quot;,
&quot;format&quot;: &quot;date-time&quot; </pre>
no?</z><z id="t1645630029" t="pithyless Sorry, no idea; probably best to ask outside of this thread - I&apos;m not familiar with swagger/malli integration"><y>#</y><d>2022-02-23</d><h>15:27</h><r>pithyless</r>Sorry, no idea; probably best to ask outside of this thread - I&apos;m not familiar with swagger/malli integration</z><z id="t1645630611" t="lambder will try to update https://github.com/metosin/malli/pull/545/files with"><y>#</y><d>2022-02-23</d><h>15:36</h><r>lambder</r>will try to update <a href="https://github.com/metosin/malli/pull/545/files" target="_blank">https://github.com/metosin/malli/pull/545/files</a> with</z><z id="t1645630635" t="lambder malli offers json swagger schema integration"><y>#</y><d>2022-02-23</d><h>15:37</h><r>lambder</r>malli offers json swagger schema integration</z><z id="t1645635917" t="lambder here [:attrs {:href &quot;/_/_/users/UD76SLVB7&quot;}]"><y>#</y><d>2022-02-23</d><h>17:05</h><r>lambder</r>here <a>@ronny</a></z><z id="t1645634372" t="Ronny Løvtangen Thanx [:attrs {:href &quot;/_/_/users/U1Z1M77M5&quot;}] , I was trying to add support for java.time.LocalDate and java.time.Instant to my project, and your post helped me. I added the code from https://github.com/metosin/malli/pull/545/files and imported it to the registry with (defn service-routes [] [&quot;/api&quot; {:coercion (reitit.coercion.malli/create {:options {:registry (merge (m/default-schemas) (malli-time/time-schemas))}}) (I believe the merge with default-options is not necessary, as reitit.coercion.malli/create already does that) I was then able to coerce a string to java.time.LocalDate by specifying the property as: [:mydate {:description &quot;My description&quot; :json-schema/example &quot;2021-11-05&quot;} :local-date] One thing I noticed, was that if I tried to send a non-parsable value, I got Error: Wrong number of args (2) passed to: slakt-service.malli.time/-&amp;gt;error-reporter/-report--28426 By changing (defn -&gt;error-reporter [parser message] (fn -report [value] to (defn -&gt;error-reporter [parser message] (fn -report [value _] I instead got the message &quot;Should be local-date or LocalDate&quot;"><y>#</y><d>2022-02-23</d><h>16:39</h><w>Ronny Løvtangen</w>Thanx <a>@lambder</a>, I was trying to add support for <code>java.time.LocalDate</code> and <code>java.time.Instant</code> to my project, and your post helped me.
I added the code from <a href="https://github.com/metosin/malli/pull/545/files" target="_blank">https://github.com/metosin/malli/pull/545/files</a> and imported it to the registry with
<pre>(defn service-routes []
  [&quot;/api&quot;
   {:coercion   (reitit.coercion.malli/create
                  {:options {:registry (merge
                                           (m/default-schemas)
                                           (malli-time/time-schemas))}})</pre>
(I believe the merge with default-options is not necessary, as <code>reitit.coercion.malli/create</code> already does that)

I was then able to coerce a string to <code>java.time.LocalDate</code> by specifying the property as:

<pre>[:mydate {:description &quot;My description&quot;
          :json-schema/example &quot;2021-11-05&quot;}
 :local-date]</pre>
One thing I noticed, was that if I tried to send a non-parsable value, I got
	
Error: Wrong number of args (2) passed to: slakt-service.malli.time/-&amp;gt;error-reporter/-report--28426

By changing

<pre>(defn -&gt;error-reporter
  [parser message]
  (fn -report [value]</pre>
to
<pre>(defn -&gt;error-reporter
  [parser message]
  (fn -report [value _]</pre>
I instead got the message
<pre>&quot;Should be local-date or LocalDate&quot;</pre></z><z id="t1645635894" t="lambder great stuff, [:attrs {:href &quot;/_/_/users/UD76SLVB7&quot;}]"><y>#</y><d>2022-02-23</d><h>17:04</h><w>lambder</w>great stuff, <a>@ronny</a></z><z id="t1645635909" t="lambder have you seen the massages in the thread?"><y>#</y><d>2022-02-23</d><h>17:05</h><w>lambder</w>have you seen the massages in the thread?</z><z id="t1645635935" t="lambder one thing I&apos;m missing is to make it work with edn request"><y>#</y><d>2022-02-23</d><h>17:05</h><w>lambder</w>one thing I&apos;m missing is to make it work with edn request</z><z id="t1645635941" t="lambder it works with json only"><y>#</y><d>2022-02-23</d><h>17:05</h><w>lambder</w>it works with json only</z><z id="t1645635993" t="lambder I&apos;ll do `(fn -report [value &amp; _] `"><y>#</y><d>2022-02-23</d><h>17:06</h><w>lambder</w>I&apos;ll do
<pre>`(fn -report [value &amp; _]</pre>`</z><z id="t1645635996" t="Ronny Løvtangen Yes. I was also wondering about type vs format. Not an expert on json schema, but looks like you are right"><y>#</y><d>2022-02-23</d><h>17:06</h><w>Ronny Løvtangen</w>Yes. I was also wondering about type vs format. Not an expert on json schema, but looks like you are right</z><z id="t1645636003" t="lambder just in case some other call needs single arity"><y>#</y><d>2022-02-23</d><h>17:06</h><w>lambder</w>just in case some other call needs single arity</z><z id="t1645636201" t="Ronny Løvtangen I also added :json-schema/example: :local-date {:class LocalDate :parser -string-&gt;local-date :json-schema/type :local-date :json-schema/example &quot;2022-02-23&quot;} ... :json-schema/example (:json-schema/example props -name) Then I don’t have to (but could override if I want to) provide example in my schema."><y>#</y><d>2022-02-23</d><h>17:10</h><w>Ronny Løvtangen</w>I also added :json-schema/example:
<pre>:local-date {:class LocalDate :parser -string-&gt;local-date :json-schema/type :local-date :json-schema/example &quot;2022-02-23&quot;}

...

:json-schema/example (:json-schema/example props -name)</pre>
Then I don’t have to (but could override if I want to) provide example in my schema.</z><z id="t1645636258" t="lambder if I don&apos;t supply the example for date-time, the SwaggerUI will get one form me"><y>#</y><d>2022-02-23</d><h>17:10</h><w>lambder</w>if I don&apos;t supply the example for date-time, the SwaggerUI will get one form me</z><z id="t1645636641" t="Ronny Løvtangen If I don’t provide json-schema/example, Swagger will show “Unknown Type: local-date”. Maybe your change to &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;date-time&quot; is what makes Swagger able to provide an example"><y>#</y><d>2022-02-23</d><h>17:17</h><w>Ronny Løvtangen</w>If I don’t provide json-schema/example, Swagger will show “Unknown Type: local-date”.
Maybe your change to
<pre>&quot;type&quot;: &quot;string&quot;,
&quot;format&quot;: &quot;date-time&quot; </pre>
is what makes Swagger able to provide an example</z><z id="t1645636667" t="lambder local-date is not corret"><y>#</y><d>2022-02-23</d><h>17:17</h><w>lambder</w>local-date is not corret</z><z id="t1645636681" t="lambder there is only date and date-time"><y>#</y><d>2022-02-23</d><h>17:18</h><w>lambder</w>there is only date and date-time</z><z id="t1645636689" t="lambder see here https://www.baeldung.com/openapi-dates"><y>#</y><d>2022-02-23</d><h>17:18</h><w>lambder</w>see here <a href="https://www.baeldung.com/openapi-dates" target="_blank">https://www.baeldung.com/openapi-dates</a></z><z id="t1645636714" t="lambder for local dates you probably want to adapt:"><y>#</y><d>2022-02-23</d><h>17:18</h><w>lambder</w>for local dates you probably want to adapt:</z><z id="t1645636716" t="lambder customDate: type: string pattern: &apos;^\d{4}(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])$&apos; description: Custom date example: &quot;20210130&quot;"><y>#</y><d>2022-02-23</d><h>17:18</h><w>lambder</w><pre>customDate: 
  type: string 
  pattern: &apos;^\d{4}(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])$&apos;
  description: Custom date 
  example: &quot;20210130&quot;</pre></z><z id="t1645636988" t="Ronny Løvtangen Isn’t “date” a good fit for java.time.LocalDate? Format yyyy-MM-dd"><y>#</y><d>2022-02-23</d><h>17:23</h><w>Ronny Løvtangen</w>Isn’t “date” a good fit for java.time.LocalDate? Format <code>yyyy-MM-dd</code></z><z id="t1645637016" t="lambder it is"><y>#</y><d>2022-02-23</d><h>17:23</h><w>lambder</w>it is</z><z id="t1645637274" t="Ronny Løvtangen With :local-date {:class LocalDate :parser -string-&gt;local-date :json-schema/type :string :json-schema/format &quot;date&quot;} Swagger provides an example :thumbsup:"><y>#</y><d>2022-02-23</d><h>17:27</h><w>Ronny Løvtangen</w>With
<pre>:local-date {:class LocalDate :parser -string-&gt;local-date :json-schema/type :string :json-schema/format &quot;date&quot;}</pre>
Swagger provides an example <b>:thumbsup:</b></z><z id="t1645637288" t="lambder right"><y>#</y><d>2022-02-23</d><h>17:28</h><w>lambder</w>right</z><z id="t1645637310" t="lambder do you have your app working with edn encoding?"><y>#</y><d>2022-02-23</d><h>17:28</h><w>lambder</w>do you have your app working with edn encoding?</z><z id="t1645637375" t="lambder do I need to provide analog of:"><y>#</y><d>2022-02-23</d><h>17:29</h><w>lambder</w>do I need to provide analog of:</z><z id="t1645637377" t="lambder {:transformers {:body {:default default-transformer-provider :formats {&quot;application/json&quot; json-transformer-provider}} :string {:default string-transformer-provider} :response {:default default-transformer-provider :formats {&quot;application/json&quot; json-transformer-provider}}}"><y>#</y><d>2022-02-23</d><h>17:29</h><w>lambder</w><pre>{:transformers {:body {:default default-transformer-provider
                         :formats {&quot;application/json&quot; json-transformer-provider}}
                  :string {:default string-transformer-provider}
                  :response {:default default-transformer-provider
                             :formats {&quot;application/json&quot; json-transformer-provider}}}</pre></z><z id="t1645637380" t="lambder for edn?"><y>#</y><d>2022-02-23</d><h>17:29</h><w>lambder</w>for edn?</z><z id="t1645637600" t="Ronny Løvtangen No, sorry, haven&apos;t done anything to provide support for edn in our application"><y>#</y><d>2022-02-23</d><h>17:33</h><w>Ronny Løvtangen</w>No, sorry, haven&apos;t done anything to provide support for edn in our application</z><z id="t1645641403" t="lambder when my edn request is:"><y>#</y><d>2022-02-23</d><h>18:36</h><w>lambder</w>when my edn request is:</z><z id="t1645641406" t="lambder { :scrape-request { :id 1 :from-date #time/zoned-date-time &quot;2022-01-01T16:14:34.447Z&quot; } }"><y>#</y><d>2022-02-23</d><h>18:36</h><w>lambder</w><pre>{
  :scrape-request {
    :id 1
    :from-date #time/zoned-date-time &quot;2022-01-01T16:14:34.447Z&quot;
  }
}</pre></z><z id="t1645641430" t="lambder I&apos;m getting:"><y>#</y><d>2022-02-23</d><h>18:37</h><w>lambder</w>I&apos;m getting:</z><z id="t1645641435" t="lambder {:schema &quot;[:map {:closed true} [:scrape-request [:map {:closed true} [:id int?] [:from-date :zoned-date-time]]]]&quot;, :errors ({:path [:scrape-request :from-date], :in [:scrape-request :from-date], :schema &quot;:zoned-date-time&quot;, :value (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;), :message &quot;Should be zoned-date-time or ZonedDateTime&quot;}), :value {:scrape-request {:id 1, :from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)}}, :type :reitit.coercion/request-coercion, :coercion :malli, :in [:request :body-params], :humanized {:scrape-request {:from-date [&quot;Should be zoned-date-time or ZonedDateTime&quot;]}}}"><y>#</y><d>2022-02-23</d><h>18:37</h><w>lambder</w><pre>{:schema &quot;[:map {:closed true} [:scrape-request [:map {:closed true} [:id int?] [:from-date :zoned-date-time]]]]&quot;, :errors ({:path [:scrape-request :from-date], :in [:scrape-request :from-date], :schema &quot;:zoned-date-time&quot;, :value (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;), :message &quot;Should be zoned-date-time or ZonedDateTime&quot;}), :value {:scrape-request {:id 1, :from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)}}, :type :reitit.coercion/request-coercion, :coercion :malli, :in [:request :body-params], :humanized {:scrape-request {:from-date [&quot;Should be zoned-date-time or ZonedDateTime&quot;]}}}</pre></z><z id="t1645641448" t="lambder see: :from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)"><y>#</y><d>2022-02-23</d><h>18:37</h><w>lambder</w>see: <code>:from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)</code></z><z id="t1645641461" t="lambder how on earth this form gets there are all?"><y>#</y><d>2022-02-23</d><h>18:37</h><w>lambder</w>how on earth this form gets there are all?</z><z id="t1645641524" t="lambder this is added to the registry:"><y>#</y><d>2022-02-23</d><h>18:38</h><w>lambder</w>this is added to the registry:</z><z id="t1645641526" t="lambder :zoned-date-time #IntoSchema{:type :zoned-date-time},"><y>#</y><d>2022-02-23</d><h>18:38</h><w>lambder</w><pre>:zoned-date-time #IntoSchema{:type :zoned-date-time},</pre></z><z id="t1645641550" t="lambder using this:"><y>#</y><d>2022-02-23</d><h>18:39</h><w>lambder</w>using this:</z><z id="t1645641553" t="lambder (m/-simple-schema {:type type :type-properties (cond-&gt; {:error/fn error-fn :decode/json {:enter safe-parser} :encode/json {:enter #(prn %)} :json-schema/type (:json-schema/type props -name)} (:json-schema/format props -name) (assoc :json-schema/format (:json-schema/format props -name))) :pred pred})"><y>#</y><d>2022-02-23</d><h>18:39</h><w>lambder</w><pre>(m/-simple-schema
        {:type type
         :type-properties
               (cond-&gt; {:error/fn         error-fn
                        :decode/json      {:enter safe-parser}
                        :encode/json      {:enter #(prn %)}
                        :json-schema/type (:json-schema/type props -name)}
                 (:json-schema/format props -name) (assoc :json-schema/format (:json-schema/format props -name)))
         :pred pred})</pre></z><z id="t1645641610" t="lambder the `safe-parser` is:"><y>#</y><d>2022-02-23</d><h>18:40</h><w>lambder</w><pre>the `safe-parser` is:</pre></z><z id="t1645641620" t="lambder provided by :"><y>#</y><d>2022-02-23</d><h>18:40</h><w>lambder</w>provided by :</z><z id="t1645641630" t="lambder (defn -string-&gt;zoned-date-time [x] (ZonedDateTime/parse x))"><y>#</y><d>2022-02-23</d><h>18:40</h><w>lambder</w><pre>(defn -string-&gt;zoned-date-time [x]
  (ZonedDateTime/parse x))</pre></z><z id="t1645641655" t="lambder so this :from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;) looks a lot like (ZonedDateTime/parse x)"><y>#</y><d>2022-02-23</d><h>18:40</h><w>lambder</w>so this <code>:from-date (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)</code> looks a lot like <code>(ZonedDateTime/parse x)</code></z><z id="t1645641683" t="lambder but instead if being invoked is it passed a a value. How did it happen ?"><y>#</y><d>2022-02-23</d><h>18:41</h><w>lambder</w>but instead if being invoked is it passed a a value. How did it happen ?</z><z id="t1645643759" t="lambder funny thing the value to decoder is coercion.malli is already wrapped with something like this:"><y>#</y><d>2022-02-23</d><h>19:15</h><w>lambder</w>funny thing the value to decoder is coercion.malli is already wrapped with something like this:</z><z id="t1645643763" t="lambder"><y>#</y><d>2022-02-23</d><h>19:16</h><w>lambder</w></z><z id="t1645643870" t="lambder this happens in reitit.coercion by transforming the request to the value"><y>#</y><d>2022-02-23</d><h>19:17</h><w>lambder</w>this happens in reitit.coercion by transforming the request to the value</z><z id="t1645643878" t="lambder"><y>#</y><d>2022-02-23</d><h>19:17</h><w>lambder</w></z><z id="t1645644991" t="juhoteperi [:attrs {:href &quot;/_/_/users/U1Z1M77M5&quot;}] those decode/json transformations aren&apos;t used by coercion here (no coercion really needed for these values) when you are using EDN. As EDN can already represent types, the coercion doesn&apos;t do anything. If you have *data-reader* registered for the #time/zoned-date-time tag (or provided :readers option to muuntaja edn format) the value should be correct and the problem must be with the schema validation (the predicate)."><y>#</y><d>2022-02-23</d><h>19:36</h><w>juhoteperi</w><a>@lambder</a> those decode/json transformations aren&apos;t used by coercion here (no coercion really needed for these values) when you are using EDN. As EDN can already represent types, the coercion doesn&apos;t do anything.

If you have <code>*data-reader*</code> registered for the <code>#time/zoned-date-time</code> tag (or provided <code>:readers</code> option to muuntaja edn format) the value should be correct and the problem must be with the schema validation (the predicate).</z><z id="t1645645130" t="lambder hey [:attrs {:href &quot;/_/_/users/U061V0GG2&quot;}] no, I don&apos;t have the readers supplied to muuntaja sepcially"><y>#</y><d>2022-02-23</d><h>19:38</h><w>lambder</w>hey <a>@juhoteperi</a> no, I don&apos;t have the readers supplied to muuntaja sepcially</z><z id="t1645645136" t="lambder I got ` :muuntaja formats/instance"><y>#</y><d>2022-02-23</d><h>19:38</h><w>lambder</w>I got `
<pre>:muuntaja   formats/instance</pre></z><z id="t1645645167" t="lambder that instance is:"><y>#</y><d>2022-02-23</d><h>19:39</h><w>lambder</w>that instance is:</z><z id="t1645645169" t="lambder (def instance (m/create (-&gt; m/default-options (update-in [:formats &quot;application/transit+json&quot; :decoder-opts] (partial merge time/time-deserialization-handlers)) (update-in [:formats &quot;application/transit+json&quot; :encoder-opts] (partial merge time/time-serialization-handlers)))))"><y>#</y><d>2022-02-23</d><h>19:39</h><w>lambder</w><pre>(def instance
  (m/create
    (-&gt; m/default-options
      (update-in
        [:formats &quot;application/transit+json&quot; :decoder-opts]
        (partial merge time/time-deserialization-handlers))
      (update-in
        [:formats &quot;application/transit+json&quot; :encoder-opts]
        (partial merge time/time-serialization-handlers)))))</pre></z><z id="t1645645173" t="juhoteperi Muuntaja will use *data-readers* , which is already provided by Clojure if you have the readers in a data_readers.clj file somewhere"><y>#</y><d>2022-02-23</d><h>19:39</h><w>juhoteperi</w>Muuntaja will use <code>*data-readers*</code>, which is already provided by Clojure if you have the readers in a <code>data_readers.clj</code> file somewhere</z><z id="t1645645227" t="lambder I do in my core ns ` (time-literals.read-write/print-time-literals-clj!) "><y>#</y><d>2022-02-23</d><h>19:40</h><w>lambder</w>I do in my core ns `
<pre>(time-literals.read-write/print-time-literals-clj!)</pre>
</z><z id="t1645645231" t="juhoteperi But hmm, it could be problem with those data readers, because :value (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;) seems really strange. Looks like the value isn&apos;t the ZonedDateTime instance, but the Clojure form calling that ZonedDateTime/parse method"><y>#</y><d>2022-02-23</d><h>19:40</h><w>juhoteperi</w>But hmm, it  could be problem with those data readers, because <code>:value (. java.time.ZonedDateTime parse &quot;2022-01-01T16:14:34.447Z&quot;)</code> seems really strange. Looks like the value isn&apos;t the ZonedDateTime instance, but the Clojure form calling that ZonedDateTime/parse method</z><z id="t1645645239" t="lambder but not setting it for read"><y>#</y><d>2022-02-23</d><h>19:40</h><w>lambder</w>but not setting it for read</z><z id="t1645645257" t="lambder will get back to it in about 1h30m"><y>#</y><d>2022-02-23</d><h>19:40</h><w>lambder</w>will get back to it in about 1h30m</z><z id="t1645645261" t="lambder need to run now"><y>#</y><d>2022-02-23</d><h>19:41</h><w>lambder</w>need to run now</z><z id="t1645645266" t="juhoteperi &gt; The library includes the magic file data_readers.cljc which Clojure and the Clojurescript compilers() will look for. "><y>#</y><d>2022-02-23</d><h>19:41</h><w>juhoteperi</w>&gt; The library includes the magic file data_readers.cljc which Clojure and the Clojurescript compilers() will look for.
</z><z id="t1645645266" t="lambder thanks for everything"><y>#</y><d>2022-02-23</d><h>19:41</h><w>lambder</w>thanks for everything</z><z id="t1645645296" t="juhoteperi So just including time-literals in the classpath should add data-readers for those tags"><y>#</y><d>2022-02-23</d><h>19:41</h><w>juhoteperi</w>So just including time-literals in the classpath should add data-readers for those tags</z><z id="t1645645466" t="juhoteperi If data-readers are working correctly, if you eval in the REPL {:foo #time/zoned-date-time &quot;2022-01-01T16:14:34.447Z&quot;} you should get the same map back, the tagged value is read to ZonedDateTime instance, and because you have the print method registered, it should be printed out the same way."><y>#</y><d>2022-02-23</d><h>19:44</h><w>juhoteperi</w>If data-readers are working correctly, if you eval in the REPL <code>{:foo #time/zoned-date-time &quot;2022-01-01T16:14:34.447Z&quot;}</code> you should get the same map back, the tagged value is read to ZonedDateTime instance, and because you have the print method registered, it should be printed out the same way.</z><z id="t1645646130" t="lambder In need to add time readers to end/read-string option for it to work"><y>#</y><d>2022-02-23</d><h>19:55</h><w>lambder</w>In need to add time readers to end/read-string option for it to work</z><z id="t1645646169" t="lambder So I guess they are not added to data_readers, but I&apos;ll dbl check"><y>#</y><d>2022-02-23</d><h>19:56</h><w>lambder</w>So I guess they are not added to data_readers, but I&apos;ll dbl check</z><z id="t1645657362" t="lambder [:attrs {:href &quot;/_/_/users/U061V0GG2&quot;}] this is just black magic to me"><y>#</y><d>2022-02-23</d><h>23:02</h><w>lambder</w><a>@juhoteperi</a> this is just black magic to me</z><z id="t1645657367" t="lambder"><y>#</y><d>2022-02-23</d><h>23:02</h><w>lambder</w></z><z id="t1645684873" t="henryw374 [:attrs {:href &quot;/_/_/users/U1Z1M77M5&quot;}] above issue fixed on the latest release - see https://github.com/henryw374/time-literals readme for details. tl;dr it was basically a workaround for a problem with Clojurescript that has taken some time to get fixed - see https://clojure.atlassian.net/browse/CLJS-3294"><y>#</y><d>2022-02-24</d><h>06:41</h><w>henryw374</w><a>@lambder</a> above issue fixed on the latest release - see <a href="https://github.com/henryw374/time-literals" target="_blank">https://github.com/henryw374/time-literals</a> readme for details.

tl;dr it was basically a workaround for a problem with Clojurescript that has taken some time to get fixed - see <a href="https://clojure.atlassian.net/browse/CLJS-3294" target="_blank">https://clojure.atlassian.net/browse/CLJS-3294</a></z><z id="t1645692450" t="lambder [:attrs {:href &quot;/_/_/users/U051B9FU1&quot;}] Thank you !"><y>#</y><d>2022-02-24</d><h>08:47</h><w>lambder</w><a>@henryw374</a> Thank you !</z><z id="t1645695629" t="lambder this worked like a charm 😄"><y>#</y><d>2022-02-24</d><h>09:40</h><w>lambder</w>this worked like a charm <b>😄</b></z><z id="t1645700472" t="rovanion [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I wrote a version of -min-max-pred that can deal with nil being passed to it as I could not figure out an f that could transform nil into a number that would make sense min and max to apply to. If you think you have use for it anywhere in Malli, here it is: (defn -nilable-min-max-pred [f nilable] (fn [{:keys [min max]}] (cond (not (or min max)) nil (and min max f nilable) (fn [x] (if (nil? x) true (let [size (f x)] (&lt;= min size max)))) (and min max f) (fn [x] (let [size (f x)] (&lt;= min size max))) (and min max nilable) (fn [x] (if (nil? x) true (&lt;= min x max))) (and min max) (fn [x] (&lt;= min x max)) (and min f nilable) (fn [x] (if (nil? x) true (&lt;= min (f x)))) (and min f) (fn [x] (&lt;= min (f x))) (and min nilable) (fn [x] (if (nil? x) true (&lt;= min x))) min (fn [x] (&lt;= min x)) (and max f nilable) (fn [x] (if (nil? x) true (&lt;= (f x) max))) (and max f) (fn [x] (&lt;= (f x) max)) (and max nilable) (fn [x] (if (nil? x) true (&lt;= x max))) max (fn [x] (&lt;= x max))))) And its use in my code is just: (register! :html/nilable-int (malli/-simple-schema (fn [opts _] {:type :html/nilable-int :pred (some-fn int? nil?) :property-pred (su/-nilable-min-max-pred nil true) :description &quot;An int or nil. Empty string is transformed to nil.&quot; :type-properties {:decode/string (fn [x] (when-not (string/blank? x) (mtransform/-string-&gt;long x))) :gen/schema [:maybe [:int opts]]}})))"><y>#</y><d>2022-02-24</d><h>11:01</h><w>rovanion</w><a>@ikitommi</a> I wrote a version of <code>-min-max-pred</code> that can deal with <code>nil</code> being passed to it as I could not figure out an <code>f</code> that could transform <code>nil</code> into a number that would make sense min and max to apply to. If you think you have use for it anywhere in Malli, here it is:

<pre>(defn -nilable-min-max-pred [f nilable]
  (fn [{:keys [min max]}]
    (cond
      (not (or min max))    nil
      (and  min max f nilable) (fn [x] (if (nil? x) true (let [size (f x)] (&lt;= min size max))))
      (and  min max f)         (fn [x] (let [size (f x)] (&lt;= min size max)))
      (and min max nilable)    (fn [x] (if (nil? x) true (&lt;= min x max)))
      (and min max)            (fn [x] (&lt;= min x max))
      (and min f nilable)      (fn [x] (if (nil? x) true (&lt;= min (f x))))
      (and min f)              (fn [x] (&lt;= min (f x)))
      (and min nilable)        (fn [x] (if (nil? x) true (&lt;= min x)))
      min                      (fn [x] (&lt;= min x))
      (and max f nilable)      (fn [x] (if (nil? x) true (&lt;= (f x) max)))
      (and max f)              (fn [x] (&lt;= (f x) max))
      (and max nilable)        (fn [x] (if (nil? x) true (&lt;= x max)))
      max                      (fn [x] (&lt;= x max)))))</pre>
And its use in my code is just:

<pre>(register! :html/nilable-int
  (malli/-simple-schema
   (fn [opts _]
     {:type            :html/nilable-int
      :pred            (some-fn int? nil?)
      :property-pred   (su/-nilable-min-max-pred nil true)
      :description     &quot;An int or nil. Empty string is transformed to nil.&quot;
      :type-properties {:decode/string (fn [x] (when-not (string/blank? x)
                                                 (mtransform/-string-&gt;long x)))
                        :gen/schema [:maybe [:int opts]]}})))</pre></z><z id="t1645796091" t="oliver marks so still struggling with transformers not being applied, I am looking at the request chain I can see that :body-params is populated with a namespaced map, how ever in the next steps I get this +:body-params {:object/type &quot;test&quot;}} --- :request--- nil --- :request :reitit.ring.coercion/coerce-exceptions --- {} --- :request :reitit.ring.coercion/coerce-response --- {} --- :response--- {:body {:coercion :malli, :errors ({:in [], :message &quot;invalid type&quot;, :path [], Seems a bit strange that the :in would be blank, I am getting this from a test which I am using to help me figure out my issue also invalid type is not over descriptive in this context seems, any tricks to getting more info from malli on what its doing, or does this help any one give me some suggestions ?"><y>#</y><d>2022-02-25</d><h>13:34</h><w>oliver marks</w>so still struggling with transformers not being applied, I am looking at the request chain I can see that :body-params is populated with a namespaced map,  how ever in the next steps I get this
<pre>+:body-params {:object/type &quot;test&quot;}}

--- :request---

  nil

--- :request :reitit.ring.coercion/coerce-exceptions ---

  {}

--- :request :reitit.ring.coercion/coerce-response ---

  {}

--- :response---

  {:body {:coercion :malli,
          :errors ({:in [],
                    :message &quot;invalid type&quot;,
                    :path [],</pre>
Seems a bit strange that the :in would be blank, I am getting this from a test which I am using to help me figure out my issue also invalid type is not over descriptive in this context seems, any tricks to getting more info from malli on what its doing, or does this help any one give me some suggestions ?</z><z id="t1645797003" t="oliver marks I would also be intrested in a bit more info on this map, https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L110 are there any docs on what going on is :transformers the function that gets applied to produce the body-params ie is it this step which should be converting my strings to keywords based on the schema ?"><y>#</y><d>2022-02-25</d><h>13:50</h><w>oliver marks</w>I would also be intrested in a bit more info on this map, <a href="https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L110" target="_blank">https://github.com/metosin/reitit/blob/198cfda00d20093f3d7b3069e5e902835c396698/modules/reitit-malli/src/reitit/coercion/malli.cljc#L110</a> are there any docs on what going on is :transformers the function that gets applied to produce the body-params ie is it this step which should be converting my strings to keywords based on the schema ?</z><z id="t1645806842" t="Grant Horner Running into a weird issue: I’m getting the following report on a function call in my test suite: {:in [1 0 :foo-id], :message &quot;should be a positive int&quot;, :path [1 0 :foo-id], :schema pos-int?, :value 9218} where, according to the report, the value is in fact a positive integer. The function is expecting a [:sequential [:map [:foo-id pos-int?] [:name string?]]] as an input, and is receiving ({:name &quot;Foo Inc&quot;, :foo-id 9218, :type &quot;security-id&quot;, :value 9218}) as the arg. This correctly passes the call to malli.core/validate , but is failing in my test suite for some reason"><y>#</y><d>2022-02-25</d><h>16:34</h><w>Grant Horner</w>Running into a weird issue: I’m getting the following report on a function call in my test suite:
<pre>{:in [1 0 :foo-id],
   :message &quot;should be a positive int&quot;,
   :path [1 0 :foo-id],
   :schema pos-int?,
   :value 9218}</pre>
where, according to the report, the value is in fact a positive integer. The function is expecting a
<pre>[:sequential [:map [:foo-id pos-int?] [:name string?]]]</pre>
as an input, and is receiving
<pre>({:name &quot;Foo Inc&quot;, :foo-id 9218, :type &quot;security-id&quot;, :value 9218})</pre>
as the arg. This correctly passes the call to <code>malli.core/validate</code> , but is failing in my test suite for some reason</z><z id="t1645807658" t="Grant Horner false alarm. the value is actually a biginteger. maybe the error message could be improved in these cases? perhaps including the value’s type?"><y>#</y><d>2022-02-25</d><h>16:47</h><r>Grant Horner</r>false alarm. the value is actually a biginteger. maybe the error message could be improved in these cases? perhaps including the value’s type?</z><z id="t1645817700" t="oliver marks I may have had a bit of progress, I seem to be able to make it work using application/json in place of application/transit+json I was using the later as cljs-ajax drops the namespace in the keys which I was hoping to avoid. could this be a case of the flow is different for application/transit+json I did add it to the coercsion map like below. {:transformers {:body {:default reitit.coercion.malli/default-transformer-provider :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider &quot;application/transit+json&quot; reitit.coercion.malli/json-transformer-provider}}"><y>#</y><d>2022-02-25</d><h>19:35</h><w>oliver marks</w>I may have had a bit of progress, I seem to be able to make it work using application/json in place of application/transit+json I was using the later as cljs-ajax drops the namespace in the keys which I was hoping to avoid. could this be a case of the flow is different for application/transit+json I did add it to the coercsion map like below.

<pre>{:transformers {:body {:default reitit.coercion.malli/default-transformer-provider
                          :formats {&quot;application/json&quot; reitit.coercion.malli/json-transformer-provider
                                    &quot;application/transit+json&quot; reitit.coercion.malli/json-transformer-provider}}</pre></z><z id="t1645834989" t="sound2gd hi clojurians~ I&apos;m stucking on decoding json from string with malli"><y>#</y><d>2022-02-26</d><h>00:23</h><w>sound2gd</w>hi clojurians~ I&apos;m stucking on decoding json from string  with malli</z><z id="t1645834994" t="sound2gd (require &apos;[malli.core :as m]) (require &apos;[malli.transform :as mt]) (m/decode [:map [:x :string] [:y :int]] &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot; (mt/transformer mt/json-transformer)) ;; =&gt; &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot;"><y>#</y><d>2022-02-26</d><h>00:23</h><w>sound2gd</w><pre>(require &apos;[malli.core :as m])
  (require &apos;[malli.transform :as mt])

  (m/decode [:map
             [:x :string]
             [:y :int]]
            &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot;
            (mt/transformer
             mt/json-transformer))
;; =&gt; &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot;</pre></z><z id="t1645856211" t="Ben Sless Json transformers assume the data is already deserialized"><y>#</y><d>2022-02-26</d><h>06:16</h><r>Ben Sless</r>Json transformers assume the data is already deserialized</z><z id="t1645856229" t="Ben Sless You need a library like jsonista for that"><y>#</y><d>2022-02-26</d><h>06:17</h><r>Ben Sless</r>You need a library like jsonista for that</z><z id="t1645886141" t="sound2gd thanks. finally work out like this"><y>#</y><d>2022-02-26</d><h>14:35</h><r>sound2gd</r>thanks. finally work out like this</z><z id="t1645886147" t="sound2gd (m/decode [:string {:decode/string #(json/decode % true) :encode/string json/encode}] &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot; (mt/transformer mt/strip-extra-keys-transformer mt/default-value-transformer mt/string-transformer))"><y>#</y><d>2022-02-26</d><h>14:35</h><r>sound2gd</r><pre>(m/decode [:string {:decode/string #(json/decode % true)
                      :encode/string json/encode}]
            &quot;{\&quot;x\&quot;: \&quot;aa\&quot;,\&quot;y\&quot;: 3}&quot;
            (mt/transformer
             mt/strip-extra-keys-transformer
             mt/default-value-transformer
             mt/string-transformer))</pre></z><z id="t1646060683" t="rovanion Given a Malli map schema like [:map [:key {:optional true} :int]] , how do I get at the properties assigned the keyword :key in the map when writing a walker? In this example, these are {:optional true} . As you can see in the below example the walker visits all the &quot;values&quot; of the map, in this case just the :int schema, and then out to the :map schema. Is there any way to get to the inbetween step, the &quot;schema&quot; and properties of :key ? (malli/walk [:map [:key {:optional true} :int]] (fn [schema path children options] (println &quot;Schema:&quot; schema) (println &quot;Path:&quot; path) (println &quot;Children:&quot; children) (println &quot;Options:&quot; options) (println &quot;Properties:&quot; (malli/properties schema)) (println))) =&gt; nil ;; Schema: :int ;; Path: [:key] ;; Children: nil ;; Options: nil ;; Properties: nil ;; ;; Schema: [:map [:key {:optional true} :int]] ;; Path: [] ;; Children: [[:key {:optional true} nil]] ;; Options: nil ;; Properties: nil "><y>#</y><d>2022-02-28</d><h>15:04</h><w>rovanion</w>Given a Malli map schema like <code>[:map [:key {:optional true} :int]]</code>, how do I get at the properties assigned the keyword <code>:key</code> in the map when writing a walker? In this example, these are <code>{:optional true}</code>.

As you can see in the below example the walker visits all the &quot;values&quot; of the map, in this case just the <code>:int</code> schema, and then out to the <code>:map</code> schema. Is there any way to get to the inbetween step, the &quot;schema&quot; and properties of <code>:key</code>?

<pre>(malli/walk                                                                                                   
      [:map [:key {:optional true} :int]]                                                                          
      (fn [schema path children options]                                                                           
        (println &quot;Schema:&quot; schema)                                                                                 
        (println &quot;Path:&quot; path)                                                                                     
        (println &quot;Children:&quot; children)                                                                             
        (println &quot;Options:&quot; options)                                                                               
        (println &quot;Properties:&quot; (malli/properties schema))                                                          
        (println))) =&gt; nil 


    ;; Schema: :int                                                                                                 
    ;; Path: [:key]                                                                                                  
    ;; Children: nil                                                                                                 
    ;; Options: nil                                                                                                  
    ;; Properties: nil                                                                                               
    ;;                                                                                                               
    ;; Schema: [:map [:key {:optional true} :int]]                                                                   
    ;; Path: []                                                                                                      
    ;; Children: [[:key {:optional true} nil]]                                                                       
    ;; Options: nil                                                                                                  
    ;; Properties: nil   </pre>
</z><z id="t1646062186" t="ikitommi Would this help? https://cljdoc.org/d/metosin/malli/0.8.3/doc/tips#walking-schema-and-entry-properties"><y>#</y><d>2022-02-28</d><h>15:29</h><r>ikitommi</r>Would this help? <a href="https://cljdoc.org/d/metosin/malli/0.8.3/doc/tips#walking-schema-and-entry-properties" target="_blank">https://cljdoc.org/d/metosin/malli/0.8.3/doc/tips#walking-schema-and-entry-properties</a></z><z id="t1646065354" t="rovanion Ah, okey, so you need to pass {::malli/walk-entry-vals true} ."><y>#</y><d>2022-02-28</d><h>16:22</h><r>rovanion</r>Ah, okey, so you need to pass <code>{::malli/walk-entry-vals true}</code>.</z><z id="t1646065358" t="rovanion Thanks."><y>#</y><d>2022-02-28</d><h>16:22</h><r>rovanion</r>Thanks.</z><z id="t1646078452" t="oliver marks So setup a test case from the example project, https://github.com/olymk2/reitit/commit/6fd0ee5b6d1553cfc25227836b8a3a126b77b5d5 I have added a single param to the malli spec if you just submit the defaults it sends &quot;january&quot; and errors because its not a key my understanding is this should be decoded by the transformer ? is this a bug or something I am not understanding ?"><y>#</y><d>2022-02-28</d><h>20:00</h><w>oliver marks</w>So setup a test case from the example project, <a href="https://github.com/olymk2/reitit/commit/6fd0ee5b6d1553cfc25227836b8a3a126b77b5d5" target="_blank">https://github.com/olymk2/reitit/commit/6fd0ee5b6d1553cfc25227836b8a3a126b77b5d5</a> I have added a single param to the malli spec if you just submit the defaults it sends &quot;january&quot; and errors because its not a key my understanding is this should be decoded by the transformer ? is this a bug or something I am not understanding ?</z><z id="t1646096507" t="vemv Is there a supported way to introspect that the type of the following schema is string? ? [:fn {:description &quot;An ID&quot;} string?] malli.core/type returns :fn for it, which is not as useful. ...`(m/type string?)` does return string? (as a symbol), so I&apos;d say that my expectation is reasonable"><y>#</y><d>2022-03-01</d><h>01:01</h><w>vemv</w>Is there a supported way to introspect that the type of the following schema is <code>string?</code>?

<pre>[:fn {:description &quot;An ID&quot;}
 string?]</pre>
<code>malli.core/type</code> returns <code>:fn</code> for it, which is not as useful.

...`(m/type string?)` does return <code>string?</code> (as a symbol), so I&apos;d say that my expectation is reasonable</z><z id="t1646098615" t="vemv I had some luck with considering this vector to be &quot;just data&quot; but yeah... an official helper would be reassuring"><y>#</y><d>2022-03-01</d><h>01:36</h><r>vemv</r>I had some luck with considering this vector to be &quot;just data&quot; but yeah... an official helper would be reassuring</z><z id="t1646109136" t="Ben Sless My unofficial hot take is fn specs are evil for this very reason"><y>#</y><d>2022-03-01</d><h>04:32</h><r>Ben Sless</r>My unofficial hot take is fn specs are evil for this very reason</z><z id="t1646154948" t="Casey Is it not possible to pass an options map (containing a registry) to malli.util/update-in ? The other functions in that ns take options map, but this one doesn&apos;t appear too. update also lacks an options arg. I can&apos;t use a local registry because I&apos;ve a non-map (primitive) registry."><y>#</y><d>2022-03-01</d><h>17:15</h><w>Casey</w>Is it not possible to pass an options map (containing a registry) to <code>malli.util/update-in</code> ? The other functions in that ns take options map, but this one doesn&apos;t appear too. <code>update</code> also lacks an options arg. I can&apos;t use a local registry because I&apos;ve a non-map (primitive) registry.</z><z id="t1646227143" t="DenisMc Hi, I would like to disallow null bytes in :string fields in my malli schema because Postgres can’t handle them. What is the cleanest way to add this sort of validation? Thanks in advance."><y>#</y><d>2022-03-02</d><h>13:19</h><w>DenisMc</w>Hi, I would like to disallow null bytes in <code>:string</code> fields in my malli schema because Postgres can’t handle them. What is the cleanest way to add this sort of validation? Thanks in advance.</z><z id="t1646228610" t="DenisMc Just looking at this further: I’m running into this null byte generator issue because I need some of my strings to be non-empty, so I’m setting :min (and :max) parameters in Malli, like so: [:my-param [:string {:min 1 :max 5}]] I see that the malli.generator/-string-gen code looks like this: (defn- -string-gen [schema options] (let [{:keys [min max]} (-min-max schema options)] (cond (and min (= min max)) (gen/fmap str/join (gen/vector gen/char min)) (and min max) (gen/fmap str/join (gen/vector gen/char min max)) min (gen/fmap str/join (gen/vector gen/char min (* 2 min))) max (gen/fmap str/join (gen/vector gen/char 0 max)) :else gen/string-alphanumeric))) ..so the generator generates alphanumeric strings if the min or max length are not set, but generates random characters (including non-alphanumeric characters) if the length is set. I’m wondering what the logic is for this? Why does the string length determine what sort of characters are included in the randomly generated strings?"><y>#</y><d>2022-03-02</d><h>13:43</h><w>DenisMc</w>Just looking at this further: I’m running into this null byte generator issue because I need some of my strings to be non-empty, so I’m setting :min (and :max) parameters in Malli, like so:
<pre>[:my-param [:string {:min 1 :max 5}]]</pre>
I see that the malli.generator/-string-gen code looks like this:
<pre>(defn- -string-gen [schema options]
  (let [{:keys [min max]} (-min-max schema options)]
    (cond
      (and min (= min max)) (gen/fmap str/join (gen/vector gen/char min))
      (and min max) (gen/fmap str/join (gen/vector gen/char min max))
      min (gen/fmap str/join (gen/vector gen/char min (* 2 min)))
      max (gen/fmap str/join (gen/vector gen/char 0 max))
      :else gen/string-alphanumeric)))</pre>
..so the generator generates alphanumeric strings if the min or max length are not set, but generates random characters (including non-alphanumeric characters) if the length is set. I’m wondering what the logic is for this? Why does the string length determine what sort of characters are included in the randomly generated strings?</z><z id="t1646395538" t="ingesol Hi! I’m trying to get malli 0.8.4 to generate clj-kondo config for my browser CLJS project, trying this code (ns mynamespace (:require-macros [malli.dev.cljs :as dev])) (defn test-fn &quot;return y when x is larger than 5&quot; {:malli/schema [:=&gt; [:cat :int :keyword] [:maybe :keyword]]} [x y] (when (&lt; 5 x) y)) (dev/start! nil) (test-fn 1 2) Instrumenting seems to work and I’m getting the expected validation error in my browser console, but I’m seeing no clj-kondo config being generated for my function schema, only seeing this in .clj-kondo/metosin/malli-types : {:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}}}"><y>#</y><d>2022-03-04</d><h>12:05</h><w>ingesol</w>Hi! I’m trying to get malli 0.8.4 to generate clj-kondo config for my browser CLJS project, trying this code
<pre>(ns mynamespace
(:require-macros [malli.dev.cljs :as dev]))

(defn test-fn
  &quot;return y when x is larger than 5&quot;
  {:malli/schema [:=&gt;
                  [:cat :int :keyword]
                  [:maybe :keyword]]}
  [x y]
  (when (&lt; 5 x)
    y))

(dev/start! nil)

(test-fn 1 2)</pre>
Instrumenting seems to work and I’m getting the expected validation error in my browser console, but I’m seeing no clj-kondo config being generated for my function schema, only seeing this in <code>.clj-kondo/metosin/malli-types</code>:
<pre>{:linters {:unresolved-symbol {:exclude [(malli.core/=&gt;)]}}}</pre></z><z id="t1646669789" t="dvingo it looks like cljs support broke during a refactor of how function schemas are stored (there is now a map for :clj and one for :cljs) so the kondo data is looking up :clj even in :cljs code: https://github.com/metosin/malli/blob/002d5cbc724e83f07f126d66b19df022859f1cbf/src/malli/clj_kondo.cljc#L179 https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2385 I should have some time over the next few days to send a pr to address this"><y>#</y><d>2022-03-07</d><h>16:16</h><r>dvingo</r>it looks like cljs support broke during a refactor of how function schemas are stored (there is now a map for :clj and one for :cljs)
so the kondo data is looking up :clj even in :cljs code:
<a href="https://github.com/metosin/malli/blob/002d5cbc724e83f07f126d66b19df022859f1cbf/src/malli/clj_kondo.cljc#L179" target="_blank">https://github.com/metosin/malli/blob/002d5cbc724e83f07f126d66b19df022859f1cbf/src/malli/clj_kondo.cljc#L179</a>
<a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2385" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2385</a>

I should have some time over the next few days to send a pr to address this</z><z id="t1646673951" t="ingesol Right, that’s what I suspected too, since the CLJS support was pretty fresh. Thank you so much for looking into it!"><y>#</y><d>2022-03-07</d><h>17:25</h><r>ingesol</r>Right, that’s what I suspected too, since the CLJS support was pretty fresh. Thank you so much for looking into it!</z><z id="t1646409745" t="Martynas M Hey. Is there a way to generate a value from a predefined list of values? Or maybe it&apos;s possible to &quot;remember&quot; previously generated values so that they would be able to be reused to produce random connections (as in DB sense)?"><y>#</y><d>2022-03-04</d><h>16:02</h><w>Martynas M</w>Hey. Is there a way to generate a value from a predefined list of values?
Or maybe it&apos;s possible to &quot;remember&quot; previously generated values so that they would be able to be reused to produce random connections (as in DB sense)?</z><z id="t1646671605" t="ikitommi maybe: (mg/sample [:any {:gen/elements [1 2 3]}]) ; =&gt; (1 1 3 2 1 1 2 1 1 1)"><y>#</y><d>2022-03-07</d><h>16:46</h><r>ikitommi</r>maybe:
<pre>(mg/sample [:any {:gen/elements [1 2 3]}])
; =&gt; (1 1 3 2 1 1 2 1 1 1)</pre></z><z id="t1646410907" t="mafcocinco Simple newbie question: For malli.generator/generate is there a way to force malli to generate all fields, including optional ?"><y>#</y><d>2022-03-04</d><h>16:21</h><w>mafcocinco</w>Simple newbie question: For <code>malli.generator/generate</code> is there a way to force <code>malli</code> to generate all fields, including <code>optional</code>?</z><z id="t1646671515" t="ikitommi at the moment, no. But would be 1-2 extra lines of code: • new option :mg/generate-optional-values • read it here https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L90 - if true always, if false never, default to nil (current) • add a test • document int README"><y>#</y><d>2022-03-07</d><h>16:45</h><r>ikitommi</r>at the moment, no. But would be 1-2 extra lines of code:
• new option <code>:mg/generate-optional-values</code>
• read it here <a href="https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L90" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L90</a> - if <code>true</code> always, if <code>false</code> never, default to <code>nil</code> (current)
• add a test
• document int README</z><z id="t1646506119" t="match37 Using malli 0.8.4, got below error, what did I miss? Appreciate your help! user=&gt; (require &apos;[malli.core :as m ]) nil user=&gt; (def s (-&gt;&gt; [:union [:map [:x :string]] [:schema [:map [:x :int]]]])) #&apos;user/s user=&gt; (m/form s) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136). :malli.core/invalid-schema {:schema :union} user=&gt; (m/validate s {:x &quot;x&quot;}) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136). :malli.core/invalid-schema {:schema :union} "><y>#</y><d>2022-03-05</d><h>18:48</h><w>match37</w>Using malli 0.8.4, got below error, what did I miss? Appreciate your help!
<pre>user=&gt; (require &apos;[malli.core :as m ])
nil

user=&gt; (def s (-&gt;&gt; [:union
                    [:map [:x :string]]
                    [:schema [:map [:x :int]]]]))
#&apos;user/s

user=&gt; (m/form s)
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136).
:malli.core/invalid-schema {:schema :union}

user=&gt; (m/validate s {:x &quot;x&quot;})
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136).
:malli.core/invalid-schema {:schema :union}</pre>
</z><z id="t1646542298" t="match37 answer my own question, I need register some predefined schemas. {:registry (merge (mu/schemas) (m/default-schemas))}"><y>#</y><d>2022-03-06</d><h>04:51</h><r>match37</r>answer my own question, I need register some predefined schemas.
<pre>{:registry (merge (mu/schemas) (m/default-schemas))}</pre></z><z id="t1646661873" t="henrik Is it possible to spec multi arity functions with the experimental Plumatic-style schema? https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-inline-schemas"><y>#</y><d>2022-03-07</d><h>14:04</h><w>henrik</w>Is it possible to spec multi arity functions with the experimental Plumatic-style schema? <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-inline-schemas" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-inline-schemas</a></z><z id="t1646662121" t="ikitommi sure: (mx/defn plus ([x :- :int] x) ([x :- :int, y :- :int] (+ x y)) ([x :- :int, y :- :int, &amp; zs :- [:* :int]] (apply + x y zs)))"><y>#</y><d>2022-03-07</d><h>14:08</h><r>ikitommi</r>sure:
<pre>(mx/defn plus
  ([x :- :int] x)
  ([x :- :int, y :- :int] (+ x y))
  ([x :- :int, y :- :int, &amp; zs :- [:* :int]] (apply + x y zs)))</pre></z><z id="t1646662169" t="henrik Doh, naturally, thank you."><y>#</y><d>2022-03-07</d><h>14:09</h><r>henrik</r>Doh, naturally, thank you.</z><z id="t1646662177" t="ikitommi 👍"><y>#</y><d>2022-03-07</d><h>14:09</h><r>ikitommi</r><b>👍</b></z><z id="t1646745297" t="henrik My head was not screwed on right yesterday. What I meant to ask was, how do I scope a particular return spec to a particular arity. In e.g. Snoop, this is possible since the return spec is part of the arity. In Plumatic, I&apos;m unsure what the syntax is."><y>#</y><d>2022-03-08</d><h>13:14</h><r>henrik</r>My head was not screwed on right yesterday. What I meant to ask was, how do I scope a particular return spec to a particular arity.

In e.g. Snoop, this is possible since the return spec is part of the arity. In Plumatic, I&apos;m unsure what the syntax is.</z><z id="t1646751917" t="ikitommi there is no such thing in the Plumatic Syntax. Thought of adding that after the args-vector, but then it would not be Plumatic Syntax anymore."><y>#</y><d>2022-03-08</d><h>15:05</h><r>ikitommi</r>there is no such thing in the Plumatic Syntax. Thought of adding that after the args-vector, but then it would not be Plumatic Syntax anymore.</z><z id="t1646751955" t="ikitommi I propose to ask this from the plumatic schema gang via an issue, happy to incorporate whatever they think is good, could add my 2 cents in the conversation there"><y>#</y><d>2022-03-08</d><h>15:05</h><r>ikitommi</r>I propose to ask this from the plumatic schema gang via an issue, happy to incorporate whatever they think is good, could add my 2 cents in the conversation there</z><z id="t1646753343" t="ikitommi … and you can do that with non-plumatic syntax already."><y>#</y><d>2022-03-08</d><h>15:29</h><r>ikitommi</r>… and you can do that with non-plumatic syntax already.</z><z id="t1646753453" t="ikitommi (defn f1 &quot;doc&quot; (^{:malli/schema [:=&gt; [:cat :int] :int]} [x] (inc x)) (^{:malli/schema [:=&gt; [:cat :int :int] :int]} [x y] (+ x y))) or (defn f2 &quot;doc&quot; {:malli/schema [:function [:=&gt; [:cat :int] :int] [:=&gt; [:cat :int :int] :int]]} ([x] (inc x)) ([x y] (+ x y)))"><y>#</y><d>2022-03-08</d><h>15:30</h><r>ikitommi</r><pre>(defn f1
  &quot;doc&quot;
  (^{:malli/schema [:=&gt; [:cat :int] :int]} [x] (inc x))
  (^{:malli/schema [:=&gt; [:cat :int :int] :int]} [x y] (+ x y)))</pre>
or
<pre>(defn f2
  &quot;doc&quot;
  {:malli/schema [:function
                  [:=&gt; [:cat :int] :int]
                  [:=&gt; [:cat :int :int] :int]]}
  ([x] (inc x))
  ([x y] (+ x y)))</pre></z><z id="t1646814379" t="henrik I think it would be good to alias the Plumatic macro name to something like &gt;defn as well. Partly because it seems to be a bit of a convention, partly because it makes it possible to refer it without breaking the equivalent in clojure.core."><y>#</y><d>2022-03-09</d><h>08:26</h><r>henrik</r>I think it would be good to alias the Plumatic macro name to something like <code>&gt;defn</code> as well. Partly because it seems to be a bit of a convention, partly because it makes it possible to refer it without breaking the equivalent in clojure.core.</z><z id="t1646814515" t="henrik Regarding arity-specific return specs; to me it makes sense to tack them on to the param vectors. It might even be possible to combine the two: a spec that runs regardless of the arity, and a spec that runs per arity."><y>#</y><d>2022-03-09</d><h>08:28</h><r>henrik</r>Regarding arity-specific return specs; to me it makes sense to tack them on to the param vectors. It might even be possible to combine the two: a spec that runs regardless of the arity, and a spec that runs per arity.</z><z id="t1646819095" t="ikitommi Personally, I really don’t like the &gt;defn s. clojure.test is the only ns that I require macros without namespace alias. mx/defn tells where it is coming from."><y>#</y><d>2022-03-09</d><h>09:44</h><r>ikitommi</r>Personally, I really don’t like the <code>&gt;defn</code>s. <code>clojure.test</code> is the only ns that I require macros without namespace alias. <code>mx/defn</code> tells where it is coming from.</z><z id="t1646819156" t="ikitommi (mx/defn plus :- :int ;; the default, masked by 2 arities? ([x :- :int] :- :int x) ([x :- :int, y :- :int] (+ x y)) ([x :- :int, y :- :int, &amp; zs :- [:* :int]] :- :int (apply + x y zs)))"><y>#</y><d>2022-03-09</d><h>09:45</h><r>ikitommi</r><pre>(mx/defn plus :- :int ;; the default, masked by 2 arities? 
  ([x :- :int] :- :int x)
  ([x :- :int, y :- :int] (+ x y))
  ([x :- :int, y :- :int, &amp; zs :- [:* :int]] :- :int (apply + x y zs)))</pre></z><z id="t1646819222" t="ikitommi starting to be quite verbose. Have asked if Cursive could grey out the schema hints so it would be move visbile"><y>#</y><d>2022-03-09</d><h>09:47</h><r>ikitommi</r>starting to be quite verbose. Have asked if Cursive could grey out the schema hints so it would be move visbile</z><z id="t1646824207" t="henrik &gt; Personally, I really don’t like the &gt;defns Fair enough. I tend to lean towards referring, when it&apos;s canonical or conventional (we decide on one &gt;defn , and overloading it is an error), and &gt;defn has become something of a naming convention among function spec libraries. &gt; verbose Agreed, and it&apos;s also not that easy to make a formatter understand the syntax to begin with. The separate vector approach of Snoop/Guardrails etc. has the advantage of registering as a conventional function in terms of arguments fed to it. By contrast, Plumatic seems like it requires quite a bit of interpretation of syntax, especially when extended in this way. It also has advantages, of course."><y>#</y><d>2022-03-09</d><h>11:10</h><r>henrik</r>&gt; Personally, I really don’t like the &gt;defns
Fair enough. I tend to lean towards referring, when it&apos;s canonical or conventional (we decide on one <code>&gt;defn</code>, and overloading it is an error), and <code>&gt;defn</code> has become something of a naming convention among function spec libraries.

&gt; verbose
Agreed, and it&apos;s also not that easy to make a formatter understand the syntax to begin with. The separate vector approach of Snoop/Guardrails etc. has the advantage of registering as a conventional function in terms of arguments fed to it. By contrast, Plumatic seems like it requires quite a bit of interpretation of syntax, especially when extended in this way. It also has advantages, of course.</z><z id="t1646797995" t="Ryan Tate Hello, Malli looks very cool. Is it possible in Malli to retain values generated during validation like spec/conform and spec/conformer ? Or if not maybe you can think of some Malli-ish way to solve this: I have some expensive validations, for example I accept an xpath as input and validate by compiling it. I don&apos;t want to throw the resulting value away and have to re-generate it later. So I transform (with s/conformer ) the xpath string to a map with a compiled version (object) of it during validation and this map is the result of validation (with s/conform ): (require &apos;[clj-xpath.core :as xpath]) (defn expr-or-nil [maybe-expr] (try (xpath/xp:compile maybe-expr) (catch org.xml.sax.SAXException e) (catch javax.xml.xpath.XPathException e))) (s/def ::xpath (s/and string? (s/conformer (fn [value] {:value value :expr (expr-or-nil value)}) :value) #(:expr %))) (s/conform ::xpath &quot;//a/@href&quot;) ;; {:value &quot;//a/@href&quot;, ;; :expr ;; #object[org.apache.xpath.jaxp.XPathExpressionImpl 0x1aa56eab &quot; I do similar things when I accept regex strings as input - I validate by compiling them with re-pattern in a conformer then I save the output from s/conform for use later. So is it possible to do something like this with Malli? The :decode/math examples in the Value Transformation section of the README.md ( https://github.com/metosin/malli#value-transformation ) seem possibly close? But it&apos;s not clear to me if decode validates. Maybe Malli is trying to keep validation in a different stream from transformation? (I admit I don&apos;t understand the transformation section of the docs very well, particularly when it comes to doing custom functions as opposed to the pre-canned transformers for json and so forth.) Kiitos/thanks for any help"><y>#</y><d>2022-03-09</d><h>03:53</h><w>Ryan Tate</w>Hello, Malli looks very cool.

Is it possible in Malli to retain values generated during validation like <code>spec/conform</code> and <code>spec/conformer</code>? Or if not maybe you can think of some Malli-ish way to solve this:

I have some expensive validations, for example I accept an xpath as input and validate by compiling it. I don&apos;t want to throw the resulting value away and have to re-generate it later. So I transform  (with <code>s/conformer</code>) the xpath string to a map with a compiled version (object) of it during validation and this map is the result of validation (with <code>s/conform</code>):
<pre>(require &apos;[clj-xpath.core :as xpath])

(defn expr-or-nil
  [maybe-expr]
  (try
    (xpath/xp:compile maybe-expr)
    (catch org.xml.sax.SAXException e)
    (catch javax.xml.xpath.XPathException e)))

(s/def ::xpath (s/and string?           
                      (s/conformer (fn [value] {:value value
                                                :expr (expr-or-nil value)})
                                    :value)
                       #(:expr %))) 

(s/conform ::xpath &quot;//a/@href&quot;)
;; {:value &quot;//a/@href&quot;,
;;  :expr
;;  #object[org.apache.xpath.jaxp.XPathExpressionImpl 0x1aa56eab &quot;</pre>
I do similar things when I accept regex strings as input - I validate by compiling them with <code>re-pattern</code> in  a conformer then I save the output from <code>s/conform</code> for use later.

So is it possible to do something like this with Malli? The <code>:decode/math</code> examples in the Value Transformation section of the README.md (<a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a>) seem possibly close? But it&apos;s not clear to me if <code>decode</code> validates.

Maybe Malli is trying to keep validation in a different stream from transformation?

(I admit I don&apos;t understand the transformation section of the docs  very well, particularly when it comes to doing custom functions as opposed to the pre-canned transformers for json and so forth.)

Kiitos/thanks for any help</z><z id="t1646807537" t="ikitommi [:attrs {:href &quot;/_/_/users/U0261B6PG6R&quot;}] you have two models there: a string and a parsed map. With malli, you should describe either the string (source) or the target (a map). If the map presentation is what you expect, describe that and add a decoder from string-&gt;it. A naive impl: (defn expr-or-nil [maybe-expr] (when (= maybe-expr &quot;//a/@href&quot;) identity)) (defn decoder [value] {:value value :expr (expr-or-nil value)}) (def Xpath (m/schema [:map {:decode/string decoder} [:value :string] [:expr fn?]])) (defn coerce [value] (let [decoded (m/decode Xpath value (mt/string-transformer))] (if-not (m/validate Xpath decoded) ::invalid decoded))) (coerce &quot;//a/@href&quot;) ; =&gt; {:value &quot;//a/@href&quot;, :expr #object[clojure.core$identity 0x2c879e65 &quot;"><y>#</y><d>2022-03-09</d><h>06:32</h><w>ikitommi</w><a>@ryantate</a> you have two models there: a string and a parsed map. With malli, you should describe either the string (source) or the target (a map). If the map presentation is what you expect, describe that and add a decoder from string-&gt;it. A naive impl:
<pre>(defn expr-or-nil [maybe-expr]
  (when (= maybe-expr &quot;//a/@href&quot;) identity))

(defn decoder [value]
  {:value value
   :expr (expr-or-nil value)})

(def Xpath
  (m/schema
   [:map {:decode/string decoder}
    [:value :string]
    [:expr fn?]]))

(defn coerce [value]
  (let [decoded (m/decode Xpath value (mt/string-transformer))]
    (if-not (m/validate Xpath decoded)
      ::invalid
      decoded)))

(coerce &quot;//a/@href&quot;)
; =&gt; {:value &quot;//a/@href&quot;, :expr #object[clojure.core$identity 0x2c879e65 &quot;</pre></z><z id="t1646807724" t="ikitommi but yes, the transform and validation are separated. There might be use cases where this is not good, but for most cases, it’s easy to compose the two using public apis. If/when someone finds out a need for one-pass-do-it-all &amp;/ stateful transformers, would like to hear those 😎"><y>#</y><d>2022-03-09</d><h>06:35</h><w>ikitommi</w>but yes, the transform and validation are separated. There might be use cases where this is not good, but for most cases, it’s easy to compose the two using public apis. If/when someone finds out a need for one-pass-do-it-all &amp;/ stateful transformers, would like to hear those <b>😎</b></z><z id="t1646833098" t="Ryan Tate [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Ah thanks for the comprehensive reply!! 👍 string -&gt; compiled-xpath is the goal, the map is just there to allow s/unform which is not essential. In my case I would probably just accept the cost of two passes because I need the xpath compilation in order to validate the string) and also the xpath string needs to be composed into a more complicated validation so I can just do one m/validate call on the larger structure (which can have many xpath strings). So I think the coerce function would be tricky to use. I could just validate all xpath as string in the larger value and then m/validate and m/parse the larger value and then walk it and call coerce on each xpath item but I would have to do that also for regex and anything else that gets compiled - becomes basically building a new validation layer which defeats the point a bit. I did a benchmark and compiling xpath is only about 2 μs and regex is even less so I will just put those checks in the schema so it is part of a compostable validation and then do it again in m/decode . It is a performance hit but a small one, hopefully not too bad 😅"><y>#</y><d>2022-03-09</d><h>13:38</h><w>Ryan Tate</w><a>@ikitommi</a> Ah thanks for the comprehensive reply!! <b>👍</b>

 string -&gt; compiled-xpath is the goal, the map is just there to allow <code>s/unform</code> which is not essential. 

In my case I would probably just accept the cost of two passes because I need the xpath compilation in order to validate the string) and also the xpath string needs to be composed into a more complicated validation so I can just do one <code>m/validate</code> call on the larger structure (which can have many xpath strings). So I think the <code>coerce</code> function would be tricky to use. I could just validate all xpath as string in the larger value and then  <code>m/validate</code> and <code>m/parse</code> the larger value and then walk it and call <code>coerce</code> on each xpath item but I would have to do that also for regex and anything else that gets compiled - becomes basically building a new validation layer which defeats the point a bit. 

I did a benchmark and compiling xpath is only about 2 μs and regex is even less so I will just put those checks in the schema so it is part of a compostable validation and then do it again in <code>m/decode</code>. It is a performance hit but a small one, hopefully not too bad <b>😅</b></z><z id="t1646834118" t="ikitommi oh, if you want to validate the big thing, you could do schema for string, and then m/encode it to the parsed format. there is no easy way to customize m/parse per schema atm."><y>#</y><d>2022-03-09</d><h>13:55</h><r>ikitommi</r>oh, if you want to validate the big thing, you could do schema for string, and then <code>m/encode</code> it to the parsed format. there is no easy way to customize <code>m/parse</code> per schema atm.</z><z id="t1646834165" t="ikitommi for performance, you should use m/validator &amp; m/decoder / m/encoder for MUCH better perf."><y>#</y><d>2022-03-09</d><h>13:56</h><r>ikitommi</r>for performance, you should use <code>m/validator</code> &amp; <code>m/decoder</code> / <code>m/encoder</code> for MUCH better perf.</z><z id="t1646834295" t="ikitommi ;; pure functions, can be cached (def validate (m/validator Xpath)) (def decode (m/decoder Xpath (mt/string-transformer))) (defn coercer [value] (let [decoded (decode value)] (if-not (validate decoded) ::invalid decoded)))"><y>#</y><d>2022-03-09</d><h>13:58</h><r>ikitommi</r><pre>;; pure functions, can be cached
(def validate (m/validator Xpath))
(def decode (m/decoder Xpath (mt/string-transformer)))

(defn coercer [value]
  (let [decoded (decode value)]
    (if-not (validate decoded)
      ::invalid
      decoded)))</pre></z><z id="t1646849928" t="Ryan Tate Issue with :orn schema inside decode . Any idea why this works: (m/decode [:string {:decode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}] &quot;foo&quot; mt/string-transformer) ;;#&quot;foo&quot; But this does not?: (m/decode [:orn [:v vector?] [:re-string [:string {:decode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}]]] &quot;foo&quot; mt/string-transformer) ;;&quot;foo&quot; Is decode meant to work with :orn , :catn , :or , :and etc?"><y>#</y><d>2022-03-09</d><h>18:18</h><w>Ryan Tate</w>Issue with <code>:orn</code> schema inside <code>decode</code>.

Any idea why this works:

<pre>(m/decode  [:string {:decode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}] &quot;foo&quot; mt/string-transformer)
;;#&quot;foo&quot;</pre>
But this does not?:
<pre>(m/decode [:orn [:v vector?] [:re-string [:string {:decode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}]]] &quot;foo&quot; mt/string-transformer)
;;&quot;foo&quot;</pre>

Is <code>decode</code> meant to work with <code>:orn</code>, <code>:catn</code>, <code>:or</code>, <code>:and</code> etc?</z><z id="t1646851878" t="Ryan Tate Actually I think I have mixed up encode and decode . I found this which has helpful definition of differences (maybe later I can make a PR to merge this table into README.md?): https://cljdoc.org/d/metosin/malli/0.8.4/doc/value-transformation decode is for making values valid, encode is to transform valid values into something else. decode will revert value if it does not match the schema per https://clojurians.slack.com/archives/CLDK6MFMK/p1615225531254000 I rewrote this way which works: (m/encode [:orn [:v vector?] [:re-string [:string {:encode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}]]] &quot;foo&quot; mt/string-transformer) ;;#&quot;foo&quot;"><y>#</y><d>2022-03-09</d><h>18:51</h><r>Ryan Tate</r>Actually I think I have mixed up <code>encode</code> and <code>decode</code>.

I found this which has helpful definition of differences (maybe later I can make a PR to merge this table into README.md?):
<a href="https://cljdoc.org/d/metosin/malli/0.8.4/doc/value-transformation" target="_blank">https://cljdoc.org/d/metosin/malli/0.8.4/doc/value-transformation</a>

<code>decode</code> is for making values valid, <code>encode</code> is to transform valid values into something else.

<code>decode</code> will revert value if it does not match the schema per <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1615225531254000" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1615225531254000</a>

I rewrote this way which works:
<pre>(m/encode [:orn [:v vector?] [:re-string [:string {:encode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}]]] &quot;foo&quot; mt/string-transformer)
;;#&quot;foo&quot;</pre></z><z id="t1646894906" t="ikitommi Doc PR most welcome"><y>#</y><d>2022-03-10</d><h>06:48</h><r>ikitommi</r>Doc PR most welcome</z><z id="t1646894960" t="ikitommi Also, a transformation debugger would be nice (and not hard to implement?): would emit which steps are run, in which order and how they change / not the value."><y>#</y><d>2022-03-10</d><h>06:49</h><r>ikitommi</r>Also, a transformation debugger would be nice (and not hard to implement?): would emit which steps are run, in which order and how they change / not the value.</z><z id="t1646853195" t="Ryan Tate Can I combine parse and encode functionality using a single schema? I can parse: (def re-schema [:string {:encode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}]) (def re-w-opts-schema [:and vector? [:catn [:pattern re-schema] [:opts [:* [:enum :i :s :u]]]]]) (def re-maybe-w-opts [:orn [:pattern re-schema] [:pattern-w-opts re-w-opts-schema]]) (m/parse re-maybe-w-opts [&quot;foo&quot; :i]) ;;[:pattern-w-opts {:pattern &quot;foo&quot;, :opts [:i]}] I can encode: (m/encode re-maybe-w-opts [&quot;foo&quot; :i] mt/string-transformer) ;;[#&quot;foo&quot; :i] How to do both and get [:pattern-w-opts {:pattern #&quot;foo&quot;, :opts [:i]}] ?"><y>#</y><d>2022-03-09</d><h>19:13</h><w>Ryan Tate</w>Can I combine <code>parse</code> and <code>encode</code> functionality using a single schema?

I can parse:

<pre>(def re-schema [:string {:encode/string (fn [s] (try (re-pattern s) (catch java.util.regex.PatternSyntaxException e)))}])
(def re-w-opts-schema [:and vector? [:catn [:pattern re-schema] [:opts [:* [:enum :i :s :u]]]]])
(def re-maybe-w-opts [:orn [:pattern re-schema] [:pattern-w-opts re-w-opts-schema]])

(m/parse re-maybe-w-opts [&quot;foo&quot; :i])
;;[:pattern-w-opts {:pattern &quot;foo&quot;, :opts [:i]}]</pre>
I can encode:

<pre>(m/encode re-maybe-w-opts [&quot;foo&quot; :i] mt/string-transformer)
;;[#&quot;foo&quot; :i]</pre>

How to do both and get

<pre>[:pattern-w-opts {:pattern #&quot;foo&quot;, :opts [:i]}]</pre>
?</z><z id="t1646895648" t="ikitommi currently, you can’t combine those and there is no schema property-based extension for parsers, so you could plug in custom logic to parsing. I think you could cal m/parse in a custom encoder :leave yourself?"><y>#</y><d>2022-03-10</d><h>07:00</h><r>ikitommi</r>currently, you can’t combine those and there is no schema property-based extension for parsers, so you could plug in custom logic to parsing. I think you could cal <code>m/parse</code> in a custom encoder <code>:leave</code>yourself?</z><z id="t1646895801" t="ikitommi oh, the branching happens at parse, would not work that way. should add hook to parsing to allow custom steps or somehow mix the two (encode &amp; parse). ideas welcome"><y>#</y><d>2022-03-10</d><h>07:03</h><r>ikitommi</r>oh, the branching happens at parse, would not work that way. should add hook to parsing to allow custom steps or somehow mix the two (encode &amp; parse). ideas welcome</z><z id="t1647271919" t="Ryan Tate Thanks for the reply, going to work on this for a bit. Parsing is more important for my use case than other transforms. Will come back if I have API extension ideas. Kiitos 👍"><y>#</y><d>2022-03-14</d><h>15:31</h><r>Ryan Tate</r>Thanks for the reply, going to work on this for a bit. Parsing is more important for my use case than other transforms. Will come back if I have API extension ideas. Kiitos <b>👍</b></z><z id="t1647725853" t="Phil Jackson I came to ask exactly the same thing. [:attrs {:href &quot;/_/_/users/U0261B6PG6R&quot;}] can you let me know if you come up with something?"><y>#</y><d>2022-03-19</d><h>21:37</h><r>Phil Jackson</r>I came to ask exactly the same thing. <a>@ryantate</a> can you let me know if you come up with something?</z><z id="t1646919606" t="Célio Maybe I’m doing it wrong, but is there a reason why transformers don’t handle enums?"><y>#</y><d>2022-03-10</d><h>13:40</h><w>Célio</w>Maybe I’m doing it wrong, but is there a reason why transformers don’t handle enums?</z><z id="t1646919633" t="Célio An example with malli.transform/json-transformer : (require &apos;[malli.core :as m]) (require &apos;[malli.transform :as mt]) (def schema [:enum {:encode name :decode keyword} :a :b :c]) (m/encode schema :x mt/json-transformer) ;; =&gt; :x (m/decode schema &quot;x&quot; mt/json-transformer) ;; =&gt; &quot;x&quot; Then I created a custom json transformer based on malli.transform/json-transformer where it adds codecs for :enum : (defn my-json-transformer ... (mt/transformer {:name :json :decoders (-&gt; (mt/-json-decoders) ... (assoc :enum mt/-string-&gt;keyword)) :encoders (-&gt; (mt/-json-encoders) (assoc :enum m/-keyword-&gt;string))})) (m/encode schema :x my-json-transformer) ;; =&gt; &quot;x&quot; (m/decode schema &quot;x&quot; my-json-transformer) ;; =&gt; :x"><y>#</y><d>2022-03-10</d><h>13:40</h><r>Célio</r>An example with <code>malli.transform/json-transformer</code>:

<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.transform :as mt])

(def schema [:enum {:encode name :decode keyword} :a :b :c])

(m/encode schema :x mt/json-transformer)
;; =&gt; :x

(m/decode schema &quot;x&quot; mt/json-transformer)
;; =&gt; &quot;x&quot;</pre>
Then I created a custom json transformer based on <code>malli.transform/json-transformer</code> where it adds codecs for <code>:enum</code>:

<pre>(defn my-json-transformer
  ...
  (mt/transformer
    {:name :json
     :decoders (-&gt; (mt/-json-decoders)
                   ...
                   (assoc :enum mt/-string-&gt;keyword))
     :encoders (-&gt; (mt/-json-encoders)
                   (assoc :enum m/-keyword-&gt;string))}))

(m/encode schema :x my-json-transformer)
;; =&gt; &quot;x&quot;

(m/decode schema &quot;x&quot; my-json-transformer)
;; =&gt; :x</pre></z><z id="t1646921341" t="Ben Sless Try decode/json ?"><y>#</y><d>2022-03-10</d><h>14:09</h><r>Ben Sless</r>Try decode/json ?</z><z id="t1646930214" t="Célio Thanks, that works."><y>#</y><d>2022-03-10</d><h>16:36</h><r>Célio</r>Thanks, that works.</z><z id="t1646948479" t="Diego Hello everyone. What’s the best way to use malli for generative testing?"><y>#</y><d>2022-03-10</d><h>21:41</h><w>Diego</w>Hello everyone. What’s the best way to use <code>malli</code> for generative testing?</z><z id="t1647087478" t="Felipe if I’m not mistaken malli’s generators are compatible with clojure.test.check, which is what I’d use https://github.com/clojure/test.check"><y>#</y><d>2022-03-12</d><h>12:17</h><r>Felipe</r>if I’m not mistaken malli’s generators are compatible with clojure.test.check, which is what I’d use <a href="https://github.com/clojure/test.check" target="_blank">https://github.com/clojure/test.check</a></z><z id="t1647108432" t="Diego Thanks [:attrs {:href &quot;/_/_/users/UA2U3KW0L&quot;}] I’ll try that."><y>#</y><d>2022-03-12</d><h>18:07</h><r>Diego</r>Thanks <a>@UA2U3KW0L</a> I’ll try that.</z><z id="t1647083877" t="Adam Helins [:attrs {:href &quot;/_/_/users/UAPP69JUE&quot;}] Edit: sorry, I was struggling with a situation similar to https://github.com/seancorfield/build-clj/issues/7 regarding tools.build and setting a custom registry. I eventually managed, thanks for raising attention on this :thumbsup:"><y>#</y><d>2022-03-12</d><h>11:17</h><w>Adam Helins</w><a>@andres.rodriguezhn</a> Edit: sorry, I was struggling with a situation similar to <a href="https://github.com/seancorfield/build-clj/issues/7" target="_blank">https://github.com/seancorfield/build-clj/issues/7</a> regarding <code>tools.build</code>  and setting a custom registry. I eventually managed, thanks for raising attention on this <b>:thumbsup:</b></z><z id="t1647162502" t="dharrigan Which way is the direction going re: vector vs map syntax?"><y>#</y><d>2022-03-13</d><h>09:08</h><w>dharrigan</w>Which way is the direction going re: vector vs map syntax?</z><z id="t1647162507" t="dharrigan Is map the way forward?"><y>#</y><d>2022-03-13</d><h>09:08</h><w>dharrigan</w>Is map the way forward?</z><z id="t1647170218" t="Ben Sless I&apos;m guessing vector syntax will never go away due to backwards compatibility"><y>#</y><d>2022-03-13</d><h>11:16</h><r>Ben Sless</r>I&apos;m guessing vector syntax will never go away due to backwards compatibility</z><z id="t1647182602" t="valtteri You can pick whichever you prefer."><y>#</y><d>2022-03-13</d><h>14:43</h><r>valtteri</r>You can pick whichever you prefer.</z><z id="t1647182681" t="valtteri If I recall correctly, Tommi mentioned that map syntax is basically sugar over vector syntax"><y>#</y><d>2022-03-13</d><h>14:44</h><r>valtteri</r>If I recall correctly, Tommi mentioned that map syntax is basically sugar over vector syntax</z><z id="t1647183306" t="valtteri Ach, sorry it was the other way around. Map syntax is closer to the internal syntax."><y>#</y><d>2022-03-13</d><h>14:55</h><r>valtteri</r>Ach, sorry it was the other way around. Map syntax is closer to the internal syntax.</z><z id="t1647183477" t="dharrigan :thumbsup:"><y>#</y><d>2022-03-13</d><h>14:57</h><r>dharrigan</r><b>:thumbsup:</b></z><z id="t1647265864" t="Martynas M Hey. What function should I use to parse a string into a number? Let&apos;s say I have this schema: (m/parse :int 15) My initial assumption was that the parse would do the string parsing. But it... doesn&apos;t work at all. How do I make this return 15 : (m/parse :int &quot;15&quot;) Is this the right function to use?"><y>#</y><d>2022-03-14</d><h>13:51</h><w>Martynas M</w>Hey.
What function should I use to parse a string into a number?
Let&apos;s say I have this schema:

<code>(m/parse :int 15)</code>

My initial assumption was that the <code>parse</code> would do the string parsing. But it... doesn&apos;t work at all.
How do I make this return <code>15</code> :
<code>(m/parse :int &quot;15&quot;)</code>

Is this the right function to use?</z><z id="t1647266782" t="ikitommi hi, it’s value transformation in malli, here are the docs: https://github.com/metosin/malli#value-transformation"><y>#</y><d>2022-03-14</d><h>14:06</h><r>ikitommi</r>hi, it’s value transformation  in malli, here are the docs: <a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a></z><z id="t1647272765" t="Martynas M Thanks. That works."><y>#</y><d>2022-03-14</d><h>15:46</h><r>Martynas M</r>Thanks. That works.</z><z id="t1647272832" t="Martynas M Why does parse exist then?"><y>#</y><d>2022-03-14</d><h>15:47</h><r>Martynas M</r>Why does parse exist then?</z><z id="t1647276029" t="ikitommi it&apos;s structural parsing, please read the part from the README. Malli itself uses it for parsing Clojure destructuring syntax to infer schemas from source code."><y>#</y><d>2022-03-14</d><h>16:40</h><r>ikitommi</r>it&apos;s structural parsing, please read the part from the README. Malli itself uses it for parsing Clojure destructuring syntax to infer schemas from source code.</z><z id="t1647278506" t="Ryan Tate Is it possible to combine :and with :cat ? In spec this would be &quot;`&amp;`&quot; (ampersand). I need to check each key with :cat and then the two keys together via a special fn. This works without the :and but once I add the :and and the :fn it fails: (m/validate [:* [:and [:cat :symbol :string] [:fn (fn [[key value]] true)]]] &apos;(regex &quot;foo&quot;)) Ultimate form is going to be like &apos;(regex &quot;foo&quot; xpath &quot;bar&quot; ...) and I want :fn to check each pair. Thanks for any tips."><y>#</y><d>2022-03-14</d><h>17:21</h><w>Ryan Tate</w>Is it possible to combine <code>:and</code> with <code>:cat</code>? In spec this would be &quot;`&amp;`&quot; (ampersand).

I need to check each key with <code>:cat</code> and then the two keys together via a special fn.

This works without the <code>:and</code> but once I add the <code>:and</code> and the <code>:fn</code> it fails:

<pre>(m/validate [:* [:and [:cat :symbol :string] [:fn (fn [[key value]] true)]]]  &apos;(regex &quot;foo&quot;))</pre>
Ultimate form is going to be like

<pre>&apos;(regex &quot;foo&quot; xpath &quot;bar&quot; ...) </pre>
and I want <code>:fn</code> to check each pair.

Thanks for any tips.</z><z id="t1647279412" t="Ryan Tate Ack I don&apos;t think it will work anyway since the :cat does not produce the values for the next predicate as in spec. So even if I could make :and work it&apos;s not gonna give key/value to :fn. Hmm. Not sure how I can accomplish this. Maybe I can parse inside the validation"><y>#</y><d>2022-03-14</d><h>17:36</h><r>Ryan Tate</r>Ack I don&apos;t think it will work anyway since the :cat does not produce the values for the next predicate as in spec. So even if I could make :and work it&apos;s not gonna give key/value to :fn. Hmm. Not sure how I can accomplish this. Maybe I can parse inside the validation</z><z id="t1647279781" t="Ryan Tate OK I solved it like this, the special function is the inner one: (m/validate [:fn (fn [seqn] (every? (fn [[key value]] true) (m/parse [:* [:cat :symbol :string]] seqn)))] &apos;(regex &quot;foo&quot; xpath &quot;bar&quot;)) 👍 If anyone has a better idea just post here 🙃"><y>#</y><d>2022-03-14</d><h>17:43</h><r>Ryan Tate</r>OK I solved it like this, the special function is the inner one:
<pre>(m/validate [:fn (fn [seqn] (every? (fn [[key value]]  true) (m/parse [:* [:cat :symbol :string]] seqn)))] &apos;(regex &quot;foo&quot; xpath &quot;bar&quot;))</pre>
<b>👍</b>

If anyone has a better idea just post here <b>🙃</b></z><z id="t1647280157" t="Ryan Tate In order to make it work and composable with m/parse I think the schema will need to repeat the seqex. So parse will run 2x. Probably will still be faster than spec: [:and [:fn (fn [seqn] (every? (fn [[key value]] true) (m/parse [:* [:cat :symbol :string]] seqn)))] [:* [:cat :symbol :string]]] "><y>#</y><d>2022-03-14</d><h>17:49</h><r>Ryan Tate</r>In order to make it work and composable with <code>m/parse</code> I think the schema will need to repeat the seqex. So parse will run 2x. Probably will still be faster than spec:
<pre>[:and [:fn (fn [seqn] (every? (fn [[key value]] true) (m/parse [:* [:cat :symbol :string]] seqn)))] [:* [:cat :symbol :string]]]</pre>
</z><z id="t1647280786" t="Ryan Tate Would still be nice if :and worked with cat though because then I could match multiple schemas across the same sequence. hmm"><y>#</y><d>2022-03-14</d><h>17:59</h><r>Ryan Tate</r>Would still be nice if <code>:and</code> worked with <code>cat</code> though because then I could match multiple schemas across the same sequence. hmm</z><z id="t1647503159" t="rovanion Does Malli happen to have a shorthand for making a map out of already defined value-specs like clojure.spec&apos;s (s/keys :req-un [:thing/omabob]) ?"><y>#</y><d>2022-03-17</d><h>07:45</h><w>rovanion</w>Does Malli happen to have a shorthand for making a map out of already defined value-specs like clojure.spec&apos;s <code>(s/keys :req-un [:thing/omabob])</code>?</z><z id="t1647503549" t="ikitommi [:map {:registry {&quot;kikka&quot; :int, &quot;kukka&quot; :string}} &quot;kikka&quot; &quot;kukka&quot;]"><y>#</y><d>2022-03-17</d><h>07:52</h><r>ikitommi</r><pre>[:map {:registry {&quot;kikka&quot; :int, &quot;kukka&quot; :string}} &quot;kikka&quot; &quot;kukka&quot;]</pre></z><z id="t1647503588" t="ikitommi e.g. if you have a schema in a registry, you can use the name instead of full entry definition."><y>#</y><d>2022-03-17</d><h>07:53</h><r>ikitommi</r>e.g. if you have a schema in a registry, you can use the name instead of full entry definition.</z><z id="t1647505856" t="rovanion Right, thanks. And if I wanted to make the key in the map unqualified while the entry in the registry is qualified by a namespace, any way around that?"><y>#</y><d>2022-03-17</d><h>08:30</h><r>rovanion</r>Right, thanks. And if I wanted to make the key in the map unqualified while the entry in the registry is qualified by a namespace, any way around that?</z><z id="t1647505885" t="rovanion Well, [:key :ns/key] works of course."><y>#</y><d>2022-03-17</d><h>08:31</h><r>rovanion</r>Well, [:key :ns/key] works of course.</z><z id="t1647512557" t="ikitommi yes, and you can make add entry props too: [:map [::id {:optional true}]] ."><y>#</y><d>2022-03-17</d><h>10:22</h><r>ikitommi</r>yes, and you can make add entry props too: <code>[:map [::id {:optional true}]]</code>.</z><z id="t1647512604" t="ikitommi not sure was adding all that sugar a good idea, made the parser more complex - and slower"><y>#</y><d>2022-03-17</d><h>10:23</h><r>ikitommi</r>not sure was adding all that sugar a good idea, made the parser more complex - and slower</z><z id="t1647525159" t="rovanion Key/entry props I do use, so I appreciate them."><y>#</y><d>2022-03-17</d><h>13:52</h><r>rovanion</r>Key/entry props I do use, so I appreciate them.</z><z id="t1647525470" t="rovanion Is it possible to add properties to an already existing custom type? (def registry (atom {})) (defn register! [type ?schema] (swap! registry assoc type ?schema)) ;; Combine the default registry with our own mutable registry. (mreg/set-default-registry! (mreg/composite-registry (mreg/fast-registry (malli/default-schemas)) (mreg/mutable-registry registry))) (register! :non-empty-string [:string {:min 1}]) (malli/validate :non-empty-string &quot;Bengt&quot;) ;; =&gt; true (malli/validate [:map [:namn :non-empty-string]] {:namn &quot;Bengt&quot;}) ;; =&gt; true (malli/validate [:map [:namn [:non-empty-string {:max 2}]]] {:namn &quot;Bengt&quot;}) ;; Throws: ;; Execution error (IllegalArgumentException) at malli.core/eval15223$fn$G (core.cljc:22). ;; No implementation of method: :-into-schema of protocol: #&apos;malli.core/IntoSchema found for class: clojure\ .lang.PersistentVector ;; While this works: (malli/validate [:map [:namn [:string {:max 2}]]] {:namn &quot;Bengt&quot;}) "><y>#</y><d>2022-03-17</d><h>13:57</h><w>rovanion</w>Is it possible to add properties to an already existing custom type?

<pre>(def registry                                                                                               
  (atom {}))

(defn register! [type ?schema]                                                                              
  (swap! registry assoc type ?schema))

;; Combine the default registry with our own mutable registry.                                              
(mreg/set-default-registry!                                                                                 
 (mreg/composite-registry                                                                                   
    (mreg/fast-registry (malli/default-schemas))                                                            
    (mreg/mutable-registry registry)))


(register! :non-empty-string [:string {:min 1}])
(malli/validate :non-empty-string &quot;Bengt&quot;)
;; =&gt; true                                                                                                  
                                                                                                            
(malli/validate [:map [:namn :non-empty-string]] {:namn &quot;Bengt&quot;})
;; =&gt; true                                                                                                  
(malli/validate [:map [:namn [:non-empty-string {:max 2}]]] {:namn &quot;Bengt&quot;})
;; Throws:                                                                                                  
;; Execution error (IllegalArgumentException) at malli.core/eval15223$fn$G (core.cljc:22).                  
;; No implementation of method: :-into-schema of protocol: #&apos;malli.core/IntoSchema found for class: clojure\
.lang.PersistentVector                                                                                      

;; While this works:                                                                                        
(malli/validate [:map [:namn [:string {:max 2}]]] {:namn &quot;Bengt&quot;})</pre>
</z><z id="t1647536303" t="ikitommi currently no, but would be a ~1 line change, haven’t thought of that use case… please write an issue,"><y>#</y><d>2022-03-17</d><h>16:58</h><r>ikitommi</r>currently no, but would be a ~1 line change, haven’t thought of that use case… please write an issue,</z><z id="t1647657570" t="vinurs hello, i define a date schema, validate it is false, what the correct format is ? (def birthday [:fn {:error/message &quot;wrong birthday format&quot; :description &quot;birthday&quot;} (partial instance? java.time.LocalDate)]) (m/validate birthday &quot;1987-09-06&quot;) =&gt; false "><y>#</y><d>2022-03-19</d><h>02:39</h><w>vinurs</w>hello, i define a date schema, validate it is false, what the correct format is ?
<pre>(def birthday
  [:fn {:error/message &quot;wrong birthday format&quot; :description &quot;birthday&quot;}
   (partial instance? java.time.LocalDate)])
(m/validate birthday &quot;1987-09-06&quot;) =&gt; false</pre>
</z><z id="t1647678973" t="Ben Sless You need to add a decoder and decode before validation"><y>#</y><d>2022-03-19</d><h>08:36</h><r>Ben Sless</r>You need to add a decoder and decode before validation</z><z id="t1647802238" t="ikitommi ((partial instance? java.time.LocalDate) &quot;1987-09-06&quot;) ; =&gt; false"><y>#</y><d>2022-03-20</d><h>18:50</h><r>ikitommi</r><pre>((partial instance? java.time.LocalDate) &quot;1987-09-06&quot;)
; =&gt; false</pre></z><z id="t1647719745" t="esp1 Quick question: what is the purpose of having equivalent predicate and type schemas, e.g. int? and :int ? Is it simply for convenience? Also, i&apos;m noticing that when I validate using :vector I get an error, while when I use vector? it works: (m/validate :vector [1 2 3]) ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136). ; :malli.core/child-error {:type :vector, :properties nil, :children nil, :min 1, :max 1} (m/validate vector? [1 2 3]) true "><y>#</y><d>2022-03-19</d><h>19:55</h><w>esp1</w>Quick question: what is the purpose of having equivalent predicate and type schemas, e.g. <code>int?</code> and <code>:int</code>? Is it simply for convenience?

Also, i&apos;m noticing that when I validate using <code>:vector</code> I get an error, while when I use <code>vector?</code> it works:
<pre>(m/validate :vector [1 2 3])
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136).
; :malli.core/child-error {:type :vector, :properties nil, :children nil, :min 1, :max 1}</pre>
<pre>(m/validate vector? [1 2 3])
true</pre>
</z><z id="t1647719799" t="esp1 this is with malli 0.8.4"><y>#</y><d>2022-03-19</d><h>19:56</h><r>esp1</r>this is with malli 0.8.4</z><z id="t1647802113" t="ikitommi &gt; Is it simply for convenience? yes, for people coming from spec. the predicates will be made optional in the future,"><y>#</y><d>2022-03-20</d><h>18:48</h><r>ikitommi</r>&gt; Is it simply for convenience?
yes, for people coming from spec. the predicates will be made optional in the future,</z><z id="t1647802171" t="ikitommi currently, the :vector expects one child. “vector of anything” would be [:vector :any]"><y>#</y><d>2022-03-20</d><h>18:49</h><r>ikitommi</r>currently, the <code>:vector</code> expects one child. “vector of anything” would be <code>[:vector :any]</code></z><z id="t1647825422" t="steveb8n Also useful if persisting specs to a db which is sometimes useful"><y>#</y><d>2022-03-21</d><h>01:17</h><r>steveb8n</r>Also useful if persisting specs to a db which is sometimes useful</z><z id="t1647908888" t="esp1 cool, thanks for the explanation!"><y>#</y><d>2022-03-22</d><h>00:28</h><r>esp1</r>cool, thanks for the explanation!</z><z id="t1647878788" t="Alex Sky Hello! Is it possible to use malli with compojure + swagger? Couldn’t find any examples. I can only see an option to implement the protocol Coercion"><y>#</y><d>2022-03-21</d><h>16:06</h><w>Alex Sky</w>Hello! Is it possible to use malli with compojure + swagger?  Couldn’t find any examples. I can only see an option to implement the protocol Coercion</z><z id="t1647880352" t="ikitommi Sadly no. Reitit has built-in support for malli"><y>#</y><d>2022-03-21</d><h>16:32</h><r>ikitommi</r>Sadly no. Reitit has built-in support for malli</z><z id="t1647927953" t="Alex Sky Is it related to some kind of restrictions? I’m a little surprised since compojure-api as well retitit and malli are created by metosin :)"><y>#</y><d>2022-03-22</d><h>05:45</h><r>Alex Sky</r>Is it related to some kind of restrictions? I’m a little surprised since compojure-api as well retitit and malli are created by metosin :)</z><z id="t1647929489" t="beders I have a hack to turn a malli spec into a Schema, if that helps"><y>#</y><d>2022-03-22</d><h>06:11</h><r>beders</r>I have a hack to turn a malli spec into a Schema, if that helps</z><z id="t1647929670" t="Alex Sky &gt; I have a hack to turn a malli spec into a Schema, if that helps Yes, could you show me an example?"><y>#</y><d>2022-03-22</d><h>06:14</h><r>Alex Sky</r>&gt;  I have a hack to turn a malli spec into a Schema, if that helps
Yes, could you show me an example?</z><z id="t1647930054" t="beders I haven’t tested that on a compojure-api route yet, but here’s the gist of it: (require &apos;[schema.core :as schema] &apos;[schema.spec.core :as schema.spec] &apos;[schema.spec.leaf :as leaf]) (defn malli-&gt;schema [malli-schema] (reify schema/Schema (spec [this] (leaf/leaf-spec (schema.spec/precondition this (fn [data] (m/validate malli-schema data)) (fn [data] (me/humanize (m/explain malli-schema data)))))) (explain [this] (str &quot;Malli-&gt;Schema:&quot; malli-schema))))"><y>#</y><d>2022-03-22</d><h>06:20</h><r>beders</r>I haven’t tested that on a compojure-api route yet, but here’s the gist of it:
<pre>(require &apos;[schema.core                   :as schema]
         &apos;[schema.spec.core              :as schema.spec]
         &apos;[schema.spec.leaf              :as leaf])

(defn malli-&gt;schema [malli-schema]
  (reify schema/Schema
    (spec [this]
      (leaf/leaf-spec
       (schema.spec/precondition this
                                 (fn [data]
                                   (m/validate malli-schema data))
                                 (fn [data]
                                   (me/humanize (m/explain malli-schema data))))))
    (explain [this]
     (str &quot;Malli-&gt;Schema:&quot; malli-schema))))</pre></z><z id="t1647930083" t="beders but this allows you to use schema like this: (schema/check (malli-&gt;schema [:map [:foo int?] [:bar keyword?]]) {:foo 1 :bar 2}) =&gt; (not {:bar [&quot;should be a keyword&quot;]}) (schema/check (malli-&gt;schema [:map [:foo int?] [:bar keyword?]]) {:foo 1 :bar :humbug})"><y>#</y><d>2022-03-22</d><h>06:21</h><r>beders</r>but this allows you to use schema like this:
<pre>(schema/check 
 (malli-&gt;schema [:map [:foo int?] [:bar keyword?]])
 {:foo 1 :bar 2})
=&gt; (not {:bar [&quot;should be a keyword&quot;]})

(schema/check 
 (malli-&gt;schema [:map [:foo int?] [:bar keyword?]])
 {:foo 1 :bar :humbug})</pre></z><z id="t1647930196" t="beders not perfect, and I’m about to use this in :body and :path-params and see if that works"><y>#</y><d>2022-03-22</d><h>06:23</h><r>beders</r>not perfect, and I’m about to use this in <code>:body</code> and <code>:path-params</code> and see if that works</z><z id="t1647932166" t="Alex Sky Thanks!"><y>#</y><d>2022-03-22</d><h>06:56</h><r>Alex Sky</r>Thanks!</z><z id="t1647902573" t="Godwin Ko is it possible to get the current index of a vector spec, so that I can have different validation logic for the exact nth element?"><y>#</y><d>2022-03-21</d><h>22:42</h><w>Godwin Ko</w>is it possible to get the current index of a vector spec, so that I can have different validation logic for the exact nth element?</z><z id="t1647931242" t="ikitommi no, but use can use sequence schemas for that"><y>#</y><d>2022-03-22</d><h>06:40</h><r>ikitommi</r>no, but use can use sequence schemas for that</z><z id="t1647997320" t="Godwin Ko ok, but it’s a bit clumsy if the validation of a specific item share most but just varies a little bit from the other…… thx a lot for your prompt respond anyway :man-bowing: :skin-tone-2:"><y>#</y><d>2022-03-23</d><h>01:02</h><r>Godwin Ko</r>ok, but it’s a bit clumsy if the validation of a specific item share most but just varies a little bit from the other…… thx a lot for your prompt respond anyway <b>:man-bowing:</b><b>:skin-tone-2:</b></z><z id="t1648013542" t="ikitommi you can also compose with [:and [:vector :int] [:fn (fn [v] (= (nth v 5) 42))]]"><y>#</y><d>2022-03-23</d><h>05:32</h><r>ikitommi</r>you can also compose with <code>[:and [:vector :int] [:fn (fn [v] (= (nth v 5) 42))]]</code></z><z id="t1648015012" t="Godwin Ko got it, i.e. raise one level to apply function spec on the entire vector :thinking_face:"><y>#</y><d>2022-03-23</d><h>05:56</h><r>Godwin Ko</r>got it, i.e. raise one level to apply function spec on the entire vector <b>:thinking_face:</b></z><z id="t1648015183" t="Godwin Ko in our use case, we have vector of maps, using function spec to replace the entire map schema still not that straight forward or desirable…… 😅"><y>#</y><d>2022-03-23</d><h>05:59</h><r>Godwin Ko</r>in our use case, we have vector of maps, using function spec to replace the entire map schema still not that straight forward or desirable…… <b>😅</b></z><z id="t1647951558" t="Nikolas Pafitis I have this schema (def ResourceIdentifier [:schema {:registry {::resource-key :keyword ::path-param [:or :string :int] ::query-params map? ::resource-ident [:cat [:+ [:or [:ref ::path-param] [:ref ::resource-key]]] [:? [:ref ::query-params]]]}} ::resource-ident]) and i get a :malli.core/potentially-recursive-seqex although I don&apos;t see how it&apos;s recursive."><y>#</y><d>2022-03-22</d><h>12:19</h><w>Nikolas Pafitis</w>I have this schema
<pre>(def ResourceIdentifier
  [:schema {:registry
            {::resource-key   :keyword
             ::path-param     [:or :string :int]
             ::query-params   map?
             ::resource-ident [:cat
                               [:+ [:or
                                    [:ref ::path-param]
                                    [:ref ::resource-key]]]
                               [:? [:ref ::query-params]]]}}
   ::resource-ident])</pre>
and i get a <code>:malli.core/potentially-recursive-seqex</code> although I don&apos;t see how it&apos;s recursive.</z><z id="t1647952241" t="ikitommi you should take away the :ref wrapping. :ref is potentially recursive. Using a plain reference value (e.g. ::path-param ) should work ok."><y>#</y><d>2022-03-22</d><h>12:30</h><r>ikitommi</r>you should take away the <code>:ref</code> wrapping. <code>:ref</code> is potentially recursive. Using a plain reference value (e.g. <code>::path-param</code>) should work ok.</z><z id="t1648031809" t="Nikolas Pafitis [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I see, thanks alot."><y>#</y><d>2022-03-23</d><h>10:36</h><r>Nikolas Pafitis</r><a>@U055NJ5CC</a> I see, thanks alot.</z><z id="t1647951949" t="Nikolas Pafitis The equivalent in clojure.spec works fine (s/def ::resource-key keyword?) (s/def ::path-param (s/or :string string? :int int?)) (s/def ::query-params map?) (s/def ::resource-ident (s/cat :path (s/+ (s/or :resource-key ::resource-key :path-param ::path-param)) :query-params (s/? ::query-params)))"><y>#</y><d>2022-03-22</d><h>12:25</h><w>Nikolas Pafitis</w>The equivalent in clojure.spec works fine
<pre>(s/def ::resource-key keyword?)
(s/def ::path-param (s/or :string string? :int int?))
(s/def ::query-params map?)
(s/def ::resource-ident (s/cat :path (s/+ (s/or :resource-key ::resource-key
                                                :path-param ::path-param))
                               :query-params (s/? ::query-params)))</pre></z><z id="t1648035306" t="Carlo I&apos;m looking into trying malli for my next project; is there some generative testing facility (I can&apos;t find it). How do you do generative testing?"><y>#</y><d>2022-03-23</d><h>11:35</h><w>Carlo</w>I&apos;m looking into trying <code>malli</code> for my next project; is there some generative testing facility (I can&apos;t find it). How do you do generative testing?</z><z id="t1648035405" t="dharrigan "><y>#</y><d>2022-03-23</d><h>11:36</h><w>dharrigan</w><code></code></z><z id="t1648035702" t="Carlo thanks [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] , so to check that a function respects the malli spec you have your own thing that generates arbitrary input data and then calls the function?"><y>#</y><d>2022-03-23</d><h>11:41</h><w>Carlo</w>thanks <a>@dharrigan</a>, so to check that a function respects the malli spec you have your own thing that generates arbitrary input data and then calls the function?</z><z id="t1648035750" t="ikitommi what about: https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-checking"><y>#</y><d>2022-03-23</d><h>11:42</h><w>ikitommi</w>what about: <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-checking" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defn-checking</a></z><z id="t1648035805" t="ikitommi If there are some evident tools missing (I think there are), please tell 🙂"><y>#</y><d>2022-03-23</d><h>11:43</h><w>ikitommi</w>If there are some evident tools missing (I think there are), please tell <b>🙂</b></z><z id="t1648035833" t="Carlo yes thanks, I don&apos;t know how I missed this file while googling 😍"><y>#</y><d>2022-03-23</d><h>11:43</h><w>Carlo</w>yes thanks, I don&apos;t know how I missed this file while googling <b>😍</b></z><z id="t1648035884" t="ikitommi also, you can get a test.check generator out of a schema with (malli.generator/generator my-schema) ."><y>#</y><d>2022-03-23</d><h>11:44</h><w>ikitommi</w>also, you can get a <code>test.check</code> generator out of a schema with <code>(malli.generator/generator my-schema)</code>.</z><z id="t1648085577" t="Carlo two follow-up questions: is there a built-in way to (mi/check) only one function? Is there a way to pretty-print the result of (mi/check) ?"><y>#</y><d>2022-03-24</d><h>01:32</h><w>Carlo</w>two follow-up questions: is there a built-in way to <code>(mi/check)</code> only one function? Is there a way to pretty-print the result of <code>(mi/check)</code>?</z><z id="t1648116878" t="Carlo To check just one function from emacs, I ended up doing: (defun med/cider-eval-on-top-level-form (fn-str) (let ((quoted-defn (concat &quot;&apos;&quot; (cider-defun-at-point)))) (cider-interactive-eval (concat &quot;(&quot; fn-str &quot; &quot; quoted-defn &quot;)&quot;)))) (defun malli-check-this () (interactive) (med/cider-eval-on-top-level-form &quot;#(mi/check {:filters [(mi/-filter-var #{(resolve (second %))})]})&quot;))"><y>#</y><d>2022-03-24</d><h>10:14</h><r>Carlo</r>To check just one function from emacs, I ended up doing:
<pre>(defun med/cider-eval-on-top-level-form (fn-str)
  (let ((quoted-defn (concat &quot;&apos;&quot; (cider-defun-at-point))))
    (cider-interactive-eval (concat &quot;(&quot; fn-str &quot; &quot; quoted-defn &quot;)&quot;))))

(defun malli-check-this ()
  (interactive)
  (med/cider-eval-on-top-level-form
   &quot;#(mi/check {:filters [(mi/-filter-var #{(resolve (second %))})]})&quot;))</pre></z><z id="t1648125533" t="Carlo About the (mi/check) pretty-printing issue, I ended up coding my visualization for #portal that looks like this (it happens when I issue the mi/check command, that I bound to a key):"><y>#</y><d>2022-03-24</d><h>12:38</h><w>Carlo</w>About the <code>(mi/check)</code> pretty-printing issue, I ended up coding my visualization for #portal that looks like this (it happens when I issue the <code>mi/check</code> command, that I bound to a key):</z><z id="t1648129264" t="ikitommi Look great! There is malli.dev.pretty for pretty printing things. Could add a handler for check there"><y>#</y><d>2022-03-24</d><h>13:41</h><r>ikitommi</r>Look great! There is <code>malli.dev.pretty</code> for pretty printing things. Could add a handler for check there</z><z id="t1648129843" t="Carlo Thank you! Mostly, the question I had while doing this was, is there a malli spec for the kind of errors that are generated by (mi/check) ? I temporarily shimmed it as: (def check-error (m/schema [:map-of symbol? [:map [:errors [:sequential [:map [:check [:map [:malli.generator/explain-output :any]]]]]]]])) but maybe you have something more complete. Btw, I&apos;m really liking malli, it&apos;s really well designed! 😍"><y>#</y><d>2022-03-24</d><h>13:50</h><r>Carlo</r>Thank you! Mostly, the question I had while doing this was, is there a malli spec for the kind of errors that are generated by <code>(mi/check)</code>?
I temporarily shimmed it as:
<pre>(def check-error
  (m/schema
   [:map-of symbol? [:map
                     [:errors [:sequential
                               [:map
                                [:check [:map
                                         [:malli.generator/explain-output :any]]]]]]]])) </pre>
but maybe you have something more complete. Btw, I&apos;m really liking malli, it&apos;s really well designed! <b>😍</b></z><z id="t1648131738" t="ikitommi thanks! there is no schema for it, but could be, PR welcome."><y>#</y><d>2022-03-24</d><h>14:22</h><r>ikitommi</r>thanks! there is no schema for it, but could be, PR welcome.</z><z id="t1648139103" t="rovanion Is the following untrue because what&apos;s compared is just the addresses in the references? (deftest optionalize-db-generated-keys (= (malli.util/optional-keys [:map [:key [:int]]]) (malli/schema [:map [:key {:optional true} [:int]]])))"><y>#</y><d>2022-03-24</d><h>16:25</h><w>rovanion</w>Is the following untrue because what&apos;s compared is just the addresses in the references?

<pre>(deftest optionalize-db-generated-keys
  (= (malli.util/optional-keys [:map [:key [:int]]])
     (malli/schema [:map [:key {:optional true} [:int]]])))</pre></z><z id="t1648140883" t="ikitommi Recall there is mu/equals , using just form checking. Could be improved..."><y>#</y><d>2022-03-24</d><h>16:54</h><r>ikitommi</r>Recall there is <code>mu/equals</code>, using just form checking. Could be improved...</z><z id="t1648140142" t="Carlo I asked this quite some time ago, and IIRC at the time it wasn&apos;t possible: what&apos;s the way of writing a spec for the function (defn add [x y] ...) so that we check that the result is bigger than both x and y ?"><y>#</y><d>2022-03-24</d><h>16:42</h><w>Carlo</w>I asked this quite some time ago, and IIRC at the time it wasn&apos;t possible: what&apos;s the way of writing a spec for the function <code>(defn add [x y] ...)</code> so that we check that the result is bigger than both <code>x</code> and <code>y</code>?</z><z id="t1648140819" t="Carlo oh yeah I found a relevant issue https://github.com/metosin/malli/issues/608"><y>#</y><d>2022-03-24</d><h>16:53</h><w>Carlo</w>oh yeah I found a relevant issue <a href="https://github.com/metosin/malli/issues/608" target="_blank">https://github.com/metosin/malli/issues/608</a></z><z id="t1648141917" t="Carlo [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I see that https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2443-L2445 is the place in which the function is instrumented, and that&apos;s probably where a check for the new :fn key of :=&gt; should go. But what else should be changed?"><y>#</y><d>2022-03-24</d><h>17:11</h><r>Carlo</r><a>@U055NJ5CC</a> I see that <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2443-L2445" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2443-L2445</a> is the place in which the function is instrumented, and that&apos;s probably where a check for the new <code>:fn</code> key of <code>:=&gt;</code> should go. But what else should be changed?</z><z id="t1648171314" t="ambrosebs I recently added static type checking for malli schemas to Typed Clojure, here&apos;s a writeup on how to do it https://github.com/typedclojure/typedclojure/tree/main/example-projects/malli-type-providers"><y>#</y><d>2022-03-25</d><h>01:21</h><w>ambrosebs</w>I recently added static type checking for malli schemas to Typed Clojure, here&apos;s a writeup on how to do it <a href="https://github.com/typedclojure/typedclojure/tree/main/example-projects/malli-type-providers" target="_blank">https://github.com/typedclojure/typedclojure/tree/main/example-projects/malli-type-providers</a></z></g><g id="s23"><z id="t1648192477" t="Karol Wójcik Oh Yeah!"><y>#</y><d>2022-03-25</d><h>07:14</h><r>Karol Wójcik</r>Oh Yeah!</z><z id="t1648202946" t="Ben Sless How does it interface with custom registries and custom schemas?"><y>#</y><d>2022-03-25</d><h>10:09</h><r>Ben Sless</r>How does it interface with custom registries and custom schemas?</z><z id="t1648208551" t="juhoteperi Cool! What is the tooling like nowadays? Does it require REPL (so it is one the same classpath as the running app) or could it be integrated into clojure-lsp?"><y>#</y><d>2022-03-25</d><h>11:42</h><r>juhoteperi</r>Cool!

What is the tooling like nowadays?

Does it require REPL (so it is one the same classpath as the running app) or could it be integrated into clojure-lsp?</z><z id="t1648219068" t="ambrosebs [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] it&apos;s a https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L196 right now for custom schemas, a big case . Could probably be a multimethod, do you have an example of a custom schema to help me understand the design space? And custom registries, I&apos;m not sure how far it gets me, but I use m/-deref when I find a :ref . That should be enough?"><y>#</y><d>2022-03-25</d><h>14:37</h><r>ambrosebs</r><a>@UK0810AQ2</a> it&apos;s a <a href="https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L196" target="_blank">https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L196</a> right now for custom schemas, a big <code>case</code>. Could probably be a multimethod, do you have an example of a custom schema to help me understand the design space? And custom registries, I&apos;m not sure how far it gets me, but I use <code>m/-deref</code> when I find a <code>:ref</code>. That should be enough?</z><z id="t1648219122" t="ambrosebs [:attrs {:href &quot;/_/_/users/U061V0GG2&quot;}] requires a REPL since it macroexpands code."><y>#</y><d>2022-03-25</d><h>14:38</h><r>ambrosebs</r><a>@U061V0GG2</a> requires a REPL since it macroexpands code.</z><z id="t1648219163" t="ambrosebs Maybe if we create a custom macro rule for every macro in clojure.core we can think of a clojure-lsp version."><y>#</y><d>2022-03-25</d><h>14:39</h><r>ambrosebs</r>Maybe if we create a custom macro rule for every macro in clojure.core we can think of a clojure-lsp version.</z><z id="t1648219199" t="Ben Sless A good example of custom schemas would be for time types, such as https://github.com/metosin/malli/pull/545 Similarly for other iterop-y parse-y things, like valid URIs"><y>#</y><d>2022-03-25</d><h>14:39</h><r>Ben Sless</r>A good example of custom schemas would be for time types, such as <a href="https://github.com/metosin/malli/pull/545" target="_blank">https://github.com/metosin/malli/pull/545</a>
Similarly for other iterop-y parse-y things, like valid URIs</z><z id="t1648219458" t="ambrosebs ok, I think we need something like (defmethod malli-&gt;Type :local-date [_] &apos;java.time.LocalTime) ."><y>#</y><d>2022-03-25</d><h>14:44</h><r>ambrosebs</r>ok, I think we need something like <code>(defmethod malli-&gt;Type :local-date [_] &apos;java.time.LocalTime)</code> .</z><z id="t1648219527" t="ambrosebs Maybe if the :class were propagated to the schema itself it would be even simpler."><y>#</y><d>2022-03-25</d><h>14:45</h><r>ambrosebs</r>Maybe if the <code>:class</code> were propagated to the schema itself it would be even simpler.</z><z id="t1648219855" t="Ben Sless So if those schemas had a way to query their backing class it would make it easier to participate in typed.clojure?"><y>#</y><d>2022-03-25</d><h>14:50</h><r>Ben Sless</r>So if those schemas had a way to query their backing class it would make it easier to participate in typed.clojure?</z><z id="t1648219974" t="ambrosebs in the simplest cases, yes. Is a &quot;simple schema&quot; usually tied to a class?"><y>#</y><d>2022-03-25</d><h>14:52</h><r>ambrosebs</r>in the simplest cases, yes. Is a &quot;simple schema&quot; usually tied to a class?</z><z id="t1648220038" t="Ben Sless No, but I could petition for something like &quot;simple class schema&quot; which could back various boring data classes"><y>#</y><d>2022-03-25</d><h>14:53</h><r>Ben Sless</r>No, but I could petition for something like &quot;simple class schema&quot; which could back various boring data classes</z><z id="t1648220107" t="Ben Sless And maybe add in malli a protocol for accessing those"><y>#</y><d>2022-03-25</d><h>14:55</h><r>Ben Sless</r>And maybe add in malli a protocol for accessing those</z><z id="t1648220140" t="ambrosebs that sounds perfect."><y>#</y><d>2022-03-25</d><h>14:55</h><r>ambrosebs</r>that sounds perfect.</z><z id="t1648220432" t="ambrosebs Can you think of any custom registry case that might be problematic? I just call m/deref to convert the entire schema eagerly."><y>#</y><d>2022-03-25</d><h>15:00</h><r>ambrosebs</r>Can you think of any custom registry case that might be problematic? I just call <code>m/deref</code> to convert the entire schema eagerly.</z><z id="t1648220493" t="Ben Sless Recursive schemas?"><y>#</y><d>2022-03-25</d><h>15:01</h><r>Ben Sless</r>Recursive schemas?</z><z id="t1648220544" t="ambrosebs ah yep, I handle those https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L236"><y>#</y><d>2022-03-25</d><h>15:02</h><r>ambrosebs</r>ah yep, I handle those <a href="https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L236" target="_blank">https://github.com/typedclojure/typedclojure/blob/4818f27a4661262b0d8268a6b00bd0363b02dba0/typed/malli/src/typed/malli/parse_type.clj#L236</a></z><z id="t1648220594" t="Ben Sless Should be fine How about dependent schemas?"><y>#</y><d>2022-03-25</d><h>15:03</h><r>Ben Sless</r>Should be fine
How about dependent schemas?</z><z id="t1648220614" t="ambrosebs Example?"><y>#</y><d>2022-03-25</d><h>15:03</h><r>ambrosebs</r>Example?</z><z id="t1648220722" t="Ben Sless https://github.com/metosin/malli#content-dependent-simple-schema"><y>#</y><d>2022-03-25</d><h>15:05</h><r>Ben Sless</r><a href="https://github.com/metosin/malli#content-dependent-simple-schema" target="_blank">https://github.com/metosin/malli#content-dependent-simple-schema</a></z><z id="t1648220862" t="ambrosebs probably would need a custom m/type dispatch in the (future) malli-&gt;Type multimethod."><y>#</y><d>2022-03-25</d><h>15:07</h><r>ambrosebs</r>probably would need a custom <code>m/type</code> dispatch in the (future) <code>malli-&gt;Type</code> multimethod.</z><z id="t1648221041" t="ambrosebs another way these simple schemas could be automated is if Typed Clojure could know the var backing the :pred . eg., pos-int? here"><y>#</y><d>2022-03-25</d><h>15:10</h><r>ambrosebs</r>another way these simple schemas could be automated is if Typed Clojure could know the var backing the <code>:pred</code>. eg., pos-int? here</z><z id="t1648221062" t="ambrosebs because the checker has the annotations for these preds"><y>#</y><d>2022-03-25</d><h>15:11</h><r>ambrosebs</r>because the checker has the annotations for these preds</z><z id="t1648221168" t="ambrosebs but there&apos;s a lot of info in the json-schema props too."><y>#</y><d>2022-03-25</d><h>15:12</h><r>ambrosebs</r>but there&apos;s a lot of info in the <code>json-schema</code> props too.</z><z id="t1648221368" t="ambrosebs perhaps a :type-properties :typedclojure/type convention might be useful too."><y>#</y><d>2022-03-25</d><h>15:16</h><r>ambrosebs</r>perhaps a <code>:type-properties :typedclojure/type</code> convention might be useful too.</z><z id="t1648229013" t="ikitommi this is great 🙂"><y>#</y><d>2022-03-25</d><h>17:23</h><r>ikitommi</r>this is great <b>🙂</b></z><z id="t1648244506" t="ambrosebs thanks Tommi 🙂"><y>#</y><d>2022-03-25</d><h>21:41</h><r>ambrosebs</r>thanks Tommi <b>🙂</b></z><z id="t1648228785" t="ikitommi welcome .pretty/prettifier , thanks [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] for the idea. Using it to create pretty checker: (require &apos;[malli.instrument :as mi]) (require &apos;[malli.dev.pretty :as pretty]) (defn check &quot;check that emits pretty results&quot; ([] (check nil)) ([options] ((pretty/prettifier ::check &quot;Check Error&quot; (fn [] (mi/check)) options)))) Dummy pretty printer for :: check: (defmethod v/-format ::check [_ _ results printer] {:body (-&gt;&gt; (for [[f error] results :let [{:keys [schema errors]} error explanation (-&gt; errors first :check :malli.generator/explain-output)]] [:group (pretty/-block &quot;When calling:&quot; (v/-visit (-&gt; errors first :check :smallest first (conj f)) printer) printer) :break :break (pretty/-block &quot;We get:&quot; (v/-visit (:value explanation) printer) printer) :break :break (pretty/-block &quot;The problem is that:&quot; (v/-visit (me/humanize explanation) printer) printer) :break :break (pretty/-block &quot;Schema:&quot; (v/-visit schema printer) printer)]) (interpose [:group (v/-color :title-dark (apply str (take 30 (repeat &quot;-&quot;))) printer) :break :break]) (into [:group]))}) in action: (check) "><y>#</y><d>2022-03-25</d><h>17:19</h><w>ikitommi</w>welcome <code>.pretty/prettifier</code>, thanks <a>@meditans</a> for the idea.

Using it to create pretty checker:
<pre>(require &apos;[malli.instrument :as mi])
(require &apos;[malli.dev.pretty :as pretty])

(defn check
  &quot;check that emits pretty results&quot;
  ([] (check nil))
  ([options] ((pretty/prettifier ::check &quot;Check Error&quot; (fn [] (mi/check)) options))))</pre>
Dummy pretty printer for <b>::</b>check:
<pre>(defmethod v/-format ::check [_ _ results printer]
  {:body (-&gt;&gt; (for [[f error] results
                    :let [{:keys [schema errors]} error
                          explanation (-&gt; errors first :check :malli.generator/explain-output)]]
                [:group
                 (pretty/-block &quot;When calling:&quot; (v/-visit (-&gt; errors first :check :smallest first (conj f)) printer) printer) :break :break
                 (pretty/-block &quot;We get:&quot; (v/-visit (:value explanation) printer) printer) :break :break
                 (pretty/-block &quot;The problem is that:&quot; (v/-visit (me/humanize explanation) printer) printer) :break :break
                 (pretty/-block &quot;Schema:&quot; (v/-visit schema printer) printer)])
              (interpose [:group (v/-color :title-dark (apply str (take 30 (repeat &quot;-&quot;))) printer) :break :break])
              (into [:group]))})</pre>
in action:
<pre>(check) </pre></z><z id="t1648228880" t="ikitommi the actual printer is silly here, should separate the input &amp; output schema problems, looking forward to seeing what you [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] cooked up for this."><y>#</y><d>2022-03-25</d><h>17:21</h><r>ikitommi</r>the actual printer is silly here, should separate the input &amp; output schema problems, looking forward to seeing what you <a>@meditans</a> cooked up for this.</z><z id="t1648228988" t="ikitommi but, the core-lib support pretty-anything now. the helper looks like: (defn prettifier [type title f options] (let [printer (assoc (or (::printer options) (assoc (-printer) :width 60)) :title title) actor (::actor options reporter)] (fn [&amp; args] (when-let [res (apply f args)] ((actor printer) type res) res))))"><y>#</y><d>2022-03-25</d><h>17:23</h><r>ikitommi</r>but, the core-lib support pretty-anything now. the helper looks like:
<pre>(defn prettifier [type title f options]
  (let [printer (assoc (or (::printer options) (assoc (-printer) :width 60)) :title title)
        actor (::actor options reporter)]
    (fn [&amp; args] (when-let [res (apply f args)] ((actor printer) type res) res))))</pre></z><z id="t1648237538" t="Carlo I am in fact still at a prototype stage re: precise messages (and I mainly produce hiccup to pass to #portal, which I&apos;m trying to turn in my repl for visualization). But I&apos;ll definitely try this out and upstream improvements if I end up making them for myself. I have to say, ideally for me, this prettified error message would be more usable in the form of a data structure (from which I can generate hiccup). But I can as well keep producing it myself from the error!"><y>#</y><d>2022-03-25</d><h>19:45</h><r>Carlo</r>I am in fact still at a prototype stage re: precise messages (and I mainly produce hiccup to pass to #portal, which I&apos;m trying to turn in my repl for visualization). But I&apos;ll definitely try this out and upstream improvements if I end up making them for myself.

I have to say, ideally for me, this prettified error message would be more usable in the form of a data structure (from which I can generate hiccup). But I can as well keep producing it myself from the error!</z><z id="t1648240436" t="ikitommi I think a shared function of check-explanation to some intermediate map would be good and could be used by both the malli pretty-printer and your portal visualizer."><y>#</y><d>2022-03-25</d><h>20:33</h><r>ikitommi</r>I think a shared function of check-explanation to some intermediate map would be good and could be used by both the malli pretty-printer and your portal visualizer.</z><z id="t1648309671" t="Carlo I got an error about trying to import malli.instrument in cljs, and in fact I see that in the malli repo we have only a instrument.clj file. Does this mean that I can&apos;t do instrumentation in cljs?"><y>#</y><d>2022-03-26</d><h>15:47</h><w>Carlo</w>I got an error about trying to import <code>malli.instrument</code> in cljs, and in fact I see that in the <code>malli</code> repo we have only a <code>instrument.clj</code> file. Does this mean that I can&apos;t do instrumentation in cljs?</z><z id="t1648327319" t="ambrosebs have you tried malli.instrument.cljs? It&apos;s apparently seen some bugfixes since the last release so I don&apos;t know if it works, but I happened upon it a few days ago https://github.com/metosin/malli/blob/master/src/malli/instrument/cljs.clj"><y>#</y><d>2022-03-26</d><h>20:41</h><r>ambrosebs</r>have you tried malli.instrument.cljs? It&apos;s apparently seen some bugfixes since the last release so I don&apos;t know if it works, but I happened upon it a few days ago <a href="https://github.com/metosin/malli/blob/master/src/malli/instrument/cljs.clj" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/instrument/cljs.clj</a></z><z id="t1648328187" t="Carlo Thank you, you&apos;re right! Here&apos;s how I missed that: I looked at this folder https://github.com/metosin/malli/tree/master/src/malli and I could only find the clj version. So I wrongly assumed that was the only available possibility!"><y>#</y><d>2022-03-26</d><h>20:56</h><r>Carlo</r>Thank you, you&apos;re right! Here&apos;s how I missed that: I looked at this folder <a href="https://github.com/metosin/malli/tree/master/src/malli" target="_blank">https://github.com/metosin/malli/tree/master/src/malli</a> and I could only find the <code>clj</code> version. So I wrongly assumed that was the only available possibility!</z><z id="t1648328237" t="Carlo How does the naming schema in the instrument folder work? I have never seen something like this!"><y>#</y><d>2022-03-26</d><h>20:57</h><r>Carlo</r>How does the naming schema in the <code>instrument</code> folder work? I have never seen something like this!</z><z id="t1648348139" t="ambrosebs I&apos;m guessing that malli.instrument contains functions for the clojure impl. the cljs impl must be implemented via macros (but otherwise with the same names), so a new namespace malli.instrument.cljs was created."><y>#</y><d>2022-03-27</d><h>02:28</h><r>ambrosebs</r>I&apos;m guessing that <code>malli.instrument</code> contains functions for the clojure impl. the cljs impl must be implemented via macros (but otherwise with the same names), so a new namespace <code>malli.instrument.cljs</code> was created.</z><z id="t1648412381" t="Carlo I&apos;m still getting this at times, though: ------ REPL Error while processing --------------------------------------------- (ns couperin.user (:require [portal.web :as p] [malli.core :as m] [malli.instrument :as mi] [malli.dev :as dev])) The required namespace &quot;malli.instrument&quot; is not available, it was required by &quot;couperin/user.cljs&quot;. &quot;malli/instrument.clj&quot; was found on the classpath. Maybe this library only supports CLJ?"><y>#</y><d>2022-03-27</d><h>20:19</h><r>Carlo</r>I&apos;m still getting this at times, though:
<pre>------ REPL Error while processing ---------------------------------------------
(ns couperin.user
  (:require [portal.web :as p]
            [malli.core :as m]
            [malli.instrument :as mi]
            [malli.dev :as dev]))
The required namespace &quot;malli.instrument&quot; is not available, it was required by &quot;couperin/user.cljs&quot;.
&quot;malli/instrument.clj&quot; was found on the classpath. Maybe this library only supports CLJ?</pre></z><z id="t1648412525" t="Carlo Same thing for the namespace"><y>#</y><d>2022-03-27</d><h>20:22</h><r>Carlo</r>Same thing for the <code></code> namespace</z><z id="t1648412744" t="Carlo ah it&apos;s probably a weird interaction with shadow-cljs https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/3"><y>#</y><d>2022-03-27</d><h>20:25</h><r>Carlo</r>ah it&apos;s probably a weird interaction with shadow-cljs <a href="https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/3" target="_blank">https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/3</a></z><z id="t1648438935" t="dvingo hey, I contributed the cljs support, it&apos;s in need of some documentation. When using the instrumentation for cljs the namespaces should be: [malli.instrument.cljs :as mi] [malli.dev.cljs :as md] and there is kondo support but it must be executed at runtime (because the schemas aren&apos;t available during compilation (macroexpansion)) and prints to the console, with the intention being you copy it to a kondo config file. https://github.com/metosin/malli/blob/400dc0c79805028a6d85413086d4d6d627231940/src/malli/clj_kondo.cljc#L203 the js console errors need some work (the pretty one is designed with terminal emulators in mind, not js web console) but if you execute an instrumented fn via nrepl in an editor the error output there is better."><y>#</y><d>2022-03-28</d><h>03:42</h><r>dvingo</r>hey, I contributed the cljs support, it&apos;s in need of some documentation. When using the instrumentation for cljs the namespaces should be:
<code>[malli.instrument.cljs :as mi]</code>
<code>[malli.dev.cljs :as md]</code>
and there is kondo support but it must be executed at runtime (because the schemas aren&apos;t available during compilation (macroexpansion)) and prints to the console, with the intention being you copy it to a kondo config file.
<a href="https://github.com/metosin/malli/blob/400dc0c79805028a6d85413086d4d6d627231940/src/malli/clj_kondo.cljc#L203" target="_blank">https://github.com/metosin/malli/blob/400dc0c79805028a6d85413086d4d6d627231940/src/malli/clj_kondo.cljc#L203</a>

the js console errors need some work (the pretty one is designed with terminal emulators in mind, not js web console) but if you execute an instrumented fn via nrepl in an editor the error output there is better.</z><z id="t1648468975" t="Carlo Thank you [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] , I&apos;m a bit confused on how instrumentation works on cljs. Even after importing: (:require [portal.web :as p] [malli.core :as m] [malli.instrument.cljs :as mi] [malli.dev.cljs :as dev]) doing (comment (dev/start!)) and adding: (m/=&gt; -add [:=&gt; [:cat :int :int] :int]) (defn -add [x y] &quot;abcd&quot;) I can still execute calls like: (-add 1 &quot;a&quot;) getting &quot;abcd&quot; as my answer (and I see that I have the instrumentation message in the browser console: ..instrumented {ns: &apos;couperin.user&apos;, name: &apos;-add&apos;, str: &apos;couperin.user/-add&apos;, _hash: 150786855, _meta: null, …} just not any error whatsoever"><y>#</y><d>2022-03-28</d><h>12:02</h><r>Carlo</r>Thank you <a>@U051V5LLP</a>, I&apos;m a bit confused on how instrumentation works on cljs. Even after importing:
<pre>(:require [portal.web :as p]
            [malli.core :as m]
            [malli.instrument.cljs :as mi]
            [malli.dev.cljs :as dev])</pre>
doing
<pre>(comment
  (dev/start!))</pre>
and adding:
<pre>(m/=&gt; -add [:=&gt; [:cat :int :int] :int])
(defn -add [x y]
  &quot;abcd&quot;)</pre>
I can still execute calls like:
<pre>(-add 1 &quot;a&quot;)</pre>
getting <code>&quot;abcd&quot;</code> as my answer (and I see that I have the instrumentation message in the browser console:
<pre>..instrumented 
{ns: &apos;couperin.user&apos;, name: &apos;-add&apos;, str: &apos;couperin.user/-add&apos;, _hash: 150786855, _meta: null, …}</pre>
just not any error whatsoever</z><z id="t1648470493" t="Carlo Ok, if I call (dev/start!) just before a call to -add , then I get the errors, but if I then modify the definition of -add , the instrumentation is not redone automatically"><y>#</y><d>2022-03-28</d><h>12:28</h><r>Carlo</r>Ok, if I call <code>(dev/start!)</code> just before a call to <code>-add</code>, then I get the errors, but if I then modify the definition of <code>-add</code> , the instrumentation is not redone automatically</z><z id="t1648475082" t="dvingo instrumentation works by replacing the function implementations so when hot reload happens the original functions will be replace the instrumented code. https://shadow-cljs.github.io/docs/UsersGuide.html#_lifecycle_hooks you&apos;ll want to call instrument! or start! after the hot code reload runs (usually something like (defn ^:dev/after-load refresh [] (md/start!)...) for shadow.cljs"><y>#</y><d>2022-03-28</d><h>13:44</h><r>dvingo</r>instrumentation works by replacing the function implementations so when hot reload happens the original functions will be replace the instrumented code.
<a href="https://shadow-cljs.github.io/docs/UsersGuide.html#_lifecycle_hooks" target="_blank">https://shadow-cljs.github.io/docs/UsersGuide.html#_lifecycle_hooks</a>
you&apos;ll want to call instrument! or start! after the hot code reload runs (usually something like <code>(defn ^:dev/after-load refresh [] (md/start!)...)</code>  for shadow.cljs</z><z id="t1648476514" t="Carlo Thank you, would you still advice to do https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/2 ? I can get it to check something but it&apos;s clearly confused by namespaces. Is there a particular place the refresh function you just mentioned should live?"><y>#</y><d>2022-03-28</d><h>14:08</h><r>Carlo</r>Thank you, would you still advice to do <a href="https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/2" target="_blank">https://clojureverse.org/t/problem-using-malli-clojurescript-instrumentation-and-shadow-cljs/8612/2</a> ? I can get it to check something but it&apos;s clearly confused by namespaces. Is there a particular place the <code>refresh</code> function you just mentioned should live?</z><z id="t1648513358" t="dvingo just the standard setup you&apos;d have for any cljs (utilizing react) app: https://github.com/day8/re-frame/blob/69cf39552715fa410e7007b7fcbc894097d8db1f/examples/todomvc/src/todomvc/core.cljs#L57"><y>#</y><d>2022-03-29</d><h>00:22</h><r>dvingo</r>just the standard setup you&apos;d have for any cljs (utilizing react) app:
<a href="https://github.com/day8/re-frame/blob/69cf39552715fa410e7007b7fcbc894097d8db1f/examples/todomvc/src/todomvc/core.cljs#L57" target="_blank">https://github.com/day8/re-frame/blob/69cf39552715fa410e7007b7fcbc894097d8db1f/examples/todomvc/src/todomvc/core.cljs#L57</a></z><z id="t1648380041" t="Ivan Fedorov New pretty explainer is so awesome! Great work, thanks a lot!"><y>#</y><d>2022-03-27</d><h>11:20</h><w>Ivan Fedorov</w>New pretty explainer is so awesome! Great work, thanks a lot!</z><z id="t1648380074" t="Ivan Fedorov can we expect it in cljs land?"><y>#</y><d>2022-03-27</d><h>11:21</h><w>Ivan Fedorov</w>can we expect it in cljs land?</z><z id="t1648474308" t="Carlo the new pretty explainer seems to break cljs instrumentation, because of not found variables."><y>#</y><d>2022-03-28</d><h>13:31</h><w>Carlo</w>the new pretty explainer seems to break cljs instrumentation, because of not found variables.</z><z id="t1648484234" t="rovanion I am either missing something or I&apos;ve found a bug. It seems like updating a key in a map-spec makes the the optional property have no effect, even though it is still there: ;;; Specification registry (def registry (atom {})) (defn register! [type ?schema] (swap! registry assoc type ?schema)) ;; Combine the default registry with our own mutable registry. (mreg/set-default-registry! (mreg/composite-registry (mreg/fast-registry (malli/default-schemas)) (mreg/mutable-registry registry))) (register! :db/f [:map [:key {:optional true} [:double]]]) (register! :user/f (-&gt; (malli/deref :db/f) (mutil/update :key #(mutil/update-properties % assoc :disabled true)))) (malli/deref :db/f) ;; =&gt; [:map [:key {:optional true} :double]] (malli/deref :user/f) ;; =&gt; [:map [:key {:optional true} [:double {:disabled true}]]] (malli/explain :db/f {}) ;; =&gt; nil (malli/explain :user/f {}) ;; =&gt; {:schema :user/f, :value {}, :errors ({:path [0 :key], :in [:key], :schema [:map [:key {:optional true} [:double {:disabled true}]]], :value nil, :type :malli.core/missing-key})} (mgen/sample :db/f) ;; =&gt; ({} {} {} {} {:key -1.5} {} {} {:key -1.09375} {:key -2.0} {:key 4.625}) (mgen/sample :user/f) ;; =&gt; ({:key -2.0} {:key -0.5} {:key 2.0} {:key -0.75} {:key -1.5} {:key 1.75} {:key 3.53125} {:key 1.25} {:key -0.25} {:key 0.271484375}) Yup, another user already found it: https://github.com/metosin/malli/issues/645"><y>#</y><d>2022-03-28</d><h>16:17</h><w>rovanion</w>I am either missing something or I&apos;ve found a bug. It seems like updating a key in a map-spec makes the the optional property have no effect, even though it is still there:

<pre>;;; Specification registry

(def registry
  (atom {}))

(defn register! [type ?schema]
  (swap! registry assoc type ?schema))

;; Combine the default registry with our own mutable registry.
(mreg/set-default-registry!
 (mreg/composite-registry
    (mreg/fast-registry (malli/default-schemas))
    (mreg/mutable-registry registry)))

(register! :db/f
   [:map
    [:key   {:optional true} [:double]]])

(register! :user/f
   (-&gt; (malli/deref :db/f)
       (mutil/update :key #(mutil/update-properties % assoc :disabled true))))

(malli/deref :db/f)
;; =&gt; [:map [:key {:optional true} :double]]

(malli/deref :user/f)
;; =&gt; [:map [:key {:optional true} [:double {:disabled true}]]]

(malli/explain :db/f {})
;; =&gt; nil

(malli/explain :user/f {})
;; =&gt; {:schema :user/f, :value {}, :errors ({:path [0 :key], :in [:key], :schema [:map [:key {:optional true} [:double {:disabled true}]]], :value nil, :type :malli.core/missing-key})}

(mgen/sample :db/f)
;; =&gt; ({} {} {} {} {:key -1.5} {} {} {:key -1.09375} {:key -2.0} {:key 4.625})

(mgen/sample :user/f)
;; =&gt; ({:key -2.0} {:key -0.5} {:key 2.0} {:key -0.75} {:key -1.5} {:key 1.75} {:key 3.53125} {:key 1.25} {:key -0.25} {:key 0.271484375})</pre>
Yup, another user already found it: <a href="https://github.com/metosin/malli/issues/645" target="_blank">https://github.com/metosin/malli/issues/645</a></z><z id="t1648646747" t="Carlo I&apos;m really liking the pretty explainer namespace, [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] ! Do you think this function https://github.com/metosin/malli/blob/d69e06326662c675a40095c7c72ca80af8a8d282/src/malli/dev/pretty.cljc#L69-L75 could get some more inputs? Like, the name of the function that&apos;s displaying the error, maybe the line location? Or is it a thing I should try to get via other means?"><y>#</y><d>2022-03-30</d><h>13:25</h><w>Carlo</w>I&apos;m really liking the pretty explainer namespace, <a>@ikitommi</a>! Do you think this function <a href="https://github.com/metosin/malli/blob/d69e06326662c675a40095c7c72ca80af8a8d282/src/malli/dev/pretty.cljc#L69-L75" target="_blank">https://github.com/metosin/malli/blob/d69e06326662c675a40095c7c72ca80af8a8d282/src/malli/dev/pretty.cljc#L69-L75</a> could get some more inputs? Like, the name of the function that&apos;s displaying the error, maybe the line location? Or is it a thing I should try to get via other means?</z><z id="t1648728284" t="Carlo Here&apos;s a tentative PR for this feature [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I&apos;d love to know if this is the right direction and what could be improved https://github.com/metosin/malli/pull/680"><y>#</y><d>2022-03-31</d><h>12:04</h><r>Carlo</r>Here&apos;s a tentative PR for this feature <a>@ikitommi</a>, I&apos;d love to know if this is the right direction and what could be improved

<a href="https://github.com/metosin/malli/pull/680" target="_blank">https://github.com/metosin/malli/pull/680</a></z><z id="t1649845103" t="ikitommi will look into this."><y>#</y><d>2022-04-13</d><h>10:18</h><r>ikitommi</r>will look into this.</z><z id="t1648693232" t="mafcocinco Is it possible to supply an arbitrary generator function to an :fn schema (or any schema really)? I know this is trivial, but works for an example: (malli.g/generate [:map [:a [:fn {:gen/function (fn [] 1)} #(int? %)]]])"><y>#</y><d>2022-03-31</d><h>02:20</h><w>mafcocinco</w>Is it possible to supply an arbitrary generator function to an <code>:fn</code> schema (or any schema really)?  I know this is trivial, but works for an example:
<pre>(malli.g/generate [:map [:a [:fn {:gen/function (fn [] 1)} #(int? %)]]])</pre></z><z id="t1649845068" t="ikitommi try :gen/gen ."><y>#</y><d>2022-04-13</d><h>10:17</h><r>ikitommi</r>try <code>:gen/gen</code>.</z><z id="t1648693251" t="mafcocinco malli throws an exception with that example, so obviously not correct but was hoping there was something like that."><y>#</y><d>2022-03-31</d><h>02:20</h><w>mafcocinco</w><code>malli</code> throws an exception with that example, so obviously not correct but was hoping there was something like that.</z><z id="t1648693324" t="mafcocinco The reason I ask is that we have, for example, a customer schema with first-name , last-name , etc. The schema for first-name uses string? to validate but would like to constrain the generated values to a handful of simple names rather than the universe of all possible strings."><y>#</y><d>2022-03-31</d><h>02:22</h><w>mafcocinco</w>The reason I ask is that we have, for example, a <code>customer</code> schema with <code>first-name</code>, <code>last-name</code>, etc.  The schema for <code>first-name</code> uses <code>string?</code> to validate but would like to constrain the generated values to a handful of simple names rather than the universe of all possible strings.</z><z id="t1648693340" t="mafcocinco Would definitely make the generated data a bit more readable and user friendly."><y>#</y><d>2022-03-31</d><h>02:22</h><w>mafcocinco</w>Would definitely make the generated data a bit more readable and user friendly.</z><z id="t1648981781" t="Carlo Quick question: does generative checking work in cljs ? If not, why not? If I try to write (mi/check) I get: ------ WARNING #1 - :undeclared-var -------------------------------------------- File: /home/carlo/code/clojure/visualizerTestCljs/src/main/core.cljs:12:1 -------------------------------------------------------------------------------- 9 | (defn badd [x y] 10 | &quot;z&quot;) 11 | 12 | (mi/check) -------^------------------------------------------------------------------------ Use of undeclared Var malli.generator/check -------------------------------------------------------------------------------- edit: solution in thread"><y>#</y><d>2022-04-03</d><h>10:29</h><w>Carlo</w>Quick question: does generative checking work in <code>cljs</code>? If not, why not? If I try to write <code>(mi/check)</code> I get:
<pre>------ WARNING #1 - :undeclared-var --------------------------------------------
 File: /home/carlo/code/clojure/visualizerTestCljs/src/main/core.cljs:12:1
--------------------------------------------------------------------------------
   9 | (defn badd [x y]
  10 |   &quot;z&quot;)
  11 | 
  12 | (mi/check)
-------^------------------------------------------------------------------------
 Use of undeclared Var malli.generator/check
--------------------------------------------------------------------------------</pre>
edit: solution in thread</z><z id="t1648982585" t="Carlo Ok, it works if I manually include an import on malli.generator , even if I don&apos;t directly use the namespace. This is probably due to how shadow-cljs includes the files. I&apos;m going to leave it here in case it&apos;s useful to someone else in the future."><y>#</y><d>2022-04-03</d><h>10:43</h><r>Carlo</r>Ok, it works if I manually include an import on <code>malli.generator</code> , even if I don&apos;t directly use the namespace. This is probably due to how shadow-cljs includes the files. I&apos;m going to leave it here in case it&apos;s useful to someone else in the future.</z><z id="t1649033446" t="dvingo I made an github issue to fix this. you shouldn&apos;t have to require that ns - I&apos;ll fix it in the coming days"><y>#</y><d>2022-04-04</d><h>00:50</h><r>dvingo</r>I made an github issue to fix this. you shouldn&apos;t have to require that ns - I&apos;ll fix it in the coming days</z><z id="t1649150287" t="Ferdinand Beyer Is there a recommendation when to call m/schema and when not? I want to define schemas in vars, would wrapping them in in m/schema improve performance?"><y>#</y><d>2022-04-05</d><h>09:18</h><w>Ferdinand Beyer</w>Is there a recommendation when to call <code>m/schema</code> and when not? I want to define schemas in vars, would wrapping them in in <code>m/schema</code> improve performance?</z><z id="t1649150805" t="Ben Sless Although I worked on improving parsing performance, calling schema will help with that It will also ensure the same object is shared if the schema is used multiple times"><y>#</y><d>2022-04-05</d><h>09:26</h><r>Ben Sless</r>Although I worked on improving parsing performance, calling schema will help with that
It will also ensure the same object is shared if the schema is used multiple times</z><z id="t1649160164" t="Ferdinand Beyer OK thanks. I’ve seen that I can get the form with m/form if I need to 😉"><y>#</y><d>2022-04-05</d><h>12:02</h><r>Ferdinand Beyer</r>OK thanks. I’ve seen that I can get the form with <code>m/form</code> if I need to <b>😉</b></z><z id="t1649355596" t="respatialized Is there a way to negatively specify a map key? Like &quot;this map cannot contain the :ident key?&quot;"><y>#</y><d>2022-04-07</d><h>18:19</h><w>respatialized</w>Is there a way to negatively specify a map key? Like &quot;this map cannot contain the <code>:ident</code> key?&quot;</z><z id="t1649355658" t="respatialized I could do an :and schema with a :not but that seems clunky and was wondering if there&apos;s another way"><y>#</y><d>2022-04-07</d><h>18:20</h><r>respatialized</r>I could do an <code>:and</code> schema with a <code>:not</code> but that seems clunky and was wondering if there&apos;s another way</z><z id="t1649366783" t="ambrosebs AFAIK think it&apos;s like spec in this respect. There are hacks around it but it&apos;s not supported, https://github.com/metosin/malli/blob/3599fbd7fe1eba96c35e5c39073397cba0984b6a/src/malli/core.cljc#L975-L982 is concerning presence, not absence."><y>#</y><d>2022-04-07</d><h>21:26</h><r>ambrosebs</r>AFAIK think it&apos;s like spec in this respect. There are hacks around it but it&apos;s not supported, <a href="https://github.com/metosin/malli/blob/3599fbd7fe1eba96c35e5c39073397cba0984b6a/src/malli/core.cljc#L975-L982" target="_blank">https://github.com/metosin/malli/blob/3599fbd7fe1eba96c35e5c39073397cba0984b6a/src/malli/core.cljc#L975-L982</a> is concerning presence, not absence.</z><z id="t1649366819" t="ambrosebs another hack I remember from spec is using map-of &apos;s keys with a restricted spec for keys."><y>#</y><d>2022-04-07</d><h>21:26</h><r>ambrosebs</r>another hack I remember from spec is using <code>map-of</code>&apos;s keys with a restricted spec for keys.</z><z id="t1649366948" t="ambrosebs when I https://github.com/typedclojure/typedclojure/blob/bb973bce811c111a814aad4889aa2a083a5e761d/typed/malli/src/typed/malli/parse_type.cljc#L148-L151 a Typed Clojure =&gt; malli translation, the best I could find was {:closed true} to prevent all other keys."><y>#</y><d>2022-04-07</d><h>21:29</h><r>ambrosebs</r>when I <a href="https://github.com/typedclojure/typedclojure/blob/bb973bce811c111a814aad4889aa2a083a5e761d/typed/malli/src/typed/malli/parse_type.cljc#L148-L151" target="_blank">https://github.com/typedclojure/typedclojure/blob/bb973bce811c111a814aad4889aa2a083a5e761d/typed/malli/src/typed/malli/parse_type.cljc#L148-L151</a> a Typed Clojure =&gt; malli translation, the best I could find was <code>{:closed true}</code> to prevent all other keys.</z><z id="t1649366959" t="ambrosebs That might be what you want actually."><y>#</y><d>2022-04-07</d><h>21:29</h><r>ambrosebs</r>That might be what you want actually.</z><z id="t1649367626" t="respatialized Unfortunately not, my use case is a data model like GeoJSON where it&apos;s open by default but some keys are reserved and cannot be used in certain contexts"><y>#</y><d>2022-04-07</d><h>21:40</h><r>respatialized</r>Unfortunately not, my use case is a data model like GeoJSON where it&apos;s open by default but some keys are reserved and cannot be used in certain contexts</z><z id="t1649403816" t="Ben Sless You can require a map be closed in malli"><y>#</y><d>2022-04-08</d><h>07:43</h><r>Ben Sless</r>You can require a map be closed in malli</z><z id="t1649355658" t="respatialized I could do an :and schema with a :not but that seems clunky and was wondering if there&apos;s another way"><y>#</y><d>2022-04-07</d><h>18:20</h><w>respatialized</w>I could do an <code>:and</code> schema with a <code>:not</code> but that seems clunky and was wondering if there&apos;s another way</z><z id="t1649402899" t="Ferdinand Beyer What’s the preferred way of testing schema compliance in tests? Works but does not give helpful failure messages: (is (m/validate ,,,)) Better, but not super intuitive: (is (nil? (m/explain ,,,))) Is there some other way that I’m missing?"><y>#</y><d>2022-04-08</d><h>07:28</h><w>Ferdinand Beyer</w>What’s the preferred way of testing schema compliance in tests?

Works but does not give helpful failure messages:
<pre>(is (m/validate ,,,))</pre>
Better, but not super intuitive:
<pre>(is (nil? (m/explain ,,,)))</pre>
Is there some other way that I’m missing?</z><z id="t1649403756" t="Ben Sless Instrument functions and use generators"><y>#</y><d>2022-04-08</d><h>07:42</h><r>Ben Sless</r>Instrument functions and use generators</z><z id="t1649594039" t="Martynas M Hey. There is a guy that asks for more transparency on what the library supports. I&apos;m not too sure how to answer his question. This probably means that he&apos;d expect to either be dismissed and pointed into README once again or then the README should be updated. https://github.com/metosin/malli/issues/652 https://www.reddit.com/r/Clojure/comments/tykor2/malli_schema_questions/"><y>#</y><d>2022-04-10</d><h>12:33</h><w>Martynas M</w>Hey.
There is a guy that asks for more transparency on what the library supports. I&apos;m not too sure how to answer his question.
This probably means that he&apos;d expect to either be dismissed and pointed into README once again or then the README should be updated.

<a href="https://github.com/metosin/malli/issues/652" target="_blank">https://github.com/metosin/malli/issues/652</a>
<a href="https://www.reddit.com/r/Clojure/comments/tykor2/malli_schema_questions/" target="_blank">https://www.reddit.com/r/Clojure/comments/tykor2/malli_schema_questions/</a></z><z id="t1649607801" t="ambrosebs I took a crack at answering."><y>#</y><d>2022-04-10</d><h>16:23</h><r>ambrosebs</r>I took a crack at answering.</z><z id="t1649603515" t="pithyless There is a theory of documentation, that I first saw promoted by Jacob Kaplan-Moss (highly influential in Django documentation and later Heroku Developer Center), that divides documentation into 4 kinds: tutorials, how-to guides, reference and explanation. In general, when I see people struggling with documentation, it is often because the author of the document in question and the reader are in two different quadrants - neither is wrong, but they&apos;re missing each other instead of mind-melding. [:attrs {:href &quot;/_/_/users/U028ART884X&quot;}] - having skimmed the linked issues, I think the same mismatching of expectations is happening. Malli does have some tutorial-like and explanation-like content in the README, and one can explore the codebase and tests to gather more reference-like content. https://malli.io gives examples one may consider how-to guides for modeling common schemas. But I think it is a fair assessment that all these things are scattered and not easy to find, especially for a newcomer to the library. Aside from Jacob Kaplan-Moss talks and writing you can find online, I found a good write up of the problems with structuring documentation here: https://documentation.divio.com/ I think moving forward, malli would benefit by taking some pointers for how to organize different kinds of documentation and information for the community. It&apos;s not a question of what should be in the README, tests, etc., but more of a question of how to organize this information that a reader coming to the project with different mindset and expectations can find the information that is most relevant for them at the time."><y>#</y><d>2022-04-10</d><h>15:11</h><w>pithyless</w>There is a theory of documentation, that I first saw promoted by Jacob Kaplan-Moss (highly influential in Django documentation and later Heroku Developer Center), that divides documentation into 4 kinds: tutorials, how-to guides, reference and explanation. In general, when I see people struggling with documentation, it is often because the author of the document in question and the reader are in two different quadrants - neither is wrong, but they&apos;re missing each other instead of mind-melding.

<a>@invertisment_clojuria</a> - having skimmed the linked issues, I think the same mismatching of expectations is happening. Malli does have some tutorial-like and explanation-like content in the README, and one can explore the codebase and tests to gather more reference-like content. <a href="https://malli.io" target="_blank">https://malli.io</a> gives examples one may consider how-to guides for modeling common schemas. But I think it is a fair assessment that all these things are scattered and not easy to find, especially for a newcomer to the library.

Aside from Jacob Kaplan-Moss talks and writing you can find online, I found a good write up of the problems with structuring documentation here: <a href="https://documentation.divio.com/" target="_blank">https://documentation.divio.com/</a> I think moving forward, malli would benefit by taking some pointers for how to organize different kinds of documentation and information for the community. It&apos;s not a question of what should be in the README, tests, etc., but more of a question of how to organize this information that a reader coming to the project with different mindset and expectations can find the information that is most relevant for them at the time.</z><z id="t1649752799" t="eskos Hi, did a bit of a hit&amp;run yesterday with this, but wanted to comment 🙂 I totally agree with this! Documentation, in general, is both incredibly hard and incredibly valuable, and I do use that divio link every time I talk about software documentation to anyone as reference - I don’t claim it to be perfect, but it is definitely good enough. For me, malli’s documentation currently has a discoverability issue. Over the past few years malli has gained a daunting amount of features, but there’s no clear path to learning each feature, and the readme’s examples aren’t comprehensive - this latter is especially kinda amazing considering the readme is probably the longest I’ve ever seen in a Clojure project, especially when considering the amount of examples. To generalize what I want from documentation is three things: 1. How do I use this. This is always the most critical one, and a sort of blindfold approach - if there isn’t a direct “do x to get y, do z after doing y to get z” kind of How-To guide, I’ll probably never learn about That One Awesome Feature. This is sort of related to the eternal discussion of if left fold is enough or should we also have map and reduce, or is filter enough or do we need keep and remove as well. 2. What is the internal logic. I don’t mean algorithms or stuff like that, but why are things organized in the way they are and what are the architectural decisions. “We like interceptors over middleware” sounds nice, but that assumes I know what interceptors and middleware are. Another would be naming schemes used to name functions, especially prefixes and suffixes used, stuff like that, or something thankfully not that common in Clojure land, but do you return raw values, lazy seqs, promises, channels...how do you assume your library is being used from the outside? 3. All I need is the documentation. If I need to read the source to understand software behavior, the documentation sucks. I’ve been told especially about this that I am Wrong™, but I don’t have time nor interest for that debate - this is my approach 🙂 From technical point of view IMO malli should add one of those libraries which can evaluate code snippets in README just to make sure the snippets stay current and working. Sort of related but inevitable is also the fact that malli’s build is now build+deps based, which is like https://github.com/Gant/Gant all over again, but ehhhh pointing back to my previous points, if I need to worry about how malli is built, I’m already too deep… 🙂"><y>#</y><d>2022-04-12</d><h>08:39</h><r>eskos</r>Hi, did a bit of a hit&amp;run yesterday with this, but wanted to comment <b>🙂</b>

I totally agree with this! Documentation, in general, is both incredibly hard and incredibly valuable, and I do use that divio link every time I talk about software documentation to anyone as reference - I don’t claim it to be perfect, but it is definitely good enough.

For me, malli’s documentation currently has a discoverability issue. Over the past few years malli has gained a daunting amount of features, but there’s no clear path to learning each feature, and the readme’s examples aren’t comprehensive - this latter is especially kinda amazing considering the readme is probably the longest I’ve ever seen in a Clojure project, especially when considering the amount of examples.

To generalize what I want from documentation is three things:
1. How do I use this. This is always the most critical one, and a sort of blindfold approach - if there isn’t a direct “do x to get y, do z after doing y to get z” kind of How-To guide, I’ll probably never learn about That One Awesome Feature. This is sort of related to the eternal discussion of if left fold is enough or should we also have map and reduce, or is <code>filter</code> enough or do we need <code>keep</code> and <code>remove</code> as well.
2. What is the internal logic. I don’t mean algorithms or stuff like that, but why are things organized in the way they are and what are the architectural decisions. “We like interceptors over middleware” sounds nice, but that assumes I know what interceptors and middleware are. Another would be naming schemes used to name functions, especially prefixes and suffixes used, stuff like that, or something thankfully not that common in Clojure land, but do you return raw values, lazy seqs, promises, channels...how do you assume your library is being used from the outside?
3. All I need is the documentation. If I need to read the source to understand software behavior, the documentation sucks. I’ve been told especially about this that I am Wrong™, but I don’t have time nor interest for that debate - this is my approach <b>🙂</b> 
From technical point of view IMO malli should add one of those libraries which can evaluate code snippets in README just to make sure the snippets stay current and working. Sort of related but inevitable is also the fact that malli’s build is now build+deps based, which is like <a href="https://github.com/Gant/Gant" target="_blank">https://github.com/Gant/Gant</a> all over again, but ehhhh pointing back to my previous points, if I need to worry about how malli is built, I’m already too deep… <b>🙂</b></z><z id="t1649765069" t="pithyless Thanks for the long and insightful comment [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] :) It&apos;s going to be a slow start, but I&apos;m willing to try to help out with this kind of documentation in the coming weeks. So the core team can focus on delivering more awesome features. ;) I see Tommi is vacationing atm, but I wonder if other malli contributors or users have more insights on what they&apos;d like to see. I&apos;ll start taking some notes."><y>#</y><d>2022-04-12</d><h>12:04</h><r>pithyless</r>Thanks for the long and insightful comment <a>@U8SFC8HLP</a> :)

It&apos;s going to be a slow start, but I&apos;m willing to try to help out with this kind of documentation in the coming weeks. So the core team can focus on delivering more awesome features. ;)

I see Tommi is vacationing atm, but I wonder if other malli contributors or users have more insights on what they&apos;d like to see. I&apos;ll start taking some notes.</z><z id="t1649845003" t="ikitommi [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] , you had a tutorial almost done? PR would be most welcome. Also, [:attrs {:href &quot;/_/_/users/U05476190&quot;}] &amp; all, all documentation improvements are most welcome, /docs being a good place for them."><y>#</y><d>2022-04-13</d><h>10:16</h><r>ikitommi</r><a>@UK0810AQ2</a> , you had a tutorial almost done? PR would be most welcome. Also, <a>@U05476190</a> &amp; all, all documentation improvements are most welcome, <code>/docs</code> being a good place for them.</z><z id="t1649674588" t="Martynas M Hey. Is there a way to specify that a schema decoder should decode into a list instead of a vector? I&apos;d like to have this schema: [:list :string] Is this possible without additional code (be it in the transformation step or after the decoding)? I think a decoder could pick this one up but it would be a custom one: [:vector {:type :list} :string] But I simply want to not add any code at all, if possible (maybe to serialize the schema later, not sure). (type (malli.generator/generate [:sequential :nil])) =&gt; clojure.lang.PersistentVector"><y>#</y><d>2022-04-11</d><h>10:56</h><w>Martynas M</w>Hey.
Is there a way to specify that a schema decoder should decode into a list instead of a vector?
I&apos;d like to have this schema:
<code>[:list :string]</code>
Is this possible without additional code (be it in the transformation step or after the decoding)?
I think a decoder could pick this one up but it would be a custom one:
<code>[:vector {:type :list} :string]</code>
But I simply want to not add any code at all, if possible (maybe to serialize the schema later, not sure).

<code>(type (malli.generator/generate [:sequential :nil]))</code> =&gt; <code>clojure.lang.PersistentVector</code></z><z id="t1649844851" t="ikitommi currently, no. but would be nice. there is a collection-transformer but it’s current purpose is to ensure the right format, should read the :type etc. property for the correct target type"><y>#</y><d>2022-04-13</d><h>10:14</h><r>ikitommi</r>currently, no. but would be nice. there is a <code>collection-transformer</code> but it’s current purpose is to ensure the right format, should read the <code>:type</code> etc. property for the correct target type</z><z id="t1649844018" t="Yehonathan Sharvit Hello, We are building an automatic form generator based on Malli. The form generator input is made of: • A malli schema • A structural description of the form The structure of the form is not necessarily the same as the structure of the data. Here is a example {:schema [:map [:username {:title &quot;Username&quot;} :string] [:email {:title &quot;Email&quot; :description &quot;The business email of the user&quot;} :string] [:personal [:map [:age {:title &quot;Age&quot; :description &quot;The age of the user&quot;} :int]]]] :ui {:sections [{:title &quot;General&quot; :fields [{:path [:username]}]} {:title &quot;Details&quot; :fields [{:path [:personal :age]}]}]}} Now, my question is: is there a way to retrieve the schema that corresponds to a map field? For instance the schema that correspond to the [:personal :age] field."><y>#</y><d>2022-04-13</d><h>10:00</h><w>Yehonathan Sharvit</w>Hello,
We are building an automatic form generator based on Malli.
The form generator input is made of:
• A malli schema
• A structural description of the form
The structure of the form is not necessarily the same as the structure of the data.
Here is a example
<pre>{:schema [:map 
          [:username {:title &quot;Username&quot;} :string]
          [:email {:title &quot;Email&quot;
                   :description &quot;The business email of the user&quot;}
           :string]
          [:personal [:map 
                      [:age {:title &quot;Age&quot;
                             :description &quot;The age of the user&quot;} :int]]]]
 :ui {:sections [{:title &quot;General&quot;
                  :fields [{:path [:username]}]}
                 {:title &quot;Details&quot;
                  :fields [{:path [:personal :age]}]}]}}</pre>
Now, my question is: is there a way to retrieve the schema that corresponds to a map field?
For instance the schema that correspond to the <code>[:personal :age]</code>  field.</z><z id="t1649844459" t="ikitommi sure, but there can be many schemas behind a path, if there is an :and or :or . but if you know what you are doing, you can just the the first one, like this: (defn schema-in [?schema path] (let [schema (m/schema ?schema)] (-&gt;&gt; (mu/in-&gt;paths schema path) (first) (mu/get-in schema)))) (schema-in [:map [:username :string] [:email :string] [:personal [:map [:age :int]]]] [:personal :age]) ; =&gt; :int"><y>#</y><d>2022-04-13</d><h>10:07</h><r>ikitommi</r>sure, but there can be many schemas behind a path, if there is an <code>:and</code> or  <code>:or</code>. but if you know what you are doing, you can just the the first one, like this:
<pre>(defn schema-in [?schema path]
  (let [schema (m/schema ?schema)]
    (-&gt;&gt; (mu/in-&gt;paths schema path) (first) (mu/get-in schema))))

(schema-in
 [:map
  [:username :string]
  [:email :string]
  [:personal [:map
              [:age :int]]]]
 [:personal :age])
; =&gt; :int</pre></z><z id="t1649844559" t="ikitommi btw, just doing the same thing in a projects (again), would like to push some parts back to the library"><y>#</y><d>2022-04-13</d><h>10:09</h><r>ikitommi</r>btw, just doing the same thing in a projects (again), would like to push some parts back to the library</z><z id="t1649847815" t="Yehonathan Sharvit What exactly are you doing in your project? UI generation?"><y>#</y><d>2022-04-13</d><h>11:03</h><r>Yehonathan Sharvit</r>What exactly are you doing in your project? UI generation?</z><z id="t1649853320" t="ikitommi yes, two cases: 1. technical ui’s for admin/prototyping, directly from malli schemas 2. having large amount of dynamic forms &amp; rules in project(s) =&gt; need both utilities for malli-backed form components and some data-oriented generic form-markup, “the ui-schema” … looking at your example, you are doing 2 too and I know there are many others doing that, looking forward to see if there could be something reusable / shared with these."><y>#</y><d>2022-04-13</d><h>12:35</h><r>ikitommi</r>yes, two cases:
1. technical ui’s for admin/prototyping, directly from malli schemas
2. having large amount of dynamic forms &amp; rules in project(s) =&gt; need both utilities for malli-backed form components and some data-oriented generic form-markup, “the ui-schema”
… looking at your example, you are doing 2 too and I know there are many others doing that, looking forward to see if there could be something reusable / shared with these.</z><z id="t1649866554" t="Yehonathan Sharvit Nice!"><y>#</y><d>2022-04-13</d><h>16:15</h><r>Yehonathan Sharvit</r>Nice!</z><z id="t1649866569" t="Yehonathan Sharvit Have you found a way to deal with :multi ?"><y>#</y><d>2022-04-13</d><h>16:16</h><r>Yehonathan Sharvit</r>Have you found a way to deal with <code>:multi</code>?</z><z id="t1649925655" t="Yehonathan Sharvit ?"><y>#</y><d>2022-04-14</d><h>08:40</h><r>Yehonathan Sharvit</r>?</z><z id="t1649844459" t="ikitommi sure, but there can be many schemas behind a path, if there is an :and or :or . but if you know what you are doing, you can just the the first one, like this: (defn schema-in [?schema path] (let [schema (m/schema ?schema)] (-&gt;&gt; (mu/in-&gt;paths schema path) (first) (mu/get-in schema)))) (schema-in [:map [:username :string] [:email :string] [:personal [:map [:age :int]]]] [:personal :age]) ; =&gt; :int"><y>#</y><d>2022-04-13</d><h>10:07</h><w>ikitommi</w>sure, but there can be many schemas behind a path, if there is an <code>:and</code> or  <code>:or</code>. but if you know what you are doing, you can just the the first one, like this:
<pre>(defn schema-in [?schema path]
  (let [schema (m/schema ?schema)]
    (-&gt;&gt; (mu/in-&gt;paths schema path) (first) (mu/get-in schema))))

(schema-in
 [:map
  [:username :string]
  [:email :string]
  [:personal [:map
              [:age :int]]]]
 [:personal :age])
; =&gt; :int</pre></z><z id="t1650048839" t="hjrnunes Hi. Say I want to validate a sequence of maps and make sure there&apos;s at least one of them with a specific entry. Is this in scope for Malli? How would I go about it? Example: ;; my schema is something that somehow looks for [:b 2] in a map sequence (m/validate my-schema [{:a 1} {:b 2} {:c 3}]) =&gt; true (m/validate my-schema [{:a 1} {:b 2} {:b 2 :c 4} {:c 3}]) =&gt; true (m/validate my-schema [{:a 1} {:c 3}]) =&gt; false"><y>#</y><d>2022-04-15</d><h>18:53</h><w>hjrnunes</w>Hi. Say I want to validate a sequence of maps and make sure there&apos;s at least one of them with a specific entry. Is this in scope for Malli? How would I go about it?  Example:
<pre>;; my schema is something that somehow looks for [:b 2] in a map sequence

(m/validate my-schema [{:a 1} {:b 2} {:c 3}])
=&gt; true

(m/validate my-schema [{:a 1} {:b 2} {:b 2 :c 4} {:c 3}])
=&gt; true

(m/validate my-schema [{:a 1} {:c 3}])
=&gt; false</pre></z><z id="t1650049216" t="NoahTheDuke you can use https://cljdoc.org/d/metosin/malli/0.8.4/doc/readme#fn-schemas to validate &quot;anything&quot;: (def my-schema [:and [:sequence map?] [:fn (fn [s] (some #(= 2 (:b %)) s))]]) i haven&apos;t tried that but it should work"><y>#</y><d>2022-04-15</d><h>19:00</h><w>NoahTheDuke</w>you can use <a href="https://cljdoc.org/d/metosin/malli/0.8.4/doc/readme#fn-schemas" target="_blank">https://cljdoc.org/d/metosin/malli/0.8.4/doc/readme#fn-schemas</a> to validate &quot;anything&quot;:
<pre>(def my-schema
  [:and
   [:sequence map?]
   [:fn (fn [s] (some #(= 2 (:b %)) s))]])</pre>
i haven&apos;t tried that but it should work</z><z id="t1650053038" t="Luke Johnson I’m sure this has been asked before, but is there a way to generate a value compared to the generated value of a key in the same map schema? {:min-value 250 ;; generated :max-value 350} ;; always exactly 100 more than min Looking through the documentation, I can’t find anything specific. https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas looks promising or maybe using :gen/fmap but I could really use some guidance."><y>#</y><d>2022-04-15</d><h>20:03</h><w>Luke Johnson</w>I’m sure this has been asked before, but is there a way to generate a value compared to the generated value of a key in the same map schema?
<pre>{:min-value 250  ;; generated
 :max-value 350} ;; always exactly 100 more than min</pre>
Looking through the documentation, I can’t find anything specific. <a href="https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#dependent-string-schemas</a> looks promising or maybe using <code>:gen/fmap</code> but I could really use some guidance.</z><z id="t1650118449" t="Ivan Fedorov Can I define registry props with options and then reuse these options when I reference props in :map definitions?"><y>#</y><d>2022-04-16</d><h>14:14</h><w>Ivan Fedorov</w>Can I define registry props with options and then reuse these options when I reference props in <code>:map</code> definitions?</z><z id="t1650303331" t="mauricio.szabo Hi, I was playing with instrumentation on Malli, but I can&apos;t find a way to define a function that accepts two args: one int? and other a tuple of int? and string? . Essentially, I want to allow a function to accept (some-function 10 [20 &quot;string&quot;]) as arguments. How do I do this?"><y>#</y><d>2022-04-18</d><h>17:35</h><w>mauricio.szabo</w>Hi, I was playing with instrumentation on Malli, but I can&apos;t find a way to define a function that accepts two args: one <code>int?</code> and other a tuple of <code>int?</code> and <code>string?</code>. Essentially, I want to allow a function to accept <code>(some-function 10 [20 &quot;string&quot;])</code> as arguments. How do I do this?</z><z id="t1650306034" t="ikitommi maybe: (m/validate [:cat int? [:tuple int? string?]] [10 [20 &quot;string&quot;]]) ; =&gt; true"><y>#</y><d>2022-04-18</d><h>18:20</h><r>ikitommi</r>maybe:
<pre>(m/validate [:cat int? [:tuple int? string?]] [10 [20 &quot;string&quot;]])
; =&gt; true</pre></z><z id="t1650378188" t="mauricio.szabo Yeah, that worked, thanks! I was trying with repeated :cat but that got me some weird messages......"><y>#</y><d>2022-04-19</d><h>14:23</h><r>mauricio.szabo</r>Yeah, that worked, thanks! I was trying with repeated <code>:cat</code> but that got me some weird messages......</z><z id="t1650529714" t="dharrigan I&apos;m wondering, after looking at the examples, I still can&apos;t really figure out how to decode a string into lowercase. I have something like this:"><y>#</y><d>2022-04-21</d><h>08:28</h><w>dharrigan</w>I&apos;m wondering, after looking at the examples, I still can&apos;t really figure out how to decode a string into lowercase. I have something like this:</z><z id="t1650529716" t="dharrigan (def foo [:map {:closed true} [:name [:string {:max 256 :error/message &quot;should be at most 256 characters&quot;}]] [:email-address [:string {:decode/string &apos;clojure.string/lower-case :min 5 :max 100 :error/message &quot;should be between 5 and 100 characters&quot;}]]]) (m/validate foo {:name &quot;foo&quot; :email-address &quot;"><y>#</y><d>2022-04-21</d><h>08:28</h><w>dharrigan</w><pre>(def foo [:map
            {:closed true}
            [:name [:string {:max 256 :error/message &quot;should be at most 256 characters&quot;}]]
            [:email-address [:string {:decode/string &apos;clojure.string/lower-case :min 5 :max 100 :error/message &quot;should be between 5 and 100 characters&quot;}]]])

  (m/validate foo {:name &quot;foo&quot; :email-address &quot;</pre></z><z id="t1650529770" t="dharrigan What my objective is (in tandem with reitit), is to ensure that the email address coming in is all in lowercase. Bit of a puzzler."><y>#</y><d>2022-04-21</d><h>08:29</h><w>dharrigan</w>What my objective is (in tandem with reitit), is to ensure that the email address coming in is all in lowercase. Bit of a puzzler.</z><z id="t1650529798" t="dharrigan Any pointers would be appreciated. Thank you."><y>#</y><d>2022-04-21</d><h>08:29</h><w>dharrigan</w>Any pointers would be appreciated. Thank you.</z><z id="t1650531930" t="dharrigan So, got it to work, after plugging away at it for a bit:"><y>#</y><d>2022-04-21</d><h>09:05</h><r>dharrigan</r>So, got it to work, after plugging away at it for a bit:</z><z id="t1650531944" t="dharrigan (m/decode signup-request {:name &quot;foo&quot; :email-address &quot;"><y>#</y><d>2022-04-21</d><h>09:05</h><r>dharrigan</r><code>(m/decode signup-request {:name &quot;foo&quot; :email-address &quot;</code></z><z id="t1650531961" t="dharrigan difference being to use a string-transformer not a json-transformer"><y>#</y><d>2022-04-21</d><h>09:06</h><r>dharrigan</r>difference being to use a <code>string-transformer</code> not a <code>json-transformer</code></z><z id="t1650532686" t="dharrigan Although, it doesn&apos;t appear to work with reitit and it&apos;s use of json-transformer."><y>#</y><d>2022-04-21</d><h>09:18</h><r>dharrigan</r>Although, it doesn&apos;t appear to work with reitit and it&apos;s use of json-transformer.</z><z id="t1650531114" t="Roee Mazor Hi, I am looking at this example: (m/validate [:alt keyword? string?] [&quot;foo&quot;]) ; =&gt; true and I am wondering why it works that way, why not: (m/validate [:alt keyword? string?] &quot;foo&quot;) ; =&gt; true "><y>#</y><d>2022-04-21</d><h>08:51</h><w>Roee Mazor</w>Hi, I am looking at this example:
<pre>(m/validate [:alt keyword? string?] [&quot;foo&quot;]) ; =&gt; true</pre>
and I am wondering why it works that way, why not:
<pre>(m/validate [:alt keyword? string?] &quot;foo&quot;) ; =&gt; true</pre>
</z><z id="t1650531167" t="Roee Mazor (the second one says false which means the alt thing actually makes it look for a sequence for some reason, how can I use :alt without a vec/seq?)"><y>#</y><d>2022-04-21</d><h>08:52</h><r>Roee Mazor</r>(the second one says <code>false</code> which means the alt thing actually makes it look for a sequence for some reason, how can I use <code>:alt</code> without a vec/seq?)</z><z id="t1650531696" t="Martynas M Try :or"><y>#</y><d>2022-04-21</d><h>09:01</h><r>Martynas M</r>Try <code>:or</code></z><z id="t1650531772" t="Roee Mazor perfect, that works perfectly ❤️"><y>#</y><d>2022-04-21</d><h>09:02</h><r>Roee Mazor</r>perfect, that works perfectly <b>❤️</b></z><z id="t1650546488" t="Ben Sless Alt is for sequence schemas. It&apos;s the | operator in regular expressions"><y>#</y><d>2022-04-21</d><h>13:08</h><r>Ben Sless</r>Alt is for sequence schemas. It&apos;s the | operator in regular expressions</z><z id="t1650770912" t="minosniu Hi, I&apos;m getting a strange error when running the http://malli.io example of &quot;Pet&quot; in Clojure (not Clojurescript). Code here:"><y>#</y><d>2022-04-24</d><h>03:28</h><w>minosniu</w>Hi, I&apos;m getting a strange error when running the <a href="http://malli.io" target="_blank">http://malli.io</a> example of &quot;Pet&quot; in Clojure (not Clojurescript). Code here:</z><z id="t1650770940" t="minosniu (def PetMalli [:schema {:registry {&quot;Pet&quot; [:map [:type keyword?] [:name string?]] &quot;Cat&quot; [:merge &quot;Pet&quot; [:map [:type [:= &quot;Cat&quot;]] [:huntingSkill [:enum {:description &quot;The measured skill for hunting&quot;} :clueless, :lazy, :adventurous, :aggressive]]]] &quot;Dog&quot; [:merge &quot;Pet&quot; [:map [:type [:= &quot;Dog&quot;]] [:packSize [:int {:min 0, :default 0 :description &quot;the size of the pack the dog is from&quot;}]]]]}} [:multi {:dispatch :type} &quot;Cat&quot; &quot;Dog&quot;]]) (m/validate PetMalli {:type &quot;Cat&quot;, :name &quot;Viivi&quot;, :huntingSkill :adventurous})"><y>#</y><d>2022-04-24</d><h>03:29</h><w>minosniu</w><pre>(def PetMalli
    [:schema {:registry {&quot;Pet&quot; [:map
                                [:type keyword?]
                                [:name string?]]
                         &quot;Cat&quot; [:merge
                                &quot;Pet&quot;
                                [:map
                                 [:type [:= &quot;Cat&quot;]]
                                 [:huntingSkill [:enum {:description &quot;The measured skill for hunting&quot;}
                                                 :clueless, :lazy, :adventurous, :aggressive]]]]
                         &quot;Dog&quot; [:merge
                                &quot;Pet&quot;
                                [:map
                                 [:type [:= &quot;Dog&quot;]]
                                 [:packSize [:int {:min 0,
                                                   :default 0
                                                   :description &quot;the size of the pack the dog is from&quot;}]]]]}}
     [:multi {:dispatch :type} &quot;Cat&quot; &quot;Dog&quot;]])

(m/validate PetMalli {:type &quot;Cat&quot;, :name &quot;Viivi&quot;, :huntingSkill :adventurous})</pre></z><z id="t1650770994" t="minosniu Message: Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136). :malli.core/invalid-schema {:schema :merge}"><y>#</y><d>2022-04-24</d><h>03:29</h><w>minosniu</w>Message: Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136).
 :malli.core/invalid-schema {:schema :merge}</z><z id="t1650771082" t="minosniu Could anyone give me some pointers? We want to use :merge for some inheritance-like constraints in our schema, which is very similar to the &quot;Pet&quot; example."><y>#</y><d>2022-04-24</d><h>03:31</h><w>minosniu</w>Could anyone give me some pointers? We want to use :merge for some inheritance-like constraints in our schema, which is very similar to the &quot;Pet&quot; example.</z><z id="t1650772723" t="Ben Sless Merge is in another registry. You need to merge it into the registry you&apos;re creating. It&apos;s in malli util, I think"><y>#</y><d>2022-04-24</d><h>03:58</h><r>Ben Sless</r>Merge is in another registry. You need to merge it into the registry you&apos;re creating. It&apos;s in malli util, I think</z><z id="t1650773961" t="minosniu My guess, too. But the code might get somewhat cumbersome. It&apos;s strange that the same code from the Pet example simply won&apos;t work, notice that in the example only local registry was used."><y>#</y><d>2022-04-24</d><h>04:19</h><r>minosniu</r>My guess, too. But the code might get somewhat cumbersome. It&apos;s strange that the same code from the Pet example simply won&apos;t work, notice that in the example only local registry was used.</z><z id="t1650774315" t="Ben Sless Yeah that&apos;s something I&apos;m still iffy about. Will wait for Tommi to chime in"><y>#</y><d>2022-04-24</d><h>04:25</h><r>Ben Sless</r>Yeah that&apos;s something I&apos;m still iffy about. Will wait for Tommi to chime in</z><z id="t1650893315" t="dvingo I don&apos;t think it&apos;s that misleading - the code is available here where the initial default registry is setup: https://github.com/metosin/malli.io/blob/master/src/malli/web.cljs#L28"><y>#</y><d>2022-04-25</d><h>13:28</h><w>dvingo</w>I don&apos;t think it&apos;s that misleading - the code is available here where the initial default registry is setup: <a href="https://github.com/metosin/malli.io/blob/master/src/malli/web.cljs#L28" target="_blank">https://github.com/metosin/malli.io/blob/master/src/malli/web.cljs#L28</a></z><z id="t1650895121" t="dvingo linking to these sources from the site is probably a good idea though"><y>#</y><d>2022-04-25</d><h>13:58</h><r>dvingo</r>linking to these sources from the site is probably a good idea though</z><z id="t1650895444" t="minosniu Worked like a charm:dizzy:"><y>#</y><d>2022-04-25</d><h>14:04</h><r>minosniu</r>Worked like a charm:dizzy:</z><z id="t1650893386" t="dvingo I think it&apos;s apparent that the local registry being used does not contain all of the schemas available (not just :merge)"><y>#</y><d>2022-04-25</d><h>13:29</h><w>dvingo</w>I think it&apos;s apparent that the local registry being used does not contain all of the schemas available (not just :merge)</z><z id="t1650896119" t="ikitommi maybe the util-schema types should be prefixed? e.g. :merge -&gt; :util/merge to make the it more explicit that they are not part of the default registry? btw this works too: (def Merge (mu/-merge)) (m/validate [Merge [:map [:x :int]] [:map [:y :int]]] {:x 1, :y 2}) ; =&gt; true"><y>#</y><d>2022-04-25</d><h>14:15</h><w>ikitommi</w>maybe the util-schema types should be prefixed? e.g. <code>:merge</code> -&gt; <code>:util/merge</code> to make the it more explicit that they are not part of the default registry? btw this works too:
<pre>(def Merge (mu/-merge))

(m/validate [Merge [:map [:x :int]] [:map [:y :int]]] {:x 1, :y 2}) ; =&gt; true</pre></z><z id="t1650897070" t="minosniu :util/merge seems more prominent and alerting."><y>#</y><d>2022-04-25</d><h>14:31</h><r>minosniu</r><code>:util/merge</code> seems more prominent and alerting.</z><z id="t1650961756" t="Martynas M Hey. Is there a way to decode a string into a symbol? (malli.core/decode [:enum &apos;identity] &quot;identity&quot; decode-transformer) I want to parse JSON and I want to parse a string into a symbol but I want to force this exact value. I could define my own decoder and I did it in one other case but I don&apos;t think I want to define too many of them."><y>#</y><d>2022-04-26</d><h>08:29</h><w>Martynas M</w>Hey.
Is there a way to decode a string into a symbol?

<pre>(malli.core/decode [:enum &apos;identity]
                   &quot;identity&quot;
                   decode-transformer)</pre>
I want to parse JSON and I want to parse a string into a symbol but I want to force this exact value.

I could define my own decoder and I did it in one other case but I don&apos;t think I want to define too many of them.</z><z id="t1650961864" t="Martynas M Probably this is the way: [:and :symbol [:enum &apos;identity]]"><y>#</y><d>2022-04-26</d><h>08:31</h><r>Martynas M</r>Probably this is the way:
<pre>[:and :symbol [:enum &apos;identity]]</pre></z><z id="t1650968272" t="Ben Sless You can specify your own decoder in the schema"><y>#</y><d>2022-04-26</d><h>10:17</h><r>Ben Sless</r>You can specify your own decoder in the schema</z><z id="t1650968308" t="Ben Sless Where you can just put the symbol decoder"><y>#</y><d>2022-04-26</d><h>10:18</h><r>Ben Sless</r>Where you can just put the symbol decoder</z><z id="t1650963516" t="Martynas M This fails to generate: (malli.generator/generate [:and :symbol [:enum &apos;my-symbol]]) Should I create an issue?"><y>#</y><d>2022-04-26</d><h>08:58</h><w>Martynas M</w>This fails to generate:
<code>(malli.generator/generate [:and :symbol [:enum &apos;my-symbol]])</code>

Should I create an issue?</z><z id="t1650972663" t="ikitommi oh, that’s an test.check impl detail, not sure how much we can do for it."><y>#</y><d>2022-04-26</d><h>11:31</h><r>ikitommi</r>oh, that’s an test.check impl detail, not sure how much we can do for it.</z><z id="t1650972710" t="ikitommi e.g. when multiple constraints, first one is used for generation and the rest to filter that the first one generated valid values."><y>#</y><d>2022-04-26</d><h>11:31</h><r>ikitommi</r>e.g. when multiple constraints, first one is used for generation and the rest to filter that the first one generated valid values.</z><z id="t1650972779" t="ikitommi quick &amp; dirty fix, override the generator: (malli.generator/generate [:and {:gen/schema [:enum &apos;my-symbol]} :symbol [:enum &apos;my-symbol]])"><y>#</y><d>2022-04-26</d><h>11:32</h><r>ikitommi</r>quick &amp; dirty fix, override the generator:
<pre>(malli.generator/generate [:and {:gen/schema [:enum &apos;my-symbol]} :symbol [:enum &apos;my-symbol]])</pre></z><z id="t1651125588" t="Martynas M I made this function for myself: (defn exact-symbol [sym] [:and {:gen/schema [:enum sym]} :symbol [:enum sym]]) I simply use the generator to validate that my schema is correct. If it generates then it is somewhat correct. My assumption is that if the generator can pick it up then it&apos;s a valid definition (not that the result is valid but the definition)."><y>#</y><d>2022-04-28</d><h>05:59</h><r>Martynas M</r>I made this function for myself:
<pre>(defn exact-symbol [sym]
  [:and {:gen/schema [:enum sym]} :symbol [:enum sym]])</pre>
I simply use the generator to validate that my schema is correct. If it generates then it is somewhat correct.
My assumption is that if the generator can pick it up then it&apos;s a valid definition (not that the result is valid but the definition).</z><z id="t1651066428" t="Ferdinand Beyer I might have found a bug Malli’s clj-kondo type config generation when using :re schemas. Instead of expecting a string matching a regular expression, clj-kondo expects an argument to be of regular expression type. Or did I misunderstand something?"><y>#</y><d>2022-04-27</d><h>13:33</h><w>Ferdinand Beyer</w>I might have found a bug Malli’s <code>clj-kondo</code> type config generation when using <code>:re</code> schemas. Instead of expecting a string matching a regular expression, <code>clj-kondo</code> expects an argument to be of regular expression type. Or did I misunderstand something?</z><z id="t1651072633" t="dvingo can you share the clj-kondo configuration for that function?"><y>#</y><d>2022-04-27</d><h>15:17</h><w>dvingo</w>can you share the clj-kondo configuration for that function?</z><z id="t1651072708" t="dvingo the kondo code outputs :regex for :re schemas: https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/clj_kondo.cljc#L101 and I&apos;m not certain but I think kondo expects a string: https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L20"><y>#</y><d>2022-04-27</d><h>15:18</h><w>dvingo</w>the kondo code outputs <code>:regex</code> for <code>:re</code> schemas: <a href="https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/clj_kondo.cljc#L101" target="_blank">https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/clj_kondo.cljc#L101</a> and I&apos;m not certain but I think kondo expects a string: <a href="https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L20" target="_blank">https://github.com/clj-kondo/clj-kondo/blob/d9fca2705863e3e604e004ccb942e0b3d2e268ec/src/clj_kondo/impl/types.clj#L20</a></z><z id="t1651074547" t="Ferdinand Beyer Unfortunately I deleted this example file already, but I can confirm that I get :regex in the config, and I agree that this should probably be :string"><y>#</y><d>2022-04-27</d><h>15:49</h><r>Ferdinand Beyer</r>Unfortunately I deleted this example file already, but I can confirm that I get <code>:regex</code> in the config, and I agree that this should probably be <code>:string</code></z><z id="t1651074582" t="Ferdinand Beyer Having said that, I never worked with clj-kondo that deeply so I don’t know what ops/types it accepts"><y>#</y><d>2022-04-27</d><h>15:49</h><r>Ferdinand Beyer</r>Having said that, I never worked with <code>clj-kondo</code> that deeply so I don’t know what ops/types it accepts</z><z id="t1651081812" t="dvingo looks like the :regex type in kondo expects a regex: https://github.com/clj-kondo/clj-kondo/blob/master/doc/types.md added this to the config: $ cat .clj-kondo/config.edn {:linters {:type-mismatch {:level :warning :namespaces {foo {foo {:arities {1 {:args [:regex] :ret :string}}}}}}}}"><y>#</y><d>2022-04-27</d><h>17:50</h><r>dvingo</r>looks like the <code>:regex</code>  type in kondo expects a regex:
<a href="https://github.com/clj-kondo/clj-kondo/blob/master/doc/types.md" target="_blank">https://github.com/clj-kondo/clj-kondo/blob/master/doc/types.md</a>
added this to the config:
<pre>$ cat .clj-kondo/config.edn
{:linters
 {:type-mismatch
  {:level :warning
   :namespaces {foo {foo {:arities {1 {:args [:regex] :ret :string}}}}}}}}</pre></z><z id="t1651081831" t="dvingo and then: $ clj-kondo --lint - &lt;&lt;&lt;&apos;(ns bar (:require [foo :refer [foo]])) (foo &quot;&quot;)&apos; &lt;stdin&gt;:1:45: warning: Expected: regular expression, received: string. linting took 12ms, errors: 0, warnings: 1 $ clj-kondo --lint - &lt;&lt;&lt;&apos;(ns bar (:require [foo :refer [foo]])) (foo #&quot;&quot;)&apos; linting took 11ms, errors: 0, warnings: 0"><y>#</y><d>2022-04-27</d><h>17:50</h><r>dvingo</r>and then:
<pre>$ clj-kondo --lint - &lt;&lt;&lt;&apos;(ns bar (:require [foo :refer [foo]])) (foo &quot;&quot;)&apos;
&lt;stdin&gt;:1:45: warning: Expected: regular expression, received: string.
linting took 12ms, errors: 0, warnings: 1</pre>
<pre>$ clj-kondo --lint - &lt;&lt;&lt;&apos;(ns bar (:require [foo :refer [foo]])) (foo #&quot;&quot;)&apos;
linting took 11ms, errors: 0, warnings: 0</pre></z><z id="t1651476914" t="Ferdinand Beyer I created a PR with a tiny fix for this here: https://github.com/metosin/malli/pull/701"><y>#</y><d>2022-05-02</d><h>07:35</h><r>Ferdinand Beyer</r>I created a PR with a tiny fix for this here: <a href="https://github.com/metosin/malli/pull/701" target="_blank">https://github.com/metosin/malli/pull/701</a></z><z id="t1651481460" t="ikitommi Merged, thanks!"><y>#</y><d>2022-05-02</d><h>08:51</h><r>ikitommi</r>Merged, thanks!</z><z id="t1651481744" t="Ferdinand Beyer That was fast, thanks 🙂"><y>#</y><d>2022-05-02</d><h>08:55</h><r>Ferdinand Beyer</r>That was fast, thanks <b>🙂</b></z><z id="t1651083446" t="Keith Houser Why does humanize not have &quot;Wrong!!&quot; message when wrong value is in the first position? ({:forms (d), :human [[&quot;should be a&quot; &quot;should be b&quot; &quot;should be c&quot;]]} {:forms (a d c), :human [nil [&quot;should be a&quot; &quot;should be b&quot; &quot;should be c&quot; &quot;Wrong!!&quot;]]})"><y>#</y><d>2022-04-27</d><h>18:17</h><w>Keith Houser</w>Why does humanize not have &quot;Wrong!!&quot; message when wrong value is in the first position?

<pre>({:forms (d),
  :human [[&quot;should be a&quot; &quot;should be b&quot; &quot;should be c&quot;]]}
 {:forms (a d c),
  :human [nil [&quot;should be a&quot; &quot;should be b&quot; &quot;should be c&quot; &quot;Wrong!!&quot;]]})</pre></z><z id="t1651476914" t="Ferdinand Beyer I created a PR with a tiny fix for this here: https://github.com/metosin/malli/pull/701"><y>#</y><d>2022-05-02</d><h>07:35</h><w>Ferdinand Beyer</w>I created a PR with a tiny fix for this here: <a href="https://github.com/metosin/malli/pull/701" target="_blank">https://github.com/metosin/malli/pull/701</a></z><z id="t1651168577" t="dumrat Why? (m/validate [:map [:type :keyword] [:name {:min 1 :max 128} string?]] {:type :ledger :name &quot;&quot;}) =&gt; true"><y>#</y><d>2022-04-28</d><h>17:56</h><w>dumrat</w>Why?

<pre>(m/validate 
   [:map
    [:type :keyword]
    [:name {:min 1 :max 128} string?]]
   {:type :ledger :name &quot;&quot;}) =&gt; true</pre></z><z id="t1651168888" t="dharrigan Try this:"><y>#</y><d>2022-04-28</d><h>18:01</h><w>dharrigan</w>Try this:</z><z id="t1651168891" t="dharrigan (m/validate [:map [:type :keyword] [:name [:string {:min 1 :max 128}]]] {:type :ledger :name &quot;&quot;}) ;; false"><y>#</y><d>2022-04-28</d><h>18:01</h><w>dharrigan</w><pre>(m/validate
  [:map
   [:type :keyword]
   [:name [:string {:min 1 :max 128}]]]
  {:type :ledger :name &quot;&quot;}) ;; false</pre></z><z id="t1651168910" t="dharrigan (m/validate [:map [:type :keyword] [:name [:string {:min 1 :max 128}]]] {:type :ledger :name &quot;foo&quot;}) ;; true"><y>#</y><d>2022-04-28</d><h>18:01</h><w>dharrigan</w><pre>(m/validate
  [:map
   [:type :keyword]
   [:name [:string {:min 1 :max 128}]]]
  {:type :ledger :name &quot;foo&quot;})  ;; true</pre></z><z id="t1651220020" t="rayat Need help: (shadow) CLJS + Malli + console multiline printing weirdness - really cannot figure this out. More details in thread ⬇️ But TLDR: `pretty/reporter` is doing something really crazy, it prints every single character/&quot;word&quot; (or fipp document node, if I&apos;m not mistaken) on new lines creating [:attrs nil] illegible walls of text in my console. "><y>#</y><d>2022-04-29</d><h>08:13</h><w>rayat</w>Need help: 

(shadow) CLJS + Malli + console multiline printing weirdness - really cannot figure this out.

More details in thread <b>⬇️</b>

But TLDR: `pretty/reporter` is doing something really crazy, it prints every single character/&quot;word&quot; (or <code>fipp</code> document node, if I&apos;m not mistaken) on new lines creating <b>MASSIVE</b> illegible walls of text in my console. </z><z id="t1651220427" t="ikitommi are you using the latest code from master? I believe that is fixed."><y>#</y><d>2022-04-29</d><h>08:20</h><r>ikitommi</r>are you using the latest code from master? I believe that is fixed.</z><z id="t1651220460" t="rayat &gt; I&apos;ve also tried other reporters, including just straight console log/warn/error, but since pretty/reporter is the closest to working and the one whose intended output I want, I&apos;ll focus on that one. I’ve tried pretty/reporter, console.log/error/warn, pretty/thrower and have even copied and modified tons of the function call chain of pretty/reporter However: 1. With thrower and default -fail completely illegible schema failures are printed a. It is extremely &quot;horizontal/squished&quot; b. and more importantly even inspected in devtools repl, I cannot see the schema failure contents, just the data of the schema I wrote in the first place i. (I&apos;ve expanded all the folding bits in devtool&apos;s custom formatted content for the error) 2. I also tried replacing some logic within pprint-document (more on that fn to follow) to console.warn instead, and got some progress somehow a. This is the first screenshot b. But as you can see, it looks like it&apos;s printing actual characters, instead of what I believe might be encodings for whitespace? 3. And with pretty/reporter , it looks like something about the whitespace is messed up, and so is also nearly illegible a. (second screenshot) b. The content does print, but it looks like each word boundary whitespace is printed as a new line, and most of the time, it&apos;s several empty newlines per. c. As I step through pprint-document, it looks like after the document goes through (serialize document) and the (eduction chain, the print call in (run! print) receives each individual word, instead of the lines that (I think) should have those words in them (-&gt;&gt; (serialize document) (eduction annotate-rights (annotate-begins options) (format-nodes options)) (run! print)) a. I thought it might have been the println line after the bit I just posted, but it just (as expected) added an extra newline after all the words from the schema error/document had been newline-printed b. In the screenshot you&apos;ll see console.group being used from one my modifications, just for convenience against scrolling through massive number of lines in the console I&apos;m really confused and stuck by this, and can&apos;t seem to find any mention of this in the malli docs, api browser, GitHub issues and slack search about this, or if anyone else has faced this. I&apos;ve tried: 1. explicitly setting the print fn to be console.log/error/warn, even window.alert to see if there was some global pollution of my console var making it split several times per word 2. inspecting the contents of document as passed to format-nodes and pruning bits of the latter&apos;s cond conditions/code to only address :group, :text etc 3. opening a fresh new chrome profile with no extensions or anything 4. removing any and all scripts from our &lt;head&gt; like tracing/analytics tools Maybe it&apos;s something about my work stack or setup or something. I&apos;m new to clojure though, and so I&apos;ve never created any clojure projects of my own, let alone shadowcljs web-apps. If it is required tho, I can try looking into making a repro project Does "><y>#</y><d>2022-04-29</d><h>08:21</h><r>rayat</r>&gt; I&apos;ve also tried other reporters, including just straight console log/warn/error, but since <code>pretty/reporter</code> is the closest to working and the one whose intended output I want, I&apos;ll focus on that one.
I’ve tried <code>pretty/reporter, console.log/error/warn, pretty/thrower</code> and have even copied and modified tons of the function call chain of <code>pretty/reporter</code> However:

1. With thrower and default -fail completely illegible schema failures are printed
    a. It is extremely &quot;horizontal/squished&quot; 
    b. and more importantly even inspected in devtools repl, I cannot see the schema failure contents, just the data of the schema I wrote in the first place
        i. (I&apos;ve expanded all the folding bits in devtool&apos;s custom formatted content for the error)
2. I also tried replacing some logic within <code>pprint-document</code> (more on that fn to follow) to console.warn instead, and got some progress somehow
    a. This is the first screenshot
    b. But as you can see, it looks like it&apos;s printing actual characters, instead of what I believe might be encodings for whitespace?
3. And with <code>pretty/reporter</code>, it looks like something about the whitespace is messed up, and so is also nearly illegible 
    a. (second screenshot)
    b. The content does print, but it looks like each word boundary whitespace is printed as a new line, and most of the time, it&apos;s several empty newlines per.
    c. As I step through pprint-document, it looks like after the document goes through (serialize document) and the (eduction chain, the print call in (run! print)  receives each individual word, instead of the lines that (I think) should have those words in them
<pre>(-&gt;&gt; (serialize document)
          (eduction
            annotate-rights
            (annotate-begins options)
            (format-nodes options))
          (run! print))</pre>
    a. I thought it might have been the println line after the bit I just posted, but it just (as expected) added an extra newline after all the words from the schema error/document had been newline-printed
    b. In the screenshot you&apos;ll see console.group being used from one my modifications, just for convenience against scrolling through massive number of lines in the console
I&apos;m really confused and stuck by this, and can&apos;t seem to find any mention of this in the malli docs, api browser, GitHub issues and slack search about this, or if anyone else has faced this.

I&apos;ve tried:
1. explicitly setting the print fn to be console.log/error/warn, even window.alert to see if there was some global pollution of my console var making it split several times per word
2. inspecting the contents of document as passed to format-nodes and pruning bits of the latter&apos;s cond conditions/code to only address :group, :text etc 
3. opening a fresh new chrome profile with no extensions or anything
4. removing any and all scripts from our &lt;head&gt; like tracing/analytics tools
Maybe it&apos;s something about my work stack or setup or something. I&apos;m new to clojure though, and so I&apos;ve never created any clojure projects of my own, let alone shadowcljs web-apps. If it is required tho, I can try looking into making a repro project

Does </z><z id="t1651220508" t="rayat [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I have [metosin.malli LATEST] in lein , do you mean a direct git dependency or something?"><y>#</y><d>2022-04-29</d><h>08:21</h><r>rayat</r><a>@U055NJ5CC</a>, I have <code>[metosin.malli LATEST]</code>  in <code>lein</code>, do you mean a direct git dependency or something?</z><z id="t1651224875" t="rayat Oh crazy, I only just found the https://github.com/metosin/malli/issues/675 . Unfortunately at my work we use lein, which has no native git-based dependency support. I think I&apos;d have an easier time justifying the introduction of malli itself versus lein plugin into our work codebase, or split our lein config into using tools.deps for dependencies. Is there If not, I understand. But then I ask if there&apos;s any recommendation you can give to get as much of the latest master&apos;s fixes on this bug? Thanks again."><y>#</y><d>2022-04-29</d><h>09:34</h><r>rayat</r>Oh crazy, I only just found the <a href="https://github.com/metosin/malli/issues/675" target="_blank">https://github.com/metosin/malli/issues/675</a>.

Unfortunately at my work we use lein, which has no native git-based dependency support. I think I&apos;d have an easier time justifying the introduction of malli itself versus lein plugin into our work codebase, or split our lein config into using <code>tools.deps</code> for dependencies.

Is there 

If not, I understand. But then I ask if there&apos;s any recommendation you can give to get as much of the latest master&apos;s fixes on this bug?

Thanks again.</z><z id="t1651224875" t="rayat Oh crazy, I only just found the https://github.com/metosin/malli/issues/675 . Unfortunately at my work we use lein, which has no native git-based dependency support. I think I&apos;d have an easier time justifying the introduction of malli itself versus lein plugin into our work codebase, or split our lein config into using tools.deps for dependencies. Is there If not, I understand. But then I ask if there&apos;s any recommendation you can give to get as much of the latest master&apos;s fixes on this bug? Thanks again."><y>#</y><d>2022-04-29</d><h>09:34</h><w>rayat</w>Oh crazy, I only just found the <a href="https://github.com/metosin/malli/issues/675" target="_blank">https://github.com/metosin/malli/issues/675</a>.

Unfortunately at my work we use lein, which has no native git-based dependency support. I think I&apos;d have an easier time justifying the introduction of malli itself versus lein plugin into our work codebase, or split our lein config into using <code>tools.deps</code> for dependencies.

Is there 

If not, I understand. But then I ask if there&apos;s any recommendation you can give to get as much of the latest master&apos;s fixes on this bug?

Thanks again.</z><z id="t1651242432" t="dvingo yep very recent fix: https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de"><y>#</y><d>2022-04-29</d><h>14:27</h><w>dvingo</w>yep very recent fix: <a href="https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de" target="_blank">https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de</a></z><z id="t1651244319" t="dvingo being stuck on lein is unfortunate, I led a project off of lein to deps across multiple repos last year and know that pain. however, thanks to Tommi&apos;s excellent design of having the reporter be a function you provide, you can address this in your own codebase: https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/dev/cljs.cljc#L32 just copy this ns: https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc and this one: src/malli/dev/virhe.cljc to include the relevant fix: https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de#diff-78b0ed5a31a32de704a1f77385e434d91bc5a44a0f74d37bd313ea96a130d97cR27 it should be noted there were two even more recent fixes for cljs though. the implication is that things will work without those fixes only for :malli/schema metadata style function schemas but that should get you unblocked!"><y>#</y><d>2022-04-29</d><h>14:58</h><w>dvingo</w>being stuck on lein is unfortunate, I led a project off of lein to deps across multiple repos last year and know that pain.

however, thanks to Tommi&apos;s excellent design of having the reporter be a function you provide, you can address this in your own codebase:
<a href="https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/dev/cljs.cljc#L32" target="_blank">https://github.com/metosin/malli/blob/a3db330eae029863e9be443cda3a2cafd8f61a33/src/malli/dev/cljs.cljc#L32</a>

just copy this ns:
<a href="https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc</a>
and this one:
src/malli/dev/virhe.cljc
to include the relevant fix:
<a href="https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de#diff-78b0ed5a31a32de704a1f77385e434d91bc5a44a0f74d37bd313ea96a130d97cR27" target="_blank">https://github.com/metosin/malli/commit/d1a28f734e6fa3e2f669d5cb08ecfcd0558991de#diff-78b0ed5a31a32de704a1f77385e434d91bc5a44a0f74d37bd313ea96a130d97cR27</a>

it should be noted there were two even more recent fixes for cljs though. the implication is that things will work without those fixes only for <code>:malli/schema</code> metadata style function schemas

but that should get you unblocked!</z><z id="t1651248986" t="rayat Thanks so so much for the help! I&apos;ve been trying to figure this out for like a week, too embarrassed in case it was like an extension or external script or some user error that was causing it - I didn&apos;t even think to check if the latest master/docs were released or not. Regarding your points: 1. facepalm I was trying to copy individual functions lol, can&apos;t believe I didn&apos;t think to just copy the relevant ns completely. Will do this post-haste. 2. Of those 2 recent fixes for cljs, it looks like a. https://github.com/metosin/malli/commit/f7b4e12d3fe3e2f60ff50057118308b7a3abe148 is about collecting metadata fn schemas, doesn&apos;t that mean it&apos;s a fix only for metadata style fn schemas? So wouldn&apos;t things work without this fix if I didn&apos;t use metadata style? ( the inverse of what you said) Lastly, since I&apos;m here: 1. I&apos;m actually using neither style, as I&apos;m trying to use malli with helix defnc components. a. I&apos;m directly using a wrapper over (-instrument {:schema ... :reporter ...} some-fn-arg-from-wrapper) i. Would that have some implications regarding any of the since-last-release cljs fixes? b. Without too many specifics, but in case helps to know why, i. defnc does not forward metadata to the expanded fn, so that route doesn&apos;t work, would have otherwise used that 1. (yet again, there&apos;s an unpublished recent change that added metadata forwarding lol - oh lein) ii. the output of the defnc macro could [:attrs nil] be an Fn , in which case =&gt; would work, but at other times it produces a js obj with a key render that has the equivalent Fn 1. This is just a detail of React, wherein the latter case of the obj.render is a special case handled automatically by React iii. so my wrapper just instruments the output of defnc with the provided schema for this special case, so it picks out the render key&apos;s val if it&apos;s an obj, or the fn itself if it&apos;s an fn, and then passes either to -instrument "><y>#</y><d>2022-04-29</d><h>16:16</h><r>rayat</r>Thanks so so much for the help! I&apos;ve been trying to figure this out for like a week, too embarrassed in case it was like an extension or external script or some user error that was causing it - I didn&apos;t even think to check if the latest master/docs were released or not.

Regarding your points:

1. <b>facepalm</b> I was trying to copy individual functions lol, can&apos;t believe I didn&apos;t think to just copy the relevant ns completely. Will do this post-haste.
2. Of those 2 recent fixes for cljs, it looks like
    a. <a href="https://github.com/metosin/malli/commit/f7b4e12d3fe3e2f60ff50057118308b7a3abe148" target="_blank">https://github.com/metosin/malli/commit/f7b4e12d3fe3e2f60ff50057118308b7a3abe148</a> is about collecting metadata fn schemas, doesn&apos;t that mean it&apos;s a fix only for metadata style fn schemas? So wouldn&apos;t things work without this fix if I didn&apos;t use metadata style? ( the inverse of what you said)
Lastly, since I&apos;m here:
1. I&apos;m actually using neither  style, as I&apos;m trying to use <code>malli</code> with <code>helix</code> <code>defnc</code> components. 
    a. I&apos;m directly using a wrapper over <code>(-instrument {:schema ... :reporter ...} some-fn-arg-from-wrapper)</code>
        i. Would that have some implications regarding any of the since-last-release cljs fixes?
    b. Without too many specifics, but in case helps to know why, 
        i. <code>defnc</code> does not forward metadata to the expanded fn, so that route doesn&apos;t work, would have otherwise used that
            1. (yet again, there&apos;s an unpublished recent change that added metadata forwarding lol - oh lein)
        ii. the output of the <code>defnc</code> macro could <b>sometimes</b> be an <code>Fn</code> , in which case <code>=&gt;</code> would work, but at other times it produces a js obj with a key <code>render</code> that has the equivalent <code>Fn</code> 
            1. This is just a detail of React, wherein the latter case of the <code>obj.render</code> is a special case handled automatically by React
        iii. so my wrapper just instruments the output of <code>defnc</code> with the provided schema for this special case, so it picks out the <code>render</code> key&apos;s val if it&apos;s an obj, or the fn itself if it&apos;s an fn, and then passes either to <code>-instrument</code> </z><z id="t1651253230" t="dvingo for 2. even though it&apos;s about collect it doesn&apos;t impact functionality - just developer experience (requires saving your code twice to see new fn schemas)"><y>#</y><d>2022-04-29</d><h>17:27</h><r>dvingo</r>for 2. even though it&apos;s about collect it doesn&apos;t impact functionality - just developer experience (requires saving your code twice to see new fn schemas)</z><z id="t1651253325" t="dvingo ok cool, I think using -instrument directly should work - for getting around helix not forwarding meta you can structure your code such that the body of all helix components proxy to your own functions of props -&gt; react element"><y>#</y><d>2022-04-29</d><h>17:28</h><r>dvingo</r>ok cool, I think using <code>-instrument</code> directly should work - for getting around helix not forwarding meta you can structure your code such that the body of all helix components proxy to your own functions of props -&gt; react element</z><z id="t1651253336" t="dvingo and then just instrument those"><y>#</y><d>2022-04-29</d><h>17:28</h><r>dvingo</r>and then just instrument those</z><z id="t1651584140" t="Nikolas Pafitis Hi, I&apos;m using mr/set-default-registry! and I&apos;m getting the following error when running kaocha test runner and the namespaces reload on change. Caused by: java.lang.IllegalArgumentException: No implementation of method: :-schema of protocol: #&apos;malli.registry/Registry found for class: nil at clojure.core$_cache_protocol_fn.invokeStatic (core_deftype.clj:584) ... malli.registry$eval15830$fn__15831$G__15819__15838.invoke (registry.cljc:11) malli.registry$custom_default_registry$reify__15870._schema (registry.cljc:50) malli.core$_lookup.invokeStatic (core.cljc:260) malli.core$_lookup.invoke (core.cljc:258) malli.core$_lookup_BANG_.invokeStatic (core.cljc:265) malli.core$_lookup_BANG_.invoke (core.cljc:263) malli.core$schema.invokeStatic (core.cljc:1985) malli.core$schema.invoke (core.cljc:1963) malli.core$properties.invokeStatic (core.cljc:1999) malli.core$properties.invoke (core.cljc:1994) malli.core$properties.invokeStatic (core.cljc:1997) malli.core$properties.invoke (core.cljc:1994)"><y>#</y><d>2022-05-03</d><h>13:22</h><w>Nikolas Pafitis</w>Hi, I&apos;m using <code>mr/set-default-registry!</code>  and I&apos;m getting the following error when running kaocha test runner and the namespaces reload on change.
<pre>Caused by: java.lang.IllegalArgumentException: No implementation of method: :-schema of protocol: #&apos;malli.registry/Registry found for class: nil
 at clojure.core$_cache_protocol_fn.invokeStatic (core_deftype.clj:584)
    ...
    malli.registry$eval15830$fn__15831$G__15819__15838.invoke (registry.cljc:11)
    malli.registry$custom_default_registry$reify__15870._schema (registry.cljc:50)
    malli.core$_lookup.invokeStatic (core.cljc:260)
    malli.core$_lookup.invoke (core.cljc:258)
    malli.core$_lookup_BANG_.invokeStatic (core.cljc:265)
    malli.core$_lookup_BANG_.invoke (core.cljc:263)
    malli.core$schema.invokeStatic (core.cljc:1985)
    malli.core$schema.invoke (core.cljc:1963)
    malli.core$properties.invokeStatic (core.cljc:1999)
    malli.core$properties.invoke (core.cljc:1994)
    malli.core$properties.invokeStatic (core.cljc:1997)
    malli.core$properties.invoke (core.cljc:1994)</pre></z><z id="t1651738534" t="pinkfrog Is there any example that uses malli to validate html forms on the frontend side?"><y>#</y><d>2022-05-05</d><h>08:15</h><w>pinkfrog</w>Is there any example that uses malli to validate html forms on the frontend side?</z><z id="t1651762985" t="Alexis Schad Hi there, is there a minimal sample project using Malli instrumentation (during dev) in a shadow-cljs webapp? Or is there a recommended configuration for https://malli.dev in cljs? I&apos;m struggling a bit to setup it well. -&gt; thread for more info"><y>#</y><d>2022-05-05</d><h>15:03</h><w>Alexis Schad</w>Hi there, is there a minimal sample project using Malli instrumentation (during dev) in a shadow-cljs webapp? Or is there a recommended configuration for <a href="https://malli.dev" target="_blank">https://malli.dev</a> in cljs? I&apos;m struggling a bit to setup it well.
-&gt; thread for more info</z><z id="t1651762999" t="Alexis Schad With a basic configuration I got:"><y>#</y><d>2022-05-05</d><h>15:03</h><r>Alexis Schad</r>With a basic configuration I got:</z><z id="t1651763003" t="Alexis Schad"><y>#</y><d>2022-05-05</d><h>15:03</h><r>Alexis Schad</r></z><z id="t1651763033" t="Alexis Schad with thrower i got:"><y>#</y><d>2022-05-05</d><h>15:03</h><r>Alexis Schad</r>with thrower i got:</z><z id="t1651763036" t="Alexis Schad"><y>#</y><d>2022-05-05</d><h>15:03</h><r>Alexis Schad</r></z><z id="t1651763300" t="dvingo the implementation of that is under active development - if you can use the latest git commit you&apos;ll have better errors"><y>#</y><d>2022-05-05</d><h>15:08</h><r>dvingo</r>the implementation of that is under active development - if you can use the latest git commit you&apos;ll have better errors</z><z id="t1651763369" t="dvingo this thread has some background, I suggest adding this metadata to your entry ns: https://github.com/metosin/malli/issues/695#issuecomment-1116884390"><y>#</y><d>2022-05-05</d><h>15:09</h><r>dvingo</r>this thread has some background, I suggest adding this metadata to your entry ns:
<a href="https://github.com/metosin/malli/issues/695#issuecomment-1116884390" target="_blank">https://github.com/metosin/malli/issues/695#issuecomment-1116884390</a></z><z id="t1651763550" t="Alexis Schad &gt; you&apos;ll have better errors The error seems pretty good rn, it&apos;s just a problem of formatting them inside the console/devtools I&apos;m looking for your link to see if it can improve something"><y>#</y><d>2022-05-05</d><h>15:12</h><r>Alexis Schad</r>&gt;  you&apos;ll have better errors
The error seems pretty good rn, it&apos;s just a problem of formatting them inside the console/devtools

I&apos;m looking for your link to see if it can improve something</z><z id="t1651764117" t="Alexis Schad With the master version of pretty/reporter, there&apos;s a reader conditional for cljs and it now prints well, thanks! I&apos;ll see if I have hot reload issue like your link"><y>#</y><d>2022-05-05</d><h>15:21</h><r>Alexis Schad</r>With the master version of pretty/reporter, there&apos;s a reader conditional for cljs and it now prints well, thanks! I&apos;ll see if I have hot reload issue like your link</z><z id="t1651764607" t="dvingo nice! yea it&apos;s tricky because instrument outputs code where it is called that overwrites the fn - so if you&apos;re iterating on the implementation of the the fn in a separate namespace they can get out of sync"><y>#</y><d>2022-05-05</d><h>15:30</h><r>dvingo</r>nice! yea it&apos;s tricky because instrument outputs code where it is called that overwrites the fn - so if you&apos;re iterating on the implementation of the the fn in a separate namespace they can get out of sync</z><z id="t1651765426" t="Alexis Schad I was using dev/start! but I had to use instrument! instead. I think I don&apos;t need the {:dev/always true} metadata, it seems to just work fine without it (I call instrument! every time the app is hot reloaded)."><y>#</y><d>2022-05-05</d><h>15:43</h><r>Alexis Schad</r>I was using dev/start! but I had to use instrument! instead. I think I don&apos;t need the {:dev/always true} metadata, it seems to just work fine without it (I call instrument! every time the app is hot reloaded).</z><z id="t1651765537" t="dvingo You&apos;ll run into staleness issues described in the ticket without reloading the ns where instrument is called"><y>#</y><d>2022-05-05</d><h>15:45</h><r>dvingo</r>You&apos;ll run into staleness issues described in the ticket without reloading the ns where instrument is called</z><z id="t1651765573" t="dvingo if you macroexpand the intstrument call it can help understand why that happens"><y>#</y><d>2022-05-05</d><h>15:46</h><r>dvingo</r>if you macroexpand the intstrument call it can help understand why that happens</z><z id="t1651766878" t="Alexis Schad I tried to update both the function and the spec and it seems to work well"><y>#</y><d>2022-05-05</d><h>16:07</h><r>Alexis Schad</r>I tried to update both the function and the spec and it seems to work well</z><z id="t1651774508" t="dvingo nice! well alright then lol"><y>#</y><d>2022-05-05</d><h>18:15</h><r>dvingo</r>nice! well alright then lol</z><z id="t1651781361" t="Alexis Schad I didn&apos;t even thank you… so thanks!"><y>#</y><d>2022-05-05</d><h>20:09</h><r>Alexis Schad</r>I didn&apos;t even thank you… so thanks!</z><z id="t1651795321" t="dvingo for sure! no prob - thanks for trying it out! the leverage from malli is pretty remarkable, just helping to add to that power 🙂"><y>#</y><d>2022-05-06</d><h>00:02</h><r>dvingo</r>for sure! no prob - thanks for trying it out! the leverage from malli is pretty remarkable, just helping to add to that power <b>🙂</b></z><z id="t1651883806" t="Alexis Schad I think I&apos;ve just had some issues that has been solved with {:dev/always true} Reloading the webapp was doing nothing, I had to restart my shadow-cljs watch. And with the workaround above it seems to work."><y>#</y><d>2022-05-07</d><h>00:36</h><r>Alexis Schad</r>I think I&apos;ve just had some issues that has been solved with <code>{:dev/always true}</code>
Reloading the webapp was doing nothing, I had to restart my shadow-cljs watch. And with the workaround above it seems to work.</z><z id="t1651865937" t="mauricio.szabo Hey, [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] , I though maybe if you want, we could use a thread here to discuss this PR? https://github.com/metosin/malli/pull/702 . I added some comments on how to make the metadata work with Shadow-CLJS, but it only works on ClojureScript :thinking_face:"><y>#</y><d>2022-05-06</d><h>19:38</h><w>mauricio.szabo</w>Hey, <a>@danvingo</a>, I though maybe if you want, we could use a thread here to discuss this PR? <a href="https://github.com/metosin/malli/pull/702" target="_blank">https://github.com/metosin/malli/pull/702</a>. I added some comments on how to make the metadata work with Shadow-CLJS, but it only works on ClojureScript <b>:thinking_face:</b></z><z id="t1651874813" t="dvingo got something working! these macros are fun 😄 thanks for investigating, I thought adding metadata on the symbol would work but I&apos;m guessing the cljs compiler handles functions differently"><y>#</y><d>2022-05-06</d><h>22:06</h><r>dvingo</r>got something working!

these macros are fun <b>😄</b>

thanks for investigating, I thought adding metadata on the symbol would work but I&apos;m guessing the cljs compiler handles functions differently</z><z id="t1652445557" t="eskos I’d need a bit of help/ideas to implement conditional validation for a case when • vector with a single Thing validates as true as it normally would • vector with multiple Things validates true only if each Thing has an additional field • Thing is a record represented as map Practically this is “If only one record is present in result set, id field isn’t required, otherwise id field is mandatory”. There’s probably multiple ways to tackle this, I’m just not sure what would be a good approach."><y>#</y><d>2022-05-13</d><h>12:39</h><w>eskos</w>I’d need a bit of help/ideas to implement conditional validation for a case when
• vector with a single Thing validates as true as it normally would
• vector with multiple Things validates true only if each Thing has an additional field
• Thing is a record represented as map
Practically this is “If only one record is present in result set, id field isn’t required, otherwise id field is mandatory”. There’s probably multiple ways to tackle this, I’m just not sure what would be a good approach.</z><z id="t1652448169" t="eskos Basically what I have is (m/schema [:or [:vector {:min 1} (mu/merge IdField Thing)] [:vector {:max 1} Thing]]) and this seems to work as intended but I’m not sure if this is the best way to do this. EDIT: Ordering also matters, the more complex schema must be first for sensible error output."><y>#</y><d>2022-05-13</d><h>13:22</h><r>eskos</r>Basically what I have is
<pre>(m/schema [:or
           [:vector {:min 1} (mu/merge IdField Thing)]
           [:vector {:max 1} Thing]])</pre>
and this seems to work as intended but I’m not sure if this is the best way to do this.

EDIT: Ordering also matters, the more complex schema must be first for sensible error output.</z><z id="t1652709332" t="ikitommi Would :multi here? [:multi {:dispatch count} [1 [:vector {:max 1} Thing]] [:malli.core/default [:vector {:min 2} (mu/merge IdField Thing)]]]"><y>#</y><d>2022-05-16</d><h>13:55</h><r>ikitommi</r>Would <code>:multi</code> here?
<pre>[:multi {:dispatch count}
 [1 [:vector {:max 1} Thing]]
 [:malli.core/default [:vector {:min 2} (mu/merge IdField Thing)]]]</pre></z><z id="t1652709877" t="eskos Oh yes, :multi seems to work wonderfully! 👍"><y>#</y><d>2022-05-16</d><h>14:04</h><r>eskos</r>Oh yes, <code>:multi</code> seems to work wonderfully! <b>👍</b></z><z id="t1652709332" t="ikitommi Would :multi here? [:multi {:dispatch count} [1 [:vector {:max 1} Thing]] [:malli.core/default [:vector {:min 2} (mu/merge IdField Thing)]]]"><y>#</y><d>2022-05-16</d><h>13:55</h><w>ikitommi</w>Would <code>:multi</code> here?
<pre>[:multi {:dispatch count}
 [1 [:vector {:max 1} Thing]]
 [:malli.core/default [:vector {:min 2} (mu/merge IdField Thing)]]]</pre></z><z id="t1652505928" t="Prashant I was trying to write a function schema such that specs of second argument are dependent on the value of first argument e.g. first argument can be a :keyword with value :id or :contact-id second argument has to be a :map that needs to contain the key supplied in first argument So far, I have done below: [:=&gt; [:cat [:alt [:= :id] [:= :contact-id]] [:alt [:map [:id :string]] [:map [:contact-id :string]]]] :string] (defn test-fn {:malli/schema =&gt;test-fn} [key value] (str (name key) &quot;_&quot; (key value))) However, above allows (test-fn :contact-id {:id &quot;op&quot;}) as a valid case in instrumentation as there is no correlation b/w first and second argument. I would greatly appreciate some help. EDIT: Below schema works: (def =&gt;take2 [:=&gt; [:cat [:alt [:cat [:= :id] [:map [:id :string]]] [:cat [:= :contact-id] [:map [:contact-id :string]]]]] :string]) (defn test-fn-2 {:malli/schema =&gt;take2} [key value] (str (name key) &quot;_&quot; (key value))) (test-fn :contact-id {:id &quot;op&quot;}) is invalid with instrumentation on. It is a little verbose though."><y>#</y><d>2022-05-14</d><h>05:25</h><w>Prashant</w>I was trying to write a function schema such that specs of second argument are dependent on the value of first argument e.g.
first argument can be a <code>:keyword</code> with value <code>:id</code> or <code>:contact-id</code>
second argument has to be a <code>:map</code> that needs to contain the key  supplied in first argument
So far, I have done below:
<pre>[:=&gt;
   [:cat
    [:alt [:= :id] [:= :contact-id]]
    [:alt [:map [:id :string]] [:map [:contact-id :string]]]]
   :string]

(defn test-fn
  {:malli/schema =&gt;test-fn}
  [key value]
  (str (name key) &quot;_&quot; (key value)))</pre>
However, above allows <code>(test-fn :contact-id {:id &quot;op&quot;})</code> as a valid case in instrumentation as there is no correlation b/w first and second argument.

I would greatly appreciate some help.

EDIT:

Below schema works:
<pre>(def =&gt;take2
  [:=&gt;
   [:cat
    [:alt
     [:cat [:= :id] [:map [:id :string]]]
     [:cat [:= :contact-id] [:map [:contact-id :string]]]]]
   :string])

(defn test-fn-2
  {:malli/schema =&gt;take2}
  [key value]
  (str (name key) &quot;_&quot; (key value)))</pre>
<code>(test-fn :contact-id {:id &quot;op&quot;})</code> is invalid with instrumentation on.  It is a little verbose though.</z><z id="t1652700272" t="vemv I might need a refresher. Given data expressed as strings (because the data comes from something that inherently only expresses things as strings e.g. a spreadsheet or csv) and a richer schema (i.e. attribute x is an int, not a string), how do I coerce those string values into a schema? Example: (my/coerce [:sequential [:map [:a int?]]] [{:a &quot;1&quot;}]) ;; =&gt; Produces `[{:a 1}]`, i.e. coerces the string into an int ;; ...and throws if no coercion was possible"><y>#</y><d>2022-05-16</d><h>11:24</h><w>vemv</w>I might need a refresher. Given data expressed as strings (because the data comes from something that inherently only expresses things as strings e.g. a spreadsheet or csv) and a richer schema (i.e. attribute x is an int, not a string), how do I coerce those string values into a schema?

Example:

<pre>(my/coerce [:sequential [:map [:a int?]]]
           [{:a &quot;1&quot;}]) ;; =&gt; Produces `[{:a 1}]`, i.e. coerces the string into an int
;; ...and throws if no coercion was possible</pre></z><z id="t1652700411" t="ikitommi try decoding: https://github.com/metosin/malli/blob/master/README.md#value-transformation"><y>#</y><d>2022-05-16</d><h>11:26</h><r>ikitommi</r>try decoding: <a href="https://github.com/metosin/malli/blob/master/README.md#value-transformation" target="_blank">https://github.com/metosin/malli/blob/master/README.md#value-transformation</a></z><z id="t1652700488" t="ikitommi it does not throw by default, but you can validate the result and throw if it&apos;s invalid. Two walks on the schema with malli are still much faster than one (decode or throw) with most others."><y>#</y><d>2022-05-16</d><h>11:28</h><r>ikitommi</r>it does not throw by default, but you can validate the result and throw if it&apos;s invalid. Two walks on the schema with malli are still much faster than one (decode or throw) with most others.</z><z id="t1652700519" t="vemv thanks much! Let&apos;s give it a go :)"><y>#</y><d>2022-05-16</d><h>11:28</h><r>vemv</r>thanks much! Let&apos;s give it a go :)</z><z id="t1652709050" t="chen florescu (def example-schema [:map {:closed true} [:product {:optional true} Product] [:version {:default &quot;1.0&quot;} [:= &quot;1.0&quot;]] [:enable true?] [:window [:int {:min 12 :max 1512}]]]) I have this schema and I want to add a constraint that only if I receive product (which is optional), then window needs to be [:int {:min 12 :max 24}]. Any suggestions how can I do that?"><y>#</y><d>2022-05-16</d><h>13:50</h><w>chen florescu</w><pre>(def example-schema
  [:map {:closed true}
   [:product {:optional true} Product]
   [:version {:default &quot;1.0&quot;} [:= &quot;1.0&quot;]]
   [:enable true?]
   [:window [:int {:min 12 :max 1512}]]])</pre>
I have this schema and I want to add a constraint that only if I receive product (which is optional), then window needs to be [:int {:min 12 :max 24}]. Any suggestions how can I do that?</z><z id="t1652715297" t="Ben Sless Those are two different schemas and there&apos;s an or between them. Then product won&apos;t be option, either"><y>#</y><d>2022-05-16</d><h>15:34</h><r>Ben Sless</r>Those are two different schemas and there&apos;s an or between them. Then product won&apos;t be option, either</z><z id="t1652778185" t="eskos Could a new version be released to clojars? I just spent an embarrassing amount of time wondering why (mt/default-value-transformer {::mt/add-optional-keys true}) isn’t working only to realise it was added 18 days after 0.8.4 was released 😛"><y>#</y><d>2022-05-17</d><h>09:03</h><w>eskos</w>Could a new version be released to clojars? I just spent an embarrassing amount of time wondering why <code>(mt/default-value-transformer {::mt/add-optional-keys true})</code> isn’t working only to realise it was added 18 days after 0.8.4 was released <b>😛</b></z><z id="t1652878746" t="Ferdinand Beyer Is there a schema for any homogenous collection, similar to spec’s coll-of ? I found :vector , :sequential and :set , and fell into the trap that a set is not sequential? . I want to spec a function that will take any collection and passes it to (set) ."><y>#</y><d>2022-05-18</d><h>12:59</h><w>Ferdinand Beyer</w>Is there a schema for any homogenous collection, similar to spec’s <code>coll-of</code>? I found <code>:vector</code> , <code>:sequential</code> and <code>:set</code>, and fell into the trap that a set is not <code>sequential?</code>.

I want to spec a function that will take any collection and passes it to <code>(set)</code>.</z><z id="t1652879159" t="Ferdinand Beyer Would it be worth adding a :coll schema to base-schemas like this? :coll (-collection-schema {:type :coll, :pred coll?})"><y>#</y><d>2022-05-18</d><h>13:05</h><r>Ferdinand Beyer</r>Would it be worth adding a <code>:coll</code> schema to <code>base-schemas</code> like this?

<pre>:coll (-collection-schema {:type :coll, :pred coll?})</pre></z><z id="t1652959317" t="armed Hey, everyone. What’s the best way to describe homogeneous map but add specific keys in it?"><y>#</y><d>2022-05-19</d><h>11:21</h><w>armed</w>Hey, everyone. What’s the best way to describe homogeneous map but add specific keys in it?</z><z id="t1652959359" t="armed I tried :union and :and with no luck."><y>#</y><d>2022-05-19</d><h>11:22</h><r>armed</r>I tried <code>:union</code> and <code>:and</code> with no luck.</z><z id="t1652959382" t="armed (mu/union [:map [:state keyword?] [:failure {:optional true} any?] [:value any?]] [:map-of keyword? string?])"><y>#</y><d>2022-05-19</d><h>11:23</h><r>armed</r><pre>(mu/union
   [:map
    [:state keyword?]
    [:failure {:optional true} any?]
    [:value any?]]
   [:map-of keyword? string?])</pre></z><z id="t1652959744" t="armed Well, actually it’s working. Had to replace :union with mu/union 🙂"><y>#</y><d>2022-05-19</d><h>11:29</h><r>armed</r>Well, actually it’s working. Had to replace <code>:union</code> with <code>mu/union</code> <b>🙂</b></z><z id="t1652965299" t="ikitommi good to hear it works! I think union puts :or around the two here."><y>#</y><d>2022-05-19</d><h>13:01</h><r>ikitommi</r>good to hear it works! I think union puts <code>:or</code> around the two here.</z><z id="t1652965321" t="ikitommi :thinking_face:"><y>#</y><d>2022-05-19</d><h>13:02</h><r>ikitommi</r><b>:thinking_face:</b></z><z id="t1652965361" t="ikitommi but, there is an issue to solve this elegantly."><y>#</y><d>2022-05-19</d><h>13:02</h><r>ikitommi</r>but, there is an issue to solve this elegantly.</z><z id="t1652999249" t="aaron51 Seems like pretty/explain doesn’t support custom registries?"><y>#</y><d>2022-05-19</d><h>22:27</h><w>aaron51</w>Seems like <code>pretty/explain</code> doesn’t support custom registries?</z><z id="t1653056178" t="plins hello everyone, I’m using reitit and malli to validate JSON requests to endpoints of my API I would like to use the malli registry, in a spec fashion, to define keys first, and afterwards referencing them in a map. doing this way would allow me to https://clojure.org/about/spec#_decomplect_mapskeysvalues the problem Im facing is: the json payload will spawn un-qualified keys, and the registry only works with qualified keys what would be the best solution to this problem? I would like to avoid [:key :ns/key]"><y>#</y><d>2022-05-20</d><h>14:16</h><w>plins</w>hello everyone, I’m using reitit and malli to validate JSON requests to endpoints of my API

I would like to use the malli registry, in a spec fashion, to define keys first, and afterwards referencing them in a map. doing this way would allow me to <a href="https://clojure.org/about/spec#_decomplect_mapskeysvalues" target="_blank">https://clojure.org/about/spec#_decomplect_mapskeysvalues</a>

the problem Im facing is:  the json payload will spawn un-qualified keys, and the registry only works with qualified keys

what would be the best solution to this problem?  I would like to avoid <code>[:key :ns/key]</code></z><z id="t1653286030" t="jprudent Hello, I&apos;ve a question about the behaviour of :and. Here is a schema with a valid input: (m/explain [:and [:sequential any?] [:multi {:dispatch &apos;first} [:a [:sequential keyword?]] [::m/default any?]]] [:a :b]) =&gt; nil"><y>#</y><d>2022-05-23</d><h>06:07</h><w>jprudent</w>Hello, I&apos;ve a question about the behaviour of <code>:and.</code> Here is a schema with a valid input:
<pre>(m/explain [:and
              [:sequential any?]
              [:multi {:dispatch &apos;first}
               [:a [:sequential keyword?]]
               [::m/default any?]]]
             [:a :b])
=&gt; nil</pre></z><z id="t1653286161" t="jprudent but with invalid input (m/explain [:and [:sequential any?] [:multi {:dispatch &apos;first} [:a [:sequential keyword?]] [::m/default any?]]] 1) Execution error (IllegalArgumentException) at malli.core/-multi-schema$reify$reify$fn (core.cljc:1497). Don&apos;t know how to create ISeq from: java.lang.Long I was expecting that the branch that checks that the input is sequential would prevent execution of the second one"><y>#</y><d>2022-05-23</d><h>06:09</h><w>jprudent</w>but with invalid input
<pre>(m/explain [:and
              [:sequential any?]
              [:multi {:dispatch &apos;first}
               [:a [:sequential keyword?]]
               [::m/default any?]]]
             1)
Execution error (IllegalArgumentException) at malli.core/-multi-schema$reify$reify$fn (core.cljc:1497).
Don&apos;t know how to create ISeq from: java.lang.Long</pre>
I was expecting that the branch that checks that the input is sequential would prevent execution of the second one</z><z id="t1653286431" t="jprudent The solution I found to avoid an exception to be raised is to have smarter dispatch function (m/explain [:multi {:dispatch (fn [x] (if (seq? x) (first x) ::error))} [:a [:sequential keyword?]] [::error [:sequential any?]] [::m/default any?]] 1) =&gt; {:schema ..., :value 1, :errors ({:path [:muguet.meta-schemas/error], :in [], :schema [:sequential any?], :value 1, :type :malli.core/invalid-type})}"><y>#</y><d>2022-05-23</d><h>06:13</h><w>jprudent</w>The solution I found to avoid an exception to be raised is to have smarter dispatch function
<pre>(m/explain [:multi {:dispatch (fn [x] (if (seq? x) (first x) ::error))}
              [:a [:sequential keyword?]]
              [::error [:sequential any?]]
              [::m/default any?]]
             1)
=&gt;
{:schema ...,
 :value 1,
 :errors ({:path [:muguet.meta-schemas/error],
           :in [],
           :schema [:sequential any?],
           :value 1,

           :type :malli.core/invalid-type})}</pre></z><z id="t1653287038" t="jprudent Why checking branches in an :and is not lazy (could stop after one of the branch is invalid) ?"><y>#</y><d>2022-05-23</d><h>06:23</h><w>jprudent</w>Why checking branches in an :and is not lazy (could stop after one of the branch is invalid) ?</z><z id="t1653287074" t="jprudent (I can live with current behaviour, no problem 🙂 just curious) Thanks"><y>#</y><d>2022-05-23</d><h>06:24</h><w>jprudent</w>(I can live with current behaviour, no problem <b>🙂</b> just curious) Thanks</z><z id="t1653300395" t="Alexis Schad Hi. I&apos;m very not expert in malli, but maybe it&apos;s the use of explain : explain try to give all the reasons why it&apos;s not valid. Let&apos;s say you have a password that must have a specific length, some special characters, etc. You may want to display all the reasons at once instead of a &quot;one by one&quot; strategy. But a lazy version would be useful I think. (I didn&apos;t check but validators should already be lazy)"><y>#</y><d>2022-05-23</d><h>10:06</h><w>Alexis Schad</w>Hi. I&apos;m very not expert in malli, but maybe it&apos;s the use of <code>explain</code>: explain try to give all the reasons why it&apos;s not valid. Let&apos;s say you have a password that must have a specific length, some special characters, etc. You may want to display all the reasons at once instead of a &quot;one by one&quot; strategy. But a lazy version would be useful I think. (I didn&apos;t check but <code>validators</code> should already be lazy)</z><z id="t1653309044" t="jprudent You&apos;re right, validate is &quot;lazy&quot;!"><y>#</y><d>2022-05-23</d><h>12:30</h><r>jprudent</r>You&apos;re right, <code>validate</code> is &quot;lazy&quot;!</z><z id="t1653309091" t="jprudent Your explanation makes sense, thanks."><y>#</y><d>2022-05-23</d><h>12:31</h><r>jprudent</r>Your explanation makes sense, thanks.</z><z id="t1653306509" t="rovanion Is it possible to remove a key-value-pair from a map during decode if the value is a specific thing? I&apos;ve got a select with an entry that reads &quot;all&quot; which is functionally the same as not giving any value at all and I want to handle that case in the reitit/malli request param coercion stage."><y>#</y><d>2022-05-23</d><h>11:48</h><w>rovanion</w>Is it possible to remove a key-value-pair from a map during decode if the value is a specific thing?

I&apos;ve got a select with an entry that reads &quot;all&quot; which is functionally the same as not giving any value at all and I want to handle that case in the reitit/malli request param coercion stage.</z><z id="t1653306767" t="rovanion I think I&apos;ve found a relevant example: (m/decode [string? {:decode/string {:enter &apos;str/upper-case}}] &quot;kerran&quot; mt/string-transformer)"><y>#</y><d>2022-05-23</d><h>11:52</h><w>rovanion</w>I think I&apos;ve found a relevant example:

<pre>(m/decode
  [string? {:decode/string {:enter &apos;str/upper-case}}]
  &quot;kerran&quot; mt/string-transformer)</pre></z><z id="t1653306778" t="rovanion ; =&gt; &quot;KERRAN&quot;"><y>#</y><d>2022-05-23</d><h>11:52</h><w>rovanion</w><pre>; =&gt; &quot;KERRAN&quot;</pre></z><z id="t1653307016" t="rovanion Though that won&apos;t remove the key: (malli.core/decode [:map [:a [:string {:decode/string #(if (= &quot;all&quot; %) nil %)}]]] {:a &quot;all&quot;} malli.transform/string-transformer) ;; =&gt; {:a nil}"><y>#</y><d>2022-05-23</d><h>11:56</h><w>rovanion</w>Though that won&apos;t remove the key:

<pre>(malli.core/decode [:map [:a [:string {:decode/string #(if (= &quot;all&quot; %) nil %)}]]]
                   {:a &quot;all&quot;}
                   malli.transform/string-transformer)
;; =&gt; {:a nil}</pre></z><z id="t1653309841" t="rovanion Para on IRC gave me a solution: (defn- remove-alla-odlingsplatser &quot;Takes a query-params map and removes the key :odlingsplatser if its value is &apos;alla odlingsplatser&apos;.&quot; [m] (if (= &quot;alla odlingsplatser&quot; (:odlingsplats m)) (dissoc m :odlingsplats) m)) "><y>#</y><d>2022-05-23</d><h>12:44</h><w>rovanion</w>Para on IRC gave me a solution:

<pre>(defn- remove-alla-odlingsplatser
  &quot;Takes a query-params map and removes the key :odlingsplatser if its value is &apos;alla odlingsplatser&apos;.&quot;
  [m]
  (if (= &quot;alla odlingsplatser&quot; (:odlingsplats m))
    (dissoc m :odlingsplats) 
    m))   </pre></z><z id="t1653309869" t="rovanion Welll, the solution he gave me was: (fn [m] (if (= &quot;all&quot; (m :a)) (dissoc m :a) m))"><y>#</y><d>2022-05-23</d><h>12:44</h><w>rovanion</w>Welll, the solution he gave me was: <code>(fn [m] (if (= &quot;all&quot; (m :a)) (dissoc m :a) m))</code></z><z id="t1653318804" t="William Robinson I want to use malli/decode on a map that has to contain at least one of :foo/id URI or :bar/id UUID . No matter how I twist and turn the schema, the only thing I can get working is the following: (malli/decode [:or [:map [:foo/id uri?] other-child other-other-child]] [:map [:bar/id uuid?] other-child other-other-child]]] {:bar/id #uuid &quot;15a0bc27-5725-41d9-89c9-6f8d3966447a&quot; :other-key :other-value} (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer)) Is there a good way to handle this without having to duplicate the schema?"><y>#</y><d>2022-05-23</d><h>15:13</h><w>William Robinson</w>I want to use <code>malli/decode</code> on a map that has to contain at least one of <code>:foo/id URI</code> or <code>:bar/id UUID</code>. No matter how I twist and turn the schema, the only thing I can get working is the following:
<pre>(malli/decode [:or
                 [:map
                  [:foo/id uri?]
                  other-child
                  other-other-child]]
                 [:map
                  [:bar/id uuid?]
                  other-child
                  other-other-child]]]
    {:bar/id    #uuid &quot;15a0bc27-5725-41d9-89c9-6f8d3966447a&quot;
     :other-key :other-value}
    (mt/transformer mt/strip-extra-keys-transformer mt/string-transformer))</pre>
Is there a good way to handle this without having to duplicate the schema?</z><z id="t1653321461" t="jprudent [:map [:foo/id [:or [uri?] [uuid?]]] [:attr1 :int] [:attr2 :int]]"><y>#</y><d>2022-05-23</d><h>15:57</h><r>jprudent</r><pre>[:map
               [:foo/id [:or [uri?] [uuid?]]]
               [:attr1 :int]
               [:attr2 :int]]</pre></z><z id="t1653321473" t="jprudent could that work ?"><y>#</y><d>2022-05-23</d><h>15:57</h><r>jprudent</r>could that work ?</z><z id="t1653323334" t="William Robinson Thanks for the suggestion! Unfortunately they are different keys, one of which always corresponds to a URI and the other to a UUID."><y>#</y><d>2022-05-23</d><h>16:28</h><r>William Robinson</r>Thanks for the suggestion! Unfortunately they are different keys, one of which always corresponds to a URI and the other to a UUID.</z><z id="t1653323571" t="William Robinson [:map [:or [:foo/id uri?]] [:bar/id uuid?]] [:attr1 :int] [:attr2 :int]] Something like the above is what I would like to achieve."><y>#</y><d>2022-05-23</d><h>16:32</h><r>William Robinson</r><pre>[:map
               [:or [:foo/id uri?]]
                    [:bar/id uuid?]]
               [:attr1 :int]
               [:attr2 :int]]
</pre>
Something like the above is what I would like to achieve.</z><z id="t1653325531" t="jprudent [:union [:or [:map [:foo/id uri?]] [:map [:bar/id uuid?]]] [:map [:attr1 :int] [:attr2 :int]]] "><y>#</y><d>2022-05-23</d><h>17:05</h><r>jprudent</r><pre>[:union
 [:or
         [:map [:foo/id uri?]]
         [:map [:bar/id uuid?]]]
 [:map
  [:attr1 :int]
  [:attr2 :int]]] </pre></z><z id="t1653325632" t="William Robinson This looks promising, will try it out and let you know, thanks!"><y>#</y><d>2022-05-23</d><h>17:07</h><r>William Robinson</r>This looks promising, will try it out and let you know, thanks!</z><z id="t1653325709" t="jprudent [:and [:map [:foo/id {:optional true} uri?] [:bar/id {:optional true} uuid?] [:attr1 :int] [:attr2 :int]] [:fn (fn [m] (or (:foo/id m) (:bar/id m)))]] "><y>#</y><d>2022-05-23</d><h>17:08</h><r>jprudent</r><pre>[:and [:map
       [:foo/id {:optional true} uri?]
       [:bar/id {:optional true} uuid?]
       [:attr1 :int]
       [:attr2 :int]]
 [:fn (fn [m] (or (:foo/id m) (:bar/id m)))]] </pre></z><z id="t1653382142" t="William Robinson Forgot to get back to you, but the last solution worked like a charm, huge thanks!"><y>#</y><d>2022-05-24</d><h>08:49</h><r>William Robinson</r>Forgot to get back to you, but the last solution worked like a charm, huge thanks!</z><z id="t1653374419" t="Ben Sless I&apos;m trying to have mutual recursion with regex schemas and failing pitifully. Any tips?"><y>#</y><d>2022-05-24</d><h>06:40</h><w>Ben Sless</w>I&apos;m trying to have mutual recursion with regex schemas and failing pitifully. Any tips?</z><z id="t1653374823" t="Ben Sless In this example: (defn char-range [from+to] (let [from (long (first from+to)) to (long (second from+to))] (m/-simple-schema {:type ::char-range :pred (fn [x] (&lt;= from (long x) to))}))) (defn char-seq [cs] (into [:cat] (mapv (fn [c] [:= c]) cs))) (m/parse (m/schema [:schema {:registry {::digit (char-range &quot;09&quot;) ::lower-case (char-range &quot;az&quot;) ::upper-case (char-range &quot;AZ&quot;) ::letter [:alt ::lower-case ::upper-case] ::number [:+ ::digit] ::var [:cat ::upper-case [:* ::lower-case]] ::boolean [:altn [:true (char-seq &quot;true&quot;)] [:false (char-seq &quot;false&quot;)]] ::atom [:cat ::lower-case [:* ::letter]] ::term [:altn [:equality [:schema [:ref ::equality]]] [:atom ::atom] [:var ::var] [:number ::number] [:boolean ::boolean] #_[:structure ::structure] #_[:list ::list] #_[:string ::string]] ::equality [:cat ::var (char-seq &quot; = &quot;) ::term] }} ::equality]) (seq &quot;X = Y&quot;)) ::equality succeeds but ::term doesn&apos;t"><y>#</y><d>2022-05-24</d><h>06:47</h><w>Ben Sless</w>In this example:
<pre>(defn char-range
  [from+to]
  (let [from (long (first from+to))
        to (long (second from+to))]
    (m/-simple-schema
     {:type ::char-range
      :pred (fn [x] (&lt;= from (long x) to))})))

(defn char-seq
  [cs]
  (into [:cat] (mapv (fn [c] [:= c]) cs)))

(m/parse
 (m/schema
  [:schema
   {:registry
    {::digit (char-range &quot;09&quot;)
     ::lower-case (char-range &quot;az&quot;)
     ::upper-case (char-range &quot;AZ&quot;)
     ::letter [:alt ::lower-case ::upper-case]
     ::number [:+ ::digit]
     ::var [:cat ::upper-case [:* ::lower-case]]
     ::boolean [:altn [:true (char-seq &quot;true&quot;)] [:false (char-seq &quot;false&quot;)]]
     ::atom [:cat ::lower-case [:* ::letter]]
     ::term [:altn
             [:equality [:schema [:ref ::equality]]]
             [:atom ::atom]
             [:var ::var]
             [:number ::number]
             [:boolean ::boolean]
             #_[:structure ::structure]
             #_[:list ::list]
             #_[:string ::string]]
     ::equality [:cat ::var (char-seq &quot; = &quot;) ::term]
     }}
   ::equality])
 (seq &quot;X = Y&quot;))</pre>
<code>::equality</code> succeeds but <code>::term</code> doesn&apos;t</z><z id="t1653377484" t="jprudent I&apos;m not sure why but I also find out that you can&apos;t have :ref in seqexp. Is that your problem ?"><y>#</y><d>2022-05-24</d><h>07:31</h><r>jprudent</r>I&apos;m not sure why but I also find out that you can&apos;t have <code>:ref</code> in seqexp. Is that your problem ?</z><z id="t1653377602" t="jprudent Is it going in a stackoverflow if you remove it ?"><y>#</y><d>2022-05-24</d><h>07:33</h><r>jprudent</r>Is it going in a stackoverflow if you remove it ?</z><z id="t1653377651" t="jprudent maybe try :orn instead of :altn"><y>#</y><d>2022-05-24</d><h>07:34</h><r>jprudent</r>maybe try <code>:orn</code> instead of <code>:altn</code></z><z id="t1653382948" t="Ben Sless That doesn&apos;t work"><y>#</y><d>2022-05-24</d><h>09:02</h><r>Ben Sless</r>That doesn&apos;t work</z><z id="t1653383056" t="Ben Sless for some reason you also can&apos;t wrap the ::term in ::equality with [:schema [:ref ,,]]"><y>#</y><d>2022-05-24</d><h>09:04</h><r>Ben Sless</r>for some reason you also can&apos;t wrap the <code>::term</code> in <code>::equality</code> with <code>[:schema [:ref ,,]]</code></z><z id="t1653417060" t="Alexis Schad What doesn&apos;t succeed? What do you expect?"><y>#</y><d>2022-05-24</d><h>18:31</h><r>Alexis Schad</r>What doesn&apos;t succeed? What do you expect?</z><z id="t1653417117" t="Alexis Schad I got [[\X []] [\space \= \space] [:var [\Y []]]]"><y>#</y><d>2022-05-24</d><h>18:31</h><r>Alexis Schad</r>I got <code>[[\X []] [\space \= \space] [:var [\Y []]]]</code></z><z id="t1653419681" t="Ben Sless Try replacing ::equality schema with ::term"><y>#</y><d>2022-05-24</d><h>19:14</h><r>Ben Sless</r>Try replacing <code>::equality</code> schema with <code>::term</code></z><z id="t1653422841" t="Alexis Schad ho ok"><y>#</y><d>2022-05-24</d><h>20:07</h><r>Alexis Schad</r>ho ok</z><z id="t1653422929" t="Alexis Schad I think it&apos;s because in ::term you altn only the \space and not the whole input seq. It tries to match \space and don&apos;t find any entry. I&apos;ll try to add an entry to check that"><y>#</y><d>2022-05-24</d><h>20:08</h><r>Alexis Schad</r>I think it&apos;s because in <code>::term</code>  you <code>altn</code> only the <code>\space</code> and not the whole input seq. It tries to match <code>\space</code> and don&apos;t find any entry. I&apos;ll try to add an entry to check that</z><z id="t1653423516" t="Alexis Schad (m/parse (m/schema [:schema {:registry {::digit (char-range &quot;09&quot;) ::lower-case (char-range &quot;az&quot;) ::upper-case (char-range &quot;AZ&quot;) ::letter [:alt ::lower-case ::upper-case] ::number [:+ ::digit] ::var [:cat ::upper-case [:* ::lower-case]] ::boolean [:altn [:true (char-seq &quot;true&quot;)] [:false (char-seq &quot;false&quot;)]] ::atom [:cat ::lower-case [:* ::letter]] ::term [:* [:altn [:equality [:schema [:ref ::equality]]] [:atom ::atom] [:var ::var] [:number ::number] [:boolean ::boolean] [:space [:cat [:= \space]]] [:equals [:cat [:= \=]]] #_[:structure ::structure] #_[:list ::list] #_[:string ::string]]] ::equality [:cat ::var (char-seq &quot; = &quot;) ::term]}} ::term]) (seq &quot;X = Y&quot;)) This &quot;works&quot; =&gt; [[:var [\X []]] [:space [\space]] [:equals [\=]] [:space [\space]] [:var [\Y []]]]"><y>#</y><d>2022-05-24</d><h>20:18</h><r>Alexis Schad</r><pre>(m/parse
 (m/schema
  [:schema
   {:registry
    {::digit (char-range &quot;09&quot;)
     ::lower-case (char-range &quot;az&quot;)
     ::upper-case (char-range &quot;AZ&quot;)
     ::letter [:alt ::lower-case ::upper-case]
     ::number [:+ ::digit]
     ::var [:cat ::upper-case [:* ::lower-case]]
     ::boolean [:altn [:true (char-seq &quot;true&quot;)] [:false (char-seq &quot;false&quot;)]]
     ::atom [:cat ::lower-case [:* ::letter]]
     ::term [:* [:altn
                 [:equality [:schema [:ref ::equality]]]
                 [:atom ::atom]
                 [:var ::var]
                 [:number ::number]
                 [:boolean ::boolean]
                 [:space [:cat [:= \space]]]
                 [:equals [:cat [:= \=]]]
                 #_[:structure ::structure]
                 #_[:list ::list]
                 #_[:string ::string]]]
     ::equality [:cat ::var (char-seq &quot; = &quot;) ::term]}}
   ::term])
 (seq &quot;X = Y&quot;))</pre>
This &quot;works&quot; =&gt; <code>[[:var [\X []]] [:space [\space]] [:equals [\=]] [:space [\space]] [:var [\Y []]]]</code></z><z id="t1653446713" t="Ben Sless Well, you changed the semantics of the parser. An &quot;equals&quot; is defined in the bnf as &quot;atom = term&quot;"><y>#</y><d>2022-05-25</d><h>02:45</h><r>Ben Sless</r>Well, you changed the semantics of the parser. An &quot;equals&quot; is defined in the bnf as &quot;atom = term&quot;</z><z id="t1653446740" t="Ben Sless I don&apos;t want to do extra parsing afterwards"><y>#</y><d>2022-05-25</d><h>02:45</h><r>Ben Sless</r>I don&apos;t want to do extra parsing afterwards</z><z id="t1653446796" t="Ben Sless ”X = Y” should be tagged as an equality term"><y>#</y><d>2022-05-25</d><h>02:46</h><r>Ben Sless</r>”X = Y” should be tagged as an equality term</z><z id="t1653463086" t="Alexis Schad I know, that&apos;s why I put &quot; around works. I was trying to explain the reason why it doesn&apos;t work. Btw you can’t do recursive seqexp in malli actually. If you want to exclusively use Malli to parse, you can replace the ref to :: term with a [:* any?] and call the parser again on that. You can also create your own schema but it’s harder I think."><y>#</y><d>2022-05-25</d><h>07:18</h><r>Alexis Schad</r>I know, that&apos;s why I put &quot; around works. I was trying to explain the reason why it doesn&apos;t work.
Btw you can’t do recursive seqexp in malli actually. If you want to exclusively use Malli to parse, you can replace the ref to <b>::</b>term with a [:* any?] and call the parser again on that.
You can also create your own schema but it’s harder I think.</z><z id="t1653467953" t="Ben Sless Why can&apos;t I have recursive seqex schemas, though?"><y>#</y><d>2022-05-25</d><h>08:39</h><r>Ben Sless</r>Why can&apos;t I have recursive seqex schemas, though?</z><z id="t1653468254" t="Alexis Schad Don&apos;t know, not a malli expert. But I think it&apos;s due to technical limitation. Malli explicitely prevent it with ::potentially-recursive-seqex error, though it is theorically possible."><y>#</y><d>2022-05-25</d><h>08:44</h><r>Alexis Schad</r>Don&apos;t know, not a malli expert. But I think it&apos;s due to technical limitation. Malli explicitely prevent it with  <code>::potentially-recursive-seqex</code> error, though it is theorically possible.</z><z id="t1653468680" t="Alexis Schad See https://github.com/metosin/malli/blob/85a948afc13262adb2082ede36ee131bd2b6364d/test/malli/core_test.cljc#L1797-L1800 [:schema {:registry {::ints [:cat int? [:ref ::ints]] is disallowed."><y>#</y><d>2022-05-25</d><h>08:51</h><r>Alexis Schad</r>See <a href="https://github.com/metosin/malli/blob/85a948afc13262adb2082ede36ee131bd2b6364d/test/malli/core_test.cljc#L1797-L1800" target="_blank">https://github.com/metosin/malli/blob/85a948afc13262adb2082ede36ee131bd2b6364d/test/malli/core_test.cljc#L1797-L1800</a>
<code>[:schema {:registry {::ints [:cat int? [:ref ::ints]]</code> is disallowed.</z><z id="t1653629288" t="escherize There’s more info here in this discussion: https://github.com/metosin/malli/pull/317"><y>#</y><d>2022-05-27</d><h>05:28</h><r>escherize</r>There’s more info here in this discussion: <a href="https://github.com/metosin/malli/pull/317" target="_blank">https://github.com/metosin/malli/pull/317</a></z><z id="t1653497247" t="kenny Hi. Instead of an :error/fn returning a string, could I return explain data? If yes, what&apos;s the recipe to do so?"><y>#</y><d>2022-05-25</d><h>16:47</h><w>kenny</w>Hi. Instead of an :error/fn returning a string, could I return explain data? If yes, what&apos;s the recipe to do so?</z><z id="t1653497924" t="Alexis Schad What do you mean by &quot;explain data&quot;? But yes if you returns a non-string value, it works as you expect (I think)."><y>#</y><d>2022-05-25</d><h>16:58</h><r>Alexis Schad</r>What do you mean by &quot;explain data&quot;? But yes if you returns a non-string value, it works as you expect (I think).</z><z id="t1653569132" t="plins https://clojuredocs.org/clojure.spec.alpha/explain-data"><y>#</y><d>2022-05-26</d><h>12:45</h><r>plins</r><a href="https://clojuredocs.org/clojure.spec.alpha/explain-data" target="_blank">https://clojuredocs.org/clojure.spec.alpha/explain-data</a></z><z id="t1653837299" t="ikitommi Currently no, but in one project needed richer explanations and did an ugly hack to enable that. I think we should support that at library level. E.g. one could return {:message &quot;so wrong&quot;, :level &quot;warning&quot;}"><y>#</y><d>2022-05-29</d><h>15:14</h><r>ikitommi</r>Currently no, but in one project needed richer explanations and did an ugly hack to enable that. I think we should support that at library level. E.g. one could return <code>{:message &quot;so wrong&quot;, :level &quot;warning&quot;}</code></z><z id="t1653837314" t="ikitommi Could you write an issue of this?"><y>#</y><d>2022-05-29</d><h>15:15</h><r>ikitommi</r>Could you write an issue of this?</z><z id="t1653822562" t="ingesol Is it possible to make the code below work on the JVM, or is there some limitation in the implementation of CLJS function schemas that only makes them accessible in the JS runtime? My function schemas work and reload nicely in the browser, but in the code below the collect-cljs call always returns () . Additional info: All my function schemas are :malli/schema metadata. (defn -main [&amp; _] (-&gt; (malli.clj-kondo/collect-cljs) (malli.clj-kondo/linter-config) (malli.clj-kondo/save!)))"><y>#</y><d>2022-05-29</d><h>11:09</h><w>ingesol</w>Is it possible to make the code below work on the JVM, or is there some limitation in the implementation of CLJS function schemas that only makes them accessible in the JS runtime? My function schemas work and reload nicely in the browser, but in the code below the <code>collect-cljs</code> call always returns <code>()</code> .

Additional info: All my function schemas are <code>:malli/schema</code> metadata.
<pre>(defn -main
  [&amp; _]
  (-&gt; (malli.clj-kondo/collect-cljs) 
      (malli.clj-kondo/linter-config) 
      (malli.clj-kondo/save!)))</pre></z><z id="t1653837128" t="ikitommi Good question. I have no idea! I believe [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] knows."><y>#</y><d>2022-05-29</d><h>15:12</h><r>ikitommi</r>Good question. I have no idea! I believe <a>@danvingo</a> knows.</z><z id="t1653859262" t="dvingo if you have a symbol in your functions schema like: (defn minus {:malli/schema [:=&gt; [:cat :int] [small-int]] } [x] (dec x)) small-int can only be resolved at runtime by a js vm. that&apos;s the fundamental limitation to why it won&apos;t work on a java vm"><y>#</y><d>2022-05-29</d><h>21:21</h><r>dvingo</r>if you have a symbol in your functions schema like:
<pre>(defn minus
  {:malli/schema [:=&gt; [:cat :int] [small-int]] }
  [x] (dec x))</pre>
<code>small-int</code> can only be resolved at runtime by a js vm.

that&apos;s the fundamental limitation to why it won&apos;t work on a java vm</z><z id="t1653886655" t="ingesol Thanks for clarifying, [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] . Also, big thanks for all your recent work on the CLJS tooling, it’s made a huge difference!"><y>#</y><d>2022-05-30</d><h>04:57</h><r>ingesol</r>Thanks for clarifying, <a>@danvingo</a>. Also, big thanks for all your recent work on the CLJS tooling, it’s made a huge difference!</z><z id="t1653924663" t="dvingo no problem. Ah that&apos;s great to hear! glad it&apos;s working for you - interested to hear if you have any feedback or things that could be improved, but if all is well that&apos;s great too 🙂"><y>#</y><d>2022-05-30</d><h>15:31</h><r>dvingo</r>no problem. Ah that&apos;s great to hear! glad it&apos;s working for you - interested to hear if you have any feedback or things that could be improved, but if all is well that&apos;s great too <b>🙂</b></z><z id="t1653926234" t="dvingo in case you didn&apos;t know there&apos;s https://github.com/metosin/malli/blob/384e31b325928a29f6bfdddae3a9f1241be4734b/src/malli/clj_kondo.cljc#L203 which is intended for use in a cljs repl - it&apos;s manual, you have to copy and paste to the kondo config. Are you trying to output the kondo config using a script (somewhat automated)? One thought I had is that for scripting support we could add a write function for node.js, the only annoying thing is that any browser APIs not available in node.js would probably break things, which would mean you&apos;d have to change the structure of your code to put the function with schemas in one place. There&apos;s tradeoffs in all these approaches unfortunately"><y>#</y><d>2022-05-30</d><h>15:57</h><r>dvingo</r>in case you didn&apos;t know there&apos;s <a href="https://github.com/metosin/malli/blob/384e31b325928a29f6bfdddae3a9f1241be4734b/src/malli/clj_kondo.cljc#L203" target="_blank">https://github.com/metosin/malli/blob/384e31b325928a29f6bfdddae3a9f1241be4734b/src/malli/clj_kondo.cljc#L203</a> which is intended for use in a cljs repl - it&apos;s manual, you have to copy and paste to the kondo config.

Are you trying to output the kondo config using a script (somewhat automated)?

One thought I had is that for scripting support we could add a write function for node.js, the only annoying thing is that any browser APIs not available in node.js would probably break things, which would mean you&apos;d have to change the structure of your code to put the function with schemas in one place.
There&apos;s tradeoffs in all these approaches unfortunately</z><z id="t1653927418" t="ingesol Yeah, that sounds a bit too much, I was thinking about node as well but probably not the route to go. My use case: I would like to keep the clj-kondo config in version control. The ideal would be a process that recompiles the config on every code change, so it would be obvious for the developer that the config is changed and needs to be pushed."><y>#</y><d>2022-05-30</d><h>16:16</h><r>ingesol</r>Yeah, that sounds a bit too much, I was thinking about node as well but probably not the route to go. My use case: I would like to keep the clj-kondo config in version control. The ideal would be a process that recompiles the config on every code change, so it would be obvious for the developer that the config is changed and needs to be pushed.</z><z id="t1653927496" t="ingesol being able to print it to console and then copy into the file is not too bad, will probably be fine."><y>#</y><d>2022-05-30</d><h>16:18</h><r>ingesol</r>being able to print it to console and then copy into the file is not too bad, will probably be fine.</z><z id="t1653927617" t="ingesol As for the general usability of CLJS: I’m using shadow-cljs. I followed the advice in the docs, and things seem to mostly work. I think I stumbled upon a file here and there that wasn’t being updated when schema changed, but it usually is fixed by a refresh."><y>#</y><d>2022-05-30</d><h>16:20</h><r>ingesol</r>As for the general usability of CLJS: I’m using shadow-cljs. I followed the advice in the docs, and things seem to mostly work. I think I stumbled upon a file here and there that wasn’t being updated when schema changed, but it usually is fixed by a refresh.</z><z id="t1653927681" t="ingesol Don’t have much detail on that here, as I’m not actively working on that code right now. But I will in a few weeks, will try to investigate properly then. But current state of things is perfectly fine for me!"><y>#</y><d>2022-05-30</d><h>16:21</h><r>ingesol</r>Don’t have much detail on that here, as I’m not actively working on that code right now. But I will in a few weeks, will try to investigate properly then. But current state of things is perfectly fine for me!</z><z id="t1654003756" t="dvingo I see, the use-case makes a lot of sense, I&apos;m wondering if there is a way to achieve it as part of the build process in CI. The tricky part is you want the code to be evaluated in a browser, but you also want access to the filesystem. I was thinking about something like karma tests - running in a headless browser in node... Not sure if that would work."><y>#</y><d>2022-05-31</d><h>13:29</h><r>dvingo</r>I see, the use-case makes a lot of sense, I&apos;m wondering if there is a way to achieve it as part of the build process in CI. The tricky part is you want the code to be evaluated in a browser, but you also want access to the filesystem. I was thinking about something like karma tests - running in a headless browser in node... Not sure if that would work.</z><z id="t1654096388" t="dvingo Another idea to get this a bit more automated: add a dev-time only button to your app that sends the cljs kondo config to a specific endpoint which writes to the kondo config file - so it&apos;s just a button press"><y>#</y><d>2022-06-01</d><h>15:13</h><r>dvingo</r>Another idea to get this a bit more automated:
add a dev-time only button to your app that sends the cljs kondo config to a specific endpoint which writes to the kondo config file - so it&apos;s just a button press</z><z id="t1654096490" t="ingesol Yeah, that could work. Might be our preferred solution in the end 🙂"><y>#</y><d>2022-06-01</d><h>15:14</h><r>ingesol</r>Yeah, that could work. Might be our preferred solution in the end <b>🙂</b></z><z id="t1654096789" t="dvingo oh - or just do it in your reload hook! then no interaction needed"><y>#</y><d>2022-06-01</d><h>15:19</h><r>dvingo</r>oh - or just do it in your reload hook! then no interaction needed</z><z id="t1654149083" t="ingesol True, that’s what I’m doing right now, but of course just printing to console."><y>#</y><d>2022-06-02</d><h>05:51</h><r>ingesol</r>True, that’s what I’m doing right now, but of course just printing to console.</z><z id="t1654149219" t="ingesol Question: I’m exclusively using keywords in schemas, never symbols. At least for now. Would I be able to “cheat” by telling the malli-&gt;cljs-kondo API that my cljs codebase is clj?"><y>#</y><d>2022-06-02</d><h>05:53</h><r>ingesol</r>Question: I’m exclusively using keywords in schemas, never symbols. At least for now. Would I be able to “cheat” by telling the <code>malli-&gt;cljs-kondo</code> API that my cljs codebase is clj?</z><z id="t1654182529" t="dvingo you could put them in cljc files and they&apos;d be picked up when you collect clj schemas. Other than that, take a look at the source, the code is pretty tiny that collects the schemas, so you should be able to get it working (I think) with your own kondo wrapper. The library can&apos;t make those assumptions about what user schemas will have in them, but with those assumptions I don&apos;t think there&apos;s a reason it can&apos;t work"><y>#</y><d>2022-06-02</d><h>15:08</h><r>dvingo</r>you could put them in cljc files and they&apos;d be picked up when you collect clj schemas. Other than that, take a look at the source, the code is pretty tiny that collects the schemas, so you should be able to get it working (I think) with your own kondo wrapper. The library can&apos;t make those assumptions about what user schemas will have in them, but with those assumptions I don&apos;t think there&apos;s a reason it can&apos;t work</z><z id="t1653886655" t="ingesol Thanks for clarifying, [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] . Also, big thanks for all your recent work on the CLJS tooling, it’s made a huge difference!"><y>#</y><d>2022-05-30</d><h>04:57</h><w>ingesol</w>Thanks for clarifying, <a>@danvingo</a>. Also, big thanks for all your recent work on the CLJS tooling, it’s made a huge difference!</z><z id="t1653886355" t="Abhinav When malli transforms a data structure, does it not preserve meta data? is this by design? (require &apos;[malli.core :as mc] &apos;[malli.transform :as mt]) (def ^{:a 10} alist (list 1 2 3)) (meta (mc/decode [:vector int?] alist (mt/transformer (mt/json-transformer) (mt/string-transformer))) ) ;=&gt; nil"><y>#</y><d>2022-05-30</d><h>04:52</h><w>Abhinav</w>When malli transforms a data structure, does it not preserve meta data? is this by design?

<pre>(require &apos;[malli.core :as mc]
         &apos;[malli.transform :as mt])

(def ^{:a 10} alist (list 1 2 3))

(meta (mc/decode [:vector int?] alist (mt/transformer (mt/json-transformer) (mt/string-transformer))) ) 
;=&gt; nil</pre></z><z id="t1653998338" t="eskos This might be a bit broad question, but tl;dr is How do I implement a custom transformer? I think I want to implement a completely custom transformer to take over the entire decode/encode process - that is, I want to entirely bypass what the built-ins do, and bring my own logic to do the value transformation. I have something brewing elsewhere that I want to integrate to malli which does value type transformation on its own, and for it to work I essentially need a function callback on malli side which would get the relevant malli schema node and its properties (eg. ) + the input value from data to be able to do that transformation. To me this looks like a job for custom transformer which would be created with the malli.transform/transformer helper function, but I can’t make heads or tails about what kind of code I need to write to actually enable such overriding capture of the entire transformation."><y>#</y><d>2022-05-31</d><h>11:58</h><w>eskos</w>This might be a bit broad question, but tl;dr is How do I implement a custom transformer?

I think I want to implement a completely custom transformer to take over the entire decode/encode process - that is, I want to entirely bypass what the built-ins do, and bring my own logic to do the value transformation.

I have something brewing elsewhere that I want to integrate to malli which does value type transformation on its own, and for it to work I essentially need a function callback on malli side which would get the relevant malli schema node and its properties (eg. ) + the input value from data to be able to do that transformation.

To me this looks like a job for custom transformer which would be created with the <code>malli.transform/transformer</code> helper function, but I can’t make heads or tails about what kind of code I need to write to actually enable such overriding capture of the entire transformation.</z><z id="t1653999607" t="ikitommi try :default-decoder with :compile if you want to prepare the transformer to be fast"><y>#</y><d>2022-05-31</d><h>12:20</h><r>ikitommi</r>try <code>:default-decoder</code> with <code>:compile</code> if you want to prepare the transformer to be fast</z><z id="t1653999870" t="ikitommi Here’s a sample, if that’s what you are looking for: (def transformer (mt/transformer {:name :my-transformer :default-decoder {:compile (fn [schema _] (println &quot;&lt;&lt;&lt;&quot; (pr-str schema)) (fn [x] (println &quot;&gt;&gt;&gt;&quot; (pr-str schema) &quot;-&gt;&quot; (pr-str x)) x))}})) (def decode (m/decoder [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] transformer)) ;&lt;&lt;&lt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] ;&lt;&lt;&lt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]] ;&lt;&lt;&lt; [:set [:enum &quot;S&quot; &quot;L&quot;]] ;&lt;&lt;&lt; [:enum &quot;S&quot; &quot;L&quot;] ;&lt;&lt;&lt; [:malli.core/val :uuid] ;&lt;&lt;&lt; :uuid ;&lt;&lt;&lt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]] ;&lt;&lt;&lt; [:tuple :boolean [:map [:a :int]]] ;&lt;&lt;&lt; :boolean ;&lt;&lt;&lt; [:map [:a :int]] ;&lt;&lt;&lt; [:malli.core/val :int] ;&lt;&lt;&lt; :int (decode {:x #{&quot;S&quot; &quot;L&quot; &quot;XL&quot;} :y :invalid :z [true {:a 123}]}) ;&gt;&gt;&gt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] -&gt; {:x #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}, :y :invalid, :z [true {:a 123}]} ;&gt;&gt;&gt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;} ;&gt;&gt;&gt; [:set [:enum &quot;S&quot; &quot;L&quot;]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;} ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;L&quot; ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;S&quot; ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;XL&quot; ;&gt;&gt;&gt; [:malli.core/val :uuid] -&gt; :invalid ;&gt;&gt;&gt; :uuid -&gt; :invalid ;&gt;&gt;&gt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]] -&gt; [true {:a 123}] ;&gt;&gt;&gt; [:tuple :boolean [:map [:a :int]]] -&gt; [true {:a 123}] ;&gt;&gt;&gt; :boolean -&gt; true ;&gt;&gt;&gt; [:map [:a :int]] -&gt; {:a 123} ;&gt;&gt;&gt; [:malli.core/val :int] -&gt; 123 ;&gt;&gt;&gt; :int -&gt; 123"><y>#</y><d>2022-05-31</d><h>12:24</h><r>ikitommi</r>Here’s a sample, if that’s what you are looking for:
<pre>(def transformer
  (mt/transformer
   {:name :my-transformer
    :default-decoder {:compile (fn [schema _]
                                 (println &quot;&lt;&lt;&lt;&quot; (pr-str schema))
                                 (fn [x]
                                   (println &quot;&gt;&gt;&gt;&quot; (pr-str schema) &quot;-&gt;&quot; (pr-str x))
                                   x))}}))

(def decode
  (m/decoder
   [:map
    [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]]
    [:y :uuid]
    [:z [:tuple :boolean [:map [:a :int]]]]]
   transformer))
;&lt;&lt;&lt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]]
;&lt;&lt;&lt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]]
;&lt;&lt;&lt; [:set [:enum &quot;S&quot; &quot;L&quot;]]
;&lt;&lt;&lt; [:enum &quot;S&quot; &quot;L&quot;]
;&lt;&lt;&lt; [:malli.core/val :uuid]
;&lt;&lt;&lt; :uuid
;&lt;&lt;&lt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]]
;&lt;&lt;&lt; [:tuple :boolean [:map [:a :int]]]
;&lt;&lt;&lt; :boolean
;&lt;&lt;&lt; [:map [:a :int]]
;&lt;&lt;&lt; [:malli.core/val :int]
;&lt;&lt;&lt; :int

(decode
 {:x #{&quot;S&quot; &quot;L&quot; &quot;XL&quot;}
  :y :invalid
  :z [true {:a 123}]})
;&gt;&gt;&gt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] -&gt; {:x #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}, :y :invalid, :z [true {:a 123}]}
;&gt;&gt;&gt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}
;&gt;&gt;&gt; [:set [:enum &quot;S&quot; &quot;L&quot;]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;L&quot;
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;S&quot;
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;XL&quot;
;&gt;&gt;&gt; [:malli.core/val :uuid] -&gt; :invalid
;&gt;&gt;&gt; :uuid -&gt; :invalid
;&gt;&gt;&gt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]] -&gt; [true {:a 123}]
;&gt;&gt;&gt; [:tuple :boolean [:map [:a :int]]] -&gt; [true {:a 123}]
;&gt;&gt;&gt; :boolean -&gt; true
;&gt;&gt;&gt; [:map [:a :int]] -&gt; {:a 123}
;&gt;&gt;&gt; [:malli.core/val :int] -&gt; 123
;&gt;&gt;&gt; :int -&gt; 123</pre></z><z id="t1654000266" t="ikitommi If you want to run bottom-up, use :leave : (def transformer (mt/transformer {:name :my-transformer :default-decoder {:compile (fn [schema _] (println &quot;&lt;&lt;&lt;&quot; (pr-str schema)) {:leave (fn [x] (println &quot;&gt;&gt;&gt;&quot; (pr-str schema) &quot;-&gt;&quot; (pr-str x)) x)})}}))"><y>#</y><d>2022-05-31</d><h>12:31</h><r>ikitommi</r>If you want to run bottom-up, use <code>:leave</code>:
<pre>(def transformer
  (mt/transformer
   {:name :my-transformer
    :default-decoder {:compile (fn [schema _]
                                 (println &quot;&lt;&lt;&lt;&quot; (pr-str schema))
                                 {:leave (fn [x]
                                           (println &quot;&gt;&gt;&gt;&quot; (pr-str schema) &quot;-&gt;&quot; (pr-str x))
                                           x)})}}))</pre></z><z id="t1654000290" t="ikitommi =&gt;"><y>#</y><d>2022-05-31</d><h>12:31</h><r>ikitommi</r>=&gt;</z><z id="t1654000291" t="ikitommi (decode {:x #{&quot;S&quot; &quot;L&quot; &quot;XL&quot;} :y :invalid :z [true {:a 123}]}) ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;L&quot; ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;S&quot; ;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;XL&quot; ;&gt;&gt;&gt; [:set [:enum &quot;S&quot; &quot;L&quot;]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;} ;&gt;&gt;&gt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;} ;&gt;&gt;&gt; :uuid -&gt; :invalid ;&gt;&gt;&gt; [:malli.core/val :uuid] -&gt; :invalid ;&gt;&gt;&gt; :boolean -&gt; true ;&gt;&gt;&gt; :int -&gt; 123 ;&gt;&gt;&gt; [:malli.core/val :int] -&gt; 123 ;&gt;&gt;&gt; [:map [:a :int]] -&gt; {:a 123} ;&gt;&gt;&gt; [:tuple :boolean [:map [:a :int]]] -&gt; [true {:a 123}] ;&gt;&gt;&gt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]] -&gt; [true {:a 123}] ;&gt;&gt;&gt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] -&gt; {:x #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}, :y :invalid, :z [true {:a 123}]}"><y>#</y><d>2022-05-31</d><h>12:31</h><r>ikitommi</r><pre>(decode
 {:x #{&quot;S&quot; &quot;L&quot; &quot;XL&quot;}
  :y :invalid
  :z [true {:a 123}]})
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;L&quot;
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;S&quot;
;&gt;&gt;&gt; [:enum &quot;S&quot; &quot;L&quot;] -&gt; &quot;XL&quot;
;&gt;&gt;&gt; [:set [:enum &quot;S&quot; &quot;L&quot;]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}
;&gt;&gt;&gt; [:malli.core/val [:set [:enum &quot;S&quot; &quot;L&quot;]]] -&gt; #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}
;&gt;&gt;&gt; :uuid -&gt; :invalid
;&gt;&gt;&gt; [:malli.core/val :uuid] -&gt; :invalid
;&gt;&gt;&gt; :boolean -&gt; true
;&gt;&gt;&gt; :int -&gt; 123
;&gt;&gt;&gt; [:malli.core/val :int] -&gt; 123
;&gt;&gt;&gt; [:map [:a :int]] -&gt; {:a 123}
;&gt;&gt;&gt; [:tuple :boolean [:map [:a :int]]] -&gt; [true {:a 123}]
;&gt;&gt;&gt; [:malli.core/val [:tuple :boolean [:map [:a :int]]]] -&gt; [true {:a 123}]
;&gt;&gt;&gt; [:map [:x [:set [:enum &quot;S&quot; &quot;L&quot;]]] [:y :uuid] [:z [:tuple :boolean [:map [:a :int]]]]] -&gt; {:x #{&quot;L&quot; &quot;S&quot; &quot;XL&quot;}, :y :invalid, :z [true {:a 123}]}</pre></z><z id="t1654001411" t="eskos Alright, thank you! What’s the second argument in :compile (fn [schema _] ... ?"><y>#</y><d>2022-05-31</d><h>12:50</h><r>eskos</r>Alright, thank you! What’s the second argument in <code>:compile (fn [schema _] ...</code> ?</z><z id="t1654001766" t="ikitommi _options , passed in all callbacks. Escape hatch to override anything at any time 😉"><y>#</y><d>2022-05-31</d><h>12:56</h><r>ikitommi</r><code>_options</code>, passed in all callbacks. Escape hatch to override anything at any time <b>😉</b></z><z id="t1654001836" t="eskos *danger-zone* 😄"><y>#</y><d>2022-05-31</d><h>12:57</h><r>eskos</r><code>*danger-zone*</code> <b>😄</b></z><z id="t1654448918" t="eskos Continuing on this, I’d need a bit of clarification, see snippet: (malli.core/decode [:map [:a {:foo :bar} :int]] {:a &quot;string&quot;} (malli.transform/transformer {:name :hello :default-decoder {:compile (fn [schema _] (println (str &quot;node schema: &quot; (malli.core/-form schema))) (fn [x] (println (str &quot;value:&quot; x &quot; / schema at val: &quot; (malli.core/-form schema))) x))}})) node schema: [:map [:a {:foo :bar} :int]] node schema: [:malli.core/val {:foo :bar} :int] node schema: :int value:{:a &quot;string&quot;} / schema at val: [:map [:a {:foo :bar} :int]] value:string / schema at val: [:malli.core/val {:foo :bar} :int] value:string / schema at val: :int =&gt; {:a &quot;string&quot;} It seems the :a tuple is walked twice, once for the tuple itself and once for the tuple’s value. I find this confusing, as the associative nature of [:a :int] would imply the properties of the key apply to the value as well. There’s a pretty easy way to get around this, schema [:map [:a [:int {:foo :bar}]]] does provide properties for the :int which really was my intention, and it sort of makes sense, but it’s of course a bit kludgier. My assumption here was that if, for example, the key is marked optional then its value is naturally optional as well, and as such, all other properties should transfer to values directly as well, plus the value shouldn’t be walked on its own. So, bug, feature, gotcha or something I could trick the transformer to handle through the aforementioned _options so that it doesn’t walk to the tuple’s value? 🙂 EDIT: I created an issue about this, lets continue on GH"><y>#</y><d>2022-06-05</d><h>17:08</h><r>eskos</r>Continuing on this, I’d need a bit of clarification, see snippet:
<pre>(malli.core/decode
  [:map [:a {:foo :bar} :int]]
  {:a &quot;string&quot;}
  (malli.transform/transformer
    {:name :hello
     :default-decoder
     {:compile (fn [schema _]
                 (println (str &quot;node schema: &quot; (malli.core/-form schema)))
                 (fn [x]
                   (println (str &quot;value:&quot; x &quot; / schema at val: &quot; (malli.core/-form schema)))
                   x))}}))
node schema: [:map [:a {:foo :bar} :int]]
node schema: [:malli.core/val {:foo :bar} :int]
node schema: :int
value:{:a &quot;string&quot;} / schema at val: [:map [:a {:foo :bar} :int]]
value:string / schema at val: [:malli.core/val {:foo :bar} :int]
value:string / schema at val: :int
=&gt; {:a &quot;string&quot;}</pre>
It seems the <code>:a</code>  tuple is walked twice, once for the tuple itself and once for the tuple’s value. I find this confusing, as the associative nature of <code>[:a :int]</code> would imply the properties of the key apply to the value as well.

There’s a pretty easy way to get around this, schema
<pre>[:map [:a [:int {:foo :bar}]]]</pre>
does provide properties for the <code>:int</code> which really was my intention, and it sort of makes sense, but it’s of course a bit kludgier.

My assumption here was that if, for example, the key is marked optional then its value is naturally optional as well, and as such, all other properties should transfer to values directly as well, plus the value shouldn’t be walked on its own.

So, bug, feature, gotcha or something I could trick the transformer to handle through the aforementioned <code>_options</code> so that it doesn’t walk to the tuple’s value? <b>🙂</b>

EDIT: I created an issue about this, lets continue on GH</z><z id="t1654518430" t="Tiago Dall&apos;Oca Hello hello! Is there a generics implemented in malli in some way? I was thinking maybe e.g. [:generic=&gt; [:n-type number?] [:cat :n-type] [:vector :n-type]] , :generic=&gt; taking a vector of pairs of keywords and schemas and then the usual :=&gt; args"><y>#</y><d>2022-06-06</d><h>12:27</h><w>Tiago Dall'Oca</w>Hello hello!

Is there a generics implemented in malli in some way? I was thinking maybe e.g. <code>[:generic=&gt; [:n-type number?] [:cat :n-type]  [:vector :n-type]]</code>, <code>:generic=&gt;</code> taking a vector of pairs of keywords and schemas and then the usual <code>:=&gt;</code> args</z><z id="t1654523426" t="NoahTheDuke All clojure functions are generic, lol"><y>#</y><d>2022-06-06</d><h>13:50</h><r>NoahTheDuke</r>All clojure functions are generic, lol</z><z id="t1654527941" t="Tiago Dall&apos;Oca the idea is to parse malli schemas to ts type definitions"><y>#</y><d>2022-06-06</d><h>15:05</h><r>Tiago Dall'Oca</r>the idea is to parse malli schemas to ts type definitions</z><z id="t1654527953" t="Tiago Dall&apos;Oca to make cljs libraries nicer to consume from ts"><y>#</y><d>2022-06-06</d><h>15:05</h><r>Tiago Dall'Oca</r>to make cljs libraries nicer to consume from ts</z><z id="t1654528331" t="NoahTheDuke Sorry, I replied with a cheeky comment but I meant to follow up: clojure inherently doesn&apos;t have generics and while I don&apos;t want to speak for the metosin folks, i suspect that the concept of &quot;generics&quot; fundamentally doesn&apos;t align with schema systems like malli. you can already achieve generics by just using :or and normal clojure functions: [:or (mapv #(do [:=&gt; [:cat %] [:vector %]]) [number? keyword? string?])]"><y>#</y><d>2022-06-06</d><h>15:12</h><r>NoahTheDuke</r>Sorry, I replied with a cheeky comment but I meant to follow up: clojure inherently doesn&apos;t have generics and while I don&apos;t want to speak for the metosin folks, i suspect that the concept of &quot;generics&quot; fundamentally doesn&apos;t align with schema systems like malli. you can already achieve generics by just using <code>:or</code> and normal clojure functions: <code>[:or (mapv #(do [:=&gt; [:cat %] [:vector %]]) [number? keyword? string?])]</code></z><z id="t1654528407" t="NoahTheDuke having said that, iwould be interested to see what you could build in this space as i think it has potential. it&apos;s cool to see the overlap between clojure schema systems and typescript&apos;s structural typing"><y>#</y><d>2022-06-06</d><h>15:13</h><r>NoahTheDuke</r>having said that, iwould be interested to see what you could build in this space as i think it has potential. it&apos;s cool to see the overlap between clojure schema systems and typescript&apos;s structural typing</z><z id="t1654531844" t="Ben Sless Simple schema can take an argument, make it the type"><y>#</y><d>2022-06-06</d><h>16:10</h><r>Ben Sless</r>Simple schema can take an argument, make it the type</z><z id="t1654531926" t="Ben Sless https://github.com/metosin/malli#content-dependent-simple-schema"><y>#</y><d>2022-06-06</d><h>16:12</h><r>Ben Sless</r><a href="https://github.com/metosin/malli#content-dependent-simple-schema" target="_blank">https://github.com/metosin/malli#content-dependent-simple-schema</a></z><z id="t1654604582" t="Tiago Dall&apos;Oca very nice"><y>#</y><d>2022-06-07</d><h>12:23</h><r>Tiago Dall'Oca</r>very nice</z><z id="t1654604607" t="Tiago Dall&apos;Oca malli positively surprising me as usual"><y>#</y><d>2022-06-07</d><h>12:23</h><r>Tiago Dall'Oca</r>malli positively surprising me as usual</z><z id="t1654604623" t="Tiago Dall&apos;Oca thank you all for the excellent work!"><y>#</y><d>2022-06-07</d><h>12:23</h><r>Tiago Dall'Oca</r>thank you all for the excellent work!</z><z id="t1654518532" t="Tiago Dall&apos;Oca I&apos;m developing mali-ts as a way to integrate malli schemas into typescript&apos;s type system and it&apos;d be really good to have generics, though I understand why in clojure it might not make so much sense"><y>#</y><d>2022-06-06</d><h>12:28</h><w>Tiago Dall'Oca</w>I&apos;m developing <code>mali-ts</code> as a way to integrate malli schemas into typescript&apos;s type system and it&apos;d be really good to have generics, though I understand why in clojure it might not make so much sense</z><z id="t1654518556" t="Tiago Dall&apos;Oca Maybe it&apos;s not even that hard to implement? I&apos;m not sure"><y>#</y><d>2022-06-06</d><h>12:29</h><w>Tiago Dall'Oca</w>Maybe it&apos;s not even that hard to implement? I&apos;m not sure</z><z id="t1654518669" t="Tiago Dall&apos;Oca And on the topic typescript integration, it&apos;d be really good to have a way to model Promise s and async stuff"><y>#</y><d>2022-06-06</d><h>12:31</h><w>Tiago Dall'Oca</w>And on the topic typescript integration, it&apos;d be really good to have a way to model <code>Promise</code>s and async stuff</z></g><g id="s24"><z id="t1654532009" t="Ben Sless If you have generics modeled then promises are solves, no?"><y>#</y><d>2022-06-06</d><h>16:13</h><r>Ben Sless</r>If you have generics modeled then promises are solves, no?</z><z id="t1654518704" t="Tiago Dall&apos;Oca If doesn&apos;t make sense to have those in malli , I might implement in malli-ts only"><y>#</y><d>2022-06-06</d><h>12:31</h><w>Tiago Dall'Oca</w>If doesn&apos;t make sense to have those in <code>malli</code>, I might implement in <code>malli-ts</code> only</z><z id="t1655063715" t="borkdude Hi! Can this be fixed somehow? ------ WARNING #1 - ----------------------------------------------------------- File: ~/.m2/repository/metosin/malli/0.8.4/malli-0.8.4.jar!/malli/core.cljc:2265:26 -------------------------------------------------------------------------------- 2262 | (reduce -register-var {})))) 2263 | 2264 | (defn class-schemas [] 2265 | {#?(:clj Pattern, :cljs js/RegExp) (-re-schema true)}) --------------------------------^----------------------------------------------- References to the global RegExp object prevents optimization of regular expressions I&apos;m compiling malli as part of #nbb and I&apos;d like to keep the rest of nbb optimized"><y>#</y><d>2022-06-12</d><h>19:55</h><w>borkdude</w>Hi! Can this be fixed somehow?
<pre>------ WARNING #1 -  -----------------------------------------------------------
 File: ~/.m2/repository/metosin/malli/0.8.4/malli-0.8.4.jar!/malli/core.cljc:2265:26
--------------------------------------------------------------------------------
2262 |          (reduce -register-var {}))))
2263 | 
2264 | (defn class-schemas []
2265 |   {#?(:clj Pattern, :cljs js/RegExp) (-re-schema true)})
--------------------------------^-----------------------------------------------
 References to the global RegExp object prevents optimization of regular expressions</pre>
I&apos;m compiling malli as part of #nbb and I&apos;d like to keep the rest of nbb optimized</z><z id="t1655065134" t="borkdude FYI: https://github.com/babashka/nbb#metosinmalli"><y>#</y><d>2022-06-12</d><h>20:18</h><w>borkdude</w>FYI: <a href="https://github.com/babashka/nbb#metosinmalli" target="_blank">https://github.com/babashka/nbb#metosinmalli</a></z><z id="t1655065164" t="juhoteperi https://github.com/metosin/malli/pull/692 Needs new release"><y>#</y><d>2022-06-12</d><h>20:19</h><w>juhoteperi</w><a href="https://github.com/metosin/malli/pull/692" target="_blank">https://github.com/metosin/malli/pull/692</a> Needs new release</z><z id="t1655066208" t="borkdude Awesome thank. cc [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}]"><y>#</y><d>2022-06-12</d><h>20:36</h><w>borkdude</w>Awesome thank. cc <a>@ikitommi</a></z><z id="t1655095636" t="ikitommi awesome! I’ll try to cut a release today (lot’s of small changes waiting)"><y>#</y><d>2022-06-13</d><h>04:47</h><w>ikitommi</w>awesome! I’ll try to cut a release today (lot’s of small changes waiting)</z><z id="t1655107719" t="ingesol I tested function instrumentation in CLJS recently, and it works pretty well with the pretty printer. One thing I noticed as a pain point was that I wanted to see the input args when an output value does not match the schema. Would that make sense to add? Or did I simply miss it?"><y>#</y><d>2022-06-13</d><h>08:08</h><w>ingesol</w>I tested function instrumentation in CLJS recently, and it works pretty well with the pretty printer. One thing I noticed as a pain point was that I wanted to see the input args when an output value does not match the schema. Would that make sense to add? Or did I simply miss it?</z><z id="t1655110914" t="ikitommi it’s not passed to the error reporter, should be a small change: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2453"><y>#</y><d>2022-06-13</d><h>09:01</h><r>ikitommi</r>it’s not passed to the error reporter, should be a small change: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2453" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2453</a></z><z id="t1655110936" t="ikitommi issue and pr would be most welcome."><y>#</y><d>2022-06-13</d><h>09:02</h><r>ikitommi</r>issue and pr would be most welcome.</z><z id="t1655110971" t="ikitommi no, the args are passed in"><y>#</y><d>2022-06-13</d><h>09:02</h><r>ikitommi</r>no, the args are passed in</z><z id="t1655110990" t="ikitommi just not used: https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc#L51-L58"><y>#</y><d>2022-06-13</d><h>09:03</h><r>ikitommi</r>just not used: <a href="https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc#L51-L58" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/dev/pretty.cljc#L51-L58</a></z><z id="t1655154609" t="ingesol Thanks. Was a quick fix, posted a PR"><y>#</y><d>2022-06-13</d><h>21:10</h><r>ingesol</r>Thanks. Was a quick fix, posted a PR</z><z id="t1655355700" t="pinkfrog Hi, is there some tool like https://github.com/Provisdom/spectomic but generates datomic schema from malli instead of spec ?"><y>#</y><d>2022-06-16</d><h>05:01</h><w>pinkfrog</w>Hi, is there some tool like <a href="https://github.com/Provisdom/spectomic" target="_blank">https://github.com/Provisdom/spectomic</a> but generates datomic schema from malli instead of spec ?</z><z id="t1655357981" t="Ben Sless I tried writing one once, I guess you could port some ideas from here and write a transformer like there is for json schema"><y>#</y><d>2022-06-16</d><h>05:39</h><r>Ben Sless</r>I tried writing one once, I guess you could port some ideas from here and write a transformer like there is for json schema</z><z id="t1655365050" t="pinkfrog Are you saying porting ideas from the above repo?"><y>#</y><d>2022-06-16</d><h>07:37</h><r>pinkfrog</r>Are you saying porting ideas from the above repo?</z><z id="t1655365680" t="eskos I don’t think Malli’s transformers can do 1-to-n replacements (eg. single value to map), although I haven’t tested the behavior for such case. That said, I don’t think it should be that hard to create equivalent behavior with some helper functions and whatnot, plus one area of malli I haven’t explored is the raw walk api, which may work just fine for this 🙂"><y>#</y><d>2022-06-16</d><h>07:48</h><r>eskos</r>I don’t think Malli’s transformers can do 1-to-n replacements (eg. single value to map), although I haven’t tested the behavior for such case.

That said, I don’t think it should be that hard to create equivalent behavior with some helper functions and whatnot, plus one area of malli I haven’t explored is the raw walk api, which may work just fine for this <b>🙂</b></z><z id="t1655369648" t="juhoteperi Should work. E.g.: [:map {:decode/string (fn [s] (if (string? s) (js/JSON.parse s) s))} [:foo :keyword]] Decode function for the map schema is run before checking map properties, and decoding those. At least I&apos;ve used this in cases where API takes comma separated string, and it is decoded to seq/vec and then items are coerced to keywords or such. Not sure if this answers the original question, but 1-to-n transfomer tranformations should work."><y>#</y><d>2022-06-16</d><h>08:54</h><r>juhoteperi</r>Should work. E.g.:

<code>[:map {:decode/string (fn [s] (if (string? s) (js/JSON.parse s) s))} [:foo :keyword]]</code>

Decode function for the map schema is run before checking map properties, and decoding those.

At least I&apos;ve used this in cases where API takes comma separated string, and it is decoded to seq/vec and then items are coerced to keywords or such.

Not sure if this answers the original question, but 1-to-n transfomer tranformations should work.</z><z id="t1655369717" t="juhoteperi (decoding is one use/type of transformer)"><y>#</y><d>2022-06-16</d><h>08:55</h><r>juhoteperi</r>(decoding is one use/type of transformer)</z><z id="t1655380147" t="eskos Okay, that’s great. Tangentially, I just did a Thing™ which I didn’t mean to but can be abused to do something like this 😅 I’ll create another thread about it since it’s sort of a pre-release now."><y>#</y><d>2022-06-16</d><h>11:49</h><r>eskos</r>Okay, that’s great. Tangentially, I just did a Thing™ which I didn’t mean to but can be abused to do something like this <b>😅</b> I’ll create another thread about it since it’s sort of a pre-release now.</z><z id="t1655380439" t="eskos There’s that post. So yeah, https://github.com/esuomi/muotti/ can be abused like so: (require &apos;[malli.core :as malli]) (require &apos;[muotti.core :as muotti]) (require &apos;[muotti.malli :as mm]) (malli/decode [:string] 1 (mm/transformer (muotti/-&gt;transformer {:transformations {[:int :string] {:transformer (constantly {:a 1 :b &quot;wow&quot;})}}}))) Obviously custom schema registry support needs to be added to make this even remotely sensible :rolling_on_the_floor_laughing:"><y>#</y><d>2022-06-16</d><h>11:53</h><r>eskos</r>There’s that post. So yeah, <a href="https://github.com/esuomi/muotti/" target="_blank">https://github.com/esuomi/muotti/</a> can be abused like so:
<pre>(require &apos;[malli.core :as malli])
(require &apos;[muotti.core :as muotti])
(require &apos;[muotti.malli :as mm])

(malli/decode
  [:string]
  1
  (mm/transformer (muotti/-&gt;transformer 
                    {:transformations {[:int :string] {:transformer (constantly {:a 1 :b &quot;wow&quot;})}}})))</pre>
Obviously custom schema registry support needs to be added to make this even remotely sensible <b>:rolling_on_the_floor_laughing:</b></z><z id="t1655380267" t="eskos Just released https://github.com/esuomi/muotti/ , a graph-based value transformation chain library which has integration with malli’s transformers."><y>#</y><d>2022-06-16</d><h>11:51</h><w>eskos</w>Just released <a href="https://github.com/esuomi/muotti/" target="_blank">https://github.com/esuomi/muotti/</a>, a graph-based value transformation chain library which has integration with malli’s transformers.</z><z id="t1655380338" t="eskos Malli support is still somewhat in progress as malli has tons of schemas and some can be considered quite subjective (eg. for value transformation, what does ) but maybe those can be supported eventually as well. For now core types are supported."><y>#</y><d>2022-06-16</d><h>11:52</h><r>eskos</r>Malli support is still somewhat in progress as malli has tons of schemas and some can be considered quite subjective (eg. for value transformation, what does ) but maybe those can be supported eventually as well. For now core types are supported.</z><z id="t1655380477" t="eskos And this is a sort of pre-release for now which is why I put this here, not #announcements - have to let the dust settle first 🙂"><y>#</y><d>2022-06-16</d><h>11:54</h><r>eskos</r>And this is a sort of pre-release for now which is why I put this here, not #announcements - have to let the dust settle first <b>🙂</b></z><z id="t1655381969" t="ikitommi Looks great! like byte-streams, but for (literal) data. Malli will have effective and derived types, will simplify things a lot, https://github.com/metosin/malli/issues/264"><y>#</y><d>2022-06-16</d><h>12:19</h><r>ikitommi</r>Looks great! like byte-streams, but for (literal) data. Malli will have effective and derived types, will simplify things a lot, <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a></z><z id="t1655382398" t="eskos Thanks! 😸 Figuring out which schemas to support and how is going to be an on-going process, I think - I’m going to exclusively avoid doing validation with muotti, naturally. My intention is to start using this in an actual project quite soonish, so I’m hoping that’ll let me refine the native support and providing sensible defaults. And as curiosity, muotti was made almost entirely during a few train trips between Helsinki and Tampere… 🙂"><y>#</y><d>2022-06-16</d><h>12:26</h><r>eskos</r>Thanks! <b>😸</b>

Figuring out which schemas to support and how is going to be an on-going process, I think - I’m going to exclusively avoid doing validation with muotti, naturally. My intention is to start using this in an actual project quite soonish, so I’m hoping that’ll let me refine the native support and providing sensible defaults.

And as curiosity, muotti was made almost entirely during a few train trips between Helsinki and Tampere… <b>🙂</b></z><z id="t1655516133" t="Valentín Hi, I want to use malli for form-input validation... I want to display customs errors"><y>#</y><d>2022-06-18</d><h>01:35</h><w>Valentín</w>Hi, I want to use malli for form-input validation... I want to display customs errors</z><z id="t1655516171" t="Valentín How could I display error msg base on the input value?"><y>#</y><d>2022-06-18</d><h>01:36</h><w>Valentín</w>How could I display error msg base on the input value?</z><z id="t1655516389" t="Valentín Example: If the user did not type anything at all, I want to display &quot;This field is required&quot;, is the user typed just one character, I want to display the following error msg &quot;It should be at least 2 character long&quot;"><y>#</y><d>2022-06-18</d><h>01:39</h><w>Valentín</w>Example: If the user did not type anything at all, I want to display &quot;This field is required&quot;, is the user typed just one character, I want to display the following error msg &quot;It should be at least 2 character long&quot;</z><z id="t1655516516" t="Valentín (def form-name [:string {:min 2 :fn {:error/fn &apos;(fn [{:keys [value]} _] (if (empty value) &quot;This field is required&quot; &quot;It must be at least 2 character long&quot;))}}]) (def form [:map [:name form-name]]) (me/humanize (m/explain form {:name &quot;&quot;})) ; The behaviour I want ; =&gt; &quot;This field is required&quot; (me/humanize (m/explain form {:name &quot;J&quot;})) ; The behaviour I want ; =&gt; &quot;It must be at least 2 character long&quot;"><y>#</y><d>2022-06-18</d><h>01:41</h><w>Valentín</w><pre>(def form-name [:string {:min 2
                         :fn {:error/fn &apos;(fn [{:keys [value]} _]
                                           (if (empty value)
                                             &quot;This field is required&quot;
                                             &quot;It must be at least 2 character long&quot;))}}])
(def form [:map [:name form-name]])

(me/humanize (m/explain form {:name &quot;&quot;}))
; The behaviour I want
; =&gt; &quot;This field is required&quot;

(me/humanize (m/explain form {:name &quot;J&quot;}))
; The behaviour I want
; =&gt; &quot;It must be at least 2 character long&quot;</pre></z><z id="t1655541286" t="George Peristerakis I think your error is in your precondition, the function you should use is empty? instead of empty"><y>#</y><d>2022-06-18</d><h>08:34</h><r>George Peristerakis</r>I think your error is in your precondition, the function you should use is <code>empty?</code> instead of <code>empty</code></z><z id="t1655541806" t="Ben Sless I think the defaults already give you this behavior. Try deleting the fn property"><y>#</y><d>2022-06-18</d><h>08:43</h><r>Ben Sless</r>I think the defaults already give you this behavior. Try deleting the fn property</z><z id="t1655564312" t="Valentín There is also something wrong, the fn function never evaluate. [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I want to custom the default error msg."><y>#</y><d>2022-06-18</d><h>14:58</h><r>Valentín</r>There is also something wrong, the fn function never evaluate. <a>@UK0810AQ2</a> I want to custom the default error msg.</z><z id="t1655566945" t="Ben Sless The property should be :error/fn directly, without the preceding :fn key But what&apos;s wrong with the default errors? :string {:error/fn {:en (fn [{:keys [schema value]} _] (let [{:keys [min max]} (m/properties schema)] (cond (not (string? value)) &quot;should be a string&quot; (and min (= min max)) (str &quot;should be &quot; min &quot; characters&quot;) (and min max) (str &quot;should be between &quot; min &quot; and &quot; max &quot; characters&quot;) min (str &quot;should be at least &quot; min &quot; characters&quot;) max (str &quot;should be at most &quot; max &quot; characters&quot;))))}} And if it&apos;s in a map you&apos;ll get &quot;missing required field blah&quot; from there Also, I think you should use empty? and not empty"><y>#</y><d>2022-06-18</d><h>15:42</h><r>Ben Sless</r>The property should be <code>:error/fn</code> directly, without the preceding <code>:fn</code> key
But what&apos;s wrong with the default errors?
<pre>:string {:error/fn {:en (fn [{:keys [schema value]} _]
                             (let [{:keys [min max]} (m/properties schema)]
                               (cond
                                 (not (string? value)) &quot;should be a string&quot;
                                 (and min (= min max)) (str &quot;should be &quot; min &quot; characters&quot;)
                                 (and min max) (str &quot;should be between &quot; min &quot; and &quot; max &quot; characters&quot;)
                                 min (str &quot;should be at least &quot; min &quot; characters&quot;)
                                 max (str &quot;should be at most &quot; max &quot; characters&quot;))))}}</pre>
And if it&apos;s in a map you&apos;ll get &quot;missing required field blah&quot; from there
Also, I think you should use <code>empty?</code> and not <code>empty</code></z><z id="t1655697336" t="Valentín [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] did you run this code on the repl? I coud not make it works."><y>#</y><d>2022-06-20</d><h>03:55</h><r>Valentín</r><a>@UK0810AQ2</a> did you run this code on the repl? I coud not make it works.</z><z id="t1655697507" t="Valentín Also, I copy and paste the following code from github, and I&apos;m getting the following exception... What am I missing?"><y>#</y><d>2022-06-20</d><h>03:58</h><r>Valentín</r>Also, I copy and paste the following code from github, and I&apos;m getting the following exception... What am I missing?</z><z id="t1655697514" t="Valentín Thanks"><y>#</y><d>2022-06-20</d><h>03:58</h><r>Valentín</r>Thanks</z><z id="t1655697554" t="Ben Sless I copied this example from malli&apos;s source, I assume it works"><y>#</y><d>2022-06-20</d><h>03:59</h><r>Ben Sless</r>I copied this example from malli&apos;s source, I assume it works</z><z id="t1656103465" t="jprudent [:attrs {:href &quot;/_/_/users/U0103KEKSLR&quot;}] you need to add the sci dependency to your project if your functions are quoted"><y>#</y><d>2022-06-24</d><h>20:44</h><r>jprudent</r><a>@U0103KEKSLR</a> you need to add the sci dependency to your project if your functions are quoted</z><z id="t1655516555" t="Valentín Thanks in advance"><y>#</y><d>2022-06-18</d><h>01:42</h><w>Valentín</w>Thanks in advance</z><z id="t1655697963" t="Panel Could it be done to validate with an async fn ?"><y>#</y><d>2022-06-20</d><h>04:06</h><w>Panel</w>Could it be done to validate with an async fn ?</z><z id="t1655743933" t="ikitommi not sure what is the question in here."><y>#</y><d>2022-06-20</d><h>16:52</h><r>ikitommi</r>not sure what is the question in here.</z><z id="t1655728026" t="borkdude How do you express [s/Long] (vector of Long in Schema) in malli?"><y>#</y><d>2022-06-20</d><h>12:27</h><w>borkdude</w>How do you express <code>[s/Long]</code> (vector of Long in Schema) in malli?</z><z id="t1655728346" t="ikitommi a [:vector :int] is close, but for all int? s."><y>#</y><d>2022-06-20</d><h>12:32</h><r>ikitommi</r>a <code>[:vector :int]</code> is close, but for all <code>int?</code>s.</z><z id="t1655728374" t="ikitommi for exact class, many ways (could be simpler), but one being: (def a-long (m/-simple-schema {:pred #(instance? Long %)})) (m/validate a-long (Integer. 12)) ;=&gt; false (m/validate a-long (Long. 12)) ; =&gt; true"><y>#</y><d>2022-06-20</d><h>12:32</h><r>ikitommi</r>for exact class, many ways (could be simpler), but one being:
<pre>(def a-long (m/-simple-schema {:pred #(instance? Long %)}))

(m/validate a-long (Integer. 12)) ;=&gt; false
(m/validate a-long (Long. 12)) ; =&gt; true</pre></z><z id="t1655728428" t="ikitommi with min, max &amp; json-schema translation: (def a-long (m/-simple-schema {:type :long :pred #(instance? Long %) :json-schema {:type &quot;long&quot;} :property-pred (m/-min-max-pred nil)})) (m/validate [a-long {:min 10}] (Long. 12)) ; =&gt; true (m/validate [a-long {:min 10}] (Long. 8)) ; =&gt; false"><y>#</y><d>2022-06-20</d><h>12:33</h><r>ikitommi</r>with min, max &amp; json-schema translation:
<pre>(def a-long
  (m/-simple-schema
   {:type :long
    :pred #(instance? Long %)
    :json-schema {:type &quot;long&quot;}
    :property-pred (m/-min-max-pred nil)}))

(m/validate [a-long {:min 10}] (Long. 12)) ; =&gt; true
(m/validate [a-long {:min 10}] (Long. 8)) ; =&gt; false</pre></z><z id="t1655728466" t="ikitommi someone asked full support for using Java Classes as Schemas. But that would not work with cljs."><y>#</y><d>2022-06-20</d><h>12:34</h><r>ikitommi</r>someone asked full support for using Java Classes as Schemas. But that would not work with cljs.</z><z id="t1655728491" t="ikitommi would allow [:vector Long]"><y>#</y><d>2022-06-20</d><h>12:34</h><r>ikitommi</r>would allow <code>[:vector Long]</code></z><z id="t1655728549" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] The reason I&apos;m asking is that my new (work-in-progress) CLI library is using a notation similar to schema for coercion: https://github.com/babashka/cli E.g.: {:coerce {:a :int}} will turn &quot;--a&quot; &quot;1&quot; into {:a 1} and {:coerce {:a [:int]}} will turn &quot;--a&quot; &quot;1&quot; into {:a [1]} . This coercion syntax doesn&apos;t have to be as powerful as malli. The idea is that you can coerce command line args into a map and then do validation on that (in your clojure function) using spec or malli (since it&apos;s a detail whether you are calling this function from the command line or from the REPL)"><y>#</y><d>2022-06-20</d><h>12:35</h><r>borkdude</r><a>@U055NJ5CC</a> The reason I&apos;m asking is that my new (work-in-progress) CLI library is using a notation similar to schema for coercion:

<a href="https://github.com/babashka/cli" target="_blank">https://github.com/babashka/cli</a>

E.g.: <code>{:coerce {:a :int}}</code> will turn <code>&quot;--a&quot; &quot;1&quot;</code> into <code>{:a 1}</code> and <code>{:coerce {:a [:int]}}</code> will turn <code>&quot;--a&quot; &quot;1&quot;</code> into <code>{:a [1]}</code> . This coercion syntax doesn&apos;t have to be as powerful as malli. The idea is that you can coerce command line args into a map and then do validation on that (in your clojure function) using spec or malli (since it&apos;s a detail whether you are calling this function from the command line or from the REPL)</z><z id="t1655728794" t="ikitommi yeah, that looks great!"><y>#</y><d>2022-06-20</d><h>12:39</h><r>ikitommi</r>yeah, that looks great!</z><z id="t1655728802" t="ikitommi there is the malli-lite syntax too."><y>#</y><d>2022-06-20</d><h>12:40</h><r>ikitommi</r>there is the malli-lite syntax too.</z><z id="t1655728804" t="ikitommi (defn coercer [schema] (m/decoder (lite/schema schema) (mt/string-transformer))) ((coercer {:a :int}) {:a &quot;123&quot;}) ; =&gt; {:a 123}"><y>#</y><d>2022-06-20</d><h>12:40</h><r>ikitommi</r><pre>(defn coercer [schema]
  (m/decoder (lite/schema schema) (mt/string-transformer)))

((coercer {:a :int}) {:a &quot;123&quot;})
; =&gt; {:a 123}</pre></z><z id="t1655729261" t="ikitommi so, you will have your own transforming part there (the simplest way to do this, looks simple), but the future processing would be done using a full(er) schema/spec lib?"><y>#</y><d>2022-06-20</d><h>12:47</h><r>ikitommi</r>so, you will have your own transforming part there (the simplest way to do this, looks simple), but the future processing would be done using a full(er) schema/spec lib?</z><z id="t1655729335" t="borkdude The idea is inspired by clojure -X, you just call a clojure function from the command line basically. And whether you call this function via the command line, or via the REPL, the validation of arguments needs to happen anyway. So why put the validation logic in a CLI library, while it should probably live inside your app code"><y>#</y><d>2022-06-20</d><h>12:48</h><r>borkdude</r>The idea is inspired by clojure -X, you just call a clojure function from the command line basically. And whether you call this function via the command line, or via the REPL, the validation of arguments needs to happen anyway. So why put the validation logic in a CLI library, while it should probably live inside your app code</z><z id="t1655729359" t="borkdude And so yes, you should do validation of args the same way you were doing it anyways in Clojure (with malli, schema, manual asserts)"><y>#</y><d>2022-06-20</d><h>12:49</h><r>borkdude</r>And so yes, you should do validation of args the same way you were doing it anyways in Clojure (with malli, schema, manual asserts)</z><z id="t1655729398" t="borkdude And you can then choose whatever you were using. The main job of the CLI library is to transform strings into data, not much more than that"><y>#</y><d>2022-06-20</d><h>12:49</h><r>borkdude</r>And you can then choose whatever you were using. The main job of the CLI library is to transform strings into data, not much more than that</z><z id="t1655729521" t="borkdude By keeping it simple, you can also put your coercion &quot;spec&quot; in the deps.edn file (it doesn&apos;t require any function symbols, just keywords and collections)"><y>#</y><d>2022-06-20</d><h>12:52</h><r>borkdude</r>By keeping it simple, you can also put your coercion &quot;spec&quot; in the deps.edn file (it doesn&apos;t require any function symbols, just keywords and collections)</z><z id="t1655729706" t="ikitommi 👍"><y>#</y><d>2022-06-20</d><h>12:55</h><r>ikitommi</r><b>👍</b></z><z id="t1655729799" t="ikitommi that’s one of the goal of malli too, to give a literal notation for schemas. Using full malli is too big for this case I guess? or does it miss something?"><y>#</y><d>2022-06-20</d><h>12:56</h><r>ikitommi</r>that’s one of the goal of malli too, to give a literal notation for schemas. Using full malli is too big for this case I guess? or does it miss something?</z><z id="t1655729849" t="borkdude I want to it be an un-opiniated library so it works together with malli, spec, schema or your hand-rolled things"><y>#</y><d>2022-06-20</d><h>12:57</h><r>borkdude</r>I want to it be an un-opiniated library so it works together with malli, spec, schema or your hand-rolled things</z><z id="t1655729902" t="borkdude although we could add some docs on how you can integrate with malli"><y>#</y><d>2022-06-20</d><h>12:58</h><r>borkdude</r>although we could add some docs on how you can integrate with malli</z><z id="t1655729912" t="borkdude the malli-lite syntax seems great for that"><y>#</y><d>2022-06-20</d><h>12:58</h><r>borkdude</r>the malli-lite syntax seems great for that</z><z id="t1655729913" t="ikitommi I think that’s a good choice. Is it possible to make it pluggable?"><y>#</y><d>2022-06-20</d><h>12:58</h><r>ikitommi</r>I think that’s a good choice. Is it possible to make it pluggable?</z><z id="t1655729933" t="ikitommi yes, happy to provide the example/glue if there is an extension point for that."><y>#</y><d>2022-06-20</d><h>12:58</h><r>ikitommi</r>yes, happy to provide the example/glue if there is an extension point for that.</z><z id="t1655729958" t="borkdude we could maybe do this using a protocol or multimethod? :thinking_face:"><y>#</y><d>2022-06-20</d><h>12:59</h><r>borkdude</r>we could maybe do this using a protocol or multimethod? <b>:thinking_face:</b></z><z id="t1655730022" t="borkdude but even without this, it&apos;s easy to plug in your own thing, since after coercion you&apos;re dealing with just clojure data"><y>#</y><d>2022-06-20</d><h>13:00</h><r>borkdude</r>but even without this, it&apos;s easy to plug in your own thing, since after coercion you&apos;re dealing with just clojure data</z><z id="t1655822565" t="ikitommi without yet looking at the code, multimethod sounds good. Global Side Effects For The Win! 🙂 will check the repo later. thanks for the lib(s), again."><y>#</y><d>2022-06-21</d><h>14:42</h><r>ikitommi</r>without yet looking at the code, multimethod sounds good. Global Side Effects For The Win! <b>🙂</b> will check the repo later. thanks for the lib(s), again.</z><z id="t1655768679" t="Panel If I have a form and want to validate on things that can only be done on server. Could I validate a schema with an async call ?"><y>#</y><d>2022-06-20</d><h>23:44</h><w>Panel</w>If I have a form and want to validate on things that can only be done on server.
Could I validate a schema with an async call ?</z><z id="t1655775823" t="Lucy Wang Why not? Simply send the raw form data to the server using ajax, the server validates it, then send back the result."><y>#</y><d>2022-06-21</d><h>01:43</h><r>Lucy Wang</r>Why not? Simply send the raw form data to the server using ajax, the server validates it, then send back the result.</z><z id="t1655780658" t="Panel I was wondering if this can be describe as a malli schema, maybe using a Fn schemas."><y>#</y><d>2022-06-21</d><h>03:04</h><r>Panel</r>I was wondering if this can be describe as a malli schema, maybe using a Fn schemas.</z><z id="t1655888638" t="Setzer22 Is there a default schema type for dates? Something like :date or :inst (except I tried those but they don&apos;t work)"><y>#</y><d>2022-06-22</d><h>09:03</h><w>Setzer22</w>Is there a default schema type for dates? Something like <code>:date</code> or <code>:inst</code> (except I tried those but they don&apos;t work)</z><z id="t1655909765" t="eskos inst? predicate is supported, but not much else probably due to cross-platform support being tricky"><y>#</y><d>2022-06-22</d><h>14:56</h><r>eskos</r><code>inst?</code> predicate is supported, but not much else probably due to cross-platform support being tricky</z><z id="t1655893916" t="ingesol https://clojurians.slack.com/archives/CHY97NXE2/p1655893717482109"><y>#</y><d>2022-06-22</d><h>10:31</h><w>ingesol</w><a href="https://clojurians.slack.com/archives/CHY97NXE2/p1655893717482109" target="_blank">https://clojurians.slack.com/archives/CHY97NXE2/p1655893717482109</a></z><z id="t1655980820" t="ikitommi finally had time to release it, the pre-summer-holiday-edition 🌴"><y>#</y><d>2022-06-23</d><h>10:40</h><w>ikitommi</w>finally had time to release it, the pre-summer-holiday-edition <b>🌴</b></z><z id="t1656020162" t="devn any chance at compojure-api + malli? is that work that just needs doing or is there a fundamental reason why malli couldn’t be added as an option on compojure-api?"><y>#</y><d>2022-06-23</d><h>21:36</h><w>devn</w>any chance at compojure-api + malli? is that work that just needs doing or is there a fundamental reason why malli couldn’t be added as an option on compojure-api?</z><z id="t1656094381" t="devn looking now, i suppose the answer is to use reitit"><y>#</y><d>2022-06-24</d><h>18:13</h><w>devn</w>looking now, i suppose the answer is to use reitit</z><z id="t1656094414" t="devn but either way i’m curious if a patch would be accepted to handle malli coercions in compojure-api"><y>#</y><d>2022-06-24</d><h>18:13</h><w>devn</w>but either way i’m curious if a patch would be accepted to handle malli coercions in compojure-api</z><z id="t1656346787" t="Ben Sless [:attrs {:href &quot;/_/_/users/U6N4HSMFW&quot;}] moving discussion of malli here, regarding json schema, the first item we should tackle, and hardest, IMO, is time schemas. There was a PR I opened and a long thread on it in the issues. It seems like the biggest tension there is good-enough vs. specification compliance How do you want to handle it?"><y>#</y><d>2022-06-27</d><h>16:19</h><w>Ben Sless</w><a>@valtteri</a> moving discussion of malli here, regarding json schema, the first item we should tackle, and hardest, IMO, is time schemas. There was a PR I opened and a long thread on it in the issues.
It seems like the biggest tension there is good-enough vs. specification compliance
How do you want to handle it?</z><z id="t1656346935" t="Ben Sless https://github.com/metosin/malli/issues/501"><y>#</y><d>2022-06-27</d><h>16:22</h><r>Ben Sless</r><a href="https://github.com/metosin/malli/issues/501" target="_blank">https://github.com/metosin/malli/issues/501</a></z><z id="t1656346961" t="Ben Sless https://github.com/metosin/malli/issues/49"><y>#</y><d>2022-06-27</d><h>16:22</h><r>Ben Sless</r><a href="https://github.com/metosin/malli/issues/49" target="_blank">https://github.com/metosin/malli/issues/49</a></z><z id="t1656347228" t="dvingo for cljs I would vote for https://github.com/henryw374/cljc.java-time (what tick uses) but how do you deal with this now being a dependency of malli?"><y>#</y><d>2022-06-27</d><h>16:27</h><r>dvingo</r>for cljs I would vote for <a href="https://github.com/henryw374/cljc.java-time" target="_blank">https://github.com/henryw374/cljc.java-time</a> (what tick uses) but how do you deal with this now being a dependency of malli?</z><z id="t1656347260" t="dvingo perhaps utilizing https://github.com/borkdude/dynaload ?"><y>#</y><d>2022-06-27</d><h>16:27</h><r>dvingo</r>perhaps utilizing <a href="https://github.com/borkdude/dynaload" target="_blank">https://github.com/borkdude/dynaload</a> ?</z><z id="t1656347598" t="valtteri Hmmm personally I’d like to minimize dependencies"><y>#</y><d>2022-06-27</d><h>16:33</h><r>valtteri</r>Hmmm personally I’d like to minimize dependencies</z><z id="t1656347651" t="valtteri I think the java.time stuff looks good and in CLJS we could perhaps just use js dates (I know, they’re bad) or goog.date?"><y>#</y><d>2022-06-27</d><h>16:34</h><r>valtteri</r>I think the java.time stuff looks good and in CLJS we could perhaps just use js dates (I know, they’re bad) or goog.date?</z><z id="t1656347710" t="valtteri We can always make initial release under malli.experimental.something so we can move on and get feedback"><y>#</y><d>2022-06-27</d><h>16:35</h><r>valtteri</r>We can always make initial release under <code>malli.experimental.something</code> so we can move on and get feedback</z><z id="t1656347777" t="dvingo how about a code path branch using dynaload? - one set of schemas backed by js dates and one by js-joda (cljc.java-time)"><y>#</y><d>2022-06-27</d><h>16:36</h><r>dvingo</r>how about a code path branch using dynaload? - one set of schemas backed by js dates and one by js-joda (cljc.java-time)</z><z id="t1656347791" t="valtteri And if it’s a decision between “good enough” and “specification compliance” this one leans to “good enough”"><y>#</y><d>2022-06-27</d><h>16:36</h><r>valtteri</r>And if it’s a decision between “good enough” and “specification compliance” this one leans to “good enough”</z><z id="t1656347836" t="dvingo but yea not a big deal because a date lib can always be added in user-space"><y>#</y><d>2022-06-27</d><h>16:37</h><r>dvingo</r>but yea not a big deal because a date lib can always be added in user-space</z><z id="t1656347991" t="valtteri Would these be realistic goals? • good and practical defaults for Java • “good enough” defaults for JS • no new deps With a quick glance Ben’s suggestion for the java impl looks good and practical to me. I’ll promise to read through all the linked references tonight."><y>#</y><d>2022-06-27</d><h>16:39</h><r>valtteri</r>Would these be realistic goals?
• good and practical defaults for Java
• “good enough” defaults for JS
• no new deps
With a quick glance Ben’s suggestion for the java impl looks good and practical to me. I’ll promise to read through all the linked references tonight.</z><z id="t1656349302" t="Ben Sless Thanks I&apos;d also try getting feedback from Henry, both on our current options and maybe on a path forwards, how we could reach full spec compliance while delivering something that covers 99% of use cases in the meanwhile"><y>#</y><d>2022-06-27</d><h>17:01</h><r>Ben Sless</r>Thanks
I&apos;d also try getting feedback from Henry, both on our current options and maybe on a path forwards, how we could reach full spec compliance while delivering something that covers 99% of use cases in the meanwhile</z><z id="t1656350404" t="valtteri Oh, so you have a hard requirement for the full spec compliance?"><y>#</y><d>2022-06-27</d><h>17:20</h><r>valtteri</r>Oh, so you have a hard requirement for the full spec compliance?</z><z id="t1656350572" t="valtteri I think we anyway want to have extension points so that the behaviour can be customized."><y>#</y><d>2022-06-27</d><h>17:22</h><r>valtteri</r>I think we anyway want to have extension points so that the behaviour can be customized.</z><z id="t1656350593" t="valtteri But have defaults that work for the 99%"><y>#</y><d>2022-06-27</d><h>17:23</h><r>valtteri</r>But have defaults that work for the 99%</z><z id="t1656355479" t="Ben Sless With an eye towards an end goal of using json schema or async api across an organization, with a variety of languages, I want to at least have parity in features"><y>#</y><d>2022-06-27</d><h>18:44</h><r>Ben Sless</r>With an eye towards an end goal of using json schema or async api across an organization, with a variety of languages, I want to at least have parity in features</z><z id="t1656424786" t="Colin P. Hill Unsure if this is in the scope of your discussion, but I&apos;m currently working on an effort that uses the support Malli has for this so far, and besides a lack of built-in support for types beyond date-time , the other pain point I&apos;ve been running into for time types is that the generated JSON schemas are less restrictive than the Malli schemas they&apos;re based on. A uuid? in Malli becomes a value with a string with a format of date-time in JSON – but JSON Schema validators are not required to treat format s as normative. This means another system could consume the JSON Schema output to validate a message, pass the message to the system using Malli, and then have it rejected as invalid. My workaround has been manually adding a pattern field."><y>#</y><d>2022-06-28</d><h>13:59</h><r>Colin P. Hill</r>Unsure if this is in the scope of your discussion, but I&apos;m currently working on an effort that uses the support Malli has for this so far, and besides a lack of built-in support for types beyond <code>date-time</code>, the other pain point I&apos;ve been running into for time types is that the generated JSON schemas are less restrictive than the Malli schemas they&apos;re based on. A <code>uuid?</code> in Malli becomes a value with a string with a <code>format</code> of <code>date-time</code> in JSON – but JSON Schema validators are not required to treat <code>format</code>s as normative. This means another system could consume the JSON Schema output to validate a message, pass the message to the system using Malli, and then have it rejected as invalid. My workaround has been manually adding a <code>pattern</code> field.</z><z id="t1656522521" t="valtteri I&apos;ve been thinking this and one way to circumvent the date/time type problem could be to treat them as strings. There could be a regex schema according to the format in JSON-schema. Dunno if this would make any sense though. But this is how it works in JSON-schema."><y>#</y><d>2022-06-29</d><h>17:08</h><r>valtteri</r>I&apos;ve been thinking this and one way to circumvent the date/time type problem could be to treat them as strings. There could be a regex schema according to the <code>format</code>  in JSON-schema. Dunno if this would make any sense though. But this is how it works in JSON-schema.</z><z id="t1656522602" t="valtteri I&apos;ve read through all the earlier conversations and checked a couple of different JSON schema implementations how they do it. I think I&apos;m more confused now than in the beginning. 😄"><y>#</y><d>2022-06-29</d><h>17:10</h><r>valtteri</r>I&apos;ve read through all the earlier conversations and checked a couple of different JSON schema implementations how they do it. I think I&apos;m more confused now than in the beginning. <b>😄</b></z><z id="t1656522810" t="Ben Sless We could always ask in their slack"><y>#</y><d>2022-06-29</d><h>17:13</h><r>Ben Sless</r>We could always ask in their slack</z><z id="t1656522867" t="valtteri Yeah. But what do you think [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] if in JSON-schema temporal types are strings with some enforced format.. would it make sense to do it in the same way on malli side?"><y>#</y><d>2022-06-29</d><h>17:14</h><r>valtteri</r>Yeah. But what do you think <a>@UK0810AQ2</a> if in JSON-schema temporal types are strings with some enforced format.. would it make sense to do it in the same way on malli side?</z><z id="t1656522907" t="valtteri So we could be compliant and move on 😉"><y>#</y><d>2022-06-29</d><h>17:15</h><r>valtteri</r>So we could be compliant and move on <b>😉</b></z><z id="t1656522943" t="valtteri Another thing we should clarify is that which version(s) of the JSON-schema spec are we targeting to support"><y>#</y><d>2022-06-29</d><h>17:15</h><r>valtteri</r>Another thing we should clarify is that which version(s) of the JSON-schema spec are we targeting to support</z><z id="t1656523561" t="valtteri We can also try to not solve the malli temporal schemas in general but make json-schema specific variants. If this would help us to move on"><y>#</y><d>2022-06-29</d><h>17:26</h><r>valtteri</r>We can also try to not solve the malli temporal schemas in general but make json-schema specific variants. If this would help us to move on</z><z id="t1656530331" t="Ben Sless Thing is, in malli you can accept strings and make sure they transform to timestamps. When they leave the system they&apos;ll be serialized back to strings anyway"><y>#</y><d>2022-06-29</d><h>19:18</h><r>Ben Sless</r>Thing is, in malli you can accept strings and make sure they transform to timestamps. When they leave the system they&apos;ll be serialized back to strings anyway</z><z id="t1656530342" t="Ben Sless The temporal thing has become my bugbear"><y>#</y><d>2022-06-29</d><h>19:19</h><r>Ben Sless</r>The temporal thing has become my bugbear</z><z id="t1656531249" t="valtteri Yeah I understand that but I was thinking since timestamps are the “blocker” because there are so many possible ways to do them and it&apos;s difficult to make it good for both java and js, we could try to avoid those decisions. Java side is more clear to me. We could also think “java first and js some day”."><y>#</y><d>2022-06-29</d><h>19:34</h><r>valtteri</r>Yeah I understand that but I was thinking since timestamps are the “blocker” because there are so many possible ways to do them and it&apos;s difficult to make it good for both java and js, we could try to avoid those decisions.

Java side is more clear to me. We could also think “java first and js some day”.</z><z id="t1656531377" t="valtteri If we think only Java and assume your suggestion about the types, there are no blockers…right? :thinking_face:"><y>#</y><d>2022-06-29</d><h>19:36</h><r>valtteri</r>If we think only Java and assume your suggestion about the types, there are no blockers…right? <b>:thinking_face:</b></z><z id="t1656531864" t="Ben Sless Not from me, Tommi or Henry might have reservations we should account for"><y>#</y><d>2022-06-29</d><h>19:44</h><r>Ben Sless</r>Not from me, Tommi or Henry might have reservations we should account for</z><z id="t1656532235" t="valtteri I think we could whip up a working example to make it concrete. I guess the types can easily be changed if better suggestions pop up"><y>#</y><d>2022-06-29</d><h>19:50</h><r>valtteri</r>I think we could whip up a working example to make it concrete. I guess the types can easily be changed if better suggestions pop up</z><z id="t1656532278" t="valtteri I mean a working example in context of json schema"><y>#</y><d>2022-06-29</d><h>19:51</h><r>valtteri</r>I mean a working example in context of json schema</z><z id="t1656532370" t="valtteri It&apos;s easier to get that feedback when people can see it in action"><y>#</y><d>2022-06-29</d><h>19:52</h><r>valtteri</r>It&apos;s easier to get that feedback when people can see it in action</z><z id="t1656612838" t="valtteri Oh man, I just noticed that the old json-schema-&gt;malli PR is actually alive again!"><y>#</y><d>2022-06-30</d><h>18:13</h><r>valtteri</r>Oh man, I just noticed that the old json-schema-&gt;malli PR is actually alive again!</z><z id="t1656613106" t="valtteri I don’t understand how I had missed that. I’ll comment to the PR that we’re thinking about these same things here. Dunno if https://github.com/tangrammer is in this Slack?"><y>#</y><d>2022-06-30</d><h>18:18</h><r>valtteri</r>I don’t understand how I had missed that. I’ll comment to the PR that we’re thinking about these same things here. Dunno if <a href="https://github.com/tangrammer" target="_blank">https://github.com/tangrammer</a> is in this Slack?</z><z id="t1656376547" t="Derek Cross-posting from #announcements : Announcing org.passen/malapropism. A small library for configuration data backed by malli https://github.com/dpassen/malapropism"><y>#</y><d>2022-06-28</d><h>00:35</h><w>Derek</w>Cross-posting from #announcements :
Announcing org.passen/malapropism. A small library for configuration data backed by malli
<a href="https://github.com/dpassen/malapropism" target="_blank">https://github.com/dpassen/malapropism</a></z><z id="t1656385499" t="pinkfrog https://www.metosin.fi/blog/high-performance-schemas-in-clojurescript-with-malli-1-2/ Do we have a second series?"><y>#</y><d>2022-06-28</d><h>03:04</h><w>pinkfrog</w><a href="https://www.metosin.fi/blog/high-performance-schemas-in-clojurescript-with-malli-1-2/" target="_blank">https://www.metosin.fi/blog/high-performance-schemas-in-clojurescript-with-malli-1-2/</a> Do we have a second series?</z><z id="t1656391816" t="Alexander Moskvichev Is there an easy way to change default date format in malli.transofm? I&apos;ve read several discussions about custom registry, etc, but just started with malli, it&apos;s too hard for now to understand. I use malli with reitit, just need to change outgoing date format"><y>#</y><d>2022-06-28</d><h>04:50</h><w>Alexander Moskvichev</w>Is there an easy way to change default date format in malli.transofm? I&apos;ve read several discussions about custom registry, etc, but just started with malli, it&apos;s too hard for now to understand. I use malli with reitit, just need to change outgoing date format</z><z id="t1656438446" t="Setzer22 Does malli support custom function predicates? I noticed some functions seem to be supported but most of them give an &quot;invalid schema&quot; error and I don&apos;t know if there&apos;s another way of doing this"><y>#</y><d>2022-06-28</d><h>17:47</h><w>Setzer22</w>Does malli support custom function predicates? I noticed some functions seem to be supported but most of them give an &quot;invalid schema&quot; error and I don&apos;t know if there&apos;s another way of doing this</z><z id="t1656438539" t="Setzer22 actually, what I need is define a schema for a map that contains a core.async channel. I can always use :any but it would&apos;ve been nice to use something like #(instance? ManyToManyChannel %)"><y>#</y><d>2022-06-28</d><h>17:48</h><w>Setzer22</w>actually, what I need is define a schema for a map that contains a core.async channel. I can always use <code>:any</code> but it would&apos;ve been nice to use something like <code>#(instance? ManyToManyChannel %)</code></z><z id="t1656438863" t="Setzer22 Also, unrelated question 😄 I&apos;m pretty curious about this: https://github.com/metosin/malli/blob/master/docs/function-schemas.md#tldr In particular, in this snippet: (defn plus1 &quot;Adds one to the number&quot; {:malli/schema [:=&gt; [:cat :int] :int]} [x] (inc x)) What&apos;s this way of using metadata to define the schema of the function via defn ? Is this a defn -like macro defined somewhere?"><y>#</y><d>2022-06-28</d><h>17:54</h><w>Setzer22</w>Also, unrelated question <b>😄</b>  I&apos;m pretty curious about this: <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#tldr" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#tldr</a>

In particular, in this snippet:
<pre>(defn plus1
  &quot;Adds one to the number&quot;
  {:malli/schema [:=&gt; [:cat :int] :int]}
  [x] (inc x))</pre>
What&apos;s this way of using metadata to define the schema of the function via <code>defn</code>? Is this a <code>defn</code>-like macro defined somewhere?</z><z id="t1656439083" t="skynet [:attrs {:href &quot;/_/_/users/UP0Q30S10&quot;}] if I understand, it&apos;s the normal Clojure defn and that&apos;s the attr-map? argument which becomes metadata https://clojuredocs.org/clojure.core/defn"><y>#</y><d>2022-06-28</d><h>17:58</h><w>skynet</w><a>@jsanchezf</a> if I understand, it&apos;s the normal Clojure <code>defn</code> and that&apos;s the <code>attr-map?</code> argument which becomes metadata <a href="https://clojuredocs.org/clojure.core/defn" target="_blank">https://clojuredocs.org/clojure.core/defn</a></z><z id="t1656439143" t="Setzer22 [:attrs {:href &quot;/_/_/users/U0DSU64Q1&quot;}] But then, how does it work? Malli has no way of knowing when a function is redefined. Simply defining some metadata does not lead to instrumentation happening"><y>#</y><d>2022-06-28</d><h>17:59</h><w>Setzer22</w><a>@craigy</a> But then, how does it work? Malli has no way of knowing when a function is redefined. Simply defining some metadata does not lead to instrumentation happening</z><z id="t1656439242" t="dvingo (dev/start! {:report (pretty/reporter)}) check the source of that call for the answer 🙂"><y>#</y><d>2022-06-28</d><h>18:00</h><r>dvingo</r><pre>(dev/start! {:report (pretty/reporter)})</pre>
check the source of that call for the answer <b>🙂</b></z><z id="t1656439284" t="dvingo this section https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defining-function-schemas explains it"><y>#</y><d>2022-06-28</d><h>18:01</h><r>dvingo</r>this section <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defining-function-schemas" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#defining-function-schemas</a> explains it</z><z id="t1656439295" t="dvingo &gt; Without instrumentation turned on, there is no schema enforcement: "><y>#</y><d>2022-06-28</d><h>18:01</h><r>dvingo</r>&gt;  Without instrumentation turned on, there is no schema enforcement:
</z><z id="t1656439314" t="dvingo &gt; defn schemas can be defined with standard Var metadata. It allows defn schema documentation and instrumentation without dependencies to malli itself from the functions. It&apos;s just data. "><y>#</y><d>2022-06-28</d><h>18:01</h><r>dvingo</r>&gt; <code>defn</code> schemas can be defined with standard Var metadata. It allows <code>defn</code> schema documentation and instrumentation without dependencies to malli itself from the functions. It&apos;s just data.
</z><z id="t1656439475" t="Setzer22 I see, so looking at the source ( https://github.com/metosin/malli/blob/b745b73a93109a71643ce58302189a6f69c56d5e/src/malli/dev.clj#L15 ) it walks all the namespaces at the time where you call dev/start! , then looks for instrumented functions. But how will it know when I create a new function or define a new namespace? Do I need to call start! again for it to pick it up?"><y>#</y><d>2022-06-28</d><h>18:04</h><r>Setzer22</r>I see, so looking at the source (<a href="https://github.com/metosin/malli/blob/b745b73a93109a71643ce58302189a6f69c56d5e/src/malli/dev.clj#L15" target="_blank">https://github.com/metosin/malli/blob/b745b73a93109a71643ce58302189a6f69c56d5e/src/malli/dev.clj#L15</a>) it walks all the namespaces at the time where you call <code>dev/start!</code> , then looks for instrumented functions.

But how will it know when I create a new function or define a new namespace? Do I need to call <code>start!</code> again for it to pick it up?</z><z id="t1656487507" t="ikitommi yes, you need to call start! again when you annotate new functions. Tried to hook Var-watching for already defined schematized defns, but the Clojure core doesn’t support that easily. Calling start! makes the collecting explicit."><y>#</y><d>2022-06-29</d><h>07:25</h><r>ikitommi</r>yes, you need to call <code>start!</code> again when you annotate new functions. Tried to hook Var-watching for already defined schematized defns, but the Clojure core doesn’t support that easily. Calling <code>start!</code> makes the collecting explicit.</z><z id="t1656452534" t="ingesol I’m using malli to instrument functions and print results using the pretty printer. Some functions accept and return huge maps, so huge that it makes the output of the pretty printer unusable. Any hints on how to improve this?"><y>#</y><d>2022-06-28</d><h>21:42</h><w>ingesol</w>I’m using malli to instrument functions and print results using the pretty printer. Some functions accept and return huge maps, so huge that it makes the output of the pretty printer unusable. Any hints on how to improve this?</z><z id="t1656484037" t="eskos • https://github.com/greglook/puget can make pretty prints even more prettier; sometimes just adding color helps a lot • https://github.com/lambdaisland/deep-diff2 (or clojure.data/diff) can be used to diff the content; with a bit of trickery you can print only the interesting parts"><y>#</y><d>2022-06-29</d><h>06:27</h><r>eskos</r>• <a href="https://github.com/greglook/puget" target="_blank">https://github.com/greglook/puget</a> can make pretty prints even more prettier; sometimes just adding color helps a lot
• <a href="https://github.com/lambdaisland/deep-diff2" target="_blank">https://github.com/lambdaisland/deep-diff2</a> (or clojure.data/diff) can be used to diff the content; with a bit of trickery you can print only the interesting parts</z><z id="t1656487282" t="ikitommi [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] Puget in nice, but Malli uses a custom pretty printer directly on top of fipp - different opinions about colors &amp; works with CLJS too. About the huge maps, currently there is no omitting of valid values ( https://github.com/bhb/expound#show-valid-values ), would have needed that too, but have had no time to implement. PR would be welcome on this. Also, I think it’s the final piece before extracting the pretty printing from reitit &amp; malli into a clean and minimal lib ( https://github.com/metosin/virhe )."><y>#</y><d>2022-06-29</d><h>07:21</h><r>ikitommi</r><a>@U8SFC8HLP</a> Puget in nice, but Malli uses a custom pretty printer directly on top of fipp - different opinions about colors &amp; works with CLJS too. About the huge maps, currently there is no omitting of valid values (<a href="https://github.com/bhb/expound#show-valid-values" target="_blank">https://github.com/bhb/expound#show-valid-values</a>), would have needed that too, but have had no time to implement. PR would be welcome on this. Also, I think it’s the final piece before extracting the pretty printing from reitit &amp; malli into a clean and minimal lib (<a href="https://github.com/metosin/virhe" target="_blank">https://github.com/metosin/virhe</a>).</z><z id="t1656487531" t="ingesol I think showing valid values is useful to get the full picture. It also makes the report easier to parse sometimes. If there are 4 args to the fn, and 1 is wrong, it can be easier on the eyes to navigate to the wrong one when you use the valid ones as guides."><y>#</y><d>2022-06-29</d><h>07:25</h><r>ingesol</r>I think showing valid values is useful to get the full picture. It also makes the report easier to parse sometimes. If there are 4 args to the fn, and 1 is wrong, it can be easier on the eyes to navigate to the wrong one when you use the valid ones as guides.</z><z id="t1656487667" t="ikitommi ok, I’m all ears on how to make it better then."><y>#</y><d>2022-06-29</d><h>07:27</h><r>ikitommi</r>ok, I’m all ears on how to make it better then.</z><z id="t1656487675" t="ingesol In my case, I have a re-frame app-db. The number of keys in the map is not huge, but the number of nested keys is. So some way of sniffing out the approximate size of the map and deciding to print the first 500 chars or something would be nice. That was what I was looking for in my question. Would be nice if fipp had that option."><y>#</y><d>2022-06-29</d><h>07:27</h><r>ingesol</r>In my case, I have a re-frame app-db. The number of keys in the map is not huge, but the number of nested keys is. So some way of sniffing out the approximate size of the map and deciding to print the first 500 chars or something would be nice. That was what I was looking for in my question. Would be nice if fipp had that option.</z><z id="t1656487706" t="ingesol From reading the code, it looks like we just pass the map to fipp for printing?"><y>#</y><d>2022-06-29</d><h>07:28</h><r>ingesol</r>From reading the code, it looks like we just pass the map to fipp for printing?</z><z id="t1656487748" t="ikitommi https://github.com/metosin/malli/blob/master/src/malli/dev/virhe.cljc#L34"><y>#</y><d>2022-06-29</d><h>07:29</h><r>ikitommi</r><a href="https://github.com/metosin/malli/blob/master/src/malli/dev/virhe.cljc#L34" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/dev/virhe.cljc#L34</a></z><z id="t1656487778" t="ingesol group hug"><y>#</y><d>2022-06-29</d><h>07:29</h><r>ingesol</r>group hug</z><z id="t1656487813" t="ingesol but virhe isn’t currently used in malli, is it? I suppose maybe I can use it to implement an alternative to the default pretty printer?"><y>#</y><d>2022-06-29</d><h>07:30</h><r>ingesol</r>but virhe isn’t currently used in malli, is it? I suppose maybe I can use it to implement an alternative to the default pretty printer?</z><z id="t1656487838" t="ikitommi virhe is… inlined 🙂 (ns malli.dev.virhe &quot;initial code for &quot;"><y>#</y><d>2022-06-29</d><h>07:30</h><r>ikitommi</r>virhe is… inlined <b>🙂</b>
<pre>(ns malli.dev.virhe
  &quot;initial code for &quot;</pre></z><z id="t1656487859" t="ingesol so… what I’m asking for is already available?"><y>#</y><d>2022-06-29</d><h>07:30</h><r>ingesol</r>so… what I’m asking for is already available?</z><z id="t1656487867" t="ikitommi actual virhe-repo is just a README, “copy code here when it’s ok”"><y>#</y><d>2022-06-29</d><h>07:31</h><r>ikitommi</r>actual virhe-repo is just a README, “copy code here when it’s ok”</z><z id="t1656487867" t="ikitommi yes"><y>#</y><d>2022-06-29</d><h>07:31</h><r>ikitommi</r>yes</z><z id="t1656487896" t="ikitommi you can either swap the EDNPrinter or pass options to it to work differently"><y>#</y><d>2022-06-29</d><h>07:31</h><r>ikitommi</r>you can either swap the EDNPrinter or pass options to it to work differently</z><z id="t1656487902" t="ikitommi all code is in malli repo."><y>#</y><d>2022-06-29</d><h>07:31</h><r>ikitommi</r>all code is in malli repo.</z><z id="t1656488046" t="ingesol awesome, thanks! I just didn’t notice that part of the API. Will have a go at this 🙂"><y>#</y><d>2022-06-29</d><h>07:34</h><r>ingesol</r>awesome, thanks! I just didn’t notice that part of the API. Will have a go at this <b>🙂</b></z><z id="t1656494811" t="ingesol In case it’s useful for anyone, here’s the change I needed. I wanted to avoid printing the re-frame app-db. Both because the contents are usually not interesting, and because it’s way too large to be printed effectively. In the case of a value not matching the schema of our app db, it would usually be something that does not match the check here so it would be printed anyway. (extend-type v/EdnPrinter fv/IVisitor (visit-map [this x] (if (:some-key-always-in-our-db x) ;; Avoid printing app db to console, as it is way too large (v/-color :text &quot;{... app db ...}&quot; x) ;; Inlining original implementation from EdnPrinter (let [xs (sort-by identity (fn [a b] (arr/rank (first a) (first b))) x)] (fe/pretty-coll this (v/-color :text &quot;{&quot; this) xs [:span (v/-color :text &quot;,&quot; this) :line] (v/-color :text &quot;}&quot; this) (fn [printer [k v]] [:span (fv/visit printer k) &quot; &quot; (fv/visit printer v)]))))))"><y>#</y><d>2022-06-29</d><h>09:26</h><r>ingesol</r>In case it’s useful for anyone, here’s the change I needed. I wanted to avoid printing the re-frame app-db. Both because the contents are usually not interesting, and because it’s way too large to be printed effectively. In the case of a value not matching the schema of our app db, it would usually be something that does not match the check here so it would be printed anyway.
<pre>(extend-type v/EdnPrinter
  fv/IVisitor
  (visit-map [this x]
    (if (:some-key-always-in-our-db x)
      ;; Avoid printing app db to console, as it is way too large
      (v/-color :text &quot;{... app db ...}&quot; x)
      ;; Inlining original implementation from EdnPrinter
      (let [xs (sort-by identity (fn [a b] (arr/rank (first a) (first b))) x)]
        (fe/pretty-coll this (v/-color :text &quot;{&quot; this) xs [:span (v/-color :text &quot;,&quot; this) :line] (v/-color :text &quot;}&quot; this)
                        (fn [printer [k v]]
                          [:span (fv/visit printer k) &quot; &quot; (fv/visit printer v)]))))))</pre></z><z id="t1656454251" t="steveb8n maybe #portal?"><y>#</y><d>2022-06-28</d><h>22:10</h><w>steveb8n</w>maybe #portal?</z><z id="t1656600196" t="stathissideris hello, does anyone know what the :schema schema does?"><y>#</y><d>2022-06-30</d><h>14:43</h><w>stathissideris</w>hello, does anyone know what the <code>:schema</code> schema does?</z><z id="t1656602261" t="ikitommi it&apos;s an eager reference, works like indentity . You can for example escape a sequence schema with it: [:cat :int [:* [:schema [:cat :int]]]"><y>#</y><d>2022-06-30</d><h>15:17</h><r>ikitommi</r>it&apos;s an eager reference, works like <code>indentity</code>. You can for example escape a sequence schema with it: <code>[:cat :int [:* [:schema [:cat :int]]]</code></z><z id="t1656602310" t="stathissideris thank you! I thought you were on vacations 😉"><y>#</y><d>2022-06-30</d><h>15:18</h><r>stathissideris</r>thank you! I thought you were on vacations <b>😉</b></z><z id="t1656612372" t="borkdude A PR which bridges the gap between malli and #babashka! https://github.com/metosin/malli/pull/718"><y>#</y><d>2022-06-30</d><h>18:06</h><w>borkdude</w>A PR which bridges the gap between malli and #babashka!
<a href="https://github.com/metosin/malli/pull/718" target="_blank">https://github.com/metosin/malli/pull/718</a></z><z id="t1656668519" t="Eric Dvorsak Is there a Malli equivalent to clojure.spec/every? I&apos;m trying to write this spec in Malli https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39"><y>#</y><d>2022-07-01</d><h>09:41</h><w>Eric Dvorsak</w>Is there a Malli equivalent to clojure.spec/every? I&apos;m trying to write this spec in Malli <a href="https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39" target="_blank">https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39</a></z><z id="t1656669451" t="valtteri Hmmm I&apos;m not sure if that exists directly but I guess it can be implemented with :and ?"><y>#</y><d>2022-07-01</d><h>09:57</h><r>valtteri</r>Hmmm I&apos;m not sure if that exists directly but I guess it can be implemented with <code>:and</code> ?</z><z id="t1656678044" t="Eric Dvorsak yeah that&apos;s what I&apos;m trying but can&apos;t really figure out how to achieve the same thing. every allows to name and declare specs for different key/values in the map as tuples"><y>#</y><d>2022-07-01</d><h>12:20</h><r>Eric Dvorsak</r>yeah that&apos;s what I&apos;m trying but can&apos;t really figure out how to achieve the same thing.

every allows to name and declare specs for different key/values in the map as tuples</z><z id="t1656674169" t="borkdude"><y>#</y><d>2022-07-01</d><h>11:16</h><w>borkdude</w></z><z id="t1656906077" t="kokonut Does malli have anything equivalent to Union in Typed Racket? https://docs.racket-lang.org/ts-guide/beginning.html #lang typed/racket (define-type Tree (U leaf node)) (struct leaf ([val : Number])) (struct node ([left : Tree] [right : Tree])) It is the same concept with F#&apos;s discriminated union. I read malli documentation carefully but couldn&apos;t find."><y>#</y><d>2022-07-04</d><h>03:41</h><w>kokonut</w>Does malli have anything equivalent to <code>Union</code> in Typed Racket?
<a href="https://docs.racket-lang.org/ts-guide/beginning.html" target="_blank">https://docs.racket-lang.org/ts-guide/beginning.html</a>
<pre>#lang typed/racket
(define-type Tree (U leaf node))
(struct leaf ([val : Number]))
(struct node ([left : Tree] [right : Tree]))</pre>
It is the same concept with F#&apos;s discriminated union.
I read malli documentation carefully but couldn&apos;t find.</z><z id="t1656908945" t="Ben Sless Isn&apos;t this just or?"><y>#</y><d>2022-07-04</d><h>04:29</h><r>Ben Sless</r>Isn&apos;t this just or?</z><z id="t1656921631" t="hansbugge Or :multi which has support for discriminators via :dispatch https://github.com/metosin/malli#multi-schemas"><y>#</y><d>2022-07-04</d><h>08:00</h><r>hansbugge</r>Or <code>:multi</code> which has support for discriminators via <code>:dispatch</code>
<a href="https://github.com/metosin/malli#multi-schemas" target="_blank">https://github.com/metosin/malli#multi-schemas</a></z><z id="t1656924706" t="Ben Sless Is the racket Union discriminating?"><y>#</y><d>2022-07-04</d><h>08:51</h><r>Ben Sless</r>Is the racket Union discriminating?</z><z id="t1656929351" t="kokonut [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I believe you can say that."><y>#</y><d>2022-07-04</d><h>10:09</h><r>kokonut</r><a>@UK0810AQ2</a> I believe you can say that.</z><z id="t1656929711" t="Ben Sless multi can dispatch to the correct schema which would make it discriminating. If you don&apos;t have a way of doing that, you can use or or orn , which is a named union"><y>#</y><d>2022-07-04</d><h>10:15</h><r>Ben Sless</r><code>multi</code> can dispatch to the correct schema which would make it discriminating. If you don&apos;t have a way of doing that, you can use <code>or</code> or <code>orn</code>, which is a named union</z><z id="t1656927542" t="Eric Dvorsak I&apos;m still trying to spec clojure.core with malli https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39 I&apos;m trying to find a way to replace this every which specs a map as 3 different kinds of key/values. unfortunately Malli map-of takes only one kind of key I&apos;m wondering if there is a way to transform the values in the schema, so that it checks that it&apos;s a map then transforms in a repetitions of tuples. Is it possible with Malli? going through the docs I can&apos;t find any clear way"><y>#</y><d>2022-07-04</d><h>09:39</h><w>Eric Dvorsak</w>I&apos;m still trying to spec clojure.core with malli <a href="https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39" target="_blank">https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj#L39</a>
I&apos;m trying to find a way to replace this <code>every</code> which specs a map as 3 different kinds of key/values.
unfortunately Malli map-of takes only one kind of key
I&apos;m wondering if there is a way to transform the values in the schema, so that it checks that it&apos;s a map then transforms in a repetitions of tuples.
Is it possible with Malli? going through the docs I can&apos;t find any clear way</z><z id="t1656929002" t="Eric Dvorsak I think I found my solution in malli source https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/destructure.cljc#L19"><y>#</y><d>2022-07-04</d><h>10:03</h><r>Eric Dvorsak</r>I think I found my solution in malli source <a href="https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/destructure.cljc#L19" target="_blank">https://github.com/metosin/malli/blob/2398df55ee806e25592fabf4d0c642ee3a2b233f/src/malli/destructure.cljc#L19</a></z><z id="t1656929954" t="Eric Dvorsak Is it expected that the output of m/parse can be lossy? (defn -map-like? [x] (or (map? x) (and (seqable? x) (every? (fn [e] (and (vector? e) (= 2 (count e)))) x)))) (def MapLike (m/-collection-schema {:type &apos;MapLike, :empty {}, :pred -map-like?})) (m/parse [MapLike [:orn [:some-keyword [:tuple :keyword :any]] [:some-int [:tuple :int :any]]]] {:k1 1 :k2 2 3 4 5 :six}) {:some-keyword [:k2 2], :some-int [5 :six]} In this snippet above one can see that because the output of parse is a map, keys of the same tuple are overwritten"><y>#</y><d>2022-07-04</d><h>10:19</h><w>Eric Dvorsak</w>Is it expected that the output of <code>m/parse</code> can be lossy?

<pre>(defn -map-like? [x] (or (map? x) (and (seqable? x) (every? (fn [e] (and (vector? e) (= 2 (count e)))) x))))
(def MapLike (m/-collection-schema {:type &apos;MapLike, :empty {}, :pred -map-like?}))
(m/parse [MapLike [:orn
                                [:some-keyword [:tuple :keyword :any]]
                                [:some-int [:tuple :int :any]]]]
                                   {:k1 1
                                    :k2 2
                                    3 4
                                    5 :six})
{:some-keyword [:k2 2], :some-int [5 :six]}</pre>
In this snippet above one can see that because the output of parse is a map, keys of the same tuple are overwritten</z><z id="t1656980562" t="Stig Brautaset How to model a deck of cards? We use spec at work, but I wanted to try Malli for a personal toy project. I promptly ran into a problem I couldn&apos;t solve, and I&apos;ve tried to make a simplified version of it here. Imagine a simplified game of poker: a hand is 5 cards, and we only care about whether it is a flush (i.e. 5 cards of the same suit) or not."><y>#</y><d>2022-07-05</d><h>00:22</h><w>Stig Brautaset</w>How to model a deck of cards?
We use spec at work, but I wanted to try Malli for a personal toy project. I promptly ran into a problem I couldn&apos;t solve, and I&apos;ve tried to make a simplified version of it here.
Imagine a simplified game of poker: a hand is 5 cards, and we only care about whether it is a flush (i.e. 5 cards of the same suit) or not.</z><z id="t1656980587" t="Stig Brautaset First attempt As we don&apos;t really care about the numbers or faces we can model a card as simple enum of its suit, and a hand as a 5-tuple of cards. The deck is trickier. It has up to 52 cards, but I can&apos;t find a way to model the additional constraint that we should only have a maximum of 13 of each suit. Thus the last test in this self-contained example (usually) fails: (ns cards.simple-test (:require [clojure.test :refer [deftest is testing]] [malli.core :as m] [malli.generator :as mg])) (def Card [:enum :spades :hearts :clubs :diamonds]) (def Hand [:tuple Card Card Card Card Card]) (def Deck [:sequential {:max 52} Card]) (deftest deck (testing &quot;we can generate a Deck&quot; (doseq [deck (mg/sample Deck)] (testing &quot;that validates&quot; (is (true? (m/validate Deck deck)))) (testing &quot;where every element is a card&quot; (is (every? #(m/validate Card %) deck))) (testing &quot;of maximum 52 cards&quot; (is (&gt;= 52 (count deck)))) (testing &quot;where each suite occurs at most 13 times&quot; ;; this test (usually) fails, because we haven&apos;t restricted ;; the count of each suit to maximum 13. (is (&gt;= 13 (-&gt;&gt; deck frequencies vals (reduce max 0))))))))"><y>#</y><d>2022-07-05</d><h>00:23</h><r>Stig Brautaset</r>First attempt

As we don&apos;t really care about the numbers or faces we can model a card as simple enum of its suit, and a hand as a 5-tuple of cards.

The deck is trickier. It has up to 52 cards, but I can&apos;t find a way to model the additional constraint that we should only have a maximum of 13 of each suit. Thus the last test in this self-contained example (usually) fails:

<pre>(ns cards.simple-test
  (:require
   [clojure.test :refer [deftest is testing]]
   [malli.core :as m]
   [malli.generator :as mg]))

(def Card [:enum :spades :hearts :clubs :diamonds])
(def Hand [:tuple Card Card Card Card Card])
(def Deck [:sequential {:max 52} Card])

(deftest deck
  (testing &quot;we can generate a Deck&quot;
    (doseq [deck (mg/sample Deck)]
      (testing &quot;that validates&quot;
        (is (true? (m/validate Deck deck))))

      (testing &quot;where every element is a card&quot;
        (is (every? #(m/validate Card %) deck)))

      (testing &quot;of maximum 52 cards&quot;
        (is (&gt;= 52 (count deck))))

      (testing &quot;where each suite occurs at most 13 times&quot;
        ;; this test (usually) fails, because we haven&apos;t restricted
        ;; the count of each suit to maximum 13.
        (is (&gt;= 13 (-&gt;&gt; deck
            frequencies
            vals
            (reduce max 0))))))))</pre></z><z id="t1656980650" t="Stig Brautaset Second attempt Let&apos;s give each card a suit and number to address the problem with our previous deck. A hand is now slighly more complicated: we have to use a set with {:min 5 :max 5} properties instead of a 5-tuple to ensure cards are not duplicated. (A hand with 5 ace of spades should not be valid!) The deck, on the other hand, is simpler than before. By using a set we can drop the {:max 52} property. It is now implicit, because there are only 52 possible combinations of 4 suits and 13 numbers. Self-contained example: (ns cards.better-test (:require [clojure.test :refer [deftest is testing]] [malli.core :as m] [malli.generator :as mg])) (def Card [:tuple [:enum :spades :hearts :clubs :diamonds] [:int {:min 1 :max 13}]]) (def Hand [:set {:min 5 :max 5} Card]) (def Deck [:set Card]) (deftest deck (testing &quot;we can generate a Deck&quot; (doseq [deck (mg/sample Deck)] (testing &quot;that validates&quot; (is (true? (m/validate Deck deck)))) (testing &quot;where every element is a card&quot; (is (every? #(m/validate Card %) deck))) (testing &quot;of maximum 52 cards&quot; (is (&gt;= 52 (count deck)))) (testing &quot;where each suite occurs at most 13 times&quot; (is (&gt;= 13 (-&gt;&gt; deck (map first) frequencies vals (reduce max 0))))))))"><y>#</y><d>2022-07-05</d><h>00:24</h><r>Stig Brautaset</r>Second attempt

Let&apos;s give each card a suit and number to address the problem with our previous deck.

A hand is now slighly more complicated: we have to use a set with <code>{:min 5 :max 5}</code> properties instead of a 5-tuple to ensure cards are not duplicated. (A hand with 5 ace of spades should not be valid!)

The deck, on the other hand, is simpler than before. By using a set we can drop the <code>{:max 52}</code> property. It is now implicit, because there are only 52 possible combinations of 4 suits and 13 numbers.

Self-contained example:

<pre>(ns cards.better-test
  (:require
   [clojure.test :refer [deftest is testing]]
   [malli.core :as m]
   [malli.generator :as mg]))

(def Card [:tuple
	   [:enum :spades :hearts :clubs :diamonds]
	   [:int {:min 1 :max 13}]])
(def Hand [:set {:min 5 :max 5} Card])
(def Deck [:set Card])

(deftest deck
  (testing &quot;we can generate a Deck&quot;
    (doseq [deck (mg/sample Deck)]
      (testing &quot;that validates&quot;
        (is (true? (m/validate Deck deck))))

      (testing &quot;where every element is a card&quot;
        (is (every? #(m/validate Card %) deck)))

      (testing &quot;of maximum 52 cards&quot;
        (is (&gt;= 52 (count deck))))

      (testing &quot;where each suite occurs at most 13 times&quot;
        (is (&gt;= 13 (-&gt;&gt; deck
            (map first)
            frequencies
            vals
            (reduce max 0))))))))</pre></z><z id="t1656980708" t="Stig Brautaset This solves the problem with my first attempt, but introduces another: we can neither sort nor properly shuffle our deck now. 😞"><y>#</y><d>2022-07-05</d><h>00:25</h><r>Stig Brautaset</r>This solves the problem with my first attempt, but introduces another: we can neither sort nor properly shuffle our deck now. <b>😞</b></z><z id="t1656981290" t="Stig Brautaset I think what I want is an ordered sequence of distinct values, but that may be because I can&apos;t see outside my Specs-shaped box. Is there an alternative way to model this with Malli? (def Deck [:sequential {:distinct true} Card]) "><y>#</y><d>2022-07-05</d><h>00:34</h><r>Stig Brautaset</r>I think what I want is an ordered sequence of distinct values, but that may be because I can&apos;t see outside my Specs-shaped box. Is there an alternative way to model this with Malli?

<pre>(def Deck [:sequential {:distinct true} Card])</pre>
</z><z id="t1657038362" t="roklenarcic Define card as tuple of suit and number up to 13. A deck is a distinct sequence of cards. Unshuffled deck is a sorted deck"><y>#</y><d>2022-07-05</d><h>16:26</h><r>roklenarcic</r>Define card as tuple of suit and number up to 13. A deck is a distinct sequence of cards. Unshuffled deck is a sorted deck</z><z id="t1657039037" t="Stig Brautaset That sounds like my second attempt: (def Card [:tuple [:enum :spades :hearts :clubs :diamonds] [:int {:min 1 :max 13}]]) (def Hand [:set {:min 5 :max 5} Card]) (def Deck [:set Card])"><y>#</y><d>2022-07-05</d><h>16:37</h><r>Stig Brautaset</r>That sounds like my second attempt:
<pre>(def Card [:tuple
	   [:enum :spades :hearts :clubs :diamonds]
	   [:int {:min 1 :max 13}]])
(def Hand [:set {:min 5 :max 5} Card])
(def Deck [:set Card])</pre></z><z id="t1657039133" t="Stig Brautaset How can I specify a distinct sequence? It seems you have to go to a set, as there’s no (documented) {:distinct true} property I can add."><y>#</y><d>2022-07-05</d><h>16:38</h><r>Stig Brautaset</r>How can I specify a distinct sequence? It seems you have to go to a set, as there’s no (documented) <code>{:distinct true}</code> property I can add.</z><z id="t1657047447" t="Stig Brautaset Ah, I think I see. I just discovered :fn 😄"><y>#</y><d>2022-07-05</d><h>18:57</h><r>Stig Brautaset</r>Ah, I think I see. I just discovered <code>:fn</code> <b>😄</b></z><z id="t1657047665" t="Stig Brautaset This appears to do what I want: (def Card [:tuple [:enum :spades :hearts :clubs :diamonds] [:int {:min 1 :max 13}]]) (def Hand [:and [:sequential {:min 5 :max 5} Card] [:fn (fn [hand] (apply distinct? hand))]]) (def Deck [:and [:sequential Card] [:fn (fn [deck] (apply distinct? deck))]])"><y>#</y><d>2022-07-05</d><h>19:01</h><r>Stig Brautaset</r>This appears to do what I want:

<pre>(def Card [:tuple
	   [:enum :spades :hearts :clubs :diamonds]
	   [:int {:min 1 :max 13}]])

(def Hand [:and
           [:sequential {:min 5 :max 5} Card]
           [:fn (fn [hand] (apply distinct? hand))]])

(def Deck [:and
           [:sequential Card]
           [:fn (fn [deck] (apply distinct? deck))]])</pre></z><z id="t1657047934" t="Stig Brautaset That can be made to work with my simplified version too: (def Card [:enum :spades :hearts :clubs :diamonds]) (def Hand [:sequential {:min 5 :max 5} Card]) (def Deck [:and [:sequential Card] [:fn #(-&gt;&gt; % frequencies vals (reduce max 0) (&gt;= 13))]]) Thank you for the help 🙂"><y>#</y><d>2022-07-05</d><h>19:05</h><r>Stig Brautaset</r>That can be made to work with my simplified version too:

<pre>(def Card [:enum :spades :hearts :clubs :diamonds])
(def Hand [:sequential {:min 5 :max 5} Card])
(def Deck [:and 
           [:sequential Card]
           [:fn #(-&gt;&gt; % frequencies vals (reduce max 0) (&gt;= 13))]])</pre>
Thank you for the help <b>🙂</b></z><z id="t1657047960" t="Stig Brautaset duckie strikes again 🙂"><y>#</y><d>2022-07-05</d><h>19:06</h><r>Stig Brautaset</r><b>duckie</b>  strikes again <b>🙂</b></z><z id="t1656986393" t="dumrat http://malli.io not working?"><y>#</y><d>2022-07-05</d><h>01:59</h><w>dumrat</w><a href="http://malli.io" target="_blank">http://malli.io</a> not working?</z><z id="t1657216702" t="valtteri Works for me :thinking_face:"><y>#</y><d>2022-07-07</d><h>17:58</h><r>valtteri</r>Works for me <b>:thinking_face:</b></z><z id="t1657125550" t="raymcdermott does anyone have experience / examples of using malli to generate openAPI docs that https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-from-example.html ?"><y>#</y><d>2022-07-06</d><h>16:39</h><w>raymcdermott</w>does anyone have experience / examples of using malli to generate openAPI docs that <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-from-example.html" target="_blank">https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-from-example.html</a>?</z><z id="t1657215979" t="valtteri Is there something special with ApiGW or should normal swagger 2.x work? There is malli.swagger namespace.."><y>#</y><d>2022-07-07</d><h>17:46</h><r>valtteri</r>Is there something special with ApiGW or should normal swagger 2.x work? There is <code>malli.swagger</code> namespace..</z><z id="t1657216015" t="valtteri OpenApi 3.x has been requested and it’s somewhere on the backlog but not under active development atm."><y>#</y><d>2022-07-07</d><h>17:46</h><r>valtteri</r>OpenApi 3.x has been requested and it’s somewhere on the backlog but not under active development atm.</z><z id="t1657217243" t="raymcdermott I was thinking that the swagger ns would probably be OK but would be nice if somebody has already trodden the path. That&apos;s all really."><y>#</y><d>2022-07-07</d><h>18:07</h><r>raymcdermott</r>I was thinking that the swagger ns would probably be OK but would be nice if somebody has already trodden the path. That&apos;s all really.</z><z id="t1657218104" t="valtteri Please let me know how it turns out. 🙂"><y>#</y><d>2022-07-07</d><h>18:21</h><r>valtteri</r>Please let me know how it turns out. <b>🙂</b></z><z id="t1657214727" t="bortexz Hi, does malli support specifying the relationship between arguments and return on function schemas, similar to spec’s fdef :fn ? Couldn’t find anything related when going over the Readme"><y>#</y><d>2022-07-07</d><h>17:25</h><w>bortexz</w>Hi, does malli support specifying the relationship between arguments and return on function schemas, similar to spec’s fdef <code>:fn</code> ? Couldn’t find anything related when going over the Readme</z><z id="t1657216671" t="valtteri Hmmm I guess we don’t have that. :thinking_face: Feel free to file an issue on github. Also contributions are welcome!"><y>#</y><d>2022-07-07</d><h>17:57</h><r>valtteri</r>Hmmm I guess we don’t have that. <b>:thinking_face:</b> Feel free to file an issue on github. Also contributions are welcome!</z><z id="t1657274196" t="bortexz Found an existing one, will keep an eye on it 🙂 https://github.com/metosin/malli/issues/608"><y>#</y><d>2022-07-08</d><h>09:56</h><r>bortexz</r>Found an existing one, will keep an eye on it <b>🙂</b> <a href="https://github.com/metosin/malli/issues/608" target="_blank">https://github.com/metosin/malli/issues/608</a></z><z id="t1657410350" t="Panel Would anyone has anything to share regarding generating Web Form from Malli ? I have seen multiple conversations, blog post and even conf talk but none of those have code. Thanks"><y>#</y><d>2022-07-09</d><h>23:45</h><w>Panel</w>Would anyone has anything to share regarding generating Web Form from Malli ?
I have seen multiple conversations, blog post and even conf talk but none of those have code. Thanks</z><z id="t1657439573" t="eskos I suppose it would require a bit indirect and more involved route to approach, since having somesuch library would need to make assumptions about nesting, specific form events, usability issues (think tab navigation, grouping, aria tags...). So maybe the reason is that no one&apos;s just yet done a good enough system they&apos;re comfortable with abstracting to a library 🙂"><y>#</y><d>2022-07-10</d><h>07:52</h><r>eskos</r>I suppose it would require a bit indirect and more involved route to approach, since having somesuch library would need to make assumptions about nesting, specific form events, usability issues (think tab navigation, grouping, aria tags...). So maybe the reason is that no one&apos;s just yet done a good enough system they&apos;re comfortable with abstracting to a library <b>🙂</b></z><z id="t1657440534" t="valtteri This is something we&apos;re doing ad-hoc in different projects. We&apos;ve discussed about wrapping the best practices into a lib and open sourcing it. But I&apos;d say the status is still “cooking”"><y>#</y><d>2022-07-10</d><h>08:08</h><r>valtteri</r>This is something we&apos;re doing ad-hoc in different projects. We&apos;ve discussed about wrapping the best practices into a lib and open sourcing it. But I&apos;d say the status is still “cooking”</z><z id="t1657442743" t="Panel Sounds like the interceptor pattern, everyone using it code a new implementation to fit their needs. [:attrs {:href &quot;/_/_/users/U6N4HSMFW&quot;}] can you share describe how you do it ? Do you walk the schema and generate hiccup ? Do you have 2 data structures, one for the validation and one to describe UI specifics ? One option I played with is to use a JS lib that accept json-schema, that did not work out for you ?"><y>#</y><d>2022-07-10</d><h>08:45</h><r>Panel</r>Sounds like the interceptor pattern, everyone using it code a new implementation to fit their needs.
<a>@U6N4HSMFW</a> can you share describe how you do it ? Do you walk the schema and generate hiccup ? Do you have 2 data structures, one for the validation and one to describe UI specifics ?
One option I played with is to use a JS lib that accept json-schema, that did not work out for you ?</z><z id="t1657449003" t="valtteri JSON-schema is fine for simple cases and if that works for you then that’s a perfectly valid way to go in my opinion."><y>#</y><d>2022-07-10</d><h>10:30</h><r>valtteri</r>JSON-schema is fine for simple cases and if that works for you then that’s a perfectly valid way to go in my opinion.</z><z id="t1657449076" t="valtteri We’ve tried it both ways you described. Just a couple of months ago a colleague demoed “walking malli schema and generating hiccup” approach."><y>#</y><d>2022-07-10</d><h>10:31</h><r>valtteri</r>We’ve tried it both ways you described. Just a couple of months ago a colleague demoed “walking malli schema and generating hiccup” approach.</z><z id="t1657449105" t="valtteri I think the “generate ui from schema” approach pays off if you have really complex forms and a lot of them"><y>#</y><d>2022-07-10</d><h>10:31</h><r>valtteri</r>I think the “generate ui from schema” approach pays off if you have really complex forms and a lot of them</z><z id="t1657449130" t="valtteri Or when you need to dynamically generate the forms"><y>#</y><d>2022-07-10</d><h>10:32</h><r>valtteri</r>Or when you need to dynamically generate the forms</z><z id="t1657449198" t="valtteri I think you could also get quite far with something like Formik + malli validation"><y>#</y><d>2022-07-10</d><h>10:33</h><r>valtteri</r>I think you could also get quite far with something like Formik + malli validation</z><z id="t1658016532" t="geraldodev [:attrs {:href &quot;/_/_/users/U6N4HSMFW&quot;}] the malli piece is set on stone for me, as for the react library, could you please elaborate why that were choosen ? Was it the better at the time, has it a feature that more inline with the approach that you are using. I&apos;ve started to look into react-hook-form https://github.com/geraldodev/react-form-hook-test/blob/use-form-state/src/main/app/core.cljs#L45 but I&apos;ve stopped. Going back to it soon. Today my colleague pointed me to https://github.com/tannerlinsley/react-form , In the last two weeks I&apos;m learning that code from tanner have high quality, I briefly looked today one example. It looked that it gets too deep into validation. It would be nice a library that interact with DOM (react) just enough and gives as the hooks (not react) points to bring malli awesomeness to our beloved clojure data strutures. I&apos;m following this rabbit hole. Are you too ?"><y>#</y><d>2022-07-17</d><h>00:08</h><r>geraldodev</r><a>@U6N4HSMFW</a> the malli piece is set on stone for me, as for the react library, could you please elaborate why that were choosen ? Was it the better at the time, has it a feature that more inline with the approach that you are using. I&apos;ve started to look into  react-hook-form <a href="https://github.com/geraldodev/react-form-hook-test/blob/use-form-state/src/main/app/core.cljs#L45" target="_blank">https://github.com/geraldodev/react-form-hook-test/blob/use-form-state/src/main/app/core.cljs#L45</a> but I&apos;ve stopped. Going back to it soon. Today my colleague pointed me to <a href="https://github.com/tannerlinsley/react-form" target="_blank">https://github.com/tannerlinsley/react-form</a> , In the last two weeks I&apos;m learning that code from tanner have high quality, I briefly looked today one example. It looked that it gets too deep into validation. It would be nice a library that interact with DOM (react) just enough and gives as  the hooks (not react) points to bring malli awesomeness to our beloved clojure data strutures. I&apos;m following this rabbit hole. Are you too ?</z><z id="t1657534950" t="Stig Brautaset Say I want a schema for an integer in the range 1-10 (inclusive). Is there a practical difference between these two? If so, which one is recommended? repl&gt; (mg/sample [:int {:min 1 :max 10}]) (2 1 3 1 7 4 7 4 10 3) repl&gt; (mg/sample [:and :int [:&gt;= 1] [:&lt;= 10]]) (1 1 1 2 5 1 9 6 6 2) The former is shorter, and it&apos;s more intuitive to me to start with :int when that&apos;s the base type. But I don&apos;t know if there&apos;s a benefit to using :&gt;= and :&lt;= to enforce the bounds instead."><y>#</y><d>2022-07-11</d><h>10:22</h><w>Stig Brautaset</w>Say I want a schema for an integer in the range 1-10 (inclusive). Is there a practical difference between these two? If so, which one is recommended?

<pre>repl&gt; (mg/sample [:int {:min 1 :max 10}])
(2 1 3 1 7 4 7 4 10 3)

repl&gt; (mg/sample [:and :int [:&gt;= 1] [:&lt;= 10]])
(1 1 1 2 5 1 9 6 6 2)</pre>
The former is shorter, and it&apos;s more intuitive to me to start with <code>:int</code> when that&apos;s the base type. But I don&apos;t know if there&apos;s a benefit to using <code>:&gt;=</code> and <code>:&lt;=</code> to enforce the bounds instead.</z><z id="t1657539637" t="valtteri I would use the one that reads better: :min :max"><y>#</y><d>2022-07-11</d><h>11:40</h><r>valtteri</r>I would use the one that reads better: <code>:min :max</code></z><z id="t1657539834" t="valtteri At least I&apos;m not aware of any extra benefits. :&gt;= and :&lt;= compile a bit differently compared to :min :max https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2281-L2290 vs. https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L589-L598 and if I had to guess, I&apos;d say the :min :max might be a little bit faster. But this is handwaving. 😉 And the difference is probably very small."><y>#</y><d>2022-07-11</d><h>11:43</h><r>valtteri</r>At least I&apos;m not aware of any extra benefits. <code>:&gt;=</code>  and <code>:&lt;=</code>  compile a bit differently compared to <code>:min :max</code>

<a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2281-L2290" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2281-L2290</a>
vs.
<a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L589-L598" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L589-L598</a>

and if I had to guess, I&apos;d say the <code>:min :max</code>  might be a little bit faster. But this is handwaving. <b>😉</b> And the difference is probably very small.</z><z id="t1657542096" t="Stig Brautaset Thank you!"><y>#</y><d>2022-07-11</d><h>12:21</h><r>Stig Brautaset</r>Thank you!</z><z id="t1657722978" t="George Peristerakis I have a registry with large data objects specs. I created a list of base specs to have a more consistent taxonomy ex: :pk-int [int? {:min 1 :unique true}] . What is the best way to represent these base specs? Should I have a separate registry or keep them in the same registry?"><y>#</y><d>2022-07-13</d><h>14:36</h><w>George Peristerakis</w>I have a registry with large data objects specs. I created a list of base specs to have a more consistent taxonomy ex: <code>:pk-int [int? {:min 1 :unique true}]</code> . What is the best way to represent these base specs? Should I have a separate registry or keep them in the same registry?</z><z id="t1657729387" t="DrLjótsson Newbie question: How do I specify that a value should be of a specific class, for example java.time.ZonedDateTime"><y>#</y><d>2022-07-13</d><h>16:23</h><w>DrLjótsson</w>Newbie question: How do I specify that a value should be of a specific class, for example java.time.ZonedDateTime</z><z id="t1657731089" t="respatialized [:fn #(instance? % java.time.ZonedDateTime)]"><y>#</y><d>2022-07-13</d><h>16:51</h><r>respatialized</r><code>[:fn #(instance? % java.time.ZonedDateTime)]</code></z><z id="t1657731143" t="respatialized Not sure if there&apos;s another &quot;official&quot; way but I&apos;ve done it that way in the past"><y>#</y><d>2022-07-13</d><h>16:52</h><r>respatialized</r>Not sure if there&apos;s another &quot;official&quot; way but I&apos;ve done it that way in the past</z><z id="t1657731487" t="DrLjótsson Thanks! I thought there might be a more official way but this will do just fine. "><y>#</y><d>2022-07-13</d><h>16:58</h><r>DrLjótsson</r>Thanks! I thought there might be a more official way but this will do just fine. </z><z id="t1657740760" t="Tiago Dall&apos;Oca Hey, more of a implementation question: why schemas instances are implemented with reify instead of using records? When I tried extending IPrintWithWriter to malli.core.Schema it didn&apos;t work because the type generated for schemas with reify isn&apos;t malli.core.Schemas"><y>#</y><d>2022-07-13</d><h>19:32</h><w>Tiago Dall'Oca</w>Hey, more of a implementation question: why schemas instances are implemented with reify instead of using records? When I tried extending <code>IPrintWithWriter</code> to <code>malli.core.Schema</code> it didn&apos;t work because the type generated for schemas with reify isn&apos;t <code>malli.core.Schemas</code></z><z id="t1657774760" t="Loic I have a question regarding key-transform and :map-of : I have map keys that are list and I want to turn that list into vector of vector. But I struggle to make a basic transformation work such as just turning keys into string in case of use of :map-of ;;work (m/decode [:map [:smth :int]] {:a 2} (mt/key-transformer {:decode name})) =&gt; {&quot;a&quot; 2} ;; does not work (m/decode [:map-of any? int?] {:a 2} (mt/key-transformer {:decode name})) =&gt; {:a 2}"><y>#</y><d>2022-07-14</d><h>04:59</h><w>Loic</w>I have a question regarding <code>key-transform</code> and <code>:map-of</code> :
I have map keys that are list and I want to turn that list into vector of vector.

But I struggle to make a basic transformation work such as just turning keys into string in case of use of <code>:map-of</code>
<pre>;;work

(m/decode
 [:map [:smth :int]]
 {:a 2}
 (mt/key-transformer {:decode name}))
=&gt; {&quot;a&quot; 2}

;; does not work
(m/decode
 [:map-of any? int?]
 {:a 2}
 (mt/key-transformer {:decode name}))
=&gt; {:a 2}</pre></z><z id="t1657883054" t="Ferdinand Beyer Is there a built-in way in Malli to strip away map keys that are not in the schema? Let’s say I have an open map schema like this: [:map [:person/first-name string?] [:person/last-name string?]] And a compliant value with an extra key: {:person/first-name &quot;Cosmo&quot; :person/last-name &quot;Kramer&quot; :person/likes #{:fruit}} I’d like to “sanitise” this data and only keep specified keys, recursively."><y>#</y><d>2022-07-15</d><h>11:04</h><w>Ferdinand Beyer</w>Is there a built-in way in Malli to strip away map keys that are not in the schema?

Let’s say I have an open map schema like this:

<pre>[:map [:person/first-name string?]
      [:person/last-name string?]]</pre>
And a compliant value with an extra key:

<pre>{:person/first-name &quot;Cosmo&quot;
 :person/last-name &quot;Kramer&quot;
 :person/likes #{:fruit}}</pre>
I’d like to “sanitise” this data and only keep specified keys, recursively.</z><z id="t1657883293" t="Ferdinand Beyer Thanks for acting as a sound stage. I found a simple way that can easily extended for recursive application: (require &apos;[malli.util :as mu]) (select-keys data (mu/keys schema)) "><y>#</y><d>2022-07-15</d><h>11:08</h><r>Ferdinand Beyer</r>Thanks for acting as a sound stage. I found a simple way that can easily extended for recursive application:

<pre>(require &apos;[malli.util :as mu])

(select-keys data (mu/keys schema))</pre>
</z><z id="t1657883803" t="valtteri There&apos;s a built-in strip-extra-keys-transformer for value transformation https://github.com/metosin/malli#value-transformation"><y>#</y><d>2022-07-15</d><h>11:16</h><r>valtteri</r>There&apos;s a built-in <code>strip-extra-keys-transformer</code> for value transformation <a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a></z><z id="t1657883945" t="Ferdinand Beyer Amazing, thanks! Missed that one 😊"><y>#</y><d>2022-07-15</d><h>11:19</h><r>Ferdinand Beyer</r>Amazing, thanks! Missed that one <b>😊</b></z><z id="t1657883962" t="valtteri No problem 🙂"><y>#</y><d>2022-07-15</d><h>11:19</h><r>valtteri</r>No problem <b>🙂</b></z><z id="t1658236529" t="AJ Jaro We recently updated a functions schema definition and it wasn’t written correctly, but not caught during the tests. Is there a way that Malli can be configured to validate arguments during Clojure tests? It was caught during “manual” testing but not during the automated tests"><y>#</y><d>2022-07-19</d><h>13:15</h><w>AJ Jaro</w>We recently updated a functions schema definition and it wasn’t written correctly, but not caught during the tests. Is there a way that Malli can be configured to validate arguments during Clojure tests? It was caught during “manual” testing but not during the automated tests</z><z id="t1658256761" t="respatialized In your test namespace: (require &apos;[malli.instrument :as mi] [clojure.test :as t]) (defn instrument-fixture [f] (mi/collect!) (mi/instrument!) (f) (mi/uninstrument!) ) (t/use-fixtures :once instrument-fixture)"><y>#</y><d>2022-07-19</d><h>18:52</h><r>respatialized</r>In your test namespace:

<pre>(require &apos;[malli.instrument :as mi]
[clojure.test :as t])

(defn instrument-fixture [f]
(mi/collect!)
(mi/instrument!)
(f)
(mi/uninstrument!)
)

(t/use-fixtures :once instrument-fixture)</pre></z><z id="t1658607205" t="hanDerPeder This works (def ok-schema {:thing/create [:map [:status [:string {:default &quot;a&quot;}]]]}) I want to extract the status part into a reusable schema, so I do (def bad-schema {:thing/status :string :thing/create [:map [:status [:thing/status {:default &quot;a&quot;}]]]}) This is not valid. Throws an exception: No implementation of method: :-into-schema of protocol: #&apos;malli.core/IntoSchema found for class: clojure.lang.Keyword Hopefully it’s clear what I’m trying to do. Is this a bug or am I going about this the wrong way?"><y>#</y><d>2022-07-23</d><h>20:13</h><w>hanDerPeder</w>This works
<pre>(def ok-schema
  {:thing/create [:map
                  [:status [:string {:default &quot;a&quot;}]]]})</pre>
I want to extract the <code>status</code> part into a reusable schema, so I do

<pre>(def bad-schema
  {:thing/status :string
   :thing/create [:map
                  [:status [:thing/status {:default &quot;a&quot;}]]]})</pre>
This is not valid. Throws an exception:
<pre>No implementation of method: :-into-schema of protocol:
   #&apos;malli.core/IntoSchema found for class: clojure.lang.Keyword</pre>
Hopefully it’s clear what I’m trying to do. Is this a bug or am I going about this the wrong way?</z><z id="t1658674538" t="pppaul [:string}"><y>#</y><d>2022-07-24</d><h>14:55</h><r>pppaul</r>[:string}</z><z id="t1658782663" t="hanDerPeder https://github.com/metosin/malli/pull/729"><y>#</y><d>2022-07-25</d><h>20:57</h><r>hanDerPeder</r><a href="https://github.com/metosin/malli/pull/729" target="_blank">https://github.com/metosin/malli/pull/729</a></z><z id="t1658674737" t="pppaul i&apos;m trying to edit malli.core, i can&apos;t figure out how to step through (get into a working cider debugging state) -map-schema. i tried pulling out the validctor method into it&apos;s own fn and setting that to cider-debug-defun-at-point but without success. any tips?"><y>#</y><d>2022-07-24</d><h>14:58</h><w>pppaul</w>i&apos;m trying to edit malli.core, i can&apos;t figure out how to step through (get into a working cider debugging state) -map-schema. i tried pulling out the validctor method into it&apos;s own fn and setting that to <code>cider-debug-defun-at-point</code> but without success. any tips?</z><z id="t1658674871" t="pppaul (m/schema [:map {:closed true} [:optional {:optional true} [:enum :a :b]] [:specified :int]]) code i&apos;m using to try to trigger -map-schema"><y>#</y><d>2022-07-24</d><h>15:01</h><w>pppaul</w><pre>(m/schema
    [:map {:closed true}
     [:optional {:optional true} [:enum :a :b]]
     [:specified :int]])</pre>
code i&apos;m using to try to trigger -map-schema</z><z id="t1658678898" t="pppaul I&apos;ve also tried this, and i get a stack overflow error. i&apos;m not really sure how to approach developing for malli. (m/validate (m/schema [:schema {:registry {:map (-map-schema)}} [:map {:closed true} [:optional {:optional true} [:enum :a :b]] [:specified :int]] ]) { ;;:hi &quot;valid&quot; :specified 1 ;;&quot;bad&quot; :error } )"><y>#</y><d>2022-07-24</d><h>16:08</h><w>pppaul</w>I&apos;ve also tried this, and i get a stack overflow error. i&apos;m not really sure how to approach developing for malli.
<pre>(m/validate
  (m/schema
    [:schema {:registry {:map (-map-schema)}}
     [:map {:closed true}
      [:optional {:optional true} [:enum :a :b]]
      [:specified :int]]
     ])
  {
   ;;:hi        &quot;valid&quot;
   :specified 1
   ;;&quot;bad&quot; :error
   }
  )</pre></z><z id="t1658678966" t="pppaul this is where i have imported -map-schema into my ns and can eval it... i did this because of the stack overflows i&apos;m getting when debugging. however, when i don&apos;t go into debug mode i don&apos;t get problems, when i&apos;m in debug mode i get stack overflows pretty wild"><y>#</y><d>2022-07-24</d><h>16:09</h><w>pppaul</w>this is where i have imported -map-schema into my ns and can eval it... i did this because of the stack overflows i&apos;m getting when debugging. however, when i don&apos;t go into debug mode i don&apos;t get problems, when i&apos;m in debug mode i get stack overflows
pretty wild</z><z id="t1658818416" t="Yehonathan Sharvit I am surprised by how JSON transformer works (m/decode :int &quot;123&quot; malli.transform/json-transformer) ;; =&gt; &quot;123&quot; Why isn’t the string &quot;123&quot; converted to an integer? In the same way, (m/decode [:map [:foo :int]] {:foo &quot;123&quot;} malli.transform/json-transformer) ;; =&gt; {:foo &quot;123&quot;}"><y>#</y><d>2022-07-26</d><h>06:53</h><w>Yehonathan Sharvit</w>I am surprised by how JSON transformer works
<pre>(m/decode :int &quot;123&quot; malli.transform/json-transformer) ;; =&gt; &quot;123&quot;</pre>
Why isn’t the string <code>&quot;123&quot;</code> converted to an integer?
In the same way,
<pre>(m/decode [:map [:foo :int]] {:foo &quot;123&quot;} malli.transform/json-transformer) ;; =&gt; {:foo &quot;123&quot;}</pre></z><z id="t1658823808" t="vemv malli.transform/-json-decoders doesn&apos;t have a string-&gt;double thingy maybe you want to be looking at malli.transform/string-transformer instead?"><y>#</y><d>2022-07-26</d><h>08:23</h><r>vemv</r><code>malli.transform/-json-decoders</code> doesn&apos;t have a <code>string-&gt;double</code> thingy

maybe you want to be looking at <code>malli.transform/string-transformer</code> instead?</z><z id="t1658827441" t="Yehonathan Sharvit The distinction between json-decoders and string-decoders is not 100% clear to me"><y>#</y><d>2022-07-26</d><h>09:24</h><r>Yehonathan Sharvit</r>The distinction between json-decoders and string-decoders is not 100% clear to me</z><z id="t1658827789" t="vemv My impression is that string-transformer is for parsing string-based values, and json-transformer for enriching values from already-parsed json with JVM/clj types (uuid, date, keyword etc) not present in json So it might make sense to compose string-transformer with json-transformer"><y>#</y><d>2022-07-26</d><h>09:29</h><r>vemv</r>My impression is that string-transformer is for parsing string-based values, and json-transformer for enriching values from already-parsed json with JVM/clj types (uuid, date, keyword etc) not present in json

So it might make sense to compose string-transformer with json-transformer</z><z id="t1658832129" t="Yehonathan Sharvit It makes sense to me also"><y>#</y><d>2022-07-26</d><h>10:42</h><r>Yehonathan Sharvit</r>It makes sense to me also</z><z id="t1658832942" t="Yehonathan Sharvit [:attrs {:href &quot;/_/_/users/U45T93RA6&quot;}] Is there a transformer that keywordize map keys when the schema keys are keywords?"><y>#</y><d>2022-07-26</d><h>10:55</h><r>Yehonathan Sharvit</r><a>@U45T93RA6</a> Is there a transformer that keywordize map keys when the schema keys are keywords?</z><z id="t1658833128" t="vemv let&apos;s move it 1:1"><y>#</y><d>2022-07-26</d><h>10:58</h><r>vemv</r>let&apos;s move it 1:1</z><z id="t1658843655" t="pppaul I have a list of keyseqs [[:parent :child1 :child2]...] that map in a human readable way into my schema, but when i do mu/get-in mu/update-in the mappings don&apos;t work. when i do subschemas the paths are sorta like [:parent 0 0 :child1 0 0 :child2] and :parent will have 10 different paths to the same :child1 and :child2. it seems a bit like a flip of a coin if i get the correct path or not. i&apos;ve tried a few different ways of figuring out the correct one (smallest count). also the :in and :path are different, and i&apos;m not sure what to use in mu/update-in. unfortunately i&apos;m not in control of the schema (it&apos;s generated based off of json-schema). my next approach will involve recursive mu/find-in , but i&apos;m wondering if anyone has run into a problem like this before, where conceptual indexing and real malli indexing have a significant mismatch and how to get to the correct spots in the schema to programmatically edit it (i&apos;m adding custom properties)"><y>#</y><d>2022-07-26</d><h>13:54</h><w>pppaul</w>I have a list of keyseqs <code>[[:parent :child1 :child2]...]</code>that map in a human readable way into my schema, but when i do mu/get-in mu/update-in the mappings don&apos;t work. when i do subschemas the paths are sorta like <code>[:parent 0 0 :child1 0 0 :child2]</code> and :parent will have 10 different paths to the same :child1 and :child2. it seems a bit like a flip of a coin if i get the correct path or not. i&apos;ve tried a few different ways of figuring out the correct one (smallest count). also the :in and :path are different, and i&apos;m not sure what to use in mu/update-in. unfortunately i&apos;m not in control of the schema (it&apos;s generated based off of json-schema). my next approach will involve recursive <code>mu/find-in</code>, but i&apos;m wondering if anyone has run into a problem like this before, where conceptual indexing and real malli indexing have a significant mismatch and how to get to the correct spots in the schema to programmatically edit it (i&apos;m adding custom properties)</z><z id="t1658900693" t="Martynas M Is there a way to represent this as a map? {id: string? size1: my-schema1 size2: my-schema1 size3: my-schema1} Where I know that id will be present all the time and size1 and others are dynamic. i.e. they can exist or they can have completely different names. I could use map-of for the second part but I would like to use map for the id part."><y>#</y><d>2022-07-27</d><h>05:44</h><w>Martynas M</w>Is there a way to represent this as a map?
<pre>{id: string?
 size1: my-schema1
 size2: my-schema1
 size3: my-schema1}</pre>
Where I know that <code>id</code> will be present all the time and <code>size1</code> and others are dynamic.
i.e. they can exist or they can have completely different names.

I could use <code>map-of</code> for the second part but I would like to use <code>map</code> for the <code>id</code> part.</z><z id="t1658909489" t="Yehonathan Sharvit Interesting question [:attrs {:href &quot;/_/_/users/U028ART884X&quot;}]"><y>#</y><d>2022-07-27</d><h>08:11</h><r>Yehonathan Sharvit</r>Interesting question <a>@U028ART884X</a></z><z id="t1658909587" t="Martynas M Instead I hardcoded the keys. It was simpler than think and solve for truly any key 😄"><y>#</y><d>2022-07-27</d><h>08:13</h><r>Martynas M</r>Instead I hardcoded the keys. It was simpler than think and solve for truly any key <b>😄</b></z><z id="t1658918272" t="pppaul yes, i posted an issue about something like this on malli&apos;s github"><y>#</y><d>2022-07-27</d><h>10:37</h><r>pppaul</r>yes, i posted an issue about something like this on malli&apos;s github</z><z id="t1658918342" t="pppaul (let [{:keys [additionalProperties]} form req-fields (-&gt;&gt; required (mapv keyword) (into #{})) all-fields (concat props req-fields)] (if-not additionalProperties (make-map props req-fields) [:and [:fn (fn [m] (-&gt;&gt; (apply dissoc m all-fields) (m/validate (m/schema [:map-of &apos;string? &apos;string?]))))] (make-map props req-fields)]))"><y>#</y><d>2022-07-27</d><h>10:39</h><r>pppaul</r><pre>(let [{:keys [additionalProperties]} form
                                          req-fields                     (-&gt;&gt; required (mapv keyword) (into #{}))
                                          all-fields                     (concat props req-fields)]
                                      (if-not additionalProperties
                                        (make-map props req-fields)
                                        [:and
                                         [:fn (fn [m]
                                                (-&gt;&gt;
                                                  (apply dissoc m all-fields)
                                                  (m/validate (m/schema [:map-of &apos;string? &apos;string?]))))]
                                         (make-map props req-fields)]))</pre></z><z id="t1658918376" t="pppaul that&apos;s code i use to transform a json schema map to act something like what you described"><y>#</y><d>2022-07-27</d><h>10:39</h><r>pppaul</r>that&apos;s code i use to transform a json schema map to act something like what you described</z><z id="t1658918448" t="pppaul [:and [:fn (fn [m] (-&gt;&gt; (dissoc m :optional :required) (m/validate (m/schema [:map-of keyword? string?]))))] [:map [:required [:enum :a :b]] [:optional {:optional true} [:enum :a :b]] ]] ends up making something like that"><y>#</y><d>2022-07-27</d><h>10:40</h><r>pppaul</r><pre>[:and
 [:fn (fn [m]
        (-&gt;&gt;
          (dissoc m :optional :required)
          (m/validate (m/schema [:map-of keyword? string?]))))]
 [:map
  [:required [:enum :a :b]]
  [:optional {:optional true} [:enum :a :b]]
  ]]</pre>
ends up making something like that</z><z id="t1658918571" t="pppaul make-map (fn [props req-fields] (apply vector :map (-&gt;&gt; props (mapv (fn [[k v]] (if (get req-fields k) [k v] [k {:optional true} v]))) (sort-by first))))"><y>#</y><d>2022-07-27</d><h>10:42</h><r>pppaul</r><pre>make-map (fn [props req-fields]
                   (apply vector :map
                     (-&gt;&gt; props
                       (mapv (fn [[k v]]
                               (if (get req-fields k)
                                 [k v]
                                 [k {:optional true} v])))
                       (sort-by first))))</pre></z><z id="t1658918706" t="pppaul there is some discussing in malli about making :closed be a schema, supporting this idea with the work around that i posted, but it&apos;s not got a PR or anything, so work around is best. you can replace the :map-of with a schema for each key very easily with the code i provided"><y>#</y><d>2022-07-27</d><h>10:45</h><r>pppaul</r>there is some discussing in malli about making :closed be a schema, supporting this idea with the work around that i posted, but it&apos;s not got a PR or anything, so work around is best. you can replace the <code>:map-of</code>with a schema for each key very easily with the code i provided</z><z id="t1659036986" t="nonrecursive hi all! i’m using reitit with malli for parameter coercion, and I have a schema with default values for some parameters, but those default values aren’t being added. has anyone else run into this?"><y>#</y><d>2022-07-28</d><h>19:36</h><w>nonrecursive</w>hi all! i’m using reitit with malli for parameter coercion, and I have a schema with default values for some parameters, but those default values aren’t being added. has anyone else run into this?</z><z id="t1659037049" t="nonrecursive my router looks like this: (def router (rr/router routes {:data {:coercion reitit.coercion.malli/coercion :middleware route-middleware}}))"><y>#</y><d>2022-07-28</d><h>19:37</h><w>nonrecursive</w>my router looks like this:

<pre>(def router
  (rr/router routes
             {:data {:coercion   reitit.coercion.malli/coercion
                     :middleware route-middleware}}))</pre></z><z id="t1659045615" t="pppaul there is a default values transformer"><y>#</y><d>2022-07-28</d><h>22:00</h><r>pppaul</r>there is a default values transformer</z><z id="t1659046434" t="nonrecursive I discovered the reason, it was because it had {:optional? true} in the options"><y>#</y><d>2022-07-28</d><h>22:13</h><r>nonrecursive</r>I discovered the reason, it was because it had <code>{:optional? true}</code> in the options</z><z id="t1659041692" t="NoahTheDuke is it possible to say &quot;this is either a set or the specific keyword :bypass &quot;?"><y>#</y><d>2022-07-28</d><h>20:54</h><w>NoahTheDuke</w>is it possible to say &quot;this is either a set or the specific keyword <code>:bypass</code> &quot;?</z><z id="t1659041741" t="NoahTheDuke realized my mistake immediately, lol. the answer is: [:or set? [:enum :bypass]]"><y>#</y><d>2022-07-28</d><h>20:55</h><w>NoahTheDuke</w>realized my mistake immediately, lol. the answer is: <code>[:or set? [:enum :bypass]]</code></z><z id="t1659052097" t="Mateo Difranco What would be the best way of handling multiple possibilities of a map inside a schema, based on a top level keyword? Maybe I can explain myself better with some examples, let&apos;s say I have something like this: {:something &quot;test&quot; :type :a :deep {:depends 3}} and {:something &quot;test&quot; :type :b :deep {:another [1 2]}} So, based on :type , I&apos;m expecting different things in :deep . This seems to be a good case for :multi , given it allows using a function for dispatch. But the dispatch function would take the :deep map, not the top level whole map. I have a work-around for this, but it&apos;s quite ugly and I&apos;m wondering if there&apos;s a better way."><y>#</y><d>2022-07-28</d><h>23:48</h><w>Mateo Difranco</w>What would be the best way of handling multiple possibilities of a map inside a schema, based on a top level keyword?
Maybe I can explain myself better with some examples, let&apos;s say I have something like this:
<pre>{:something &quot;test&quot;
 :type :a
 :deep {:depends 3}}</pre>
and
<pre>{:something &quot;test&quot;
 :type :b
 :deep {:another [1 2]}}</pre>
So, based on <code>:type</code>, I&apos;m expecting different things in <code>:deep</code>. This seems to be a good case for <code>:multi</code>, given it allows using a function for dispatch. But the dispatch function would take the <code>:deep</code> map, not the top level whole map.
I have a work-around for this, but it&apos;s quite ugly and I&apos;m wondering if there&apos;s a better way.</z><z id="t1659060128" t="pppaul this looks like what multi is designed for, i haven&apos;t used multi, i&apos;m curious where it fails in this case."><y>#</y><d>2022-07-29</d><h>02:02</h><w>pppaul</w>this looks like what multi is designed for, i haven&apos;t used multi, i&apos;m curious where it fails in this case.</z><z id="t1659105134" t="Mateo Difranco Well, I might be wrong, but take a look at this: (def Something [:map [:something string?] [:type [:enum :a :b]] [:deep [:multi {:dispatch :type} [:a [:map [:depends int?]]] [:b [:map [:another [:vector int?]]]]]]]) (m/validate Something {:something &quot;test&quot; :type :a :deep {:depends 3}}) ;=&gt; false And if I do a really ugly side effect, we can look at what exactly the dispatch function takes: (def Something [:map [:something string?] [:type [:enum :a :b]] [:deep [:multi {:dispatch (fn [x] (or (println x) :type))} &lt;------------- [:a [:map [:depends int?]]] [:b [:map [:another [:vector int?]]]]]]]) (m/validate Something {:something &quot;test&quot; :type :a :deep {:depends 3}}) ;=&gt; false, but also prints {:depends 3}"><y>#</y><d>2022-07-29</d><h>14:32</h><w>Mateo Difranco</w>Well, I might be wrong, but take a look at this:
<pre>(def Something
  [:map
   [:something string?]
   [:type [:enum :a :b]]
   [:deep
    [:multi {:dispatch :type}
     [:a [:map [:depends int?]]]
     [:b [:map [:another [:vector int?]]]]]]])

(m/validate
 Something
 {:something &quot;test&quot;
 :type :a
 :deep {:depends 3}}) ;=&gt; false</pre>
And if I do a really ugly side effect, we can look at what exactly the <code>dispatch</code> function takes:
<pre>(def Something
  [:map
   [:something string?]
   [:type [:enum :a :b]]
   [:deep
    [:multi {:dispatch (fn [x] (or (println x) :type))} &lt;-------------
     [:a [:map [:depends int?]]]
     [:b [:map [:another [:vector int?]]]]]]])

(m/validate
 Something
 {:something &quot;test&quot;
 :type :a
 :deep {:depends 3}}) ;=&gt; false, but also prints {:depends 3}</pre></z><z id="t1659112373" t="valtteri You probably should do the multi for the parent of :deep"><y>#</y><d>2022-07-29</d><h>16:32</h><r>valtteri</r>You probably should do the multi for the parent of :deep</z><z id="t1659112414" t="valtteri If you need to dispatch on the :type of the parent"><y>#</y><d>2022-07-29</d><h>16:33</h><r>valtteri</r>If you need to dispatch on the :type of the parent</z><z id="t1659112576" t="Mateo Difranco I thought about that, but then how would I avoid duplication of the structure? For example, if I move :multi to the top of the schema, I would need to make each possibility contain the whole structure right? In this case, :a would have a schema matching :something for example. Maybe I can merge in each possibility though, but I was wondering if there was a better solution."><y>#</y><d>2022-07-29</d><h>16:36</h><r>Mateo Difranco</r>I thought about that, but then how would I avoid duplication of the structure?
For example, if I move <code>:multi</code> to the top of the schema, I would need to make each possibility contain the whole structure right? In this case, <code>:a</code> would have a schema matching <code>:something</code> for example. Maybe I can merge in each possibility though, but I was wondering if there was a better solution.</z><z id="t1659113335" t="valtteri Yep, I guess that&apos;s whats you gotta do. You can splice the sub-schemas into smaller chunks for reuse"><y>#</y><d>2022-07-29</d><h>16:48</h><r>valtteri</r>Yep, I guess that&apos;s whats you gotta do. You can splice the sub-schemas into smaller chunks for reuse</z><z id="t1659113352" t="valtteri There might be some better way I&apos;m not aware of 🙂"><y>#</y><d>2022-07-29</d><h>16:49</h><r>valtteri</r>There might be some better way I&apos;m not aware of <b>🙂</b></z><z id="t1659111462" t="annarcana are there any SQL libraries that work with malli?"><y>#</y><d>2022-07-29</d><h>16:17</h><w>annarcana</w>are there any SQL libraries that work with malli?</z><z id="t1659112508" t="valtteri Depends on what you mean with that. :) We have experimental tool that derives malli schemas from sql table schema"><y>#</y><d>2022-07-29</d><h>16:35</h><r>valtteri</r>Depends on what you mean with that. :) We have experimental tool that derives malli schemas from sql table schema</z><z id="t1659117802" t="colliderwriter or this (no personal experience): https://github.com/kwrooijen/gungnir"><y>#</y><d>2022-07-29</d><h>18:03</h><r>colliderwriter</r>or this (no personal experience):

<a href="https://github.com/kwrooijen/gungnir" target="_blank">https://github.com/kwrooijen/gungnir</a></z><z id="t1659117911" t="annarcana Yes! This looks like what I had in mind (data-driven SQL schemas)"><y>#</y><d>2022-07-29</d><h>18:05</h><r>annarcana</r>Yes! This looks like what I had in mind (data-driven SQL schemas)</z><z id="t1659117979" t="annarcana We are already using malli to generate reitit routes from data models, so one thought was to also generate SQL table schemas from same"><y>#</y><d>2022-07-29</d><h>18:06</h><r>annarcana</r>We are already using malli to generate reitit routes from data models, so one thought was to also generate SQL table schemas from same</z><z id="t1659118031" t="annarcana I suppose any data-driven library like gungnir could work but something that already can do malli-&gt;SQL type translation was something I was hoping would be out there somewhere"><y>#</y><d>2022-07-29</d><h>18:07</h><r>annarcana</r>I suppose any data-driven library like gungnir could work but something that already can do malli-&gt;SQL type translation was something I was hoping would be out there somewhere</z><z id="t1659118044" t="colliderwriter afaict, this does not do schemas but it seems to have all the parts"><y>#</y><d>2022-07-29</d><h>18:07</h><r>colliderwriter</r>afaict, this does not do schemas but it seems to have all the parts</z><z id="t1659118212" t="annarcana it can do table create/drop migrations which should be enough for my purposes, but I&apos;ll have to dig into it"><y>#</y><d>2022-07-29</d><h>18:10</h><r>annarcana</r>it can do table create/drop migrations which should be enough for my purposes, but I&apos;ll have to dig into it</z><z id="t1659118323" t="colliderwriter i&apos;d be interested to hear your thoughts"><y>#</y><d>2022-07-29</d><h>18:12</h><r>colliderwriter</r>i&apos;d be interested to hear your thoughts</z><z id="t1659191794" t="Alejandro Hello. Is there a blog post, a documentation page, anything that discusses motivation behind malli? I&apos;d like to know how spec, plumatic/schema, and malli relate to each other."><y>#</y><d>2022-07-30</d><h>14:36</h><w>Alejandro</w>Hello. Is there a blog post, a documentation page, anything that discusses motivation behind malli? I&apos;d like to know how spec, plumatic/schema, and malli relate to each other.</z><z id="t1659193782" t="valtteri Here’s a video where Tommi explains also the motivation https://www.youtube.com/watch?v=MR83MhWQ61E"><y>#</y><d>2022-07-30</d><h>15:09</h><r>valtteri</r>Here’s a video where Tommi explains also the motivation <a href="https://www.youtube.com/watch?v=MR83MhWQ61E" target="_blank">https://www.youtube.com/watch?v=MR83MhWQ61E</a></z><z id="t1659193834" t="valtteri Comparison and reasoning wrt other tools (schema, spec) starts around 3:30"><y>#</y><d>2022-07-30</d><h>15:10</h><r>valtteri</r>Comparison and reasoning wrt other tools (schema, spec) starts around 3:30</z><z id="t1659195325" t="Alejandro thank you"><y>#</y><d>2022-07-30</d><h>15:35</h><r>Alejandro</r>thank you</z><z id="t1659191875" t="pinkfrog m/validate returns true/false, what’s the function that throws exception when data is malformed?"><y>#</y><d>2022-07-30</d><h>14:37</h><w>pinkfrog</w><code>m/validate</code> returns true/false, what’s the function that throws exception when data is malformed?</z><z id="t1659192013" t="pinkfrog The purpose of doing this is, I want to add code like (m/validate :int foobar) inside a function, and when foobar is not int, I want an exception is thrown so I can know some thing bad happens in sentry. Another good to have is, the m/validate (equivalent) can be turned on in dev and off in prod."><y>#</y><d>2022-07-30</d><h>14:40</h><w>pinkfrog</w>The purpose of doing this is, I want to add code like
<pre>(m/validate :int foobar)</pre>
inside a function, and when foobar is not int, I want an exception is thrown so I can know some thing bad happens in sentry.
Another good to have is, the m/validate (equivalent)  can be turned on in dev and off in prod.</z><z id="t1659192847" t="annarcana You&apos;ll most likely want some combination of explain /`humanize`. ( https://github.com/metosin/malli#error-messages ) I don&apos;t believe malli has any function that deliberately throws an exception, by design, but you can always use throw with an Exception whose payload is the malli explain output."><y>#</y><d>2022-07-30</d><h>14:54</h><w>annarcana</w>You&apos;ll most likely want some combination of <code>explain</code>/`humanize`. (<a href="https://github.com/metosin/malli#error-messages" target="_blank">https://github.com/metosin/malli#error-messages</a>) I don&apos;t believe malli has any function that deliberately throws an exception, by design, but you can always use <code>throw</code> with an <code>Exception</code> whose payload is the malli <code>explain</code> output.</z><z id="t1659193004" t="pinkfrog [:attrs {:href &quot;/_/_/users/U05087MJH&quot;}] Maybe I shall just do (assert (m/validate ,,,))"><y>#</y><d>2022-07-30</d><h>14:56</h><w>pinkfrog</w><a>@annapawlicka</a> Maybe I shall just do <code>(assert (m/validate ,,,))</code></z><z id="t1659201138" t="NoahTheDuke In the simplest case, this is what I would suggest doing."><y>#</y><d>2022-07-30</d><h>17:12</h><r>NoahTheDuke</r>In the simplest case, this is  what I would suggest doing.</z><z id="t1659193964" t="Ben Sless Do you want this with decode, too?"><y>#</y><d>2022-07-30</d><h>15:12</h><w>Ben Sless</w>Do you want this with decode, too?</z><z id="t1659231092" t="pinkfrog yes!"><y>#</y><d>2022-07-31</d><h>01:31</h><r>pinkfrog</r>yes!</z><z id="t1659542071" t="Ben Sless you should build something like: (defn coercer [schema options transformer] (let [schema (m/schema schema options) validator (m/validator schema options) decoder (m/decoder schema options transformer) explainer (m/explainer schema options)] (fn [x success failure] (let [ret (decoder x)] (if (validator ret) (success ret) (failure (explainer ret)))))))"><y>#</y><d>2022-08-03</d><h>15:54</h><r>Ben Sless</r><pre>you should build something like:

(defn coercer
  [schema options transformer]
  (let [schema (m/schema schema options)
        validator (m/validator schema options)
        decoder (m/decoder schema options transformer)
        explainer (m/explainer schema options)]
    (fn [x success failure]
      (let [ret (decoder x)]
        (if (validator ret)
          (success ret)
          (failure (explainer ret)))))))</pre></z><z id="t1660538253" t="pinkfrog [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Say I do not want to define the validators in advance. So is it meaningful to create the validators on the fly or shall I just directly use the m/validate function? Is there any performance discrepancy regarding the two?"><y>#</y><d>2022-08-15</d><h>04:37</h><r>pinkfrog</r><a>@UK0810AQ2</a> Say I do not want to define the validators in advance. So is it meaningful to create the validators on the fly or shall I just directly use the m/validate function? Is there any performance discrepancy regarding the two?</z><z id="t1660540280" t="Ben Sless Yes, closing over a validator is faster than calling validate every time. In what context are you using this?"><y>#</y><d>2022-08-15</d><h>05:11</h><r>Ben Sless</r>Yes, closing over a validator is faster than calling validate every time. In what context are you using this?</z><z id="t1660541523" t="pinkfrog Across the codebase, many functions accepts a map but the data type etc is not clear. I want to annotate the functions."><y>#</y><d>2022-08-15</d><h>05:32</h><r>pinkfrog</r>Across the codebase, many functions accepts a map but the data type etc is not clear. I want to annotate the functions.</z><z id="t1660546862" t="Ben Sless ah, you should have said so, you want this: https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata"><y>#</y><d>2022-08-15</d><h>07:01</h><r>Ben Sless</r>ah, you should have said so, you want this: <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata</a></z><z id="t1660551774" t="pinkfrog Using function schemas, there is a tendency to spec on all the arguments, but I’d rather spec on one of them."><y>#</y><d>2022-08-15</d><h>08:22</h><r>pinkfrog</r>Using function schemas, there is a tendency to spec on all the arguments, but I’d rather spec on one of them.</z><z id="t1660551842" t="Ben Sless Why not spec the others as any?"><y>#</y><d>2022-08-15</d><h>08:24</h><r>Ben Sless</r>Why not spec the others as any?</z><z id="t1660552176" t="pinkfrog That causes confusion."><y>#</y><d>2022-08-15</d><h>08:29</h><r>pinkfrog</r>That causes confusion.</z><z id="t1660552443" t="Ben Sless I think you don&apos;t have to spec all the arguments with this macro, no?"><y>#</y><d>2022-08-15</d><h>08:34</h><r>Ben Sless</r>I think you don&apos;t have to spec all the arguments with this macro, no?</z><z id="t1659502963" t="Stel Abrego Hey y&apos;all, I&apos;m wondering if it&apos;s possible in Malli to create a spec for a map with these qualifications: • There are some specific keyword keys that are required (this is simple in Malli) • There can also be an arbitrary amount of keys that are vectors, but they all must be vectors of keywords and their values must be maps. (not straightforward) • Besides the two possibilities above, the map is closed (ex no string keys for example, also not straightforward) The last two things are the weird requirements. Seems like :map can&apos;t really support this. I might need to use [:and [:map ... ] [:fn ...] but even then it might be awkward to satisfy #3."><y>#</y><d>2022-08-03</d><h>05:02</h><w>Stel Abrego</w>Hey y&apos;all, I&apos;m wondering if it&apos;s possible in Malli to create a spec for a map with these qualifications:
• There are some specific keyword keys that are required (this is simple in Malli)
• There can also be an arbitrary amount of keys that are vectors, but they all must be vectors of keywords and their values must be maps. (not straightforward)
• Besides the two possibilities above, the map is closed (ex no string keys for example, also not straightforward)
The last two things are the weird requirements. Seems like <code>:map</code> can&apos;t really support this. I might need to use <code>[:and [:map ... ] [:fn ...]</code> but even then it might be awkward to satisfy #3.</z><z id="t1659543791" t="pppaul using :fn is how i did exactly this"><y>#</y><d>2022-08-03</d><h>16:23</h><r>pppaul</r>using <code>:fn</code> is how i did exactly this</z><z id="t1659543858" t="pppaul https://github.com/metosin/malli/issues/682"><y>#</y><d>2022-08-03</d><h>16:24</h><r>pppaul</r><a href="https://github.com/metosin/malli/issues/682" target="_blank">https://github.com/metosin/malli/issues/682</a></z><z id="t1659543893" t="pppaul last post is the solution, unless you want to give malli a PR and do some hard work"><y>#</y><d>2022-08-03</d><h>16:24</h><r>pppaul</r>last post is the solution, unless you want to give malli a PR and do some hard work</z><z id="t1659543984" t="pppaul [:and [:fn (fn [m] (-&gt;&gt; (dissoc m :specified :optional :required) (m/validate (m/schema [:map-of keyword? string?]))))] [:map [:required [:enum :a :b]] [:optional {:optional true} [:enum :a :b]] [:specified :int]]] make a function that outputs something like this"><y>#</y><d>2022-08-03</d><h>16:26</h><r>pppaul</r><pre>[:and
 [:fn (fn [m]
        (-&gt;&gt;
          (dissoc m :specified :optional :required)
          (m/validate (m/schema [:map-of keyword? string?]))))]
 [:map
  [:required [:enum :a :b]]
  [:optional {:optional true} [:enum :a :b]]
  [:specified :int]]]</pre>
make a function that outputs something like this</z><z id="t1659567372" t="Stel Abrego [:attrs {:href &quot;/_/_/users/U0LAJQLQ1&quot;}] thank you for the help! I&apos;m going to look at this later."><y>#</y><d>2022-08-03</d><h>22:56</h><r>Stel Abrego</r><a>@U0LAJQLQ1</a> thank you for the help! I&apos;m going to look at this later.</z><z id="t1659567699" t="pppaul just be aware that i didn&apos;t provide a general function, you need to create one that respects the keys in your malli map schema."><y>#</y><d>2022-08-03</d><h>23:01</h><r>pppaul</r>just be aware that i didn&apos;t provide a general function, you need to create one that respects the keys in your malli map schema.</z><z id="t1659640789" t="Stel Abrego A little update, I realized that clojure.spec can solve this problem with actually great error messages so I might rewrite in spec. Might write a blog post about it later too."><y>#</y><d>2022-08-04</d><h>19:19</h><r>Stel Abrego</r>A little update, I realized that clojure.spec can solve this problem with actually great error messages so I might rewrite in spec. Might write a blog post about it later too.</z><z id="t1659541929" t="Ben Sless What&apos;s the best way to express in malli &quot;a map must contain at least one of a set of kv&quot;?"><y>#</y><d>2022-08-03</d><h>15:52</h><w>Ben Sless</w>What&apos;s the best way to express in malli &quot;a map must contain at least one of a set of kv&quot;?</z><z id="t1659545174" t="NoahTheDuke is that :or or :multi ?"><y>#</y><d>2022-08-03</d><h>16:46</h><w>NoahTheDuke</w>is that <code>:or</code> or <code>:multi</code>?</z><z id="t1659547664" t="Ben Sless It&apos;s probably :or , but it&apos;s gross to have [:and M1 [:or M2.0 M2.1 M2.2]]"><y>#</y><d>2022-08-03</d><h>17:27</h><w>Ben Sless</w>It&apos;s probably <code>:or</code>, but it&apos;s gross to have <code>[:and M1 [:or M2.0 M2.1 M2.2]]</code></z><z id="t1659547742" t="Ben Sless I also think this requires some awareness of implementation details to get coercion right, because when dealing with two keys, you&apos;ll want to try to coerce both, i.e. [:or [:merge Ma Mb] Ma Mb]]"><y>#</y><d>2022-08-03</d><h>17:29</h><w>Ben Sless</w>I also think this requires some awareness of implementation details to get coercion right, because when dealing with two keys, you&apos;ll want to try to coerce both, i.e. <code>[:or [:merge Ma Mb] Ma Mb]]</code></z><z id="t1659547751" t="Ben Sless That&apos;s even messier and for only two keys"><y>#</y><d>2022-08-03</d><h>17:29</h><w>Ben Sless</w>That&apos;s even messier and for only two keys</z><z id="t1659547766" t="Ben Sless now do that with three keys, the combinations become unreasonable"><y>#</y><d>2022-08-03</d><h>17:29</h><w>Ben Sless</w>now do that with three keys, the combinations become unreasonable</z><z id="t1659548126" t="Ben Sless The correct thing to do in these situations is compile an execution plan"><y>#</y><d>2022-08-03</d><h>17:35</h><w>Ben Sless</w>The correct thing to do in these situations is compile an execution plan</z><z id="t1659548136" t="Ben Sless Sort of like pattern matching libraries do"><y>#</y><d>2022-08-03</d><h>17:35</h><w>Ben Sless</w>Sort of like pattern matching libraries do</z><z id="t1659548757" t="NoahTheDuke you could also do a function schema for this, make the various keys optional and then perform the check in the :fn"><y>#</y><d>2022-08-03</d><h>17:45</h><w>NoahTheDuke</w>you could also do a function schema for this, make the various keys optional and then perform the check in the <code>:fn</code></z><z id="t1659549971" t="Ben Sless I am morally opposed to function schemas"><y>#</y><d>2022-08-03</d><h>18:06</h><r>Ben Sless</r>I am morally opposed to function schemas</z><z id="t1659550755" t="NoahTheDuke any particular reason? seems appropriate for this kind of work"><y>#</y><d>2022-08-03</d><h>18:19</h><r>NoahTheDuke</r>any particular reason? seems appropriate for this kind of work</z><z id="t1659556293" t="Ben Sless They&apos;re completely opaque, not well defined, not serializable, hard up to impossible to generate"><y>#</y><d>2022-08-03</d><h>19:51</h><r>Ben Sless</r>They&apos;re completely opaque, not well defined, not serializable, hard up to impossible to generate</z><z id="t1659556367" t="Ben Sless The semantics of &quot;at least one of this group&quot; are clear, don&apos;t need a function. It can (should) be another schema type"><y>#</y><d>2022-08-03</d><h>19:52</h><r>Ben Sless</r>The semantics of &quot;at least one of this group&quot; are clear, don&apos;t need a function. It can (should) be another schema type</z></g><g id="s25"><z id="t1659556690" t="NoahTheDuke That makes sense to me. I wonder how hard it is to write a new schema type like this"><y>#</y><d>2022-08-03</d><h>19:58</h><r>NoahTheDuke</r>That makes sense to me. I wonder how hard it is to write a new schema type like this</z><z id="t1659557784" t="Ben Sless A bad implementation is easy, an efficient implementation is hard 🙂"><y>#</y><d>2022-08-03</d><h>20:16</h><r>Ben Sless</r>A bad implementation is easy, an efficient implementation is hard <b>🙂</b></z><z id="t1659557904" t="NoahTheDuke Is it? Naively, I would expect it to be an or : (fn [obj] (or (contains? obj :a) (contains? obj :b) (contains? obj :c))) or something similar. is there more to it?"><y>#</y><d>2022-08-03</d><h>20:18</h><r>NoahTheDuke</r>Is it? Naively, I would expect it to be an <code>or</code>:
<pre>(fn [obj]
  (or (contains? obj :a)
      (contains? obj :b)
      (contains? obj :c)))</pre>
or something similar. is there more to it?</z><z id="t1659557935" t="NoahTheDuke Maybe I&apos;m misunderstanding the actual problem"><y>#</y><d>2022-08-03</d><h>20:18</h><r>NoahTheDuke</r>Maybe I&apos;m misunderstanding the actual problem</z><z id="t1659558106" t="Ben Sless because there&apos;s a combinatoric explosion, you need for two keys: [:or [:map [:k1 S1] [:k2 S2]] [:map [:k1 S1]] [:map [:k2 S2]]]"><y>#</y><d>2022-08-03</d><h>20:21</h><r>Ben Sless</r>because there&apos;s a combinatoric explosion, you need for two keys:
<code>[:or [:map [:k1 S1] [:k2 S2]] [:map [:k1 S1]] [:map [:k2 S2]]]</code></z><z id="t1659558144" t="Ben Sless for three keys you have 7 options (I think, I&apos;m tired)"><y>#</y><d>2022-08-03</d><h>20:22</h><r>Ben Sless</r>for three keys you have 7 options (I think, I&apos;m tired)</z><z id="t1659558166" t="NoahTheDuke &quot;At least one of a set&quot; means as long as one exists, it doesn&apos;t matter if others exist, so you can just check each one"><y>#</y><d>2022-08-03</d><h>20:22</h><r>NoahTheDuke</r>&quot;At least one of a set&quot; means as long as one exists, it doesn&apos;t matter if others exist, so you can just check each one</z><z id="t1659558211" t="NoahTheDuke could compile a list of the ones that do exist and then merge them after the fact too"><y>#</y><d>2022-08-03</d><h>20:23</h><r>NoahTheDuke</r>could compile a list of the ones that do exist and then merge them after the fact too</z><z id="t1659558215" t="Ben Sless Yes, but now make decode, encode, parse and explain work 🙂"><y>#</y><d>2022-08-03</d><h>20:23</h><r>Ben Sless</r>Yes, but now make decode, encode, parse and explain work <b>🙂</b></z><z id="t1659558270" t="NoahTheDuke hah I won&apos;t be nerd sniped! but yes, if you don&apos;t want to directly implement a bunch of stuff, I think I can see the issue more clearly"><y>#</y><d>2022-08-03</d><h>20:24</h><r>NoahTheDuke</r>hah I won&apos;t be nerd sniped! but yes, if you don&apos;t want to directly implement a bunch of stuff, I think I can see the issue more clearly</z><z id="t1659558358" t="Ben Sless That&apos;s why I dislike function schemas 🙂"><y>#</y><d>2022-08-03</d><h>20:25</h><r>Ben Sless</r>That&apos;s why I dislike function schemas <b>🙂</b></z><z id="t1659657495" t="mauricio.szabo Folks, a simple question about .pretty/explain - is it possible to NOT print the full value being matched? The reason is: I have a HUGE data, and it&apos;s actually breaking my terminal limit, so I can&apos;t actually see the error 😞"><y>#</y><d>2022-08-04</d><h>23:58</h><w>mauricio.szabo</w>Folks, a simple question about <code>.pretty/explain</code> - is it possible to NOT print the full value being matched?

The reason is: I have a HUGE data, and it&apos;s actually breaking my terminal limit, so I can&apos;t actually see the error <b>😞</b></z><z id="t1659735382" t="ingesol https://clojurians.slack.com/archives/CLDK6MFMK/p1656494811406489?thread_ts=1656452534.761089&amp;amp;cid=CLDK6MFMK"><y>#</y><d>2022-08-05</d><h>21:36</h><r>ingesol</r><a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1656494811406489?thread_ts=1656452534.761089&amp;amp;cid=CLDK6MFMK" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1656494811406489?thread_ts=1656452534.761089&amp;amp;cid=CLDK6MFMK</a></z><z id="t1660114632" t="ikitommi would be easy to add an option to drop that. please write an issue. Also, see https://github.com/metosin/malli/pull/731"><y>#</y><d>2022-08-10</d><h>06:57</h><r>ikitommi</r>would be easy to add an option to drop that. please write an issue. Also, see <a href="https://github.com/metosin/malli/pull/731" target="_blank">https://github.com/metosin/malli/pull/731</a></z><z id="t1660114666" t="ikitommi e.g. option (or new default) will mask the irrelevant parts of the value. they can be huge."><y>#</y><d>2022-08-10</d><h>06:57</h><r>ikitommi</r>e.g. option (or new default) will mask the irrelevant parts of the value. they can be huge.</z><z id="t1659657728" t="pppaul you can write it out to a file"><y>#</y><d>2022-08-05</d><h>00:02</h><w>pppaul</w>you can write it out to a file</z><z id="t1659658079" t="mauricio.szabo Not really, I&apos;m on React-Native"><y>#</y><d>2022-08-05</d><h>00:07</h><w>mauricio.szabo</w>Not really, I&apos;m on React-Native</z><z id="t1659661370" t="pppaul you may have to edit some of the functions in the namespace to customize the output."><y>#</y><d>2022-08-05</d><h>01:02</h><w>pppaul</w>you may have to edit some of the functions in the namespace to customize the output.</z><z id="t1659724001" t="Colin P. Hill In Malli function signatures, what does the ? prefix on a parameter mean?"><y>#</y><d>2022-08-05</d><h>18:26</h><w>Colin P. Hill</w>In Malli function signatures, what does the <code>?</code> prefix on a parameter mean?</z><z id="t1659726501" t="valtteri It means that by convention the function will tolerate nil and possibly other nonsense for those params."><y>#</y><d>2022-08-05</d><h>19:08</h><r>valtteri</r>It means that by convention the function will tolerate <code>nil</code> and possibly other nonsense for those params.</z><z id="t1659780622" t="hjrnunes I need to validate a map-like type with metadata. Actually, values are collections - vector-like types - which also have metadata that needs validation. I&apos;ve played around with the -map-schema and -collection-schema implementations and I can make them support my custom types easily, but I am unsure how I can express the metadata schema. I could use properties but I wonder if that makes sense. The metadata is as important as the rest. Actually it&apos;s where the most variation will be. Is there a better way than simply maintaining two schemas - one for the actual type and another for the metadata map - and running validation for each independently?"><y>#</y><d>2022-08-06</d><h>10:10</h><w>hjrnunes</w>I need to validate a map-like type with metadata. Actually, values are collections - vector-like types - which also have metadata that needs validation.
I&apos;ve played around with the <code>-map-schema</code> and <code>-collection-schema</code>  implementations and I can make them support my custom types easily, but I am unsure how I can express the metadata schema. I could use properties but I wonder if that makes sense. The metadata is as important as the rest. Actually it&apos;s where the most variation will be.
Is there a better way than simply maintaining two schemas - one for the actual type and another for the metadata map - and running validation for each independently?</z><z id="t1660114134" t="ikitommi currently, there isn’t an extension point for validation, like there is for most other schema applications (transforming, generating, …), so there isn’t an easy way to add a generic, properties-based declaration for meta-data, if there was, could be something like: [:map {:metadata [:map [:closed :boolean]]} [:x :int]]"><y>#</y><d>2022-08-10</d><h>06:48</h><r>ikitommi</r>currently, there isn’t an extension point for validation, like there is for most other schema applications (transforming, generating, …), so there isn’t an easy way to add a generic, properties-based declaration for meta-data, if there was, could be something like:
<pre>[:map {:metadata [:map [:closed :boolean]]} [:x :int]]</pre></z><z id="t1660114189" t="ikitommi if you can provide an example how and where you would like to define the metadata schemas, could suggest ways to build such thing. It’s definetely doable, many ways to do that."><y>#</y><d>2022-08-10</d><h>06:49</h><r>ikitommi</r>if you can provide an example how and where you would like to define the metadata schemas, could suggest ways to build such thing. It’s definetely doable, many ways to do that.</z><z id="t1660114210" t="ikitommi Please write an issue with some sample data?"><y>#</y><d>2022-08-10</d><h>06:50</h><r>ikitommi</r>Please write an issue with some sample data?</z><z id="t1660115541" t="hjrnunes Well, that&apos;s the thing. I&apos;m not really sure how to best handle it. I can easily do it via properties like the snippet you shared, but it just felt odd to have schema in the properties. Maybe I&apos;m just overthinking it."><y>#</y><d>2022-08-10</d><h>07:12</h><r>hjrnunes</r>Well, that&apos;s the thing. I&apos;m not really sure how to best handle it. I can easily do it via properties like the snippet you shared, but it just felt odd to have schema in the properties. Maybe I&apos;m just overthinking it.</z><z id="t1660116404" t="ikitommi could also be a lookup, e.g. [:map {:domain/type ::object} …] , so that the metadata-schemas are in a separate registry and looked out with a property-key. You can the create a helper that takes a schema and returns a metadata validator and use that when needed. keeps the validation of metadata and values as separate. should be easy’ish to do with schema walking."><y>#</y><d>2022-08-10</d><h>07:26</h><r>ikitommi</r>could also be a lookup, e.g. <code>[:map {:domain/type ::object} …]</code>, so that the metadata-schemas are in a separate registry and looked out with a property-key. You can the create a helper that takes a schema and returns a metadata validator and use that when needed. keeps the validation of metadata and values as separate. should be easy’ish to do with schema walking.</z><z id="t1659821771" t="Eugen hi, is there a guide to learn malli for dummies? I am new to clojure and I kind of struggle to get my head around malli. I would like to use it for data modeling - as an exploratory tool. I would like to define some entities and be able to customize the generated output. (have a list of names, companies, etc). I read through the section and I still feel like I am missing some context. For example, I would like to generate company names like: Acme + some random smallish number ?!: ACME 12 I have defined an ID like (def id [:string {:min 1, :max 20}]) and I would like to limit what characters it should contain (it should have only printable characters for example)"><y>#</y><d>2022-08-06</d><h>21:36</h><w>Eugen</w>hi, is there a guide to learn malli for dummies?
I am new to clojure and I kind of struggle to get my head around malli.

I would like to use it for data modeling - as an exploratory tool.
I would like to define some entities and be able to customize the generated output.
(have a list of names, companies, etc).

I read through the section and I still feel like I am missing some context.

For example, I would like to generate company names like: Acme + some random smallish number ?!: <code>ACME 12</code>
I have defined an ID like
<pre>(def id [:string {:min 1, :max 20}]) </pre>
and I would like to limit what characters it should contain (it should have only printable characters for example)</z><z id="t1659823675" t="hanDerPeder Malli, as spec, leverages the test.check library for generating values. I would start there. There are some very useful guides linked in the readme of that project. "><y>#</y><d>2022-08-06</d><h>22:07</h><r>hanDerPeder</r>Malli, as spec, leverages the test.check library for generating values. I would start there. There are some very useful guides linked in the readme of that project. </z><z id="t1659823701" t="hanDerPeder https://www.youtube.com/watch?v=F4VZPxLZUdA"><y>#</y><d>2022-08-06</d><h>22:08</h><r>hanDerPeder</r><a href="https://www.youtube.com/watch?v=F4VZPxLZUdA" target="_blank">https://www.youtube.com/watch?v=F4VZPxLZUdA</a></z><z id="t1659823713" t="hanDerPeder This one seems relevant"><y>#</y><d>2022-08-06</d><h>22:08</h><r>hanDerPeder</r>This one seems relevant</z><z id="t1659824235" t="Eugen thanks [:attrs {:href &quot;/_/_/users/U013U475882&quot;}]"><y>#</y><d>2022-08-06</d><h>22:17</h><r>Eugen</r>thanks <a>@U013U475882</a></z><z id="t1659824376" t="Eugen I think my end goal is very similar to what [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] talked about here https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;ab_channel=LambdaIsland . Thank you [:attrs {:href &quot;/_/_/users/U07FP7QJ0&quot;}] for making the video ! I would love to have a more in-depth presenatation of that. If you have anything please share. BTW, can you share how the project evolved? It&apos;s been two years."><y>#</y><d>2022-08-06</d><h>22:19</h><r>Eugen</r>I think my end goal is very similar to what <a>@U07FP7QJ0</a> talked about here <a href="https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;ab_channel=LambdaIsland" target="_blank">https://www.youtube.com/watch?v=ww9yR_rbgQs&amp;amp;ab_channel=LambdaIsland</a> .

Thank you <a>@U07FP7QJ0</a> for making the video !
I would love to have a more in-depth presenatation of that.
If you have anything please share.
BTW, can you share how the project evolved?
It&apos;s been two years.</z><z id="t1659966414" t="pppaul (def id [:string {:gen/elements [list of names to use] :min 1, :max 20}]) "><y>#</y><d>2022-08-08</d><h>13:46</h><r>pppaul</r><pre>(def id [:string {:gen/elements [list of names to use] :min 1, :max 20}]) </pre></z><z id="t1659966474" t="Eugen thanks for all the help, I am getting my head around it - but it&apos;s lots of new stuff to learn (test-check)."><y>#</y><d>2022-08-08</d><h>13:47</h><r>Eugen</r>thanks for all the help, I am getting my head around it - but it&apos;s lots of new stuff to learn (test-check).</z><z id="t1659966548" t="Eugen I am thinking of writing some generators that will leverage data sources like WikiData to get real world examples. This should be more to generate some lorem ipsum style of data."><y>#</y><d>2022-08-08</d><h>13:49</h><r>Eugen</r>I am thinking of writing some generators that will leverage data sources like WikiData to get real world examples.
This should be more to generate some lorem ipsum style of data.</z><z id="t1659966550" t="pppaul if you aren&apos;t experienced with generators there is a bit of a learning curve, but it&apos;s not too hard. i find programmatically attaching the generators harder than making them."><y>#</y><d>2022-08-08</d><h>13:49</h><r>pppaul</r>if you aren&apos;t experienced with generators there is a bit of a learning curve, but it&apos;s not too hard. i find programmatically attaching the generators harder than making them.</z><z id="t1659966650" t="Eugen thanks for the feedback. That is a question I have - how to use the generators in the app. Since it&apos;s a lot of new stuff I am bound to make mistakes, hence me asking."><y>#</y><d>2022-08-08</d><h>13:50</h><r>Eugen</r>thanks for the feedback.
That is a question I have - how to use the generators in the app.
Since it&apos;s a lot of new stuff I am bound to make mistakes, hence me asking.</z><z id="t1659966702" t="pppaul if you have schema&apos;s that can generate nested things, you will want to control those generators a lot (any? is a very nasty one)."><y>#</y><d>2022-08-08</d><h>13:51</h><r>pppaul</r>if you have schema&apos;s that can generate nested things, you will want to control those generators a lot (any? is a very nasty one).</z><z id="t1659966762" t="Eugen if I make it I will be bale to write on CV: generator tamer 🙂"><y>#</y><d>2022-08-08</d><h>13:52</h><r>Eugen</r>if I make it I will be bale to write on CV: generator tamer <b>🙂</b></z><z id="t1659967076" t="pppaul also, the gen/ properties don&apos;t work together, so if you want to use elments-&gt;fmap you have to use gen/gen instead. if you are converting to json, you need to watch out for symbol/string/keyword keys causing dupe key issues"><y>#</y><d>2022-08-08</d><h>13:57</h><r>pppaul</r>also, the <code>gen/</code> properties don&apos;t work together, so if you want to use elments-&gt;fmap you have to use <code>gen/gen</code> instead. if you are converting to json, you need to watch out for symbol/string/keyword keys causing dupe key issues</z><z id="t1659967115" t="Eugen don&apos;t know what that means for now, but I&apos;ll try to keep an eye out for it."><y>#</y><d>2022-08-08</d><h>13:58</h><r>Eugen</r>don&apos;t know what that means for now, but I&apos;ll try to keep an eye out for it.</z><z id="t1659967117" t="Eugen thanks"><y>#</y><d>2022-08-08</d><h>13:58</h><r>Eugen</r>thanks</z><z id="t1659967188" t="pppaul maybe not a normal issue to run into, but it was an issue for me when i was making generators for schemas that i converted from json to malli (i didn&apos;t own the schema)"><y>#</y><d>2022-08-08</d><h>13:59</h><r>pppaul</r>maybe not a normal issue to run into, but it was an issue for me when i was making generators for schemas that i converted from json to malli (i didn&apos;t own the schema)</z><z id="t1659967282" t="pppaul {&apos;key :a :key :c &quot;key&quot; :d} that in json is a map where all keys are the same, and thus invalid"><y>#</y><d>2022-08-08</d><h>14:01</h><r>pppaul</r><code>{&apos;key :a :key :c &quot;key&quot; :d}</code>   that in json is a map where all keys are the same, and thus invalid</z><z id="t1659967402" t="pppaul anyway, biggest issue with generators is the recursive stuff, so if you have any of that you have to take care of it right away and figure out how to limit the recursions, or your data is going to get extremely large"><y>#</y><d>2022-08-08</d><h>14:03</h><r>pppaul</r>anyway, biggest issue with generators is the recursive stuff, so if you have any of that you have to take care of it right away and figure out how to limit the recursions, or your data is going to get extremely large</z><z id="t1659967474" t="Eugen thanks"><y>#</y><d>2022-08-08</d><h>14:04</h><r>Eugen</r>thanks</z><z id="t1659967494" t="Eugen I&apos;ll try to stay away from recursion"><y>#</y><d>2022-08-08</d><h>14:04</h><r>Eugen</r>I&apos;ll try to stay away from recursion</z><z id="t1659977073" t="NoahTheDuke Just opened an https://github.com/metosin/malli/issues/734 for a subtle implementation detail/maybe bug with :tuple schemas: if given a seq, m/encode silently fails to do any encoding instead of coercing to a vector."><y>#</y><d>2022-08-08</d><h>16:44</h><w>NoahTheDuke</w>Just opened an <a href="https://github.com/metosin/malli/issues/734" target="_blank">https://github.com/metosin/malli/issues/734</a> for a subtle implementation detail/maybe bug with <code>:tuple</code> schemas: if given a seq, <code>m/encode</code> silently fails to do any encoding instead of coercing to a vector.</z><z id="t1660002403" t="Eugen is there a guide/version of this article with malli ? https://cognitect.com/blog/2017/3/24/3xeif9bxaom78qyzwssgwz1leuorh4"><y>#</y><d>2022-08-08</d><h>23:46</h><w>Eugen</w>is there a guide/version of this article with malli ? <a href="https://cognitect.com/blog/2017/3/24/3xeif9bxaom78qyzwssgwz1leuorh4" target="_blank">https://cognitect.com/blog/2017/3/24/3xeif9bxaom78qyzwssgwz1leuorh4</a></z><z id="t1660113024" t="ikitommi not exactly that, would you be interested in writing that?"><y>#</y><d>2022-08-10</d><h>06:30</h><r>ikitommi</r>not exactly that, would you be interested in writing that?</z><z id="t1660113152" t="ikitommi should be easy to map that to malli"><y>#</y><d>2022-08-10</d><h>06:32</h><r>ikitommi</r>should be easy to map that to malli</z><z id="t1660121695" t="Eugen sounds interesting, but right now I don&apos;t have time for that. getting my bearings and it takes quite some time. I will consider this in a few months when I get more confient I did (re)found specmonstah (the third time) https://github.com/reifyhealth/specmonstah/ . On papaer it provides what I need so I am going to work with that and see if it&apos;s a good fit for what I am looking for: generate data for a web app to facilitate demos"><y>#</y><d>2022-08-10</d><h>08:54</h><r>Eugen</r>sounds interesting, but right now I don&apos;t have time for that. getting my bearings and it takes quite some time. I will consider this in a few months when I get more confient

I did (re)found specmonstah (the third time) <a href="https://github.com/reifyhealth/specmonstah/" target="_blank">https://github.com/reifyhealth/specmonstah/</a> .

On papaer it provides what I need so I am going to work with that and see if it&apos;s a good fit for what I am looking for: generate data for a web app to facilitate demos</z><z id="t1660089138" t="bortexz Hi, recently started playing with Malli, I am trying to understand why this works: (def Map1 (mu/optional-keys (m/schema [:map ::a ::b] {:registry (merge (m/default-schemas) (mu/schemas) {::a string? ::b [:merge [:map [::a [:ref ::a]]] [:map [:y string?]]]})}) [::b])) but this fails with enum child error: (def Map2 (mu/optional-keys [:map {:registry (merge (m/default-schemas) (mu/schemas) {::a string? ::b [:merge [:map [::a [:ref ::a]]] [:map [:y string?]]]})} ::a ::b] [::b])) =&gt; ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). ; :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1, :max nil} Is it a bug? Am I missing something? Edit: Another question that is slightly related (involves registries too) malli.util derivative transforms like mu/optional-keys obfuscate the refs when used inside registry: (def Map1 [:map {:registry {::b string? ::a (mu/optional-keys [:map [::b [:ref ::b]]])}} ::a]) =&gt; ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). ; :malli.core/invalid-ref {:type :ref, :ref :malli-domain-lab/b} Is there any workaround for this?"><y>#</y><d>2022-08-09</d><h>23:52</h><w>bortexz</w>Hi, recently started playing with Malli, I am trying to understand why this works:
<pre>(def Map1
  (mu/optional-keys
   (m/schema
    [:map ::a ::b]
    {:registry (merge
                (m/default-schemas)
                (mu/schemas)
                {::a string?
                 ::b [:merge
                      [:map [::a [:ref ::a]]]
                      [:map [:y string?]]]})})
   [::b]))</pre>
but this fails with enum child error:
<pre>(def Map2
  (mu/optional-keys
   [:map {:registry (merge
                     (m/default-schemas)
                     (mu/schemas)
                     {::a string?
                      ::b [:merge
                           [:map [::a [:ref ::a]]]
                           [:map [:y string?]]]})}
    ::a
    ::b]
   [::b]))
=&gt; 
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
; :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1, :max nil}</pre>
Is it a bug? Am I missing something?

Edit: Another question that is slightly related (involves registries too) malli.util derivative transforms like mu/optional-keys obfuscate the refs when used inside registry:
<pre>(def Map1 
  [:map {:registry {::b string?
                    ::a (mu/optional-keys
                         [:map [::b [:ref ::b]]])}}
   ::a])
=&gt;
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
; :malli.core/invalid-ref {:type :ref, :ref :malli-domain-lab/b}</pre>
Is there any workaround for this?</z><z id="t1660113774" t="ikitommi Hi. I believe it’s a bug, please write an issue."><y>#</y><d>2022-08-10</d><h>06:42</h><r>ikitommi</r>Hi. I believe it’s a bug, please write an issue.</z><z id="t1660113910" t="ikitommi Robust way to define a schema space for an application is to use the global scope, e.g.: (mr/set-default-registry! ;; linear search (mr/composite-registry ;; default schemas (m/default-schemas) ;; utils (mu/schemas))) (mu/optional-keys [:map {:registry {::a string? ::b [:merge [:map [::a [:ref ::a]]] [:map [:y string?]]]}} ::a ::b] [::b])"><y>#</y><d>2022-08-10</d><h>06:45</h><r>ikitommi</r>Robust way to define a schema space for an application is to use the global scope, e.g.:
<pre>(mr/set-default-registry!
  ;; linear search
  (mr/composite-registry
    ;; default schemas
    (m/default-schemas)
    ;; utils
    (mu/schemas)))

(mu/optional-keys
 [:map {:registry {::a string?
                   ::b [:merge
                        [:map [::a [:ref ::a]]]
                        [:map [:y string?]]]}}
  ::a
  ::b]
 [::b])</pre></z><z id="t1660119374" t="bortexz Done! https://github.com/metosin/malli/issues/736 Thank you, I’ll rearrange how the registries are defined to make it work"><y>#</y><d>2022-08-10</d><h>08:16</h><r>bortexz</r>Done! <a href="https://github.com/metosin/malli/issues/736" target="_blank">https://github.com/metosin/malli/issues/736</a>
Thank you, I’ll rearrange how the registries are defined to make it work</z><z id="t1660114939" t="ikitommi getting back to computer this week from the long summer vacation, happy to see there the lively discussions here. if there is something clearly not resolved / answered by someone ( 🙇 for everyone for helping others!), you can mention me in the thread. will try to read the new new issues &amp; prs this week."><y>#</y><d>2022-08-10</d><h>07:02</h><w>ikitommi</w>getting back to computer this week from the long summer vacation, happy to see there the lively discussions here. if there is something clearly not resolved / answered by someone (<b>🙇</b> for everyone for helping others!), you can mention me in the thread. will try to read the new new issues &amp; prs this week.</z><z id="t1660128605" t="Akiz Hi, I need to change all keys in the schema from :keyword to :string. Is there an utility for this?"><y>#</y><d>2022-08-10</d><h>10:50</h><w>Akiz</w>Hi, I need to change all keys in the schema from :keyword to :string.
Is there an utility for this?</z><z id="t1660132467" t="ikitommi what do you mean by keys here: map keys in values? or in schemas? something else? example would help"><y>#</y><d>2022-08-10</d><h>11:54</h><r>ikitommi</r>what do you mean by keys here: map keys in values? or in schemas? something else? example would help</z><z id="t1660134364" t="Akiz Sure. Here&apos;s an example. I would like to achieve that I don&apos;t have to define the output-schema manually. In this case it would be enough to replace keyword with string and vice versa. But It would be great if I could somehow use a transformer to transform only schemas. (require &apos;[malli.core :as m]) (require &apos;[malli.transform :as mt]) (def input-schema [:map [:name :string] [:type :keyword]]) (def output-schema [:map [:name :string] [:type :string]]) (defn encode {:malli/schema [:=&gt; [:cat input-schema] output-schema]} [val] (m/encode input-schema val mt/string-transformer))"><y>#</y><d>2022-08-10</d><h>12:26</h><r>Akiz</r>Sure.
Here&apos;s an example. I would like to achieve that I don&apos;t have to define the output-schema manually.
In this case it would be enough to replace keyword with string and vice versa.
But It would be great if I could somehow use a transformer to transform only schemas.

<pre>(require &apos;[malli.core :as m])
(require &apos;[malli.transform :as mt])

(def input-schema [:map [:name :string] [:type :keyword]])
(def output-schema [:map [:name :string] [:type :string]])

(defn encode
  {:malli/schema [:=&gt; [:cat input-schema] output-schema]}
  [val]
  (m/encode input-schema val mt/string-transformer))</pre></z><z id="t1660134498" t="ikitommi would this help: https://github.com/metosin/malli/pull/737"><y>#</y><d>2022-08-10</d><h>12:28</h><r>ikitommi</r>would this help: <a href="https://github.com/metosin/malli/pull/737" target="_blank">https://github.com/metosin/malli/pull/737</a></z><z id="t1660134594" t="Akiz Yes, this is exactly what I tried unsuccessfully to achieve via schema-walk. Thanks!"><y>#</y><d>2022-08-10</d><h>12:29</h><r>Akiz</r>Yes, this is exactly what I tried unsuccessfully to achieve via schema-walk. Thanks!</z><z id="t1660134605" t="ikitommi 👍"><y>#</y><d>2022-08-10</d><h>12:30</h><r>ikitommi</r><b>👍</b></z><z id="t1660135101" t="ikitommi Merged the error-value helpers into master. In case of validation error, you can get just the values in error and/or mask the valid values with something like … , like expound does. Should be useful in pointing out (small set of) errors in huge values. feedback welcome, ping [:attrs {:href &quot;/_/_/users/U3Y18N0UC&quot;}] : (def Address [:map {:closed true} [:id :string] [:tags [:set :keyword]] [:numbers [:sequential :int]] [:address [:map [:street :string] [:city :string] [:zip :int] [:lonlat [:tuple :double :double]]]]]) (def address {:id &quot;Lillan&quot; :EXTRA &quot;KEY&quot; :tags #{:artesan &quot;coffee&quot; :garden &quot;ground&quot;} :numbers (list 1 &quot;2&quot; 3 4 &quot;5&quot; 6 7) :address {:street &quot;Ahlmanintie 29&quot; :zip 33100 :lonlat [61.4858322, &quot;23.7832851,17&quot;]}}) (-&gt; Address (m/explain address) (me/error-value {::me/mask-valid-values &apos;...})) ;{:tags #{&quot;coffee&quot; &quot;ground&quot; ...}, ; :numbers (... &quot;2&quot; ... ... &quot;5&quot; ... ...), ; :address {:lonlat [... &quot;23.7832851,17&quot;], :street ..., :zip ...}, ; :EXTRA &quot;KEY&quot;, ; :id ...}"><y>#</y><d>2022-08-10</d><h>12:38</h><w>ikitommi</w>Merged the error-value helpers into master. In case of  validation error, you can get just the values in error and/or mask the valid values with something like <code>…</code>, like expound does. Should be useful in pointing out (small set of) errors in huge values. feedback welcome, ping <a>@mauricio.szabo</a>:
<pre>(def Address
  [:map {:closed true}
   [:id :string]
   [:tags [:set :keyword]]
   [:numbers [:sequential :int]]
   [:address [:map
              [:street :string]
              [:city :string]
              [:zip :int]
              [:lonlat [:tuple :double :double]]]]])

(def address
  {:id &quot;Lillan&quot;
   :EXTRA &quot;KEY&quot;
   :tags #{:artesan &quot;coffee&quot; :garden &quot;ground&quot;}
   :numbers (list 1 &quot;2&quot; 3 4 &quot;5&quot; 6 7)
   :address {:street &quot;Ahlmanintie 29&quot;
             :zip 33100
             :lonlat [61.4858322, &quot;23.7832851,17&quot;]}})

(-&gt; Address
    (m/explain address)
    (me/error-value {::me/mask-valid-values &apos;...}))
;{:tags #{&quot;coffee&quot; &quot;ground&quot; ...},
; :numbers (... &quot;2&quot; ... ... &quot;5&quot; ... ...),
; :address {:lonlat [... &quot;23.7832851,17&quot;], :street ..., :zip ...},
; :EXTRA &quot;KEY&quot;,
; :id ...}</pre></z><z id="t1660135172" t="ikitommi next thing would be to integrate this into pretty explaning. I think it would be good to mask out valid values by default? and the options being: 1. mask valid values (default) 2. show full values 3. don’t show value at all"><y>#</y><d>2022-08-10</d><h>12:39</h><r>ikitommi</r>next thing would be to integrate this into pretty explaning. I think it would be good to mask out valid values by default? and the options being:
1. mask valid values (default)
2. show full values
3. don’t show value at all</z><z id="t1660135290" t="ikitommi the tests also show how to do the same thing for individual errors. e.g. present errors one-by-one - like expound does."><y>#</y><d>2022-08-10</d><h>12:41</h><r>ikitommi</r>the tests also show how to do the same thing for individual errors. e.g. present errors one-by-one - like expound does.</z><z id="t1660137352" t="mauricio.szabo Yes, I think masking valid values by default is good - it seems &quot;prettier&quot; this way, and makes for less noise IMHO"><y>#</y><d>2022-08-10</d><h>13:15</h><r>mauricio.szabo</r>Yes, I think masking valid values by default is good - it seems &quot;prettier&quot; this way, and makes for less noise IMHO</z><z id="t1660142924" t="ikitommi https://github.com/metosin/malli/pull/738 , feedback and testing most welcome: (malli.dev.pretty/explain [:map [:id :int] [:tags [:set :keyword]] [:address [:map [:street :string] [:city :string] [:zip :int] [:lonlat [:tuple :double :double]]]]] {:id &quot;123&quot; :EXTRA &quot;KEY&quot; :tags #{:artesan &quot;coffee&quot; :garden} :address {:street &quot;Ahlmanintie 29&quot; :city &quot;Tampere&quot; :zip 33100 :lonlat [61.4858322, 23.7832851]}}) =&gt;"><y>#</y><d>2022-08-10</d><h>14:48</h><w>ikitommi</w><a href="https://github.com/metosin/malli/pull/738" target="_blank">https://github.com/metosin/malli/pull/738</a>, feedback and testing most welcome:
<pre>(malli.dev.pretty/explain
 [:map
  [:id :int]
  [:tags [:set :keyword]]
  [:address [:map
             [:street :string]
             [:city :string]
             [:zip :int]
             [:lonlat [:tuple :double :double]]]]]
 {:id &quot;123&quot;
  :EXTRA &quot;KEY&quot;
  :tags #{:artesan &quot;coffee&quot; :garden}
  :address {:street &quot;Ahlmanintie 29&quot;
            :city &quot;Tampere&quot;
            :zip 33100
            :lonlat [61.4858322, 23.7832851]}})</pre>
=&gt;</z><z id="t1660154847" t="Mateo Difranco Awesome!"><y>#</y><d>2022-08-10</d><h>18:07</h><r>Mateo Difranco</r>Awesome!</z><z id="t1660210467" t="ikitommi ^:-- if someone can show an real-life example where the value masking is still bad, please share (privately ok too). I guess if one has huge nested maps, masking each irrelevant key separately might still cause large values. Or a list of 100 entries with the last one in failure would cause 99 … s, which might not be best. For maps, all the irrelevant keys could be optionally accumulated into single entry on … as both key and value and for sequences, a …99 to show how many valids there are."><y>#</y><d>2022-08-11</d><h>09:34</h><w>ikitommi</w>^:-- if someone can show an real-life example where the value masking is still bad, please share (privately ok too). I guess if one has huge nested maps, masking each irrelevant key separately might still cause large values. Or a list of 100 entries with the last one in failure would cause 99 <code>…</code>s, which might not be best. For maps, all the irrelevant keys could be optionally accumulated into single entry on <code>…</code> as both key and value and for sequences, a <code>…99</code> to show how many valids there are.</z><z id="t1660246446" t="dangercoder Hi, great work on Malli! I’m trying to figure out how I can use malli without duplicating attributes. Is the “What I want” syntax possible in some way? ;; What I have [:map [::order-id :int] [::order-multiplier :int] [::order-amount decimal?]] ;; What I want [:map [::order-id] [::order-multiplier] [::order-amount]] (m/validate ::order-id &quot;123&quot;) ;; =&gt; false"><y>#</y><d>2022-08-11</d><h>19:34</h><w>dangercoder</w>Hi, great work on Malli! I’m trying to figure out how I can use malli without duplicating attributes. Is the “What I want” syntax possible in some way?

<pre>;; What I have
[:map
 [::order-id :int]
 [::order-multiplier :int]
 [::order-amount decimal?]]

;; What I want
[:map
 [::order-id]
 [::order-multiplier]
 [::order-amount]]

(m/validate ::order-id &quot;123&quot;)
;; =&gt; false</pre></z><z id="t1660246866" t="valtteri You can define a registry and register your schemas there. Here’s an inline example (m/validate ::order-id &quot;123&quot; {:registry (merge (m/default-schemas) {::order-id :int ::order-multiplier :int ::order-amount decimal?})})"><y>#</y><d>2022-08-11</d><h>19:41</h><r>valtteri</r>You can define a registry and register your schemas there. Here’s an inline example
<pre>(m/validate ::order-id &quot;123&quot; {:registry (merge
                                         (m/default-schemas)
                                         {::order-id :int
                                          ::order-multiplier :int
                                          ::order-amount decimal?})})</pre></z><z id="t1660246921" t="valtteri More info how to work with registries here https://github.com/metosin/malli#schema-registry"><y>#</y><d>2022-08-11</d><h>19:42</h><r>valtteri</r>More info how to work with registries here <a href="https://github.com/metosin/malli#schema-registry" target="_blank">https://github.com/metosin/malli#schema-registry</a></z><z id="t1660246983" t="dangercoder Thanks a lot for the answer, cheers!"><y>#</y><d>2022-08-11</d><h>19:43</h><r>dangercoder</r>Thanks a lot for the answer, cheers!</z><z id="t1660248191" t="dangercoder Cool thing. I created a custom “register function”. (s/register ::api-key [:string {:min 1}]) in IntelliJ/cursive i resolved my function as clojure.spec.alpha/def — this way I can jump to the schema-definition of a namespaced keyword if there is a register call. 😄"><y>#</y><d>2022-08-11</d><h>20:03</h><r>dangercoder</r>Cool thing. I created a custom “register function”.

<pre>(s/register ::api-key [:string {:min 1}])</pre>
in IntelliJ/cursive i resolved my function as clojure.spec.alpha/def — this way I can jump to the schema-definition of a namespaced keyword if there is a register call. <b>😄</b></z><z id="t1660248206" t="dangercoder 🤯"><y>#</y><d>2022-08-11</d><h>20:03</h><r>dangercoder</r><b>🤯</b></z><z id="t1660249625" t="valtteri Cool!"><y>#</y><d>2022-08-11</d><h>20:27</h><r>valtteri</r>Cool!</z><z id="t1660558812" t="pinkfrog Hi, running this example I got sci not available (m/decode [string? {:decode/string &apos;str/upper-case}] &quot;kerran&quot; mt/string-transformer) ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). ; :malli.core/sci-not-available {:code str/upper-case}"><y>#</y><d>2022-08-15</d><h>10:20</h><w>pinkfrog</w>Hi, running this example I got sci not available
<pre>(m/decode
  [string? {:decode/string &apos;str/upper-case}]
  &quot;kerran&quot; mt/string-transformer)</pre>
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
; :malli.core/sci-not-available {:code str/upper-case}</z><z id="t1660558860" t="borkdude I think you should include SCI as an optional dependency yourself. If you don&apos;t use the quotes, you won&apos;t need SCI"><y>#</y><d>2022-08-15</d><h>10:21</h><w>borkdude</w>I think you should include SCI as an optional dependency yourself. If you don&apos;t use the quotes, you won&apos;t need SCI</z><z id="t1660559943" t="pinkfrog Thanks. Dunno what’s the added benefits of sci."><y>#</y><d>2022-08-15</d><h>10:39</h><r>pinkfrog</r>Thanks. Dunno what’s the added benefits of sci.</z><z id="t1660560010" t="borkdude The benefit of SCI would be if you would like to serialize your schemas to the front-end"><y>#</y><d>2022-08-15</d><h>10:40</h><r>borkdude</r>The benefit of SCI would be if you would like to serialize your schemas to the front-end</z><z id="t1660560018" t="borkdude The quote is only needed for serialization"><y>#</y><d>2022-08-15</d><h>10:40</h><r>borkdude</r>The quote is only needed for serialization</z><z id="t1660560151" t="pinkfrog Then why not a custom export function to convert function to its symbol names. I am not quite getting the actual benefits compared of importing sci here."><y>#</y><d>2022-08-15</d><h>10:42</h><r>pinkfrog</r>Then why not a custom export function to convert function to its symbol names. I am not quite getting the actual benefits compared of importing sci here.</z><z id="t1660560211" t="borkdude Because just a symbol won&apos;t give you evaluation in the client"><y>#</y><d>2022-08-15</d><h>10:43</h><r>borkdude</r>Because just a symbol won&apos;t give you evaluation in the client</z><z id="t1660560390" t="pinkfrog When client are you referring to the js environment? Also, pardon me, are we assuming sci could run on js (given the recent work of nbb and such)"><y>#</y><d>2022-08-15</d><h>10:46</h><r>pinkfrog</r>When client are you referring to the js environment? Also, pardon me, are we assuming sci could run on js (given the recent work of nbb and such)</z><z id="t1660560409" t="borkdude yes, JavaScript"><y>#</y><d>2022-08-15</d><h>10:46</h><r>borkdude</r>yes, JavaScript</z><z id="t1660560449" t="borkdude you can include malli on the client side and then use SCI to evaluate your schemas and get exactly the same validation as on the server"><y>#</y><d>2022-08-15</d><h>10:47</h><r>borkdude</r>you can include malli on the client side and then use SCI to evaluate your schemas and get exactly the same validation as on the server</z><z id="t1660560541" t="borkdude So you can send your schema&apos;s dynamically to the client"><y>#</y><d>2022-08-15</d><h>10:49</h><r>borkdude</r>So you can send your schema&apos;s dynamically to the client</z><z id="t1660560706" t="pinkfrog &gt; So you can send your schema’s dynamically to the client That is so futuristic, that I am not sure I am ready."><y>#</y><d>2022-08-15</d><h>10:51</h><r>pinkfrog</r>&gt;  So you can send your schema’s dynamically to the client
That is so futuristic, that I am not sure I am ready.</z><z id="t1660562191" t="valtteri In the latest version of the README the examples have been changed to not require SCI unless mentioned."><y>#</y><d>2022-08-15</d><h>11:16</h><r>valtteri</r>In the latest version of the README the examples have been changed to not require SCI unless mentioned.</z><z id="t1660562228" t="valtteri I think this particular one is now (m/decode [string? {:decode/string clojure.string/upper-case}] &quot;kerran&quot; mt/string-transformer) ; =&gt; &quot;KERRAN&quot;"><y>#</y><d>2022-08-15</d><h>11:17</h><r>valtteri</r>I think this particular one is now
<pre>(m/decode
  [string? {:decode/string clojure.string/upper-case}]
  &quot;kerran&quot; mt/string-transformer)
; =&gt; &quot;KERRAN&quot;</pre></z><z id="t1660560026" t="pinkfrog I wonder why https://cljdoc.org/d/metosin/malli/0.8.9/doc/readme#value-transformation:~:text=Adding%20optional%20keys%20too%20via%20%3A%3Amt/add%2Doptional%2Dkeys%20option%3A . here uses qualified keyword, :: mt/add-optional-keys, but others like :decode/encode does not use qualfied ones"><y>#</y><d>2022-08-15</d><h>10:40</h><w>pinkfrog</w>I wonder why <a href="https://cljdoc.org/d/metosin/malli/0.8.9/doc/readme#value-transformation:~:text=Adding%20optional%20keys%20too%20via%20%3A%3Amt/add%2Doptional%2Dkeys%20option%3A" target="_blank">https://cljdoc.org/d/metosin/malli/0.8.9/doc/readme#value-transformation:~:text=Adding%20optional%20keys%20too%20via%20%3A%3Amt/add%2Doptional%2Dkeys%20option%3A</a>. here uses qualified keyword, <b>::</b>mt/add-optional-keys, but others like :decode/encode does not use qualfied ones</z><z id="t1660565386" t="ikitommi Malli started with simple keywords everywhere, but as the options are passed everywhere, this doesn’t scale well -&gt; moved to use qualified keywords. Could clean up all options for 1.0.0?"><y>#</y><d>2022-08-15</d><h>12:09</h><r>ikitommi</r>Malli started with simple keywords everywhere, but as the options are passed everywhere, this doesn’t scale well -&gt; moved to use qualified keywords. Could clean up all options for 1.0.0?</z><z id="t1660565483" t="ikitommi One ideas was to have default global options map, could be read from EDN-file, set like the registry etc and which could be tune all different parts of the system. Not there yet."><y>#</y><d>2022-08-15</d><h>12:11</h><r>ikitommi</r>One ideas was to have default global options map, could be read from EDN-file, set like the registry etc and which could be tune all different parts of the system. Not there yet.</z><z id="t1660570635" t="pinkfrog I’d like to learn more on the scale well part. When I am writing something only used internally, I will use qualified keywords, because this helps jump to usage, bulk rename, etc. But when I am providing some opts map for the user, I will use simple keyword. Mandating qualified keywords kinda complicates the opts map."><y>#</y><d>2022-08-15</d><h>13:37</h><r>pinkfrog</r>I’d like to learn more on the <code>scale well</code> part.
When I am writing something only used internally, I will use qualified keywords, because this helps jump to usage, bulk rename, etc.
But when I am providing some opts map for the user, I will use simple keyword. Mandating qualified keywords kinda complicates the opts map.</z><z id="t1660577611" t="ikitommi Malli options has :`registry` being the only reserved simple key. There are some qualified keys used in core like ::m/walk-entry-vals , which are relevant only in a special use case (here, using m/walk ). If we had two option arguments (&quot;how the system is configured&quot; and &quot;how this use case should work&quot;) we could use simple keys in both. Now, it&apos;s just one arg, and I think it&apos;s better to namespace the latter keys to avoid conflicts and to document which ns owns them. You can merge &apos;em all into one map and pass it everywhere."><y>#</y><d>2022-08-15</d><h>15:33</h><r>ikitommi</r>Malli options has  :`registry` being the only reserved simple key. There are some qualified keys used in core like <code>::m/walk-entry-vals</code>, which are relevant only in a special use case  (here, using <code>m/walk</code>). If we had two option arguments (&quot;how the system is configured&quot; and &quot;how this use case should work&quot;) we could use simple keys in both. Now, it&apos;s just one arg, and I think it&apos;s better to namespace the latter keys to avoid conflicts and to document which ns owns them. You can merge &apos;em all into one map and pass it everywhere.</z><z id="t1660577711" t="ikitommi I recall there are two open issues related to how to manage the global options better. Both would introduce a breaking change in the public APIs."><y>#</y><d>2022-08-15</d><h>15:35</h><r>ikitommi</r>I recall there are two open issues related to how to manage the global options better. Both would introduce a breaking change in the public APIs.</z><z id="t1660577768" t="ikitommi I would like to remove the &quot;pass in optional options arg to every function&quot;, have ideas on that, but, need to think about it first."><y>#</y><d>2022-08-15</d><h>15:36</h><r>ikitommi</r>I would like to remove the &quot;pass in optional options arg to every function&quot;, have ideas on that, but, need to think about it first.</z><z id="t1660577792" t="ikitommi Here is a good example on bad and good option naming: https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L332-L361"><y>#</y><d>2022-08-15</d><h>15:36</h><r>ikitommi</r>Here is a good example on bad and good option naming: <a href="https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L332-L361" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/error.cljc#L332-L361</a></z><z id="t1660746641" t="afleck is there an “exclusive or” way of combining schemas? say I have (def foo-schema [:map [:id string?] [:foo number?]]) (def bar-schema [:map [:id string?] [:bar number?]]) (def foobar-schema [:orn [:foo foo-schema] [:bar bar-schema]]) if I do (me/humanize (m/explain foobar-schema {:id :k :foo 3})) I get {:id [&quot;should be a string&quot; &quot;should be a string&quot;], :bar [&quot;missing required key&quot;]} but ideally I only want to see a single :id [&quot;should be a string&quot;] error. I guess put more abstractly I’m wondering if there’s a way to know “minimal number of problems that if fixed would make the value valid”"><y>#</y><d>2022-08-17</d><h>14:30</h><w>afleck</w>is there an “exclusive or” way of combining schemas? say I have
<pre>(def foo-schema [:map [:id string?] [:foo number?]])
(def bar-schema [:map [:id string?] [:bar number?]])

(def foobar-schema [:orn [:foo foo-schema] [:bar bar-schema]])</pre>
if I do
<pre>(me/humanize (m/explain foobar-schema {:id :k :foo 3}))</pre>
I get
<pre>{:id [&quot;should be a string&quot; &quot;should be a string&quot;],
 :bar [&quot;missing required key&quot;]}</pre>
but ideally I only want to see a single <code>:id [&quot;should be a string&quot;]</code> error. I guess put more abstractly I’m wondering if there’s a way to know “minimal number of problems that if fixed would make the value valid”</z><z id="t1660747416" t="afleck hmm seeming like maybe a multi schema could potentially be helpful"><y>#</y><d>2022-08-17</d><h>14:43</h><r>afleck</r>hmm seeming like maybe a multi schema could potentially be helpful</z><z id="t1660841260" t="ikitommi :multi is good option here"><y>#</y><d>2022-08-18</d><h>16:47</h><r>ikitommi</r><code>:multi</code> is good option here</z><z id="t1660765961" t="Colin P. Hill Is this a bug, or am I misunderstanding something? :thinking_face: It looks like it&apos;s complaining about the :=&gt; schema only having one child, when it clearly has two. (defn test-fn {:malli/schema [:=&gt; [:cat :int] [:int]]} [n] n) =&gt; #&apos;user/test-fn (require &apos;[malli.dev :as dev]) =&gt; nil (dev/start!) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136). :malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}"><y>#</y><d>2022-08-17</d><h>19:52</h><w>Colin P. Hill</w>Is this a bug, or am I misunderstanding something? <b>:thinking_face:</b> It looks like it&apos;s complaining about the <code>:=&gt;</code> schema only having one child, when it clearly has two.
<pre>(defn test-fn
    {:malli/schema [:=&gt;
                    [:cat :int]
                    [:int]]}
    [n]
    n)
=&gt; #&apos;user/test-fn
(require &apos;[malli.dev :as dev])
=&gt; nil
(dev/start!)
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:136).
:malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}</pre></z><z id="t1660766882" t="NoahTheDuke looks like it&apos;s discarding :int , and then discarding the empty vector too? what happens if you change it to int? ?"><y>#</y><d>2022-08-17</d><h>20:08</h><r>NoahTheDuke</r>looks like it&apos;s discarding <code>:int</code> , and then discarding the empty vector too? what happens if you change it to <code>int?</code>?</z><z id="t1660766937" t="Colin P. Hill Identical error"><y>#</y><d>2022-08-17</d><h>20:08</h><r>Colin P. Hill</r>Identical error</z><z id="t1660830955" t="NoahTheDuke sorry to not be more help, that&apos;s super weird"><y>#</y><d>2022-08-18</d><h>13:55</h><r>NoahTheDuke</r>sorry to not be more help, that&apos;s super weird</z><z id="t1660831029" t="Colin P. Hill Version 0.8.4, in case anyone wants to see if they can reproduce it"><y>#</y><d>2022-08-18</d><h>13:57</h><r>Colin P. Hill</r>Version 0.8.4, in case anyone wants to see if they can reproduce it</z><z id="t1660831193" t="NoahTheDuke can you share the full stack trace? maybe that will help"><y>#</y><d>2022-08-18</d><h>13:59</h><r>NoahTheDuke</r>can you share the full stack trace? maybe that will help</z><z id="t1660831481" t="Colin P. Hill #error { :cause &quot;:malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}&quot; :data {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}} :via [{:type clojure.lang.ExceptionInfo :message &quot;:malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}&quot; :data {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}} :at [malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 136]}] :trace [[malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 136] [malli.core$_fail_BANG_ invoke &quot;core.cljc&quot; 134] [malli.core$_check_children_BANG_ invokeStatic &quot;core.cljc&quot; 162] [malli.core$_check_children_BANG_ invoke &quot;core.cljc&quot; 154] [malli.core$__EQ__GT$reify__7246 _into_schema &quot;core.cljc&quot; 1694] [malli.core$into_schema invokeStatic &quot;core.cljc&quot; 1921] [malli.core$into_schema invoke &quot;core.cljc&quot; 1912] [malli.core$schema invokeStatic &quot;core.cljc&quot; 1982] [malli.core$schema invoke &quot;core.cljc&quot; 1963] [malli.core$function_schema invokeStatic &quot;core.cljc&quot; 2390] [malli.core$function_schema invoke &quot;core.cljc&quot; 2387] [malli.core$function_schema invokeStatic &quot;core.cljc&quot; 2388] [malli.core$function_schema invoke &quot;core.cljc&quot; 2387] [malli.core$_register_function_schema_BANG_ invokeStatic &quot;core.cljc&quot; 2398] [malli.core$_register_function_schema_BANG_ invoke &quot;core.cljc&quot; 2395] [malli.core$_register_function_schema_BANG_ invokeStatic &quot;core.cljc&quot; 2396] [malli.core$_register_function_schema_BANG_ invoke &quot;core.cljc&quot; 2395] [malli.instrument$_collect_BANG_ invokeStatic &quot;instrument.clj&quot; 41] [malli.instrument$_collect_BANG_ invoke &quot;instrument.clj&quot; 39] [malli.instrument$collect_BANG_$fn__15014 invoke &quot;instrument.clj&quot; 70] [clojure.core.protocols$iter_reduce invokeStatic &quot;protocols.clj&quot; 49] [clojure.core.protocols$fn__8238 invokeStatic &quot;protocols.clj&quot; 75] [clojure.core.protocols$fn__8238 invoke &quot;protocols.clj&quot; 75] [clojure.core.protocols$fn__8178$G__8173__8191 invoke &quot;protocols.clj&quot; 13] [clojure.core$reduce invokeStatic &quot;core.clj&quot; 6886] [clojure.core$reduce invoke &quot;core.clj&quot; 6868] [malli.instrument$collect_BANG_ invokeStatic &quot;instrument.clj&quot; 70] [malli.instrument$collect_BANG_ invoke &quot;instrument.clj&quot; 58] [malli.dev$start_BANG_ invokeStatic &quot;dev.clj&quot; 23] [malli.dev$start_BANG_ invoke &quot;dev.clj&quot; 15] [malli.dev$start_BANG_ invokeStatic &quot;dev.clj&quot; 20] [malli.dev$start_BANG_ invoke &quot;dev.clj&quot; 15] [user$eval15353 invokeStatic &quot;scratch_16.clj&quot; 2] [user$eval15353 invoke &quot;scratch_16.clj&quot; 10] [clojure.lang.Compiler eval &quot;Compiler.java&quot; 7194] [clojure.lang.Compiler eval &quot;Compiler.java&quot; 7149] [clojure.core$eval invokeStatic &quot;core.clj&quot; 3215] [clojure.core$eval invoke &quot;core.clj&quot; 3211] [clojure.main$repl$read_eval_print__9206$fn__9209 invoke &quot;main.clj&quot; 437] [clojure.main$repl$read_eval_print__9206 invoke &quot;main.clj&quot; 437] [clojure.main$repl$fn__9215 invoke &quot;main.clj&quot; 458] [clojure.main$repl invokeStatic &quot;main.clj&quot; 458] [clojure.main$repl doInvoke &quot;main.clj&quot; 368] [clojure.lang.RestFn invoke &quot;RestFn.java&quot; 1523] [nrepl.middleware.interruptible_eval$evaluate invokeStatic &quot;interruptible_eval.clj&quot; 79] [nrepl.middleware.interruptible_eval$evaluate invoke &quot;interruptible_eval.clj&quot; 55] [nrepl.middleware.interruptible_eval$interruptible_eval$fn__10823$fn__10827 invoke &quot;interruptible_eval.clj&quot; 142] [clojure.lang.AFn run &quot;AFn.java&quot; 22] [nrepl.middleware.session$session_exec$main_loop__10925$fn__10929 invoke &quot;session.clj&quot; 171] [nrepl.middleware.session$session_exec$main_loop__10925 invoke &quot;session.clj&quot; 170] [clojure.lang.AFn run &quot;AFn.java&quot; 22] [java.lang.Thread run &quot;Thread.java&quot; 831]]}"><y>#</y><d>2022-08-18</d><h>14:04</h><r>Colin P. Hill</r><pre>#error {
 :cause &quot;:malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}&quot;
 :data {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}}
 :via
 [{:type clojure.lang.ExceptionInfo
   :message &quot;:malli.core/child-error {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}&quot;
   :data {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :=&gt;, :properties nil, :children [[:cat]], :min 2, :max 2}}
   :at [malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 136]}]
 :trace
 [[malli.core$_fail_BANG_ invokeStatic &quot;core.cljc&quot; 136]
  [malli.core$_fail_BANG_ invoke &quot;core.cljc&quot; 134]
  [malli.core$_check_children_BANG_ invokeStatic &quot;core.cljc&quot; 162]
  [malli.core$_check_children_BANG_ invoke &quot;core.cljc&quot; 154]
  [malli.core$__EQ__GT$reify__7246 _into_schema &quot;core.cljc&quot; 1694]
  [malli.core$into_schema invokeStatic &quot;core.cljc&quot; 1921]
  [malli.core$into_schema invoke &quot;core.cljc&quot; 1912]
  [malli.core$schema invokeStatic &quot;core.cljc&quot; 1982]
  [malli.core$schema invoke &quot;core.cljc&quot; 1963]
  [malli.core$function_schema invokeStatic &quot;core.cljc&quot; 2390]
  [malli.core$function_schema invoke &quot;core.cljc&quot; 2387]
  [malli.core$function_schema invokeStatic &quot;core.cljc&quot; 2388]
  [malli.core$function_schema invoke &quot;core.cljc&quot; 2387]
  [malli.core$_register_function_schema_BANG_ invokeStatic &quot;core.cljc&quot; 2398]
  [malli.core$_register_function_schema_BANG_ invoke &quot;core.cljc&quot; 2395]
  [malli.core$_register_function_schema_BANG_ invokeStatic &quot;core.cljc&quot; 2396]
  [malli.core$_register_function_schema_BANG_ invoke &quot;core.cljc&quot; 2395]
  [malli.instrument$_collect_BANG_ invokeStatic &quot;instrument.clj&quot; 41]
  [malli.instrument$_collect_BANG_ invoke &quot;instrument.clj&quot; 39]
  [malli.instrument$collect_BANG_$fn__15014 invoke &quot;instrument.clj&quot; 70]
  [clojure.core.protocols$iter_reduce invokeStatic &quot;protocols.clj&quot; 49]
  [clojure.core.protocols$fn__8238 invokeStatic &quot;protocols.clj&quot; 75]
  [clojure.core.protocols$fn__8238 invoke &quot;protocols.clj&quot; 75]
  [clojure.core.protocols$fn__8178$G__8173__8191 invoke &quot;protocols.clj&quot; 13]
  [clojure.core$reduce invokeStatic &quot;core.clj&quot; 6886]
  [clojure.core$reduce invoke &quot;core.clj&quot; 6868]
  [malli.instrument$collect_BANG_ invokeStatic &quot;instrument.clj&quot; 70]
  [malli.instrument$collect_BANG_ invoke &quot;instrument.clj&quot; 58]
  [malli.dev$start_BANG_ invokeStatic &quot;dev.clj&quot; 23]
  [malli.dev$start_BANG_ invoke &quot;dev.clj&quot; 15]
  [malli.dev$start_BANG_ invokeStatic &quot;dev.clj&quot; 20]
  [malli.dev$start_BANG_ invoke &quot;dev.clj&quot; 15]
  [user$eval15353 invokeStatic &quot;scratch_16.clj&quot; 2]
  [user$eval15353 invoke &quot;scratch_16.clj&quot; 10]
  [clojure.lang.Compiler eval &quot;Compiler.java&quot; 7194]
  [clojure.lang.Compiler eval &quot;Compiler.java&quot; 7149]
  [clojure.core$eval invokeStatic &quot;core.clj&quot; 3215]
  [clojure.core$eval invoke &quot;core.clj&quot; 3211]
  [clojure.main$repl$read_eval_print__9206$fn__9209 invoke &quot;main.clj&quot; 437]
  [clojure.main$repl$read_eval_print__9206 invoke &quot;main.clj&quot; 437]
  [clojure.main$repl$fn__9215 invoke &quot;main.clj&quot; 458]
  [clojure.main$repl invokeStatic &quot;main.clj&quot; 458]
  [clojure.main$repl doInvoke &quot;main.clj&quot; 368]
  [clojure.lang.RestFn invoke &quot;RestFn.java&quot; 1523]
  [nrepl.middleware.interruptible_eval$evaluate invokeStatic &quot;interruptible_eval.clj&quot; 79]
  [nrepl.middleware.interruptible_eval$evaluate invoke &quot;interruptible_eval.clj&quot; 55]
  [nrepl.middleware.interruptible_eval$interruptible_eval$fn__10823$fn__10827 invoke &quot;interruptible_eval.clj&quot; 142]
  [clojure.lang.AFn run &quot;AFn.java&quot; 22]
  [nrepl.middleware.session$session_exec$main_loop__10925$fn__10929 invoke &quot;session.clj&quot; 171]
  [nrepl.middleware.session$session_exec$main_loop__10925 invoke &quot;session.clj&quot; 170]
  [clojure.lang.AFn run &quot;AFn.java&quot; 22]
  [java.lang.Thread run &quot;Thread.java&quot; 831]]}</pre></z><z id="t1660832175" t="Colin P. Hill Issue disappears when I bump to version 0.8.9, which I don&apos;t see any reason not to do, so I suppose it&apos;s immaterial"><y>#</y><d>2022-08-18</d><h>14:16</h><r>Colin P. Hill</r>Issue disappears when I bump to version 0.8.9, which I don&apos;t see any reason not to do, so I suppose it&apos;s immaterial</z><z id="t1660832229" t="Colin P. Hill Though I don&apos;t see anything about it in the change notes so maybe it was accidentally fixed and could still use a regression test, idk"><y>#</y><d>2022-08-18</d><h>14:17</h><r>Colin P. Hill</r>Though I don&apos;t see anything about it in the change notes so maybe it was accidentally fixed and could still use a regression test, idk</z><z id="t1660833121" t="NoahTheDuke i bet this is it: https://github.com/metosin/malli/pull/690"><y>#</y><d>2022-08-18</d><h>14:32</h><r>NoahTheDuke</r>i bet this is it: <a href="https://github.com/metosin/malli/pull/690" target="_blank">https://github.com/metosin/malli/pull/690</a></z><z id="t1660833165" t="Colin P. Hill seems likely"><y>#</y><d>2022-08-18</d><h>14:32</h><r>Colin P. Hill</r>seems likely</z><z id="t1660833267" t="NoahTheDuke glad upgrading is the solution, that&apos;s a very easy solution lol"><y>#</y><d>2022-08-18</d><h>14:34</h><r>NoahTheDuke</r>glad upgrading is the solution, that&apos;s a very easy solution lol</z><z id="t1660919195" t="ikitommi Hi, is there an example cljs-project with shadow-cljs + malli.dev instrumentation enabled? Starting to port a large app from spec to malli, interested in good practices on how to do dev/prod separation, pretty printing errors in html (for react error boundaries on dev errors + enabling sci-powered code editing on the browser)."><y>#</y><d>2022-08-19</d><h>14:26</h><w>ikitommi</w>Hi, is there an example cljs-project with shadow-cljs + malli.dev instrumentation enabled? Starting to port a large app from spec to malli, interested in good practices on how to do dev/prod separation, pretty printing errors in html (for react error boundaries on dev errors + enabling sci-powered code editing on the browser).</z><z id="t1660919410" t="ikitommi Goals: • great DX • clear separation of dev &amp; prod validation • tools for building dynamic schema systems • small bundle size"><y>#</y><d>2022-08-19</d><h>14:30</h><r>ikitommi</r>Goals:
• great DX
• clear separation of dev &amp; prod validation
• tools for building dynamic schema systems
• small bundle size</z><z id="t1660919506" t="borkdude for SCI-powered code editing I would take a look at https://nextjournal.github.io/clojure-mode/"><y>#</y><d>2022-08-19</d><h>14:31</h><r>borkdude</r>for SCI-powered code editing I would take a look at <a href="https://nextjournal.github.io/clojure-mode/" target="_blank">https://nextjournal.github.io/clojure-mode/</a></z><z id="t1661087575" t="ikitommi that&apos;s great. Not a &quot;dependency + one-liner to get an editor&quot;, but awesome in features etc."><y>#</y><d>2022-08-21</d><h>13:12</h><r>ikitommi</r>that&apos;s great. Not a &quot;dependency + one-liner to get an editor&quot;, but awesome in features etc.</z><z id="t1661087691" t="ikitommi But, is there a simple (read-only) clojure code formatter for html? Malli error pretty printing is basically a sequence of text blocks and code blocks."><y>#</y><d>2022-08-21</d><h>13:14</h><r>ikitommi</r>But, is there a simple (read-only) clojure code formatter for html? Malli error pretty printing is basically a sequence of text blocks and code blocks.</z><z id="t1661182955" t="dvingo I started playing around with a setup but it&apos;s closed source at the moment. I&apos;d like some more details on what is meant by bullet 2 - separation of dev and prod. and for bullet 3 what is dynamic schema? constructing schema at runtime? based on data? for point 4, the entry namespace in my project includes https://malli.dev which will increase bundle size. With shadow-cljs I think one way to solve this is with ns-aliases but I haven&apos;t confirmed this works. I fear you may have to use 2 different builds one for dev one for prod. I&apos;m not sure about great DX - I haven&apos;t used the cljs instrumentation on a large project, I think https://github.com/CrypticButter/snoop may offer better DX but has tradeoffs of its own - using new syntax for defn mainly. The reason is that the intsrumentation macro produces large amounts of code (a set! call for every instrumented fn plus the code to filter every ns + fn in them) so on large codebases I can foresee this being prohibitive perf-wise. I&apos;ve thought a little bit about a shadow-cljs server plugin/extension that would track which functions are instrumented and which are stale, which would have to happen per client (open browser window running the app). Then the macro would have access to this state to only output instrumentation code for stale functions. I&apos;m not sure how feasible that is though, or how much time it would take, or how maintainable it would be."><y>#</y><d>2022-08-22</d><h>15:42</h><r>dvingo</r>I started playing around with a setup but it&apos;s closed source at the moment.
I&apos;d like some more details on what is meant by bullet 2 - separation of dev and prod.
and for bullet 3 what is dynamic schema? constructing schema at runtime? based on data?

for point 4, the entry namespace in my project includes <a href="https://malli.dev" target="_blank">https://malli.dev</a> which will increase bundle size. With shadow-cljs I think one way to solve this is with <code>ns-aliases</code> but I haven&apos;t confirmed this works. I fear you may have to use 2 different builds one for dev one for prod.

I&apos;m not sure about great DX - I haven&apos;t used the cljs instrumentation on a large project, I think <a href="https://github.com/CrypticButter/snoop" target="_blank">https://github.com/CrypticButter/snoop</a> may offer better DX but has tradeoffs of its own - using new syntax for defn mainly.
The reason is that the intsrumentation macro produces large amounts of code (a <code>set!</code> call for every instrumented fn plus the code to filter every ns + fn in them) so on large codebases I can foresee this being prohibitive perf-wise. I&apos;ve thought a little bit about a shadow-cljs server plugin/extension that would track which functions are instrumented and which are stale, which would have to happen per client (open browser window running the app). Then the macro would have access to this state to only output instrumentation code for stale functions. I&apos;m not sure how feasible that is though, or how much time it would take, or how maintainable it would be.</z><z id="t1661182987" t="dvingo [:attrs {:href &quot;/_/_/users/U21QNFC5C&quot;}] I think has been using the cljs instrumentation - any insights?"><y>#</y><d>2022-08-22</d><h>15:43</h><r>dvingo</r><a>@U21QNFC5C</a> I think has been using the cljs instrumentation - any insights?</z><z id="t1661183247" t="ingesol This is funny, was about to post a couple of questions about friction with tooling 🙂"><y>#</y><d>2022-08-22</d><h>15:47</h><r>ingesol</r>This is funny, was about to post a couple of questions about friction with tooling <b>🙂</b></z><z id="t1661183507" t="ingesol Maybe a bit into the weeds, but there are 2 issues holding us back from a full rollout right now: • If you remove :malli/schema metadata from a function, it remains instrumented • We are relying on function identity, in a way that is not easily changed, and that is broken by the wrapping function added in -instrument . I think we have added the setup required, specifically: • In shadow init, call md/start! before mounting our reagent comp • In after-load, call md/start! This is supposed to be sufficient according to the docs, but nothing is unstrumented until we call md/stop!"><y>#</y><d>2022-08-22</d><h>15:51</h><r>ingesol</r>Maybe a bit into the weeds, but there are 2 issues holding us back from a full rollout right now:
• If you remove <code>:malli/schema</code> metadata from a function, it remains instrumented
• We are relying on function identity, in a way that is not easily changed, and that is broken by the wrapping function added in <code>-instrument</code>. 
I think we have added the setup required, specifically:
• In shadow init, call <code>md/start!</code> before mounting our reagent comp
• In after-load, call <code>md/start!</code>
This is supposed to be sufficient according to the docs, but nothing is unstrumented until we call <code>md/stop!</code></z><z id="t1661185375" t="ingesol Also, all those ..instrumented ns.here is not very nice when there are tens and hundreds of them. Should ideally be grouped or optional."><y>#</y><d>2022-08-22</d><h>16:22</h><r>ingesol</r>Also, all those <code>..instrumented ns.here</code> is not very nice when there are tens and hundreds of them. Should ideally be grouped or optional.</z><z id="t1661188208" t="ingesol https://github.com/metosin/malli/issues/744"><y>#</y><d>2022-08-22</d><h>17:10</h><r>ingesol</r><a href="https://github.com/metosin/malli/issues/744" target="_blank">https://github.com/metosin/malli/issues/744</a></z><z id="t1663261023" t="ingesol Another issue posted on CLJS instrumentation https://github.com/metosin/malli/issues/752"><y>#</y><d>2022-09-15</d><h>16:57</h><r>ingesol</r>Another issue posted on CLJS instrumentation <a href="https://github.com/metosin/malli/issues/752" target="_blank">https://github.com/metosin/malli/issues/752</a></z><z id="t1660955133" t="geraldodev I have a react form that has a input :type &quot;date&quot; and the stored value is a string &quot;2022-08-01&quot;. How to check for valid date in malli with clojurescript ?"><y>#</y><d>2022-08-20</d><h>00:25</h><w>geraldodev</w>I have a react form that has a input :type &quot;date&quot; and the stored value is a string &quot;2022-08-01&quot;. How to check for valid date in malli with clojurescript ?</z><z id="t1661003846" t="pppaul anyone here had success using malli.swagger?"><y>#</y><d>2022-08-20</d><h>13:57</h><w>pppaul</w>anyone here had success using malli.swagger?</z><z id="t1661004327" t="pppaul {:info {:title &quot;Site Map&quot;}, :paths {&quot;&quot; {:get {:parameters {:query {:type &quot;object&quot;, :properties {:email {:type &quot;string&quot;}}}, :path {:type &quot;object&quot;, :properties {:uuid {:type &quot;string&quot;, :format &quot;uuid&quot;}}, :required [:uuid]}, :formData {:type &quot;object&quot;, :properties {}}}, :responses {403 {:description &quot;User tried to access something their not allowed to&quot;, :custom/template &quot;mvp/error_pages/403.html&quot;}, 401 {:description &quot;Bad Auth/Cookie gets a redirect to login&quot;}}, :produces (&quot;text/html&quot;)}, :post {:parameters {:query {:type &quot;object&quot;, :properties {:email {:type &quot;string&quot;}}}, :path {:type &quot;object&quot;, :properties {:uuid {:type &quot;string&quot;, :format &quot;uuid&quot;}}, :required [:uuid]}, :formData {:type &quot;object&quot;, :properties {:email {:type &quot;string&quot;}, :otp {:type &quot;array&quot;, :items {:type &quot;integer&quot;, :format &quot;int64&quot;}}}, :required [:email :otp]}}, :responses {403 {:description &quot;User tried to access something their not allowed to&quot;, :custom/template &quot;mvp/error_pages/403.html&quot;}, 401 {:description &quot;Bad Auth/Cookie gets a redirect to login&quot;}}, :produces (&quot;text/html&quot;), :consumes (&quot;multipart/form-data&quot;)}}, &quot;/login3{uuid}&quot; {}}, :basePath &quot;/swagger&quot;} this is what i&apos;m giving it"><y>#</y><d>2022-08-20</d><h>14:05</h><w>pppaul</w><pre>{:info {:title &quot;Site Map&quot;},
 :paths {&quot;&quot; {:get {:parameters {:query {:type &quot;object&quot;,
                                        :properties {:email {:type &quot;string&quot;}}},
                                :path {:type &quot;object&quot;,
                                       :properties {:uuid {:type &quot;string&quot;,
                                                           :format &quot;uuid&quot;}},
                                       :required [:uuid]},
                                :formData {:type &quot;object&quot;,
                                           :properties {}}},
                   :responses {403 {:description &quot;User tried to access something their not allowed to&quot;,
                                    :custom/template &quot;mvp/error_pages/403.html&quot;},
                               401 {:description &quot;Bad Auth/Cookie gets a redirect to login&quot;}},
                   :produces (&quot;text/html&quot;)},
             :post {:parameters {:query {:type &quot;object&quot;,
                                         :properties {:email {:type &quot;string&quot;}}},
                                 :path {:type &quot;object&quot;,
                                        :properties {:uuid {:type &quot;string&quot;,
                                                            :format &quot;uuid&quot;}},
                                        :required [:uuid]},
                                 :formData {:type &quot;object&quot;,
                                            :properties {:email {:type &quot;string&quot;},
                                                         :otp {:type &quot;array&quot;,
                                                               :items {:type &quot;integer&quot;,
                                                                       :format &quot;int64&quot;}}},
                                            :required [:email :otp]}},
                    :responses {403 {:description &quot;User tried to access something their not allowed to&quot;,
                                     :custom/template &quot;mvp/error_pages/403.html&quot;},
                                401 {:description &quot;Bad Auth/Cookie gets a redirect to login&quot;}},
                    :produces (&quot;text/html&quot;),
                    :consumes (&quot;multipart/form-data&quot;)}},
         &quot;/login3{uuid}&quot; {}},
 :basePath &quot;/swagger&quot;}</pre>
this is what i&apos;m giving it</z><z id="t1661004394" t="NoahTheDuke Maybe thread this discussion?"><y>#</y><d>2022-08-20</d><h>14:06</h><r>NoahTheDuke</r>Maybe thread this discussion?</z><z id="t1661004634" t="pppaul i&apos;m using https://github.com/metosin/ring-swagger maybe this doesn&apos;t work anymore? (it&apos;s pretty old). i looked at some of the tests and my swagger objects look pretty similar to the ones in the tests. i get complaints from swagger-json fn saying it doesn&apos;t know how to convert my object into a swagger schema"><y>#</y><d>2022-08-20</d><h>14:10</h><r>pppaul</r>i&apos;m using <a href="https://github.com/metosin/ring-swagger" target="_blank">https://github.com/metosin/ring-swagger</a> maybe this doesn&apos;t work anymore? (it&apos;s pretty old). i looked at some of the tests and my swagger objects look pretty similar to the ones in the tests. i get complaints from <code>swagger-json</code>fn saying it doesn&apos;t know how to convert my <code>object</code> into a swagger schema</z><z id="t1661004679" t="pppaul looking at swagger&apos;s docs https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject i think malli.swagger is generating wrong data"><y>#</y><d>2022-08-20</d><h>14:11</h><r>pppaul</r>looking at swagger&apos;s docs <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject" target="_blank">https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#parameterObject</a> i think malli.swagger is generating wrong data</z><z id="t1661004821" t="valtteri Currently it produces OpenAPI 2.x https://github.com/metosin/malli#swagger2"><y>#</y><d>2022-08-20</d><h>14:13</h><r>valtteri</r>Currently it produces OpenAPI 2.x <a href="https://github.com/metosin/malli#swagger2" target="_blank">https://github.com/metosin/malli#swagger2</a></z><z id="t1661005161" t="pppaul well, malli.swagger output is throwing errors for the other library for swagger that metosin made. i don&apos;t know what to do"><y>#</y><d>2022-08-20</d><h>14:19</h><r>pppaul</r>well, malli.swagger output is throwing errors for the other library for swagger that metosin made. i don&apos;t know what to do</z><z id="t1661005254" t="pppaul { &quot;skipParam&quot;: { &quot;name&quot;: &quot;skip&quot;, &quot;in&quot;: &quot;query&quot;, &quot;description&quot;: &quot;number of items to skip&quot;, &quot;required&quot;: true, &quot;type&quot;: &quot;integer&quot;, &quot;format&quot;: &quot;int32&quot; }, &quot;limitParam&quot;: { &quot;name&quot;: &quot;limit&quot;, &quot;in&quot;: &quot;query&quot;, &quot;description&quot;: &quot;max records to return&quot;, &quot;required&quot;: true, &quot;type&quot;: &quot;integer&quot;, &quot;format&quot;: &quot;int32&quot; } } it&apos;s not outputting this style of object"><y>#</y><d>2022-08-20</d><h>14:20</h><r>pppaul</r><pre>{
  &quot;skipParam&quot;: {
    &quot;name&quot;: &quot;skip&quot;,
    &quot;in&quot;: &quot;query&quot;,
    &quot;description&quot;: &quot;number of items to skip&quot;,
    &quot;required&quot;: true,
    &quot;type&quot;: &quot;integer&quot;,
    &quot;format&quot;: &quot;int32&quot;
  },
  &quot;limitParam&quot;: {
    &quot;name&quot;: &quot;limit&quot;,
    &quot;in&quot;: &quot;query&quot;,
    &quot;description&quot;: &quot;max records to return&quot;,
    &quot;required&quot;: true,
    &quot;type&quot;: &quot;integer&quot;,
    &quot;format&quot;: &quot;int32&quot;
  }
}</pre>
it&apos;s not outputting this style of object</z><z id="t1661005698" t="pppaul i guess i have to study the swagger docs and make my own transformer"><y>#</y><d>2022-08-20</d><h>14:28</h><r>pppaul</r>i guess i have to study the swagger docs and make my own transformer</z><z id="t1661006051" t="valtteri Please file an issue and we will look into it. 🙂"><y>#</y><d>2022-08-20</d><h>14:34</h><r>valtteri</r>Please file an issue and we will look into it. <b>🙂</b></z><z id="t1661006462" t="valtteri I&apos;m not sure if Tommi has intended that malli.swagger should play along with ring-swagger"><y>#</y><d>2022-08-20</d><h>14:41</h><r>valtteri</r>I&apos;m not sure if Tommi has intended that <code>malli.swagger</code>  should play along with <code>ring-swagger</code></z><z id="t1661006516" t="pppaul 😞"><y>#</y><d>2022-08-20</d><h>14:41</h><r>pppaul</r><b>😞</b></z><z id="t1661006654" t="valtteri I don&apos;t also understand why would both be needed. AFAIK they both generate swagger.json"><y>#</y><d>2022-08-20</d><h>14:44</h><r>valtteri</r>I don&apos;t also understand why would both be needed. AFAIK they both generate <code>swagger.json</code></z><z id="t1661006677" t="valtteri That you can use to render swagger ui"><y>#</y><d>2022-08-20</d><h>14:44</h><r>valtteri</r>That you can use to render swagger ui</z><z id="t1661006872" t="valtteri Difference being that ring-swagger can generate the json from plumatic schema / clojure.spec and malli.swagger does that for malli schemas"><y>#</y><d>2022-08-20</d><h>14:47</h><r>valtteri</r>Difference being that <code>ring-swagger</code>  can generate the json from plumatic schema / clojure.spec and <code>malli.swagger</code>  does that for malli schemas</z><z id="t1661007230" t="valtteri Uhhhmm.. Need to correct myself. Looks like malli.swagger produces &quot;chunks&quot; of swagger 2.0 compatible JSON, not the complete swagger doc."><y>#</y><d>2022-08-20</d><h>14:53</h><r>valtteri</r>Uhhhmm.. Need to correct myself. Looks like <code>malli.swagger</code>  produces &quot;chunks&quot; of swagger 2.0 compatible JSON, not the complete swagger doc.</z><z id="t1661007237" t="pppaul ok, i did not know that"><y>#</y><d>2022-08-20</d><h>14:53</h><r>pppaul</r>ok, i did not know that</z><z id="t1661007297" t="pppaul it makes sense that malli swagger wouldn&apos;t produce the whole swagger doc, i just don&apos;t know what to do with it&apos;s output"><y>#</y><d>2022-08-20</d><h>14:54</h><r>pppaul</r>it makes sense that malli swagger wouldn&apos;t produce the whole swagger doc, i just don&apos;t know what to do with it&apos;s output</z><z id="t1661007299" t="valtteri Which kinda makes sense since Malli knows only about the shape of data. It doesn&apos;t know anything about route definitions and other stuff that goes into swagger spec"><y>#</y><d>2022-08-20</d><h>14:54</h><r>valtteri</r>Which kinda makes sense since Malli knows only about the shape of data. It doesn&apos;t know anything about route definitions and other stuff that goes into swagger spec</z><z id="t1661007322" t="valtteri Are you using reitit by any chance?"><y>#</y><d>2022-08-20</d><h>14:55</h><r>valtteri</r>Are you using <code>reitit</code>  by any chance?</z><z id="t1661007327" t="pppaul yada"><y>#</y><d>2022-08-20</d><h>14:55</h><r>pppaul</r>yada</z><z id="t1661007331" t="valtteri Because there&apos;s reitit.swagger"><y>#</y><d>2022-08-20</d><h>14:55</h><r>valtteri</r>Because there&apos;s <code>reitit.swagger</code></z><z id="t1661007363" t="pppaul i was hacking on yada swagger to try to get it working with malli"><y>#</y><d>2022-08-20</d><h>14:56</h><r>pppaul</r>i was hacking on yada swagger to try to get it working with malli</z><z id="t1661007377" t="pppaul changing over to reitit is a bigger challenge"><y>#</y><d>2022-08-20</d><h>14:56</h><r>pppaul</r>changing over to reitit is a bigger challenge</z><z id="t1661007475" t="valtteri Yeah, I see. I don&apos;t know how Yada swagger works but in reitit it works so that it constructs the full swagger.json from route data + schema definitions. For schemas it supports plumatic, clojure.spec and malli.. And when it&apos;s constructing the swagger, it checks which impl it is, generates the needed JSON chunks and places them into the swagger doc"><y>#</y><d>2022-08-20</d><h>14:57</h><r>valtteri</r>Yeah, I see. I don&apos;t know how Yada swagger works but in reitit it works so that it constructs the full <code>swagger.json</code>  from route data + schema definitions. For schemas it supports plumatic, clojure.spec and malli.. And when it&apos;s constructing the swagger, it checks which impl it is, generates the needed JSON chunks and places them into the swagger doc</z><z id="t1661007513" t="pppaul yeah, i used malli swagger to generate the params data, but it still wasn&apos;t enough"><y>#</y><d>2022-08-20</d><h>14:58</h><r>pppaul</r>yeah, i used malli swagger to generate the params data, but it still wasn&apos;t enough</z><z id="t1661007719" t="valtteri Yeah.. I&apos;m trying to look if ring-swagger has extension points where you could jack in malli"><y>#</y><d>2022-08-20</d><h>15:01</h><r>valtteri</r>Yeah.. I&apos;m trying to look if <code>ring-swagger</code>  has extension points where you could jack in malli</z><z id="t1661008246" t="valtteri Mhmhmh to my 👀 it looks like some serious hacking would be required"><y>#</y><d>2022-08-20</d><h>15:10</h><r>valtteri</r>Mhmhmh to my <b>👀</b>  it looks like some serious hacking would be required</z><z id="t1661008948" t="pppaul i think i just have to change the params code, i already have merged route + method params"><y>#</y><d>2022-08-20</d><h>15:22</h><r>pppaul</r>i think i just have to change the params code, i already have merged route + method params</z><z id="t1661008975" t="pppaul i just don&apos;t know what to change the params to, seems like i need to build ref structures and flatten out nested maps or something"><y>#</y><d>2022-08-20</d><h>15:22</h><r>pppaul</r>i just don&apos;t know what to change the params to, seems like i need to build ref structures and flatten out nested maps or something</z><z id="t1661009079" t="pppaul i poked at it for a few hours, and i think i rather just see about using reitit..."><y>#</y><d>2022-08-20</d><h>15:24</h><r>pppaul</r>i poked at it for a few hours, and i think i rather just see about using reitit...</z><z id="t1661087496" t="ikitommi here too https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger"><y>#</y><d>2022-08-21</d><h>13:11</h><r>ikitommi</r>here too <a href="https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger" target="_blank">https://github.com/metosin/reitit/tree/master/examples/ring-malli-swagger</a></z><z id="t1661103164" t="pppaul thanks, I think that&apos;s exactly what I need to figure out how to fix yada"><y>#</y><d>2022-08-21</d><h>17:32</h><r>pppaul</r>thanks, I think that&apos;s exactly what I need to figure out how to fix yada</z><z id="t1661168452" t="eskos Swagger is specifically pre-OpenAPI, which does get confusing. The name change and a whole bunch of backwards breaking changes happened with the release of OpenAPI 3.0, so a good mental note is that you really shouldn’t expect one from another. This isn’t necessarily very helpful to the issue at hand, but still an unfortunate detail one should be aware of."><y>#</y><d>2022-08-22</d><h>11:40</h><r>eskos</r>Swagger is specifically pre-OpenAPI, which does get confusing. The name change and a whole bunch of backwards breaking changes happened with the release of OpenAPI 3.0, so a good mental note is that you really shouldn’t expect one from another.

This isn’t necessarily very helpful to the issue at hand, but still an unfortunate detail one should be aware of.</z><z id="t1661098720" t="Eliraz hello! I&apos;m trying to work with on my project"><y>#</y><d>2022-08-21</d><h>16:18</h><w>Eliraz</w>hello! I&apos;m trying to work with <code></code> on my project</z><z id="t1661098746" t="Eliraz and am getting the following issue: The required namespace &quot;malli.dev&quot; is not available, it was required by &quot;main/root.cljs&quot;. &quot;malli/dev.clj&quot; was found on the classpath. Maybe this library only supports CLJ?"><y>#</y><d>2022-08-21</d><h>16:19</h><w>Eliraz</w>and am getting the following issue:
<pre>The required namespace &quot;malli.dev&quot; is not available, it was required by &quot;main/root.cljs&quot;.
&quot;malli/dev.clj&quot; was found on the classpath. Maybe this library only supports CLJ?</pre></z><z id="t1661183031" t="dvingo yea what ingesol said sounds right, there&apos;s some notes here too: https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md"><y>#</y><d>2022-08-22</d><h>15:43</h><r>dvingo</r>yea what ingesol said sounds right, there&apos;s some notes here too:
<a href="https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md" target="_blank">https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md</a></z><z id="t1661098762" t="Eliraz anybody knows what the issue is?"><y>#</y><d>2022-08-21</d><h>16:19</h><w>Eliraz</w>anybody knows what the issue is?</z><z id="t1661100415" t="ingesol [:attrs {:href &quot;/_/_/users/U012XM1CH39&quot;}] You need to use malli.dev.cljs for CLJS I think."><y>#</y><d>2022-08-21</d><h>16:46</h><w>ingesol</w><a>@eliraz.kedmi157</a> You need to use <code>malli.dev.cljs</code> for CLJS I think.</z><z id="t1661178775" t="plins looks like malli does not accepts a set as a schema what would be the equivalent of (spec/valid? #{:a :b} :a) ?"><y>#</y><d>2022-08-22</d><h>14:32</h><w>plins</w>looks like malli does not accepts a set as a schema

what would be the equivalent of <code>(spec/valid? #{:a :b} :a)</code> ?</z><z id="t1661178833" t="NoahTheDuke is this just :enum ?"><y>#</y><d>2022-08-22</d><h>14:33</h><r>NoahTheDuke</r>is this just <code>:enum</code>?</z><z id="t1661178848" t="NoahTheDuke one of n possibilities?"><y>#</y><d>2022-08-22</d><h>14:34</h><r>NoahTheDuke</r>one of n possibilities?</z><z id="t1661178877" t="plins looks like so, thanks"><y>#</y><d>2022-08-22</d><h>14:34</h><r>plins</r>looks like so, thanks</z><z id="t1661259134" t="Chris O’Donnell Does anyone know the status of https://github.com/metosin/malli/pull/545 ? Running into the limitations of inst? at work, and it would be great to have a standard solution."><y>#</y><d>2022-08-23</d><h>12:52</h><w>Chris O’Donnell</w>Does anyone know the status of <a href="https://github.com/metosin/malli/pull/545" target="_blank">https://github.com/metosin/malli/pull/545</a> ? Running into the limitations of <code>inst?</code> at work, and it would be great to have a standard solution.</z><z id="t1661697003" t="ikitommi highly needed, pushed up on the TODO to check it out."><y>#</y><d>2022-08-28</d><h>14:30</h><r>ikitommi</r>highly needed, pushed up on the TODO to check it out.</z><z id="t1661698483" t="Chris O’Donnell Thanks! Let me know if there&apos;s anything I can do to help."><y>#</y><d>2022-08-28</d><h>14:54</h><r>Chris O’Donnell</r>Thanks! Let me know if there&apos;s anything I can do to help.</z><z id="t1661521759" t="Setzer22 Hi! We&apos;ve just noticed that schemas using a registry don&apos;t work with methods from malli utils, is this intended? This works as expected: (m/entries [:map [:hola :string]]) ; =&gt; ([:hola [:malli.core/val :string]]) But this fails (returns nil, but the schema is the same) (m/entries [:schema {:registry {&quot;Foo&quot; [:map [:hola :string]]}} &quot;Foo&quot;]) ; =&gt; nil"><y>#</y><d>2022-08-26</d><h>13:49</h><w>Setzer22</w>Hi! We&apos;ve just noticed that schemas using a registry don&apos;t work with methods from malli utils, is this intended?

This works as expected:
<pre>(m/entries [:map [:hola :string]]) ; =&gt; ([:hola [:malli.core/val :string]])</pre>
But this fails (returns nil, but the schema is the same)
<pre>(m/entries [:schema 
            {:registry {&quot;Foo&quot; [:map [:hola :string]]}}
            &quot;Foo&quot;]) ; =&gt; nil</pre></z><z id="t1661523598" t="NoahTheDuke You need m/deref-all : (m/entries (m/deref-all [:schema {:registry {&quot;Foo&quot; [:map [:hola :string]]}} &quot;Foo&quot;])) ;=&gt; ([:hola [:malli.core/val :string]])"><y>#</y><d>2022-08-26</d><h>14:19</h><r>NoahTheDuke</r>You need <code>m/deref-all</code> :
<pre>(m/entries
  (m/deref-all
    [:schema {:registry {&quot;Foo&quot; [:map [:hola :string]]}}
     &quot;Foo&quot;]))
;=&gt; ([:hola [:malli.core/val :string]])</pre></z><z id="t1661523880" t="Setzer22 awesome, thanks! 👍"><y>#</y><d>2022-08-26</d><h>14:24</h><r>Setzer22</r>awesome, thanks! <b>👍</b></z><z id="t1662035985" t="souenzzo Hello In the context of this issue: https://github.com/metosin/malli/issues/739#issuecomment-1232938081 Should :my/int represent something different from [:my/int] ? or they both different notations with the same meaning? This behavior can be considered a bug? (m/ast :my/int opts) #_#_=&gt; {:type :malli.core/schema, :value :my/int} (m/ast [:my/int] opts) #_#_=&gt; {:type :my/int}"><y>#</y><d>2022-09-01</d><h>12:39</h><w>souenzzo</w>Hello

In the context of this issue: <a href="https://github.com/metosin/malli/issues/739#issuecomment-1232938081" target="_blank">https://github.com/metosin/malli/issues/739#issuecomment-1232938081</a>

Should <code>:my/int</code> represent something different from <code>[:my/int]</code> ? or they both different notations with the same meaning?

This behavior can be considered a bug?
<pre>(m/ast :my/int opts) #_#_=&gt; {:type :malli.core/schema, :value :my/int}
(m/ast [:my/int] opts) #_#_=&gt; {:type :my/int}</pre></z><z id="t1662036210" t="ikitommi oh, doesn’t look right. works the same, but extra wrapping :thinking_face:"><y>#</y><d>2022-09-01</d><h>12:43</h><r>ikitommi</r>oh, doesn’t look right. works the same, but extra wrapping <b>:thinking_face:</b></z><z id="t1662036272" t="ikitommi need to think about the issue, thanks for a gentle reminder 🙂"><y>#</y><d>2022-09-01</d><h>12:44</h><r>ikitommi</r>need to think about the issue, thanks for a gentle reminder <b>🙂</b></z><z id="t1662036338" t="souenzzo the extra wrapping makes one turn into $ref and another turn into a simple type, in json-schema generation."><y>#</y><d>2022-09-01</d><h>12:45</h><r>souenzzo</r>the extra wrapping makes one turn into <code>$ref</code> and another turn into a simple type, in json-schema generation.</z><z id="t1662036386" t="souenzzo I&apos;m unsure if I should consider it a json-schema bug, or a malli bug."><y>#</y><d>2022-09-01</d><h>12:46</h><r>souenzzo</r>I&apos;m unsure if I should consider it a json-schema bug, or a malli bug.</z><z id="t1662072263" t="Justin Reed How do I modify this: [:map [:key-0 uuid?] [:key-1 string?] [:key-2 [:string {:max 9 :min 9}]] such that a map must have one of these three keys? For example, {:key-0 (UUID/randomUUID)} {:key-1 &quot;HELLO WORLD&quot;} {:key-2 &quot;123456789&quot;} {:key-1 &quot;HELLO WORLD&quot; :key-2 &quot;123456789&quot;} are all valid, but {} {:key-4 &quot;SOME OTHER KEY&quot;} are not. I didn&apos;t find a direct way of doing this in the docs, so I thought I&apos;d ask before I ventured down the path of cobbling it together with :and, :or, etc."><y>#</y><d>2022-09-01</d><h>22:44</h><w>Justin Reed</w>How do I modify this:
<pre>[:map
   [:key-0 uuid?]
   [:key-1 string?]
   [:key-2 [:string {:max 9 :min 9}]]</pre>
such that a map must have one of these three keys? For example,
<pre>{:key-0 (UUID/randomUUID)}
{:key-1 &quot;HELLO WORLD&quot;}
{:key-2 &quot;123456789&quot;}
{:key-1 &quot;HELLO WORLD&quot; :key-2 &quot;123456789&quot;} </pre>
are all valid, but
<pre>{}
{:key-4 &quot;SOME OTHER KEY&quot;}</pre>
are not.

I didn&apos;t find a direct way of doing this in the docs, so I thought I&apos;d ask before I ventured down the path of cobbling it together with :and, :or, etc.</z><z id="t1662113076" t="iarenaza While it&apos;s not explicitly described as such, there is a hint about that possibility in the example shown in the paragraph with the text &quot;Finding all subschemas with paths, retaining order:&quot; There, the :fn schema is used to check that either the :streeet or the :lonlat keys are present in the :map schema (using the :and schema to tie both conditions). So something like this should work: (mapv (fn [m] (malli/validate [:and [:map [:key-0 {:optional true} uuid?] [:key-1 {:optional true} string?] [:key-2 {:optional true} [:string {:max 9 :min 9}]]] [:fn (fn [{:keys [key-0 key-1 key-2]}] (or key-0 key-1 key-2))]] m)) [{:key-0 (UUID/randomUUID)} {:key-1 &quot;HELLO WORLD&quot;} {:key-2 &quot;123456789&quot;} {:key-1 &quot;HELLO WORLD&quot; :key-2 &quot;123456789&quot;} {} {:key-4 &quot;SOME OTHER KEY&quot;}])"><y>#</y><d>2022-09-02</d><h>10:04</h><r>iarenaza</r>While it&apos;s not explicitly described as such, there is a hint about that possibility in the example shown in the paragraph with the text &quot;Finding all subschemas with paths, retaining order:&quot; There, the <code>:fn</code> schema is used to check that either the <code>:streeet</code> or the <code>:lonlat</code> keys are present in the <code>:map</code> schema (using the <code>:and</code> schema to tie both conditions). So something like this should work:

<pre>(mapv (fn [m]
        (malli/validate [:and
                         [:map
                          [:key-0 {:optional true} uuid?]
                          [:key-1 {:optional true} string?]
                          [:key-2 {:optional true} [:string {:max 9 :min 9}]]]
                         [:fn (fn [{:keys [key-0 key-1 key-2]}]
                                (or key-0 key-1 key-2))]]
                        m))
      [{:key-0 (UUID/randomUUID)}
       {:key-1 &quot;HELLO WORLD&quot;}
       {:key-2 &quot;123456789&quot;}
       {:key-1 &quot;HELLO WORLD&quot; :key-2 &quot;123456789&quot;}
       {}
       {:key-4 &quot;SOME OTHER KEY&quot;}])</pre></z><z id="t1662132945" t="emccue [:or [:map {:closed true} [:key-0 uuid?]] [:map {:closed true} [:key-1 string?]] [:map {:closed true} [:key-2 [:string {:max 9 :min 9}]] [:map {:closed true} [:key-0 uuid?] [:key-1 string?]] [:map {:closed true} [:key-1 string?] [:key-2 [:string {:max 9 :min 9}]]] [:map {:closed true} [:key-0 uuid?] [:key-2 [:string {:max 9 :min 9}]]] [:map {:closed true} [:key-0 uuid?] [:key-1 string?] [:key-2 [:string {:max 9 :min 9}]]] "><y>#</y><d>2022-09-02</d><h>15:35</h><r>emccue</r><pre>[:or 
  [:map {:closed true}
    [:key-0 uuid?]]
  [:map {:closed true}
    [:key-1 string?]]
  [:map {:closed true}
    [:key-2 [:string {:max 9 :min 9}]]
  [:map {:closed true}
    [:key-0 uuid?]
    [:key-1 string?]]
  [:map {:closed true}
    [:key-1 string?]
    [:key-2 [:string {:max 9 :min 9}]]]
  [:map {:closed true}
    [:key-0 uuid?]
    [:key-2 [:string {:max 9 :min 9}]]]
  [:map {:closed true}
    [:key-0 uuid?]
    [:key-1 string?]
    [:key-2 [:string {:max 9 :min 9}]]]
  </pre></z><z id="t1662133082" t="emccue is my first go at it - obviously you&apos;d write something that would produce that"><y>#</y><d>2022-09-02</d><h>15:38</h><r>emccue</r>is my first go at it - obviously you&apos;d write something that would produce that</z><z id="t1662139930" t="Justin Reed Thank you both for your help. I was about to go down the road [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}] demonstrated, but was hoping for something less redundant. [:attrs {:href &quot;/_/_/users/U8T05KBEW&quot;}] ’s nudge is exactly what I was looking for."><y>#</y><d>2022-09-02</d><h>17:32</h><r>Justin Reed</r>Thank you both for your help. I was about to go down the road <a>@U3JH98J4R</a> demonstrated, but was hoping for something less redundant. <a>@U8T05KBEW</a>’s nudge is exactly what I was looking for.</z><z id="t1662262552" t="Jungwoo Kim Hi, is there any way to check var? (m/validate [:map [:my-fn symbol?]] {:my-fn &apos;clojure.core/identity}) ;; obviously true (m/validate [:map [:my-fn var?]] {:my-fn (requiring-resolve &apos;clojure.core/identity)}) ;; expected true but invalid schema As docs, https://github.com/metosin/malli#mallicorepredicate-schemas doesn’t support var? . How do I validate var? ?"><y>#</y><d>2022-09-04</d><h>03:35</h><w>Jungwoo Kim</w>Hi, is there any way to check <code>var?</code>

<pre>(m/validate [:map
               [:my-fn symbol?]] {:my-fn &apos;clojure.core/identity}) ;; obviously true
  (m/validate [:map
               [:my-fn var?]] {:my-fn (requiring-resolve &apos;clojure.core/identity)}) ;; expected true but invalid schema</pre>
As docs, <a href="https://github.com/metosin/malli#mallicorepredicate-schemas" target="_blank">https://github.com/metosin/malli#mallicorepredicate-schemas</a> doesn’t support <code>var?</code> . How do I validate <code>var?</code> ?</z><z id="t1662288090" t="respatialized [:my-fn [:fn var?]] If nothing else you could use a predicate schema"><y>#</y><d>2022-09-04</d><h>10:41</h><r>respatialized</r><code>[:my-fn [:fn var?]]</code> If nothing else you could use a predicate schema</z><z id="t1662334434" t="Jungwoo Kim Ahh that’s so useful ! thank you!"><y>#</y><d>2022-09-04</d><h>23:33</h><r>Jungwoo Kim</r>Ahh that’s so useful ! thank you!</z><z id="t1662620643" t="Ferdinand Beyer It seems that I can&apos;t use recursive schemas in regular expression schemas? (def selector-schema (malli/schema [:schema {:registry {::selector [:and vector? [:+ [:cat keyword? [:? [:ref ::selector]]]]]}} [:ref ::selector]])) (malli/validate selector-schema [:foo [:bar]]) ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). ; :malli.core/potentially-recursive-seqex [:ref :user/selector] Is there another way to specify this? I basically want to specify a vector of keywords, that are optionally followed by a vector that conforms to the same spec..."><y>#</y><d>2022-09-08</d><h>07:04</h><w>Ferdinand Beyer</w>It seems that I can&apos;t use recursive schemas in regular expression schemas?

<pre>(def selector-schema
  (malli/schema
   [:schema {:registry {::selector [:and vector? [:+ [:cat keyword? [:? [:ref ::selector]]]]]}}
    [:ref ::selector]]))

(malli/validate selector-schema [:foo [:bar]])
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
; :malli.core/potentially-recursive-seqex [:ref :user/selector]</pre>
Is there another way to specify this? I basically want to specify a vector of keywords, that are optionally followed by a vector that conforms to the same spec...</z><z id="t1662620950" t="ikitommi you can’t inline the recursive references (reasoning https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc ), but you can use them, with explicit :schema wrapping, e.g. (def selector-schema (malli/schema [:schema {:registry {::selector [:and vector? [:+ [:cat keyword? [:? [:schema [:ref ::selector]]]]]]}} [:ref ::selector]]))"><y>#</y><d>2022-09-08</d><h>07:09</h><r>ikitommi</r>you can’t inline the recursive references (reasoning <a href="https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/impl/regex.cljc</a>), but you can use them, with explicit <code>:schema</code> wrapping, e.g.
<pre>(def selector-schema
  (malli/schema
   [:schema {:registry {::selector [:and vector? [:+ [:cat keyword? [:? [:schema [:ref ::selector]]]]]]}}
    [:ref ::selector]]))</pre></z><z id="t1662621028" t="Ferdinand Beyer Thanks a bunch!"><y>#</y><d>2022-09-08</d><h>07:10</h><r>Ferdinand Beyer</r>Thanks a bunch!</z><z id="t1662621034" t="Ferdinand Beyer This works!"><y>#</y><d>2022-09-08</d><h>07:10</h><r>Ferdinand Beyer</r>This works!</z><z id="t1662621054" t="ikitommi there was a discussion of auto-wrapping :ref s here, but it might be more confusing."><y>#</y><d>2022-09-08</d><h>07:10</h><r>ikitommi</r>there was a discussion of auto-wrapping <code>:ref</code>s here, but it might be more confusing.</z><z id="t1662621058" t="ikitommi Your welcome 🙂"><y>#</y><d>2022-09-08</d><h>07:10</h><r>ikitommi</r>Your welcome <b>🙂</b></z><z id="t1662621083" t="Ferdinand Beyer I wonder if we should place a hint to that somewhere in the README. Happy to give it a try and PR"><y>#</y><d>2022-09-08</d><h>07:11</h><r>Ferdinand Beyer</r>I wonder if we should place a hint to that somewhere in the README. Happy to give it a try and PR</z><z id="t1662621110" t="Ferdinand Beyer I was about to give up already, would never have guessed to wrap it in [:schema]"><y>#</y><d>2022-09-08</d><h>07:11</h><r>Ferdinand Beyer</r>I was about to give up already, would never have guessed to wrap it in <code>[:schema]</code></z><z id="t1662621114" t="ikitommi &gt; As all these examples show, the “seqex” operators take any non-seqex child schema to mean a sequence of one element that matches that schema. To force that behaviour for a seqex child :schema can be used: &gt; (m/validate &gt; [:cat [:= :names] [:schema [:* string?]] [:= :nums] [:schema [:* number?]]] &gt; [:names [&quot;a&quot; &quot;b&quot;] :nums [1 2 3]]) &gt; ; =&gt; true &gt; &gt; ;; whereas &gt; (m/validate &gt; [:cat [:= :names] [:* string?] [:= :nums] [:* number?]] &gt; [:names &quot;a&quot; &quot;b&quot; :nums 1 2 3]) &gt; ; =&gt; true &gt; "><y>#</y><d>2022-09-08</d><h>07:11</h><r>ikitommi</r>&gt; As all these examples show, the “seqex” operators take any non-seqex child schema to mean a sequence of one element that matches that schema. To force that behaviour for a seqex child <code>:schema</code> can be used:
&gt; <pre>(m/validate
&gt;   [:cat [:= :names] [:schema [:* string?]] [:= :nums] [:schema [:* number?]]]
&gt;   [:names [&quot;a&quot; &quot;b&quot;] :nums [1 2 3]])
&gt; ; =&gt; true
&gt; 
&gt; ;; whereas
&gt; (m/validate
&gt;   [:cat [:= :names] [:* string?] [:= :nums] [:* number?]]
&gt;   [:names &quot;a&quot; &quot;b&quot; :nums 1 2 3])
&gt; ; =&gt; true</pre>
&gt; </z><z id="t1662621135" t="ikitommi that’s on the README, which is bit overgrown…"><y>#</y><d>2022-09-08</d><h>07:12</h><r>ikitommi</r>that’s on the README, which is bit overgrown…</z><z id="t1662621143" t="Ferdinand Beyer Oh man."><y>#</y><d>2022-09-08</d><h>07:12</h><r>Ferdinand Beyer</r>Oh man.</z><z id="t1662621148" t="Ferdinand Beyer Sorry 🙂"><y>#</y><d>2022-09-08</d><h>07:12</h><r>Ferdinand Beyer</r>Sorry <b>🙂</b></z><z id="t1662621156" t="ikitommi np"><y>#</y><d>2022-09-08</d><h>07:12</h><r>ikitommi</r>np</z><z id="t1662621218" t="Ferdinand Beyer Note to self: Always read the whole section"><y>#</y><d>2022-09-08</d><h>07:13</h><r>Ferdinand Beyer</r>Note to self: Always read the whole section</z><z id="t1662978879" t="Carlo Can I generate a value from a registry? Something like: (def reg {::id int? ::name string? ::user [:tuple ::id ::name]}) (mg/generate {:registry reg} ::user)"><y>#</y><d>2022-09-12</d><h>10:34</h><w>Carlo</w>Can I generate a value from a registry? Something like:
<pre>(def reg
  {::id int?
   ::name string?
   ::user [:tuple ::id ::name]})

(mg/generate {:registry reg} ::user)</pre></z><z id="t1662989883" t="Ferdinand Beyer Yes, by wrapping it in [:schema] : (mg/generate [:schema {:registry reg} ::user])"><y>#</y><d>2022-09-12</d><h>13:38</h><r>Ferdinand Beyer</r>Yes, by wrapping it in <code>[:schema]</code>:

<pre>(mg/generate [:schema {:registry reg} ::user])</pre></z><z id="t1662990864" t="Carlo Thank you, could you expand a bit more on why this works/where to find docs?"><y>#</y><d>2022-09-12</d><h>13:54</h><r>Carlo</r>Thank you, could you expand a bit more on why this works/where to find docs?</z><z id="t1663004417" t="Ferdinand Beyer It works since generate requires a schema to generate examples for. A registry is not a schema, just a map. So you need to create a schema that uses your registry. As https://github.com/metosin/malli#local-registry , any schema can have a local registry property, e.g. [:map {:registry ,,,}] . Since you don&apos;t have such a schema in your case, you can use the generic [:schema] one, and just refer to a named one from the local registry. An alternative would be the m/schema function to instantiate the schema explicitly. Remember that forms such as [:map] are not schemas yet, but will be instantiated on demand. You can explicitly turn them into schemas using m/schema . Hope that helps!"><y>#</y><d>2022-09-12</d><h>17:40</h><r>Ferdinand Beyer</r>It works since <code>generate</code> requires a schema to generate examples for. A registry is not a schema, just a map. So you need to create a schema that uses your registry.

As <a href="https://github.com/metosin/malli#local-registry" target="_blank">https://github.com/metosin/malli#local-registry</a>, any schema can have a local registry property, e.g. <code>[:map {:registry ,,,}]</code>.  Since you don&apos;t have such a schema in your case, you can use the generic <code>[:schema]</code> one, and just refer to a named one from the local registry.

An alternative would be the <code>m/schema</code> function to instantiate the schema explicitly. Remember that forms such as <code>[:map]</code> are not schemas yet, but will be instantiated on demand. You can explicitly turn them into schemas using <code>m/schema</code>.

Hope that helps!</z><z id="t1663078227" t="Carlo That is much more clear, thanks for the thoughtful answer [:attrs {:href &quot;/_/_/users/U031CHTGX1T&quot;}]"><y>#</y><d>2022-09-13</d><h>14:10</h><r>Carlo</r>That is much more clear, thanks for the thoughtful answer <a>@U031CHTGX1T</a></z><z id="t1663052667" t="Martynas M Is there a decoder for malli schema itself from JSON? For instance if I have this schema: [:map [:key {:optional true} :string]] Can I parse it from this JSON? [&quot;map&quot;, [&quot;key&quot;, { &quot;optional&quot;: true }, &quot;string&quot;] ]"><y>#</y><d>2022-09-13</d><h>07:04</h><w>Martynas M</w>Is there a decoder for malli schema itself from JSON?
For instance if I have this schema:

<code>[:map [:key {:optional true} :string]]</code>

Can I parse it from this JSON?

<pre>[&quot;map&quot;,
	[&quot;key&quot;, { &quot;optional&quot;: true }, &quot;string&quot;]
]</pre></z><z id="t1663063478" t="ikitommi [:map [&quot;key&quot; {:optional true} :string]] is also a valid schema, so one can’t guess from the JSON example that the &quot;key&quot; should be handled as a keyword."><y>#</y><d>2022-09-13</d><h>10:04</h><r>ikitommi</r><code>[:map [&quot;key&quot; {:optional true} :string]]</code> is also a valid schema, so one can’t guess from the JSON example that the <code>&quot;key&quot;</code> should be handled as a keyword.</z><z id="t1663063545" t="ikitommi but, if someone would write schemas of all malli schema syntaxes, one could do everything else (but not guess the string-&gt;kw things)"><y>#</y><d>2022-09-13</d><h>10:05</h><r>ikitommi</r>but, if someone would write schemas of all malli schema syntaxes, one could do everything else (but not guess the string-&gt;kw things)</z><z id="t1663064036" t="Martynas M Ok. That means that a dumbed-down version would work :thinking_face:"><y>#</y><d>2022-09-13</d><h>10:13</h><r>Martynas M</r>Ok. That means that a dumbed-down version would work <b>:thinking_face:</b></z><z id="t1663071550" t="ikitommi yes. If you want all maps to have keyword keys, you can: 1. read in from json 2. clojure-walk all vectors to have first arg as keyword 3. m/schema 4. [:attrs nil] 5. profit"><y>#</y><d>2022-09-13</d><h>12:19</h><r>ikitommi</r>yes. If you want all maps to have keyword keys, you can:
1. read in from json
2. clojure-walk all vectors to have first arg as keyword
3. m/schema
4. <del>m/walk and convert all map keys into keyword</del>
5. profit</z><z id="t1663075174" t="Martynas M There is also a difference between keyword and symbol . And that&apos;s also significant because :inst? ,`inst?` and &quot;inst?&quot; are different :thinking_face:"><y>#</y><d>2022-09-13</d><h>13:19</h><r>Martynas M</r>There is also a difference between <code>keyword</code> and <code>symbol</code> .
And that&apos;s also significant because <code>:inst?</code> ,`inst?` and <code>&quot;inst?&quot;</code> are different <b>:thinking_face:</b></z><z id="t1663081962" t="ikitommi maybe Tagged JSON? https://github.com/metosin/jsonista#tagged-json"><y>#</y><d>2022-09-13</d><h>15:12</h><r>ikitommi</r>maybe Tagged JSON? <a href="https://github.com/metosin/jsonista#tagged-json" target="_blank">https://github.com/metosin/jsonista#tagged-json</a></z><z id="t1663082120" t="Martynas M I was thinking about dumbing down the schema and making everything a keyword or a number :thinking_face: I don&apos;t need all power."><y>#</y><d>2022-09-13</d><h>15:15</h><r>Martynas M</r>I was thinking about dumbing down the schema and making everything a keyword or a number <b>:thinking_face:</b>
I don&apos;t need all power.</z><z id="t1663149842" t="juhoteperi If you know all your map keys are going to be keywords, you could use walker and transform to change map keys to keywords from strings, in the read schema."><y>#</y><d>2022-09-14</d><h>10:04</h><r>juhoteperi</r>If you know all your map keys are going to be keywords, you could use walker and transform to change map keys to keywords from strings, in the read schema.</z><z id="t1663149879" t="juhoteperi Or you if just write limited Malli schema for the Malli schemas you need to support, you can use :keyword there to read the JSON strings as keys for the map keys."><y>#</y><d>2022-09-14</d><h>10:04</h><r>juhoteperi</r>Or you if just write limited Malli schema for the Malli schemas you need to support, you can use <code>:keyword</code> there to read the JSON strings as keys for the map keys.</z><z id="t1663151942" t="Martynas M I was thinking about making a subset of malli by doing something similar to a custom parser. And then use :inst instead of inst? and :number instead of number? to make it all very uniform for the reader and parser. And after parsing I would do clojure.walk/postwalk or something similar to replace into the functions that malli understands. So I should probably implement parsing for all basic types, :map , :set and some basic options like :optional . I think I don&apos;t need seq regex matching in this specific use as this will only be used to define a data structure and sequences, maybe lists with order too but there shouldn&apos;t be tuples."><y>#</y><d>2022-09-14</d><h>10:39</h><r>Martynas M</r>I was thinking about making a subset of malli by doing something similar to a custom parser.

And then use <code>:inst</code> instead of <code>inst?</code> and <code>:number</code> instead of <code>number?</code> to make it all very uniform for the reader and parser. And after parsing I would do <code>clojure.walk/postwalk</code> or something similar to replace into the functions that malli understands.

So I should probably implement parsing for all basic types, <code>:map</code> , <code>:set</code> and some basic options like <code>:optional</code>. I think I don&apos;t need seq regex matching in this specific use as this will only be used to define a data structure and sequences, maybe lists with order too but there shouldn&apos;t be tuples.</z><z id="t1663078590" t="Anders Eknert Hey! Just discovered malli, and it looks like it does a lot of the things I need it for 😃 Could be I’ve missed something in the README, but one thing that isn’t immediately apparent to me, is if/how I can do validation of values that reference other attributes? So say that I have a map like: { &quot;min&quot;: 10, &quot;max&quot;: 20 } and I want to ensure that the min value is never greater than the value for max , etc"><y>#</y><d>2022-09-13</d><h>14:16</h><w>Anders Eknert</w>Hey! Just discovered malli, and it looks like it does a lot of the things I need it for <b>😃</b> Could be I’ve missed something in the README, but one thing that isn’t immediately apparent to me, is if/how I can do validation of values that reference other attributes? So say that I have a map like:
<pre>{
  &quot;min&quot;: 10,
  &quot;max&quot;: 20
}</pre>
and I want to ensure that the <code>min</code> value is never greater than the value for <code>max</code> , etc</z><z id="t1663081083" t="lread The malli playground is a great place to discover malli features. Maybe https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D will give you inspiration?"><y>#</y><d>2022-09-13</d><h>14:58</h><r>lread</r>The malli playground is a great place to discover malli features.
Maybe <a href="https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D" target="_blank">https://malli.io/?value=%7B%3Ax%201%2C%20%3Ay%202%7D&amp;amp;schema=%5B%3Aand%0A%20%5B%3Amap%20%5B%3Ax%20int%3F%5D%20%5B%3Ay%20int%3F%5D%5D%0A%20%5B%3Afn%0A%20%20%7B%3Aerror%2Fmessage%20%22x%20should%20be%20greater%20than%20y%22%7D%0A%20%20(fn%20%5B%7B%3Akeys%20%5Bx%20y%5D%7D%5D%20(%3E%20x%20y))%5D%5D</a> will give you inspiration?</z><z id="t1663081224" t="Anders Eknert Ooohh, that&apos;s very nice! Thanks very much 😃"><y>#</y><d>2022-09-13</d><h>15:00</h><r>Anders Eknert</r>Ooohh, that&apos;s very nice! Thanks very much <b>😃</b></z><z id="t1663081595" t="lread You are most welcome! I find it a great place to explore."><y>#</y><d>2022-09-13</d><h>15:06</h><r>lread</r>You are most welcome! I find it a great place to explore.</z><z id="t1663081835" t="Anders Eknert For sure! For whatever reason, I hadn&apos;t registered that was a thing before. Much appreciated 👍"><y>#</y><d>2022-09-13</d><h>15:10</h><r>Anders Eknert</r>For sure! For whatever reason, I hadn&apos;t registered that was a thing before. Much appreciated <b>👍</b></z><z id="t1663146084" t="Anders Eknert Back again 😅 While the custom validator function works for validation, I’ve found it breaks the default value transformer. My code looks something like this: (def Conf [:map [:polling [:and [:map {:default {}} [:min-delay-seconds [int? {:default 60}]] [:max-delay-seconds [int? {:default 120}]]] [:fn {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;} (fn [{:keys [min-delay-seconds max-delay-seconds]}] (&gt; min-delay-seconds max-delay-seconds))]]]]) Without the :and + :fn : (m/decode Conf {} mt/default-value-transformer) =&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}} And once that’s been added, the map comes back empty: (m/decode Conf {} mt/default-value-transformer) =&gt; {} I assume I’m doing something wrong, but I struggle with understanding what 🙂"><y>#</y><d>2022-09-14</d><h>09:01</h><r>Anders Eknert</r>Back again <b>😅</b> While the custom validator function works for validation, I’ve found it breaks the default value transformer. My code looks something like this:
<pre>(def Conf
  [:map
   [:polling
    [:and
     [:map {:default {}}
      [:min-delay-seconds [int? {:default 60}]]
      [:max-delay-seconds [int? {:default 120}]]]
     [:fn
      {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;}
      (fn [{:keys [min-delay-seconds max-delay-seconds]}]
        (&gt; min-delay-seconds max-delay-seconds))]]]])</pre>
Without the <code>:and</code>  + <code>:fn</code> :
<pre>(m/decode Conf {} mt/default-value-transformer)

=&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}}</pre>
And once that’s been added, the map comes back empty:
<pre>(m/decode Conf {} mt/default-value-transformer)

=&gt; {}</pre>
I assume I’m doing something wrong, but I struggle with understanding what <b>🙂</b></z><z id="t1663164754" t="lread Not at my dev box right now, but maybe due to {:default {}} ?"><y>#</y><d>2022-09-14</d><h>14:12</h><r>lread</r>Not at my dev box right now, but maybe due to <code>{:default {}}</code>?</z><z id="t1663165044" t="Anders Eknert Doesn’t make a difference I’m afraid… I’ve tried a large number of combinations, but apparently not the right one 😅"><y>#</y><d>2022-09-14</d><h>14:17</h><r>Anders Eknert</r>Doesn’t make a difference I’m afraid… I’ve tried a large number of combinations, but apparently not the right one <b>😅</b></z><z id="t1663166847" t="lread I don’t want to to think I know malli well at all, so there might be other ways. Moving the :default {} up seems to work: (require &apos;[malli.core :as m] &apos;[malli.transform :as mt]) (def Conf [:map [:polling {:default {}} [:and [:map [:min-delay-seconds [int? {:default 60}]] [:max-delay-seconds [int? {:default 120}]]] [:fn {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;} (fn [{:keys [min-delay-seconds max-delay-seconds]}] (&gt; min-delay-seconds max-delay-seconds))]]]]) (m/decode Conf {} mt/default-value-transformer) ;; =&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}} (m/decode Conf {:polling {:min-delay-seconds 1231}} mt/default-value-transformer) ;; =&gt; {:polling {:min-delay-seconds 1231, :max-delay-seconds 120}} "><y>#</y><d>2022-09-14</d><h>14:47</h><r>lread</r>I don’t want to to think I know malli well at all, so there might be other ways.

Moving the <code>:default {}</code> up seems to work:
<pre>(require &apos;[malli.core :as m]
         &apos;[malli.transform :as mt])

(def Conf
  [:map
   [:polling {:default {}}
    [:and
     [:map 
      [:min-delay-seconds [int? {:default 60}]]
      [:max-delay-seconds [int? {:default 120}]]]
     [:fn
      {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;}
      (fn [{:keys [min-delay-seconds max-delay-seconds]}]
        (&gt; min-delay-seconds max-delay-seconds))]]]])

(m/decode Conf {} mt/default-value-transformer)
;; =&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}}

(m/decode Conf {:polling {:min-delay-seconds 1231}} mt/default-value-transformer)
;; =&gt; {:polling {:min-delay-seconds 1231, :max-delay-seconds 120}}</pre>
</z><z id="t1663167011" t="Anders Eknert Wow, it does! I must have tried pretty much any combination but that one facepalm Thanks again, Lee! ⭐ ️"><y>#</y><d>2022-09-14</d><h>14:50</h><r>Anders Eknert</r>Wow, it does! I must have tried pretty much any combination but that one <b>facepalm</b> Thanks again, Lee!  <b>⭐</b>️</z><z id="t1663167072" t="lread My pleasure, more experienced mallites might chime in, but the above looks ok to me."><y>#</y><d>2022-09-14</d><h>14:51</h><r>lread</r>My pleasure, more experienced mallites might chime in, but the above looks ok to me.</z><z id="t1663090650" t="marciol Hey, I have some code that have dependencies on spec, something that I cannot address in the near term, so I still need to duplicate malli and spec schemas everywhere. I&apos;m just wondering if there is a lib that allows some sort of translation of malli schemas into spec schemas, in a way that we can make other spec dependent code thinks that a malli schema is a spec schema. Does anyone knows about some think like this?"><y>#</y><d>2022-09-13</d><h>17:37</h><w>marciol</w>Hey, I have some code that have dependencies on spec, something that I cannot address in the near term, so I still need to duplicate malli and spec schemas everywhere. I&apos;m just wondering if there is a lib that allows some sort of translation of malli schemas into spec schemas, in a way that we can make other spec dependent code thinks that a malli schema is a spec schema. Does anyone knows about some think like this?</z><z id="t1663093884" t="pithyless I&apos;m aware of: https://github.com/dvingo/malli-code-gen/blob/main/thoughts.md#clojurespecalpha https://github.com/dvingo/malli-code-gen/blob/main/src/main/space/matterandvoid/malli_gen/clojure_alpha_specs.cljc I remember reading the docs, but have no idea how complete the actual implementation is."><y>#</y><d>2022-09-13</d><h>18:31</h><r>pithyless</r>I&apos;m aware of: <a href="https://github.com/dvingo/malli-code-gen/blob/main/thoughts.md#clojurespecalpha" target="_blank">https://github.com/dvingo/malli-code-gen/blob/main/thoughts.md#clojurespecalpha</a>

<a href="https://github.com/dvingo/malli-code-gen/blob/main/src/main/space/matterandvoid/malli_gen/clojure_alpha_specs.cljc" target="_blank">https://github.com/dvingo/malli-code-gen/blob/main/src/main/space/matterandvoid/malli_gen/clojure_alpha_specs.cljc</a>

I remember reading the docs, but have no idea how complete the actual implementation is.</z><z id="t1663093938" t="marciol I will track this, can be a point where I can start. Thanks"><y>#</y><d>2022-09-13</d><h>18:32</h><r>marciol</r>I will track this, can be a point where I can start. Thanks</z><z id="t1663094324" t="pithyless I also remember this presentation showing how to generate domain models from malli (similar to the above repo thoughts). It&apos;s not directly related to clojure.spec, but perhaps you may gleam some insights if you go down the road of actually implementing this kind of generator. https://www.youtube.com/watch?v=ww9yR_rbgQs"><y>#</y><d>2022-09-13</d><h>18:38</h><r>pithyless</r>I also remember this presentation showing how to generate domain models from malli (similar to the above repo thoughts). It&apos;s not directly related to clojure.spec, but perhaps you may gleam some insights if you go down the road of actually implementing this kind of generator.

<a href="https://www.youtube.com/watch?v=ww9yR_rbgQs" target="_blank">https://www.youtube.com/watch?v=ww9yR_rbgQs</a></z><z id="t1663094565" t="pithyless I think both of these things came about before malli introduced https://github.com/metosin/malli#qualified-keys-in-a-map - perhaps with some clever use of macros and custom malli registries, you can get 80% there without much effort?"><y>#</y><d>2022-09-13</d><h>18:42</h><r>pithyless</r>I think both of these things came about before malli introduced <a href="https://github.com/metosin/malli#qualified-keys-in-a-map" target="_blank">https://github.com/metosin/malli#qualified-keys-in-a-map</a> - perhaps with some clever use of macros and custom malli registries, you can get 80% there without much effort?</z><z id="t1663094638" t="marciol Lets see, there is a lot of duplication going on so I need to solve it through some clever strategy"><y>#</y><d>2022-09-13</d><h>18:43</h><r>marciol</r>Lets see, there is a lot of duplication going on so I need to solve it through some clever strategy</z><z id="t1663097515" t="dvingo Yea, I paused working on that, but the good news is that since then malli added malli.core/ast which makes it a lot easier to parse and walk schemas. I have a transform for taking malli schemas describing a hashmap and producing pathom output vectors that is working: https://gist.github.com/dvingo/213633acfdd520bddcdc91fc1c7b9e44 you should be able to do something similar to output clojure specs. The Kondo output has a more complete set of schema types: https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc"><y>#</y><d>2022-09-13</d><h>19:31</h><r>dvingo</r>Yea, I paused working on that, but the good news is that since then malli added <code>malli.core/ast</code> which makes it a lot easier to parse and walk schemas.

I have a transform for taking malli schemas describing a hashmap and producing pathom output vectors that is working:
<a href="https://gist.github.com/dvingo/213633acfdd520bddcdc91fc1c7b9e44" target="_blank">https://gist.github.com/dvingo/213633acfdd520bddcdc91fc1c7b9e44</a>

you should be able to do something similar to output clojure specs. The Kondo output has a more complete set of schema types:
<a href="https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/clj_kondo.cljc</a></z><z id="t1663097549" t="marciol 🙌"><y>#</y><d>2022-09-13</d><h>19:32</h><r>marciol</r><b>🙌</b></z><z id="t1663097623" t="dvingo I think [:attrs {:href &quot;/_/_/users/U0A5V8ZR6&quot;}] continued working on something similar https://github.com/Blasterai/malli-datomic/blob/master/src/blasterai/malli_datomic/spec_utils.cljc"><y>#</y><d>2022-09-13</d><h>19:33</h><r>dvingo</r>I think <a>@U0A5V8ZR6</a> continued working on something similar
<a href="https://github.com/Blasterai/malli-datomic/blob/master/src/blasterai/malli_datomic/spec_utils.cljc" target="_blank">https://github.com/Blasterai/malli-datomic/blob/master/src/blasterai/malli_datomic/spec_utils.cljc</a></z><z id="t1663104516" t="escherize I want to use malli for the clj-kondo type-mismatch stuff on a large clojure project. But I’d rather not add it as a dependency. Is there a way to make malli.core/=&gt; annotate functions in other namespaces? Then I can put all my m/=&gt; ’s into an un-committed namespace and still get the benefits of () . I looked at the code, and adding the feature doesn’t seem too tough. But I may be missing another approach"><y>#</y><d>2022-09-13</d><h>21:28</h><w>escherize</w>I want to use malli for the clj-kondo type-mismatch stuff on a large clojure project. But I’d rather not add it as a dependency. Is there a way to make malli.core/=&gt; annotate functions in other namespaces? Then I can put all my <code>m/=&gt;</code>’s into an un-committed namespace and still get the benefits of <code>()</code>. I looked at the code, and adding the feature doesn’t seem too tough. But I may be missing another approach</z><z id="t1663108203" t="dvingo yea that should be possible with a little custom code. Underneath =&gt; just calls -register-function-schema https://github.com/metosin/malli/blob/bf92680ad76e57697261dd45c52dd31ffa9a8e1e/src/malli/instrument.clj#L41 which takes an ns symbol, a name symbol, a schema and a metadata map"><y>#</y><d>2022-09-13</d><h>22:30</h><r>dvingo</r>yea that should be possible with a little custom code. Underneath <code>=&gt;</code> just calls <code>-register-function-schema</code>
<a href="https://github.com/metosin/malli/blob/bf92680ad76e57697261dd45c52dd31ffa9a8e1e/src/malli/instrument.clj#L41" target="_blank">https://github.com/metosin/malli/blob/bf92680ad76e57697261dd45c52dd31ffa9a8e1e/src/malli/instrument.clj#L41</a>
which takes an ns symbol, a name symbol, a schema and a metadata map</z><z id="t1663135938" t="ikitommi maybe m/=&gt; should allow qualified symbols too? e.g. (m/=&gt; my.domain/foo ...)"><y>#</y><d>2022-09-14</d><h>06:12</h><r>ikitommi</r>maybe <code>m/=&gt;</code> should allow qualified symbols too? e.g.
<pre>(m/=&gt; my.domain/foo ...)</pre></z><z id="t1663135962" t="ikitommi would not be a big change I guess: https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2440-L2442"><y>#</y><d>2022-09-14</d><h>06:12</h><r>ikitommi</r>would not be a big change I guess: <a href="https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2440-L2442" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/core.cljc#L2440-L2442</a></z><z id="t1663105932" t="escherize How do I make a schema for a vector that has 3 items: int, nil, string? e.g. [1 nil &quot;a&quot;] I can make a vector that is homogenous, or I can make a list using sequence schema. But I can’t figure this one out"><y>#</y><d>2022-09-13</d><h>21:52</h><w>escherize</w>How do I make a schema for a vector that has 3 items: int, nil, string? e.g. <code>[1 nil &quot;a&quot;]</code> I can make a vector that is homogenous, or I can make a list using sequence schema. But I can’t figure this one out</z><z id="t1663129367" t="ikitommi try [:tuple :int :nil :string]"><y>#</y><d>2022-09-14</d><h>04:22</h><r>ikitommi</r>try <code>[:tuple :int :nil :string]</code></z><z id="t1663175061" t="escherize Exactly right! In hindsight I could have also: (mp/provide [[1 nil &quot;x&quot;] [2 nil &quot;y&quot;] [1 nil &quot;z&quot;]] {:malli.provider/tuple-threshold 3})"><y>#</y><d>2022-09-14</d><h>17:04</h><r>escherize</r>Exactly right! In hindsight I could have also:

<pre>(mp/provide
 [[1 nil &quot;x&quot;]
  [2 nil &quot;y&quot;]
  [1 nil &quot;z&quot;]]
 {:malli.provider/tuple-threshold 3})</pre></z><z id="t1663146084" t="Anders Eknert Back again 😅 While the custom validator function works for validation, I’ve found it breaks the default value transformer. My code looks something like this: (def Conf [:map [:polling [:and [:map {:default {}} [:min-delay-seconds [int? {:default 60}]] [:max-delay-seconds [int? {:default 120}]]] [:fn {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;} (fn [{:keys [min-delay-seconds max-delay-seconds]}] (&gt; min-delay-seconds max-delay-seconds))]]]]) Without the :and + :fn : (m/decode Conf {} mt/default-value-transformer) =&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}} And once that’s been added, the map comes back empty: (m/decode Conf {} mt/default-value-transformer) =&gt; {} I assume I’m doing something wrong, but I struggle with understanding what 🙂"><y>#</y><d>2022-09-14</d><h>09:01</h><w>Anders Eknert</w>Back again <b>😅</b> While the custom validator function works for validation, I’ve found it breaks the default value transformer. My code looks something like this:
<pre>(def Conf
  [:map
   [:polling
    [:and
     [:map {:default {}}
      [:min-delay-seconds [int? {:default 60}]]
      [:max-delay-seconds [int? {:default 120}]]]
     [:fn
      {:error/message &quot;max polling delay must be &gt;= min polling delay&quot;}
      (fn [{:keys [min-delay-seconds max-delay-seconds]}]
        (&gt; min-delay-seconds max-delay-seconds))]]]])</pre>
Without the <code>:and</code>  + <code>:fn</code> :
<pre>(m/decode Conf {} mt/default-value-transformer)

=&gt; {:polling {:min-delay-seconds 60, :max-delay-seconds 120}}</pre>
And once that’s been added, the map comes back empty:
<pre>(m/decode Conf {} mt/default-value-transformer)

=&gt; {}</pre>
I assume I’m doing something wrong, but I struggle with understanding what <b>🙂</b></z><z id="t1663306769" t="robert-stuttaford just sanity-checking that this is appropriate - when using a registry, and having registered a spec for :my/keyword e.g. :string , then using that keyword in a :map, i simply do [:map [:my/keyword :my/keyword]] - there isn&apos;t some simpler syntax to use similar to clojure.spec.alpha/keys ?"><y>#</y><d>2022-09-16</d><h>05:39</h><w>robert-stuttaford</w>just sanity-checking that this is appropriate - when using a registry, and having registered a spec for <code>:my/keyword</code> e.g. <code>:string</code>, then using that keyword in a :map, i simply do <code>[:map [:my/keyword :my/keyword]]</code>  - there isn&apos;t some simpler syntax to use similar to <code>clojure.spec.alpha/keys</code> ?</z><z id="t1663336352" t="kenny I believe you can replace the vector with just the qualified keyword. e.g., [:map :my/keyword]"><y>#</y><d>2022-09-16</d><h>13:52</h><r>kenny</r>I believe you can replace the vector with just the qualified keyword. e.g., [:map :my/keyword]</z><z id="t1663337030" t="robert-stuttaford sweet i&apos;ll try that!"><y>#</y><d>2022-09-16</d><h>14:03</h><r>robert-stuttaford</r>sweet i&apos;ll try that!</z><z id="t1663306801" t="robert-stuttaford also, i can use recursive :ref in a mutable registry, right? update: yes you can"><y>#</y><d>2022-09-16</d><h>05:40</h><w>robert-stuttaford</w>also, i can use recursive <code>:ref</code> in a mutable registry, right? update: yes you can</z><z id="t1663355187" t="John Maruska Is there a way to merge two constrained maps (`[:and [:map ...] [:fn ...]]`) together that doesn&apos;t drop the :fn s of the second map? I haven&apos;t been able to figure it out so far, so (gen/sample-seq (mg/generator my-schema)) is giving results that fail m/validate"><y>#</y><d>2022-09-16</d><h>19:06</h><w>John Maruska</w>Is there a way to merge two constrained maps (`[:and [:map ...] [:fn ...]]`) together that doesn&apos;t drop the <code>:fn</code>s of the second map?  I haven&apos;t been able to figure it out so far, so <code>(gen/sample-seq (mg/generator my-schema))</code> is giving results that fail <code>m/validate</code></z><z id="t1663504727" t="ikitommi :thinking_face: with the latest master: (mu/merge [:and [:map [:x :int]] [:fn &apos;map?]] [:and [:map [:y :int]] [:fn &apos;coll?]]) ;[:and ; [:map [:x :int] [:y :int]] ; [:fn map?] ; [:fn coll?]]"><y>#</y><d>2022-09-18</d><h>12:38</h><r>ikitommi</r><b>:thinking_face:</b> with the latest master:
<pre>(mu/merge
 [:and
  [:map [:x :int]]
  [:fn &apos;map?]]
 [:and
  [:map [:y :int]]
  [:fn &apos;coll?]])
;[:and 
; [:map [:x :int] [:y :int]] 
; [:fn map?] 
; [:fn coll?]]</pre></z><z id="t1663504776" t="ikitommi looks correct [:attrs {:href &quot;/_/_/users/U8VJYTQ76&quot;}] ?"><y>#</y><d>2022-09-18</d><h>12:39</h><r>ikitommi</r>looks correct <a>@U8VJYTQ76</a>?</z><z id="t1663599701" t="John Maruska Guess I just needed the weekend break -- found the issue this morning inside the function in my :fn"><y>#</y><d>2022-09-19</d><h>15:01</h><r>John Maruska</r>Guess I just needed the weekend break -- found the issue this morning inside the function in my <code>:fn</code></z><z id="t1663500554" t="Ory Band Hi. I&apos;m trying ot use a default fn value transformer from the tips section ( https://github.com/metosin/malli/blob/master/docs/tips.md#default-value-from-a-function ) and also discussed here https://clojurians.slack.com/archives/CLDK6MFMK/p1626171933375100 , but sci fails with &quot;could not resolve symbol&quot; with the function i&apos;m using. Any idea why? ; (err) Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:39). ; (err) Could not resolve symbol: get-num-cpus"><y>#</y><d>2022-09-18</d><h>11:29</h><w>Ory Band</w>Hi. I&apos;m trying ot use a default fn value transformer from the tips section (<a href="https://github.com/metosin/malli/blob/master/docs/tips.md#default-value-from-a-function" target="_blank">https://github.com/metosin/malli/blob/master/docs/tips.md#default-value-from-a-function</a>) and also discussed here <a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1626171933375100" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1626171933375100</a>,

but sci fails with &quot;could not resolve symbol&quot; with the function i&apos;m using. Any idea why?
<pre>; (err) Execution error (ExceptionInfo) at sci.impl.utils/throw-error-with-location (utils.cljc:39).
; (err) Could not resolve symbol: get-num-cpus</pre></z><z id="t1663501215" t="Ory Band got a response from borkdude here, unclear how to proceed though - how to pass a namespace? https://clojurians.slack.com/archives/C015LCR9MHD/p1663501053285409"><y>#</y><d>2022-09-18</d><h>11:40</h><r>Ory Band</r>got a response from borkdude here, unclear how to proceed though - how to pass a namespace? <a href="https://clojurians.slack.com/archives/C015LCR9MHD/p1663501053285409" target="_blank">https://clojurians.slack.com/archives/C015LCR9MHD/p1663501053285409</a></z><z id="t1663504856" t="ikitommi you can pass in the normal sci-options via :malli.core/sci-options . what ever sci accepts, is accepted here too: (m/validate [:fn &apos;(fn [arg] (malli.impl.util/-invalid? arg))] ::m/invalid {::m/sci-options {:namespaces {&apos;malli.impl.util {&apos;-invalid? malli.impl.util/-invalid?}}}}) ; =&gt; true"><y>#</y><d>2022-09-18</d><h>12:40</h><r>ikitommi</r>you can pass in the normal sci-options via <code>:malli.core/sci-options</code>. what ever sci accepts, is accepted here too:
<pre>(m/validate
 [:fn &apos;(fn [arg] (malli.impl.util/-invalid? arg))]
 ::m/invalid
 {::m/sci-options {:namespaces {&apos;malli.impl.util {&apos;-invalid? malli.impl.util/-invalid?}}}})
; =&gt; true</pre></z><z id="t1663504888" t="ikitommi sci readme seems to have tips and helpers on how to bind multiple things at once."><y>#</y><d>2022-09-18</d><h>12:41</h><r>ikitommi</r>sci readme seems to have tips and helpers on how to bind multiple things at once.</z><z id="t1663504893" t="Ory Band specifically in my case, how can i add my custom fn get-num-cpu ?"><y>#</y><d>2022-09-18</d><h>12:41</h><r>Ory Band</r>specifically in my case, how can i add my custom fn <code>get-num-cpu</code>?</z><z id="t1663505051" t="ikitommi (defn get-num-cpus [] (-&gt; (Runtime/getRuntime) .availableProcessors)) (m/validate [:fn &apos;(fn [arg] (= arg (get-num-cpus)))] 10 {::m/sci-options {:namespaces {&apos;user {&apos;get-num-cpus get-num-cpus}}}}) ; =&gt; true"><y>#</y><d>2022-09-18</d><h>12:44</h><r>ikitommi</r><pre>(defn get-num-cpus []
  (-&gt; (Runtime/getRuntime) .availableProcessors))

(m/validate
 [:fn &apos;(fn [arg] (= arg (get-num-cpus)))]
 10
 {::m/sci-options {:namespaces {&apos;user {&apos;get-num-cpus get-num-cpus}}}})
; =&gt; true</pre></z><z id="t1663505237" t="ikitommi does that solve the issue?"><y>#</y><d>2022-09-18</d><h>12:47</h><r>ikitommi</r>does that solve the issue?</z><z id="t1663505250" t="ikitommi but, do you need sci here?"><y>#</y><d>2022-09-18</d><h>12:47</h><r>ikitommi</r>but, do you need sci here?</z><z id="t1663505254" t="Ory Band thanks tommi! testing, getting back to you soon"><y>#</y><d>2022-09-18</d><h>12:47</h><r>Ory Band</r>thanks tommi! testing, getting back to you soon</z><z id="t1663505271" t="Ory Band hmm, i thought i did. don&apos;t i? i need to calculate the value based on amount of available cpus"><y>#</y><d>2022-09-18</d><h>12:47</h><r>Ory Band</r>hmm, i thought i did. don&apos;t i? i need to calculate the value based on amount of available cpus</z><z id="t1663505274" t="ikitommi you could also just remove the &apos; and say #(hash-map :thread-count (* 5 (get-num-cpus)))"><y>#</y><d>2022-09-18</d><h>12:47</h><r>ikitommi</r>you could also just remove the <code>&apos;</code> and say <code>#(hash-map :thread-count (* 5 (get-num-cpus)))</code></z><z id="t1663505291" t="Ory Band wait. i could do that? i thought you couldn&apos;t pass functions"><y>#</y><d>2022-09-18</d><h>12:48</h><r>Ory Band</r>wait. i could do that? i thought you couldn&apos;t pass functions</z><z id="t1663505308" t="ikitommi m/eval takes any function or a source code. for the latter, it uses sci to interpret it."><y>#</y><d>2022-09-18</d><h>12:48</h><r>ikitommi</r><code>m/eval</code> takes any function or a source code. for the latter, it uses sci to interpret it.</z><z id="t1663505339" t="ikitommi you can’t store normal functions as data (over wire / db etc), but if you don’t need that, you don’t have to use sci."><y>#</y><d>2022-09-18</d><h>12:48</h><r>ikitommi</r>you can’t store normal functions as data (over wire / db etc), but if you don’t need that, you don’t have to use sci.</z><z id="t1663505359" t="Ory Band and i can put a fn under the :default key and it would work?"><y>#</y><d>2022-09-18</d><h>12:49</h><r>Ory Band</r>and i can put a fn under the <code>:default</code> key and it would work?</z><z id="t1663505400" t="ikitommi yes"><y>#</y><d>2022-09-18</d><h>12:50</h><r>ikitommi</r>yes</z><z id="t1663505407" t="ikitommi (m/validate [:fn #(= % (get-num-cpus))] 10) ; =&gt; true"><y>#</y><d>2022-09-18</d><h>12:50</h><r>ikitommi</r><pre>(m/validate
 [:fn #(= % (get-num-cpus))]
 10)
; =&gt; true</pre></z><z id="t1663505431" t="Ory Band amazing. i&apos;m going to test that and get back to you. another question: what if i need to calculate the :default based on another key&apos;s input?"><y>#</y><d>2022-09-18</d><h>12:50</h><r>Ory Band</r>amazing. i&apos;m going to test that and get back to you.
another question: what if i need to calculate the <code>:default</code> based on another key&apos;s input?</z><z id="t1663505438" t="Ory Band not storing this as data"><y>#</y><d>2022-09-18</d><h>12:50</h><r>Ory Band</r>not storing this as data</z><z id="t1663505465" t="Ory Band see this example, how can i avoid sci? [:parallel-pull-count {:title &quot;Pull messages thread count&quot; :description &quot;&quot; :default 1} pos-int?] [:ack-and-lease-extension-thread-count {:title &quot;ACK processing and lease extension thread count&quot; :description &quot;&quot; ; immitate java-pubsub&apos;s default value ; :default-fn &apos;#(max 6 (* 2 (:parallel-pull-count %)))} pos-int?]]]])"><y>#</y><d>2022-09-18</d><h>12:51</h><r>Ory Band</r>see this example, how can i avoid sci?
<pre>[:parallel-pull-count
      {:title       &quot;Pull messages thread count&quot;
       :description &quot;&quot;
       :default 1}
      pos-int?]
     [:ack-and-lease-extension-thread-count
      {:title       &quot;ACK processing and lease extension thread count&quot;
       :description &quot;&quot;
       ; immitate java-pubsub&apos;s default value
       ; 
       :default-fn &apos;#(max 6 (* 2 (:parallel-pull-count %)))}
      pos-int?]]]])</pre></z><z id="t1663505611" t="ikitommi currently, the transformation interceptors don’t see their parents, so, attaching a transformer into a map key -&gt; just sees that key &amp; it’s children. This could be changed, but would need an issue and some thinking on how to do that."><y>#</y><d>2022-09-18</d><h>12:53</h><r>ikitommi</r>currently, the transformation interceptors don’t see their parents, so, attaching a transformer into a map key -&gt; just sees that key &amp; it’s children. This could be changed, but would need an issue and some thinking on how to do that.</z><z id="t1663505649" t="ikitommi but, you can attach the default values into the :map itself -&gt; in that case the default-fn sees the whole map."><y>#</y><d>2022-09-18</d><h>12:54</h><r>ikitommi</r>but, you can attach the default values into the <code>:map</code> itself -&gt; in that case the default-fn sees the whole map.</z><z id="t1663505689" t="Ory Band yeah but in case the map was given by the user and one of the keys is missing, i want to support defaulting there as well"><y>#</y><d>2022-09-18</d><h>12:54</h><r>Ory Band</r>yeah but in case the map was given by the user and one of the keys is missing, i want to support defaulting there as well</z><z id="t1663505810" t="Ory Band btw, just tried your suggestion and it doesn&apos;t work: :default #(hash-map :thread-count (* 5 (get-num-cpus)))} i&apos;m getting ; (out) clojure.lang.ExceptionInfo: Invalid configuration {&quot;parsing_errors&quot; {:concurrency [&quot;invalid type&quot;]}}"><y>#</y><d>2022-09-18</d><h>12:56</h><r>Ory Band</r>btw, just tried your suggestion and it doesn&apos;t work:
<pre>:default #(hash-map :thread-count (* 5 (get-num-cpus)))}</pre>
i&apos;m getting
<pre>; (out) clojure.lang.ExceptionInfo: Invalid configuration {&quot;parsing_errors&quot; {:concurrency [&quot;invalid type&quot;]}}</pre></z><z id="t1663506250" t="Ory Band what am i doing wrong?"><y>#</y><d>2022-09-18</d><h>13:04</h><r>Ory Band</r>what am i doing wrong?</z><z id="t1663506525" t="ikitommi the :default key is defined in the default-value-transformer and it should be a value, e.g. (hash-map :thread-count (* 5 (get-num-cpus))) . the default-fn-value-transformer defines a key :default-fn which can be a function, e.g. #(hash-map :thread-count (* 5 (get-num-cpus))) ."><y>#</y><d>2022-09-18</d><h>13:08</h><r>ikitommi</r>the <code>:default</code> key is defined in the <code>default-value-transformer</code> and it should be a value, e.g. <code>(hash-map :thread-count (* 5 (get-num-cpus)))</code>. the <code>default-fn-value-transformer</code> defines a key <code>:default-fn</code> which can be a function, e.g. <code>#(hash-map :thread-count (* 5 (get-num-cpus)))</code>.</z><z id="t1663506602" t="ikitommi (m/decode [:map {:default {}} [:x {:default (get-num-cpus)} string?] [:y {:default-fn #(* (get-num-cpus) (:x %))} string?]] nil (mt/transformer (mt/default-value-transformer) (default-fn-value-transformer))) ; =&gt; {:x 10, :y 100}"><y>#</y><d>2022-09-18</d><h>13:10</h><r>ikitommi</r><pre>(m/decode
 [:map {:default {}}
  [:x {:default (get-num-cpus)} string?]
  [:y {:default-fn #(* (get-num-cpus) (:x %))} string?]]
 nil
 (mt/transformer
  (mt/default-value-transformer)
  (default-fn-value-transformer)))
; =&gt; {:x 10, :y 100}</pre></z><z id="t1663506626" t="Ory Band so i should use default-fn then"><y>#</y><d>2022-09-18</d><h>13:10</h><r>Ory Band</r>so i should use <code>default-fn</code> then</z><z id="t1663506638" t="ikitommi I think so"><y>#</y><d>2022-09-18</d><h>13:10</h><r>ikitommi</r>I think so</z><z id="t1663506641" t="Ory Band testing"><y>#</y><d>2022-09-18</d><h>13:10</h><r>Ory Band</r>testing</z><z id="t1663508426" t="Ory Band it works. thank you!"><y>#</y><d>2022-09-18</d><h>13:40</h><r>Ory Band</r>it works. thank you!</z><z id="t1663530625" t="Anders Eknert &gt; currently, the transformation interceptors don’t see their parents, so, attaching a transformer into a map key -&gt; just sees that key &amp; it’s children. This could be changed, but would need an issue and some thinking on how to do that. Interesting. That’s just the issue I was struggling with 😅 Should I create an issue?"><y>#</y><d>2022-09-18</d><h>19:50</h><r>Anders Eknert</r>&gt; currently, the transformation interceptors don’t see their parents, so, attaching a transformer into a map key -&gt; just sees that key &amp; it’s children. This could be changed, but would need an issue and some thinking on how to do that.
Interesting. That’s just the issue I was struggling with <b>😅</b> Should I create an issue?</z><z id="t1663531430" t="Anders Eknert To be more specific, I’m trying to get the name in the key of a :map-of construct, and use it as a default for one of the values in a sub-map"><y>#</y><d>2022-09-18</d><h>20:03</h><r>Anders Eknert</r>To be more specific, I’m trying to get the name in the key of a <code>:map-of</code> construct, and use it as a default for one of the values in a sub-map</z><z id="t1663664540" t="hmadelaine Hi everyone ! I have a question regarding malli.error/humanize and a sequential schema. I have modified the example given in the README. Instead of having a nil latitude, I put a string. (-&gt; Address (m/explain {:id &quot;ID676&quot; :tags #{:artesan :coffee :garden} :address {:street &quot;Ahlmanintie 29&quot; :city &quot;paris&quot; :zip 33100 :lonlat [61.4858322, &quot;23.89&quot;]}}) (me/humanize)) =&gt; {:address {:lonlat [nil [&quot;should be a double&quot;]]}} I was expecting in the humanized error, this output : {:address {:lonlat [&quot;23.89&quot; [&quot;should be a double&quot;]]}} The result of m/explain indicates clearly in the errors that the input “23.89&quot; is incorrect. {:schema [:map [:id string?] [:tags [:set keyword?]] [:address [:map [:street string?] [:city string?] [:zip int?] [:lonlat [:tuple double? double?]]]]], :value {:id &quot;Hiram&quot;, :tags #{:coffee :artesan :garden}, :address {:street &quot;Ahlmanintie 29&quot;, :city &quot;paris&quot;, :zip 33100, :lonlat [61.4858322 &quot;23.89&quot;]}}, :errors ({:path [:address :lonlat 1], :in [:address :lonlat 1], :schema double?, :value &quot;23.89&quot;})} Is it normal ? Thnak you very much"><y>#</y><d>2022-09-20</d><h>09:02</h><w>hmadelaine</w>Hi everyone !
I have a question regarding <code>malli.error/humanize</code>and a <code>sequential</code>  schema.

I have modified the example given in the README.
Instead of having a <code>nil</code>  latitude, I put a string.
<pre>(-&gt; Address
      (m/explain
        {:id      &quot;ID676&quot;
         :tags    #{:artesan :coffee :garden}
         :address {:street &quot;Ahlmanintie 29&quot;
                   :city    &quot;paris&quot;
                   :zip    33100
                   :lonlat [61.4858322, &quot;23.89&quot;]}})
      (me/humanize))
=&gt; {:address {:lonlat [nil [&quot;should be a double&quot;]]}}</pre>
I was expecting in the humanized error,  this output :
<pre>{:address {:lonlat [&quot;23.89&quot; [&quot;should be a double&quot;]]}}</pre>
The result of <code>m/explain</code>  indicates clearly in the errors that the input “23.89&quot; is incorrect.

<pre>{:schema [:map
          [:id string?]
          [:tags [:set keyword?]]
          [:address [:map [:street string?] [:city string?] [:zip int?] [:lonlat [:tuple double? double?]]]]],
 :value {:id &quot;Hiram&quot;,
         :tags #{:coffee :artesan :garden},
         :address {:street &quot;Ahlmanintie 29&quot;, :city &quot;paris&quot;, :zip 33100, :lonlat [61.4858322 &quot;23.89&quot;]}},
 :errors ({:path [:address :lonlat 1], :in [:address :lonlat 1], :schema double?, :value &quot;23.89&quot;})}</pre>
Is it normal ?
Thnak you very much</z><z id="t1663682400" t="ikitommi this is normal, for sequential, nil are used to mask the valid values, e.g. “second and fourth elements in error” = [nil nil [&quot;error&quot;] nil [&quot;error&quot;]]"><y>#</y><d>2022-09-20</d><h>14:00</h><r>ikitommi</r>this is normal, for sequential, <code>nil</code> are used to mask the valid values, e.g. “second and fourth elements in error” = <code>[nil nil [&quot;error&quot;] nil [&quot;error&quot;]]</code></z><z id="t1663682449" t="ikitommi you can configure how to show the valid values, e.g. (-&gt; Address (m/explain {:id &quot;Lillan&quot; :tags #{:artesan &quot;coffee&quot; :garden &quot;ground&quot;} :address {:street &quot;Ahlmanintie 29&quot; :zip 33100 :lonlat [61.4858322, &quot;23.7832851,17&quot;]}}) (me/error-value {::me/mask-valid-values &apos;...})) ;{:id ... ; :tags #{&quot;coffee&quot; &quot;ground&quot; ...} ; :address {:street ... ; :zip ... ; :lonlat [... &quot;23.7832851,17&quot;]}}"><y>#</y><d>2022-09-20</d><h>14:00</h><r>ikitommi</r>you can configure how to show the valid values, e.g.
<pre>(-&gt; Address
    (m/explain
     {:id &quot;Lillan&quot;
      :tags #{:artesan &quot;coffee&quot; :garden &quot;ground&quot;}
      :address {:street &quot;Ahlmanintie 29&quot;
                :zip 33100
                :lonlat [61.4858322, &quot;23.7832851,17&quot;]}})
    (me/error-value {::me/mask-valid-values &apos;...}))
;{:id ...
; :tags #{&quot;coffee&quot; &quot;ground&quot; ...}
; :address {:street ...
;           :zip ...
;           :lonlat [... &quot;23.7832851,17&quot;]}}</pre></z><z id="t1663683760" t="hmadelaine Alright ! Thank you very much 👍"><y>#</y><d>2022-09-20</d><h>14:22</h><r>hmadelaine</r>Alright ! Thank you very much <b>👍</b></z><z id="t1663685461" t="hmadelaine It seems that me/error-value is not available in 0.8.9 ?"><y>#</y><d>2022-09-20</d><h>14:51</h><r>hmadelaine</r>It seems that <code>me/error-value</code>  is not available in <code>0.8.9</code> ?</z><z id="t1663686423" t="hmadelaine Do you plan to release malli this month ?"><y>#</y><d>2022-09-20</d><h>15:07</h><r>hmadelaine</r>Do you plan to release malli this month ?</z><z id="t1663688878" t="ikitommi yrs"><y>#</y><d>2022-09-20</d><h>15:47</h><r>ikitommi</r>yrs</z><z id="t1663688925" t="hmadelaine Thank you for the excellent work 🙏"><y>#</y><d>2022-09-20</d><h>15:48</h><r>hmadelaine</r>Thank you for the excellent work <b>🙏</b></z><z id="t1663750427" t="hmadelaine Hi ! With metosin/spec-tools I use the function (select-spec spec value) I did not find an equivalent in malli Do you plan to add it later or should I add it to my own ns malli.utils ? Thanks"><y>#</y><d>2022-09-21</d><h>08:53</h><w>hmadelaine</w>Hi !
With <code>metosin/spec-tools</code> I use the function <code>(select-spec spec value)</code>
I did not find an equivalent in <code>malli</code>
Do you plan to add it later or should I add it to my own ns <code>malli.utils</code>?
Thanks</z><z id="t1663751719" t="ikitommi there is no helper, but: (m/decode schema value (mt/strip-extra-keys-transformer))"><y>#</y><d>2022-09-21</d><h>09:15</h><r>ikitommi</r>there is no helper, but:
<pre>(m/decode schema value (mt/strip-extra-keys-transformer))</pre></z><z id="t1663751768" t="hmadelaine Yes that is what I did 😉 Thank you"><y>#</y><d>2022-09-21</d><h>09:16</h><r>hmadelaine</r>Yes that is what I did <b>😉</b>
Thank you</z><z id="t1663751785" t="ikitommi for perf: (def select-address (m/decoder Address (mt/strip-extra-keys-transformer))) (select-address value)"><y>#</y><d>2022-09-21</d><h>09:16</h><r>ikitommi</r>for perf:
<pre>(def select-address (m/decoder Address (mt/strip-extra-keys-transformer)))

(select-address value)</pre></z></g><g id="s26"><z id="t1663751808" t="ikitommi if you have both spec-tools and malli, please share perf numbers on that. I think it’s… big"><y>#</y><d>2022-09-21</d><h>09:16</h><r>ikitommi</r>if you have both spec-tools and malli, please share perf numbers on that. I think it’s… big</z><z id="t1663751858" t="hmadelaine Good idea"><y>#</y><d>2022-09-21</d><h>09:17</h><r>hmadelaine</r>Good idea</z><z id="t1663865849" t="Ben Sless Found some performance improvement opportunities around parsing, especially around regex parsers. Also, trying to fold and/or parsers, but it&apos;s confusing 🙃"><y>#</y><d>2022-09-22</d><h>16:57</h><w>Ben Sless</w>Found some performance improvement opportunities around parsing, especially around regex parsers.
Also, trying to fold and/or parsers, but it&apos;s confusing <b>🙃</b></z><z id="t1663867273" t="ikitommi looking forward!"><y>#</y><d>2022-09-22</d><h>17:21</h><r>ikitommi</r>looking forward!</z><z id="t1663867287" t="ikitommi to"><y>#</y><d>2022-09-22</d><h>17:21</h><r>ikitommi</r>to</z><z id="t1663867514" t="Ben Sless Would appreciate a pointer regarding what I&apos;m getting wrong with orn this is the or parser: (defn- -or-&gt;parser [children] (fn [f] (let [parsers (-vmap f children)] #?(:clj (reduce (fn [acc parser] (fn [data] (let [parsed (acc data)] (if (miu/-invalid? parsed) (parser data) parsed)))) (fn [_] ::invalid) (reverse parsers)) :cljs #(reduce (fn [_ parser] (miu/-map-valid reduced (parser %))) ::invalid parsers))))) And the orn parser doesn&apos;t work (defn- -orn-&gt;parser [this] #?(:clj (reduce (fn [acc [k _ c]] (let [parser (-parser c)] (fn [data] (let [parsed (acc data)] (if (miu/-invalid? parsed) (parser data) (miu/-tagged k parsed)))))) (fn [_] ::invalid) (reverse (-children this))) :cljs (let [parsers (-vmap (fn [[k _ c]] (let [c (-parser c)] (fn [x] (miu/-map-valid #(reduced (miu/-tagged k %)) (c x))))) (-children this))] (fn [x] (reduce (fn [_ parser] (parser x)) x parsers))))) "><y>#</y><d>2022-09-22</d><h>17:25</h><r>Ben Sless</r>Would appreciate a pointer regarding what I&apos;m getting wrong with <code>orn</code>
this is the <code>or</code> parser:
<pre>(defn- -or-&gt;parser
  [children]
  (fn [f]
    (let [parsers (-vmap f children)]
      #?(:clj
         (reduce
          (fn [acc parser]
            (fn [data]
              (let [parsed (acc data)]
                (if (miu/-invalid? parsed)
                  (parser data)
                  parsed))))
          (fn [_] ::invalid)
          (reverse parsers))
         :cljs
         #(reduce (fn [_ parser] (miu/-map-valid reduced (parser %))) ::invalid parsers)))))</pre>
And the <code>orn</code> parser doesn&apos;t work
<pre>(defn- -orn-&gt;parser
  [this]
  #?(:clj
     (reduce
      (fn [acc [k _ c]]
        (let [parser (-parser c)]
          (fn [data]
            (let [parsed (acc data)]
              (if (miu/-invalid? parsed)
                (parser data)
                (miu/-tagged k parsed))))))
      (fn [_] ::invalid)
      (reverse (-children this)))
     :cljs
     (let [parsers (-vmap (fn [[k _ c]]
                            (let [c (-parser c)]
                              (fn [x] (miu/-map-valid #(reduced (miu/-tagged k %)) (c x)))))
                          (-children this))]
       (fn [x] (reduce (fn [_ parser] (parser x)) x parsers)))))</pre>
</z><z id="t1663999647" t="Ben Sless Anyway, first MR which I&apos;m sure of submitted. Would you like to see before/after comparisons?"><y>#</y><d>2022-09-24</d><h>06:07</h><r>Ben Sless</r>Anyway, first MR which I&apos;m sure of submitted. Would you like to see before/after comparisons?</z><z id="t1663868737" t="Ben Sless I decided to break things apart and start with the improvements I&apos;m sure of https://github.com/metosin/malli/pull/756"><y>#</y><d>2022-09-22</d><h>17:45</h><w>Ben Sless</w>I decided to break things apart and start with the improvements I&apos;m sure of
<a href="https://github.com/metosin/malli/pull/756" target="_blank">https://github.com/metosin/malli/pull/756</a></z><z id="t1663868858" t="Ben Sless One radical thing I&apos;ve considered trying is pivoting the values array in the Cache to as many arrays as CacheEntry has fields, avoids allocation and makes the entire thing cache friendly"><y>#</y><d>2022-09-22</d><h>17:47</h><w>Ben Sless</w>One radical thing I&apos;ve considered trying is pivoting the values array in the Cache to as many arrays as CacheEntry has fields, avoids allocation and makes the entire thing cache friendly</z><z id="t1663869732" t="dvingo after a comment by Thomas Heller ( https://github.com/metosin/malli/pull/754#issuecomment-1252581659 ) I refactored the cljs function instrumentation https://github.com/metosin/malli/pull/755 to happen all in cljs with only collecting schemas happening in a macro. The benefits include the namespaces matching with the clojure versions (aside from malli.dev.cljs ), a simpler mental model as instrumentation doesn&apos;t occur via generated code, and a more straight forward implementation that matches clojure&apos;s pretty closely."><y>#</y><d>2022-09-22</d><h>18:02</h><w>dvingo</w>after a comment by Thomas Heller (<a href="https://github.com/metosin/malli/pull/754#issuecomment-1252581659" target="_blank">https://github.com/metosin/malli/pull/754#issuecomment-1252581659</a>) I refactored the cljs function instrumentation <a href="https://github.com/metosin/malli/pull/755" target="_blank">https://github.com/metosin/malli/pull/755</a> to happen all in cljs with only collecting schemas happening in a macro. The benefits include the namespaces matching with the clojure versions (aside from <code>malli.dev.cljs</code>), a simpler mental model  as instrumentation doesn&apos;t occur via generated code, and a more straight forward implementation that matches clojure&apos;s pretty closely.</z><z id="t1663877843" t="kenny When working with Malli and generators, how do folks typically handle lazy loading of test.check?"><y>#</y><d>2022-09-22</d><h>20:17</h><w>kenny</w>When working with Malli and generators, how do folks typically handle lazy loading of test.check?</z><z id="t1663883514" t="dvingo https://github.com/borkdude/dynaload is great for this sort of thing"><y>#</y><d>2022-09-22</d><h>21:51</h><r>dvingo</r><a href="https://github.com/borkdude/dynaload" target="_blank">https://github.com/borkdude/dynaload</a> is great for this sort of thing</z><z id="t1663895319" t="kenny Cool lib :thumbsup: :skin-tone-2: How do you set the generator on a schema to be dynamically loaded? i.e., if I&apos;m setting :gen/gen key, it&apos;d need to be loaded when setting it."><y>#</y><d>2022-09-23</d><h>01:08</h><r>kenny</r>Cool lib <b>:thumbsup:</b><b>:skin-tone-2:</b>  How do you set the generator on a schema to be dynamically loaded? i.e., if I&apos;m setting <code>:gen/gen</code> key, it&apos;d need to be loaded when setting it.</z><z id="t1663937004" t="dvingo i haven&apos;t done it myself, but perhaps walking the schema dynamically to produce a new schema? https://github.com/metosin/malli#programming-with-schemas the &quot;Adding generated example values to Schemas&quot; section in particular"><y>#</y><d>2022-09-23</d><h>12:43</h><r>dvingo</r>i haven&apos;t done it myself, but perhaps walking the schema dynamically to produce a new schema?
<a href="https://github.com/metosin/malli#programming-with-schemas" target="_blank">https://github.com/metosin/malli#programming-with-schemas</a>
the &quot;Adding generated example values to Schemas&quot; section in particular</z><z id="t1664013085" t="Ben Sless"><y>#</y><d>2022-09-24</d><h>09:51</h><w>Ben Sless</w></z><z id="t1665129245" t="ikitommi this is awesome!!"><y>#</y><d>2022-10-07</d><h>07:54</h><r>ikitommi</r>this is awesome!!</z><z id="t1665131825" t="Ben Sless Thank you! It&apos;s also a really good benchmark case for parsing, which is what led to my other adventures 🙂"><y>#</y><d>2022-10-07</d><h>08:37</h><r>Ben Sless</r>Thank you!
It&apos;s also a really good benchmark case for parsing, which is what led to my other adventures <b>🙂</b></z><z id="t1664103960" t="delaguardo Hi! Is there a way to make a schema to validate a map has a set of keys and validate the rest of the keys against :map-of schema? This is very close to additionalProperties directive in json-schema."><y>#</y><d>2022-09-25</d><h>11:06</h><w>delaguardo</w>Hi! Is there a way to make a schema to validate a map has a set of keys and validate the rest of the keys against :map-of schema? This is very close to <code>additionalProperties</code> directive in json-schema.</z><z id="t1664106321" t="delaguardo just found this - https://github.com/metosin/malli/issues/43 discussion"><y>#</y><d>2022-09-25</d><h>11:45</h><r>delaguardo</r>just found this - <a href="https://github.com/metosin/malli/issues/43" target="_blank">https://github.com/metosin/malli/issues/43</a> discussion</z><z id="t1664104216" t="delaguardo [:map {:extra-keys [:map-of {:min 1 :max 2} :string :string]} [:x [:= &quot;X&quot;]] [:y {:optional true} :string]] I was thinking to add an option into -map-schema but I bit lost in the source code. Would appreciate any help to better understand how IntoSchema work internally 🙂 can’t find any low-level article about that"><y>#</y><d>2022-09-25</d><h>11:10</h><w>delaguardo</w><pre>[:map {:extra-keys [:map-of {:min 1 :max 2} :string :string]}
  [:x [:= &quot;X&quot;]]
  [:y {:optional true} :string]]</pre>
I was thinking to add an option into <code>-map-schema</code> but I bit lost in the source code. Would appreciate any help to better understand how IntoSchema work internally <b>🙂</b> can’t find any low-level article about that</z><z id="t1665129236" t="ikitommi there is a old issue about this. is important."><y>#</y><d>2022-10-07</d><h>07:53</h><r>ikitommi</r>there is a old issue about this. is important.</z><z id="t1665131405" t="delaguardo So far I made a custom -map-schema with :extra-entries option where it expects to have a schema to validate the “rest” of the map (defn -map-schema ([] (-map-schema {:naked-keys true})) ([opts] ;; :naked-keys, :lazy ^{:type ::m/into-schema} (reify m/AST (-from-ast [parent ast options] (m/-from-entry-ast parent ast options)) m/IntoSchema (-type [_] :map) (-type-properties [_]) (-properties-schema [_ _]) (-children-schema [_ _]) (-into-schema [parent {:keys [closed extra-entries] :or {extra-entries true} :as properties} children options] (let [entry-parser (m/-create-entry-parser children opts options) form (delay (m/-create-entry-form parent properties entry-parser options)) cache (m/-create-cache options) extra-entries (if closed false extra-entries) extra-entries (cond (boolean? extra-entries) (m/into-schema (if extra-entries :any &apos;empty?) nil nil options) (vector? extra-entries) (m/schema extra-entries options)) -&gt;parser (fn [this f] (let [keyset (m/-entry-keyset (m/-entry-parser this)) parsers (cond-&gt;&gt; (m/-vmap (fn [[key {:keys [optional]} schema]] (let [parser (f schema)] (fn [m] (if-let [e (find m key)] (let [v (val e) v* (parser v)] (cond (miu/-invalid? v*) (reduced v*) (identical? v* v) m :else (assoc m key v*))) (if optional m (reduced ::m/invalid)))))) (m/-children this)) extra-entries (cons (let [parser (f extra-entries)] (fn [m] (let [ks (keys keyset) m&apos; (select-keys m ks) m (apply dissoc m ks) m* (parser m)] (cond (miu/-invalid? m*) (reduced m*) :else (merge m&apos; m*)))))))] (fn [x] (if (map? x) (reduce (fn [m parser] (parser m)) x parsers) ::m/invalid))))] ^{:type ::m/schema} (reify m/AST (-to-ast [this _] (m/-entry-ast this (m/-entry-keyset entry-parser))) m/Schema (-validator [this] (let [keyset (m/-entry-keyset (m/-entry-parser this)) validators (cond-&gt; (m/-vmap (fn [[key {:keys [optional]} value]] (let [valid? (m/-validator value) default (boolean optional)] (fn [^Associative m] (if-let [map-entry (.entryAt m key)] (valid? (.val map-entry)) default)))) (m/-children this)) extra-entries (conj (let [valid? (m/-validator extra-entries)] (fn [^Associative m] (valid? (apply dissoc m (keys keyset))))))) validate (miu/-every-pred validators)] (fn [m] (and (map? m) (validate m))))) (-explainer [this path] (let [keyset (m/-entry-keyset (m/-entry-parser this)) explainers (cond-&gt; (m/-vmap (fn [[key {:keys [optional]} schema]] (let [explainer (m/-explainer schema (conj path key))] (fn [x in acc] (if-let [e (find x key)] (explainer (val e) (conj in key) acc) (if-not optional (conj acc (miu/-error (conj path key) (conj in key) this nil ::m/missing-key)) acc))))) (m/-children this)) extra-entries (conj (let [explainer (m/-explainer extra-entries path)] (fn [x in acc] (explainer (apply dissoc x (keys keyset)) in acc)))))] (fn [x in acc] (if-not (map? x) (conj acc (miu/-error path in this x ::m/invalid-type)) (reduce (fn [acc explainer] (explainer x in acc)) acc explainers))))) (-parser [this] (-&gt;parser this m/-parser)) (-unparser [this] (-&gt;parser this m/-unparser)) (-transformer [this transformer method options] (let [this-transformer (m/-value-transformer transformer this method options) -&gt;children (reduce (fn [acc [k s]] (let [t (m/-transformer s transformer method options)] (cond-&gt; acc t (conj [k t])))) [] (m/-entries this)) apply-&gt;children (when (seq -&gt;children) (m/-map-transformer -&gt;children)) apply-&gt;children (m/-guard map? apply-&gt;children)] (m/-intercepting this-transformer apply-&gt;children))) (-walk [this walker path options] (m/-walk-entries this walker path options)) (-properties [_] properties) (-options [_] options) (-children [_] (m/-entry-children entry-parser)) (-parent [_] parent) (-form [_] @form) m/EntrySchema (-entries [_] (m/-entry-entries entry-parser)) (-entry-parser [_] entry-parser) m/Cached (-cache [_] cache) m/LensSchema (-keep [_] true) (-get [this key default] (or (m/-get-entries this key default) (and extra-entries (m/-get extra-entries key default)))) (-set [this key value] (m/-set-entries this key value)))))))) "><y>#</y><d>2022-10-07</d><h>08:30</h><r>delaguardo</r>So far I made a custom <code>-map-schema</code> with <code>:extra-entries</code> option where it expects to have a schema to validate the “rest” of the map
<pre>(defn -map-schema
  ([]
   (-map-schema {:naked-keys true}))
  ([opts] ;; :naked-keys, :lazy
   ^{:type ::m/into-schema}
   (reify
     m/AST
     (-from-ast [parent ast options] (m/-from-entry-ast parent ast options))

     m/IntoSchema
     (-type [_] :map)
     (-type-properties [_])
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent {:keys [closed extra-entries]
                            :or {extra-entries true}
                            :as properties} children options]
       (let [entry-parser (m/-create-entry-parser children opts options)
             form (delay (m/-create-entry-form parent properties entry-parser options))
             cache (m/-create-cache options)
             extra-entries (if closed false extra-entries)
             extra-entries (cond (boolean? extra-entries)
                                 (m/into-schema (if extra-entries :any &apos;empty?) nil nil options)
                                 (vector? extra-entries)
                                 (m/schema extra-entries options))
             -&gt;parser (fn [this f]
                        (let [keyset (m/-entry-keyset (m/-entry-parser this))
                              parsers (cond-&gt;&gt; (m/-vmap
                                                (fn [[key {:keys [optional]} schema]]
                                                  (let [parser (f schema)]
                                                    (fn [m]
                                                      (if-let [e (find m key)]
                                                        (let [v (val e)
                                                              v* (parser v)]
                                                          (cond (miu/-invalid? v*) (reduced v*)
                                                                (identical? v* v) m
                                                                :else (assoc m key v*)))
                                                        (if optional m (reduced ::m/invalid))))))
                                                (m/-children this))
                                        extra-entries (cons (let [parser (f extra-entries)]
                                                              (fn [m]
                                                                (let [ks (keys keyset)
                                                                      m&apos; (select-keys m ks)
                                                                      m (apply dissoc m ks)
                                                                      m* (parser m)]
                                                                  (cond (miu/-invalid? m*) (reduced m*)
                                                                        :else (merge m&apos; m*)))))))]
                          (fn [x] (if (map? x) (reduce (fn [m parser] (parser m)) x parsers) ::m/invalid))))]
         ^{:type ::m/schema}
         (reify
           m/AST
           (-to-ast [this _] (m/-entry-ast this (m/-entry-keyset entry-parser)))

           m/Schema
           (-validator [this]
             (let [keyset (m/-entry-keyset (m/-entry-parser this))
                   validators (cond-&gt; (m/-vmap
                                       (fn [[key {:keys [optional]} value]]
                                         (let [valid? (m/-validator value)
                                               default (boolean optional)]
                                           (fn [^Associative m] (if-let [map-entry (.entryAt m key)] (valid? (.val map-entry)) default))))
                                       (m/-children this))
                                extra-entries (conj (let [valid? (m/-validator extra-entries)]
                                                      (fn [^Associative m] (valid? (apply dissoc m (keys keyset)))))))
                   validate (miu/-every-pred validators)]
               (fn [m] (and (map? m) (validate m)))))
           (-explainer [this path]
             (let [keyset (m/-entry-keyset (m/-entry-parser this))
                   explainers (cond-&gt; (m/-vmap
                                       (fn [[key {:keys [optional]} schema]]
                                         (let [explainer (m/-explainer schema (conj path key))]
                                           (fn [x in acc]
                                             (if-let [e (find x key)]
                                               (explainer (val e) (conj in key) acc)
                                               (if-not optional
                                                 (conj acc (miu/-error (conj path key) (conj in key) this nil ::m/missing-key))
                                                 acc)))))
                                       (m/-children this))
                                extra-entries (conj (let [explainer (m/-explainer extra-entries path)]
                                                      (fn [x in acc]
                                                        (explainer (apply dissoc x (keys keyset)) in acc)))))]
               (fn [x in acc]
                 (if-not (map? x)
                   (conj acc (miu/-error path in this x ::m/invalid-type))
                   (reduce
                    (fn [acc explainer]
                      (explainer x in acc))
                    acc explainers)))))
           (-parser [this] (-&gt;parser this m/-parser))
           (-unparser [this] (-&gt;parser this m/-unparser))
           (-transformer [this transformer method options]
             (let [this-transformer (m/-value-transformer transformer this method options)
                   -&gt;children (reduce (fn [acc [k s]]
                                        (let [t (m/-transformer s transformer method options)]
                                          (cond-&gt; acc t (conj [k t])))) [] (m/-entries this))
                   apply-&gt;children (when (seq -&gt;children) (m/-map-transformer -&gt;children))
                   apply-&gt;children (m/-guard map? apply-&gt;children)]
               (m/-intercepting this-transformer apply-&gt;children)))
           (-walk [this walker path options] (m/-walk-entries this walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] (m/-entry-children entry-parser))
           (-parent [_] parent)
           (-form [_] @form)

           m/EntrySchema
           (-entries [_] (m/-entry-entries entry-parser))
           (-entry-parser [_] entry-parser)

           m/Cached
           (-cache [_] cache)

           m/LensSchema
           (-keep [_] true)
           (-get [this key default] (or (m/-get-entries this key default)
                                        (and extra-entries
                                             (m/-get extra-entries key default))))
           (-set [this key value] (m/-set-entries this key value))))))))</pre>
</z><z id="t1665131475" t="delaguardo However it is incomplete and needs adjustments"><y>#</y><d>2022-10-07</d><h>08:31</h><r>delaguardo</r>However it is incomplete and needs adjustments</z><z id="t1664205175" t="erwinrooijakkers Is there a way to describe that a map should contain either one specific key or another key? e.g. {:foo 1} ; correct {:bar 1} ; correct {} ; incorrect, should contain one of :foo or :bar"><y>#</y><d>2022-09-26</d><h>15:12</h><w>erwinrooijakkers</w>Is there a way to describe that a map should contain either one specific key or another key?

e.g.
<pre>{:foo 1} ; correct
{:bar 1} ; correct
{} ; incorrect, should contain one of :foo or :bar</pre></z><z id="t1664206307" t="delaguardo [:or [:map [:foo [:= 1]]] [:map [:bar [:= 1]]]] "><y>#</y><d>2022-09-26</d><h>15:31</h><r>delaguardo</r><pre>[:or [:map [:foo [:= 1]]] [:map [:bar [:= 1]]]]</pre>
</z><z id="t1664206372" t="erwinrooijakkers yep thanks, 🙂 but there are many more keys in the map so that would be loads of duplication, maybe there’s a way to do ir inside the map"><y>#</y><d>2022-09-26</d><h>15:32</h><r>erwinrooijakkers</r>yep thanks, <b>🙂</b>  but there are many more keys in the map so that would be loads of duplication, maybe there’s a way to do ir inside the map</z><z id="t1664206710" t="erwinrooijakkers e.g., user=&gt; (m/validate [:map [:or [:foo :int]] [:bar :int]] {:quz 1}) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). :malli.core/invalid-schema {:schema :x}"><y>#</y><d>2022-09-26</d><h>15:38</h><r>erwinrooijakkers</r>e.g.,
<pre>user=&gt; (m/validate [:map [:or [:foo :int]] [:bar :int]] {:quz 1})
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
:malli.core/invalid-schema {:schema :x}</pre></z><z id="t1664208071" t="hmadelaine You could use a :fn schema for that purpose : It is naive but it works (def FooOrBar [:and [:map [:foo {:optional true} number?] [:bar {:optional true} number?]] [:fn {:error/message &quot;Only one key must be present&quot;} (fn [data] (= 1 (count data)))]]) (m/validate FooOrBar {:foo 1}) =&gt; true (m/validate FooOrBar {:bar 1}) =&gt; true (m/validate FooOrBar {:foo 1 :bar 1}) =&gt; false (m/validate FooOrBar {}) =&gt; false"><y>#</y><d>2022-09-26</d><h>16:01</h><r>hmadelaine</r>You could use a :fn schema for that purpose :
It is naive but it works
<pre>(def FooOrBar
  [:and
   [:map
    [:foo {:optional true} number?]
    [:bar {:optional true} number?]]
   [:fn
    {:error/message &quot;Only one key must be present&quot;}
    (fn [data]
      (= 1 (count data)))]])


(m/validate FooOrBar {:foo 1}) =&gt; true
(m/validate FooOrBar {:bar 1}) =&gt; true
(m/validate FooOrBar {:foo 1 :bar 1}) =&gt; false
(m/validate FooOrBar {}) =&gt; false</pre></z><z id="t1664222384" t="pithyless &gt; but there are many more keys in the map so that would be loads of duplication The duplication can be resolved via composition, ala :merge , :union or even :select-keys . Remember also, that you may need to close the map schemas appropriately, if you do not want both :foo and :bar to be valid together. I would prefer :or over :and , since it is more likely to be generator friendly; but you may even consider a version using :multi with custom dispatcher that checks for the existence of certain keys."><y>#</y><d>2022-09-26</d><h>19:59</h><r>pithyless</r>&gt; but there are many more keys in the map so that would be loads of duplication
The duplication can be resolved via composition, ala <code>:merge</code> , <code>:union</code> or even <code>:select-keys</code>.

Remember also, that you may need to close the map schemas appropriately, if you do not want both :foo and :bar to be valid together.

I would prefer <code>:or</code> over <code>:and</code>, since it is more likely to be generator friendly; but you may even consider a version using <code>:multi</code> with custom dispatcher that checks for the existence of certain keys.</z><z id="t1664461591" t="darnok @erwinrooijakkers Have you found a solution?"><y>#</y><d>2022-09-29</d><h>14:26</h><r>darnok</r>@erwinrooijakkers Have you found a solution?</z><z id="t1664461675" t="darnok I have similar case, and I tried :and and :or and closing all maps. It doesn&apos;t work, because one of the specs won&apos;t pass the keys missing in another maps."><y>#</y><d>2022-09-29</d><h>14:27</h><r>darnok</r>I have similar case, and I tried <code>:and</code> and <code>:or</code> and closing all maps. It doesn&apos;t work, because one of the specs won&apos;t pass the keys missing in another maps.</z><z id="t1664208514" t="robert-stuttaford https://twitter.com/RobStuttaford/status/1574430197079752706 (is it ok for me to paste a link to a tweet like this?)"><y>#</y><d>2022-09-26</d><h>16:08</h><w>robert-stuttaford</w><a href="https://twitter.com/RobStuttaford/status/1574430197079752706" target="_blank">https://twitter.com/RobStuttaford/status/1574430197079752706</a> (is it ok for me to paste a link to a tweet like this?)</z><z id="t1664223411" t="richiardiandrea This is very nice, I wonder if we could do the same with cider...it would be very cool to be able to customize the jump to reference functionality"><y>#</y><d>2022-09-26</d><h>20:16</h><r>richiardiandrea</r>This is very nice, I wonder if we could do the same with cider...it would be very cool to be able to customize the jump to reference functionality</z><z id="t1664225966" t="DrLjótsson I am trying to get swagger-ui to work in reitit but am failing. I just want to double check if reitit + swagger-ui works when malli is used to spec the routes. The docs at https://github.com/metosin/reitit/blob/master/doc/ring/swagger.md say that &quot;Reitit supports https://swagger.io/ documentation, thanks to https://github.com/metosin/schema-tools and https://github.com/metosin/spec-tools ., i.e. malli is not mentioned."><y>#</y><d>2022-09-26</d><h>20:59</h><w>DrLjótsson</w>I am trying to get swagger-ui to work in reitit but am failing. I just want to double check if reitit + swagger-ui works when malli is used to spec the routes. The docs at <a href="https://github.com/metosin/reitit/blob/master/doc/ring/swagger.md" target="_blank">https://github.com/metosin/reitit/blob/master/doc/ring/swagger.md</a> say that &quot;Reitit supports <a href="https://swagger.io/" target="_blank">https://swagger.io/</a> documentation, thanks to <a href="https://github.com/metosin/schema-tools" target="_blank">https://github.com/metosin/schema-tools</a> and <a href="https://github.com/metosin/spec-tools" target="_blank">https://github.com/metosin/spec-tools</a>., i.e. malli is not mentioned.</z><z id="t1664262129" t="DrLjótsson I can confirm that swagger works with malli if reitit.coercion.malli/coercion is used."><y>#</y><d>2022-09-27</d><h>07:02</h><r>DrLjótsson</r>I can confirm that swagger works with malli if <code>reitit.coercion.malli/coercion</code>is used.</z><z id="t1664356873" t="Martynas M What does this error mean? https://github.com/metosin/malli/blob/c0965e2b2b37ea1d81e6f4ece7c87f56fa90398a/test/malli/core_test.cljc#L1799 I get it when I try to have a malli schema to decode malli tuples. And well... it has to be recursive :thinking_face:"><y>#</y><d>2022-09-28</d><h>09:21</h><w>Martynas M</w>What does this error mean?
<a href="https://github.com/metosin/malli/blob/c0965e2b2b37ea1d81e6f4ece7c87f56fa90398a/test/malli/core_test.cljc#L1799" target="_blank">https://github.com/metosin/malli/blob/c0965e2b2b37ea1d81e6f4ece7c87f56fa90398a/test/malli/core_test.cljc#L1799</a>

I get it when I try to have a malli schema to decode malli tuples. And well... it has to be recursive <b>:thinking_face:</b></z><z id="t1664357020" t="Martynas M I fixed the error by not using :ref in the definition like this: ::malli-tuple-schema [:cat [:= :tuple] [:* ::malli-schema] #_[:* [:ref ::malli-schema]]]"><y>#</y><d>2022-09-28</d><h>09:23</h><r>Martynas M</r>I fixed the error by not using <code>:ref</code> in the definition like this:
<pre>::malli-tuple-schema [:cat
                      [:= :tuple]
                      [:* ::malli-schema]
                      #_[:* [:ref ::malli-schema]]]</pre></z><z id="t1664372281" t="ambrosebs I think it means that any regex operation cannot contain a recursive schema. checking for :ref is a crude way of checking for recursion."><y>#</y><d>2022-09-28</d><h>13:38</h><r>ambrosebs</r>I think it means that any regex operation cannot contain a recursive schema. checking for <code>:ref</code> is a crude way of checking for recursion.</z><z id="t1664372379" t="ambrosebs I developed a more refined way to detect recursive specs in the generators namespace. perhaps using that here would be a nice enhancement."><y>#</y><d>2022-09-28</d><h>13:39</h><r>ambrosebs</r>I developed a more refined way to detect recursive specs in the generators namespace. perhaps using that here would be a nice enhancement.</z><z id="t1664372503" t="Martynas M &gt; cannot contain a recursive schema Well if I remove the :ref it will still reference the ::malli-schema but it will copy it. So the schema works the same way as it would work with :ref"><y>#</y><d>2022-09-28</d><h>13:41</h><r>Martynas M</r>&gt; cannot contain a recursive schema
Well if I remove the <code>:ref</code> it will still reference the <code>::malli-schema</code> but it will copy it. So the schema works the same way as it would work with <code>:ref</code></z><z id="t1664372568" t="ambrosebs Agreed. That&apos;s the part that I think could potentially be improved."><y>#</y><d>2022-09-28</d><h>13:42</h><r>ambrosebs</r>Agreed. That&apos;s the part that I think could potentially be improved.</z><z id="t1664372595" t="ambrosebs eg., the ;; A bit undesirable, but intentional: test a few lines down from the test you linked."><y>#</y><d>2022-09-28</d><h>13:43</h><r>ambrosebs</r>eg., the <code>;; A bit undesirable, but intentional:</code> test a few lines down from the test you linked.</z><z id="t1664372607" t="ambrosebs is ::malli-schema recursive?"><y>#</y><d>2022-09-28</d><h>13:43</h><r>ambrosebs</r>is <code>::malli-schema</code> recursive?</z><z id="t1664372617" t="Martynas M Everything there is recursive 😄"><y>#</y><d>2022-09-28</d><h>13:43</h><r>Martynas M</r>Everything there is recursive <b>😄</b></z><z id="t1664372631" t="Martynas M ::malli-schema [:or [:ref ::malli-map-schema] [:ref ::malli-set-schema] [:ref ::malli-vector-schema] [:ref ::malli-tuple-schema] :keyword]"><y>#</y><d>2022-09-28</d><h>13:43</h><r>Martynas M</r><pre>::malli-schema [:or
                                [:ref ::malli-map-schema]
                                [:ref ::malli-set-schema]
                                [:ref ::malli-vector-schema]
                                [:ref ::malli-tuple-schema]
                                :keyword]</pre></z><z id="t1664372657" t="ambrosebs ah. I&apos;m confused, you said you &quot;fixed the error&quot;, what does that look like now?"><y>#</y><d>2022-09-28</d><h>13:44</h><r>ambrosebs</r>ah. I&apos;m confused, you said you &quot;fixed the error&quot;, what does that look like now?</z><z id="t1664372677" t="Martynas M This looks like [:* ::malli-schema] and it works without the error"><y>#</y><d>2022-09-28</d><h>13:44</h><r>Martynas M</r>This looks like <code>[:* ::malli-schema]</code> and it works without the error</z><z id="t1664372725" t="ambrosebs thanks. now I understand how crude this check is 🙂"><y>#</y><d>2022-09-28</d><h>13:45</h><r>ambrosebs</r>thanks. now I understand how crude this check is <b>🙂</b></z><z id="t1664372785" t="ambrosebs I thought it was an overapproximation on checking for recursive specs. but it only guards against very specific recursive ones."><y>#</y><d>2022-09-28</d><h>13:46</h><r>ambrosebs</r>I thought it was an overapproximation on checking for recursive specs. but it only guards against very specific recursive ones.</z><z id="t1664372807" t="ambrosebs unless I&apos;m missing something."><y>#</y><d>2022-09-28</d><h>13:46</h><r>ambrosebs</r>unless I&apos;m missing something.</z><z id="t1664372846" t="Martynas M This is a more basic example that passes the checker: [:schema {:registry {::malli-field-options [:map [:optional {:optional true} :boolean] [:min {:optional true} :int] [:registry {:optional true} ::malli-map-schema]], ::malli-map-schema [:cat [:= :map] [:* [:or [:tuple :keyword [:ref ::malli-schema]] [:tuple :keyword [:ref ::malli-field-options] [:ref ::malli-schema]]]]], ::malli-schema [:or [:ref ::malli-map-schema] :keyword]}} ::malli-schema]"><y>#</y><d>2022-09-28</d><h>13:47</h><r>Martynas M</r>This is a more basic example that passes the checker:
<pre>[:schema
 {:registry
  {::malli-field-options [:map
                          [:optional {:optional true} :boolean]
                          [:min {:optional true} :int]
                          [:registry {:optional true} ::malli-map-schema]],
   ::malli-map-schema [:cat
                       [:= :map]
                       [:* [:or
                            [:tuple :keyword [:ref ::malli-schema]]
                            [:tuple :keyword [:ref ::malli-field-options] [:ref ::malli-schema]]]]],
   ::malli-schema [:or
                   [:ref ::malli-map-schema]
                   :keyword]}}
 ::malli-schema]</pre></z><z id="t1664373095" t="ambrosebs ok, and that one has no references/`:ref` directly on regex ops. can you post the full one that yields the error and requires a change?"><y>#</y><d>2022-09-28</d><h>13:51</h><r>ambrosebs</r>ok, and that one has no references/`:ref` directly on regex ops. can you post the full one that yields the error and requires a change?</z><z id="t1664373323" t="Martynas M I don&apos;t know. I can&apos;t find it"><y>#</y><d>2022-09-28</d><h>13:55</h><r>Martynas M</r>I don&apos;t know. I can&apos;t find it</z><z id="t1664373336" t="Martynas M I&apos;ll probably be editing it more. Maybe I can find it later. But when I got that bug I was unsure what to do. So it&apos;s a tough one."><y>#</y><d>2022-09-28</d><h>13:55</h><r>Martynas M</r>I&apos;ll probably be editing it more. Maybe I can find it later. But when I got that bug I was unsure what to do. So it&apos;s a tough one.</z><z id="t1664373370" t="ambrosebs np, just sounds like a good test case. I get the gist of it."><y>#</y><d>2022-09-28</d><h>13:56</h><r>ambrosebs</r>np, just sounds like a good test case. I get the gist of it.</z><z id="t1665129173" t="ikitommi the :ref can’t be used to expand/inline things into a sequential schema. you can use :ref s, but need to wrap it into :schema - takes just one position in the sequence. This is an implementation decision, described in the ns. If there is a performant way not to do this, I’m all 👂 s!"><y>#</y><d>2022-10-07</d><h>07:52</h><r>ikitommi</r>the <code>:ref</code> can’t be used to expand/inline things into a sequential schema. you can use <code>:ref</code>s, but need to wrap it into <code>:schema</code> - takes just one position in the sequence. This is an implementation decision, described in the ns. If there is a performant way not to do this, I’m all <b>👂</b>s!</z><z id="t1664397611" t="Diego Got a question about malli’s :re schemas. I’ve got this code for validating email addresses: (def email-address-regex #&quot;(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+)*|\&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])&quot;) (def email-address? [:re {:error/message &quot;Please provide a valid email address&quot;} email-address-regex]) (me/humanize (m/explain email-address? &quot; It seems like :re is using re-find because re-find does return true, but what can I do to make :re behave more like re-match ?"><y>#</y><d>2022-09-28</d><h>20:40</h><w>Diego</w>Got a question about malli’s <code>:re</code> schemas.

I’ve got this code for validating email addresses:
<pre>(def email-address-regex  #&quot;(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+)*|\&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])&quot;)
(def email-address? [:re {:error/message &quot;Please provide a valid email address&quot;} email-address-regex])

(me/humanize (m/explain email-address? &quot;</pre>
It seems like <code>:re</code> is using <code>re-find</code> because <code>re-find</code> does return true, but what can I do to make <code>:re</code> behave more like <code>re-match</code> ?</z><z id="t1664442171" t="iarenaza Yeah, it seems it&apos;s using re-find for validation: https://github.com/metosin/malli/blob/0.8.9/src/malli/core.cljc#L1350-L1351 In that case, you need to use the &quot;beginning of line/string&quot; (`^`) and &quot;end of line/string&quot; (`$`) anchors in your regular expression, so that re-find must match your regular expression over the whole input value, not just a part of it: user&gt; (require &apos;[malli.core :as m]) nil user&gt; (require &apos;[malli.error :as me]) nil user&gt; (def email-address-regex #&quot;^(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+)*|\&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:\ (?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$&quot;) #&apos;user/email-address-regex user&gt; (def email-address? [:re {:error/message &quot;Please provide a valid email address&quot;} email-address-regex]) #&apos;user/email-address? user&gt; (me/humanize (m/explain email-address? &quot;"><y>#</y><d>2022-09-29</d><h>09:02</h><r>iarenaza</r>Yeah, it seems it&apos;s using <code>re-find</code> for validation: <a href="https://github.com/metosin/malli/blob/0.8.9/src/malli/core.cljc#L1350-L1351" target="_blank">https://github.com/metosin/malli/blob/0.8.9/src/malli/core.cljc#L1350-L1351</a>

In that case, you need to use the &quot;beginning of line/string&quot; (`^`) and &quot;end of line/string&quot; (`$`) anchors in your regular expression, so that <code>re-find</code> must match your regular expression over the whole input value, not just a part of it:

<pre>user&gt; (require &apos;[malli.core :as m])
nil
user&gt; (require &apos;[malli.error :as me])
nil
user&gt; (def email-address-regex  #&quot;^(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&apos;*+/=?^_`{|}~-]+)*|\&quot;(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:\
(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$&quot;)
#&apos;user/email-address-regex
user&gt; (def email-address? [:re {:error/message &quot;Please provide a valid email address&quot;} email-address-regex])
#&apos;user/email-address?
user&gt; (me/humanize (m/explain email-address? &quot;</pre></z><z id="t1664481293" t="Diego Thanks!"><y>#</y><d>2022-09-29</d><h>19:54</h><r>Diego</r>Thanks!</z><z id="t1664478338" t="ingesol I tried to instrument a CLJS multimethod (the dispatch function), but it does not seem to work. I can call it with wrong input type, and it still works: (defn my-dispatch {:malli/schema [:=&gt; [:cat :string] :keyword]} [s] (keyword s) (defmulti a-multi-method my-dispatch) (defmethod a-multi-method :default [_] :the-default) ;; The below does not crash like it should (a-multi-method 4) "><y>#</y><d>2022-09-29</d><h>19:05</h><w>ingesol</w>I tried to instrument a CLJS multimethod (the dispatch function), but it does not seem to work. I can call it with wrong input type, and it still works:

<pre>(defn my-dispatch
  {:malli/schema [:=&gt; [:cat :string] :keyword]}
  [s]
  (keyword s)

(defmulti a-multi-method
  my-dispatch)

(defmethod a-multi-method :default [_]
  :the-default)

;; The below does not crash like it should
(a-multi-method 4)</pre>
</z><z id="t1664483331" t="ambrosebs Just a hunch, but have you tried: (defmulti a-multi-method #(my-dispatch %)) "><y>#</y><d>2022-09-29</d><h>20:28</h><r>ambrosebs</r>Just a hunch, but have you tried:
<pre>(defmulti a-multi-method
  #(my-dispatch %))</pre>
</z><z id="t1664519590" t="ingesol Thanks, that’s an interesting idea. The assumption is that the original function will be cached inside the multimethod storage? Anyway, it did unfortunately not work."><y>#</y><d>2022-09-30</d><h>06:33</h><r>ingesol</r>Thanks, that’s an interesting idea. The assumption is that the original function will be cached inside the multimethod storage? Anyway, it did unfortunately not work.</z><z id="t1664529453" t="ingesol Also, to clarify, calling the my-dispatch function normally from somewhere else with wrong args triggers validation"><y>#</y><d>2022-09-30</d><h>09:17</h><r>ingesol</r>Also, to clarify, calling the <code>my-dispatch</code> function normally from somewhere else with wrong args triggers validation</z><z id="t1664544640" t="dvingo It looks like this is due to how multimethods are implemented. https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L11343 the dispatch-fn is passed into a JS object (deftype) and that captures the original function value. Just tried this in JS: var afn = function afn(){ console.log(&apos;FIRST&apos;)} y = {x: afn} afn = function (){ console.log(&apos;SECOND&apos;)} y.x() // =&gt; FIRST so I think this is what the problem is"><y>#</y><d>2022-09-30</d><h>13:30</h><r>dvingo</r>It looks like this is due to how multimethods are implemented.
<a href="https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L11343" target="_blank">https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L11343</a>
the dispatch-fn is passed into a JS object (deftype)  and that captures the original function value. Just tried this in JS:
<pre>var afn = function afn(){ console.log(&apos;FIRST&apos;)}
y = {x: afn}
afn = function (){ console.log(&apos;SECOND&apos;)}
y.x()
// =&gt; FIRST</pre>
so I think this is what the problem is</z><z id="t1664544759" t="dvingo we may be able to mutate the MultiFn &apos;s dispatch-fn property when we instrument, but then the defmulti would have to have the instrumentation applied, not the function"><y>#</y><d>2022-09-30</d><h>13:32</h><r>dvingo</r>we may be able to mutate the <code>MultiFn</code>&apos;s <code>dispatch-fn</code> property when we instrument, but then the <code>defmulti</code> would have to have the instrumentation applied, not the function</z><z id="t1664548560" t="ambrosebs &gt; Thanks, that’s an interesting idea. The assumption is that the original function will be cached inside the multimethod storage? Anyway, it did unfortunately not work. Yes, I was also going to suggest #&apos;my-dispatch but I forgot how vars work in CLJS."><y>#</y><d>2022-09-30</d><h>14:36</h><r>ambrosebs</r>&gt; Thanks, that’s an interesting idea. The assumption is that the original function will be cached inside the multimethod storage? Anyway, it did unfortunately not work.
Yes, I was also going to suggest <code>#&apos;my-dispatch</code> but I forgot how vars work in CLJS.</z><z id="t1664556033" t="ingesol Taking one step back, the most valuable thing for our codebase would be to be able to declare the contract for the multimethod in general. Instrumenting the dispatch function is more like a hack to get at least some of the value. I know that instrumenting defmulti is probably a large and maybe not attractive subject, just mentioning it."><y>#</y><d>2022-09-30</d><h>16:40</h><r>ingesol</r>Taking one step back, the most valuable thing for our codebase would be to be able to declare the contract for the multimethod in general. Instrumenting the dispatch function is more like a hack to get at least some of the value. I know that instrumenting <code>defmulti</code> is probably a large and maybe not attractive subject, just mentioning it.</z><z id="t1664556957" t="ambrosebs AFAIK it is not possible in CLJ."><y>#</y><d>2022-09-30</d><h>16:55</h><r>ambrosebs</r>AFAIK it is not possible in CLJ.</z><z id="t1664556989" t="ambrosebs probably easier in cljs"><y>#</y><d>2022-09-30</d><h>16:56</h><r>ambrosebs</r>probably easier in cljs</z><z id="t1664557512" t="ingesol To illustrate what I mean (defmulti say-hi {:malli/schema [:=&gt; [:cat [:map [:nationality :keyword]]] :string]} (fn [person] (:nationality person))) (defmethod say-hi :german &quot;Guten tag&quot;)"><y>#</y><d>2022-09-30</d><h>17:05</h><r>ingesol</r>To illustrate what I mean

<pre>(defmulti say-hi
  {:malli/schema [:=&gt; [:cat [:map [:nationality :keyword]]] :string]}
  (fn [person]
    (:nationality person)))

(defmethod say-hi :german
  &quot;Guten tag&quot;)</pre></z><z id="t1664557766" t="ingesol I think I remember some earlier discussion indicating that the above is simplistic and probably not a good idea, but did not find it. And [:attrs {:href &quot;/_/_/users/U055XFK8V&quot;}] , just to clarify, this is the thing you are saying is not possible in CLJ?"><y>#</y><d>2022-09-30</d><h>17:09</h><r>ingesol</r>I think I remember some earlier discussion indicating that the above is simplistic and probably not a good idea, but did not find it. And <a>@U055XFK8V</a>, just to clarify, this is the thing you are saying is not possible in CLJ?</z><z id="t1664560053" t="ambrosebs Yes, I&apos;ve looked at clojure.lang.MultiFn and there&apos;s no obvious way to achieve this."><y>#</y><d>2022-09-30</d><h>17:47</h><r>ambrosebs</r>Yes, I&apos;ve looked at clojure.lang.MultiFn and there&apos;s no obvious way to achieve this.</z><z id="t1664560071" t="ambrosebs I managed to do this for defprotocol https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html"><y>#</y><d>2022-09-30</d><h>17:47</h><r>ambrosebs</r>I managed to do this for defprotocol <a href="https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html" target="_blank">https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html</a></z><z id="t1664560192" t="ambrosebs actually, MultiFn isn&apos;t a final class so perhaps a wrapper can be created. I might look into that."><y>#</y><d>2022-09-30</d><h>17:49</h><r>ambrosebs</r>actually, MultiFn isn&apos;t a <code>final</code> class so perhaps a wrapper can be created. I might look into that.</z><z id="t1664560308" t="ingesol But that would require an alternative defmulti macro, right?"><y>#</y><d>2022-09-30</d><h>17:51</h><r>ingesol</r>But that would require an alternative <code>defmulti</code> macro, right?</z><z id="t1664560385" t="ambrosebs I&apos;m thinking we leave everything as-is, but an instrument! function when called on a multimethod would set the multimethod var to a thin wrapper around MultiFn."><y>#</y><d>2022-09-30</d><h>17:53</h><r>ambrosebs</r>I&apos;m thinking we leave everything as-is, but an <code>instrument!</code> function when called on a multimethod would set the multimethod var to a thin wrapper around MultiFn.</z><z id="t1664560426" t="ambrosebs The tricky part is making sure that wrapper works with existing defmethod calls. And if we subclass MultiFn, it might work."><y>#</y><d>2022-09-30</d><h>17:53</h><r>ambrosebs</r>The tricky part is making sure that wrapper works with existing <code>defmethod</code> calls. And if we subclass MultiFn, it might work.</z><z id="t1664560488" t="ingesol This is all about the mechanics of doing the instrumentation, I also seem to remember there are issues with the semantics. Will try to look it up"><y>#</y><d>2022-09-30</d><h>17:54</h><r>ingesol</r>This is all about the mechanics of doing the instrumentation, I also seem to remember there are issues with the semantics. Will try to look it up</z><z id="t1664560821" t="ingesol Maybe forget that last thing. So at least the way we use multimethods, it makes sense to enforce a shared input/output contract for all defmethod s. The only thing that is not clear is how/where on the defmulti to define the schema."><y>#</y><d>2022-09-30</d><h>18:00</h><r>ingesol</r>Maybe forget that last thing. So at least the way we use multimethods, it makes sense to enforce a shared input/output contract for all <code>defmethod</code>s. The only thing that is not clear is how/where on the <code>defmulti</code> to define the schema.</z><z id="t1664560842" t="ingesol Pinging [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] in case he has opinions on this"><y>#</y><d>2022-09-30</d><h>18:00</h><r>ingesol</r>Pinging <a>@U055NJ5CC</a> in case he has opinions on this</z><z id="t1664561059" t="ambrosebs Thinking something like public MyMultiFn extends MultiFn { public MyMultiFn(IFn wrapper, MultiFn inner) { } public Object invoke(args ...) { wrapper.invoke(inner, args...); } .... } (defn instrument-multi! [var checking-wrapper] (alter-var-root var (fn [multi] (MyMultiFn. checking-wrapper multi))) "><y>#</y><d>2022-09-30</d><h>18:04</h><r>ambrosebs</r>Thinking something like
<pre>public MyMultiFn extends MultiFn {
  public MyMultiFn(IFn wrapper, MultiFn inner) { }
  public Object invoke(args ...) {
    wrapper.invoke(inner, args...);
  }
....
}</pre>
<pre>(defn instrument-multi! [var checking-wrapper]
  (alter-var-root var (fn [multi] (MyMultiFn. checking-wrapper multi)))</pre>
</z><z id="t1664670237" t="ambrosebs I managed to prototype defmulti instrumentation successfully for Prismatic Schema, so I take back my assertion that this was impossible."><y>#</y><d>2022-10-02</d><h>00:23</h><r>ambrosebs</r>I managed to prototype defmulti instrumentation successfully for Prismatic Schema, so I take back my assertion that this was impossible.</z><z id="t1665128680" t="ikitommi Would be great if multimethods could be schematized. No opinions on the impl."><y>#</y><d>2022-10-07</d><h>07:44</h><r>ikitommi</r>Would be great if multimethods could be schematized. No opinions on the impl.</z><z id="t1665168261" t="ambrosebs Ok I&apos;ll prep a proof of concept"><y>#</y><d>2022-10-07</d><h>18:44</h><r>ambrosebs</r>Ok I&apos;ll prep a proof of concept</z><z id="t1664629793" t="Chris O’Donnell Put up a small PR fixing a typo I found testing the json schema implementation: https://github.com/metosin/malli/pull/757 . Haven&apos;t contributed to malli before; please let me know if there&apos;s anything else I should do."><y>#</y><d>2022-10-01</d><h>13:09</h><w>Chris O’Donnell</w>Put up a small PR fixing a typo I found testing the json schema implementation: <a href="https://github.com/metosin/malli/pull/757" target="_blank">https://github.com/metosin/malli/pull/757</a>. Haven&apos;t contributed to malli before; please let me know if there&apos;s anything else I should do.</z><z id="t1664799917" t="robert-stuttaford is there a Correct™ way to test if a value is a valid malli spec? i&apos;d like to avoid try catch if that&apos;s possible"><y>#</y><d>2022-10-03</d><h>12:25</h><w>robert-stuttaford</w>is there a Correct™ way to test if a value is a valid malli spec? i&apos;d like to avoid try catch if that&apos;s possible</z><z id="t1664804178" t="NoahTheDuke You mean “can the given form be used as a Malli schema”, not “does the given form conform to an existing malli schema”, right? "><y>#</y><d>2022-10-03</d><h>13:36</h><r>NoahTheDuke</r>You mean “can the given form be used as a Malli schema”, not “does the given form conform to an existing malli schema”, right? </z><z id="t1664807038" t="respatialized AFAIK there isn&apos;t yet a self-describing meta-schema for malli schemas; the only way I&apos;ve done this is indeed with try/catch on m/schema ."><y>#</y><d>2022-10-03</d><h>14:23</h><r>respatialized</r>AFAIK there isn&apos;t yet a self-describing meta-schema for malli schemas; the only way I&apos;ve done this is indeed with try/catch on <code>m/schema</code>.</z><z id="t1664807115" t="robert-stuttaford that&apos;s right [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] 🙂 thanks [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] !"><y>#</y><d>2022-10-03</d><h>14:25</h><r>robert-stuttaford</r>that&apos;s right <a>@UEENNMX0T</a> <b>🙂</b> thanks <a>@UFTRLDZEW</a>!</z><z id="t1665128563" t="ikitommi Schemas can define their schemas as schemas. The IntoSchema has the needed hooks, someone just needs to write the Schemas for properties &amp; Children."><y>#</y><d>2022-10-07</d><h>07:42</h><r>ikitommi</r>Schemas can define their schemas as schemas. The <code>IntoSchema</code> has the needed hooks, someone just needs to write the Schemas for properties &amp; Children.</z><z id="t1664854534" t="dumrat Ran into a little perf trouble with malli sampling. Looks like performance is exponential wrt to sample size. Is there a reason for this? Sample code: (def cashflow-schema (m/schema [:map [:type keyword?] [:direction keyword?] [:incurred-by {:optional true} [:map [:type keyword?] [:name string?]]] [:amount int?] [:categories [:set string?]] ;; [:date inst?] [:description {:optional true} string?] [:towards {:optional true} [:map [:type keyword?] [:name string?]]]])) (defn get-sampling-data [sample-sizes] (map (fn [ss] [ss ((comp first :mean) (quick-benchmark (doseq [x (mg/sample cashflow-schema {:size ss})] x) {}))]) sample-sizes)) (defn get-vis-data [sample-sizes] (let [data (get-sampling-data sample-sizes) values (map (fn [[ss time]] {:sample-size ss :time time}) data)] {:data {:values values} :encoding {:x {:field &quot;sample-size&quot; :type &quot;quantitative&quot;} :y {:field &quot;time&quot; :type &quot;quantitative&quot;}} :mark &quot;line&quot;})) (get-vis-data (range 5 110 5)) (oz/view! *1)"><y>#</y><d>2022-10-04</d><h>03:35</h><w>dumrat</w>Ran into a little perf trouble with malli sampling. Looks like performance is exponential wrt to sample size. Is there a reason for this?
Sample code:

<pre>(def cashflow-schema
  (m/schema
   [:map
    [:type keyword?]
    [:direction keyword?]
    [:incurred-by {:optional true} [:map [:type keyword?] [:name string?]]]
    [:amount int?]
    [:categories [:set string?]]
    ;; [:date inst?]
    [:description {:optional true} string?]
    [:towards {:optional true} [:map [:type keyword?] [:name string?]]]]))

(defn get-sampling-data [sample-sizes]
  (map (fn [ss] [ss ((comp first :mean)
                           (quick-benchmark (doseq [x (mg/sample cashflow-schema {:size ss})]
                                              x) {}))])
             sample-sizes))

(defn get-vis-data [sample-sizes]
  (let [data (get-sampling-data sample-sizes)
        values (map (fn [[ss time]] {:sample-size ss :time time}) data)]
    {:data {:values values}
     :encoding {:x {:field &quot;sample-size&quot; :type &quot;quantitative&quot;}
                :y {:field &quot;time&quot; :type &quot;quantitative&quot;}}
     :mark &quot;line&quot;}))

(get-vis-data (range 5 110 5))
(oz/view! *1)</pre></z><z id="t1664855417" t="Ben Sless Can you def a generator from the schema and run again?"><y>#</y><d>2022-10-04</d><h>03:50</h><r>Ben Sless</r>Can you def a generator from the schema and run again?</z><z id="t1664861233" t="dumrat Yes, that works! Looks like it&apos;s almost constant time now."><y>#</y><d>2022-10-04</d><h>05:27</h><r>dumrat</r>Yes, that works! Looks like it&apos;s almost constant time now.</z><z id="t1664864117" t="Ben Sless Awesome! All malli operations can instantiate single closures which already do all the heavy lifting and only need to validate, parse, w/e You should also try a larger range, and add a doall around the generated result,it may be lazy"><y>#</y><d>2022-10-04</d><h>06:15</h><r>Ben Sless</r>Awesome!
All malli operations can instantiate single closures which already do all the heavy lifting and only need to validate, parse, w/e
You should also try a larger range, and add a doall around the generated result,it may be lazy</z><z id="t1664865586" t="dumrat Now that you mention it, it might be lazy, I agree. Time doesn&apos;t look right. But I tried generating samples with this and it&apos;s much faster than with previous method so for my purposes this is fine. Let me check the perf anyway"><y>#</y><d>2022-10-04</d><h>06:39</h><r>dumrat</r>Now that you mention it, it might be lazy, I agree. Time doesn&apos;t look right.
But I tried generating samples with this and it&apos;s much faster than with previous method so for my purposes this is fine.
Let me check the perf anyway</z><z id="t1664865856" t="dumrat One question: I used generator like this: (defn generate-samples [sample-size] (let [gen (mg/generator cashflow-schema)] (doall (gen/sample gen sample-size)))) This is fine right?"><y>#</y><d>2022-10-04</d><h>06:44</h><r>dumrat</r>One question:

I used generator like this:

<pre>(defn generate-samples [sample-size]
  (let [gen (mg/generator cashflow-schema)]
    (doall (gen/sample gen sample-size))))</pre>
This is fine right?</z><z id="t1664867551" t="Ben Sless Yes, but you can even def the generator right under the schema. As you can see it does not depend on the sample size at all"><y>#</y><d>2022-10-04</d><h>07:12</h><r>Ben Sless</r>Yes, but you can even def the generator right under the schema. As you can see it does not depend on the sample size at all</z><z id="t1664868098" t="dumrat Yeah, so doing this makes it significantly faster (For example, to generate 500 samples, my previous code takes 10s while generator takes 1.5s so there&apos;s a marked perf improvement. But the growth is still exponential. But I think I will leave it there. I originally wanted to generate around 1000 samples and it took too long that&apos;s why I delved into this."><y>#</y><d>2022-10-04</d><h>07:21</h><r>dumrat</r>Yeah, so doing this makes it significantly faster (For example, to generate 500 samples, my previous code takes 10s while generator takes 1.5s  so there&apos;s a marked perf improvement. But the growth is still exponential. But I think I will leave it there. I originally wanted to generate around 1000 samples and it took too long that&apos;s why I delved into this.</z><z id="t1664877606" t="Ben Sless The old nerd snipe 🙂"><y>#</y><d>2022-10-04</d><h>10:00</h><r>Ben Sless</r>The old nerd snipe <b>🙂</b></z><z id="t1664854578" t="dumrat"><y>#</y><d>2022-10-04</d><h>03:36</h><w>dumrat</w></z><z id="t1664958121" t="DenisMc Quick question about malli with swagger. Right now, I define my reitit route definitions with malli, and malli-swagger generates the swagger definitions - all working well. However, recently I have added a couple of API responses where the malli definition is of the form [:or [&lt;option1 payload&gt;] [&lt;option 2 payload&gt;]] In this case, swagger seems to just report &lt;option 1 payload&gt; as the route payload. How would I go about updating swagger so that it displays the options to the API user? Thanks in advance."><y>#</y><d>2022-10-05</d><h>08:22</h><w>DenisMc</w>Quick question about malli with swagger. Right now, I define my reitit route definitions with malli, and malli-swagger generates the swagger definitions - all working well. However, recently I have added a couple of API responses where the malli definition is of the form <code>[:or [&lt;option1 payload&gt;] [&lt;option 2 payload&gt;]]</code> In this case, swagger seems to just report <code>&lt;option 1 payload&gt;</code>  as the route payload. How would I go about updating swagger so that it displays the options to the API user? Thanks in advance.</z><z id="t1664973162" t="eskos Maybe https://github.com/metosin/malli#multi-schemas would do the trick?"><y>#</y><d>2022-10-05</d><h>12:32</h><r>eskos</r>Maybe <a href="https://github.com/metosin/malli#multi-schemas" target="_blank">https://github.com/metosin/malli#multi-schemas</a> would do the trick?</z><z id="t1665182338" t="DenisMc I’ll give it a go 👍"><y>#</y><d>2022-10-07</d><h>22:38</h><r>DenisMc</r>I’ll give it a go <b>👍</b></z><z id="t1665000390" t="dangercoder Does anyone know an idiomatic way of making malli always generate UTF8 strings? I currently use my own :utf8-string type instead of :string"><y>#</y><d>2022-10-05</d><h>20:06</h><w>dangercoder</w>Does anyone know an idiomatic way of making malli always generate UTF8 strings? I currently use my own <code>:utf8-string</code> type instead of <code>:string</code></z><z id="t1665000844" t="NoahTheDuke When is it not generating utf-8 strings?"><y>#</y><d>2022-10-05</d><h>20:14</h><r>NoahTheDuke</r>When is it not generating utf-8 strings?</z><z id="t1665001388" t="dangercoder (malli.generator/generate [:string {:min 10}]) "><y>#</y><d>2022-10-05</d><h>20:23</h><r>dangercoder</r><pre>(malli.generator/generate [:string {:min 10}])</pre>
</z><z id="t1665001526" t="dangercoder adding :min makes the generator not generate utf-8 strings consistently"><y>#</y><d>2022-10-05</d><h>20:25</h><r>dangercoder</r>adding <code>:min</code>  makes the generator not generate utf-8 strings consistently</z><z id="t1665057396" t="dangercoder https://github.com/metosin/malli/issues/758 Would be great if someone else could try it out and see if you get the same results"><y>#</y><d>2022-10-06</d><h>11:56</h><r>dangercoder</r><a href="https://github.com/metosin/malli/issues/758" target="_blank">https://github.com/metosin/malli/issues/758</a>

Would be great if someone else could try it out and see if you get the same results</z><z id="t1665068902" t="ambrosebs I was the last person to touch that code so I should try it out...do you know how long this has happened and if there is a better generator to use?"><y>#</y><d>2022-10-06</d><h>15:08</h><r>ambrosebs</r>I was the last person to touch that code so I should try it out...do you know how long this has happened and if there is a better generator to use?</z><z id="t1665070916" t="ambrosebs looks like this case is built on gen/char ."><y>#</y><d>2022-10-06</d><h>15:41</h><r>ambrosebs</r>looks like this case is built on <code>gen/char</code> .</z><z id="t1665071196" t="ambrosebs perhaps gen/char-ascii or gen/char-alphanumeric should be used."><y>#</y><d>2022-10-06</d><h>15:46</h><r>ambrosebs</r>perhaps <code>gen/char-ascii</code> or <code>gen/char-alphanumeric</code> should be used.</z><z id="t1665072748" t="ambrosebs proposed a fix https://github.com/metosin/malli/pull/759"><y>#</y><d>2022-10-06</d><h>16:12</h><r>ambrosebs</r>proposed a fix <a href="https://github.com/metosin/malli/pull/759" target="_blank">https://github.com/metosin/malli/pull/759</a></z><z id="t1665250434" t="dangercoder Thanks for the fix :heart_hands:"><y>#</y><d>2022-10-08</d><h>17:33</h><r>dangercoder</r>Thanks for the fix <b>:heart_hands:</b></z><z id="t1665129561" t="ikitommi had a busy month and ending that now with a 1 week family vacation under a 🌴 . Just kooked at the PRs, merged most, big thanks to all contributors! Will cut a release after a week."><y>#</y><d>2022-10-07</d><h>07:59</h><w>ikitommi</w>had a busy month and ending that now with a 1 week family vacation under a <b>🌴</b>.  Just kooked at the PRs, merged most, big thanks to all contributors! Will cut a release after a week.</z><z id="t1665138991" t="NoahTheDuke Congrats on the vacation! "><y>#</y><d>2022-10-07</d><h>10:36</h><r>NoahTheDuke</r>Congrats on the vacation! </z><z id="t1665130715" t="dharrigan 🥳"><y>#</y><d>2022-10-07</d><h>08:18</h><w>dharrigan</w><b>🥳</b></z><z id="t1665258341" t="skynet how do I use the function generated from :malli/gen true in function metadata &lt; https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata &gt;? the doc says &quot;Setting :malli/gen to true while function body generation is enabled with mi/instrument! allows body to be generated, to return valid generated data.&quot; for example (require &apos;[malli.core :as m]) (defn pow {:malli/schema [:=&gt; [:cat :int] :int] :malli/gen true} ; how do I find/use this generated function body? [x] (* x x)) (require &apos;malli.dev) (malli.dev/start!) (pow 1) ;1"><y>#</y><d>2022-10-08</d><h>19:45</h><w>skynet</w>how do I use the function generated from <code>:malli/gen true</code> in function metadata &lt;<a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#function-schema-metadata</a>&gt;?
the doc says &quot;Setting <code>:malli/gen</code> to <code>true</code> while function body generation is enabled with <code>mi/instrument!</code> allows body to be generated, to return valid generated data.&quot;

for example
<pre>(require &apos;[malli.core :as m])
(defn pow 
  {:malli/schema [:=&gt; [:cat :int] :int]
   :malli/gen true} ; how do I find/use this generated function body?
  [x] 
  (* x x))

(require &apos;malli.dev)
(malli.dev/start!)
(pow 1)
;1</pre></z><z id="t1665323034" t="dvingo You have to pass in malli.generator/generate to the start! call. there is an example under this section: https://github.com/metosin/malli/blob/master/docs/function-schemas.md#instrumentation (&quot;With :gen we can omit the function body&quot;..) (defn pow {:malli/schema [:=&gt; [:cat :int] :int] :malli/gen true} [x] (* x x)) (defn pow2 {:malli/schema [:=&gt; [:cat :int] :int] :malli/gen false} [x] (* x x)) (md/start! {:gen malli.generator/generate}) (comment (pow 45) ; =&gt; random int (pow2 45) ; =&gt; 2025 )"><y>#</y><d>2022-10-09</d><h>13:43</h><r>dvingo</r>You have to pass in <code>malli.generator/generate</code> to the <code>start!</code> call.
there is an example under this section: <a href="https://github.com/metosin/malli/blob/master/docs/function-schemas.md#instrumentation" target="_blank">https://github.com/metosin/malli/blob/master/docs/function-schemas.md#instrumentation</a> (&quot;With <code>:gen</code> we can omit the function body&quot;..)

<pre>(defn pow {:malli/schema [:=&gt; [:cat :int] :int] :malli/gen true} [x] (* x x))
(defn pow2 {:malli/schema [:=&gt; [:cat :int] :int] :malli/gen false} [x] (* x x))
(md/start! {:gen malli.generator/generate})
(comment
  (pow 45)
  ; =&gt; random int

  (pow2 45)
  ; =&gt; 2025
  )</pre></z><z id="t1665334344" t="skynet [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] perfect! just what I needed. didn&apos;t put it together to use the same argument to start! , thanks"><y>#</y><d>2022-10-09</d><h>16:52</h><r>skynet</r><a>@U051V5LLP</a> perfect! just what I needed. didn&apos;t put it together to use the same argument to <code>start!</code>, thanks</z><z id="t1665337633" t="skynet oh and one missing piece: I now need to add :malli/gen false to the defn metadata in order to disable gen for specific functions when doing this, but this might work out"><y>#</y><d>2022-10-09</d><h>17:47</h><r>skynet</r>oh and one missing piece: I now need to add <code>:malli/gen false</code> to the defn metadata in order to disable gen for specific functions when doing this, but this might work out</z><z id="t1665347458" t="dvingo oh yea, I didn&apos;t realize that you have to opt out - another idea is to use the :filters option to target only those that you want to gen"><y>#</y><d>2022-10-09</d><h>20:30</h><r>dvingo</r>oh yea, I didn&apos;t realize that you have to opt out - another idea is to use the <code>:filters</code> option to target only those that you want to gen</z><z id="t1665482746" t="robert-stuttaford has anyone had a go at writing malli specs with https://github.com/lambdaisland/regal ? what i like about this is that it makes the regex a little more self-documenting edit: nevermind, there&apos;s a malli section right in the readme!"><y>#</y><d>2022-10-11</d><h>10:05</h><w>robert-stuttaford</w>has anyone had a go at writing malli specs with <a href="https://github.com/lambdaisland/regal" target="_blank">https://github.com/lambdaisland/regal</a> ? what i like about this is that it makes the regex a little more self-documenting

edit: nevermind, there&apos;s a malli section right in the readme!</z><z id="t1665934208" t="ikitommi I haven’t updated the Regal-side in some time. please update if the integration is out-of-date"><y>#</y><d>2022-10-16</d><h>15:30</h><r>ikitommi</r>I haven’t updated the Regal-side in some time. please update if the integration is out-of-date</z><z id="t1665934313" t="robert-stuttaford will do!"><y>#</y><d>2022-10-16</d><h>15:31</h><r>robert-stuttaford</r>will do!</z><z id="t1665514441" t="Nikolas Pafitis Hi I have a schema that looks like this [:map ... [:timeline-type [:enum :reactive :proactive-actual :proactive-alternative]]] And I&apos;m trying to use this schema with malli coercion to coerce the query params, now from the frontend i send this timeline-type as a string (obviously as it&apos;s in the query string) but it&apos;s not coerced to a keyword. Is there some option for :enum (or any other type for that matter) that I can specify a specific coercer for reitit. For example something like: [:enum {:malli.coerce/coerce-as :keyword} :reactive :proactive-actual :proactive-alternative] or something along those lines? Or what else could I do here."><y>#</y><d>2022-10-11</d><h>18:54</h><w>Nikolas Pafitis</w>Hi I have a schema that looks like this
<pre>[:map 
  ...
  [:timeline-type [:enum :reactive :proactive-actual :proactive-alternative]]]</pre>
And I&apos;m trying to use this schema with malli coercion to coerce the query params, now from the frontend i send this timeline-type as a string (obviously as it&apos;s in the query string) but it&apos;s not coerced to a keyword. Is there some option for <code>:enum</code> (or any other type for that matter) that I can specify a specific coercer for reitit. For example something like:
<pre>[:enum {:malli.coerce/coerce-as :keyword} :reactive :proactive-actual :proactive-alternative]</pre>
or something along those lines? Or what else could I do here.</z><z id="t1665934148" t="ikitommi Hi. There is an issue for resolving the real type from schemas, see https://github.com/metosin/malli/issues/264 . Before that, you can use :and -&gt; [:and :keyword [:enum :reactive :proactive-actual :proactive-alternative]]"><y>#</y><d>2022-10-16</d><h>15:29</h><r>ikitommi</r>Hi. There is an issue for resolving the real type from schemas, see <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a>. Before that, you can use <code>:and</code> -&gt; <code>[:and :keyword [:enum :reactive :proactive-actual :proactive-alternative]]</code></z><z id="t1665517146" t="Hankstenberg Hi guys, quick question: If I run m/walk in clojurescript like this: (m/walk [:map [:id string?]] (m/schema-walker identity) I&apos;m getting back a &quot;#object[malli.core.t_malli$core35871]&quot; instead of the vector I put in. What can I do with this object?"><y>#</y><d>2022-10-11</d><h>19:39</h><w>Hankstenberg</w>Hi guys, quick question: If I run m/walk in clojurescript like this:

<code>(m/walk</code>
 <code>[:map [:id string?]]</code>
 <code>(m/schema-walker identity)</code>

I&apos;m getting back a &quot;#object[malli.core.t_malli$core35871]&quot; instead of the vector I put in. What can I do with this object?</z><z id="t1665520742" t="dvingo try passing it to (malli.core/form to get the vector out if that&apos;s what you want"><y>#</y><d>2022-10-11</d><h>20:39</h><r>dvingo</r>try passing it to <code>(malli.core/form</code> to get the vector out if that&apos;s what you want</z><z id="t1665549734" t="Hankstenberg Oh, okay now I get it thanks!"><y>#</y><d>2022-10-12</d><h>04:42</h><r>Hankstenberg</r>Oh, okay now I get it thanks!</z><z id="t1665549407" t="timothypratley Hello 👋 To include a literal, is it best to use :fn ? In these examples I want to limit the matches to a specific value. This seems to work: ((ma/parser [:fn #{1}]) 1) ;=&gt; 1 ((ma/parser [:* [:cat [:fn #{1}] [:fn #{2}]]]) [1 2 1 2 1 2]) ;=&gt; [[1 2] [1 2] [1 2]] Does this seem like the correct approach?"><y>#</y><d>2022-10-12</d><h>04:36</h><w>timothypratley</w>Hello <b>👋</b>
To include a literal, is it best to use <code>:fn</code> ?
In these examples I want to limit the matches to a specific value.
This seems to work:
<pre>((ma/parser [:fn #{1}]) 1)
;=&gt; 1
((ma/parser [:* [:cat [:fn #{1}] [:fn #{2}]]])
 [1 2 1 2 1 2])
;=&gt; [[1 2] [1 2] [1 2]]</pre>
Does this seem like the correct approach?</z><z id="t1665578961" t="Chris O’Donnell I would probably use [:= 1] personally, but your approach seems fine, too."><y>#</y><d>2022-10-12</d><h>12:49</h><r>Chris O’Donnell</r>I would probably use <code>[:= 1]</code> personally, but your approach seems fine, too.</z><z id="t1665781073" t="timothypratley Oh great thank you, I didn&apos;t see := that&apos;s what I was hoping for"><y>#</y><d>2022-10-14</d><h>20:57</h><r>timothypratley</r>Oh great thank you, I didn&apos;t see <code>:=</code> that&apos;s what I was hoping for</z><z id="t1665897495" t="Ben Sless fn spec is best avoided IMO, it makes it hard to reason about specs"><y>#</y><d>2022-10-16</d><h>05:18</h><r>Ben Sless</r>fn spec is best avoided IMO, it makes it hard to reason about specs</z><z id="t1665585081" t="Stig Brautaset Can I instrument protocol methods with Malli? We use protocols (implemented by records) quite a lot. With Spec we add an indirection via a regular function to have something to hang Clojure Spec specs off of. Is that what I’d do with Malli too?"><y>#</y><d>2022-10-12</d><h>14:31</h><w>Stig Brautaset</w>Can I instrument protocol methods with Malli? We use protocols (implemented by records) quite a lot. With Spec we add an indirection via a regular function to have something to hang Clojure Spec specs off of. Is that what I’d do with Malli too?</z><z id="t1665681344" t="dvingo Ambrose was looking into this https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html https://clojurians.slack.com/archives/C06MAR553/p1661105488092049"><y>#</y><d>2022-10-13</d><h>17:15</h><r>dvingo</r>Ambrose was looking into this <a href="https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html" target="_blank">https://blog.ambrosebs.com/2022/09/08/schema-defprotocol.html</a>
<a href="https://clojurians.slack.com/archives/C06MAR553/p1661105488092049" target="_blank">https://clojurians.slack.com/archives/C06MAR553/p1661105488092049</a></z><z id="t1666009890" t="Stig Brautaset Thank you!"><y>#</y><d>2022-10-17</d><h>12:31</h><r>Stig Brautaset</r>Thank you!</z><z id="t1665598460" t="Prashant Hi, I was curious if anyone has any pointers/implementation on validating EntityMap using Malli . These are returned by (datomic.api/entity db entity-id) . These EntityMap objects don&apos;t implement IPersistentMap so schema like [:map ...] fails with type mismatch. I would greatly appreciate the inputs."><y>#</y><d>2022-10-12</d><h>18:14</h><w>Prashant</w>Hi, I was curious if anyone has any pointers/implementation on validating <code>EntityMap</code> using Malli . These are returned by <code>(datomic.api/entity db entity-id)</code> .
These <code>EntityMap</code> objects don&apos;t implement <code>IPersistentMap</code> so schema like <code>[:map ...]</code> fails with type mismatch.

I would greatly appreciate the inputs.</z><z id="t1665626728" t="dvingo You can create your own schema type using -simple-schema (here are some examples: https://github.com/metosin/malli/blob/1a9b3767f1d64d504663ca151363244db2635708/src/malli/core.cljc#L660 ) I&apos;m not sure on the details but I think you can make your predicate function convert the entity to a hashmap and then leverage the existing :map schema type by having your custom schema type pass its arguments to the :map type"><y>#</y><d>2022-10-13</d><h>02:05</h><r>dvingo</r>You can create your own schema type using <code>-simple-schema</code> (here are some examples: <a href="https://github.com/metosin/malli/blob/1a9b3767f1d64d504663ca151363244db2635708/src/malli/core.cljc#L660" target="_blank">https://github.com/metosin/malli/blob/1a9b3767f1d64d504663ca151363244db2635708/src/malli/core.cljc#L660</a>)

I&apos;m not sure on the details but I think you can make your predicate function convert the entity to a hashmap and then leverage the existing <code>:map</code>  schema type by having your custom schema type pass its arguments to the <code>:map</code> type</z><z id="t1665667303" t="Prashant Thanks [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] I will give it a shot."><y>#</y><d>2022-10-13</d><h>13:21</h><r>Prashant</r>Thanks <a>@U051V5LLP</a> I will give it a shot.</z><z id="t1665669986" t="Prashant I have reached till below and was wondering how to pass the arguments to the :map type. (defn entity? [entity] (instance? datomic.query.EntityMap entity)) (defn -entitiy-map-schema [] (-simple-schema {:type :entity-map :pred entity? :type-properties {:decode/map #(if (entity? %) (into {} %) %)}})) On a sidenote, since a instances of datomic.query.EntityMap may have nested datomic.query.EntityMap , I think using a ::ref would also be needed?"><y>#</y><d>2022-10-13</d><h>14:06</h><r>Prashant</r>I have reached till below and was wondering how to pass the arguments to the <code>:map</code> type.

<pre>(defn entity?
  [entity]
  (instance? datomic.query.EntityMap entity))


(defn -entitiy-map-schema
  []
  (-simple-schema
    {:type :entity-map
     :pred entity?     
     :type-properties {:decode/map #(if (entity? %)
                                      (into {} %)
                                      %)}}))</pre>
On a sidenote, since a instances of <code>datomic.query.EntityMap</code> may have nested <code>datomic.query.EntityMap</code>, I think using a <code>::ref</code> would also be needed?</z><z id="t1665672968" t="dvingo hmm, I think it might not be as simple as using -simple-schema you may have to copy the -map-schema implementation and delegate to that, here is a heavily hacked one I got working but gives the general idea:"><y>#</y><d>2022-10-13</d><h>14:56</h><r>dvingo</r>hmm, I think it might not be as simple as using <code>-simple-schema</code>
you may have to copy the <code>-map-schema</code> implementation and delegate to that, here is a heavily hacked one I got working but gives the general idea:</z><z id="t1665672987" t="dvingo (defn -entity-map-schema ([] (-entity-map-schema {:naked-keys true})) ([opts] ;; :naked-keys, :lazy ^{:type ::into-schema} (reify m/IntoSchema (-type [_] :entity-map) (-type-properties [_]) (-properties-schema [_ _]) (-children-schema [_ _]) (-into-schema [parent {:keys [closed] :as properties} children options] (let [map-schema (m/schema (into [:map] children)) entry-parser (m/-create-entry-parser children opts options) cache (m/-create-cache options)] ^{:type ::schema} (reify m/AST (m/-to-ast [this _] (m/-to-ast map-schema _)) m/Schema (-validator [this] (let [keyset (m/-entry-keyset (m/-entry-parser this)) _ (println &quot;2 &quot; (m/children map-schema)) validators (map (fn [[key {:keys [optional]} value]] (let [valid? (m/-validator value) default (boolean optional)] (fn [m] (if-let [map-entry (find m key)] (valid? (val map-entry)) default)))) (m/children map-schema)) validate (apply every-pred validators)] ;; THIS LINE IS THE SIGNIFICANT CHANGE: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (fn [m] (and (instance? datomic.query.EntityMap m) (validate (into {} m)))))) (-explainer [this path] (m/-explainer map-schema path)) (-parser [this] (m/-parser map-schema)) (-unparser [this] (m/-unparser map-schema)) (-transformer [this transformer method options] (m/-transformer map-schema transformer method options)) (-walk [this walker path options] (m/-walk-entries map-schema walker path options)) (-properties [_] properties) (-options [_] options) (-children [_] (m/-entry-children entry-parser)) (-parent [_] parent) (-form [_] (m/-form map-schema)) m/EntrySchema (-entries [_] (m/-entry-entries entry-parser)) (-entry-parser [_] entry-parser) m/Cached (-cache [_] cache) m/LensSchema (-keep [_] true) (-get [this key default] (m/-get-entries this key default)) (-set [this key value] (m/-set-entries this key value))))))))"><y>#</y><d>2022-10-13</d><h>14:56</h><r>dvingo</r><pre>(defn -entity-map-schema
  ([]
   (-entity-map-schema {:naked-keys true}))
  ([opts] ;; :naked-keys, :lazy
   ^{:type ::into-schema}
   (reify
     m/IntoSchema
     (-type [_] :entity-map)
     (-type-properties [_])
     (-properties-schema [_ _])
     (-children-schema [_ _])
     (-into-schema [parent {:keys [closed] :as properties} children options]
       (let [map-schema   (m/schema (into [:map] children))
             entry-parser (m/-create-entry-parser children opts options)
             cache        (m/-create-cache options)]
         ^{:type ::schema}
         (reify
           m/AST
           (m/-to-ast [this _] (m/-to-ast map-schema _))
           m/Schema
           (-validator [this]
             (let [keyset     (m/-entry-keyset (m/-entry-parser this))
                   _          (println &quot;2 &quot; (m/children map-schema))
                   validators (map
                                (fn [[key {:keys [optional]} value]]
                                    (let [valid?  (m/-validator value)
                                          default (boolean optional)]
                                      (fn [m] (if-let [map-entry (find m key)]
                                                (valid? (val map-entry))
                                                default))))
                                (m/children map-schema))

                   validate   (apply every-pred validators)]

               ;; THIS LINE IS THE SIGNIFICANT CHANGE:
               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               (fn [m] (and
                         (instance? datomic.query.EntityMap m)
                          (validate (into {} m))))))

           (-explainer [this path] (m/-explainer map-schema path))
           (-parser [this] (m/-parser map-schema))
           (-unparser [this] (m/-unparser map-schema))
           (-transformer [this transformer method options] (m/-transformer map-schema transformer method options))
           (-walk [this walker path options] (m/-walk-entries map-schema walker path options))
           (-properties [_] properties)
           (-options [_] options)
           (-children [_] (m/-entry-children entry-parser))
           (-parent [_] parent)
           (-form [_] (m/-form map-schema))
           m/EntrySchema
           (-entries [_] (m/-entry-entries entry-parser))
           (-entry-parser [_] entry-parser)
           m/Cached
           (-cache [_] cache)
           m/LensSchema
           (-keep [_] true)
           (-get [this key default] (m/-get-entries this key default))
           (-set [this key value] (m/-set-entries this key value))))))))</pre></z><z id="t1665673033" t="dvingo the main thing is when malli creates the schema (using -into-schema you take the provided children and create an underlying :map schema map-schema (m/schema (into [:map] children)) "><y>#</y><d>2022-10-13</d><h>14:57</h><r>dvingo</r>the main thing is when malli creates the schema (using <code>-into-schema</code> you take the provided children and create an underlying <code>:map</code> schema
<pre>map-schema   (m/schema (into [:map] children))</pre>
</z><z id="t1665673049" t="dvingo then fill in all the protocol methods for IntoSchema using that"><y>#</y><d>2022-10-13</d><h>14:57</h><r>dvingo</r>then fill in all the protocol methods for <code>IntoSchema</code> using that</z><z id="t1665673090" t="Prashant Thanks a ton!!! this is super helpful."><y>#</y><d>2022-10-13</d><h>14:58</h><r>Prashant</r>Thanks a ton!!! this is super helpful.</z><z id="t1665673110" t="dvingo there may be a much simpler way to do this, I&apos;m not an expert on this, just figuring things out by reading the source code of malli.core"><y>#</y><d>2022-10-13</d><h>14:58</h><r>dvingo</r>there may be a much simpler way to do this, I&apos;m not an expert on this, just figuring things out by reading the source code of malli.core</z><z id="t1665673207" t="dvingo and you can try it with: (m/validate (m/schema [:entity-map [:x :int]] {:registry (assoc (m/default-schemas) :entity-map (-entity-map-schema))}) (d/entity db [:some/id-prop 5]))"><y>#</y><d>2022-10-13</d><h>15:00</h><r>dvingo</r>and you can try it with:
<pre>(m/validate
  (m/schema [:entity-map [:x :int]] 
    {:registry (assoc (m/default-schemas) :entity-map (-entity-map-schema))})
  (d/entity db [:some/id-prop 5]))</pre></z><z id="t1665673228" t="Prashant This gives a very good head start. I was also thinking on the same lines of copying map schema and hacking through it."><y>#</y><d>2022-10-13</d><h>15:00</h><r>Prashant</r>This gives a very good head start. I was also thinking on the same lines of copying map schema and hacking through it.</z><z id="t1665673264" t="Prashant Thanks again [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] !!!"><y>#</y><d>2022-10-13</d><h>15:01</h><r>Prashant</r>Thanks again <a>@U051V5LLP</a>!!!</z><z id="t1665673374" t="dvingo sure thing! I&apos;m still learning myself, so would be curious what you come up with 🙂"><y>#</y><d>2022-10-13</d><h>15:02</h><r>dvingo</r>sure thing! I&apos;m still learning myself, so would be curious what you come up with <b>🙂</b></z><z id="t1665933799" t="ikitommi Would it help if the malli.core/-map-schema took an extra option for the predicate? e.g. on could just do: (def EntityMap (m/-map-schema {:pred entity?})) (m/validate EntityMap ...)"><y>#</y><d>2022-10-16</d><h>15:23</h><r>ikitommi</r>Would it help if the <code>malli.core/-map-schema</code> took an extra option for the predicate? e.g. on could just do:
<pre>(def EntityMap (m/-map-schema {:pred entity?}))

(m/validate EntityMap ...)</pre></z><z id="t1665933942" t="ikitommi Malli is intended to be extendable, so all IntoSchema s are created using functions and it’s a easy &amp; non-breaking change to add new options 🙂"><y>#</y><d>2022-10-16</d><h>15:25</h><r>ikitommi</r>Malli is intended to be extendable, so all <code>IntoSchema</code>s are created using functions and it’s a easy &amp; non-breaking change to add new options <b>🙂</b></z><z id="t1665933963" t="ikitommi (also, effects bundle-size on cljs, non-used schemas can be DCEd)"><y>#</y><d>2022-10-16</d><h>15:26</h><r>ikitommi</r>(also, effects bundle-size on cljs, non-used schemas can be DCEd)</z><z id="t1665934000" t="ikitommi anyway, PR welcome on adding the :pred for the m/-map-schema"><y>#</y><d>2022-10-16</d><h>15:26</h><r>ikitommi</r>anyway, PR welcome on adding the <code>:pred</code> for the <code>m/-map-schema</code></z><z id="t1666015823" t="Prashant Thanks for the suggestion Tommi. I will definitely look into implementing your suggestion and when satisfied, raise a PR 🙂"><y>#</y><d>2022-10-17</d><h>14:10</h><r>Prashant</r>Thanks for the suggestion Tommi.
I will definitely look into implementing your suggestion and when satisfied, raise a PR <b>🙂</b></z><z id="t1666021502" t="Prashant [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Raised this https://github.com/metosin/malli/pull/767 per your suggestion 🙂"><y>#</y><d>2022-10-17</d><h>15:45</h><r>Prashant</r><a>@U055NJ5CC</a> Raised this <a href="https://github.com/metosin/malli/pull/767" target="_blank">https://github.com/metosin/malli/pull/767</a> per your suggestion <b>🙂</b></z><z id="t1665729207" t="robert-stuttaford where can i learn about how to write generators for complex :multi specs? currently butting my head against this: (mg/sample ;; OK [:map [:db/id {:optional true}]]) (mg/sample ;; OK [:multi {:dispatch :type} [:some.type/value [:map [:some/key :string]]]]) (mg/sample ;; Couldn&apos;t satisfy such-that predicate after 100 tries. [:and [:map [:db/id {:optional true}]] [:multi {:dispatch :type} [:some.type/value [:map [:some/key :string]]]]])"><y>#</y><d>2022-10-14</d><h>06:33</h><w>robert-stuttaford</w>where can i learn about how to write generators for complex <code>:multi</code>  specs? currently butting my head against this:

<pre>(mg/sample ;; OK
   [:map [:db/id {:optional true}]])

  (mg/sample ;; OK
   [:multi {:dispatch :type}
    [:some.type/value
     [:map
      [:some/key :string]]]])

  (mg/sample ;; Couldn&apos;t satisfy such-that predicate after 100 tries.
   [:and
    [:map [:db/id {:optional true}]]
    [:multi {:dispatch :type}
     [:some.type/value
      [:map
       [:some/key :string]]]]])</pre></z><z id="t1665743336" t="pithyless Two things come to mind: 1. I think your :multi map needs to include the dispatch key (otherwise it won&apos;t be generated correctly) 2. Is it feasible for you to merge the multi map? This would work: (mg/sample [:multi {:dispatch :type} [:some.type/value (mu/merge [:map [:type [:= :some.type/value]] [:some/key :string]] [:map [:db/id :string]])]])"><y>#</y><d>2022-10-14</d><h>10:28</h><r>pithyless</r>Two things come to mind:
1. I think your <code>:multi</code> map needs to include the dispatch key (otherwise it won&apos;t be generated correctly)
2. Is it feasible for you to merge the multi map? This would work:
<pre>(mg/sample
    [:multi {:dispatch :type}
     [:some.type/value
      (mu/merge 
        [:map
         [:type [:= :some.type/value]]
         [:some/key :string]]
        [:map
         [:db/id :string]])]])</pre></z><z id="t1665743390" t="pithyless Nevertheless, subscribing to this thread in hope that there is a better way to solve this problem (have encountered it as well)."><y>#</y><d>2022-10-14</d><h>10:29</h><r>pithyless</r>Nevertheless, subscribing to this thread in hope that there is a better way to solve this problem (have encountered it as well).</z><z id="t1665743575" t="robert-stuttaford thanks that gives me some things to try 😅"><y>#</y><d>2022-10-14</d><h>10:32</h><r>robert-stuttaford</r>thanks that gives me some things to try <b>😅</b></z><z id="t1665761941" t="Stig Brautaset This is a topic I’m interested in too. I tried to spec out the complete state of a board game (a toy project), and it was very easy to get into a situation where the generation failed."><y>#</y><d>2022-10-14</d><h>15:39</h><r>Stig Brautaset</r>This is a topic I’m interested in too. I tried to spec out the complete state of a board game (a toy project), and it was very easy to get into a situation where the generation failed.</z><z id="t1665818500" t="robert-stuttaford ok so it seems i can&apos;t use mu/union because of cyclic dependencies between my specs; so it looks like generating data is off the table for me here. just in case there&apos;s something i&apos;m missing, if you&apos;ve any advice [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , i&apos;d greatly appreciate it 🙂"><y>#</y><d>2022-10-15</d><h>07:21</h><r>robert-stuttaford</r>ok so it seems i can&apos;t use <code>mu/union</code> because of cyclic dependencies between my specs; so it looks like generating data is off the table for me here.

just in case there&apos;s something i&apos;m missing, if you&apos;ve any advice <a>@U055NJ5CC</a>, i&apos;d greatly appreciate it <b>🙂</b></z><z id="t1665897342" t="Ben Sless You can break cyclic dependencies with a ref spec"><y>#</y><d>2022-10-16</d><h>05:15</h><r>Ben Sless</r>You can break cyclic dependencies with a ref spec</z><z id="t1665905329" t="robert-stuttaford i am using ref specs - the issue is that to use mu/union, the keyword specs you give it have to be registered already, which forces a specific code loading order, but i can&apos;t ensure that order because the spec is for an entity that links to other entities of the same spec, linked-list type &apos;next-item&apos; / &apos;parent-item&apos; stuff. the specs work as validation (with :ref specs); it just doesn&apos;t work to generate"><y>#</y><d>2022-10-16</d><h>07:28</h><r>robert-stuttaford</r>i am using ref specs - the issue is that to use mu/union, the keyword specs you give it have to be registered already, which forces a specific code loading order, but i can&apos;t ensure that order because the spec is for an entity that links to other entities of the same spec, linked-list type &apos;next-item&apos; / &apos;parent-item&apos; stuff.

the specs work as validation (with :ref specs); it just doesn&apos;t work to generate</z><z id="t1665905553" t="Ben Sless Huh, weird. Want to send the complete schema (or minimal repro)? I think I managed that once"><y>#</y><d>2022-10-16</d><h>07:32</h><r>Ben Sless</r>Huh, weird. Want to send the complete schema (or minimal repro)? I think I managed that once</z><z id="t1665906598" t="robert-stuttaford apex spec is :multi. all of the internal impls all a shared base :map spec, and some are that base plus some extra :map spec. the base :map spec has :refs to the apex :multi spec. then, after all that, i am also wrapping this in a generic Datomic id handling system, where whenever i specify a :db.type/ref, there&apos;s a wrapper spec that allows either a long, a tempid, a map with a long or tempid, or an :and of :map :db/id optional and whatever the actual spec was; in this case, the apex multi spec. all of this validates, but it doesn&apos;t generate 😬 i suspect what i want is conceptually not possible, but i don&apos;t know enough about malli or the domain it operates in to know for sure."><y>#</y><d>2022-10-16</d><h>07:49</h><r>robert-stuttaford</r>apex spec is :multi. all of the internal impls all a shared base :map spec, and some are that base plus some extra :map spec. the base :map spec has :refs to the apex :multi spec.

then, after all that, i am also wrapping this in a generic Datomic id handling system, where whenever i specify a :db.type/ref, there&apos;s a wrapper spec that allows either a long, a tempid, a map with a long or tempid, or an :and of :map :db/id optional and whatever the actual spec was; in this case, the apex multi spec.

all of this validates, but it doesn&apos;t generate <b>😬</b>

i suspect what i want is conceptually not possible, but i don&apos;t know enough about malli or the domain it operates in to know for sure.</z><z id="t1665906643" t="robert-stuttaford i can provide pseudocode if that was too eye-watering to reason through 🙂"><y>#</y><d>2022-10-16</d><h>07:50</h><r>robert-stuttaford</r>i can provide pseudocode if that was too eye-watering to reason through <b>🙂</b></z><z id="t1665907698" t="Ben Sless Have you tried using a schema schema to wrap it all together?"><y>#</y><d>2022-10-16</d><h>08:08</h><r>Ben Sless</r>Have you tried using a schema schema to wrap it all together?</z><z id="t1665907719" t="Ben Sless e.g. [:schema {:registry everything-you-just-said} ::apex] ?"><y>#</y><d>2022-10-16</d><h>08:08</h><r>Ben Sless</r>e.g. <code>[:schema {:registry everything-you-just-said} ::apex]</code>?</z><z id="t1665908008" t="robert-stuttaford ah, i am incrementally building this up with calls to swap! on an atom that has been given to (mr/set-default-registry! (mr/mutable-registry *registry)) . i&apos;ll work up a minimal repro version of what i said without that and with [:schema {:registry ...} :: apex] and see how it goes!"><y>#</y><d>2022-10-16</d><h>08:13</h><r>robert-stuttaford</r>ah, i am incrementally building this up with calls to swap! on an atom that has been given to <code>(mr/set-default-registry! (mr/mutable-registry *registry))</code> . i&apos;ll work up a minimal repro version of what i said without that and with [:schema {:registry ...} <b>::</b>apex]  and see how it goes!</z><z id="t1665933426" t="ikitommi Hi, some comments on this: • :and generator generates on the first and just validates the generated result with the validators of the rest of the childs -&gt; not likely to match • I was sure that there was an example on :multi + gen in README, but it seems there is not! but for now, there is no logic to merge the dispatch types into the schemas, so you have to do it yourself. Here’s an example from README: [:multi {:dispatch :type :decode/string #(update % :type keyword)} [:sized [:map [:type [:= :sized]] [:size int?]]] [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]] • should find time to work on https://github.com/metosin/malli/issues/264 , would help here and I think this is really important anyway • if all childs are maps and the :dispatch value is a Keyword or a String, there could be a helper to push the key + value into the maps. this helper could be used in gen, json-schema etc. namespaces to make it work correctly • I’m thinking :and is bad (like Plumatic Team found out) and there should be something like :constrained instead. • sorry [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] , I guess this didn’t help you, but that’s something for the background. Looking forward to your repro + Ben’s solution 🙂 "><y>#</y><d>2022-10-16</d><h>15:17</h><r>ikitommi</r>Hi, some comments on this:
• <code>:and</code> generator generates on the first and just validates the generated result with the validators of the rest of the childs -&gt; not likely to match
• I was sure that there was an example on <code>:multi</code> + gen in README, but it seems there is not! but for now, there is no logic to merge the dispatch types into the schemas, so you have to do it yourself. Here’s an example from README:
<pre>[:multi {:dispatch :type
         :decode/string #(update % :type keyword)}
 [:sized [:map [:type [:= :sized]] [:size int?]]]
 [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]]</pre>
• should find time to work on <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a>, would help here and I think this is really important anyway
• if all childs are maps and the <code>:dispatch</code> value is a Keyword or a String, there could be a helper to push the key + value into the maps. this helper could be used in gen, json-schema etc. namespaces to make it work correctly
• I’m thinking <code>:and</code> is bad (like Plumatic Team found out) and there should be something like <code>:constrained</code> instead.
• sorry <a>@robert-stuttaford</a>, I guess this didn’t help you, but that’s something for the background. Looking forward to your repro + Ben’s solution <b>🙂</b> </z><z id="t1665934227" t="robert-stuttaford thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , this is useful info!"><y>#</y><d>2022-10-16</d><h>15:30</h><r>robert-stuttaford</r>thanks <a>@U055NJ5CC</a>, this is useful info!</z><z id="t1665939192" t="Ben Sless Based on some experience playing with kanren, should and implement a bind of one generator to the next?"><y>#</y><d>2022-10-16</d><h>16:53</h><r>Ben Sless</r>Based on some experience playing with kanren, should <code>and</code> implement a <code>bind</code> of one generator to the next?</z><z id="t1665940337" t="Ben Sless Not sure if it&apos;s viable, but a schema can describe how it can return a generator from a seed value to build up with bind. That way, for example, a map schema would use merge"><y>#</y><d>2022-10-16</d><h>17:12</h><r>Ben Sless</r>Not sure if it&apos;s viable, but a schema can describe how it can return a generator from a seed value to build up with bind. That way, for example, a map schema would use merge</z><z id="t1665933426" t="ikitommi Hi, some comments on this: • :and generator generates on the first and just validates the generated result with the validators of the rest of the childs -&gt; not likely to match • I was sure that there was an example on :multi + gen in README, but it seems there is not! but for now, there is no logic to merge the dispatch types into the schemas, so you have to do it yourself. Here’s an example from README: [:multi {:dispatch :type :decode/string #(update % :type keyword)} [:sized [:map [:type [:= :sized]] [:size int?]]] [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]] • should find time to work on https://github.com/metosin/malli/issues/264 , would help here and I think this is really important anyway • if all childs are maps and the :dispatch value is a Keyword or a String, there could be a helper to push the key + value into the maps. this helper could be used in gen, json-schema etc. namespaces to make it work correctly • I’m thinking :and is bad (like Plumatic Team found out) and there should be something like :constrained instead. • sorry [:attrs {:href &quot;/_/_/users/U0509NKGK&quot;}] , I guess this didn’t help you, but that’s something for the background. Looking forward to your repro + Ben’s solution 🙂 "><y>#</y><d>2022-10-16</d><h>15:17</h><w>ikitommi</w>Hi, some comments on this:
• <code>:and</code> generator generates on the first and just validates the generated result with the validators of the rest of the childs -&gt; not likely to match
• I was sure that there was an example on <code>:multi</code> + gen in README, but it seems there is not! but for now, there is no logic to merge the dispatch types into the schemas, so you have to do it yourself. Here’s an example from README:
<pre>[:multi {:dispatch :type
         :decode/string #(update % :type keyword)}
 [:sized [:map [:type [:= :sized]] [:size int?]]]
 [:human [:map [:type [:= :human]] [:name string?] [:address [:map [:country keyword?]]]]]]</pre>
• should find time to work on <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a>, would help here and I think this is really important anyway
• if all childs are maps and the <code>:dispatch</code> value is a Keyword or a String, there could be a helper to push the key + value into the maps. this helper could be used in gen, json-schema etc. namespaces to make it work correctly
• I’m thinking <code>:and</code> is bad (like Plumatic Team found out) and there should be something like <code>:constrained</code> instead.
• sorry <a>@robert-stuttaford</a>, I guess this didn’t help you, but that’s something for the background. Looking forward to your repro + Ben’s solution <b>🙂</b> </z><z id="t1665945427" t="ikitommi … and, it’s out 🥳 . Thank’s everyone!!"><y>#</y><d>2022-10-16</d><h>18:37</h><w>ikitommi</w>… and, it’s out <b>🥳</b>. Thank’s everyone!!</z><z id="t1666042686" t="skynet I&apos;m seeing a bug in malli 0.9.0 and 0.9.1, and I&apos;m trying to get a minimal reproduction of this issue but I can&apos;t. the error I&apos;m getting is: Exception: java.lang.ClassCastExcetpion: class clojure.lang.Symbol cannot be cast to class java.lang.String (clojure.lang.Symbol is in unnamed module of loader &apos;app&apos;; java.lang.String is in module java.base of loader &apos;bootstrap&apos;) at clojure.core$symbol.invokeStatic (core.clj:591) ... malli.instrument$_strument_BANG_$fn__24440$fn__24441.invoke (instrument.clj:23) malli.core$_instrument$fn__21304.doInvoke (core.cljc:2480) ... &lt;my code&gt; this occurs in a test after doing ! . there are some functions in the project with :malli/gen true in function metadata, and some with that set to false . malli is started with: (malli.dev/start! {::m/function-checker mg/function-checker :report (pretty/reporter) :gen mg/generate}) this all works on 0.8.9. unfortunately I can&apos;t share the code, but I&apos;m not sure this is enough for someone to fix it"><y>#</y><d>2022-10-17</d><h>21:38</h><w>skynet</w>I&apos;m seeing a bug in malli 0.9.0 and 0.9.1, and I&apos;m trying to get a minimal reproduction of this issue but I can&apos;t. the error I&apos;m getting is:

<pre>Exception: java.lang.ClassCastExcetpion: class clojure.lang.Symbol cannot be cast to class java.lang.String (clojure.lang.Symbol is in unnamed module of loader &apos;app&apos;; java.lang.String is in module java.base of loader &apos;bootstrap&apos;)
 at clojure.core$symbol.invokeStatic (core.clj:591)
    ...
    malli.instrument$_strument_BANG_$fn__24440$fn__24441.invoke (instrument.clj:23)
    malli.core$_instrument$fn__21304.doInvoke (core.cljc:2480)
    ...
    &lt;my code&gt;</pre>
this occurs in a test after doing <code>!</code>. there are some functions in the project with <code>:malli/gen true</code> in function metadata, and some with that set to <code>false</code>. malli is started with:
<pre>(malli.dev/start!
  {::m/function-checker mg/function-checker
   :report (pretty/reporter)
   :gen mg/generate})</pre>
this all works on 0.8.9. unfortunately I can&apos;t share the code, but I&apos;m not sure this is enough for someone to fix it</z><z id="t1666045976" t="skynet oh actually I figured it out, I was redefining a fn that was instrumented, and had it returning invalid data, like this https://github.com/skynet-gh/2022-10-17-malli-instrument-bug then malli calls (symbol n s) in that case https://github.com/metosin/malli/blob/master/src/malli/instrument.clj#L23 and n and s are symbols in that case, which doesn&apos;t work for multi-arity https://clojuredocs.org/clojure.core/symbol so changing it to (symbol (name n) (name s)) works"><y>#</y><d>2022-10-17</d><h>22:32</h><w>skynet</w>oh actually I figured it out, I was redefining a fn that was instrumented, and had it returning invalid data, like this <a href="https://github.com/skynet-gh/2022-10-17-malli-instrument-bug" target="_blank">https://github.com/skynet-gh/2022-10-17-malli-instrument-bug</a>

then malli calls <code>(symbol n s)</code> in that case <a href="https://github.com/metosin/malli/blob/master/src/malli/instrument.clj#L23" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/instrument.clj#L23</a>
and <code>n</code> and <code>s</code> are symbols in that case, which doesn&apos;t work for multi-arity <a href="https://clojuredocs.org/clojure.core/symbol" target="_blank">https://clojuredocs.org/clojure.core/symbol</a>
so changing it to <code>(symbol (name n) (name s))</code> works</z><z id="t1666046632" t="skynet ok I over-complicated it. I think it will break after ! with :report whenever you have any invalid input/output on an instrumented function"><y>#</y><d>2022-10-17</d><h>22:43</h><w>skynet</w>ok I over-complicated it. I think it will break after <code>!</code> with <code>:report</code> whenever you have any invalid input/output on an instrumented function</z><z id="t1666047052" t="dvingo Oh shoot, I just touched that code recently, I can take a look"><y>#</y><d>2022-10-17</d><h>22:50</h><w>dvingo</w>Oh shoot, I just touched that code recently, I can take a look</z><z id="t1666049355" t="dvingo https://github.com/metosin/malli/pull/768 TIL - that code works in cljs !"><y>#</y><d>2022-10-17</d><h>23:29</h><r>dvingo</r><a href="https://github.com/metosin/malli/pull/768" target="_blank">https://github.com/metosin/malli/pull/768</a>
TIL - that code works in cljs !</z><z id="t1666099479" t="skynet that&apos;s tricky, I didn&apos;t know that either"><y>#</y><d>2022-10-18</d><h>13:24</h><r>skynet</r>that&apos;s tricky, I didn&apos;t know that either</z><z id="t1666072715" t="ikitommi [metosin/malli &quot;0.9.2&quot;] , thanks [:attrs {:href &quot;/_/_/users/U051V5LLP&quot;}] for the quick fix!"><y>#</y><d>2022-10-18</d><h>05:58</h><w>ikitommi</w><code>[metosin/malli &quot;0.9.2&quot;]</code>, thanks <a>@danvingo</a> for the quick fix!</z><z id="t1666072760" t="ikitommi would be good to have tests for the dev-tooling too for the future."><y>#</y><d>2022-10-18</d><h>05:59</h><w>ikitommi</w>would be good to have tests for the dev-tooling too for the future.</z><z id="t1666097500" t="dvingo agreed! I will take a look into adding some for start!"><y>#</y><d>2022-10-18</d><h>12:51</h><r>dvingo</r>agreed! I will take a look into adding some for <code>start!</code></z><z id="t1666131358" t="dvingo [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I&apos;m writing some tests for ! and friends and noticed that the arguments are a little confusing. start! takes :ns which indicates the set of namespaces to be collected, but then instrument! doesn&apos;t use that set - instead you have to separately pass :filters with [(mi/-filter-ns...) do you think it makes sense to use the set of namespaces passed in to start! if they are present and pass those to filters so instrument! will use the same set? Otherwise you have to pass both :ns and :filters to only start collection and instrumentation on the desired set of namespaces"><y>#</y><d>2022-10-18</d><h>22:15</h><w>dvingo</w><a>@ikitommi</a> I&apos;m writing some tests for <code>!</code> and friends and noticed that the arguments are a little confusing.

<code>start!</code>  takes <code>:ns</code> which indicates the set of namespaces to be collected, but then <code>instrument!</code>  doesn&apos;t use that set - instead you have to separately pass <code>:filters</code> with <code>[(mi/-filter-ns...)</code>
do you think it makes sense to use the set of namespaces passed in to <code>start!</code> if they are present and pass those to filters so <code>instrument!</code> will use the same set? Otherwise you have to pass both <code>:ns</code> and <code>:filters</code> to only start collection and instrumentation on the desired set of namespaces</z><z id="t1666155686" t="ikitommi :thinking_face: just looked at the code, dev/start! doesn&apos;t seem to use any :ns option either. Where did you pick that up?"><y>#</y><d>2022-10-19</d><h>05:01</h><r>ikitommi</r><b>:thinking_face:</b> just looked at the code, <code>dev/start!</code> doesn&apos;t seem to use any <code>:ns</code> option either. Where did you pick that up?</z><z id="t1666178946" t="dvingo oh wow, that&apos;s my mistake! I see what happened - it&apos;s collect! that uses it, https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/dev.clj#L23 which does support changing what is collected: https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/instrument.clj#L46 I must have saw that and inferred that you wouldn&apos;t always want to collect everything when using dev/start! do you have any thoughts on if the :ns option should be supported for start! ? I can change it back for the cljs version if you want"><y>#</y><d>2022-10-19</d><h>11:29</h><r>dvingo</r>oh wow, that&apos;s my mistake!
I see what happened - it&apos;s <code>collect!</code> that uses it,
<a href="https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/dev.clj#L23" target="_blank">https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/dev.clj#L23</a>
which does support changing what is collected:
<a href="https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/instrument.clj#L46" target="_blank">https://github.com/metosin/malli/blob/546eb663484e66ef1271b99189b17dbeca215ec8/src/malli/instrument.clj#L46</a>

I must have saw that and inferred that you wouldn&apos;t always want to collect everything when using <code>dev/start!</code>

do you have any thoughts on if the <code>:ns</code> option should be supported for <code>start!</code>? I can change it back for the cljs version if you want</z><z id="t1666247599" t="ikitommi I think it should in start! too, but silly to be only on collect!"><y>#</y><d>2022-10-20</d><h>06:33</h><r>ikitommi</r>I think it should in <code>start!</code> too, but silly to be only on <code>collect!</code></z><z id="t1666150814" t="Joel Using the subschemas example, I wanted to pull out some custom data from the schema structure with the associated path. From something like this… [:street {:optional true :custom-field :value} string?] I want to make grab the path and that :value I put in that the properties. However, I see that using mu/subschemas does not return the properties. I guess I need to write my own walker? I find that puzzling since I think malli would need that :optional true info."><y>#</y><d>2022-10-19</d><h>03:40</h><w>Joel</w>Using the subschemas example, I wanted to pull out some custom data from the schema structure with the associated path.  From something like this… <code>[:street {:optional true :custom-field :value} string?]</code>  I want to make grab the path and that <code>:value</code> I put in that the properties.
However, I see that using mu/subschemas does not return the properties. I guess I need to write my own walker? I find that puzzling since I think malli would need that <code>:optional true</code> info.</z><z id="t1666155429" t="ikitommi could you paste a minimal repro here?"><y>#</y><d>2022-10-19</d><h>04:57</h><r>ikitommi</r>could you paste a minimal repro here?</z><z id="t1666187067" t="Joel (def Schema (m/schema [:map [:purchases {:optional true } [:set string?]]])) (mu/subschemas Schema) When :purchases is walked, it doesn’t list the {:optional…}"><y>#</y><d>2022-10-19</d><h>13:44</h><r>Joel</r><pre>(def Schema
  (m/schema
   [:map
    [:purchases {:optional true } [:set string?]]]))
 (mu/subschemas Schema)</pre>
When <code>:purchases</code> is walked, it doesn’t list the {:optional…}</z><z id="t1666190222" t="ikitommi It’s because the properties are on the map-entry, not the child itself."><y>#</y><d>2022-10-19</d><h>14:37</h><r>ikitommi</r>It’s because the properties are on the map-entry, not the child itself.</z><z id="t1666190254" t="ikitommi there is mu/find that works like clojure.core/find , e.g. returns the [key properties value] entry."><y>#</y><d>2022-10-19</d><h>14:37</h><r>ikitommi</r>there is <code>mu/find</code> that works like <code>clojure.core/find</code>, e.g. returns the <code>[key properties value]</code> entry.</z><z id="t1666190262" t="ikitommi so, you can: (def Schema (m/schema [:map [:purchases {:optional true} [:set string?]]])) (defn get-in-props [schema path] (if-let [?entry (mu/find (mu/get-in schema (butlast path)) (last path))] (when (vector? ?entry) (second ?entry)))) (for [sub (mu/subschemas Schema)] (assoc sub :entry-props (get-in-props Schema (:path sub)))) ;({:path [], :in [], :schema [:map [:purchases {:optional true} [:set string?]]], :entry-props nil} ; {:path [:purchases], :in [:purchases], :schema [:set string?], :entry-props {:optional true}} ; {:path [:purchases :malli.core/in], :in [:purchases :malli.core/in], :schema string?, :entry-props nil})"><y>#</y><d>2022-10-19</d><h>14:37</h><r>ikitommi</r>so, you can:
<pre>(def Schema
  (m/schema
   [:map
    [:purchases {:optional true} [:set string?]]]))

(defn get-in-props [schema path]
  (if-let [?entry (mu/find (mu/get-in schema (butlast path)) (last path))]
    (when (vector? ?entry) (second ?entry))))

(for [sub (mu/subschemas Schema)]
  (assoc sub :entry-props (get-in-props Schema (:path sub))))
;({:path [], :in [], :schema [:map [:purchases {:optional true} [:set string?]]], :entry-props nil}
; {:path [:purchases], :in [:purchases], :schema [:set string?], :entry-props {:optional true}}
; {:path [:purchases :malli.core/in], :in [:purchases :malli.core/in], :schema string?, :entry-props nil})</pre></z><z id="t1666190265" t="ikitommi hope that helps."><y>#</y><d>2022-10-19</d><h>14:37</h><r>ikitommi</r>hope that helps.</z><z id="t1666190337" t="Joel looks like it will, ill give it a go."><y>#</y><d>2022-10-19</d><h>14:38</h><r>Joel</r>looks like it will, ill give it a go.</z><z id="t1666190644" t="Joel i don’t understand what :malli.core/in is “about”, but this gets me what i need - thanks!"><y>#</y><d>2022-10-19</d><h>14:44</h><r>Joel</r>i don’t understand what <code>:malli.core/in</code> is “about”, but this gets me what i need - thanks!</z><z id="t1666191249" t="ikitommi it&apos;s basically a pointer into to a homogeneous seq, &quot;values in any position&quot;."><y>#</y><d>2022-10-19</d><h>14:54</h><r>ikitommi</r>it&apos;s basically a pointer into to a homogeneous seq, &quot;values in any position&quot;.</z><z id="t1666160889" t="timothypratley Hi 👋 I&apos;m trying to understand 2 things about catn : &apos;[:catn [m [:schema [:ref &quot;m&quot;]]] [s [:schema [:ref &quot;s&quot;]]] [_ [:orn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]]] 1. It seems to produce the same output whether I use :orn or :altn -- is there a reason to prefer one over the other? 2. The result it produces is {m {:a 1}, s #{:a}, _ [k :k]} is there any way I can produce {m {:a 1}, s #{:a}, k :k} instead? Where the catn takes the name from the choice operator (`:orn`)? Below is the full schema but you can ignore most of it, it&apos;s just the choice between vector and keyword at the end that I&apos;m focusing on: &apos;[:schema {:registry {&quot;start&quot; [:and vector? [:catn [m [:schema [:ref &quot;m&quot;]]] [s [:schema [:ref &quot;s&quot;]]] [_ [:orn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]]]], &quot;m&quot; map?, &quot;s&quot; set?, &quot;v&quot; [:and vector? [:catn [a [:schema any?]] [b [:schema any?]] [c [:schema any?]]]], &quot;k&quot; keyword?}} &quot;start&quot;] And an example input: &apos;{m {:a 1} s #{:a} k :k} "><y>#</y><d>2022-10-19</d><h>06:28</h><w>timothypratley</w>Hi <b>👋</b>
I&apos;m trying to understand 2 things about <code>catn</code>:
<pre>&apos;[:catn
     [m [:schema [:ref &quot;m&quot;]]]
     [s [:schema [:ref &quot;s&quot;]]]
     [_ [:orn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]]]</pre>
1. It seems to produce the same output whether I use <code>:orn</code> or <code>:altn</code> -- is there a reason to prefer one over the other?
2. The result it produces is <code>{m {:a 1}, s #{:a}, _ [k :k]}</code> is there any way I can produce <code>{m {:a 1}, s #{:a}, k :k}</code> instead? Where the <code>catn</code> takes the name from the choice operator (`:orn`)?
Below is the full schema but you can ignore most of it, it&apos;s just the choice between vector and keyword at the end that I&apos;m focusing on:
<pre>&apos;[:schema
  {:registry {&quot;start&quot; [:and vector?
                       [:catn
                        [m [:schema [:ref &quot;m&quot;]]]
                        [s [:schema [:ref &quot;s&quot;]]]
                        [_ [:orn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]]]],
              &quot;m&quot;     map?,
              &quot;s&quot;     set?,
              &quot;v&quot;     [:and vector?
                       [:catn [a [:schema any?]] [b [:schema any?]] [c [:schema any?]]]],
              &quot;k&quot;     keyword?}}
  &quot;start&quot;]</pre>
And an example input:
<pre>&apos;{m {:a 1}
  s #{:a}
  k :k}</pre>
</z><z id="t1666210097" t="timothypratley One thing I discovered is that I can move the name binding &quot;inside&quot; cat using single argument orn instead of using catn : [:cat [:orn [m [:schema [:ref &quot;m&quot;]]]] [:orn [s [:schema [:ref &quot;s&quot;]]]] [:altn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]] =&gt; [[m {:a 1}] [s #{:a}] [k :k]] Which is interesting."><y>#</y><d>2022-10-19</d><h>20:08</h><r>timothypratley</r>One thing I discovered is that I can move the name binding &quot;inside&quot; cat using single argument <code>orn</code> instead of using <code>catn</code>:
<pre>[:cat
     [:orn [m [:schema [:ref &quot;m&quot;]]]]
     [:orn [s [:schema [:ref &quot;s&quot;]]]]
     [:altn [v [:schema [:ref &quot;v&quot;]]] [k [:schema [:ref &quot;k&quot;]]]]]</pre>
=&gt; <code>[[m {:a 1}] [s #{:a}] [k :k]]</code>
 Which is interesting.</z><z id="t1666221487" t="timothypratley Why does using a schema ref catn behave differently from an embedded catn : (ma/parse &apos;[:schema {:registry {&quot;start&quot; [:and vector? [:catn [a [:schema any?]] [b [:schema [:ref &quot;b&quot;]]]]], &quot;b&quot; [:catn [c [:schema any?]] [d [:schema any?]]]}} &quot;start&quot;], &apos;[1 (2 3)]) (ma/parse &apos;[:schema {:registry {&quot;start&quot; [:and vector? [:catn [a [:schema any?]] [b [:catn [c [:schema any?]] [d [:schema any?]]]]]]}} &quot;start&quot;], &apos;[1 2 3]) ^^ The first (using a schema ref) matches a list inside a vector [1 (2 3)] , whereas the second (embedded) matches a flat vector [1 2 3] -- I&apos;m wondering if there is a way to use a ref to match a flat vector instead of a list."><y>#</y><d>2022-10-19</d><h>23:18</h><w>timothypratley</w>Why does using a schema ref <code>catn</code> behave differently from an embedded <code>catn</code>:
<pre>(ma/parse
  &apos;[:schema {:registry {&quot;start&quot; [:and vector? [:catn
                                               [a [:schema any?]]
                                               [b [:schema [:ref &quot;b&quot;]]]]],
                        &quot;b&quot; [:catn [c [:schema any?]] [d [:schema any?]]]}}
    &quot;start&quot;],
  &apos;[1 (2 3)])

(ma/parse
  &apos;[:schema {:registry {&quot;start&quot; [:and vector? [:catn
                                               [a [:schema any?]]
                                               [b [:catn [c [:schema any?]] [d [:schema any?]]]]]]}}
    &quot;start&quot;],
  &apos;[1 2 3])</pre>
^^ The first (using a schema ref) matches a list inside a vector <code>[1 (2 3)]</code>, whereas the second (embedded) matches a flat vector <code>[1 2 3]</code> -- I&apos;m wondering if there is a way to use a ref to match a flat vector instead of a list.</z><z id="t1666246968" t="ikitommi try to answer both here: • if you you a regex schema inside a regex schema, it get’s inlined, so you can create a “flat” list using those • non-regex schemas just take one slot in the regex schema, so: ◦ [:orn [:s :string] [:bs [:+ :boolean]] is “a string or 1+ booleans” taking 1 slot ◦ [:altn [:s :string] [:bs [:+ :boolean]] is the same but if used inside a regex schema, the :+ get’s inlined ◦ you can’t inline a :ref in the regex schema ◦ wrapping any schema into :schema makes it “normal schema” and thus, it takes just one slot in the regex (`:ref` and regex schemas)"><y>#</y><d>2022-10-20</d><h>06:22</h><w>ikitommi</w>try to answer both here:
• if you you a regex schema inside a regex schema, it get’s inlined, so you can create a “flat” list using those
• non-regex schemas just take one slot in the regex schema, so:
    ◦ <code>[:orn [:s :string] [:bs [:+ :boolean]]</code> is “a string or 1+ booleans” taking 1 slot
    ◦ <code>[:altn [:s :string] [:bs [:+ :boolean]]</code> is the same but if used inside a regex schema, the <code>:+</code> get’s inlined
    ◦ you can’t inline a <code>:ref</code> in the regex schema
    ◦ wrapping any schema into <code>:schema</code> makes it “normal schema” and thus, it takes just one slot in the regex (`:ref` and regex schemas)</z><z id="t1666297849" t="timothypratley I see, thank you 🙂"><y>#</y><d>2022-10-20</d><h>20:30</h><r>timothypratley</r>I see, thank you <b>🙂</b></z><z id="t1666296304" t="skynet when I&apos;m using malli in a terminal like setting, I kind of want the pretty explain output reversed from how it is seen on a webpage: https://github.com/valyagolev/malli/blob/c7c22a8fefd3a8491a35e1e320ab620791c4500c/src/malli/dev/pretty.cljc#L37-L40 since the bottom is closest to what I&apos;m looking at, and the top stuff I might have to scroll up to see. luckily I&apos;m able to call this whole defmethod myself, but maybe it&apos;s common enough that other people would find it useful to have a function in that namespace to set explain to &quot;console&quot; mode?"><y>#</y><d>2022-10-20</d><h>20:05</h><w>skynet</w>when I&apos;m using malli in a terminal like setting, I kind of want the pretty explain output reversed from how it is seen on a webpage: <a href="https://github.com/valyagolev/malli/blob/c7c22a8fefd3a8491a35e1e320ab620791c4500c/src/malli/dev/pretty.cljc#L37-L40" target="_blank">https://github.com/valyagolev/malli/blob/c7c22a8fefd3a8491a35e1e320ab620791c4500c/src/malli/dev/pretty.cljc#L37-L40</a>
since the bottom is closest to what I&apos;m looking at, and the top stuff I might have to scroll up to see. luckily I&apos;m able to call this whole <code>defmethod</code> myself, but maybe it&apos;s common enough that other people would find it useful to have a function in that namespace to set explain to &quot;console&quot; mode?</z><z id="t1666335324" t="ikitommi console-mode sound good. Also, color themes (none/light/dark/custom) + html-emitting mode (for react error boundaries etc). How different would the :console mode be from the normal? All mm-methods should be different? just the one? some amount of config can be done via adding configuration options to the printer (it’s backed by a map), but if it’s totally different (the html-mode could be), then another mm &amp; ns might be better."><y>#</y><d>2022-10-21</d><h>06:55</h><r>ikitommi</r>console-mode sound good. Also, color themes (none/light/dark/custom) + html-emitting mode (for react error boundaries etc). How different would the <code>:console</code> mode be from the normal? All mm-methods should be different? just the one? some amount of config can be done via adding configuration options to the <code>printer</code> (it’s backed by a map), but if it’s totally different (the html-mode could be), then another mm &amp; ns might be better.</z><z id="t1666357956" t="skynet I&apos;m currently just rearranging the blocks (and removing the &quot;more info&quot; block): (defmethod v/-format ::m/explain ... (-block &quot;Schema:&quot; (-block &quot;Value:&quot; (-block &quot;Errors:&quot; only other thing I might change is the amount of whitespace. there&apos;s like 3 blank lines after the error, I might reduce to 1 line. mayyybe remove blank lines after the Schema: , Value: , Errors: section titles and content, but that could make it less readable"><y>#</y><d>2022-10-21</d><h>13:12</h><r>skynet</r>I&apos;m currently just rearranging the blocks (and removing the &quot;more info&quot; block):
<pre>(defmethod v/-format ::m/explain
  ...
    (-block &quot;Schema:&quot;
    (-block &quot;Value:&quot;
    (-block &quot;Errors:&quot;</pre>
only other thing I might change is the amount of whitespace. there&apos;s like 3 blank lines after the error, I might reduce to 1 line. mayyybe remove blank lines after the <code>Schema:</code>, <code>Value:</code>, <code>Errors:</code> section titles and content, but that could make it less readable</z><z id="t1666335324" t="ikitommi console-mode sound good. Also, color themes (none/light/dark/custom) + html-emitting mode (for react error boundaries etc). How different would the :console mode be from the normal? All mm-methods should be different? just the one? some amount of config can be done via adding configuration options to the printer (it’s backed by a map), but if it’s totally different (the html-mode could be), then another mm &amp; ns might be better."><y>#</y><d>2022-10-21</d><h>06:55</h><w>ikitommi</w>console-mode sound good. Also, color themes (none/light/dark/custom) + html-emitting mode (for react error boundaries etc). How different would the <code>:console</code> mode be from the normal? All mm-methods should be different? just the one? some amount of config can be done via adding configuration options to the <code>printer</code> (it’s backed by a map), but if it’s totally different (the html-mode could be), then another mm &amp; ns might be better.</z><z id="t1666354614" t="Thomas Moerman I&apos;m currently implementing a custom schema (for reference types). My question: Is it idiomatic to call (m/validate ?schema ?subject {:registry ?my-local-reg}) [:attrs nil] the body of a content-dependent schema like in: (let [;; self-checking keyword spec is necessary to make `[:my/ref :asset/id] work local-registry (merge ;; self-validating schemas {:asset/id (m/schema [:fn #(= :asset/id %)]) :grommet/id (m/schema [:fn #(= :grommet/id %)])} ;; for ID values {:or (m/-or-schema) :int (m/-int-schema) :string (m/-string-schema) :uuid (m/-uuid-schema) :id [:or :int :string :uuid]}) ;; content-dependent schema Ref (m/-simple-schema (fn [props children] (log/spy :info children) {:type :my/ref :pred (fn [x] (let [attr-schema (first children) [id-attr id-val] (first x)] (and (map? x) (= 1 (count x)) ;; ============== ;; ;; Q: is this ok? ;; ;; ============== ;; (m/validate :id id-val {:registry local-registry}) (m/validate attr-schema id-attr {:registry local-registry})))) ;; Don&apos;t forget the children count constraints! :min 1 :max 1})) custom-reg {:my/ref Ref} registry (mr/composite-registry m/default-registry local-registry custom-reg)] [(m/validate [:my/ref :asset/id] {:asset/id 123} {:registry registry}) (m/validate [:my/ref :asset/id] {:grommet/id 123} {:registry registry}) (m/validate [:my/ref [:or :asset/id :grommet/id]] {:asset/id 123} {:registry registry}) (m/validate [:my/ref [:or :asset/id :grommet/id]] {:other/id 123} {:registry registry}) ]) Is there perhaps another approach preferable? Thanks 🙏"><y>#</y><d>2022-10-21</d><h>12:16</h><w>Thomas Moerman</w>I&apos;m currently implementing a custom schema (for reference types).

My question: Is it idiomatic to call <code>(m/validate ?schema ?subject {:registry ?my-local-reg})</code> <b>within</b> the body of a content-dependent schema like in:
<pre>(let [;; self-checking keyword spec is necessary to make `[:my/ref :asset/id] work
      local-registry
                 (merge
                   ;; self-validating schemas
                   {:asset/id   (m/schema [:fn #(= :asset/id %)])
                    :grommet/id (m/schema [:fn #(= :grommet/id %)])}
                   
                   ;; for ID values
                   {:or     (m/-or-schema)
                    :int    (m/-int-schema)
                    :string (m/-string-schema)
                    :uuid   (m/-uuid-schema)
                    :id     [:or :int :string :uuid]})
      
      ;; content-dependent schema
      Ref        (m/-simple-schema (fn [props children]
                                     (log/spy :info children)
                                     {:type :my/ref
                                      :pred (fn [x]
                                              (let [attr-schema (first children)
                                                    [id-attr id-val] (first x)]
                                                (and (map? x)
                                                     (= 1 (count x))
                                                     ;; ============== ;;
                                                     ;; Q: is this ok? ;;
                                                     ;; ============== ;;
                                                     (m/validate :id id-val {:registry local-registry})
                                                     (m/validate attr-schema id-attr {:registry local-registry}))))
                                      ;; Don&apos;t forget the children count constraints!
                                      :min  1
                                      :max  1}))

      custom-reg {:my/ref Ref}

      registry   (mr/composite-registry
                   m/default-registry
                   local-registry
                   custom-reg)]

  [(m/validate [:my/ref :asset/id] {:asset/id 123} {:registry registry})
   (m/validate [:my/ref :asset/id] {:grommet/id 123} {:registry registry})
   (m/validate [:my/ref [:or :asset/id :grommet/id]] {:asset/id 123} {:registry registry})
   (m/validate [:my/ref [:or :asset/id :grommet/id]] {:other/id 123} {:registry registry})
   ])</pre>
Is there perhaps another approach preferable?

Thanks <b>🙏</b></z><z id="t1666356159" t="Thomas Moerman I guess a better version would look somethat like -maybe-schema instead of using simple-schema"><y>#</y><d>2022-10-21</d><h>12:42</h><r>Thomas Moerman</r>I guess a better version would look somethat like <code>-maybe-schema</code> instead of using <code>simple-schema</code></z><z id="t1666424818" t="ikitommi Have stumbled few times on writing custom reference schemas, not trivial. No best practices, but we have been adding new configuration options to schemas, (e.g. just added :pred to m/-map-schema ), so if there is an existing schema type which is almost what you need and would be exactly what you need with adding an configuration option - I’m open to hearing &amp; maybe adding that."><y>#</y><d>2022-10-22</d><h>07:46</h><r>ikitommi</r>Have stumbled few times on writing custom reference schemas, not trivial. No best practices, but we have been adding new configuration options to schemas, (e.g. just added <code>:pred</code> to <code>m/-map-schema</code>), so if there is an existing schema type which is almost what you need and would be exactly what you need with adding an configuration option - I’m open to hearing &amp; maybe adding that.</z><z id="t1666424823" t="ikitommi but, prefer using a cached m/validator instead of m/validate if possible, it’s much faster."><y>#</y><d>2022-10-22</d><h>07:47</h><r>ikitommi</r>but, prefer using a cached <code>m/validator</code> instead of <code>m/validate</code> if possible, it’s much faster.</z><z id="t1666449385" t="Thomas Moerman Yeah you&apos;re right, it&apos;s not trivial. I&apos;m trying to get my head around the essence of what makes it so difficult, there is some kind of circularity in the problem, it seems."><y>#</y><d>2022-10-22</d><h>14:36</h><r>Thomas Moerman</r>Yeah you&apos;re right, it&apos;s not trivial. I&apos;m trying to get my head around the essence of what makes it so difficult, there is some kind of circularity in the problem, it seems.</z><z id="t1666424567" t="ikitommi Should m/-instument instrument also nested function definitions by default? https://github.com/metosin/malli/issues/770"><y>#</y><d>2022-10-22</d><h>07:42</h><w>ikitommi</w>Should <code>m/-instument</code> instrument also nested function definitions by default? <a href="https://github.com/metosin/malli/issues/770" target="_blank">https://github.com/metosin/malli/issues/770</a></z><z id="t1666572796" t="aaron51 Does Malli have a way to wrap input in a vector, if it’s not already a vector? I know this is a one-liner in Clojure but it’s nice to keep all the coercion together. (if (vec? x) x [x])"><y>#</y><d>2022-10-24</d><h>00:53</h><w>aaron51</w>Does Malli have a way to wrap input in a vector, if it’s not already a vector? I know this is a one-liner in Clojure but it’s nice to keep all the coercion together. 

(if (vec? x) x [x])</z><z id="t1666587031" t="ikitommi don’t think so. what is your use case for this? input coercion?"><y>#</y><d>2022-10-24</d><h>04:50</h><r>ikitommi</r>don’t think so. what is your use case for this? input coercion?</z><z id="t1666587117" t="ikitommi there is mt/collection-transformer https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L416-L423 , but doing just just any-seq-like-&gt;target-type, not wrapping non-seqs into collections."><y>#</y><d>2022-10-24</d><h>04:51</h><r>ikitommi</r>there is <code>mt/collection-transformer</code> <a href="https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L416-L423" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/transform.cljc#L416-L423</a>, but doing just just any-seq-like-&gt;target-type, not wrapping non-seqs into collections.</z><z id="t1666608022" t="aaron51 Use case is a reitit handler that accepts one or more than one multipart files. When the request has one file, the param is a map. When multiple files, the param is a vector. Would be a bit easier to handle if it was always a vector."><y>#</y><d>2022-10-24</d><h>10:40</h><r>aaron51</r>Use case is a reitit handler that accepts one or more than one multipart files. When the request has one file, the param is a map. When multiple files, the param is a vector. Would be a bit easier to handle if it was always a vector.</z><z id="t1666610450" t="ikitommi I see, you can create a custom transformer for this. like the mt/collection-transformer but with custom functions. You can map any transformer into reitit coercion. not fun, but doable."><y>#</y><d>2022-10-24</d><h>11:20</h><r>ikitommi</r>I see, you can create a custom transformer for this. like the <code>mt/collection-transformer</code> but with custom functions. You can map any transformer into reitit coercion. not fun, but doable.</z><z id="t1666794918" t="bortexz Is this a bug, or am I doing something wrong? (defonce registry* (atom (m/default-schemas))) (mr/set-default-registry! (mr/mutable-registry registry*)) (defn sdef &quot;Defines a new schema in mutable [[registry*]].&quot; ([type schema] (swap! registry* assoc type schema) schema) ([type props schema] (swap! registry* assoc type [:schema props schema]) schema)) (sdef ::thing-nested2 int?) (sdef ::thing-nested (mu/optional-keys [:map ::thing-nested2])) (sdef ::thing (mu/optional-keys [:map ::thing-nested])) (mu/update ::thing ::thing-nested (fn [s] (mu/required-keys s [::thing-nested2]))) Blows up with: ; Evaluating file: malli.clj ; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). ; :malli.core/invalid-schema {:schema nil} ; Evaluation of file malli.clj failed: class clojure.lang.Compiler$CompilerException"><y>#</y><d>2022-10-26</d><h>14:35</h><w>bortexz</w>Is this a bug, or am I doing something wrong?
<pre>(defonce registry* (atom (m/default-schemas)))

(mr/set-default-registry! (mr/mutable-registry registry*))

(defn sdef
  &quot;Defines a new schema in mutable [[registry*]].&quot;
  ([type schema] (swap! registry* assoc type schema) schema)
  ([type props schema] (swap! registry* assoc type [:schema props schema]) schema))

(sdef ::thing-nested2 int?)
(sdef ::thing-nested (mu/optional-keys [:map ::thing-nested2]))
(sdef ::thing (mu/optional-keys [:map ::thing-nested]))

(mu/update ::thing ::thing-nested (fn [s] (mu/required-keys s [::thing-nested2])))</pre>
Blows up with:
<pre>; Evaluating file: malli.clj
; Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
; :malli.core/invalid-schema {:schema nil}
; Evaluation of file malli.clj failed: class clojure.lang.Compiler$CompilerException</pre></z><z id="t1666802089" t="bortexz If reading the schema from the registry directly, it seems to work: (mu/update (get @registry* ::thing) ::thing-nested (fn [s] (mu/required-keys s [::thing-nested2]))) "><y>#</y><d>2022-10-26</d><h>16:34</h><r>bortexz</r>If reading the schema from the registry directly, it seems to work:
<pre>(mu/update (get @registry* ::thing) ::thing-nested (fn [s] (mu/required-keys s [::thing-nested2])))</pre>
</z><z id="t1666804258" t="ikitommi hmm. that’s not good."><y>#</y><d>2022-10-26</d><h>17:10</h><r>ikitommi</r>hmm. that’s not good.</z><z id="t1666805365" t="ikitommi The malli.util helpers do not deref the schemas =&gt; calling mu/get on a reference tries to get from the reference, not from the value behind it."><y>#</y><d>2022-10-26</d><h>17:29</h><r>ikitommi</r>The <code>malli.util</code> helpers do not deref the schemas =&gt; calling <code>mu/get</code> on a reference tries to get from the reference, not from the value behind it.</z><z id="t1666805419" t="ikitommi calling m/deref-all on the subject should work, but just for one level. This is unfortunate."><y>#</y><d>2022-10-26</d><h>17:30</h><r>ikitommi</r>calling <code>m/deref-all</code> on the subject should work, but just for one level. This is unfortunate.</z><z id="t1666805504" t="ikitommi checked if that’s easy to change in malli, doesn’t seem to: https://github.com/metosin/malli/pull/772/files - all tests fail 😞"><y>#</y><d>2022-10-26</d><h>17:31</h><r>ikitommi</r>checked if that’s easy to change in malli, doesn’t seem to: <a href="https://github.com/metosin/malli/pull/772/files" target="_blank">https://github.com/metosin/malli/pull/772/files</a> - all tests fail <b>😞</b></z><z id="t1666805615" t="ikitommi here’s the list of all paths that are part of the schema: (mu/subschemas ::thing) ;[{:path [], ; :in [], ; :schema :malli.core-test/thing} ; {:path [0] ; :in [] ; :schema [:map [:malli.core-test/thing-nested {:optional true} :malli.core-test/thing-nested]]} ; {:path [0 :malli.core-test/thing-nested] ; :in [:malli.core-test/thing-nested] ; :schema :malli.core-test/thing-nested} ; {:path [0 :malli.core-test/thing-nested 0], ; :in [:malli.core-test/thing-nested], ; :schema [:map [:malli.core-test/thing-nested2 {:optional true} :malli.core-test/thing-nested2]]} ; {:path [0 :malli.core-test/thing-nested 0 :malli.core-test/thing-nested2], ; :in [:malli.core-test/thing-nested :malli.core-test/thing-nested2], ; :schema :malli.core-test/thing-nested2} ; {:path [0 :malli.core-test/thing-nested 0 :malli.core-test/thing-nested2 0], ; :in [:malli.core-test/thing-nested :malli.core-test/thing-nested2], ; :schema int?}]"><y>#</y><d>2022-10-26</d><h>17:33</h><r>ikitommi</r>here’s the list of all paths that are part of the schema:
<pre>(mu/subschemas ::thing)
;[{:path [], 
;  :in [], 
;  :schema :malli.core-test/thing}
; {:path [0]
;  :in []
;  :schema [:map [:malli.core-test/thing-nested {:optional true} :malli.core-test/thing-nested]]}
; {:path [0 :malli.core-test/thing-nested]
;  :in [:malli.core-test/thing-nested]
;  :schema :malli.core-test/thing-nested}
; {:path [0 :malli.core-test/thing-nested 0],
;  :in [:malli.core-test/thing-nested],
;  :schema [:map [:malli.core-test/thing-nested2 {:optional true} :malli.core-test/thing-nested2]]}
; {:path [0 :malli.core-test/thing-nested 0 :malli.core-test/thing-nested2],
;  :in [:malli.core-test/thing-nested :malli.core-test/thing-nested2],
;  :schema :malli.core-test/thing-nested2}
; {:path [0 :malli.core-test/thing-nested 0 :malli.core-test/thing-nested2 0],
;  :in [:malli.core-test/thing-nested :malli.core-test/thing-nested2],
;  :schema int?}]</pre></z><z id="t1666805649" t="ikitommi e.g. each reference schema contributes to the path with 0 ."><y>#</y><d>2022-10-26</d><h>17:34</h><r>ikitommi</r>e.g. each reference schema contributes to the path with <code>0</code>.</z><z id="t1666805759" t="ikitommi so, this would work too: (mu/update-in ::thing [0 ::thing-nested] (fn [s] (mu/required-keys s [::thing-nested2])))"><y>#</y><d>2022-10-26</d><h>17:35</h><r>ikitommi</r>so, this would work too:
<pre>(mu/update-in ::thing [0 ::thing-nested] (fn [s] (mu/required-keys s [::thing-nested2])))</pre></z><z id="t1666805767" t="ikitommi please write an issue, will think about this."><y>#</y><d>2022-10-26</d><h>17:36</h><r>ikitommi</r>please write an issue, will think about this.</z><z id="t1666856616" t="bortexz Done ( https://github.com/metosin/malli/issues/773 ) thanks for looking into this [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] 🙏"><y>#</y><d>2022-10-27</d><h>07:43</h><r>bortexz</r>Done (<a href="https://github.com/metosin/malli/issues/773" target="_blank">https://github.com/metosin/malli/issues/773</a>) thanks for looking into this <a>@U055NJ5CC</a> <b>🙏</b></z><z id="t1666891640" t="souenzzo does malli has something like spec&apos;s conform operation? my use case is: my schema has an or :a string? :b int? :ab [:or :a :b] And I a function that given the :ab schema + a value, it tells me if the value is :a , :b or :invalid"><y>#</y><d>2022-10-27</d><h>17:27</h><w>souenzzo</w>does malli has something like spec&apos;s <code>conform</code> operation?
my use case is:
my schema has an or
<pre>:a string?
:b int?
:ab [:or :a :b]</pre>
And I a function that given the <code>:ab</code> schema + a value, it tells me if the value is <code>:a</code>, <code>:b</code> or <code>:invalid</code></z><z id="t1666892126" t="ikitommi try m/parse &amp; m/unparse . If you want named nodes, you can: [:orn [:s :string] [:b :boolean]]"><y>#</y><d>2022-10-27</d><h>17:35</h><r>ikitommi</r>try <code>m/parse</code> &amp; <code>m/unparse</code>. If you want named nodes, you can: <code>[:orn [:s :string] [:b :boolean]]</code></z><z id="t1666892243" t="ikitommi same with regexs, adding a n to the name, you can present the nodes in entry-style and get named results, e.g. :cat -&gt; :catn , :alt -&gt; :altn"><y>#</y><d>2022-10-27</d><h>17:37</h><r>ikitommi</r>same with regexs, adding a <code>n</code> to the name, you can present the nodes in entry-style and get named results, e.g. <code>:cat</code> -&gt; <code>:catn</code>, <code>:alt</code> -&gt; <code>:altn</code></z><z id="t1666892844" t="souenzzo nice! TY"><y>#</y><d>2022-10-27</d><h>17:47</h><r>souenzzo</r>nice! TY</z><z id="t1666907282" t="mauricio.szabo Folks, can I ask for a huge improvement on Malli? Show the errors on instrument, on .pretty/explain , etc, at the end of everything"><y>#</y><d>2022-10-27</d><h>21:48</h><w>mauricio.szabo</w>Folks, can I ask for a huge improvement on Malli? Show the errors on instrument, on <code>.pretty/explain</code>, etc, at the end of everything</z><z id="t1666907326" t="mauricio.szabo Sometimes when I get an error, I can&apos;t find it anywhere - either it is greater than my terminal buffer or it gets lost in the middle of a &quot;your state is this&quot; and &quot;your schema is this&quot;"><y>#</y><d>2022-10-27</d><h>21:48</h><w>mauricio.szabo</w>Sometimes when I get an error, I can&apos;t find it anywhere - either it is greater than my terminal buffer or it gets lost in the middle of a &quot;your state is this&quot; and &quot;your schema is this&quot;</z><z id="t1666907830" t="mauricio.szabo It&apos;s not just inconvenient - on React-Native, for example, sometimes the console is not redirected to the REPL (because metro and other issues) so I keep having to disable and re-enable instrumentation 😢"><y>#</y><d>2022-10-27</d><h>21:57</h><w>mauricio.szabo</w>It&apos;s not just inconvenient - on React-Native, for example, sometimes the console is not redirected to the REPL (because metro and other issues) so I keep having to disable and re-enable instrumentation <b>😢</b></z><z id="t1666967198" t="dvingo the reporter option can be passed in to instrument and to start, so pretty quick work to copy the pretty namespace to your project and mess around how you like"><y>#</y><d>2022-10-28</d><h>14:26</h><r>dvingo</r>the reporter option can be passed in to instrument and to start, so pretty quick work to copy the pretty namespace to your project and mess around how you like</z><z id="t1666970820" t="mauricio.szabo I... actually have no idea what you mean 😄"><y>#</y><d>2022-10-28</d><h>15:27</h><r>mauricio.szabo</r>I... actually have no idea what you mean <b>😄</b></z><z id="t1666970826" t="mauricio.szabo Do you have an example?"><y>#</y><d>2022-10-28</d><h>15:27</h><r>mauricio.szabo</r>Do you have an example?</z><z id="t1666981437" t="dvingo (malli.dev/start! {:report (fn [type data] (.error js/console &quot;Instrument error: &quot; (str type)))})"><y>#</y><d>2022-10-28</d><h>18:23</h><r>dvingo</r><pre>(malli.dev/start! {:report (fn [type data] (.error js/console &quot;Instrument error: &quot; (str type)))})</pre></z><z id="t1666981526" t="mauricio.szabo Thanks, I&apos;ll try 🙂"><y>#</y><d>2022-10-28</d><h>18:25</h><r>mauricio.szabo</r>Thanks, I&apos;ll try <b>🙂</b></z><z id="t1666981637" t="dvingo sure thing 🙂 https://github.com/metosin/malli/blob/537c5fb8f96c35fc9e0d41629faa88a1aa8b56c3/src/malli/dev/pretty.cljc#L82 I meant you can copy this namespace and change it up as you like"><y>#</y><d>2022-10-28</d><h>18:27</h><r>dvingo</r>sure thing <b>🙂</b> <a href="https://github.com/metosin/malli/blob/537c5fb8f96c35fc9e0d41629faa88a1aa8b56c3/src/malli/dev/pretty.cljc#L82" target="_blank">https://github.com/metosin/malli/blob/537c5fb8f96c35fc9e0d41629faa88a1aa8b56c3/src/malli/dev/pretty.cljc#L82</a> I meant you can copy this namespace and change it up as you like</z><z id="t1666911752" t="mauricio.szabo Ok, for .pretty/explain there is a work-around - I can capture the :errors property and pretty-print them"><y>#</y><d>2022-10-27</d><h>23:02</h><w>mauricio.szabo</w>Ok, for <code>.pretty/explain</code> there is a work-around - I can capture the <code>:errors</code> property and pretty-print them</z><z id="t1666951046" t="ikitommi Anyone interested in doing / sharing a Schema for def syntax? like the https://github.com/metosin/malli/blob/master/src/malli/destructure.cljc#L11-L55 here."><y>#</y><d>2022-10-28</d><h>09:57</h><w>ikitommi</w>Anyone interested in doing / sharing a Schema for <code>def</code> syntax? like the <a href="https://github.com/metosin/malli/blob/master/src/malli/destructure.cljc#L11-L55" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/destructure.cljc#L11-L55</a> here.</z><z id="t1666951249" t="ikitommi actually… this: https://github.com/metosin/malli/blob/master/src/malli/experimental.cljc#L8-L33"><y>#</y><d>2022-10-28</d><h>10:00</h><r>ikitommi</r>actually… this: <a href="https://github.com/metosin/malli/blob/master/src/malli/experimental.cljc#L8-L33" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/experimental.cljc#L8-L33</a></z><z id="t1666951315" t="ikitommi nevermind, already working on it 🙂"><y>#</y><d>2022-10-28</d><h>10:01</h><r>ikitommi</r>nevermind, already working on it <b>🙂</b></z><z id="t1666967087" t="dvingo if you&apos;re touching that code, i think there is an edge case for cljs (maybe clj too) if you have a custom registry - the schemas used for parsing the experimental defn form may not be available - https://github.com/metosin/malli/pull/702/files#diff-8fa8701bc52f9f699e5512b8ea028a44c05033b134751af5f789cd57edcf05ad had to add that line to get it working."><y>#</y><d>2022-10-28</d><h>14:24</h><r>dvingo</r>if you&apos;re touching that code, i think there is an edge case for cljs (maybe clj too) if you have a custom registry - the schemas used for parsing the experimental defn form may not be available -
<a href="https://github.com/metosin/malli/pull/702/files#diff-8fa8701bc52f9f699e5512b8ea028a44c05033b134751af5f789cd57edcf05ad" target="_blank">https://github.com/metosin/malli/pull/702/files#diff-8fa8701bc52f9f699e5512b8ea028a44c05033b134751af5f789cd57edcf05ad</a>
had to add that line to get it working.</z><z id="t1666970137" t="sashton Are closed-schema and multi incompatible? I am calling closed-schema on a schema which includes a multi nested in it. It fails to validate correctly, but if I remove the closed-schema , it works as expected. Example: (def operator-schema (malli/schema [:multi {:dispatch :op} [:addition [:map [:summand-1 :int] [:summand-2 :int]]] [:multiplication [:map [:factor-1 :int] [:factor-2 :int]]]])) (def equation-schema (mallu/closed-schema [:map [:left-hand-side operator-schema] [:right-hand-side :int]])) (malle/humanize (malli/explain equation-schema {:left-hand-side {:op :addition :summand-1 1 :summand-2 2} :right-hand-side 3})) =&gt; {:left-hand-side {:op [&quot;disallowed key&quot;]}} "><y>#</y><d>2022-10-28</d><h>15:15</h><w>sashton</w>Are <code>closed-schema</code> and <code>multi</code> incompatible? I am calling <code>closed-schema</code> on a schema which includes a <code>multi</code> nested in it. It fails to validate correctly, but if I remove the <code>closed-schema</code> , it works as expected.
Example:
<pre>(def operator-schema 
  (malli/schema
   [:multi {:dispatch :op}
    [:addition [:map
                [:summand-1 :int]
                [:summand-2 :int]]]
    [:multiplication [:map
                      [:factor-1 :int]
                      [:factor-2 :int]]]]))

(def equation-schema
  (mallu/closed-schema
   [:map
    [:left-hand-side operator-schema]
    [:right-hand-side :int]]))

(malle/humanize (malli/explain equation-schema {:left-hand-side {:op :addition
                                                                 :summand-1 1
                                                                 :summand-2 2}
                                                :right-hand-side 3}))

=&gt; {:left-hand-side {:op [&quot;disallowed key&quot;]}}</pre>
</z><z id="t1666972584" t="sashton Never mind, user error: I forgot to include the [:op :keyword] declaration in each of the submaps in operator-schema"><y>#</y><d>2022-10-28</d><h>15:56</h><r>sashton</r>Never mind, user error: I forgot to include the <code>[:op :keyword]</code> declaration in each of the submaps in <code>operator-schema</code></z><z id="t1667209784" t="dumrat (me/humanize (m/explain [:and [:fn (fn [{:keys [tag]}] (= :Portfolio tag))] ...] {:tag :some-other-tag ...})) =&gt; [&quot;unknown error&quot;] I understand that the &quot;unknown error&quot; is the result because malli doesn&apos;t know what to say when my custom function returns false. Can I customize this error message here?"><y>#</y><d>2022-10-31</d><h>09:49</h><w>dumrat</w><pre>(me/humanize
  (m/explain
    [:and
      [:fn (fn [{:keys [tag]}] (= :Portfolio tag))]
      ...]
    {:tag :some-other-tag ...}))
=&gt;
[&quot;unknown error&quot;]</pre>
I understand that the <code>&quot;unknown error&quot;</code> is the result because malli doesn&apos;t know what to say when my custom function returns false. Can I customize this error message here?</z><z id="t1667209850" t="dumrat I know I can use :enum here to do the same validation. Just want to know how to handle custom fns."><y>#</y><d>2022-10-31</d><h>09:50</h><r>dumrat</r>I know I can use <code>:enum</code> here to do the same validation. Just want to know how to handle custom fns.</z><z id="t1667209959" t="ikitommi (me/humanize (m/explain [:and [:fn {:error/message &quot;horror&quot;} (fn [{:keys [tag]}] (= :Portfolio tag))]] {:tag :some-other-tag})) ; =&gt; [&quot;horror&quot;]"><y>#</y><d>2022-10-31</d><h>09:52</h><r>ikitommi</r><pre>(me/humanize
 (m/explain
  [:and
   [:fn {:error/message &quot;horror&quot;}
    (fn [{:keys [tag]}] (= :Portfolio tag))]]
  {:tag :some-other-tag}))
; =&gt; [&quot;horror&quot;]</pre></z><z id="t1667210017" t="dumrat great thanks"><y>#</y><d>2022-10-31</d><h>09:53</h><r>dumrat</r>great thanks</z><z id="t1667210024" t="ikitommi you’re welcome"><y>#</y><d>2022-10-31</d><h>09:53</h><r>ikitommi</r>you’re welcome</z><z id="t1667229177" t="dumrat Data: [{:key1 1 :val 4} {:key2 2 :val 5} {:key3 3 :val 6}] I&apos;d like to write a schema which requires all three keys key1, key2, key3 to be present in the sub maps of the input vector. How to do this?"><y>#</y><d>2022-10-31</d><h>15:12</h><w>dumrat</w>Data:
<pre>[{:key1 1 :val 4} {:key2 2 :val 5} {:key3 3 :val 6}]</pre>
I&apos;d like to write a schema which requires all three keys <code>key1, key2, key3</code> to be present in the sub maps of the input vector. How to do this?</z><z id="t1667271073" t="dumrat Is there a schema for malli schemas? 😄"><y>#</y><d>2022-11-01</d><h>02:51</h><w>dumrat</w>Is there a schema for malli schemas? <b>😄</b></z><z id="t1667280574" t="ikitommi there is support for building that 🙂 e.g. in IntoSchema protocol, there are: (-properties-schema [this options] &quot;maybe returns :map schema describing schema properties&quot;) (-children-schema [this options] &quot;maybe returns sequence schema describing schema children&quot;) … just have had no time to add the implementations to those. Validation of a form can be done with m/schema , throws if not a valid thing."><y>#</y><d>2022-11-01</d><h>05:29</h><r>ikitommi</r>there is support for building that <b>🙂</b> e.g. in <code>IntoSchema</code> protocol, there are:
<pre>(-properties-schema [this options] &quot;maybe returns :map schema describing schema properties&quot;)
  (-children-schema [this options] &quot;maybe returns sequence schema describing schema children&quot;)</pre>
… just have had no time to add the implementations to those. Validation of a form can be done with <code>m/schema</code>, throws if not a valid thing.</z><z id="t1667319067" t="dumrat Any reason why malli validation would not honor {:optional true} ? i.e. [:map [:details [:map [:email {:optional true} :string]]]] Proceeds to ignore the optional status when validating and fails validation."><y>#</y><d>2022-11-01</d><h>16:11</h><w>dumrat</w>Any reason why malli validation would not honor <code>{:optional true}</code> ?

i.e.

<pre>[:map
 [:details
  [:map
   [:email {:optional true} :string]]]]</pre>
Proceeds to ignore the optional status when validating and fails validation.</z><z id="t1667320313" t="timothypratley (ma/validate [:map [:details [:map [:email {:optional true} :string]]]] {:details {}}) =&gt; true"><y>#</y><d>2022-11-01</d><h>16:31</h><r>timothypratley</r><pre>(ma/validate [:map
              [:details
               [:map
                [:email {:optional true} :string]]]]
             {:details {}})</pre>
=&gt; <code>true</code></z><z id="t1667320320" t="timothypratley seems fine?"><y>#</y><d>2022-11-01</d><h>16:32</h><r>timothypratley</r>seems fine?</z><z id="t1667378742" t="dumrat My bad. I needed to use ‘maybe’ here."><y>#</y><d>2022-11-02</d><h>08:45</h><r>dumrat</r>My bad. I needed to use ‘maybe’ here.</z><z id="t1667378869" t="dumrat Is there a way to use a schema which has few maybe schemas but consider maybe not be there for validation? Or do I have to strip the maybes from schema and do validation manually? On mobile, I can give code sample later if needed."><y>#</y><d>2022-11-02</d><h>08:47</h><w>dumrat</w>Is there a way to use a schema which has few maybe schemas but consider maybe not be there for validation? Or do I have to strip the maybes from schema and do validation manually? On mobile, I can give code sample later if needed.</z><z id="t1667379997" t="ikitommi please share an example"><y>#</y><d>2022-11-02</d><h>09:06</h><r>ikitommi</r>please share an example</z><z id="t1667446949" t="dumrat ok case is like this. 1. I&apos;ve got a few endpoints (around 20) returning large sets of xml. These are quite old services that we don&apos;t have control over. 2. I parse xml, then do some transformations on them 3. I have malli schemas for the transformed data. I coerce the data using schemas. Then I validate using same schemas. 4. Data from the services are often incomplete (nil values where they shouldn&apos;t be mostly). So I add [:maybe ...] for some fields to sort of make the validations work. 5. Now, I&apos;d like to still know the cases where validations fail without the [:maybe ...] wrappings so I can have a report of missing stuff. Is it possible to do this or do I have to transform schema myself and remove the [:maybe ...] wrappings? sample: (def counterparties-schema [:vector [:map [:address [:maybe :string]] [:baseNumber :int] [:contactName [:maybe :string]] [:contactPhone [:maybe :string]] [:cptyType [:maybe :string]] [:enabledForSettlement :boolean] [:id :int] [:legalVehicleId :int] [:mnemonic :string] [:name [:maybe :string]]]]) ;; Validation with this succeeds (m/validate counterparties-schema data) =&gt; true ;; But I&apos;d still like to know fields where validation would have failed if [:maybe ...] wrappings weren&apos;t there. ;; i.e [:address :string] etc. ;; Manually something like this: (defn strict [schema] (clojure.walk/postwalk (fn [v] (if (and (vector? v) (= (first v) :maybe)) (second v) v)) schema)) ;; So I can still know the missing values (m/validate (strict counterparties-schema) data) What I was asking first is that is this kind of thing supported by malli itself? Perhaps that&apos;s a dumb question. Is this a common use case though? Or am I thinking about this wrong?"><y>#</y><d>2022-11-03</d><h>03:42</h><r>dumrat</r>ok case is like this.

1. I&apos;ve got a few endpoints (around 20) returning large sets of xml. These are quite old services that we don&apos;t have control over.
2. I parse xml, then do some transformations on them
3. I have malli schemas for the transformed data. I coerce the data using schemas. Then I validate using same schemas.
4. Data from the services are often incomplete (nil values where they shouldn&apos;t be mostly). So I add <code>[:maybe ...]</code> for some fields to sort of make the validations work.
5. Now, I&apos;d like to still know the cases where validations fail without the <code>[:maybe ...]</code> wrappings so I can have a report of missing stuff. Is it possible to do this or do I have to transform schema myself and remove the <code>[:maybe ...]</code> wrappings?
sample:

<pre>(def counterparties-schema
  [:vector
   [:map
    [:address [:maybe :string]]
    [:baseNumber :int]
    [:contactName [:maybe :string]]
    [:contactPhone [:maybe :string]]
    [:cptyType [:maybe :string]]
    [:enabledForSettlement :boolean]
    [:id :int]
    [:legalVehicleId :int]
    [:mnemonic :string]
    [:name [:maybe :string]]]])

;; Validation with this succeeds
(m/validate counterparties-schema data)
=&gt; true

;; But I&apos;d still like to know fields where validation would have failed if [:maybe ...] wrappings weren&apos;t there.
;; i.e [:address :string] etc.

;; Manually something like this:
(defn strict [schema]
  (clojure.walk/postwalk 
   (fn [v] 
     (if (and (vector? v) (= (first v) :maybe))
       (second v) v)) 
   schema))

;; So I can still know the missing values
(m/validate (strict counterparties-schema) data)</pre>
What I was asking first is that is this kind of thing supported by malli itself? Perhaps that&apos;s a dumb question.

Is this a common use case though? Or am I thinking about this wrong?</z><z id="t1667380030" t="ingesol CLJS instrumentation reloading discussion in #clojurescript https://clojurians.slack.com/archives/C03S1L9DN/p1667377689417939?thread_ts=1667373586.775569&amp;amp;cid=C03S1L9DN"><y>#</y><d>2022-11-02</d><h>09:07</h><w>ingesol</w>CLJS instrumentation reloading discussion in #clojurescript <a href="https://clojurians.slack.com/archives/C03S1L9DN/p1667377689417939?thread_ts=1667373586.775569&amp;amp;cid=C03S1L9DN" target="_blank">https://clojurians.slack.com/archives/C03S1L9DN/p1667377689417939?thread_ts=1667373586.775569&amp;amp;cid=C03S1L9DN</a></z><z id="t1667410755" t="mauricio.szabo A question about decompleted map keys and values: if I register, for example, that :user/id is always an [:string {:min 1}] , is there a way to query Malli for :user/id and know the result is [:string {:min 1}] ? Or even if it&apos;s just a :string ?"><y>#</y><d>2022-11-02</d><h>17:39</h><w>mauricio.szabo</w>A question about decompleted map keys and values: if I register, for example, that <code>:user/id</code> is always an <code>[:string {:min 1}]</code>, is there a way to query Malli for <code>:user/id</code> and know the result is <code>[:string {:min 1}]</code>? Or even if it&apos;s just a <code>:string</code>?</z><z id="t1667413199" t="ikitommi (m/schema :user/id) returns the ref, you can deref that with m/deref (or m/deref-all )"><y>#</y><d>2022-11-02</d><h>18:19</h><r>ikitommi</r><code>(m/schema :user/id)</code> returns the ref, you can deref that with <code>m/deref</code> (or <code>m/deref-all</code>)</z><z id="t1667423517" t="mauricio.szabo Thanks, I had to do one step further to be useful: (m/ast (m/deref-all (m/schema :user/id))) That helped 🙂"><y>#</y><d>2022-11-02</d><h>21:11</h><r>mauricio.szabo</r>Thanks, I had to do one step further to be useful:

<pre>(m/ast (m/deref-all (m/schema :user/id)))</pre>
That helped <b>🙂</b></z><z id="t1667463479" t="jeroenvandijk Did someone already use rewrite-cljc to point out malli validation errors inline? I believe it is possible and I’m thinking of doing this"><y>#</y><d>2022-11-03</d><h>08:17</h><w>jeroenvandijk</w>Did someone already use <code>rewrite-cljc</code> to point out <code>malli</code> validation errors inline? I believe it is possible and I’m thinking of doing this</z><z id="t1667466887" t="jeroenvandijk All little bit how expound underlines invalid values with ^^^ (see https://github.com/bhb/expound#expound-1 ), so a little different than .pretty/explain i think. More like the output of babashka with for instance: echo &apos;(/ 100 0)&apos; &gt; foo.clj; bb foo.clj .... ----- Context ------------------------------------------------------------------ 1: (/ 100 0) ^--- Divide by zero"><y>#</y><d>2022-11-03</d><h>09:14</h><r>jeroenvandijk</r>All little bit how expound underlines invalid values with <code>^^^</code> (see <a href="https://github.com/bhb/expound#expound-1" target="_blank">https://github.com/bhb/expound#expound-1</a>), so a little different than <code>.pretty/explain</code> i think. More like the output of babashka with for instance:
<pre>echo &apos;(/ 100 0)&apos; &gt; foo.clj; bb foo.clj 

....
----- Context ------------------------------------------------------------------
1: (/ 100 0)
   ^--- Divide by zero</pre></z><z id="t1667468409" t="ikitommi I would also like to see those. Also, paiting the errors with pretty, like expound does it."><y>#</y><d>2022-11-03</d><h>09:40</h><r>ikitommi</r>I would also like to see those. Also, paiting the errors with pretty, like expound does it.</z><z id="t1667468495" t="ikitommi drafted mx/def on the way to ClojureDays, which could have a clj-kondo hook to highlight the errors in the editor: https://twitter.com/ikitommi/status/1585995979748409345 . ping [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}]"><y>#</y><d>2022-11-03</d><h>09:41</h><r>ikitommi</r>drafted <code>mx/def</code> on the way to ClojureDays, which could have a clj-kondo hook to highlight the errors in the editor: <a href="https://twitter.com/ikitommi/status/1585995979748409345" target="_blank">https://twitter.com/ikitommi/status/1585995979748409345</a>. ping <a>@borkdude</a></z><z id="t1667468541" t="borkdude rewrite-cljc is now rewrite-clj maintained under org.clj-commons"><y>#</y><d>2022-11-03</d><h>09:42</h><r>borkdude</r>rewrite-cljc is now rewrite-clj maintained under org.clj-commons</z><z id="t1667468571" t="jeroenvandijk ah yeah made a mistake rewrite-clj indeed"><y>#</y><d>2022-11-03</d><h>09:42</h><r>jeroenvandijk</r>ah yeah made a mistake <code>rewrite-clj</code>  indeed</z><z id="t1667468592" t="jeroenvandijk However just found that I can probably do what I want with edamame as well"><y>#</y><d>2022-11-03</d><h>09:43</h><r>jeroenvandijk</r>However just found that I can probably do what I want with edamame as well</z><z id="t1667468615" t="jeroenvandijk Needed this https://github.com/borkdude/edamame#postprocess for detailed location info"><y>#</y><d>2022-11-03</d><h>09:43</h><r>jeroenvandijk</r>Needed this <a href="https://github.com/borkdude/edamame#postprocess" target="_blank">https://github.com/borkdude/edamame#postprocess</a> for detailed location info</z><z id="t1667468724" t="ikitommi did a test with edamame a while back: https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5"><y>#</y><d>2022-11-03</d><h>09:45</h><r>ikitommi</r>did a test with edamame a while back: <a href="https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5" target="_blank">https://gist.github.com/ikitommi/0e5c4e48d8aeb7dd176128856ecdacb5</a></z><z id="t1667468931" t="jeroenvandijk Ah useful thank you!"><y>#</y><d>2022-11-03</d><h>09:48</h><r>jeroenvandijk</r>Ah useful thank you!</z><z id="t1667468950" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think we could add &quot;type checking&quot; for def - this is what you need right?"><y>#</y><d>2022-11-03</d><h>09:49</h><r>borkdude</r><a>@ikitommi</a> I think we could add &quot;type checking&quot; for <code>def</code> - this is what you need right?</z><z id="t1667469242" t="ikitommi [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] “type-checking” using clj-kondo type system, yes, that would be awesome!"><y>#</y><d>2022-11-03</d><h>09:54</h><r>ikitommi</r><a>@borkdude</a> “type-checking” using clj-kondo type system, yes, that would be awesome!</z><z id="t1667469320" t="ikitommi another try would be use use malli for the validation and just emit errors. But that’s way more work I think (all the relevant schemas should be loaded, e.g. should need to run the whole program to figure our what is the schema)"><y>#</y><d>2022-11-03</d><h>09:55</h><r>ikitommi</r>another try would be use use malli for the validation and just emit errors. But that’s way more work I think (all the relevant schemas should be loaded, e.g. should need to run the whole program to figure our what is the schema)</z><z id="t1667469353" t="ikitommi so, should the mx/def emit clj-kondo types?"><y>#</y><d>2022-11-03</d><h>09:55</h><r>ikitommi</r>so, should the <code>mx/def</code> emit clj-kondo types?</z><z id="t1667470029" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] when clj-kondo supports this yes, but currently I don&apos;t think it supports it yet"><y>#</y><d>2022-11-03</d><h>10:07</h><r>borkdude</r><a>@ikitommi</a> when clj-kondo supports this yes, but currently I don&apos;t think it supports it yet</z><z id="t1667470037" t="borkdude let&apos;s see if there is already an issue for it"><y>#</y><d>2022-11-03</d><h>10:07</h><r>borkdude</r>let&apos;s see if there is already an issue for it</z><z id="t1667470231" t="borkdude ah yes, a very old one :rolling_on_the_floor_laughing: https://github.com/clj-kondo/clj-kondo/issues/609"><y>#</y><d>2022-11-03</d><h>10:10</h><r>borkdude</r>ah yes, a very old one <b>:rolling_on_the_floor_laughing:</b>
<a href="https://github.com/clj-kondo/clj-kondo/issues/609" target="_blank">https://github.com/clj-kondo/clj-kondo/issues/609</a></z><z id="t1667470237" t="borkdude no upvotes ;)"><y>#</y><d>2022-11-03</d><h>10:10</h><r>borkdude</r>no upvotes ;)</z><z id="t1667470525" t="ikitommi now, one! 🙂"><y>#</y><d>2022-11-03</d><h>10:15</h><r>ikitommi</r>now, one! <b>🙂</b></z><z id="t1667470575" t="ikitommi but, would that work here? the mx/def says “here’s a var which should have a value of type XYZ”"><y>#</y><d>2022-11-03</d><h>10:16</h><r>ikitommi</r>but, would that work here? the <code>mx/def</code> says “here’s a var which should have a value of type XYZ”</z><z id="t1667470593" t="borkdude there is no support for this yet, I think"><y>#</y><d>2022-11-03</d><h>10:16</h><r>borkdude</r>there is no support for this yet, I think</z><z id="t1667470598" t="borkdude only for functions"><y>#</y><d>2022-11-03</d><h>10:16</h><r>borkdude</r>only for functions</z><z id="t1667470619" t="borkdude or perhaps there is"><y>#</y><d>2022-11-03</d><h>10:16</h><r>borkdude</r>or perhaps there is</z><z id="t1667470623" t="ikitommi could hooks work here?"><y>#</y><d>2022-11-03</d><h>10:17</h><r>ikitommi</r>could hooks work here?</z><z id="t1667470626" t="borkdude maybe try {:tag :int} or so"><y>#</y><d>2022-11-03</d><h>10:17</h><r>borkdude</r>maybe try <code>{:tag :int}</code> or so</z><z id="t1667470634" t="ikitommi :thinking_face:"><y>#</y><d>2022-11-03</d><h>10:17</h><r>ikitommi</r><b>:thinking_face:</b></z><z id="t1667470640" t="borkdude I have to go now, be back in an hour"><y>#</y><d>2022-11-03</d><h>10:17</h><r>borkdude</r>I have to go now, be back in an hour</z><z id="t1667470651" t="ikitommi :tag takes a clj-kondo type?"><y>#</y><d>2022-11-03</d><h>10:17</h><r>ikitommi</r><code>:tag</code> takes a clj-kondo type?</z><z id="t1667470652" t="ikitommi same here"><y>#</y><d>2022-11-03</d><h>10:17</h><r>ikitommi</r>same here</z><z id="t1667470679" t="borkdude yes: {:namespaces {foo {bar {:tag :int}}}} - if you are lucky this works, not sure"><y>#</y><d>2022-11-03</d><h>10:17</h><r>borkdude</r>yes: <code>{:namespaces {foo {bar {:tag :int}}}}</code> - if you are lucky this works, not sure</z><z id="t1667485787" t="jeroenvandijk FYI [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I have something that I’m happy with ( [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] also thanks to edamame), see https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129 . Here is some example output: 1: {:b :z ^------- should be an integer 2: 3: :c {:c0 2} ^------- missing required key :x 4: 5: } ^------- missing required key :a"><y>#</y><d>2022-11-03</d><h>14:29</h><r>jeroenvandijk</r>FYI <a>@ikitommi</a>, I have something that I’m happy with (<a>@borkdude</a> also thanks to edamame), see <a href="https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129" target="_blank">https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129</a>. Here is some example output:
<pre>1: {:b :z
         ^------- should be an integer
  2: 
  3: :c {:c0 2}
              ^------- missing required key :x
  4: 
  5: }
     ^------- missing required key :a</pre></z></g><g id="s27"><z id="t1667486058" t="lread Oh that&apos;s pretty neat [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] . I might experiment with this strategy for reporting errors in cljdoc.edn files."><y>#</y><d>2022-11-03</d><h>14:34</h><r>lread</r>Oh that&apos;s pretty neat <a>@U0FT7SRLP</a>. I might experiment with this strategy for reporting errors in <code>cljdoc.edn</code> files.</z><z id="t1667486595" t="borkdude [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] Cool stuff, I think it&apos;s worth a blog post or maybe an article in the malli or edamame repo :)"><y>#</y><d>2022-11-03</d><h>14:43</h><r>borkdude</r><a>@U0FT7SRLP</a> Cool stuff, I think it&apos;s worth a blog post or maybe an article in the malli or edamame repo :)</z><z id="t1667486919" t="jeroenvandijk Thanks [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] ! Yeah I guess it can be useful for others, or in other contexts. Also it is combining some funny techniques together. Will think about an article. Do you have an example format you are thinking of?"><y>#</y><d>2022-11-03</d><h>14:48</h><r>jeroenvandijk</r>Thanks <a>@borkdude</a>! Yeah I guess it can be useful for others, or in other contexts. Also it is combining some funny techniques together. Will think about an article. Do you have an example format you are thinking of?</z><z id="t1667486965" t="jeroenvandijk Btw, I have created a similar mechanism for giving feedback on invalid edn input, also using Edamame. Maybe can include this in the same article"><y>#</y><d>2022-11-03</d><h>14:49</h><r>jeroenvandijk</r>Btw, I have created a similar  mechanism for giving feedback on invalid edn input, also using Edamame. Maybe can include this in the same article</z><z id="t1667487047" t="borkdude I&apos;m open to having an examples/malli/README.md thing in edamame for example, or similar, or doc/postprocess.md or so"><y>#</y><d>2022-11-03</d><h>14:50</h><r>borkdude</r>I&apos;m open to having an <code>examples/malli/README.md</code> thing in edamame for example, or similar, or <code>doc/postprocess.md</code> or so</z><z id="t1667487059" t="borkdude but if you want to post it in your own blog, also fine, then we can link there"><y>#</y><d>2022-11-03</d><h>14:50</h><r>borkdude</r>but if you want to post it in your own blog, also fine, then we can link there</z><z id="t1667487086" t="borkdude If you don&apos;t have a blog, you can quickly create one with ... https://github.com/borkdude/quickblog :)"><y>#</y><d>2022-11-03</d><h>14:51</h><r>borkdude</r>If you don&apos;t have a blog, you can quickly create one with ...
<a href="https://github.com/borkdude/quickblog" target="_blank">https://github.com/borkdude/quickblog</a> :)</z><z id="t1667487119" t="jeroenvandijk haha good one, let me think about it for a bit. No blog at the moment. I’ll come back to it"><y>#</y><d>2022-11-03</d><h>14:51</h><r>jeroenvandijk</r>haha good one, let me think about it for a bit. No blog at the moment. I’ll come back to it</z><z id="t1667487131" t="borkdude no pressure"><y>#</y><d>2022-11-03</d><h>14:52</h><r>borkdude</r>no pressure</z><z id="t1667488304" t="ikitommi Looks great! Also would like see both the code and the post 👍"><y>#</y><d>2022-11-03</d><h>15:11</h><r>ikitommi</r>Looks great! Also would like see both the code and the post <b>👍</b></z><z id="t1667488383" t="jeroenvandijk Thanks [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] a raw version is already here https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129 (for the Malli feedback)"><y>#</y><d>2022-11-03</d><h>15:13</h><r>jeroenvandijk</r>Thanks <a>@ikitommi</a> a raw version is already here <a href="https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129" target="_blank">https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129</a> (for the Malli feedback)</z><z id="t1667561481" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] https://twitter.com/borkdude/status/1588493830961393664 (WIP)"><y>#</y><d>2022-11-04</d><h>11:31</h><r>borkdude</r><a>@ikitommi</a> <a href="https://twitter.com/borkdude/status/1588493830961393664" target="_blank">https://twitter.com/borkdude/status/1588493830961393664</a>
(WIP)</z><z id="t1667561620" t="borkdude (Need to fix a few test... Ran 366 tests containing 3188 assertions. 80 failures, 8 errors. )"><y>#</y><d>2022-11-04</d><h>11:33</h><r>borkdude</r>(Need to fix a few test...
<pre>Ran 366 tests containing 3188 assertions.
80 failures, 8 errors.</pre>
)</z><z id="t1667561952" t="ikitommi oh, super! that was fast. I’ll emit the clj-kondo types when this ships. So, this would work with complex types like maps too and also for defining the values? e.g. “this var should hold a map of :age key with int value” and saying (def mything {:age &quot;1&quot;}) would be a failure?"><y>#</y><d>2022-11-04</d><h>11:39</h><r>ikitommi</r>oh, super! that was fast. I’ll emit the clj-kondo types when this ships. So, this would work with complex types like maps too and also for defining the values? e.g. “this var should hold a map of :age key with int value” and saying <code>(def mything {:age &quot;1&quot;})</code> would be a failure?</z><z id="t1667561977" t="borkdude I&apos;ll have to test it :)"><y>#</y><d>2022-11-04</d><h>11:39</h><r>borkdude</r>I&apos;ll have to test it :)</z><z id="t1667562887" t="borkdude Getting closer: Ran 366 tests containing 3233 assertions. 1 failures, 0 errors."><y>#</y><d>2022-11-04</d><h>11:54</h><r>borkdude</r>Getting closer:
<pre>Ran 366 tests containing 3233 assertions.
1 failures, 0 errors.</pre></z><z id="t1667563043" t="borkdude This is obviously wrong facepalm"><y>#</y><d>2022-11-04</d><h>11:57</h><r>borkdude</r>This is obviously wrong <b>facepalm</b></z><z id="t1667563133" t="borkdude Repro:"><y>#</y><d>2022-11-04</d><h>11:58</h><r>borkdude</r>Repro:</z><z id="t1667563369" t="borkdude Ran 366 tests containing 3233 assertions. 0 failures, 0 errors. 🎉"><y>#</y><d>2022-11-04</d><h>12:02</h><r>borkdude</r><pre>Ran 366 tests containing 3233 assertions.
0 failures, 0 errors.</pre>
<b>🎉</b></z><z id="t1667563449" t="borkdude Still getting false positives with test corpus... lunch time"><y>#</y><d>2022-11-04</d><h>12:04</h><r>borkdude</r>Still getting false positives with test corpus... lunch time</z><z id="t1667563614" t="borkdude It&apos;s funny, I&apos;m getting errors from dynamic vars which are initialized to nil and then later called with swap! - I guess I&apos;ll have to ignore dynamic vars"><y>#</y><d>2022-11-04</d><h>12:06</h><r>borkdude</r>It&apos;s funny, I&apos;m getting errors from dynamic vars which are initialized to <code>nil</code>
and then later called with <code>swap!</code> - I guess I&apos;ll have to ignore dynamic vars</z><z id="t1667564324" t="borkdude https://twitter.com/borkdude/status/1588505774833426433"><y>#</y><d>2022-11-04</d><h>12:18</h><r>borkdude</r><a href="https://twitter.com/borkdude/status/1588505774833426433" target="_blank">https://twitter.com/borkdude/status/1588505774833426433</a></z><z id="t1667567487" t="borkdude Another nice edge case... https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L10803-L10816 It thinks gensym_counter is nil (since it was initialized to nil )"><y>#</y><d>2022-11-04</d><h>13:11</h><r>borkdude</r>Another nice edge case...

<a href="https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L10803-L10816" target="_blank">https://github.com/clojure/clojurescript/blob/961807166c8cf4d45a225d63416f06464fb27eaf/src/main/cljs/cljs/core.cljs#L10803-L10816</a>

It thinks <code>gensym_counter</code> is nil (since it was initialized to <code>nil</code>)</z><z id="t1667567506" t="borkdude so swap! is giving a type error"><y>#</y><d>2022-11-04</d><h>13:11</h><r>borkdude</r>so <code>swap!</code> is giving a type error</z><z id="t1667569890" t="borkdude [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Now got this working: $ clojure -M:clj-kondo/dev --lint - --config &apos;{:linters {:type-mismatch {:namespaces {user {x {:tag {:op :keys :req {:x :any}} }}}}}}&apos; &lt;&lt;&lt; &quot;(def x) (inc x)&quot; &lt;stdin&gt;:1:14: warning: Expected: number, received: map."><y>#</y><d>2022-11-04</d><h>13:51</h><r>borkdude</r><a>@ikitommi</a> Now got this working:

<pre>$ clojure -M:clj-kondo/dev --lint - --config &apos;{:linters {:type-mismatch {:namespaces {user {x {:tag {:op :keys :req {:x :any}} }}}}}}&apos; &lt;&lt;&lt; &quot;(def x) (inc x)&quot;
&lt;stdin&gt;:1:14: warning: Expected: number, received: map.</pre></z><z id="t1667569912" t="borkdude So here we declare that x is a map that has at least an :x key"><y>#</y><d>2022-11-04</d><h>13:51</h><r>borkdude</r>So here we declare that <code>x</code> is a map that has at least an <code>:x</code> key</z><z id="t1667570046" t="borkdude but this is probably the reverse of what you were proposing. the config in clj-kondo is to override types that have been inferred, possibly incorrectly"><y>#</y><d>2022-11-04</d><h>13:54</h><r>borkdude</r>but this is probably the reverse of what you were proposing. the config in clj-kondo is to override types that have been inferred, possibly incorrectly</z><z id="t1667570403" t="borkdude Perhaps clj-kondo should both check the type and take the config as the source of truth...?"><y>#</y><d>2022-11-04</d><h>14:00</h><r>borkdude</r>Perhaps clj-kondo should both check the type and take the config as the source of truth...?</z><z id="t1667570426" t="borkdude I&apos;m not sure how one would use that in practice"><y>#</y><d>2022-11-04</d><h>14:00</h><r>borkdude</r>I&apos;m not sure how one would use that in practice</z><z id="t1667469229" t="J Hi guys! Did you know if there a lib to convert a plumatic schema to a malli schema?"><y>#</y><d>2022-11-03</d><h>09:53</h><w>J</w>Hi guys! Did you know if there a lib to convert a plumatic schema to a malli schema?</z><z id="t1667479133" t="jeroenvandijk Not sure if it exists, but maybe the lite syntax can help you convert your plumatic schema https://github.com/metosin/malli#lite"><y>#</y><d>2022-11-03</d><h>12:38</h><r>jeroenvandijk</r>Not sure if it exists, but maybe the lite syntax can help you convert your plumatic schema <a href="https://github.com/metosin/malli#lite" target="_blank">https://github.com/metosin/malli#lite</a></z><z id="t1667485787" t="jeroenvandijk FYI [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , I have something that I’m happy with ( [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] also thanks to edamame), see https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129 . Here is some example output: 1: {:b :z ^------- should be an integer 2: 3: :c {:c0 2} ^------- missing required key :x 4: 5: } ^------- missing required key :a"><y>#</y><d>2022-11-03</d><h>14:29</h><w>jeroenvandijk</w>FYI <a>@ikitommi</a>, I have something that I’m happy with (<a>@borkdude</a> also thanks to edamame), see <a href="https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129" target="_blank">https://gist.github.com/jeroenvandijk/080370966fadb7e65601931c3de47ed5#file-malli_inline_output-clj-L129</a>. Here is some example output:
<pre>1: {:b :z
         ^------- should be an integer
  2: 
  3: :c {:c0 2}
              ^------- missing required key :x
  4: 
  5: }
     ^------- missing required key :a</pre></z><z id="t1667984513" t="J Hi guys! I have a question about how to check “extra constraints”. Let’s say, we have this schema: (def CreatCommentPayload [:map [:comment/owner uuid?] [:comment/text string?] [:comment/associated-account [:vector uuid?]]]) For example, this payload is valid for create a comment: (validate CreateCommentPayload {:comment/owner #uuid &quot;92688fe4-9050-42b0-af5d-6d74a3b3d65b&quot; :comment/text &quot;Hello&quot; :comment/associated-account [#uuid &quot;864fbd90-914d-4c6d-b1b9-415276f7dda8&quot;]} In fact, this is not enough validation. There is some other possible validations: • comment/owner should exist in the database. • Each account in comment/associated-account should exist in the database. There are several ways to check this two other facts: 1- Custom schema Like: (def CreateCommentPayload [:map [:comment/owner [:and uuid? exists?] [:comment/text string?] [:comment/associated-account [:and [:vector uuid?] exists?]]) exists? is a custom function to check if one or several accounts is or not in the database. 2- Constraint schema Like: (def CreateCommentConstraint [:fn (fn [comment-payload] (exists? (into (:comment/associted-account comment-payload []) (:comment/owner comment-payload)) (def CreateCommentSchema [:and CreateCommentPayload CreateCommentConstraint]) We reuse the exists? function but here we check all the accounts with one request. 3- Don’t check constraint in schema There will be a solution. The check of this constraints can be done in another layer of the app. What’s your position about this case?"><y>#</y><d>2022-11-09</d><h>09:01</h><w>J</w>Hi guys! I have a question about how to check “extra constraints”. Let’s say, we have this schema:
<pre>(def CreatCommentPayload
 [:map
  [:comment/owner uuid?]
  [:comment/text string?]
  [:comment/associated-account [:vector uuid?]]])</pre>
For example, this payload is valid for create a comment:
<pre>(validate CreateCommentPayload {:comment/owner #uuid &quot;92688fe4-9050-42b0-af5d-6d74a3b3d65b&quot;
                                :comment/text &quot;Hello&quot;
                                :comment/associated-account [#uuid &quot;864fbd90-914d-4c6d-b1b9-415276f7dda8&quot;]}</pre>
In fact, this is not enough validation. There is some other possible validations:
• <code>comment/owner</code> should exist in the database.
• Each account in <code>comment/associated-account</code> should exist in the database.
There are several ways to check this two other facts:

1- Custom schema
Like:
<pre>(def CreateCommentPayload
 [:map
  [:comment/owner [:and uuid? exists?]
  [:comment/text string?]
  [:comment/associated-account [:and [:vector uuid?] exists?]])</pre>
<code>exists?</code> is a custom function to check if one or several accounts is or not in the database.

2- Constraint schema
Like:
<pre>(def CreateCommentConstraint
 [:fn (fn [comment-payload]
        (exists? (into (:comment/associted-account comment-payload []) (:comment/owner comment-payload))
(def CreateCommentSchema
 [:and CreateCommentPayload CreateCommentConstraint])</pre>
We reuse the <code>exists?</code>function but here we check all the accounts with one request.

3- Don’t check constraint in schema
There will be a solution. The check of this constraints can be done in another layer of the app.

What’s your position about this case?</z><z id="t1667997871" t="Ben Sless Since the constraints you specify involve side effects, I&apos;d say they shouldn&apos;t be in the schema"><y>#</y><d>2022-11-09</d><h>12:44</h><r>Ben Sless</r>Since the constraints you specify involve side effects, I&apos;d say they shouldn&apos;t be in the schema</z><z id="t1667999272" t="eskos Schema is about structural validation, while you could with eg. fn schemas make them check from db all the things, it’s probably cleaner to implement that as separate validation layer. Or rely on db constraints themselves, and handle insert/update failures gracefully."><y>#</y><d>2022-11-09</d><h>13:07</h><r>eskos</r>Schema is about structural validation, while you could with eg. fn schemas make them check from db all the things, it’s probably cleaner to implement that as separate validation layer. Or rely on db constraints themselves, and handle insert/update failures gracefully.</z><z id="t1668069390" t="J Thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] and [:attrs {:href &quot;/_/_/users/U8SFC8HLP&quot;}] ."><y>#</y><d>2022-11-10</d><h>08:36</h><r>J</r>Thanks <a>@UK0810AQ2</a> and <a>@U8SFC8HLP</a>.</z><z id="t1668025644" t="dvingo Am I missing something obvious here? (m/schema [:comment {:some :prop}] {:registry (merge (m/default-schemas) {:comment :int})}) =&gt; [:int {:some :prop}] does not work: (m/schema [:comment {:some :prop}] {:registry (merge (m/default-schemas) {:comment [:map [:a :int]]})}) Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138). :malli.core/invalid-schema {:schema [:map [:a :int]]} "><y>#</y><d>2022-11-09</d><h>20:27</h><w>dvingo</w>Am I missing something obvious here?
<pre>(m/schema [:comment {:some :prop}] 
  {:registry (merge (m/default-schemas) {:comment :int})})
=&gt; [:int {:some :prop}]</pre>
does not work:
<pre>(m/schema [:comment {:some :prop}] 
  {:registry (merge (m/default-schemas) {:comment [:map [:a :int]]})})
Execution error (ExceptionInfo) at malli.core/-fail! (core.cljc:138).
:malli.core/invalid-schema {:schema [:map [:a :int]]}</pre>
</z><z id="t1668027656" t="aaron51 Is a :fn schema of (.exists (io/file x)) appropriate in Malli? Given that “schema is about structural validation”? ( https://clojurians.slack.com/archives/CLDK6MFMK/p1667999272184759?thread_ts=1667984513.081219&amp;amp;cid=CLDK6MFMK )"><y>#</y><d>2022-11-09</d><h>21:00</h><w>aaron51</w>Is a <code>:fn</code> schema of <code>(.exists (io/file x))</code> appropriate in Malli? Given that “schema is about structural validation”? (<a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1667999272184759?thread_ts=1667984513.081219&amp;amp;cid=CLDK6MFMK" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1667999272184759?thread_ts=1667984513.081219&amp;amp;cid=CLDK6MFMK</a>)</z><z id="t1668102639" t="Casey Is there a function in malli already that does something like (select-keys MySchema a-map) to make a map containing only the keys defined in the schema? I don&apos;t want to define a closed schema, but I also don&apos;t want to pass unknown keys further down"><y>#</y><d>2022-11-10</d><h>17:50</h><w>Casey</w>Is there a function in malli already that does something like <code>(select-keys MySchema a-map)</code> to make a map containing only the keys defined in the schema? I don&apos;t want to define a closed schema, but I also don&apos;t want to pass unknown keys further down</z><z id="t1668103596" t="ikitommi there is an example of this in Malli readme, see https://github.com/metosin/malli#value-transformation"><y>#</y><d>2022-11-10</d><h>18:06</h><r>ikitommi</r>there is an example of this in Malli readme, see <a href="https://github.com/metosin/malli#value-transformation" target="_blank">https://github.com/metosin/malli#value-transformation</a></z><z id="t1668103605" t="Casey (select-keys (mu/keys MySchema) value) does this"><y>#</y><d>2022-11-10</d><h>18:06</h><r>Casey</r><code>(select-keys (mu/keys MySchema) value)</code> does this</z><z id="t1668103632" t="ikitommi e.g. me/strip-extra-keys-transformer , it&apos;s recursive"><y>#</y><d>2022-11-10</d><h>18:07</h><r>ikitommi</r>e.g. <code>me/strip-extra-keys-transformer</code>, it&apos;s recursive</z><z id="t1668103662" t="Casey Ah! I see, for use with (m/decode)"><y>#</y><d>2022-11-10</d><h>18:07</h><r>Casey</r>Ah! I see, for use with (m/decode)</z><z id="t1668105091" t="Casey Than you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] !"><y>#</y><d>2022-11-10</d><h>18:31</h><r>Casey</r>Than you <a>@U055NJ5CC</a>!</z><z id="t1668517797" t="agigao In the context of coercion - can we process data before we pass it to a schema nested one level deeper? For example: (def file-metada [:map [:name string?] [:file file-content]]) (def file-content [:vector [:map [:id uuid?] [:name string?]]]) Actually read the file and transform data before passing to file-content for validation."><y>#</y><d>2022-11-15</d><h>13:09</h><w>agigao</w>In the context of coercion - can we process data before we pass it to a schema nested one level deeper?

For example:
<pre>(def file-metada
  [:map
   [:name string?]
   [:file file-content]])

(def file-content
  [:vector
   [:map
    [:id uuid?]
    [:name string?]]])</pre>
Actually read the file and transform data before passing to file-content for validation.</z><z id="t1668518720" t="ikitommi something I wrote."><y>#</y><d>2022-11-15</d><h>13:25</h><w>ikitommi</w>something I wrote.</z><z id="t1668569077" t="dumrat I have been looking for something like this. I thought to myself &quot;Surely malli must have some way to transform data - not just coerce&quot;. I will give meander a go."><y>#</y><d>2022-11-16</d><h>03:24</h><r>dumrat</r>I have been looking for something like this. I thought to myself &quot;Surely malli must have some way to transform data - not just coerce&quot;. I will give meander a go.</z><z id="t1668579941" t="ikitommi planning to add some helpers in Malli for this, e.g. a pre-build matcher , meander-transformer , visualization etc. Needs to play with this a bit to see what is the relevant reusable part first."><y>#</y><d>2022-11-16</d><h>06:25</h><r>ikitommi</r>planning to add some helpers in Malli for this, e.g. a pre-build <code>matcher</code>, <code>meander-transformer</code>, visualization etc. Needs to play with this a bit to see what is the relevant reusable part first.</z><z id="t1668764931" t="agigao Thank you!"><y>#</y><d>2022-11-18</d><h>09:48</h><r>agigao</r>Thank you!</z><z id="t1668588635" t="Bart Kleijngeld Is this expected behavior and if so, can someone point out what I&apos;m misunderstanding? Explicitly stating to use the default schemas registry causes an error (and actually every merge I&apos;ve done so far does): (m/validate [:map [:x string?]] {:a 1}) ;; =&gt; false (m/validate [:map {:registry (merge (m/default-schemas))} [:x string?]] {:a 1}) ;; =&gt; clojure.lang.ExceptionInfo: :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1, :max nil} {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :enum, :properties nil, :children nil, :min 1, :max nil}} Shouldn&apos;t this be equivalent?"><y>#</y><d>2022-11-16</d><h>08:50</h><w>Bart Kleijngeld</w>Is this expected behavior and if so, can someone point out what I&apos;m misunderstanding?

Explicitly stating to use the default schemas registry causes an error (and actually every <code>merge</code> I&apos;ve done so far does):

<pre>(m/validate
  [:map
   [:x string?]]
  {:a 1})  ;; =&gt; false</pre>
<pre>(m/validate
  [:map {:registry (merge (m/default-schemas))}
   [:x string?]]
  {:a 1})  ;; =&gt; clojure.lang.ExceptionInfo: :malli.core/child-error {:type :enum, :properties nil, :children nil, :min 1, :max nil}
                 {:type :malli.core/child-error, :message :malli.core/child-error, :data {:type :enum, :properties nil, :children nil, :min 1, :max nil}}</pre>
Shouldn&apos;t this be equivalent?</z><z id="t1668590485" t="ikitommi currently, the property-registry doesn’t allow IntoSchema instances, just Schema s. Original idea was that you can only present serializable things. Not sure if this is a good constraint, as you can anyway have non-serializable things in schemas, e.g [:string {:gen/gen …generator-function-here…}]"><y>#</y><d>2022-11-16</d><h>09:21</h><r>ikitommi</r>currently, the property-registry doesn’t allow <code>IntoSchema</code> instances, just <code>Schema</code>s. Original idea was that you can only present serializable things. Not sure if this is a good constraint, as you can anyway have non-serializable things in schemas, e.g <code>[:string {:gen/gen …generator-function-here…}]</code></z><z id="t1668590551" t="ikitommi Please write an issue out of this."><y>#</y><d>2022-11-16</d><h>09:22</h><r>ikitommi</r>Please write an issue out of this.</z><z id="t1668590559" t="Bart Kleijngeld I will. Thanks for the explanation"><y>#</y><d>2022-11-16</d><h>09:22</h><r>Bart Kleijngeld</r>I will. Thanks for the explanation</z><z id="t1668590847" t="Bart Kleijngeld See https://github.com/metosin/malli/issues/780 (If you have any title suggestion that will make this issue most findable/descriptive for you let me know)"><y>#</y><d>2022-11-16</d><h>09:27</h><r>Bart Kleijngeld</r>See <a href="https://github.com/metosin/malli/issues/780" target="_blank">https://github.com/metosin/malli/issues/780</a>

(If you have any title suggestion that will make this issue most findable/descriptive for you let me know)</z><z id="t1668603475" t="Bart Kleijngeld I&apos;m looking to express something like an :or schema, but instead of enumerating the arguments by hand I&apos;d like to supply a collection of schemas. So something like: [:any-of schemas-coll] instead of [:or schema-1 schema-2 ... schema-n] Especially nice because registries tend to be regular maps, so you can just pass those in. Of course I can construct the :or schema above from a collection, but I would expect some nice idiom to be present. Is there something like this present? Or should I create a new schema type for this?"><y>#</y><d>2022-11-16</d><h>12:57</h><w>Bart Kleijngeld</w>I&apos;m looking to express something like an <code>:or</code> schema, but instead of enumerating the arguments by hand I&apos;d like to supply a collection of schemas.

So something like:

<pre>[:any-of schemas-coll]</pre>
instead of
<pre>[:or schema-1 schema-2 ... schema-n]</pre>
Especially nice because registries tend to be regular maps, so you can just pass those in.
Of course I can construct the <code>:or</code> schema above from a collection, but I would expect some nice idiom to be present.

Is there something like this present? Or should I create a new schema type for this?</z><z id="t1668610915" t="ikitommi no idiom, children are currently varargs, not a single collection. But: (into [:or] [:int :string]) ; =&gt; [:or :int :string]"><y>#</y><d>2022-11-16</d><h>15:01</h><w>ikitommi</w>no idiom, children are currently varargs, not a single collection. But:
<pre>(into [:or] [:int :string])
; =&gt; [:or :int :string]</pre></z><z id="t1668610991" t="ikitommi also, there is the map ast: (m/ast [:or :int :string]) ; =&gt; {:type :or, :children [{:type :int} {:type :string}]} (update *1 :children conj {:type :boolean}) ; =&gt; {:type :or, :children [{:type :int} {:type :string} {:type :boolean}]} (m/from-ast *1) ; =&gt; [:or :int :string :boolean]"><y>#</y><d>2022-11-16</d><h>15:03</h><w>ikitommi</w>also, there is the map ast:
<pre>(m/ast [:or :int :string])
; =&gt; {:type :or, :children [{:type :int} {:type :string}]}

(update *1 :children conj {:type :boolean})
; =&gt; {:type :or, :children [{:type :int} {:type :string} {:type :boolean}]}

(m/from-ast *1)
; =&gt; [:or :int :string :boolean]</pre></z><z id="t1668611193" t="Bart Kleijngeld Thanks!"><y>#</y><d>2022-11-16</d><h>15:06</h><w>Bart Kleijngeld</w>Thanks!</z><z id="t1668690961" t="hanDerPeder Is this a bug? (m/validate :at.least/ten 8 {:registry (merge (m/default-schemas) {:at.least/ten [int? {:min 10}]})}) ;; =&gt; true, but 8 &lt; 10"><y>#</y><d>2022-11-17</d><h>13:16</h><w>hanDerPeder</w>Is this a bug?
<pre>(m/validate :at.least/ten 8
            {:registry (merge
                        (m/default-schemas)
                        {:at.least/ten [int? {:min 10}]})}) ;; =&gt; true, but 8 &lt; 10</pre></z><z id="t1668691112" t="hanDerPeder I would expect the props from the vector to be passed to the schema. (m/properties (m/schema :at.least/ten {:registry (merge (m/default-schemas) {:at.least/ten [int? {:min 10}]})})) ;; =&gt; nil"><y>#</y><d>2022-11-17</d><h>13:18</h><r>hanDerPeder</r>I would expect the props from the vector to be passed to the schema.
<pre>(m/properties
 (m/schema :at.least/ten
           {:registry (merge
                       (m/default-schemas)
                       {:at.least/ten [int? {:min 10}]})})) ;; =&gt; nil</pre></z><z id="t1668691717" t="ikitommi int? is just a predicate, does not support properties, :int is a real schema. Try [:int {:min 10}] instead."><y>#</y><d>2022-11-17</d><h>13:28</h><r>ikitommi</r><code>int?</code> is just a predicate, does not support properties, <code>:int</code> is a real schema. Try <code>[:int {:min 10}]</code> instead.</z><z id="t1668691736" t="ikitommi would be nice to get a warning out of this, but not there yet."><y>#</y><d>2022-11-17</d><h>13:28</h><r>ikitommi</r>would be nice to get a warning out of this, but not there yet.</z><z id="t1668691843" t="juhoteperi [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] predicate schemas probably support some properties, just not these"><y>#</y><d>2022-11-17</d><h>13:30</h><r>juhoteperi</r><a>@U055NJ5CC</a> predicate schemas probably support some properties, just not these</z><z id="t1668691847" t="hanDerPeder aha, thanks 👍 this would imply that there is not a real schema equivalent of inst? , right? how come?"><y>#</y><d>2022-11-17</d><h>13:30</h><r>hanDerPeder</r>aha, thanks <b>👍</b> this would imply that there is not a real schema equivalent of <code>inst?</code> , right? how come?</z><z id="t1668691905" t="ikitommi there is a separate ticket for making good time schemas, e.g. :time , :date , …"><y>#</y><d>2022-11-17</d><h>13:31</h><r>ikitommi</r>there is a separate ticket for making good time schemas, e.g. <code>:time</code>, <code>:date</code> , …</z><z id="t1668691949" t="ikitommi but, bumped into the missing :inst just yesterday, so, hear you."><y>#</y><d>2022-11-17</d><h>13:32</h><r>ikitommi</r>but, bumped into the missing <code>:inst</code> just yesterday, so, hear you.</z><z id="t1668691951" t="juhoteperi (defn -int-schema [] (-simple-schema {:type :int, :pred int?, :property-pred (-min-max-pred nil)})) and int? is (-simple-schema {:type &apos;int?, :pred int?})"><y>#</y><d>2022-11-17</d><h>13:32</h><r>juhoteperi</r><code>(defn -int-schema [] (-simple-schema {:type :int, :pred int?, :property-pred (-min-max-pred nil)}))</code>

and

<code>int?</code> is <code>(-simple-schema {:type &apos;int?, :pred int?})</code></z><z id="t1668691996" t="juhoteperi We could register property-pred for predicates where it makes sense"><y>#</y><d>2022-11-17</d><h>13:33</h><r>juhoteperi</r>We could register <code>property-pred</code> for predicates where it makes sense</z><z id="t1668692009" t="juhoteperi .... though I might prefer just removing property predicates completely"><y>#</y><d>2022-11-17</d><h>13:33</h><r>juhoteperi</r>.... though I might prefer just removing property predicates completely</z><z id="t1668692047" t="hanDerPeder I second that, speaking as a relatively new user coming from spec I expected int? and :int to be equivalent"><y>#</y><d>2022-11-17</d><h>13:34</h><r>hanDerPeder</r>I second that, speaking as a relatively new user coming from spec I expected <code>int?</code> and <code>:int</code> to be equivalent</z><z id="t1668692126" t="hanDerPeder but to end I would just like to say you guys but out some amazing libraries. i&apos;ve learned a ton from reading your code. thanks!"><y>#</y><d>2022-11-17</d><h>13:35</h><r>hanDerPeder</r>but to end I would just like to say you guys but out some amazing libraries. i&apos;ve learned a ton from reading your code. thanks!</z><z id="t1668692292" t="ikitommi also https://github.com/metosin/malli/issues/636"><y>#</y><d>2022-11-17</d><h>13:38</h><r>ikitommi</r>also <a href="https://github.com/metosin/malli/issues/636" target="_blank">https://github.com/metosin/malli/issues/636</a></z><z id="t1668692607" t="hanDerPeder shouldn&apos;t this also work? (m/properties (m/schema :at.least/ten {:registry (merge (m/default-schemas) {:at.least/ten [:int {:doc &quot;this number needs to be at least ten&quot; :custom/attrib :tranmogrify :min 10}]})})) ie, I expect schema properties to be returned, but is nil"><y>#</y><d>2022-11-17</d><h>13:43</h><r>hanDerPeder</r>shouldn&apos;t this also work?
<pre>(m/properties
 (m/schema :at.least/ten
           {:registry (merge
                       (m/default-schemas)
                       {:at.least/ten [:int {:doc &quot;this number needs to be at least ten&quot;
                                             :custom/attrib :tranmogrify
                                             :min 10}]})}))</pre>
ie, I expect schema properties to be returned, but is nil</z><z id="t1668693162" t="hanDerPeder aha, malli.core/deref"><y>#</y><d>2022-11-17</d><h>13:52</h><r>hanDerPeder</r>aha, <code>malli.core/deref</code></z><z id="t1668703052" t="ikitommi m/coercer and m/coerce landed on master. Runs decode + validate, throws with explain result in case of error. Have copied those fns once too many times between projects."><y>#</y><d>2022-11-17</d><h>16:37</h><w>ikitommi</w><code>m/coercer</code> and <code>m/coerce</code> landed on master. Runs decode + validate, throws with explain result in case of error. Have copied those fns once too many times between projects.</z><z id="t1668770140" t="ikitommi https://github.com/metosin/malli#coercion"><y>#</y><d>2022-11-18</d><h>11:15</h><r>ikitommi</r><a href="https://github.com/metosin/malli#coercion" target="_blank">https://github.com/metosin/malli#coercion</a></z><z id="t1668764991" t="lepistane Hello I can&apos;t seem to figure out how to make humanize and explain give me reason fit for me. So i gotta a schema [:map {:closed true} [:client [:fn #function[app.validation/fn--37864]]] [:sport [:fn #function[app.validation/fn--37866]]] [:stream [:fn #function[app.validation/fn--37868]]] [:timestamp [:fn #function[app.validation/fn--37870]]]] All these are custom functions (more tight than regular predicate) And when i send gibberish to be validated i wanted to have human readable output (in logs) (me/humanize (m/explain schema data)) But i get {:sport [&quot;unknown error&quot;], :stream [&quot;unknown error&quot;]} which i don&apos;t find very useful and i would like these to be more useful. is there anyway for these errors to be different? solved [:fn {:error/message &quot;AAA&quot;} (fn [val] ...)))]"><y>#</y><d>2022-11-18</d><h>09:49</h><w>lepistane</w>Hello

I can&apos;t seem to figure out how to make humanize and explain give me <code>reason</code> fit for me.

So i gotta a schema
<pre>[:map
 {:closed true}
 [:client [:fn #function[app.validation/fn--37864]]]
 [:sport [:fn #function[app.validation/fn--37866]]]
 [:stream [:fn #function[app.validation/fn--37868]]]
 [:timestamp [:fn #function[app.validation/fn--37870]]]]</pre>
All these are custom functions (more tight than regular predicate)

And when i send gibberish to be validated i wanted to have human readable output (in logs)
<pre>(me/humanize (m/explain schema data))</pre>
But i get
<pre>{:sport [&quot;unknown error&quot;], :stream [&quot;unknown error&quot;]}</pre>
which i don&apos;t find very useful and i would like these to be more useful.

is there anyway for these errors to be different?

<code>solved</code>
<pre>[:fn {:error/message &quot;AAA&quot;}
             (fn [val] ...)))]</pre></z><z id="t1668773372" t="ikitommi thought on https://github.com/metosin/malli/pull/782 ?"><y>#</y><d>2022-11-18</d><h>12:09</h><w>ikitommi</w>thought on <a href="https://github.com/metosin/malli/pull/782" target="_blank">https://github.com/metosin/malli/pull/782</a>?</z><z id="t1668847606" t="ikitommi If someone has mad skills or just passion for visualizing things with javascrip/plantuml/any-open-source, would appreciate tips or help: I would like to visualize both the malli transformer chains + the meander transformations. Did the https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/#visualization in the blog post with Joint+, but it’s under commercial licence, so not valid for OS. Just did a http://www.plantuml.com/plantuml/uml/fPHHxz8m4C3V-oak-_i0wYH0JBGGn1XUUT74HrFM0wfRIxgEe8HFvdVmCzckb7MXQ8nls-_krj_jRblMXcdJL2L1QOJv3XzLemi4LaD6Y_euKXnr1cS2Bq1m2hGsMiYTkzqANPirgx17IvQ0mc0rlYEJ7h5NYAQ7VeX3TtyXGV4JqpiqNf6hYWbvPzaqWhSFTTt4BW7bKJFkIPv-yLKovLzRSiJ2AEq8urnZxLZ53f7RUyzZkMTAMxlHjIApagbk4-qAQL1lMO6mEXrShL1o3FCv37xzV0bFRrv_6A_U3c6n07XQioFxgZxlhUci51BffcJ5j_RorKQLV6RmP3m4Pm3lKkEpk6G9UgxGx1M_mC2og1GooBgIuIFfILBwNvpFFOlCBcRswB1fyh3_E6sWcRIJpDrEjItw_QFqEb78jTZjJPu_3zCdn7z5b0eUeWi8PTsgXQpkVORaUE9H_5PHiZyMX73duJx0UvLshtj9axyb-SMzPOMMG-2MPvSvaMGf8PrgGaawxNXrqkylpfacd3bPekJsl_OR with PlantUML, but the layout is kinda bad and doesn’t support nested fields properly. 🧵"><y>#</y><d>2022-11-19</d><h>08:46</h><w>ikitommi</w>If someone has mad skills or just passion for visualizing things with javascrip/plantuml/any-open-source, would appreciate tips or help: I would like to visualize both the malli transformer chains + the meander transformations. Did the <a href="https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/#visualization" target="_blank">https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/#visualization</a> in the blog post with Joint+, but it’s under commercial licence, so not valid for OS. Just did a <a href="http://www.plantuml.com/plantuml/uml/fPHHxz8m4C3V-oak-_i0wYH0JBGGn1XUUT74HrFM0wfRIxgEe8HFvdVmCzckb7MXQ8nls-_krj_jRblMXcdJL2L1QOJv3XzLemi4LaD6Y_euKXnr1cS2Bq1m2hGsMiYTkzqANPirgx17IvQ0mc0rlYEJ7h5NYAQ7VeX3TtyXGV4JqpiqNf6hYWbvPzaqWhSFTTt4BW7bKJFkIPv-yLKovLzRSiJ2AEq8urnZxLZ53f7RUyzZkMTAMxlHjIApagbk4-qAQL1lMO6mEXrShL1o3FCv37xzV0bFRrv_6A_U3c6n07XQioFxgZxlhUci51BffcJ5j_RorKQLV6RmP3m4Pm3lKkEpk6G9UgxGx1M_mC2og1GooBgIuIFfILBwNvpFFOlCBcRswB1fyh3_E6sWcRIJpDrEjItw_QFqEb78jTZjJPu_3zCdn7z5b0eUeWi8PTsgXQpkVORaUE9H_5PHiZyMX73duJx0UvLshtj9axyb-SMzPOMMG-2MPvSvaMGf8PrgGaawxNXrqkylpfacd3bPekJsl_OR" target="_blank">http://www.plantuml.com/plantuml/uml/fPHHxz8m4C3V-oak-_i0wYH0JBGGn1XUUT74HrFM0wfRIxgEe8HFvdVmCzckb7MXQ8nls-_krj_jRblMXcdJL2L1QOJv3XzLemi4LaD6Y_euKXnr1cS2Bq1m2hGsMiYTkzqANPirgx17IvQ0mc0rlYEJ7h5NYAQ7VeX3TtyXGV4JqpiqNf6hYWbvPzaqWhSFTTt4BW7bKJFkIPv-yLKovLzRSiJ2AEq8urnZxLZ53f7RUyzZkMTAMxlHjIApagbk4-qAQL1lMO6mEXrShL1o3FCv37xzV0bFRrv_6A_U3c6n07XQioFxgZxlhUci51BffcJ5j_RorKQLV6RmP3m4Pm3lKkEpk6G9UgxGx1M_mC2og1GooBgIuIFfILBwNvpFFOlCBcRswB1fyh3_E6sWcRIJpDrEjItw_QFqEb78jTZjJPu_3zCdn7z5b0eUeWi8PTsgXQpkVORaUE9H_5PHiZyMX73duJx0UvLshtj9axyb-SMzPOMMG-2MPvSvaMGf8PrgGaawxNXrqkylpfacd3bPekJsl_OR</a> with PlantUML, but the layout is kinda bad and doesn’t support nested fields properly. <b>🧵</b></z><z id="t1668847702" t="ikitommi"><y>#</y><d>2022-11-19</d><h>08:48</h><r>ikitommi</r></z><z id="t1668847829" t="ikitommi"><y>#</y><d>2022-11-19</d><h>08:50</h><r>ikitommi</r></z><z id="t1668848028" t="ikitommi here’s another try with PlantUML:"><y>#</y><d>2022-11-19</d><h>08:53</h><r>ikitommi</r>here’s another try with PlantUML:</z><z id="t1668848257" t="ikitommi last http://www.plantuml.com/plantuml/uml/fPH1Rk8m68NtFiMlC0lGJ6O4QAGs88fKiML3fIwHYN_0RM8Znq6qb9Fr3ZrJRT8Qfp6jgkwIv_V7txCVZ0jDbIxpZ10Kcki7cCbIfGYqW2X9Y-q_oL15i2Vm6pXB82cquc9bNvTS5NfASwof6Gs8N6FURIYzccAU47LDUkIRq_l18TvGjK9T8JAPKouQb6N9sV6ZDet7ugJO2sE_LAdpQag4-0kZR37LKbc5CgQmi5fEDmG0dkRlsgz6ajhgnr1QcZ1hL8QU2urgILE4oMvZpLoABWo7q7vv_WEjY__NtSbb1qOZWDQKRkcTl5qRj4761IQBZARtnyU_2vcnWSQThaHxBW1NeVioSaO3wZutJ98Te6qqRnGYY4uZ7SCVXEw5eB_5lAzHHAQ9qRdD-i7DVh1RMr5XUXNR4jc8PjzPrQE4CuWLNwrrF7ghOPAuwZYNEovdzY_KMtSJ6Vrim2sVEEmFgebox6dDrFlAL9MrwQgNsTbDUyzxpI8X7dZJAMm8loVXq_Gz_K02HiWO1RF_Mwy0 , code expression together:"><y>#</y><d>2022-11-19</d><h>08:57</h><r>ikitommi</r>last <a href="http://www.plantuml.com/plantuml/uml/fPH1Rk8m68NtFiMlC0lGJ6O4QAGs88fKiML3fIwHYN_0RM8Znq6qb9Fr3ZrJRT8Qfp6jgkwIv_V7txCVZ0jDbIxpZ10Kcki7cCbIfGYqW2X9Y-q_oL15i2Vm6pXB82cquc9bNvTS5NfASwof6Gs8N6FURIYzccAU47LDUkIRq_l18TvGjK9T8JAPKouQb6N9sV6ZDet7ugJO2sE_LAdpQag4-0kZR37LKbc5CgQmi5fEDmG0dkRlsgz6ajhgnr1QcZ1hL8QU2urgILE4oMvZpLoABWo7q7vv_WEjY__NtSbb1qOZWDQKRkcTl5qRj4761IQBZARtnyU_2vcnWSQThaHxBW1NeVioSaO3wZutJ98Te6qqRnGYY4uZ7SCVXEw5eB_5lAzHHAQ9qRdD-i7DVh1RMr5XUXNR4jc8PjzPrQE4CuWLNwrrF7ghOPAuwZYNEovdzY_KMtSJ6Vrim2sVEEmFgebox6dDrFlAL9MrwQgNsTbDUyzxpI8X7dZJAMm8loVXq_Gz_K02HiWO1RF_Mwy0" target="_blank">http://www.plantuml.com/plantuml/uml/fPH1Rk8m68NtFiMlC0lGJ6O4QAGs88fKiML3fIwHYN_0RM8Znq6qb9Fr3ZrJRT8Qfp6jgkwIv_V7txCVZ0jDbIxpZ10Kcki7cCbIfGYqW2X9Y-q_oL15i2Vm6pXB82cquc9bNvTS5NfASwof6Gs8N6FURIYzccAU47LDUkIRq_l18TvGjK9T8JAPKouQb6N9sV6ZDet7ugJO2sE_LAdpQag4-0kZR37LKbc5CgQmi5fEDmG0dkRlsgz6ajhgnr1QcZ1hL8QU2urgILE4oMvZpLoABWo7q7vv_WEjY__NtSbb1qOZWDQKRkcTl5qRj4761IQBZARtnyU_2vcnWSQThaHxBW1NeVioSaO3wZutJ98Te6qqRnGYY4uZ7SCVXEw5eB_5lAzHHAQ9qRdD-i7DVh1RMr5XUXNR4jc8PjzPrQE4CuWLNwrrF7ghOPAuwZYNEovdzY_KMtSJ6Vrim2sVEEmFgebox6dDrFlAL9MrwQgNsTbDUyzxpI8X7dZJAMm8loVXq_Gz_K02HiWO1RF_Mwy0</a>, code expression together:</z><z id="t1668848369" t="jeroenvandijk What about https://mermaid-js.github.io/mermaid/#/classDiagram Unfortunately, no experience yet and not sure if it is better than PlantUML."><y>#</y><d>2022-11-19</d><h>08:59</h><r>jeroenvandijk</r>What about <a href="https://mermaid-js.github.io/mermaid/#/classDiagram" target="_blank">https://mermaid-js.github.io/mermaid/#/classDiagram</a>Unfortunately, no experience yet and not sure if it is better than PlantUML.</z><z id="t1668854575" t="ikitommi Thanks, but I don’t think Mermaid supports field-level mappings."><y>#</y><d>2022-11-19</d><h>10:42</h><r>ikitommi</r>Thanks, but I don’t think Mermaid supports field-level mappings.</z><z id="t1668860831" t="dumrat [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I tried graphviz dot (for the first time - so this could be improved upon I guess): https://bit.ly/3TVe9NU"><y>#</y><d>2022-11-19</d><h>12:27</h><r>dumrat</r><a>@U055NJ5CC</a> I tried graphviz dot (for the first time - so this could be improved upon I guess):

<a href="https://bit.ly/3TVe9NU" target="_blank">https://bit.ly/3TVe9NU</a></z><z id="t1668963394" t="ikitommi [:attrs {:href &quot;/_/_/users/UC1DTFY1G&quot;}] that&apos;s actually quite good, bit wonky but best so far :man-bowing:"><y>#</y><d>2022-11-20</d><h>16:56</h><r>ikitommi</r><a>@UC1DTFY1G</a> that&apos;s actually quite good, bit wonky but best so far <b>:man-bowing:</b></z><z id="t1668854856" t="ikitommi merged the :enum &amp; := type-inferrer with transformers into master. So, this works now: (m/decode [:map [:enum1 [:enum :kikka :kukka]] [:enum2 [:enum &apos;kikka &apos;kukka]] [:enum3 [:enum 1 2]] [:enum4 [:enum 1.1 2.2]]] {:enum1 &quot;kikka&quot; :enum2 &quot;kikka&quot; :enum3 &quot;1&quot; :enum4 &quot;1.1&quot;} (mt/string-transformer)) ;{:enum1 :kikka ; :enum2 kikka ; :enum3 1 ; :enum4 1.1}"><y>#</y><d>2022-11-19</d><h>10:47</h><w>ikitommi</w>merged the <code>:enum</code> &amp; <code>:=</code> type-inferrer with transformers into master. So, this works now:
<pre>(m/decode
 [:map
  [:enum1 [:enum :kikka :kukka]]
  [:enum2 [:enum &apos;kikka &apos;kukka]]
  [:enum3 [:enum 1 2]]
  [:enum4 [:enum 1.1 2.2]]]
 {:enum1 &quot;kikka&quot;
  :enum2 &quot;kikka&quot;
  :enum3 &quot;1&quot;
  :enum4 &quot;1.1&quot;}
 (mt/string-transformer))
;{:enum1 :kikka
; :enum2 kikka
; :enum3 1
; :enum4 1.1}</pre></z><z id="t1668862652" t="rafalw Hi, I&apos;ve started using malli&apos;s function intrumentation for cljs projects, it works great but on error I&apos;m getting &quot;Warning&quot; message in browser&apos;s console, is it posible to make it to be an &quot;error&quot; instead of &quot;warning&quot;?"><y>#</y><d>2022-11-19</d><h>12:57</h><w>rafalw</w>Hi, I&apos;ve started using malli&apos;s function intrumentation for cljs projects, it works great but on error I&apos;m getting &quot;Warning&quot; message in browser&apos;s console, is it posible to make it to be an &quot;error&quot; instead of &quot;warning&quot;?</z><z id="t1668878556" t="dvingo can you post a screenshot? and how are you starting the instrumentation? this is how they look with .cljs/start! https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md#errors-in-the-browser-console"><y>#</y><d>2022-11-19</d><h>17:22</h><r>dvingo</r>can you post a screenshot? and how are you starting the instrumentation?
this is how they look with <code>.cljs/start!</code>
<a href="https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md#errors-in-the-browser-console" target="_blank">https://github.com/metosin/malli/blob/master/docs/clojurescript-function-instrumentation.md#errors-in-the-browser-console</a></z><z id="t1669195540" t="rafalw when its reload (shadow-cljs detects some changes) it&apos;s an warning, when page is refreshed (for example F5) it&apos;s an error"><y>#</y><d>2022-11-23</d><h>09:25</h><r>rafalw</r>when its reload (shadow-cljs detects some changes) it&apos;s an warning, when page is refreshed (for example F5) it&apos;s an error</z><z id="t1669221181" t="dvingo ah, i think this is due to the way shadow-cljs loads cljs code - it uses eval and prevents exceptions from being thrown as they normally do I&apos;ve found the following pattern works to get proper malli exceptions displaying: https://github.com/matterandvoid-space/todomvc-fulcro-subscriptions/blob/766d27be316c3f2ab6a23bd8db30932ec0601a4f/src/main/space/matterandvoid/todomvc/client/dev_entry.cljs#L20"><y>#</y><d>2022-11-23</d><h>16:33</h><r>dvingo</r>ah, i think this is due to the way shadow-cljs loads cljs code - it uses <code>eval</code> and prevents exceptions from being thrown as they normally do
I&apos;ve found the following pattern works to get proper malli exceptions displaying:
<a href="https://github.com/matterandvoid-space/todomvc-fulcro-subscriptions/blob/766d27be316c3f2ab6a23bd8db30932ec0601a4f/src/main/space/matterandvoid/todomvc/client/dev_entry.cljs#L20" target="_blank">https://github.com/matterandvoid-space/todomvc-fulcro-subscriptions/blob/766d27be316c3f2ab6a23bd8db30932ec0601a4f/src/main/space/matterandvoid/todomvc/client/dev_entry.cljs#L20</a></z><z id="t1668872564" t="Danny https://github.com/mfikes/cljs-bean/pull/94"><y>#</y><d>2022-11-19</d><h>15:42</h><w>Danny</w><a href="https://github.com/mfikes/cljs-bean/pull/94" target="_blank">https://github.com/mfikes/cljs-bean/pull/94</a></z><z id="t1668898897" t="aaron51 How can I humanize malli.instrument/instrument! failures? With large data and a large schema, it’s really hard to tell where the problem is from the invalid-input failure"><y>#</y><d>2022-11-19</d><h>23:01</h><w>aaron51</w>How can I humanize <code>malli.instrument/instrument!</code> failures? With large data and a large schema, it’s really hard to tell where the problem is from the <code>invalid-input</code> failure</z><z id="t1668903348" t="aaron51 Maybe I need to pass my own “report” function (defaults to -fail! ) that throws a humanized error?"><y>#</y><d>2022-11-20</d><h>00:15</h><w>aaron51</w>Maybe I need to pass my own “report” function (defaults to <code>-fail!</code>) that throws a humanized error?</z><z id="t1668904142" t="aaron51 Seems like the report function doesn’t receive parameters that can be humanized…"><y>#</y><d>2022-11-20</d><h>00:29</h><r>aaron51</r>Seems like the <code>report</code> function doesn’t receive parameters that can be humanized…</z><z id="t1668935164" t="ikitommi (mx/defn plus [x :- :int, y :- :int] (+ x y)) (mi/instrument! {:report (pretty/reporter)}) (plus &quot;1&quot; &quot;2&quot;)"><y>#</y><d>2022-11-20</d><h>09:06</h><r>ikitommi</r><pre>(mx/defn plus [x :- :int, y :- :int] (+ x y))

(mi/instrument! {:report (pretty/reporter)})

(plus &quot;1&quot; &quot;2&quot;)</pre></z><z id="t1668935185" t="ikitommi"><y>#</y><d>2022-11-20</d><h>09:06</h><r>ikitommi</r></z><z id="t1668935204" t="ikitommi reporter is a function to create it, takes a bunch of optional options."><y>#</y><d>2022-11-20</d><h>09:06</h><r>ikitommi</r>reporter is a function to create it, takes a bunch of optional options.</z><z id="t1668935628" t="ikitommi if you want to throw the humanized (instead of just printing it): (mi/instrument! {:report (pretty/thrower)})"><y>#</y><d>2022-11-20</d><h>09:13</h><r>ikitommi</r>if you want to throw the humanized (instead of just printing it):
<pre>(mi/instrument! {:report (pretty/thrower)})</pre></z><z id="t1668935747" t="ikitommi"><y>#</y><d>2022-11-20</d><h>09:15</h><r>ikitommi</r></z><z id="t1668960084" t="aaron51 Awesome. Thank you!"><y>#</y><d>2022-11-20</d><h>16:01</h><r>aaron51</r>Awesome. Thank you!</z><z id="t1668935424" t="ikitommi malli.provider defaults now to creating real schemas (e.g. :int ) instead of predicate ones (e.g. int? ): (mp/provide [{:a [1 2 3] :b &quot;kikka&quot; :c true} {:a nil :b &quot;kikka&quot; :c &quot;true&quot;}]) ;[:map ; [:a [:maybe [:vector :int]]] ; [:b :string] ; [:c :some]] + also the :some schema."><y>#</y><d>2022-11-20</d><h>09:10</h><w>ikitommi</w><code>malli.provider</code> defaults now to creating real schemas (e.g. <code>:int</code>) instead of predicate ones (e.g. <code>int?</code>):
<pre>(mp/provide [{:a [1 2 3]
              :b &quot;kikka&quot;
              :c true}
             {:a nil
              :b &quot;kikka&quot;
              :c &quot;true&quot;}])
;[:map 
; [:a [:maybe [:vector :int]]] 
; [:b :string] 
; [:c :some]]</pre>
+ also the <code>:some</code> schema.</z><z id="t1669017426" t="Hankstenberg Hi guys, how can I repeat an element of a tuple one or more times? E.g. I&apos;d like to have a tuple: [:tuple :int :string] and only the string part should occur one or more times. When I try :repeat or anything, the strings get wrapped into a vector. Or is there a better way to get a heterogeneous list like [12 &quot;a&quot; &quot;b&quot; &quot;c&quot; ...]?"><y>#</y><d>2022-11-21</d><h>07:57</h><w>Hankstenberg</w>Hi guys, how can I repeat an element of a tuple one or more times? E.g. I&apos;d like to have a tuple: [:tuple :int :string] and only the string part should occur one or more times. When I try :repeat or anything, the strings get wrapped into a vector. Or is there a better way to get a heterogeneous list like [12 &quot;a&quot; &quot;b&quot; &quot;c&quot; ...]?</z><z id="t1669021225" t="ikitommi try: [:cat :int [:+ :string]]"><y>#</y><d>2022-11-21</d><h>09:00</h><r>ikitommi</r>try: <code>[:cat :int [:+ :string]]</code></z><z id="t1669021290" t="Hankstenberg Ah, thank you very much!"><y>#</y><d>2022-11-21</d><h>09:01</h><r>Hankstenberg</r>Ah, thank you very much!</z><z id="t1669045351" t="jeroenvandijk Is there a way to extend a :multi like how clojure.spec allows you to extend a multispec ?"><y>#</y><d>2022-11-21</d><h>15:42</h><w>jeroenvandijk</w>Is there a way to extend  a <code>:multi</code> like how <code>clojure.spec</code> allows you to extend a <code>multispec</code>?</z><z id="t1669045438" t="jeroenvandijk So far I found that all the keys of the :multi need to be in the body at definition. I would like to add entries later."><y>#</y><d>2022-11-21</d><h>15:43</h><r>jeroenvandijk</r>So far I found that all the keys of the <code>:multi</code> need to be in the body at definition. I would like to add entries later.</z><z id="t1669045488" t="jeroenvandijk With a mutable registry and some hackery I can add entries, but it is not very clean"><y>#</y><d>2022-11-21</d><h>15:44</h><r>jeroenvandijk</r>With a mutable registry and some hackery I can add entries, but it is not very clean</z><z id="t1669046178" t="jeroenvandijk I’m looking for something like this where I can register the dispatch type outside of the multi (let [schema [:schema {:registry {:x [:map [:hello :int]]}} [:multi {:dispatch (fn [x] [:ref (:type x)])}]]] (or (-&gt; (m/explain schema {:type :x :hello 1 }) (me/humanize)) :ok)) ;=&gt; [&quot;invalid dispatch value&quot;]"><y>#</y><d>2022-11-21</d><h>15:56</h><r>jeroenvandijk</r>I’m looking for something like this where I can register the dispatch type outside of the multi
<pre>(let [schema [:schema
              {:registry {:x [:map [:hello :int]]}}
              [:multi {:dispatch (fn [x] [:ref (:type x)])}]]]
  (or (-&gt;
       (m/explain schema {:type :x
                          :hello 1
                          })
       (me/humanize))
      :ok)) ;=&gt; [&quot;invalid dispatch value&quot;]</pre></z><z id="t1669046609" t="ikitommi You can use references (strings or qualified keys) in multi body, like with map: [:multi {:dispatch :type} :domain/user :domain/order]"><y>#</y><d>2022-11-21</d><h>16:03</h><r>ikitommi</r>You can use references (strings or qualified keys) in multi body, like with map:
<code>[:multi {:dispatch :type} :domain/user :domain/order]</code></z><z id="t1669046654" t="ikitommi e.g. just reg the impls into registry reference them with the key"><y>#</y><d>2022-11-21</d><h>16:04</h><r>ikitommi</r>e.g.  just reg the impls into registry reference them with the key</z><z id="t1669046669" t="jeroenvandijk Ah I see now. Didn’t try qualified keys"><y>#</y><d>2022-11-21</d><h>16:04</h><r>jeroenvandijk</r>Ah I see now. Didn’t try qualified keys</z><z id="t1669046682" t="ikitommi there is also an example of lazy registry, could be used too: https://github.com/metosin/malli#lazy-registries"><y>#</y><d>2022-11-21</d><h>16:04</h><r>ikitommi</r>there is also an example of lazy registry, could be used too: <a href="https://github.com/metosin/malli#lazy-registries" target="_blank">https://github.com/metosin/malli#lazy-registries</a></z><z id="t1669046815" t="jeroenvandijk But it’s not possible to leave the multi without the key entries, right?"><y>#</y><d>2022-11-21</d><h>16:06</h><r>jeroenvandijk</r>But it’s not possible to leave the multi without the key entries, right?</z><z id="t1669046827" t="jeroenvandijk I want to extend my schema after the first definition"><y>#</y><d>2022-11-21</d><h>16:07</h><r>jeroenvandijk</r>I want to extend my schema after the first definition</z><z id="t1669046881" t="jeroenvandijk So something like (def CloudFormation (m/schema [:multi {:dispatch :Type, :lazy-refs true}] {:registry registry}))"><y>#</y><d>2022-11-21</d><h>16:08</h><r>jeroenvandijk</r>So something like
<pre>(def CloudFormation
  (m/schema
    [:multi {:dispatch :Type, :lazy-refs true}]
    {:registry registry}))</pre></z><z id="t1669046913" t="ikitommi I would be easy to ad a new key e.g. :`methods` into multi, that is used for the lookups. Would that work?"><y>#</y><d>2022-11-21</d><h>16:08</h><r>ikitommi</r>I would be easy to ad a new key e.g. :`methods` into multi, that is used for the lookups. Would that work?</z><z id="t1669046956" t="jeroenvandijk Yeah that would be perfect"><y>#</y><d>2022-11-21</d><h>16:09</h><r>jeroenvandijk</r>Yeah that would be perfect</z><z id="t1669047044" t="jeroenvandijk something like .. :methods (fn [] @*my-schema) And then I would change *my-schema somewhere else, right?"><y>#</y><d>2022-11-21</d><h>16:10</h><r>jeroenvandijk</r>something like
<pre>.. :methods (fn [] @*my-schema)</pre>
And then I would change <code>*my-schema</code> somewhere else, right?</z><z id="t1669047103" t="jeroenvandijk I think this would more or less cover what multispec can do"><y>#</y><d>2022-11-21</d><h>16:11</h><r>jeroenvandijk</r>I think this would more or less cover what multispec can do</z><z id="t1669047171" t="ikitommi Please write a PR"><y>#</y><d>2022-11-21</d><h>16:12</h><r>ikitommi</r>Please write a PR</z><z id="t1669047179" t="jeroenvandijk Yep, thanks"><y>#</y><d>2022-11-21</d><h>16:12</h><r>jeroenvandijk</r>Yep, thanks</z><z id="t1669128640" t="ikitommi [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] I meant an Issue is enough 🙂"><y>#</y><d>2022-11-22</d><h>14:50</h><r>ikitommi</r><a>@U0FT7SRLP</a> I meant an Issue is enough <b>🙂</b></z><z id="t1669196164" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] 😅 I actually tried to implement your suggestion by adding a :methods option. And it works, but after the schema is loaded it doesn&apos;t revaluate when the state/multimethod updates. Ill create an issue with an explanation and push what i have so far in a separate draft PR"><y>#</y><d>2022-11-23</d><h>09:36</h><r>jeroenvandijk</r><a>@U055NJ5CC</a> <b>😅</b> I actually tried to implement your suggestion by adding a <code>:methods</code> option. And it works, but after the schema is loaded it doesn&apos;t revaluate when the state/multimethod updates. Ill create an issue with an explanation and push what i have so far in a separate draft PR</z><z id="t1669201602" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I created an Issue https://github.com/metosin/malli/issues/786 and the :methods experiment is in https://github.com/metosin/malli/issues/787"><y>#</y><d>2022-11-23</d><h>11:06</h><r>jeroenvandijk</r><a>@U055NJ5CC</a> I created an Issue <a href="https://github.com/metosin/malli/issues/786" target="_blank">https://github.com/metosin/malli/issues/786</a> and the <code>:methods</code> experiment is in <a href="https://github.com/metosin/malli/issues/787" target="_blank">https://github.com/metosin/malli/issues/787</a></z><z id="t1669107657" t="Hankstenberg What is the best way to tell if a given string is a valid malli schema? As I understand it this is a two-step process... first I need to determine if it&apos;s valid edn data and in a second step I have to determine if it&apos;s a valid malli schema. There is a schema called &quot;`:schema` &quot; in malli.core/base-schemas , but how do I use it properly?"><y>#</y><d>2022-11-22</d><h>09:00</h><w>Hankstenberg</w>What is the best way to tell if a given string is a valid malli schema? As I understand it this is a two-step process... first I need to determine if it&apos;s valid edn data and in a second step I have to determine if it&apos;s a valid malli schema. There is a schema called &quot;`:schema` &quot; in <code>malli.core/base-schemas</code> , but how do I use it properly?</z><z id="t1669107722" t="ikitommi valid string like &quot;[:enum :kikka :kukka]&quot; ?"><y>#</y><d>2022-11-22</d><h>09:02</h><r>ikitommi</r>valid string like  <code>&quot;[:enum :kikka :kukka]&quot;</code>?</z><z id="t1669107878" t="Hankstenberg Well the idea is that the user provides a schema definition and I want to check if it&apos;s a valid malli schema, so something like &quot;[:cat :int]&quot;, anything that can be turned into a schema with m/schema in the current context should be valid, everthing else I&apos;d like to give proper error messages on."><y>#</y><d>2022-11-22</d><h>09:04</h><r>Hankstenberg</r>Well the idea is that the user provides a schema definition and I want to check if it&apos;s a valid malli schema, so something like &quot;[:cat :int]&quot;, anything that can be turned into a schema with m/schema in the current context should be valid, everthing else I&apos;d like to give proper error messages on.</z><z id="t1669107907" t="Hankstenberg I&apos;d like to humanize the output of &quot;trying to use the input as a malli schema&quot;."><y>#</y><d>2022-11-22</d><h>09:05</h><r>Hankstenberg</r>I&apos;d like to humanize the output of &quot;trying to use the input as a malli schema&quot;.</z><z id="t1669107935" t="ikitommi without humanizing: (malli.edn/read-string &quot;[:enum :kikka :kukka]&quot;) ; =&gt; [:enum :kikka :kukka] (malli.edn/read-string &quot;[:enumz :kikka :kukka]&quot;) ; =throws=&gt; :malli.core/invalid-schema {:schema :enumz}"><y>#</y><d>2022-11-22</d><h>09:05</h><r>ikitommi</r>without humanizing:
<pre>(malli.edn/read-string &quot;[:enum :kikka :kukka]&quot;)
; =&gt; [:enum :kikka :kukka]

(malli.edn/read-string &quot;[:enumz :kikka :kukka]&quot;)
; =throws=&gt; :malli.core/invalid-schema {:schema :enumz}</pre></z><z id="t1669108010" t="Hankstenberg Yea, but is there a meta-schema for a malli schema? I thought it was maybe malli.core/base-schema/:schema"><y>#</y><d>2022-11-22</d><h>09:06</h><r>Hankstenberg</r>Yea, but is there a meta-schema for a malli schema? I thought it was maybe malli.core/base-schema/:schema</z><z id="t1669108192" t="Hankstenberg It&apos;s got to be something that me/read-string does under the hood."><y>#</y><d>2022-11-22</d><h>09:09</h><r>Hankstenberg</r>It&apos;s got to be something that me/read-string does under the hood.</z><z id="t1669110543" t="ikitommi there is no Malli Schema for Malli Schemas. There is support for it (each schema can define it&apos;s supported properties &amp; schema for children), but no-one has had time to actually describe those."><y>#</y><d>2022-11-22</d><h>09:49</h><r>ikitommi</r>there is no Malli Schema for Malli Schemas. There is support for it (each schema can define it&apos;s supported properties &amp; schema for children), but no-one has had time to actually describe those.</z><z id="t1669110578" t="Hankstenberg Okay good to know, thanks! 🙂"><y>#</y><d>2022-11-22</d><h>09:49</h><r>Hankstenberg</r>Okay good to know, thanks! <b>🙂</b></z><z id="t1669279969" t="hanDerPeder whats the point of having -update and -comp in malli.core? -comp unrolls more arities than clojure.core/comp , so I&apos;m guessing it&apos;s a perf thing. But -update is the same as 3-arity clojure.core/update ."><y>#</y><d>2022-11-24</d><h>08:52</h><w>hanDerPeder</w>whats the point of having <code>-update</code> and <code>-comp</code> in malli.core? <code>-comp</code> unrolls more arities than <code>clojure.core/comp</code>, so I&apos;m guessing it&apos;s a perf thing. But <code>-update</code> is the same as 3-arity <code>clojure.core/update</code>.</z><z id="t1669280764" t="ikitommi yeah, -comp is a perf thing, -update … can’t recall. looks like it’s not that useful atm."><y>#</y><d>2022-11-24</d><h>09:06</h><r>ikitommi</r>yeah, <code>-comp</code> is a perf thing, <code>-update</code>… can’t recall. looks like it’s not that useful atm.</z><z id="t1669299683" t="vemv Have you seen this error message while running a Malli-based codebase through Cloverage? No implementation of method: :-type of protocol: #&apos;malli.core/IntoSchema found for class: clojure.lang.PersistentList don&apos;t know how to fix that"><y>#</y><d>2022-11-24</d><h>14:21</h><w>vemv</w>Have you seen this error message while running a Malli-based codebase through Cloverage?

<pre>No implementation of method: :-type of protocol: #&apos;malli.core/IntoSchema found for class: clojure.lang.PersistentList</pre>
don&apos;t know how to fix that</z><z id="t1669300162" t="vemv ...I fixed it by commenting out these lines we had: ^{:type ::m/into-schema} that pattern was sort of mindlessly copied from the Malli impl. What does it intend to do? Is it safe for us to remove?"><y>#</y><d>2022-11-24</d><h>14:29</h><w>vemv</w>...I fixed it by commenting out these lines we had: <code>^{:type ::m/into-schema}</code>

that pattern was sort of mindlessly copied from the Malli impl. What does it intend to do? Is it safe for us to remove?</z><z id="t1669308605" t="ikitommi it&apos;s safe to remove. It&apos;s only used for pretty printing the the reified this."><y>#</y><d>2022-11-24</d><h>16:50</h><w>ikitommi</w>it&apos;s safe to remove. It&apos;s only used for pretty printing the the reified this.</z><z id="t1669310122" t="vemv thanks! out of curiosity, do you have a sense of why that particular error is triggered? Does overriding ^:type have some sort of code-evaluation semantic to the clj compiler? Otherwise :type ::m/into-schema seems fairly &apos;inoccuous&apos; to me, I don&apos;t see how it can trigger this issue"><y>#</y><d>2022-11-24</d><h>17:15</h><r>vemv</r>thanks! out of curiosity, do you have a sense of why that particular error is triggered?

Does overriding <code>^:type</code> have some sort of code-evaluation semantic to the clj compiler?

Otherwise <code>:type ::m/into-schema</code> seems fairly &apos;inoccuous&apos; to me, I don&apos;t see how it can trigger this issue</z><z id="t1669410794" t="dharrigan Better here I think: Got a small PR for consideration "><y>#</y><d>2022-11-25</d><h>21:13</h><w>dharrigan</w>Better here I think: Got a small PR for consideration <code></code></z><z id="t1669818059" t="dharrigan Thank you [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] for merging in this small PR. I hope others may find it benefical too 🙂"><y>#</y><d>2022-11-30</d><h>14:20</h><r>dharrigan</r>Thank you <a>@U055NJ5CC</a> for merging in this small PR. I hope others may find it benefical too <b>🙂</b></z><z id="t1669459765" t="ikitommi what bad can happen if we add a mutable schema type? 🙈 https://github.com/metosin/malli/issues/786#issuecomment-1328020448"><y>#</y><d>2022-11-26</d><h>10:49</h><w>ikitommi</w>what bad can happen if we add a mutable schema type? <b>🙈</b> <a href="https://github.com/metosin/malli/issues/786#issuecomment-1328020448" target="_blank">https://github.com/metosin/malli/issues/786#issuecomment-1328020448</a></z><z id="t1669461713" t="pithyless &gt; Just because we can, doesn&apos;t mean we should. 🙈 I feel if this was an issue posted on Clojure JIRA, it would require a lot more burden of proof on the poster to argue why this is really necessary, what are the practical use-cases that can&apos;t be solved otherwise, and whether the pros overcome all the cons (and future maintenance/compatibility). For example, is breaking the validate/validator referential transparency something we want to be doing so easily? Feels like a slippery slope... I don&apos;t have a dog in this fight, I don&apos;t really feel the pain of the original poster, but I&apos;d argue prudence: maybe we should move this idea to an independent malli extension library until it shows its usefulness. Otherwise it will be hard to remove if it goes into malli-core and people depend on it. :)"><y>#</y><d>2022-11-26</d><h>11:21</h><r>pithyless</r>&gt; Just because we can, doesn&apos;t mean we should. <b>🙈</b> 
I feel if this was an issue posted on Clojure JIRA, it would require a lot more burden of proof on the poster to argue why this is really necessary, what are the practical use-cases that can&apos;t be solved otherwise, and whether the pros overcome all the cons (and future maintenance/compatibility).

For example, is breaking the <code>validate/validator</code> referential transparency something we want to be doing so easily? Feels like a slippery slope...

I don&apos;t have a dog in this fight, I don&apos;t really feel the pain of the original poster, but I&apos;d argue prudence: maybe we should move this idea to an independent malli extension library until it shows its usefulness. Otherwise it will be hard to remove if it goes into malli-core and people depend on it. :)</z><z id="t1669468235" t="ikitommi I agree it should not be part of the core. I had a use-case in a project with custom reference types, where this might have been useful, not 100% sure. For the “hard to remove later”, there are some escape hatches https://github.com/metosin/malli#alpha : &gt; • extender API: public vars, name starts with - , e.g. malli.core/-collection-schema . Not needed with basic use cases, might evolve during the alpha, follow https://github.com/metosin/malli/blob/master/CHANGELOG.md for details &gt; • experimental: stuff in malli.experimental ns, code might change be moved under a separate support library, but you can always copy the old implementation to your project, so ok to use. maybe malli.experimental.mutable :thinking_face: (NOTE: just added the experimental documentation to README)"><y>#</y><d>2022-11-26</d><h>13:10</h><r>ikitommi</r>I agree it should not be part of the core. I had a use-case in a project with custom reference types, where this might have been useful, not 100% sure. For the “hard to remove later”, there are some escape hatches <a href="https://github.com/metosin/malli#alpha" target="_blank">https://github.com/metosin/malli#alpha</a>:
&gt; • extender API: public vars, name starts with <code>-</code>, e.g. <code>malli.core/-collection-schema</code>. Not needed with basic use cases, might evolve during the alpha, follow <a href="https://github.com/metosin/malli/blob/master/CHANGELOG.md" target="_blank">https://github.com/metosin/malli/blob/master/CHANGELOG.md</a> for details
&gt; • experimental: stuff in <code>malli.experimental</code> ns, code might change be moved under a separate support library, but you can always copy the old implementation to your project, so ok to use.
maybe <code>malli.experimental.mutable</code> <b>:thinking_face:</b>
(NOTE: just added the experimental documentation to README)</z><z id="t1669469740" t="ikitommi oh, as the normal schemas capture forms eagerly, the whole parent-schema tree should be mutable to keep the child mutable. Not going to change all schemas to be lazy because of this."><y>#</y><d>2022-11-26</d><h>13:35</h><r>ikitommi</r>oh, as the normal schemas capture forms eagerly, the whole parent-schema tree should be mutable to keep the child mutable. Not going to change all schemas to be lazy because of this.</z><z id="t1669469807" t="ikitommi mutable = evil. thanks."><y>#</y><d>2022-11-26</d><h>13:36</h><r>ikitommi</r>mutable = evil. thanks.</z><z id="t1669470357" t="ikitommi (deftest schema-test (let [!schema (atom :int) mutable (mem/schema (fn [options] (m/schema @!schema options))) mutable-schema (mem/schema (fn [options] (m/schema [:map [:mutable mutable]] options))) immutable-schema (m/schema [:map [:mutable mutable]])] (testing &quot;initial schema form&quot; (is (= [:map [:mutable :int]] (m/form mutable-schema) (m/form immutable-schema)))) (testing &quot;mutating schema&quot; (reset! !schema [:enum &quot;so&quot; &quot;mutable&quot;])) (testing &quot;mutable schema changed ok&quot; (is (= [:map [:mutable [:enum &quot;so&quot; &quot;mutable&quot;]]] (m/form mutable-schema)))) (testing &quot;immutable schema captured the orginal form&quot; (is (= [:map [:mutable :int]] (m/form immutable-schema))) (testing &quot;but workers see the mutated schema&quot; (is (true? (m/validate immutable-schema {:mutable &quot;so&quot;})))) (testing &quot;mutating schema again&quot; (reset! !schema :boolean)) (testing &quot;form is still from the original value&quot; (is (= [:map [:mutable :int]] (m/form immutable-schema)))) (testing &quot;validator is cached from the second value&quot; (is (true? (m/validate immutable-schema {:mutable &quot;so&quot;})))) (testing &quot;explainer is cached with the third value&quot; (is (nil? (m/explain immutable-schema {:mutable true})))) (testing &quot;conclusion&quot; (is (not= &quot;mutable&quot; &quot;good idea&quot;))))))"><y>#</y><d>2022-11-26</d><h>13:45</h><r>ikitommi</r><pre>(deftest schema-test
  (let [!schema (atom :int)
        mutable (mem/schema (fn [options] (m/schema @!schema options)))
        mutable-schema (mem/schema (fn [options] (m/schema [:map [:mutable mutable]] options)))
        immutable-schema (m/schema [:map [:mutable mutable]])]

    (testing &quot;initial schema form&quot;
      (is (= [:map [:mutable :int]]
             (m/form mutable-schema)
             (m/form immutable-schema))))

    (testing &quot;mutating schema&quot;
      (reset! !schema [:enum &quot;so&quot; &quot;mutable&quot;]))

    (testing &quot;mutable schema changed ok&quot;
      (is (= [:map [:mutable [:enum &quot;so&quot; &quot;mutable&quot;]]]
             (m/form mutable-schema))))

    (testing &quot;immutable schema captured the orginal form&quot;
      (is (= [:map [:mutable :int]]
             (m/form immutable-schema)))

      (testing &quot;but workers see the mutated schema&quot;
        (is (true? (m/validate immutable-schema {:mutable &quot;so&quot;}))))

      (testing &quot;mutating schema again&quot;
        (reset! !schema :boolean))

      (testing &quot;form is still from the original value&quot;
        (is (= [:map [:mutable :int]] (m/form immutable-schema))))

      (testing &quot;validator is cached from the second value&quot;
        (is (true? (m/validate immutable-schema {:mutable &quot;so&quot;}))))

      (testing &quot;explainer is cached with the third value&quot;
        (is (nil? (m/explain immutable-schema {:mutable true}))))

      (testing &quot;conclusion&quot;
        (is (not= &quot;mutable&quot; &quot;good idea&quot;))))))</pre></z><z id="t1669639672" t="jeroenvandijk [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks for trying to come up with a solution for #786. I’m reading your conclusion now 😅 Too bad"><y>#</y><d>2022-11-28</d><h>12:47</h><r>jeroenvandijk</r><a>@U055NJ5CC</a> Thanks for trying to come up with a solution for #786. I’m reading your conclusion now <b>😅</b> Too bad</z><z id="t1669639760" t="jeroenvandijk I’ll create something internally and see how this goes. I do have use cases for this / multispec, but I can understand it might not be compatible with Malli’s design"><y>#</y><d>2022-11-28</d><h>12:49</h><r>jeroenvandijk</r>I’ll create something internally and see how this goes. I do have use cases for this / multispec, but I can understand it might not be compatible with Malli’s design</z><z id="t1669640491" t="jeroenvandijk Inspired by your example [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] , the following can work for me too (defn multimethod-schema [mm] (let [dispatch (.dispatchFn mm)] (m/into-schema :multi {:dispatch dispatch} (map (fn [[type f]] [type (f {dispatch type})]) (methods mm))))) (defmulti mm-example :Type) (def mm-schema (if (= (System/getenv &quot;ENV&quot;) &quot;PRODUCTION&quot;) (constantly (multimethod-schema mm-example)) (fn [] (multimethod-schema mm-example)))) (defn valid? [x] (m/validate (mm-schema) x)) (valid? {:Type :x}) ;=&gt; false (defmethod mm-example :x [_] [:map [:Type [:= :x]]]) (valid? {:Type :x}) ;=&gt; true"><y>#</y><d>2022-11-28</d><h>13:01</h><r>jeroenvandijk</r>Inspired by your example <a>@U055NJ5CC</a>, the following can work for me too
<pre>(defn multimethod-schema [mm]
  (let [dispatch (.dispatchFn mm)]
    (m/into-schema
     :multi
     {:dispatch dispatch}
     (map (fn [[type f]] [type (f {dispatch type})]) (methods mm)))))

(defmulti mm-example :Type)   
     
(def mm-schema 
  (if (= (System/getenv &quot;ENV&quot;) &quot;PRODUCTION&quot;)
    (constantly (multimethod-schema mm-example))
    (fn [] (multimethod-schema mm-example))))

 (defn valid? [x]
   (m/validate (mm-schema) x))

(valid? {:Type :x}) ;=&gt; false

(defmethod mm-example :x [_]
  [:map [:Type [:= :x]]])

(valid? {:Type :x}) ;=&gt; true</pre></z><z id="t1669640538" t="jeroenvandijk I don’t think I need much more than this, let’s see"><y>#</y><d>2022-11-28</d><h>13:02</h><r>jeroenvandijk</r>I don’t think I need much more than this, let’s see</z><z id="t1669640561" t="ikitommi that works, unless you wrap it in another schema, .e.g [:map [:mm (mm-schema)]]"><y>#</y><d>2022-11-28</d><h>13:02</h><r>ikitommi</r>that works, unless you wrap it in another schema, .e.g <code>[:map [:mm (mm-schema)]]</code></z><z id="t1669640584" t="ikitommi there, :map eagerly creates the form from the current snapshot value."><y>#</y><d>2022-11-28</d><h>13:03</h><r>ikitommi</r>there, <code>:map</code> eagerly creates the form from the current snapshot value.</z><z id="t1669640678" t="ikitommi I think it would be possible (and a good idea!) to be able to disable all caching in malli via an option, e.g. a dev-mode. would allow one to shoot him/her in the leg in new, imaginary ways. But, would also allow a “expected” repl experience, that could be turned of in normal/prod mode."><y>#</y><d>2022-11-28</d><h>13:04</h><r>ikitommi</r>I think it would be possible (and a good idea!) to be able to disable all caching in malli via an option, e.g. a dev-mode. would allow one to shoot him/her in the leg in new, imaginary ways. But, would also allow a “expected” repl experience, that could be turned of in normal/prod mode.</z><z id="t1669640875" t="ikitommi I think it would also clean up malli internals a lot if all caching would happen via the Cached protocol. swapping it’s impl would be trivial after that. so: 1. refactor malli-interanl caching to always use Cached 2. allow disabling caching via an option 3. welcome (optional) mutability for people who don’t have enough troubles already - or they know what they are doing 😎 "><y>#</y><d>2022-11-28</d><h>13:07</h><r>ikitommi</r>I think it would also clean up malli internals a lot if all caching would happen via the <code>Cached</code> protocol. swapping it’s impl would be trivial after that. so:
1. refactor malli-interanl caching to always use <code>Cached</code> 
2. allow disabling caching via an option
3. welcome (optional) mutability for people who don’t have enough troubles already - or they know what they are doing <b>😎</b> </z><z id="t1669640910" t="ikitommi I can give it a shot at some point, interested in seeing if 1 would be a good idea."><y>#</y><d>2022-11-28</d><h>13:08</h><r>ikitommi</r>I can give it a shot at some point, interested in seeing if 1 would be a good idea.</z><z id="t1669641087" t="jeroenvandijk Yeah interesting. To be honest I haven’t used all the features/optimizations of Malli yet. So I can’t judge how far such a change would impact things. I have been viewing Malli naively as an optimized, data oriented version of clojure.spec, but this of course has it’s own tradeoffs. I’m happy to burn myself with the above trick and report later how bad it was 😅"><y>#</y><d>2022-11-28</d><h>13:11</h><r>jeroenvandijk</r>Yeah interesting. To be honest I haven’t used all the features/optimizations of Malli yet. So I can’t judge how far such a change would impact things. I have been viewing Malli naively as an optimized, data oriented version of clojure.spec, but this of course has it’s own tradeoffs. I’m happy to burn myself with the above trick and report later how bad it was <b>😅</b></z><z id="t1669660456" t="jeroenvandijk Btw, I find the :multi construct very powerful. It’s also a nice tool to make the error messages very precise. I already adapted the multispec sugar to something custom to accomodate more precise errors. So maybe a generic multispec thing is not that useful after all. But I believe the option to disable caching for parts of the schema remains interesting. For now though performance is not my main concern"><y>#</y><d>2022-11-28</d><h>18:34</h><r>jeroenvandijk</r>Btw, I find the <code>:multi</code> construct very powerful. It’s also a nice tool to make the error messages very precise. I already adapted the multispec sugar to something custom to accomodate more precise errors. So maybe a generic multispec thing is not that useful after all. But I believe the option to disable caching for parts of the schema remains interesting. For now though performance is not my main concern</z><z id="t1669547992" t="Carlo Is there a way to make :tuple accept lists, instead of vectors? What&apos;s the default way to spec a list?"><y>#</y><d>2022-11-27</d><h>11:19</h><w>Carlo</w>Is there a way to make <code>:tuple</code> accept lists, instead of vectors? What&apos;s the default way to spec a list?</z><z id="t1669550187" t="Carlo I see that :cat takes a {:type :list} argument. I&apos;m using this for the time being."><y>#</y><d>2022-11-27</d><h>11:56</h><r>Carlo</r>I see that <code>:cat</code> takes a <code>{:type :list}</code> argument. I&apos;m using this for the time being.</z><z id="t1669572785" t="ikitommi yes, :cat should accept all sequences, don’t think the :type hint does anything there. Would like to implement https://github.com/metosin/malli/issues/264 in near future, with that malli would understand the :type tags."><y>#</y><d>2022-11-27</d><h>18:13</h><r>ikitommi</r>yes, <code>:cat</code> should accept all sequences, don’t think the <code>:type</code> hint does anything there. Would like to implement <a href="https://github.com/metosin/malli/issues/264" target="_blank">https://github.com/metosin/malli/issues/264</a> in near future, with that malli would understand the <code>:type</code> tags.</z><z id="t1669662973" t="mike_ananev Hi, there. I’m little bit confused how to transform schema to real Swagger2 structure, from example https://github.com/metosin/malli#swagger2 ? I want to write message specs using Malli and generate some artefacts for other teams which use Golang or Java. I’m trying to figure out how to do this? I’ve implemented Malli Spec -&gt; JSON Schema, but wanna use Swagger or Protobuf. The example above is incomplete and I don’t know how to generate real swagger file."><y>#</y><d>2022-11-28</d><h>19:16</h><w>mike_ananev</w>Hi, there. I’m little bit confused how to transform schema to real Swagger2 structure, from example <a href="https://github.com/metosin/malli#swagger2" target="_blank">https://github.com/metosin/malli#swagger2</a> ?
I want to write message specs using Malli and generate some artefacts for other teams which use Golang or Java. I’m trying to figure out how to do this?
I’ve implemented Malli Spec -&gt; JSON Schema, but wanna use Swagger or Protobuf. The example above is incomplete and I don’t know how to generate real swagger file.</z><z id="t1669664755" t="valtteri If you’re describing just data schemas, your swagger documentation would probably be something like { &quot;swagger&quot;: &quot;2.0&quot; &quot;info&quot;: {&quot;title&quot;: &quot;My Title&quot;, &quot;description&quot;: &quot;something&quot;}, &quot;definitions&quot; { &quot;MyObj1&quot;: &lt;your malli-&gt;swagger-output-here&gt;, &quot;MyObj2&quot;: &lt;your malli-&gt;swagger-output-here&gt;, } }"><y>#</y><d>2022-11-28</d><h>19:45</h><r>valtteri</r>If you’re describing just data schemas, your swagger documentation would probably be something like
<pre>{
  &quot;swagger&quot;: &quot;2.0&quot;
  &quot;info&quot;: {&quot;title&quot;: &quot;My Title&quot;, &quot;description&quot;: &quot;something&quot;},
  &quot;definitions&quot; {
    &quot;MyObj1&quot;: &lt;your malli-&gt;swagger-output-here&gt;,
    &quot;MyObj2&quot;: &lt;your malli-&gt;swagger-output-here&gt;,
  }
}</pre></z><z id="t1669664771" t="Ben Sless For swagger you also need data like route and method which isn&apos;t part of the schema. Protobuf support doesn&apos;t exist yet afaik"><y>#</y><d>2022-11-28</d><h>19:46</h><r>Ben Sless</r>For swagger you also need data like route and method which isn&apos;t part of the schema.
Protobuf support doesn&apos;t exist yet afaik</z><z id="t1669664835" t="valtteri AFAIK swagger had slight (annoying) differences compared to JSON schema :thinking_face:"><y>#</y><d>2022-11-28</d><h>19:47</h><r>valtteri</r>AFAIK swagger had slight (annoying) differences compared to JSON schema <b>:thinking_face:</b></z><z id="t1669664880" t="valtteri But anyways, as Ben said, Swagger doesn’t bring much (any) value if you’re just describing data. JSON schema should do the trick."><y>#</y><d>2022-11-28</d><h>19:48</h><r>valtteri</r>But anyways, as Ben said, Swagger doesn’t bring much (any) value if you’re just describing data. JSON schema should do the trick.</z><z id="t1669664921" t="valtteri There are JSON schema libs for Java and Go"><y>#</y><d>2022-11-28</d><h>19:48</h><r>valtteri</r>There are JSON schema libs for Java and Go</z><z id="t1669665676" t="mike_ananev Ok, thank you. Got it! It would be good to transform Malli specs to Protobuf 3 schemas cause many teams use gRPC."><y>#</y><d>2022-11-28</d><h>20:01</h><r>mike_ananev</r>Ok, thank you. Got it!
It would be good to transform Malli specs to Protobuf 3 schemas cause many teams use gRPC.</z><z id="t1669667793" t="Ben Sless Tell them distributed objects are bad or wait until I get to PR it to malli? 🙃"><y>#</y><d>2022-11-28</d><h>20:36</h><r>Ben Sless</r>Tell them distributed objects are bad or wait until I get to PR it to malli? <b>🙃</b></z><z id="t1669738057" t="Akiz Hi, I use ‘Malli’ for ‘route data validation’. My problem is that when I validate a large structure and get an error, the output to Emacs and REPL is very slow (other IDEs don’t have this problem), I have to wait several minutes before I can work again (the error output has ~10000 lines). I was thinking of shortening the error somehow, but I have no clear idea how. Has somebody here solved a similar problem?"><y>#</y><d>2022-11-29</d><h>16:07</h><w>Akiz</w>Hi, I use ‘Malli’ for ‘route data validation’.
My problem is that when I validate a large structure and get an error, the output to Emacs and REPL is very slow (other IDEs don’t have this problem), I have to wait several minutes before I can work again (the error output has ~10000 lines).
I was thinking of shortening the error somehow, but I have no clear idea how. Has somebody here solved a similar problem?</z><z id="t1669738706" t="respatialized malli.error/humanize can reduce the error size, but I&apos;m not sure if you&apos;ve already tried that or if it will suffice for your problem."><y>#</y><d>2022-11-29</d><h>16:18</h><r>respatialized</r><code>malli.error/humanize</code> can reduce the error size, but I&apos;m not sure if you&apos;ve already tried that or if it will suffice for your problem.</z><z id="t1669738733" t="NoahTheDuke how are you performing the validation? could you do something like (assert (m/validate X Schema) (-&gt; X (m/explain Schema) (me/humanize))) ?"><y>#</y><d>2022-11-29</d><h>16:18</h><r>NoahTheDuke</r>how are you performing the validation? could you do something like <code>(assert (m/validate X Schema) (-&gt; X (m/explain Schema) (me/humanize)))</code>?</z><z id="t1669738844" t="respatialized a more general purpose solution might be to defer your error logging to an async logging library like https://github.com/BrunoBonacci/mulog , which provides a ring buffer mechanism that you can hook into with custom transformation functions to output errors and logs that narrow down to the specific thing you&apos;re trying to investigate."><y>#</y><d>2022-11-29</d><h>16:20</h><r>respatialized</r>a more general purpose solution might be to defer your error logging to an async logging library like <a href="https://github.com/BrunoBonacci/mulog" target="_blank">https://github.com/BrunoBonacci/mulog</a>, which provides a ring buffer mechanism that you can hook into with custom transformation functions to output errors and logs that narrow down to the specific thing you&apos;re trying to investigate.</z><z id="t1669738862" t="Akiz I forgot to tell that humanization doesnt work for me.. for unknown reason, this is my coercion in reitit-hander. It would probably help a lot. (r.coercion.malli/create (-&gt; r.coercion.malli/default-options (assoc :strip-extra-keys true) (update :error-keys #(conj % :humanized))))"><y>#</y><d>2022-11-29</d><h>16:21</h><r>Akiz</r>I forgot to tell that humanization doesnt work for me.. for unknown reason, this is my coercion in reitit-hander. It would probably help a lot.
<pre>(r.coercion.malli/create (-&gt; r.coercion.malli/default-options                                                                          (assoc :strip-extra-keys true)                                                                   (update :error-keys #(conj % :humanized))))</pre></z><z id="t1669739097" t="Akiz [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] i use timbre currently, but i would like to solve that problem on malli / emacs level first."><y>#</y><d>2022-11-29</d><h>16:24</h><r>Akiz</r><a>@UFTRLDZEW</a> i use timbre currently, but i would like to solve that problem on malli / emacs level first.</z><z id="t1669739649" t="ikitommi several minutes 🙀"><y>#</y><d>2022-11-29</d><h>16:34</h><r>ikitommi</r>several minutes <b>🙀</b></z><z id="t1669739664" t="Akiz Oh, the error is not related to reitit coercion. It is invalid return output value…"><y>#</y><d>2022-11-29</d><h>16:34</h><r>Akiz</r>Oh, the error is not related to reitit coercion.
It is invalid return output value…</z><z id="t1669739715" t="Akiz [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Yeah, vscode got it in second."><y>#</y><d>2022-11-29</d><h>16:35</h><r>Akiz</r><a>@U055NJ5CC</a> Yeah, vscode got it in second.</z><z id="t1669739744" t="ikitommi do you have the pretty printing turned on?"><y>#</y><d>2022-11-29</d><h>16:35</h><r>ikitommi</r>do you have the pretty printing turned on?</z><z id="t1669739777" t="ikitommi the colored outputs can be slow, dunno if there is a bug in rendering, fipp is supposed to be fast."><y>#</y><d>2022-11-29</d><h>16:36</h><r>ikitommi</r>the colored outputs can be slow, dunno if there is a bug in rendering, fipp is supposed to be fast.</z><z id="t1669739817" t="ikitommi but, not an emacs user (anymore), so not sure what happends there, if calva is fast with the same case."><y>#</y><d>2022-11-29</d><h>16:36</h><r>ikitommi</r>but, not an emacs user (anymore), so not sure what happends there, if calva is fast with the same case.</z><z id="t1669740073" t="Akiz Did you switch to vscode? Yeah, i do, i will try to disable it, thanks. Is there some easy way for instrumented fns to produce only humanized errors?"><y>#</y><d>2022-11-29</d><h>16:41</h><r>Akiz</r>Did you switch to vscode?
Yeah, i do, i will try to disable it, thanks.
Is there some easy way for instrumented fns to produce only humanized errors?</z><z id="t1669743113" t="Akiz • disabling pretty/reporter for instrumentation helped a lot.. closing other windows in emacs as well 😄 . "><y>#</y><d>2022-11-29</d><h>17:31</h><r>Akiz</r>• disabling pretty/reporter for instrumentation helped a lot.. closing other windows in emacs as well <b>😄</b>. </z><z id="t1669741103" t="Ben Sless Regarding providing protobuf schema from malli, what do you think about defining a data representation for the protobuf spec (even as an external dependency), then defining the transformation from malli to it? I hate protobuf but it could be useful There are also limitations to account for, like oneOf can&apos;t be repeated, which make me pull my hair out"><y>#</y><d>2022-11-29</d><h>16:58</h><w>Ben Sless</w>Regarding providing protobuf schema from malli, what do you think about defining a data representation for the protobuf spec (even as an external dependency), then defining the transformation from malli to it?
I hate protobuf but it could be useful
There are also limitations to account for, like oneOf can&apos;t be repeated, which make me pull my hair out</z><z id="t1669799605" t="dharrigan I&apos;m wondering, when invoking (mg/generate schema) , if the schema contains something like [:enabled {:default true} :boolean] , can the generate always use the default value, rather than flipping between true and false?"><y>#</y><d>2022-11-30</d><h>09:13</h><w>dharrigan</w>I&apos;m wondering, when invoking <code>(mg/generate schema)</code>, if the schema contains something like <code>[:enabled {:default true} :boolean]</code>, can the generate always use the default value, rather than flipping between true and false?</z><z id="t1669800029" t="jeroenvandijk I think you could do [:enabled {:gen/elements [true]}] Maybe I’m wrong, https://github.com/metosin/malli#value-generation"><y>#</y><d>2022-11-30</d><h>09:20</h><r>jeroenvandijk</r>I think you could do <code>[:enabled {:gen/elements [true]}]</code>  Maybe I’m wrong, <a href="https://github.com/metosin/malli#value-generation" target="_blank">https://github.com/metosin/malli#value-generation</a></z><z id="t1669800099" t="dharrigan oohh.. trying..."><y>#</y><d>2022-11-30</d><h>09:21</h><r>dharrigan</r>oohh.. trying...</z><z id="t1669800204" t="dharrigan Yup, that works. ta! 🙂"><y>#</y><d>2022-11-30</d><h>09:23</h><r>dharrigan</r>Yup, that works. ta! <b>🙂</b></z><z id="t1669838449" t="dharrigan I&apos;m a little confused as to where optional sits in a schema. It&apos;s not immediately clear in the documentation. Is this [:map [:name {:optional true} :string] same as [:map [:name [:string {:optional true}]]] ?"><y>#</y><d>2022-11-30</d><h>20:00</h><w>dharrigan</w>I&apos;m a little confused as to where <code>optional</code> sits in a schema. It&apos;s not immediately clear in the documentation. Is this <code>[:map [:name {:optional true} :string]</code> same as <code>[:map [:name [:string {:optional true}]]]</code>?</z><z id="t1669839539" t="Chris O’Donnell I don&apos;t think so. Pretty sure :optional needs to be a parameter of the map key entry."><y>#</y><d>2022-11-30</d><h>20:18</h><r>Chris O’Donnell</r>I don&apos;t think so. Pretty sure <code>:optional</code> needs to be a parameter of the map key entry.</z><z id="t1669839544" t="Chris O’Donnell (The former)"><y>#</y><d>2022-11-30</d><h>20:19</h><r>Chris O’Donnell</r>(The former)</z><z id="t1669839570" t="NoahTheDuke i believe that the position of the {} is supposed to look like metadata on the following object"><y>#</y><d>2022-11-30</d><h>20:19</h><r>NoahTheDuke</r>i believe that the position of the <code>{}</code> is supposed to look like metadata on the following object</z><z id="t1669839605" t="NoahTheDuke so [:map [:name :string]] and then with the optional &quot;metadata&quot;/params [:map [:name {:optional true} :string]]"><y>#</y><d>2022-11-30</d><h>20:20</h><r>NoahTheDuke</r>so <code>[:map [:name :string]]</code> and then with the optional &quot;metadata&quot;/params <code>[:map [:name {:optional true} :string]]</code></z><z id="t1669839772" t="dharrigan I see, so, [:map [:name {:optional true}]] means the name is optional. Then if I have [:map [:name {:optional true} [:string {:min 1 :max 4}]]] , then it&apos;s not only optional, but I&apos;ve also said that the string (if provided) must be between 1 and 4."><y>#</y><d>2022-11-30</d><h>20:22</h><r>dharrigan</r>I see, so, <code>[:map [:name {:optional true}]]</code> means the name is optional. Then if I have <code>[:map [:name {:optional true} [:string {:min 1 :max 4}]]]</code>, then it&apos;s not only optional, but I&apos;ve also said that the string (if provided) must be between 1 and 4.</z><z id="t1669839787" t="dharrigan so the metadata is about the proceeding &quot;thing&quot;"><y>#</y><d>2022-11-30</d><h>20:23</h><r>dharrigan</r>so the metadata is about the proceeding &quot;thing&quot;</z><z id="t1669840031" t="NoahTheDuke ah yeah, it would be the previous thing not the following, as you&apos;ve noted with the {:min 1} example"><y>#</y><d>2022-11-30</d><h>20:27</h><r>NoahTheDuke</r>ah yeah, it would be the previous thing not the following, as you&apos;ve noted with the <code>{:min 1}</code> example</z><z id="t1669840055" t="NoahTheDuke {:optional true} means that the key might not be present, whereas [:maybe X] means the value might not be present"><y>#</y><d>2022-11-30</d><h>20:27</h><r>NoahTheDuke</r><code>{:optional true}</code> means that the key might not be present, whereas <code>[:maybe X]</code> means the value might not be present</z><z id="t1669840141" t="dharrigan 👍"><y>#</y><d>2022-11-30</d><h>20:29</h><r>dharrigan</r><b>👍</b></z><z id="t1670261506" t="escherize Think of it like hiccup: [:div {:style &quot;..red&quot;} [:span ...]] the attributes maps apply to the tags immediately before them"><y>#</y><d>2022-12-05</d><h>17:31</h><r>escherize</r>Think of it like hiccup: <code>[:div {:style &quot;..red&quot;} [:span ...]]</code> the attributes maps apply to the tags immediately before them</z><z id="t1670262627" t="dharrigan 👍"><y>#</y><d>2022-12-05</d><h>17:50</h><r>dharrigan</r><b>👍</b></z><z id="t1670011871" t="Ben Sless How about type variables for https://github.com/metosin/malli/issues/770 ?"><y>#</y><d>2022-12-02</d><h>20:11</h><w>Ben Sless</w>How about type variables for <a href="https://github.com/metosin/malli/issues/770" target="_blank">https://github.com/metosin/malli/issues/770</a>?</z><z id="t1670169759" t="jfntn Not sure I understand, can you give an example?"><y>#</y><d>2022-12-04</d><h>16:02</h><r>jfntn</r>Not sure I understand, can you give an example?</z><z id="t1670170641" t="Ben Sless (map identity xs) is a classic example, identity doesn&apos;t have type any -&gt; any , but a -&gt; a , there&apos;s a clear relation between input and output"><y>#</y><d>2022-12-04</d><h>16:17</h><r>Ben Sless</r><code>(map identity xs)</code> is a classic example, <code>identity</code> doesn&apos;t have type <code>any -&gt; any</code>, but <code>a -&gt; a</code>, there&apos;s a clear relation between input and output</z><z id="t1670170771" t="jfntn Thanks I see what you mean now, but isn’t that orthogonal to that particular issue?"><y>#</y><d>2022-12-04</d><h>16:19</h><r>jfntn</r>Thanks I see what you mean now, but isn’t that orthogonal to that particular issue?</z><z id="t1670173364" t="Ben Sless Partially. How will you write the schema for the higher order function map ?"><y>#</y><d>2022-12-04</d><h>17:02</h><r>Ben Sless</r>Partially. How will you write the schema for the higher order function <code>map</code>?</z><z id="t1670180332" t="jfntn Right, I think I see what you mean now. The instrumentation fn would unify the type variables with the actual values at runtime"><y>#</y><d>2022-12-04</d><h>18:58</h><r>jfntn</r>Right, I think I see what you mean now. The instrumentation fn would unify the type variables with the actual values at runtime</z><z id="t1670021792" t="escherize in prismatic schema, you can use a class with s/defn . Is there a similar approach for mx/defn ? I could check for instance in a [:fn] I suppose"><y>#</y><d>2022-12-02</d><h>22:56</h><w>escherize</w>in prismatic schema, you can use a class with <code>s/defn</code>. Is there a similar approach for <code>mx/defn</code>? I could check for instance in a <code>[:fn]</code> I suppose</z><z id="t1670138741" t="Carlo A question about recursive generators and :+ . Consider this recursive spec that describes a boolean formula: (def formula [:schema {:registry {::formula [:or :boolean [:tuple [:enum :not] :boolean] [:tuple [:enum :and] [:* [:ref ::formula]]] [:tuple [:enum :or] [:* [:ref ::formula]]]]}} [:ref ::formula]]) We can of course generate examples via: (repeatedly 20 #(mg/generate formula)) But, if I change :* with :+ (rest in 🧵 )"><y>#</y><d>2022-12-04</d><h>07:25</h><w>Carlo</w>A question about recursive generators and <code>:+</code>. Consider this recursive spec that describes a boolean formula:
<pre>(def formula
  [:schema
   {:registry
    {::formula
     [:or
      :boolean
      [:tuple [:enum :not] :boolean]
      [:tuple [:enum :and] [:* [:ref ::formula]]]
      [:tuple [:enum :or]  [:* [:ref ::formula]]]]}}
   [:ref ::formula]])</pre>
We can of course generate examples via:
<pre>(repeatedly 20 #(mg/generate formula))</pre>
But, if I change <code>:*</code> with <code>:+</code> (rest in <b>🧵</b>)</z><z id="t1670138975" t="Carlo I now have: (def formula [:schema {:registry {::formula [:or :boolean [:tuple [:enum :not] :boolean] [:tuple [:enum :and] [:+ [:ref ::formula]]] [:tuple [:enum :or] [:+ [:ref ::formula]]]]}} [:ref ::formula]]) (repeatedly 20 #(mg/generate formula)) and the generator for this seems broken to me (for starters, it usually doesn&apos;t return 20 things. I suspect the reason is that it makes more difficult to generate values (as a naive sampling terminates more rarely). Is that correct?"><y>#</y><d>2022-12-04</d><h>07:29</h><r>Carlo</r>I now have:
<pre>(def formula
  [:schema
   {:registry
    {::formula
     [:or
      :boolean
      [:tuple [:enum :not] :boolean]
      [:tuple [:enum :and] [:+ [:ref ::formula]]]
      [:tuple [:enum :or]  [:+ [:ref ::formula]]]]}}
   [:ref ::formula]])

(repeatedly 20 #(mg/generate formula))</pre>
and the generator for this seems broken to me (for starters, it usually doesn&apos;t return 20 things. I suspect the reason is that it makes more difficult to generate values (as a naive sampling terminates more rarely). Is that correct?</z><z id="t1670149895" t="ikitommi recursive generators are hard, please read https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L186-L281 . Ideas welcome on how to make it better."><y>#</y><d>2022-12-04</d><h>10:31</h><r>ikitommi</r>recursive generators are hard, please read <a href="https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L186-L281" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/generator.cljc#L186-L281</a>. Ideas welcome on how to make it better.</z><z id="t1670292842" t="ambrosebs FYI I&apos;m looking into it here: https://github.com/metosin/malli/pull/792"><y>#</y><d>2022-12-06</d><h>02:14</h><r>ambrosebs</r>FYI I&apos;m looking into it here: <a href="https://github.com/metosin/malli/pull/792" target="_blank">https://github.com/metosin/malli/pull/792</a></z><z id="t1670307503" t="ambrosebs the issue is that recursive :+ can make generators like (gen/non-empty (gen/return ()))"><y>#</y><d>2022-12-06</d><h>06:18</h><r>ambrosebs</r>the issue is that recursive <code>:+</code> can make generators like <code>(gen/non-empty (gen/return ()))</code></z><z id="t1670309035" t="ambrosebs should be fixed in https://github.com/metosin/malli/pull/792"><y>#</y><d>2022-12-06</d><h>06:43</h><r>ambrosebs</r>should be fixed in <a href="https://github.com/metosin/malli/pull/792" target="_blank">https://github.com/metosin/malli/pull/792</a></z><z id="t1670311236" t="ikitommi That was a quick resolution, thanks [:attrs {:href &quot;/_/_/users/U055XFK8V&quot;}] !"><y>#</y><d>2022-12-06</d><h>07:20</h><r>ikitommi</r>That was a quick resolution, thanks <a>@U055XFK8V</a>!</z><z id="t1670141198" t="Carlo Also, what&apos;s :malli.core/potentially-recursive-seqex supposed to represent? Can&apos;t seqexes contain recursive terms?"><y>#</y><d>2022-12-04</d><h>08:06</h><w>Carlo</w>Also, what&apos;s <code>:malli.core/potentially-recursive-seqex</code> supposed to represent? Can&apos;t seqexes contain recursive terms?</z><z id="t1670142763" t="Carlo By a brute force search, I saw that this problem is solved if I wrap :+ into a :schema . A more thorough explanation would be useful though"><y>#</y><d>2022-12-04</d><h>08:32</h><r>Carlo</r>By a brute force search, I saw that this problem is solved if I wrap <code>:+</code> into a <code>:schema</code>. A more thorough explanation would be useful though</z><z id="t1670180792" t="jfntn Can someone confirm whether :schema values being explained as reified values is a bug? malli.core &gt; (explain [:map [:a int?]] {:a &quot;_&quot;}) {:errors ({:in [:a], :path [:a], :schema #&lt; https://github.com/metosin/malli/issues/789"><y>#</y><d>2022-12-04</d><h>19:06</h><w>jfntn</w>Can someone confirm whether <code>:schema</code> values being explained as reified values is a bug?
<pre>malli.core
&gt; (explain [:map [:a int?]] {:a &quot;_&quot;})
{:errors ({:in [:a],
           :path [:a],
           :schema #&lt;</pre>
<a href="https://github.com/metosin/malli/issues/789" target="_blank">https://github.com/metosin/malli/issues/789</a></z><z id="t1670218613" t="Ben Sless Should and generators use bind in reverse order to allow for transformers? Sort of like specs conforming"><y>#</y><d>2022-12-05</d><h>05:36</h><w>Ben Sless</w>Should and generators use bind in reverse order to allow for transformers? Sort of like specs conforming</z><z id="t1670265382" t="dharrigan I wonder if anyone may have an example of using {:gen/gen ....} to generate a random email address for a malli schema?"><y>#</y><d>2022-12-05</d><h>18:36</h><w>dharrigan</w>I wonder if anyone may have an example of using <code>{:gen/gen ....}</code> to generate a random email address for a malli schema?</z><z id="t1670265739" t="pithyless on my phone, but are you familiar with https://github.com/gfredericks/test.chuck ? I’ve previously used string-from-regex for this. I’ve also more recently been using the faker library with malli to generate reasonable looking data if you’re not testing the extremes of the data itself (and don’t need smart shrinking)"><y>#</y><d>2022-12-05</d><h>18:42</h><r>pithyless</r>on my phone, but are you familiar with <a href="https://github.com/gfredericks/test.chuck" target="_blank">https://github.com/gfredericks/test.chuck</a>? I’ve previously used <code>string-from-regex</code> for this. I’ve also more recently been using the <code>faker</code> library with malli to generate reasonable looking data if you’re not testing the extremes of the data itself (and don’t need smart shrinking)</z><z id="t1670265789" t="Ben Sless I can whip one up if you&apos;d like Tldr is I&apos;d break it down to its components first, then compose their generators"><y>#</y><d>2022-12-05</d><h>18:43</h><r>Ben Sless</r>I can whip one up if you&apos;d like
Tldr is I&apos;d break it down to its components first, then compose their generators</z><z id="t1670265947" t="pithyless with generators I think the question is always what’s “interesting” and in scope for the “purpose” of the output. If you’d like to test the limitations of the email string itself [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] approach of composing from smaller generators is sound. "><y>#</y><d>2022-12-05</d><h>18:45</h><r>pithyless</r>with generators I think the question is always what’s “interesting” and in scope for the “purpose” of the output. If you’d like to test the limitations of the email string itself <a>@UK0810AQ2</a> approach of composing from smaller generators is sound. </z><z id="t1670266049" t="dharrigan Actually"><y>#</y><d>2022-12-05</d><h>18:47</h><r>dharrigan</r>Actually</z><z id="t1670266051" t="dharrigan I figured it out"><y>#</y><d>2022-12-05</d><h>18:47</h><r>dharrigan</r>I figured it out</z><z id="t1670266057" t="dharrigan thre is an undocumented re-gen !!!"><y>#</y><d>2022-12-05</d><h>18:47</h><r>dharrigan</r>thre is an undocumented <code>re-gen</code>!!!</z><z id="t1670266070" t="dharrigan It pays to look at the source code"><y>#</y><d>2022-12-05</d><h>18:47</h><r>dharrigan</r>It pays to look at the source code</z><z id="t1670266093" t="dharrigan [:foo/email-address [:re {:gen/re-gen [email-pattern]} email-pattern]]"><y>#</y><d>2022-12-05</d><h>18:48</h><r>dharrigan</r><code>[:foo/email-address [:re {:gen/re-gen [email-pattern]} email-pattern]]</code></z><z id="t1670266106" t="Ben Sless Yeah but the email regex is a monster"><y>#</y><d>2022-12-05</d><h>18:48</h><r>Ben Sless</r>Yeah but the email regex is a monster</z><z id="t1670266127" t="dharrigan Yeah, it&apos;s hairy, been there before on validating email. I&apos;ll take a pragmatic approach."><y>#</y><d>2022-12-05</d><h>18:48</h><r>dharrigan</r>Yeah, it&apos;s hairy, been there before on validating email. I&apos;ll take a pragmatic approach.</z><z id="t1670269803" t="NoahTheDuke is there any difference between [:id :int] and [:id int?] ?"><y>#</y><d>2022-12-05</d><h>19:50</h><w>NoahTheDuke</w>is there any difference between <code>[:id :int]</code> and <code>[:id int?]</code>?</z><z id="t1670269825" t="NoahTheDuke I tried to search but it&apos;s kind of nebulous lol"><y>#</y><d>2022-12-05</d><h>19:50</h><r>NoahTheDuke</r>I tried to search but it&apos;s kind of nebulous lol</z><z id="t1670270101" t="pithyless They have implementation differences that leak into your code in surprising ways (if you&apos;re not aware of them). I suggest using :int by default. :) See e.g: https://github.com/metosin/malli/issues/636 https://github.com/metosin/malli/issues/327"><y>#</y><d>2022-12-05</d><h>19:55</h><r>pithyless</r>They have implementation differences that leak into your code in surprising ways (if you&apos;re not aware of them). I suggest using <code>:int</code> by default. :)

See e.g:
<a href="https://github.com/metosin/malli/issues/636" target="_blank">https://github.com/metosin/malli/issues/636</a>
<a href="https://github.com/metosin/malli/issues/327" target="_blank">https://github.com/metosin/malli/issues/327</a></z><z id="t1670270359" t="NoahTheDuke ah yeah, i remember seeing that a while back. that&apos;s annoying"><y>#</y><d>2022-12-05</d><h>19:59</h><r>NoahTheDuke</r>ah yeah, i remember seeing that a while back. that&apos;s annoying</z><z id="t1670343727" t="Abhinav This was very interesting"><y>#</y><d>2022-12-06</d><h>16:22</h><r>Abhinav</r>This was very interesting</z><z id="t1670353545" t="NoahTheDuke Found a difference between [:sequential {:max 1} schema] and [:? schema] when transformed to a json-schema: https://github.com/metosin/malli/issues/793"><y>#</y><d>2022-12-06</d><h>19:05</h><w>NoahTheDuke</w>Found a difference between <code>[:sequential {:max 1} schema]</code> and <code>[:? schema]</code> when transformed to a json-schema: <a href="https://github.com/metosin/malli/issues/793" target="_blank">https://github.com/metosin/malli/issues/793</a></z><z id="t1670354561" t="NoahTheDuke Looks like none of the &quot;malli.core/sequence-schemas&quot; are handled by https://github.com/metosin/malli/blob/cda67420c215b0a8018e1adf70660826d1ba658f/src/malli/json_schema.cljc"><y>#</y><d>2022-12-06</d><h>19:22</h><r>NoahTheDuke</r>Looks like none of the &quot;malli.core/sequence-schemas&quot; are handled by <a href="https://github.com/metosin/malli/blob/cda67420c215b0a8018e1adf70660826d1ba658f/src/malli/json_schema.cljc" target="_blank">https://github.com/metosin/malli/blob/cda67420c215b0a8018e1adf70660826d1ba658f/src/malli/json_schema.cljc</a></z><z id="t1670362445" t="NoahTheDuke A related question: What edition of JSON Schema is Malli targeting?"><y>#</y><d>2022-12-06</d><h>21:34</h><r>NoahTheDuke</r>A related question: What edition of JSON Schema is Malli targeting?</z><z id="t1670361383" t="ambrosebs Some cleanup following the recent generator bugfix, including a function from schema -&gt; code that generates generator. https://github.com/metosin/malli/pull/794"><y>#</y><d>2022-12-06</d><h>21:16</h><w>ambrosebs</w>Some cleanup following the recent generator bugfix, including a function from schema -&gt; code that generates generator. <a href="https://github.com/metosin/malli/pull/794" target="_blank">https://github.com/metosin/malli/pull/794</a></z><z id="t1670362445" t="NoahTheDuke A related question: What edition of JSON Schema is Malli targeting?"><y>#</y><d>2022-12-06</d><h>21:34</h><w>NoahTheDuke</w>A related question: What edition of JSON Schema is Malli targeting?</z><z id="t1670797372" t="Erik Colson hi. I am trying out malli. What is the usual approach to validate a date string with malli?"><y>#</y><d>2022-12-11</d><h>22:22</h><w>Erik Colson</w>hi.  I am trying out malli.  What is the usual approach to validate a date string with malli?</z><z id="t1670815772" t="Ben Sless Coerce it first to the expected date type using a decoder"><y>#</y><d>2022-12-12</d><h>03:29</h><r>Ben Sless</r>Coerce it first to the expected date type using a decoder</z><z id="t1670829032" t="dharrigan Here&apos;s a little example that I have used (there may be other approaches)"><y>#</y><d>2022-12-12</d><h>07:10</h><r>dharrigan</r>Here&apos;s a little example that I have used (there may be other approaches)</z><z id="t1670829061" t="dharrigan (def ^:private iso8601-message &quot;is not in ISO DATE TIME format, e.g. 2020-07-03T10:15:30+01:00 or 2020-07-03T10:15:30Z&quot;) ;; ISO_OFFSET_DATE_TIME format, e.g., 2011-12-03T10:15:30+01:00 or 2011-12-03T10:15:30Z (defn ^:private date-time-parser [date-time] (try (.parse DateTimeFormatter/ISO_OFFSET_DATE_TIME date-time) (catch DateTimeParseException _))) (def date-range [:map [:from {:optional true} [:fn {:swagger/type &quot;string&quot; :swagger/format &quot;date-time&quot; :error/message iso8601-message} date-time-parser]] [:to {:optional true} [:fn {:swagger/type &quot;string&quot; :swagger/format &quot;date-time&quot; :error/message iso8601-message} date-time-parser]]])"><y>#</y><d>2022-12-12</d><h>07:11</h><r>dharrigan</r><pre>(def ^:private iso8601-message &quot;is not in ISO DATE TIME format, e.g. 2020-07-03T10:15:30+01:00 or 2020-07-03T10:15:30Z&quot;)

;; ISO_OFFSET_DATE_TIME format, e.g., 2011-12-03T10:15:30+01:00 or 2011-12-03T10:15:30Z
(defn ^:private date-time-parser
  [date-time]
  (try
    (.parse DateTimeFormatter/ISO_OFFSET_DATE_TIME date-time)
    (catch DateTimeParseException _)))

(def date-range [:map
                 [:from {:optional true} [:fn {:swagger/type &quot;string&quot; :swagger/format &quot;date-time&quot; :error/message iso8601-message} date-time-parser]]
                 [:to {:optional true} [:fn {:swagger/type &quot;string&quot; :swagger/format &quot;date-time&quot; :error/message iso8601-message} date-time-parser]]])</pre></z><z id="t1670830629" t="Ben Sless It&apos;s a bit draconian but I came to adopt the approach of never using a :fn schema if I can help it. Instead, all data coming into the process should go through a coercer. In reitit coercion is built in for you, otherwise just roll your own: https://clojurians.slack.com/archives/CLDK6MFMK/p1636145457067000?thread_ts=1636057867.062800&amp;amp;cid=CLDK6MFMK Then just say your date is an inst?"><y>#</y><d>2022-12-12</d><h>07:37</h><r>Ben Sless</r>It&apos;s a bit draconian but I came to adopt the approach of never using a <code>:fn</code> schema if I can help it. Instead, all data coming into the process should go through a coercer. In reitit coercion is built in for you, otherwise just roll your own:
<a href="https://clojurians.slack.com/archives/CLDK6MFMK/p1636145457067000?thread_ts=1636057867.062800&amp;amp;cid=CLDK6MFMK" target="_blank">https://clojurians.slack.com/archives/CLDK6MFMK/p1636145457067000?thread_ts=1636057867.062800&amp;amp;cid=CLDK6MFMK</a>
Then just say your date is an <code>inst?</code></z><z id="t1670830906" t="eskos I used to do what [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] does and it works well enough IMO. While not immediately apparent, I also created https://github.com/esuomi/muotti/ partly because of the complexities related to this problem, and in fact its source has a tidbit which may also be inspiration, if nothing else: https://github.com/esuomi/muotti/blob/d6e4e3df5f70bf1d26d035b034d9306445aea423/src/main/clj/muotti/malli.clj#L181-L199"><y>#</y><d>2022-12-12</d><h>07:41</h><r>eskos</r>I used to do what <a>@U11EL3P9U</a> does and it works well enough IMO. While not immediately apparent, I also created <a href="https://github.com/esuomi/muotti/" target="_blank">https://github.com/esuomi/muotti/</a> partly because of the complexities related to this problem, and in fact its source has a tidbit which may also be inspiration, if nothing else: <a href="https://github.com/esuomi/muotti/blob/d6e4e3df5f70bf1d26d035b034d9306445aea423/src/main/clj/muotti/malli.clj#L181-L199" target="_blank">https://github.com/esuomi/muotti/blob/d6e4e3df5f70bf1d26d035b034d9306445aea423/src/main/clj/muotti/malli.clj#L181-L199</a></z><z id="t1670832317" t="dharrigan 👍"><y>#</y><d>2022-12-12</d><h>08:05</h><r>dharrigan</r><b>👍</b></z><z id="t1670843243" t="Erik Colson thanks for the examples. I am going to use [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] ’s approach on this. [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] what is the reason you prefer not to use :fn ?"><y>#</y><d>2022-12-12</d><h>11:07</h><r>Erik Colson</r>thanks for the examples.  I am going to use <a>@U11EL3P9U</a>’s approach on this.  <a>@UK0810AQ2</a> what is the reason you prefer not to use <code>:fn</code> ?</z><z id="t1670843815" t="Ben Sless • fn schemas are opaque • values can&apos;t be generated • they hide the real type you&apos;re interested in. For example, if you have a time stamp, you might want to compare it against things (such as other dates), meaning you&apos;ll have to parse it anyway. You want the real type on your hands • Schemas specify ought, not is. you use decoding to make the best effort to bring what is to ought, then validate. You can often find an actual type which is closer to what you want than a fn"><y>#</y><d>2022-12-12</d><h>11:16</h><r>Ben Sless</r>• fn schemas are opaque
• values can&apos;t be generated
• they hide the real type you&apos;re interested in. For example, if you have a time stamp, you might want to compare it against things (such as other dates), meaning you&apos;ll have to parse it anyway. You want the real type on your hands
• Schemas specify ought, not is. you use decoding to make the best effort to bring what is to ought, then validate. You can often find an actual type which is closer to what you want than a <code>fn</code></z><z id="t1670843859" t="Ben Sless also see https://www.youtube.com/watch?v=IcgmSRJHu_8"><y>#</y><d>2022-12-12</d><h>11:17</h><r>Ben Sless</r>also see <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8" target="_blank">https://www.youtube.com/watch?v=IcgmSRJHu_8</a></z><z id="t1670843978" t="Ben Sless I can give you a real example - I have code which takes date over as string and needs to calculate N days ago from it, an API which returns numbers in JSON as strings. I don&apos;t want to do manual parsing. Once everything is past the gate of coercion and validation, I want my data to be the types I actually use, not what some random stressed out developer at $COMPANY crammed over a poorly thought out API"><y>#</y><d>2022-12-12</d><h>11:19</h><r>Ben Sless</r>I can give you a real example - I have code which takes date over as string and needs to calculate N days ago from it, an API which returns numbers in JSON as strings. I don&apos;t want to do manual parsing. Once everything is past the gate of coercion and validation, I want my data to be the types I actually use, not what some random stressed out developer at $COMPANY crammed over a poorly thought out API</z><z id="t1670858684" t="Erik Colson [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] That seems to make sense. Thanks for your explanation!"><y>#</y><d>2022-12-12</d><h>15:24</h><r>Erik Colson</r><a>@UK0810AQ2</a> That seems to make sense.  Thanks for your explanation!</z><z id="t1670880880" t="DrLjótsson Is there a non-negligible performance penalty for sending in raw malli specs to validation functions instead of defining them with m/schema once and providing them to validation functions?"><y>#</y><d>2022-12-12</d><h>21:34</h><w>DrLjótsson</w>Is there a non-negligible performance penalty for sending in raw malli specs to validation functions instead of defining them with <code>m/schema</code> once and providing them to validation functions?</z><z id="t1670880939" t="DrLjótsson I.e., (def X [:int]) (m/validate x 9) vs (def X (m/schema [:int])) (m/validate x 9) "><y>#</y><d>2022-12-12</d><h>21:35</h><r>DrLjótsson</r>I.e.,

<pre>(def X [:int])
(m/validate x 9)</pre>
vs
<pre>(def X (m/schema [:int]))
(m/validate x 9)</pre>
</z><z id="t1670880988" t="DrLjótsson Under the assumption that the validation function will be run multiple times of course."><y>#</y><d>2022-12-12</d><h>21:36</h><r>DrLjótsson</r>Under the assumption that the validation function will be run multiple times of course.</z><z id="t1670909156" t="Ben Sless You should build a validator if performance matters, can be two orders of magnitude faster"><y>#</y><d>2022-12-13</d><h>05:25</h><r>Ben Sless</r>You should build a validator if performance matters, can be two orders of magnitude faster</z><z id="t1671034413" t="ikitommi oh, that’s a bug. fixing it in https://github.com/metosin/malli/pull/798"><y>#</y><d>2022-12-14</d><h>16:13</h><w>ikitommi</w>oh, that’s a bug. fixing it in <a href="https://github.com/metosin/malli/pull/798" target="_blank">https://github.com/metosin/malli/pull/798</a></z><z id="t1671035191" t="ikitommi merged [:attrs {:href &quot;/_/_/users/US9EF3BGU&quot;}]"><y>#</y><d>2022-12-14</d><h>16:26</h><r>ikitommi</r>merged <a>@US9EF3BGU</a></z><z id="t1671035441" t="rmxm still I have another pickle... so when I run explain-data, I can obtain all error messages into a sec. however, when I define :fn it doesnt put error as &quot;last&quot; as mentioned before, I will paste the real code, the gist of the problem is that map with :error/message is at different index of the vector"><y>#</y><d>2022-12-14</d><h>16:30</h><r>rmxm</r>still I have another pickle... so
when I run explain-data, I can obtain all error messages into a sec.

however, when I define :fn it doesnt put error as &quot;last&quot;
as mentioned before, I will paste the real code, the gist of the problem is that map with :error/message is at different index of the vector</z><z id="t1671036486" t="rmxm (def schema [map [:x [:fn #(= % 2) {:error/message &quot;not 2&quot;}]] [:y [:string {:min 2 :error/message &quot;longer than 2}]]) (def payload {:x 3 :y &quot;a&quot;}) (-&gt;&gt; (mu/explain-data schema payload) :errors (map #(-&gt; % :schema last :error/message)))"><y>#</y><d>2022-12-14</d><h>16:48</h><r>rmxm</r><pre>(def schema
 [map
  [:x [:fn #(= % 2) {:error/message &quot;not 2&quot;}]]
  [:y [:string {:min 2 :error/message &quot;longer than 2}]])

(def payload
 {:x 3
  :y &quot;a&quot;})

(-&gt;&gt; (mu/explain-data schema payload)
     :errors
     (map #(-&gt; % :schema last :error/message)))</pre></z><z id="t1671038834" t="ikitommi not sure what you are doing, but: (def schema [:map [:x [:fn {:error/message &quot;not 2&quot;} #(= % 2)]] [:y [:string {:min 2 :error/message &quot;longer than 2&quot;}]]]) (def payload {:x 3 :y &quot;a&quot;}) (-&gt;&gt; (mu/explain-data schema payload) :errors (map #(-&gt; % :schema m/properties :error/message))) ; =&gt; (&quot;not 2&quot; &quot;longer than 2&quot;)"><y>#</y><d>2022-12-14</d><h>17:27</h><r>ikitommi</r>not sure what you are doing, but:
<pre>(def schema
  [:map
   [:x [:fn {:error/message &quot;not 2&quot;} #(= % 2)]]
   [:y [:string {:min 2 :error/message &quot;longer than 2&quot;}]]])

(def payload
  {:x 3
   :y &quot;a&quot;})

(-&gt;&gt; (mu/explain-data schema payload)
     :errors
     (map #(-&gt; % :schema m/properties :error/message)))
; =&gt; (&quot;not 2&quot; &quot;longer than 2&quot;)</pre></z><z id="t1671038852" t="ikitommi or you can use something like me/humanize : (-&gt;&gt; (m/explain schema payload) (me/humanize)) ; =&gt; {:x [&quot;not 2&quot;], :y [&quot;longer than 2&quot;]}"><y>#</y><d>2022-12-14</d><h>17:27</h><r>ikitommi</r>or you can use something like <code>me/humanize</code>:
<pre>(-&gt;&gt; (m/explain schema payload)
     (me/humanize))
; =&gt; {:x [&quot;not 2&quot;], :y [&quot;longer than 2&quot;]}</pre></z><z id="t1671039618" t="rmxm great thanks... well I am trying to just aggregate error strings to push them as notifications... those examples work, thanks"><y>#</y><d>2022-12-14</d><h>17:40</h><r>rmxm</r>great thanks...
well I am trying to just aggregate error strings to push them as notifications... those examples work, thanks</z><z id="t1671045911" t="escherize I want to decode a string with an enum like so: [:enum :A :B] + &quot;A&quot; =&gt; :A This doesn’t work: (mc/decode [:enum :A :B] &quot;A&quot; (mtx/string-transformer)) ;; =&gt; &quot;A&quot; But all of these will work: [(mc/decode [:and keyword? [:enum :A :B]] &quot;A&quot; (mtx/json-transformer)) (mc/decode [:and keyword? [:enum :A :B]] &quot;A&quot; (mtx/string-transformer)) (mc/decode [:enum {:decode/specific keyword} :A :B] &quot;A&quot; (mtx/transformer {:name :specific}))] ;;=&gt; [:A :A :A] Is there another (even better?) way to do that?"><y>#</y><d>2022-12-14</d><h>19:25</h><w>escherize</w>I want to decode a string with an enum like so: <code>[:enum :A :B] + &quot;A&quot; =&gt; :A</code>

This doesn’t work:

<pre>(mc/decode [:enum :A :B] &quot;A&quot; (mtx/string-transformer))
;; =&gt; &quot;A&quot;</pre>
But all of these will work:
<pre>[(mc/decode [:and keyword? [:enum :A :B]]            &quot;A&quot; (mtx/json-transformer))
 (mc/decode [:and keyword? [:enum :A :B]]            &quot;A&quot; (mtx/string-transformer))
 (mc/decode [:enum {:decode/specific keyword} :A :B] &quot;A&quot; (mtx/transformer {:name :specific}))]
;;=&gt; [:A :A :A] </pre>
Is there another (even better?) way to do that?</z><z id="t1671046783" t="Ben Sless decode/string instead of specific?"><y>#</y><d>2022-12-14</d><h>19:39</h><r>Ben Sless</r>decode/string instead of specific?</z><z id="t1671047623" t="ikitommi not released, but https://github.com/metosin/malli/pull/782 last month 😎 (m/decode [:enum :A :B] &quot;A&quot; (mt/string-transformer)) ;=&gt; :A"><y>#</y><d>2022-12-14</d><h>19:53</h><r>ikitommi</r>not released, but <a href="https://github.com/metosin/malli/pull/782" target="_blank">https://github.com/metosin/malli/pull/782</a> last month <b>😎</b>
<pre>(m/decode [:enum :A :B] &quot;A&quot; (mt/string-transformer))
;=&gt; :A</pre></z><z id="t1671047640" t="escherize sorry [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] , I can’t parse that."><y>#</y><d>2022-12-14</d><h>19:54</h><r>escherize</r>sorry <a>@UK0810AQ2</a>, I can’t parse that.</z><z id="t1671047651" t="escherize [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Oh, neato"><y>#</y><d>2022-12-14</d><h>19:54</h><r>escherize</r><a>@U055NJ5CC</a> Oh, neato</z><z id="t1671047706" t="escherize Is that coming out in a release soon? (aka when?)"><y>#</y><d>2022-12-14</d><h>19:55</h><r>escherize</r>Is that coming out in a release soon? (aka when?)</z><z id="t1671047729" t="ikitommi if you use deps, you can just point to the latest commit on master."><y>#</y><d>2022-12-14</d><h>19:55</h><r>ikitommi</r>if you use deps, you can just point to the latest commit on master.</z><z id="t1671047849" t="ikitommi will try to cut a release this year, need some work on the providers, a minor breaking change, so a minor bump to 0.10.0"><y>#</y><d>2022-12-14</d><h>19:57</h><r>ikitommi</r>will try to cut a release this year, need some work on the providers, a minor breaking change, so a <code>minor</code> bump to <code>0.10.0</code></z><z id="t1671047876" t="escherize I think I’ll wait for that, then. Thanks for the info!"><y>#</y><d>2022-12-14</d><h>19:57</h><r>escherize</r>I think I’ll wait for that, then. Thanks for the info!</z><z id="t1671055573" t="escherize Is there an analogous function to prismatic schema’s check ? Here’s the docstring: &quot;Return nil if x matches schema; otherwise, returns a value that looks like the &apos;bad&apos; parts of x with ValidationErrors at the leaves describing the failures. If you will be checking many datums, it is much more efficient to create a &apos;checker&apos; once and call it on each of them.&quot;"><y>#</y><d>2022-12-14</d><h>22:06</h><w>escherize</w>Is there an analogous function to prismatic schema’s <code>check</code>? Here’s the docstring:
<pre>&quot;Return nil if x matches schema; otherwise, returns a value that looks like the
   &apos;bad&apos; parts of x with ValidationErrors at the leaves describing the failures.

   If you will be checking many datums, it is much more efficient to create
   a &apos;checker&apos; once and call it on each of them.&quot;</pre></z><z id="t1671055596" t="escherize hmm, is that a key in explain?"><y>#</y><d>2022-12-14</d><h>22:06</h><r>escherize</r>hmm, is that a key in explain?</z><z id="t1671055668" t="escherize I have this to work with: {:schema [:map [:x int?]], :value {:y &quot;3&quot;}, :errors ({:path [:x], :in [:x], :schema [:map [:x int?]], :value nil, :type :malli.core/missing-key})}"><y>#</y><d>2022-12-14</d><h>22:07</h><r>escherize</r>I have this to work with:
<pre>{:schema [:map [:x int?]],
 :value {:y &quot;3&quot;},
 :errors ({:path [:x], :in [:x], :schema [:map [:x int?]], :value nil, :type :malli.core/missing-key})}</pre></z><z id="t1671055704" t="escherize seems like I can reduce on errors, and assoc-in using :path or :in?"><y>#</y><d>2022-12-14</d><h>22:08</h><r>escherize</r>seems like I can reduce on errors, and assoc-in using :path or :in?</z><z id="t1671055860" t="escherize answering my own question here, using (me/humanize (m/errors $schema $value)) does similar thing to plumatic.schema/check ✨"><y>#</y><d>2022-12-14</d><h>22:11</h><r>escherize</r>answering my own question here, using <code>(me/humanize (m/errors $schema $value))</code> does similar thing to <code>plumatic.schema/check</code> <b>✨</b></z><z id="t1671055860" t="escherize answering my own question here, using (me/humanize (m/errors $schema $value)) does similar thing to plumatic.schema/check ✨"><y>#</y><d>2022-12-14</d><h>22:11</h><w>escherize</w>answering my own question here, using <code>(me/humanize (m/errors $schema $value))</code> does similar thing to <code>plumatic.schema/check</code> <b>✨</b></z><z id="t1671065192" t="rmxm another quick question, similar to the last one, why? (m/properties [:enum &quot;x&quot; &quot;y&quot; {:error/message &quot;a&quot;}]) ;; nil (m/properties [:string {:error/message &quot;a&quot;}]) ;; #:error{:message &quot;a&quot;}"><y>#</y><d>2022-12-15</d><h>00:46</h><w>rmxm</w>another quick question, similar to the last one, why?
<pre>(m/properties [:enum &quot;x&quot; &quot;y&quot; {:error/message &quot;a&quot;}]) ;; nil
(m/properties [:string {:error/message &quot;a&quot;}]) ;; #:error{:message &quot;a&quot;}</pre></z><z id="t1671084760" t="ikitommi properties map should be the second element in the vector syntax, not the last."><y>#</y><d>2022-12-15</d><h>06:12</h><r>ikitommi</r>properties map should be the second element in the vector syntax, not the last.</z><z id="t1671127535" t="rmxm thanks a lot, yeah silly mistake... but more and more I get more confident I will be able to express any crazy schema + have validating/schema/errors in one shape, thanks for your help"><y>#</y><d>2022-12-15</d><h>18:05</h><r>rmxm</r>thanks a lot, yeah silly mistake... but more and more I get more confident I will be able to express any crazy schema + have validating/schema/errors in one shape, thanks for your help</z><z id="t1671069266" t="lepistane I have a question. So when i am using spec to describe paramenters with reitit.ring.middleware.multipart/temp-file-part there is swagger/type which can be shown in the swagger page. I can&apos;t seem to find a way to do this with malli (yes i swapped coercion) I tried https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/ring/malli.cljc this breaks page so that you can&apos;t even put params anymore :parameters {:query [:map {:json-schema {:type &quot;file&quot;}} [:filename string?] [:content-type string?] [:size int?] [:tempfile [:fn (partial instance? )]]] this is the gist Is this solvable or i am stuck with spec? after some tryouts this worked [:filename {:swagger/type &quot;file&quot;} string?] but i am wondering am i making a mistake and this should be done some other way? edit https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj provided all answers i needed, didn&apos;t see it first time i checked examples 🙂 thankful and grateful for the examples gratitude"><y>#</y><d>2022-12-15</d><h>01:54</h><w>lepistane</w>I have a question.

So when i am using spec to describe <code>paramenters</code> with reitit.ring.middleware.multipart/temp-file-part there is swagger/type which can be shown in the swagger page.
I can&apos;t seem to find a way to do this with malli (yes i swapped coercion)

I tried <a href="https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/ring/malli.cljc" target="_blank">https://github.com/metosin/reitit/blob/master/modules/reitit-malli/src/reitit/ring/malli.cljc</a> this breaks page so that you can&apos;t even put params anymore
<pre>:parameters {:query [:map {:json-schema {:type &quot;file&quot;}}
                                     [:filename string?]
                                     [:content-type string?]
                                     [:size int?]
                                     [:tempfile [:fn (partial instance? )]]]</pre>
this is the gist

Is this solvable or i am stuck with spec?

after some tryouts this worked
<pre>[:filename {:swagger/type &quot;file&quot;} string?] </pre>
but i am wondering am i making a mistake and this should be done some other way?

<code>edit</code>
<a href="https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj" target="_blank">https://github.com/metosin/reitit/blob/master/examples/ring-malli-swagger/src/example/server.clj</a>
provided all answers i needed, didn&apos;t see it first time i checked examples <b>🙂</b>
thankful and grateful for the examples <b>gratitude</b></z><z id="t1671074346" t="lepistane I guess i didn&apos;t find answer to all questions ... So i have custom schema that uses custom function for special case validation. [:map {:closed true} [:match-id [:fn #:error{:message &quot;Invalid match-id&quot;} #function[valid-uuid-as-str?]]] [:date [:fn #:error{:message &quot;Invalid date&quot;} #function[valid-date-as-str?]]]] But it doesn&apos;t work. I am already using this specialized validation in other places but i was thinking about reusing it all everywhere. is it possible that reitit parameter validation can be only primitive predicates (from clj.core and malli) ?"><y>#</y><d>2022-12-15</d><h>03:19</h><w>lepistane</w>I guess i didn&apos;t find answer to all questions ...

So i have custom schema that uses custom function for special case validation.
<pre>[:map {:closed true} 
 [:match-id [:fn #:error{:message &quot;Invalid match-id&quot;} #function[valid-uuid-as-str?]]] 
 [:date [:fn #:error{:message &quot;Invalid date&quot;} #function[valid-date-as-str?]]]]</pre>
But it doesn&apos;t work.

I am already using this specialized validation in other places but i was thinking about reusing it all everywhere.
is it possible that reitit parameter validation can be only primitive predicates (from clj.core and malli) ?</z><z id="t1671085747" t="ikitommi there are no restrictions on reitit for using malli, it should just work. let me test that."><y>#</y><d>2022-12-15</d><h>06:29</h><r>ikitommi</r>there are no restrictions on reitit for using malli, it should just work. let me test that.</z><z id="t1671086199" t="ikitommi tested and it just works :thinking_face:"><y>#</y><d>2022-12-15</d><h>06:36</h><r>ikitommi</r>tested and it just works <b>:thinking_face:</b></z><z id="t1671086236" t="ikitommi if you can do a minimalist repro, I can check what’s wrong with it."><y>#</y><d>2022-12-15</d><h>06:37</h><r>ikitommi</r>if you can do a minimalist repro, I can check what’s wrong with it.</z><z id="t1671102489" t="lepistane [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] Thanks! Here is the repo (just reused existing mali reitit example and added on top) https://github.com/StankovicMarko/reitit/blob/custom-validation/examples/ring-malli-swagger/src/example/server.clj You can see what i added on top: https://github.com/StankovicMarko/reitit/commit/8f6634d1f7529aebd23e6527ac738857894b0328 Main issue is that when i put values for GET plus, if they are wrong i can&apos;t make a request until i put correct value. picture A And for test route i can add whatever i want and i dont want that. I want to prevent it just like with &apos;native&apos; types picture B"><y>#</y><d>2022-12-15</d><h>11:08</h><r>lepistane</r><a>@ikitommi</a> Thanks!

Here is the repo (just reused existing mali reitit example and added on top)
<a href="https://github.com/StankovicMarko/reitit/blob/custom-validation/examples/ring-malli-swagger/src/example/server.clj" target="_blank">https://github.com/StankovicMarko/reitit/blob/custom-validation/examples/ring-malli-swagger/src/example/server.clj</a>

You can see what i added on top: <a href="https://github.com/StankovicMarko/reitit/commit/8f6634d1f7529aebd23e6527ac738857894b0328" target="_blank">https://github.com/StankovicMarko/reitit/commit/8f6634d1f7529aebd23e6527ac738857894b0328</a>

Main issue is that when i put values for GET plus, if they are wrong i can&apos;t make a request until i put correct value.
picture A

And for test route i can add whatever i want and i dont want that. I want to prevent it just like with &apos;native&apos; types
picture B</z><z id="t1671102512" t="lepistane What am i doing wrong?"><y>#</y><d>2022-12-15</d><h>11:08</h><r>lepistane</r>What am i doing wrong?</z><z id="t1671107621" t="lepistane This was the only i managed to do it [:map [:date {:description &quot;Date when match happened&quot; :json-schema/type &quot;string&quot; :json-schema/format &quot;date&quot; :json-schema/default &quot;2022-10-10&quot;} [:and [:re #&quot;^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$&quot;] [:fn {:error/message &quot;Invalid date&quot;} v/valid-date-as-str?]]]] Use regex to enforce format of a string but feels wrong. shouldn&apos;t this already be available? https://swagger.io/docs/specification/data-models/data-types/#string"><y>#</y><d>2022-12-15</d><h>12:33</h><r>lepistane</r>This was the only i managed to do it
<pre>[:map
                            [:date {:description &quot;Date when match happened&quot;
                                    :json-schema/type &quot;string&quot;
                                    :json-schema/format &quot;date&quot;
                                    :json-schema/default &quot;2022-10-10&quot;}
                             [:and
                              [:re #&quot;^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$&quot;]
                              [:fn {:error/message &quot;Invalid date&quot;}
                               v/valid-date-as-str?]]]]</pre>
Use regex to enforce format of a string but feels wrong.

shouldn&apos;t this already be available?
<a href="https://swagger.io/docs/specification/data-models/data-types/#string" target="_blank">https://swagger.io/docs/specification/data-models/data-types/#string</a></z><z id="t1671107650" t="lepistane Am i missing something?"><y>#</y><d>2022-12-15</d><h>12:34</h><r>lepistane</r>Am i missing something?</z><z id="t1671112234" t="lepistane [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] any ideas?"><y>#</y><d>2022-12-15</d><h>13:50</h><r>lepistane</r><a>@ikitommi</a> any ideas?</z><z id="t1671118748" t="Jordan Robinson Hello, I&apos;m in the process of porting over a codebase from spec to malli, and it&apos;s very cool! Thanks for all your work. I have a small question that may be a bit stupid so forgive my ignorance, is there a way to pick up the seed or size values from within a :gen/fmap function?"><y>#</y><d>2022-12-15</d><h>15:39</h><w>Jordan Robinson</w>Hello, I&apos;m in the process of porting over a codebase from spec to malli, and it&apos;s very cool! Thanks for all your work. I have a small question that may be a bit stupid so forgive my ignorance, is there a way to pick up the seed or size values from within a <code>:gen/fmap</code> function?</z><z id="t1671122674" t="escherize What I have done, is use a deterministic transformation on the generated value in :gen/fmap"><y>#</y><d>2022-12-15</d><h>16:44</h><r>escherize</r>What I have done, is use a deterministic transformation on the generated value in :gen/fmap</z><z id="t1671122853" t="Jordan Robinson that sounds like it might be along the lines of what I&apos;m looking for, I don&apos;t suppose you have a code snippet at all?"><y>#</y><d>2022-12-15</d><h>16:47</h><r>Jordan Robinson</r>that sounds like it might be along the lines of what I&apos;m looking for, I don&apos;t suppose you have a code snippet at all?</z><z id="t1671122907" t="escherize its not a stupid question, let me see here"><y>#</y><d>2022-12-15</d><h>16:48</h><r>escherize</r>its not a stupid question, let me see here</z><z id="t1671123004" t="escherize (mg/generate [:and {:gen/fmap #(str &quot;my_&quot; % &quot;_thing&quot;)} string?] {:seed 10, :size 10})"><y>#</y><d>2022-12-15</d><h>16:50</h><r>escherize</r><pre>(mg/generate
 [:and {:gen/fmap #(str &quot;my_&quot; % &quot;_thing&quot;)} string?]
 {:seed 10, :size 10})</pre></z><z id="t1671123007" t="escherize something like that work for you?"><y>#</y><d>2022-12-15</d><h>16:50</h><r>escherize</r>something like that work for you?</z><z id="t1671123323" t="Jordan Robinson ah I see, I did try something like that at first but it didn&apos;t really work for my situation, let me try and write some pseudocode for what I have (malli/schema [:fn {:gen/fmap (fn [_] (generate-thing {:seed ???}))} (fn [thing] (validate-thing thing))]) which I&apos;m then calling via (mg/generate schemas/thing {:seed 0})"><y>#</y><d>2022-12-15</d><h>16:55</h><r>Jordan Robinson</r>ah I see, I did try something like that at first but it didn&apos;t really work for my situation, let me try and write some pseudocode for what I have

<pre>(malli/schema [:fn
                 {:gen/fmap
                  (fn [_]
                    (generate-thing {:seed ???}))}
                 (fn [thing] (validate-thing thing))])</pre>
which I&apos;m then calling via <code>(mg/generate schemas/thing {:seed 0})</code></z><z id="t1671123341" t="Jordan Robinson so I&apos;m not sure that would work here, does that make a bit more sense?"><y>#</y><d>2022-12-15</d><h>16:55</h><r>Jordan Robinson</r>so I&apos;m not sure that would work here, does that make a bit more sense?</z></g><g id="s28"><z id="t1671123449" t="escherize can you build up a generator, and supply it in the :gen/gen property?"><y>#</y><d>2022-12-15</d><h>16:57</h><r>escherize</r>can you build up a generator, and supply it in the :gen/gen property?</z><z id="t1671123465" t="escherize meaning a clojure.test.check.generators"><y>#</y><d>2022-12-15</d><h>16:57</h><r>escherize</r>meaning a clojure.test.check.generators</z><z id="t1671123490" t="Jordan Robinson potentially yes, but this isn&apos;t actually in test code, so I&apos;d really only rather use clojure.test.check.generators as a last resort since that would mean putting it in the src imports which, feels a bit funky"><y>#</y><d>2022-12-15</d><h>16:58</h><r>Jordan Robinson</r>potentially yes, but this isn&apos;t actually in test code, so I&apos;d really only rather use clojure.test.check.generators as a last resort since that would mean putting it in the src imports which, feels a bit funky</z><z id="t1671123510" t="Jordan Robinson if it&apos;s not a common thing what I&apos;m doing though I guess I&apos;d have to go down that route"><y>#</y><d>2022-12-15</d><h>16:58</h><r>Jordan Robinson</r>if it&apos;s not a common thing what I&apos;m doing though I guess I&apos;d have to go down that route</z><z id="t1671123537" t="escherize I guess it depends how hard it is to generate your thing"><y>#</y><d>2022-12-15</d><h>16:58</h><r>escherize</r>I guess it depends how hard it is to generate your thing</z><z id="t1671123553" t="Jordan Robinson not hard but it does take an int seed"><y>#</y><d>2022-12-15</d><h>16:59</h><r>Jordan Robinson</r>not hard but it does take an int seed</z><z id="t1671123558" t="Jordan Robinson and I&apos;m not sure how to pass that through"><y>#</y><d>2022-12-15</d><h>16:59</h><r>Jordan Robinson</r>and I&apos;m not sure how to pass that through</z><z id="t1671123576" t="Jordan Robinson since otherwise if I call it without the seed in tests, well, it&apos;s random 😅"><y>#</y><d>2022-12-15</d><h>16:59</h><r>Jordan Robinson</r>since otherwise if I call it without the seed in tests, well, it&apos;s random <b>😅</b></z><z id="t1671123591" t="escherize is it data? it might be worth using malli to describe it"><y>#</y><d>2022-12-15</d><h>16:59</h><r>escherize</r>is it data? it might be worth using malli to describe it</z><z id="t1671123601" t="escherize then you will get easier generation"><y>#</y><d>2022-12-15</d><h>17:00</h><r>escherize</r>then you will get easier generation</z><z id="t1671123660" t="Jordan Robinson that&apos;s a good point, I guess I&apos;m looking for an easy way out as we already have (generate-thing)"><y>#</y><d>2022-12-15</d><h>17:01</h><r>Jordan Robinson</r>that&apos;s a good point, I guess I&apos;m looking for an easy way out as we already have <code>(generate-thing)</code></z><z id="t1671123679" t="escherize how about…"><y>#</y><d>2022-12-15</d><h>17:01</h><r>escherize</r>how about…</z><z id="t1671123712" t="escherize (mg/generate [:and {:gen/fmap #(generate-thing %)} int?] {:seed 10})"><y>#</y><d>2022-12-15</d><h>17:01</h><r>escherize</r><pre>(mg/generate
 [:and {:gen/fmap #(generate-thing %)} int?]
 {:seed 10})</pre></z><z id="t1671123720" t="escherize O_o"><y>#</y><d>2022-12-15</d><h>17:02</h><r>escherize</r>O_o</z><z id="t1671123742" t="escherize probably not super good, since the schema is meaningless now"><y>#</y><d>2022-12-15</d><h>17:02</h><r>escherize</r>probably not super good, since the schema is meaningless now</z><z id="t1671123745" t="Jordan Robinson aha I wasn&apos;t sure if that would work, as if I use that to validate as well will it try and think the input should also be an int?"><y>#</y><d>2022-12-15</d><h>17:02</h><r>Jordan Robinson</r>aha I wasn&apos;t sure if that would work, as if I use that to validate as well will it try and think the input should also be an int?</z><z id="t1671123746" t="Jordan Robinson yeah"><y>#</y><d>2022-12-15</d><h>17:02</h><r>Jordan Robinson</r>yeah</z><z id="t1671123756" t="escherize you can use it to generate.."><y>#</y><d>2022-12-15</d><h>17:02</h><r>escherize</r>you can use it to generate..</z><z id="t1671123777" t="escherize (mg/generate [:and {:gen/fmap #(generate-thing %)} [:or int? [:fn ..check for mything..]] {:seed 10})"><y>#</y><d>2022-12-15</d><h>17:02</h><r>escherize</r><pre>(mg/generate
 [:and {:gen/fmap #(generate-thing %)} 
  [:or int? [:fn ..check for mything..]]
 {:seed 10})</pre></z><z id="t1671123790" t="Jordan Robinson ahh that&apos;s interesting"><y>#</y><d>2022-12-15</d><h>17:03</h><r>Jordan Robinson</r>ahh that&apos;s interesting</z><z id="t1671123790" t="escherize really weird though"><y>#</y><d>2022-12-15</d><h>17:03</h><r>escherize</r>really weird though</z><z id="t1671123798" t="Jordan Robinson yes very weird, 😅 I guess that&apos;s how my brain went to trying to get a seed value in at first"><y>#</y><d>2022-12-15</d><h>17:03</h><r>Jordan Robinson</r>yes very weird, <b>😅</b> I guess that&apos;s how my brain went to trying to get a seed value in at first</z><z id="t1671123812" t="escherize yeah not sure it’s super easy"><y>#</y><d>2022-12-15</d><h>17:03</h><r>escherize</r>yeah not sure it’s super easy</z><z id="t1671123887" t="escherize actually.. in: (malli/schema [:fn {:gen/fmap (fn [_] (generate-thing {:seed ???}))} (fn [thing] (validate-thing thing))])"><y>#</y><d>2022-12-15</d><h>17:04</h><r>escherize</r>actually.. in:
<pre>(malli/schema [:fn
                 {:gen/fmap
                  (fn [_]
                    (generate-thing {:seed ???}))}
                 (fn [thing] (validate-thing thing))])</pre></z><z id="t1671123898" t="escherize what would be getting mapped over?"><y>#</y><d>2022-12-15</d><h>17:04</h><r>escherize</r>what would be getting mapped over?</z><z id="t1671123924" t="Jordan Robinson ah nothing, but it does work, I ripped it from the malli test code"><y>#</y><d>2022-12-15</d><h>17:05</h><r>Jordan Robinson</r>ah nothing, but it does work, I ripped it from the malli test code</z><z id="t1671123958" t="Jordan Robinson this is the relevant example: (is (= 42 (mg/generate [:re {:gen/fmap (fn [_] 42) :gen/schema :int} #&quot;abc&quot;]))"><y>#</y><d>2022-12-15</d><h>17:05</h><r>Jordan Robinson</r>this is the relevant example:
<pre>(is (= 42 (mg/generate [:re
                            {:gen/fmap (fn [_] 42)
                             :gen/schema :int}
                            #&quot;abc&quot;]))</pre></z><z id="t1671123975" t="Jordan Robinson ( https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L171 )"><y>#</y><d>2022-12-15</d><h>17:06</h><r>Jordan Robinson</r>(<a href="https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L171" target="_blank">https://github.com/metosin/malli/blob/master/test/malli/generator_test.cljc#L171</a>)</z><z id="t1671123976" t="escherize but you can generate values from a regex"><y>#</y><d>2022-12-15</d><h>17:06</h><r>escherize</r>but you can generate values from a regex</z><z id="t1671123985" t="escherize i guess you can generate values form a :fn schema too"><y>#</y><d>2022-12-15</d><h>17:06</h><r>escherize</r>i guess you can generate values form a :fn schema too</z><z id="t1671124089" t="Jordan Robinson thanks very much for your help btw, I&apos;m about to finish today but you&apos;ve given me some very interesting ideas"><y>#</y><d>2022-12-15</d><h>17:08</h><r>Jordan Robinson</r>thanks very much for your help btw, I&apos;m about to finish today but you&apos;ve given me some very interesting ideas</z><z id="t1671124132" t="escherize Nice! yeah I am starting on porting a giant codebase from spec and schema (with plenty of custom macros) to malli. Fun times!"><y>#</y><d>2022-12-15</d><h>17:08</h><r>escherize</r>Nice! yeah I am starting on porting a giant codebase from spec and schema (with plenty of custom macros) to malli. Fun times!</z><z id="t1671124154" t="Jordan Robinson I&apos;m in somewhat of a similar situation, it&apos;s fun till it isn&apos;t has been my experience so far 😅"><y>#</y><d>2022-12-15</d><h>17:09</h><r>Jordan Robinson</r>I&apos;m in somewhat of a similar situation, it&apos;s fun till it isn&apos;t has been my experience so far <b>😅</b></z><z id="t1671124227" t="escherize hope your pulse doesn’t rise too much over it 😛"><y>#</y><d>2022-12-15</d><h>17:10</h><r>escherize</r>hope your pulse doesn’t rise too much over it <b>😛</b></z><z id="t1671707753" t="Jordan Robinson as an update on this, I ended up writing a custom generator using the clojure test check generators in the end, thanks again for all your help"><y>#</y><d>2022-12-22</d><h>11:15</h><r>Jordan Robinson</r>as an update on this, I ended up writing a custom generator using the clojure test check generators in the end, thanks again for all your help</z><z id="t1671122285" t="lepistane I am unable to find a solution to what should be simple thing. How do i convert date string to LocalDateTime object automatically? (i am assuming this is request coercion) This is my muuntaja instance (def muuntaja-instance (m/create (-&gt; m/default-options (assoc-in [:formats &quot;application/json&quot; :decoder-opts] {:decode-key-fn csk/-&gt;kebab-case-keyword &lt;&lt;???&gt;&gt; #(java.time.LocalDate/parse %)}) (assoc-in [:formats &quot;application/json&quot; :encoder-opts] {:encode-key-fn csk/-&gt;camelCaseString :date-format &quot;yyyy-MM-dd&quot;}) "><y>#</y><d>2022-12-15</d><h>16:38</h><w>lepistane</w>I am unable to find a solution to what should be simple thing.
How do i convert date string to LocalDateTime object automatically?
(i am assuming this is request coercion)

This is my muuntaja instance
<pre>(def muuntaja-instance
  (m/create
   (-&gt; m/default-options
      (assoc-in [:formats &quot;application/json&quot; :decoder-opts] {:decode-key-fn csk/-&gt;kebab-case-keyword
                                                             &lt;&lt;???&gt;&gt; #(java.time.LocalDate/parse %)})
      (assoc-in [:formats &quot;application/json&quot; :encoder-opts] {:encode-key-fn csk/-&gt;camelCaseString
                                                             :date-format &quot;yyyy-MM-dd&quot;}) </pre>
</z><z id="t1671124246" t="Ben Sless You have to define your own schema type for that, unfortunately, but it&apos;s pretty easy"><y>#</y><d>2022-12-15</d><h>17:10</h><r>Ben Sless</r>You have to define your own schema type for that, unfortunately, but it&apos;s pretty easy</z><z id="t1671124268" t="escherize yesterday I wrote an x/defn macro that behaves like Schema’s s/defn. (mx/defn does not throw with incorrect :in or :out.) Is there a library or project to mirror little utilities like that in Schema or Spec?"><y>#</y><d>2022-12-15</d><h>17:11</h><w>escherize</w>yesterday I wrote an x/defn macro that behaves like Schema’s s/defn. (mx/defn does not throw with incorrect :in or :out.) Is there a library or project to mirror little utilities like that in Schema or Spec?</z><z id="t1671124279" t="escherize What other migration strats have you found useful?"><y>#</y><d>2022-12-15</d><h>17:11</h><w>escherize</w>What other migration strats have you found useful?</z><z id="t1671127108" t="dvingo there is also https://github.com/CrypticButter/snoop"><y>#</y><d>2022-12-15</d><h>17:58</h><r>dvingo</r>there is also
<a href="https://github.com/CrypticButter/snoop" target="_blank">https://github.com/CrypticButter/snoop</a></z><z id="t1671127156" t="dvingo mx/defn should throw when instrumentation is enabled"><y>#</y><d>2022-12-15</d><h>17:59</h><r>dvingo</r><code>mx/defn</code> should throw when instrumentation is enabled</z><z id="t1671127170" t="escherize it does"><y>#</y><d>2022-12-15</d><h>17:59</h><r>escherize</r>it does</z><z id="t1671127219" t="escherize snoop is cool, but i want to stick to vanilla ways of doing things"><y>#</y><d>2022-12-15</d><h>18:00</h><r>escherize</r>snoop is cool, but i want to stick to vanilla ways of doing things</z><z id="t1671127249" t="escherize my macro just calls instrument at defn creation time"><y>#</y><d>2022-12-15</d><h>18:00</h><r>escherize</r>my macro just calls instrument at defn creation time</z><z id="t1671127262" t="escherize with a specific filter to match only the current function"><y>#</y><d>2022-12-15</d><h>18:01</h><r>escherize</r>with a specific filter to match only the current function</z><z id="t1671127784" t="ikitommi wanted to keep mx/defn slim. thought of adding the Schema-style :always|never-validate hints too."><y>#</y><d>2022-12-15</d><h>18:09</h><r>ikitommi</r>wanted to keep <code>mx/defn</code> slim. thought of adding the Schema-style <code>:always|never-validate</code> hints too.</z><z id="t1671131839" t="escherize how would you implement the never validate mode?"><y>#</y><d>2022-12-15</d><h>19:17</h><r>escherize</r>how would you implement the never validate mode?</z><z id="t1671131902" t="escherize I have a macro emitting the function with an extra { :: validate! id} metadata and emitting an instrumentation filter after doing the core/defn call. so that’s a way to do the always-validate behavior"><y>#</y><d>2022-12-15</d><h>19:18</h><r>escherize</r>I have a macro emitting the function with an extra {<b>::</b>validate! id} metadata and emitting an instrumentation filter after doing the core/defn call. so that’s a way to do the always-validate behavior</z><z id="t1671131918" t="escherize not sure how to guard it, maybe add something into mi/-strument where it filters out on a certain fxn metadata value"><y>#</y><d>2022-12-15</d><h>19:18</h><r>escherize</r>not sure how to guard it, maybe add something into mi/-strument where it filters out on a certain fxn metadata value</z><z id="t1671149189" t="escherize relevant bit of :always-validate https://github.com/metabase/metabase/pull/27218/files#diff-e29756aed1e2e2cbce8a26a8e4b2e1cbedfb83cd4d853cf6942455e49516e4d8R44"><y>#</y><d>2022-12-16</d><h>00:06</h><r>escherize</r>relevant bit of :always-validate <a href="https://github.com/metabase/metabase/pull/27218/files#diff-e29756aed1e2e2cbce8a26a8e4b2e1cbedfb83cd4d853cf6942455e49516e4d8R44" target="_blank">https://github.com/metabase/metabase/pull/27218/files#diff-e29756aed1e2e2cbce8a26a8e4b2e1cbedfb83cd4d853cf6942455e49516e4d8R44</a></z><z id="t1671127208" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] taking the coercer discussion here to thread"><y>#</y><d>2022-12-15</d><h>18:00</h><w>Ben Sless</w><a>@ikitommi</a> taking the coercer discussion here to thread</z><z id="t1671127254" t="Ben Sless I assume the 1 arity for coercer decodes or throws, would be nice if we could have 3 arity for on success and on failure continuations, where the on-success takes the decoded value and on-failure takes the explained result"><y>#</y><d>2022-12-15</d><h>18:00</h><r>Ben Sless</r>I assume the 1 arity for coercer decodes or throws, would be nice if we could have 3 arity for on success and on failure continuations, where the on-success takes the decoded value and on-failure takes the explained result</z><z id="t1671127848" t="ikitommi sure, that would work as the arities woudn’t clash."><y>#</y><d>2022-12-15</d><h>18:10</h><r>ikitommi</r>sure, that would work as the arities woudn’t clash.</z><z id="t1671127905" t="ikitommi want to make a PR?"><y>#</y><d>2022-12-15</d><h>18:11</h><r>ikitommi</r>want to make a PR?</z><z id="t1671127973" t="ikitommi I like the idea. control to the user."><y>#</y><d>2022-12-15</d><h>18:12</h><r>ikitommi</r>I like the idea. control to the user.</z><z id="t1671129219" t="Ben Sless Will do"><y>#</y><d>2022-12-15</d><h>18:33</h><r>Ben Sless</r>Will do</z><z id="t1671129301" t="Ben Sless Sketch for more robust time schemas"><y>#</y><d>2022-12-15</d><h>18:35</h><w>Ben Sless</w>Sketch for more robust time schemas</z><z id="t1671129327" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] feedback / ideas before I pursue this path further?"><y>#</y><d>2022-12-15</d><h>18:35</h><r>Ben Sless</r><a>@ikitommi</a> feedback / ideas before I pursue this path further?</z><z id="t1671129411" t="Ben Sless And thoughts regarding adding an epoch transformer?"><y>#</y><d>2022-12-15</d><h>18:36</h><r>Ben Sless</r>And thoughts regarding adding an epoch transformer?</z><z id="t1671171035" t="ikitommi Looks good. Quick comments: • cljs + bundle size. If you want to use malli.time , it will brings the generators in, as multimethods don&apos;t get DCEd, it&apos;s a lot of extra. README defines how to check the bundle size reports. Option to have malli.time and malli.time.generators , which sucks too. • If this is only for Clj now, then not a big issue. Could be then malli.experimental.time - when temporal/cljs solution comes, it most likely changes a bit. • Schema types could be namespaced with time , e.g. :time/local-date , thinking of doing same for malli.util schemas."><y>#</y><d>2022-12-16</d><h>06:10</h><r>ikitommi</r>Looks good. Quick comments:
• cljs + bundle size. If you want to use <code>malli.time</code>, it will brings the generators in, as multimethods don&apos;t get DCEd, it&apos;s a lot of extra. README defines how to check the bundle size reports. Option to have <code>malli.time</code> and <code>malli.time.generators</code> , which sucks too.
• If this is only for Clj now, then not a big issue. Could be then <code>malli.experimental.time</code> - when temporal/cljs solution comes, it most likely changes a bit.
• Schema types could be namespaced with <code>time</code>, e.g. <code>:time/local-date</code>, thinking of doing same for malli.util schemas.</z><z id="t1671176035" t="Ben Sless • cljs: not really sure how to approach that so I just punted and did clj only • will move to experimental for now • namespacing: I thought I did"><y>#</y><d>2022-12-16</d><h>07:33</h><r>Ben Sless</r>• cljs: not really sure how to approach that so I just punted and did clj only
• will move to experimental for now
• namespacing: I thought I did</z><z id="t1671181275" t="ikitommi namespace, so you did, didn’t notice, brilliant! 🙂"><y>#</y><d>2022-12-16</d><h>09:01</h><r>ikitommi</r>namespace, so you did, didn’t notice, brilliant! <b>🙂</b></z><z id="t1671182071" t="juhoteperi I think it would be OK to merge and maybe even release clj-only version first"><y>#</y><d>2022-12-16</d><h>09:14</h><r>juhoteperi</r>I think it would be OK to merge and maybe even release clj-only version first</z><z id="t1671182094" t="juhoteperi Though there is some danger in that case that something in the API will be hard to implement on Cljs side"><y>#</y><d>2022-12-16</d><h>09:14</h><r>juhoteperi</r>Though there is some danger in that case that something in the API will be hard to implement on Cljs side</z><z id="t1671182329" t="juhoteperi I could explore using date-io as a facade to different JS date libs, so users can use whatever they want: https://github.com/dmtrKovalenko/date-io#projects"><y>#</y><d>2022-12-16</d><h>09:18</h><r>juhoteperi</r>I could explore using date-io as a facade to different JS date libs, so users can use whatever they want: <a href="https://github.com/dmtrKovalenko/date-io#projects" target="_blank">https://github.com/dmtrKovalenko/date-io#projects</a></z><z id="t1671183208" t="juhoteperi Adding clj-only as experimental ns sounds good to me"><y>#</y><d>2022-12-16</d><h>09:33</h><r>juhoteperi</r>Adding clj-only as experimental ns sounds good to me</z><z id="t1671204514" t="valtteri Personally I’m a bit concerned about the longevity of date-io and would appreciate malli.time to be built upon something that will last over time. However I trust [:attrs {:href &quot;/_/_/users/U061V0GG2&quot;}] ‘s opinion over mine 🙂 "><y>#</y><d>2022-12-16</d><h>15:28</h><r>valtteri</r>Personally I’m a bit concerned about the longevity of date-io and would appreciate malli.time to be built upon something that will last over time. However I trust <a>@U061V0GG2</a> ‘s opinion over mine <b>🙂</b> </z><z id="t1671204581" t="juhoteperi Yeah the issue about Temporal support on date-io shows the the API isn&apos;t very well designed"><y>#</y><d>2022-12-16</d><h>15:29</h><r>juhoteperi</r>Yeah the issue about Temporal support on date-io shows the the API isn&apos;t very well designed</z><z id="t1671204629" t="juhoteperi But building our own thing to to support different libs isn&apos;t much better either"><y>#</y><d>2022-12-16</d><h>15:30</h><r>juhoteperi</r>But building our own thing to to support different libs isn&apos;t much better either</z><z id="t1671342064" t="Ben Sless Besides separating out generators code and providing acceptors for json schema, any other things to keep in mind?"><y>#</y><d>2022-12-18</d><h>05:41</h><r>Ben Sless</r>Besides separating out generators code and providing acceptors for json schema, any other things to keep in mind?</z><z id="t1671364382" t="Ben Sless Draft MR is ready, your feedback is appreciated https://github.com/metosin/malli/pull/802"><y>#</y><d>2022-12-18</d><h>11:53</h><r>Ben Sless</r>Draft MR is ready, your feedback is appreciated
<a href="https://github.com/metosin/malli/pull/802" target="_blank">https://github.com/metosin/malli/pull/802</a></z><z id="t1671429462" t="Ben Sless [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] I think it&apos;s ready for review, besides adding tests the design is pretty settled. Only thing I&apos;m not sure about is the parsing code which exists in the core ns."><y>#</y><d>2022-12-19</d><h>05:57</h><r>Ben Sless</r><a>@ikitommi</a> I think it&apos;s ready for review, besides adding tests the design is pretty settled.
Only thing I&apos;m not sure about is the parsing code which exists in the core ns.</z><z id="t1671137422" t="escherize Before I build it myself — Is there a way to get a descirption of a schema in malli.core? e.g. [;map [:x int?]] =&gt; “A map containing: x, an integer”"><y>#</y><d>2022-12-15</d><h>20:50</h><w>escherize</w>Before I build it myself — Is there a way to get a descirption of a schema in malli.core? e.g. <code>[;map [:x int?]]</code> =&gt; “A map containing: x, an integer”</z><z id="t1671144479" t="escherize If it did, Given a malli schema, it should return a string with a description of the shape it expects."><y>#</y><d>2022-12-15</d><h>22:47</h><r>escherize</r>If it did, Given a malli schema, it should return a string with a description of the shape it expects.</z><z id="t1671144523" t="escherize Are there problems with doing that? I figure a call to m/ast, then dispatching on :type should be sufficient. wdyt?"><y>#</y><d>2022-12-15</d><h>22:48</h><r>escherize</r>Are there problems with doing that? I figure a call to m/ast, then dispatching on :type should be sufficient. wdyt?</z><z id="t1671169704" t="ikitommi you should use m/walk + dispatch on type. Each Schema implements it&apos;s own -walk so all the children are walked correctly, see https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc on how to do this."><y>#</y><d>2022-12-16</d><h>05:48</h><r>ikitommi</r>you should use <code>m/walk</code> + dispatch on type. Each Schema implements it&apos;s own <code>-walk</code> so all the children are walked correctly, see <a href="https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc" target="_blank">https://github.com/metosin/malli/blob/master/src/malli/json_schema.cljc</a> on how to do this.</z><z id="t1671169792" t="ikitommi but, an interesting idea!"><y>#</y><d>2022-12-16</d><h>05:49</h><r>ikitommi</r>but, an interesting idea!</z><z id="t1671207130" t="escherize Could you help me understand the benefits of using walk vs ast? Is walk more stable?"><y>#</y><d>2022-12-16</d><h>16:12</h><r>escherize</r>Could you help me understand the benefits of using walk vs ast? Is walk more stable?</z><z id="t1671208670" t="ikitommi All schemas implement the m/-walk . So you can walk over any schema, even those defined in user space. (m/walk schema (m/schema-walker identity)) works always. With AST, you have to know all schemas ahead of time to know how to handle those. In your use case, I guess you need to handle all schemas anyway, you can do the same with AST. Just that it breaks if someone changes the AST for a schema (each schema controls how it looks). There is a disclaimer in Malli README not to use the AST as a persistence model, could change, no no plans to break it and will avoid doing that. We are using AST walking too in projects. But, walk is always safe."><y>#</y><d>2022-12-16</d><h>16:37</h><r>ikitommi</r>All schemas implement the <code>m/-walk</code>. So you can walk over any schema, even those defined in user space. <code>(m/walk schema (m/schema-walker identity))</code> works always. With AST, you have to know all schemas ahead of time to know how to handle those. In your use case, I guess you need to handle all schemas anyway, you can do the same with AST. Just that it breaks if someone changes the AST for a schema (each schema controls how it looks). There is a disclaimer in Malli README not to use the AST as a persistence model, could change, no no plans to break it and will avoid doing that. We are using AST walking too in projects. But, walk is always safe.</z><z id="t1671208738" t="escherize Thanks for explaining that 🙏 I am looking into walk and schema-walker now."><y>#</y><d>2022-12-16</d><h>16:38</h><r>escherize</r>Thanks for explaining that <b>🙏</b> I am looking into walk and schema-walker now.</z><z id="t1671210323" t="escherize Here’s a self contained example. I used cond since its easier to fit. I’ll actually use a multimethod though (mc/walk [:map [:x :int] [:y :string]] (fn [schema _path children _options] (println &quot;-------&quot;) (println &quot;schema:&quot; schema) (println &quot;children:&quot; children) (cond (= (mc/type schema) :int) &quot;INTEGER&quot; (= (mc/type schema) :string) &quot;STRING&quot; (= (mc/type schema) :map) (str &quot;map of &quot; (str/join &quot;&quot; (mapv (fn [[k _ v]] (pr-str [k v])) children))) :else schema)))"><y>#</y><d>2022-12-16</d><h>17:05</h><r>escherize</r>Here’s a self contained example. I used cond since its easier to fit. I’ll actually use a multimethod though
<pre>(mc/walk
 [:map [:x :int] [:y :string]]
 (fn [schema _path children _options]
   (println &quot;-------&quot;)
   (println &quot;schema:&quot; schema)
   (println &quot;children:&quot; children)
   (cond
     (= (mc/type schema) :int) &quot;INTEGER&quot;
     (= (mc/type schema) :string) &quot;STRING&quot;
     (= (mc/type schema) :map) (str &quot;map of &quot;
                                    (str/join &quot;&quot; (mapv (fn [[k _ v]] (pr-str [k v]))
                                                       children)))
     :else schema)))</pre></z><z id="t1671210358" t="escherize I don’t think schema-walker is the way to go, since I dont want to ultimately return a schema"><y>#</y><d>2022-12-16</d><h>17:05</h><r>escherize</r>I don’t think schema-walker is the way to go, since I dont want to ultimately return a schema</z><z id="t1671210581" t="escherize maybe I can attach the stringified explaination to the schema as a property, and look for the prop on children?"><y>#</y><d>2022-12-16</d><h>17:09</h><r>escherize</r>maybe I can attach the stringified explaination to the schema as a property, and look for the prop on children?</z><z id="t1671210585" t="ikitommi I would copy the malli.json-schema and start from that"><y>#</y><d>2022-12-16</d><h>17:09</h><r>ikitommi</r>I would copy the <code>malli.json-schema</code> and start from that</z><z id="t1671210650" t="ikitommi it&apos;s a postwalk, you get the transformed children to your callback, should be straightforward to implement what you want"><y>#</y><d>2022-12-16</d><h>17:10</h><r>ikitommi</r>it&apos;s a postwalk, you get the transformed children to your callback, should be straightforward to implement what you want</z><z id="t1671171035" t="ikitommi Looks good. Quick comments: • cljs + bundle size. If you want to use malli.time , it will brings the generators in, as multimethods don&apos;t get DCEd, it&apos;s a lot of extra. README defines how to check the bundle size reports. Option to have malli.time and malli.time.generators , which sucks too. • If this is only for Clj now, then not a big issue. Could be then malli.experimental.time - when temporal/cljs solution comes, it most likely changes a bit. • Schema types could be namespaced with time , e.g. :time/local-date , thinking of doing same for malli.util schemas."><y>#</y><d>2022-12-16</d><h>06:10</h><w>ikitommi</w>Looks good. Quick comments:
• cljs + bundle size. If you want to use <code>malli.time</code>, it will brings the generators in, as multimethods don&apos;t get DCEd, it&apos;s a lot of extra. README defines how to check the bundle size reports. Option to have <code>malli.time</code> and <code>malli.time.generators</code> , which sucks too.
• If this is only for Clj now, then not a big issue. Could be then <code>malli.experimental.time</code> - when temporal/cljs solution comes, it most likely changes a bit.
• Schema types could be namespaced with <code>time</code>, e.g. <code>:time/local-date</code>, thinking of doing same for malli.util schemas.</z><z id="t1671197733" t="Thomas Moerman small q: I sometimes see ?something arguments with the ? prefix in e.g. in Malli and other metosin code bases, is that a convention for a &quot;maybe&quot; (x or nil) argument?"><y>#</y><d>2022-12-16</d><h>13:35</h><w>Thomas Moerman</w>small q: I sometimes see <code>?something</code> arguments with the <code>?</code> prefix in e.g. in Malli and other metosin code bases, is that a convention for a &quot;maybe&quot; (x or nil) argument?</z><z id="t1671198611" t="Ben Sless Yes"><y>#</y><d>2022-12-16</d><h>13:50</h><r>Ben Sless</r>Yes</z><z id="t1671198638" t="Thomas Moerman cheers"><y>#</y><d>2022-12-16</d><h>13:50</h><r>Thomas Moerman</r>cheers</z><z id="t1671205467" t="ambrosebs FWIW when I see ?schema I think &quot;coercable to a Schema&quot;."><y>#</y><d>2022-12-16</d><h>15:44</h><r>ambrosebs</r>FWIW when I see <code>?schema</code> I think &quot;coercable to a Schema&quot;.</z><z id="t1671205508" t="ambrosebs and schema as more like &quot;an instance of Schema&quot;"><y>#</y><d>2022-12-16</d><h>15:45</h><r>ambrosebs</r>and <code>schema</code> as more like &quot;an instance of Schema&quot;</z><z id="t1671205530" t="ambrosebs at least, that helped with my reading of malli.core"><y>#</y><d>2022-12-16</d><h>15:45</h><r>ambrosebs</r>at least, that helped with my reading of malli.core</z><z id="t1671205886" t="Ben Sless Oh yeah It&apos;s a rougher sense of Maybe Could be nil, like ?properties, could be &quot;could be a schema, don&apos;t know yet&quot;"><y>#</y><d>2022-12-16</d><h>15:51</h><r>Ben Sless</r>Oh yeah
It&apos;s a rougher sense of Maybe
Could be nil, like ?properties, could be &quot;could be a schema, don&apos;t know yet&quot;</z><z id="t1671210490" t="Thomas Moerman Ah, yes, i see."><y>#</y><d>2022-12-16</d><h>17:08</h><r>Thomas Moerman</r>Ah, yes, i see.</z><z id="t1671210620" t="Thomas Moerman The coercion makes sense as well, especially in the context of Malli."><y>#</y><d>2022-12-16</d><h>17:10</h><r>Thomas Moerman</r>The coercion makes sense as well, especially in the context of Malli.</z><z id="t1671378843" t="respatialized basic question: is there a mechanism for annotating/adding descriptions to basic schema types in a manner similar to annotating map keys? Example use case: annotating tuple elements. I&apos;d like to attach more information than just :string alone. E.g. instead of: [:tuple :uuid :string :string] something like: [:tuple {:type :uuid :description &quot;The unique identifier for thing.&quot;} {:type :string :description &quot;The thing&apos;s annotation.&quot;} {:type :string :description &quot;The thing&apos;s title.&quot;}] is there an obvious way to do this that I&apos;ve just totally overlooked?"><y>#</y><d>2022-12-18</d><h>15:54</h><w>respatialized</w>basic question: is there a mechanism for annotating/adding descriptions to basic schema types in a manner similar to annotating map keys?

Example use case: annotating tuple elements. I&apos;d like to attach more information than just <code>:string</code> alone. E.g. instead of:
<pre>[:tuple :uuid :string :string]</pre>
something like:
<pre>[:tuple {:type :uuid :description &quot;The unique identifier for thing.&quot;} {:type :string :description &quot;The thing&apos;s annotation.&quot;} {:type :string :description &quot;The thing&apos;s title.&quot;}]</pre>
is there an obvious way to do this that I&apos;ve just totally overlooked?</z><z id="t1671379686" t="ikitommi Any schema can have properties, so: `[:tuple [:uuid {:description &quot;...&quot;}] [:string {...}] [:string {...}]]`"><y>#</y><d>2022-12-18</d><h>16:08</h><r>ikitommi</r>Any schema can have properties, so:
`[:tuple
 [:uuid {:description &quot;...&quot;}]
 [:string {...}]
 [:string {...}]]`</z><z id="t1671379853" t="respatialized yeah I remembered the [:string {:description &quot;...&quot;}] syntax not long after I posted this, thanks! duckie"><y>#</y><d>2022-12-18</d><h>16:10</h><r>respatialized</r>yeah I remembered the <code>[:string {:description &quot;...&quot;}]</code> syntax not long after I posted this, thanks!

<b>duckie</b></z><z id="t1671747664" t="Tiago Dall&apos;Oca quick question: is it normal for (mi/collect!) to be slow? I thought this macro could be at the end of every ns using defn schema metadata, but wouldn&apos;t be practical if it slowed down ns file evaluation 😕"><y>#</y><d>2022-12-22</d><h>22:21</h><w>Tiago Dall'Oca</w>quick question: is it normal for <code>(mi/collect!)</code> to be slow? I thought this macro could be at the end of every ns using defn schema metadata, but wouldn&apos;t be practical if it slowed down ns file evaluation <b>😕</b></z><z id="t1671749322" t="Tiago Dall&apos;Oca actually putting (do (mi/collect!) nil)) at the end of the file solved the issue"><y>#</y><d>2022-12-22</d><h>22:48</h><r>Tiago Dall'Oca</r>actually putting <code>(do (mi/collect!) nil))</code> at the end of the file solved the issue</z><z id="t1671749346" t="Tiago Dall&apos;Oca the problem was emacs trying to print a whole bunch of text (apparently more then 1MB!)"><y>#</y><d>2022-12-22</d><h>22:49</h><r>Tiago Dall'Oca</r>the problem was emacs trying to print a whole bunch of text (apparently more then 1MB!)</z><z id="t1671749322" t="Tiago Dall&apos;Oca actually putting (do (mi/collect!) nil)) at the end of the file solved the issue"><y>#</y><d>2022-12-22</d><h>22:48</h><w>Tiago Dall'Oca</w>actually putting <code>(do (mi/collect!) nil))</code> at the end of the file solved the issue</z><z id="t1671795362" t="armed Hi, is there a way to apply malli function schemas (`m/=&gt;`) to macros? Minimal example: (def ?ErrOrOpts [:or [:fn {:error/message &quot;should be Throwable&quot;} throwable?] [:map {:error/message &quot;should be a map&quot;} [:throwable [:fn {:error/message &quot;should be Throwable&quot;} throwable?]]]]) (def ?LogArgs [:function [:=&gt; [:cat ?Message] :nil] [:=&gt; [:cat ?Message ?ErrOrOpts] :nil]]) (m/=&gt; foo ?LogArgs) (defmacro foo ([msg] nil) ([msg err-or-opts] nil)) (comment (foo &quot;hello&quot;) ) blows up with: Invalid function arity (3): ((foo &quot;hello&quot;) nil &quot;hello&quot;) .... It seems that macro call is wrapped"><y>#</y><d>2022-12-23</d><h>11:36</h><w>armed</w>Hi, is there a way to apply malli function schemas (`m/=&gt;`)  to macros? Minimal example:
<pre>(def ?ErrOrOpts
  [:or
   [:fn {:error/message &quot;should be Throwable&quot;} throwable?]
   [:map {:error/message &quot;should be a map&quot;}
    [:throwable [:fn {:error/message &quot;should be Throwable&quot;} throwable?]]]])

(def ?LogArgs
  [:function
   [:=&gt; [:cat ?Message] :nil]
   [:=&gt; [:cat ?Message ?ErrOrOpts] :nil]])

(m/=&gt; foo ?LogArgs)
(defmacro foo
  ([msg] nil)
  ([msg err-or-opts] nil))

(comment 
  (foo &quot;hello&quot;)
  )</pre>
blows up with:
<pre>Invalid function arity (3):

  ((foo &quot;hello&quot;) nil &quot;hello&quot;)
....</pre>
It seems that macro call is wrapped</z><z id="t1671795851" t="armed the workaround seems is prepend args with two :any , e.g. [:=&gt; [:cat :any :any &lt;real marco args&gt;] :nil]"><y>#</y><d>2022-12-23</d><h>11:44</h><r>armed</r>the workaround seems is prepend args with two <code>:any</code>, e.g. <code>[:=&gt; [:cat :any :any &lt;real marco args&gt;] :nil]</code></z><z id="t1671795917" t="armed but error messages will contain all that extra stuff"><y>#</y><d>2022-12-23</d><h>11:45</h><r>armed</r>but error messages will contain all that extra stuff</z><z id="t1671803183" t="armed seems it is not possible to instrument macros properly, better to instrument functions which macro calls"><y>#</y><d>2022-12-23</d><h>13:46</h><r>armed</r>seems it is not possible to instrument macros properly, better to instrument functions which macro calls</z></g></div></body>