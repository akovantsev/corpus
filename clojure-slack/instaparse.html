<!DOCTYPE html>
<head><title>instaparse</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 152px;} r {min-width: 184px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#instaparse</h2><pre><i>generated UTC: 2023-02-13 19:05</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/instaparse/2023-02-09">https://clojurians-log.clojureverse.org/instaparse/2023-02-09</a></i><i>
messages: 1728</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter2(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}
function textFilter(text) {
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (s){
            var sid = s.getAttribute("id");
            text.split(' ').forEach(function (t) {
                if (t !== '') {
                    filterTextStyle.innerHTML += "\ng#" + sid + " > z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
                }
            });
        })
    }
}
function textFilter3(text) {
    console.time("text search");
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        const re = new RegExp( text, "i");
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (w){
            var zs = w.getElementsByTagName ("z");
            var zsArr = Array.prototype.slice.call(zs);
            var ids = zsArr
                .filter(function (el) {
                    return !re.test(el.innerText);
                })
                .map(function (el){
                    return el.getAttribute("id");
                });
            if (ids) {
                filterTextStyle.innerHTML += "\n#" + ids.join(",#") + " {display: none; opacity: 0.6}";
            }
        })
    }
    console.timeEnd("text search");
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><g id="s0"><z id="t1434257103" t="aengelberg @mhuebert: Re: recent instaparse-live changes: The memoization worked like a charm, the parsing is a lot faster now when only changing the sample. Great idea!"><y>#</y><d>2015-06-14</d><h>04:45</h><w>aengelberg</w>@mhuebert: Re: recent instaparse-live changes: The memoization worked like a charm, the parsing is a lot faster now when only changing the sample. Great idea!</z><z id="t1434420027" t="lucasbradstreet Howdy. instaparse-cljs 1.4.0.0-SNAPSHOT works with Clojure 1.7 now. Recent fixes from v1.3.5-1.4.0 haven&apos;t been ported to cljs yet. "><y>#</y><d>2015-06-16</d><h>02:00</h><w>lucasbradstreet</w>Howdy. instaparse-cljs 1.4.0.0-SNAPSHOT works with Clojure 1.7 now. Recent fixes from v1.3.5-1.4.0 haven&apos;t been ported to cljs yet. </z><z id="t1434420135" t="aengelberg cc @canweriotnow"><y>#</y><d>2015-06-16</d><h>02:02</h><w>aengelberg</w>cc @canweriotnow</z><z id="t1434420177" t="aengelberg @lucasbradstreet sweet!!! any plans to include tracing features? or is that not as applicable to cljs?"><y>#</y><d>2015-06-16</d><h>02:02</h><w>aengelberg</w>@lucasbradstreet sweet!!! any plans to include tracing features? or is that not as applicable to cljs?</z><z id="t1434420281" t="aengelberg A lot of the hacky namespace reloading would probably be not doable on the cljs side. So maybe it would hit performance a little bit to include conditional tracing everywhere"><y>#</y><d>2015-06-16</d><h>02:04</h><w>aengelberg</w>A lot of the hacky namespace reloading would probably be not doable on the cljs side. So maybe it would hit performance a little bit to include conditional tracing everywhere</z><z id="t1434420285" t="lucasbradstreet Depends on how hard it is to support. I can&apos;t throw too much more time into this for now. I think it usually makes sense to dev the parser in CLJ first, though instaparse-live may have changed my mind ;)"><y>#</y><d>2015-06-16</d><h>02:04</h><w>lucasbradstreet</w>Depends on how hard it is to support. I can&apos;t throw too much more time into this for now. I think it usually makes sense to dev the parser in CLJ first, though instaparse-live may have changed my mind ;)</z><z id="t1434420330" t="lucasbradstreet Ah, yeah, if that&apos;s required I&apos;ll probably pass on it for now. "><y>#</y><d>2015-06-16</d><h>02:05</h><w>lucasbradstreet</w>Ah, yeah, if that&apos;s required I&apos;ll probably pass on it for now. </z><z id="t1434497680" t="canweriotnow @lucasbradstreet: awesome. We&apos;re digging to find issues with processing certain chars or ranges in the cljs port... “%x41-57” works, but “%x41” doesn’t. “%x79-7A” doesn’t... possibly one of the char fns in instaparse.abnf (cljs) - clj version works fine."><y>#</y><d>2015-06-16</d><h>23:34</h><w>canweriotnow</w>@lucasbradstreet: awesome. We&apos;re digging to find issues with processing certain chars or ranges in the cljs port...  “%x41-57” works, but “%x41” doesn’t. “%x79-7A” doesn’t... possibly one of the char fns in instaparse.abnf (cljs) - clj version works fine.</z><z id="t1434497701" t="canweriotnow We&apos;ll submit an issue (or hopefully PR) when we track it down."><y>#</y><d>2015-06-16</d><h>23:35</h><w>canweriotnow</w>We&apos;ll submit an issue (or hopefully PR) when we track it down.</z><z id="t1434497960" t="aengelberg Yeah, playing around in my REPL, the %x41 does not work for some reason."><y>#</y><d>2015-06-16</d><h>23:39</h><w>aengelberg</w>Yeah, playing around in my REPL, the %x41 does not work for some reason.</z><z id="t1434498318" t="aengelberg https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118"><y>#</y><d>2015-06-16</d><h>23:45</h><w>aengelberg</w><a href="https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118" target="_blank">https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118</a></z><z id="t1434498396" t="aengelberg Should be (string (apply str (coerce-char (char-codes num1)))))"><y>#</y><d>2015-06-16</d><h>23:46</h><w>aengelberg</w>Should be (string (apply str (coerce-char (char-codes num1)))))</z><z id="t1434498444" t="lucasbradstreet Ah cool. I won&apos;t have much time to push these changes atm but if you want to send me a PR I&apos;ll merge it. "><y>#</y><d>2015-06-16</d><h>23:47</h><w>lucasbradstreet</w>Ah cool. I won&apos;t have much time to push these changes atm but if you want to send me a PR I&apos;ll merge it. </z><z id="t1434498537" t="canweriotnow Wow, awesome"><y>#</y><d>2015-06-16</d><h>23:48</h><w>canweriotnow</w>Wow, awesome</z><z id="t1434498545" t="aengelberg @lucasbradstreet Actually I can&apos;t really tell what the purpose of char-codes is."><y>#</y><d>2015-06-16</d><h>23:49</h><w>aengelberg</w>@lucasbradstreet Actually I can&apos;t really tell what the purpose of char-codes is.</z><z id="t1434498562" t="aengelberg It seems to take a character (possibly unicode) and split it into two characters. but at the REPL it doesn&apos;t seem to do that."><y>#</y><d>2015-06-16</d><h>23:49</h><w>aengelberg</w>It seems to take a character (possibly unicode) and split it into two characters. but at the REPL it doesn&apos;t seem to do that.</z><z id="t1434498758" t="lucasbradstreet Just off the top of my head it is to deal with multibyte chars by getting each byte (charCodeAt)"><y>#</y><d>2015-06-16</d><h>23:52</h><w>lucasbradstreet</w>Just off the top of my head it is to deal with multibyte chars by getting each byte (charCodeAt)</z><z id="t1434499063" t="canweriotnow hmm.. maybe %x41-57 didn&apos;t actually work, but just didn&apos;t throw like %x41 ... need to dig deeper."><y>#</y><d>2015-06-16</d><h>23:57</h><w>canweriotnow</w>hmm.. maybe <code>%x41-57</code> didn&apos;t actually work, but just didn&apos;t throw like <code>%x41</code>... need to dig deeper.</z><z id="t1434499185" t="canweriotnow The thing we&apos;re doing is generating parsers for various URI/IRI schemes from the ABNF in their respective RFCs, so we&apos;re problably hitting edge cases like crazy simple_smile"><y>#</y><d>2015-06-16</d><h>23:59</h><w>canweriotnow</w>The thing we&apos;re doing is generating parsers for various URI/IRI schemes from the ABNF in their respective RFCs, so we&apos;re problably hitting edge cases like crazy <b>simple_smile</b></z><z id="t1434499594" t="aengelberg That part of the abnf namespace seems not properly designed for supplementary characters altogether..."><y>#</y><d>2015-06-17</d><h>00:06</h><w>aengelberg</w>That part of the abnf namespace seems not properly designed for supplementary characters altogether...</z><z id="t1434499669" t="aengelberg It isn&apos;t using any utility (unlike the clj version) to turn an oversized integer into a series of two characters."><y>#</y><d>2015-06-17</d><h>00:07</h><w>aengelberg</w>It isn&apos;t using any utility (unlike the clj version) to turn an oversized integer into a series of two characters.</z><z id="t1434506978" t="aengelberg The get-char-combinator function needs a rework, so ABNF terminals like %x5D-10FFFF can work."><y>#</y><d>2015-06-17</d><h>02:09</h><w>aengelberg</w>The <code>get-char-combinator</code> function needs a rework, so ABNF terminals like <code>%x5D-10FFFF</code> can work.</z><z id="t1434507043" t="aengelberg JavaScript, unlike Java, does not seem to support regular expressions with \x{10FFFF} ."><y>#</y><d>2015-06-17</d><h>02:10</h><w>aengelberg</w>JavaScript, unlike Java, does not seem to support regular expressions with <code>\x{10FFFF}</code>.</z><z id="t1434507204" t="aengelberg In instaparse for Clojure, single characters are represented as a string combinator with the surrogate pair (two 16-bit chars side by side), and a character range uses the regex \x{10FFF} syntax. ClojureScript or JavaScript appear to not have much support for either of these things. It may be impossible to support Unicode character ranges in ABNF without introducing third-party js libraries."><y>#</y><d>2015-06-17</d><h>02:13</h><w>aengelberg</w>In instaparse for Clojure, single characters are represented as a string combinator with the surrogate pair (two 16-bit chars side by side), and a character range uses the regex <code>\x{10FFF}</code> syntax. ClojureScript or JavaScript appear to not have much support for either of these things. It may be impossible to support Unicode character ranges in ABNF without introducing third-party js libraries.</z><z id="t1434508812" t="aengelberg OK, the former is doable via goog.i18n.uChar/fromCharCode."><y>#</y><d>2015-06-17</d><h>02:40</h><w>aengelberg</w>OK, the former is doable via goog.i18n.uChar/fromCharCode.</z><z id="t1434513826" t="lucasbradstreet Nice! Yeah, this character support code is probably the weakest part of the port. "><y>#</y><d>2015-06-17</d><h>04:03</h><w>lucasbradstreet</w>Nice! Yeah, this character support code is probably the weakest part of the port. </z><z id="t1434513878" t="lucasbradstreet I&apos;m glad that you&apos;re finding these issues. I had a feeling there were some lurking issues there."><y>#</y><d>2015-06-17</d><h>04:04</h><w>lucasbradstreet</w>I&apos;m glad that you&apos;re finding these issues. I had a feeling there were some lurking issues there.</z><z id="t1434517003" t="aengelberg goog has some utils to work with surrogate strings, but the regex (char range) seems impossible without pulling in an external dependency like Regenerate. https://github.com/mathiasbynens/regenerate"><y>#</y><d>2015-06-17</d><h>04:56</h><w>aengelberg</w>goog has some utils to work with surrogate strings, but the regex (char range) seems impossible without pulling in an external dependency like Regenerate. <a href="https://github.com/mathiasbynens/regenerate" target="_blank">https://github.com/mathiasbynens/regenerate</a></z><z id="t1434519918" t="lucasbradstreet Ah, yeah, I think I’d rather recreate the functionality internally than pull in extra deps. Definitely a bit of a pain though."><y>#</y><d>2015-06-17</d><h>05:45</h><w>lucasbradstreet</w>Ah, yeah, I think I’d rather recreate the functionality internally than pull in extra deps. Definitely a bit of a pain though.</z><z id="t1434520044" t="lucasbradstreet Interesting https://mathiasbynens.be/notes/javascript-unicode"><y>#</y><d>2015-06-17</d><h>05:47</h><w>lucasbradstreet</w>Interesting <a href="https://mathiasbynens.be/notes/javascript-unicode" target="_blank">https://mathiasbynens.be/notes/javascript-unicode</a></z><z id="t1434520064" t="lucasbradstreet I wonder if this issue is true for all browsers"><y>#</y><d>2015-06-17</d><h>05:47</h><w>lucasbradstreet</w>I wonder if this issue is true for all browsers</z><z id="t1434520065" t="lucasbradstreet https://mathiasbynens.be/notes/es6-unicode-regex"><y>#</y><d>2015-06-17</d><h>05:47</h><w>lucasbradstreet</w><a href="https://mathiasbynens.be/notes/es6-unicode-regex" target="_blank">https://mathiasbynens.be/notes/es6-unicode-regex</a></z><z id="t1434520129" t="lucasbradstreet Actually, if you could create a PR with a failing cljs test case that would be a good place to start"><y>#</y><d>2015-06-17</d><h>05:48</h><w>lucasbradstreet</w>Actually, if you could create a PR with a failing cljs test case that would be a good place to start</z><z id="t1434560441" t="aengelberg https://github.com/lbradstreet/instaparse-cljs/pull/9"><y>#</y><d>2015-06-17</d><h>17:00</h><w>aengelberg</w><a href="https://github.com/lbradstreet/instaparse-cljs/pull/9" target="_blank">https://github.com/lbradstreet/instaparse-cljs/pull/9</a></z><z id="t1434562897" t="aengelberg Hmm, now I&apos;m mildly concerned because circleci is passing... ;)"><y>#</y><d>2015-06-17</d><h>17:41</h><w>aengelberg</w>Hmm, now I&apos;m mildly concerned because circleci is passing... ;)</z><z id="t1434563526" t="aengelberg Hmm, I think that&apos;s because there isn&apos;t really a notion of the cljs tests &quot;passing&quot; or &quot;failing&quot; (no exit codes)"><y>#</y><d>2015-06-17</d><h>17:52</h><w>aengelberg</w>Hmm, I think that&apos;s because there isn&apos;t really a notion of the cljs tests &quot;passing&quot; or &quot;failing&quot; (no exit codes)</z><z id="t1434610056" t="lucasbradstreet @aengelberg: I gave you commit access to instaparse-cljs, feel free to push anything you want, or create PRs and I’ll review them"><y>#</y><d>2015-06-18</d><h>06:47</h><w>lucasbradstreet</w>@aengelberg: I gave you commit access to instaparse-cljs, feel free to push anything you want, or create PRs and I’ll review them</z><z id="t1434639795" t="aengelberg Thanks @lucasbradstreet! I&apos;m working on some changes to clj instaparse that add special combinators for Unicode char ranges; it improves performance and makes it more portable to cljs."><y>#</y><d>2015-06-18</d><h>15:03</h><w>aengelberg</w>Thanks @lucasbradstreet! I&apos;m working on some changes to clj instaparse that add special combinators for Unicode char ranges; it improves performance and makes it more portable to cljs.</z><z id="t1434680449" t="aengelberg @lucasbradstreet: have you considered using cljx for the instaparse source code as well, so it&apos;s easier to merge upstream changes?"><y>#</y><d>2015-06-19</d><h>02:20</h><w>aengelberg</w>@lucasbradstreet: have you considered using cljx for the instaparse source code as well, so it&apos;s easier to merge upstream changes?</z><z id="t1434680732" t="lucasbradstreet Yes, that one is a bit of a trade off. There will definitely be more merge issues and it does kinda uglify the code a lot. It mostly depends on whether Mark would prefer separate cljs and clj, or cljx in an eventual upstream merge"><y>#</y><d>2015-06-19</d><h>02:25</h><w>lucasbradstreet</w>Yes, that one is a bit of a trade off. There will definitely be more merge issues and it does kinda uglify the code a lot. It mostly depends on whether Mark would prefer separate cljs and clj, or cljx in an eventual upstream merge</z><z id="t1434681165" t="aengelberg I was thinking it might actually make it easier to merge upstream changes, because currently if a feature is changed in the clj version, it is quietly merged into the clj source without changing the cljs side at all."><y>#</y><d>2015-06-19</d><h>02:32</h><w>aengelberg</w>I was thinking it might actually make it easier to merge upstream changes, because currently if a feature is changed in the clj version, it is quietly merged into the clj source without changing the cljs side at all.</z><z id="t1435077246" t="aengelberg [ANN] Instaparse 1.4.1 https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141"><y>#</y><d>2015-06-23</d><h>16:34</h><w>aengelberg</w>[ANN] Instaparse 1.4.1 <a href="https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141" target="_blank">https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141</a></z><z id="t1435092584" t="aengelberg @lucasbradstreet: I&apos;ve started a cljs-1.4.1 branch, that has the upstream commits merged in as well as a cljs port of the Unicode support (the unicode test case now passes!)"><y>#</y><d>2015-06-23</d><h>20:49</h><w>aengelberg</w>@lucasbradstreet: I&apos;ve started a <code>cljs-1.4.1</code> branch, that has the upstream commits merged in as well as a cljs port of the Unicode support (the unicode test case now passes!)</z><z id="t1435111345" t="lucasbradstreet Nicely done!"><y>#</y><d>2015-06-24</d><h>02:02</h><w>lucasbradstreet</w>Nicely done!</z><z id="t1435123099" t="lucasbradstreet @aengelberg: you&apos;re a machine!"><y>#</y><d>2015-06-24</d><h>05:18</h><w>lucasbradstreet</w>@aengelberg: you&apos;re a machine!</z><z id="t1435123163" t="lucasbradstreet I&apos;ll review the PR. Assuming all is well, I&apos;ll push a new snapshot and we can get ready for a prod artefact "><y>#</y><d>2015-06-24</d><h>05:19</h><w>lucasbradstreet</w>I&apos;ll review the PR. Assuming all is well, I&apos;ll push a new snapshot and we can get ready for a prod artefact </z><z id="t1435123478" t="aengelberg @lucasbradstreet: Thanks!"><y>#</y><d>2015-06-24</d><h>05:24</h><w>aengelberg</w>@lucasbradstreet: Thanks!</z><z id="t1435124619" t="lucasbradstreet New 1.4.1.0-SNAPSHOT on clojars simple_smile"><y>#</y><d>2015-06-24</d><h>05:43</h><w>lucasbradstreet</w>New 1.4.1.0-SNAPSHOT on clojars <b>simple_smile</b></z><z id="t1435124643" t="lucasbradstreet I’ll push 1.4.1.0 to clojars once mhuebert gives the OK"><y>#</y><d>2015-06-24</d><h>05:44</h><w>lucasbradstreet</w>I’ll push 1.4.1.0 to clojars once mhuebert gives the OK</z><z id="t1435124660" t="lucasbradstreet (or once we’ve got instaparse-live#8 figured out)"><y>#</y><d>2015-06-24</d><h>05:44</h><w>lucasbradstreet</w>(or once we’ve got instaparse-live#8 figured out)</z><z id="t1435124678" t="lucasbradstreet It’s great that we’re in sync again"><y>#</y><d>2015-06-24</d><h>05:44</h><w>lucasbradstreet</w>It’s great that we’re in sync again</z><z id="t1435124877" t="aengelberg Would recommend giving instaparse live &quot;the poop test&quot; a.k.a. insert :shit: at various places in the UI and see what breaks"><y>#</y><d>2015-06-24</d><h>05:47</h><w>aengelberg</w>Would recommend giving instaparse live &quot;the poop test&quot; a.k.a. insert <b>:shit:</b> at various places in the UI and see what breaks</z><z id="t1435124914" t="aengelberg U+1F4A9"><y>#</y><d>2015-06-24</d><h>05:48</h><w>aengelberg</w>U+1F4A9</z><z id="t1435125044" t="aengelberg (or any Unicode supplementary character, but poop is the most fun :D)"><y>#</y><d>2015-06-24</d><h>05:50</h><w>aengelberg</w>(or any Unicode supplementary character, but poop is the most fun :D)</z><z id="t1435211420" t="aengelberg Yay, it works! http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ"><y>#</y><d>2015-06-25</d><h>05:50</h><w>aengelberg</w>Yay, it works! <a href="http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ" target="_blank">http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ</a></z><z id="t1435218578" t="lucasbradstreet sweet!"><y>#</y><d>2015-06-25</d><h>07:49</h><w>lucasbradstreet</w>sweet!</z><z id="t1435218584" t="lucasbradstreet I’ll put out a release artifact then simple_smile"><y>#</y><d>2015-06-25</d><h>07:49</h><w>lucasbradstreet</w>I’ll put out a release artifact then <b>simple_smile</b></z><z id="t1435223779" t="lucasbradstreet 1.4.1.0 artifact is up simple_smile"><y>#</y><d>2015-06-25</d><h>09:16</h><w>lucasbradstreet</w>1.4.1.0 artifact is up <b>simple_smile</b></z><z id="t1435223787" t="lucasbradstreet Good work"><y>#</y><d>2015-06-25</d><h>09:16</h><w>lucasbradstreet</w>Good work</z><z id="t1435248243" t="aengelberg Thanks for being responsive / receptive to my changes! Looking forward to getting feedback from users on the new version."><y>#</y><d>2015-06-25</d><h>16:04</h><w>aengelberg</w>Thanks for being responsive / receptive to my changes! Looking forward to getting feedback from users on the new version.</z><z id="t1435248272" t="aengelberg cc @canweriotnow, unicode char ranges have now been restored to sanity 😄"><y>#</y><d>2015-06-25</d><h>16:04</h><w>aengelberg</w>cc @canweriotnow, unicode char ranges have now been restored to sanity <b>😄</b></z><z id="t1435248285" t="aengelberg ABNF char ranges, that is. (unicode support is also there if needed)"><y>#</y><d>2015-06-25</d><h>16:04</h><w>aengelberg</w>ABNF char ranges, that is. (unicode support is also there if needed)</z><z id="t1435274039" t="canweriotnow @aengelberg thx, awesome!"><y>#</y><d>2015-06-25</d><h>23:13</h><w>canweriotnow</w>@aengelberg thx, awesome!</z><z id="t1435297459" t="lucasbradstreet @aengelberg: not a problem. I’m really happy the port is getting some use simple_smile"><y>#</y><d>2015-06-26</d><h>05:44</h><w>lucasbradstreet</w>@aengelberg: not a problem. I’m really happy the port is getting some use <b>simple_smile</b></z><z id="t1435297548" t="aengelberg I know, I&apos;m excited as well ;)"><y>#</y><d>2015-06-26</d><h>05:45</h><w>aengelberg</w>I know, I&apos;m excited as well ;)</z><z id="t1437513242" t="marcofiset What are some approaches you guys use to interpret your parse tree?"><y>#</y><d>2015-07-21</d><h>21:14</h><w>marcofiset</w>What are some approaches you guys use to interpret your parse tree?</z><z id="t1437513739" t="socksy you can use multimethods dispatching on node type"><y>#</y><d>2015-07-21</d><h>21:22</h><w>socksy</w>you can use multimethods dispatching on node type</z><z id="t1437513905" t="socksy use a zipper to navigate the tree"><y>#</y><d>2015-07-21</d><h>21:25</h><w>socksy</w>use a zipper to navigate the tree</z><z id="t1437514436" t="socksy or heck, just use https://clojure.github.io/clojure/clojure.walk-api.html"><y>#</y><d>2015-07-21</d><h>21:33</h><w>socksy</w>or heck, just use <a href="https://clojure.github.io/clojure/clojure.walk-api.html" target="_blank">https://clojure.github.io/clojure/clojure.walk-api.html</a></z><z id="t1437514510" t="socksy recommend using postwalk, and then writing a function to do whatever you’re thinking"><y>#</y><d>2015-07-21</d><h>21:35</h><w>socksy</w>recommend using postwalk, and then writing a function to do whatever you’re thinking</z><z id="t1437514562" t="socksy depends on how you want to eval, it’s a wee bit harder for compilation, but not much. You just need to make sure you emit a string. One solution would be to treat it as a side effect of whatever function you use"><y>#</y><d>2015-07-21</d><h>21:36</h><w>socksy</w>depends on how you want to eval, it’s a wee bit harder for compilation, but not much. You just need to make sure you emit a string. One solution would be to treat it as a side effect of whatever function you use</z><z id="t1437514604" t="socksy admittedly, when I last did this I wasn’t using an instaparse’d parse tree, so maybe the technique varies a bit"><y>#</y><d>2015-07-21</d><h>21:36</h><w>socksy</w>admittedly, when I last did this I wasn’t using an instaparse’d parse tree, so maybe the technique varies a bit</z><z id="t1437514623" t="socksy think I re-implemented postwalk also"><y>#</y><d>2015-07-21</d><h>21:37</h><w>socksy</w>think I re-implemented postwalk also</z><z id="t1437514771" t="socksy seems instaparse you could maybe just use insta/transform"><y>#</y><d>2015-07-21</d><h>21:39</h><w>socksy</w>seems instaparse you could maybe just use insta/transform</z><z id="t1437514804" t="socksy which must do a walk of the tree, and takes a map of node type to function"><y>#</y><d>2015-07-21</d><h>21:40</h><w>socksy</w>which must do a walk of the tree, and takes a map of node type to function</z><z id="t1437516996" t="aengelberg @marcofiset insta/transform has always been sufficient for my use cases. Is there more sophisticated functionality you&apos;re looking for? If so, clojure.walk/[pre|post]walk might be the next step up."><y>#</y><d>2015-07-21</d><h>22:16</h><w>aengelberg</w>@marcofiset <code>insta/transform</code> has always been sufficient for my use cases. Is there more sophisticated functionality you&apos;re looking for? If so, <code>clojure.walk/[pre|post]walk</code> might be the next step up.</z><z id="t1437517272" t="marcofiset I am not looking for anything particular, just wanted to start a discussion on the subject. I&apos;m using multi methods for the moment and I was curious about what other people might be using. "><y>#</y><d>2015-07-21</d><h>22:21</h><w>marcofiset</w>I am not looking for anything particular, just wanted to start a discussion on the subject. I&apos;m using multi methods for the moment and I was curious about what other people might be using. </z><z id="t1437517431" t="marcofiset I didn&apos;t know about insta/transform, I&apos;ll definitely take a look."><y>#</y><d>2015-07-21</d><h>22:23</h><w>marcofiset</w>I didn&apos;t know about insta/transform, I&apos;ll definitely take a look.</z><z id="t1437517505" t="aengelberg Yeah, instaparse.core/transform is a simple function that does the trick for simple parse tree consumption."><y>#</y><d>2015-07-21</d><h>22:25</h><w>aengelberg</w>Yeah, <code>instaparse.core/transform</code> is a simple function that does the trick for simple parse tree consumption.</z><z id="t1437517520" t="aengelberg Hey, that rhymes"><y>#</y><d>2015-07-21</d><h>22:25</h><w>aengelberg</w>Hey, that rhymes</z><z id="t1437517550" t="aengelberg @marcofiset Take a look at this section of the readme: https://github.com/engelberg/instaparse#transforming-the-tree"><y>#</y><d>2015-07-21</d><h>22:25</h><w>aengelberg</w>@marcofiset Take a look at this section of the readme: <a href="https://github.com/engelberg/instaparse#transforming-the-tree" target="_blank">https://github.com/engelberg/instaparse#transforming-the-tree</a></z><z id="t1437518172" t="marcofiset Wow, I&apos;m really impressed with the arithmetic example! Very straightforward and simple. My multi methods solution is going to the trash and will be replaced by something similar 😃"><y>#</y><d>2015-07-21</d><h>22:36</h><w>marcofiset</w>Wow, I&apos;m really impressed with the arithmetic example! Very straightforward and simple. My multi methods solution is going to the trash and will be replaced by something similar <b>😃</b></z><z id="t1437564004" t="marcofiset I’ve been noticing something with a new project using instaparse. It seems that everything I get out of the parser is wrapped in a list. I don’t recall having seen this behaviour before. Can someone enlighten me? simple_smile"><y>#</y><d>2015-07-22</d><h>11:20</h><w>marcofiset</w>I’ve been noticing something with a new project using instaparse. It seems that everything I get out of the parser is wrapped in a list. I don’t recall having seen this behaviour before. Can someone enlighten me? <b>simple_smile</b></z><z id="t1437566567" t="marcofiset After a couple of quick tests, it seems to be my particular grammar that causes this, but I&apos;m not sure why."><y>#</y><d>2015-07-22</d><h>12:02</h><w>marcofiset</w>After a couple of quick tests, it seems to be my particular grammar that causes this, but I&apos;m not sure why.</z><z id="t1437582944" t="aengelberg @marcofiset: are you hiding the root tag (`&lt;S&gt; = ...`)? If so, this is by design as explained in this section of the readme: https://github.com/engelberg/instaparse#hiding-tags"><y>#</y><d>2015-07-22</d><h>16:35</h><w>aengelberg</w>@marcofiset: are you hiding the root tag (`&lt;S&gt; = ...`)? If so, this is by design as explained in this section of the readme: <a href="https://github.com/engelberg/instaparse#hiding-tags" target="_blank">https://github.com/engelberg/instaparse#hiding-tags</a></z><z id="t1437597114" t="marcofiset You&apos;re right, that was it."><y>#</y><d>2015-07-22</d><h>20:31</h><w>marcofiset</w>You&apos;re right, that was it.</z><z id="t1437597153" t="marcofiset I decided not to ignore it instead, and introduced a hidden sub-expression which handles the recursivity."><y>#</y><d>2015-07-22</d><h>20:32</h><w>marcofiset</w>I decided not to ignore it instead, and introduced a hidden sub-expression which handles the recursivity.</z><z id="t1438909199" t="micha hello everyone, is there a grammar for clojure source that i can use in instaparse?"><y>#</y><d>2015-08-07</d><h>00:59</h><w>micha</w>hello everyone, is there a grammar for clojure source that i can use in instaparse?</z><z id="t1438909233" t="micha or EDN would probably work in a pinch too"><y>#</y><d>2015-08-07</d><h>01:00</h><w>micha</w>or EDN would probably work in a pinch too</z><z id="t1438909483" t="aengelberg Not that I know of. Maybe this would help, you could port the ANTLR grammar into EBNF somehow https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure"><y>#</y><d>2015-08-07</d><h>01:04</h><w>aengelberg</w>Not that I know of. Maybe this would help, you could port the ANTLR grammar into EBNF somehow <a href="https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure" target="_blank">https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure</a></z><z id="t1438909609" t="aengelberg Although an EDN parser wouldn&apos;t be too hard to make from scratch. It&apos;s mostly balanced parens with various types of leafs or delimiters. The hard part is strings, handling all the \&quot; stuff"><y>#</y><d>2015-08-07</d><h>01:06</h><w>aengelberg</w>Although an EDN parser wouldn&apos;t be too hard to make from scratch. It&apos;s mostly balanced parens with various types of leafs or delimiters. The hard part is strings, handling all the <code>\&quot;</code> stuff</z><z id="t1438909642" t="aengelberg And comments"><y>#</y><d>2015-08-07</d><h>01:07</h><w>aengelberg</w>And comments</z><z id="t1438909651" t="micha yeah i was thinking that also, really i just need curly braces, because i only want to parse maps"><y>#</y><d>2015-08-07</d><h>01:07</h><w>micha</w>yeah i was thinking that also, really i just need curly braces, because i only want to parse maps</z><z id="t1438909669" t="micha but curlies can appear in strings"><y>#</y><d>2015-08-07</d><h>01:07</h><w>micha</w>but curlies can appear in strings</z><z id="t1438909671" t="aengelberg Maps with no lists / sets as keys or values?"><y>#</y><d>2015-08-07</d><h>01:07</h><w>aengelberg</w>Maps with no lists / sets as keys or values?</z><z id="t1438909715" t="micha yeah the map can contain anything, but i can presumably slurp that in and just look for the matching curly"><y>#</y><d>2015-08-07</d><h>01:08</h><w>micha</w>yeah the map can contain anything, but i can presumably slurp that in and just look for the matching curly</z><z id="t1438909736" t="aengelberg If you get the string terminal right, Instaparse will be smart about closing parens even if parens appear within the string"><y>#</y><d>2015-08-07</d><h>01:08</h><w>aengelberg</w>If you get the string terminal right, Instaparse will be smart about closing parens even if parens appear within the string</z><z id="t1438909780" t="micha how about indentation-based languages?"><y>#</y><d>2015-08-07</d><h>01:09</h><w>micha</w>how about indentation-based languages?</z><z id="t1438909787" t="aengelberg ehhhhhh"><y>#</y><d>2015-08-07</d><h>01:09</h><w>aengelberg</w>ehhhhhh</z><z id="t1438909853" t="micha haha yeah"><y>#</y><d>2015-08-07</d><h>01:10</h><w>micha</w>haha yeah</z><z id="t1438909873" t="aengelberg &quot;You&apos;re thinking in the wrong mindset&quot; https://imgur.com/gallery/M5wl14r"><y>#</y><d>2015-08-07</d><h>01:11</h><w>aengelberg</w>&quot;You&apos;re thinking in the wrong mindset&quot; <a href="https://imgur.com/gallery/M5wl14r" target="_blank">https://imgur.com/gallery/M5wl14r</a></z><z id="t1438909932" t="micha hahahaha excellent reference there"><y>#</y><d>2015-08-07</d><h>01:12</h><w>micha</w>hahahaha excellent reference there</z><z id="t1438909960" t="micha the project i&apos;m working on is a generalized, abstract sort of markdown"><y>#</y><d>2015-08-07</d><h>01:12</h><w>micha</w>the project i&apos;m working on is a generalized, abstract sort of markdown</z><z id="t1438909991" t="micha it&apos;s designed to mix well with prose, so indentation based structure is a big win"><y>#</y><d>2015-08-07</d><h>01:13</h><w>micha</w>it&apos;s designed to mix well with prose, so indentation based structure is a big win</z><z id="t1438910057" t="aengelberg So like, prose at the top level, important stuff indented?"><y>#</y><d>2015-08-07</d><h>01:14</h><w>aengelberg</w>So like, prose at the top level, important stuff indented?</z><z id="t1438910222" t="micha # This is line 1 of a certain type of block. The block continues here because of the indentation. * This could be a list item p With a paragraph in it that continues on multiple lines...and has a strange #(inline something or other delimited by hash-parens)#... ~~~{:foo &quot;bar&quot;, :baz 123} tags can also have attributes parsed as EDN... * here is the next list item "><y>#</y><d>2015-08-07</d><h>01:17</h><w>micha</w><pre># This is line 1 of a certain type of block.
  The block continues here because of the indentation.

* This could be a list item

  p With a paragraph in it
    that continues on multiple lines...and
    has a strange #(inline something or other
    delimited by hash-parens)#...

  ~~~{:foo &quot;bar&quot;, :baz 123} tags can also have
    attributes parsed as EDN...

* here is the next list item
</pre></z><z id="t1438910292" t="micha there we go"><y>#</y><d>2015-08-07</d><h>01:18</h><w>micha</w>there we go</z><z id="t1438910300" t="micha the parser will be a macro really"><y>#</y><d>2015-08-07</d><h>01:18</h><w>micha</w>the parser will be a macro really</z><z id="t1438910307" t="micha it will emit s-expressions"><y>#</y><d>2015-08-07</d><h>01:18</h><w>micha</w>it will emit s-expressions</z><z id="t1438910315" t="micha calling multimethods"><y>#</y><d>2015-08-07</d><h>01:18</h><w>micha</w>calling multimethods</z><z id="t1438910329" t="micha so you can implement dispatches for any tags you like"><y>#</y><d>2015-08-07</d><h>01:18</h><w>micha</w>so you can implement dispatches for any tags you like</z><z id="t1438910350" t="micha so what # foo means is up to you"><y>#</y><d>2015-08-07</d><h>01:19</h><w>micha</w>so what <code># foo</code> means is up to you</z><z id="t1438910397" t="micha the indentation is crucial for making the thing general without special cases and hardcoded things"><y>#</y><d>2015-08-07</d><h>01:19</h><w>micha</w>the indentation is crucial for making the thing general without special cases and hardcoded things</z><z id="t1438910433" t="aengelberg The reason &quot;ehhhh&quot; is the visceral response to indentation based langs in instaparse is because in CFGs it&apos;s difficult if not impossible to remember how many spaces / tabs you&apos;re looking for on each line."><y>#</y><d>2015-08-07</d><h>01:20</h><w>aengelberg</w>The reason &quot;ehhhh&quot; is the visceral response to indentation based langs in instaparse is because in CFGs it&apos;s difficult if not impossible to remember how many spaces / tabs you&apos;re looking for on each line.</z><z id="t1438910455" t="aengelberg So it&apos;s really only a problem if you have chunks within chunks that are indented even more."><y>#</y><d>2015-08-07</d><h>01:20</h><w>aengelberg</w>So it&apos;s really only a problem if you have chunks within chunks that are indented even more.</z><z id="t1438910480" t="micha yeah, and i want to support even more tricky things, like indentation plus extra whitespace at the front of the line"><y>#</y><d>2015-08-07</d><h>01:21</h><w>micha</w>yeah, and i want to support even more tricky things, like indentation plus extra whitespace at the front of the line</z><z id="t1438910497" t="micha i have a naive handmade parser now to parse the blocks"><y>#</y><d>2015-08-07</d><h>01:21</h><w>micha</w>i have a naive handmade parser now to parse the blocks</z><z id="t1438910512" t="micha it looks for tags that can start a block"><y>#</y><d>2015-08-07</d><h>01:21</h><w>micha</w>it looks for tags that can start a block</z><z id="t1438910520" t="micha then it looks for the &quot;outdent&quot;"><y>#</y><d>2015-08-07</d><h>01:22</h><w>micha</w>then it looks for the &quot;outdent&quot;</z><z id="t1438910531" t="micha so it doesn&apos;t look for a specific amount of indentation"><y>#</y><d>2015-08-07</d><h>01:22</h><w>micha</w>so it doesn&apos;t look for a specific amount of indentation</z><z id="t1438910547" t="aengelberg Example?"><y>#</y><d>2015-08-07</d><h>01:22</h><w>aengelberg</w>Example?</z><z id="t1438910554" t="micha it looks for a minimum amount of indentation, but you can use more"><y>#</y><d>2015-08-07</d><h>01:22</h><w>micha</w>it looks for a minimum amount of indentation, but you can use more</z><z id="t1438910640" t="micha # This is all part of the same block and the next block doesnt start until the an &quot;outdent&quot; is seen This is an outdent, so the above block will have been ended. "><y>#</y><d>2015-08-07</d><h>01:24</h><w>micha</w><pre># This is all
  part of the
    same block
  and the next
  block
    doesnt
      start until the
  an &quot;outdent&quot; is seen

This is an outdent, so
the above block will 
have been ended.
</pre></z><z id="t1438910674" t="micha however,"><y>#</y><d>2015-08-07</d><h>01:24</h><w>micha</w>however,</z><z id="t1438910727" t="micha # This is not all part of the same # block because this tag creates a nested block "><y>#</y><d>2015-08-07</d><h>01:25</h><w>micha</w><pre># This is not
  all part of the same
  # block because this
    tag creates a nested
    block
</pre></z><z id="t1438910815" t="aengelberg Hmm, what if you parse each block and then run the parser AGAIN on the text in the block to find subblocks?"><y>#</y><d>2015-08-07</d><h>01:26</h><w>aengelberg</w>Hmm, what if you parse each block and then run the parser AGAIN on the text in the block to find subblocks?</z><z id="t1438910832" t="micha hm"><y>#</y><d>2015-08-07</d><h>01:27</h><w>micha</w>hm</z><z id="t1438910866" t="micha i think i could give up the leading extra spaces thing, too"><y>#</y><d>2015-08-07</d><h>01:27</h><w>micha</w>i think i could give up the leading extra spaces thing, too</z><z id="t1438910884" t="micha and set indentation to some configurable fixed size"><y>#</y><d>2015-08-07</d><h>01:28</h><w>micha</w>and set indentation to some configurable fixed size</z><z id="t1438910904" t="aengelberg (my-parser text) =&gt; ([:block &quot;This is not&quot; &quot;all part of the same&quot; &quot;# block because this&quot; &quot; tag ...&quot;]) (insta/transform *1 {:block (fn [&amp; strs] (my-parser (str/join &quot;\n&quot; strs)))}) "><y>#</y><d>2015-08-07</d><h>01:28</h><w>aengelberg</w><pre>(my-parser text) =&gt; ([:block &quot;This is not&quot; &quot;all part of the same&quot; &quot;# block because this&quot; &quot;   tag ...&quot;])
(insta/transform *1 {:block (fn [&amp; strs] (my-parser (str/join &quot;\n&quot; strs)))})
</pre></z><z id="t1438910930" t="aengelberg Except recursively smarter"><y>#</y><d>2015-08-07</d><h>01:28</h><w>aengelberg</w>Except recursively smarter</z><z id="t1438910939" t="micha interesting"><y>#</y><d>2015-08-07</d><h>01:28</h><w>micha</w>interesting</z><z id="t1438910951" t="aengelberg I just thought of this, it might end up being impractical."><y>#</y><d>2015-08-07</d><h>01:29</h><w>aengelberg</w>I just thought of this, it might end up being impractical.</z><z id="t1438910960" t="aengelberg But that might be the way to do it."><y>#</y><d>2015-08-07</d><h>01:29</h><w>aengelberg</w>But that might be the way to do it.</z><z id="t1438911021" t="micha i will play around with it and let you know how it works out"><y>#</y><d>2015-08-07</d><h>01:30</h><w>micha</w>i will play around with it and let you know how it works out</z><z id="t1438911047" t="micha i can at least instaparse the inline stuff, if not the blocks"><y>#</y><d>2015-08-07</d><h>01:30</h><w>micha</w>i can at least instaparse the inline stuff, if not the blocks</z><z id="t1438911139" t="aengelberg True"><y>#</y><d>2015-08-07</d><h>01:32</h><w>aengelberg</w>True</z><z id="t1438911170" t="aengelberg Anyway, now that I think about it, this trick may be applicable to any indentation-based language"><y>#</y><d>2015-08-07</d><h>01:32</h><w>aengelberg</w>Anyway, now that I think about it, this trick may be applicable to any indentation-based language</z><z id="t1438911250" t="micha it&apos;s also an interesting case because i need to parse &quot;any character that isn&apos;t a tag&quot;"><y>#</y><d>2015-08-07</d><h>01:34</h><w>micha</w>it&apos;s also an interesting case because i need to parse &quot;any character that isn&apos;t a tag&quot;</z><z id="t1438911261" t="micha like the text in between tags"><y>#</y><d>2015-08-07</d><h>01:34</h><w>micha</w>like the text in between tags</z><z id="t1438911285" t="micha i think i can use negative lookahead with regex like #&quot;.&quot;"><y>#</y><d>2015-08-07</d><h>01:34</h><w>micha</w>i think i can use negative lookahead with regex like <code>#&quot;.&quot;</code></z><z id="t1438911347" t="micha anyway thanks for the help! i&apos;ll let you know how it all works out"><y>#</y><d>2015-08-07</d><h>01:35</h><w>micha</w>anyway thanks for the help! i&apos;ll let you know how it all works out</z><z id="t1438911576" t="aengelberg No problem, I&apos;d love to hear how it goes"><y>#</y><d>2015-08-07</d><h>01:39</h><w>aengelberg</w>No problem, I&apos;d love to hear how it goes</z><z id="t1439821846" t="micha @aengelberg: made some progress this weekend with my instaparse project! https://github.com/adzerk-oss/zerkdown"><y>#</y><d>2015-08-17</d><h>14:30</h><w>micha</w>@aengelberg: made some progress this weekend with my instaparse project! <a href="https://github.com/adzerk-oss/zerkdown" target="_blank">https://github.com/adzerk-oss/zerkdown</a></z><z id="t1439821888" t="micha it&apos;s a work in progress of course"><y>#</y><d>2015-08-17</d><h>14:31</h><w>micha</w>it&apos;s a work in progress of course</z><z id="t1439821914" t="micha it does a braindead parsing of clojure maps/vectors"><y>#</y><d>2015-08-17</d><h>14:31</h><w>micha</w>it does a braindead parsing of clojure maps/vectors</z><z id="t1439821934" t="micha https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf"><y>#</y><d>2015-08-17</d><h>14:32</h><w>micha</w><a href="https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf" target="_blank">https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf</a></z><z id="t1439821959" t="micha feedback appreciated simple_smile"><y>#</y><d>2015-08-17</d><h>14:32</h><w>micha</w>feedback appreciated <b>simple_smile</b></z><z id="t1439842701" t="aengelberg @micha this project is very cool"><y>#</y><d>2015-08-17</d><h>20:18</h><w>aengelberg</w>@micha this project is very cool</z><z id="t1439842724" t="aengelberg Does your ebnf allow [{] ?"><y>#</y><d>2015-08-17</d><h>20:18</h><w>aengelberg</w>Does your ebnf allow <code>[{]</code>?</z><z id="t1439842755" t="micha not in a :CLJ or :VEC block"><y>#</y><d>2015-08-17</d><h>20:19</h><w>micha</w>not in a <code>:CLJ</code> or <code>:VEC</code> block</z><z id="t1439842771" t="micha [&quot;{&quot;] would be ok though"><y>#</y><d>2015-08-17</d><h>20:19</h><w>micha</w><code>[&quot;{&quot;]</code> would be ok though</z><z id="t1439842805" t="aengelberg &lt;VEC-CHAR&gt; = !(LSB | RSB | DQ) ANY-CHAR looks like it would allow mismatched map delimiters inside it"><y>#</y><d>2015-08-17</d><h>20:20</h><w>aengelberg</w><code>&lt;VEC-CHAR&gt;              = !(LSB | RSB | DQ) ANY-CHAR</code> looks like it would allow mismatched map delimiters inside it</z><z id="t1439842832" t="micha oh interesting"><y>#</y><d>2015-08-17</d><h>20:20</h><w>micha</w>oh interesting</z><z id="t1439842852" t="micha yeah it&apos;s ambiguous"><y>#</y><d>2015-08-17</d><h>20:20</h><w>micha</w>yeah it&apos;s ambiguous</z><z id="t1439842884" t="micha !(LSB | RSB | STRING | MAP) ANY-CHAR would be nice there"><y>#</y><d>2015-08-17</d><h>20:21</h><w>micha</w><code>!(LSB | RSB | STRING | MAP) ANY-CHAR</code> would be nice there</z><z id="t1439842920" t="aengelberg then it would still allow mismatched quotes and delimiters because strings and maps don&apos;t successfully parse simple_smile"><y>#</y><d>2015-08-17</d><h>20:22</h><w>aengelberg</w>then it would still allow mismatched quotes and delimiters because strings and maps don&apos;t successfully parse <b>simple_smile</b></z><z id="t1439842956" t="micha hmm"><y>#</y><d>2015-08-17</d><h>20:22</h><w>micha</w>hmm</z><z id="t1439842997" t="aengelberg maybe (!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ"><y>#</y><d>2015-08-17</d><h>20:23</h><w>aengelberg</w>maybe <code>(!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ</code></z><z id="t1439843004" t="micha yeah"><y>#</y><d>2015-08-17</d><h>20:23</h><w>micha</w>yeah</z><z id="t1439843022" t="micha i will try that"><y>#</y><d>2015-08-17</d><h>20:23</h><w>micha</w>i will try that</z><z id="t1439843034" t="micha i am planning to do the recursion from clojure btw"><y>#</y><d>2015-08-17</d><h>20:23</h><w>micha</w>i am planning to do the recursion from clojure btw</z><z id="t1439843064" t="micha i will parse one level of indentation, then for each :BLOCK call insta again on the body"><y>#</y><d>2015-08-17</d><h>20:24</h><w>micha</w>i will parse one level of indentation, then for each <code>:BLOCK</code> call insta again on the body</z><z id="t1439843110" t="micha it seems like it will be straightforward, i hope"><y>#</y><d>2015-08-17</d><h>20:25</h><w>micha</w>it seems like it will be straightforward, i hope</z><z id="t1439843122" t="aengelberg cool"><y>#</y><d>2015-08-17</d><h>20:25</h><w>aengelberg</w>cool</z><z id="t1439843163" t="aengelberg Just make sure instaparse Failures are returned / shortcircuited properly simple_smile"><y>#</y><d>2015-08-17</d><h>20:26</h><w>aengelberg</w>Just make sure instaparse Failures are returned / shortcircuited properly <b>simple_smile</b></z><z id="t1439843188" t="micha how do you mean?"><y>#</y><d>2015-08-17</d><h>20:26</h><w>micha</w>how do you mean?</z><z id="t1439843211" t="aengelberg if a &quot;sub-parse&quot; returns a failure, then what?"><y>#</y><d>2015-08-17</d><h>20:26</h><w>aengelberg</w>if a &quot;sub-parse&quot; returns a failure, then what?</z><z id="t1439843383" t="aengelberg I imagine it will be most idiomatic to call insta/parse again within the transformer. But my point is, if a parse failure arises (malformed zerkdown) within that, you will need to propagate that error properly simple_smile"><y>#</y><d>2015-08-17</d><h>20:29</h><w>aengelberg</w>I imagine it will be most idiomatic to call <code>insta/parse</code> again within the transformer. But my point is, if a parse failure arises (malformed zerkdown) within that, you will need to propagate that error properly <b>simple_smile</b></z><z id="t1439843520" t="micha ah right"><y>#</y><d>2015-08-17</d><h>20:32</h><w>micha</w>ah right</z><z id="t1439843558" t="micha what did you mean before about strings and maps not successfully parsing?"><y>#</y><d>2015-08-17</d><h>20:32</h><w>micha</w>what did you mean before about strings and maps not successfully parsing?</z><z id="t1439843623" t="aengelberg negative lookahead = make sure this thing does not successfully parse"><y>#</y><d>2015-08-17</d><h>20:33</h><w>aengelberg</w>negative lookahead = make sure this thing does not successfully parse</z><z id="t1439843831" t="aengelberg !STRING x means no &quot;complete well-formed strings&quot; allowed, but you probably wanted &quot;no double-quotes of any kind really&quot;"><y>#</y><d>2015-08-17</d><h>20:37</h><w>aengelberg</w><code>!STRING x</code> means no &quot;complete well-formed strings&quot; allowed, but you probably wanted &quot;no double-quotes of any kind really&quot;</z><z id="t1439844084" t="aengelberg and then you can add in | STRING to allow well-formed strings"><y>#</y><d>2015-08-17</d><h>20:41</h><w>aengelberg</w>and then you can add in <code>| STRING</code> to allow well-formed strings</z><z id="t1439844643" t="micha oh i see"><y>#</y><d>2015-08-17</d><h>20:50</h><w>micha</w>oh i see</z><z id="t1439844651" t="micha i actually don&apos;t care about double quotes"><y>#</y><d>2015-08-17</d><h>20:50</h><w>micha</w>i actually don&apos;t care about double quotes</z><z id="t1439844670" t="micha i just don&apos;t want well formed strings, because those can legitimately contain {}[] etc"><y>#</y><d>2015-08-17</d><h>20:51</h><w>micha</w>i just don&apos;t want well formed strings, because those can legitimately contain {}[] etc</z><z id="t1439844699" t="micha i&apos;m not trying to fully parse the clojure data, i just need to know where it ends"><y>#</y><d>2015-08-17</d><h>20:51</h><w>micha</w>i&apos;m not trying to fully parse the clojure data, i just need to know where it ends</z><z id="t1439844719" t="micha i send it as a string and use clojure.core/read-string on it later"><y>#</y><d>2015-08-17</d><h>20:51</h><w>micha</w>i send it as a string and use <code>clojure.core/read-string</code> on it later</z><z id="t1439844740" t="aengelberg that&apos;s fair, but if [{]}] is allowed it&apos;s not exactly obvious where it ends simple_smile"><y>#</y><d>2015-08-17</d><h>20:52</h><w>aengelberg</w>that&apos;s fair, but if <code>[{]}]</code> is allowed it&apos;s not exactly obvious where it ends <b>simple_smile</b></z><z id="t1439844753" t="micha haha yes"><y>#</y><d>2015-08-17</d><h>20:52</h><w>micha</w>haha yes</z><z id="t1439844801" t="micha very interesting"><y>#</y><d>2015-08-17</d><h>20:53</h><w>micha</w>very interesting</z><z id="t1439844809" t="aengelberg anyway I don&apos;t think it&apos;s super hard to make the delimiters correct. (!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ"><y>#</y><d>2015-08-17</d><h>20:53</h><w>aengelberg</w>anyway I don&apos;t think it&apos;s super hard to make the delimiters correct. <code>(!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ</code></z><z id="t1439844820" t="aengelberg That basically says &quot;no double-quotes, UNLESS there is a well formed string&quot;"><y>#</y><d>2015-08-17</d><h>20:53</h><w>aengelberg</w>That basically says &quot;no double-quotes, UNLESS there is a well formed string&quot;</z><z id="t1439844848" t="micha yes that&apos;s awesome"><y>#</y><d>2015-08-17</d><h>20:54</h><w>micha</w>yes that&apos;s awesome</z><z id="t1439844876" t="micha testing was pretty easy to do, by configuring with different start rules"><y>#</y><d>2015-08-17</d><h>20:54</h><w>micha</w>testing was pretty easy to do, by configuring with different start rules</z><z id="t1439844895" t="aengelberg yeah. just don&apos;t forget negative testing simple_smile"><y>#</y><d>2015-08-17</d><h>20:54</h><w>aengelberg</w>yeah. just don&apos;t forget negative testing <b>simple_smile</b></z><z id="t1439844910" t="micha ah right"><y>#</y><d>2015-08-17</d><h>20:55</h><w>micha</w>ah right</z><z id="t1439844919" t="micha yeah i didn&apos;t think of that"><y>#</y><d>2015-08-17</d><h>20:55</h><w>micha</w>yeah i didn&apos;t think of that</z><z id="t1439845033" t="aengelberg really cool idea. what is the intended use case for zerkdown?"><y>#</y><d>2015-08-17</d><h>20:57</h><w>aengelberg</w>really cool idea. what is the intended use case for zerkdown?</z><z id="t1439846216" t="micha well i want to use it for just about everything!"><y>#</y><d>2015-08-17</d><h>21:16</h><w>micha</w>well i want to use it for just about everything!</z><z id="t1439846222" t="micha mostly for websites"><y>#</y><d>2015-08-17</d><h>21:17</h><w>micha</w>mostly for websites</z><z id="t1439846234" t="micha but i can imagine using it for literate programming and things like that"><y>#</y><d>2015-08-17</d><h>21:17</h><w>micha</w>but i can imagine using it for literate programming and things like that</z><z id="t1439846272" t="micha but for making webapps it&apos;s really nice to have a &quot;prose&quot; syntax you can customize for your use case"><y>#</y><d>2015-08-17</d><h>21:17</h><w>micha</w>but for making webapps it&apos;s really nice to have a &quot;prose&quot; syntax you can customize for your use case</z><z id="t1439846317" t="micha like normally you have like # My Title that compiles down to &lt;h1&gt;My Title&lt;/h1&gt; "><y>#</y><d>2015-08-17</d><h>21:18</h><w>micha</w>like normally you have like
<pre># My Title
</pre>
that compiles down to
<pre>&lt;h1&gt;My Title&lt;/h1&gt;
</pre></z><z id="t1439846421" t="micha but what if you need something like &lt;h1&gt;My Title &lt;small&gt;The Best Thing Ever&lt;/small&gt;&lt;/h1&gt; i want to be able to just define a new inline tag for that, like # My Title &lt;&lt;The Best Thing Ever&gt;&gt; "><y>#</y><d>2015-08-17</d><h>21:20</h><w>micha</w>but what if you need something like
<pre>&lt;h1&gt;My Title &lt;small&gt;The Best Thing Ever&lt;/small&gt;&lt;/h1&gt;
</pre>
i want to be able to just define a new inline tag for that, like
<pre># My Title &lt;&lt;The Best Thing Ever&gt;&gt;
</pre></z><z id="t1439846438" t="micha or even more complex things with behavior and everything, like forms and buttons"><y>#</y><d>2015-08-17</d><h>21:20</h><w>micha</w>or even more complex things with behavior and everything, like forms and buttons</z><z id="t1439901225" t="micha i got the recursive parser construction working! one weird trick instaparse doesn&apos;t want you to know about... https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60"><y>#</y><d>2015-08-18</d><h>12:33</h><w>micha</w>i got the recursive parser construction working! one weird trick instaparse doesn&apos;t want you to know about... <a href="https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60" target="_blank">https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60</a></z><z id="t1439910588" t="aengelberg A programmer used this one weird trick to handle indented languages... click here to see what! (Lexer-based libraries HATE this!)"><y>#</y><d>2015-08-18</d><h>15:09</h><w>aengelberg</w>A programmer used this one weird trick to handle indented languages... click here to see what! (Lexer-based libraries HATE this!)</z><z id="t1440630015" t="nodename I’m having a little trouble with a simple parser:"><y>#</y><d>2015-08-26</d><h>23:00</h><w>nodename</w>I’m having a little trouble with a simple parser:</z><z id="t1440630019" t="nodename (def exp-parser (insta/parser &quot;S = Sexp Sexp = Term | &apos;(&apos; Term* &apos;)&apos; Term = Char+ Char = #&apos;[a-z]&apos;&quot;))"><y>#</y><d>2015-08-26</d><h>23:00</h><w>nodename</w>(def exp-parser
  (insta/parser
    &quot;S = Sexp
    Sexp = Term | &apos;(&apos; Term* &apos;)&apos;
    Term = Char+
    Char = #&apos;[a-z]&apos;&quot;))</z><z id="t1440630070" t="nodename user=&gt; (exp-parser &quot;(hi)&quot;) [:S [:Sexp &quot;(&quot; [:Term [:Char &quot;h&quot;]] [:Term [:Char &quot;i&quot;]] &quot;)&quot;]] I thought the Char+ would make “hi” a single Term..."><y>#</y><d>2015-08-26</d><h>23:01</h><w>nodename</w>user=&gt; (exp-parser &quot;(hi)&quot;)
[:S [:Sexp &quot;(&quot; [:Term [:Char &quot;h&quot;]] [:Term [:Char &quot;i&quot;]] &quot;)&quot;]]
I thought the Char+ would make “hi” a single Term...</z><z id="t1440660658" t="ska @nodename: One Char is a character from the range given in the regexp. You allow many Chars with the +. Maybe you want Term = Char"><y>#</y><d>2015-08-27</d><h>07:30</h><w>ska</w>@nodename: One Char is a character from the range given in the regexp.  You allow many Chars with the +.  Maybe you want Term = Char</z><z id="t1440660674" t="ska Char = #&apos;[a-z]+&apos;"><y>#</y><d>2015-08-27</d><h>07:31</h><w>ska</w>Char = #&apos;[a-z]+&apos;</z><z id="t1440660723" t="ska So that the regexp eats the characters. Of course then &quot;Char&quot; is not a really good name anymore and might become sth like Symbol or Name"><y>#</y><d>2015-08-27</d><h>07:32</h><w>ska</w>So that the regexp eats the characters.  Of course then &quot;Char&quot; is not a really good name anymore and might become sth like Symbol or Name</z><z id="t1440660777" t="nodename Yes, that works, but I expected what I had to work too. Don’t see why not."><y>#</y><d>2015-08-27</d><h>07:32</h><w>nodename</w>Yes, that works, but I expected what I had to work too. Don’t see why not.</z><z id="t1440661797" t="ska It actually does that, it&apos;s just not the first result. Your grammar is ambiguous. See the result of insta/parses"><y>#</y><d>2015-08-27</d><h>07:49</h><w>ska</w>It actually does that, it&apos;s just not the first result.  Your grammar is ambiguous.  See the result of insta/parses</z><z id="t1440661825" t="ska The reason is, that + in instaparse is not greedy but allows all possible paths whereas + in the regexp would be greedy"><y>#</y><d>2015-08-27</d><h>07:50</h><w>ska</w>The reason is, that + in instaparse is not greedy but allows all possible paths whereas + in the regexp would be greedy</z><z id="t1440661892" t="nodename Ah, thanks. Do you know how I could modify Term to make it greedy?"><y>#</y><d>2015-08-27</d><h>07:51</h><w>nodename</w>Ah, thanks. Do you know how I could modify Term to make it greedy?</z><z id="t1440661987" t="ska My approach would be to use the regexp mentioned above. To me that is kinda the tokenization step in instaparse. I don&apos;t know if other solutions exists from the top off my head"><y>#</y><d>2015-08-27</d><h>07:53</h><w>ska</w>My approach would be to use the regexp mentioned above.  To me that is kinda the tokenization step in instaparse.  I don&apos;t know if other solutions exists from the top off my head</z><z id="t1440662063" t="ska Looks like I tried that already and came to the conclusion that there is no other way: https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460"><y>#</y><d>2015-08-27</d><h>07:54</h><w>ska</w>Looks like I tried that already and came to the conclusion that there is no other way: <a href="https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460" target="_blank">https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460</a></z><z id="t1440662121" t="nodename Ha, OK, will read! Thanks!"><y>#</y><d>2015-08-27</d><h>07:55</h><w>nodename</w>Ha, OK, will read! Thanks!</z><z id="t1440802362" t="aengelberg @nodename you could use negative lookahead, i.e. Term = Char+ !Char"><y>#</y><d>2015-08-28</d><h>22:52</h><w>aengelberg</w>@nodename you could use negative lookahead, i.e. <code>Term = Char+ !Char</code></z><z id="t1440826874" t="nodename @aengelberg thanks!"><y>#</y><d>2015-08-29</d><h>05:41</h><w>nodename</w>@aengelberg thanks!</z><z id="t1441006496" t="ska interesting, wasn&apos;t aware of that"><y>#</y><d>2015-08-31</d><h>07:34</h><w>ska</w>interesting, wasn&apos;t aware of that</z><z id="t1444861405" t="aaelony has anyone tried parsing between sql flavors? For example make a Redshift legal sql query a Hive legal sql query, assuming identical table and column names ? Would instaparse be a good fit for this kind of translation?"><y>#</y><d>2015-10-14</d><h>22:23</h><w>aaelony</w>has anyone tried parsing between sql flavors? For example make a Redshift legal sql query a Hive legal sql query, assuming identical table and column names ? Would instaparse be a good fit for this kind of translation?</z><z id="t1444862310" t="aengelberg I&apos;m not familiar with the differences of Redshift and Hive formats; how many gotchas are there when going between the two styles?"><y>#</y><d>2015-10-14</d><h>22:38</h><w>aengelberg</w>I&apos;m not familiar with the differences of Redshift and Hive formats; how many gotchas are there when going between the two styles?</z><z id="t1444862650" t="aengelberg @aaelony: ^"><y>#</y><d>2015-10-14</d><h>22:44</h><w>aengelberg</w>@aaelony: ^</z><z id="t1444864996" t="aaelony there are differences in data types in create table statements, there are also differences in syntax and function calls"><y>#</y><d>2015-10-14</d><h>23:23</h><w>aaelony</w>there are differences in data types in create table statements, there are also differences in syntax and function calls</z><z id="t1444865043" t="aaelony just trying to gauge if such translations are a good fit to try in instaparse"><y>#</y><d>2015-10-14</d><h>23:24</h><w>aaelony</w>just trying to gauge if such translations are a good fit to try in instaparse</z><z id="t1444866430" t="aengelberg Instaparse&apos;s job is to fully parse a string and return its meaning as a tree of data. If you need to fully parse a sql query and examine the data before you know what to do with it, Instaparse is a good choice. But if the problem could be solved by a regular expression searching the string for patterns, Instaparse might be overkill."><y>#</y><d>2015-10-14</d><h>23:47</h><w>aengelberg</w>Instaparse&apos;s job is to fully parse a string and return its meaning as a tree of data. If you need to fully parse a sql query and examine the data before you know what to do with it, Instaparse is a good choice. But if the problem could be solved by a regular expression searching the string for patterns, Instaparse might be overkill.</z><z id="t1444870338" t="aaelony That is useful, thank you. I think there are things idiomatic to each but maybe regexes are sufficient after all "><y>#</y><d>2015-10-15</d><h>00:52</h><w>aaelony</w>That is useful, thank you. I think there are things idiomatic to each but maybe regexes are sufficient after all </z><z id="t1444900470" t="ska Funny enough, I spent the morning writing a grammar for some SQL inspired tiny query language simple_smile"><y>#</y><d>2015-10-15</d><h>09:14</h><w>ska</w>Funny enough, I spent the morning writing a grammar for some SQL inspired tiny query language <b>simple_smile</b></z><z id="t1444927045" t="aaelony yes, my initial thoughts were that sql syntax docs could be parsed in some way, e.g. https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html compared to https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL"><y>#</y><d>2015-10-15</d><h>16:37</h><w>aaelony</w>yes, my initial thoughts were that sql syntax docs could be parsed in some way, e.g. <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html" target="_blank">https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html</a> compared to <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></z><z id="t1452585712" t="meow what is performance like for instaparse - someone I&apos;m working with had a problem in the past with it being slow but never tracked down the source of the problem"><y>#</y><d>2016-01-12</d><h>08:01</h><w>meow</w>what is performance like for instaparse - someone I&apos;m working with had a problem in the past with it being slow but never tracked down the source of the problem</z><z id="t1452593548" t="ska When parsing becomes slow, it might be due to the grammar being ambiguous. In general, I&apos;d say that Instparse is good enough for many use cases, even if I&apos;ve read papers complaining about the perf. The one that I still have was written in German, though."><y>#</y><d>2016-01-12</d><h>10:12</h><w>ska</w>When parsing becomes slow, it might be due to the grammar being ambiguous.  In general, I&apos;d say that Instparse is good enough for many use cases, even if I&apos;ve read papers complaining about the perf.  The one that I still have was written in German, though.</z><z id="t1452594473" t="meow I&apos;ll tell the #C0J20813K devs to come here to find out how to parse fast"><y>#</y><d>2016-01-12</d><h>10:27</h><w>meow</w>I&apos;ll tell the #C0J20813K devs to come here to find out how to parse fast</z><z id="t1452594499" t="meow @rafd: ^"><y>#</y><d>2016-01-12</d><h>10:28</h><w>meow</w>@rafd: ^</z><z id="t1452594541" t="meow @ska: thanks for the info! simple_smile"><y>#</y><d>2016-01-12</d><h>10:29</h><w>meow</w>@ska: thanks for the info! <b>simple_smile</b></z><z id="t1452603997" t="rafd @jamesnvc ^"><y>#</y><d>2016-01-12</d><h>13:06</h><w>rafd</w>@jamesnvc ^</z><z id="t1452613640" t="jamesnvc hello"><y>#</y><d>2016-01-12</d><h>15:47</h><w>jamesnvc</w>hello</z><z id="t1452613672" t="jamesnvc Yeah, I really like using instaparse server-side, but I tried writing one in cljs (pretty simple, just extracting links) and it was noticeably slow..."><y>#</y><d>2016-01-12</d><h>15:47</h><w>jamesnvc</w>Yeah, I really like using instaparse server-side, but I tried writing one in cljs (pretty simple, just extracting links) and it was noticeably slow...</z><z id="t1452613686" t="jamesnvc it was being called on a lot of text, but is there something I should be doing?"><y>#</y><d>2016-01-12</d><h>15:48</h><w>jamesnvc</w>it was being called on a lot of text, but is there something I should be doing?</z><z id="t1452614109" t="ska @jamesnvc: sometimes it is possible to chunk the text before parsing it. For example, when parsing logfiles use instaparse just for the lines not the whole file."><y>#</y><d>2016-01-12</d><h>15:55</h><w>ska</w>@jamesnvc: sometimes it is possible to chunk the text before parsing it.  For example, when parsing logfiles use instaparse just for the lines not the whole file.</z><z id="t1452614145" t="jamesnvc This is a bunch of little chunks of text; being called on the text of each message in a chat client"><y>#</y><d>2016-01-12</d><h>15:55</h><w>jamesnvc</w>This is a bunch of little chunks of text; being called on the text of each message in a chat client</z><z id="t1452614176" t="jamesnvc I’ll try writing the grammar again and make sure it isn’t ambiguous"><y>#</y><d>2016-01-12</d><h>15:56</h><w>jamesnvc</w>I’ll try writing the grammar again and make sure it isn’t ambiguous</z><z id="t1452615312" t="ghadi I have a new parser that should be much faster than instaparse if you have no ambiguity"><y>#</y><d>2016-01-12</d><h>16:15</h><w>ghadi</w>I have a new parser that should be much faster than instaparse if you have no ambiguity</z><z id="t1452615331" t="ghadi https://github.com/ghadishayban/pex"><y>#</y><d>2016-01-12</d><h>16:15</h><w>ghadi</w><a href="https://github.com/ghadishayban/pex" target="_blank">https://github.com/ghadishayban/pex</a></z><z id="t1452615356" t="ghadi needs better docs 😃"><y>#</y><d>2016-01-12</d><h>16:15</h><w>ghadi</w>needs better docs <b>😃</b></z><z id="t1452615376" t="ghadi https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ"><y>#</y><d>2016-01-12</d><h>16:16</h><w>ghadi</w><a href="https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ" target="_blank">https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ</a></z><z id="t1452616551" t="jamesnvc oh cool, I’ll give that a shot, thanks!"><y>#</y><d>2016-01-12</d><h>16:35</h><w>jamesnvc</w>oh cool, I’ll give that a shot, thanks!</z><z id="t1452616652" t="jamesnvc @ghadi oh, does this work in clojurescript though? That is my issue with instaparse — my clj perf is fine, but cljs leaves something to be desired"><y>#</y><d>2016-01-12</d><h>16:37</h><w>jamesnvc</w>@ghadi oh, does this work in clojurescript though? That is my issue with instaparse — my clj perf is fine, but cljs leaves something to be desired</z><z id="t1452616675" t="ghadi oh, no it doesn&apos;t"><y>#</y><d>2016-01-12</d><h>16:37</h><w>ghadi</w>oh, no it doesn&apos;t</z><z id="t1452616695" t="ghadi should perform well there too, want to port a virtual machine ? 😉"><y>#</y><d>2016-01-12</d><h>16:38</h><w>ghadi</w>should perform well there too, want to port a virtual machine ? <b>😉</b></z><z id="t1452616716" t="ghadi https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java"><y>#</y><d>2016-01-12</d><h>16:38</h><w>ghadi</w><a href="https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java" target="_blank">https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java</a></z><z id="t1452617408" t="jamesnvc Oh, interesting..."><y>#</y><d>2016-01-12</d><h>16:50</h><w>jamesnvc</w>Oh, interesting...</z><z id="t1452617435" t="jamesnvc I may consider that, if just as a fun project!"><y>#</y><d>2016-01-12</d><h>16:50</h><w>jamesnvc</w>I may consider that, if just as a fun project!</z><z id="t1452618437" t="ghadi Peg.js is pretty nice, IMHO"><y>#</y><d>2016-01-12</d><h>17:07</h><w>ghadi</w>Peg.js is pretty nice, IMHO</z><z id="t1452647479" t="lucasbradstreet Hi @jamesnvc, cljs perf is definitely a bit slow. You need to be using advanced mode compile otherwise it’s incredibly slow."><y>#</y><d>2016-01-13</d><h>01:11</h><w>lucasbradstreet</w>Hi @jamesnvc, cljs perf is definitely a bit slow. You need to be using advanced mode compile otherwise it’s incredibly slow.</z><z id="t1452647484" t="lucasbradstreet I’m the guy who did the port"><y>#</y><d>2016-01-13</d><h>01:11</h><w>lucasbradstreet</w>I’m the guy who did the port</z><z id="t1452647520" t="jamesnvc @lucasbradstreet: Cool, thanks simple_smile Good to know I’m (maybe) not just doing something crazy"><y>#</y><d>2016-01-13</d><h>01:12</h><w>jamesnvc</w>@lucasbradstreet: Cool, thanks <b>simple_smile</b> Good to know I’m (maybe) not just doing something crazy</z><z id="t1452647534" t="lucasbradstreet Depending on what you’re doing, you can also serialise the parser definition and load it in directly"><y>#</y><d>2016-01-13</d><h>01:12</h><w>lucasbradstreet</w>Depending on what you’re doing, you can also serialise the parser definition and load it in directly</z><z id="t1452647558" t="lucasbradstreet Creating the initial parser in cljs can take quite a while, but the parsing itself can be pretty acceptable"><y>#</y><d>2016-01-13</d><h>01:12</h><w>lucasbradstreet</w>Creating the initial parser in cljs can take quite a while, but the parsing itself can be pretty acceptable</z><z id="t1452647943" t="meow and my money was on crazy @jamesnvc"><y>#</y><d>2016-01-13</d><h>01:19</h><w>meow</w>and my money was on crazy @jamesnvc</z><z id="t1452648018" t="meow can any of that &quot;job&quot; be split between client and server?"><y>#</y><d>2016-01-13</d><h>01:20</h><w>meow</w>can any of that &quot;job&quot; be split between client and server?</z><z id="t1452648028" t="meow say for a chat app"><y>#</y><d>2016-01-13</d><h>01:20</h><w>meow</w>say for a chat app</z><z id="t1452648078" t="meow just send the user keystrokes to the server - do it in clj there"><y>#</y><d>2016-01-13</d><h>01:21</h><w>meow</w>just send the user keystrokes to the server - do it in clj there</z><z id="t1452648090" t="meow just brainstorming"><y>#</y><d>2016-01-13</d><h>01:21</h><w>meow</w>just brainstorming</z><z id="t1452648094" t="meow outloud"><y>#</y><d>2016-01-13</d><h>01:21</h><w>meow</w>outloud</z><z id="t1452648225" t="meow doesn&apos;t each keystroke go to the server already - that&apos;s how you can display the fact that the user is typing"><y>#</y><d>2016-01-13</d><h>01:23</h><w>meow</w>doesn&apos;t each keystroke go to the server already - that&apos;s how you can display the fact that the user is typing</z><z id="t1452648247" t="meow so don&apos;t do any processing on the client - do the instaparse on the server"><y>#</y><d>2016-01-13</d><h>01:24</h><w>meow</w>so don&apos;t do any processing on the client - do the instaparse on the server</z><z id="t1452648274" t="meow and use yada or onyx or something to scale it"><y>#</y><d>2016-01-13</d><h>01:24</h><w>meow</w>and use yada or onyx or something to scale it</z><z id="t1452648299" t="meow we can segregrate services on the server and compose them"><y>#</y><d>2016-01-13</d><h>01:24</h><w>meow</w>we can segregrate services on the server and compose them</z><z id="t1452648348" t="meow compose microservices on the server and keep the client relatively stupid whenever the data is already on the server"><y>#</y><d>2016-01-13</d><h>01:25</h><w>meow</w>compose microservices on the server and keep the client relatively stupid whenever the data is already on the server</z><z id="t1452648987" t="lucasbradstreet I was parsing excel formulas on the client and it was good enough"><y>#</y><d>2016-01-13</d><h>01:36</h><w>lucasbradstreet</w>I was parsing excel formulas on the client and it was good enough</z><z id="t1452649001" t="lucasbradstreet Certainly faster than a round-trip to the server"><y>#</y><d>2016-01-13</d><h>01:36</h><w>lucasbradstreet</w>Certainly faster than a round-trip to the server</z><z id="t1452649307" t="meow ok"><y>#</y><d>2016-01-13</d><h>01:41</h><w>meow</w>ok</z><z id="t1452649326" t="meow I&apos;ll defer to @jamesnvc since I&apos;m just blowing smoke"><y>#</y><d>2016-01-13</d><h>01:42</h><w>meow</w>I&apos;ll defer to @jamesnvc since I&apos;m just blowing smoke</z><z id="t1452649525" t="lucasbradstreet My overall experience was that creating the initial parser was very expensive, but overall parsing was OK, but that it had to be in advanced mode. All with a big chunk of “your mileage may vary”. Unfortunately I don’t have any time to work on performance any further"><y>#</y><d>2016-01-13</d><h>01:45</h><w>lucasbradstreet</w>My overall experience was that creating the initial parser was very expensive, but overall parsing was OK, but that it had to be in advanced mode. All with a big chunk of “your mileage may vary”. Unfortunately I don’t have any time to work on performance any further</z><z id="t1452683280" t="jamesnvc Cool, I was thinking of splitting it between client and server, but I will give it a shot with advanced compliation too"><y>#</y><d>2016-01-13</d><h>11:08</h><w>jamesnvc</w>Cool, I was thinking of splitting it between client and server, but I will give it a shot with advanced compliation too</z><z id="t1452683715" t="lucasbradstreet Also works. I’d measure how long it takes to do the individual parses, not just page load time - because that will be affected by creating the initial parser"><y>#</y><d>2016-01-13</d><h>11:15</h><w>lucasbradstreet</w>Also works. I’d measure how long it takes to do the individual parses, not just page load time - because that will be affected by creating the initial parser</z><z id="t1452691241" t="meow @jamesnvc: we should test both and not make assumptions either way, imnsho"><y>#</y><d>2016-01-13</d><h>13:20</h><w>meow</w>@jamesnvc: we should test both and not make assumptions either way, imnsho</z><z id="t1452691261" t="meow @lucasbradstreet: thanks for the help and suggestions - much appreciated"><y>#</y><d>2016-01-13</d><h>13:21</h><w>meow</w>@lucasbradstreet: thanks for the help and suggestions - much appreciated</z><z id="t1452691422" t="lucasbradstreet Agreed. Though you have to assume some variability in request latency when testing the other method, which is why I ultimately went with the client side approach. That said, you can have slow CPU clients too. "><y>#</y><d>2016-01-13</d><h>13:23</h><w>lucasbradstreet</w>Agreed. Though you have to assume some variability in request latency when testing the other method, which is why I ultimately went with the client side approach. That said, you can have slow CPU clients too. </z><z id="t1452691595" t="meow then we should simulate issues with both environments and various combinations/permutations"><y>#</y><d>2016-01-13</d><h>13:26</h><w>meow</w>then we should simulate issues with both environments and various combinations/permutations</z><z id="t1452691610" t="meow ask the #C0J20813K team how good I am at doing that"><y>#</y><d>2016-01-13</d><h>13:26</h><w>meow</w>ask the #C0J20813K team how good I am at doing that</z><z id="t1452691626" t="meow issues, oh yeah, I got issues"><y>#</y><d>2016-01-13</d><h>13:27</h><w>meow</w>issues, oh yeah, I got issues</z><z id="t1452696484" t="lucasbradstreet ha 👍"><y>#</y><d>2016-01-13</d><h>14:48</h><w>lucasbradstreet</w>ha <b>👍</b></z><z id="t1452697587" t="meow simple_smile"><y>#</y><d>2016-01-13</d><h>15:06</h><w>meow</w><b>simple_smile</b></z><z id="t1454964122" t="wongiseng Hi, very basic question probably not specific to instaparse. From this basic example : &quot;S = N | (N (&apos;+&apos; N)+); N = &apos;0&apos; | &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;&quot; if I want to enforce that not all N are 0s, should this be done in the grammar definition or by adding some logic on processing the parsed result ? I suspect the latter, but just in case anyone knows other ways to enforce this restriction directly in the grammar, I&apos;d like to know. TIA"><y>#</y><d>2016-02-08</d><h>20:42</h><w>wongiseng</w>Hi, very basic question probably not specific to instaparse. From this basic example :
&quot;S = N | (N (&apos;+&apos; N)+);
  N = &apos;0&apos; | &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;&quot;

if I want to enforce that not all N are 0s, should this be done in the grammar definition or by adding some logic on processing the parsed result ? I suspect the latter, but just in case anyone knows other ways to enforce this restriction directly in the grammar, I&apos;d like to know. TIA</z><z id="t1454967132" t="aengelberg Hi @wongiseng, I saw your question on gitter as well. Instaparse&apos;s job is to turn strings into meaningful data; any validation you want to do on that data probably should happen after the parse."><y>#</y><d>2016-02-08</d><h>21:32</h><w>aengelberg</w>Hi @wongiseng, I saw your question on gitter as well. Instaparse&apos;s job is to turn strings into meaningful data; any validation you want to do on that data probably should happen after the parse.</z><z id="t1454967191" t="aengelberg The only real way to have more sophisticated validation on an input is to use lookahead and negative lookahead."><y>#</y><d>2016-02-08</d><h>21:33</h><w>aengelberg</w>The only real way to have more sophisticated validation on an input is to use lookahead and negative lookahead.</z><z id="t1454967205" t="aengelberg Well, those are the only ways to do sophisticated validation within instaparse."><y>#</y><d>2016-02-08</d><h>21:33</h><w>aengelberg</w>Well, those are the only ways to do sophisticated validation within instaparse.</z><z id="t1454967257" t="aengelberg In this particular example you could use negative lookahead, e.g. S = !(&apos;0&apos;*) (N | (N (&apos;+&apos; N)+));"><y>#</y><d>2016-02-08</d><h>21:34</h><w>aengelberg</w>In this particular example you could use negative lookahead, e.g.
S = !(&apos;0&apos;*) (N | (N (&apos;+&apos; N)+));</z><z id="t1454967260" t="socksy this works, but it&apos;s ambiguous: (def minimum-one-not-zero (insta/parser &quot;EXP = N | S; S = (ZN &apos;+&apos;)* N (&apos;+&apos; ZN)*; N = &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;; ZN = &apos;0&apos; | N;&quot;)) "><y>#</y><d>2016-02-08</d><h>21:34</h><w>socksy</w>this works, but it&apos;s ambiguous:
<pre>(def minimum-one-not-zero
  (insta/parser
    &quot;EXP = N | S;
    S = (ZN &apos;+&apos;)* N (&apos;+&apos; ZN)*;
    N =  &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;
    ZN = &apos;0&apos; | N;&quot;))
</pre></z><z id="t1454967275" t="aengelberg ^ That would work as well"><y>#</y><d>2016-02-08</d><h>21:34</h><w>aengelberg</w>^ That would work as well</z><z id="t1454967302" t="socksy (tested)"><y>#</y><d>2016-02-08</d><h>21:35</h><w>socksy</w>(tested)</z><z id="t1454967362" t="aengelberg The advantage to writing your own validation after the parse is that when the input is wrong, you can write your own error message to say whatever you want instead of instaparse&apos;s failure message which might not be as readable."><y>#</y><d>2016-02-08</d><h>21:36</h><w>aengelberg</w>The advantage to writing your own validation after the parse is that when the input is wrong, you can write your own error message to say whatever you want instead of instaparse&apos;s failure message which might not be as readable.</z><z id="t1454967394" t="socksy ^definitely Parse error at line 1, column 4: 0+0 ^ Expected: &quot;+&quot;"><y>#</y><d>2016-02-08</d><h>21:36</h><w>socksy</w>^definitely 
<pre>Parse error at line 1, column 4:
0+0
   ^
Expected:
&quot;+&quot;</pre></z><z id="t1454967417" t="aengelberg oops, my negative lookahead approach definitely wouldn&apos;t work because I totally didn&apos;t see the pluses in the input"><y>#</y><d>2016-02-08</d><h>21:36</h><w>aengelberg</w>oops, my negative lookahead approach definitely wouldn&apos;t work because I totally didn&apos;t see the pluses in the input</z><z id="t1454967487" t="aengelberg Maybe S = &amp;(#&quot;.*[1-9]&quot;) (N | (N (&apos;+&apos; N)+); "><y>#</y><d>2016-02-08</d><h>21:38</h><w>aengelberg</w>Maybe
<pre>S = &amp;(#&quot;.*[1-9]&quot;) (N | (N (&apos;+&apos; N)+);
</pre></z><z id="t1454967505" t="aengelberg e.g. &quot;make sure there&apos;s some nonzero number somewhere, then parse as usual&quot;"><y>#</y><d>2016-02-08</d><h>21:38</h><w>aengelberg</w>e.g. &quot;make sure there&apos;s some nonzero number somewhere, then parse as usual&quot;</z><z id="t1454967549" t="aengelberg that&apos;s lookahead not negative lookahead"><y>#</y><d>2016-02-08</d><h>21:39</h><w>aengelberg</w>that&apos;s lookahead not negative lookahead</z><z id="t1454967653" t="socksy if errors aren&apos;t important, and the fact you might get the &quot;wrong&quot; evaluation (e.g. &quot;1+0+1&quot; could be [:EXP [:S [:N &quot;1&quot;] &quot;+&quot; [:ZN &quot;0&quot;] &quot;+&quot; [:ZN [:N &quot;1&quot;]]]] or [:EXP [:S [:ZN [:N&quot;1&quot;]] &quot;+&quot; [:ZN 0] &quot;+&quot; [:N 1]]] ) is also unimportant (e.g. you eval N and ZN the same), then you should be fine with the ambiguous grammar"><y>#</y><d>2016-02-08</d><h>21:40</h><w>socksy</w>if errors aren&apos;t important, and the fact you might get the &quot;wrong&quot; evaluation (e.g. &quot;1+0+1&quot; could be <code>[:EXP [:S [:N &quot;1&quot;] &quot;+&quot; [:ZN &quot;0&quot;] &quot;+&quot; [:ZN [:N &quot;1&quot;]]]]</code> or <code>[:EXP [:S [:ZN [:N&quot;1&quot;]] &quot;+&quot; [:ZN 0] &quot;+&quot; [:N 1]]]</code>) is also unimportant (e.g. you eval N and ZN the same), then you should be fine with the ambiguous grammar</z><z id="t1454967692" t="socksy (instaparse gives you the former)"><y>#</y><d>2016-02-08</d><h>21:41</h><w>socksy</w>(instaparse gives you the former)</z><z id="t1454967904" t="aengelberg @socksy how about S = N (&apos;+&apos; N)* | (N &apos;+&apos;)* &apos;0&apos; (&apos;+&apos; ZN)*; "><y>#</y><d>2016-02-08</d><h>21:45</h><w>aengelberg</w>@socksy how about
<pre>S = N (&apos;+&apos; N)* | (N &apos;+&apos;)* &apos;0&apos; (&apos;+&apos; ZN)*;
</pre></z><z id="t1454967927" t="aengelberg I&apos;m just writing these off the top of my head, not evaluating them to be sure. I think that would be unambiguous though"><y>#</y><d>2016-02-08</d><h>21:45</h><w>aengelberg</w>I&apos;m just writing these off the top of my head, not evaluating them to be sure. I think that would be unambiguous though</z><z id="t1454968003" t="aengelberg hmm, that&apos;s definitely wrong simple_smile"><y>#</y><d>2016-02-08</d><h>21:46</h><w>aengelberg</w>hmm, that&apos;s definitely wrong <b>simple_smile</b></z><z id="t1454968014" t="aengelberg not sure where that came from"><y>#</y><d>2016-02-08</d><h>21:46</h><w>aengelberg</w>not sure where that came from</z><z id="t1454968079" t="aengelberg Using lookahead would likely be the easiest path, since the grammar would be unambiguous and easy to understand"><y>#</y><d>2016-02-08</d><h>21:47</h><w>aengelberg</w>Using lookahead would likely be the easiest path, since the grammar would be unambiguous and easy to understand</z></g><g id="s1"><z id="t1454968674" t="wongiseng Cool, thanks for the explanations, I&apos;ll play a bit with look ahead, but eventually I guess i&apos;ll validate after the parse"><y>#</y><d>2016-02-08</d><h>21:57</h><w>wongiseng</w>Cool, thanks for the explanations, I&apos;ll play a bit with look ahead, but eventually I guess i&apos;ll validate after the parse</z><z id="t1454968720" t="wongiseng The negative lookaheads makes the grammar hard to digest for me"><y>#</y><d>2016-02-08</d><h>21:58</h><w>wongiseng</w>The negative lookaheads makes the grammar hard to digest for me</z><z id="t1454973711" t="wongiseng For now I use @socksy&apos;s approach simple_smile https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf thanks a lot!"><y>#</y><d>2016-02-08</d><h>23:21</h><w>wongiseng</w>For now I use @socksy&apos;s approach <b>simple_smile</b> <a href="https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf" target="_blank">https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf</a> thanks a lot!</z><z id="t1454973976" t="wongiseng My actual problem was OR to have at least one positive term"><y>#</y><d>2016-02-08</d><h>23:26</h><w>wongiseng</w>My actual problem was OR  to have at least one positive term</z><z id="t1460353865" t="conaw hey, anyone know how to match the \ character?"><y>#</y><d>2016-04-11</d><h>05:51</h><w>conaw</w>hey, anyone know how to match the \ character?</z><z id="t1460353951" t="conaw I’m trying to match strings within a parsed file, something like this string = &apos;\&quot;&apos; #&apos;[^(?&lt;!\\\)\&quot;]* &apos;\&quot;&apos;"><y>#</y><d>2016-04-11</d><h>05:52</h><w>conaw</w>I’m trying to match strings within a parsed file, something like this    string = &apos;\&quot;&apos; #&apos;[^(?&lt;!\\\)\&quot;]* &apos;\&quot;&apos;</z><z id="t1460353986" t="conaw I keep getting either errors of unmatched parens, or instaparse errors when I’m doing"><y>#</y><d>2016-04-11</d><h>05:53</h><w>conaw</w>I keep getting either errors of unmatched parens, or instaparse errors when I’m doing</z><z id="t1460353989" t="conaw \ or \\"><y>#</y><d>2016-04-11</d><h>05:53</h><w>conaw</w>\ or \\</z><z id="t1460355442" t="conaw figured it out"><y>#</y><d>2016-04-11</d><h>06:17</h><w>conaw</w>figured it out</z><z id="t1460355465" t="conaw If anyone’s interested"><y>#</y><d>2016-04-11</d><h>06:17</h><w>conaw</w>If anyone’s interested</z><z id="t1460355472" t="conaw string = &apos;\&quot;&apos; (#&apos;[^\&quot;]&apos; | &apos;\\\\\&quot;&apos;) &apos;\&quot;&apos;"><y>#</y><d>2016-04-11</d><h>06:17</h><w>conaw</w>string = &apos;\&quot;&apos; (#&apos;[^\&quot;]&apos; | &apos;\\\\\&quot;&apos;) &apos;\&quot;&apos;</z><z id="t1460355552" t="conaw I’m know there should be a way to do it with lookbehind inside the regex, but at least now I only have one problem"><y>#</y><d>2016-04-11</d><h>06:19</h><w>conaw</w>I’m know there should be a way to do it with lookbehind inside the regex, but at least now I only have one problem</z><z id="t1460355594" t="conaw Would be great to have an instaparse wiki for common grammars, if that doesn’t already exist somewhere"><y>#</y><d>2016-04-11</d><h>06:19</h><w>conaw</w>Would be great to have an instaparse wiki for common grammars, if that doesn’t already exist somewhere</z><z id="t1460355643" t="conaw also, would be great to know if anyone is using a combination of instaparse and any of the nlp libraries"><y>#</y><d>2016-04-11</d><h>06:20</h><w>conaw</w>also, would be great to know if anyone is using a combination of instaparse and any of the nlp libraries</z><z id="t1460451996" t="ska What kind of combination are you thinking about, @conaw ?"><y>#</y><d>2016-04-12</d><h>09:06</h><w>ska</w>What kind of combination are you thinking about, @conaw ?</z><z id="t1460452204" t="ska Oh, and regarding your string question, I did something similar with finding regexps in a query language which would be enclosed by slashes and allowed backslash-escaped slashed inside. The regexp for this was so weird, I completely forgot, how it worked, but here it is: REGEXP = &lt;&apos;/&apos;&gt; #&apos;(?:.(?!(?&lt;![\\\\])/))+.?&apos; &lt;&apos;/&apos;&gt; (the grammar is defined in a Clojure string, thus the massive escaping)"><y>#</y><d>2016-04-12</d><h>09:10</h><w>ska</w>Oh, and regarding your string question, I did something similar with finding regexps in a query language which would be enclosed by slashes and allowed backslash-escaped slashed inside.  The regexp for this was so weird, I completely forgot, how it worked, but here it is: <pre>REGEXP = &lt;&apos;/&apos;&gt; #&apos;(?:.(?!(?&lt;![\\\\])/))+.?&apos; &lt;&apos;/&apos;&gt;</pre>  (the grammar is defined in a Clojure string, thus the massive escaping)</z><z id="t1460452255" t="conaw not sure yet to be honest — I’d like to be doing POS tagging, and tokenizing, but really enjoying instaparse and curious if anyone has used it in conjunction with something like opennlp"><y>#</y><d>2016-04-12</d><h>09:10</h><w>conaw</w>not sure yet to be honest — I’d like to be doing POS tagging, and tokenizing, but really enjoying instaparse and curious if anyone has used it in conjunction with something like opennlp</z><z id="t1460452380" t="ska I once did a workshop on Clojure with very basic NLP examples (it was at a faculty for computational linguistics), but I did not combine it with any existing NLP libraries. Here at work, the NLP stuff is mostly self-written as much of it predates the open source libs. And we do not (yet?) use Clojure in that area."><y>#</y><d>2016-04-12</d><h>09:13</h><w>ska</w>I once did a workshop on Clojure with very basic NLP examples (it was at a faculty for computational linguistics), but I did not combine it with any existing NLP libraries.  Here at work, the NLP stuff is mostly self-written as much of it predates the open source libs.  And we do not (yet?) use Clojure in that area.</z><z id="t1460452519" t="ska Hm, looks like I never polished that workshop to put it online somewhere. Sorry."><y>#</y><d>2016-04-12</d><h>09:15</h><w>ska</w>Hm, looks like I never polished that workshop to put it online somewhere.  Sorry.</z><z id="t1460452595" t="ska But you may be interested in the instaparse talk here: https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj"><y>#</y><d>2016-04-12</d><h>09:16</h><w>ska</w>But you may be interested in the instaparse talk here: <a href="https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj" target="_blank">https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj</a></z><z id="t1460452616" t="ska (enough boasting now; please excuse the self-plugging)"><y>#</y><d>2016-04-12</d><h>09:16</h><w>ska</w>(enough boasting now; please excuse the self-plugging)</z><z id="t1460453151" t="conaw Not boasting at all, I appreciate the link."><y>#</y><d>2016-04-12</d><h>09:25</h><w>conaw</w>Not boasting at all, I appreciate the link.</z><z id="t1460453964" t="conaw Another thing — Is there an idiomatic way to get the matched portion of a string for a given portion of a parse into the final transformed clojure data"><y>#</y><d>2016-04-12</d><h>09:39</h><w>conaw</w>Another thing — Is there an idiomatic way to get the matched portion of a string for a given portion of a parse into the final transformed clojure data</z><z id="t1460453996" t="conaw I’m trying to parse the same text multiple times iteratively — passing the result to a different more granular parser based on the first"><y>#</y><d>2016-04-12</d><h>09:39</h><w>conaw</w>I’m trying to parse the same text multiple times iteratively — passing the result to a different more granular parser based on the first</z><z id="t1460454016" t="conaw basically I’m trying to split the text up using a parse"><y>#</y><d>2016-04-12</d><h>09:40</h><w>conaw</w>basically I’m trying to split the text up using a parse</z><z id="t1460454292" t="conaw spans looks like"><y>#</y><d>2016-04-12</d><h>09:44</h><w>conaw</w>spans looks like</z><z id="t1460459642" t="ska There is a :partial option but it only returns the parse tree as far as it could be parsed. Maybe the total mode would help? Can&apos;t say. Sorry."><y>#</y><d>2016-04-12</d><h>11:14</h><w>ska</w>There is a :partial option but it only returns the parse tree as far as it could be parsed.  Maybe the total mode would help?  Can&apos;t say.  Sorry.</z><z id="t1460471647" t="ska @conaw, I just found the span function which takes a parse tree (result of parsing) and returns start and end index into the string. So, you could first parse partially and then as your input string for the covered substring."><y>#</y><d>2016-04-12</d><h>14:34</h><w>ska</w>@conaw, I just found the <code>span</code> function which takes a parse tree (result of parsing) and returns start and end index into the string. So, you could first parse partially and then as your input string for the covered substring.</z><z id="t1460471858" t="ska Like this: (let [s &quot;abcd&quot; g &quot;Q=&apos;a&apos; &apos;b&apos;&quot; p (i/parser g) t (p s :partial true)] (apply subs (into [s] (i/span t)))) "><y>#</y><d>2016-04-12</d><h>14:37</h><w>ska</w>Like this: 
<pre>(let [s &quot;abcd&quot;
               g &quot;Q=&apos;a&apos; &apos;b&apos;&quot;
               p (i/parser g)
               t (p s :partial true)]
               (apply subs
                             (into [s] (i/span t))))

</pre></z><z id="t1460471972" t="ska (sorry for the broken indentation)"><y>#</y><d>2016-04-12</d><h>14:39</h><w>ska</w>(sorry for the broken indentation)</z><z id="t1460595642" t="conaw @ska yup, that was my last remark, should have used the code marker to make it more clear. I did have a little trouble figuring out how to get only the span details for particular tags though — my guess is that I should use tree-seq for that"><y>#</y><d>2016-04-14</d><h>01:00</h><w>conaw</w>@ska yup, that was my last remark, should have used the <code>code marker to make it more clear.  I did have a little trouble figuring out how to get only the span details for particular tags though — my guess is that I should use </code>tree-seq for that</z><z id="t1460595676" t="conaw and now I know how not to use the code marker"><y>#</y><d>2016-04-14</d><h>01:01</h><w>conaw</w>and now I know how not to use  the <code>code marker</code></z><z id="t1460626078" t="ska @conaw, ah now I understand your last comment. I misread it for an unfinished sentence and later forgot about it. Then span was a surprise to me. 😄"><y>#</y><d>2016-04-14</d><h>09:27</h><w>ska</w>@conaw, ah now I understand your last comment. I misread it for an unfinished sentence and later forgot about it. Then <code>span</code> was a surprise to me. <b>😄</b></z><z id="t1461207648" t="bwstearns Does anyone have any quick guidance on this question at SO: https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf"><y>#</y><d>2016-04-21</d><h>03:00</h><w>bwstearns</w>Does anyone have any quick guidance on this question at SO: <a href="https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf" target="_blank">https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf</a></z><z id="t1461207690" t="bwstearns I think it might be an instance of lacking the right words to google for the answer effectively."><y>#</y><d>2016-04-21</d><h>03:01</h><w>bwstearns</w>I think it might be an instance of lacking the right words to google for the answer effectively.</z><z id="t1461208904" t="aengelberg @bwstearns: You could concatenate all the strings as a transform step."><y>#</y><d>2016-04-21</d><h>03:21</h><w>aengelberg</w>@bwstearns: You could concatenate all the strings as a transform step.</z><z id="t1461208981" t="aengelberg i.e. unhide the letter and number tags, but add :letter str, :number str into your transformer map."><y>#</y><d>2016-04-21</d><h>03:23</h><w>aengelberg</w>i.e. unhide the letter and number tags, but add <code>:letter str, :number str</code> into your transformer map.</z><z id="t1461209058" t="bwstearns @aengelberg: that&apos;s what I&apos;m doing now. Because I&apos;m doing it for a bunch of tags I was wondering if there was something built in for handling that as a common case or not."><y>#</y><d>2016-04-21</d><h>03:24</h><w>bwstearns</w>@aengelberg: that&apos;s what I&apos;m doing now. Because I&apos;m doing it for a bunch of tags I was wondering if there was something built in for handling that as a common case or not.</z><z id="t1461209067" t="aengelberg Other than regexes, there&apos;s no way to concatenate strings in a way specified entirely by the instaparse grammar."><y>#</y><d>2016-04-21</d><h>03:24</h><w>aengelberg</w>Other than regexes, there&apos;s no way to concatenate strings in a way specified entirely by the instaparse grammar.</z><z id="t1461209134" t="aengelberg The transform approach is the easiest way I could think of out of all the &quot;do something to the tree, fresh out of the parser&quot; possible approaches."><y>#</y><d>2016-04-21</d><h>03:25</h><w>aengelberg</w>The transform approach is the easiest way I could think of out of all the &quot;do something to the tree, fresh out of the parser&quot; possible approaches.</z><z id="t1461209217" t="bwstearns That makes sense. I think what I&apos;ll do is put the preprocessor transforms into another hash to keep the more meaninful transform actions less cluttered and then merge them right before usage."><y>#</y><d>2016-04-21</d><h>03:26</h><w>bwstearns</w>That makes sense. I think what I&apos;ll do is put the preprocessor transforms into another hash to keep the more meaninful transform actions less cluttered and then merge them right before usage.</z><z id="t1461209268" t="aengelberg That can work. Or just call insta/transform twice, if you don&apos;t mind the performance impact of traversing the tree twice."><y>#</y><d>2016-04-21</d><h>03:27</h><w>aengelberg</w>That can work. Or just call insta/transform twice, if you don&apos;t mind the performance impact of traversing the tree twice.</z><z id="t1461209307" t="bwstearns that works too. I don&apos;t think I have any performance issues on the horizon with this project."><y>#</y><d>2016-04-21</d><h>03:28</h><w>bwstearns</w>that works too. I don&apos;t think I have any performance issues on the horizon with this project.</z><z id="t1461209558" t="bwstearns @aengelberg: thanks a ton for taking a look. The question got some foot traffic but no feedback. If you&apos;re looking for internet points feel free to drop what you said in there and I&apos;ll accept it. Otherwise I&apos;ll copy it in as an own-answer for the next person."><y>#</y><d>2016-04-21</d><h>03:32</h><w>bwstearns</w>@aengelberg: thanks a ton for taking a look. The question got some foot traffic but no feedback. If you&apos;re looking for internet points feel free to drop what you said in there and I&apos;ll accept it. Otherwise I&apos;ll copy it in as an own-answer for the next person.</z><z id="t1461210641" t="aengelberg @bwstearns: Any time! I&apos;ve added an answer to your post"><y>#</y><d>2016-04-21</d><h>03:50</h><w>aengelberg</w>@bwstearns: Any time! I&apos;ve added an answer to your post</z><z id="t1461210690" t="bwstearns awesome. thanks. Didn&apos;t think about the performant part, is that primarily due to the extra step of having to transform it or is it because regexes are inherently faster than using parser rules?"><y>#</y><d>2016-04-21</d><h>03:51</h><w>bwstearns</w>awesome. thanks. Didn&apos;t think about the performant part, is that primarily due to the extra step of having to transform it or is it because regexes are inherently faster than using parser rules?</z><z id="t1461211110" t="aengelberg #&apos;a+&apos; is faster than &apos;a&apos;+ , as letting regexes do the work of searching for all possible &quot;a&quot;s is faster than having instaparse do that work"><y>#</y><d>2016-04-21</d><h>03:58</h><w>aengelberg</w><code>#&apos;a+&apos;</code> is faster than <code>&apos;a&apos;+</code>, as letting regexes do the work of searching for all possible &quot;a&quot;s is faster than having instaparse do that work</z><z id="t1461211392" t="aengelberg @bwstearns: ^"><y>#</y><d>2016-04-21</d><h>04:03</h><w>aengelberg</w>@bwstearns: ^</z><z id="t1461212213" t="bwstearns Right, that makes sense because of the greediness. Thanks a ton for taking the time on this."><y>#</y><d>2016-04-21</d><h>04:16</h><w>bwstearns</w>Right, that makes sense because of the greediness. Thanks a ton for taking the time on this.</z><z id="t1461212403" t="aengelberg It&apos;s not exactly *because* of the greediness, it&apos;s just speedier when a Java program is doing this task than Clojure simple_smile"><y>#</y><d>2016-04-21</d><h>04:20</h><w>aengelberg</w>It&apos;s not exactly *because* of the greediness, it&apos;s just speedier when a Java program is doing this task than Clojure <b>simple_smile</b></z><z id="t1461447696" t="bwstearns In the wikipedia conventions section on EBNF it suggests that you can have bounded repetitions ( https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions ), but the documentation doesn&apos;t say anything about it and I poked around the source and couldn&apos;t find anything in cfg that suggested it was there. Is the best way to get bounded reps to just merge in those rules from combinators?"><y>#</y><d>2016-04-23</d><h>21:41</h><w>bwstearns</w>In the wikipedia conventions section on EBNF it suggests that you can have bounded repetitions (<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions" target="_blank">https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions</a>), but the documentation doesn&apos;t say anything about it and I poked around the source and couldn&apos;t find anything in cfg that suggested it was there. Is the best way to get bounded reps to just merge in those rules from combinators?</z><z id="t1461739192" t="aengelberg @bwstearns sorry, didn&apos;t see your question until now. The instaparse ABNF notation (which is explained in ABNF.md ) supports repetition with any lower and/or upper bound. e.g. (insta/parser &quot;S = 3*5(&apos;a&apos;)&quot; :input-format :abnf) matches 3 to 5 a s. The default EBNF notation does not support it, so unless you want to switch to ABNF (a few conventions would have to change) then merging in combinators is the best approach."><y>#</y><d>2016-04-27</d><h>06:39</h><w>aengelberg</w>@bwstearns sorry, didn&apos;t see your question until now. The instaparse ABNF notation (which is explained in <code>ABNF.md</code>) supports repetition with any lower and/or upper bound. e.g. <code>(insta/parser &quot;S = 3*5(&apos;a&apos;)&quot; :input-format :abnf)</code> matches 3 to 5 <code>a</code>s. The default EBNF notation does not support it, so unless you want to switch to ABNF (a few conventions would have to change) then merging in combinators is the best approach.</z><z id="t1461765944" t="bwstearns @aengelberg: Sorry, I should have followed up with what I found, which is pretty much what you just said lol. I ended up implementing it by making a rep combinator and merging it into the main grammar, and then after looking at how unreadable it was getting I just threw a #&apos;\d\d&apos; regex at it (or something similar, I forget which part of the thing I was trying to parse). Thanks for following up though. Also, I knew I recognized you from something. Really enjoyed the automata presentation (I am of the youtube audience, haven’t had the good fortune to get to a clojure event in person yet)."><y>#</y><d>2016-04-27</d><h>14:05</h><w>bwstearns</w>@aengelberg: Sorry, I should have followed up with what I found, which is pretty much what you just said lol. I ended up implementing it by making a rep combinator and merging it into the main grammar, and then after looking at how unreadable it was getting I just threw a #&apos;\d\d&apos; regex at it (or something similar, I forget which part of the thing I was trying to parse). 

Thanks for following up though. Also, I knew I recognized you from something. Really enjoyed the automata presentation (I am of the youtube audience, haven’t had the good fortune to get to a clojure event in person yet).</z><z id="t1461915311" t="aengelberg @bwstearns: Glad you liked the talk! simple_smile If you have any more questions just @-mention me or say the word &quot;instaparse&quot; which also notifies me"><y>#</y><d>2016-04-29</d><h>07:35</h><w>aengelberg</w>@bwstearns: Glad you liked the talk! <b>simple_smile</b> If you have any more questions just @-mention me or say the word &quot;instaparse&quot; which also notifies me</z><z id="t1464769955" t="ska Hi. I am aware that Instaparse collects the offsets to the strings it parses in the metadata of the elements of the parse tree. I would like to turn the parse tree into XML (using :output-format :enlive and clojure.xml/emit ) and get the offset information somehow into the XML tree. Any pointers or ideas how to achieve this?"><y>#</y><d>2016-06-01</d><h>08:32</h><w>ska</w>Hi.  I am aware that Instaparse collects the offsets to the strings it parses in the metadata of the elements of the parse tree.  I would like to turn the parse tree into XML (using <code>:output-format :enlive</code> and <code>clojure.xml/emit</code>) and get the offset information somehow into the XML tree.  Any pointers or ideas how to achieve this?</z><z id="t1464870095" t="ska Does instaparse support special symbols for EOF and/or BOF?"><y>#</y><d>2016-06-02</d><h>12:21</h><w>ska</w>Does instaparse support special symbols for EOF and/or BOF?</z><z id="t1464883595" t="ska Hm, first experiments give hint that having &lt;EOF&gt; = &lt;#&apos;\\Z&apos;&gt; in my grammar works."><y>#</y><d>2016-06-02</d><h>16:06</h><w>ska</w>Hm, first experiments give hint that having <code>&lt;EOF&gt; = &lt;#&apos;\\Z&apos;&gt;</code> in my grammar works.</z><z id="t1464885459" t="aengelberg You could use the regex symbol for end of string, #&quot;$&quot; I believe"><y>#</y><d>2016-06-02</d><h>16:37</h><w>aengelberg</w>You could use the regex symbol for end of string, #&quot;$&quot; I believe</z><z id="t1464988242" t="dave hey everyone! this is a shot in the dark, but is anyone interested in helping me speed up alda&apos;s parser? i have some notes here: https://github.com/alda-lang/alda/pull/238 i have to run at the moment, but thought i&apos;d leave this here in case someone is interested in helping me tackle this"><y>#</y><d>2016-06-03</d><h>21:10</h><w>dave</w>hey everyone! this is a shot in the dark, but is anyone interested in helping me speed up alda&apos;s parser? i have some notes here: <a href="https://github.com/alda-lang/alda/pull/238" target="_blank">https://github.com/alda-lang/alda/pull/238</a>

i have to run at the moment, but thought i&apos;d leave this here in case someone is interested in helping me tackle this</z><z id="t1465885098" t="aengelberg @ghaz FYI https://github.com/aengelberg/cljsee"><y>#</y><d>2016-06-14</d><h>06:18</h><w>aengelberg</w>@ghaz FYI <a href="https://github.com/aengelberg/cljsee" target="_blank">https://github.com/aengelberg/cljsee</a></z><z id="t1465885108" t="aengelberg @lucasbradstreet ^"><y>#</y><d>2016-06-14</d><h>06:18</h><w>aengelberg</w>@lucasbradstreet ^</z><z id="t1465885185" t="aengelberg I wrote this plugin with Instaparse in mind as a use case. I&apos;m hoping this can help us get instaparse-cljs to (non cljx) portable code and maybe even merge this upstream."><y>#</y><d>2016-06-14</d><h>06:19</h><w>aengelberg</w>I wrote this plugin with Instaparse in mind as a use case. I&apos;m hoping this can help us get instaparse-cljs to (non cljx) portable code and maybe even merge this upstream.</z><z id="t1465886795" t="lucasbradstreet Thanks @aengelberg. I retweeted your tweet about it because it&apos;s awesome! Nice work. Unfortunately I have absolutely no time to help with a port right now :(, but the approach sounds like a great way to go "><y>#</y><d>2016-06-14</d><h>06:46</h><w>lucasbradstreet</w>Thanks @aengelberg. I retweeted your tweet about it because it&apos;s awesome! Nice work. Unfortunately I have absolutely no time to help with a port right now :(, but the approach sounds like a great way to go </z><z id="t1467597226" t="turbopape What&apos;s the status of cljs support ? "><y>#</y><d>2016-07-04</d><h>01:53</h><w>turbopape</w>What&apos;s the status of cljs support ? </z><z id="t1467597289" t="turbopape Is it still living as a fork?"><y>#</y><d>2016-07-04</d><h>01:54</h><w>turbopape</w>Is it still living as a fork?</z><z id="t1467597476" t="aengelberg The only cljs support still lives in lbradstreet/instaparse-cljs"><y>#</y><d>2016-07-04</d><h>01:57</h><w>aengelberg</w>The only cljs support still lives in lbradstreet/instaparse-cljs</z><z id="t1467597597" t="aengelberg But I&apos;m currently in the process of rewriting instaparse-cljs into a form that we&apos;d be willing to accept back into upstream, now that cljsee exists"><y>#</y><d>2016-07-04</d><h>01:59</h><w>aengelberg</w>But I&apos;m currently in the process of rewriting instaparse-cljs into a form that we&apos;d be willing to accept back into upstream, now that cljsee exists</z><z id="t1467618391" t="aengelberg @seylerius: Here&apos;s a grammar that parses exponents like you were you asking: boot.user=&gt; (def p (insta/parser &quot; &lt;S&gt; = ows (exponent ows)+ &lt;exponent&gt; = token &lt;&apos;^&apos;&gt; super super = token | &lt;&apos;{&apos;&gt; token &lt;&apos;}&apos;&gt; &lt;token&gt; = #&apos;[^\\s\\^{}]+&apos; &lt;ows&gt; = &lt;#&apos;\\s*&apos;&gt; &quot;)) #&apos;boot.user/p boot.user=&gt; (p &quot;foo^2 x^{x+1}&quot;) (&quot;foo&quot; [:super &quot;2&quot;] &quot;x&quot; [:super &quot;x+1&quot;]) This parser is pretty naive about the range of possible inputs, since I&apos;m not totally sure myself what that range of inputs is in your use case."><y>#</y><d>2016-07-04</d><h>07:46</h><w>aengelberg</w>@seylerius: Here&apos;s a grammar that parses exponents like you were you asking:
<pre>boot.user=&gt; (def p (insta/parser &quot;
&lt;S&gt; = ows (exponent ows)+
&lt;exponent&gt; = token &lt;&apos;^&apos;&gt; super
super = token | &lt;&apos;{&apos;&gt; token &lt;&apos;}&apos;&gt;
&lt;token&gt; = #&apos;[^\\s\\^{}]+&apos;
&lt;ows&gt; = &lt;#&apos;\\s*&apos;&gt;
&quot;))
#&apos;boot.user/p
boot.user=&gt; (p &quot;foo^2 x^{x+1}&quot;)
(&quot;foo&quot; [:super &quot;2&quot;] &quot;x&quot; [:super &quot;x+1&quot;])
</pre>
This parser is pretty naive about the range of possible inputs, since I&apos;m not totally sure myself what that range of inputs is in your use case.</z><z id="t1467650610" t="seylerius Thanks!"><y>#</y><d>2016-07-04</d><h>16:43</h><w>seylerius</w>Thanks!</z><z id="t1467650833" t="seylerius Another question: * / + = &amp; ~ can appear in singles without being tokens. How would you represent that? Current parser: http://sprunge.us/GNDe"><y>#</y><d>2016-07-04</d><h>16:47</h><w>seylerius</w>Another question: <code>*</code> <code>/</code> <code>+</code> <code>=</code> &amp; <code>~</code> can appear in singles without being tokens. How would you represent that? Current parser: <a href="http://sprunge.us/GNDe" target="_blank">http://sprunge.us/GNDe</a></z><z id="t1467651298" t="seylerius @aengelberg: What I have will do for the moment, but it&apos;s a part of the spec I&apos;d like to meet eventually."><y>#</y><d>2016-07-04</d><h>16:54</h><w>seylerius</w>@aengelberg: What I have will do for the moment, but it&apos;s a part of the spec I&apos;d like to meet eventually.</z><z id="t1467651806" t="Andy Hi, We switched recently for parsing user input using plain regex to instaparse. Code looks way better. However there are two corner cases where I am not sure what would be idiomatic way: 1) parsing of certain domain of inputs should result on noop. Our current solution is: &quot;sentence = define / explain / help / catchall &lt;&lt;skipped definitions&gt;&gt; catchall = #&apos;(.|[\n\r])*&apos;&quot; with an intention to just ignore last part during transformation : catchall (fn [_] nil) Now I wonder if there is another way to catch this case and ignore without using exceptions. 2)`&apos;(.|[\n\r])*&apos;` comes with | which on JVM leads on recursion and might result in stack overflow. In fact it happened one to us. Is there a better way to write catchall which would account for anything including \n and \r ."><y>#</y><d>2016-07-04</d><h>17:03</h><w>Andy</w>Hi,
We switched recently for parsing user input using plain regex to instaparse. Code looks way better. However there are two corner cases where I am not sure what would be idiomatic way:
1) parsing of certain domain of inputs should result on noop.  Our current solution is:
<pre>&quot;sentence = define / explain / help / catchall
&lt;&lt;skipped definitions&gt;&gt;
 catchall = #&apos;(.|[\n\r])*&apos;&quot;
</pre>
with an intention to just ignore last part during transformation <code>: catchall (fn [_] nil)</code>

Now I wonder if there is another way to catch this case and ignore without using exceptions.

2)`&apos;(.|[\n\r])*&apos;` comes with <code>|</code> which on JVM leads on recursion and might result in stack overflow. In fact it happened one to us.  Is there a better way to write <code>catchall</code> which would account for anything including <code>\n</code> and <code>\r</code>.</z><z id="t1467652205" t="aengelberg @happy.lisper for catchall you could do #&apos;[\s\S]*&apos;"><y>#</y><d>2016-07-04</d><h>17:10</h><w>aengelberg</w>@happy.lisper for catchall you could do <code>#&apos;[\s\S]*&apos;</code></z><z id="t1467652224" t="Andy ty"><y>#</y><d>2016-07-04</d><h>17:10</h><w>Andy</w>ty</z><z id="t1467652276" t="aengelberg So your use case is: &quot;Parse the entire string as a define , an explain , or a help , but if that doesn&apos;t work then return nil&quot;?"><y>#</y><d>2016-07-04</d><h>17:11</h><w>aengelberg</w>So your use case is: &quot;Parse the entire string as a <code>define</code>, an <code>explain</code>, or a <code>help</code>, but if that doesn&apos;t work then return nil&quot;?</z><z id="t1467652303" t="aengelberg Because you could just run the parse and a transform, then check (insta/failure? result)"><y>#</y><d>2016-07-04</d><h>17:11</h><w>aengelberg</w>Because you could just run the parse and a transform, then check <code>(insta/failure? result)</code></z><z id="t1467652312" t="Andy yes, where nil is just a signal to ignore the input."><y>#</y><d>2016-07-04</d><h>17:11</h><w>Andy</w>yes, where <code>nil</code> is just a signal to ignore the input.</z><z id="t1467652434" t="aengelberg (def p (insta/parser ...)) (let [result (p input-string) transformed (insta/transform p {...})] (when-not (insta/failure? transformed) transformed)) "><y>#</y><d>2016-07-04</d><h>17:13</h><w>aengelberg</w><pre>(def p (insta/parser ...))
(let [result (p input-string)
      transformed (insta/transform p {...})]
  (when-not (insta/failure? transformed)
    transformed))
</pre></z><z id="t1467652452" t="aengelberg Note that insta/transform is specifically designed to pass through failures"><y>#</y><d>2016-07-04</d><h>17:14</h><w>aengelberg</w>Note that <code>insta/transform</code> is specifically designed to pass through failures</z><z id="t1467652513" t="Andy Let me consider that 🙂 ."><y>#</y><d>2016-07-04</d><h>17:15</h><w>Andy</w>Let me consider that <b>🙂</b>.</z><z id="t1467652790" t="aengelberg @seylerius: Given an input ~a ~b , how do you know the a and b are to be parsed as individual ~ &apos;s, as opposed to a code string of &quot;a &quot; followed by &quot;b&quot; ?"><y>#</y><d>2016-07-04</d><h>17:19</h><w>aengelberg</w>@seylerius: Given an input <code>~a ~b</code>, how do you know the <code>a</code> and <code>b</code> are to be parsed as individual <code>~</code>&apos;s, as opposed to a code string of <code>&quot;a &quot;</code> followed by <code>&quot;b&quot;</code>?</z><z id="t1467653046" t="seylerius @aengelberg: If I&apos;m reading this correctly, the characters touching the inside of the tokens need to be alphanumeric, or at least non-whitespace."><y>#</y><d>2016-07-04</d><h>17:24</h><w>seylerius</w>@aengelberg: If I&apos;m reading this correctly, the characters touching the inside of the tokens need to be alphanumeric, or at least non-whitespace.</z><z id="t1467653263" t="aengelberg so *a b c* shouldn&apos;t be allowed?"><y>#</y><d>2016-07-04</d><h>17:27</h><w>aengelberg</w>so <code>*a b c*</code> shouldn&apos;t be allowed?</z><z id="t1467653304" t="aengelberg the current grammar that I suggested would allow that. Just trying to get a sense of the range of inputs so I can help design a parser accordingly"><y>#</y><d>2016-07-04</d><h>17:28</h><w>aengelberg</w>the current grammar that I suggested would allow that. Just trying to get a sense of the range of inputs so I can help design a parser accordingly</z><z id="t1467653364" t="seylerius *foo* *bar* ➡ [:b &quot;foo&quot; &quot;bar&quot;] foo* bar* ➡ &quot;foo* bar*&quot; "><y>#</y><d>2016-07-04</d><h>17:29</h><w>seylerius</w><code>*foo* *bar*</code> <b>➡</b> <code>[:b &quot;foo&quot; &quot;bar&quot;] </code>
<code>foo* bar*</code> <b>➡</b> <code>&quot;foo* bar*&quot; </code></z><z id="t1467653616" t="seylerius @aengelberg: that make sense?"><y>#</y><d>2016-07-04</d><h>17:33</h><w>seylerius</w>@aengelberg: that make sense?</z><z id="t1467653690" t="aengelberg for the first example do you mean [:b &quot;foo&quot;] [:b &quot;bar&quot;] ?"><y>#</y><d>2016-07-04</d><h>17:34</h><w>aengelberg</w>for the first example do you mean <code>[:b &quot;foo&quot;] [:b &quot;bar&quot;]</code>?</z><z id="t1467653836" t="aengelberg is there a guarantee that *a**b* won&apos;t happen?"><y>#</y><d>2016-07-04</d><h>17:37</h><w>aengelberg</w>is there a guarantee that <code>*a**b*</code> won&apos;t happen?</z><z id="t1467653926" t="seylerius @aengelberg: Yes. And guarantee? No. Ambiguity in the spec we can lock to an interpretation? Yes."><y>#</y><d>2016-07-04</d><h>17:38</h><w>seylerius</w>@aengelberg: Yes. 
And guarantee? No. Ambiguity in the spec we can lock to an interpretation? Yes.</z><z id="t1467654317" t="seylerius We basically get to decide if that&apos;s a pair of bold characters or a flat string we&apos;ll leave be."><y>#</y><d>2016-07-04</d><h>17:45</h><w>seylerius</w>We basically get to decide if that&apos;s a pair of bold characters or a flat string we&apos;ll leave be.</z><z id="t1467654328" t="seylerius It would only likely happen as a typo."><y>#</y><d>2016-07-04</d><h>17:45</h><w>seylerius</w>It would only likely happen as a typo.</z><z id="t1467654341" t="seylerius (Or a stupid user)"><y>#</y><d>2016-07-04</d><h>17:45</h><w>seylerius</w>(Or a stupid user)</z><z id="t1467654487" t="seylerius @aengelberg: I&apos;m basically upgrading organum. Sample org file: http://sprunge.us/KBbL"><y>#</y><d>2016-07-04</d><h>17:48</h><w>seylerius</w>@aengelberg: I&apos;m basically upgrading organum. Sample org file: <a href="http://sprunge.us/KBbL" target="_blank">http://sprunge.us/KBbL</a></z><z id="t1467654661" t="aengelberg hmm, thinking through how to enforce alphanumeric chars on the insides of tokens."><y>#</y><d>2016-07-04</d><h>17:51</h><w>aengelberg</w>hmm, thinking through how to enforce alphanumeric chars on the insides of tokens.</z><z id="t1467654742" t="aengelberg doing a &quot;lookbehind&quot; on the last * is nontrivial."><y>#</y><d>2016-07-04</d><h>17:52</h><w>aengelberg</w>doing a &quot;lookbehind&quot; on the last <code>*</code> is nontrivial.</z><z id="t1467655276" t="seylerius What if I stripped leading and trailing whitespace before parsing, and modified the base string rule to start and end alphanumeric? Would that be easier?"><y>#</y><d>2016-07-04</d><h>18:01</h><w>seylerius</w>What if I stripped leading and trailing whitespace before parsing, and modified the base <code>string</code> rule to start and end alphanumeric? Would that be easier?</z><z id="t1467655537" t="seylerius But, no, that wouldn&apos;t quite work."><y>#</y><d>2016-07-04</d><h>18:05</h><w>seylerius</w>But, no, that wouldn&apos;t quite work.</z><z id="t1467655889" t="seylerius @aengelberg: Will the parser ignore escaped tokens, like \* ?"><y>#</y><d>2016-07-04</d><h>18:11</h><w>seylerius</w>@aengelberg: Will the parser ignore escaped tokens, like <code>\*</code>?</z><z id="t1467655968" t="seylerius Ach. Clojure doesn&apos;t like \* in a string"><y>#</y><d>2016-07-04</d><h>18:12</h><w>seylerius</w>Ach. Clojure doesn&apos;t like <code>\*</code> in a string</z><z id="t1467657043" t="seylerius @aengelberg: Is here any way to mark tokens to not be parsed?"><y>#</y><d>2016-07-04</d><h>18:30</h><w>seylerius</w>@aengelberg: Is here any way to mark tokens to not be parsed?</z><z id="t1467657215" t="Andy would angle brackets &lt;&gt; to hide parsed elements work?"><y>#</y><d>2016-07-04</d><h>18:33</h><w>Andy</w>would angle brackets <code>&lt;&gt;</code> to hide parsed elements work?</z><z id="t1467657329" t="aengelberg @seylerius you&apos;d have to do \\* if inside a Clojure string"><y>#</y><d>2016-07-04</d><h>18:35</h><w>aengelberg</w>@seylerius you&apos;d have to do <code>\\*</code> if inside a Clojure string</z><z id="t1467657414" t="aengelberg the goal is to avoid parsing *a * as [:b &quot;a &quot;]"><y>#</y><d>2016-07-04</d><h>18:36</h><w>aengelberg</w>the goal is to avoid parsing <code>*a *</code> as <code>[:b &quot;a &quot;]</code></z><z id="t1467657454" t="seylerius @aengelberg: Anything special I have to do to mark that? I just tried parsing \\*foo\\* and got (&quot;\\&quot; [:b &quot;foo\\&quot;]) "><y>#</y><d>2016-07-04</d><h>18:37</h><w>seylerius</w>@aengelberg: Anything special I have to do to mark that? I just tried parsing <code>\\*foo\\*</code> and got <code>(&quot;\\&quot; [:b &quot;foo\\&quot;]) </code></z><z id="t1467657502" t="aengelberg instaparse doesn&apos;t automatically handle backslashes in any special way besides what has been defined in your grammar."><y>#</y><d>2016-07-04</d><h>18:38</h><w>aengelberg</w>instaparse doesn&apos;t automatically handle backslashes in any special way besides what has been defined in your grammar.</z><z id="t1467657702" t="seylerius Okay. How do you define a simple backslash replacement in this type of grammar, then?"><y>#</y><d>2016-07-04</d><h>18:41</h><w>seylerius</w>Okay. How do you define a simple backslash replacement in this type of grammar, then?</z><z id="t1467657959" t="aengelberg Maybe replace &lt;string&gt; with: &lt;string&gt; = &apos;\\\\*&apos; | #&apos;[^*/_+=~^_\\\\]+&apos; user&gt; (inline-markup &quot;a\\* b&quot;) (&quot;a&quot; &quot;\\*&quot; &quot; b&quot;) "><y>#</y><d>2016-07-04</d><h>18:45</h><w>aengelberg</w>Maybe replace <code>&lt;string&gt;</code> with:
<pre>&lt;string&gt; = &apos;\\\\*&apos; | #&apos;[^*/_+=~^_\\\\]+&apos;
</pre>
<pre>user&gt; (inline-markup &quot;a\\* b&quot;)
(&quot;a&quot; &quot;\\*&quot; &quot; b&quot;)
</pre></z><z id="t1467657977" t="aengelberg Pretty messy, I know. (four backslashes 🙄 )"><y>#</y><d>2016-07-04</d><h>18:46</h><w>aengelberg</w>Pretty messy, I know. (four backslashes <b>🙄</b>)</z><z id="t1467658083" t="aengelberg I don&apos;t know if this solves your problem though; you don&apos;t want to escape * &apos;s in every ** My Subsection text, do you?"><y>#</y><d>2016-07-04</d><h>18:48</h><w>aengelberg</w>I don&apos;t know if this solves your problem though; you don&apos;t want to escape <code>*</code>&apos;s in every <code>** My Subsection</code> text, do you?</z><z id="t1467658153" t="aengelberg sorry if I&apos;m a bit unhelpful; phasing in and out of AFK"><y>#</y><d>2016-07-04</d><h>18:49</h><w>aengelberg</w>sorry if I&apos;m a bit unhelpful; phasing in and out of AFK</z><z id="t1467658238" t="seylerius I&apos;m thinking I&apos;m just going to tell users that if they want a plain * they have to escape it."><y>#</y><d>2016-07-04</d><h>18:50</h><w>seylerius</w>I&apos;m thinking I&apos;m just going to tell users that if they want a plain <code>*</code> they have to escape it.</z><z id="t1467658283" t="seylerius Headlines are already handled by the time this stage of parsing is invoked, so those won&apos;t be an issue."><y>#</y><d>2016-07-04</d><h>18:51</h><w>seylerius</w>Headlines are already handled by the time this stage of parsing is invoked, so those won&apos;t be an issue.</z><z id="t1467658401" t="seylerius And your special case of *a**b* is apparently already readily converted to ([:b &quot;a&quot;] [:b &quot;b&quot;])"><y>#</y><d>2016-07-04</d><h>18:53</h><w>seylerius</w>And your special case of <code>*a**b*</code> is apparently already readily converted to <code>([:b &quot;a&quot;] [:b &quot;b&quot;])</code></z><z id="t1467663066" t="seylerius @aengelberg: Separate (earlier stage) parser: Is it possible (other than by having respective rules for #&apos;^* &apos; , #&apos;^** &apos; , #&apos;^*** &apos; , etc) to easily produce h1 , h2 , h3 , etc?"><y>#</y><d>2016-07-04</d><h>20:11</h><w>seylerius</w>@aengelberg: Separate (earlier stage) parser: Is it possible (other than by having respective rules for <code>#&apos;^* &apos;</code>, <code>#&apos;^** &apos;</code>, <code>#&apos;^*** &apos;</code>, etc) to easily produce <code>h1</code>, <code>h2</code>, <code>h3</code>, etc?</z><z id="t1467663625" t="seylerius Actually, yeah. Just don&apos;t hide the token, and I can put that through a counter after the fact."><y>#</y><d>2016-07-04</d><h>20:20</h><w>seylerius</w>Actually, yeah. Just don&apos;t hide the token, and I can put that through a counter after the fact.</z><z id="t1467678938" t="seylerius @aengelberg: I&apos;m trying to make blank lines in one parser flag as :blank , but they&apos;re staying as empty seqs. Parser: http://sprunge.us/RcOf Tester: http://sprunge.us/GGdK"><y>#</y><d>2016-07-05</d><h>00:35</h><w>seylerius</w>@aengelberg: I&apos;m trying to make blank lines in one parser flag as <code>:blank</code>, but they&apos;re staying as empty seqs. 
Parser: <a href="http://sprunge.us/RcOf" target="_blank">http://sprunge.us/RcOf</a>
Tester: <a href="http://sprunge.us/GGdK" target="_blank">http://sprunge.us/GGdK</a></z><z id="t1467679158" t="aengelberg currently that parser doesn&apos;t account for any newlines (`\n`) between the lines / blank lines, is that intentional?"><y>#</y><d>2016-07-05</d><h>00:39</h><w>aengelberg</w>currently that parser doesn&apos;t account for any newlines (`\n`) between the lines / blank lines, is that intentional?</z><z id="t1467680082" t="seylerius The library I&apos;m modifying reads the file into a line-seq initially, so I&apos;m mostly just going with that."><y>#</y><d>2016-07-05</d><h>00:54</h><w>seylerius</w>The library I&apos;m modifying reads the file into a line-seq initially, so I&apos;m mostly just going with that.</z><z id="t1467746797" t="seylerius @aengelberg: Think it would be easier if it was parsing the original, and not a line-seq?"><y>#</y><d>2016-07-05</d><h>19:26</h><w>seylerius</w>@aengelberg: Think it would be easier if it was parsing the original, and not a line-seq?</z><z id="t1467747027" t="aengelberg it may be useful to, instead of line-seq, use a different parser on the original input that identifies the sections / subsections but not the inline syntax."><y>#</y><d>2016-07-05</d><h>19:30</h><w>aengelberg</w>it may be useful to, instead of line-seq, use a different parser on the original input that identifies the sections / subsections but not the inline syntax.</z><z id="t1467747131" t="seylerius Yeah. I&apos;m already splitting it into multiple instaparsers. I take it insta can handle multi-line input?"><y>#</y><d>2016-07-05</d><h>19:32</h><w>seylerius</w>Yeah. I&apos;m already splitting it into multiple instaparsers. I take it insta can handle multi-line input?</z><z id="t1467747243" t="aengelberg yeah, just make sure all your strings / regexes handle them. All characters are equal citizens in instaparse input, it&apos;s up to the grammar to handle what it wants to handle. And make sure the grammar handles CRLFs (`\r\n`) which may appear."><y>#</y><d>2016-07-05</d><h>19:34</h><w>aengelberg</w>yeah, just make sure all your strings / regexes handle them. All characters are equal citizens in instaparse input, it&apos;s up to the grammar to handle what it wants to handle. And make sure the grammar handles CRLFs (`\r\n`) which may appear.</z><z id="t1467757336" t="seylerius @aengelberg: So make sure my regexps are multi-line and whatnot?"><y>#</y><d>2016-07-05</d><h>22:22</h><w>seylerius</w>@aengelberg: So make sure my regexps are multi-line and whatnot?</z><z id="t1467757647" t="aengelberg yep"><y>#</y><d>2016-07-05</d><h>22:27</h><w>aengelberg</w>yep</z><z id="t1467757664" t="aengelberg e.g. . inside a regex matches any non-newline character"><y>#</y><d>2016-07-05</d><h>22:27</h><w>aengelberg</w>e.g. <code>.</code> inside a regex matches any non-newline character</z><z id="t1467758152" t="aengelberg also, \s inside a regex handles any kind of whitespace (including newlines)"><y>#</y><d>2016-07-05</d><h>22:35</h><w>aengelberg</w>also, <code>\s</code> inside a regex handles any kind of whitespace (including newlines)</z><z id="t1467758454" t="seylerius Good caveats to know, thanks"><y>#</y><d>2016-07-05</d><h>22:40</h><w>seylerius</w>Good caveats to know, thanks</z><z id="t1467871526" t="seylerius @aengelberg: Any particular instaparse way to go multi-line, or just specify it in the regexps?"><y>#</y><d>2016-07-07</d><h>06:05</h><w>seylerius</w>@aengelberg: Any particular instaparse way to go multi-line, or just specify it in the regexps?</z><z id="t1467911408" t="aengelberg @seylerius not sure what exactly you&apos;re confused about, but here are some examples: imagine you&apos;re parsing the following input: aaaa bbb cccccc the grammar could look like S = A &apos;\n&apos; B &apos;\n&apos; C A = &apos;a&apos;+ B = &apos;b&apos;+ C = &apos;c&apos;+ "><y>#</y><d>2016-07-07</d><h>17:10</h><w>aengelberg</w>@seylerius not sure what exactly you&apos;re confused about, but here are some examples:
imagine you&apos;re parsing the following input:
<pre>aaaa
bbb
cccccc
</pre>
the grammar could look like
<pre>S = A &apos;\n&apos; B &apos;\n&apos; C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
</pre></z><z id="t1467911445" t="aengelberg or S = #&apos;a+\n&apos; #&apos;b+\n&apos; #&apos;c+&apos; "><y>#</y><d>2016-07-07</d><h>17:10</h><w>aengelberg</w>or
<pre>S = #&apos;a+\n&apos; #&apos;b+\n&apos; #&apos;c+&apos;
</pre></z><z id="t1467911505" t="aengelberg either \n or \\n would work if you are inside a Clojure string."><y>#</y><d>2016-07-07</d><h>17:11</h><w>aengelberg</w>either <code>\n</code> or <code>\\n</code> would work if you are inside a Clojure string.</z><z id="t1467911612" t="aengelberg S = A ows B ows C A = &apos;a&apos;+ B = &apos;b&apos;+ C = &apos;c&apos;+ (* optional whitespace *) &lt;ows&gt; = &lt;#&apos;\s*&apos;&gt; "><y>#</y><d>2016-07-07</d><h>17:13</h><w>aengelberg</w><pre>S = A ows B ows C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
(* optional whitespace *)
&lt;ows&gt; = &lt;#&apos;\s*&apos;&gt;
</pre></z><z id="t1467911637" t="aengelberg For that example, inside a Clojure string you would need to change \s to \\s ."><y>#</y><d>2016-07-07</d><h>17:13</h><w>aengelberg</w>For that example, inside a Clojure string you would need to change <code>\s</code> to <code>\\s</code>.</z><z id="t1467913334" t="seylerius @aengelberg: Also, how would you modify what would normally be a .* to not eat an optional :[ that follows it? Or would you just post-process that out after?"><y>#</y><d>2016-07-07</d><h>17:42</h><w>seylerius</w>@aengelberg: Also, how would you modify what would normally be a <code>.*</code> to not eat an optional <code>:[</code> that follows it? Or would you just post-process that out after?</z><z id="t1467913476" t="aengelberg so you&apos;re trying to parse #&quot;shown-part hidden-part&quot; but only return &quot;shown-part&quot; in the parse result?"><y>#</y><d>2016-07-07</d><h>17:44</h><w>aengelberg</w>so you&apos;re trying to parse <code>#&quot;shown-part hidden-part&quot;</code> but only return <code>&quot;shown-part&quot;</code> in the parse result?</z><z id="t1467913617" t="aengelberg you could use the regex lookahead to omit it from the result, but then actually parse it (with instaparse&apos;s &lt;&gt; hiding feature) in order to properly advance the parser. S = #&apos;shown-part(?=hidden-part)&apos; &lt;#&apos;hidden-part&apos;&gt; "><y>#</y><d>2016-07-07</d><h>17:46</h><w>aengelberg</w>you could use the regex lookahead to omit it from the result, but then actually parse it (with instaparse&apos;s <code>&lt;&gt;</code> hiding feature) in order to properly advance the parser.
<pre>S = #&apos;shown-part(?=hidden-part)&apos; &lt;#&apos;hidden-part&apos;&gt;
</pre></z><z id="t1467913829" t="aengelberg or unhide the second #&apos;hidden-part&apos; if you actually do want it in the parse tree, but separate from #&apos;shown-part&apos; ."><y>#</y><d>2016-07-07</d><h>17:50</h><w>aengelberg</w>or unhide the second <code>#&apos;hidden-part&apos;</code> if you actually do want it in the parse tree, but separate from <code>#&apos;shown-part&apos;</code>.</z><z id="t1467916756" t="seylerius @aengelberg: More like org-mode headlines allow tags at the end in that style. Not hidden so much as separate."><y>#</y><d>2016-07-07</d><h>18:39</h><w>seylerius</w>@aengelberg: More like org-mode headlines allow tags at the end in that style. Not hidden so much as separate.</z><z id="t1467952087" t="seylerius @aengelberg: Basically, how would you parse an optional non-hidden token that follows a token that may contain things somewhat similar to the optional non-hidden token?"><y>#</y><d>2016-07-08</d><h>04:28</h><w>seylerius</w>@aengelberg: Basically, how would you parse an optional non-hidden token that follows a token that may contain things somewhat similar to the optional non-hidden token?</z><z id="t1468261311" t="seylerius Ah, I see what you&apos;re talking about"><y>#</y><d>2016-07-11</d><h>18:21</h><w>seylerius</w>Ah, I see what you&apos;re talking about</z><z id="t1471480536" t="uwo Is there anyway to prevent intsta/parse from printing to the repl on error?"><y>#</y><d>2016-08-18</d><h>00:35</h><w>uwo</w>Is there anyway to prevent <code>intsta/parse</code> from printing to the repl on error?</z><z id="t1471574879" t="seylerius Hrm. Is there a way to make some tokens higher priority than others? This parser ( http://sprunge.us/hFCU ) eats the entire input file, failing to break out the initial metadata."><y>#</y><d>2016-08-19</d><h>02:47</h><w>seylerius</w>Hrm. Is there a way to make some tokens higher priority than others? This parser (<a href="http://sprunge.us/hFCU" target="_blank">http://sprunge.us/hFCU</a>) eats the entire input file, failing to break out the initial metadata.</z><z id="t1471574972" t="seylerius When I try to make the content token reluctant (adding a ? to the * ), it fails to match when the content section begins."><y>#</y><d>2016-08-19</d><h>02:49</h><w>seylerius</w>When I try to make the <code>content</code> token reluctant (adding a <code>?</code> to the <code>*</code>), it fails to match when the content section begins.</z><z id="t1471615915" t="dave @seylerius you could use ordered choice https://github.com/Engelberg/instaparse#ordered-choice"><y>#</y><d>2016-08-19</d><h>14:11</h><w>dave</w>@seylerius you could use ordered choice <a href="https://github.com/Engelberg/instaparse#ordered-choice" target="_blank">https://github.com/Engelberg/instaparse#ordered-choice</a></z><z id="t1471615948" t="dave define a rule that could be one or the other, using / instead of | , and put the one you prefer first"><y>#</y><d>2016-08-19</d><h>14:12</h><w>dave</w>define a rule that could be one or the other, using <code>/</code> instead of <code>|</code>, and put the one you prefer first</z><z id="t1471616012" t="dave although, it looks like your title rule is probably consuming everything"><y>#</y><d>2016-08-19</d><h>14:13</h><w>dave</w>although, it looks like your title rule is probably consuming everything</z><z id="t1471616025" t="dave #&apos;.*&apos;"><y>#</y><d>2016-08-19</d><h>14:13</h><w>dave</w><code>#&apos;.*&apos;</code></z><z id="t1471616030" t="dave that will consume everything"><y>#</y><d>2016-08-19</d><h>14:13</h><w>dave</w>that will consume everything</z><z id="t1471616045" t="seylerius Nope, it&apos;s not eating newlines."><y>#</y><d>2016-08-19</d><h>14:14</h><w>seylerius</w>Nope, it&apos;s not eating newlines.</z><z id="t1471616055" t="seylerius This looks like it&apos;s going to do it."><y>#</y><d>2016-08-19</d><h>14:14</h><w>seylerius</w>This looks like it&apos;s going to do it.</z><z id="t1471616058" t="dave oh, you&apos;re right!"><y>#</y><d>2016-08-19</d><h>14:14</h><w>dave</w>oh, you&apos;re right!</z><z id="t1471625134" t="aengelberg @uwo: instaparse doesn&apos;t print anything when a failure occurs. It returns a instaparse.Failure object which happens to print in a special way at the REPL"><y>#</y><d>2016-08-19</d><h>16:45</h><w>aengelberg</w>@uwo: instaparse doesn&apos;t print anything when a failure occurs. It returns a <code>instaparse.Failure</code> object which happens to print in a special way at the REPL</z><z id="t1472313305" t="seylerius Okay, I&apos;m producing hiccup-style structures from inataparse. I need help figuring out how to re-parse specific items within the structure."><y>#</y><d>2016-08-27</d><h>15:55</h><w>seylerius</w>Okay, I&apos;m producing hiccup-style structures from inataparse. I need help figuring out how to re-parse specific items within the structure.</z><z id="t1472313399" t="seylerius Solo strings (unmatched with a tag) are one of the types I need to re- parse in place"><y>#</y><d>2016-08-27</d><h>15:56</h><w>seylerius</w>Solo strings (unmatched with a tag) are one of the types I need to re- parse in place</z><z id="t1472313439" t="seylerius Wait, this would go better in #C03S1KBA2"><y>#</y><d>2016-08-27</d><h>15:57</h><w>seylerius</w>Wait, this would go better in #C03S1KBA2</z><z id="t1472313549" t="seylerius Didn&apos;t realize I was still in instaparse"><y>#</y><d>2016-08-27</d><h>15:59</h><w>seylerius</w>Didn&apos;t realize I was still in instaparse</z><z id="t1472343669" t="aengelberg @seylerius this is a good place for that."><y>#</y><d>2016-08-28</d><h>00:21</h><w>aengelberg</w>@seylerius this is a good place for that.</z><z id="t1472343695" t="aengelberg You could put further &quot;insta/parse&quot;s in the functions inside the &quot;insta/transform&quot; map"><y>#</y><d>2016-08-28</d><h>00:21</h><w>aengelberg</w>You could put further &quot;insta/parse&quot;s in the functions inside the &quot;insta/transform&quot; map</z><z id="t1472343708" t="seylerius Wat"><y>#</y><d>2016-08-28</d><h>00:21</h><w>seylerius</w>Wat</z><z id="t1472343713" t="seylerius This is awesome."><y>#</y><d>2016-08-28</d><h>00:21</h><w>seylerius</w>This is awesome.</z><z id="t1472343785" t="aengelberg (insta/transform {:x (fn [s] (insta/parse otherparser s))} (insta/parse firstparser s)"><y>#</y><d>2016-08-28</d><h>00:23</h><w>aengelberg</w><code>(insta/transform {:x (fn [s] (insta/parse otherparser s))} (insta/parse firstparser s)</code></z><z id="t1472343792" t="aengelberg Hard to bang out a good example on mobile"><y>#</y><d>2016-08-28</d><h>00:23</h><w>aengelberg</w>Hard to bang out a good example on mobile</z><z id="t1472343818" t="seylerius Lolyep."><y>#</y><d>2016-08-28</d><h>00:23</h><w>seylerius</w>Lolyep.</z><z id="t1472343826" t="seylerius That looks fascinating."><y>#</y><d>2016-08-28</d><h>00:23</h><w>seylerius</w>That looks fascinating.</z><z id="t1472343852" t="aengelberg It would get weird if the nested parser had an error though."><y>#</y><d>2016-08-28</d><h>00:24</h><w>aengelberg</w>It would get weird if the nested parser had an error though.</z><z id="t1472343859" t="seylerius Yeah."><y>#</y><d>2016-08-28</d><h>00:24</h><w>seylerius</w>Yeah.</z><z id="t1472343929" t="seylerius So how deep does it go looking for :x ?"><y>#</y><d>2016-08-28</d><h>00:25</h><w>seylerius</w>So how deep does it go looking for <code>:x</code>?</z><z id="t1472343969" t="seylerius And how do you make it check for loose strings?"><y>#</y><d>2016-08-28</d><h>00:26</h><w>seylerius</w>And how do you make it check for loose strings?</z><z id="t1472344017" t="aengelberg It does a full traversal of the hiccup / enlive, as long as all structures around the :x are valid hiccup / enlive"><y>#</y><d>2016-08-28</d><h>00:26</h><w>aengelberg</w>It does a full traversal of the hiccup / enlive, as long as all structures around the <code>:x</code> are valid hiccup / enlive</z><z id="t1472344025" t="seylerius Nice"><y>#</y><d>2016-08-28</d><h>00:27</h><w>seylerius</w>Nice</z><z id="t1472345954" t="seylerius @aengelberg: How do you get solo strings?"><y>#</y><d>2016-08-28</d><h>00:59</h><w>seylerius</w>@aengelberg: How do you get solo strings?</z><z id="t1472418079" t="seylerius Gah, what&apos;s wrong with this parser? doc-metadata works fine, but running headlines on the remaining content just returns flat content. https://github.com/seylerius/organum"><y>#</y><d>2016-08-28</d><h>21:01</h><w>seylerius</w>Gah, what&apos;s wrong with this parser? <code>doc-metadata</code> works fine, but running <code>headlines</code> on the remaining content just returns flat content. <a href="https://github.com/seylerius/organum" target="_blank">https://github.com/seylerius/organum</a></z><z id="t1472418156" t="seylerius @aengelberg: Got any clues?"><y>#</y><d>2016-08-28</d><h>21:02</h><w>seylerius</w>@aengelberg: Got any clues?</z><z id="t1472418237" t="seylerius Simple reproduction: (headlines (last (doc-metadata (slurp &quot;&quot;)))) "><y>#</y><d>2016-08-28</d><h>21:03</h><w>seylerius</w>Simple reproduction: <code>(headlines (last (doc-metadata (slurp &quot;&quot;)))) </code></z><z id="t1472418308" t="seylerius It&apos;s something in the h token, because that&apos;s the last thing I changed before it started failing."><y>#</y><d>2016-08-28</d><h>21:05</h><w>seylerius</w>It&apos;s something in the <code>h</code> token, because that&apos;s the last thing I changed before it started failing.</z><z id="t1472418645" t="ska At a first glance, the #&apos;.+&apos; looks suspicious to me. Is greediness biting you here? (Did not try it out, though)"><y>#</y><d>2016-08-28</d><h>21:10</h><w>ska</w>At a first glance, the <code>#&apos;.+&apos;</code> looks suspicious to me.  Is greediness biting you here? (Did not try it out, though)</z><z id="t1472419500" t="aengelberg @seylerius the regex you put for :content is probably not what you want. Due to the (?s) flag, seems to match everything including newlines, as long as the first character is not a * ."><y>#</y><d>2016-08-28</d><h>21:25</h><w>aengelberg</w>@seylerius the regex you put for <code>:content</code> is probably not what you want. Due to the <code>(?s)</code> flag, seems to match everything including newlines, as long as the first character is not a <code>*</code>.</z><z id="t1472419506" t="aengelberg I&apos;m not sure what your desired behavior is though."><y>#</y><d>2016-08-28</d><h>21:25</h><w>aengelberg</w>I&apos;m not sure what your desired behavior is though.</z><z id="t1472419576" t="aengelberg BTW, both the first ^ and the ? in your regex appear redundant, if I understand it correctly."><y>#</y><d>2016-08-28</d><h>21:26</h><w>aengelberg</w>BTW, both the first <code>^</code> and the <code>?</code> in your regex appear redundant, if I understand it correctly.</z><z id="t1472419589" t="seylerius The content regexp is fine. It&apos;s after I changed a few things to tidy up :h and added tag parsing that it started failing."><y>#</y><d>2016-08-28</d><h>21:26</h><w>seylerius</w>The content regexp is fine. It&apos;s after I changed a few things to tidy up <code>:h</code> and added tag parsing that it started failing.</z><z id="t1472419614" t="seylerius Basically, a headline starts with some number of stars. Everything else isn&apos;t a headline."><y>#</y><d>2016-08-28</d><h>21:26</h><w>seylerius</w>Basically, a headline starts with some number of stars. Everything else isn&apos;t a headline.</z><z id="t1472419616" t="aengelberg I cloned your project and am looking at that parser. Is there a different version / branch I missed?"><y>#</y><d>2016-08-28</d><h>21:26</h><w>aengelberg</w>I cloned your project and am looking at that parser. Is there a different version / branch I missed?</z><z id="t1472419658" t="seylerius Nope, I pushed the latest version just before I spoke up today."><y>#</y><d>2016-08-28</d><h>21:27</h><w>seylerius</w>Nope, I pushed the latest version just before I spoke up today.</z><z id="t1472419693" t="aengelberg Sorry I may have been unclear. When I said :content I meant the content inside the headlines parser."><y>#</y><d>2016-08-28</d><h>21:28</h><w>aengelberg</w>Sorry I may have been unclear. When I said <code>:content</code> I meant the content inside the headlines parser.</z><z id="t1472419706" t="aengelberg Not the doc-metadata parser"><y>#</y><d>2016-08-28</d><h>21:28</h><w>aengelberg</w>Not the doc-metadata parser</z><z id="t1472419745" t="aengelberg As an experiment I removed all the hide-tags from the headlines parser, since I got that behavior you were talking about (flat content). That exposed the headlines&apos; :content rule as being greedy."><y>#</y><d>2016-08-28</d><h>21:29</h><w>aengelberg</w>As an experiment I removed all the hide-tags from the headlines parser, since I got that behavior you were talking about (flat content). That exposed the headlines&apos; <code>:content</code> rule as being greedy.</z><z id="t1472419806" t="aengelberg organum.core&gt; (headlines content) [:S [:token [:content &quot;This is an attempt... "><y>#</y><d>2016-08-28</d><h>21:30</h><w>aengelberg</w><pre>organum.core&gt; (headlines content)
[:S [:token [:content &quot;This is an attempt...
</pre></z><z id="t1472419820" t="seylerius Yep. I&apos;ve got an ordered choice making it prefer to define a section (headline then content) if possible, and just content if not. The defining difference between content and headline is whether it starts with stars."><y>#</y><d>2016-08-28</d><h>21:30</h><w>seylerius</w>Yep. I&apos;ve got an ordered choice making it prefer to define a section (headline then content) if possible, and just content if not. The defining difference between content and headline is whether it starts with stars.</z><z id="t1472419871" t="seylerius Although, Hmmm. You&apos;ve got a point about the mode there."><y>#</y><d>2016-08-28</d><h>21:31</h><w>seylerius</w>Although, Hmmm. You&apos;ve got a point about the mode there.</z><z id="t1472419918" t="aengelberg I think this is what happened: - The section rule failed at the start of the string - It then fell back to the content rule due to ordered choice - The content rule mistakenly parses the whole string (for the reason I mentioned above) - Parse is done"><y>#</y><d>2016-08-28</d><h>21:31</h><w>aengelberg</w>I think this is what happened:
- The <code>section</code> rule failed at the start of the string
- It then fell back to the <code>content</code> rule due to ordered choice
- The <code>content</code> rule mistakenly parses the whole string (for the reason I mentioned above)
- Parse is done</z><z id="t1472420062" t="seylerius Yeah. You&apos;re right. Making the content rule less accepting (not (?s) ) fixes that part, and now I&apos;m seeing failures to parse the first headline. Joy."><y>#</y><d>2016-08-28</d><h>21:34</h><w>seylerius</w>Yeah. You&apos;re right. Making the content rule less accepting (not <code>(?s)</code>) fixes that part, and now I&apos;m seeing failures to parse the first headline. Joy.</z><z id="t1472420187" t="seylerius How does inataparse play with non-capturing groups?"><y>#</y><d>2016-08-28</d><h>21:36</h><w>seylerius</w>How does inataparse play with non-capturing groups?</z><z id="t1472420289" t="aengelberg Not familiar with that term; are you referring to the groups returned by a Java regex match?"><y>#</y><d>2016-08-28</d><h>21:38</h><w>aengelberg</w>Not familiar with that term; are you referring to the groups returned by a Java regex match?</z><z id="t1472420404" t="seylerius Non-capturing groups are for saying, &quot;this should be here, but don&apos;t return it in a group&quot;"><y>#</y><d>2016-08-28</d><h>21:40</h><w>seylerius</w>Non-capturing groups are for saying, &quot;this should be here, but don&apos;t return it in a group&quot;</z><z id="t1472420439" t="seylerius Okay, new push. Can&apos;t manage to get tags out separate."><y>#</y><d>2016-08-28</d><h>21:40</h><w>seylerius</w>Okay, new push. Can&apos;t manage to get tags out separate.</z><z id="t1472420480" t="aengelberg oh, you mean things like regex lookahead and lookbehind?"><y>#</y><d>2016-08-28</d><h>21:41</h><w>aengelberg</w>oh, you mean things like regex lookahead and lookbehind?</z><z id="t1472420561" t="seylerius They work if I make them mandatory, but get eaten by the headline body if they&apos;re optional. Would lookahead allow saying &quot;if there&apos;s whitespace followed by a colon, stop here&quot;?"><y>#</y><d>2016-08-28</d><h>21:42</h><w>seylerius</w>They work if I make them mandatory, but get eaten by the headline body if they&apos;re optional. Would lookahead allow saying &quot;if there&apos;s whitespace followed by a colon, stop here&quot;?</z><z id="t1472420737" t="aengelberg This is the instaparse source code that applies regexes, may shed some light on whether certain constructs would work. https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670"><y>#</y><d>2016-08-28</d><h>21:45</h><w>aengelberg</w>This is the instaparse source code that applies regexes, may shed some light on whether certain constructs would work. <a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670" target="_blank">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670</a></z><z id="t1472420841" t="aengelberg I would expect regex non matching lookaheads to work, but non-matching lookbehinds to NOT work. Instaparse runs a regex match on the substring of the current index onward, so previous characters are invisible. EDIT: I misunderstood the term &quot;non-matching&quot;"><y>#</y><d>2016-08-28</d><h>21:47</h><w>aengelberg</w>I would expect regex non matching lookaheads to work, but non-matching lookbehinds to NOT work. Instaparse runs a regex match on the substring of the current index onward, so previous characters are invisible. EDIT: I misunderstood the term &quot;non-matching&quot;</z><z id="t1472420951" t="aengelberg I see you&apos;re using (?:) now. I don&apos;t think &quot;non capturing&quot; is what you want"><y>#</y><d>2016-08-28</d><h>21:49</h><w>aengelberg</w>I see you&apos;re using <code>(?:)</code> now. I don&apos;t think &quot;non capturing&quot; is what you want</z><z id="t1472420962" t="seylerius I think you&apos;re right."><y>#</y><d>2016-08-28</d><h>21:49</h><w>seylerius</w>I think you&apos;re right.</z><z id="t1472420987" t="aengelberg organum.core&gt; (re-find #&quot;a&quot; &quot;a&quot;) &quot;a&quot; organum.core&gt; (re-find #&quot;(?:a)&quot; &quot;a&quot;) &quot;a&quot; "><y>#</y><d>2016-08-28</d><h>21:49</h><w>aengelberg</w><pre>organum.core&gt; (re-find #&quot;a&quot; &quot;a&quot;)
&quot;a&quot;
organum.core&gt; (re-find #&quot;(?:a)&quot; &quot;a&quot;)
&quot;a&quot;
</pre></z><z id="t1472420996" t="seylerius What&apos;s weird is non-greedy options fail entirely."><y>#</y><d>2016-08-28</d><h>21:49</h><w>seylerius</w>What&apos;s weird is non-greedy options fail entirely.</z><z id="t1472421018" t="aengelberg (?:) basically means, if there are any other groups () inside that block, DON&apos;T return them as an additional output."><y>#</y><d>2016-08-28</d><h>21:50</h><w>aengelberg</w><code>(?:)</code> basically means, if there are any other groups <code>()</code> inside that block, DON&apos;T return them as an additional output.</z><z id="t1472421064" t="seylerius Ah, it looks like negative lookahead is the trick."><y>#</y><d>2016-08-28</d><h>21:51</h><w>seylerius</w>Ah, it looks like negative lookahead is the trick.</z><z id="t1472421080" t="aengelberg (?!=) ?"><y>#</y><d>2016-08-28</d><h>21:51</h><w>aengelberg</w><code>(?!=)</code>?</z><z id="t1472421103" t="aengelberg the ?: flag shouldn&apos;t affect Instaparse&apos;s usage of regexes at all. Instaparse throws away match groups"><y>#</y><d>2016-08-28</d><h>21:51</h><w>aengelberg</w>the <code>?:</code> flag shouldn&apos;t affect Instaparse&apos;s usage of regexes at all. Instaparse throws away match groups</z><z id="t1472421115" t="seylerius (?!\\s+:)"><y>#</y><d>2016-08-28</d><h>21:51</h><w>seylerius</w><code>(?!\\s+:)</code></z><z id="t1472421141" t="aengelberg seems legit"><y>#</y><d>2016-08-28</d><h>21:52</h><w>aengelberg</w>seems legit</z><z id="t1472421165" t="seylerius Nope. Pushing. Still eats the tags."><y>#</y><d>2016-08-28</d><h>21:52</h><w>seylerius</w>Nope. Pushing. Still eats the tags.</z><z id="t1472421180" t="aengelberg hmm"><y>#</y><d>2016-08-28</d><h>21:53</h><w>aengelberg</w>hmm</z><z id="t1472421196" t="seylerius Pushed"><y>#</y><d>2016-08-28</d><h>21:53</h><w>seylerius</w>Pushed</z><z id="t1472421231" t="aengelberg need to run now, can probably help more in an hour or so. I&apos;d say the next step is manually parsing the regexes on the strings."><y>#</y><d>2016-08-28</d><h>21:53</h><w>aengelberg</w>need to run now, can probably help more in an hour or so. I&apos;d say the next step is manually parsing the regexes on the strings.</z><z id="t1472421258" t="aengelberg and try gradually taking characters away from the regex to see what the problem is"><y>#</y><d>2016-08-28</d><h>21:54</h><w>aengelberg</w>and try gradually taking characters away from the regex to see what the problem is</z><z id="t1472421263" t="seylerius Okay, thanks for the help. Talk with ya when you&apos;ve got time."><y>#</y><d>2016-08-28</d><h>21:54</h><w>seylerius</w>Okay, thanks for the help. Talk with ya when you&apos;ve got time.</z><z id="t1472421276" t="aengelberg feel free to dump any further findings here"><y>#</y><d>2016-08-28</d><h>21:54</h><w>aengelberg</w>feel free to dump any further findings here</z><z id="t1472421297" t="seylerius Will do. Slack has persistence, which is pretty handy"><y>#</y><d>2016-08-28</d><h>21:54</h><w>seylerius</w>Will do. Slack has persistence, which is pretty handy</z><z id="t1472427283" t="seylerius Okay, trying reluctance means I only get the first character of the headline, and the rest becomes part of the content."><y>#</y><d>2016-08-28</d><h>23:34</h><w>seylerius</w>Okay, trying reluctance means I only get the first character of the headline, and the rest becomes part of the content.</z><z id="t1472427299" t="seylerius Trying lookahead seems to just fail."><y>#</y><d>2016-08-28</d><h>23:34</h><w>seylerius</w>Trying lookahead seems to just fail.</z><z id="t1472427726" t="seylerius Okay, tags are mostly fixed, but it&apos;s only grabbing the first one."><y>#</y><d>2016-08-28</d><h>23:42</h><w>seylerius</w>Okay, tags are mostly fixed, but it&apos;s only grabbing the first one.</z><z id="t1472427731" t="seylerius Pushed."><y>#</y><d>2016-08-28</d><h>23:42</h><w>seylerius</w>Pushed.</z><z id="t1472427749" t="seylerius Would appreciate a look when you have time, @aengelberg"><y>#</y><d>2016-08-28</d><h>23:42</h><w>seylerius</w>Would appreciate a look when you have time, @aengelberg</z><z id="t1472427810" t="seylerius Ach. It&apos;s also not getting second headlines. They&apos;re turning into content lines due to newline weirdness."><y>#</y><d>2016-08-28</d><h>23:43</h><w>seylerius</w>Ach. It&apos;s also not getting second headlines. They&apos;re turning into content lines due to newline weirdness.</z><z id="t1472428009" t="seylerius Pushed again. Fixed newline weirdness"><y>#</y><d>2016-08-28</d><h>23:46</h><w>seylerius</w>Pushed again. Fixed newline weirdness</z><z id="t1472428217" t="seylerius Hah, fixed it. Required post-tag newline/whitespace."><y>#</y><d>2016-08-28</d><h>23:50</h><w>seylerius</w>Hah, fixed it. Required post-tag newline/whitespace.</z><z id="t1472428239" t="seylerius Gah. Org is a beautiful format, but it&apos;s a bitch to parse."><y>#</y><d>2016-08-28</d><h>23:50</h><w>seylerius</w>Gah. Org is a beautiful format, but it&apos;s a bitch to parse.</z><z id="t1472428597" t="aengelberg The parser breaks if I put into the file * The First : Section :foo:bar: "><y>#</y><d>2016-08-28</d><h>23:56</h><w>aengelberg</w>The parser breaks if I put into the file
<pre>* The First : Section :foo:bar:
</pre></z><z id="t1472428603" t="aengelberg Not sure if that&apos;s valid org-mode."><y>#</y><d>2016-08-28</d><h>23:56</h><w>aengelberg</w>Not sure if that&apos;s valid org-mode.</z><z id="t1472429149" t="aengelberg @seylerius This approach handles a variety of potential characters before the tags, at the expense of speed, since it parses every single character on the header line to get around regex greediness. (def headlines (insta/parser &quot;&lt;S&gt; = token (ows token)* &lt;token&gt; = section / content section = h (ows content)* h = ows stars &lt;#&apos;\\s+&apos;&gt; (todo &lt;#&apos;\\s+&apos;&gt;)? title &lt;title&gt; = (#&apos;.&apos;+ ws-line? tags) / #&apos;.+&apos; stars = #&apos;^\\*+&apos; todo = #&apos;TODO|DONE&apos; tags = &lt;&apos;:&apos;&gt; (tag &lt;&apos;:&apos;&gt;)+ ws &lt;tag&gt; = #&apos;["><y>#</y><d>2016-08-29</d><h>00:05</h><w>aengelberg</w>@seylerius This approach handles a variety of potential characters before the tags, at the expense of speed, since it parses every single character on the header line to get around regex greediness.
<pre>(def headlines
  (insta/parser
   &quot;&lt;S&gt; = token (ows token)*
    &lt;token&gt; = section / content
    section = h (ows content)*
    h = ows stars &lt;#&apos;\\s+&apos;&gt; (todo &lt;#&apos;\\s+&apos;&gt;)? title
    &lt;title&gt; = (#&apos;.&apos;+ ws-line? tags) / #&apos;.+&apos;
    stars = #&apos;^\\*+&apos;
    todo = #&apos;TODO|DONE&apos;
    tags = &lt;&apos;:&apos;&gt; (tag &lt;&apos;:&apos;&gt;)+ ws
    &lt;tag&gt; = #&apos;[</pre></z><z id="t1472429327" t="seylerius Probably be an uncommon usage, but technically legal, @aengelberg. Probably ought to do something like this. Hmmm."><y>#</y><d>2016-08-29</d><h>00:08</h><w>seylerius</w>Probably be an uncommon usage, but technically legal, @aengelberg. Probably ought to do something like this. Hmmm.</z><z id="t1472429660" t="seylerius Yeah, that works. Definitely going to need the follow-up concatenation I was planning on."><y>#</y><d>2016-08-29</d><h>00:14</h><w>seylerius</w>Yeah, that works. Definitely going to need the follow-up concatenation I was planning on.</z><z id="t1472433574" t="seylerius Okay, another puzzle for ya, @aengelberg. In this latest push, why isn&apos;t priority getting picked up? I&apos;ve cleaned up some of the names and added an overall parse function that takes a string, to simplify testing."><y>#</y><d>2016-08-29</d><h>01:19</h><w>seylerius</w>Okay, another puzzle for ya, @aengelberg. In this latest push, why isn&apos;t priority getting picked up? I&apos;ve cleaned up some of the names and added an overall <code>parse</code> function that takes a string, to simplify testing.</z><z id="t1472433621" t="seylerius (parse (slurp &quot;&quot;)) should work for testing."><y>#</y><d>2016-08-29</d><h>01:20</h><w>seylerius</w><code>(parse (slurp &quot;&quot;)) </code> should work for testing.</z><z id="t1472433635" t="seylerius (Thanks a ton for the help, BTW)"><y>#</y><d>2016-08-29</d><h>01:20</h><w>seylerius</w>(Thanks a ton for the help, BTW)</z><z id="t1472433952" t="seylerius A priority is defined as a letter preceded by a pound sign, in square brackets. [#A] or [#z] , for example."><y>#</y><d>2016-08-29</d><h>01:25</h><w>seylerius</w>A priority is defined as a letter preceded by a pound sign, in square brackets. <code>[#A]</code> or <code>[#z]</code>, for example.</z><z id="t1472434792" t="seylerius Lol, whoops. Reversed my pound sign and bracket"><y>#</y><d>2016-08-29</d><h>01:39</h><w>seylerius</w>Lol, whoops. Reversed my pound sign and bracket</z><z id="t1472442733" t="seylerius @aengelberg: Can you help me figure out why the parsed sample is not registering as compliant hiccup to insta/transform ?"><y>#</y><d>2016-08-29</d><h>03:52</h><w>seylerius</w>@aengelberg: Can you help me figure out why the parsed sample is not registering as compliant hiccup to <code>insta/transform</code>?</z><z id="t1472444949" t="seylerius Okay, I see that it&apos;s looking for a root node. Tried to unhide the document node, but it&apos;s not showing up."><y>#</y><d>2016-08-29</d><h>04:29</h><w>seylerius</w>Okay, I see that it&apos;s looking for a root node. Tried to unhide the <code>document</code> node, but it&apos;s not showing up.</z><z id="t1472444991" t="aengelberg @seylerius lemme take a look"><y>#</y><d>2016-08-29</d><h>04:29</h><w>aengelberg</w>@seylerius lemme take a look</z><z id="t1472445011" t="seylerius Thanks."><y>#</y><d>2016-08-29</d><h>04:30</h><w>seylerius</w>Thanks.</z><z id="t1472445165" t="aengelberg @seylerius what&apos;s the repro case?"><y>#</y><d>2016-08-29</d><h>04:32</h><w>aengelberg</w>@seylerius what&apos;s the repro case?</z><z id="t1472445221" t="seylerius (parse (slurp &quot;&quot;)) returns a seq, not a vector with a root node."><y>#</y><d>2016-08-29</d><h>04:33</h><w>seylerius</w><code>(parse (slurp &quot;&quot;)) </code> returns a seq, not a vector with a root node.</z><z id="t1472445253" t="aengelberg looks like function reducing doesn&apos;t exist"><y>#</y><d>2016-08-29</d><h>04:34</h><w>aengelberg</w>looks like function <code>reducing</code> doesn&apos;t exist</z><z id="t1472445285" t="aengelberg CompilerException java.lang.RuntimeException: Unable to resolve symbol: reducing in this context"><y>#</y><d>2016-08-29</d><h>04:34</h><w>aengelberg</w><code>CompilerException java.lang.RuntimeException: Unable to resolve symbol: reducing in this context</code></z><z id="t1472445412" t="seylerius Cleared that up."><y>#</y><d>2016-08-29</d><h>04:36</h><w>seylerius</w>Cleared that up.</z><z id="t1472445417" t="seylerius Thanks"><y>#</y><d>2016-08-29</d><h>04:36</h><w>seylerius</w>Thanks</z><z id="t1472445477" t="seylerius Still isn&apos;t giving me a root node, though."><y>#</y><d>2016-08-29</d><h>04:37</h><w>seylerius</w>Still isn&apos;t giving me a root node, though.</z><z id="t1472445542" t="seylerius ([:author... , rather than [:document [:author..."><y>#</y><d>2016-08-29</d><h>04:39</h><w>seylerius</w><code>([:author...</code>, rather than <code>[:document [:author...</code></z><z id="t1472445664" t="aengelberg interesting. transforming on a sequence should work. I think you may have found a bug in instaparse."><y>#</y><d>2016-08-29</d><h>04:41</h><w>aengelberg</w>interesting. transforming on a sequence should work. I think you may have found a bug in instaparse.</z><z id="t1472445692" t="aengelberg The fact that there&apos;s a string in the uppermost level is what&apos;s throwing it off."><y>#</y><d>2016-08-29</d><h>04:41</h><w>aengelberg</w>The fact that there&apos;s a string in the uppermost level is what&apos;s throwing it off.</z><z id="t1472445803" t="seylerius Fascinating"><y>#</y><d>2016-08-29</d><h>04:43</h><w>seylerius</w>Fascinating</z><z id="t1472445981" t="seylerius @aengelberg: Maybe make strings pass straight through transform ?"><y>#</y><d>2016-08-29</d><h>04:46</h><w>seylerius</w>@aengelberg: Maybe make strings pass straight through <code>transform</code>?</z><z id="t1472445982" t="aengelberg I can confirm that&apos;s a bug"><y>#</y><d>2016-08-29</d><h>04:46</h><w>aengelberg</w>I can confirm that&apos;s a bug</z><z id="t1472445988" t="aengelberg Yeah, that&apos;s what I&apos;m about to do."><y>#</y><d>2016-08-29</d><h>04:46</h><w>aengelberg</w>Yeah, that&apos;s what I&apos;m about to do.</z><z id="t1472445992" t="seylerius Awesome"><y>#</y><d>2016-08-29</d><h>04:46</h><w>seylerius</w>Awesome</z><z id="t1472447495" t="aengelberg @seylerius https://github.com/Engelberg/instaparse/pull/145"><y>#</y><d>2016-08-29</d><h>05:11</h><w>aengelberg</w>@seylerius <a href="https://github.com/Engelberg/instaparse/pull/145" target="_blank">https://github.com/Engelberg/instaparse/pull/145</a></z><z id="t1472447995" t="aengelberg oops, didn&apos;t link properly... edited"><y>#</y><d>2016-08-29</d><h>05:19</h><w>aengelberg</w>oops, didn&apos;t link properly... edited</z><z id="t1472448540" t="seylerius Downloaded, testing."><y>#</y><d>2016-08-29</d><h>05:29</h><w>seylerius</w>Downloaded, testing.</z><z id="t1472448548" t="seylerius It works! Thanks, @aengelberg!"><y>#</y><d>2016-08-29</d><h>05:29</h><w>seylerius</w>It works! Thanks, @aengelberg!</z><z id="t1472495406" t="seylerius @aengelberg: Yep, that worked perfectly. What&apos;s the release schedule on that, out of curiosity?"><y>#</y><d>2016-08-29</d><h>18:30</h><w>seylerius</w>@aengelberg: Yep, that worked perfectly. What&apos;s the release schedule on that, out of curiosity?</z><z id="t1472495587" t="seylerius In the meantime, I&apos;m moving on to adding additional parsers (drawers, blocks, footnotes, lists, tables, to name a few)."><y>#</y><d>2016-08-29</d><h>18:33</h><w>seylerius</w>In the meantime, I&apos;m moving on to adding additional parsers (drawers, blocks, footnotes, lists, tables, to name a few).</z><z id="t1472496971" t="aengelberg @seylerius For instaparse we prefer to merge fixes, bump version numbers / changelogs, and deploy to clojars all at once. And only my dad has the power to do the last part. So whenever he gets around to doing that is when I&apos;d expect to see the latest version. Should be sometime today."><y>#</y><d>2016-08-29</d><h>18:56</h><w>aengelberg</w>@seylerius For instaparse we prefer to merge fixes, bump version numbers / changelogs, and deploy to clojars all at once. And only my dad has the power to do the last part. So whenever he gets around to doing that is when I&apos;d expect to see the latest version. Should be sometime today.</z><z id="t1472497731" t="seylerius Shiny. Looking forward to it. Also, shiny that y&apos;all are a father-son team. Be cool if one of my kids coded with me (after I have some)."><y>#</y><d>2016-08-29</d><h>19:08</h><w>seylerius</w>Shiny. Looking forward to it. Also, shiny that y&apos;all are a father-son team. Be cool if one of my kids coded with me (after I have some).</z><z id="t1472499094" t="aengelberg Thanks. It&apos;s fun! You may enjoy the Clojure/west 2014 instaparse talk, which provides some backstory on the collaboration"><y>#</y><d>2016-08-29</d><h>19:31</h><w>aengelberg</w>Thanks. It&apos;s fun! You may enjoy the Clojure/west 2014 instaparse talk, which provides some backstory on the collaboration</z><z id="t1472499737" t="seylerius Awesome. I&apos;ll check it out"><y>#</y><d>2016-08-29</d><h>19:42</h><w>seylerius</w>Awesome. I&apos;ll check it out</z><z id="t1472588759" t="andrei I am trying to write a simple grammar that parses comments: /* some text */ , is there a way in instaparse to say any character? e.g. &quot;comment = ‘/*’ .* ‘*/‘&quot; "><y>#</y><d>2016-08-30</d><h>20:25</h><w>andrei</w>I am trying to write a simple grammar that parses comments:
<code>/* some text */</code>, is there a way in instaparse to say any character?
e.g.
<pre>&quot;comment = ‘/*’ .* ‘*/‘&quot;
</pre></z><z id="t1472588844" t="aengelberg @andrei Instaparse doesn&apos;t have a special character for that, but you can use regular expressions to cover any character"><y>#</y><d>2016-08-30</d><h>20:27</h><w>aengelberg</w>@andrei Instaparse doesn&apos;t have a special character for that, but you can use regular expressions to cover any character</z><z id="t1472588884" t="aengelberg e.g. comment = &apos;/*&apos; #&apos;[\\s\\S]&apos;* &apos;*/&apos;"><y>#</y><d>2016-08-30</d><h>20:28</h><w>aengelberg</w>e.g. <code>comment = &apos;/*&apos; #&apos;[\\s\\S]&apos;* &apos;*/&apos;</code></z><z id="t1472588947" t="aengelberg (`#&quot;[\s\S]&quot;` is my personal favorite way to match any character in a regex)"><y>#</y><d>2016-08-30</d><h>20:29</h><w>aengelberg</w>(`#&quot;[\s\S]&quot;` is my personal favorite way to match any character in a regex)</z><z id="t1472589004" t="seylerius @andrei: Yeah, you&apos;ll want something like this: &quot;comment = &lt;&apos;/*&apos;&gt; #&apos;.*&apos; &lt;&apos;*/&apos;&gt;&quot; My version hides the comment tokens, though @aengelberg&apos;s regexp might be more appropriate."><y>#</y><d>2016-08-30</d><h>20:30</h><w>seylerius</w>@andrei: Yeah, you&apos;ll want something like this:
<pre>&quot;comment = &lt;&apos;/*&apos;&gt; #&apos;.*&apos; &lt;&apos;*/&apos;&gt;&quot;
</pre>
My version hides the comment tokens, though @aengelberg&apos;s regexp might be more appropriate.</z><z id="t1472589043" t="andrei @aengelberg @seylerius thank you for the suggestions. I think I got a bit mislead by the source code, https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40 I thought there are some defaults in instaparse"><y>#</y><d>2016-08-30</d><h>20:30</h><w>andrei</w>@aengelberg @seylerius thank you for the suggestions. 
I think I got a bit mislead by the source code, 
<a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40" target="_blank">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40</a>
I thought there are some defaults in instaparse</z><z id="t1472589083" t="andrei but now reading through the doc strings, these are only to parse the grammar itself https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2"><y>#</y><d>2016-08-30</d><h>20:31</h><w>andrei</w>but now reading through the doc strings, these are only to parse the grammar itself 
<a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2" target="_blank">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2</a></z><z id="t1472589096" t="aengelberg a couple things I see in @seylerius&apos;s solution: 1) . in a regex doesn&apos;t include newlines 2) .* will greedily match past the */ and won&apos;t be able to parse the end of a comment"><y>#</y><d>2016-08-30</d><h>20:31</h><w>aengelberg</w>a couple things I see in @seylerius&apos;s solution:
1) <code>.</code> in a regex doesn&apos;t include newlines
2) <code>.*</code> will greedily match past the <code>*/</code> and won&apos;t be able to parse the end of a comment</z><z id="t1472589127" t="aengelberg @andrei Sorry for the misleading code. Those constants are available but only to the ABNF format."><y>#</y><d>2016-08-30</d><h>20:32</h><w>aengelberg</w>@andrei Sorry for the misleading code. Those constants are available but only to the ABNF format.</z><z id="t1472589157" t="aengelberg EBNF is the default"><y>#</y><d>2016-08-30</d><h>20:32</h><w>aengelberg</w>EBNF is the default</z><z id="t1472589189" t="andrei are there constants for ebnf? looking at the code I think not"><y>#</y><d>2016-08-30</d><h>20:33</h><w>andrei</w>are there constants for ebnf? looking at the code I think not</z><z id="t1472589194" t="seylerius @andrei A point to keep in mind with @aengelberg&apos;s solution is that you&apos;ll need to condense the individual characters of the output."><y>#</y><d>2016-08-30</d><h>20:33</h><w>seylerius</w>@andrei A point to keep in mind with @aengelberg&apos;s solution is that you&apos;ll need to condense the individual characters of the output.</z><z id="t1472589267" t="andrei @seylerius @aengelberg is there a way for specifying in instaparse to group matches together, s.t. one doesn’t need to condense the matches?"><y>#</y><d>2016-08-30</d><h>20:34</h><w>andrei</w>@seylerius @aengelberg is there a way for specifying in instaparse to group matches together, s.t. one doesn’t need to condense the  matches?</z><z id="t1472589267" t="aengelberg yeah, thanks for clarifying that @seylerius"><y>#</y><d>2016-08-30</d><h>20:34</h><w>aengelberg</w>yeah, thanks for clarifying that @seylerius</z><z id="t1472589296" t="seylerius You&apos;ll get output like [:comment &quot;f&quot; &quot;o&quot; &quot;o&quot; &quot; &quot; &quot;b&quot; &quot;a&quot; &quot;r&quot;] from input like /*foo bar*/"><y>#</y><d>2016-08-30</d><h>20:34</h><w>seylerius</w>You&apos;ll get output like <code>[:comment &quot;f&quot; &quot;o&quot; &quot;o&quot; &quot; &quot; &quot;b&quot; &quot;a&quot; &quot;r&quot;] </code> from input like <code>/*foo bar*/</code></z><z id="t1472589304" t="andrei exactly"><y>#</y><d>2016-08-30</d><h>20:35</h><w>andrei</w>exactly</z><z id="t1472589323" t="andrei there are ways to use transform and apply str on it"><y>#</y><d>2016-08-30</d><h>20:35</h><w>andrei</w>there are ways to use transform and apply str on it</z><z id="t1472589329" t="seylerius Yep."><y>#</y><d>2016-08-30</d><h>20:35</h><w>seylerius</w>Yep.</z><z id="t1472589340" t="aengelberg @andrei The official specification for ABNF is more strict and specific than EBNF, and it dictates that those constants are available. EBNF is more of an ambiguous mashup of a variety of standards we were able to find on the internet"><y>#</y><d>2016-08-30</d><h>20:35</h><w>aengelberg</w>@andrei The official specification for ABNF is more strict and specific than EBNF, and it dictates that those constants are available. EBNF is more of an ambiguous mashup of a variety of standards we were able to find on the internet</z><z id="t1472589344" t="andrei it just feels that there should be a grammar direct way"><y>#</y><d>2016-08-30</d><h>20:35</h><w>andrei</w>it just feels that there should be a grammar direct way</z><z id="t1472589366" t="aengelberg So there are no constants in EBNF, since none of the EBNF resources we found seemed to indicate such"><y>#</y><d>2016-08-30</d><h>20:36</h><w>aengelberg</w>So there are no constants in EBNF, since none of the EBNF resources we found seemed to indicate such</z><z id="t1472589375" t="seylerius And remember to wrap your comment tokens in &lt;&gt; like I did, so you don&apos;t save the markup itself."><y>#</y><d>2016-08-30</d><h>20:36</h><w>seylerius</w>And remember to wrap your comment tokens in <code>&lt;&gt;</code> like I did, so you don&apos;t save the markup itself.</z><z id="t1472589391" t="aengelberg Sadly there is no grammar direct way to concat the strings"><y>#</y><d>2016-08-30</d><h>20:36</h><w>aengelberg</w>Sadly there is no grammar direct way to concat the strings</z><z id="t1472589409" t="seylerius Transform works pretty well, though."><y>#</y><d>2016-08-30</d><h>20:36</h><w>seylerius</w>Transform works pretty well, though.</z><z id="t1472589429" t="andrei hmm, or a more elaborated reg exp"><y>#</y><d>2016-08-30</d><h>20:37</h><w>andrei</w>hmm, or a more elaborated reg exp</z><z id="t1472589475" t="andrei I am using smth like this for strings &lt;string&gt; = dqoute #&apos;([^&quot;\\]|\\.)*&apos; dqoute &lt;dqoute&gt; = &lt;&apos;\&quot;&apos;&gt; "><y>#</y><d>2016-08-30</d><h>20:37</h><w>andrei</w>I am using smth like this for strings
<pre>&lt;string&gt; = dqoute #&apos;([^&quot;\\]|\\.)*&apos; dqoute
   &lt;dqoute&gt; = &lt;&apos;\&quot;&apos;&gt;
</pre></z><z id="t1472589493" t="seylerius (insta/transform {:comment (partial apply str)} (comment-parser input-data)) "><y>#</y><d>2016-08-30</d><h>20:38</h><w>seylerius</w><code>(insta/transform {:comment (partial apply str)} (comment-parser input-data)) </code></z><z id="t1472589545" t="andrei and probably the performance impact is small if one applies transforms"><y>#</y><d>2016-08-30</d><h>20:39</h><w>andrei</w>and probably the performance impact is small if one applies transforms</z><z id="t1472589587" t="seylerius Lolyep. Far as I can tell, inataparse does a good job with efficient transforms."><y>#</y><d>2016-08-30</d><h>20:39</h><w>seylerius</w>Lolyep. Far as I can tell, inataparse does a good job with efficient transforms.</z><z id="t1472589600" t="aengelberg it depends on the size of the file. Probably actually creating all those individual strings is going to be the bottleneck rather than concatenating them later"><y>#</y><d>2016-08-30</d><h>20:40</h><w>aengelberg</w>it depends on the size of the file. Probably actually creating all those individual strings is going to be the bottleneck rather than concatenating them later</z><z id="t1472589606" t="andrei I must admit I was lead astray by regexps vs transforms which is more efficient - although I think its a very premature optimisation"><y>#</y><d>2016-08-30</d><h>20:40</h><w>andrei</w>I must admit I was lead astray by regexps vs transforms which is more efficient - although I think its a very premature optimisation</z><z id="t1472589627" t="aengelberg A regex is a sensible solution if you can get it right 🙂"><y>#</y><d>2016-08-30</d><h>20:40</h><w>aengelberg</w>A regex is a sensible solution if you can get it right <b>🙂</b></z><z id="t1472589660" t="aengelberg My first thought is to do a negative lookahead for */ as part of the regex"><y>#</y><d>2016-08-30</d><h>20:41</h><w>aengelberg</w>My first thought is to do a negative lookahead for <code>*/</code> as part of the regex</z><z id="t1472589778" t="seylerius Trouble is, from what I&apos;ve found, that the */ will get eaten in the .*"><y>#</y><d>2016-08-30</d><h>20:42</h><w>seylerius</w>Trouble is, from what I&apos;ve found, that the <code>*/</code> will get eaten in the <code>.*</code></z><z id="t1472589799" t="seylerius And the negative lookahead will pass because the end token was already eaten"><y>#</y><d>2016-08-30</d><h>20:43</h><w>seylerius</w>And the negative lookahead will pass because the end token was already eaten</z></g><g id="s2"><z id="t1472589856" t="andrei so more reg exp magic for me to look into. to give a bit more context I am playing around with parsing localizable strings. /* This is a comment */ &quot;hello&quot; = &quot;Hello!&quot;; /* This is another comment */ &quot;click_button&quot; = &quot;Click&quot;; /* Title bar, prints the number of selected products (The translation should be short due to the limit of 100 characters for the title of the mobile app) */ &quot;bar_print_$_selected_products&quot; = &quot;You Selected %@ Products”; "><y>#</y><d>2016-08-30</d><h>20:44</h><w>andrei</w>so more reg exp magic for me to look into.
to give a bit more context I am playing around with parsing localizable strings.
<pre>/* This is a comment */

&quot;hello&quot; = &quot;Hello!&quot;;

/* This is another comment */
&quot;click_button&quot; = &quot;Click&quot;;

/* Title bar, prints the number of selected products (The translation should be short due to the limit of 100 characters for the title of the mobile app) */
&quot;bar_print_$_selected_products&quot; = &quot;You Selected %@ Products”;
</pre></z><z id="t1472589872" t="andrei just an experiment, nothing production related."><y>#</y><d>2016-08-30</d><h>20:44</h><w>andrei</w>just an experiment, nothing production related.</z><z id="t1472590040" t="andrei @aengelberg @seylerius thank you for your help, so far I enjoyed using instaparse. is cool that I can use some things that I learned in college to do some useful things"><y>#</y><d>2016-08-30</d><h>20:47</h><w>andrei</w>@aengelberg @seylerius thank you for your help, so far I enjoyed using instaparse.
is cool that I can use some things that I learned in college to do some useful things</z><z id="t1472590074" t="andrei although I must say that I need to re-learn things about parsers and defining grammars"><y>#</y><d>2016-08-30</d><h>20:47</h><w>andrei</w>although I must say that I need to re-learn things about parsers and defining  grammars</z><z id="t1472590091" t="aengelberg @seylerius I meant a regex negative lookahead, i.e. #&quot;.*(?!=/\*)&quot; or something"><y>#</y><d>2016-08-30</d><h>20:48</h><w>aengelberg</w>@seylerius I meant a regex negative lookahead, i.e. <code>#&quot;.*(?!=/\*)&quot;</code> or something</z><z id="t1472590180" t="aengelberg @andrei glad you&apos;re having fun! feel free to ask here if you have any more questions"><y>#</y><d>2016-08-30</d><h>20:49</h><w>aengelberg</w>@andrei glad you&apos;re having fun! feel free to ask here if you have any more questions</z><z id="t1472590199" t="seylerius @aengelberg: That&apos;s what I thought. It winds up eating the end-token in the .* and passes the negative lookahead anyway. I was fighting that with the headline parser in organum over the weekend."><y>#</y><d>2016-08-30</d><h>20:49</h><w>seylerius</w>@aengelberg: That&apos;s what I thought. It winds up eating the end-token in the <code>.*</code> and passes the negative lookahead anyway. I was fighting that with the headline parser in organum over the weekend.</z><z id="t1472590217" t="seylerius When I was trying to get it to parse tags."><y>#</y><d>2016-08-30</d><h>20:50</h><w>seylerius</w>When I was trying to get it to parse tags.</z><z id="t1472590259" t="aengelberg oh, I guess the regex would pass, saying &quot;here&apos;s a sequence of characters (including /* ), and look, there is not a /* *after* these characters!&quot;"><y>#</y><d>2016-08-30</d><h>20:50</h><w>aengelberg</w>oh, I guess the regex would pass, saying &quot;here&apos;s a sequence of characters (including <code>/*</code>), and look, there is not a <code>/*</code> *after* these characters!&quot;</z><z id="t1472590266" t="seylerius Bingo"><y>#</y><d>2016-08-30</d><h>20:51</h><w>seylerius</w>Bingo</z><z id="t1472590293" t="aengelberg so maybe #&quot;((?!/\*).)*&quot;"><y>#</y><d>2016-08-30</d><h>20:51</h><w>aengelberg</w>so maybe <code>#&quot;((?!/\*).)*&quot;</code></z><z id="t1472590304" t="aengelberg that would generate a bunch of match groups though due to the ()"><y>#</y><d>2016-08-30</d><h>20:51</h><w>aengelberg</w>that would generate a bunch of match groups though due to the <code>()</code></z><z id="t1472590334" t="seylerius Gah, lemme see what I did for that in the tags in organum."><y>#</y><d>2016-08-30</d><h>20:52</h><w>seylerius</w>Gah, lemme see what I did for that in the tags in organum.</z><z id="t1472590434" t="seylerius https://github.com/seylerius/organum/blob/master/src/organum/core.clj"><y>#</y><d>2016-08-30</d><h>20:53</h><w>seylerius</w><a href="https://github.com/seylerius/organum/blob/master/src/organum/core.clj" target="_blank">https://github.com/seylerius/organum/blob/master/src/organum/core.clj</a></z><z id="t1472590458" t="seylerius Yeah, ordered choice wound up featuring heavily."><y>#</y><d>2016-08-30</d><h>20:54</h><w>seylerius</w>Yeah, ordered choice wound up featuring heavily.</z><z id="t1472590556" t="seylerius Maybe (&lt;&apos;*/&apos;&gt; / #&apos;.&apos;)+ ?"><y>#</y><d>2016-08-30</d><h>20:55</h><w>seylerius</w>Maybe <code>(&lt;&apos;*/&apos;&gt; / #&apos;.&apos;)+</code>?</z><z id="t1472590581" t="seylerius Always prefer to end a comment if possible, otherwise continue eating characters?"><y>#</y><d>2016-08-30</d><h>20:56</h><w>seylerius</w>Always prefer to end a comment if possible, otherwise continue eating characters?</z><z id="t1472590588" t="seylerius Wait, not quite"><y>#</y><d>2016-08-30</d><h>20:56</h><w>seylerius</w>Wait, not quite</z><z id="t1472590597" t="seylerius That&apos;ll continue past the end."><y>#</y><d>2016-08-30</d><h>20:56</h><w>seylerius</w>That&apos;ll continue past the end.</z><z id="t1472590637" t="seylerius Ach. I need to drive back to the store; I&apos;m done with this client. Check in with y&apos;all in about ten."><y>#</y><d>2016-08-30</d><h>20:57</h><w>seylerius</w>Ach. I need to drive back to the store; I&apos;m done with this client. Check in with y&apos;all in about ten.</z><z id="t1472590987" t="andrei I will also catch up with you guys a bit later too or early tomorrow, its getting a bit late here in Berlin."><y>#</y><d>2016-08-30</d><h>21:03</h><w>andrei</w>I will also catch up with you guys a bit later too or early tomorrow, its getting a bit late here in Berlin.</z><z id="t1472592945" t="seylerius Have a good one."><y>#</y><d>2016-08-30</d><h>21:35</h><w>seylerius</w>Have a good one.</z><z id="t1472658509" t="aengelberg @seylerius the bug you encountered a couple days ago is now pushed to Clojars as Instaparse 1.4.3."><y>#</y><d>2016-08-31</d><h>15:48</h><w>aengelberg</w>@seylerius the bug you encountered a couple days ago is now pushed to Clojars as Instaparse 1.4.3.</z><z id="t1472658526" t="aengelberg https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143"><y>#</y><d>2016-08-31</d><h>15:48</h><w>aengelberg</w><a href="https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143" target="_blank">https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143</a></z><z id="t1472658735" t="seylerius @aengelberg: Shiny! Thanks for the heads up."><y>#</y><d>2016-08-31</d><h>15:52</h><w>seylerius</w>@aengelberg: Shiny! Thanks for the heads up.</z><z id="t1472658784" t="aengelberg Or rather, a fix for said bug."><y>#</y><d>2016-08-31</d><h>15:53</h><w>aengelberg</w>Or rather, a fix for said bug.</z><z id="t1472658787" t="aengelberg :)"><y>#</y><d>2016-08-31</d><h>15:53</h><w>aengelberg</w>:)</z><z id="t1472658799" t="seylerius 😁"><y>#</y><d>2016-08-31</d><h>15:53</h><w>seylerius</w><b>😁</b></z><z id="t1477559218" t="seylerius So, (map (partial reparse-string is-table) (nth (parse-file &quot;&quot;) 6)) fails, complaining about a lack of either #&quot;\r\n&quot; or #&quot;[\r\n]&quot; . Essentially, it seems to think a :br should start the text line in that section."><y>#</y><d>2016-10-27</d><h>09:06</h><w>seylerius</w>So, <code>(map (partial reparse-string is-table) (nth (parse-file &quot;&quot;) 6))</code> fails, complaining about a lack of either <code>#&quot;\r\n&quot;</code> or <code>#&quot;[\r\n]&quot;</code>. Essentially, it seems to think a <code>:br</code> should start the text line in that section.</z><z id="t1477585383" t="aengelberg @seylerius where is the grammar you&apos;re using to parse? apologies if you posted earlier and I missed it."><y>#</y><d>2016-10-27</d><h>16:23</h><w>aengelberg</w>@seylerius where is the grammar you&apos;re using to parse? apologies if you posted earlier and I missed it.</z><z id="t1477585392" t="aengelberg and sample file?"><y>#</y><d>2016-10-27</d><h>16:23</h><w>aengelberg</w>and sample file?</z><z id="t1477588802" t="seylerius Ach, forgot to link to the repo. https://github.com/seylerius/organum"><y>#</y><d>2016-10-27</d><h>17:20</h><w>seylerius</w>Ach, forgot to link to the repo. <a href="https://github.com/seylerius/organum" target="_blank">https://github.com/seylerius/organum</a></z><z id="t1478275091" t="be9 Hi, I need to parse strings like some text with spaces XXX 12345678 98765 43 222 11 . Here are 3 parts: “some text with spaces”, “XXX 12345678”, and &quot;98765 43 222 11”. While the last part is required, the “XXX 12345678” part is optional and will be considered as text by a naive greedy regex. How could I prevent this with Instaparse?"><y>#</y><d>2016-11-04</d><h>15:58</h><w>be9</w>Hi, I need to parse strings like <code>some text with spaces XXX 12345678 98765 43 222 11</code>. Here are 3 parts: “some text with spaces”, “XXX 12345678”, and &quot;98765 43 222 11”. While the last part is required, the “XXX 12345678” part is optional and will be considered as text by a naive greedy regex. How could I prevent this with Instaparse?</z><z id="t1478275187" t="seylerius @be9 Can you describe the requirements your text needs to meet?"><y>#</y><d>2016-11-04</d><h>15:59</h><w>seylerius</w>@be9 Can you describe the requirements your text needs to meet?</z><z id="t1478275204" t="seylerius Or give a few more specific examples?"><y>#</y><d>2016-11-04</d><h>16:00</h><w>seylerius</w>Or give a few more specific examples?</z><z id="t1478275691" t="be9 @seylerius Ok, let’s simplify even more. Two examples: John Doe AGE 50 , Dohn Joe . An input string contains a name and might contain this age thing. I want to parse those eventually to {:name “John Doe” :age 50} and {:name “Dohn Joe”} ."><y>#</y><d>2016-11-04</d><h>16:08</h><w>be9</w>@seylerius Ok, let’s simplify even more. Two examples: <code>John Doe AGE 50</code>, <code>Dohn Joe</code>. An input string contains a name and might contain this age thing. I want to parse those eventually to <code>{:name “John Doe” :age 50}</code> and <code>{:name “Dohn Joe”}</code>.</z><z id="t1478275735" t="be9 First one should not be {:name “John Doe AGE 50”} 🙂"><y>#</y><d>2016-11-04</d><h>16:08</h><w>be9</w>First one should not be <code>{:name “John Doe AGE 50”}</code> <b>🙂</b></z><z id="t1478275758" t="seylerius Okay. This is a problem I&apos;ve run into before."><y>#</y><d>2016-11-04</d><h>16:09</h><w>seylerius</w>Okay. This is a problem I&apos;ve run into before.</z><z id="t1478275772" t="be9 Names can be long and contain digits too"><y>#</y><d>2016-11-04</d><h>16:09</h><w>be9</w>Names can be long and contain digits too</z><z id="t1478275912" t="be9 John Doe AGE 50 AGE 50 would be preferrably parsed as {:name “John Doe AGE 50” :age 50}"><y>#</y><d>2016-11-04</d><h>16:11</h><w>be9</w><code>John Doe AGE 50 AGE 50</code> would be preferrably parsed as <code>{:name “John Doe AGE 50” :age 50}</code></z><z id="t1478275927" t="seylerius Basically what you need is to have a name token, token, and then a name+age token. You then parse for this: &quot;name-age / name&quot;"><y>#</y><d>2016-11-04</d><h>16:12</h><w>seylerius</w>Basically what you need is to have a name token, token, and then a name+age token. You then parse for this: <code>&quot;name-age / name&quot;</code></z><z id="t1478275950" t="seylerius The slash allows you to express a preference for one over the other."><y>#</y><d>2016-11-04</d><h>16:12</h><w>seylerius</w>The slash allows you to express a preference for one over the other.</z><z id="t1478275984" t="seylerius Basically, you&apos;re saying &quot;if this string can match an age too, do that, otherwise it&apos;s just a name&quot;"><y>#</y><d>2016-11-04</d><h>16:13</h><w>seylerius</w>Basically, you&apos;re saying &quot;if this string can match an age too, do that, otherwise it&apos;s just a name&quot;</z><z id="t1478276013" t="seylerius I do this a lot in my rebuild of organum, if you want to take a look at the repo."><y>#</y><d>2016-11-04</d><h>16:13</h><w>seylerius</w>I do this a lot in my rebuild of organum, if you want to take a look at the repo.</z><z id="t1478276034" t="be9 oh, the slash. I see, thanks!"><y>#</y><d>2016-11-04</d><h>16:13</h><w>be9</w>oh, the slash. I see, thanks!</z><z id="t1478276066" t="seylerius Yep. The slash is for preferential parsing."><y>#</y><d>2016-11-04</d><h>16:14</h><w>seylerius</w>Yep. The slash is for preferential parsing.</z><z id="t1478276092" t="be9 :+1: @seylerius, I guess that’s it 🙂"><y>#</y><d>2016-11-04</d><h>16:14</h><w>be9</w><b>:+1:</b> @seylerius, I guess that’s it <b>🙂</b></z><z id="t1478423184" t="alpi May I ask questions on clojurescript port here?"><y>#</y><d>2016-11-06</d><h>09:06</h><w>alpi</w>May I ask questions on clojurescript port here?</z><z id="t1478543398" t="aengelberg @alpi sure"><y>#</y><d>2016-11-07</d><h>18:29</h><w>aengelberg</w>@alpi sure</z><z id="t1483025116" t="gfredericks I don&apos;t imagine there&apos;s a way to unparse something"><y>#</y><d>2016-12-29</d><h>15:25</h><w>gfredericks</w>I don&apos;t imagine there&apos;s a way to unparse something</z><z id="t1483039564" t="seylerius In what sense? Reconstruct the input that was parsed?"><y>#</y><d>2016-12-29</d><h>19:26</h><w>seylerius</w>In what sense? Reconstruct the input that was parsed?</z><z id="t1483039693" t="seylerius @gfredericks What are you trying to accomplish by &quot;unparsing&quot;, and how much control do you have over the parsing?"><y>#</y><d>2016-12-29</d><h>19:28</h><w>seylerius</w>@gfredericks What are you trying to accomplish by &quot;unparsing&quot;, and how much control do you have over the parsing?</z><z id="t1483043170" t="aengelberg @gfredericks: some discussion has happened about this in https://github.com/Engelberg/instaparse/issues/82"><y>#</y><d>2016-12-29</d><h>20:26</h><w>aengelberg</w>@gfredericks: some discussion has happened about this in <a href="https://github.com/Engelberg/instaparse/issues/82" target="_blank">https://github.com/Engelberg/instaparse/issues/82</a></z><z id="t1483043235" t="aengelberg which I just noticed you saw and commented on"><y>#</y><d>2016-12-29</d><h>20:27</h><w>aengelberg</w>which I just noticed you saw and commented on</z><z id="t1483043360" t="aengelberg The fact that &quot;hide tag&quot; (`&lt;&gt;`) is a thing makes it a complex problem to provide unparsing as a general solution"><y>#</y><d>2016-12-29</d><h>20:29</h><w>aengelberg</w>The fact that &quot;hide tag&quot; (`&lt;&gt;`) is a thing makes it a complex problem to provide unparsing as a general solution</z><z id="t1483043458" t="aengelberg also lookahead / negative lookahead"><y>#</y><d>2016-12-29</d><h>20:30</h><w>aengelberg</w>also lookahead / negative lookahead</z><z id="t1483050188" t="gfredericks I want a canonical printer. Potentially pretty printing...which sounds hard"><y>#</y><d>2016-12-29</d><h>22:23</h><w>gfredericks</w>I want a canonical printer. Potentially pretty printing...which sounds hard</z><z id="t1483050191" t="gfredericks So no, not reconstructing the original input exactly"><y>#</y><d>2016-12-29</d><h>22:23</h><w>gfredericks</w>So no, not reconstructing the original input exactly</z><z id="t1483055238" t="seylerius Hmmm."><y>#</y><d>2016-12-29</d><h>23:47</h><w>seylerius</w>Hmmm.</z><z id="t1483057515" t="gfredericks pretty printing is complex enough that I&apos;m convinced it would be crazy to try to mix it into a grammar somehow"><y>#</y><d>2016-12-30</d><h>00:25</h><w>gfredericks</w>pretty printing is complex enough that I&apos;m convinced it would be crazy to try to mix it into a grammar somehow</z><z id="t1483153227" t="gfredericks instaparse requires keywords for the names of the whatchamacallits?"><y>#</y><d>2016-12-31</d><h>03:00</h><w>gfredericks</w>instaparse requires keywords for the names of the whatchamacallits?</z><z id="t1483153255" t="gfredericks I think I might be using instaparse in a weird enough way for that to be a very mild problem"><y>#</y><d>2016-12-31</d><h>03:00</h><w>gfredericks</w>I think I might be using instaparse in a weird enough way for that to be a very mild problem</z><z id="t1483153273" t="gfredericks because I have to gensym the names and so it&apos;s a memory leak"><y>#</y><d>2016-12-31</d><h>03:01</h><w>gfredericks</w>because I have to gensym the names and so it&apos;s a memory leak</z><z id="t1483159621" t="seylerius @gfredericks It outputs either hiccup or enlive notation, so yes it probably would want keywords in reverse."><y>#</y><d>2016-12-31</d><h>04:47</h><w>seylerius</w>@gfredericks It outputs either hiccup or enlive notation, so yes it probably would want keywords in reverse.</z><z id="t1483177948" t="aengelberg @gfredericks: (def all-keywords-ever (map keyword (range))) ;; each time you dynamically create a parser (let [my-syms ... kws (zipmap my-syms all-keywords-ever)] ...) "><y>#</y><d>2016-12-31</d><h>09:52</h><w>aengelberg</w>@gfredericks:
<pre>(def all-keywords-ever (map keyword (range)))

;; each time you dynamically create a parser
(let [my-syms ...
kws (zipmap my-syms all-keywords-ever)]
...)
</pre></z><z id="t1483177960" t="aengelberg That might be a way to conserve on keywords"><y>#</y><d>2016-12-31</d><h>09:52</h><w>aengelberg</w>That might be a way to conserve on keywords</z><z id="t1483178121" t="aengelberg Or do a string replace in the grammar to substitute non terminals with reusable symbols, then postwalk the resulting tree to convert back"><y>#</y><d>2016-12-31</d><h>09:55</h><w>aengelberg</w>Or do a string replace in the grammar to substitute non terminals with reusable symbols, then postwalk the resulting tree to convert back</z><z id="t1483194290" t="gfredericks I&apos;m using the combinators, so it shouldn&apos;t be too hard to do something like that if I decide this matters"><y>#</y><d>2016-12-31</d><h>14:24</h><w>gfredericks</w>I&apos;m using the combinators, so it shouldn&apos;t be too hard to do something like that if I decide this matters</z><z id="t1483213299" t="zmaril @gfredericks @aengelberg if we can actually get generating from grammars going I&apos;d still be really stoked"><y>#</y><d>2016-12-31</d><h>19:41</h><w>zmaril</w>@gfredericks @aengelberg if we can actually get generating from grammars going I&apos;d still be really stoked</z><z id="t1483213356" t="zmaril I&apos;ve been working on https://github.com/zmaril/instaparse-c the past few weeks and am getting within spitting distance of doing some fun stuff."><y>#</y><d>2016-12-31</d><h>19:42</h><w>zmaril</w>I&apos;ve been working on <a href="https://github.com/zmaril/instaparse-c" target="_blank">https://github.com/zmaril/instaparse-c</a> the past few weeks and am getting within spitting distance of doing some fun stuff.</z><z id="t1483213389" t="zmaril It can basically parse C at this point and I&apos;m working on finishing the macro preprocessor now."><y>#</y><d>2016-12-31</d><h>19:43</h><w>zmaril</w>It can basically parse C at this point and I&apos;m working on finishing the macro preprocessor now.</z><z id="t1483213517" t="zmaril The goal is to get the output into datascript and queryable. But a side product of this is that if you have something that can generate strings from grammars then we already have something that can produce c programs (sans macros)."><y>#</y><d>2016-12-31</d><h>19:45</h><w>zmaril</w>The goal is to get the output into datascript and queryable. But a side product of this is that if you have something that can generate strings from grammars then we already have something that can produce c programs (sans macros).</z><z id="t1483214310" t="gfredericks @zmaril do you or anybody know if all instaparse grammars are implemented using the combinators?"><y>#</y><d>2016-12-31</d><h>19:58</h><w>gfredericks</w>@zmaril do you or anybody know if all instaparse grammars are implemented using the combinators?</z><z id="t1483214319" t="gfredericks s/grammars/parser/"><y>#</y><d>2016-12-31</d><h>19:58</h><w>gfredericks</w>s/grammars/parser/</z><z id="t1483214335" t="zmaril Yes they should be"><y>#</y><d>2016-12-31</d><h>19:58</h><w>zmaril</w>Yes they should be</z><z id="t1483214377" t="zmaril My understanding is that the ebnf notation that everybody uses is actually parsed by a parser expressed in the combinators that transforms the output into combinators"><y>#</y><d>2016-12-31</d><h>19:59</h><w>zmaril</w>My understanding is that the ebnf notation that everybody uses is actually parsed by a parser expressed in the combinators that transforms the output into combinators</z><z id="t1483214411" t="gfredericks I just glanced at the combinator list -- I think only the lookaheads are problematic, but that&apos;s probably a big deal for sophisticated parsers"><y>#</y><d>2016-12-31</d><h>20:00</h><w>gfredericks</w>I just glanced at the combinator list -- I think only the lookaheads are problematic, but that&apos;s probably a big deal for sophisticated parsers</z><z id="t1483214424" t="zmaril yep"><y>#</y><d>2016-12-31</d><h>20:00</h><w>zmaril</w>yep</z><z id="t1483214429" t="gfredericks so...oh well."><y>#</y><d>2016-12-31</d><h>20:00</h><w>gfredericks</w>so...oh well.</z><z id="t1483214456" t="zmaril how does one express negation in generators now?"><y>#</y><d>2016-12-31</d><h>20:00</h><w>zmaril</w>how does one express negation in generators now?</z><z id="t1483214469" t="gfredericks you could implement them with gen/such-that but the generator would fail if the lookahead condition is unlikely to pass by chance"><y>#</y><d>2016-12-31</d><h>20:01</h><w>gfredericks</w>you could implement them with <code>gen/such-that</code> but the generator would fail if the lookahead condition is unlikely to pass by chance</z><z id="t1483214497" t="gfredericks I have no how that would play out IRL"><y>#</y><d>2016-12-31</d><h>20:01</h><w>gfredericks</w>I have no how that would play out IRL</z><z id="t1483214503" t="zmaril That should be fine then. For the parsers I write lookahead is typically used to implement reserved keywords."><y>#</y><d>2016-12-31</d><h>20:01</h><w>zmaril</w>That should be fine then. For the parsers I write lookahead is typically used to implement reserved keywords.</z><z id="t1483214523" t="zmaril I&apos;ve never used positive lookahead actually now that I think about it"><y>#</y><d>2016-12-31</d><h>20:02</h><w>zmaril</w>I&apos;ve never used positive lookahead actually now that I think about it</z><z id="t1483214538" t="gfredericks when I made the regex→string generator I just decided not to support look[ahead|behind] for the same reason"><y>#</y><d>2016-12-31</d><h>20:02</h><w>gfredericks</w>when I made the regex→string generator I just decided not to support look[ahead|behind] for the same reason</z><z id="t1483214558" t="zmaril It&apos;s one of those things that is academic to me at this point"><y>#</y><d>2016-12-31</d><h>20:02</h><w>zmaril</w>It&apos;s one of those things that is academic to me at this point</z><z id="t1483214585" t="zmaril I&apos;m pretty sure that 99% gen/such-that of the time would be fine"><y>#</y><d>2016-12-31</d><h>20:03</h><w>zmaril</w>I&apos;m pretty sure that 99% gen/such-that of the time would be fine</z><z id="t1483214609" t="gfredericks it might not be too hard to throw together a PoC"><y>#</y><d>2016-12-31</d><h>20:03</h><w>gfredericks</w>it might not be too hard to throw together a PoC</z><z id="t1483214622" t="gfredericks in fact that would potentially be useful for what I&apos;m working on right now"><y>#</y><d>2016-12-31</d><h>20:03</h><w>gfredericks</w>in fact that would potentially be useful for what I&apos;m working on right now</z><z id="t1483214679" t="zmaril yeah, I think that would fit really well and mirror what spec is doing"><y>#</y><d>2016-12-31</d><h>20:04</h><w>zmaril</w>yeah, I think that would fit really well and mirror what spec is doing</z><z id="t1483214692" t="zmaril I&apos;ve been using spec/conform the same way I use instaparse and it works really well"><y>#</y><d>2016-12-31</d><h>20:04</h><w>zmaril</w>I&apos;ve been using spec/conform the same way I use instaparse and it works really well</z><z id="t1483214712" t="zmaril So I imagine we could use generators the same way spec does and it would work well (fingers crossed)"><y>#</y><d>2016-12-31</d><h>20:05</h><w>zmaril</w>So I imagine we could use generators the same way spec does and it would work well (fingers crossed)</z><z id="t1483214852" t="gfredericks 😂 I just realized that it would require using string-from-regex from test.chuck to support regexes in the grammars, and string-from-regex uses instaparse to parse the regex."><y>#</y><d>2016-12-31</d><h>20:07</h><w>gfredericks</w><b>😂</b> I just realized that it would require using <code>string-from-regex</code> from test.chuck to support regexes in the grammars, and <code>string-from-regex</code> uses instaparse to parse the regex.</z><z id="t1483214869" t="zmaril turtles"><y>#</y><d>2016-12-31</d><h>20:07</h><w>zmaril</w>turtles</z><z id="t1483214880" t="gfredericks indeed"><y>#</y><d>2016-12-31</d><h>20:08</h><w>gfredericks</w>indeed</z><z id="t1483214890" t="zmaril that was the thing that was holding me up actually"><y>#</y><d>2016-12-31</d><h>20:08</h><w>zmaril</w>that was the thing that was holding me up actually</z><z id="t1483214894" t="zmaril was that I didn&apos;t want to mess with regexs"><y>#</y><d>2016-12-31</d><h>20:08</h><w>zmaril</w>was that I didn&apos;t want to mess with regexs</z><z id="t1483214970" t="aengelberg just catching up"><y>#</y><d>2016-12-31</d><h>20:09</h><w>aengelberg</w>just catching up</z><z id="t1483215030" t="aengelberg After I wrote &quot;instagenerate&quot; I realized going the generator route (as opposed to core.logic) would probably be easier, despite the lookahead such-that problem"><y>#</y><d>2016-12-31</d><h>20:10</h><w>aengelberg</w>After I wrote &quot;instagenerate&quot; I realized going the generator route (as opposed to core.logic) would probably be easier, despite the lookahead <code>such-that</code> problem</z><z id="t1483215041" t="aengelberg But what do you want to do about hide-tags?"><y>#</y><d>2016-12-31</d><h>20:10</h><w>aengelberg</w>But what do you want to do about hide-tags?</z><z id="t1483215070" t="zmaril I think I have an idea, h/o"><y>#</y><d>2016-12-31</d><h>20:11</h><w>zmaril</w>I think I have an idea, h/o</z><z id="t1483215104" t="zmaril well, hmmm what is the problem you see with hide-tags?"><y>#</y><d>2016-12-31</d><h>20:11</h><w>zmaril</w>well, hmmm what is the problem you see with hide-tags?</z><z id="t1483215134" t="aengelberg It depends on what you expect the &quot;input&quot; to the generator to be"><y>#</y><d>2016-12-31</d><h>20:12</h><w>aengelberg</w>It depends on what you expect the &quot;input&quot; to the generator to be</z><z id="t1483215144" t="aengelberg a parse tree still?"><y>#</y><d>2016-12-31</d><h>20:12</h><w>aengelberg</w>a parse tree still?</z><z id="t1483215154" t="gfredericks it&apos;d be the combinator"><y>#</y><d>2016-12-31</d><h>20:12</h><w>gfredericks</w>it&apos;d be the combinator</z><z id="t1483215166" t="gfredericks it would generate totally random parsable things"><y>#</y><d>2016-12-31</d><h>20:12</h><w>gfredericks</w>it would generate totally random parsable things</z><z id="t1483215173" t="gfredericks not based on same partial input"><y>#</y><d>2016-12-31</d><h>20:12</h><w>gfredericks</w>not based on same partial input</z><z id="t1483215204" t="aengelberg ok, in that case I don&apos;t really have a problem with hide tags despite just waking up"><y>#</y><d>2016-12-31</d><h>20:13</h><w>aengelberg</w>ok, in that case I don&apos;t really have a problem with hide tags despite just waking up</z><z id="t1483215220" t="zmaril I think if we got something going that just took a grammar and gave back random strings, that would be a good first step"><y>#</y><d>2016-12-31</d><h>20:13</h><w>zmaril</w>I think if we got something going that just took a grammar and gave back random strings, that would be a good first step</z><z id="t1483215290" t="aengelberg part of why I did core.logic in instagenerate is @zmaril&apos;s initial request to go from partial input -&gt; parseable strings, so I felt the need to put in the sophistication of logic programming as a general solver for all cases"><y>#</y><d>2016-12-31</d><h>20:14</h><w>aengelberg</w>part of why I did core.logic in instagenerate is @zmaril&apos;s initial request to go from partial input -&gt; parseable strings, so I felt the need to put in the sophistication of logic programming as a general solver for all cases</z><z id="t1483215315" t="zmaril oh, if we want to do partial input, we can provide skeletons with places to start generating from"><y>#</y><d>2016-12-31</d><h>20:15</h><w>zmaril</w>oh, if we want to do partial input, we can provide skeletons with places to start generating from</z><z id="t1483215341" t="zmaril then we just walk the skeleton and generate random strings at the indicated places"><y>#</y><d>2016-12-31</d><h>20:15</h><w>zmaril</w>then we just walk the skeleton and generate random strings at the indicated places</z><z id="t1483215364" t="zmaril still not fully general but better"><y>#</y><d>2016-12-31</d><h>20:16</h><w>zmaril</w>still not fully general but better</z><z id="t1483215439" t="zmaril and then we could restrict the grammar inside the combinator somehow"><y>#</y><d>2016-12-31</d><h>20:17</h><w>zmaril</w>and then we could restrict the grammar inside the combinator somehow</z><z id="t1483215708" t="aengelberg (def p (insta/parser &quot; S = A B A | B A B &lt;A&gt; (&apos;a&apos; &lt;&apos;c&apos;&gt; &apos;b&apos;)+ &lt;B&gt; (&apos;b&apos; &apos;a&apos;)+ &quot;)) (generate p [:S &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot;]) =&gt; (&quot;acbbaacb&quot;) "><y>#</y><d>2016-12-31</d><h>20:21</h><w>aengelberg</w><pre>(def p (insta/parser &quot;
S = A B A | B A B
&lt;A&gt; (&apos;a&apos; &lt;&apos;c&apos;&gt; &apos;b&apos;)+
&lt;B&gt; (&apos;b&apos; &apos;a&apos;)+
&quot;))

(generate p [:S &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot;])
=&gt; (&quot;acbbaacb&quot;)
</pre></z><z id="t1483215815" t="aengelberg seems hard to performantly solve generally"><y>#</y><d>2016-12-31</d><h>20:23</h><w>aengelberg</w>seems hard to performantly solve generally</z><z id="t1483215874" t="zmaril who said anything about performance"><y>#</y><d>2016-12-31</d><h>20:24</h><w>zmaril</w>who said anything about performance</z><z id="t1483215879" t="aengelberg 🙂 fair enough"><y>#</y><d>2016-12-31</d><h>20:24</h><w>aengelberg</w><b>🙂</b> fair enough</z><z id="t1483215900" t="aengelberg but a generator approach using such-that may never complete on a large enough grammar"><y>#</y><d>2016-12-31</d><h>20:25</h><w>aengelberg</w>but a generator approach using <code>such-that</code> may never complete on a large enough grammar</z><z id="t1483215931" t="zmaril cross that bridge when we get there"><y>#</y><d>2016-12-31</d><h>20:25</h><w>zmaril</w>cross that bridge when we get there</z><z id="t1483215948" t="zmaril computers are like really fast"><y>#</y><d>2016-12-31</d><h>20:25</h><w>zmaril</w>computers are like really fast</z><z id="t1483215980" t="zmaril this is more of a what&apos;s possible idea than a production thing"><y>#</y><d>2016-12-31</d><h>20:26</h><w>zmaril</w>this is more of a what&apos;s possible idea than a production thing</z><z id="t1483216063" t="aengelberg cool"><y>#</y><d>2016-12-31</d><h>20:27</h><w>aengelberg</w>cool</z><z id="t1483216080" t="aengelberg let me know if I can help out in whichever path you decide to try out"><y>#</y><d>2016-12-31</d><h>20:28</h><w>aengelberg</w>let me know if I can help out in whichever path you decide to try out</z><z id="t1483216108" t="zmaril for sure!"><y>#</y><d>2016-12-31</d><h>20:28</h><w>zmaril</w>for sure!</z><z id="t1483216731" t="gfredericks yeah generators aren&apos;t generally for production stuff"><y>#</y><d>2016-12-31</d><h>20:38</h><w>gfredericks</w>yeah generators aren&apos;t generally for production stuff</z><z id="t1483217000" t="gfredericks I want a combinator that doesn&apos;t match anything"><y>#</y><d>2016-12-31</d><h>20:43</h><w>gfredericks</w>I want a combinator that doesn&apos;t match anything</z><z id="t1483217021" t="gfredericks I thought maybe (combo/alt) but that returns ε"><y>#</y><d>2016-12-31</d><h>20:43</h><w>gfredericks</w>I thought maybe <code>(combo/alt)</code> but that returns ε</z><z id="t1483217051" t="zmaril (gen/such-that (constantly false)) or something?"><y>#</y><d>2016-12-31</d><h>20:44</h><w>zmaril</w>(gen/such-that (constantly false)) or something?</z><z id="t1483217058" t="gfredericks a combinator, not a generator"><y>#</y><d>2016-12-31</d><h>20:44</h><w>gfredericks</w>a combinator, not a generator</z><z id="t1483217062" t="zmaril oh right sorry"><y>#</y><d>2016-12-31</d><h>20:44</h><w>zmaril</w>oh right sorry</z><z id="t1483217078" t="gfredericks I guess I can do negative lookahead with epsilon?"><y>#</y><d>2016-12-31</d><h>20:44</h><w>gfredericks</w>I guess I can do negative lookahead with epsilon?</z><z id="t1483217092" t="zmaril or a really unlikely string?"><y>#</y><d>2016-12-31</d><h>20:44</h><w>zmaril</w>or a really unlikely string?</z><z id="t1483217127" t="zmaril like (string &quot;THISWILLNEVERBEMATCHEDHOPEFULLY&quot;)"><y>#</y><d>2016-12-31</d><h>20:45</h><w>zmaril</w>like (string &quot;THISWILLNEVERBEMATCHEDHOPEFULLY&quot;)</z><z id="t1483217172" t="gfredericks 🙂"><y>#</y><d>2016-12-31</d><h>20:46</h><w>gfredericks</w><b>🙂</b></z><z id="t1483217190" t="zmaril we&apos;re not fancy here"><y>#</y><d>2016-12-31</d><h>20:46</h><w>zmaril</w>we&apos;re not fancy here</z><z id="t1483217198" t="gfredericks (string (str (java.util.UUID/randomUUID)))"><y>#</y><d>2016-12-31</d><h>20:46</h><w>gfredericks</w><code>(string (str (java.util.UUID/randomUUID)))</code></z><z id="t1483217216" t="zmaril that works!"><y>#</y><d>2016-12-31</d><h>20:46</h><w>zmaril</w>that works!</z><z id="t1483217304" t="gfredericks I have an alternate thing in my codebase that could be called a parser, but instaparse also has something by that name so I called it a parsifier instead"><y>#</y><d>2016-12-31</d><h>20:48</h><w>gfredericks</w>I have an alternate thing in my codebase that could be called a parser, but instaparse also has something by that name so I called it a parsifier instead</z><z id="t1483217312" t="gfredericks and it&apos;s hard to remember that word because it could also have been parsinator"><y>#</y><d>2016-12-31</d><h>20:48</h><w>gfredericks</w>and it&apos;s hard to remember that word because it could also have been parsinator</z><z id="t1483217374" t="zmaril hahaha"><y>#</y><d>2016-12-31</d><h>20:49</h><w>zmaril</w>hahaha</z><z id="t1483217417" t="zmaril (defn enlive-output-&gt;datascript-datums [m] (if-not (map? m) {:type :value :value m} (as-&gt; m $ (assoc $ :meta (meta m)) (assoc $ :db/id (d/tempid :mcc)) (transform [:content ALL] enlive-output-&gt;datascript-datums $)))) This will take enlive output and make it so you can query it from datascript"><y>#</y><d>2016-12-31</d><h>20:50</h><w>zmaril</w><pre>(defn enlive-output-&gt;datascript-datums [m]
 (if-not (map? m)
    {:type :value :value m}
    (as-&gt; m $
        (assoc $ :meta (meta m))
        (assoc $ :db/id (d/tempid :mcc))
        (transform [:content ALL] enlive-output-&gt;datascript-datums $))))
</pre> This will take enlive output and make it so you can query it from datascript</z><z id="t1483217604" t="gfredericks does instaparse use its own regex engine?"><y>#</y><d>2016-12-31</d><h>20:53</h><w>gfredericks</w>does instaparse use its own regex engine?</z><z id="t1483217617" t="zmaril no"><y>#</y><d>2016-12-31</d><h>20:53</h><w>zmaril</w>no</z><z id="t1483217620" t="gfredericks I just got a misparse where the thing matches the regex but instaparse disagrees"><y>#</y><d>2016-12-31</d><h>20:53</h><w>gfredericks</w>I just got a misparse where the thing matches the regex but instaparse disagrees</z><z id="t1483217622" t="zmaril depends on java if I recall"><y>#</y><d>2016-12-31</d><h>20:53</h><w>zmaril</w>depends on java if I recall</z><z id="t1483217632" t="gfredericks and reordering a disjunction in the regex fixes it"><y>#</y><d>2016-12-31</d><h>20:53</h><w>gfredericks</w>and reordering a disjunction in the regex fixes it</z><z id="t1483217644" t="zmaril hmm"><y>#</y><d>2016-12-31</d><h>20:54</h><w>zmaril</w>hmm</z><z id="t1483217650" t="gfredericks this is the instparse-cljs thing in particular, but still on the jvm"><y>#</y><d>2016-12-31</d><h>20:54</h><w>gfredericks</w>this is the instparse-cljs thing in particular, but still on the jvm</z><z id="t1483217656" t="zmaril check if instaparse passes any flags in"><y>#</y><d>2016-12-31</d><h>20:54</h><w>zmaril</w>check if instaparse passes any flags in</z><z id="t1483217753" t="gfredericks here&apos;s the failing version: https://www.refheap.com/124435"><y>#</y><d>2016-12-31</d><h>20:55</h><w>gfredericks</w>here&apos;s the failing version: <a href="https://www.refheap.com/124435" target="_blank">https://www.refheap.com/124435</a></z><z id="t1483217891" t="zmaril hmm"><y>#</y><d>2016-12-31</d><h>20:58</h><w>zmaril</w>hmm</z><z id="t1483217898" t="zmaril &quot;0/2&quot; parses"><y>#</y><d>2016-12-31</d><h>20:58</h><w>zmaril</w><code>&quot;0/2&quot;</code> parses</z><z id="t1483217924" t="zmaril can you add in some parens to the second part to clarify your intent"><y>#</y><d>2016-12-31</d><h>20:58</h><w>zmaril</w>can you add in some parens to the second part to clarify your intent</z><z id="t1483217999" t="gfredericks &quot;0/2&quot; is not supposed to parse o_O"><y>#</y><d>2016-12-31</d><h>20:59</h><w>gfredericks</w>&quot;0/2&quot; is not supposed to parse o_O</z><z id="t1483218034" t="gfredericks I see that&apos;s my fault though"><y>#</y><d>2016-12-31</d><h>21:00</h><w>gfredericks</w>I see that&apos;s my fault though</z><z id="t1483218229" t="zmaril ha"><y>#</y><d>2016-12-31</d><h>21:03</h><w>zmaril</w>ha</z><z id="t1483221581" t="aengelberg I second !epsilon as the &quot;don&apos;t parse&quot;"><y>#</y><d>2016-12-31</d><h>21:59</h><w>aengelberg</w>I second <code>!epsilon</code> as the &quot;don&apos;t parse&quot;</z><z id="t1483221629" t="aengelberg also instaparse fails on infinite loop grammars, so this might work never-succeed = never-succeed (then use never-succeed wherever)"><y>#</y><d>2016-12-31</d><h>22:00</h><w>aengelberg</w>also instaparse fails on infinite loop grammars, so this might work
<pre>never-succeed = never-succeed
</pre>
(then use <code>never-succeed</code> wherever)</z><z id="t1483221718" t="gfredericks @aengelberg do you think the current behavior of (combo/alt) is bad/weird?"><y>#</y><d>2016-12-31</d><h>22:01</h><w>gfredericks</w>@aengelberg do you think the current behavior of <code>(combo/alt)</code> is bad/weird?</z><z id="t1483221764" t="gfredericks my hunch is that According To Math it should either throw or not match anything"><y>#</y><d>2016-12-31</d><h>22:02</h><w>gfredericks</w>my hunch is that According To Math it should either throw or not match anything</z><z id="t1483221781" t="aengelberg yeah I agree with your instinct. Not really sure what the thinking was in that design."><y>#</y><d>2016-12-31</d><h>22:03</h><w>aengelberg</w>yeah I agree with your instinct. Not really sure what the thinking was in that design.</z><z id="t1483221797" t="gfredericks my argument is that because (combo/alt p) probably does not match ε, neither should (combo/alt)"><y>#</y><d>2016-12-31</d><h>22:03</h><w>gfredericks</w>my argument is that because <code>(combo/alt p)</code> probably does not match ε, neither should <code>(combo/alt)</code></z><z id="t1483221803" t="aengelberg Maybe since &quot;don&apos;t parse anything&quot; isn&apos;t really a common use case"><y>#</y><d>2016-12-31</d><h>22:03</h><w>aengelberg</w>Maybe since &quot;don&apos;t parse anything&quot; isn&apos;t really a common use case</z><z id="t1483221813" t="gfredericks you shouldn&apos;t parse more things by removing an arg from combo/alt"><y>#</y><d>2016-12-31</d><h>22:03</h><w>gfredericks</w>you shouldn&apos;t parse more things by removing an arg from <code>combo/alt</code></z><z id="t1483221826" t="aengelberg agreed"><y>#</y><d>2016-12-31</d><h>22:03</h><w>aengelberg</w>agreed</z><z id="t1483221843" t="gfredericks yeah I always end up finding the uncommon use cases"><y>#</y><d>2016-12-31</d><h>22:04</h><w>gfredericks</w>yeah I always end up finding the uncommon use cases</z><z id="t1483221865" t="gfredericks for a while every time I tried to use CLJS I ended up creating a jira ticket"><y>#</y><d>2016-12-31</d><h>22:04</h><w>gfredericks</w>for a while every time I tried to use CLJS I ended up creating a jira ticket</z><z id="t1483221895" t="aengelberg #gobigorgohome"><y>#</y><d>2016-12-31</d><h>22:04</h><w>aengelberg</w>#gobigorgohome</z><z id="t1483221969" t="aengelberg I think I know why your parser is failing"><y>#</y><d>2016-12-31</d><h>22:06</h><w>aengelberg</w>I think I know why your parser is failing</z><z id="t1483222008" t="aengelberg The regex for the denominator, when given &quot;25&quot; as input, may arbitrarily decide to match either &quot;2&quot; or &quot;25&quot;"><y>#</y><d>2016-12-31</d><h>22:06</h><w>aengelberg</w>The regex for the denominator, when given <code>&quot;25&quot;</code> as input, may arbitrarily decide to match either <code>&quot;2&quot;</code> or <code>&quot;25&quot;</code></z><z id="t1483222024" t="aengelberg In instaparse, whatever the regex decides is the one and only possible parse"><y>#</y><d>2016-12-31</d><h>22:07</h><w>aengelberg</w>In instaparse, whatever the regex decides is the one and only possible parse</z><z id="t1483222073" t="aengelberg user=&gt; (re-matches #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;) &quot;25&quot; user=&gt; (re-seq #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;) (&quot;2&quot; &quot;5&quot;) user=&gt; (re-find #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;) &quot;2&quot; "><y>#</y><d>2016-12-31</d><h>22:07</h><w>aengelberg</w><pre>user=&gt; (re-matches #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;25&quot;
user=&gt; (re-seq #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
(&quot;2&quot; &quot;5&quot;)
user=&gt; (re-find #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;2&quot;
</pre></z><z id="t1483222113" t="gfredericks oh it&apos;s about re-matches vs re-find ?"><y>#</y><d>2016-12-31</d><h>22:08</h><w>gfredericks</w>oh it&apos;s about <code>re-matches</code> vs <code>re-find</code>?</z><z id="t1483222119" t="aengelberg https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning"><y>#</y><d>2016-12-31</d><h>22:08</h><w>aengelberg</w><a href="https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning" target="_blank">https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning</a></z><z id="t1483222127" t="gfredericks oh I think I see"><y>#</y><d>2016-12-31</d><h>22:08</h><w>gfredericks</w>oh I think I see</z><z id="t1483222144" t="aengelberg you could instead do #&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;"><y>#</y><d>2016-12-31</d><h>22:09</h><w>aengelberg</w>you could instead do <code>#&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;</code></z><z id="t1483222162" t="aengelberg If you move logic from regexes into instaparse, you get flexibility at the cost of speed"><y>#</y><d>2016-12-31</d><h>22:09</h><w>aengelberg</w>If you move logic from regexes into instaparse, you get flexibility at the cost of speed</z><z id="t1483222270" t="gfredericks so the fact that I fixed it by rearranging the regex is sort of an implementation detail I guess?"><y>#</y><d>2016-12-31</d><h>22:11</h><w>gfredericks</w>so the fact that I fixed it by rearranging the regex is sort of an implementation detail I guess?</z><z id="t1483222322" t="aengelberg Yes, so I would call rearranging the regex an improper solution"><y>#</y><d>2016-12-31</d><h>22:12</h><w>aengelberg</w>Yes, so I would call rearranging the regex an improper solution</z><z id="t1483222345" t="aengelberg but #&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot; is proper"><y>#</y><d>2016-12-31</d><h>22:12</h><w>aengelberg</w>but <code>#&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;</code> is proper</z><z id="t1483222510" t="gfredericks okay fine I&apos;ll switch it 😛"><y>#</y><d>2016-12-31</d><h>22:15</h><w>gfredericks</w>okay fine I&apos;ll switch it <b>😛</b></z><z id="t1486976333" t="doddenino Hi! Is there a way to do a step by step debug of a parser?"><y>#</y><d>2017-02-13</d><h>08:58</h><w>doddenino</w>Hi! Is there a way to do a step by step debug of a parser?</z><z id="t1487008255" t="dave @doddenino: https://github.com/Engelberg/instaparse#total-parse-mode &lt;-- this is maybe not exactly what you want, but it can be helpful for debugging a parse failure"><y>#</y><d>2017-02-13</d><h>17:50</h><w>dave</w>@doddenino: <a href="https://github.com/Engelberg/instaparse#total-parse-mode" target="_blank">https://github.com/Engelberg/instaparse#total-parse-mode</a> &lt;-- this is maybe not exactly what you want, but it can be helpful for debugging a parse failure</z><z id="t1487008288" t="aengelberg @doddenino you&apos;re probably looking for tracing mode. https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md"><y>#</y><d>2017-02-13</d><h>17:51</h><w>aengelberg</w>@doddenino you&apos;re probably looking for tracing mode. <a href="https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md" target="_blank">https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md</a></z><z id="t1487008358" t="doddenino Oh that&apos;s great! 🙂 Thanks! I&apos;m having a lot of problems trying to make my parser work correctly 😞"><y>#</y><d>2017-02-13</d><h>17:52</h><w>doddenino</w>Oh that&apos;s great! <b>🙂</b> Thanks! I&apos;m having a lot of problems trying to make my parser work correctly <b>😞</b></z><z id="t1487008417" t="aengelberg Also, calling insta/parse with :start overridden can also help debug certain small pieces of your parser."><y>#</y><d>2017-02-13</d><h>17:53</h><w>aengelberg</w>Also, calling <code>insta/parse</code> with <code>:start</code> overridden can also help debug certain small pieces of your parser.</z><z id="t1487008618" t="doddenino @aengelberg I think trace is perfect"><y>#</y><d>2017-02-13</d><h>17:56</h><w>doddenino</w>@aengelberg I think trace is perfect</z><z id="t1487009459" t="doddenino I don&apos;t know how and why, but it&apos;s working correctly now 😅"><y>#</y><d>2017-02-13</d><h>18:10</h><w>doddenino</w>I don&apos;t know how and why, but it&apos;s working correctly now <b>😅</b></z><z id="t1487009571" t="doddenino Celebrating too soon 😞"><y>#</y><d>2017-02-13</d><h>18:12</h><w>doddenino</w>Celebrating too soon <b>😞</b></z><z id="t1487063633" t="doddenino I&apos;m trying to write a lambda calculus expressions parser, but I&apos;m having a hard time dealing applications being left associative and having higher precedence than abstractions. I can either parse &quot;a b c&quot; or &quot;fn x . x a&quot; correctly, but not both with the same parser 😞"><y>#</y><d>2017-02-14</d><h>09:13</h><w>doddenino</w>I&apos;m trying to write a lambda calculus expressions parser, but I&apos;m having a hard time dealing applications being left associative and having higher precedence than abstractions. I can either parse &quot;a b c&quot; or &quot;fn x . x a&quot; correctly, but not both with the same parser <b>😞</b></z><z id="t1487098763" t="aengelberg @doddenino: I&apos;m not familiar with the syntax you&apos;re trying to parse, but have you looked at the ordered choice / operator?"><y>#</y><d>2017-02-14</d><h>18:59</h><w>aengelberg</w>@doddenino: I&apos;m not familiar with the syntax you&apos;re trying to parse, but have you looked at the ordered choice <code>/</code> operator?</z><z id="t1487153531" t="doddenino Yes, I was using that already. I managed to solve it by enforcing a stricter syntax, dealing better with a specific edge case and randomly moving stuff around until it worked fine 😄"><y>#</y><d>2017-02-15</d><h>10:12</h><w>doddenino</w>Yes, I was using that already. I managed to solve it by enforcing a stricter syntax, dealing better with a specific edge case and randomly moving stuff around until it worked fine <b>😄</b></z><z id="t1487354066" t="frank I&apos;m having trouble creating a parser using the grammar specified here: https://developers.google.com/protocol-buffers/docs/reference/proto3-spec"><y>#</y><d>2017-02-17</d><h>17:54</h><w>frank</w>I&apos;m having trouble creating a parser using the grammar specified here: <a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec" target="_blank">https://developers.google.com/protocol-buffers/docs/reference/proto3-spec</a></z><z id="t1487354092" t="frank I&apos;m getting the feeling that there are syntax differences"><y>#</y><d>2017-02-17</d><h>17:54</h><w>frank</w>I&apos;m getting the feeling that there are syntax differences</z><z id="t1487354246" t="frank I&apos;m slurping the grammar out of a separate file, but I feel like escaped quotes still aren&apos;t being handled as I intend (e.g. quote = &quot;&apos;&quot; | &apos;&quot;&apos; )"><y>#</y><d>2017-02-17</d><h>17:57</h><w>frank</w>I&apos;m slurping the grammar out of a separate file, but I feel like escaped quotes still aren&apos;t being handled as I intend (e.g. <code>quote = &quot;&apos;&quot; | &apos;&quot;&apos;</code>)</z><z id="t1487354629" t="frank does anyone know how quotes ought to be escaped in instaparse ebnf strings?"><y>#</y><d>2017-02-17</d><h>18:03</h><w>frank</w>does anyone know how quotes ought to be escaped in instaparse ebnf strings?</z><z id="t1487355201" t="gfredericks the way you have it looks likely to work to me"><y>#</y><d>2017-02-17</d><h>18:13</h><w>gfredericks</w>the way you have it looks likely to work to me</z><z id="t1487355469" t="frank maybe there&apos;s unmatched quotes somewhere in the grammar that I copied and pasted 😕"><y>#</y><d>2017-02-17</d><h>18:17</h><w>frank</w>maybe there&apos;s unmatched quotes somewhere in the grammar that I copied and pasted <b>😕</b></z><z id="t1487355578" t="gfredericks try making a trivial grammar that only matches a quote to make sure it works the way you expect"><y>#</y><d>2017-02-17</d><h>18:19</h><w>gfredericks</w>try making a trivial grammar that only matches a quote to make sure it works the way you expect</z><z id="t1487355658" t="seylerius ^ This. So much this. When I&apos;m making grammars, I often make little phrases to match a character I haven&apos;t tested before."><y>#</y><d>2017-02-17</d><h>18:20</h><w>seylerius</w>^ This. So much this. When I&apos;m making grammars, I often make little phrases to match a character I haven&apos;t tested before.</z><z id="t1487355704" t="frank I&apos;ll try that, thanks"><y>#</y><d>2017-02-17</d><h>18:21</h><w>frank</w>I&apos;ll try that, thanks</z><z id="t1487356160" t="aengelberg &quot;&apos;&quot; | &apos;&quot;&apos; looks right, but there are sometimes additional layers of escaping you have to deal with."><y>#</y><d>2017-02-17</d><h>18:29</h><w>aengelberg</w><code>&quot;&apos;&quot; | &apos;&quot;&apos;</code> looks right, but there are sometimes additional layers of escaping you have to deal with.</z><z id="t1487356193" t="aengelberg e.g. if you wrote your grammar as a string in a Clojure file, it would probably have to look like (def parser (insta/parser &quot;quote \&quot;&apos;\&quot; | &apos;\&quot;&apos;&quot;)) "><y>#</y><d>2017-02-17</d><h>18:29</h><w>aengelberg</w>e.g. if you wrote your grammar as a string in a Clojure file, it would probably have to look like
<pre>(def parser (insta/parser &quot;quote \&quot;&apos;\&quot; | &apos;\&quot;&apos;&quot;))
</pre></z><z id="t1487356271" t="aengelberg I see this in the protobuf spec hexEscape = &apos;\&apos; that will probably throw off instaparse, since it thinks you are escaping the second &apos;"><y>#</y><d>2017-02-17</d><h>18:31</h><w>aengelberg</w>I see this in the protobuf spec
<pre>hexEscape = &apos;\&apos;
</pre>
that will probably throw off instaparse, since it thinks you are escaping the second <code>&apos;</code></z><z id="t1487356285" t="aengelberg so it should really be hexEscape = &apos;\\&apos; "><y>#</y><d>2017-02-17</d><h>18:31</h><w>aengelberg</w>so it should really be
<pre>hexEscape = &apos;\\&apos;
</pre></z><z id="t1487356321" t="aengelberg @frank ^"><y>#</y><d>2017-02-17</d><h>18:32</h><w>aengelberg</w>@frank ^</z><z id="t1487356340" t="aengelberg also, /[^\0\n\\]/ is not valid EBNF in instaparse (should be #&quot;[^\0\n\\]&quot; )"><y>#</y><d>2017-02-17</d><h>18:32</h><w>aengelberg</w>also, <code>/[^\0\n\\]/</code> is not valid EBNF in instaparse (should be <code>#&quot;[^\0\n\\]&quot;</code>)</z><z id="t1487356958" t="frank ah, that&apos;s probably it!"><y>#</y><d>2017-02-17</d><h>18:42</h><w>frank</w>ah, that&apos;s probably it!</z><z id="t1487357021" t="frank strangely enough, #&quot;[^\0\n\\]&quot; isn&apos;t valid clojure regex syntax, so I stole the same regex syntax from https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf"><y>#</y><d>2017-02-17</d><h>18:43</h><w>frank</w>strangely enough, <code>#&quot;[^\0\n\\]&quot;</code> isn&apos;t valid clojure regex syntax, so I stole the same regex syntax from <a href="https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf" target="_blank">https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf</a></z><z id="t1487357044" t="frank they&apos;ve got a few extra backslashes: #&quot;[^\\0\\n]&quot;"><y>#</y><d>2017-02-17</d><h>18:44</h><w>frank</w>they&apos;ve got a few extra backslashes: <code>#&quot;[^\\0\\n]&quot;</code></z><z id="t1487357185" t="frank @aengelberg what&apos;s the equivalent of the … that they&apos;ve got littered all over their grammar?"><y>#</y><d>2017-02-17</d><h>18:46</h><w>frank</w>@aengelberg what&apos;s the equivalent of the <code>…</code> that they&apos;ve got littered all over their grammar?</z><z id="t1487357377" t="aengelberg I think they meant that as a shorthand for alternating between all the digits. Sadly instaparse can&apos;t infer the intermediate values, so you would have to &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;8&quot; | &quot;9&quot;"><y>#</y><d>2017-02-17</d><h>18:49</h><w>aengelberg</w>I think they meant that as a shorthand for alternating between all the digits. Sadly instaparse can&apos;t infer the intermediate values, so you would have to <code>&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;8&quot; | &quot;9&quot;</code></z><z id="t1487357415" t="frank ah, gotcha"><y>#</y><d>2017-02-17</d><h>18:50</h><w>frank</w>ah, gotcha</z><z id="t1487357757" t="frank alternatively, #&quot;[0-9]&quot; should work too, right?"><y>#</y><d>2017-02-17</d><h>18:55</h><w>frank</w>alternatively, #&quot;[0-9]&quot; should work too, right?</z><z id="t1487357774" t="aengelberg correct"><y>#</y><d>2017-02-17</d><h>18:56</h><w>aengelberg</w>correct</z><z id="t1487476875" t="bherrmann has anyone used instaparse to mottle through oracle sql?"><y>#</y><d>2017-02-19</d><h>04:01</h><w>bherrmann</w>has anyone used instaparse to mottle through oracle sql?</z><z id="t1487497182" t="aengelberg I vaguely recall hearing about people using instaparse for SQL, but I unfortunately can&apos;t point to something specific."><y>#</y><d>2017-02-19</d><h>09:39</h><w>aengelberg</w>I vaguely recall hearing about people using instaparse for SQL, but I unfortunately can&apos;t point to something specific.</z><z id="t1487497208" t="aengelberg Might be something in the instaparse Google group archives"><y>#</y><d>2017-02-19</d><h>09:40</h><w>aengelberg</w>Might be something in the instaparse Google group archives</z><z id="t1487885189" t="anthony.naddeo @aengelberg I have a parser that I&apos;m not sure how else to improve: https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs"><y>#</y><d>2017-02-23</d><h>21:26</h><w>anthony.naddeo</w>@aengelberg I have a parser that I&apos;m not sure how else to improve: <a href="https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs" target="_blank">https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs</a></z><z id="t1487885222" t="anthony.naddeo I&apos;ve eliminated a ton of ambiguity but I&apos;m still seeing that its performance scales poorly with the size of the input, even when there are only 1 or two possible parses"><y>#</y><d>2017-02-23</d><h>21:27</h><w>anthony.naddeo</w>I&apos;ve eliminated a ton of ambiguity but I&apos;m still seeing that its performance scales poorly with the size of the input, even when there are only 1 or two possible parses</z><z id="t1487885243" t="anthony.naddeo but that same input when fed chunk by chunk adds up to a much more reasonable parse time"><y>#</y><d>2017-02-23</d><h>21:27</h><w>anthony.naddeo</w>but that same input when fed chunk by chunk adds up to a much more reasonable parse time</z><z id="t1487885302" t="anthony.naddeo I was reading about the :optimize :memory option, but that seems to make it worse"><y>#</y><d>2017-02-23</d><h>21:28</h><w>anthony.naddeo</w>I was reading about the <code>:optimize :memory</code> option, but that seems to make it worse</z><z id="t1487885321" t="anthony.naddeo I even tried it with Java instead of Node to see if it was just a JS thing and the results were still similar"><y>#</y><d>2017-02-23</d><h>21:28</h><w>anthony.naddeo</w>I even tried it with Java instead of Node to see if it was just a JS thing and the results were still similar</z><z id="t1487885367" t="anthony.naddeo My next step was about to be to write a function that breaks the input up into chunks, but to do that I&apos;ll need to know where a chunk starts/stops or impose some sort of convention around the input"><y>#</y><d>2017-02-23</d><h>21:29</h><w>anthony.naddeo</w>My next step was about to be to write a function that breaks the input up into chunks, but to do that I&apos;ll need to know where a chunk starts/stops or impose some sort of convention around the input</z><z id="t1487889477" t="hiredman have you seen https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md ? I feel like I have seen splitting input in to chunks recommended for larger inputs to instaparse"><y>#</y><d>2017-02-23</d><h>22:37</h><w>hiredman</w>have you seen <a href="https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md" target="_blank">https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md</a>? I feel like I have seen splitting input in to chunks recommended for larger inputs to instaparse</z><z id="t1487889630" t="anthony.naddeo Yeah that&apos;s where I got it from"><y>#</y><d>2017-02-23</d><h>22:40</h><w>anthony.naddeo</w>Yeah that&apos;s where I got it from</z><z id="t1487889647" t="anthony.naddeo It just seems like something I shouldn&apos;t have to do"><y>#</y><d>2017-02-23</d><h>22:40</h><w>anthony.naddeo</w>It just seems like something I shouldn&apos;t have to do</z><z id="t1487889663" t="anthony.naddeo If only because I need my parser to determine when a readable chunk starts/stops"><y>#</y><d>2017-02-23</d><h>22:41</h><w>anthony.naddeo</w>If only because I need my parser to determine when a readable chunk starts/stops</z><z id="t1487889670" t="anthony.naddeo it isn&apos;t a line by line thing"><y>#</y><d>2017-02-23</d><h>22:41</h><w>anthony.naddeo</w>it isn&apos;t a line by line thing</z><z id="t1487889752" t="hiredman I might try and eliminate regexes in the grammar definition, if I recall correctly those can be (or maybe they were?) inefficient"><y>#</y><d>2017-02-23</d><h>22:42</h><w>hiredman</w>I might try and eliminate regexes in the grammar definition, if I recall correctly those can be (or maybe they were?) inefficient</z><z id="t1487889959" t="anthony.naddeo Are there any examples you know of large grammars that scale linearly with the size of the input?"><y>#</y><d>2017-02-23</d><h>22:45</h><w>anthony.naddeo</w>Are there any examples you know of large grammars that scale linearly with the size of the input?</z><z id="t1487889970" t="anthony.naddeo Before I go down a rabbit hole I want to make sure I know what to expect"><y>#</y><d>2017-02-23</d><h>22:46</h><w>anthony.naddeo</w>Before I go down a rabbit hole I want to make sure I know what to expect</z><z id="t1487890139" t="hiredman no, I don&apos;t"><y>#</y><d>2017-02-23</d><h>22:48</h><w>hiredman</w>no, I don&apos;t</z><z id="t1487890184" t="hiredman I don&apos;t know of any large grammars, and I have only used smallish grammars on small inputs"><y>#</y><d>2017-02-23</d><h>22:49</h><w>hiredman</w>I don&apos;t know of any large grammars, and I have only used smallish grammars on small inputs</z><z id="t1487890248" t="anthony.naddeo I&apos;m just afraid that the performance actually won&apos;t get better as hard as I may try and I want to cut my losses if I can."><y>#</y><d>2017-02-23</d><h>22:50</h><w>anthony.naddeo</w>I&apos;m just afraid that the performance actually won&apos;t get better as hard as I may try and I want to cut  my losses if I can.</z><z id="t1487890257" t="anthony.naddeo Or just use this for things that only require parsing snippets"><y>#</y><d>2017-02-23</d><h>22:50</h><w>anthony.naddeo</w>Or just use this for things that only require parsing snippets</z><z id="t1487890267" t="anthony.naddeo Thanks for the advice though @hiredman"><y>#</y><d>2017-02-23</d><h>22:51</h><w>anthony.naddeo</w>Thanks for the advice though @hiredman</z><z id="t1487890433" t="hiredman it would be neat if instaparse could emit warnings and suggest fixes if your grammar is not LL(1)"><y>#</y><d>2017-02-23</d><h>22:53</h><w>hiredman</w>it would be neat if instaparse could emit warnings and suggest fixes if your grammar is not LL(1)</z><z id="t1487890626" t="anthony.naddeo At this point, it seems like what I really want is a mode where it parses in chunks itself. My grammar is really just a repetition of 4 possible blocks. It seems like it could just parse the first block independent of the second. That is to say, as soon as it matches just consider it a block and move on."><y>#</y><d>2017-02-23</d><h>22:57</h><w>anthony.naddeo</w>At this point, it seems like what I really want is a mode where it parses in chunks itself. My grammar is really just a repetition of 4 possible blocks. It seems like it could just parse the first block independent of the second. That is to say, as soon as it matches just consider it a block and move on.</z><z id="t1487890645" t="anthony.naddeo Given the right level of ambiguity I would be ok with massaging the results"><y>#</y><d>2017-02-23</d><h>22:57</h><w>anthony.naddeo</w>Given the right level of ambiguity I would be ok with massaging the results</z><z id="t1487890821" t="aengelberg How large are your problematic inputs?"><y>#</y><d>2017-02-23</d><h>23:00</h><w>aengelberg</w>How large are your problematic inputs?</z><z id="t1487890950" t="anthony.naddeo Well, it scales poorly. There isn&apos;t a size in specific. It parses the Elm programming langauge. When testing, I start with a single function, then I just keep duplicating that function and observe the performance"><y>#</y><d>2017-02-23</d><h>23:02</h><w>anthony.naddeo</w>Well, it scales poorly. There isn&apos;t a size in specific. It parses the Elm programming langauge. When testing, I start with a single function, then I just keep duplicating that function and observe the performance</z><z id="t1487890967" t="anthony.naddeo each additional function adds more than its fair share of time"><y>#</y><d>2017-02-23</d><h>23:02</h><w>anthony.naddeo</w>each additional function adds more than its fair share of time</z><z id="t1487890975" t="anthony.naddeo I&apos;ll paste a snippet of something that takes too long"><y>#</y><d>2017-02-23</d><h>23:02</h><w>anthony.naddeo</w>I&apos;ll paste a snippet of something that takes too long</z><z id="t1487891215" t="anthony.naddeo (def input &quot;nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next nextSource : Source a -&gt; Source a nextSource (Source a next) = Source (next a) next &quot;) "><y>#</y><d>2017-02-23</d><h>23:06</h><w>anthony.naddeo</w><pre>(def input &quot;nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next


nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

&quot;)
</pre></z><z id="t1487891295" t="anthony.naddeo That one I actually just had to kill"><y>#</y><d>2017-02-23</d><h>23:08</h><w>anthony.naddeo</w>That one I actually just had to kill</z><z id="t1487891308" t="anthony.naddeo but if you cut it in half it only takes about a second or so to parse"><y>#</y><d>2017-02-23</d><h>23:08</h><w>anthony.naddeo</w>but if you cut it in half it only takes about a second or so to parse</z><z id="t1487891324" t="anthony.naddeo And its a pretty reasonable size for an Elm source file"><y>#</y><d>2017-02-23</d><h>23:08</h><w>anthony.naddeo</w>And its a pretty reasonable size for an Elm source file</z><z id="t1487891446" t="aengelberg Ouch"><y>#</y><d>2017-02-23</d><h>23:10</h><w>aengelberg</w>Ouch</z><z id="t1487891474" t="aengelberg I&apos;ll try to take a look soon"><y>#</y><d>2017-02-23</d><h>23:11</h><w>aengelberg</w>I&apos;ll try to take a look soon</z><z id="t1487891932" t="anthony.naddeo Cool, thanks a lot"><y>#</y><d>2017-02-23</d><h>23:18</h><w>anthony.naddeo</w>Cool, thanks a lot</z><z id="t1487891959" t="anthony.naddeo Also, definitely pretty new to clojure still. If I can make the code more approachable/replable feel free to point that out"><y>#</y><d>2017-02-23</d><h>23:19</h><w>anthony.naddeo</w>Also, definitely pretty new to clojure still. If I can make the code more approachable/replable feel free to point that out</z><z id="t1487891964" t="anthony.naddeo I kind of just hacked everything together"><y>#</y><d>2017-02-23</d><h>23:19</h><w>anthony.naddeo</w>I kind of just hacked everything together</z><z id="t1487893013" t="aengelberg @anthony.naddeo I fixed it before: start = (&lt;ws&gt;* block &lt;ws&gt;*)+ after: start = (&lt;ws&gt; block &lt;ws&gt;)+ "><y>#</y><d>2017-02-23</d><h>23:36</h><w>aengelberg</w>@anthony.naddeo I fixed it

before:
<pre>start = (&lt;ws&gt;* block &lt;ws&gt;*)+
</pre>

after:
<pre>start = (&lt;ws&gt; block &lt;ws&gt;)+
</pre></z><z id="t1487893034" t="anthony.naddeo That? Let me try now"><y>#</y><d>2017-02-23</d><h>23:37</h><w>anthony.naddeo</w>That? Let me try now</z><z id="t1487893054" t="aengelberg the large input now takes 100ms on my machine"><y>#</y><d>2017-02-23</d><h>23:37</h><w>aengelberg</w>the large input now takes 100ms on my machine</z><z id="t1487893186" t="anthony.naddeo 100ms? I just tried it and it is WAY better, but I wish I had those numbers"><y>#</y><d>2017-02-23</d><h>23:39</h><w>anthony.naddeo</w>100ms? I just tried it and it is WAY better, but I wish I had those numbers</z><z id="t1487893192" t="anthony.naddeo are you just in a node repl?"><y>#</y><d>2017-02-23</d><h>23:39</h><w>anthony.naddeo</w>are you just in a node repl?</z><z id="t1487893195" t="anthony.naddeo I&apos;m down to 900ms now"><y>#</y><d>2017-02-23</d><h>23:39</h><w>anthony.naddeo</w>I&apos;m down to 900ms now</z><z id="t1487893198" t="anthony.naddeo which is great"><y>#</y><d>2017-02-23</d><h>23:39</h><w>anthony.naddeo</w>which is great</z><z id="t1487893202" t="anthony.naddeo compared to never stopping"><y>#</y><d>2017-02-23</d><h>23:40</h><w>anthony.naddeo</w>compared to never stopping</z><z id="t1487893214" t="anthony.naddeo I wouldn&apos;t have thought to do that"><y>#</y><d>2017-02-23</d><h>23:40</h><w>anthony.naddeo</w>I wouldn&apos;t have thought to do that</z><z id="t1487893226" t="aengelberg sorry I&apos;m in JVM, not JS"><y>#</y><d>2017-02-23</d><h>23:40</h><w>aengelberg</w>sorry I&apos;m in JVM, not JS</z><z id="t1487893246" t="aengelberg 900ms makes sense for node, instaparse in cljs is known to be ~ 10x slower"><y>#</y><d>2017-02-23</d><h>23:40</h><w>aengelberg</w>900ms makes sense for node, instaparse in cljs is known to be ~ 10x slower</z><z id="t1487893310" t="anthony.naddeo oh interesting. Did you use my parser.clj file?"><y>#</y><d>2017-02-23</d><h>23:41</h><w>anthony.naddeo</w>oh interesting. Did you use my parser.clj file?</z><z id="t1487893330" t="anthony.naddeo yeah this is way better"><y>#</y><d>2017-02-23</d><h>23:42</h><w>anthony.naddeo</w>yeah this is way better</z><z id="t1487893337" t="anthony.naddeo Thanks a ton"><y>#</y><d>2017-02-23</d><h>23:42</h><w>anthony.naddeo</w>Thanks a ton</z><z id="t1487893387" t="aengelberg I just copied the grammar string from parser.cljs into my clojure file since the EBNF syntax is the same on both platforms"><y>#</y><d>2017-02-23</d><h>23:43</h><w>aengelberg</w>I just copied the grammar string from <code>parser.cljs</code> into my clojure file since the EBNF syntax is the same on both platforms</z><z id="t1487893397" t="aengelberg np"><y>#</y><d>2017-02-23</d><h>23:43</h><w>aengelberg</w>np</z><z id="t1487893543" t="anthony.naddeo One odd thing though"><y>#</y><d>2017-02-23</d><h>23:45</h><w>anthony.naddeo</w>One odd thing though</z><z id="t1487893558" t="anthony.naddeo I would expect that the * impacts performance because it adds ambiguity right?"><y>#</y><d>2017-02-23</d><h>23:45</h><w>anthony.naddeo</w>I would expect that the <code>*</code> impacts performance because it adds ambiguity right?</z><z id="t1487893589" t="anthony.naddeo If so, shouldn&apos;t there be more than a single parse for it? (time (count (insta/parses parser/parser input :unhide :all))) returned 1 unless I did something wrong"><y>#</y><d>2017-02-23</d><h>23:46</h><w>anthony.naddeo</w>If so, shouldn&apos;t there be more than a single parse for it? <code>(time (count (insta/parses parser/parser input :unhide :all)))</code> returned 1 unless I did something wrong</z><z id="t1487893811" t="hiredman ambiguity can mean multiple results, but it can also mean a single result that required checking lots of different cases to arrive at"><y>#</y><d>2017-02-23</d><h>23:50</h><w>hiredman</w>ambiguity can mean multiple results, but it can also mean a single result that required checking lots of different cases to arrive at</z><z id="t1487893842" t="anthony.naddeo What metrics could people use to determine ambiguity if not parse counts?"><y>#</y><d>2017-02-23</d><h>23:50</h><w>anthony.naddeo</w>What metrics could people use to determine ambiguity if not parse counts?</z><z id="t1487893942" t="hiredman #6 in that peformance doc suggests looking at rules individually to see if you have rules that in isolation can result in multiple parses"><y>#</y><d>2017-02-23</d><h>23:52</h><w>hiredman</w>#6 in that peformance doc suggests looking at rules individually to see if you have rules that in isolation can result in multiple parses</z><z id="t1487893944" t="aengelberg Instaparse de-duplicates results, so some internal ambiguity can lurk around but still impact the perf"><y>#</y><d>2017-02-23</d><h>23:52</h><w>aengelberg</w>Instaparse de-duplicates results, so some internal ambiguity can lurk around but still impact the perf</z><z id="t1487893984" t="anthony.naddeo interesting"><y>#</y><d>2017-02-23</d><h>23:53</h><w>anthony.naddeo</w>interesting</z><z id="t1487893994" t="anthony.naddeo well, I&apos;m glad that was an easy fix, thanks guys"><y>#</y><d>2017-02-23</d><h>23:53</h><w>anthony.naddeo</w>well, I&apos;m glad that was an easy fix, thanks guys</z><z id="t1487894004" t="anthony.naddeo I don&apos;t think I can go back to other parsers. I would have been heart broken"><y>#</y><d>2017-02-23</d><h>23:53</h><w>anthony.naddeo</w>I don&apos;t think I can go back to other parsers. I would have been heart broken</z><z id="t1487894111" t="aengelberg btw @anthony.naddeo, I made the following optimization to your Name and name which halved the time for me: Name = #&apos;(?!\\b(if|then|else|in|let|case|of)\\b)[A-Z][a-zA-Z0-9]*&apos; name = #&apos;(?!\\b(if|then|else|in|let|case|of|type)\\b)[a-z][a-zA-Z0-9]*&apos; "><y>#</y><d>2017-02-23</d><h>23:55</h><w>aengelberg</w>btw @anthony.naddeo, I made the following optimization to your <code>Name</code> and <code>name</code> which halved the time for me:
<pre>Name = #&apos;(?!\\b(if|then|else|in|let|case|of)\\b)[A-Z][a-zA-Z0-9]*&apos;
    name = #&apos;(?!\\b(if|then|else|in|let|case|of|type)\\b)[a-z][a-zA-Z0-9]*&apos;
</pre></z><z id="t1487894199" t="aengelberg Actually the first \b doesn&apos;t really do anything, because the first character of this particular token is the first char in the string from the regex&apos;s perspective"><y>#</y><d>2017-02-23</d><h>23:56</h><w>aengelberg</w>Actually the first \b doesn&apos;t really do anything, because the first character of this particular token is the first char in the string from the regex&apos;s perspective</z><z id="t1487894263" t="aengelberg But my optimization was to shift more responsibility into the regex; that is always ideal"><y>#</y><d>2017-02-23</d><h>23:57</h><w>aengelberg</w>But my optimization was to shift more responsibility into the regex; that is always ideal</z><z id="t1487894999" t="aengelberg related: symbol = #&apos;(?!(-&gt;|=)\\b)[+/*&lt;&gt;:&amp;|=^?%#~!-]+&apos; "><y>#</y><d>2017-02-24</d><h>00:09</h><w>aengelberg</w>related:
<pre>symbol = #&apos;(?!(-&gt;|=)\\b)[+/*&lt;&gt;:&amp;|=^?%#~!-]+&apos;
</pre></z><z id="t1487895038" t="anthony.naddeo oh awesome, let me try that now"><y>#</y><d>2017-02-24</d><h>00:10</h><w>anthony.naddeo</w>oh awesome, let me try that now</z><z id="t1487895050" t="anthony.naddeo I had meant to circle back and fix all that stuff on the bottom..."><y>#</y><d>2017-02-24</d><h>00:10</h><w>anthony.naddeo</w>I had meant to circle back and fix all that stuff on the bottom...</z><z id="t1487896351" t="anthony.naddeo @aengelberg yeah, that&apos;s pretty awesome. Thanks a ton. I guess I have some work to do"><y>#</y><d>2017-02-24</d><h>00:32</h><w>anthony.naddeo</w>@aengelberg yeah, that&apos;s pretty awesome. Thanks a ton. I guess I have some work to do</z><z id="t1487896364" t="anthony.naddeo Its cut nearly in half on JS"><y>#</y><d>2017-02-24</d><h>00:32</h><w>anthony.naddeo</w>Its cut nearly in half on JS</z><z id="t1487896460" t="aengelberg just curious, does Elm allow newlines pretty much anywhere there can be whitespace? if so, I would recommend making a universal ws and ows (optional whitespace) that allows whitespace, newlines, and comments, which you can then spam in your grammar anytime you would use &lt;break&gt; ."><y>#</y><d>2017-02-24</d><h>00:34</h><w>aengelberg</w>just curious, does Elm allow newlines pretty much anywhere there can be whitespace? if so, I would recommend making a universal <code>ws</code> and <code>ows</code> (optional whitespace) that allows whitespace, newlines, and comments, which you can then spam in your grammar anytime you would use <code>&lt;break&gt;</code>.</z><z id="t1487896499" t="aengelberg whitespace and comments are sometimes the trickiest parts of grammar perf"><y>#</y><d>2017-02-24</d><h>00:34</h><w>aengelberg</w>whitespace and comments are sometimes the trickiest parts of grammar perf</z><z id="t1487896683" t="anthony.naddeo Its pretty flexible with newlines yeah. It does care about indentation (which I haven&apos;t attempted to model in anyway). Are you saying that break performs poorly or that it would be easier to maintain if I just settled on fewer whitespace tokens"><y>#</y><d>2017-02-24</d><h>00:38</h><w>anthony.naddeo</w>Its pretty flexible with newlines yeah. It does care about indentation (which I haven&apos;t attempted to model in anyway). Are you saying that <code>break</code> performs poorly or that it would be easier to maintain if I just settled on fewer whitespace tokens</z><z id="t1487896766" t="aengelberg I don&apos;t think anything&apos;s wrong with break , but you might run into false negatives i.e. valid Elm code that doesn&apos;t parse properly"><y>#</y><d>2017-02-24</d><h>00:39</h><w>aengelberg</w>I don&apos;t think anything&apos;s wrong with <code>break</code>, but you might run into false negatives i.e. valid Elm code that doesn&apos;t parse properly</z><z id="t1487896805" t="aengelberg and making ws easier to reason about makes you less likely to fall into ambiguity traps like two adjacent ws parsers"><y>#</y><d>2017-02-24</d><h>00:40</h><w>aengelberg</w>and making ws easier to reason about makes you less likely to fall into ambiguity traps like two adjacent ws parsers</z><z id="t1487896818" t="anthony.naddeo yeah that&apos;s a good point"><y>#</y><d>2017-02-24</d><h>00:40</h><w>anthony.naddeo</w>yeah that&apos;s a good point</z><z id="t1487896852" t="anthony.naddeo break probably can go. It was just the result of trial and error when I first picked up the parser, I shouldn&apos;t feel particularly attached to it if I can just use ws everywhere"><y>#</y><d>2017-02-24</d><h>00:40</h><w>anthony.naddeo</w>break probably can go. It was just the result of trial and error when I first picked up the parser, I shouldn&apos;t feel particularly attached to it if I can just use ws everywhere</z><z id="t1487896923" t="anthony.naddeo thanks again. This is far more support than I expected"><y>#</y><d>2017-02-24</d><h>00:42</h><w>anthony.naddeo</w>thanks again. This is far more support than I expected</z><z id="t1487897364" t="aengelberg No problem"><y>#</y><d>2017-02-24</d><h>00:49</h><w>aengelberg</w>No problem</z><z id="t1487897370" t="anthony.naddeo I think it might also make sense for me to roll comments into a rule similar to that"><y>#</y><d>2017-02-24</d><h>00:49</h><w>anthony.naddeo</w>I think it might also make sense for me to roll comments into a rule similar to that</z><z id="t1487897384" t="anthony.naddeo they too can appear anywhere"><y>#</y><d>2017-02-24</d><h>00:49</h><w>anthony.naddeo</w>they too can appear anywhere</z><z id="t1487897418" t="aengelberg Agreed. Your usage of single line comments seemed kind of arbitrary though admittedly I&apos;m not familiar with Elm"><y>#</y><d>2017-02-24</d><h>00:50</h><w>aengelberg</w>Agreed. Your usage of single line comments seemed kind of arbitrary though admittedly I&apos;m not familiar with Elm</z></g><g id="s3"><z id="t1487897441" t="anthony.naddeo yeah its totally arbitrary. I&apos;ve punted on all inline comments atm"><y>#</y><d>2017-02-24</d><h>00:50</h><w>anthony.naddeo</w>yeah its totally arbitrary. I&apos;ve punted on all inline comments atm</z><z id="t1487897497" t="anthony.naddeo the only challenge was modeling them in a meaningful way. I wanted to be able to convert the tree back into code and preserve the comments, or be able to include data about comments in queries against the parse tree"><y>#</y><d>2017-02-24</d><h>00:51</h><w>anthony.naddeo</w>the only challenge was modeling them in a meaningful way. I wanted to be able to convert the tree back into code and preserve the comments, or be able to include data about comments in queries against the parse tree</z><z id="t1489017485" t="bherrmann how does instaparse compare to ANTLR"><y>#</y><d>2017-03-08</d><h>23:58</h><w>bherrmann</w>how does instaparse compare to ANTLR</z><z id="t1489017619" t="aengelberg @bherrmann: in comparison, instaparse is slow and memory-inefficient, but far easier to use and accepts more types of grammars"><y>#</y><d>2017-03-09</d><h>00:00</h><w>aengelberg</w>@bherrmann: in comparison, instaparse is slow and memory-inefficient, but far easier to use and accepts more types of grammars</z><z id="t1489017644" t="aengelberg I&apos;ve never actually used ANTLR so I&apos;m just guessing on both points"><y>#</y><d>2017-03-09</d><h>00:00</h><w>aengelberg</w>I&apos;ve never actually used ANTLR so I&apos;m just guessing on both points</z><z id="t1489017653" t="bherrmann Ha!"><y>#</y><d>2017-03-09</d><h>00:00</h><w>bherrmann</w>Ha!</z><z id="t1489017702" t="bherrmann We have a large oracle grammar… in ANTLR and I’m curious about using instaparse instead"><y>#</y><d>2017-03-09</d><h>00:01</h><w>bherrmann</w>We have a large oracle grammar…  in ANTLR  and I’m curious about using instaparse instead</z><z id="t1489017750" t="aengelberg So it&apos;s already working in ANTLR?"><y>#</y><d>2017-03-09</d><h>00:02</h><w>aengelberg</w>So it&apos;s already working in ANTLR?</z><z id="t1489017754" t="aengelberg Why would you want to switch?"><y>#</y><d>2017-03-09</d><h>00:02</h><w>aengelberg</w>Why would you want to switch?</z><z id="t1489017915" t="aengelberg (genuinely curious)"><y>#</y><d>2017-03-09</d><h>00:05</h><w>aengelberg</w>(genuinely curious)</z><z id="t1489018092" t="bherrmann well. This might be the wrong reason"><y>#</y><d>2017-03-09</d><h>00:08</h><w>bherrmann</w>well.   This might be the wrong reason</z><z id="t1489018116" t="bherrmann by when we make changes to the ANTLR grammar, it generates a java file which is too big to be compiled"><y>#</y><d>2017-03-09</d><h>00:08</h><w>bherrmann</w>by when we make changes to the ANTLR grammar, it generates a java file which is too big to be compiled</z><z id="t1489018142" t="bherrmann so at the moment, we have to giggle the rules to keep the output small enough to be compiled."><y>#</y><d>2017-03-09</d><h>00:09</h><w>bherrmann</w>so at the moment, we have to giggle the rules to keep the output small enough to be compiled.</z><z id="t1489018150" t="bherrmann It is ANTLR V3"><y>#</y><d>2017-03-09</d><h>00:09</h><w>bherrmann</w>It is ANTLR V3</z><z id="t1489018208" t="seylerius That sounds... clumsy."><y>#</y><d>2017-03-09</d><h>00:10</h><w>seylerius</w>That sounds... clumsy.</z><z id="t1489018293" t="bherrmann well, it that old song of someone understanding how ANTLR v3 works and them leaving the company...."><y>#</y><d>2017-03-09</d><h>00:11</h><w>bherrmann</w>well, it that old song of someone understanding how ANTLR v3 works and them leaving the company....</z><z id="t1489018616" t="bherrmann I’m working with a modified version of this http://www.antlr3.org/grammar/1209225566284/PLSQL3.g"><y>#</y><d>2017-03-09</d><h>00:16</h><w>bherrmann</w>I’m working with a modified version of this <a href="http://www.antlr3.org/grammar/1209225566284/PLSQL3.g" target="_blank">http://www.antlr3.org/grammar/1209225566284/PLSQL3.g</a></z><z id="t1489018654" t="bherrmann I should really read this https://tomassetti.me/antlr-mega-tutorial/"><y>#</y><d>2017-03-09</d><h>00:17</h><w>bherrmann</w>I should really read this <a href="https://tomassetti.me/antlr-mega-tutorial/" target="_blank">https://tomassetti.me/antlr-mega-tutorial/</a></z><z id="t1489018690" t="bherrmann although that page is ANTLR V4"><y>#</y><d>2017-03-09</d><h>00:18</h><w>bherrmann</w>although that page is ANTLR V4</z><z id="t1489018724" t="bherrmann I’m curious if the PLSQL3.g could easily be consumed by Instaparse"><y>#</y><d>2017-03-09</d><h>00:18</h><w>bherrmann</w>I’m curious if the PLSQL3.g could easily be consumed by Instaparse</z><z id="t1489018845" t="aengelberg The is_sql thing actually looks like something unique to ANTLR (not standard BNF)"><y>#</y><d>2017-03-09</d><h>00:20</h><w>aengelberg</w>The <code>is_sql</code> thing actually looks like something unique to ANTLR (not standard BNF)</z><z id="t1489018852" t="aengelberg i.e. setting local variables"><y>#</y><d>2017-03-09</d><h>00:20</h><w>aengelberg</w>i.e. setting local variables</z><z id="t1489019030" t="bherrmann yea, that is weird"><y>#</y><d>2017-03-09</d><h>00:23</h><w>bherrmann</w>yea, that is weird</z><z id="t1489019064" t="bherrmann we dont use the is_sql in our copy."><y>#</y><d>2017-03-09</d><h>00:24</h><w>bherrmann</w>we dont use the is_sql in our copy.</z><z id="t1489019298" t="bherrmann so the grammar has about 1600 lines (ours has around 2k)… They appear otherwise very similar"><y>#</y><d>2017-03-09</d><h>00:28</h><w>bherrmann</w>so the grammar has about 1600 lines (ours has around 2k)…   They appear otherwise very similar</z><z id="t1489531129" t="nathansmutz I&apos;m sure this is asked a lot; but I&apos;m not figuring out how to search it. Is there a standard way to get instaparse to pick grammar-fitting things out of a mess of other text? In text-mining, I&apos;ve used regular expressions to carve out the bits I want to parse; but that&apos;s pretty redundant. Starting and ending your grammar with an &lt;anything&gt; pattern is slow; and, I&apos;m sure, makes instaparser grind away on unnecessary work."><y>#</y><d>2017-03-14</d><h>22:38</h><w>nathansmutz</w>I&apos;m sure this is asked a lot; but I&apos;m not figuring out how to search it. 
Is there a standard way to get instaparse to pick grammar-fitting things out of a mess of other text? 

In text-mining, I&apos;ve used regular expressions to carve out the bits I want to parse; but that&apos;s pretty redundant.  Starting and ending your grammar with an &lt;anything&gt; pattern  is slow; and, I&apos;m sure, makes instaparser grind away on unnecessary work.</z><z id="t1489599139" t="aengelberg Instaparse only works on &quot;full parses&quot;, so adding &lt;anything&gt; is the only way to go."><y>#</y><d>2017-03-15</d><h>17:32</h><w>aengelberg</w>Instaparse only works on &quot;full parses&quot;, so adding <code>&lt;anything&gt;</code> is the only way to go.</z><z id="t1489599240" t="aengelberg @nathansmutz if adding &lt;#&apos;[\\s\\S]&apos;+&gt; (anything) is too slow, you could maybe (str/replace #&quot;things you definitely don&apos;t want to parse&quot; &quot;&quot;) beforehand"><y>#</y><d>2017-03-15</d><h>17:34</h><w>aengelberg</w>@nathansmutz if adding <code>&lt;#&apos;[\\s\\S]&apos;+&gt;</code> (anything) is too slow, you could maybe <code>(str/replace #&quot;things you definitely don&apos;t want to parse&quot; &quot;&quot;)</code> beforehand</z><z id="t1489599264" t="aengelberg so instaparse isn&apos;t churning through too much garbage"><y>#</y><d>2017-03-15</d><h>17:34</h><w>aengelberg</w>so instaparse isn&apos;t churning through too much garbage</z><z id="t1489768017" t="nathansmutz Thanks @aengelberg. I wonder if my &lt;anything&gt; was more complicated than that when I tried it. Hmm, there may be a useful project in &quot;parsing&quot; instaparse code into regex suitable for grabbing parsable chunks. I&apos;m pretty sure instaparse is generating regex on the backend; but the capture-groups would need some editing."><y>#</y><d>2017-03-17</d><h>16:26</h><w>nathansmutz</w>Thanks @aengelberg. I wonder if my &lt;anything&gt; was more complicated than that when I tried it.  
Hmm,  there may be a useful project in &quot;parsing&quot; instaparse code into regex suitable for grabbing parsable chunks.  I&apos;m pretty sure instaparse is generating regex on the backend; but the capture-groups would need some editing.</z><z id="t1489768172" t="hiredman that is not correct, instaparse parses context free langauges, which regexes cannot do"><y>#</y><d>2017-03-17</d><h>16:29</h><w>hiredman</w>that is not correct, instaparse parses context free langauges, which regexes cannot do</z><z id="t1489768213" t="hiredman (regular languages are a subset of context free languages)"><y>#</y><d>2017-03-17</d><h>16:30</h><w>hiredman</w>(regular languages are a subset of context free languages)</z><z id="t1489770671" t="nathansmutz @hiredman I think I see what you mean. The problems I&apos;ve been solving are probably simple enough that regex could define the same patterns. I suppose, getting into some real recursive stuff, it&apos;d be less easy to go from instaparse-code to regex that says &quot;grab a block of text that looks like this&quot;."><y>#</y><d>2017-03-17</d><h>17:11</h><w>nathansmutz</w>@hiredman  I think I see what you mean.  The problems I&apos;ve been solving are probably simple enough that regex could define the same patterns.   I suppose, getting into some real recursive stuff, it&apos;d be less easy to go from instaparse-code to regex that says &quot;grab a block of text that looks like this&quot;.</z><z id="t1491252554" t="wistb @aengelberg , I am trying instaparse against an IETF abnf ( https://tools.ietf.org/html/rfc7950 ). I am getting the error Parse error at line 92, column 44: &lt; URI in RFC 3986 &gt;"><y>#</y><d>2017-04-03</d><h>20:49</h><w>wistb</w>@aengelberg , I am trying instaparse against an IETF abnf (<a href="https://tools.ietf.org/html/rfc7950" target="_blank">https://tools.ietf.org/html/rfc7950</a> ). I am getting the error Parse error at line 92, column 44:
                         &lt; URI in RFC 3986 &gt;</z><z id="t1491252596" t="wistb and this is what I see at that location"><y>#</y><d>2017-04-03</d><h>20:49</h><w>wistb</w>and this is what I see at that location</z><z id="t1491252597" t="wistb uri-str = &lt; a string that matches the rule &gt; &lt; URI in RFC 3986 &gt;"><y>#</y><d>2017-04-03</d><h>20:49</h><w>wistb</w>uri-str             = &lt; a string that matches the rule &gt;
                         &lt; URI in RFC 3986 &gt;</z><z id="t1491252637" t="aengelberg &lt; a string that matches the rule &gt; isn&apos;t valid BNF. In that spec, it is used for prose that can only be understood by humans."><y>#</y><d>2017-04-03</d><h>20:50</h><w>aengelberg</w><code>&lt; a string that matches the rule &gt;</code> isn&apos;t valid BNF. In that spec, it is used for prose that can only be understood by humans.</z><z id="t1491252661" t="aengelberg In Instaparse we use &lt;abc&gt; completely differently, used to refer to the &quot;hidden&quot; version of the non-terminal abc ."><y>#</y><d>2017-04-03</d><h>20:51</h><w>aengelberg</w>In Instaparse we use <code>&lt;abc&gt;</code> completely differently, used to refer to the &quot;hidden&quot; version of the non-terminal <code>abc</code>.</z><z id="t1491253201" t="wistb thank you @aengelberg . I made a change and the parsing moved forward. Now, I am getting an error (in the last few pages of the grammar file, So, I am hoping the grammar is holding up well so far)"><y>#</y><d>2017-04-03</d><h>21:00</h><w>wistb</w>thank you @aengelberg . I made a change and the parsing moved forward. Now, I am getting an error (in the last few pages of the grammar file, So, I am hoping the grammar is holding up well so far)</z><z id="t1491253203" t="wistb CompilerException java.lang.RuntimeException: Error parsing grammar specification: Parse error at line 915, column 32: action-keyword = %s&quot;action&quot;"><y>#</y><d>2017-04-03</d><h>21:00</h><w>wistb</w>CompilerException java.lang.RuntimeException: Error parsing grammar specification:
Parse error at line 915, column 32:
   action-keyword           = %s&quot;action&quot;</z><z id="t1491253228" t="wistb I think the ietf doc wants to use &apos;non case sensitive&apos; form."><y>#</y><d>2017-04-03</d><h>21:00</h><w>wistb</w>I think the ietf doc wants to use &apos;non case sensitive&apos; form.</z><z id="t1491254693" t="aengelberg I don&apos;t think %s is valid ABNF per the spec, though I see what it&apos;s getting at, and it wouldn&apos;t be too hard to implement."><y>#</y><d>2017-04-03</d><h>21:24</h><w>aengelberg</w>I don&apos;t think <code>%s</code> is valid ABNF per the spec, though I see what it&apos;s getting at, and it wouldn&apos;t be too hard to implement.</z><z id="t1491254794" t="aengelberg If you&apos;re ok with case insensitive, you could just do &quot;action&quot;"><y>#</y><d>2017-04-03</d><h>21:26</h><w>aengelberg</w>If you&apos;re ok with case insensitive, you could just do <code>&quot;action&quot;</code></z><z id="t1491254801" t="wistb @aengelberg for now, I removed %s and moved on. It is getting close to the end of the file, but, I have this error :"><y>#</y><d>2017-04-03</d><h>21:26</h><w>wistb</w>@aengelberg for now, I removed %s and moved on. It is getting close to the end of the file, but, I have this error :</z><z id="t1491254806" t="aengelberg If you really want case sensitive, you could translate it to decimal or hex and use %d / %x"><y>#</y><d>2017-04-03</d><h>21:26</h><w>aengelberg</w>If you really want case sensitive, you could translate it to decimal or hex and use <code>%d</code> / <code>%x</code></z><z id="t1491254818" t="aengelberg You&apos;re going to want :input-format :abnf if you haven&apos;t set that already btw"><y>#</y><d>2017-04-03</d><h>21:26</h><w>aengelberg</w>You&apos;re going to want <code>:input-format :abnf</code> if you haven&apos;t set that already btw</z><z id="t1491254921" t="wistb CompilerException java.lang.RuntimeException: a occurs on the right-hand side of your grammar, but not on the left,"><y>#</y><d>2017-04-03</d><h>21:28</h><w>wistb</w>CompilerException java.lang.RuntimeException: a occurs on the right-hand side of your grammar, but not on the left,</z><z id="t1491254956" t="wistb I am invoking , like so,"><y>#</y><d>2017-04-03</d><h>21:29</h><w>wistb</w>I am invoking , like so,</z><z id="t1491254957" t="wistb (def my-parser (insta/parser ( http://clojure.java.io/resource &quot;my.abnf&quot;) :input-format :abnf :trace true))"><y>#</y><d>2017-04-03</d><h>21:29</h><w>wistb</w>(def my-parser
  (insta/parser (<a href="http://clojure.java.io/resource" target="_blank">http://clojure.java.io/resource</a> &quot;my.abnf&quot;)
                :input-format :abnf :trace true))</z><z id="t1491255021" t="wistb But, this time, I don&apos;t know which particular text is the culprit."><y>#</y><d>2017-04-03</d><h>21:30</h><w>wistb</w>But, this time, I don&apos;t know which particular text is the culprit.</z><z id="t1491255320" t="aengelberg hmm."><y>#</y><d>2017-04-03</d><h>21:35</h><w>aengelberg</w>hmm.</z><z id="t1491255332" t="aengelberg Only thing I can think of is there is a loose a or A somewhere..."><y>#</y><d>2017-04-03</d><h>21:35</h><w>aengelberg</w>Only thing I can think of is there is a loose <code>a</code> or <code>A</code> somewhere...</z><z id="t1491255369" t="aengelberg Or it&apos;s one of the &lt; a string that matches the rule &gt; "><y>#</y><d>2017-04-03</d><h>21:36</h><w>aengelberg</w>Or it&apos;s one of the <code>&lt; a string that matches the rule &gt; </code></z><z id="t1491255376" t="aengelberg and the a is the first of many invalid things in that expression."><y>#</y><d>2017-04-03</d><h>21:36</h><w>aengelberg</w>and the <code>a</code> is the first of many invalid things in that expression.</z><z id="t1491255434" t="wistb Let me see. I removed those kind of usages. May be there is still something lurking .."><y>#</y><d>2017-04-03</d><h>21:37</h><w>wistb</w>Let me see. I removed those kind of usages. May be there is still something lurking ..</z><z id="t1491255692" t="wistb @aengelberg .. great . that is the issue. one such usage got left out. I changed it, now, that parsing is completing without error. Thank you."><y>#</y><d>2017-04-03</d><h>21:41</h><w>wistb</w>@aengelberg .. great . that is the issue. one such usage got left out. I changed it, now, that parsing is completing without error.  Thank you.</z><z id="t1491255700" t="aengelberg sweet"><y>#</y><d>2017-04-03</d><h>21:41</h><w>aengelberg</w>sweet</z><z id="t1491255702" t="aengelberg np"><y>#</y><d>2017-04-03</d><h>21:41</h><w>aengelberg</w>np</z><z id="t1491255853" t="wistb I am not sure about the change I made (I dont know much about grammars), though .. I changed the text from yang-version-arg-str = &lt; a string that matches the rule &gt; &lt; yang-version-arg &gt; to yang-version-arg-str = yang-version-arg yang-version-arg = &quot;1.1&quot;"><y>#</y><d>2017-04-03</d><h>21:44</h><w>wistb</w>I am not sure about the change I made (I dont know much about grammars), though ..

I changed the text from

yang-version-arg-str = &lt; a string that matches the rule &gt;
                       &lt; yang-version-arg &gt;
to

yang-version-arg-str = yang-version-arg
yang-version-arg    = &quot;1.1&quot;</z><z id="t1491255905" t="wistb if that is correct, I wonder why the ietf folks did not do the same. As it is , the ietf abnf is not parseable, right."><y>#</y><d>2017-04-03</d><h>21:45</h><w>wistb</w>if that is correct, I wonder why the ietf folks did not do the same. As it is , the ietf abnf is not parseable, right.</z><z id="t1491256143" t="aengelberg I think some grammars are written with the intention of helping humans to write programs, rather than to be fed to parser generators like Instaparse."><y>#</y><d>2017-04-03</d><h>21:49</h><w>aengelberg</w>I think some grammars are written with the intention of helping humans to write programs, rather than to be fed to parser generators like Instaparse.</z><z id="t1491256154" t="aengelberg So they don&apos;t feel the need to exactly follow the ABNF spec."><y>#</y><d>2017-04-03</d><h>21:49</h><w>aengelberg</w>So they don&apos;t feel the need to exactly follow the ABNF spec.</z><z id="t1492212890" t="gmercer Hi - I was trying to use instaparse (clone from github) with lumo (or planck) I hit some issues (they are in the lumo channel) I am happy to cross-post but I thought it may be polite to not do so initially"><y>#</y><d>2017-04-14</d><h>23:34</h><w>gmercer</w>Hi - I was trying to use instaparse (clone from github) with lumo (or planck) 
I hit some issues (they are in the lumo channel) 
I am happy to cross-post but I thought it may be polite to not do so initially</z><z id="t1492215289" t="aengelberg Instaparse is known to be incompatible with bootstrapped cljs so I&apos;m not surprised :("><y>#</y><d>2017-04-15</d><h>00:14</h><w>aengelberg</w>Instaparse is known to be incompatible with bootstrapped cljs so I&apos;m not surprised :(</z><z id="t1492215314" t="aengelberg Specifically, the cljs version currently uses clj to do macro-time compile steps"><y>#</y><d>2017-04-15</d><h>00:15</h><w>aengelberg</w>Specifically, the cljs version currently uses clj to do macro-time compile steps</z><z id="t1492215364" t="aengelberg In theory, it doesn&apos;t have to do that logic on clj, but I don&apos;t know of an easy way to use reader conditionals, etc to write cross-compatible macros as opposed to functions"><y>#</y><d>2017-04-15</d><h>00:16</h><w>aengelberg</w>In theory, it doesn&apos;t have to do that logic on clj, but I don&apos;t know of an easy way to use reader conditionals, etc to write cross-compatible macros as opposed to functions</z><z id="t1492215725" t="gmercer cross compatible macros - thanks, now I have a focus .. soon instaparse will be bootstrapped cljs compatible 😃"><y>#</y><d>2017-04-15</d><h>00:22</h><w>gmercer</w><code>cross compatible macros</code> - thanks, now I have a focus .. soon instaparse will be bootstrapped cljs compatible <b>😃</b></z><z id="t1492216030" t="gmercer although the earlier issue regarding the reader eagerly compiling the regex would add a little bit of hairiness 😞"><y>#</y><d>2017-04-15</d><h>00:27</h><w>gmercer</w>although the earlier issue regarding the reader eagerly compiling the regex would add a little bit of hairiness <b>😞</b></z><z id="t1492216108" t="aengelberg Let me know if you need any assistance / explanations for some of the instaparse code"><y>#</y><d>2017-04-15</d><h>00:28</h><w>aengelberg</w>Let me know if you need any assistance / explanations for some of the instaparse code</z><z id="t1492216118" t="gmercer cheers"><y>#</y><d>2017-04-15</d><h>00:28</h><w>gmercer</w>cheers</z><z id="t1496753188" t="wilkerlucio hello people, I&apos;m stuck with a instaparse rule, maybe someone here can help me out 🙂"><y>#</y><d>2017-06-06</d><h>12:46</h><w>wilkerlucio</w>hello people, I&apos;m stuck with a instaparse rule, maybe someone here can help me out <b>🙂</b></z><z id="t1496753196" t="wilkerlucio I&apos;m writing a parser for Javascript regexes"><y>#</y><d>2017-06-06</d><h>12:46</h><w>wilkerlucio</w>I&apos;m writing a parser for Javascript regexes</z><z id="t1496753200" t="wilkerlucio this is the current grammar:"><y>#</y><d>2017-06-06</d><h>12:46</h><w>wilkerlucio</w>this is the current grammar:</z><z id="t1496753209" t="wilkerlucio Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag* Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)* Concatenation = SuffixedExpr* SuffixedExpr = SingleExpr Suffix? SingleExpr = BaseExpr | ParenthesizedExpr ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt; Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier? Optional = &lt;&apos;?&apos;&gt; Positive = &lt;&apos;+&apos;&gt; NonNegative = &lt;&apos;*&apos;&gt; CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt; Quantifier = &apos;?&apos; | &apos;+&apos; BaseExpr = CharExpr | LiteralChar | Anchor | BackReference Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot; LiteralChar = PlainChar | EscapedChar BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot; PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot; CharExpr = Dot | LiteralChar | BCC Dot = &apos;.&apos; BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt; BCCUnionLeft = BCCNegation? BCCElemBase* BCCNegation = &apos;^&apos; BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC BCCRangeRightable = BCCCharEndRange | SpecialCharClass BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable) BCCChar = BCCPlainChar | EscapedChar BCCCharEndRange = BCCPlainChar | EscapedChar BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos; EscapedChar = SpecialCharClass | NormalSlashedCharacters | ControlChar | HexChar | BasicEscapedChar HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos; MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt; VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt; BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot; SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot; NormalSlashedCharacters = #&quot;\\[tnrf]&quot; ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot; (** FLAGS **) GroupFlags = NonCapturingMatchFlags | PositiveLookAheadFlag | NegativeLookAheadFlag NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt; PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt; NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt; MatchFlag = #&quot;[gimuy]&quot; "><y>#</y><d>2017-06-06</d><h>12:46</h><w>wilkerlucio</w><pre>Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix?
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot | LiteralChar | BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass | NormalSlashedCharacters | ControlChar | HexChar | BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
</pre></z><z id="t1496753319" t="wilkerlucio I would like it to parse { , as a plain char, currently on the PlainChar definition this char is excluded to allow for the CurlyRepetition"><y>#</y><d>2017-06-06</d><h>12:48</h><w>wilkerlucio</w>I would like it to parse <code>{</code>, as a plain char, currently on the <code>PlainChar</code> definition this char is excluded to allow for the <code>CurlyRepetition</code></z><z id="t1496753327" t="wilkerlucio I&apos;m probably missing something"><y>#</y><d>2017-06-06</d><h>12:48</h><w>wilkerlucio</w>I&apos;m probably missing something</z><z id="t1496753341" t="wilkerlucio but if I allow the { at PlainChar"><y>#</y><d>2017-06-06</d><h>12:49</h><w>wilkerlucio</w>but if I allow the <code>{</code> at <code>PlainChar</code></z><z id="t1496753355" t="wilkerlucio then when I try to do: a{2}"><y>#</y><d>2017-06-06</d><h>12:49</h><w>wilkerlucio</w>then when I try to do: <code>a{2}</code></z><z id="t1496753386" t="wilkerlucio I was expect it to go into SuffixedExpr and match a PlainChar followed by a Suffix that would be a CurlyRepetition"><y>#</y><d>2017-06-06</d><h>12:49</h><w>wilkerlucio</w>I was expect it to go into <code>SuffixedExpr</code> and match a <code>PlainChar</code> followed by a <code>Suffix</code> that would be a <code>CurlyRepetition</code></z><z id="t1496753411" t="wilkerlucio but instead seems like it&apos;s not matching the suffix, and instead matches a series of plain chars"><y>#</y><d>2017-06-06</d><h>12:50</h><w>wilkerlucio</w>but instead seems like it&apos;s not matching the suffix, and instead matches a series of plain chars</z><z id="t1496753731" t="wilkerlucio sorry the noise, I got a much simplified version now, by this grammar:"><y>#</y><d>2017-06-06</d><h>12:55</h><w>wilkerlucio</w>sorry the noise, I got a much simplified version now, by this grammar:</z><z id="t1496753734" t="wilkerlucio Concatenation = SuffixedExpr* SuffixedExpr = LiteralChar CurlyRepetition? CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt; LiteralChar = #&quot;.&quot; "><y>#</y><d>2017-06-06</d><h>12:55</h><w>wilkerlucio</w><pre>Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition?

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;.&quot;
</pre></z><z id="t1496753782" t="wilkerlucio I expected it to match &quot;a{2}&quot; as a LiteralChar followed by a CurlyRepetition , but instead it matches as [:Concatenation [:SuffixedExpr [:LiteralChar &quot;a&quot;]] [:SuffixedExpr [:LiteralChar &quot;{&quot;]] [:SuffixedExpr [:LiteralChar &quot;2&quot;]] [:SuffixedExpr [:LiteralChar &quot;}&quot;]]]"><y>#</y><d>2017-06-06</d><h>12:56</h><w>wilkerlucio</w>I expected it to match <code>&quot;a{2}&quot;</code> as a <code>LiteralChar</code> followed by a <code>CurlyRepetition</code>, but instead it matches as <code>[:Concatenation [:SuffixedExpr [:LiteralChar &quot;a&quot;]] [:SuffixedExpr [:LiteralChar &quot;{&quot;]] [:SuffixedExpr [:LiteralChar &quot;2&quot;]] [:SuffixedExpr [:LiteralChar &quot;}&quot;]]]</code></z><z id="t1496753822" t="wilkerlucio how can make it try force match the CurlyRepetition before stepping a level up and matching more literal chars?"><y>#</y><d>2017-06-06</d><h>12:57</h><w>wilkerlucio</w>how can make it try force match the <code>CurlyRepetition</code> before stepping a level up and matching more literal chars?</z><z id="t1496764842" t="aengelberg @wilkerlucio maybe ordered choice / in instaparse might help here?"><y>#</y><d>2017-06-06</d><h>16:00</h><w>aengelberg</w>@wilkerlucio maybe ordered choice <code>/</code> in instaparse might help here?</z><z id="t1496764953" t="aengelberg so you want a{2 to parse as 3 PlainChars, but a{2} to parse as a PlainChar followed by a CurlyRepetition?"><y>#</y><d>2017-06-06</d><h>16:02</h><w>aengelberg</w>so you want <code>a{2</code> to parse as 3 PlainChars, but <code>a{2}</code> to parse as a PlainChar followed by a CurlyRepetition?</z><z id="t1496770461" t="wilkerlucio @aengelberg yes, with some help I was able to figure it out, here is a way to handle it:"><y>#</y><d>2017-06-06</d><h>17:34</h><w>wilkerlucio</w>@aengelberg yes, with some help I was able to figure it out, here is a way to handle it:</z><z id="t1496770463" t="wilkerlucio Concatenation = SuffixedExpr* SuffixedExpr = LiteralChar CurlyRepetition? / AnyLiteralChar CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt; LiteralChar = #&quot;[^{]&quot; AnyLiteralChar = #&quot;.&quot;"><y>#</y><d>2017-06-06</d><h>17:34</h><w>wilkerlucio</w><pre>Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition? / AnyLiteralChar

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;[^{]&quot;
AnyLiteralChar = #&quot;.&quot;</pre></z><z id="t1496770489" t="wilkerlucio I had to restrict the first one a little and have a second more permissive rule, now it parses the way I was expecting 🙂"><y>#</y><d>2017-06-06</d><h>17:34</h><w>wilkerlucio</w>I had to restrict the first one a little and have a second more permissive rule, now it parses the way I was expecting <b>🙂</b></z><z id="t1496770555" t="aengelberg I suggest you take away the ? after CurlyRepetition , to make the grammar unambiguous (improving performance)."><y>#</y><d>2017-06-06</d><h>17:35</h><w>aengelberg</w>I suggest you take away the <code>?</code> after <code>CurlyRepetition</code>, to make the grammar unambiguous (improving performance).</z><z id="t1496770610" t="wilkerlucio @aengelberg but it is needed there, because the curlyrepetition is optional"><y>#</y><d>2017-06-06</d><h>17:36</h><w>wilkerlucio</w>@aengelberg but it is needed there, because the curlyrepetition is optional</z><z id="t1496770636" t="wilkerlucio ah, I think I got you said, it would match anyway"><y>#</y><d>2017-06-06</d><h>17:37</h><w>wilkerlucio</w>ah, I think I got you said, it would match anyway</z><z id="t1496770644" t="wilkerlucio in my real case its a bit more complicated"><y>#</y><d>2017-06-06</d><h>17:37</h><w>wilkerlucio</w>in my real case its a bit more complicated</z><z id="t1496770659" t="wilkerlucio and the latest AnyLiteral actually just matches the { , otherwise other complications arise"><y>#</y><d>2017-06-06</d><h>17:37</h><w>wilkerlucio</w>and the latest AnyLiteral actually just matches the <code>{</code>, otherwise other complications arise</z><z id="t1496770677" t="wilkerlucio parsing regex is pretty annoying to be honest -.-"><y>#</y><d>2017-06-06</d><h>17:37</h><w>wilkerlucio</w>parsing regex is pretty annoying to be honest -.-</z><z id="t1496770684" t="aengelberg lol yeah"><y>#</y><d>2017-06-06</d><h>17:38</h><w>aengelberg</w>lol yeah</z><z id="t1496770701" t="aengelberg also, something to watch out for: . does not include the newline character"><y>#</y><d>2017-06-06</d><h>17:38</h><w>aengelberg</w>also, something to watch out for: <code>.</code> does not include the newline character</z><z id="t1496770713" t="aengelberg but [^{] does"><y>#</y><d>2017-06-06</d><h>17:38</h><w>aengelberg</w>but <code>[^{]</code> does</z><z id="t1496770734" t="wilkerlucio yeah, when I need everything I like to use something like [\s\S]"><y>#</y><d>2017-06-06</d><h>17:38</h><w>wilkerlucio</w>yeah, when I need everything I like to use something like <code>[\s\S]</code></z><z id="t1496770737" t="wilkerlucio so it matches everything"><y>#</y><d>2017-06-06</d><h>17:38</h><w>wilkerlucio</w>so it matches everything</z><z id="t1496770748" t="aengelberg that’s exactly what I was going to suggest"><y>#</y><d>2017-06-06</d><h>17:39</h><w>aengelberg</w>that’s exactly what I was going to suggest</z><z id="t1496770756" t="wilkerlucio in case you wonder, this is what my current grammar looks like (for parsing JS RegExp):"><y>#</y><d>2017-06-06</d><h>17:39</h><w>wilkerlucio</w>in case you wonder, this is what my current grammar looks like (for parsing JS RegExp):</z><z id="t1496770760" t="wilkerlucio Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag* Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)* Concatenation = SuffixedExpr* SuffixedExpr = SingleExpr Suffix? / CurlyRepetition / LiteralSpecialChar SingleExpr = BaseExpr | ParenthesizedExpr ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt; Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier? Optional = &lt;&apos;?&apos;&gt; Positive = &lt;&apos;+&apos;&gt; NonNegative = &lt;&apos;*&apos;&gt; CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt; Quantifier = &apos;?&apos; | &apos;+&apos; BaseExpr = CharExpr | LiteralChar | Anchor | BackReference Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot; LiteralChar = PlainChar | EscapedChar LiteralSpecialChar = &apos;{&apos; BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot; PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot; CharExpr = Dot / LiteralChar / BCCEmpty / BCC Dot = &apos;.&apos; BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt; BCCEmpty = &apos;[]&apos; BCCUnionLeft = BCCNegation? BCCElemBase* BCCNegation = &apos;^&apos; BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC BCCRangeRightable = BCCCharEndRange | SpecialCharClass BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable) BCCChar = BCCPlainChar | EscapedChar BCCCharEndRange = BCCPlainChar | EscapedChar BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos; EscapedChar = SpecialCharClass / NormalSlashedCharacters / ControlChar / HexChar / BasicEscapedChar HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos; MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt; VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt; BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot; SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot; NormalSlashedCharacters = #&quot;\\[tnrf]&quot; ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot; (** FLAGS **) GroupFlags = NonCapturingMatchFlags | PositiveLookAheadFlag | NegativeLookAheadFlag NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt; PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt; NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt; MatchFlag = #&quot;[gimuy]&quot; "><y>#</y><d>2017-06-06</d><h>17:39</h><w>wilkerlucio</w><pre>Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix? / CurlyRepetition / LiteralSpecialChar
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar
LiteralSpecialChar = &apos;{&apos;

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot / LiteralChar / BCCEmpty / BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;
BCCEmpty = &apos;[]&apos;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass / NormalSlashedCharacters / ControlChar / HexChar / BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
</pre></z><z id="t1496770824" t="wilkerlucio it doesn&apos;t need to be perfect, the usage of this is to port the test.chuck string-from-regex to CLJS"><y>#</y><d>2017-06-06</d><h>17:40</h><w>wilkerlucio</w>it doesn&apos;t need to be perfect, the usage of this is to port the <code>test.chuck</code> <code>string-from-regex</code> to CLJS</z><z id="t1496770840" t="aengelberg gfredericks has already done work in test.chuck to parse Java regexes in instaparse, which may be useful: https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf"><y>#</y><d>2017-06-06</d><h>17:40</h><w>aengelberg</w>gfredericks has already done work in <code>test.chuck</code> to parse Java regexes in instaparse, which may be useful: <a href="https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf" target="_blank">https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf</a></z><z id="t1496770855" t="wilkerlucio yeah, this is actually based of that"><y>#</y><d>2017-06-06</d><h>17:40</h><w>wilkerlucio</w>yeah, this is actually based of that</z><z id="t1496770861" t="wilkerlucio I&apos;m trying to port it to CLJS"><y>#</y><d>2017-06-06</d><h>17:41</h><w>wilkerlucio</w>I&apos;m trying to port it to CLJS</z><z id="t1496770866" t="aengelberg oh lol, you’re right, I just needed to look closer"><y>#</y><d>2017-06-06</d><h>17:41</h><w>aengelberg</w>oh lol, you’re right, I just needed to look closer</z><z id="t1496770875" t="aengelberg you’re porting test.chuck to cljs?"><y>#</y><d>2017-06-06</d><h>17:41</h><w>aengelberg</w>you’re porting test.chuck to cljs?</z><z id="t1496770880" t="aengelberg or just the regex generator?"><y>#</y><d>2017-06-06</d><h>17:41</h><w>aengelberg</w>or just the regex generator?</z><z id="t1496770893" t="wilkerlucio just the regex generator, the rest is already all cljc actually"><y>#</y><d>2017-06-06</d><h>17:41</h><w>wilkerlucio</w>just the regex generator, the rest is already all <code>cljc</code> actually</z><z id="t1496770902" t="aengelberg ok this explains a lot 🙂"><y>#</y><d>2017-06-06</d><h>17:41</h><w>aengelberg</w>ok this explains a lot <b>🙂</b></z><z id="t1496770946" t="aengelberg so then how did you get the grammar into a weird state that behaved improperly with curly repetitions, just by removing certain things not part of the EcmaScript regex spec?"><y>#</y><d>2017-06-06</d><h>17:42</h><w>aengelberg</w>so then how did you get the grammar into a weird state that behaved improperly with curly repetitions, just by removing certain things not part of the EcmaScript regex spec?</z><z id="t1496770954" t="aengelberg or was it already like that?"><y>#</y><d>2017-06-06</d><h>17:42</h><w>aengelberg</w>or was it already like that?</z><z id="t1496770984" t="wilkerlucio the Java Regex have many different features compared to JS one"><y>#</y><d>2017-06-06</d><h>17:43</h><w>wilkerlucio</w>the Java Regex have many different features compared to JS one</z><z id="t1496771002" t="aengelberg hmm I was under the impression that Java had a super-set of features to JS"><y>#</y><d>2017-06-06</d><h>17:43</h><w>aengelberg</w>hmm I was under the impression that Java had a super-set of features to JS</z><z id="t1496771006" t="aengelberg clearly I was mistaken"><y>#</y><d>2017-06-06</d><h>17:43</h><w>aengelberg</w>clearly I was mistaken</z><z id="t1496771014" t="wilkerlucio no, JS is more tolerant in some cases"><y>#</y><d>2017-06-06</d><h>17:43</h><w>wilkerlucio</w>no, JS is more tolerant in some cases</z><z id="t1496771034" t="wilkerlucio for example, those are invalid on JVM, but ok on JS: /a{/ /a{}/ /[]/"><y>#</y><d>2017-06-06</d><h>17:43</h><w>wilkerlucio</w>for example, those are invalid on JVM, but ok on JS: <code>/a{/</code> <code>/a{}/</code> <code>/[]/</code></z><z id="t1496771060" t="wilkerlucio when JS sees an incomplete curly braces, it threats as literals"><y>#</y><d>2017-06-06</d><h>17:44</h><w>wilkerlucio</w>when JS sees an incomplete curly braces, it threats as literals</z><z id="t1496771067" t="wilkerlucio where JVM throws an exception"><y>#</y><d>2017-06-06</d><h>17:44</h><w>wilkerlucio</w>where JVM throws an exception</z><z id="t1496771116" t="wilkerlucio but in general the JS is simpler, since it doens&apos;t support character class unions (that feature adds a lot of complexity on the JVM Regex grammar, see: https://www.regular-expressions.info/charclassintersect.html )"><y>#</y><d>2017-06-06</d><h>17:45</h><w>wilkerlucio</w>but in general the JS is simpler, since it doens&apos;t support character class unions (that feature adds a lot of complexity on the JVM Regex grammar, see: <a href="https://www.regular-expressions.info/charclassintersect.html" target="_blank">https://www.regular-expressions.info/charclassintersect.html</a>)</z><z id="t1496771136" t="wilkerlucio so, this is the kind of feature that has a strong dependency on the platform"><y>#</y><d>2017-06-06</d><h>17:45</h><w>wilkerlucio</w>so, this is the kind of feature that has a strong dependency on the platform</z><z id="t1496771231" t="wilkerlucio Gary did a great job making generative testing to check if the custom parser conforms with the platform regex parser, check this test: https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119"><y>#</y><d>2017-06-06</d><h>17:47</h><w>wilkerlucio</w>Gary did a great job making generative testing to check if the custom parser conforms with the platform regex parser, check this test: <a href="https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119" target="_blank">https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119</a></z><z id="t1496771258" t="wilkerlucio it generates random regexs and try to parse it with custom and native regex parsers, and they have to conform (all fail or all pass)"><y>#</y><d>2017-06-06</d><h>17:47</h><w>wilkerlucio</w>it generates random regexs and try to parse it with custom and native regex parsers, and they have to conform (all fail or all pass)</z><z id="t1496771283" t="wilkerlucio it&apos;s just very hard to get the grammar to work exactly like the native one, with all quirks dealt with"><y>#</y><d>2017-06-06</d><h>17:48</h><w>wilkerlucio</w>it&apos;s just very hard to get the grammar to work exactly like the native one, with all quirks dealt with</z><z id="t1498017749" t="fabrao Hello all, how can I make something like (def parser (insta/parser &quot;regra = &lt;&apos;filtro&apos;&gt; &lt;ws&gt; elemento+ elemento = operador &lt;ws&gt; operando operador = (&apos;origem&apos;) operando = #&apos;[a-zA-Z0-9\\-]([0-9a-zA-Z\\-]*)&apos; ws = #&apos;\\s+&apos;&quot;)) (parser &quot;filtro origem 001-ARTICO origem 011-BALDACCI&quot;) what´s wrong?"><y>#</y><d>2017-06-21</d><h>04:02</h><w>fabrao</w>Hello all, how can I make something like
<pre>(def parser
  (insta/parser &quot;regra = &lt;&apos;filtro&apos;&gt; &lt;ws&gt; elemento+
                elemento = operador &lt;ws&gt; operando
                operador = (&apos;origem&apos;)
                operando = #&apos;[a-zA-Z0-9\\-]([0-9a-zA-Z\\-]*)&apos;
                ws = #&apos;\\s+&apos;&quot;))
(parser &quot;filtro 
        origem 001-ARTICO 
        origem 011-BALDACCI&quot;)

</pre> what´s wrong?</z><z id="t1498043493" t="gfredericks @fabrao looks like the grammar doesn&apos;t allow whitespace in between elemento s"><y>#</y><d>2017-06-21</d><h>11:11</h><w>gfredericks</w>@fabrao looks like the grammar doesn&apos;t allow whitespace in between <code>elemento</code>s</z><z id="t1498077931" t="aengelberg ^"><y>#</y><d>2017-06-21</d><h>20:45</h><w>aengelberg</w>^</z><z id="t1498264911" t="wistb test"><y>#</y><d>2017-06-24</d><h>00:41</h><w>wistb</w>test</z><z id="t1498264932" t="wistb hi, beginner question."><y>#</y><d>2017-06-24</d><h>00:42</h><w>wistb</w>hi, beginner question.</z><z id="t1498264938" t="wistb (def abc-parser (insta/parser ( http://clojure.java.io/resource &quot;grammars/abc.abnf&quot;) :input-format :abnf :trace true :output-format :enlive)) ;;:auto-whitespace whitespace))"><y>#</y><d>2017-06-24</d><h>00:42</h><w>wistb</w>(def abc-parser
  (insta/parser (<a href="http://clojure.java.io/resource" target="_blank">http://clojure.java.io/resource</a> &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive))
                ;;:auto-whitespace whitespace))</z><z id="t1498264977" t="wistb if I enable the whitespace option , I am getting a copile error when I run &apos;lein run&apos;."><y>#</y><d>2017-06-24</d><h>00:42</h><w>wistb</w>if I enable the whitespace option , I am getting a copile error when I run &apos;lein run&apos;.</z><z id="t1498264997" t="wistb like this :"><y>#</y><d>2017-06-24</d><h>00:43</h><w>wistb</w>like this :</z><z id="t1498264998" t="wistb (def abc-parser (insta/parser ( http://clojure.java.io/resource &quot;grammars/abc.abnf&quot;) :input-format :abnf :trace true :output-format :enlive :auto-whitespace whitespace))"><y>#</y><d>2017-06-24</d><h>00:43</h><w>wistb</w>(def abc-parser
  (insta/parser (<a href="http://clojure.java.io/resource" target="_blank">http://clojure.java.io/resource</a> &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive
                :auto-whitespace whitespace))</z><z id="t1498265037" t="wistb same problem if I used :auto-whitespace :standard"><y>#</y><d>2017-06-24</d><h>00:43</h><w>wistb</w>same problem if I used :auto-whitespace :standard</z><z id="t1498265195" t="wistb Caused by: java.lang.IllegalArgumentException: No matching clause: :char at instaparse.combinators_source$auto_whitespace_parser.invokeStatic(combinators_source.clj:163) at instaparse.combinators_source$auto_whitespace_parser.invoke(combinators_source.clj:162) at instaparse.combinators_source$auto_whitespace$iter__426__430$fn__431.invoke(combinators_source.clj:184)"><y>#</y><d>2017-06-24</d><h>00:46</h><w>wistb</w>Caused by: java.lang.IllegalArgumentException: No matching clause: :char
	at instaparse.combinators_source$auto_whitespace_parser.invokeStatic(combinators_source.clj:163)
	at instaparse.combinators_source$auto_whitespace_parser.invoke(combinators_source.clj:162)
	at instaparse.combinators_source$auto_whitespace$iter__426__430$fn__431.invoke(combinators_source.clj:184)</z><z id="t1499247865" t="matan With instaparse, how do you elegantly match any sequence of characters up until a specific sequence of characters?"><y>#</y><d>2017-07-05</d><h>09:44</h><w>matan</w>With instaparse, how do you elegantly match any sequence of characters up until a specific sequence of characters?</z><z id="t1499248474" t="matan Currently I do that in a cumbersome way, given the impedence mismatch between grammars and regular expressions: WrappedLabel = UnderscorePair Word UnderscorePair UnderscorePair = &quot;__&quot; Word = #&quot;.+(?=__)&quot; (* a valid word is hereby contrained to anything that does not include an UnderScorePair *) "><y>#</y><d>2017-07-05</d><h>09:54</h><w>matan</w>Currently I do that in a cumbersome way, given the impedence mismatch between grammars and regular expressions:

<pre>WrappedLabel = UnderscorePair Word UnderscorePair
UnderscorePair = &quot;__&quot;
Word = #&quot;.+(?=__)&quot; (* a valid word is hereby contrained to anything that does not include an UnderScorePair *)
</pre></z><z id="t1499248508" t="matan __ appears both as a grammar definition (`UnderscorePair`) as well as serving as a stop expression in the regex"><y>#</y><d>2017-07-05</d><h>09:55</h><w>matan</w><code>__</code> appears both as a grammar definition (`UnderscorePair`) as well as serving as a stop expression in the regex</z><z id="t1499248562" t="matan 🤔 I am curious in case there&apos;s a solution I&apos;ve not thought of"><y>#</y><d>2017-07-05</d><h>09:56</h><w>matan</w><b>🤔</b> I am curious in case there&apos;s a solution I&apos;ve not thought of</z><z id="t1499248626" t="matan The above is supposed to catch and parse anything of the form __foo__ , so that foo can be extracted (as part of a larger parse the details of which are quite plain and uninteresting)"><y>#</y><d>2017-07-05</d><h>09:57</h><w>matan</w>The above is supposed to catch and parse anything of the form <code>__foo__</code>, so that <code>foo</code> can be extracted (as part of a larger parse the details of which are quite plain and uninteresting)</z><z id="t1499271211" t="aengelberg @matan that&apos;s how I would do it. I&apos;m not aware of a more elegant or efficient solution, besides making the underscore pairs part of the regex."><y>#</y><d>2017-07-05</d><h>16:13</h><w>aengelberg</w>@matan that&apos;s how I would do it. I&apos;m not aware of a more elegant or efficient solution, besides making the underscore pairs part of the regex.</z><z id="t1499360473" t="matan @aengelberg many thanks for the confirmation! of course, it stems from the difference between what regular expression language is and what grammars are, not from how instaparse works doesn&apos;t it 🙂 Would you agree to this?"><y>#</y><d>2017-07-06</d><h>17:01</h><w>matan</w>@aengelberg many thanks for the confirmation! of course, it stems from the difference between what regular expression language is and what grammars are, not from how instaparse works doesn&apos;t it <b>🙂</b> Would you agree to this?</z><z id="t1499360746" t="aengelberg You mean regexes’ greediness? I would say that’s an artifact of regexes’ supported use case not matching what Instaparse needs it to do. If regexes had a way to lazily emit multiple parse results of the same string, we could maybe use that to make regex non-terminals behave more intuitively."><y>#</y><d>2017-07-06</d><h>17:05</h><w>aengelberg</w>You mean regexes’ greediness? I would say that’s an artifact of regexes’ supported use case not matching what Instaparse needs it to do. If regexes had a way to lazily emit multiple parse results of the same string, we could maybe use that to make regex non-terminals behave more intuitively.</z><z id="t1499360927" t="aengelberg e.g. if I match #&quot;^a+&quot; on &quot;aaa&quot; I’d like to see &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;"><y>#</y><d>2017-07-06</d><h>17:08</h><w>aengelberg</w>e.g. if I match <code>#&quot;^a+&quot;</code> on <code>&quot;aaa&quot;</code> I’d like to see <code>&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></z><z id="t1499361015" t="matan Yes, well, at a higher level, regular expressions and grammars generate disparate automatons, whereas what you mention is one difference in the detail thereof (the most relevant one). This relates to two area I&apos;m lately looking at ― fuzzy parsing and scannerless parsing"><y>#</y><d>2017-07-06</d><h>17:10</h><w>matan</w>Yes, well, at a higher level, regular expressions and grammars generate disparate automatons, whereas what you mention is one difference in the detail thereof (the most relevant one). This relates to two area I&apos;m lately looking at ― fuzzy parsing and scannerless parsing</z><z id="t1499361047" t="matan As to regex, have you ever used something like this? https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches"><y>#</y><d>2017-07-06</d><h>17:10</h><w>matan</w>As to regex, have you ever used something like this?
<a href="https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches" target="_blank">https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches</a></z><z id="t1499361104" t="matan Oh, not really, ignore that last one"><y>#</y><d>2017-07-06</d><h>17:11</h><w>matan</w>Oh, not really, ignore that last one</z><z id="t1499361137" t="aengelberg That’s returning one match for each of a variety of starting indexes, which is not quite what I want"><y>#</y><d>2017-07-06</d><h>17:12</h><w>aengelberg</w>That’s returning one match for each of a variety of starting indexes, which is not quite what I want</z><z id="t1499361156" t="matan Yes, again, ignore that"><y>#</y><d>2017-07-06</d><h>17:12</h><w>matan</w>Yes, again, ignore that</z><z id="t1499361188" t="aengelberg You could theoretically do (for [i (range (count s))] (re-match re (subs s 0 i)))"><y>#</y><d>2017-07-06</d><h>17:13</h><w>aengelberg</w>You could theoretically do <code>(for [i (range (count s))] (re-match re (subs s 0 i)))</code></z><z id="t1499361203" t="aengelberg but that is super slow and might not actually work depending on the regex"><y>#</y><d>2017-07-06</d><h>17:13</h><w>aengelberg</w>but that is super slow and might not actually work depending on the regex</z><z id="t1499361322" t="aengelberg the automaton structure of regexes is simply not designed to (efficiently) reason about the set of all possible matches for one string, using backtracking and laziness"><y>#</y><d>2017-07-06</d><h>17:15</h><w>aengelberg</w>the automaton structure of regexes is simply not designed to (efficiently) reason about the set of all possible matches for one string, using backtracking and laziness</z><z id="t1499361353" t="aengelberg actually maybe if you compile a NDFA"><y>#</y><d>2017-07-06</d><h>17:15</h><w>aengelberg</w>actually maybe if you compile a NDFA</z><z id="t1499361362" t="aengelberg then run it through one character at a time"><y>#</y><d>2017-07-06</d><h>17:16</h><w>aengelberg</w>then run it through one character at a time</z><z id="t1499361416" t="aengelberg and mark every time you are in a success state"><y>#</y><d>2017-07-06</d><h>17:16</h><w>aengelberg</w>and mark every time you are in a success state</z><z id="t1499361903" t="matan The interaction of a grammar with the need to account for syntactic categories (a.k.a variables, and/or non-terminals) that translate to non-finite sets of productions is very interesting. Right now, we typically &quot;escape&quot; to regular expressions for that. Of course, this goes beyond the scope of my original question with its particular silly use case."><y>#</y><d>2017-07-06</d><h>17:25</h><w>matan</w>The interaction of a grammar with the need to account for syntactic categories (a.k.a variables, and/or non-terminals) that translate to non-finite sets of productions is very interesting. Right now, we typically &quot;escape&quot; to regular expressions for that. Of course, this goes beyond the scope of my original question with its particular silly use case.</z><z id="t1499362031" t="aengelberg In this case, the set of productions is not infinite; for the current index i , all I really need to know is, the set of indexes j \in [0,N) such that s[i:j] is a complete parse according to the regex."><y>#</y><d>2017-07-06</d><h>17:27</h><w>aengelberg</w>In this case, the set of productions is not infinite; for the current index <code>i</code>, all I really need to know is, the set of indexes <code>j \in [0,N)</code> such that <code>s[i:j]</code> is a complete parse according to the regex.</z><z id="t1499362162" t="matan Right, obviously, when looking at a specific input text (or string)."><y>#</y><d>2017-07-06</d><h>17:29</h><w>matan</w>Right, obviously, when looking at a specific input text (or string).</z><z id="t1499362333" t="matan But in the general sense, I also meant to say that we use regular expressions for where we want to stipulate a non-finite set, whereas a plain CFG doesn&apos;t provide (IIRC) that kind of support, which is why we use regex along with it. I have to refresh and brush up more on formal languages though, maybe what I just said is totally incorrect, or just sufficiently inaccurate to be incorrect."><y>#</y><d>2017-07-06</d><h>17:32</h><w>matan</w>But in the general sense, I also meant to say that we use regular expressions for where we want to stipulate a non-finite set, whereas a plain CFG doesn&apos;t provide (IIRC) that kind of support, which is why we use regex along with it. I have to refresh and brush up more on formal languages though, maybe what I just said is totally incorrect, or just sufficiently inaccurate to be incorrect.</z><z id="t1499701941" t="mrchance Hi! In Instaparse, how do I specify operator precedence... I tried ordered choice, but it doesn&apos;t do what I want. Simple example: (def tp (insta/parser &quot; s = expression &lt;expression&gt; = binop / integer integer = #&apos;[0-9]+&apos; &lt;binop&gt; = times / plus times = expression &lt;&apos;*&apos;&gt; expression plus = expression &lt;&apos;+&apos;&gt; expression&quot; :auto-whitespace whitespace)) parser&gt; (tp &quot;5 + 3 * 7&quot;) [:s [:times [:plus [:integer &quot;5&quot;] [:integer &quot;3&quot;]] [:integer &quot;7&quot;]]] I have seen solutions that distinguish between add-expression and mul-expression, but that doesn&apos;t scale very well for more operators"><y>#</y><d>2017-07-10</d><h>15:52</h><w>mrchance</w>Hi! In Instaparse, how do I specify operator precedence... I tried ordered choice, but it doesn&apos;t do what I want. Simple example:
<pre>(def tp (insta/parser &quot;
s = expression
&lt;expression&gt; = binop / integer
integer = #&apos;[0-9]+&apos;
&lt;binop&gt; = times / plus
times = expression &lt;&apos;*&apos;&gt; expression
plus = expression &lt;&apos;+&apos;&gt; expression&quot;
                      :auto-whitespace whitespace))

parser&gt; (tp &quot;5 + 3 * 7&quot;)
[:s [:times [:plus [:integer &quot;5&quot;] [:integer &quot;3&quot;]] [:integer &quot;7&quot;]]]
</pre>
I have seen solutions that distinguish between add-expression and mul-expression, but that doesn&apos;t scale very well for more operators</z><z id="t1499702062" t="aengelberg Ordered choice only works when considering parses available at a given position, not when ranking this parse here over another parse over there."><y>#</y><d>2017-07-10</d><h>15:54</h><w>aengelberg</w>Ordered choice only works when considering parses available at a given position, not when ranking this parse here over another parse over there.</z><z id="t1499702119" t="aengelberg So in your example, your binop / integer was making it try 5 + 3 before 5"><y>#</y><d>2017-07-10</d><h>15:55</h><w>aengelberg</w>So in your example, your <code>binop / integer</code> was making it try <code>5 + 3</code> before <code>5</code></z><z id="t1499703994" t="mrchance ah, so I can fix it by making expression unordered? Or what&apos;s the best way?"><y>#</y><d>2017-07-10</d><h>16:26</h><w>mrchance</w>ah, so I can fix it by making expression unordered? Or what&apos;s the best way?</z><z id="t1499704205" t="aengelberg I don&apos;t think ordered choice is the best tool for &quot;order of operations&quot;... I&apos;ll send you another example in a sec"><y>#</y><d>2017-07-10</d><h>16:30</h><w>aengelberg</w>I don&apos;t think ordered choice is the best tool for &quot;order of operations&quot;... I&apos;ll send you another example in a sec</z><z id="t1499704344" t="mrchance Thanks!"><y>#</y><d>2017-07-10</d><h>16:32</h><w>mrchance</w>Thanks!</z><z id="t1499704599" t="aengelberg @mrchance check out the arithmetic expr parser in https://github.com/engelberg/instaparse#transforming-the-tree"><y>#</y><d>2017-07-10</d><h>16:36</h><w>aengelberg</w>@mrchance check out the arithmetic expr parser in <a href="https://github.com/engelberg/instaparse#transforming-the-tree" target="_blank">https://github.com/engelberg/instaparse#transforming-the-tree</a></z><z id="t1499704623" t="mrchance Thanks, I&apos;ll check it out"><y>#</y><d>2017-07-10</d><h>16:37</h><w>mrchance</w>Thanks, I&apos;ll check it out</z><z id="t1499704648" t="aengelberg notice how no ordered choice is necessary, because the grammar is structured so that the order of operations follows naturally"><y>#</y><d>2017-07-10</d><h>16:37</h><w>aengelberg</w>notice how no ordered choice is necessary, because the grammar is structured so that the order of operations follows naturally</z><z id="t1499705696" t="mrchance hm, ok, but my impression is that would get unwieldy when there is more operators. I&apos;ll give it a try though, I don&apos;t have that many 😉"><y>#</y><d>2017-07-10</d><h>16:54</h><w>mrchance</w>hm, ok, but my impression is that would get unwieldy when there is more operators. I&apos;ll give it a try though, I don&apos;t have that many <b>😉</b></z><z id="t1499705733" t="aengelberg perhaps. not sure."><y>#</y><d>2017-07-10</d><h>16:55</h><w>aengelberg</w>perhaps. not sure.</z><z id="t1499705875" t="aengelberg Here’s a potentially more elegant way of expressing it (not sure if this actually works): expr = add-sub add-sub = mul-div ((&apos;+&apos; | &apos;-&apos;) mul-div)* mul-div = term ((&apos;*&apos; | &apos;/&apos;) term)* term = number | &lt;&apos;(&apos;&gt; add-sub &lt;&apos;)&apos;&gt; "><y>#</y><d>2017-07-10</d><h>16:57</h><w>aengelberg</w>Here’s a potentially more elegant way of expressing it (not sure if this actually works):
<pre>expr = add-sub
add-sub = mul-div ((&apos;+&apos; | &apos;-&apos;) mul-div)*
mul-div = term ((&apos;*&apos; | &apos;/&apos;) term)*
term = number | &lt;&apos;(&apos;&gt; add-sub &lt;&apos;)&apos;&gt;
</pre></z><z id="t1499707964" t="mrchance hmm, wouldn&apos;t this disallow top level multiplication terms?"><y>#</y><d>2017-07-10</d><h>17:32</h><w>mrchance</w>hmm, wouldn&apos;t this disallow top level multiplication terms?</z><z id="t1499708027" t="mrchance I am already wishing I had given my own language a lisp syntax 😉"><y>#</y><d>2017-07-10</d><h>17:33</h><w>mrchance</w>I am already wishing I had given my own language a lisp syntax <b>😉</b></z><z id="t1499714556" t="aengelberg @mrchance no, it would end up as [:expr [:add-sub [:mul-div &quot;1&quot; &quot;*&quot; &quot;2&quot;]]]"><y>#</y><d>2017-07-10</d><h>19:22</h><w>aengelberg</w>@mrchance no, it would end up as <code>[:expr [:add-sub [:mul-div &quot;1&quot; &quot;*&quot; &quot;2&quot;]]]</code></z><z id="t1499728146" t="mrchance right 🙂 It worked, btw. For the Moment it&apos;s still quite manageable too. Thanks for the fast replies!"><y>#</y><d>2017-07-10</d><h>23:09</h><w>mrchance</w>right <b>🙂</b> It worked, btw. For the Moment it&apos;s still quite manageable too. Thanks for the fast replies!</z><z id="t1499880387" t="fabrao Hello all, how to I parse any kind of char in this: Groups: CN=THIAGO VITOR COSTA,OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS DO DOMÃ­NIO,CN=USERS,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES_CN,OU=GRUPOS,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS,CN=BUILTIN,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES,OU=GRUPOS,DC=DOM,DC=COM,DC=BR ? The Groups: is reserved and the rest is the capture information"><y>#</y><d>2017-07-12</d><h>17:26</h><w>fabrao</w>Hello all, how to I parse any kind of char in this: <code>Groups: CN=THIAGO VITOR COSTA,OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS DO DOMÃ­NIO,CN=USERS,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES_CN,OU=GRUPOS,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS,CN=BUILTIN,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES,OU=GRUPOS,DC=DOM,DC=COM,DC=BR</code>? The Groups: is reserved and the rest is the capture information</z><z id="t1503031677" t="bbss I&apos;m trying to parse Google&apos;s protobuf with Instaparse, but I can&apos;t find a recent file with it&apos;s EBNF spec."><y>#</y><d>2017-08-18</d><h>04:47</h><w>bbss</w>I&apos;m trying to parse Google&apos;s protobuf with Instaparse, but I can&apos;t find a recent file with it&apos;s EBNF spec.</z><z id="t1503031705" t="bbss https://developers.google.com/protocol-buffers/docs/reference/proto3-spec I&apos;ve copied all the bits from this site, but some lines are giving errors when I try to parse them."><y>#</y><d>2017-08-18</d><h>04:48</h><w>bbss</w><a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec" target="_blank">https://developers.google.com/protocol-buffers/docs/reference/proto3-spec</a>
I&apos;ve copied all the bits from this site, but some lines are giving errors when I try to parse them.</z><z id="t1503031751" t="bbss Is instaparse compatible with what they put in there? For example I see they use = where other files often seem to have :: == ."><y>#</y><d>2017-08-18</d><h>04:49</h><w>bbss</w>Is instaparse compatible with what they put in there? For example I see they use <code>=</code> where other files often seem to have <code>:: ==</code>.</z><z id="t1503031919" t="bbss Ah, I just noticed the escape sequence part of the readme, let me look into that."><y>#</y><d>2017-08-18</d><h>04:51</h><w>bbss</w>Ah, I just noticed the escape sequence part of the readme, let me look into that.</z><z id="t1503038164" t="bbss ah I notice it&apos;s been discussed here before: https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html"><y>#</y><d>2017-08-18</d><h>06:36</h><w>bbss</w>ah I notice it&apos;s been discussed here before:
<a href="https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html" target="_blank">https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html</a></z><z id="t1503038362" t="bbss @frank did you perhaps end up succeeding parsing that spec? Can&apos;t find any more discussion in further dates on the clojureverse.."><y>#</y><d>2017-08-18</d><h>06:39</h><w>bbss</w>@frank did you perhaps end up succeeding parsing that spec? Can&apos;t find any more discussion in further dates on the clojureverse..</z><z id="t1503040888" t="bbss Okay, great I got it to work with the comments there. For any future visitors: https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10"><y>#</y><d>2017-08-18</d><h>07:21</h><w>bbss</w>Okay, great I got it to work with the comments there.
For any future visitors: 
<a href="https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10" target="_blank">https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10</a></z><z id="t1503071123" t="frank sorry just seeing this now - I had to make changes to it"><y>#</y><d>2017-08-18</d><h>15:45</h><w>frank</w>sorry just seeing this now - I had to make changes to it</z><z id="t1503071193" t="frank one thing that might need to be done is removing comments before feeding it into the parser (or adjusting the grammar to know about them)"><y>#</y><d>2017-08-18</d><h>15:46</h><w>frank</w>one thing that might need to be done is removing comments before feeding it into the parser (or adjusting the grammar to know about them)</z><z id="t1503118498" t="bbss @frank no worries, figured it out. I hadn&apos;t really used context free grammar before, but after meddling with those files for a bit I might actually use them more often. It seems like an indispensable tool for a Lisp programmer really 🙂"><y>#</y><d>2017-08-19</d><h>04:54</h><w>bbss</w>@frank no worries, figured it out. I hadn&apos;t really used context free grammar before, but after meddling with those files for a bit I might actually use them more often. It seems like an indispensable tool for a Lisp programmer really <b>🙂</b></z><z id="t1503118519" t="bbss and you&apos;re right, I actually wrote a function to remove the comments."><y>#</y><d>2017-08-19</d><h>04:55</h><w>bbss</w>and you&apos;re right, I actually wrote a function to remove the comments.</z><z id="t1504124028" t="hlolli In clojurescript with defparser, Im guessing the regexes are read wrongly, with insta/parser I get in my willingly generated token error {:tag :regexp, :expecting #&quot;^[0-9]+\.?[0-9]*&quot;} in same error via defparse {:tag :regexp, :expecting #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;} both originating from &lt;digit&gt; = #&apos;[0-9]+\\.?[0-9]*&apos;"><y>#</y><d>2017-08-30</d><h>20:13</h><w>hlolli</w>In clojurescript with defparser, Im guessing the regexes are read wrongly, with insta/parser I get in my willingly generated token error
<pre>{:tag :regexp,
 :expecting #&quot;^[0-9]+\.?[0-9]*&quot;}
</pre>
in same error via defparse
<pre>{:tag :regexp,
 :expecting #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;}
</pre>
both originating from
<code>&lt;digit&gt; = #&apos;[0-9]+\\.?[0-9]*&apos;</code></z><z id="t1504124132" t="hlolli my first question should be, does some other clojurescript user experience this, as Im running my forked version of Instaparse 1.4.7 running on lumo."><y>#</y><d>2017-08-30</d><h>20:15</h><w>hlolli</w>my first question should be, does some other clojurescript user experience this, as Im running my forked version of Instaparse 1.4.7 running on lumo.</z><z id="t1504124188" t="aengelberg Instaparse is known to have some bugs on Lumo"><y>#</y><d>2017-08-30</d><h>20:16</h><w>aengelberg</w>Instaparse is known to have some bugs on Lumo</z><z id="t1504124201" t="aengelberg because Lumo behaves weirdly with cljc files"><y>#</y><d>2017-08-30</d><h>20:16</h><w>aengelberg</w>because Lumo behaves weirdly with cljc files</z><z id="t1504124250" t="hlolli yes, I know, I&apos;ve fixed those on my fork and it&apos;s effectively working fine, just this one error with regexes, so Im only guessing this is unrelated."><y>#</y><d>2017-08-30</d><h>20:17</h><w>hlolli</w>yes, I know, I&apos;ve fixed those on my fork and it&apos;s effectively working fine, just this one error with regexes, so Im only guessing this is unrelated.</z><z id="t1504124255" t="aengelberg since defparse is evaluated at macro-time, not runtime, my guess is that Lumo trying to execute code on ClojureScript that was meant to be run on Clojure"><y>#</y><d>2017-08-30</d><h>20:17</h><w>aengelberg</w>since <code>defparse</code> is evaluated at macro-time, not runtime, my guess is that Lumo trying to execute code on ClojureScript that was meant to be run on Clojure</z><z id="t1504124306" t="hlolli or related, then in the way you described 🙂"><y>#</y><d>2017-08-30</d><h>20:18</h><w>hlolli</w>or related, then in the way you described <b>🙂</b></z><z id="t1504124313" t="aengelberg The regexp combinator in particular has special logic when run on ClojureScript https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93"><y>#</y><d>2017-08-30</d><h>20:18</h><w>aengelberg</w>The <code>regexp</code> combinator in particular has special logic when run on ClojureScript <a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93" target="_blank">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93</a></z><z id="t1504124318" t="aengelberg which might be why you&apos;re only running into this now"><y>#</y><d>2017-08-30</d><h>20:18</h><w>aengelberg</w>which might be why you&apos;re only running into this now</z><z id="t1504124378" t="hlolli hmm, ok, I try removing this constraint to see what happens..."><y>#</y><d>2017-08-30</d><h>20:19</h><w>hlolli</w>hmm, ok, I try removing this constraint to see what happens...</z><z id="t1504124394" t="aengelberg also maybe try not using defparser and see if that fixes it"><y>#</y><d>2017-08-30</d><h>20:19</h><w>aengelberg</w>also maybe try not using <code>defparser</code> and see if that fixes it</z><z id="t1504124438" t="hlolli yes, that fixes it, I want to use defparser for the performance it brings, Im using the parser to evaluate musical expressions in realtime music application"><y>#</y><d>2017-08-30</d><h>20:20</h><w>hlolli</w>yes, that fixes it, I want to use defparser for the performance it brings, Im using the parser to evaluate musical expressions in realtime music application</z><z id="t1504124898" t="aengelberg makes sense."><y>#</y><d>2017-08-30</d><h>20:28</h><w>aengelberg</w>makes sense.</z><z id="t1504124915" t="aengelberg also that sounds cool, is your application similar to https://github.com/alda-lang/alda ?"><y>#</y><d>2017-08-30</d><h>20:28</h><w>aengelberg</w>also that sounds cool, is your application similar to <a href="https://github.com/alda-lang/alda" target="_blank">https://github.com/alda-lang/alda</a> ?</z><z id="t1504125495" t="gfredericks The Adlaphone: a musical instrument for programmers"><y>#</y><d>2017-08-30</d><h>20:38</h><w>gfredericks</w>The Adlaphone: a musical instrument for programmers</z><z id="t1504125598" t="hlolli only very partially similar to Alda, the use of parser is very limited, and only an extra feature Im implementing atm."><y>#</y><d>2017-08-30</d><h>20:39</h><w>hlolli</w>only very partially similar to Alda, the use of parser is very limited, and only an extra feature Im implementing atm.</z><z id="t1504125673" t="hlolli more about native datatypes Im sending to Csound, audio processing language, and make simple repetitive patterns."><y>#</y><d>2017-08-30</d><h>20:41</h><w>hlolli</w>more about native datatypes Im sending to Csound, audio processing language, and make simple repetitive patterns.</z><z id="t1504126474" t="hlolli loud thinking, I notice that the function regex gets called twice by defparser but once on parse, the second time the input is &quot;/^[0-9]+\.?[0-9]*/&quot; and returnes #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;"><y>#</y><d>2017-08-30</d><h>20:54</h><w>hlolli</w>loud thinking, I notice that the function regex gets called twice by defparser but once on parse, the second time the input is <code>&quot;/^[0-9]+\.?[0-9]*/&quot;</code> and returnes <code>#&quot;^\/^[0-9]+\.?[0-9]*\/&quot;</code></z><z id="t1504126738" t="hlolli ah fixed it 🙂"><y>#</y><d>2017-08-30</d><h>20:58</h><w>hlolli</w>ah fixed it <b>🙂</b></z><z id="t1504126805" t="hlolli in defparse macro I commented ;; Regexp terminals are handled differently in cljs ;; (= :regexp (:tag form)) ;; `(merge (c/regexp ~(str (:regexp form))) ;; ~(dissoc form :tag :regexp)) maybe I should test the standard cljs and see if this is also a problem there."><y>#</y><d>2017-08-30</d><h>21:00</h><w>hlolli</w>in <code>defparse</code> macro I commented
<pre>;; Regexp terminals are handled differently in cljs
 ;; (= :regexp (:tag form))
 ;; `(merge (c/regexp ~(str (:regexp form)))
 ;;         ~(dissoc form :tag :regexp))
</pre>
maybe I should test the standard cljs and see if this is also a problem there.</z><z id="t1509542821" t="Empperi does someone happen to know if there is a ready tool to convert W3C EBNF declarations to format which instaparse understands?"><y>#</y><d>2017-11-01</d><h>13:27</h><w>Empperi</w>does someone happen to know if there is a ready tool to convert W3C EBNF declarations to format which instaparse understands?</z><z id="t1509542841" t="Empperi specifically I’m looking for SPARQL ebnf declarations which I could feed into instaparse"><y>#</y><d>2017-11-01</d><h>13:27</h><w>Empperi</w>specifically I’m looking for SPARQL ebnf declarations which I could feed into instaparse</z><z id="t1509543153" t="Empperi I would also accept an ANTLR -&gt; instaparse converter"><y>#</y><d>2017-11-01</d><h>13:32</h><w>Empperi</w>I would also accept an ANTLR -&gt; instaparse converter</z><z id="t1509552429" t="novel instaparse understands the SPARQL grammar from w3c. you just have to adapt the production rules for the terminals so that instaparse will detect them as regexes. See for instance https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf"><y>#</y><d>2017-11-01</d><h>16:07</h><w>novel</w>instaparse understands the SPARQL grammar from w3c. you just have to adapt the production rules for the terminals so that instaparse will detect them as regexes. See for instance <a href="https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf" target="_blank">https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf</a></z><z id="t1509623299" t="Empperi yeah, I know it is almost the same. What you just linked looks like actually a ready made file which instaparse should be able to digest"><y>#</y><d>2017-11-02</d><h>11:48</h><w>Empperi</w>yeah, I know it is almost the same. What you just linked looks like actually a ready made file which instaparse should be able to digest</z><z id="t1509623313" t="Empperi looks promising, need to test that out, thanks! 👍"><y>#</y><d>2017-11-02</d><h>11:48</h><w>Empperi</w>looks promising, need to test that out, thanks! <b>👍</b></z><z id="t1509623580" t="Empperi indeed, instaparse happily consumed that file. My first SPARQL query did not get through the parser though but it is much easier to proceed from here"><y>#</y><d>2017-11-02</d><h>11:53</h><w>Empperi</w>indeed, instaparse happily consumed that file. My first SPARQL query did not get through the parser though but it is much easier to proceed from here</z><z id="t1510149424" t="tbrooke I am looking at a project that uses https://nearley.js.org/ in javascript which uses Early parsing — I did find an old Clojure repo that mentioned early parsing --- I am somewhat new to parsing and wondered if anyone was up on early parsing or whether I could do the same thing in Clojure with instaparse or another library - I don’t want to use javascript and I would like to rewrite the parser with Clojure Clojurescript"><y>#</y><d>2017-11-08</d><h>13:57</h><w>tbrooke</w>I am looking at a project that uses <a href="https://nearley.js.org/" target="_blank">https://nearley.js.org/</a> in javascript  which uses Early parsing — I did find an old Clojure repo that mentioned early parsing --- I am somewhat new to parsing and wondered if anyone was up on early parsing or whether I could do the same thing in Clojure with instaparse or another library - I don’t want to use javascript and I would like to rewrite the parser with Clojure Clojurescript</z><z id="t1511456117" t="jeremys Hey guys, I am playing with instaparse and I have a problem contructucting a grammar."><y>#</y><d>2017-11-23</d><h>16:55</h><w>jeremys</w>Hey guys, I am playing with instaparse and I have a problem contructucting a grammar.</z><z id="t1511456138" t="jeremys Here is what I am going for (insta/defparser ex7 &quot; doc = (text | tag)* text = #&apos;[^@]*&apos; tag = &apos;@&apos; #&apos;[a-z]*&apos; inner-text* inner-text = &apos;{&apos; #&apos;[^}]*&apos; &apos;}&apos; &quot;) (ex7 &quot;some text @toto{inner text}&quot;)"><y>#</y><d>2017-11-23</d><h>16:55</h><w>jeremys</w>Here is what I am going for <pre>(insta/defparser ex7
  &quot;
  doc = (text | tag)*
  text = #&apos;[^@]*&apos;
  tag = &apos;@&apos; #&apos;[a-z]*&apos; inner-text*
  inner-text = &apos;{&apos; #&apos;[^}]*&apos; &apos;}&apos;
  &quot;)

(ex7 &quot;some text @toto{inner text}&quot;)</pre></z><z id="t1511456314" t="jeremys The problem is the parser when parsing a tag rule won’t consider the inner-text rule giving me the parse [:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot;] [:text &quot;{inner text}&quot;]]"><y>#</y><d>2017-11-23</d><h>16:58</h><w>jeremys</w>The problem is the parser when parsing a <code>tag</code> rule won’t consider the <code>inner-text</code> rule giving me the parse <pre>[:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot;] [:text &quot;{inner text}&quot;]]</pre></z><z id="t1511456355" t="jeremys instead of the desired [:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot; [:inner-text &quot;{&quot; &quot;inner text&quot; &quot;}&quot;]]]"><y>#</y><d>2017-11-23</d><h>16:59</h><w>jeremys</w>instead of the desired <pre>[:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot; [:inner-text &quot;{&quot; &quot;inner text&quot; &quot;}&quot;]]]</pre></z><z id="t1511456512" t="jeremys Any Idea how I can modify the grammar to consider the inner-text rule before going back to the text one ?"><y>#</y><d>2017-11-23</d><h>17:01</h><w>jeremys</w>Any Idea how I can modify the grammar to consider the <code>inner-text rule</code> before going back to the <code>text</code> one ?</z><z id="t1511474837" t="aengelberg @jeremys Maybe change inner-text* to inner-text* !inner-text , to ensure that it parses as many inner-texts as it can."><y>#</y><d>2017-11-23</d><h>22:07</h><w>aengelberg</w>@jeremys Maybe change <code>inner-text*</code> to <code>inner-text* !inner-text</code>, to ensure that it parses as many inner-texts as it can.</z><z id="t1511479153" t="jeremys @aengelberg Thx Alex I’ll try to use the lookahead, I haven’t played with that yet."><y>#</y><d>2017-11-23</d><h>23:19</h><w>jeremys</w>@aengelberg Thx Alex I’ll try to use the lookahead, I haven’t played with that yet.</z><z id="t1511528308" t="jeremys @aengelberg Thx for the help, the negative lookahead work perfectly. I also started a thread on clojureverse with that question. You can find it here https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4"><y>#</y><d>2017-11-24</d><h>12:58</h><w>jeremys</w>@aengelberg Thx for the help, the negative lookahead work perfectly. I also started a thread on clojureverse with that question. You can find it here <a href="https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4" target="_blank">https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4</a></z><z id="t1512066231" t="mrchance hi, is there a possibility in instaparse to bind parse results? For example, when looking for a matching closing tag?"><y>#</y><d>2017-11-30</d><h>18:23</h><w>mrchance</w>hi, is there a possibility in instaparse to bind parse results? For example, when looking for a matching closing tag?</z><z id="t1512066858" t="aengelberg @mrchance sadly no. I&apos;d recommend writing your parser so that it accepts any pair of tags (matching or not), and then separately do some validation to make sure the tag pairs are well formed."><y>#</y><d>2017-11-30</d><h>18:34</h><w>aengelberg</w>@mrchance sadly no. I&apos;d recommend writing your parser so that it accepts any pair of tags (matching or not), and then separately do some validation to make sure the tag pairs are well formed.</z><z id="t1512067348" t="mrchance ok, thanks. Should be easy enough to do in the transform step"><y>#</y><d>2017-11-30</d><h>18:42</h><w>mrchance</w>ok, thanks. Should be easy enough to do in the transform step</z><z id="t1513158486" t="Empperi hmm, I have a rather large EBNF that I’m using to initialize an instaparse parser in ClojureScript"><y>#</y><d>2017-12-13</d><h>09:48</h><w>Empperi</w>hmm, I have a rather large EBNF that I’m using to initialize an instaparse parser in ClojureScript</z><z id="t1513158518" t="Empperi It works just fine but the problem is that the parser creation takes a long time and since it’s ClojureScript that causes the UI to freeze while it is being created"><y>#</y><d>2017-12-13</d><h>09:48</h><w>Empperi</w>It works just fine but the problem is that the parser creation takes a long time and since it’s ClojureScript that causes the UI to freeze while it is being created</z><z id="t1513158541" t="Empperi I was wondering if there is any way to do this in a webworker and if anyone has tried to do that before"><y>#</y><d>2017-12-13</d><h>09:49</h><w>Empperi</w>I was wondering if there is any way to do this in a webworker and if anyone has tried to do that before</z><z id="t1513158565" t="Empperi my initial feeling is that “no you cannot use webworkers” since they work with message passing and as such only Strings can be passed"><y>#</y><d>2017-12-13</d><h>09:49</h><w>Empperi</w>my initial feeling is that “no you cannot use webworkers” since they work with message passing and as such only Strings can be passed</z><z id="t1513158633" t="Empperi ideas?"><y>#</y><d>2017-12-13</d><h>09:50</h><w>Empperi</w>ideas?</z><z id="t1513159528" t="hlolli @niklas.collin are you using the defparser macro?"><y>#</y><d>2017-12-13</d><h>10:05</h><w>hlolli</w>@niklas.collin are you using the defparser macro?</z><z id="t1513159553" t="Empperi no, I’m using instaparse.core/parser"><y>#</y><d>2017-12-13</d><h>10:05</h><w>Empperi</w>no, I’m using <code>instaparse.core/parser</code></z><z id="t1513159584" t="hlolli I wonder if you&apos;d be faster if you&apos;d be using the macro, then it precompiles a bit."><y>#</y><d>2017-12-13</d><h>10:06</h><w>hlolli</w>I wonder if you&apos;d be faster if you&apos;d be using the macro, then it precompiles a bit.</z><z id="t1513159594" t="Empperi dunno, maybe"><y>#</y><d>2017-12-13</d><h>10:06</h><w>Empperi</w>dunno, maybe</z><z id="t1513159601" t="Empperi I could try"><y>#</y><d>2017-12-13</d><h>10:06</h><w>Empperi</w>I could try</z><z id="t1513159672" t="Empperi well, that’s what the defparser documentation in instaparse github page says that it should work better"><y>#</y><d>2017-12-13</d><h>10:07</h><w>Empperi</w>well, that’s what the <code>defparser</code> documentation in instaparse github page says that it should work better</z><z id="t1513159677" t="Empperi thanks, will try that"><y>#</y><d>2017-12-13</d><h>10:07</h><w>Empperi</w>thanks, will try that</z><z id="t1513160901" t="Empperi yeah, now performance is pretty much instant"><y>#</y><d>2017-12-13</d><h>10:28</h><w>Empperi</w>yeah, now performance is pretty much instant</z><z id="t1513160904" t="Empperi cheers 🙂"><y>#</y><d>2017-12-13</d><h>10:28</h><w>Empperi</w>cheers <b>🙂</b></z><z id="t1513184675" t="aengelberg @hlolli yep, that&apos;s exactly what it&apos;s meant for. @niklas.collin I&apos;m glad it served its purpose!"><y>#</y><d>2017-12-13</d><h>17:04</h><w>aengelberg</w>@hlolli yep, that&apos;s exactly what it&apos;s meant for. @niklas.collin I&apos;m glad it served its purpose!</z><z id="t1513269088" t="mbjarland I&apos;m playing around with instaparse and for kicks and giggles I wrote a parser to parse some log files I have laying around"><y>#</y><d>2017-12-14</d><h>16:31</h><w>mbjarland</w>I&apos;m playing around with instaparse and for kicks and giggles I wrote a parser to parse some log files I have laying around</z><z id="t1513269110" t="mbjarland is there a way to define a fixed width &quot;anything goes&quot; string in instaparse"><y>#</y><d>2017-12-14</d><h>16:31</h><w>mbjarland</w>is there a way to define a fixed width &quot;anything goes&quot; string in instaparse</z><z id="t1513269153" t="mbjarland i.e. if I just want to gobble up a few characters into a tree node and don&apos;t care about the content there, is that possible?"><y>#</y><d>2017-12-14</d><h>16:32</h><w>mbjarland</w>i.e. if I just want to gobble up a few characters into a tree node and don&apos;t care about the content there, is that possible?</z><z id="t1513269156" t="aengelberg Fixed width? Maybe #&apos;.{N}&apos; ?"><y>#</y><d>2017-12-14</d><h>16:32</h><w>aengelberg</w>Fixed width? Maybe <code>#&apos;.{N}&apos;</code>?</z><z id="t1513269189" t="mbjarland right, yes regex does the job but is probably not very performant for just &quot;take substring of 10 from where you are&quot;"><y>#</y><d>2017-12-14</d><h>16:33</h><w>mbjarland</w>right, yes regex does the job but is probably not very performant for just &quot;take substring of 10 from where you are&quot;</z><z id="t1513269270" t="mbjarland ok, so regex is the way to go for this in instaparse?"><y>#</y><d>2017-12-14</d><h>16:34</h><w>mbjarland</w>ok, so regex is the way to go for this in instaparse?</z><z id="t1513269301" t="aengelberg I think regex is the most performant way to grab a not-static set of characters"><y>#</y><d>2017-12-14</d><h>16:35</h><w>aengelberg</w>I think regex is the most performant way to grab a not-static set of characters</z><z id="t1513269428" t="mbjarland : ) well I should probably mention that I think instaparse is excellent and by far the best parser lib I&apos;ve run across....so my intent was not to come here and critique it"><y>#</y><d>2017-12-14</d><h>16:37</h><w>mbjarland</w>: ) well I should probably mention that I think instaparse is excellent and by far the best parser lib I&apos;ve run across....so my intent was not to come here and critique it</z><z id="t1513269480" t="aengelberg Thanks! And no worries, I was just answering your question from the perspective of what instaparse actually supports"><y>#</y><d>2017-12-14</d><h>16:38</h><w>aengelberg</w>Thanks! And no worries, I was just answering your question from the perspective of what instaparse actually supports</z><z id="t1513269503" t="mbjarland that being said...if I parse 2G of log files (without instaparse) and compare the simplest regex match with (subs line 10 20) , regex performace doesn&apos;t exactly shine"><y>#</y><d>2017-12-14</d><h>16:38</h><w>mbjarland</w>that being said...if I parse 2G of log files (without instaparse) and compare the simplest regex match with <code>(subs line 10 20)</code>, regex performace doesn&apos;t exactly shine</z><z id="t1513269512" t="aengelberg But I see your point that if it theoretically supported a dedicated &quot;substring&quot; combinator, that would be faster"><y>#</y><d>2017-12-14</d><h>16:38</h><w>aengelberg</w>But I see your point that if it theoretically supported a dedicated &quot;substring&quot; combinator, that would be faster</z><z id="t1513269599" t="mbjarland anyway, figured I would ask, but regex does indeed do the job and perhaps what I&apos;m doing with this parser is a bit of an edge case"><y>#</y><d>2017-12-14</d><h>16:39</h><w>mbjarland</w>anyway, figured I would ask, but regex does indeed do the job and perhaps what I&apos;m doing with this parser is a bit of an edge case</z><z id="t1513269625" t="aengelberg Maybe we should support &quot;custom combinators&quot; so people like you with special use cases can write their own more performant specialized versions"><y>#</y><d>2017-12-14</d><h>16:40</h><w>aengelberg</w>Maybe we should support &quot;custom combinators&quot; so people like you with special use cases can write their own more performant specialized versions</z><z id="t1513269642" t="mbjarland that would be awesome"><y>#</y><d>2017-12-14</d><h>16:40</h><w>mbjarland</w>that would be awesome</z><z id="t1513269767" t="mbjarland you would have to add some kind of extension point to the instaparse bnf syntax I guess"><y>#</y><d>2017-12-14</d><h>16:42</h><w>mbjarland</w>you would have to add some kind of extension point to the instaparse bnf syntax I guess</z><z id="t1513270025" t="aengelberg Maybe, or we don&apos;t allow extensions to the EBNF syntax and just let people make custom combinators for the combinator syntax"><y>#</y><d>2017-12-14</d><h>16:47</h><w>aengelberg</w>Maybe, or we don&apos;t allow extensions to the EBNF syntax and just let people make custom combinators for the combinator syntax</z><z id="t1513270249" t="mbjarland ah, ok, hadn&apos;t grokked the combinators syntax until now"><y>#</y><d>2017-12-14</d><h>16:50</h><w>mbjarland</w>ah, ok, hadn&apos;t grokked the combinators syntax until now</z><z id="t1513270583" t="mbjarland right now I&apos;m considering writing my own mini language for this log parsing, I could use instaparse to parse that language and then do custom, optimized parsing based on the format specification tree coming out from instaparse...so still useful"><y>#</y><d>2017-12-14</d><h>16:56</h><w>mbjarland</w>right now I&apos;m considering writing my own mini language for this log parsing, I could use instaparse to parse that language and then do custom, optimized parsing based on the format specification tree coming out from instaparse...so still useful</z><z id="t1513272095" t="mbjarland hmm, how come I need to double escape the not-inclusive rule in the following grammmar: (def my-p (instaparse.core/parser &quot;spec = (field-spec &lt;&apos; &apos;?&gt;)+ field-spec = &lt;&apos;[&apos;&gt;name &apos; &apos;* &lt;&apos;:&apos;&gt; &apos; &apos;* (width | not-inclusive | not-exclusive | rest)&lt;&apos;]&apos;&gt; name = #&apos;[^:]+&apos; width = &lt;&apos;{&apos;&gt; #&apos;\\d+&apos; &lt;&apos;}&apos;&gt; not-inclusive = &lt;&apos;\\\\&apos;&gt; #&apos;.&apos; not-exclusive = &lt;&apos;/&apos;&gt; #&apos;.&apos; rest = &apos;*&apos; &quot;)) "><y>#</y><d>2017-12-14</d><h>17:21</h><w>mbjarland</w>hmm, how come I need to double escape the not-inclusive rule in the following grammmar: 
<pre>(def my-p 
  (instaparse.core/parser 
    &quot;spec = (field-spec &lt;&apos; &apos;?&gt;)+
     field-spec = &lt;&apos;[&apos;&gt;name &apos; &apos;* &lt;&apos;:&apos;&gt; &apos; &apos;* (width | not-inclusive | not-exclusive | rest)&lt;&apos;]&apos;&gt;
     name = #&apos;[^:]+&apos;
     width = &lt;&apos;{&apos;&gt; #&apos;\\d+&apos; &lt;&apos;}&apos;&gt;
     not-inclusive = &lt;&apos;\\\\&apos;&gt; #&apos;.&apos;
     not-exclusive = &lt;&apos;/&apos;&gt; #&apos;.&apos;
     rest = &apos;*&apos;    
    &quot;))
</pre></z><z id="t1513272145" t="aengelberg you mean the &apos;\\\\&apos; ?"><y>#</y><d>2017-12-14</d><h>17:22</h><w>aengelberg</w>you mean the <code>&apos;\\\\&apos;</code>?</z><z id="t1513272147" t="mbjarland yeah"><y>#</y><d>2017-12-14</d><h>17:22</h><w>mbjarland</w>yeah</z><z id="t1513272161" t="mbjarland shouldn&apos;t two have been enough?"><y>#</y><d>2017-12-14</d><h>17:22</h><w>mbjarland</w>shouldn&apos;t two have been enough?</z><z id="t1513272189" t="aengelberg because 1) you need to tell Clojure that you aren&apos;t escaping a character within a string 2) you need to tell Instaparse that you aren&apos;t escaping a character within a string combinator"><y>#</y><d>2017-12-14</d><h>17:23</h><w>aengelberg</w>because
1) you need to tell Clojure that you aren&apos;t escaping a character within a string
2) you need to tell Instaparse that you aren&apos;t escaping a character within a string combinator</z><z id="t1513272214" t="mbjarland ok, missed point 2 there"><y>#</y><d>2017-12-14</d><h>17:23</h><w>mbjarland</w>ok, missed point 2 there</z><z id="t1513329003" t="Empperi is there some way in instaparse to ask for all possible grammar elements at certain point of the parse tree?"><y>#</y><d>2017-12-15</d><h>09:10</h><w>Empperi</w>is there some way in instaparse to ask for all possible grammar elements at certain point of the parse tree?</z><z id="t1513329037" t="Empperi meaning, I have parse result, I take a specific point in that parse tree and the would get a list of parse elements that could go there"><y>#</y><d>2017-12-15</d><h>09:10</h><w>Empperi</w>meaning, I have parse result, I take a specific point in that parse tree and the would get a list of parse elements that could go there</z><z id="t1513329059" t="Empperi I could theoretically write an EBNF analyzer to do just this but don’t feel like it unless I have to"><y>#</y><d>2017-12-15</d><h>09:10</h><w>Empperi</w>I could theoretically write an EBNF analyzer to do just this but don’t feel like it unless I have to</z><z id="t1513329072" t="Empperi since I think instaparse already does this somewhere under the hood and has the necessary information"><y>#</y><d>2017-12-15</d><h>09:11</h><w>Empperi</w>since I think instaparse already does this somewhere under the hood and has the necessary information</z><z id="t1513329594" t="Empperi hmm, there is instaparse.cfg/ebnf , need look at it and if it would provide the necessary information"><y>#</y><d>2017-12-15</d><h>09:19</h><w>Empperi</w>hmm, there is <code>instaparse.cfg/ebnf</code>, need look at it and if it would provide the necessary information</z><z id="t1513329704" t="Empperi actually it looks like it just might"><y>#</y><d>2017-12-15</d><h>09:21</h><w>Empperi</w>actually it looks like it just might</z><z id="t1513357178" t="aengelberg @niklas.collin not sure what you&apos;re asking. what would be an example of using this functionality?"><y>#</y><d>2017-12-15</d><h>16:59</h><w>aengelberg</w>@niklas.collin not sure what you&apos;re asking. what would be an example of using this functionality?</z><z id="t1513357271" t="Empperi Autocomplete suggestions for code editor"><y>#</y><d>2017-12-15</d><h>17:01</h><w>Empperi</w>Autocomplete suggestions for code editor</z><z id="t1513357314" t="Empperi And the result from cfg/ebnf looks ok usable"><y>#</y><d>2017-12-15</d><h>17:01</h><w>Empperi</w>And the result from cfg/ebnf looks ok usable</z><z id="t1513371973" t="aengelberg There have been a few discussions about generating data for a parser, or listing possible inputs to a parser"><y>#</y><d>2017-12-15</d><h>21:06</h><w>aengelberg</w>There have been a few discussions about generating data for a parser, or listing possible inputs to a parser</z><z id="t1513371979" t="aengelberg Not sure the best path to exposing that"><y>#</y><d>2017-12-15</d><h>21:06</h><w>aengelberg</w>Not sure the best path to exposing that</z><z id="t1513372021" t="aengelberg are you sure ebnf is what you want? That just creates a combinator based on an EBNF spec, it doesn&apos;t generate a list of things that could go there"><y>#</y><d>2017-12-15</d><h>21:07</h><w>aengelberg</w>are you sure <code>ebnf</code> is what you want? That just creates a combinator based on an EBNF spec, it doesn&apos;t generate a list of things that could go there</z><z id="t1513446177" t="borkdude Hello. Why is my InstaParser so slow? 850ms vs 8ms hand-written Clojure: https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119"><y>#</y><d>2017-12-16</d><h>17:42</h><w>borkdude</w>Hello. Why is my InstaParser so slow? 850ms vs 8ms hand-written Clojure:
<a href="https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119" target="_blank">https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119</a></z><z id="t1513446189" t="borkdude Maybe it’s my grammar, but I don’t see it."><y>#</y><d>2017-12-16</d><h>17:43</h><w>borkdude</w>Maybe it’s my grammar, but I don’t see it.</z><z id="t1513446192" t="aengelberg How big is the input?"><y>#</y><d>2017-12-16</d><h>17:43</h><w>aengelberg</w>How big is the input?</z><z id="t1513446207" t="borkdude The input is this: https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt"><y>#</y><d>2017-12-16</d><h>17:43</h><w>borkdude</w>The input is this: <a href="https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt" target="_blank">https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt</a></z><z id="t1513446275" t="borkdude Here’s the grammar: https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17"><y>#</y><d>2017-12-16</d><h>17:44</h><w>borkdude</w>Here’s the grammar: <a href="https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17" target="_blank">https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17</a></z><z id="t1513446514" t="aengelberg I mean, you&apos;re basically generating one string per character in a 40kb file. I&apos;m not surprised it&apos;s slow."><y>#</y><d>2017-12-16</d><h>17:48</h><w>aengelberg</w>I mean, you&apos;re basically generating one string per character in a 40kb file. I&apos;m not surprised it&apos;s slow.</z><z id="t1513446531" t="aengelberg And wrapping with vectors, etc"><y>#</y><d>2017-12-16</d><h>17:48</h><w>aengelberg</w>And wrapping with vectors, etc</z><z id="t1513446631" t="borkdude That’s fair, but even without wrapping the arguments I get a similar time"><y>#</y><d>2017-12-16</d><h>17:50</h><w>borkdude</w>That’s fair, but even without wrapping the arguments I get a similar time</z><z id="t1513446648" t="borkdude I had that before, but I wanted to transform the arguments to ints, that’s why I wrapped them later"><y>#</y><d>2017-12-16</d><h>17:50</h><w>borkdude</w>I had that before, but I wanted to transform the arguments to ints, that’s why I wrapped them later</z><z id="t1513446693" t="aengelberg Hmm yeah"><y>#</y><d>2017-12-16</d><h>17:51</h><w>aengelberg</w>Hmm yeah</z><z id="t1513446801" t="borkdude I mean, it’s not really a problem, but just curious why or if I made a mistake in my grammar"><y>#</y><d>2017-12-16</d><h>17:53</h><w>borkdude</w>I mean, it’s not really a problem, but just curious why or if I made a mistake in my grammar</z><z id="t1513446835" t="aengelberg I don&apos;t think you made a mistake like an ambiguity issue or anything"><y>#</y><d>2017-12-16</d><h>17:53</h><w>aengelberg</w>I don&apos;t think you made a mistake like an ambiguity issue or anything</z><z id="t1513446863" t="aengelberg It&apos;s just really exercising the parser&apos;s dataflow overhead"><y>#</y><d>2017-12-16</d><h>17:54</h><w>aengelberg</w>It&apos;s just really exercising the parser&apos;s dataflow overhead</z><z id="t1513446915" t="aengelberg I saw similar issues when trying to perf-tune @dave&apos;s Alda parser a while ago"><y>#</y><d>2017-12-16</d><h>17:55</h><w>aengelberg</w>I saw similar issues when trying to perf-tune @dave&apos;s Alda parser a while ago</z><z id="t1513446969" t="aengelberg Because his rules were like &quot;if you see this single character, parse this other single character&quot;"><y>#</y><d>2017-12-16</d><h>17:56</h><w>aengelberg</w>Because his rules were like &quot;if you see this single character, parse this other single character&quot;</z><z id="t1513447061" t="aengelberg Instaparse does a lot of bookkeeping during a parse to make sure it magically works with weirdly recursive grammars, so for super low level parsers like this it doesn&apos;t exactly shine"><y>#</y><d>2017-12-16</d><h>17:57</h><w>aengelberg</w>Instaparse does a lot of bookkeeping during a parse to make sure it magically works with weirdly recursive grammars, so for super low level parsers like this it doesn&apos;t exactly shine</z><z id="t1513447077" t="borkdude (def parse2 (insta/parser &quot;&lt;INPUT&gt; = (INSTRUCTION &lt;&apos;,&apos;&gt;)+ INSTRUCTION &lt;INSTRUCTION&gt; = SPIN | EXCHANGE | PARTNER SPIN = &lt;&apos;s&apos;&gt; POSITION EXCHANGE = &lt;&apos;x&apos;&gt; POSITION &lt;&apos;/&apos;&gt; POSITION PARTNER = &lt;&apos;p&apos;&gt; PROGRAM &lt;&apos;/&apos;&gt; PROGRAM &lt;POSITION&gt; = #&apos;\\d\\d?&apos; &lt;PROGRAM&gt; = #&apos;[a-p]&apos;&quot;)) No nesting of position and program, 800ms"><y>#</y><d>2017-12-16</d><h>17:57</h><w>borkdude</w><pre>(def parse2
  (insta/parser
   &quot;&lt;INPUT&gt;       = (INSTRUCTION &lt;&apos;,&apos;&gt;)+ INSTRUCTION 
    &lt;INSTRUCTION&gt; = SPIN | EXCHANGE | PARTNER
    SPIN          = &lt;&apos;s&apos;&gt; POSITION
    EXCHANGE      = &lt;&apos;x&apos;&gt; POSITION &lt;&apos;/&apos;&gt; POSITION
    PARTNER       = &lt;&apos;p&apos;&gt; PROGRAM  &lt;&apos;/&apos;&gt; PROGRAM
    &lt;POSITION&gt;    = #&apos;\\d\\d?&apos;
    &lt;PROGRAM&gt;     = #&apos;[a-p]&apos;&quot;))
</pre>
No nesting of position and program, 800ms</z><z id="t1513447095" t="borkdude ok"><y>#</y><d>2017-12-16</d><h>17:58</h><w>borkdude</w>ok</z><z id="t1513447193" t="aengelberg Just curious, does anything improve if you change the first rule to INSTRUCTION (&lt;&apos;,&apos;&gt; INSTRUCTION)* ?"><y>#</y><d>2017-12-16</d><h>17:59</h><w>aengelberg</w>Just curious, does anything improve if you change the first rule to <code>INSTRUCTION (&lt;&apos;,&apos;&gt; INSTRUCTION)*</code>?</z><z id="t1513447485" t="borkdude I wondered about that rule as well. Quickbenching…"><y>#</y><d>2017-12-16</d><h>18:04</h><w>borkdude</w>I wondered about that rule as well. Quickbenching…</z><z id="t1513447513" t="borkdude Yup, 582ms!"><y>#</y><d>2017-12-16</d><h>18:05</h><w>borkdude</w>Yup, 582ms!</z></g><g id="s4"><z id="t1513447550" t="borkdude Does the order of rules matter for performance?"><y>#</y><d>2017-12-16</d><h>18:05</h><w>borkdude</w>Does the order of rules matter for performance?</z><z id="t1513447581" t="borkdude I mean, when it’s more likely to encounter EXCHANGE, does it help putting that first?"><y>#</y><d>2017-12-16</d><h>18:06</h><w>borkdude</w>I mean, when it’s more likely to encounter EXCHANGE, does it help putting that first?</z><z id="t1513483794" t="aengelberg I&apos;m not actually sure why that is faster, just a hunch since I haven&apos;t seen the left-recursive usage a whole lot."><y>#</y><d>2017-12-17</d><h>04:09</h><w>aengelberg</w>I&apos;m not actually sure why that is faster, just a hunch since I haven&apos;t seen the left-recursive usage a whole lot.</z><z id="t1513599873" t="Empperi @aengelberg definitely not sure if cfg/ebnf is the correct thing but it looks like it provides the necessary data. Not in the format that would be optimal but I think I can kinda do some kind of functionality based on it. For now, I’m mostly happy if I can find the string literals which can go in and I can ignore regexp literals and other more complex stuff. So, basically I do this recursive algorithm which retrieves elements from the combinatioral tree until it finds :string"><y>#</y><d>2017-12-18</d><h>12:24</h><w>Empperi</w>@aengelberg definitely not sure if cfg/ebnf is the correct thing but it looks like it provides the necessary data. Not in the format that would be optimal but I think I can kinda do some kind of functionality based on it. For now, I’m mostly happy if I can find the string literals which can go in and I can ignore regexp literals and other more complex stuff. So, basically I do this recursive algorithm which retrieves elements from the combinatioral tree until it finds <code>:string</code></z><z id="t1513599884" t="Empperi best I can come up with as it is now"><y>#</y><d>2017-12-18</d><h>12:24</h><w>Empperi</w>best I can come up with as it is now</z><z id="t1513763521" t="mbjarland say I have the following grammar: (defn make-layout-parser-internal [] (insta/parser &quot;layout-string = col-delim (col-align col-delim)+ col-delim = (col-fill | col-padding)* col-fill = (&apos;F&apos; | &apos;f&apos;) col-padding = #&apos;[^\\[\\]fF]*&apos; col-align = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;l&apos; | &apos;C&apos; | &apos;c&apos; | &apos;R&apos; | &apos;r&apos;) &lt;&apos;]&apos;&gt;&quot;)) but I want to make a slight modification to it in a certain context. In essence I have two grammars with just a slight differentce between them and depending on the surrounding (non instaparse related) programming context I would like to parse using either grammar a or grammar b. Would I need to define two distinct grammars as per the above or is there some good way to share most of the grammar and have just a slight modification? In my specific case I would have a difference in the col-align value only"><y>#</y><d>2017-12-20</d><h>09:52</h><w>mbjarland</w>say I have the following grammar: 
<pre>(defn make-layout-parser-internal []
  (insta/parser
    &quot;layout-string = col-delim (col-align col-delim)+
     col-delim    = (col-fill | col-padding)*
     col-fill     = (&apos;F&apos; | &apos;f&apos;)
     col-padding  = #&apos;[^\\[\\]fF]*&apos;
     col-align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;l&apos; | &apos;C&apos; | &apos;c&apos; | &apos;R&apos; | &apos;r&apos;) &lt;&apos;]&apos;&gt;&quot;))
</pre>
but I want to make a slight modification to it in a certain context. In essence I have two grammars with just a slight differentce between them and depending on the surrounding (non instaparse related) programming context I would like to parse using either grammar a or grammar b. Would I need to define two distinct grammars as per the above or is there some good way to share most of the grammar and have just a slight modification? In my specific case I would have a difference in the <code>col-align</code> value only</z><z id="t1514356761" t="aengelberg @mbjarland you could use combinators to create separate submaps of common components that get merged together in each use case."><y>#</y><d>2017-12-27</d><h>06:39</h><w>aengelberg</w>@mbjarland you could use combinators to create separate submaps of common components that get merged together in each use case.</z><z id="t1515401503" t="mbjarland I have a question about greedy parsing and ambiguous grammars, I have the following grammar: (insta/parser &quot;layout = (align | delim | repeat)+ repeat = &lt;&apos;{&apos;&gt; (align | delim)+ &lt;&apos;}&apos;&gt; delim = (fill | padding)+ fill = &apos;F&apos; padding = #&apos;[^\\[\\]{}fF]*&apos; align = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;C&apos; | &apos;R&apos; | &apos;V&apos;) &lt;&apos;]&apos;&gt;&quot; :string-ci true)) where the only relevant pieces are the layout = (align | delim | repeat)+ and delim = (fill | padding)+ pieces. Assume we get a ‘fill’ followed by a ‘padding’, the parser can here choose between [:delim [:fill &quot;F&quot;]] [:delim [:padding &quot;xxx&quot;]] and [:delim [:fill &quot;F&quot;] [:padding &quot;xxx&quot;]] . This is not really instaparse specific, but rather to do with bnf’s and disambiguating repeating elements. I would like to force the second interpretation where the delim = (fill | padding)+ is greedy and collects all contiguous delim elements into a list before proceeding. Any ideas much appreciated"><y>#</y><d>2018-01-08</d><h>08:51</h><w>mbjarland</w>I have a question about greedy parsing and ambiguous grammars, I have the following grammar: 
<pre>(insta/parser
    &quot;layout   = (align | delim | repeat)+
     repeat   = &lt;&apos;{&apos;&gt; (align | delim)+ &lt;&apos;}&apos;&gt;
     delim    = (fill | padding)+
     fill     = &apos;F&apos;
     padding  = #&apos;[^\\[\\]{}fF]*&apos;
     align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;C&apos; | &apos;R&apos; | &apos;V&apos;) &lt;&apos;]&apos;&gt;&quot;
    :string-ci true))
</pre>
where the only relevant pieces are the <code>layout = (align | delim | repeat)+</code> and <code>delim = (fill | padding)+</code> pieces. Assume we get a ‘fill’ followed by a ‘padding’, the parser can here choose between <code>[:delim [:fill &quot;F&quot;]] [:delim [:padding &quot;xxx&quot;]]</code> and <code>[:delim [:fill &quot;F&quot;] [:padding &quot;xxx&quot;]]</code>. This is not really instaparse specific, but rather to do with bnf’s and disambiguating repeating elements. I would like to force the second interpretation where the <code>delim = (fill | padding)+</code> is greedy and collects all contiguous delim elements into a list before proceeding. Any ideas much appreciated</z><z id="t1515402087" t="aengelberg @mbjarland you could change (align | delim)+ to delim? (align delim?)* , that would force the parser to alternate between delim and align, effectively making the delim rule greedy"><y>#</y><d>2018-01-08</d><h>09:01</h><w>aengelberg</w>@mbjarland you could change <code>(align | delim)+</code> to <code>delim? (align delim?)*</code>, that would force the parser to alternate between delim and align, effectively making the delim rule greedy</z><z id="t1515402205" t="mbjarland and this is why I love the clojure community, thank you for the fast reply! : ) are we talking about the first rule layout = ... ? In that case I would have to cook up a repeating pattern with 3 elements"><y>#</y><d>2018-01-08</d><h>09:03</h><w>mbjarland</w>and this is why I love the clojure community, thank you for the fast reply! : ) 
are we talking about the first rule <code>layout = ...</code>? In that case I would have to cook up a repeating pattern with 3 elements</z><z id="t1515402249" t="mbjarland so what I’m doing here is defining a column layout"><y>#</y><d>2018-01-08</d><h>09:04</h><w>mbjarland</w>so what I’m doing here is defining a column layout</z><z id="t1515402268" t="aengelberg Actually I was talking about the repeat rule. But you made a good point that we&apos;d also have to apply a similar solution to the layout rule to get a similar effect"><y>#</y><d>2018-01-08</d><h>09:04</h><w>aengelberg</w>Actually I was talking about the repeat rule. But you made a good point that we&apos;d also have to apply a similar solution to the layout rule to get a similar effect</z><z id="t1515402276" t="mbjarland where the repeat says “if the user comes in with more columns than we have defined, use the repeating group to fill out the layout”"><y>#</y><d>2018-01-08</d><h>09:04</h><w>mbjarland</w>where the repeat says “if the user comes in with more columns than we have defined, use the repeating group to fill out the layout”</z><z id="t1515402309" t="aengelberg Column layout? Not sure what you mean"><y>#</y><d>2018-01-08</d><h>09:05</h><w>aengelberg</w>Column layout? Not sure what you mean</z><z id="t1515402327" t="mbjarland never mind, that is really application related and not related to the grammar"><y>#</y><d>2018-01-08</d><h>09:05</h><w>mbjarland</w>never mind, that is really application related and not related to the grammar</z><z id="t1515402367" t="mbjarland thought actually explaining what the thing does might clarify, but I think it just muddles the waters even more : )"><y>#</y><d>2018-01-08</d><h>09:06</h><w>mbjarland</w>thought actually explaining what the thing does might clarify, but I think it just muddles the waters even more : )</z><z id="t1515402401" t="mbjarland I also thought about the / ordered parsing syntax, but I can not really see how to apply that to these repeating patterns"><y>#</y><d>2018-01-08</d><h>09:06</h><w>mbjarland</w>I also thought about the <code>/</code> ordered parsing syntax, but I can not really see how to apply that to these repeating patterns</z><z id="t1515402467" t="aengelberg layout = delim? ((align | repeat) delim?)* repeat = &lt;&apos;{&apos;&gt; delim? (align delim?)* &lt;&apos;}&apos;&gt; "><y>#</y><d>2018-01-08</d><h>09:07</h><w>aengelberg</w><pre>layout = delim? ((align | repeat) delim?)*
repeat = &lt;&apos;{&apos;&gt; delim? (align delim?)* &lt;&apos;}&apos;&gt;
</pre></z><z id="t1515402530" t="mbjarland : )"><y>#</y><d>2018-01-08</d><h>09:08</h><w>mbjarland</w>: )</z><z id="t1515402551" t="aengelberg Since align and repeat both require nonzero characters to be present in order for the rule to succeed, wedging them in the repeat rule enforces some regularity in the repetition and thus unambiguates the parsing"><y>#</y><d>2018-01-08</d><h>09:09</h><w>aengelberg</w>Since <code>align</code> and <code>repeat</code> both require nonzero characters to be present in order for the rule to succeed, wedging them in the repeat rule enforces some regularity in the repetition and thus unambiguates the parsing</z><z id="t1515402599" t="mbjarland that works, I tried it with insta/parses and my standard examples and it comes out with a single interpretation"><y>#</y><d>2018-01-08</d><h>09:09</h><w>mbjarland</w>that works, I tried it with <code>insta/parses</code> and my standard examples and it comes out with a single interpretation</z><z id="t1515402610" t="mbjarland I will have to meditate on the exact mechanics"><y>#</y><d>2018-01-08</d><h>09:10</h><w>mbjarland</w>I will have to meditate on the exact mechanics</z><z id="t1515402628" t="aengelberg Yeah, ordered choice doesn&apos;t really help here unless delim was competing with some other rule and you wanted to establish the priority. But in this case delim is just competing with itself, in a way."><y>#</y><d>2018-01-08</d><h>09:10</h><w>aengelberg</w>Yeah, ordered choice doesn&apos;t really help here unless delim was competing with some other rule and you wanted to establish the priority. But in this case delim is just competing with itself, in a way.</z><z id="t1515402658" t="mbjarland exactly, just a question on what level in the bnf the repetition happens"><y>#</y><d>2018-01-08</d><h>09:10</h><w>mbjarland</w>exactly, just a question on what level in the bnf the repetition happens</z><z id="t1515402666" t="aengelberg Yeah"><y>#</y><d>2018-01-08</d><h>09:11</h><w>aengelberg</w>Yeah</z><z id="t1515402687" t="aengelberg Fortunately that&apos;s easily solved by restructuring the combinators, no fancy PEG combinators necessary"><y>#</y><d>2018-01-08</d><h>09:11</h><w>aengelberg</w>Fortunately that&apos;s easily solved by restructuring the combinators, no fancy PEG combinators necessary</z><z id="t1515402693" t="mbjarland this is actually a higher level pattern, I will make sure to grok this properly for the next time I run into an ambiguous repetition"><y>#</y><d>2018-01-08</d><h>09:11</h><w>mbjarland</w>this is actually a higher level pattern, I will make sure to grok this properly for the next time I run into an ambiguous repetition</z><z id="t1515402710" t="mbjarland thanks a ton!"><y>#</y><d>2018-01-08</d><h>09:11</h><w>mbjarland</w>thanks a ton!</z><z id="t1515402725" t="aengelberg No problem"><y>#</y><d>2018-01-08</d><h>09:12</h><w>aengelberg</w>No problem</z><z id="t1515403088" t="aengelberg @mbjarland I just thought of another way you could have solved it: ignore the above changes I proposed and instead change delim rule to: delim = (fill | padding)+ !delim "><y>#</y><d>2018-01-08</d><h>09:18</h><w>aengelberg</w>@mbjarland I just thought of another way you could have solved it: ignore the above changes I proposed and instead change <code>delim</code> rule to:

<pre>delim = (fill | padding)+ !delim
</pre></z><z id="t1515403121" t="aengelberg Pretty sure my first solution would be more performant, albeit more complex"><y>#</y><d>2018-01-08</d><h>09:18</h><w>aengelberg</w>Pretty sure my first solution would be more performant, albeit more complex</z><z id="t1515411182" t="mbjarland what does the !delim do?"><y>#</y><d>2018-01-08</d><h>11:33</h><w>mbjarland</w>what does the <code>!delim</code> do?</z><z id="t1516591566" t="xiongtx Does the order of rules for Instaparse matter? I seem to recall that rule order didn&apos;t for tools like Lex/JLex...but I could be wrong."><y>#</y><d>2018-01-22</d><h>03:26</h><w>xiongtx</w>Does the order of rules for Instaparse matter? I seem to recall that rule order didn&apos;t for tools like Lex/JLex...but I could be wrong.</z><z id="t1516591624" t="aengelberg The order of rules in an alternation does not matter, if that&apos;s what you&apos;re asking."><y>#</y><d>2018-01-22</d><h>03:27</h><w>aengelberg</w>The order of rules in an alternation does not matter, if that&apos;s what you&apos;re asking.</z><z id="t1516592661" t="xiongtx I meant the statements themselves; but funny you should bring that up, b/c I was just wondering about the order of alternations as well."><y>#</y><d>2018-01-22</d><h>03:44</h><w>xiongtx</w>I meant the statements themselves; but funny you should bring that up, b/c I was just wondering about the order of alternations as well.</z><z id="t1516592760" t="xiongtx For type = &apos;int&apos; | &apos;boolean&apos; | className className = identifier identifier = #&quot;[A-Za-z_]+[A-Za-z0-9_]*&quot; Is there a way to the order of alternations matter, i.e. (insta/parse parser &quot;int&quot;) return {:type &quot;int&quot;] instead of (from my observation) [:type [:className [:identifier &quot;int&quot;]]] ?"><y>#</y><d>2018-01-22</d><h>03:46</h><w>xiongtx</w>For

 <pre>type = &apos;int&apos; | &apos;boolean&apos; | className

className = identifier

identifier = #&quot;[A-Za-z_]+[A-Za-z0-9_]*&quot;
</pre>

Is there a way to the order of alternations matter, i.e. <code>(insta/parse parser &quot;int&quot;)</code> return <code>{:type &quot;int&quot;]</code> instead of (from my observation) <code>[:type [:className [:identifier &quot;int&quot;]]]</code>?</z><z id="t1523189051" t="misha greetings! I am having a trouble to match 2 consequent backslashes (clj): (insta/parse (insta/parser &quot;s = #&apos;\\\\&apos;&quot;) &quot;\\\\&quot;) =&gt; Parse error at line 1, column 1: \\ ^ Expected: #&quot;\\&quot; (followed by end-of-string) (insta/parse (insta/parser &quot;s = #\&quot;\\\\\&quot;&quot;) &quot;\\\\&quot;) =&gt; Parse error at line 1, column 1: \\ ^ Expected: #&quot;\\&quot; (followed by end-of-string) at this point I am just brut forcing with no luck"><y>#</y><d>2018-04-08</d><h>12:04</h><w>misha</w>greetings! I am having a trouble to match 2 consequent backslashes (clj):
<pre>(insta/parse
  (insta/parser &quot;s = #&apos;\\\\&apos;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)

(insta/parse
  (insta/parser &quot;s = #\&quot;\\\\\&quot;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)
</pre>
at this point I am just brut forcing with no luck</z><z id="t1523239471" t="aengelberg @misha I think you are just under-escaping. Try (insta/parse (insta/parser &quot;s = #&apos;\\\\\\\\&apos;&quot;) &quot;\\\\&quot;) "><y>#</y><d>2018-04-09</d><h>02:04</h><w>aengelberg</w>@misha I think you are just under-escaping. Try
<pre>(insta/parse
  (insta/parser &quot;s = #&apos;\\\\\\\\&apos;&quot;)
  &quot;\\\\&quot;)
</pre></z><z id="t1523239558" t="aengelberg Since instaparse and Clojure strings both have their own notation of backslash escaping, you unfortunately have to use an obscene amount of backslashes to convey a legitimate backslash character"><y>#</y><d>2018-04-09</d><h>02:05</h><w>aengelberg</w>Since instaparse and Clojure strings both have their own notation of backslash escaping, you unfortunately have to use an obscene amount of backslashes to convey a legitimate backslash character</z><z id="t1523239562" t="aengelberg https://github.com/engelberg/instaparse#escape-characters"><y>#</y><d>2018-04-09</d><h>02:06</h><w>aengelberg</w><a href="https://github.com/engelberg/instaparse#escape-characters" target="_blank">https://github.com/engelberg/instaparse#escape-characters</a></z><z id="t1523239630" t="aengelberg As that section in the readme explains, one way to get more predictable escaping behavior is to store your grammar in a separate resource file, and that removes one of the layers of escaping (Clojure strings)"><y>#</y><d>2018-04-09</d><h>02:07</h><w>aengelberg</w>As that section in the readme explains, one way to get more predictable escaping behavior is to store your grammar in a separate resource file, and that removes one of the layers of escaping (Clojure strings)</z><z id="t1523256190" t="misha @aengelberg thank you, that works. I already put grammar and source string into their own files, before asking for help, might have missed something (like ns reload)."><y>#</y><d>2018-04-09</d><h>06:43</h><w>misha</w>@aengelberg thank you, that works. I already put grammar and source string into their own files, before asking for help, might have missed something (like ns reload).</z><z id="t1523257141" t="misha how can I distinguish between \n within a text, and a line end in multiline text? Can I do it without relying on next line&apos;s grammar/content? For example, here I need to extract &quot; Simple__ communication example\non several lines&quot; as a single value, w/o including &quot;Alice&quot;. Is there a landmark I can use to stop at &quot;visual&quot; line&apos;s end?: title __Simple__ communication example\non several lines Alice -&gt; Bob: Authentication Request I tried #&apos;(?m)...$&apos; regex flag, but I doubt it will receive &quot;visual&quot; line as an input."><y>#</y><d>2018-04-09</d><h>06:59</h><w>misha</w>how can I distinguish between <code>\n</code> within a text, and a line end in multiline text? Can I do it without relying on next line&apos;s grammar/content? For example, here I need to extract &quot;Simple__ communication example\non several lines&quot; as a single value, w/o including &quot;Alice&quot;. Is there a landmark I can use to stop at &quot;visual&quot; line&apos;s end?:
<pre>title __Simple__ communication example\non several lines
Alice -&gt; Bob: Authentication Request
</pre>
I tried <code>#&apos;(?m)...$&apos;</code> regex flag, but I doubt it will receive &quot;visual&quot; line as an input.</z><z id="t1523287788" t="aengelberg @misha yeah, from the regex&apos;s perspective it&apos;s matching against the entire rest of the string, so $ means &quot;end of file&quot;, not &quot;end of line&quot;. You could use regex&apos;s lookahead feature to detect and end of line, like (?=\r?\n)"><y>#</y><d>2018-04-09</d><h>15:29</h><w>aengelberg</w>@misha yeah, from the regex&apos;s perspective it&apos;s matching against the entire rest of the string, so <code>$</code> means &quot;end of file&quot;, not &quot;end of line&quot;. You could use regex&apos;s lookahead feature to detect and end of line, like <code>(?=\r?\n)</code></z><z id="t1524094577" t="gfredericks can instaparse be used to parse significant-whitespace-indentation-things, in the python sense?"><y>#</y><d>2018-04-18</d><h>23:36</h><w>gfredericks</w>can instaparse be used to parse significant-whitespace-indentation-things, in the python sense?</z><z id="t1524094644" t="aengelberg not really, primarily because of how the &quot;levels&quot; work in said indentation-heavy languages"><y>#</y><d>2018-04-18</d><h>23:37</h><w>aengelberg</w>not really, primarily because of how the &quot;levels&quot; work in said indentation-heavy languages</z><z id="t1524094723" t="gfredericks @aengelberg can you change your username to ængelberg"><y>#</y><d>2018-04-18</d><h>23:38</h><w>gfredericks</w>@aengelberg can you change your username to ængelberg</z><z id="t1524094746" t="gfredericks thanks"><y>#</y><d>2018-04-18</d><h>23:39</h><w>gfredericks</w>thanks</z><z id="t1524094747" t="aengelberg done"><y>#</y><d>2018-04-18</d><h>23:39</h><w>aengelberg</w>done</z><z id="t1524094800" t="gfredericks okay well that&apos;s disappointing because I&apos;m parsing such a thing and I guess I&apos;ll have to do it tediously by hand have you seen any general tools that can handle it?"><y>#</y><d>2018-04-18</d><h>23:40</h><w>gfredericks</w>okay well that&apos;s disappointing because I&apos;m parsing such a thing and I guess I&apos;ll have to do it tediously by hand

have you seen any general tools that can handle it?</z><z id="t1524094860" t="aengelberg if you could somehow pre-tokenize all of the indentation before passing it to instaparse, that might work"><y>#</y><d>2018-04-18</d><h>23:41</h><w>aengelberg</w>if you could somehow pre-tokenize all of the indentation before passing it to instaparse, that might work</z><z id="t1524094985" t="aengelberg what I mean is that you&apos;d have to convert def f(x): if x == 1: return 2; else: return 3; into def f(x): →if x == 1: →return 2; ←else: →return 3; ←← "><y>#</y><d>2018-04-18</d><h>23:43</h><w>aengelberg</w>what I mean is that you&apos;d have to convert
<pre>def f(x):
  if x == 1:
    return 2;
  else:
    return 3;
</pre>
into
<pre>def f(x):
→if x == 1:
→return 2;
←else:
→return 3;
←←
</pre></z><z id="t1524095012" t="aengelberg if that makes sense"><y>#</y><d>2018-04-18</d><h>23:43</h><w>aengelberg</w>if that makes sense</z><z id="t1524095022" t="gfredericks and the arrows act like brackets?"><y>#</y><d>2018-04-18</d><h>23:43</h><w>gfredericks</w>and the arrows act like brackets?</z><z id="t1524095027" t="aengelberg basically"><y>#</y><d>2018-04-18</d><h>23:43</h><w>aengelberg</w>basically</z><z id="t1524095042" t="aengelberg because instaparse can&apos;t keep state of how far to the right you should be at any given point"><y>#</y><d>2018-04-18</d><h>23:44</h><w>aengelberg</w>because instaparse can&apos;t keep state of how far to the right you should be at any given point</z><z id="t1524095050" t="aengelberg based on higher-level indentations"><y>#</y><d>2018-04-18</d><h>23:44</h><w>aengelberg</w>based on higher-level indentations</z><z id="t1524095081" t="gfredericks I think the combination of writing that code and having to write a grammar is probably more tedious than parsing it manually"><y>#</y><d>2018-04-18</d><h>23:44</h><w>gfredericks</w>I think the combination of writing that code and having to write a grammar is probably more tedious than parsing it manually</z><z id="t1524095097" t="aengelberg perhaps"><y>#</y><d>2018-04-18</d><h>23:44</h><w>aengelberg</w>perhaps</z><z id="t1524095218" t="aengelberg oh also you could maybe get sneaky with nested parsing"><y>#</y><d>2018-04-18</d><h>23:46</h><w>aengelberg</w>oh also you could maybe get sneaky with nested parsing</z><z id="t1524095279" t="aengelberg where, say, the top level parser gives you back [:def &quot;f(x)&quot; [:nested-block &quot;if x == 1:&quot; &quot; return 2;&quot; &quot;else:&quot; &quot; return 3;&quot;]] "><y>#</y><d>2018-04-18</d><h>23:47</h><w>aengelberg</w>where, say, the top level parser gives you back
<pre>[:def &quot;f(x)&quot;
 [:nested-block
  &quot;if x == 1:&quot;
  &quot;  return 2;&quot;
  &quot;else:&quot;
  &quot;  return 3;&quot;]]
</pre></z><z id="t1524095295" t="aengelberg and then you have some code that then takes said nested blocks and re-runs the parser on it"><y>#</y><d>2018-04-18</d><h>23:48</h><w>aengelberg</w>and then you have some code that then takes said nested blocks and re-runs the parser on it</z><z id="t1524095297" t="aengelberg and so on"><y>#</y><d>2018-04-18</d><h>23:48</h><w>aengelberg</w>and so on</z><z id="t1524095341" t="gfredericks oh interesting"><y>#</y><d>2018-04-18</d><h>23:49</h><w>gfredericks</w>oh interesting</z><z id="t1524095362" t="gfredericks if you&apos;re not trampolining your parser, why bother getting up in the morning?"><y>#</y><d>2018-04-18</d><h>23:49</h><w>gfredericks</w>if you&apos;re not trampolining your parser, why bother getting up in the morning?</z><z id="t1524095621" t="aengelberg you would have to re-append those nested block lines (with newlines in between)"><y>#</y><d>2018-04-18</d><h>23:53</h><w>aengelberg</w>you would have to re-append those nested block lines (with newlines in between)</z><z id="t1524095643" t="gfredericks sure"><y>#</y><d>2018-04-18</d><h>23:54</h><w>gfredericks</w>sure</z><z id="t1524095809" t="aengelberg the grammar would look like S = def | if | ... def = &lt;&apos;def &apos;&gt; thing-you&apos;re-deffing &lt;&apos;:\n&apos;&gt; nested-block nested-block = (&apos; &apos; #&quot;.*\n?&quot;)* "><y>#</y><d>2018-04-18</d><h>23:56</h><w>aengelberg</w>the grammar would look like
<pre>S = def | if | ...
def = &lt;&apos;def &apos;&gt; thing-you&apos;re-deffing &lt;&apos;:\n&apos;&gt; nested-block
nested-block = (&apos; &apos; #&quot;.*\n?&quot;)*
</pre></z><z id="t1524096059" t="gfredericks we&apos;re relying on the greediness of .* to definitely eat the \n even though it`s got a ? on it?"><y>#</y><d>2018-04-19</d><h>00:00</h><w>gfredericks</w>we&apos;re relying on the greediness of <code>.*</code> to definitely eat the <code>\n</code> even though it`s got a <code>?</code> on it?</z><z id="t1524096101" t="aengelberg well, . by default means non-newline chars in regex-land"><y>#</y><d>2018-04-19</d><h>00:01</h><w>aengelberg</w>well, <code>.</code> by default means non-newline chars in regex-land</z><z id="t1524096107" t="gfredericks the \n? had me worried that it might parse [&quot; foo&quot; &quot; bar&quot;] from &quot; foo bar&quot;"><y>#</y><d>2018-04-19</d><h>00:01</h><w>gfredericks</w>the <code>\n?</code> had me worried that it might parse <code>[&quot; foo&quot; &quot; bar&quot;]</code> from <code>&quot; foo bar&quot;</code></z><z id="t1524096117" t="aengelberg but yes we are relying on the greediness"><y>#</y><d>2018-04-19</d><h>00:01</h><w>aengelberg</w>but yes we are relying on the greediness</z><z id="t1524096121" t="gfredericks :+1:"><y>#</y><d>2018-04-19</d><h>00:02</h><w>gfredericks</w><b>:+1:</b></z><z id="t1524096144" t="aengelberg #&quot;.*(\n|$)&quot; might be safer"><y>#</y><d>2018-04-19</d><h>00:02</h><w>aengelberg</w><code>#&quot;.*(\n|$)&quot;</code> might be safer</z><z id="t1524096197" t="aengelberg btw I believe @dave has some prior art on nested parsers for Alda"><y>#</y><d>2018-04-19</d><h>00:03</h><w>aengelberg</w>btw I believe @dave has some prior art on nested parsers for Alda</z><z id="t1524096208" t="aengelberg actually just kidding I think he migrated away from instaparse in more recent versions of Alda"><y>#</y><d>2018-04-19</d><h>00:03</h><w>aengelberg</w>actually just kidding I think he migrated away from instaparse in more recent versions of Alda</z><z id="t1524099922" t="dave indeed, i ended up rolling my own parser, mostly in the hope that someday we can start to asynchronously process parsed expressions/statements as they are parsed -- meaning that a score could start playing before it&apos;s even done being parsed"><y>#</y><d>2018-04-19</d><h>01:05</h><w>dave</w>indeed, i ended up rolling my own parser, mostly in the hope that someday we can start to asynchronously process parsed expressions/statements as they are parsed -- meaning that a score could start playing before it&apos;s even done being parsed</z><z id="t1524099939" t="dave ...although in doing so, performance got significantly better, to the extent that we might never need to do that 😄"><y>#</y><d>2018-04-19</d><h>01:05</h><w>dave</w>...although in doing so, performance got significantly better, to the extent that we might never need to do that <b>😄</b></z><z id="t1524100148" t="dave before moving away from instaparse, i was doing some pretty complicated stuff with multiple grammars. it was starting to make my head hurt a little, so that may have had something to do with the decision too"><y>#</y><d>2018-04-19</d><h>01:09</h><w>dave</w>before moving away from instaparse, i was doing some pretty complicated stuff with multiple grammars. it was starting to make my head hurt a little, so that may have had something to do with the decision too</z><z id="t1524100193" t="dave the grammars needed to share some rules with each other, so i was defining grammars using bits and pieces strung together"><y>#</y><d>2018-04-19</d><h>01:09</h><w>dave</w>the grammars needed to share some rules with each other, so i was defining grammars using bits and pieces strung together</z><z id="t1524100298" t="dave the reason for that was basically to try and get better perf (without being super knowledgeable about how to improve parser performance otherwise), instead of a big master grammar like i had before, i started parsing out large chunks with more specialized grammars, and do the parsing in multiple passes"><y>#</y><d>2018-04-19</d><h>01:11</h><w>dave</w>the reason for that was basically to try and get better perf (without being super knowledgeable about how to improve parser performance otherwise), instead of a big master grammar like i had before, i started parsing out large chunks with more specialized grammars, and do the parsing in multiple passes</z><z id="t1527000587" t="aengelberg"><y>#</y><d>2018-05-22</d><h>14:49</h><w>aengelberg</w></z><z id="t1527000655" t="aengelberg @sova Once your query has been parsed from a string into data (that&apos;s usually the hard part), you can use whatever strategy you want to actually evaluate it. insta/transform is meant to be just one tool in your toolbelt to serve the most common case."><y>#</y><d>2018-05-22</d><h>14:50</h><w>aengelberg</w>@sova Once your query has been parsed from a string into data (that&apos;s usually the hard part), you can use whatever strategy you want to actually evaluate it. <code>insta/transform</code> is meant to be just one tool in your toolbelt to serve the most common case.</z><z id="t1527000775" t="aengelberg I think this is the transform example you were referring to: =&gt; (-&gt;&gt; (arithmetic &quot;1-2/(3-4)+5*6&quot;) (insta/transform {:add +, :sub -, :mul *, :div /, :number clojure.edn/read-string :expr identity})) 33 "><y>#</y><d>2018-05-22</d><h>14:52</h><w>aengelberg</w>I think this is the transform example you were referring to:
<pre>=&gt; (-&gt;&gt; (arithmetic &quot;1-2/(3-4)+5*6&quot;)
     (insta/transform
       {:add +, :sub -, :mul *, :div /,
        :number clojure.edn/read-string :expr identity}))
33
</pre></z><z id="t1527000846" t="aengelberg In this case it isn&apos;t replacing :add with + , it&apos;s actually calling + on all of the elements that come after :add . So as the transformer works its way up the tree, it ends up evaluating the whole expression."><y>#</y><d>2018-05-22</d><h>14:54</h><w>aengelberg</w>In this case it isn&apos;t replacing <code>:add</code> with <code>+</code>, it&apos;s actually calling <code>+</code> on all of the elements that come after <code>:add</code>. So as the transformer works its way up the tree, it ends up evaluating the whole expression.</z><z id="t1527000977" t="aengelberg Does that explanation help?"><y>#</y><d>2018-05-22</d><h>14:56</h><w>aengelberg</w>Does that explanation help?</z><z id="t1527001196" t="sova-soars-the-sora wow! that is very cool, it&apos;s calling + ... this explanation is very helpful, it gives me a really strong starting point, but i&apos;m still not sure how i can end up with a thing i can test logicals on. since i could replace different nodes with whatever function i see fit, there&apos;s a lot of power there, but i gotta end up with something that i could pour &quot;lemon juice&quot; through and if the internal query expression was (&quot;lemon&quot; | &quot;momo&quot;) &amp; &quot;juice&quot; ... it would work. do you have any ideas on transforming nodes into logic gates?"><y>#</y><d>2018-05-22</d><h>14:59</h><w>sova-soars-the-sora</w>wow!  that is very cool, it&apos;s calling <code>+</code> ... this explanation is very helpful, it gives me a really strong starting point,
 but i&apos;m still not sure how i can end up with a thing i can test logicals on.  

since i could replace different nodes with whatever function i see fit, there&apos;s a lot of power there,
but i gotta end up with something that i could pour &quot;lemon juice&quot; through and if the internal 
query expression was (&quot;lemon&quot; | &quot;momo&quot;) &amp; &quot;juice&quot; ... it would work.

do you have any ideas on transforming nodes into logic gates?</z><z id="t1527001300" t="sova-soars-the-sora okay, you mention that it works its way up the tree so presumably it starts at the leaves... so if on matching leaves we write down &quot;true&quot; and non matching leaves we write &quot;false&quot; and then eventually do an eval on the whole thing, it&apos;ll be like getting a truth statement back."><y>#</y><d>2018-05-22</d><h>15:01</h><w>sova-soars-the-sora</w>okay, you mention that it works its way up the tree so presumably it starts at the leaves...
so if on matching leaves we write down &quot;true&quot; and non matching leaves we write &quot;false&quot; and then eventually do an eval on the whole thing, it&apos;ll be like getting a truth statement back.</z><z id="t1527001378" t="sova-soars-the-sora Thanks for taking the time to explain that, by the way."><y>#</y><d>2018-05-22</d><h>15:02</h><w>sova-soars-the-sora</w>Thanks for taking the time to explain that, by the way.</z><z id="t1527023276" t="akiroz Found this channel in #beginners and I just wanna say: @aengelberg thank you for the great library, it saved me multiple times from DSL hell 😊"><y>#</y><d>2018-05-22</d><h>21:07</h><w>akiroz</w>Found this channel in #beginners and I just wanna say: @aengelberg thank you for the great library, it saved me multiple times from DSL hell <b>😊</b></z><z id="t1527023365" t="aengelberg thanks @akiroz, glad you are finding it useful"><y>#</y><d>2018-05-22</d><h>21:09</h><w>aengelberg</w>thanks @akiroz, glad you are finding it useful</z><z id="t1527023544" t="aengelberg @sova yeah your true/false strategy should work. insta/transform is a recursive function, and whenever it&apos;s processing a node it transforms all of the children first, hence the &quot;leaves first&quot; approach."><y>#</y><d>2018-05-22</d><h>21:12</h><w>aengelberg</w>@sova yeah your true/false strategy should work. <code>insta/transform</code> is a recursive function, and whenever it&apos;s processing a node it transforms all of the children first, hence the &quot;leaves first&quot; approach.</z><z id="t1527023592" t="aengelberg you can take a look at the source code of insta/transform . It has some boilerplate to make sure it works on instaparse&apos;s various output formats, but at its core it&apos;s a fairly simple depth-first iterator."><y>#</y><d>2018-05-22</d><h>21:13</h><w>aengelberg</w>you can take a look at the source code of <code>insta/transform</code>. It has some boilerplate to make sure it works on instaparse&apos;s various output formats, but at its core it&apos;s a fairly simple depth-first iterator.</z><z id="t1527023645" t="aengelberg https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46"><y>#</y><d>2018-05-22</d><h>21:14</h><w>aengelberg</w><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46" target="_blank">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46</a></z><z id="t1527023898" t="aengelberg the super-simplified version of the logic looks like this: (defn- hiccup-transform [transform-map parse-tree] (if (not (empty? parse-tree)) (let [transform (transform-map (first parse-tree))] (apply transform (map (partial hiccup-transform transform-map) (next parse-tree)))) parse-tree)) "><y>#</y><d>2018-05-22</d><h>21:18</h><w>aengelberg</w>the super-simplified version of the logic looks like this:
<pre>(defn- hiccup-transform
  [transform-map parse-tree]
  (if (not (empty? parse-tree))
    (let [transform (transform-map (first parse-tree))]
      (apply transform (map (partial hiccup-transform transform-map)
                            (next parse-tree))))
    parse-tree))
</pre></z><z id="t1527024773" t="sova-soars-the-sora Cool! Thanks very much for providing source and also zooming in on the vital part."><y>#</y><d>2018-05-22</d><h>21:32</h><w>sova-soars-the-sora</w>Cool!  Thanks very much for providing source and also zooming in on the vital part.</z><z id="t1527024879" t="sova-soars-the-sora So the (partial ..) function ... could you tell me more about how that comes into play?"><y>#</y><d>2018-05-22</d><h>21:34</h><w>sova-soars-the-sora</w>So the (partial ..) function ... could you tell me more about how that comes into play?</z><z id="t1527025532" t="aengelberg partial is a function built-in to Clojure that helps curry arguments in anonymous functions http://clojuredocs.org/clojure.core/partial"><y>#</y><d>2018-05-22</d><h>21:45</h><w>aengelberg</w><code>partial</code> is a function built-in to Clojure that helps curry arguments in anonymous functions <a href="http://clojuredocs.org/clojure.core/partial" target="_blank">http://clojuredocs.org/clojure.core/partial</a></z><z id="t1527190559" t="sova-soars-the-sora Hello again. I stumbled onto http://instaparse-live.matt.is/ and it&apos;s really awesome, I&apos;ve been tinkering with it and with a repl-like feedback loop it&apos;s been pretty painless finding something that can parse logic like i need"><y>#</y><d>2018-05-24</d><h>19:35</h><w>sova-soars-the-sora</w>Hello again.  I stumbled onto <a href="http://instaparse-live.matt.is/" target="_blank">http://instaparse-live.matt.is/</a>  and it&apos;s really awesome, I&apos;ve been tinkering with it and with a repl-like feedback loop it&apos;s been pretty painless finding something that can parse logic like i need</z><z id="t1527190578" t="sova-soars-the-sora But one thing I have noticed is that if there are parse variations, there may be multiple result parses"><y>#</y><d>2018-05-24</d><h>19:36</h><w>sova-soars-the-sora</w>But one thing I have noticed is that if there are parse variations, there may be multiple result parses</z><z id="t1527190898" t="sova-soars-the-sora That pretty much encapsulates the nodes as I want to store them... i wonder if there is a cleaner or clearer representation for just &amp; and | logic w/ parens"><y>#</y><d>2018-05-24</d><h>19:41</h><w>sova-soars-the-sora</w>That pretty much encapsulates the nodes as I want to store them... i wonder if there is a cleaner or clearer representation for just &amp; and  |  logic w/ parens</z><z id="t1527190998" t="sova-soars-the-sora Sometimes, there are multiple valid interpretations, for example: (pardon the zoom level)..."><y>#</y><d>2018-05-24</d><h>19:43</h><w>sova-soars-the-sora</w>Sometimes, there are multiple valid interpretations, for example: (pardon the zoom level)...</z><z id="t1527191176" t="sova-soars-the-sora It seems as though they are both perfectly valid so, maybe I can just use the first one of the result set"><y>#</y><d>2018-05-24</d><h>19:46</h><w>sova-soars-the-sora</w>It seems as though they are both perfectly valid so, maybe I can just use the first one of the result set</z><z id="t1527191822" t="sova-soars-the-sora better example.."><y>#</y><d>2018-05-24</d><h>19:57</h><w>sova-soars-the-sora</w>better example..</z><z id="t1527192505" t="dave wow, i haven&apos;t seen this before. so cool!"><y>#</y><d>2018-05-24</d><h>20:08</h><w>dave</w>wow, i haven&apos;t seen this before. so cool!</z><z id="t1527265957" t="sova-soars-the-sora yeah, LISP is insanely cool, instaparse is amazing, and context free grammars absolutely rock. seeing how easy it actually is to get tokens out of arbitrary syntax i&apos;m really inspired to work on some NLP stuff!"><y>#</y><d>2018-05-25</d><h>16:32</h><w>sova-soars-the-sora</w>yeah, LISP is insanely cool, instaparse is amazing, and context free grammars absolutely rock.  seeing how easy it actually is to get tokens out of arbitrary syntax i&apos;m really inspired to work on some NLP stuff!</z><z id="t1527447050" t="Logan Powell 👋 Hi everyone!"><y>#</y><d>2018-05-27</d><h>18:50</h><w>Logan Powell</w><b>👋</b> Hi everyone!</z><z id="t1527447713" t="Logan Powell btw, http://instaparse-live.matt.is/ is awesome"><y>#</y><d>2018-05-27</d><h>19:01</h><w>Logan Powell</w>btw, <a href="http://instaparse-live.matt.is/" target="_blank">http://instaparse-live.matt.is/</a> is awesome</z><z id="t1527448127" t="akiroz @loganpowell Why not just read the clojure code as data? I mean lisp code IS data, there&apos;s no need to deal with string parsing"><y>#</y><d>2018-05-27</d><h>19:08</h><w>akiroz</w>@loganpowell Why not just read the clojure code as data? I mean lisp code IS data, there&apos;s no need to deal with string parsing</z><z id="t1527448171" t="Logan Powell how would I pull out the pieces of the function definitions as strings?"><y>#</y><d>2018-05-27</d><h>19:09</h><w>Logan Powell</w>how would I pull out the pieces of the function definitions as strings?</z><z id="t1527448191" t="Logan Powell I&apos;m converting it to markdown"><y>#</y><d>2018-05-27</d><h>19:09</h><w>Logan Powell</w>I&apos;m converting it to markdown</z><z id="t1527448207" t="akiroz just print it to string"><y>#</y><d>2018-05-27</d><h>19:10</h><w>akiroz</w>just print it to string</z><z id="t1527448226" t="Logan Powell haha, I&apos;m very stupid. That&apos;s a great idea"><y>#</y><d>2018-05-27</d><h>19:10</h><w>Logan Powell</w>haha, I&apos;m very stupid. That&apos;s a great idea</z><z id="t1527448252" t="akiroz you might want pprint actually, since it&apos;s for docs"><y>#</y><d>2018-05-27</d><h>19:10</h><w>akiroz</w>you might want <code>pprint</code> actually, since it&apos;s for docs</z><z id="t1527448267" t="Logan Powell ok, so I get the string that way, then how do I pull out the specific parts of that string that I need?"><y>#</y><d>2018-05-27</d><h>19:11</h><w>Logan Powell</w>ok, so I get the string that way, then how do I pull out the specific parts of that string that I need?</z><z id="t1527448295" t="akiroz well first parse the whole thing into data with the built-in read function"><y>#</y><d>2018-05-27</d><h>19:11</h><w>akiroz</w>well first parse the whole thing into data with the built-in <code>read</code> function</z><z id="t1527448330" t="akiroz manipulate the data as much as you want then print it"><y>#</y><d>2018-05-27</d><h>19:12</h><w>akiroz</w>manipulate the data as much as you want then print it</z><z id="t1527448345" t="Logan Powell hmm... let me give that a shot!"><y>#</y><d>2018-05-27</d><h>19:12</h><w>Logan Powell</w>hmm... let me give that a shot!</z><z id="t1527448407" t="akiroz @loganpowell if you need more advanced code analysis, check out tools.analyzer"><y>#</y><d>2018-05-27</d><h>19:13</h><w>akiroz</w>@loganpowell if you need more advanced code analysis, check out <code>tools.analyzer</code></z><z id="t1527448418" t="akiroz https://github.com/clojure/tools.analyzer"><y>#</y><d>2018-05-27</d><h>19:13</h><w>akiroz</w><a href="https://github.com/clojure/tools.analyzer" target="_blank">https://github.com/clojure/tools.analyzer</a></z><z id="t1527448443" t="Logan Powell I&apos;m using cljs, works the same?"><y>#</y><d>2018-05-27</d><h>19:14</h><w>Logan Powell</w>I&apos;m using cljs, works the same?</z><z id="t1527448474" t="akiroz you mean the read part or analyser?"><y>#</y><d>2018-05-27</d><h>19:14</h><w>akiroz</w>you mean the <code>read</code> part or analyser?</z><z id="t1527448485" t="Logan Powell both"><y>#</y><d>2018-05-27</d><h>19:14</h><w>Logan Powell</w>both</z><z id="t1527448498" t="akiroz former is called cljs.reader/read-string in cljs"><y>#</y><d>2018-05-27</d><h>19:14</h><w>akiroz</w>former is called <code>cljs.reader/read-string</code> in cljs</z><z id="t1527448507" t="akiroz latter I have no idea if it works in cljs (I&apos;m gonna guess no)"><y>#</y><d>2018-05-27</d><h>19:15</h><w>akiroz</w>latter I have no idea if it works in cljs (I&apos;m gonna guess no)</z><z id="t1527448592" t="Logan Powell is reader a part of core or do I need to add it as a :dependency?"><y>#</y><d>2018-05-27</d><h>19:16</h><w>Logan Powell</w>is <code>reader</code> a part of core or do I need to add it as a :dependency?</z><z id="t1527448609" t="akiroz it&apos;s built-in"><y>#</y><d>2018-05-27</d><h>19:16</h><w>akiroz</w>it&apos;s built-in</z><z id="t1527448615" t="Logan Powell cool"><y>#</y><d>2018-05-27</d><h>19:16</h><w>Logan Powell</w>cool</z><z id="t1527448687" t="Logan Powell it&apos;s working 🙂 I was getting all excited about instaparse... now I have to calm down my curiosity and get to work 😄"><y>#</y><d>2018-05-27</d><h>19:18</h><w>Logan Powell</w>it&apos;s working <b>🙂</b> I was getting all excited about instaparse... now I have to calm down my curiosity and get to work <b>😄</b></z><z id="t1527448741" t="Logan Powell do I use core.match with this?"><y>#</y><d>2018-05-27</d><h>19:19</h><w>Logan Powell</w>do I use <code>core.match</code> with this?</z><z id="t1527448795" t="akiroz Haha, I suppose building a parser yourself would be a great learning exercise too.... but code grammar is a bit complex."><y>#</y><d>2018-05-27</d><h>19:19</h><w>akiroz</w>Haha, I suppose building a parser yourself would be a great learning exercise too.... but code grammar is a bit complex.</z><z id="t1527448833" t="Logan Powell it looks as so, you&apos;re right"><y>#</y><d>2018-05-27</d><h>19:20</h><w>Logan Powell</w>it looks as so, you&apos;re right</z><z id="t1527448833" t="akiroz You can use whatever tools you want to process the data, it&apos;s just a list"><y>#</y><d>2018-05-27</d><h>19:20</h><w>akiroz</w>You can use whatever tools you want to process the data, it&apos;s just a list</z><z id="t1527448843" t="Logan Powell ok, let me give it a go"><y>#</y><d>2018-05-27</d><h>19:20</h><w>Logan Powell</w>ok, let me give it a go</z><z id="t1527453897" t="aengelberg yeah, Instaparse only aims to help turn strings into data, so if you already have a way to do that (`read-string`) then instaparse won&apos;t be much help"><y>#</y><d>2018-05-27</d><h>20:44</h><w>aengelberg</w>yeah, Instaparse only aims to help turn strings into data, so if you already have a way to do that (`read-string`) then instaparse won&apos;t be much help</z><z id="t1527453921" t="aengelberg the &quot;analysis&quot; of your resulting data is always left as an exercise to the reader anyway 🙂"><y>#</y><d>2018-05-27</d><h>20:45</h><w>aengelberg</w>the &quot;analysis&quot; of your resulting data is always left as an exercise to the reader anyway <b>🙂</b></z><z id="t1527482666" t="sova-soars-the-sora does it make sense to use instaparse on the input to (read-line) (e.g. getting input from std in?)"><y>#</y><d>2018-05-28</d><h>04:44</h><w>sova-soars-the-sora</w>does it make sense to use instaparse on the input to (read-line)  (e.g. getting input from std in?)</z><z id="t1527491342" t="sova-soars-the-sora because I want to parse numbers and strings. integers"><y>#</y><d>2018-05-28</d><h>07:09</h><w>sova-soars-the-sora</w>because I want to parse numbers and strings.  integers</z><z id="t1527548083" t="aengelberg not sure what you mean @sova; instaparse parsers can be run on any string"><y>#</y><d>2018-05-28</d><h>22:54</h><w>aengelberg</w>not sure what you mean @sova; instaparse parsers can be run on any string</z><z id="t1527552238" t="sova-soars-the-sora Yeah, I had a hard time forming my question, i&apos;m getting input from stdin, i have resorted to using edn/read-string which gives a vector of strings,"><y>#</y><d>2018-05-29</d><h>00:03</h><w>sova-soars-the-sora</w>Yeah, I had a hard time forming my question, i&apos;m getting input from stdin, i have resorted to using edn/read-string which gives a vector of strings,</z><z id="t1527653207" t="fabrao Hello all, I´m doing parser for fixed width with instaparse and the code is (-&gt;&gt; ((insta/parser &quot;VALOR = CODIGO BARRAS CODIGO = 2DIGIT BARRAS = 3DIGIT &quot; :input-format :abnf) &quot;12334&quot;) (insta/transform {:DIGIT (comp str)})) How do I concat the &quot;DIGITs&quot; and keep CODIGO and BARRAS?"><y>#</y><d>2018-05-30</d><h>04:06</h><w>fabrao</w>Hello all, I´m doing parser for fixed width with instaparse and the code is 
<pre>(-&gt;&gt;
   ((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = 2DIGIT
BARRAS = 3DIGIT
&quot; :input-format :abnf) &quot;12334&quot;)
   (insta/transform {:DIGIT (comp str)}))</pre> 
How do I concat the &quot;DIGITs&quot; and keep CODIGO and BARRAS?</z><z id="t1527661282" t="aengelberg @fabrao try adding transform entries for :CODIGO (partial apply str) :BARRAS (partial apply str)"><y>#</y><d>2018-05-30</d><h>06:21</h><w>aengelberg</w>@fabrao try adding transform entries for <code>:CODIGO (partial apply str) :BARRAS (partial apply str)</code></z><z id="t1527683382" t="fabrao @aengelberg it did not work, this keep showing [:VALOR [:DIGIT &quot;1&quot;]:DIGIT2 [:DIGIT &quot;3&quot;][:DIGIT &quot;3&quot;]:DIGIT4]"><y>#</y><d>2018-05-30</d><h>12:29</h><w>fabrao</w>@aengelberg it did not work, this keep showing <code>[:VALOR [:DIGIT &quot;1&quot;]:DIGIT2 [:DIGIT &quot;3&quot;][:DIGIT &quot;3&quot;]:DIGIT4]</code></z><z id="t1527683473" t="fabrao I had to change to ((insta/parser &quot;VALOR = CODIGO BARRAS CODIGO = #&apos;.{3}&apos; BARRAS = #&apos;.{2}&apos; &quot;) &quot;12334&quot;)"><y>#</y><d>2018-05-30</d><h>12:31</h><w>fabrao</w>I had to change to 
<pre>((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = #&apos;.{3}&apos;
BARRAS = #&apos;.{2}&apos;
&quot;) &quot;12334&quot;)</pre></z><z id="t1527781068" t="sova-soars-the-sora hey @aengelberg, how does instaparse work? i was looking at the source and it looks like it makes multiple passes until it&apos;s successfully consumed the whole input string, correct? and if a parse doesn&apos;t work, an &quot;error node is embedded in the tree&quot; so it knows not to try that parse again?"><y>#</y><d>2018-05-31</d><h>15:37</h><w>sova-soars-the-sora</w>hey @aengelberg, how does instaparse work?  i was looking at the source and it looks like it makes multiple passes until it&apos;s successfully consumed the whole input string, correct?  and if a parse doesn&apos;t work, an &quot;error node is embedded in the tree&quot; so it knows not to try that parse again?</z><z id="t1527784069" t="aengelberg @sova this talk explains the internals pretty well https://www.youtube.com/watch?v=b2AUW6psVcE"><y>#</y><d>2018-05-31</d><h>16:27</h><w>aengelberg</w>@sova this talk explains the internals pretty well <a href="https://www.youtube.com/watch?v=b2AUW6psVcE" target="_blank">https://www.youtube.com/watch?v=b2AUW6psVcE</a></z><z id="t1527784124" t="sova-soars-the-sora oh nice. thank you! i was very curious because it&apos;s very powerful and very fast and i don&apos;t remember things being so fast in compilers class 😄"><y>#</y><d>2018-05-31</d><h>16:28</h><w>sova-soars-the-sora</w>oh nice.  thank you!  i was very curious because it&apos;s very powerful and very fast and i don&apos;t remember things being so fast in compilers class <b>😄</b></z><z id="t1527784161" t="aengelberg glad to hear it&apos;s fast! Although what makes Instaparse really unique is that it works well with left-recursive and ambiguous grammars"><y>#</y><d>2018-05-31</d><h>16:29</h><w>aengelberg</w>glad to hear it&apos;s fast! Although what makes Instaparse really unique is that it works well with left-recursive and ambiguous grammars</z><z id="t1527784192" t="aengelberg something like S = &apos;a&apos; | S &apos;a&apos; usually doesn&apos;t work in normal parsers"><y>#</y><d>2018-05-31</d><h>16:29</h><w>aengelberg</w>something like
<pre>S = &apos;a&apos; | S &apos;a&apos;
</pre>
usually doesn&apos;t work in normal parsers</z><z id="t1527784221" t="sova-soars-the-sora leftwards-building strings... I see that is cool"><y>#</y><d>2018-05-31</d><h>16:30</h><w>sova-soars-the-sora</w>leftwards-building strings... I see  that is cool</z><z id="t1527784480" t="sova-soars-the-sora I want to do some language processing stuff -- eventually reduce articles people write to synopses and relevant tags. i feel like that&apos;s very possible but i gotta think a bit more on the approach. like checking words against a dictionary to try and focus on nouns and verbs"><y>#</y><d>2018-05-31</d><h>16:34</h><w>sova-soars-the-sora</w>I want to do some language processing stuff -- eventually reduce articles people write to synopses and relevant tags.  i feel like that&apos;s very possible but i gotta think a bit more on the approach.  like checking words against a dictionary to try and focus on nouns and verbs</z><z id="t1527785749" t="sova-soars-the-sora aha, now i know why the file is called .gll 😄"><y>#</y><d>2018-05-31</d><h>16:55</h><w>sova-soars-the-sora</w>aha, now i know why the file is called .gll <b>😄</b></z><z id="t1527787286" t="sova-soars-the-sora &quot;send me all your old magazine subscriptions before any new ones&quot; is a good way to explain how it works briefly."><y>#</y><d>2018-05-31</d><h>17:21</h><w>sova-soars-the-sora</w>&quot;send me all your old magazine subscriptions before any new ones&quot; is a good way to explain how it works briefly.</z><z id="t1533233430" t="mlimotte Can I get some help with a (hopefully) a simple grammar? I haven’t done much with CFGs so I could be totally off base. I want to find variable expressions in a string. For example: hello, {{name}}. This is similar to the Mustache variety of interpolation, but I need to pre-parse it to do something slightly different. I can recognize the pattern above pretty easily. My problem is having it ignore single brackets. For example: hello, {{name}}. Please choose {Yes, No}. The last part is not a double bracket expression and should just be treated like the other uninteresting text. So, my grammar looks like this (I’ve tried a bunch of other variations, this is the closest I’ve come): (def p (insta/parser &quot;&lt;S&gt; = (block | TXT)* block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt; &lt;TXT&gt; = (OPEN | CLOSE | A | block)* &lt;OPEN&gt; = !&apos;{&apos; &apos;{&apos; &lt;CLOSE&gt; = !&apos;}&apos; &apos;}&apos; &lt;A&gt; = #&apos;[^{}]*&apos;&quot;)) "><y>#</y><d>2018-08-02</d><h>18:10</h><w>mlimotte</w>Can I get some help with a (hopefully) a simple grammar?  I haven’t done much with CFGs so I could be totally off base.
I want to find variable expressions in a string.  
For example:  <code>hello, {{name}}.</code>
This is similar to the Mustache variety of interpolation, but I need to pre-parse it to do something slightly different.

I can recognize the pattern above pretty easily.  My problem is having it ignore single brackets.
For example: <code>hello, {{name}}.  Please choose {Yes, No}.</code>
The last part is not a double bracket expression and should just be treated like the other uninteresting text.

So, my grammar looks like this (I’ve tried a bunch of other variations, this is the closest I’ve come):

<pre>(def p 
  (insta/parser
    &quot;&lt;S&gt; = (block | TXT)*
     block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
     &lt;TXT&gt; = (OPEN | CLOSE | A | block)*
     &lt;OPEN&gt; = !&apos;{&apos; &apos;{&apos;
     &lt;CLOSE&gt; = !&apos;}&apos; &apos;}&apos;
     &lt;A&gt; = #&apos;[^{}]*&apos;&quot;))
</pre></z><z id="t1533233523" t="mlimotte A call (p &quot;x{a}&quot;) yields: =&gt; Parse error at line 1, column 2: x{a} ^ Expected one of: &quot;{{&quot; &quot;}&quot; NOT &quot;{&quot; "><y>#</y><d>2018-08-02</d><h>18:12</h><w>mlimotte</w>A call <code>(p &quot;x{a}&quot;)</code> yields:
<pre>=&gt; Parse error at line 1, column 2:
x{a}
 ^
Expected one of:
&quot;{{&quot;
&quot;}&quot;
NOT &quot;{&quot;
</pre></z><z id="t1533233574" t="mlimotte Seems like the x got picked up by &lt;A&gt;. I would have liked it to match !‘{’, so that the next char could match in &lt;OPEN&gt;"><y>#</y><d>2018-08-02</d><h>18:12</h><w>mlimotte</w>Seems like the <code>x</code> got picked up by &lt;A&gt;.  I would have liked it to match !‘{’, so that the next char could match in &lt;OPEN&gt;</z><z id="t1533233587" t="aengelberg try changing the OPEN and CLOSE rules to &lt;OPEN&gt; = &apos;{&apos; !&apos;{&apos; &lt;CLOSE&gt; = &apos;}&apos; !&apos;}&apos; "><y>#</y><d>2018-08-02</d><h>18:13</h><w>aengelberg</w>try changing the <code>OPEN</code> and <code>CLOSE</code> rules to
<pre>&lt;OPEN&gt; = &apos;{&apos; !&apos;{&apos;
&lt;CLOSE&gt; = &apos;}&apos; !&apos;}&apos;
</pre></z><z id="t1533233674" t="mlimotte 😄"><y>#</y><d>2018-08-02</d><h>18:14</h><w>mlimotte</w><b>😄</b></z><z id="t1533233678" t="mlimotte That seems to work."><y>#</y><d>2018-08-02</d><h>18:14</h><w>mlimotte</w>That seems to work.</z><z id="t1533233710" t="aengelberg The problem in the original grammar was that the negative lookahead was conflicting with the token itself. It was basically saying &quot;If there isn&apos;t an open bracket, please parse an open bracket&quot;"><y>#</y><d>2018-08-02</d><h>18:15</h><w>aengelberg</w>The problem in the original grammar was that the negative lookahead was conflicting with the token itself. It was basically saying &quot;If there isn&apos;t an open bracket, please parse an open bracket&quot;</z><z id="t1533233726" t="aengelberg Whereas what you really want is &quot;Please parse an open bracket but only if there isn&apos;t another open bracket right after&quot;"><y>#</y><d>2018-08-02</d><h>18:15</h><w>aengelberg</w>Whereas what you really want is &quot;Please parse an open bracket but only if there isn&apos;t another open bracket right after&quot;</z><z id="t1533233753" t="mlimotte hmm.. ok, i think that makes sense to me."><y>#</y><d>2018-08-02</d><h>18:15</h><w>mlimotte</w>hmm..  ok, i think that makes sense to me.</z><z id="t1533233766" t="mlimotte Very cool. Thanks for the quick help!"><y>#</y><d>2018-08-02</d><h>18:16</h><w>mlimotte</w>Very cool.  Thanks for the quick help!</z><z id="t1533233772" t="aengelberg no problem"><y>#</y><d>2018-08-02</d><h>18:16</h><w>aengelberg</w>no problem</z><z id="t1533233938" t="mlimotte Here’s an edge case that still fails. But it’s a bit contrived, so if it’s not a trivial fix, I don’t need to worry about it. (p &quot;{{y}&quot;)"><y>#</y><d>2018-08-02</d><h>18:18</h><w>mlimotte</w>Here’s an edge case that still fails.  But it’s a bit contrived, so if it’s not a trivial fix, I don’t need to worry about it.  
<code>(p &quot;{{y}&quot;)</code></z><z id="t1533233951" t="aengelberg do you want that to parse as normal text?"><y>#</y><d>2018-08-02</d><h>18:19</h><w>aengelberg</w>do you want that to parse as normal text?</z><z id="t1533233961" t="mlimotte yep"><y>#</y><d>2018-08-02</d><h>18:19</h><w>mlimotte</w>yep</z><z id="t1533233983" t="mlimotte not a block"><y>#</y><d>2018-08-02</d><h>18:19</h><w>mlimotte</w>not a <code>block</code></z><z id="t1533234098" t="aengelberg maybe something like &lt;S&gt; = TXT* block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt; &lt;TXT&gt; = (block / A)* &lt;A&gt; = #&apos;[^{}]*&apos; | &apos;{&apos; | &apos;}&apos; "><y>#</y><d>2018-08-02</d><h>18:21</h><w>aengelberg</w>maybe something like
<pre>&lt;S&gt; = TXT*
block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
&lt;TXT&gt; = (block / A)*
&lt;A&gt; = #&apos;[^{}]*&apos; | &apos;{&apos; | &apos;}&apos;
</pre></z><z id="t1533234147" t="aengelberg here I&apos;m changing the A rule to match any text (including brackets and double brackets) but then using the ordered choice (`/`) to prefer parsing complete blocks when possible."><y>#</y><d>2018-08-02</d><h>18:22</h><w>aengelberg</w>here I&apos;m changing the <code>A</code> rule to match any text (including brackets and double brackets) but then using the ordered choice (`/`) to prefer parsing complete blocks when possible.</z><z id="t1533234281" t="mlimotte oh.. that’s great. I had tried an approach like that previously, but didn’t know how to prefer one parse over another … that / operator is new to me."><y>#</y><d>2018-08-02</d><h>18:24</h><w>mlimotte</w>oh.. that’s great.  I had tried an approach like that previously, but didn’t know how to prefer one parse over another … that <code>/</code> operator is new to me.</z><z id="t1533234297" t="aengelberg :+1:"><y>#</y><d>2018-08-02</d><h>18:24</h><w>aengelberg</w><b>:+1:</b></z><z id="t1533234328" t="mlimotte thanks for your help, again"><y>#</y><d>2018-08-02</d><h>18:25</h><w>mlimotte</w>thanks for your help, again</z><z id="t1533234333" t="aengelberg np"><y>#</y><d>2018-08-02</d><h>18:25</h><w>aengelberg</w>np</z><z id="t1535126314" t="aengelberg"><y>#</y><d>2018-08-24</d><h>15:58</h><w>aengelberg</w></z><z id="t1535126339" t="aengelberg @jeroenvandijk that grammar doesn&apos;t appear to be valid BNF; many of the string tokens are not properly quoted"><y>#</y><d>2018-08-24</d><h>15:58</h><w>aengelberg</w>@jeroenvandijk that grammar doesn&apos;t appear to be valid BNF; many of the string tokens are not properly quoted</z><z id="t1535126419" t="aengelberg Also, instaparse has adopted the angle brackets &lt;&gt; to mean &quot;hiding tags&quot; (not an EBNF standard) but this AWS grammar uses them in all of the rule names, which might result in weird behavior"><y>#</y><d>2018-08-24</d><h>16:00</h><w>aengelberg</w>Also, instaparse has adopted the angle brackets <code>&lt;&gt;</code> to mean &quot;hiding tags&quot; (not an EBNF standard) but this AWS grammar uses them in all of the rule names, which might result in weird behavior</z><z id="t1535126441" t="aengelberg for example &lt;condition_block&gt; = &quot;Condition&quot; : { &lt;condition_map&gt; } should be condition_block = &quot;Condition&quot; &quot;:&quot; &quot;{&quot; condition_map &quot;}&quot; "><y>#</y><d>2018-08-24</d><h>16:00</h><w>aengelberg</w>for example
<pre>&lt;condition_block&gt; = &quot;Condition&quot; : { &lt;condition_map&gt; }
</pre>
should be
<pre>condition_block = &quot;Condition&quot; &quot;:&quot; &quot;{&quot; condition_map &quot;}&quot;
</pre></z><z id="t1535127732" t="hiredman my experience with instaparse, and other parsers for that matter, and external grammars, is pretty much no one provides complete grammars that are machine parseable."><y>#</y><d>2018-08-24</d><h>16:22</h><w>hiredman</w>my experience with instaparse, and other parsers for that matter, and external grammars, is pretty much no one provides complete grammars that are machine parseable.</z><z id="t1535127896" t="hiredman it is incredibly frustrating to find out that, for example, the only grammar for the version 3 of the protobuf type description language available is incomplete and only published as fragments in &lt;pre&gt; blocks on the protobuf website"><y>#</y><d>2018-08-24</d><h>16:24</h><w>hiredman</w>it is incredibly frustrating to find out that, for example, the only grammar for the version 3 of the protobuf type description language available is incomplete and only published as fragments in &lt;pre&gt; blocks on the protobuf website</z><z id="t1535356272" t="jeroenvandijk @aengelberg @hiredman interesting. I was hoping it to have a parser one copy paste away 🙂"><y>#</y><d>2018-08-27</d><h>07:51</h><w>jeroenvandijk</w>@aengelberg @hiredman interesting. I was hoping it to have a parser one copy paste away <b>🙂</b></z><z id="t1535356351" t="jeroenvandijk When I remove the &apos;&lt;&gt;&apos;, instaparse is complaining over the use of : , ... and it is missing condition_map . I think I have to do a proper investigation where this parser is being used to understand how it should work"><y>#</y><d>2018-08-27</d><h>07:52</h><w>jeroenvandijk</w>When I remove the &apos;&lt;&gt;&apos;, instaparse is complaining over the use of <code>:</code>, <code>...</code> and it is missing <code>condition_map</code>. I think I have to do a proper investigation where this parser is being used to understand how it should work</z><z id="t1535356364" t="jeroenvandijk Thanks for your feedback"><y>#</y><d>2018-08-27</d><h>07:52</h><w>jeroenvandijk</w>Thanks for your feedback</z><z id="t1535382432" t="aengelberg no problem"><y>#</y><d>2018-08-27</d><h>15:07</h><w>aengelberg</w>no problem</z><z id="t1536666918" t="souenzzo There is some repo with a colaborative collection of useful/example grammars?"><y>#</y><d>2018-09-11</d><h>11:55</h><w>souenzzo</w>There is some repo with a colaborative collection of useful/example grammars?</z><z id="t1537376729" t="aengelberg hmm not that I know of"><y>#</y><d>2018-09-19</d><h>17:05</h><w>aengelberg</w>hmm not that I know of</z><z id="t1537471332" t="drone anyone know of an instaparse grammar for C? I’m checking out mcc ( https://github.com/zmaril/mcc ), but looks like it may be incomplete and bit-rotted"><y>#</y><d>2018-09-20</d><h>19:22</h><w>drone</w>anyone know of an instaparse grammar for C? I’m checking out mcc (<a href="https://github.com/zmaril/mcc" target="_blank">https://github.com/zmaril/mcc</a>), but looks like it may be incomplete and bit-rotted</z><z id="t1537471366" t="aengelberg not that I&apos;m aware of"><y>#</y><d>2018-09-20</d><h>19:22</h><w>aengelberg</w>not that I&apos;m aware of</z><z id="t1537471394" t="drone thanks"><y>#</y><d>2018-09-20</d><h>19:23</h><w>drone</w>thanks</z><z id="t1540501436" t="schmee hey folks! I’m trying to write my first parser for a very simple file format. I’ve made it work, but my solution uses negative lookahead. Is there any way to write a grammar that produces the same output without negative lookahead? here a REPL example:"><y>#</y><d>2018-10-25</d><h>21:03</h><w>schmee</w>hey folks! I’m trying to write my first parser for a very simple file format. I’ve made it work, but my solution uses negative lookahead. Is there any way to write a grammar that produces the same output without negative lookahead? here a REPL example:</z><z id="t1540501440" t="schmee user=&gt; (def s #_=&gt; &quot;NAME=Thing 1 #_=&gt; ACTIVE=120201-171231 #_=&gt; #_=&gt; NAME=Thing 2 #_=&gt; ACTIVE=120201-171231&quot;) #_=&gt; #&apos;user/s user=&gt; (def grammar #_=&gt; (insta/parser #_=&gt; &quot;top = (block &lt;newline?&gt;)+ #_=&gt; block = line+ !line #_=&gt; line = key &lt;&apos;=&apos;&gt; value &lt;newline?&gt; #_=&gt; key = #&apos;[A-Z]+&apos; #_=&gt; value = #&apos;[^\n]*&apos; #_=&gt; newline = &apos;\n&apos;&quot;)) #_=&gt; #&apos;user/grammar user=&gt; (clojure.pprint/pprint (insta/parse grammar s)) [:top [:block [:line [:key &quot;NAME&quot;] [:value &quot;Thing 1&quot;]] [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]] [:block [:line [:key &quot;NAME&quot;] [:value &quot;Thing 2&quot;]] [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]] nil "><y>#</y><d>2018-10-25</d><h>21:04</h><w>schmee</w><pre>user=&gt; (def s
   #_=&gt;   &quot;NAME=Thing 1
   #_=&gt; ACTIVE=120201-171231
   #_=&gt;
   #_=&gt; NAME=Thing 2
   #_=&gt; ACTIVE=120201-171231&quot;)
   #_=&gt;
#&apos;user/s

user=&gt; (def grammar
   #_=&gt;   (insta/parser
   #_=&gt;     &quot;top = (block &lt;newline?&gt;)+
   #_=&gt;      block = line+ !line
   #_=&gt;      line = key &lt;&apos;=&apos;&gt; value &lt;newline?&gt;
   #_=&gt;      key = #&apos;[A-Z]+&apos;
   #_=&gt;      value = #&apos;[^\n]*&apos;
   #_=&gt;      newline = &apos;\n&apos;&quot;))
   #_=&gt;
#&apos;user/grammar

user=&gt; (clojure.pprint/pprint (insta/parse grammar s))
[:top
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 1&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 2&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]]
nil
</pre></z><z id="t1540501699" t="schmee if there’s any other way to simplify it I’d love to hear about it 🙂"><y>#</y><d>2018-10-25</d><h>21:08</h><w>schmee</w>if there’s any other way to simplify it I’d love to hear about it <b>🙂</b></z><z id="t1541074394" t="socksy I don&apos;t have a repl to hand, but couldn&apos;t you use a newline as a character separator rather than a negative look ahead for another line? "><y>#</y><d>2018-11-01</d><h>12:13</h><r>socksy</r>I don&apos;t have a repl to hand, but couldn&apos;t you use a newline as a character separator rather than a negative look ahead for another line? </z><z id="t1542637203" t="Vincent Cantin Hello. I am starting to use instaparse, and I am matching the end of a multi-line string using #&apos;\\Z&apos; . While it seems to work, is it the correct way to match it?"><y>#</y><d>2018-11-19</d><h>14:20</h><w>Vincent Cantin</w>Hello. I am starting to use instaparse, and I am matching the end of a multi-line string using <code>#&apos;\\Z&apos;</code>. While it seems to work, is it the correct way to match it?</z><z id="t1542646403" t="aengelberg @vincent.cantin that seems like a legit approach to me; I&apos;d have to know more about your broader use case to know whether there&apos;s a more elegant overall approach."><y>#</y><d>2018-11-19</d><h>16:53</h><w>aengelberg</w>@vincent.cantin that seems like a legit approach to me; I&apos;d have to know more about your broader use case to know whether there&apos;s a more elegant overall approach.</z><z id="t1542646833" t="aengelberg for example, you could use the instaparse negative lookahead feature (`!`) to determine whether there are no more tokens to match"><y>#</y><d>2018-11-19</d><h>17:00</h><w>aengelberg</w>for example, you could use the instaparse negative lookahead feature (`!`) to determine whether there are no more tokens to match</z><z id="t1542706229" t="Vincent Cantin @aengelberg The context is: I am parsing a markdown document and I need to detect a line separator as either something based on \n and \r, or either the end of the document."><y>#</y><d>2018-11-20</d><h>09:30</h><w>Vincent Cantin</w>@aengelberg The context is: I am parsing a markdown document and I need to detect a line separator as either something based on \n and \r, or either the end of the document.</z><z id="t1542706310" t="Vincent Cantin Thank you for the negative lookahead hint, I will try it."><y>#</y><d>2018-11-20</d><h>09:31</h><w>Vincent Cantin</w>Thank you for the negative lookahead hint, I will try it.</z><z id="t1542733918" t="aengelberg @vincent.cantin you could maybe structure the parser as S = line (separator line)* separator = &apos;\n&apos; | &apos;\r&apos; then you don&apos;t have to explicitly check whether it reaches the end of the file."><y>#</y><d>2018-11-20</d><h>17:11</h><w>aengelberg</w>@vincent.cantin you could maybe structure the parser as
<pre>S = line (separator line)*
separator = &apos;\n&apos; | &apos;\r&apos;
</pre>
then you don&apos;t have to explicitly check whether it reaches the end of the file.</z><z id="t1542868881" t="Vincent Cantin That would be doable, but it requires to adapt the full grammar for that."><y>#</y><d>2018-11-22</d><h>06:41</h><r>Vincent Cantin</r>That would be doable, but it requires to adapt the full grammar for that.</z><z id="t1542799378" t="Vincent Cantin I am currently reading the CommonMark specification for parsing markdown format. Do you know if anybody already wrote such a parser with instaparse?"><y>#</y><d>2018-11-21</d><h>11:22</h><w>Vincent Cantin</w>I am currently reading the CommonMark specification for parsing markdown format. Do you know if anybody already wrote such a parser with instaparse?</z><z id="t1542799775" t="Vincent Cantin I found this project but it is a simple version, not the full spec. https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj"><y>#</y><d>2018-11-21</d><h>11:29</h><w>Vincent Cantin</w>I found this project but it is a simple version, not the full spec. <a href="https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj" target="_blank">https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj</a></z><z id="t1542809623" t="Vincent Cantin The reason I ask is that I am implementing one using instaparse. I just started recently, it’s called hiccdown."><y>#</y><d>2018-11-21</d><h>14:13</h><w>Vincent Cantin</w>The reason I ask is that I am implementing one using instaparse. I just started recently, it’s called hiccdown.</z><z id="t1542868512" t="Vincent Cantin I found a strange behavior with #&apos;\\Z&apos; , I wonder if it is a bug or if it is normal. ((insta/parser &quot;Paragraph = NonBlankLine+ BlankLine+ BlankLine = #&apos;[ \\t]&apos;* EOL NonBlankLine = #&apos;\\S&apos;+ EOL EOL = (#&apos;\\n&apos; | EOF) EOF = #&apos;\\Z&apos;&quot;) &quot;abc\ndef\n&quot;) =&gt; [:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]] [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL [:EOF &quot;&quot;]]] [:BlankLine [:EOL &quot;\n&quot;]]] "><y>#</y><d>2018-11-22</d><h>06:35</h><w>Vincent Cantin</w>I found a strange behavior with <code>#&apos;\\Z&apos;</code>, I wonder if it is a bug or if it is normal.

<pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = #&apos;\\Z&apos;&quot;)
 &quot;abc\ndef\n&quot;)

=&gt; 
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL [:EOF &quot;&quot;]]]
 [:BlankLine [:EOL &quot;\n&quot;]]]
</pre></z><z id="t1542868623" t="Vincent Cantin EOF appears before &quot;\n&quot; in the parsed result."><y>#</y><d>2018-11-22</d><h>06:37</h><w>Vincent Cantin</w>EOF appears before <code>&quot;\n&quot;</code> in the parsed result.</z><z id="t1542869183" t="Vincent Cantin This other approach which uses the negative lookahead does put the &quot;\n&quot; in the right place in the result, but there is another problem: The BlankLine is missing in the result. That may be a bug of instaparse. I am using the version 1.4.9 . ((insta/parser &quot;Paragraph = NonBlankLine+ BlankLine+ BlankLine = #&apos;[ \\t]&apos;* EOL NonBlankLine = #&apos;\\S&apos;+ EOL EOL = (#&apos;\\n&apos; | EOF) EOF = !#&apos;.&apos;&quot;) &quot;abc\ndef\n&quot;) =&gt; [:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]] [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]] "><y>#</y><d>2018-11-22</d><h>06:46</h><w>Vincent Cantin</w>This other approach which uses the negative lookahead does put the <code>&quot;\n&quot;</code> in the right place in the result, but there is another problem: The <code>BlankLine</code> is missing in the result. That may be a bug of instaparse. I am using the version <code>1.4.9</code>.

<pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = !#&apos;.&apos;&quot;)
 &quot;abc\ndef\n&quot;)
=&gt;
[:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
            [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]]
</pre></z><z id="t1542870534" t="Vincent Cantin I am going to use this workaround for now: append “EOF” at the end of the input and parse it. It works very well 🙂 ((insta/parser &quot;Paragraph = NonBlankLine+ BlankLine+ BlankLine = #&apos;[ \\t]&apos;* EOL NonBlankLine = #&apos;\\S&apos;+ EOL EOL = (#&apos;\\n&apos; | EOF) EOF = &apos;EOF&apos; #&apos;\\Z&apos;&quot;) ; works as well with !#&apos;.&apos; &quot;abc\ndef\nEOF&quot;) =&gt; [:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]] [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]] [:BlankLine [:EOL [:EOF &quot;EOF&quot; &quot;&quot;]]]] "><y>#</y><d>2018-11-22</d><h>07:08</h><w>Vincent Cantin</w>I am going to use this workaround for now: append “EOF” at the end of the input and parse it. It works very well <b>🙂</b>
<pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = &apos;EOF&apos; #&apos;\\Z&apos;&quot;) ; works as well with !#&apos;.&apos;
 &quot;abc\ndef\nEOF&quot;)
=&gt;
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]
 [:BlankLine [:EOL [:EOF &quot;EOF&quot; &quot;&quot;]]]]
</pre></z><z id="t1542899976" t="sova-soars-the-sora love instaparse"><y>#</y><d>2018-11-22</d><h>15:19</h><w>sova-soars-the-sora</w>love instaparse</z><z id="t1549309937" t="mattly is there a way to get line/column numbers associated with the tokens generated from instaparse?"><y>#</y><d>2019-02-04</d><h>19:52</h><w>mattly</w>is there a way to get line/column numbers associated with the tokens generated from instaparse?</z><z id="t1549310021" t="aengelberg Yeah, check out instaparse.line-col"><y>#</y><d>2019-02-04</d><h>19:53</h><w>aengelberg</w>Yeah, check out <code>instaparse.line-col</code></z><z id="t1549310169" t="mattly yay!"><y>#</y><d>2019-02-04</d><h>19:56</h><w>mattly</w>yay!</z><z id="t1549310171" t="mattly thanks"><y>#</y><d>2019-02-04</d><h>19:56</h><w>mattly</w>thanks</z><z id="t1549318658" t="souenzzo it&apos;s just DATA"><y>#</y><d>2019-02-04</d><h>22:17</h><w>souenzzo</w>it&apos;s just DATA</z><z id="t1549318691" t="aengelberg it&apos;s not code, it&apos;s DATA"><y>#</y><d>2019-02-04</d><h>22:18</h><w>aengelberg</w>it&apos;s not code, it&apos;s DATA</z><z id="t1558489406" t="souenzzo is possible to write a grammar for clojure? including things like ^metadata and ;; comments"><y>#</y><d>2019-05-22</d><h>01:43</h><w>souenzzo</w>is possible to write a grammar for clojure?
including things like <code>^metadata</code> and <code>;; comments</code></z><z id="t1558987821" t="aengelberg It should be possible, yes"><y>#</y><d>2019-05-27</d><h>20:10</h><w>aengelberg</w>It should be possible, yes</z><z id="t1558987829" t="aengelberg I&apos;m not aware of any prior art"><y>#</y><d>2019-05-27</d><h>20:10</h><w>aengelberg</w>I&apos;m not aware of any prior art</z><z id="t1565990285" t="aengelberg not to my knowledge, unless you count ClojureScript"><y>#</y><d>2019-08-16</d><h>21:18</h><w>aengelberg</w>not to my knowledge, unless you count ClojureScript</z><z id="t1565990321" t="aengelberg the underlying engine is actually based on an existing algorithm called GLL, which was originally implemented in Racket https://github.com/epsil/gll"><y>#</y><d>2019-08-16</d><h>21:18</h><w>aengelberg</w>the underlying engine is actually based on an existing algorithm called GLL, which was originally implemented in Racket <a href="https://github.com/epsil/gll" target="_blank">https://github.com/epsil/gll</a></z><z id="t1565990408" t="aengelberg but being able to create parsers based on arbitrary EBNF specifications (rather than a language-specific DSL of combinators) I think is unique to instaparse"><y>#</y><d>2019-08-16</d><h>21:20</h><w>aengelberg</w>but being able to create parsers based on arbitrary EBNF specifications (rather than a language-specific DSL of combinators) I think is unique to instaparse</z><z id="t1565990453" t="pepas yeah, I was so surprised when I started getting into parsers and no one seemed to take BNF as input"><y>#</y><d>2019-08-16</d><h>21:20</h><w>pepas</w>yeah, I was so surprised when I started getting into parsers and no one seemed to take BNF as input</z><z id="t1565990462" t="pepas Huge kudos to you and your old man!"><y>#</y><d>2019-08-16</d><h>21:21</h><w>pepas</w>Huge kudos to you and your old man!</z><z id="t1565990467" t="aengelberg thanks!"><y>#</y><d>2019-08-16</d><h>21:21</h><w>aengelberg</w>thanks!</z><z id="t1566531802" t="hiredman is there I recommended way for dealing with C style comments like / ... / instagram parsers? I vaguely recall maybe trying to handle them with a custom whitespace rule, but it has been a long time"><y>#</y><d>2019-08-23</d><h>03:43</h><w>hiredman</w>is there I recommended way for dealing with C style comments like / ... / instagram parsers? I vaguely recall maybe trying to handle them with a custom whitespace rule, but it has been a long time</z><z id="t1570984898" t="skelter I have a combination of a parser and a particular data file that causes the parser to consume CPU and memory until out of memory exception."><y>#</y><d>2019-10-13</d><h>16:41</h><w>skelter</w>I have a combination of a parser and a particular data file that causes the parser to consume CPU and memory until out of memory exception.</z><z id="t1571089622" t="aengelberg that&apos;s not good"><y>#</y><d>2019-10-14</d><h>21:47</h><w>aengelberg</w>that&apos;s not good</z><z id="t1571192275" t="skelter I think I now have it isolated to its own project, if you’d like a captured specimen."><y>#</y><d>2019-10-16</d><h>02:17</h><w>skelter</w>I think I now have it isolated to its own project, if you’d like a captured specimen.</z><z id="t1571192294" t="aengelberg that would be great"><y>#</y><d>2019-10-16</d><h>02:18</h><w>aengelberg</w>that would be great</z><z id="t1571192301" t="aengelberg github tickets also welcome"><y>#</y><d>2019-10-16</d><h>02:18</h><w>aengelberg</w>github tickets also welcome</z><z id="t1571275889" t="skelter Not sure I want this particular specimen in the public pipeline. Maybe if I can reduce it to something more comfortable."><y>#</y><d>2019-10-17</d><h>01:31</h><w>skelter</w>Not sure I want this particular specimen in the public pipeline.  Maybe if I can reduce it to something more comfortable.</z><z id="t1571276492" t="skelter regarding the channel description line, what is a good example of trampolining a parser?"><y>#</y><d>2019-10-17</d><h>01:41</h><w>skelter</w>regarding the channel description line, what is a good example of trampolining a parser?</z><z id="t1571290567" t="hiredman I suspect it is tongue in cheek, the internals of instaparse(and many gll parsers) use what you could call a trampoline to drive parsing"><y>#</y><d>2019-10-17</d><h>05:36</h><w>hiredman</w>I suspect it is tongue in cheek, the internals of instaparse(and many gll parsers) use what you could call a trampoline to drive parsing</z><z id="t1571295174" t="aengelberg yeah, I think that came from a conversation with @gfredericks in which we discussed parsers generating parsers or some other unusual use case"><y>#</y><d>2019-10-17</d><h>06:52</h><w>aengelberg</w>yeah, I think that came from a conversation with @gfredericks in which we discussed parsers generating parsers or some other unusual use case</z><z id="t1571438354" t="gfredericks Slander. I don&apos;t recall any such thing."><y>#</y><d>2019-10-18</d><h>22:39</h><w>gfredericks</w>Slander. I don&apos;t recall any such thing.</z><z id="t1572354437" t="Daniel Hines Does there happen to exist a tool for taking an instaparse grammar and generating random strings with it?"><y>#</y><d>2019-10-29</d><h>13:07</h><w>Daniel Hines</w>Does there happen to exist a tool for taking an instaparse grammar and generating random strings with it?</z><z id="t1572414114" t="aengelberg @d4hines the idea has been tossed around a couple times, but the only implementation I&apos;m aware of is my experiment https://github.com/aengelberg/instagenerate which isn&apos;t super useable in practice."><y>#</y><d>2019-10-30</d><h>05:41</h><w>aengelberg</w>@d4hines the idea has been tossed around a couple times, but the only implementation I&apos;m aware of is my experiment <a href="https://github.com/aengelberg/instagenerate" target="_blank">https://github.com/aengelberg/instagenerate</a> which isn&apos;t super useable in practice.</z><z id="t1572414386" t="aengelberg My usage of core.logic was primarily motivated by a challenge to reverse-engineer output parse trees or fill in partial outputs. But if the main goal is to simply generate random inputs to a grammar (which most people really want), I think the implementation could be a lot cleaner, and leverage test.check."><y>#</y><d>2019-10-30</d><h>05:46</h><w>aengelberg</w>My usage of core.logic was primarily motivated by a challenge to reverse-engineer output parse trees or fill in partial outputs. But if the main goal is to simply generate random inputs to a grammar (which most people really want), I think the implementation could be a lot cleaner, and leverage test.check.</z><z id="t1572414440" t="aengelberg The hardest part I think would be coming up with a good solution to lookahead and negative lookahead, while guaranteeing terminable generation..."><y>#</y><d>2019-10-30</d><h>05:47</h><w>aengelberg</w>The hardest part I think would be coming up with a good solution to lookahead and negative lookahead, while guaranteeing terminable generation...</z><z id="t1572443134" t="Daniel Hines I&apos;m a noob when it comes to this stuff. Do you need lookahead for an EBNF grammar?"><y>#</y><d>2019-10-30</d><h>13:45</h><r>Daniel Hines</r>I&apos;m a noob when it comes to this stuff. Do you need lookahead for an EBNF grammar?</z><z id="t1572622180" t="aengelberg I don’t think so, it’s just a nice feature that sometimes people take advantage of"><y>#</y><d>2019-11-01</d><h>15:29</h><r>aengelberg</r>I don’t think so, it’s just a nice feature that sometimes people take advantage of</z><z id="t1572439743" t="Daniel Hines That&apos;s really cool!"><y>#</y><d>2019-10-30</d><h>12:49</h><w>Daniel Hines</w>That&apos;s really cool!</z><z id="t1572440593" t="jeroenvandijk Maybe this project is relevant https://github.com/cs-au-dk/dk.brics.automaton ? We used it to generate data, also from regexps"><y>#</y><d>2019-10-30</d><h>13:03</h><w>jeroenvandijk</w>Maybe this project is relevant <a href="https://github.com/cs-au-dk/dk.brics.automaton" target="_blank">https://github.com/cs-au-dk/dk.brics.automaton</a> ? We used it to generate data, also from regexps</z><z id="t1572445657" t="gfredericks When I wrote a generator for regexes I intentionally didn&apos;t try to support lookaheadbehinds"><y>#</y><d>2019-10-30</d><h>14:27</h><w>gfredericks</w>When I wrote a generator for regexes I intentionally didn&apos;t try to support lookaheadbehinds</z><z id="t1572445692" t="gfredericks But it seems like something you could support with the same caveats as such-that"><y>#</y><d>2019-10-30</d><h>14:28</h><w>gfredericks</w>But it seems like something you could support with the same caveats as such-that</z><z id="t1572445713" t="gfredericks (And have it fail the same way, rather than infinite loop)"><y>#</y><d>2019-10-30</d><h>14:28</h><w>gfredericks</w>(And have it fail the same way, rather than infinite loop)</z><z id="t1574769155" t="Ahmad Nazir Raja Hi, This is related to greedy behavior of instaparse. I have the following grammar: X := Y* Z* Y := CHAR Z := CHAR CHAR := (&apos;a&apos; | &apos;b&apos; | &apos;c&apos;) With input aaa I get the output shown below. I expect greedy behavior and that Y should be matched instead of Z. Does anyone have an idea to why this happens or how to enforce greedy behavior?"><y>#</y><d>2019-11-26</d><h>11:52</h><w>Ahmad Nazir Raja</w>Hi,
This is related to greedy behavior of instaparse. I have the following grammar:


<pre>X := Y* Z*

Y := CHAR
Z := CHAR

CHAR := (&apos;a&apos; | &apos;b&apos; | &apos;c&apos;)</pre>

With input <code>aaa</code> I get the output shown below. I expect greedy behavior and that Y should be matched instead of Z. Does anyone have an idea to why this happens or how to enforce greedy behavior?</z><z id="t1575398126" t="aengelberg @U82LVQ5NX sorry for the late reply, but instaparse doesn’t guarantee greediness or non-greediness; in fact, if you call insta/parses you will get every version of the parse including ones where Y is parsing some or all of the chars."><y>#</y><d>2019-12-03</d><h>18:35</h><r>aengelberg</r>@U82LVQ5NX sorry for the late reply, but instaparse doesn’t guarantee greediness or non-greediness; in fact, if you call <code>insta/parses</code> you will get every version of the parse including ones where <code>Y</code> is parsing some or all of the chars.</z><z id="t1575398280" t="Ahmad Nazir Raja Yes, I tried parses and I could see all versions. For some reason I thought there would be a way to prefer one version over the other. Anyway, thanks for the response."><y>#</y><d>2019-12-03</d><h>18:38</h><r>Ahmad Nazir Raja</r>Yes, I tried <code>parses</code> and I could see all versions. For some reason I thought there would be a way to prefer one version over the other. Anyway, thanks for the response.</z><z id="t1575398282" t="aengelberg You can achieve greediness by using negative lookahead: X := Y* !Y Z*"><y>#</y><d>2019-12-03</d><h>18:38</h><r>aengelberg</r>You can achieve greediness by using negative lookahead:
<pre>X := Y* !Y Z*</pre></z><z id="t1575398307" t="aengelberg this ensures that it won’t start parsing Z until it can’t parse Y anymore."><y>#</y><d>2019-12-03</d><h>18:38</h><r>aengelberg</r>this ensures that it won’t start parsing Z until it can’t parse Y anymore.</z><z id="t1575397996" t="Daniel Hines How do I read this?"><y>#</y><d>2019-12-03</d><h>18:33</h><w>Daniel Hines</w>How do I read this?</z><z id="t1575398035" t="Daniel Hines"><y>#</y><d>2019-12-03</d><h>18:33</h><w>Daniel Hines</w></z><z id="t1575398422" t="aengelberg I think the instaparse equivalent of this would be: remainder_sort_names := &apos;&apos; | &apos;,&apos; sort_name remainder_sorts"><y>#</y><d>2019-12-03</d><h>18:40</h><r>aengelberg</r>I think the instaparse equivalent of this would be:
<pre>remainder_sort_names := &apos;&apos; | &apos;,&apos; sort_name remainder_sorts</pre></z><z id="t1575398446" t="Daniel Hines Oh! Duh! Epsilon!"><y>#</y><d>2019-12-03</d><h>18:40</h><r>Daniel Hines</r>Oh! Duh! Epsilon!</z><z id="t1575398450" t="aengelberg although instaparse also supports ε as an alias for &apos;&apos;"><y>#</y><d>2019-12-03</d><h>18:40</h><r>aengelberg</r>although instaparse also supports <code>ε</code> as an alias for <code>&apos;&apos;</code></z><z id="t1575398480" t="Daniel Hines Noob fail. Thanks a bunch!"><y>#</y><d>2019-12-03</d><h>18:41</h><r>Daniel Hines</r>Noob fail. Thanks a bunch!</z><z id="t1578168105" t="sova-soars-the-sora Hi! Why is it called a &quot;Context-Free&quot; Grammar?"><y>#</y><d>2020-01-04</d><h>20:01</h><w>sova-soars-the-sora</w>Hi!  Why is it called a &quot;Context-Free&quot; Grammar?</z><z id="t1578168111" t="sova-soars-the-sora Isn&apos;t it nothing BUT context?"><y>#</y><d>2020-01-04</d><h>20:01</h><w>sova-soars-the-sora</w>Isn&apos;t it nothing BUT context?</z><z id="t1578168138" t="sova-soars-the-sora 😃"><y>#</y><d>2020-01-04</d><h>20:02</h><w>sova-soars-the-sora</w><b>😃</b></z><z id="t1578169011" t="gfredericks wikipedia says rules in a context-sensitive grammar take the form α_A_β → αγβ"><y>#</y><d>2020-01-04</d><h>20:16</h><w>gfredericks</w>wikipedia says rules in a context-sensitive grammar take the form

α_A_β → αγβ</z><z id="t1578191828" t="sova-soars-the-sora Hmmm I seeeee. Thank you @gfredericks"><y>#</y><d>2020-01-05</d><h>02:37</h><w>sova-soars-the-sora</w>Hmmm I seeeee.  Thank you @gfredericks</z><z id="t1578344123" t="hiredman I believe the terminology(and concepts) comes out of linguistics first (not cs) and was first used as a way to construct (or produce) all the strings in a language (a constructive definition of all the strings in a language). So context free comes from the fact that when you are using the grammar to construct strings you can apply the production rules anywhere they match without other restrictions"><y>#</y><d>2020-01-06</d><h>20:55</h><w>hiredman</w>I believe the terminology(and concepts) comes out of linguistics first (not cs) and was first used as a way to construct (or produce) all the strings in a language (a constructive definition of all the strings in a language). So context free comes from the fact that when you are using the grammar to construct strings you can apply the production rules anywhere they match without other restrictions</z><z id="t1578344311" t="hiredman https://en.m.wikipedia.org/wiki/Generative_grammar"><y>#</y><d>2020-01-06</d><h>20:58</h><w>hiredman</w><a href="https://en.m.wikipedia.org/wiki/Generative_grammar" target="_blank">https://en.m.wikipedia.org/wiki/Generative_grammar</a></z><z id="t1579966059" t="Adrian Smith https://i.imgur.com/G1xdp1F.png In this example how do I make it so the identifiers rule matches anything until the next rule along is valid?"><y>#</y><d>2020-01-25</d><h>15:27</h><w>Adrian Smith</w><a href="https://i.imgur.com/G1xdp1F.png" target="_blank">https://i.imgur.com/G1xdp1F.png</a> In this example how do I make it so the identifiers rule matches anything until the next rule along is valid?</z><z id="t1579966289" t="Adrian Smith ah I see it kind of explains this in https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning"><y>#</y><d>2020-01-25</d><h>15:31</h><w>Adrian Smith</w>ah I see it kind of explains this in <a href="https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning" target="_blank">https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning</a></z><z id="t1580043765" t="Adrian Smith how would you go about writing a grammer for SQL columns? where commas must appear between elements"><y>#</y><d>2020-01-26</d><h>13:02</h><w>Adrian Smith</w>how would you go about writing a grammer for SQL columns? where commas must appear between elements</z><z id="t1582276769" t="mmeix New to Instaparse and wrapping my head around grammars: how would I write a grammar that can do nested tag pairs like in xml: &quot;&lt;p&gt;&lt;span&gt;text&lt;/span&gt;&lt;/p&gt;&quot; =&gt; [:p [:span text]] ?"><y>#</y><d>2020-02-21</d><h>09:19</h><w>mmeix</w>New to Instaparse and wrapping my head around grammars: how would I write a grammar that can do nested tag pairs like in xml: <code>&quot;&lt;p&gt;&lt;span&gt;text&lt;/span&gt;&lt;/p&gt;&quot; =&gt; [:p [:span text]]</code> ?</z><z id="t1582763876" t="aengelberg it’s possible to parse XML hierarchies into Clojure data, however I don’t think you can enforce that the tags must be matching."><y>#</y><d>2020-02-27</d><h>00:37</h><r>aengelberg</r>it’s possible to parse XML hierarchies into Clojure data, however I don’t think you can enforce that the tags must be matching.</z><z id="t1582763916" t="aengelberg You can enforce that manually with your own custom logic after the fact, just not as part of the parser."><y>#</y><d>2020-02-27</d><h>00:38</h><r>aengelberg</r>You can enforce that manually with your own custom logic after the fact, just not as part of the parser.</z><z id="t1582822980" t="mmeix So I would just trust, that tags are properly matched/paired/nested."><y>#</y><d>2020-02-27</d><h>17:03</h><r>mmeix</r>So I would just trust, that tags are properly matched/paired/nested.</z><z id="t1582823026" t="mmeix and take each closing tag as the next needed"><y>#</y><d>2020-02-27</d><h>17:03</h><r>mmeix</r>and take each closing tag as the next needed</z><z id="t1582288244" t="manutter51 caveat: I haven’t had my coffee yet, but the basic idea is that you say something like “a BLOCK element is a P or a DIV or a TABLE (etc), an INLINE element is a SPAN or a B or TEXT (etc),” and then say “a P element is the literal string ‘&lt;P&gt;’ or ‘&lt;p&gt;’ followed by zero or more INLINE elements, followed by the literal string ‘&lt;/P&gt;’ or ‘&lt;/p&gt;’.” And similarly with SPAN."><y>#</y><d>2020-02-21</d><h>12:30</h><w>manutter51</w>caveat: I haven’t had my coffee yet, but the basic idea is that you say something like “a BLOCK element is a P or a DIV or a TABLE (etc), an INLINE element is a SPAN or a B or TEXT (etc),” and then say “a P element is the literal string ‘&lt;P&gt;’ or ‘&lt;p&gt;’ followed by zero or more INLINE elements, followed by the literal string ‘&lt;/P&gt;’ or ‘&lt;/p&gt;’.” And similarly with SPAN.</z><z id="t1582290696" t="mmeix ah! thanks ... that should start it"><y>#</y><d>2020-02-21</d><h>13:11</h><w>mmeix</w>ah! thanks ... that should start it</z><z id="t1582290832" t="manutter51 The other caveat is that Instaparse is incredibly fun to work with and may be addictive. 😉"><y>#</y><d>2020-02-21</d><h>13:13</h><w>manutter51</w>The other caveat is that Instaparse is incredibly fun to work with and may be addictive. <b>😉</b></z><z id="t1582295549" t="mmeix Confirmed! 😁"><y>#</y><d>2020-02-21</d><h>14:32</h><w>mmeix</w>Confirmed! <b>😁</b></z><z id="t1582820543" t="sova-soars-the-sora @mmeix it looks to me at first glance that you could make some rules span = &lt;span&gt; val &lt;/span&gt; paragraph = &lt;p&gt; val &lt;/p&gt; val = paragraph* | span* | val [editS: added stars to p and span in val]"><y>#</y><d>2020-02-27</d><h>16:22</h><w>sova-soars-the-sora</w>@mmeix it looks to me at first glance that you could make some rules
span = &lt;span&gt; val &lt;/span&gt;
paragraph = &lt;p&gt; val &lt;/p&gt;
val = paragraph* | span* | val
[editS: added stars to p and span in val]</z><z id="t1582820559" t="sova-soars-the-sora the last rule allows recursion, which can infinitely nest spans or p&apos;s"><y>#</y><d>2020-02-27</d><h>16:22</h><w>sova-soars-the-sora</w>the last rule allows recursion, which can infinitely nest spans or p&apos;s</z><z id="t1582820579" t="sova-soars-the-sora notice how i defined the rigid components of the grammar on the right-hand side, with my variable, and how i use variable names only on the left-hand side."><y>#</y><d>2020-02-27</d><h>16:22</h><w>sova-soars-the-sora</w>notice how i defined the rigid components of the grammar on the right-hand side, with my variable, and how i use variable names only on the left-hand side.</z><z id="t1582820850" t="mmeix That looks like a good recipe. Thanks!"><y>#</y><d>2020-02-27</d><h>16:27</h><w>mmeix</w>That looks like a good recipe. Thanks!</z><z id="t1582820991" t="sova-soars-the-sora @mmeix http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1"><y>#</y><d>2020-02-27</d><h>16:29</h><w>sova-soars-the-sora</w>@mmeix <a href="http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1" target="_blank">http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1</a></z><z id="t1582821007" t="sova-soars-the-sora i had to make sure it works before setting you out"><y>#</y><d>2020-02-27</d><h>16:30</h><w>sova-soars-the-sora</w>i had to make sure it works before setting you out</z><z id="t1582821033" t="sova-soars-the-sora notice how there can be multiple valid parses with the recursion now."><y>#</y><d>2020-02-27</d><h>16:30</h><w>sova-soars-the-sora</w>notice how there can be multiple valid parses with the recursion now.</z><z id="t1582821167" t="sova-soars-the-sora you&apos;ll probably need to be creative with the output to get rid of tags you don&apos;t need 😃 i forget exactly how we would delete unnecessary strings in the grammar itself, there&apos;s a way with rules i think, it might just be mathematical though lol"><y>#</y><d>2020-02-27</d><h>16:32</h><w>sova-soars-the-sora</w>you&apos;ll probably need to be creative with the output to get rid of tags you don&apos;t need <b>😃</b>  i forget exactly how we would delete unnecessary strings in the grammar itself, there&apos;s a way with rules i think, it might just be mathematical though lol</z><z id="t1582822160" t="mmeix Getting rid of tags is done by enclosing them with &lt;…&gt;"><y>#</y><d>2020-02-27</d><h>16:49</h><w>mmeix</w>Getting rid of tags is done by enclosing them with &lt;…&gt;</z><z id="t1582822178" t="mmeix Thanks for the gist!"><y>#</y><d>2020-02-27</d><h>16:49</h><w>mmeix</w>Thanks for the gist!</z><z id="t1582822312" t="mmeix Now I’m thinking, if it would be possible to get a general solution without enumerating all possible tags (span, p , …). It would need to somehow remember the tag name until its closing cousin arrives"><y>#</y><d>2020-02-27</d><h>16:51</h><w>mmeix</w>Now I’m thinking, if it would be possible to get a general solution without enumerating all possible tags (span, p , …). It would need to somehow remember the tag name until its closing cousin arrives</z><z id="t1582822396" t="mmeix Didn’t know http://instaparse-live.matt.is ! Great tool!"><y>#</y><d>2020-02-27</d><h>16:53</h><w>mmeix</w>Didn’t know <a href="http://instaparse-live.matt.is" target="_blank">http://instaparse-live.matt.is</a> ! Great tool!</z><z id="t1582909209" t="sova-soars-the-sora @mmeix i think you probably want to parse this into a tree and go over it tree-style if you need opening/closing tag harmony. using a CFG to do that might be possible but it&apos;s more for orientable sequences. in reality if you wanted to you could just run over that thing wit a regex and make opening tags [: and closing tags ], throwing away &lt;/span&gt; and &lt;/p&gt; in favor of ] i would definitely write some sample input, some sample output, and then see what tool is best for the job. instaparse is indeed powerful, i used it to create an EBNF grammar representation of Japanese. https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/"><y>#</y><d>2020-02-28</d><h>17:00</h><w>sova-soars-the-sora</w>@mmeix i think you probably want to parse this into a tree and go over it tree-style if you need opening/closing tag harmony.  using a CFG to do that might be possible but it&apos;s more for orientable sequences.

in reality if you wanted to you could just run over that thing wit a regex and make opening tags [: and closing tags ], throwing away &lt;/span&gt; and &lt;/p&gt; in favor of ]

i would definitely write some sample input, some sample output, and then see what tool is best for the job.  instaparse is indeed powerful, i used it to create an EBNF grammar representation of Japanese.
<a href="https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/" target="_blank">https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/</a></z><z id="t1583380381" t="bmaddy I have a question about how to do something in Instaparse. Imagine a string like this: 3 1 John 0 2 Jane 2 1 3 3 Bob 0 The first number is the number of people. Then, for each person, an id, name, number of people they supervise, and list of ids for the people they supervise. So in that example string there are 3 people. Jane (id = 2) supervises John (id = 1) and Bob (id = 3). Can I use Instaparse to parse stuff like that? Specifically, I&apos;m wondering how to read a number n and parse exactly n items after that."><y>#</y><d>2020-03-05</d><h>03:53</h><w>bmaddy</w>I have a question about how to do something in Instaparse. Imagine a string like this:
<pre>3 1 John 0 2 Jane 2 1 3 3 Bob 0</pre>
The first number is the number of people. Then, for each person, an id, name, number of people they supervise, and list of ids for the people they supervise. So in that example string there are 3 people. Jane (id = 2) supervises John (id = 1) and Bob (id = 3). Can I use Instaparse to parse stuff like that? Specifically, I&apos;m wondering how to read a number n and parse exactly n items after that.</z><z id="t1583382587" t="aengelberg sadly Instaparse isn&apos;t well suited for situations where you parse a thing and then use that as an input to some later part of the same parser."><y>#</y><d>2020-03-05</d><h>04:29</h><w>aengelberg</w>sadly Instaparse isn&apos;t well suited for situations where you parse a thing and then use that as an input to some later part of the same parser.</z><z id="t1583382642" t="bmaddy Sounds good. Thank you!"><y>#</y><d>2020-03-05</d><h>04:30</h><w>bmaddy</w>Sounds good. Thank you!</z><z id="t1583429333" t="zane Out of curiosity, what would be better suited for situations like that?"><y>#</y><d>2020-03-05</d><h>17:28</h><w>zane</w>Out of curiosity, what would be better suited for situations like that?</z><z id="t1583444600" t="thom https://github.com/youngnh/parsatron might be a better fit"><y>#</y><d>2020-03-05</d><h>21:43</h><w>thom</w><a href="https://github.com/youngnh/parsatron" target="_blank">https://github.com/youngnh/parsatron</a> might be a better fit</z><z id="t1583444647" t="thom if you have a look at the way let-&gt;&gt; can be used in https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown"><y>#</y><d>2020-03-05</d><h>21:44</h><w>thom</w>if you have a look at the way <code>let-&gt;&gt;</code> can be used in <a href="https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown" target="_blank">https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown</a></z><z id="t1586607236" t="sova-soars-the-sora does one have to do anything special to use instaparse on the clientside (cljs) ?"><y>#</y><d>2020-04-11</d><h>12:13</h><w>sova-soars-the-sora</w>does one have to do anything special to use instaparse on the clientside (cljs) ?</z><z id="t1586617312" t="gfredericks I used it in https://gfredericks.com/things/bespoke-primes I don&apos;t remember doing anything special but that doesn&apos;t mean very much"><y>#</y><d>2020-04-11</d><h>15:01</h><w>gfredericks</w>I used it in <a href="https://gfredericks.com/things/bespoke-primes" target="_blank">https://gfredericks.com/things/bespoke-primes</a>

I don&apos;t remember doing anything special but that doesn&apos;t mean very much</z><z id="t1586644286" t="sova-soars-the-sora sweetness. looks like it should work outta da box!"><y>#</y><d>2020-04-11</d><h>22:31</h><w>sova-soars-the-sora</w>sweetness.  looks like it should work outta da box!</z><z id="t1586826485" t="zane Can confirm, does work outta da box. :+1: :skin-tone-2:"><y>#</y><d>2020-04-14</d><h>01:08</h><w>zane</w>Can confirm, does work outta da box. <b>:+1:</b><b>:skin-tone-2:</b></z><z id="t1586888373" t="zane I&apos;m curious how often folks wind up using records (vs other alternatives) when writing polymorphic transformation functions for their instaparse parse trees."><y>#</y><d>2020-04-14</d><h>18:19</h><w>zane</w>I&apos;m curious how often folks wind up using records (vs other alternatives) when writing polymorphic transformation functions for their instaparse parse trees.</z><z id="t1587066989" t="zane Judging from the README there doesn&apos;t appear to be a (public) function to get a data representation of an Instaparse grammar, but could someone confirm?"><y>#</y><d>2020-04-16</d><h>19:56</h><w>zane</w>Judging from the <code>README</code> there doesn&apos;t appear to be a (public) function to get a data representation of an Instaparse grammar, but could someone confirm?</z></g><g id="s5"><z id="t1587079469" t="gfredericks I was wanting that recently but I can&apos;t remember if it was for a good reason"><y>#</y><d>2020-04-16</d><h>23:24</h><w>gfredericks</w>I was wanting that recently but I can&apos;t remember if it was for a good reason</z><z id="t1587147502" t="zane I&apos;m wanting to generate documentation, but perhaps there&apos;s a better way to go about that."><y>#</y><d>2020-04-17</d><h>18:18</h><w>zane</w>I&apos;m wanting to generate documentation, but perhaps there&apos;s a better way to go about that.</z><z id="t1590602735" t="sova-soars-the-sora Hi everyone, I&apos;m interesting in dynamically defining grammar components. I have a big list of nouns, I&apos;d like to incorporate them into my grammar without too much crazy. Is there some way I can add in a dynamic rule with something like nouns = coll?"><y>#</y><d>2020-05-27</d><h>18:05</h><w>sova-soars-the-sora</w>Hi everyone, I&apos;m interesting in dynamically defining grammar components.  I have a big list of nouns, I&apos;d like to incorporate them into my grammar without too much crazy.  Is there some way I can add in a dynamic rule with something like nouns = coll?</z><z id="t1590602753" t="aengelberg You probably want instaparse.combinators"><y>#</y><d>2020-05-27</d><h>18:05</h><w>aengelberg</w>You probably want <code>instaparse.combinators</code></z><z id="t1590602799" t="sova-soars-the-sora thanks!"><y>#</y><d>2020-05-27</d><h>18:06</h><w>sova-soars-the-sora</w>thanks!</z><z id="t1590602812" t="sova-soars-the-sora i shall take a gander"><y>#</y><d>2020-05-27</d><h>18:06</h><w>sova-soars-the-sora</w>i shall take a gander</z><z id="t1590602834" t="aengelberg https://github.com/engelberg/instaparse#combinators"><y>#</y><d>2020-05-27</d><h>18:07</h><w>aengelberg</w><a href="https://github.com/engelberg/instaparse#combinators" target="_blank">https://github.com/engelberg/instaparse#combinators</a></z><z id="t1590602864" t="sova-soars-the-sora Would it be ok to do something like (str/join &quot;|&quot; nouns-seq) in the grammar def"><y>#</y><d>2020-05-27</d><h>18:07</h><w>sova-soars-the-sora</w>Would it be ok to do something like <code>(str/join &quot;|&quot; nouns-seq) </code> in the grammar def</z><z id="t1590602905" t="aengelberg that might be more error-prone and hard to read, but it wouldn’t be more or less efficient than the combinator version"><y>#</y><d>2020-05-27</d><h>18:08</h><w>aengelberg</w>that might be more error-prone and hard to read, but it wouldn’t be more or less efficient than the combinator version</z><z id="t1590602942" t="sova-soars-the-sora Okay cool"><y>#</y><d>2020-05-27</d><h>18:09</h><w>sova-soars-the-sora</w>Okay cool</z><z id="t1590602966" t="aengelberg How many nouns are we talking? I’d be wary of putting too many into a parser rule"><y>#</y><d>2020-05-27</d><h>18:09</h><w>aengelberg</w>How many nouns are we talking? I’d be wary of putting too many into a parser rule</z><z id="t1590603011" t="aengelberg Because to parse text that satisfies the rule, it ultimately has to iterate through every option at every point in your text that could potentially be a noun"><y>#</y><d>2020-05-27</d><h>18:10</h><w>aengelberg</w>Because to parse text that satisfies the rule, it ultimately has to iterate through every option at every point in your text that could potentially be a noun</z><z id="t1590603079" t="aengelberg And if you pass a string to the parser that doesn’t successfully parse, the “failure” message will be really long"><y>#</y><d>2020-05-27</d><h>18:11</h><w>aengelberg</w>And if you pass a string to the parser that doesn’t successfully parse, the “failure” message will be really long</z><z id="t1590603132" t="sova-soars-the-sora I&apos;m using about 5-20 nouns"><y>#</y><d>2020-05-27</d><h>18:12</h><w>sova-soars-the-sora</w>I&apos;m using about 5-20 nouns</z><z id="t1590603144" t="aengelberg ah ok, that’s definitely manageable"><y>#</y><d>2020-05-27</d><h>18:12</h><w>aengelberg</w>ah ok, that’s definitely manageable</z><z id="t1590603181" t="sova-soars-the-sora I&apos;m trying to just do string join on the nouns list I have, but they lose their quotes"><y>#</y><d>2020-05-27</d><h>18:13</h><w>sova-soars-the-sora</w>I&apos;m trying to just do string join on the nouns list I have, but they lose their quotes</z><z id="t1590603212" t="aengelberg maybe (apply str/join &quot;|&quot; (map #(str &quot;&apos;&quot; % &quot;&apos;&quot;) nouns-seq))"><y>#</y><d>2020-05-27</d><h>18:13</h><w>aengelberg</w>maybe <code>(apply str/join &quot;|&quot; (map #(str &quot;&apos;&quot; % &quot;&apos;&quot;) nouns-seq))</code></z><z id="t1590603243" t="sova-soars-the-sora ah beautiful"><y>#</y><d>2020-05-27</d><h>18:14</h><w>sova-soars-the-sora</w>ah beautiful</z><z id="t1590603245" t="sova-soars-the-sora thank you very much"><y>#</y><d>2020-05-27</d><h>18:14</h><w>sova-soars-the-sora</w>thank you very much</z><z id="t1590603570" t="sova-soars-the-sora almost perfect, it gives me a (&apos;list&apos; &apos;of&apos; &apos;nouns&apos;) .. not sure how to make it digestible for the parser"><y>#</y><d>2020-05-27</d><h>18:19</h><w>sova-soars-the-sora</w>almost perfect, it gives me a (&apos;list&apos; &apos;of&apos; &apos;nouns&apos;) .. not sure how to make it digestible for the parser</z><z id="t1590603587" t="aengelberg I think that’s where the apply str/join comes in"><y>#</y><d>2020-05-27</d><h>18:19</h><w>aengelberg</w>I think that’s where the <code>apply str/join</code> comes in</z><z id="t1590603617" t="aengelberg oops, I was wrong, you don’t need apply"><y>#</y><d>2020-05-27</d><h>18:20</h><w>aengelberg</w>oops, I was wrong, you don’t need <code>apply</code></z><z id="t1590603629" t="aengelberg just (str/join &quot;|&quot; …)"><y>#</y><d>2020-05-27</d><h>18:20</h><w>aengelberg</w>just <code>(str/join &quot;|&quot; …)</code></z><z id="t1590603733" t="sova-soars-the-sora Excellent! Thank you."><y>#</y><d>2020-05-27</d><h>18:22</h><w>sova-soars-the-sora</w>Excellent!  Thank you.</z><z id="t1590603748" t="sova-soars-the-sora I&apos;m looking forward to showing you guys what I&apos;ve come up with, once it&apos;s done! 😃"><y>#</y><d>2020-05-27</d><h>18:22</h><w>sova-soars-the-sora</w>I&apos;m looking forward to showing you guys what I&apos;ve come up with, once it&apos;s done! <b>😃</b></z><z id="t1590603757" t="aengelberg can’t wait to see!"><y>#</y><d>2020-05-27</d><h>18:22</h><w>aengelberg</w>can’t wait to see!</z><z id="t1590603812" t="sova-soars-the-sora it&apos;s a great wonder to have the power of magic at your fingertips! 😄"><y>#</y><d>2020-05-27</d><h>18:23</h><w>sova-soars-the-sora</w>it&apos;s a great wonder to have the power of magic at your fingertips! <b>😄</b></z><z id="t1590606125" t="sova-soars-the-sora I keep ending up with a vector although I would like to use a map... I don&apos;t know if it&apos;s clojurescript"><y>#</y><d>2020-05-27</d><h>19:02</h><w>sova-soars-the-sora</w>I keep ending up with a vector although I would like to use a map... I don&apos;t know if it&apos;s clojurescript</z><z id="t1590606151" t="aengelberg you mean for the input or the output?"><y>#</y><d>2020-05-27</d><h>19:02</h><w>aengelberg</w>you mean for the input or the output?</z><z id="t1590606209" t="sova-soars-the-sora the output of insta/parse"><y>#</y><d>2020-05-27</d><h>19:03</h><w>sova-soars-the-sora</w>the output of insta/parse</z><z id="t1590606217" t="aengelberg you can set :output-format :enlive to get a map out of the parser"><y>#</y><d>2020-05-27</d><h>19:03</h><w>aengelberg</w>you can set <code>:output-format :enlive</code> to get a map out of the parser</z><z id="t1590606243" t="sova-soars-the-sora wizardry"><y>#</y><d>2020-05-27</d><h>19:04</h><w>sova-soars-the-sora</w>wizardry</z><z id="t1590606491" t="sova-soars-the-sora Hmm, not bad, but it has :tag and :content, I could do with simply swapping [] with {}"><y>#</y><d>2020-05-27</d><h>19:08</h><w>sova-soars-the-sora</w>Hmm, not bad, but it has :tag and :content, I could do with simply swapping  [] with {}</z><z id="t1590606717" t="sova-soars-the-sora Thanks for all the help, I&apos;ll scratch around"><y>#</y><d>2020-05-27</d><h>19:11</h><w>sova-soars-the-sora</w>Thanks for all the help, I&apos;ll scratch around</z><z id="t1590621357" t="sova-soars-the-sora Can instaparse flatten a recursive structure with a rule?"><y>#</y><d>2020-05-27</d><h>23:15</h><w>sova-soars-the-sora</w>Can instaparse flatten a recursive structure with a rule?</z><z id="t1590685025" t="sova-soars-the-sora Hi. I finished what I was working on. Phase one, anyway."><y>#</y><d>2020-05-28</d><h>16:57</h><w>sova-soars-the-sora</w>Hi.  I finished what I was working on.  Phase one, anyway.</z><z id="t1590685194" t="sova-soars-the-sora A few months ago we created a tool that lets people input Japanese by clicking on boxes. Nouns, verbs, particles (grammar words in Japanese that mark grammatical role of a term). It&apos;s a useful teaching and learning tool. Students can create a native-Japanese composition with a tool that respects the basic grammar rules. I thought it might be possible to generate an English translation in real-time of the Japanese a student was generating. Turns out, it is! Turns out, Instaparse is super powerful and I was able to use some grammar and EBNF insights from January to work it into a real-time translation tool. Here&apos;s a brief gif, you can see it in Action."><y>#</y><d>2020-05-28</d><h>16:59</h><w>sova-soars-the-sora</w>A few months ago we created a tool that lets people input Japanese by clicking on boxes.  Nouns, verbs, particles (grammar words in Japanese that mark grammatical role of a term).
It&apos;s a useful teaching and learning tool.  Students can create a native-Japanese composition with a tool that respects the basic grammar rules.
I thought it might be possible to generate an English translation in real-time of the Japanese a student was generating.  Turns out, it is!  Turns out, Instaparse is super powerful and I was able to use some grammar and EBNF insights from January to work it into a real-time translation tool.
Here&apos;s a brief gif, you can see it in Action.</z><z id="t1590685271" t="sova-soars-the-sora And here are some still shots to help show what&apos;s happening: A generated Japanese phrase is parsed, smushed, and sequenced into Plain &apos;Ainglish. This composition was made by a student! =)"><y>#</y><d>2020-05-28</d><h>17:01</h><w>sova-soars-the-sora</w>And here are some still shots to help show what&apos;s happening:  A generated Japanese phrase is parsed, smushed, and sequenced into Plain &apos;Ainglish.  This composition was made by a student! =)</z><z id="t1590685426" t="sova-soars-the-sora Thanks a lot for Instaparse! 😄 You can do magical things indistinguishable from magic."><y>#</y><d>2020-05-28</d><h>17:03</h><w>sova-soars-the-sora</w>Thanks a lot for Instaparse! <b>😄</b> You can do magical things indistinguishable from magic.</z><z id="t1594852166" t="mrchance Hi! If instaparse parses a string in Clojure but fails to do the same in cljs with an identical grammar, what&apos;s a good place to start debugging?"><y>#</y><d>2020-07-15</d><h>22:29</h><w>mrchance</w>Hi! If instaparse parses a string in Clojure but fails to do the same in cljs with an identical grammar, what&apos;s a good place to start debugging?</z><z id="t1594852223" t="aengelberg instaparse defers to the host language when it comes to regex syntax, so if you have a #&quot;…&quot; in your grammar that might be a good place to start"><y>#</y><d>2020-07-15</d><h>22:30</h><w>aengelberg</w>instaparse defers to the host language when it comes to regex syntax, so if you have a <code>#&quot;…&quot;</code> in your grammar that might be a good place to start</z><z id="t1594852262" t="mrchance Aha! I do, will check that, thanks"><y>#</y><d>2020-07-15</d><h>22:31</h><w>mrchance</w>Aha! I do, will check that, thanks</z><z id="t1594852920" t="mrchance Got it, it was Javas [^]+] vs. JS&apos; [^\]+] , thanks again 🙂 Writing the parser was a breeze btw!"><y>#</y><d>2020-07-15</d><h>22:42</h><w>mrchance</w>Got it, it was Javas <code>[^]+]</code> vs. JS&apos; <code>[^\]+]</code> , thanks again <b>🙂</b>
Writing the parser was a breeze btw!</z><z id="t1594852942" t="aengelberg nice! cool to hear that, thx"><y>#</y><d>2020-07-15</d><h>22:42</h><w>aengelberg</w>nice! cool to hear that, thx</z><z id="t1597373020" t="scarrucciu Hello all, is there a way to match on a value, but still use that value for a downstream rule? For example have a string that looks like &quot;ABC*123~EFG*456~HIJ*789&quot; and I would want to nest down a level when I see ABC and HIJ, but I also want to parse the ABC and HIJ are part of the regular segment structure that is using the ~ as the delim"><y>#</y><d>2020-08-14</d><h>02:43</h><w>scarrucciu</w>Hello all, is there a way to match on a value, but still use that value for a downstream rule? For example have a string that looks like <code>&quot;ABC*123~EFG*456~HIJ*789&quot;</code>  and I would want to nest down a level when I see ABC and HIJ, but I also want to parse the ABC and HIJ are part of the regular segment structure that is using the ~ as the delim</z><z id="t1597373091" t="aengelberg Would the lookahead feature help?"><y>#</y><d>2020-08-14</d><h>02:44</h><r>aengelberg</r>Would the lookahead feature help?</z><z id="t1597373143" t="scarrucciu was thinking that, would that allow me to essentially parse prospectively without actually pulling the value? Will try it now"><y>#</y><d>2020-08-14</d><h>02:45</h><r>scarrucciu</r>was thinking that, would that allow me to essentially parse prospectively without actually pulling the value? Will try it now</z><z id="t1597373216" t="scarrucciu that worked! and was way to simple. Thanks for the quick reply"><y>#</y><d>2020-08-14</d><h>02:46</h><r>scarrucciu</r>that worked! and was way to simple. Thanks for the quick reply</z><z id="t1601558015" t="jeremys Hi, I was wondering, is there a way to force instaparse to throw an error instead of backtracking and exploring another parse solution ?"><y>#</y><d>2020-10-01</d><h>13:13</h><w>jeremys</w>Hi, I was wondering, is there a way to force instaparse to throw an error instead of backtracking and exploring another parse solution ?</z><z id="t1601569390" t="hiredman If your grammar can be expressed without alternatives then you don&apos;t need a parsing library"><y>#</y><d>2020-10-01</d><h>16:23</h><w>hiredman</w>If your grammar can be expressed without alternatives then you don&apos;t need a parsing library</z><z id="t1601645859" t="jeremys @hiredman Hi, I don&apos;t know what to make of your answer. I could also say that even with a grammar that offer alternatives I could still make the choice not to use a parsing library and write a reader by hand. I am using instaparse because it makes it much easier to build a parser with it than without it. It also makes it easier to evolve the grammar. Maybe the answer to my question is that my grammar can be expressed another way instead of wanting to tell the parser not to backtrack. Still if the functionality existed I&apos;d like to know about it! Cheers."><y>#</y><d>2020-10-02</d><h>13:37</h><w>jeremys</w>@hiredman Hi, I don&apos;t know what to make of your answer. I could also say that even with a grammar that offer alternatives I could still make the choice not to use a parsing library and write a reader by hand. I am using instaparse because it makes it much easier to build a parser with it than without it. It also makes it easier to evolve the grammar. Maybe the answer to my question is that my grammar can be expressed another way instead of wanting to tell the parser not to backtrack. Still if the functionality existed I&apos;d like to know about it!  Cheers.</z><z id="t1601646070" t="manutter51 What was your reason for wanting to error out instead of backtracking? Are you trying to raise an alert about invalid expressions in what you’re parsing, or are you trying to debug your grammar?"><y>#</y><d>2020-10-02</d><h>13:41</h><w>manutter51</w>What was your reason for wanting to error out instead of backtracking? Are you trying to raise an alert about invalid expressions in what you’re parsing, or are you trying to debug your grammar?</z><z id="t1601655410" t="jeremys @manutter51 hi! I want to raise an alert about invalid code. I am working on something like https://docs.racket-lang.org/pollen/ that allows to write code in the middle of text. My problem arises in particular situations. For instance, the entry rule of my grammar looks like this: doc = (plain-text | embedded)* If I write a pollen expression like this: plain-text ◊str[&quot;some string&quot;] plain-text it is parsed as: [:doc &quot;plain-text &quot; [:tag [:tag-name &quot;str&quot;] [:tag-clj-arg &quot;[&quot; &quot; &quot; &quot;\&quot;aaa\&quot;&quot; &quot;]&quot;]] &quot; plain-text&quot;] Now if i make a mistake balancing the quotes: plain-text ◊str[&quot;some string&quot;&quot;] plain-text the way my grammar works I get: [:doc &quot;plain-text &quot; [:tag [:tag-name &quot;str&quot;]] &quot;[ \&quot;some string\&quot;\&quot;] plain-text&quot;] From the point of view of the parser there is no error here. The [&quot;some string&quot;&quot;] expression, which serves as arguments to the str function, couldn&apos;t be parsed as correct clojure code. However the parser can fall back to the plain-text grammatical rule and did just that. In this case I&apos;d rather it didn&apos;t."><y>#</y><d>2020-10-02</d><h>16:16</h><w>jeremys</w>@manutter51 hi! I want to raise an alert about invalid code. I am working on something like <a href="https://docs.racket-lang.org/pollen/" target="_blank">https://docs.racket-lang.org/pollen/</a> that allows to write code in the middle of text. My problem arises in particular situations.
For instance, the entry rule of my grammar looks like this:
<pre>doc = (plain-text | embedded)*</pre>
If I write a pollen expression like this:
<pre>plain-text ◊str[&quot;some string&quot;] plain-text</pre>
it is parsed as:
<pre>[:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;] 
  [:tag-clj-arg &quot;[&quot; &quot; &quot; &quot;\&quot;aaa\&quot;&quot; &quot;]&quot;]] 
 &quot; plain-text&quot;]</pre>
Now if i make a mistake balancing the quotes:
<pre>plain-text ◊str[&quot;some string&quot;&quot;] plain-text</pre>
the way my grammar works I get:
<pre>[:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;]] 
 &quot;[ \&quot;some string\&quot;\&quot;]  plain-text&quot;]</pre>
From the point of view of the parser there is no error here. The <code>[&quot;some string&quot;&quot;]</code>  expression, which serves as arguments to the <code>str</code> function, couldn&apos;t be parsed as correct clojure code. However the parser can fall back to the <code>plain-text</code> grammatical rule and did just that. In this case I&apos;d rather it didn&apos;t.</z><z id="t1601656003" t="manutter51 Perhaps you could define plain-text so that it’s not allowed to contain an unescaped ◊ character?"><y>#</y><d>2020-10-02</d><h>16:26</h><w>manutter51</w>Perhaps you could define <code>plain-text</code> so that it’s not allowed to contain an unescaped <code>◊</code> character?</z><z id="t1601656913" t="jeremys It is actually 🙂 That&apos;s how the grammar recognizes that there is a &quot;tag-fn&quot; there (in pollen&apos;s jargon) or embedded code in general. And so we rightly get the [:tag [:tag-name &quot;str&quot;]] part. What happens is that the arguments to the function are optional. Thus if the text that follows the function&apos;s name is malformed args, the parser can fall back to plain text. It may be be that the parser can&apos;t be made to throw in that case or that I can&apos;t gerrymander my grammar into doing what I want. It would would be cool if I could though."><y>#</y><d>2020-10-02</d><h>16:41</h><w>jeremys</w>It is actually <b>🙂</b> That&apos;s how the grammar recognizes that there is a &quot;tag-fn&quot; there (in pollen&apos;s jargon) or embedded code in general. And so we rightly get the <code>[:tag [:tag-name &quot;str&quot;]]</code> part. What happens is that the arguments to the function are optional. Thus if the text that follows the function&apos;s name is malformed args, the parser can fall back to plain text. It may be be that the parser can&apos;t be made to throw in that case or that I can&apos;t gerrymander my grammar into doing what I want. It would would be cool if I could though.</z><z id="t1605533518" t="misha greetings! is there a way to specify &quot;greedy&quot; matches in the grammar (instead of the tree transforming) other than using inline regex-es? (insta/parse (insta/parser &quot;S = &apos;a&apos;+&quot;) &quot;aaaa&quot;) to get =&gt; [:S &quot;aaaa&quot;] instead of: =&gt; [:S &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot;] my actual use case is: I have a bunch of rules wrapped in &lt;&gt; (for &quot;documentation&quot;), so the tags will not show up in output tree, so I&apos;d line to have a single match string in the output (like &quot;aaaaa&quot;). I&apos;d like to avoid tree transforming, because grammar is &quot;up for extension&quot; for someone else, and making sure they update transformers as well add a line to grammar - is extra point of potential failure"><y>#</y><d>2020-11-16</d><h>13:31</h><w>misha</w>greetings!
is there a way to specify &quot;greedy&quot; matches in the grammar (instead of the tree transforming) other than using inline regex-es?

(insta/parse (insta/parser &quot;S = &apos;a&apos;+&quot;) &quot;aaaa&quot;)
to get
=&gt; [:S &quot;aaaa&quot;]
instead of:
=&gt; [:S &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot;]

my actual use case is: I have a bunch of rules wrapped in &lt;&gt; (for &quot;documentation&quot;), so the tags will not show up in output tree, so I&apos;d line to have a single match string in the output (like &quot;aaaaa&quot;).
I&apos;d like to avoid tree transforming, because grammar is &quot;up for extension&quot; for someone else, and making sure they update transformers as well add a line to grammar - is extra point of potential failure</z><z id="t1605533959" t="misha and inline regexes do not compose [:attrs nil] at all: &lt;phrase&gt; = #&apos;\w+(\s+\w+)*&apos; text = #&apos;\s*\w+(\s+\w+)*\s*&apos; instead of &lt;space&gt; = #&apos;\s+&apos; &lt;word&gt; = #&apos;\w+&apos; &lt;phrase&gt; = word (space word)* text = space? phrase space?"><y>#</y><d>2020-11-16</d><h>13:39</h><w>misha</w>and inline regexes do not compose <del>well</del> at all:
<pre>&lt;phrase&gt; =    #&apos;\w+(\s+\w+)*&apos;
text     = #&apos;\s*\w+(\s+\w+)*\s*&apos;</pre>
instead of
<pre>&lt;space&gt;  = #&apos;\s+&apos;
&lt;word&gt;   = #&apos;\w+&apos;
&lt;phrase&gt; = word (space word)*
text     = space? phrase space?</pre></z><z id="t1607401902" t="Zaymon Hello all. I’m starting to learn parsing and EBNF and I am struggling to remove the ambiguity from my parser. I have constructed a simple example to demonstrate the problem I am having. The following parser tags text marked as emphasises like ***emphasis*** (def remove-ambiguity (insta/parser &quot;S = (em / char)+ | epsilon em = &lt;&apos;*&apos; &apos;*&apos;&gt; char* &lt;&apos;*&apos; &apos;*&apos;&gt; &lt;char&gt; = #&apos;.&apos;&quot;) Although with an input such as **em** **em** there are many possible parse results: ([:S [:em &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot;]] [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;] [:S [:em &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot;] &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;] [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]] [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; [:em &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot;]] [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; [:em &quot; &quot;] &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;] [:S [:em &quot;e&quot; &quot;m&quot;] &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;] [:S [:em &quot;e&quot; &quot;m&quot;] &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]] &lt;-- This is the one I want ;; This makes sense since there are a few ways you can match up the asterisks to match the rule. However I only ever want to allow results like this `[:em &quot;e&quot; &quot;m&quot;] &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]] It’s almost like I want it to greedily take the first match possible and then ignore all others. But I have no idea how to express this. Any help would be greatly appreciated 😄 ."><y>#</y><d>2020-12-08</d><h>04:31</h><w>Zaymon</w>Hello all.

I’m starting to learn parsing and EBNF and I am struggling to remove the ambiguity from my parser. I have constructed a simple example to demonstrate the problem I am having.

The following parser tags text marked as emphasises like <code>***emphasis***</code>
<pre>(def remove-ambiguity
  (insta/parser
   &quot;S = (em / char)+ | epsilon
    em = &lt;&apos;*&apos; &apos;*&apos;&gt; char* &lt;&apos;*&apos; &apos;*&apos;&gt;
    &lt;char&gt; = #&apos;.&apos;&quot;)</pre>
Although with an input such as <code>**em** **em**</code>  there are many possible parse results:
<pre>([:S [:em &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot;]]
 [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;]
 [:S [:em &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot;] &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;]
 [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot; &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]]
 [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; [:em &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot;]]
 [:S &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; [:em &quot; &quot;] &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;]
 [:S [:em &quot;e&quot; &quot;m&quot;] &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;e&quot; &quot;m&quot; &quot;*&quot; &quot;*&quot;]
 [:S [:em &quot;e&quot; &quot;m&quot;] &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]] &lt;-- This is the one I want

;; This makes sense since there are a few ways you can match up the asterisks to match the rule. However I only ever want to allow results like this `[:em &quot;e&quot; &quot;m&quot;] &quot; &quot; [:em &quot;e&quot; &quot;m&quot;]]</pre>
It’s almost like I want it to greedily take the first match possible and then ignore all others. But I have no idea how to express this. Any help would be greatly appreciated <b>😄</b>.</z><z id="t1607449683" t="hiredman your grammar says &apos; &apos; is both the start of an em sequence, and two chars, and that is the ambiguity"><y>#</y><d>2020-12-08</d><h>17:48</h><w>hiredman</w>your grammar says &apos;&apos; is both the start of an em sequence, and two chars, and that is the ambiguity</z><z id="t1607469395" t="Zaymon Is there a way I can force the correct behavior? I always want it to be the first found pair "><y>#</y><d>2020-12-08</d><h>23:16</h><r>Zaymon</r>Is there a way I can force the correct behavior? I always want it to be the first found pair </z><z id="t1607471585" t="Zaymon How do I specify that a char is any character or sequence of characters except **"><y>#</y><d>2020-12-08</d><h>23:53</h><r>Zaymon</r>How do I specify that a char is any character or sequence of characters except <code>**</code></z><z id="t1607473632" t="Zaymon Looks like I can use negative lookahead in the definition of char"><y>#</y><d>2020-12-09</d><h>00:27</h><r>Zaymon</r>Looks like I can use negative lookahead in the definition of char</z><z id="t1612245449" t="Vincent Cantin Hello"><y>#</y><d>2021-02-02</d><h>05:57</h><w>Vincent Cantin</w>Hello</z><z id="t1612245520" t="Vincent Cantin Was there any attempt to use Instaparse to propose auto-completion at the end of a string which is only matching the beginning side of a grammar? Does Instaparse have any support for this kind of use case?"><y>#</y><d>2021-02-02</d><h>05:58</h><w>Vincent Cantin</w>Was there any attempt to use Instaparse to propose auto-completion at the end of a string which is only matching the beginning side of a grammar?

Does Instaparse have any support for this kind of use case?</z><z id="t1612245930" t="Vincent Cantin For example, assuming that we have the grammar: my-grammar = &apos;he&apos; | &apos;helsinky&apos; | &apos;hello&apos; and we have the string &quot;he&quot; , that matches the grammar already. It would be nice if Instaparse could say that the next characters for a grammar match could also be &quot;lsinky&quot; or &quot;llo&quot; ."><y>#</y><d>2021-02-02</d><h>06:05</h><w>Vincent Cantin</w>For example, assuming that we have the grammar:
<pre>my-grammar = &apos;he&apos; | &apos;helsinky&apos; | &apos;hello&apos;</pre>
and we have the string <code>&quot;he&quot;</code>, that matches the grammar already.

It would be nice if Instaparse could say that the next characters for a grammar match could also be <code>&quot;lsinky&quot;</code> or <code>&quot;llo&quot;</code> .</z><z id="t1612246027" t="Vincent Cantin I am using Instaparse heavily in the project https://github.com/green-coder/girouette"><y>#</y><d>2021-02-02</d><h>06:07</h><w>Vincent Cantin</w>I am using Instaparse heavily in the project <a href="https://github.com/green-coder/girouette" target="_blank">https://github.com/green-coder/girouette</a></z><z id="t1612247105" t="Vincent Cantin Maybe a new &quot;suggestion&quot; mode could be added in Instaparse, where the resulting parse tree could contain some special nodes where we could query some suggestions of letter insertion."><y>#</y><d>2021-02-02</d><h>06:25</h><w>Vincent Cantin</w>Maybe a new <code>&quot;suggestion&quot;</code> mode could be added in Instaparse, where the resulting parse tree could contain some special nodes where we could query some suggestions of letter insertion.</z><z id="t1612995297" t="mathpunk I&apos;m writing my first grammar. It&apos;s going pretty well but, I&apos;ve captured all the stuff I care about and now I have some extra junk I don&apos;t care about. How can I express something like, &quot;S = word data junk&quot;, where I&apos;m interested in part of the pattern and then afterward there is maybe some &quot;whatever&quot;?"><y>#</y><d>2021-02-10</d><h>22:14</h><w>mathpunk</w>I&apos;m writing my first grammar. It&apos;s going pretty well but, I&apos;ve captured all the stuff I care about and now I have some extra junk I don&apos;t care about. How can I express something like, &quot;S = word data junk&quot;, where I&apos;m interested in part of the pattern and then afterward there is maybe some &quot;whatever&quot;?</z><z id="t1612995436" t="aengelberg [:attrs {:href &quot;/_/_/users/U0E9KE222&quot;}] you might want the “hide” syntax (`&lt;&gt;`)?"><y>#</y><d>2021-02-10</d><h>22:17</h><w>aengelberg</w><a>@mathpunk</a> you might want the “hide” syntax (`&lt;&gt;`)?</z><z id="t1612995454" t="aengelberg https://github.com/engelberg/instaparse#hiding-content"><y>#</y><d>2021-02-10</d><h>22:17</h><w>aengelberg</w><a href="https://github.com/engelberg/instaparse#hiding-content" target="_blank">https://github.com/engelberg/instaparse#hiding-content</a></z><z id="t1612995577" t="aengelberg you could capture all the other junk with &lt;#&apos;[\s\S]*&apos;&gt;"><y>#</y><d>2021-02-10</d><h>22:19</h><w>aengelberg</w>you could capture all the other junk with <code>&lt;#&apos;[\s\S]*&apos;&gt;</code></z><z id="t1612995648" t="mathpunk excellent, thank you!"><y>#</y><d>2021-02-10</d><h>22:20</h><w>mathpunk</w>excellent, thank you!</z><z id="t1613161925" t="mathpunk I love working with this library"><y>#</y><d>2021-02-12</d><h>20:32</h><w>mathpunk</w>I love working with this library</z><z id="t1613162068" t="mathpunk I got pretty far with my goal, but my grammar doesn&apos;t handle all my cases. I&apos;d like to see how many so I&apos;m trying to do a (try... (catch to see the % of fails on my data. Are exceptions thrown by the parser different than typical java exceptions?"><y>#</y><d>2021-02-12</d><h>20:34</h><w>mathpunk</w>I got pretty far with my goal, but my grammar doesn&apos;t handle all my cases. I&apos;d like to see how many so I&apos;m trying to do a <code>(try... (catch</code> to see the % of fails on my data. Are exceptions thrown by the parser different than typical java exceptions?</z><z id="t1613162140" t="mathpunk I might just be holding try/catch wrong"><y>#</y><d>2021-02-12</d><h>20:35</h><w>mathpunk</w>I might just be holding try/catch wrong</z><z id="t1613506972" t="aengelberg The parser doesn’t actually throw exceptions, it instead returns a custom Failure object that prints out a special way"><y>#</y><d>2021-02-16</d><h>20:22</h><w>aengelberg</w>The parser doesn’t actually throw exceptions, it instead returns a custom <code>Failure</code> object that prints out a special way</z><z id="t1613522292" t="mathpunk Ah, thank you."><y>#</y><d>2021-02-17</d><h>00:38</h><w>mathpunk</w>Ah, thank you.</z><z id="t1613524849" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U0E9KE222&quot;}] As I recall, there is a function in the API to test if a result is a failure."><y>#</y><d>2021-02-17</d><h>01:20</h><r>Vincent Cantin</r><a>@U0E9KE222</a> As I recall, there is a function in the API to test if a result is a failure.</z><z id="t1616700740" t="mathpunk Do you folks have tips on getting started with interpreting parsed output? The things that come to mind are, clojure.walk, spectre, core.match.... I haven&apos;t worked with hiccup so I don&apos;t know what patterns people to use to work with that"><y>#</y><d>2021-03-25</d><h>19:32</h><w>mathpunk</w>Do you folks have tips on getting started with interpreting parsed output? The things that come to mind are, clojure.walk, spectre, core.match.... I haven&apos;t worked with hiccup so I don&apos;t know what patterns people to use to work with that</z><z id="t1616736944" t="Vincent Cantin It highly depends on what you want to do with the data, and if your data is contextual or not (i.e. if a label has a special meaning when under some special parents)"><y>#</y><d>2021-03-26</d><h>05:35</h><w>Vincent Cantin</w>It highly depends on what you want to do with the data, and if your data is contextual or not (i.e. if a label has a special meaning when under some special parents)</z><z id="t1616737003" t="Vincent Cantin A recursive DIY parsing function may be the simplest to implement and maintain."><y>#</y><d>2021-03-26</d><h>05:36</h><w>Vincent Cantin</w>A recursive DIY parsing function may be the simplest to implement and maintain.</z><z id="t1618080969" t="Vincent Cantin I needed to have an expression which would always fail to match anything in Instaparse. I used &quot;S = &amp;&apos;nop&apos; &apos;no-way&apos;&quot; . Was there another simpler way to do it?"><y>#</y><d>2021-04-10</d><h>18:56</h><w>Vincent Cantin</w>I needed to have an expression which would always fail to match anything in Instaparse. I used <code>&quot;S = &amp;&apos;nop&apos; &apos;no-way&apos;&quot;</code> . Was there another simpler way to do it?</z><z id="t1618088118" t="aengelberg maybe ! eps ?"><y>#</y><d>2021-04-10</d><h>20:55</h><w>aengelberg</w>maybe <code>! eps</code>?</z><z id="t1618088251" t="aengelberg #&apos;$^&apos; might be more performant"><y>#</y><d>2021-04-10</d><h>20:57</h><w>aengelberg</w><code>#&apos;$^&apos;</code> might be more performant</z><z id="t1618778483" t="sova-soars-the-sora Hi. I was wondering, is there a way to do fuzzy matching or fuzzy parsing? And how I mean is that I want to draw rectangles around Japanese text, parsing it effectively, but I would like to be able to parse even if some terms are unknown or undefined. Is there a way to do that in instaparse, a way to parse with fuzziness so not every single term in the parse input is defined by the rules?"><y>#</y><d>2021-04-18</d><h>20:41</h><w>sova-soars-the-sora</w>Hi.  I was wondering, is there a way to do fuzzy matching or fuzzy parsing?  And how I mean is that I want to draw rectangles around Japanese text, parsing it effectively, but I would like to be able to parse even if some terms are unknown or undefined.  Is there a way to do that in instaparse, a way to parse with fuzziness so not every single term in the parse input is defined by the rules?</z><z id="t1618778646" t="aengelberg Sadly no. Instaparse was designed to turn strings into data using a well-defined language, so partial matching and fuzzy matching aren&apos;t well-supported."><y>#</y><d>2021-04-18</d><h>20:44</h><w>aengelberg</w>Sadly no. Instaparse was designed to turn strings into data using a well-defined language, so partial matching and fuzzy matching aren&apos;t well-supported.</z><z id="t1618778774" t="sova-soars-the-sora No problem. I&apos;m wondering how I can do this ^.^ Maybe I can pre-process everything and do a sort of mini dictionary prep step."><y>#</y><d>2021-04-18</d><h>20:46</h><w>sova-soars-the-sora</w>No problem.  I&apos;m wondering how I can do this ^.^  Maybe I can pre-process everything and do a sort of mini dictionary prep step.</z><z id="t1618779116" t="sova-soars-the-sora So if I do a dictionary scan of the input text, I think it is smartest to start with longest strings first"><y>#</y><d>2021-04-18</d><h>20:51</h><w>sova-soars-the-sora</w>So if I do a dictionary scan of the input text, I think it is smartest to start with longest strings first</z><z id="t1618779157" t="sova-soars-the-sora match all the 7-letter words, 6-letter words, 5-letter words, and so on."><y>#</y><d>2021-04-18</d><h>20:52</h><w>sova-soars-the-sora</w>match all the 7-letter words, 6-letter words, 5-letter words, and so on.</z><z id="t1618779283" t="sova-soars-the-sora maybe just cut it into slices? &quot;Shewenttothemuseum&quot; -&gt; &quot;Shewent&quot; (no results) &quot;emuseum&quot; no results... but then &quot;Shewent&quot; (also no results) .... &quot;museum&quot; result found. mark it. keep it moving. Kinda like a sieve of erasthenes but on text"><y>#</y><d>2021-04-18</d><h>20:54</h><w>sova-soars-the-sora</w>maybe just cut it into slices?  &quot;Shewenttothemuseum&quot;
-&gt;
&quot;Shewent&quot;  (no results)
&quot;emuseum&quot; no results...
but then
 &quot;Shewent&quot; (also no results)
.... &quot;museum&quot; result found.  mark it.  keep it moving.
Kinda like a sieve of erasthenes but on text</z><z id="t1618779413" t="sova-soars-the-sora Making m stringlets of size n from a string sounds like linear in data, so we could probably do pretty large datasets but maybe not a whole novel conveniently this way. Hmm, I suppose it is easy if we split on sentence ends (periods 。) and then do the sieve approach on each sentence"><y>#</y><d>2021-04-18</d><h>20:56</h><w>sova-soars-the-sora</w>Making m stringlets of size n from a string sounds like linear in data, so we could probably do pretty large datasets but maybe not a whole novel conveniently this way.  Hmm, I suppose it is easy if we split on sentence ends (periods 。)   and then do the sieve approach on each sentence</z><z id="t1618779449" t="sova-soars-the-sora This might actually work pretty darn well!"><y>#</y><d>2021-04-18</d><h>20:57</h><w>sova-soars-the-sora</w>This might actually work pretty darn well!</z><z id="t1618779496" t="sova-soars-the-sora Preprocess the input with a sieve + dictionary lookup, figure out the nouns and verbs throw them into the rules then try and run the parse on it. i&apos;ll still need some core rules for grammar but the idea is to have a lot of them hard-coded"><y>#</y><d>2021-04-18</d><h>20:58</h><w>sova-soars-the-sora</w>Preprocess the input with a sieve + dictionary lookup, figure out the nouns and verbs
throw them into the rules
then try and run the parse on it.  i&apos;ll still need some core rules for grammar but the idea is to have a lot of them hard-coded</z><z id="t1618779550" t="aengelberg A regex could be a good fit to quickly scan for valid dictionary words. Some regex libraries let you compile a large union of words ( #&quot;word1|word2|word3|... ) into a finite state machine that can do a linear-time scan of text."><y>#</y><d>2021-04-18</d><h>20:59</h><w>aengelberg</w>A regex could be a good fit to quickly scan for valid dictionary words. Some regex libraries let you compile a large union of words ( <code>#&quot;word1|word2|word3|...</code> ) into a finite state machine that can do a linear-time scan of text.</z><z id="t1618779733" t="sova-soars-the-sora ohhh cool. that&apos;s a really neat idea. i think i might need to use web lookups but if i keep tabs on those results they could go into such a regex."><y>#</y><d>2021-04-18</d><h>21:02</h><w>sova-soars-the-sora</w>ohhh cool.  that&apos;s a really neat idea. i think i might need to use web lookups but if i keep tabs on those results they could go into such a regex.</z><z id="t1619159427" t="Sigve If i understand correctly, :auto-whitespace :standard inserts &lt;whitespace&gt;? rules. So that for the parser (def words-and-numbers-auto-whitespace (insta/parser &quot;sentence = token+ &lt;token&gt; = word | number word = #&apos;[a-zA-Z]+&apos; number = #&apos;[0-9]+&apos;&quot; :auto-whitespace :standard)) (words-and-numbers-auto-whitespace &quot;abc 123 45 de&quot;) and (words-and-numbers-auto-whitespace &quot;abc123 45de&quot;) produces the same result. Is there any method of instead inserting non-optional whitespace rules, which in this case would disallow &quot;abc123 45de&quot; `?"><y>#</y><d>2021-04-23</d><h>06:30</h><w>Sigve</w>If i understand correctly, <code>:auto-whitespace :standard</code> inserts <code>&lt;whitespace&gt;?</code> rules. So that for the parser

<pre>(def words-and-numbers-auto-whitespace
  (insta/parser
    &quot;sentence = token+
     &lt;token&gt; = word | number
     word = #&apos;[a-zA-Z]+&apos;
     number = #&apos;[0-9]+&apos;&quot;

    :auto-whitespace :standard))</pre>
<code>(words-and-numbers-auto-whitespace &quot;abc 123 45 de&quot;)</code> and <code>(words-and-numbers-auto-whitespace &quot;abc123 45de&quot;)</code> produces the same result.

Is there any method of instead inserting non-optional whitespace rules, which  in this case would disallow <code>&quot;abc123 45de&quot;</code>`?</z><z id="t1619205818" t="sova-soars-the-sora [:attrs {:href &quot;/_/_/users/U01E4ELDYM9&quot;}] the desired result is only letters and only numbers together in sequence? You could have tokens-numbers and tokens-letters and a sentence can be tokens-numbers+ | tokens-letters+"><y>#</y><d>2021-04-23</d><h>19:23</h><w>sova-soars-the-sora</w><a>@sigve.nordgaard</a> the desired result is only letters and only numbers together in sequence?  You could have <code>tokens-numbers</code> and <code>tokens-letters</code> and a <code>sentence</code> can be <code>tokens-numbers+ | tokens-letters+</code></z><z id="t1619205853" t="sova-soars-the-sora If I have understood the question. That would only allow contiguous digits or contiguous characters, not a mix"><y>#</y><d>2021-04-23</d><h>19:24</h><w>sova-soars-the-sora</w>If I have understood the question.  That would only allow contiguous digits or contiguous characters, not a mix</z><z id="t1619419495" t="Sigve [:attrs {:href &quot;/_/_/users/U3ES97LAC&quot;}] thanks for the answer, but i only used the grammar above as an example (taken from https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace ). My problem is that i need the tokens of the grammar to be whitespace separated, so that keywords of the grammar cannot be &quot;merged&quot; with the following tokens. For example: replace word in the grammar i pasted with some keyword like &apos;power&apos; , which then should be followed by some number. Then i need the string &apos;power 100&apos; to be valid, but not the string power100 . The problem is that the :auto-whitespace :standard feature allows both."><y>#</y><d>2021-04-26</d><h>06:44</h><w>Sigve</w><a>@sova</a> thanks for the answer, but i only used the grammar above as an example (taken from <a href="https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace" target="_blank">https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace</a>).

My problem is that i need the tokens of the grammar to be whitespace separated, so that keywords of the grammar cannot be &quot;merged&quot; with the following tokens.

For example: replace <code>word</code> in the grammar i pasted with some keyword like <code>&apos;power&apos;</code> , which then should be followed by some number.
Then i need the string <code>&apos;power 100&apos;</code> to be valid, but not the string <code>power100</code>. The problem is that the <code>:auto-whitespace :standard</code> feature allows both.</z><z id="t1623174487" t="Ed Does anyone know if there&apos;s an easy way to &quot;unparse&quot; something that parsed with intstaparse? I&apos;ve written a grammar to parse something so I can transform it, and now need to spit it back out again as a string. I can write something that will recursively do walk the tree and do that, but I wondered if there was something I was missing that would do it for me 😉"><y>#</y><d>2021-06-08</d><h>17:48</h><w>Ed</w>Does anyone know if there&apos;s an easy way to &quot;unparse&quot; something that parsed with intstaparse? I&apos;ve written a grammar to parse something so I can transform it, and now need to spit it back out again as a string. I can write something that will recursively do walk the tree and do that, but I wondered if there was something I was missing that would do it for me <b>😉</b></z><z id="t1623181676" t="sova-soars-the-sora Hmm, and you don&apos;t have access to the original string?"><y>#</y><d>2021-06-08</d><h>19:47</h><w>sova-soars-the-sora</w>Hmm, and you don&apos;t have access to the original string?</z><z id="t1623184028" t="Ed I do, but I&apos;ve changed the content. That was why I parsed it in the first place ;) ... I was just hoping I was missing an instaprint that went the other way. If nobody knows of anything like that, then I&apos;ll write something custom. It&apos;s not too complicated a grammar."><y>#</y><d>2021-06-08</d><h>20:27</h><w>Ed</w>I do, but I&apos;ve changed the content. That was why I parsed it in the first place ;) ... I was just hoping I was missing an instaprint that went the other way. If nobody knows of anything like that, then I&apos;ll write something custom. It&apos;s not too complicated a grammar.</z><z id="t1623238801" t="Ed So I fiddled with my grammar a bit, so it captured some more strings than I needed to actually do the transformations I wanted to do using regexes, and the recursive printer ended up being (defn write-tag [writer template] (if (vector? template) (doseq [s (next template)] (write-tag writer s)) (.write writer template)) writer) (defn write-template [template] (.toString (write-tag (StringWriter.) template))) Simples ... should have just tried to write it in the first place 😉"><y>#</y><d>2021-06-09</d><h>11:40</h><w>Ed</w>So I fiddled with my grammar a bit, so it captured some more strings than I needed to actually do the transformations I wanted to do using regexes, and the recursive printer ended up being
<pre>(defn write-tag [writer template]
  (if (vector? template)
    (doseq [s (next template)]
      (write-tag writer s))
    (.write writer template))
  writer)

(defn write-template [template]
  (.toString (write-tag (StringWriter.) template)))</pre>
Simples ... should have just tried to write it in the first place <b>😉</b></z><z id="t1623283534" t="sova-soars-the-sora [:attrs {:href &quot;/_/_/users/U0P0TMEFJ&quot;}] well done 😃"><y>#</y><d>2021-06-10</d><h>00:05</h><w>sova-soars-the-sora</w><a>@l0st3d</a> well done <b>😃</b></z><z id="t1623691466" t="markaddleman Does instaparse support round tripping? I have a string-based language that I want to manipulate. I&apos;d like to parse it, manipulate the parse tree using meander and then generate a new string from the parse tree"><y>#</y><d>2021-06-14</d><h>17:24</h><w>markaddleman</w>Does instaparse support round tripping?  I have a string-based language that I want to manipulate.  I&apos;d like to parse it, manipulate the parse tree using meander and then generate a new string from the parse tree</z><z id="t1623694356" t="sova-soars-the-sora I think it&apos;s possible. I don&apos;t know what meander is..."><y>#</y><d>2021-06-14</d><h>18:12</h><w>sova-soars-the-sora</w>I think it&apos;s possible.  I don&apos;t know what meander is...</z><z id="t1623694386" t="aengelberg there isn’t a way to “unparse” though that’s been requested a few times"><y>#</y><d>2021-06-14</d><h>18:13</h><w>aengelberg</w>there isn’t a way to “unparse” though that’s been requested a few times</z><z id="t1623694420" t="aengelberg you could write your own “unparser” that leverages insta/transform and implements a different string-reconstruction logic for each tag in your grammar"><y>#</y><d>2021-06-14</d><h>18:13</h><w>aengelberg</w>you could write your own “unparser” that leverages <code>insta/transform</code> and implements a different string-reconstruction logic for each tag in your grammar</z><z id="t1623694462" t="aengelberg assuming you don’t use the “hide” rule (`&lt;&gt;`), those implementations would basically just be str"><y>#</y><d>2021-06-14</d><h>18:14</h><w>aengelberg</w>assuming you don’t use the “hide” rule (`&lt;&gt;`), those implementations would basically just be <code>str</code></z><z id="t1623694549" t="markaddleman thanks. I may be signing myself up for a world of hurt but my current approach is to use clojure spec to generate the parse tree and then unform to &quot;unparse&quot; it"><y>#</y><d>2021-06-14</d><h>18:15</h><w>markaddleman</w>thanks.  I may be signing myself up for a world of hurt but my current approach is to use clojure spec to generate the parse tree and then unform to &quot;unparse&quot; it</z><z id="t1623694631" t="aengelberg instaparse will almost certainly be a better fit than clojure spec to do the initial parse, though I see why you’d want to use a library that gives you an “undo” function"><y>#</y><d>2021-06-14</d><h>18:17</h><w>aengelberg</w>instaparse will almost certainly be a better fit than clojure spec to do the initial parse, though I see why you’d want to use a library that gives you an “undo” function</z><z id="t1623694696" t="markaddleman yeah, i feel like this is a no-win situation"><y>#</y><d>2021-06-14</d><h>18:18</h><w>markaddleman</w>yeah, i feel like this is a no-win situation</z><z id="t1623694730" t="aengelberg I don’t think writing your own un-parser would be too challenging"><y>#</y><d>2021-06-14</d><h>18:18</h><w>aengelberg</w>I don’t think writing your own un-parser would be too challenging</z><z id="t1623720124" t="markaddleman You were right. Using parse options :unhide :all , I can easily use meander to unparse the parse tree"><y>#</y><d>2021-06-15</d><h>01:22</h><r>markaddleman</r>You were right.  Using parse options <code>:unhide :all</code> , I can easily use meander to unparse the parse tree</z><z id="t1623765236" t="markaddleman Thank you!"><y>#</y><d>2021-06-15</d><h>13:53</h><r>markaddleman</r>Thank you!</z><z id="t1623694756" t="aengelberg since it’s mostly putting strings back together from a recursive tree"><y>#</y><d>2021-06-14</d><h>18:19</h><w>aengelberg</w>since it’s mostly putting strings back together from a recursive tree</z><z id="t1623694837" t="markaddleman hm. thanks. I&apos;ll give it a try"><y>#</y><d>2021-06-14</d><h>18:20</h><w>markaddleman</w>hm.  thanks.  I&apos;ll give it a try</z><z id="t1624957008" t="borkdude Hey, someone here? :)"><y>#</y><d>2021-06-29</d><h>08:56</h><w>borkdude</w>Hey, someone here? :)</z><z id="t1624957029" t="borkdude I was trying to make this ebnf grammar work with instaparse: https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf But so far it didn&apos;t work out"><y>#</y><d>2021-06-29</d><h>08:57</h><w>borkdude</w>I was trying to make this ebnf grammar work with instaparse:

<a href="https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf" target="_blank">https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf</a>

But so far it didn&apos;t work out</z><z id="t1624957111" t="borkdude Here&apos;s what I got: https://gist.github.com/borkdude/98c5d9e2bf598b227e8e643e4271e61e user=&gt; (def parser (insta/parser &quot;/Users/borkdude/Downloads/bash.ebnf&quot;)) #&apos;user/parser user=&gt; (parser &quot;foo&quot;) Parse error at line 1, column 1: foo ^ Expected: #&quot;[0-9]&quot;"><y>#</y><d>2021-06-29</d><h>08:58</h><w>borkdude</w>Here&apos;s what I got:
<a href="https://gist.github.com/borkdude/98c5d9e2bf598b227e8e643e4271e61e" target="_blank">https://gist.github.com/borkdude/98c5d9e2bf598b227e8e643e4271e61e</a>

<pre>user=&gt; (def parser (insta/parser &quot;/Users/borkdude/Downloads/bash.ebnf&quot;))
#&apos;user/parser
user=&gt; (parser &quot;foo&quot;)
Parse error at line 1, column 1:
foo
^
Expected:
#&quot;[0-9]&quot;</pre></z><z id="t1624958848" t="Sigve Hi, when you do not specify a starting rule for the grammar instaparse selects the top rule for a starting point. In you case that is the number rule. https://github.com/engelberg/instaparse#parsing-from-another-start-rule This should work: (parser &quot;foo&quot; :start :command)"><y>#</y><d>2021-06-29</d><h>09:27</h><w>Sigve</w>Hi, when you do not specify a starting rule for the grammar instaparse selects the top rule for a starting point. In you case that is the number rule.
<a href="https://github.com/engelberg/instaparse#parsing-from-another-start-rule" target="_blank">https://github.com/engelberg/instaparse#parsing-from-another-start-rule</a>
This should work:
<pre>(parser &quot;foo&quot; :start :command)</pre></z><z id="t1624959035" t="Sigve (NB: surrounding an rule with angle brackets makes it hidden, since all commands are hidden you will probably only get an empty list on a successful parse)"><y>#</y><d>2021-06-29</d><h>09:30</h><w>Sigve</w>(NB: surrounding an rule with angle brackets makes it hidden, since all commands are hidden you will probably only get an empty list on a successful parse)</z><z id="t1624961028" t="borkdude aaah"><y>#</y><d>2021-06-29</d><h>10:03</h><w>borkdude</w>aaah</z><z id="t1624961119" t="borkdude user=&gt; (parser &quot;foo&quot; :start :word) (&quot;f&quot; &quot;o&quot; &quot;o&quot;) "><y>#</y><d>2021-06-29</d><h>10:05</h><w>borkdude</w><pre>user=&gt; (parser &quot;foo&quot; :start :word)
(&quot;f&quot; &quot;o&quot; &quot;o&quot;)</pre>
</z><z id="t1624961182" t="borkdude btw, it wasn&apos;t my choice to use angle brackets, I just copied that from the original ebnf"><y>#</y><d>2021-06-29</d><h>10:06</h><w>borkdude</w>btw, it wasn&apos;t my choice to use angle brackets, I just copied that from the original ebnf</z><z id="t1624961346" t="borkdude oh I see, hidden means you don&apos;t get it back in the structure, but directly?"><y>#</y><d>2021-06-29</d><h>10:09</h><w>borkdude</w>oh I see, hidden means you don&apos;t get it back in the structure, but directly?</z><z id="t1624961607" t="borkdude why does this succeed if I have set :partial to false : user=&gt; (parser &quot;foo&quot; :start :word :partial false) [:word]"><y>#</y><d>2021-06-29</d><h>10:13</h><w>borkdude</w>why does this succeed if I have set <code>:partial</code> to <code>false</code>:
<pre>user=&gt; (parser &quot;foo&quot; :start :word :partial false)
[:word]</pre></z><z id="t1624961616" t="Sigve That was my hunch, which is why i thought a head&apos;s up was in it&apos;s place:) Yes, these is at good example of hiding here: https://github.com/engelberg/instaparse#hiding-content as mentioned, it is usually used for hiding whitespace and other tokens you do not care about in the final output, but if you hide the top rule, everything disapears"><y>#</y><d>2021-06-29</d><h>10:13</h><w>Sigve</w>That was my hunch, which is why i thought a head&apos;s up was in it&apos;s place:)

Yes, these is at good example of hiding here: <a href="https://github.com/engelberg/instaparse#hiding-content" target="_blank">https://github.com/engelberg/instaparse#hiding-content</a>
as mentioned, it is usually used for hiding whitespace and other tokens you do not care about in the final output, but if you hide the top rule, everything disapears</z><z id="t1624961695" t="borkdude ah I see, it was because of the hiding again: user=&gt; (parser &quot;foo&quot; :start :word :partial false) [:word [:word [:word [:letter &quot;f&quot;]] [:letter &quot;o&quot;]] [:letter &quot;o&quot;]] "><y>#</y><d>2021-06-29</d><h>10:14</h><w>borkdude</w>ah I see, it was because of the hiding again:
<pre>user=&gt; (parser &quot;foo&quot; :start :word :partial false)
[:word [:word [:word [:letter &quot;f&quot;]] [:letter &quot;o&quot;]] [:letter &quot;o&quot;]]</pre>
</z><z id="t1624961760" t="Sigve :partial allows a partially complete/successful parse to succeed, embedding the failure node in the AST where at the point where the output"><y>#</y><d>2021-06-29</d><h>10:16</h><w>Sigve</w><code>:partial</code>allows a partially complete/successful parse to succeed, embedding the failure node in the AST where at the point where the output</z><z id="t1624961764" t="Sigve ah:)"><y>#</y><d>2021-06-29</d><h>10:16</h><w>Sigve</w>ah:)</z><z id="t1624961957" t="borkdude It seems the original ebnf works a bit differently than instaparse. e.g.: &lt;for_command&gt; ::= &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos; | &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos; | &apos;for&apos; &lt;word&gt; &apos;;&apos; &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos; | &apos;for&apos; &lt;word&gt; &apos;;&apos; &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos; | &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;in&apos; &lt;word_list&gt; &lt;list_terminator&gt; &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos; | &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;in&apos; &lt;word_list&gt; &lt;list_terminator&gt; &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos;"><y>#</y><d>2021-06-29</d><h>10:19</h><w>borkdude</w>It seems the original ebnf works a bit differently than instaparse. e.g.:
<pre>&lt;for_command&gt; ::=  &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos;
            |  &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos;
            |  &apos;for&apos; &lt;word&gt; &apos;;&apos; &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos;
            |  &apos;for&apos; &lt;word&gt; &apos;;&apos; &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos;
            |  &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;in&apos; &lt;word_list&gt; &lt;list_terminator&gt;
                   &lt;newline_list&gt; &apos;do&apos; &lt;compound_list&gt; &apos;done&apos;
            |  &apos;for&apos; &lt;word&gt; &lt;newline_list&gt; &apos;in&apos; &lt;word_list&gt; &lt;list_terminator&gt;
                   &lt;newline_list&gt; &apos;{&apos; &lt;compound_list&gt; &apos;}&apos;</pre></z><z id="t1624961973" t="borkdude seems to assume that the tokens are automatically separated by whitespace"><y>#</y><d>2021-06-29</d><h>10:19</h><w>borkdude</w>seems to assume that the tokens are automatically separated by whitespace</z><z id="t1624962042" t="borkdude if I have to rewrite the grammar anyway I&apos;m more inclined to hand-roll my own parser"><y>#</y><d>2021-06-29</d><h>10:20</h><w>borkdude</w>if I have to rewrite the grammar anyway I&apos;m more inclined to hand-roll my own parser</z><z id="t1625027641" t="sova-soars-the-sora 😮"><y>#</y><d>2021-06-30</d><h>04:34</h><r>sova-soars-the-sora</r><b>😮</b></z><z id="t1625028045" t="sova-soars-the-sora"><y>#</y><d>2021-06-30</d><h>04:40</h><r>sova-soars-the-sora</r></z><z id="t1624962181" t="Sigve I think that for most yacc/bison parsers rules are separated by whitespace by default yes, instaparse supports adding this by using the auto-whitespace feature which has worked well for me https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace"><y>#</y><d>2021-06-29</d><h>10:23</h><w>Sigve</w>I think that for most yacc/bison parsers rules are separated by whitespace by default yes,
instaparse supports adding this by using the auto-whitespace feature which has worked well for me
<a href="https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace" target="_blank">https://github.com/Engelberg/instaparse/blob/master/docs/ExperimentalFeatures.md#auto-whitespace</a></z><z id="t1624962256" t="Sigve I dont know what you are using this parser for, but in my experience using a proper grammar-based parser is more maintainable and flexible in the long run. Of course for small use cases it can be a lot to get into and learn"><y>#</y><d>2021-06-29</d><h>10:24</h><w>Sigve</w>I dont know what you are using this parser for, but in my experience using a proper grammar-based parser is more maintainable and flexible in the long run. Of course for small use cases it can be a lot to get into and learn</z><z id="t1624962394" t="borkdude this parser should parse bash syntax"><y>#</y><d>2021-06-29</d><h>10:26</h><w>borkdude</w>this parser should parse bash syntax</z><z id="t1624962402" t="borkdude but bash is not such a big language"><y>#</y><d>2021-06-29</d><h>10:26</h><w>borkdude</w>but bash is not such a big language</z><z id="t1624962426" t="borkdude This is the original: https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf"><y>#</y><d>2021-06-29</d><h>10:27</h><w>borkdude</w>This is the original: <a href="https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf" target="_blank">https://github.com/cbeust/kash/blob/master/src/main/resources/bash.ebnf</a></z><z id="t1624962435" t="borkdude I just have some problems getting this to work with instaparse so far"><y>#</y><d>2021-06-29</d><h>10:27</h><w>borkdude</w>I just have some problems getting this to work with instaparse so far</z><z id="t1624962467" t="borkdude it&apos;s not very important, just a fun project"><y>#</y><d>2021-06-29</d><h>10:27</h><w>borkdude</w>it&apos;s not very important, just a fun project</z><z id="t1624962751" t="Sigve Then i guess comes down to which approach you find most fun:) I think instaparse is quite amazing once you grok it, but again i understand i can be a hassle go get into. On the other side, hand written parsers can also be painful to get correct"><y>#</y><d>2021-06-29</d><h>10:32</h><w>Sigve</w>Then i guess comes down to which approach you find most fun:) I think instaparse is quite amazing once you grok it, but again i understand i can be a hassle go get into. On the other side, hand written parsers can also be painful to get correct</z><z id="t1624996209" t="aengelberg There isn’t really a single EBNF syntax specification or RFC, so every “EBNF grammar” you’ll find in the wild will have a slightly varied flavor of the syntax. Sometimes because a certain parser library chose a unique metasyntax, or sometimes because the grammar is meant to serve as documentation rather than compiled and executed."><y>#</y><d>2021-06-29</d><h>19:50</h><w>aengelberg</w>There isn’t really a single EBNF syntax specification or RFC, so every “EBNF grammar” you’ll find in the wild will have a slightly varied flavor of the syntax. Sometimes because a certain parser library chose a unique metasyntax, or sometimes because the grammar is meant to serve as documentation rather than compiled and executed.</z><z id="t1624996478" t="aengelberg Instaparse attempts to support most of the different flavors, which is why you can use either x? or [x] syntax for example"><y>#</y><d>2021-06-29</d><h>19:54</h><w>aengelberg</w>Instaparse attempts to support most of the different flavors, which is why you can use either <code>x?</code> or <code>[x]</code>  syntax for example</z><z id="t1624996503" t="aengelberg But sometimes a grammar or a different parser library will make a particularly unusual syntax choice, like using angle brackets in rule names"><y>#</y><d>2021-06-29</d><h>19:55</h><w>aengelberg</w>But sometimes a grammar or a different parser library will make a particularly unusual syntax choice, like using angle brackets in rule names</z><z id="t1624996612" t="aengelberg Or a grammar will make an implicit logical assumption that Instaparse has no way to act upon, like whitespace being parsed between tokens"><y>#</y><d>2021-06-29</d><h>19:56</h><w>aengelberg</w>Or a grammar will make an implicit logical assumption that Instaparse has no way to act upon, like whitespace being parsed between tokens</z><z id="t1624996732" t="aengelberg The angle brackets are particularly unfortunate since Instaparse chose to use angle brackets for an instaparse-specific feature (hiding data from the output parse tree)"><y>#</y><d>2021-06-29</d><h>19:58</h><w>aengelberg</w>The angle brackets are particularly unfortunate since Instaparse chose to use angle brackets for an instaparse-specific feature (hiding data from the output parse tree)</z><z id="t1624997016" t="aengelberg ABNF, on the other hand, seems to be a much more regulated metasyntax, so copy and pasting ABNF grammars into instaparse (using :input-format :abnf ) tends to be safer"><y>#</y><d>2021-06-29</d><h>20:03</h><w>aengelberg</w>ABNF, on the other hand, seems to be a much more regulated metasyntax, so copy and pasting ABNF grammars into instaparse (using <code>:input-format :abnf</code>) tends to be safer</z><z id="t1626537635" t="Rob Haisfield How does Instaparse compare to Megaparsack? https://twitter.com/lexi_lambda/status/1411768876753358851?s=21"><y>#</y><d>2021-07-17</d><h>16:00</h><w>Rob Haisfield</w>How does Instaparse compare to Megaparsack? <a href="https://twitter.com/lexi_lambda/status/1411768876753358851?s=21" target="_blank">https://twitter.com/lexi_lambda/status/1411768876753358851?s=21</a></z><z id="t1626538447" t="sova-soars-the-sora That looks neat and it looks like it supports things that are not exactly CFG at least not the ones I am aware of… Instaparse is implemented under the hood as an LRR parser (correct me if I’m wrong) making it very super duper fast and powaful. Interesting find tho"><y>#</y><d>2021-07-17</d><h>16:14</h><w>sova-soars-the-sora</w>That looks neat and it looks like it supports things that are not exactly CFG at least not the ones I am aware of… Instaparse is implemented under the hood as an LRR parser (correct me if I’m wrong) making it very super duper fast and powaful.  Interesting find tho</z><z id="t1626686100" t="aengelberg Instaparse&apos;s engine is based on the GLL algorithm, if that helps"><y>#</y><d>2021-07-19</d><h>09:15</h><w>aengelberg</w>Instaparse&apos;s engine is based on the GLL algorithm, if that helps</z><z id="t1626715481" t="sova-soars-the-sora GLL woo! Thanks for the keyword"><y>#</y><d>2021-07-19</d><h>17:24</h><w>sova-soars-the-sora</w>GLL woo! Thanks for the keyword</z><z id="t1628625780" t="sova-soars-the-sora Instaparse live is so sweet. http://instaparse-live.matt.is/"><y>#</y><d>2021-08-10</d><h>20:03</h><w>sova-soars-the-sora</w>Instaparse live is so sweet. <a href="http://instaparse-live.matt.is/" target="_blank">http://instaparse-live.matt.is/</a></z><z id="t1643827175" t="ghaskins Hi All, I’m trying to understand a failure related to trying to exclude “[” via regex negation"><y>#</y><d>2022-02-02</d><h>18:39</h><w>ghaskins</w>Hi All,

I’m trying to understand a failure related to trying to exclude “[” via regex negation</z><z id="t1643827195" t="ghaskins this grammar snippet &lt;unquoted-literal&gt; ::= #&quot;[^()\[\s]+&quot;"><y>#</y><d>2022-02-02</d><h>18:39</h><w>ghaskins</w>this grammar snippet

<pre>&lt;unquoted-literal&gt; ::= #&quot;[^()\[\s]+&quot;</pre></z><z id="t1643827216" t="ghaskins triggers insta/failure? to return true but there is no info provided"><y>#</y><d>2022-02-02</d><h>18:40</h><w>ghaskins</w>triggers insta/failure? to return true but there is no info provided</z><z id="t1643827228" t="ghaskins this works"><y>#</y><d>2022-02-02</d><h>18:40</h><w>ghaskins</w>this works</z><z id="t1643827229" t="ghaskins &lt;unquoted-literal&gt; ::= #&quot;[^()\s]+&quot;"><y>#</y><d>2022-02-02</d><h>18:40</h><w>ghaskins</w><pre>&lt;unquoted-literal&gt; ::= #&quot;[^()\s]+&quot;</pre></z><z id="t1643827255" t="ghaskins and it seems to be fine from a clojure/jvm regex perspective"><y>#</y><d>2022-02-02</d><h>18:40</h><w>ghaskins</w>and it seems to be fine from a clojure/jvm regex perspective</z><z id="t1643827256" t="ghaskins (re-find #&quot;[^\[]+&quot; &quot;[foo]&quot;) =&gt; &quot;foo]&quot; (re-find #&quot;[^()\[]+&quot; &quot;[foo]&quot;) =&gt; &quot;foo]&quot; (re-find #&quot;[^()\[\s]+&quot; &quot;[ foo]&quot;) =&gt; &quot;foo]&quot;"><y>#</y><d>2022-02-02</d><h>18:40</h><w>ghaskins</w><pre>(re-find #&quot;[^\[]+&quot; &quot;[foo]&quot;)
=&gt; &quot;foo]&quot;
(re-find #&quot;[^()\[]+&quot; &quot;[foo]&quot;)
=&gt; &quot;foo]&quot;
(re-find #&quot;[^()\[\s]+&quot; &quot;[ foo]&quot;)
=&gt; &quot;foo]&quot;</pre></z><z id="t1643827316" t="ghaskins (im totally open to other/better ways to parse this outside of regex, too"><y>#</y><d>2022-02-02</d><h>18:41</h><w>ghaskins</w>(im totally open to other/better ways to parse this outside of regex, too</z><z id="t1643827343" t="ghaskins any help appreciated"><y>#</y><d>2022-02-02</d><h>18:42</h><w>ghaskins</w>any help appreciated</z><z id="t1643827646" t="ghaskins nm, i figured it out"><y>#</y><d>2022-02-02</d><h>18:47</h><w>ghaskins</w>nm, i figured it out</z><z id="t1653429245" t="winsome I&apos;m trying to parse a rule like this: (parser &quot;EOL ::= [#xD#xA]+&quot;) , but it blows up with a parse error: EOL ::= [#xD#xA]+ ^ Expected one of: ! &amp; ε eps EPSILON epsilon Epsilon &lt; ( { [ #&quot;#\&quot;[^\&quot;\\]*(?:\\.[^\&quot;\\]*)*\&quot;(?x) #Double-quoted regexp&quot; #&quot;#&apos;[^&apos;\\]*(?:\\.[^&apos;\\]*)*&apos;(?x) #Single-quoted regexp&quot; #&quot;\&quot;[^\&quot;\\]*(?:\\.[^\&quot;\\]*)*\&quot;(?x) #Double-quoted string&quot; #&quot;&apos;[^&apos;\\]*(?:\\.[^&apos;\\]*)*&apos;(?x) #Single-quoted string&quot; (* #&quot;[^, \r\t\n&lt;&gt;(){}\[\]+*?:=|&apos;&quot;#&amp;!;./]+(?x) #Non-terminal&quot;"><y>#</y><d>2022-05-24</d><h>21:54</h><w>winsome</w>I&apos;m trying to parse a rule like this: <code>(parser &quot;EOL ::= [#xD#xA]+&quot;)</code>, but it blows up with a parse error:
<pre>EOL ::= [#xD#xA]+
         ^
Expected one of:
!
&amp;
ε
eps
EPSILON
epsilon
Epsilon
&lt;
(
{
[
#&quot;#\&quot;[^\&quot;\\]*(?:\\.[^\&quot;\\]*)*\&quot;(?x) #Double-quoted regexp&quot;
#&quot;#&apos;[^&apos;\\]*(?:\\.[^&apos;\\]*)*&apos;(?x) #Single-quoted regexp&quot;
#&quot;\&quot;[^\&quot;\\]*(?:\\.[^\&quot;\\]*)*\&quot;(?x) #Double-quoted string&quot;
#&quot;&apos;[^&apos;\\]*(?:\\.[^&apos;\\]*)*&apos;(?x) #Single-quoted string&quot;
(*
#&quot;[^, \r\t\n&lt;&gt;(){}\[\]+*?:=|&apos;&quot;#&amp;!;./]+(?x) #Non-terminal&quot;</pre></z><z id="t1653429285" t="winsome I&apos;m going off of this EBNF syntax: https://www.w3.org/TR/REC-xml/#sec-notation"><y>#</y><d>2022-05-24</d><h>21:54</h><w>winsome</w>I&apos;m going off of this EBNF syntax: <a href="https://www.w3.org/TR/REC-xml/#sec-notation" target="_blank">https://www.w3.org/TR/REC-xml/#sec-notation</a></z><z id="t1653429346" t="winsome &quot;#xN - where N is a hexadecimal integer, the expression matches the character whose number (code point) in ISO/IEC 10646 is N. The number of leading zeros in the #xN form is insignificant.&quot;"><y>#</y><d>2022-05-24</d><h>21:55</h><w>winsome</w>&quot;#xN - where N is a hexadecimal integer, the expression matches the character whose number (code point) in ISO/IEC 10646 is N. The number of leading zeros in the #xN form is insignificant.&quot;</z><z id="t1653429431" t="winsome Do I need to translate that syntax into some other representation? Is there one in particular that I should choose?"><y>#</y><d>2022-05-24</d><h>21:57</h><w>winsome</w>Do I need to translate that syntax into some other representation? Is there one in particular that I should choose?</z><z id="t1653429796" t="hiredman instaparse uses clojure&apos;s syntax for regexes, so it expects # to be the start of a regex, maybe \ to escape it (would have to be \\ in a string literal)"><y>#</y><d>2022-05-24</d><h>22:03</h><w>hiredman</w>instaparse uses clojure&apos;s syntax for regexes, so it expects # to be the start of a regex, maybe \ to escape it (would have to be \\ in a string literal)</z><z id="t1653429861" t="winsome oh, it didn&apos;t occur to me that it would look for those inside a string."><y>#</y><d>2022-05-24</d><h>22:04</h><w>winsome</w>oh, it didn&apos;t occur to me that it would look for those inside a string.</z><z id="t1653429882" t="winsome Escaping with \ and \\ produce the same problem, though."><y>#</y><d>2022-05-24</d><h>22:04</h><w>winsome</w>Escaping with <code>\</code> and <code>\\</code> produce the same problem, though.</z><z id="t1653429941" t="winsome These are the code points for cr lf, I believe, maybe I need to translate those into the the clojure versions"><y>#</y><d>2022-05-24</d><h>22:05</h><w>winsome</w>These are the code points for cr lf, I believe, maybe I need to translate those into the the clojure versions</z><z id="t1653430067" t="hiredman ah, yes, well even if # didn&apos;t throw the above error, the syntax they use for matching octets is not a thing"><y>#</y><d>2022-05-24</d><h>22:07</h><w>hiredman</w>ah, yes, well even if # didn&apos;t throw the above error, the syntax they use for matching octets is not a thing</z><z id="t1653430084" t="hiredman (codepoints, not octets)"><y>#</y><d>2022-05-24</d><h>22:08</h><w>hiredman</w>(codepoints, not octets)</z><z id="t1653430090" t="aengelberg yeah, the problem is that #xN is a pseudo-syntax that the XML specification may have invented for its own grammar, to help clarify the nuances of the character code points. But Instaparse doesn’t know how to interpret that as an actual parser."><y>#</y><d>2022-05-24</d><h>22:08</h><w>aengelberg</w>yeah, the problem is that <code>#xN</code> is a pseudo-syntax that the XML specification may have invented for its own grammar, to help clarify the nuances of the character code points. But Instaparse doesn’t know how to interpret that as an actual parser.</z><z id="t1653430179" t="hiredman the way to embed a character by code point in a clojure string is \uN"><y>#</y><d>2022-05-24</d><h>22:09</h><w>hiredman</w>the way to embed a character by code point in a clojure string is \uN</z><z id="t1653430209" t="winsome Is N a hex number?"><y>#</y><d>2022-05-24</d><h>22:10</h><w>winsome</w>Is N a hex number?</z><z id="t1653430209" t="hiredman user=&gt; &quot;\u0029&quot; &quot;)&quot; user=&gt; "><y>#</y><d>2022-05-24</d><h>22:10</h><w>hiredman</w><pre>user=&gt; &quot;\u0029&quot;
&quot;)&quot;
user=&gt;</pre>
</z><z id="t1653430231" t="hiredman (yes)"><y>#</y><d>2022-05-24</d><h>22:10</h><w>hiredman</w>(yes)</z><z id="t1653430272" t="winsome &quot;\u000D\u000A&quot; &quot;\r\n&quot;"><y>#</y><d>2022-05-24</d><h>22:11</h><w>winsome</w><pre>&quot;\u000D\u000A&quot;
&quot;\r\n&quot;</pre></z><z id="t1653430289" t="aengelberg I think this should work in instaparse: EOL ::= &quot;\u000D&quot; | &quot;\u000A&quot;"><y>#</y><d>2022-05-24</d><h>22:11</h><w>aengelberg</w>I think this should work in instaparse:
<pre>EOL ::= &quot;\u000D&quot; | &quot;\u000A&quot;</pre></z><z id="t1653430537" t="aengelberg actually, this might not work if you’re slurping the grammar from a file and passing that into instaparse. the \u000A thing is a Clojure reader feature, not an instaparse feature"><y>#</y><d>2022-05-24</d><h>22:15</h><r>aengelberg</r>actually, this might not work if you’re slurping the grammar from a file and passing that into instaparse. the <code>\u000A</code> thing is a Clojure reader feature, not an instaparse feature</z><z id="t1653430484" t="aengelberg Java regexes also support referring to chars as code points, which means you can use the Instaparse regex feature as well: EOL ::= #&quot;[\\x0D\\x0A]&quot;"><y>#</y><d>2022-05-24</d><h>22:14</h><w>aengelberg</w>Java regexes also support referring to chars as code points, which means you can use the Instaparse regex feature as well:
<pre>EOL ::= #&quot;[\\x0D\\x0A]&quot;</pre></z><z id="t1653430664" t="winsome (grammar/parser &quot;EOL ::= #\&quot;[\\x0D\\x0A]\&quot;&quot;) seems to work."><y>#</y><d>2022-05-24</d><h>22:17</h><w>winsome</w><code>(grammar/parser &quot;EOL ::= #\&quot;[\\x0D\\x0A]\&quot;&quot;)</code> seems to work.</z><z id="t1653430707" t="winsome And changing the double quote to a single quote makes it a little less messy: (grammar/parser &quot;EOL ::= #&apos;[\\x0D\\x0A]&apos;&quot;)"><y>#</y><d>2022-05-24</d><h>22:18</h><w>winsome</w>And changing the double quote to a single quote makes it a little less messy: <code>(grammar/parser &quot;EOL ::= #&apos;[\\x0D\\x0A]&apos;&quot;)</code></z><z id="t1653430710" t="winsome Thanks!"><y>#</y><d>2022-05-24</d><h>22:18</h><w>winsome</w>Thanks!</z><z id="t1653430743" t="aengelberg no problem"><y>#</y><d>2022-05-24</d><h>22:19</h><w>aengelberg</w>no problem</z><z id="t1653827029" t="niclasnilsson Hi everyone. I have a grammar problem I don’t know how to get around. I’m parsing guitar chords, and there is an “ambiguity” in the grammar (at least the way I implemented it). The problem is that a chord can have a quality (major/minor for instance). If it’s minor, it’s always written out, but if it’s major it’s often omitted (default). Then after the chord quality, there are intervals. Each interval also have an optional quality and always a number. My problem is that in some cases this leads to two different possible answers. In those cases, the one with a chord quality is always the right one. I could of course always do insta/parses and analyse the results and pick the right one, but I guess/hope there is a better way to express the grammar to avoid this and just get one (correct) result? I’d like the chord-quality to always take precedence / be “greedy”. Is there a way to write the grammar to solve this? Edit: One thing to add is that if there is no chord-quality, it means major (so major is implicitly default), if that helps in any way. (ns chord-parser (:require [instaparse.core :as insta])) (def chord-ebnf-small &quot;chord = root chord-quality interval* root = #&apos;[A-G]&apos; chord-quality = quality? interval = quality? number number = &apos;7&apos; | &apos;9&apos; | &apos;11&apos; | &apos;13&apos; quality = major | minor major = &apos;M&apos; minor = &apos;m&apos;&quot;) (def chord-parser (insta/parser chord-ebnf-small)) (insta/parses chord-parser &quot;C9&quot;) ; =&gt; ([:chord ; [:root &quot;C&quot;] ; [:chord-quality] ; [:interval [:number &quot;9&quot;]]) ; As expected. (insta/parses chord-parser &quot;Cm&quot;) ; =&gt; ([:chord ; [:root &quot;C&quot;] ; [:chord-quality [:quality [:minor &quot;m&quot;]]]) ; As expected. (insta/parses chord-parser &quot;CmM9&quot;) ; =&gt; ([:chord ; [:root &quot;C&quot;] ; [:chord-quality [:quality [:minor &quot;m&quot;]]] ; [:interval [:quality [:major &quot;M&quot;]] [:number &quot;9&quot;]]) ; As expected. (insta/parses chord-parser &quot;Cm9&quot;) ; =&gt; ([:chord ; [:root &quot;C&quot;] ; [:chord-quality] ; [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;9&quot;]] ; [:chord ; [:root &quot;C&quot;] ; [:chord-quality [:quality [:minor &quot;m&quot;]]] ; [:interval [:number &quot;9&quot;]]]) ; Ambiguous. The one with an actual chord-quality is the correct one. (insta/parses chord-parser &quot;Cm9m11&quot;) ; =&gt; ([:chord ; [:root &quot;C&quot;] ; [:chord-quality] ; [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;9&quot;]] ; [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;11&quot;]] ; [:chord ; [:root &quot;C&quot;] ; [:chord-quality [:quality [:minor &quot;m&quot;]]] ; [:interval [:number &quot;9&quot;]] ; [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;11&quot;]]]) ; Ambiguous. The one with an actual chord-quality is the correct one."><y>#</y><d>2022-05-29</d><h>12:23</h><w>niclasnilsson</w>Hi everyone. I have a grammar problem I don’t know how to get around. I’m parsing guitar chords, and there is an “ambiguity” in the grammar (at least the way I implemented it).

The problem is that a chord can have a quality (major/minor for instance). If it’s minor, it’s always written out, but if it’s major it’s often omitted (default). Then after the chord quality, there are intervals. Each interval also have an optional quality and always a number. My problem is that in some cases this leads to two different possible answers. In those cases, the one with a chord quality is always the right one. I could of course always do <code>insta/parses</code> and analyse the results and pick the right one, but I guess/hope there is a better way to express the grammar to avoid this and just get one (correct) result? I’d like the chord-quality to always take precedence / be “greedy”.

Is there a way to write the grammar to solve this?

Edit: One thing to add is that if there is no chord-quality, it means major (so major is implicitly default), if that helps in any way.

<pre>(ns chord-parser
  (:require
    [instaparse.core :as insta]))

(def chord-ebnf-small
  &quot;chord = root chord-quality interval*
   root = #&apos;[A-G]&apos;
   chord-quality = quality?
   interval = quality? number
   number = &apos;7&apos; | &apos;9&apos; | &apos;11&apos; | &apos;13&apos;
   quality = major | minor
   major = &apos;M&apos;
   minor = &apos;m&apos;&quot;)

(def chord-parser (insta/parser chord-ebnf-small))


(insta/parses chord-parser &quot;C9&quot;)
; =&gt; ([:chord 
;      [:root &quot;C&quot;] 
;      [:chord-quality] 
;      [:interval [:number &quot;9&quot;]])
; As expected.

(insta/parses chord-parser &quot;Cm&quot;)
; =&gt; ([:chord 
;      [:root &quot;C&quot;] 
;      [:chord-quality [:quality [:minor &quot;m&quot;]]])
; As expected.

(insta/parses chord-parser &quot;CmM9&quot;)
; =&gt; ([:chord
;      [:root &quot;C&quot;]
;      [:chord-quality [:quality [:minor &quot;m&quot;]]]
;      [:interval [:quality [:major &quot;M&quot;]] [:number &quot;9&quot;]])
; As expected.

(insta/parses chord-parser &quot;Cm9&quot;)
; =&gt; ([:chord 
;      [:root &quot;C&quot;] 
;      [:chord-quality] 
;      [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;9&quot;]]
;     [:chord 
;      [:root &quot;C&quot;] 
;      [:chord-quality [:quality [:minor &quot;m&quot;]]] 
;      [:interval [:number &quot;9&quot;]]])
; Ambiguous. The one with an actual chord-quality is the correct one.

(insta/parses chord-parser &quot;Cm9m11&quot;)
; =&gt; ([:chord
;      [:root &quot;C&quot;]
;      [:chord-quality]
;      [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;9&quot;]]
;      [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;11&quot;]]
;     [:chord
;      [:root &quot;C&quot;]
;      [:chord-quality [:quality [:minor &quot;m&quot;]]]
;      [:interval [:number &quot;9&quot;]]
;      [:interval [:quality [:minor &quot;m&quot;]] [:number &quot;11&quot;]]])
; Ambiguous. The one with an actual chord-quality is the correct one.</pre></z><z id="t1653894595" t="Linus Ericsson I would solve this by a separate function that processes the parsed chord entities to default major etc"><y>#</y><d>2022-05-30</d><h>07:09</h><r>Linus Ericsson</r>I would solve this by a separate function that processes the parsed chord entities to default major etc</z><z id="t1653896289" t="niclasnilsson Yep, but for me that’s the step after whatever can be done in the parsing step. I changed the EBNF to the following, using the PEG extension “ordered choice” (the / ), and now insta/parse always returns the right one. I will still have to fill in major as default afterwards of course, since that information is implicit. (def chord-ebnf-small &quot;chord = root / root chord-quality / root chord-quality interval* / root interval* root = #&apos;[A-G]&apos; chord-quality = quality interval = quality? number number = &apos;7&apos; | &apos;9&apos; | &apos;11&apos; | &apos;13&apos; quality = major | minor major = &apos;M&apos; minor = &apos;m&apos;&quot;)"><y>#</y><d>2022-05-30</d><h>07:38</h><r>niclasnilsson</r>Yep, but for me that’s the step after whatever can be done in the parsing step. I changed the EBNF to the following, using the PEG extension “ordered choice” (the / ),  and now <code>insta/parse</code> always returns the right one. I will still have to fill in major as default afterwards of course, since that information is implicit.

<pre>(def chord-ebnf-small
  &quot;chord = root / root chord-quality / root chord-quality interval* / root interval*
   root = #&apos;[A-G]&apos;
   chord-quality = quality
   interval = quality? number
   number = &apos;7&apos; | &apos;9&apos; | &apos;11&apos; | &apos;13&apos;
   quality = major | minor
   major = &apos;M&apos;
   minor = &apos;m&apos;&quot;)</pre></z><z id="t1653896707" t="Linus Ericsson Yes I understood what you wanted to do. I just cannot see why you want instaparse to do it - it may be possible but it is not really a part of parsing the tabs. The implicit major chords are not really the same as explicit major chords."><y>#</y><d>2022-05-30</d><h>07:45</h><r>Linus Ericsson</r>Yes I understood what you wanted to do. I just cannot see why you want instaparse to do it - it may be possible but it is not really a part of parsing the tabs. The implicit major chords are not really the same as explicit major chords.</z><z id="t1653896925" t="niclasnilsson Ah, no, maybe I misunderstand you, but I didn’t want instaparse to fill in major as default. I wanted instaparse to pick the right choice and interpret Cm9 as C minor 9 and not as C (major) with a minor 9. With the PEG ordered choice I managed to get what I wanted."><y>#</y><d>2022-05-30</d><h>07:48</h><r>niclasnilsson</r>Ah, no, maybe I misunderstand you, but I didn’t want instaparse to fill in major as default. I wanted instaparse to pick the right choice and interpret Cm9 as C minor 9 and not as C (major) with a minor 9. With the PEG ordered choice I managed to get what I wanted.</z><z id="t1653897002" t="Linus Ericsson Ah, ok! Now I see. Great that it could be solved with ordered choice."><y>#</y><d>2022-05-30</d><h>07:50</h><r>Linus Ericsson</r>Ah, ok! Now I see. Great that it could be solved with ordered choice.</z><z id="t1653897110" t="niclasnilsson Yes, this was the first time I looked into those extensions, but they seem pretty useful."><y>#</y><d>2022-05-30</d><h>07:51</h><r>niclasnilsson</r>Yes, this was the first time I looked into those extensions, but they seem pretty useful.</z><z id="t1653897185" t="Linus Ericsson I would extend the root to be C C# D D# E F F# G G# A A# B (and maybe all the b versions as well)"><y>#</y><d>2022-05-30</d><h>07:53</h><r>Linus Ericsson</r>I would extend the root to be C C# D D# E F F# G G# A A# B (and maybe all the b versions as well)</z><z id="t1653897236" t="Linus Ericsson And all the colorings, but that might be out of the scope for the example 🙂"><y>#</y><d>2022-05-30</d><h>07:53</h><r>Linus Ericsson</r>And all the colorings, but that might be out of the scope for the example <b>🙂</b></z><z id="t1653897243" t="niclasnilsson Absolutely. And there are 6, sus, dim and stuff missing as well 🙂"><y>#</y><d>2022-05-30</d><h>07:54</h><r>niclasnilsson</r>Absolutely. And there are 6, sus, dim and stuff missing as well <b>🙂</b></z><z id="t1653897251" t="niclasnilsson colorings?"><y>#</y><d>2022-05-30</d><h>07:54</h><r>niclasnilsson</r>colorings?</z><z id="t1653897296" t="niclasnilsson That’s outside of my current music theory knowledge, but that sounds interesting!"><y>#</y><d>2022-05-30</d><h>07:54</h><r>niclasnilsson</r>That’s outside of my current music theory knowledge, but that sounds interesting!</z><z id="t1653897308" t="Linus Ericsson No, i meant chord types."><y>#</y><d>2022-05-30</d><h>07:55</h><r>Linus Ericsson</r>No, i meant chord types.</z><z id="t1653897339" t="niclasnilsson Ah, as in playing the chord in different ways / places on the neck?"><y>#</y><d>2022-05-30</d><h>07:55</h><r>niclasnilsson</r>Ah, as in playing the chord in different ways / places on the neck?</z><z id="t1653897379" t="Linus Ericsson That would be something - idk if tabulatures has notation for that, but that was not what I meant either https://www.guitarworld.com/lessons/10-gorgeous-color-chords-can-inspire-your-playing"><y>#</y><d>2022-05-30</d><h>07:56</h><r>Linus Ericsson</r>That would be something - idk if tabulatures has notation for that, but that was not what I meant either <a href="https://www.guitarworld.com/lessons/10-gorgeous-color-chords-can-inspire-your-playing" target="_blank">https://www.guitarworld.com/lessons/10-gorgeous-color-chords-can-inspire-your-playing</a></z><z id="t1653897598" t="niclasnilsson Ah, got it. I don’t think I’ve seen tab notation on that, apart from “slash chords” like Am7/G to note the bass note."><y>#</y><d>2022-05-30</d><h>07:59</h><r>niclasnilsson</r>Ah, got it. I don’t think I’ve seen tab notation on that, apart from “slash chords” like Am7/G to note the bass note.</z><z id="t1653897626" t="niclasnilsson (which may or may not be part of the actual chord)"><y>#</y><d>2022-05-30</d><h>08:00</h><r>niclasnilsson</r>(which may or may not be part of the actual chord)</z><z id="t1653897667" t="niclasnilsson and when it’s part of the chord, I guess it actually becomes coloring?"><y>#</y><d>2022-05-30</d><h>08:01</h><r>niclasnilsson</r>and when it’s part of the chord, I guess it actually becomes coloring?</z><z id="t1653897695" t="niclasnilsson interesting"><y>#</y><d>2022-05-30</d><h>08:01</h><r>niclasnilsson</r>interesting</z><z id="t1653897748" t="Linus Ericsson I&apos;m in the deep end of the pond here but yes, if you was to play Cmaj7 it would be noted as that, and not C/B"><y>#</y><d>2022-05-30</d><h>08:02</h><r>Linus Ericsson</r>I&apos;m in the deep end of the pond here but yes, if you was to play Cmaj7 it would be noted as that, and not C/B</z><z id="t1653897878" t="Linus Ericsson I guess it would be a nice thing to be able to convert between (midi) note values and tabulatures, possibly with bass notes..."><y>#</y><d>2022-05-30</d><h>08:04</h><r>Linus Ericsson</r>I guess it would be a nice thing to be able to convert between (midi) note values and tabulatures, possibly with bass notes...</z><z id="t1653897879" t="niclasnilsson Yes, I’m more thinking in the way of what’s “common” in chord progressions, like C, C/E, F"><y>#</y><d>2022-05-30</d><h>08:04</h><r>niclasnilsson</r>Yes, I’m more thinking in the way of what’s “common” in chord progressions, like C, C/E, F</z><z id="t1653897973" t="niclasnilsson And I suppose since E is part of C major, it’s coloring, vs if the bass note was something outside of C major, it’s probably something else?"><y>#</y><d>2022-05-30</d><h>08:06</h><r>niclasnilsson</r>And I suppose since E is part of C major, it’s coloring, vs if the bass note was something outside of C major, it’s probably something else?</z><z id="t1653898030" t="Linus Ericsson Hmm, &quot;as a&quot; bass player i would parse C C/E F as C - E - F"><y>#</y><d>2022-05-30</d><h>08:07</h><r>Linus Ericsson</r>Hmm, &quot;as a&quot; bass player i would parse C C/E F as C - E - F</z><z id="t1653898036" t="niclasnilsson Fun stuff to think about and learn about!"><y>#</y><d>2022-05-30</d><h>08:07</h><r>niclasnilsson</r>Fun stuff to think about and learn about!</z><z id="t1653898079" t="niclasnilsson Exactly, but the guitarist can also play E in the bass of the C chord."><y>#</y><d>2022-05-30</d><h>08:07</h><r>niclasnilsson</r>Exactly, but the guitarist can also play E in the bass of the C chord.</z><z id="t1653898082" t="Linus Ericsson One day I will learn musical notation by implementing it."><y>#</y><d>2022-05-30</d><h>08:08</h><r>Linus Ericsson</r>One day I will learn musical notation by implementing it.</z><z id="t1653898145" t="niclasnilsson Learning (non-computer) stuff through coding is my favourite way of understanding stuff, by far."><y>#</y><d>2022-05-30</d><h>08:09</h><r>niclasnilsson</r>Learning (non-computer) stuff through coding is my favourite way of understanding stuff, by far.</z><z id="t1664202822" t="r0man Hello, I have defined a grammar [1] to parse Java stacktrace with Instaparse. The grammar seems to work if I pass well formed input to it. What I would like to do next, is use the grammar to also parse input that has &quot;garbage&quot; at the beginning or the end of the input string. So I would go from something like this: S = exception causes exception = ... causes = ... to something like this: S = &lt;garbage?&gt; exception causes &lt;garbage?&gt; exception = ... causes = ... Now, the issue I am facing is how to define &lt;garbage&gt; . I tried to define it as #[\s\S]* but I believe it is too greedy and it messes up my grammar. For example, sometimes parsing succeeds with garbage, but most of the input is eaten by &lt;garbage&gt; and not by my actual stacktrace grammar. I&apos;m staring to wonder if I actually should include the &lt;garbage&gt; into my grammar at all, or use some other functionality of Instaparse. I saw I can use insta/parses to get access to all parses tried so far, but they are quite a lot, and I am not sure which one to pick (I guess it depends on my application). How do you deal with garbage, or rules that are too greedy in Instaparse? Thanks for your help. [1] https://github.com/r0man/orchard/blob/stacktrace-at-point/resources/orchard/stacktrace/parser/java.bnf"><y>#</y><d>2022-09-26</d><h>14:33</h><w>r0man</w>Hello,

I have defined a grammar [1] to parse Java stacktrace with Instaparse. The grammar seems to work if I pass well formed input to it.

What I would like to do next, is use the grammar to also parse input that has &quot;garbage&quot; at the beginning or the end of the input string.

So I would go from something like this:

<pre>S = exception causes
exception = ...
causes = ...
</pre>

to something like this:

<pre>S = &lt;garbage?&gt; exception causes &lt;garbage?&gt;
exception = ...
causes = ...
</pre>

Now, the issue I am facing is how to define <code>&lt;garbage&gt;</code>. I tried to define it as <code>#[\s\S]*</code> but I believe it is too greedy and it messes up my grammar. For example, sometimes parsing succeeds with garbage, but most of the input is eaten by <code>&lt;garbage&gt;</code> and not by my actual stacktrace grammar.

I&apos;m staring to wonder if I actually should include the &lt;garbage&gt; into my grammar at all, or use some other functionality of Instaparse. I saw I can use <code>insta/parses</code> to get access to all parses tried so far, but they are quite a lot, and I am not sure which one to pick (I guess it depends on my application).

How do you deal with garbage, or rules that are too greedy in Instaparse?

Thanks for your help.

[1] <a href="https://github.com/r0man/orchard/blob/stacktrace-at-point/resources/orchard/stacktrace/parser/java.bnf" target="_blank">https://github.com/r0man/orchard/blob/stacktrace-at-point/resources/orchard/stacktrace/parser/java.bnf</a></z><z id="t1667548407" t="sova-soars-the-sora I have a set of vowel patterns I want to match against, flexibly. Any idears?"><y>#</y><d>2022-11-04</d><h>07:53</h><w>sova-soars-the-sora</w>I have a set of vowel patterns I want to match against, flexibly.  Any idears?</z><z id="t1667763248" t="zane Might want to provide some more details. simple_smile"><y>#</y><d>2022-11-06</d><h>19:34</h><r>zane</r>Might want to provide some more details. <b>simple_smile</b></z><z id="t1673721381" t="borkdude If anyone wants to try instaparse with #babashka check this out: https://github.com/babashka/instaparse.bb"><y>#</y><d>2023-01-14</d><h>18:36</h><w>borkdude</w>If anyone wants to try instaparse with #babashka check this out:
<a href="https://github.com/babashka/instaparse.bb" target="_blank">https://github.com/babashka/instaparse.bb</a></z><z id="t1673858530" t="Sigve It would be interesting to read about the challenges in porting this, and the subsequent limitations"><y>#</y><d>2023-01-16</d><h>08:42</h><r>Sigve</r>It would be interesting to read about the challenges in porting this, and the subsequent limitations</z><z id="t1673858871" t="borkdude The limitations are around not being able to serialize certain things like functions, for which there are solutions (e.g. send around quoted things and evaluate them later)"><y>#</y><d>2023-01-16</d><h>08:47</h><r>borkdude</r>The limitations are around not being able to serialize certain things like functions, for which there are solutions (e.g. send around quoted things and evaluate them later)</z><z id="t1673858885" t="borkdude Since pod function calls are basically RPC calls"><y>#</y><d>2023-01-16</d><h>08:48</h><r>borkdude</r>Since pod function calls are basically RPC calls</z><z id="t1673941272" t="Sigve I see, thanks"><y>#</y><d>2023-01-17</d><h>07:41</h><r>Sigve</r>I see, thanks</z><z id="t1673974215" t="robert-stuttaford we managed to take our servers down with an instaparse implementation that powers a css documentation system we built for ourselves. we literally lived the one problem, two problems regex today 😂"><y>#</y><d>2023-01-17</d><h>16:50</h><w>robert-stuttaford</w>we managed to take our servers down with an instaparse implementation that powers a css documentation system we built for ourselves.

we literally lived the one problem, two problems regex today <b>😂</b></z><z id="t1675081723" t="licht1stein Hi, I&apos;m totally new to parsing, working on a linguistic side project. I&apos;m trying to parse something that looks like this: &quot;&lt;pc&gt;1,1&lt;k1&gt;a&lt;k2&gt;a&lt;h&gt;1&lt;e&gt;1\n&lt;hom&gt;1.&lt;/hom&gt; &lt;s&gt;a&lt;/s&gt;&quot; , where &lt;pc&gt;1,1 , &lt;k1&gt;a is a first type of tag, and &lt;s&gt;a&lt;/s&gt; is another type of tag. I would like to get something like {:pc &quot;1,1&quot; :k1 &quot;a&quot; :k2 &quot;a&quot; :h &quot;1&quot;} for starters, because the second part should be simple xml. I&apos;ve got this, which works as long as the string doesn&apos;t contain anything else, but breaks on the entire sample: &quot; S = {tag} tag = &lt;tag-open&gt; + key + &lt;tag-close&gt; + value key = #&apos;[a-zA-Z0-9]+&apos; value = #&apos;[a-zA-Z0-9]+&apos; tag-open = #&apos;&lt;&apos; tag-close = &apos;&gt;&apos; &quot; I feel like I&apos;m missing an understanding of some basic piece. I also don&apos;t know how to separate xml tags from these first kind of tags. Please help."><y>#</y><d>2023-01-30</d><h>12:28</h><w>licht1stein</w>Hi, I&apos;m totally new to parsing, working on a linguistic side project. I&apos;m trying to parse something that looks like this: <code>&quot;&lt;pc&gt;1,1&lt;k1&gt;a&lt;k2&gt;a&lt;h&gt;1&lt;e&gt;1\n&lt;hom&gt;1.&lt;/hom&gt; &lt;s&gt;a&lt;/s&gt;&quot;</code>, where <code>&lt;pc&gt;1,1</code> , <code>&lt;k1&gt;a</code> is a first type of tag, and <code>&lt;s&gt;a&lt;/s&gt;</code> is another type of tag. I would like to get something like <code>{:pc &quot;1,1&quot; :k1 &quot;a&quot; :k2 &quot;a&quot; :h &quot;1&quot;}</code> for starters, because the second part should be simple xml. I&apos;ve got this, which works as long as the string doesn&apos;t contain anything else, but breaks on the entire sample:

<pre>&quot;
S = {tag}
tag = &lt;tag-open&gt; + key + &lt;tag-close&gt; + value
key = #&apos;[a-zA-Z0-9]+&apos;
value = #&apos;[a-zA-Z0-9]+&apos;
tag-open = #&apos;&lt;&apos;
tag-close = &apos;&gt;&apos;
&quot;</pre>
I feel like I&apos;m missing an understanding of some basic piece. I also don&apos;t know how to separate xml tags from these first kind of tags. Please help.</z><z id="t1675096505" t="thom This is presumably some form of SGML. You can probably find a Java library that’ll parse it already, but also most HTML libraries will do little fixups to unclosed tags (lots based on JSoup etc). If you want to parse it yourself you just need to introduce opening and closing tags to your grammar and make the closing ones optional."><y>#</y><d>2023-01-30</d><h>16:35</h><r>thom</r>This is presumably some form of SGML. You can probably find a Java library that’ll parse it already, but also most HTML libraries will do little fixups to unclosed tags (lots based on JSoup etc). If you want to parse it yourself you just need to introduce opening and closing tags to your grammar and make the closing ones optional.</z><z id="t1675933199" t="Sigve If anyone here is in the small subset of people using both Instaparse and (n)vim, i made a syntax file with some instaparse-specific things that makes it a bit nicer than using ebnf.vim or similar. Also includes a very basic indent script https://github.com/sigvesn/instaparse.vim"><y>#</y><d>2023-02-09</d><h>08:59</h><w>Sigve</w>If anyone here is in the small subset of people using both Instaparse and (n)vim, i made a syntax file with some instaparse-specific things that makes it a bit nicer than using ebnf.vim or similar. Also includes a very basic indent script

<a href="https://github.com/sigvesn/instaparse.vim" target="_blank">https://github.com/sigvesn/instaparse.vim</a></z></g></div></body>