<!DOCTYPE html>
<head><title>clara</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: pointer
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 184px;} r {min-width: 216px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#clara</h2><pre><i>generated UTC: 2020-11-22 14:51</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/clara/2020-11-17">https://clojurians-log.clojureverse.org/clara/2020-11-17</a></i><i>
messages: 5858</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr) {
    dateFilterInput.innerText = "clear: " + datestr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const t = (cursor && cursor.getAttribute("t"))
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (t && t.startsWith(datestr)) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el,el.previousElementSibling.textContent + " " + el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        console.log(e.target);
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        console.log(e.target);
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><z id="t1441309803000003" t="devn Howdy folks"><y>#</y><d>2015-09-03</d><h>19:50</h><w>devn</w>Howdy folks</z><z id="t1441309808000004" t="devn I am embarking on a Clara journey"><y>#</y><d>2015-09-03</d><h>19:50</h><w>devn</w>I am embarking on a Clara journey</z><z id="t1441309826000005" t="devn I am curious if anyone has any recommended reading"><y>#</y><d>2015-09-03</d><h>19:50</h><w>devn</w>I am curious if anyone has any recommended reading</z><z id="t1441735926000002" t="devn I found some..."><y>#</y><d>2015-09-08</d><h>18:12</h><w>devn</w>I found some...</z><z id="t1441736141000003" t="devn http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf"><y>#</y><d>2015-09-08</d><h>18:15</h><w>devn</w><a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank">http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</a></z><z id="t1441736149000004" t="devn https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471"><y>#</y><d>2015-09-08</d><h>18:15</h><w>devn</w><a href="https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471" target="_blank">https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471</a></z><z id="t1441736196000009" t="devn via @fogus ... via @alandipert"><y>#</y><d>2015-09-08</d><h>18:16</h><w>devn</w>via @fogus ... via @alandipert</z><z id="t1441736223000010" t="devn I suppose this channel could also be #zeder"><y>#</y><d>2015-09-08</d><h>18:17</h><w>devn</w>I suppose this channel could also be #zeder</z><z id="t1441736236000011" t="devn I&apos;ll quit talking to myself, for now..."><y>#</y><d>2015-09-08</d><h>18:17</h><w>devn</w>I&apos;ll quit talking to myself, for now...</z><z id="t1441755680000012" t="cedric.hurst hey @devn"><y>#</y><d>2015-09-08</d><h>23:41</h><w>cedric.hurst</w>hey @devn</z><z id="t1441755722000013" t="cedric.hurst the drools project has some fairly decent generic documentation on the rete algorithm as well: http://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html/ch05.html#ReteOO"><y>#</y><d>2015-09-08</d><h>23:42</h><w>cedric.hurst</w>the drools project has some fairly decent generic documentation on the rete algorithm as well: <a href="http://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html/ch05.html#ReteOO" target="_blank">http://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html/ch05.html#ReteOO</a></z><z id="t1441829925000014" t="devn Thanks @cedric.hurst"><y>#</y><d>2015-09-09</d><h>20:18</h><w>devn</w>Thanks @cedric.hurst</z><z id="t1445878252000005" t="noprompt does anyone know if it&apos;s possible to destructure facts in queries?"><y>#</y><d>2015-10-26</d><h>16:50</h><w>noprompt</w>does anyone know if it&apos;s possible to destructure facts in queries?</z><z id="t1445878304000006" t="noprompt following the railroad diagram doesn&apos;t appear to result in a valid query."><y>#</y><d>2015-10-26</d><h>16:51</h><w>noprompt</w>following the railroad diagram doesn&apos;t appear to result in a valid query.</z><z id="t1445878714000007" t="noprompt nm, we figured it out. we had a stale session. 😿"><y>#</y><d>2015-10-26</d><h>16:58</h><w>noprompt</w>nm, we figured it out. we had a stale session. <b>😿</b></z><z id="t1446161146000010" t="noprompt @ryanbrush is here! 🎊"><y>#</y><d>2015-10-29</d><h>23:25</h><w>noprompt</w>@ryanbrush is here! <b>🎊</b></z><z id="t1446161765000011" t="ryanbrush Howdy! I&apos;m something of a slack newbie but thought I would check it out."><y>#</y><d>2015-10-29</d><h>23:36</h><w>ryanbrush</w>Howdy! I&apos;m something of a slack newbie but thought I would check it out.</z><z id="t1446166140000012" t="ryanbrush So while I&apos;m here, I thought it would be worth mentioning that Clara 0.9 is out. We&apos;re finally on Clojure 1.7 with reader conditionals! https://groups.google.com/forum/#!topic/clara-rules/6Y2zHx9OQwA"><y>#</y><d>2015-10-30</d><h>00:49</h><w>ryanbrush</w>So while I&apos;m here, I thought it would be worth mentioning that Clara 0.9 is out. We&apos;re finally on Clojure 1.7 with reader conditionals! <a href="https://groups.google.com/forum/#!topic/clara-rules/6Y2zHx9OQwA" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/6Y2zHx9OQwA</a></z><z id="t1446217698000013" t="enn :+1: thanks, much nicer to work with than cljx"><y>#</y><d>2015-10-30</d><h>15:08</h><w>enn</w><b>:+1:</b> thanks, much nicer to work with than cljx</z><z id="t1446217786000015" t="devn @ryanbrush: huzzah! nice release."><y>#</y><d>2015-10-30</d><h>15:09</h><w>devn</w>@ryanbrush: huzzah! nice release.</z><z id="t1446233400000017" t="devn @ryanbrush: sorry to be a bother, and I could and will certainly do it myself if it&apos;s a pain or you&apos;d rather not, but any chance of getting a clara-tools release in light of the clara 0.9.0 release?"><y>#</y><d>2015-10-30</d><h>19:30</h><w>devn</w>@ryanbrush: sorry to be a bother, and I could and will certainly do it myself if it&apos;s a pain or you&apos;d rather not, but any chance of getting a clara-tools release in light of the clara 0.9.0 release?</z><z id="t1446233432000019" t="devn Also, welcome @thomas simple_smile"><y>#</y><d>2015-10-30</d><h>19:30</h><w>devn</w>Also, welcome @thomas <b>simple_smile</b></z><z id="t1446233939000020" t="thomas Thank you"><y>#</y><d>2015-10-30</d><h>19:38</h><w>thomas</w>Thank you</z><z id="t1446235418000021" t="devn @thomas: you using clara?"><y>#</y><d>2015-10-30</d><h>20:03</h><w>devn</w>@thomas: you using clara?</z><z id="t1446237614000022" t="thomas No, but I am working on a product with a rule engine at the moment... Hence my interest in clara"><y>#</y><d>2015-10-30</d><h>20:40</h><w>thomas</w>No, but I am working on a product with a rule engine at the moment... Hence my interest in clara</z><z id="t1446237696000023" t="devn @thomas: cool. i&apos;m on a team that&apos;s pretty new to rules engines, myself included. we&apos;re building a new product using clara at the moment and so far it&apos;s been really great."><y>#</y><d>2015-10-30</d><h>20:41</h><w>devn</w>@thomas: cool. i&apos;m on a team that&apos;s pretty new to rules engines, myself included. we&apos;re building a new product using clara at the moment and so far it&apos;s been really great.</z><z id="t1446237784000024" t="devn @thomas: I&apos;d also like to add that @ryanbrush has done a really great job of maintaining, and is using it for real work in production. Super responsive on questions, issues, PRs, etc. So, recommended. simple_smile"><y>#</y><d>2015-10-30</d><h>20:43</h><w>devn</w>@thomas: I&apos;d also like to add that @ryanbrush has done a really great job of maintaining, and is using it for real work in production. Super responsive on questions, issues, PRs, etc. So, recommended. <b>simple_smile</b></z><z id="t1446237801000025" t="thomas Sounds good. I haven&apos;t had a good look at clara yet. "><y>#</y><d>2015-10-30</d><h>20:43</h><w>thomas</w>Sounds good. I haven&apos;t had a good look at clara yet.  </z><z id="t1446238394000027" t="ryanbrush Yes, we&apos;re using it heavily in production now, and I know of a couple others who are as well (although I&apos;m not sure if they&apos;re okay with it being publicly revealed). I did see a post that AppsFlyer is using it ( https://www.appsflyer.com/blog/how-we-solved-authentication-and-authorization-in-our-microservices-architecture/ ) as well."><y>#</y><d>2015-10-30</d><h>20:53</h><w>ryanbrush</w>Yes, we&apos;re using it heavily in production now, and I know of a couple others who are as well (although I&apos;m not sure if they&apos;re okay with it being publicly revealed). I did see a post that AppsFlyer is using it (<a href="https://www.appsflyer.com/blog/how-we-solved-authentication-and-authorization-in-our-microservices-architecture/" target="_blank">https://www.appsflyer.com/blog/how-we-solved-authentication-and-authorization-in-our-microservices-architecture/</a>) as well.</z><z id="t1446238577000029" t="ryanbrush @devn As for a clara-tools release, I should be able to push out 0.1.0 tomorrow based on the accum_updates branch, assuming everything is working well for you with that and Clara 0.9.0."><y>#</y><d>2015-10-30</d><h>20:56</h><w>ryanbrush</w>@devn As for a clara-tools release, I should be able to push out 0.1.0 tomorrow based on the accum_updates branch, assuming everything is working well for you with that and Clara 0.9.0.</z><z id="t1446238902000030" t="devn @ryanbrush: It&apos;s certainly better to see a graph containing the accumulator instead of no graph at all. I guess I would be surprised if 0.9.0 broke the changes you pushed on the accum_updates branch, but I will give it a look and verify now."><y>#</y><d>2015-10-30</d><h>21:01</h><w>devn</w>@ryanbrush: It&apos;s certainly better to see a graph containing the accumulator instead of no graph at all. I guess I would be surprised if 0.9.0 broke the changes you pushed on the <code>accum_updates</code> branch, but I will give it a look and verify now.</z><z id="t1446246739000032" t="devn @mdp: hola simple_smile"><y>#</y><d>2015-10-30</d><h>23:12</h><w>devn</w>@mdp: hola <b>simple_smile</b></z><z id="t1446248134000033" t="mdp @devn: hey simple_smile"><y>#</y><d>2015-10-30</d><h>23:35</h><w>mdp</w>@devn: hey <b>simple_smile</b></z><z id="t1446297362000036" t="ryanbrush @devn clara-tools-0.1.1 is up on Clojars. I took it for a spin with Clara 0.9 and everything seems to be working well."><y>#</y><d>2015-10-31</d><h>13:16</h><w>ryanbrush</w>@devn clara-tools-0.1.1 is up on Clojars. I took it for a spin with Clara 0.9 and everything seems to be working well.</z><z id="t1446297459000037" t="ryanbrush For anyone else who is curious, clara-tools is an experimental UI to visualize rule logic and sessions. (It&apos;s what I used in the Strangeloop 2014 talk.) It&apos;s not as battle hardened as clara-rules itself but has drawn some interest."><y>#</y><d>2015-10-31</d><h>13:17</h><w>ryanbrush</w>For anyone else who is curious, clara-tools is an experimental UI to visualize rule logic and sessions. (It&apos;s what I used in the Strangeloop 2014 talk.) It&apos;s not as battle hardened as clara-rules itself but has drawn some interest.</z><z id="t1446334267000038" t="devn @ryanbrush: you rule. thanks!"><y>#</y><d>2015-10-31</d><h>23:31</h><w>devn</w>@ryanbrush: you rule. thanks!</z><z id="t1446334361000039" t="devn @ryanbrush: i guess I&apos;m a little surprised there hasn&apos;t been more interest in it. Is the situation you have at Cerner one in which clinical staff help to write rules, or evaluate the results of the engine?"><y>#</y><d>2015-10-31</d><h>23:32</h><w>devn</w>@ryanbrush: i guess I&apos;m a little surprised there hasn&apos;t been more interest in it. Is the situation you have at Cerner one in which clinical staff help to write rules, or evaluate the results of the engine?</z><z id="t1446334465000040" t="devn i&apos;ve always thought that the explanation piece of a rules engine was one of the biggest driving factors behind choosing to use one on a project, so I guess I&apos;m surprised there aren&apos;t fancier explanations or more interest in graphing"><y>#</y><d>2015-10-31</d><h>23:34</h><w>devn</w>i&apos;ve always thought that the explanation piece of a rules engine was one of the biggest driving factors behind choosing to use one on a project, so I guess I&apos;m surprised there aren&apos;t fancier explanations or more interest in graphing</z><z id="t1446396591000041" t="ryanbrush @devn Our internal code has its own facilities for doing explanation that are specific to the domain, and unfortunately not something I can get into publicly. I do think clara-tools has a bright future, it just hasn&apos;t quite made it to being a big priority yet."><y>#</y><d>2015-11-01</d><h>16:49</h><w>ryanbrush</w>@devn Our internal code has its own facilities for doing explanation that are specific to the domain, and unfortunately not something I can get into publicly. I do think clara-tools has a bright future, it just hasn&apos;t quite made it to being a big priority yet.</z><z id="t1446409378000042" t="devn @ryanbrush: Yeah, no surprise to me that there&apos;s some special sauce for domain-specific explanation. We&apos;re already there ourselves."><y>#</y><d>2015-11-01</d><h>20:22</h><w>devn</w>@ryanbrush: Yeah, no surprise to me that there&apos;s some special sauce for domain-specific explanation. We&apos;re already there ourselves.</z><z id="t1446409459000043" t="devn I guess I&apos;m wondering aloud a little bit about whether or not it&apos;s the concern of Clara to provide hooks into extending/providing the built-in explanation facilities."><y>#</y><d>2015-11-01</d><h>20:24</h><w>devn</w>I guess I&apos;m wondering aloud a little bit about whether or not it&apos;s the concern of Clara to provide hooks into extending/providing the built-in explanation facilities.</z><z id="t1446409570000045" t="devn Or if it&apos;s more along the lines of: &quot;clara gives you plenty of data to build your own explanations. use it.&quot;"><y>#</y><d>2015-11-01</d><h>20:26</h><w>devn</w>Or if it&apos;s more along the lines of: &quot;clara gives you plenty of data to build your own explanations. use it.&quot;</z><z id="t1446409636000046" t="devn I think there&apos;s a delicate balance there, but I don&apos;t have a strong opinion at the moment."><y>#</y><d>2015-11-01</d><h>20:27</h><w>devn</w>I think there&apos;s a delicate balance there, but I don&apos;t have a strong opinion at the moment.</z><z id="t1446420628000047" t="devn Heya @ryanbrush -- Is there a reason why there isn&apos;t a group-by -esque built-in accumulator?"><y>#</y><d>2015-11-01</d><h>23:30</h><w>devn</w>Heya @ryanbrush -- Is there a reason why there isn&apos;t a <code>group-by</code>-esque built-in accumulator?</z><z id="t1446421956000048" t="ryanbrush @devn No reason besides the fact that we just hadn&apos;t needed it yet. I think it makes sense and would be happy to include it if someone wants to take a stab at it."><y>#</y><d>2015-11-01</d><h>23:52</h><w>ryanbrush</w>@devn No reason besides the fact that we just hadn&apos;t needed it yet. I think it makes sense and would be happy to include it if someone wants to take a stab at it.</z><z id="t1446422073000049" t="devn @ryanbrush: cool, was seeing max/sum/all/min/average and such, which made me wonder if group-by would somehow be problematic for automatic retraction"><y>#</y><d>2015-11-01</d><h>23:54</h><w>devn</w>@ryanbrush: cool, was seeing max/sum/all/min/average and such, which made me wonder if group-by would somehow be problematic for automatic retraction</z><z id="t1446422541000050" t="ryanbrush Retraction presents some edge cases that aren&apos;t trivial but it&apos;s solvable in group-by similar to how we do it in other accumulators. Notice the all accumulator takes care to only remove what is retracted, for instance. Group-by is more complicated but I think a suitable approach would work."><y>#</y><d>2015-11-02</d><h>00:02</h><w>ryanbrush</w>Retraction presents some edge cases that aren&apos;t trivial but it&apos;s solvable in group-by similar to how we do it in other accumulators. Notice the all accumulator takes care to only remove what is retracted, for instance. Group-by is more complicated but I think a suitable approach would work.</z><z id="t1446422580000051" t="devn Gotcha. Thanks."><y>#</y><d>2015-11-02</d><h>00:03</h><w>devn</w>Gotcha. Thanks.</z><z id="t1446422649000052" t="devn @ryanbrush: as long as I&apos;ve got you here: something that&apos;s been on my mind that I think I remember reading something on the ML about is: How much can I rely on storing rules in a database, what about sessions? We&apos;ve been toying with the idea of exposing some level of rule authorship at some point in the future, but either way, we are going to have differing sets of rules, some of which will be generated based on configuration data."><y>#</y><d>2015-11-02</d><h>00:04</h><w>devn</w>@ryanbrush: as long as I&apos;ve got you here: something that&apos;s been on my mind that I think I remember reading something on the ML about is: How much can I rely on storing rules in a database, what about sessions? We&apos;ve been toying with the idea of exposing some level of rule authorship at some point in the future, but either way, we are going to have differing sets of rules, some of which will be generated based on configuration data.</z><z id="t1446423060000053" t="devn Other random things on my mind: 1.) I&apos;ve been reading about Jess and Drools, and they have a collect or collectBy IIRC. Since map can be written in terms of reduce , is it reasonable to say that Clara has collect by way of its accumulate ? Is all basically collect ? 2.) Do you have any suggested reading? I am occasionally flop-sweating a bit over whether or not I should reach for an accumulator, for instance. This is my first time working with a rules engine, and so I am still sort of in the hunting and pecking phase. Not entirely confident."><y>#</y><d>2015-11-02</d><h>00:11</h><w>devn</w>Other random things on my mind:

1.) I&apos;ve been reading about Jess and Drools, and they have a <code>collect</code> or <code>collectBy</code> IIRC. Since <code>map</code> can be written in terms of <code>reduce</code>, is it reasonable to say that Clara has <code>collect</code> by way of its <code>accumulate</code>? Is <code>all</code> basically <code>collect</code>?

2.) Do you have any suggested reading? I am occasionally flop-sweating a bit over whether or not I should reach for an accumulator, for instance. This is my first time working with a rules engine, and so I am still sort of in the hunting and pecking phase. Not entirely confident.</z><z id="t1446423321000056" t="ryanbrush I don&apos;t see any problem with storing rules or externally or generating them, and mixing those rules with hand-written rules. mk-session supports multiple inputs that can pull rules in from multiple heterogenous sources. Note that to load new rules you need to create a new session...you can&apos;t add or update rules to a session that has already been created."><y>#</y><d>2015-11-02</d><h>00:15</h><w>ryanbrush</w>I don&apos;t see any problem with storing rules or externally or generating them, and mixing those rules with hand-written rules. mk-session supports multiple inputs that can pull rules in from multiple heterogenous sources. Note that to load new rules you need to create a new session...you can&apos;t add or update rules to a session that has already been created.</z><z id="t1446423390000057" t="ryanbrush As for collect and collectBy, it&apos;s been a while since I&apos;ve used Drools but I believe they are basically just the all accumulator (or some other special accumulator case)."><y>#</y><d>2015-11-02</d><h>00:16</h><w>ryanbrush</w>As for collect and collectBy, it&apos;s been a while since I&apos;ve used Drools but I believe they are basically just the all accumulator (or some other special accumulator case).</z><z id="t1446423532000058" t="ryanbrush As for recommended reading, most of what I&apos;ve found lately subscribes to the approach of rules-for-business-users rather than directed at engineers, so there&apos;s not much out there. I think designing rules just follows the best practices for designing code: take the simplest, most clear, and least surprising approach possible...and iterate to improve it."><y>#</y><d>2015-11-02</d><h>00:18</h><w>ryanbrush</w>As for recommended reading, most of what I&apos;ve found lately subscribes to the approach of rules-for-business-users rather than directed at engineers, so there&apos;s not much out there. I think designing rules just follows the best practices for designing code: take the simplest, most clear, and least surprising approach possible...and iterate to improve it.</z><z id="t1446423535000059" t="devn @ryanbrush: yeah, we&apos;re pulling from multiple sources right now. I guess the big question was: as of right now, do you foresee any future compatibility issues with storing the value of a defrule . Like, if 1.0 changed to having :lhs {:different [] :stuff []}"><y>#</y><d>2015-11-02</d><h>00:18</h><w>devn</w>@ryanbrush: yeah, we&apos;re pulling from multiple sources right now. I guess the big question was: as of right now, do you foresee any future compatibility issues with storing the value of a <code>defrule</code>. Like, if 1.0 changed to having <code>:lhs {:different [] :stuff []}</code></z><z id="t1446423617000060" t="ryanbrush No, I think the schema for the defrule and defquery value is pretty much locked down."><y>#</y><d>2015-11-02</d><h>00:20</h><w>ryanbrush</w>No, I think the schema for the defrule and defquery value is pretty much locked down.</z><z id="t1446423660000061" t="ryanbrush Any changes there would be non-breaking (like we might add properties for activation groups or things like that). But that basic structure of a rule is pretty fundamental to the system, so I don&apos;t see it changing."><y>#</y><d>2015-11-02</d><h>00:21</h><w>ryanbrush</w>Any changes there would be non-breaking (like we might add properties for activation groups or things like that). But that basic structure of a rule is pretty fundamental to the system, so I don&apos;t see it changing.</z><z id="t1446423663000062" t="devn @ryanbrush: good common sense advice. i would hope we&apos;re meeting our obligation to keep things clean, but in some cases I question whether I&apos;m taking the &quot;easy&quot; route over the &quot;simple&quot; route, simply because I don&apos;t know what I don&apos;t know."><y>#</y><d>2015-11-02</d><h>00:21</h><w>devn</w>@ryanbrush: good common sense advice. i would hope we&apos;re meeting our obligation to keep things clean, but in some cases I question whether I&apos;m taking the &quot;easy&quot; route over the &quot;simple&quot; route, simply because I don&apos;t know what I don&apos;t know.</z><z id="t1446423684000065" t="ryanbrush @devn Haha, I feel that way every day I wrote code!"><y>#</y><d>2015-11-02</d><h>00:21</h><w>ryanbrush</w>@devn Haha, I feel that way every day I wrote code!</z><z id="t1446423736000066" t="devn heh, yeah, kind of a universal problem simple_smile"><y>#</y><d>2015-11-02</d><h>00:22</h><w>devn</w>heh, yeah, kind of a universal problem <b>simple_smile</b></z><z id="t1446423743000067" t="devn btw @ryanbrush -- i dropped you a PM"><y>#</y><d>2015-11-02</d><h>00:22</h><w>devn</w>btw @ryanbrush -- i dropped you a PM</z><z id="t1446423786000068" t="ryanbrush @devn By the way, what do you think about changing the URL for this group to http://www.clara-rules.org/ ? It&apos;s a bit cleaner and more accessible front door to Clara than the GitHub page."><y>#</y><d>2015-11-02</d><h>00:23</h><w>ryanbrush</w>@devn By the way, what do you think about changing the URL for this group to <a href="http://www.clara-rules.org/" target="_blank">http://www.clara-rules.org/</a> ? It&apos;s a bit cleaner and more accessible front door to Clara than the GitHub page.</z><z id="t1446423797000070" t="devn Of course!"><y>#</y><d>2015-11-02</d><h>00:23</h><w>devn</w>Of course!</z><z id="t1446423807000071" t="devn This is really your channel. simple_smile"><y>#</y><d>2015-11-02</d><h>00:23</h><w>devn</w>This is really your channel. <b>simple_smile</b></z><z id="t1447448695000003" t="noprompt @ryanbrush: this appears to be invalid is there a way to express this?:"><y>#</y><d>2015-11-13</d><h>21:04</h><w>noprompt</w>@ryanbrush: this appears to be invalid is there a way to express this?:</z><z id="t1447448697000004" t="noprompt [?it &lt;- accumulator [:or [X1 (= ?v x)] [X2 (= ?v x)] [X3 (= ?v x)]]]"><y>#</y><d>2015-11-13</d><h>21:04</h><w>noprompt</w><pre>[?it &lt;- accumulator
   [:or
    [X1 (= ?v x)]
    [X2 (= ?v x)]
    [X3 (= ?v x)]]]</pre></z><z id="t1447448846000005" t="noprompt the error we receive {:type java.lang.IllegalArgumentException :message &quot;Only one argument can be passed to a condition.&quot; :at [clara.rules.dsl$construct_condition invoke &quot;dsl.clj&quot; 53]}"><y>#</y><d>2015-11-13</d><h>21:07</h><w>noprompt</w>the error we receive <pre>{:type java.lang.IllegalArgumentException
   :message &quot;Only one argument can be passed to a condition.&quot;
   :at [clara.rules.dsl$construct_condition invoke &quot;dsl.clj&quot; 53]}</pre></z><z id="t1447448928000006" t="noprompt maybe it&apos;s worth a PR but i think it&apos;d be helpful to use ex-info here providing the offending form. we had to do a bit of binary chop to find the problem."><y>#</y><d>2015-11-13</d><h>21:08</h><w>noprompt</w>maybe it&apos;s worth a PR but i think it&apos;d be helpful to use <code>ex-info</code> here providing the offending form. we had to do a bit of binary chop to find the problem.</z><z id="t1447449342000007" t="ryanbrush @noprompt: Yeah, that error message is pretty bad; we need to share something better there. As for the problem itself, accumulators can only accumulate over simple fact-based expressions rather than everything in a complex expression. So rather than having the [:or ] &quot;inside&quot; the accumulator, you&apos;d need to accumulate over each of X1, X2, and X3 independently."><y>#</y><d>2015-11-13</d><h>21:15</h><w>ryanbrush</w>@noprompt:  Yeah, that error message is pretty bad; we need to share something better there. As for the problem itself, accumulators can only accumulate over simple fact-based expressions rather than everything in a complex expression. So rather than having the [:or ] &quot;inside&quot; the accumulator, you&apos;d need to accumulate over each of X1, X2, and X3 independently.</z><z id="t1447449631000008" t="ryanbrush There might be other ways to break down the problem depending on what you&apos;re trying to accomplish. For instance, if X1, X2, and X3 are children of a super type, you can match on the super type. Clara just uses Clojure&apos;s type system by default, which also works with Java&apos;s type hierarchy and obeys clojure.core/derive if you want to use that to logically derive new types."><y>#</y><d>2015-11-13</d><h>21:20</h><w>ryanbrush</w>There might be other ways to break down the problem depending on what you&apos;re trying to accomplish. For instance, if X1, X2, and X3 are children of a super type, you can match on the super type.  Clara just uses Clojure&apos;s type system by default, which also works with Java&apos;s type hierarchy and obeys clojure.core/derive if you want to use that to logically derive new types.</z><z id="t1447449935000009" t="noprompt here&apos;s what we came up with:"><y>#</y><d>2015-11-13</d><h>21:25</h><w>noprompt</w>here&apos;s what we came up with:</z><z id="t1447449936000010" t="noprompt [?it &lt;- [:or [?x1 &lt;- accumulator :from [X1 (= ?v x)]] [?x2 &lt;- accumulator :from [X2 (= ?v x)]] [?x3 &lt;- accumulator :from [X3 (= ?v x)]]]]"><y>#</y><d>2015-11-13</d><h>21:25</h><w>noprompt</w><pre>[?it &lt;-
 [:or
  [?x1 &lt;- accumulator :from
   [X1 (= ?v x)]]

  [?x2 &lt;- accumulator :from
   [X2 (= ?v x)]]

  [?x3 &lt;- accumulator :from
   [X3 (= ?v x)]]]]</pre></z><z id="t1447449987000012" t="noprompt @ryanbrush: you mentioned derive can you explain how that would work? afaik it only works with namespaced keywords."><y>#</y><d>2015-11-13</d><h>21:26</h><w>noprompt</w>@ryanbrush: you mentioned <code>derive</code> can you explain how that would work? afaik it only works with namespaced keywords.</z><z id="t1447450213000013" t="ryanbrush Sure. Some users are just using Clojure maps as their fact types and tagging type metadata to them in the form of namespaced keywords, where derive will work."><y>#</y><d>2015-11-13</d><h>21:30</h><w>ryanbrush</w>Sure. Some users are just using Clojure maps as their fact types and tagging type metadata to them in the form of namespaced keywords, where derive will work.</z><z id="t1447450296000014" t="ryanbrush I think the child in derive can also be an arbitrary record type...it&apos;s the parent that needs to be a namespaced keyword. This might be an abuse of the intent of derive, though."><y>#</y><d>2015-11-13</d><h>21:31</h><w>ryanbrush</w>I think the child in derive can also be an arbitrary record type...it&apos;s the parent that needs to be a namespaced keyword. This might be an abuse of the intent of derive, though.</z><z id="t1447450370000015" t="ryanbrush As for the model you came up with: I&apos;m actually not sure that will work...or at least I don&apos;t have a test covering binding to the result of an :or expression and that isn&apos;t something we&apos;ve done in production."><y>#</y><d>2015-11-13</d><h>21:32</h><w>ryanbrush</w>As for the model you came up with: I&apos;m actually not sure that will work...or at least I don&apos;t have a test covering binding to the result of an :or expression and that isn&apos;t something we&apos;ve done in production.</z><z id="t1447450413000016" t="noprompt right. we&apos;re using records and unfortunately that does not work with derive (e.g. (derive Square Shape) )."><y>#</y><d>2015-11-13</d><h>21:33</h><w>noprompt</w>right. we&apos;re using records and unfortunately that does not work with <code>derive</code> (e.g. <code>(derive Square Shape)</code>).</z><z id="t1447450418000017" t="ryanbrush Another approach would be to break up the accumulators into separate rules, each of which insert some &quot;GroupOfX&quot; type that can be joined to in another rule that combines them all."><y>#</y><d>2015-11-13</d><h>21:33</h><w>ryanbrush</w>Another approach would be to break up the accumulators into separate rules, each of which insert some &quot;GroupOfX&quot; type that can be joined to in another rule that combines them all.</z><z id="t1447450456000018" t="noprompt oh i see what you&apos;re saying wrt derive ."><y>#</y><d>2015-11-13</d><h>21:34</h><w>noprompt</w>oh i see what you&apos;re saying wrt <code>derive</code>.</z><z id="t1447450494000019" t="noprompt re: your uncertainty. well we&apos;ll kick the tires for you and let you know if it does work. 😄"><y>#</y><d>2015-11-13</d><h>21:34</h><w>noprompt</w>re: your uncertainty. well we&apos;ll kick the tires for you and let you know if it does work. <b>😄</b></z><z id="t1447450682000021" t="ryanbrush I know the above approach will work."><y>#</y><d>2015-11-13</d><h>21:38</h><w>ryanbrush</w>I know the above approach will work.</z><z id="t1447450735000022" t="noprompt okay, we&apos;ll do that if this turns up dry."><y>#</y><d>2015-11-13</d><h>21:38</h><w>noprompt</w>okay, we&apos;ll do that if this turns up dry.</z><z id="t1447450863000023" t="ryanbrush I&apos;m almost certain that you won&apos;t be able to bind the result of an &quot;:or&quot;, so I think the post above is your best bet. The Rete algorithm splits up the or&apos;s into separate rule invocations, and there aren&apos;t well-defined semantics for binding the result of other boolean operators in general. But merging the results of separate accumulators will work and is something we do frequently."><y>#</y><d>2015-11-13</d><h>21:41</h><w>ryanbrush</w>I&apos;m almost certain that you won&apos;t be able to bind the result of an &quot;:or&quot;, so I think the post above is your best bet. The Rete algorithm splits up the or&apos;s into separate rule invocations, and there aren&apos;t well-defined semantics for binding the result of other boolean operators in general.  But merging the results of separate accumulators will work and is something we do frequently.</z><z id="t1447451005000024" t="ryanbrush By the way, please do report bad or misleading error messages, here or on the github project. I think this is a weak point in Clara right now, especially for new users, so we want to make that better."><y>#</y><d>2015-11-13</d><h>21:43</h><w>ryanbrush</w>By the way, please do report bad or misleading error messages, here or on the github project. I think this is a weak point in Clara right now, especially for new users, so we want to make that better.</z><z id="t1447454136000025" t="noprompt @ryanbrush: re: error messages, we&apos;re investing in clara so hopefully you can expect more than just an experience report. simple_smile"><y>#</y><d>2015-11-13</d><h>22:35</h><w>noprompt</w>@ryanbrush: re: error messages, we&apos;re investing in clara so hopefully you can expect more than just an experience report. <b>simple_smile</b></z><z id="t1447454194000026" t="noprompt we focus a lot on producing good error messages at work and use ex-info to not only provide a description but, where possible, provide a prescription to solve the problem."><y>#</y><d>2015-11-13</d><h>22:36</h><w>noprompt</w>we focus a lot on producing good error messages at work and use <code>ex-info</code> to not only provide a description but, where possible, provide a prescription to solve the problem.</z><z id="t1447455042000027" t="ryanbrush Sounds great! And I definitely agree with the idea of good, prescriptive error messages. This can be challenging when dealing with the kind of deep macros, like what Clara does when building the Rete network, but is an important step forward."><y>#</y><d>2015-11-13</d><h>22:50</h><w>ryanbrush</w>Sounds great! And I definitely agree with the idea of good, prescriptive error messages. This can be challenging when dealing with the kind of deep macros, like what Clara does when building the Rete network, but is an important step forward.</z><z id="t1447455200000028" t="ryanbrush By the way, I&apos;m planning on moving Clara to its own GitHub project organization and add at least one more committer soon, a colleague who has made some nice pull requests. It shouldn&apos;t be too disruptive, but I&apos;ll be sure to share here when that happens."><y>#</y><d>2015-11-13</d><h>22:53</h><w>ryanbrush</w>By the way, I&apos;m planning on moving Clara to its own GitHub project organization and add at least one more committer soon, a colleague who has made some nice pull requests. It shouldn&apos;t be too disruptive, but I&apos;ll be sure to share here when that happens.</z><z id="t1447520728000029" t="ryanbrush I had some fun playing with Instaparse and Clara recently, so I blogged about it: http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/"><y>#</y><d>2015-11-14</d><h>17:05</h><w>ryanbrush</w>I had some fun playing with Instaparse and Clara recently, so I blogged about it: <a href="http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/" target="_blank">http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/</a></z><z id="t1447615053000031" t="devn What do y&apos;all think about meeting up on Monday night after dinner?"><y>#</y><d>2015-11-15</d><h>19:17</h><w>devn</w>What do y&apos;all think about meeting up on Monday night after dinner?</z><z id="t1447615063000032" t="devn @ryanbrush: very cool"><y>#</y><d>2015-11-15</d><h>19:17</h><w>devn</w>@ryanbrush: very cool</z><z id="t1447674030000033" t="thomas @ryanbrush: read your blog post. really good. thank you."><y>#</y><d>2015-11-16</d><h>11:40</h><w>thomas</w>@ryanbrush:  read your blog post. really good. thank you.</z><z id="t1447683531000034" t="ryanbrush @thomas Thanks! It was a lot of fun to write. I appreciate the kind words!"><y>#</y><d>2015-11-16</d><h>14:18</h><w>ryanbrush</w>@thomas Thanks! It was a lot of fun to write. I appreciate the kind words!</z><z id="t1448372023000040" t="ragge hello"><y>#</y><d>2015-11-24</d><h>13:33</h><w>ragge</w>hello</z><z id="t1448372068000041" t="ragge @ryanbrush: are there any guidelines/limits for the number of facts?"><y>#</y><d>2015-11-24</d><h>13:34</h><w>ragge</w>@ryanbrush: are there any guidelines/limits for the number of facts?</z><z id="t1448376008000042" t="ryanbrush @ragge Not really, besides the limits of the JVM. We frequently have 100,000+ facts in our sessions, and I&apos;ve tested into the millions (although for a limited scenario). Most of the work is done in Clojure group-by and reducer functions, which scale well."><y>#</y><d>2015-11-24</d><h>14:40</h><w>ryanbrush</w>@ragge Not really, besides the limits of the JVM. We frequently have 100,000+ facts in our sessions, and I&apos;ve tested into the millions (although for a limited scenario). Most of the work is done in Clojure group-by and reducer functions, which scale well.</z><z id="t1448376186000043" t="ryanbrush @ragge The only thing to keep in mind is doing a non-equality cartesian join over lots of facts. Rule constraints that join on equals use hash-based joins, which scale well. This constraint applies pretty commonly to rule engines."><y>#</y><d>2015-11-24</d><h>14:43</h><w>ryanbrush</w>@ragge The only thing to keep in mind is doing a non-equality cartesian join over lots of facts. Rule constraints that join on equals use hash-based joins, which scale well.  This constraint applies pretty commonly to rule engines.</z><z id="t1448382083000044" t="ragge @ryanbrush: thanks for your reply, will definitely give it a go for our use case (which is currently around 50k facts)"><y>#</y><d>2015-11-24</d><h>16:21</h><w>ragge</w>@ryanbrush: thanks for your reply, will definitely give it a go for our use case (which is currently around 50k facts)</z><z id="t1448383955000045" t="ryanbrush @ragge Sounds good. Clara&apos;s performance should at least be competitive with other JVM-based rule engines and is working well with a large number of facts for us. If you do run into a workload that isn&apos;t doing well, please let me know."><y>#</y><d>2015-11-24</d><h>16:52</h><w>ryanbrush</w>@ragge Sounds good. Clara&apos;s performance should at least be competitive with other JVM-based rule engines and is working well with a large number of facts for us. If you do run into a workload that isn&apos;t doing well, please let me know.</z><z id="t1448385817000046" t="albaker is there a performance measurement of Clara?"><y>#</y><d>2015-11-24</d><h>17:23</h><w>albaker</w>is there a performance measurement of Clara?</z><z id="t1448385849000047" t="albaker or guidelines, like how much memory you should budget for number of facts/rules?"><y>#</y><d>2015-11-24</d><h>17:24</h><w>albaker</w>or guidelines, like how much memory you should budget for number of facts/rules?</z><z id="t1448399753000048" t="ryanbrush @albaker I use Criterium ( https://github.com/hugoduncan/criterium ) against a function that loads and exercises our Clara rulesets to measure performance. I did post the program I wrote some time ago to benchmark Clara itself at https://github.com/rbrush/clara-benchmark , but generally its easier just to write your own test function and use Criterium to measure."><y>#</y><d>2015-11-24</d><h>21:15</h><w>ryanbrush</w>@albaker I use Criterium (<a href="https://github.com/hugoduncan/criterium" target="_blank">https://github.com/hugoduncan/criterium</a>) against a function that loads and exercises our Clara rulesets to measure performance.  I did post the program I wrote some time ago to benchmark Clara itself at <a href="https://github.com/rbrush/clara-benchmark" target="_blank">https://github.com/rbrush/clara-benchmark</a>, but generally its easier just to write your own test function and use Criterium to measure.</z><z id="t1448399901000050" t="ryanbrush @albaker Some considerations for a memory budget: each condition on a rule will compile into its own function, and identical conditions between rules are reused, reducing the overall size. The facts are mostly just stored in Clojure sequences, or maps grouped by fact type. In general, the memory footprint will be dominated by the size of the facts you have."><y>#</y><d>2015-11-24</d><h>21:18</h><w>ryanbrush</w>@albaker Some considerations for a memory budget: each condition on a rule will compile into its own function, and identical conditions between rules are reused, reducing the overall size. The facts are mostly just stored in Clojure sequences, or maps grouped by fact type. In general, the memory footprint will be dominated by the size of the facts you have.</z><z id="t1448400007000051" t="ryanbrush I think the best way to think of it as you&apos;re just writing Clojure functions and creating Clojure structures. Clara will wire things together, but the footprint is generally a function of the size of your data."><y>#</y><d>2015-11-24</d><h>21:20</h><w>ryanbrush</w>I think the best way to think of it as you&apos;re just writing Clojure functions and creating Clojure structures. Clara will wire things together, but the footprint is generally a function of the size of your data.</z><z id="t1448407713000052" t="albaker Cool, thanks! "><y>#</y><d>2015-11-24</d><h>23:28</h><w>albaker</w>Cool, thanks! </z><z id="t1448467875000053" t="ryanbrush FYI, I just pushed Clara 0.9.1 to Clojars. It&apos;s a fix release for a specific scenario, but worth the upgrade. https://groups.google.com/forum/#!topic/clara-rules/dWLm9veo-dA"><y>#</y><d>2015-11-25</d><h>16:11</h><w>ryanbrush</w>FYI, I just pushed Clara 0.9.1 to Clojars. It&apos;s a fix release for a specific scenario, but worth the upgrade. <a href="https://groups.google.com/forum/#!topic/clara-rules/dWLm9veo-dA" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/dWLm9veo-dA</a></z><z id="t1448906113000054" t="devn @ryanbrush: Is it possible to use [:or [?foo &lt;- my/accumulator [X (= a 1)]] [?bar &lt;- my/accumulator [Y (= b 2)]]]"><y>#</y><d>2015-11-30</d><h>17:55</h><w>devn</w>@ryanbrush: Is it possible to use <code>[:or [?foo &lt;- my/accumulator [X (= a 1)]] [?bar &lt;- my/accumulator [Y (= b 2)]]]</code></z><z id="t1448906655000055" t="devn @ryanbrush: here&apos;s a sketch of what we imagine: (defrule thing-a [?foo &lt;- [:or [my/accumulator [Foo (= a 1)]] [:not [Foo (= a 1)]]]] =&gt; (when-not (nil? ?foo) (insert! (map-&gt;Bar ?foo)))) "><y>#</y><d>2015-11-30</d><h>18:04</h><w>devn</w>@ryanbrush: here&apos;s a sketch of what we imagine:
<pre>(defrule thing-a
  [?foo &lt;- [:or
            [my/accumulator [Foo (= a 1)]]
            [:not [Foo (= a 1)]]]]
  =&gt;
  (when-not (nil? ?foo)
    (insert! (map-&gt;Bar ?foo))))
</pre></z><z id="t1448906690000056" t="devn We want Foo to be optional, but when it exists, we&apos;d like to accumulate over matching Foo facts."><y>#</y><d>2015-11-30</d><h>18:04</h><w>devn</w>We want Foo to be optional, but when it exists, we&apos;d like to accumulate over matching Foo facts.</z><z id="t1448906816000057" t="ryanbrush The best way to solve this problem is to have my/accumulator provide a default value. That way if there are no Foo records, the default value will be returned from the accumulator and propagate down."><y>#</y><d>2015-11-30</d><h>18:06</h><w>ryanbrush</w>The best way to solve this problem is to have my/accumulator provide a default value. That way if there are no Foo records, the default value will be returned from the accumulator and propagate down.</z><z id="t1448906845000058" t="ryanbrush For instance, the provided sum accumulator will return a sum of zero if there are no items to sum."><y>#</y><d>2015-11-30</d><h>18:07</h><w>ryanbrush</w>For instance, the provided sum accumulator will return a sum of zero if there are no items to sum.</z><z id="t1448906877000059" t="devn Funnily enough, we talked about that a bit."><y>#</y><d>2015-11-30</d><h>18:07</h><w>devn</w>Funnily enough, we talked about that a bit.</z><z id="t1448906948000060" t="ryanbrush As a side note, you can&apos;t quite think of [:or]&apos;s in rules quite like you&apos;d think of or expressions in Clojure. [:or ..] doesn&apos;t &quot;return&quot; a value that can be bound to. (In fact, in the Rete algorithm [:or] actually causes two separate rules to be generated for each branch.)"><y>#</y><d>2015-11-30</d><h>18:09</h><w>ryanbrush</w>As a side note, you can&apos;t quite think of [:or]&apos;s in rules quite like you&apos;d think of or expressions in Clojure. [:or ..] doesn&apos;t &quot;return&quot; a value that can be bound to. (In fact, in the Rete algorithm [:or] actually causes two separate rules to be generated for each branch.)</z><z id="t1448907066000061" t="devn @ryanbrush: thanks!"><y>#</y><d>2015-11-30</d><h>18:11</h><w>devn</w>@ryanbrush: thanks!</z><z id="t1448907338000062" t="ryanbrush @devn By the way, when fiddling with this I noticed Clara isn&apos;t reporting an error if a user attempts to bind a variable in an unsupported location. This is a bug, so I logged it here https://github.com/rbrush/clara-rules/issues/144"><y>#</y><d>2015-11-30</d><h>18:15</h><w>ryanbrush</w>@devn By the way, when fiddling with this I noticed Clara isn&apos;t reporting an error if a user attempts to bind a variable in an unsupported location. This is a bug, so I logged it here <a href="https://github.com/rbrush/clara-rules/issues/144" target="_blank">https://github.com/rbrush/clara-rules/issues/144</a></z><z id="t1448911763000064" t="devn @ryanbrush: that is good to know, indeed"><y>#</y><d>2015-11-30</d><h>19:29</h><w>devn</w>@ryanbrush: that is good to know, indeed</z><z id="t1448911819000065" t="devn @ryanbrush: trying to be respectful of your time here, but another question: with accumulators, can I make a function which produces an accumulator and use that in the LHS?"><y>#</y><d>2015-11-30</d><h>19:30</h><w>devn</w>@ryanbrush: trying to be respectful of your time here, but another question: with accumulators, can I make a function which produces an accumulator and use that in the LHS?</z><z id="t1448911939000066" t="devn like [Bar (= ?x x)] [?foo &lt;- (make-accumulator ?x) :from [Foo (= ?y y]] "><y>#</y><d>2015-11-30</d><h>19:32</h><w>devn</w>like
<pre>[Bar (= ?x x)]
[?foo &lt;- (make-accumulator ?x) :from [Foo (= ?y y]]
</pre></z><z id="t1448911970000067" t="devn this basically comes down to wanting to tweak the initial value to the accumulator"><y>#</y><d>2015-11-30</d><h>19:32</h><w>devn</w>this basically comes down to wanting to tweak the initial value to the accumulator</z><z id="t1448912248000068" t="ryanbrush @devn Definitely! The accumulators in clara.rules.accumulators are all just functions that return accumulators and should be a good reference. They use constants for the initial value but you can easily pass it as a param."><y>#</y><d>2015-11-30</d><h>19:37</h><w>ryanbrush</w>@devn Definitely! The accumulators in clara.rules.accumulators are all just functions that return accumulators and should be a good reference. They use constants for the initial value but you can easily pass it as a param.</z><z id="t1448912250000069" t="devn asking because all of the examples i&apos;ve seen are def&apos;d and only took the field to compare on"><y>#</y><d>2015-11-30</d><h>19:37</h><w>devn</w>asking because all of the examples i&apos;ve seen are def&apos;d and only took the field to compare on</z><z id="t1448912285000070" t="devn cool, guess I could have tried it, but didn&apos;t know calling a function in place of a def&apos;d accumulator had any edges i needed to be aware of"><y>#</y><d>2015-11-30</d><h>19:38</h><w>devn</w>cool, guess I could have tried it, but didn&apos;t know calling a function in place of a def&apos;d accumulator had any edges i needed to be aware of</z><z id="t1448912318000071" t="ryanbrush Any function that returns an accumulator will work. The provided ones just happen to use fields."><y>#</y><d>2015-11-30</d><h>19:38</h><w>ryanbrush</w>Any function that returns an accumulator will work. The provided ones just happen to use fields.</z><z id="t1448912832000072" t="devn @ryanbrush: a couple other small bits - Any reason that things like min/max couldn&apos;t optionally take a function to coerce the value of a field to be comparable? For instance, dates. - Using reduce-to-accum seems to imply :supports-retract given that min , max etc. call comparison-based , which in turn calls reduce-to-accum with an initial value of nil . Is that true? I remember reading the pull request a couple of times, but are there any good rules of thumb to use when building accumulators to know that you&apos;ve supported retraction? Now that I write that out, my other question is: When retract is mentioned, is it talking about automatic retraction, explicit retraction, or both?"><y>#</y><d>2015-11-30</d><h>19:47</h><w>devn</w>@ryanbrush: a couple other small bits

- Any reason that things like min/max couldn&apos;t optionally take a function to coerce the value of a field to be comparable? For instance, dates.
- Using <code>reduce-to-accum</code> seems to imply <code>:supports-retract</code> given that <code>min</code>, <code>max</code> etc. call <code>comparison-based</code>, which in turn calls <code>reduce-to-accum</code> with an initial value of <code>nil</code>. Is that true? I remember reading the pull request a couple of times, but are there any good rules of thumb to use when building accumulators to know that you&apos;ve supported retraction? Now that I write that out, my other question is: When <code>retract</code> is mentioned, is it talking about automatic retraction, explicit retraction, or both?</z><z id="t1448913301000075" t="ryanbrush As long as your accumulator has a retract-fn, it supports retraction. reduce-to-accum is a convenience function that makes it easier to turn general reduce functions into accumulators by (by default) creating a retract-fn that removes the retracted item from the accumulator and re-runs the reduce. In some cases you can create more efficient retract-fn implementations. See, for instance, sum...to retract a value from a sum you can just subtract the value, which is of course more efficient than re-running the entire sum with the value removed."><y>#</y><d>2015-11-30</d><h>19:55</h><w>ryanbrush</w>As long as your accumulator has a retract-fn, it supports retraction. reduce-to-accum is a convenience function that makes it easier to turn general reduce functions into accumulators by (by default) creating a retract-fn that removes the retracted item from the accumulator and re-runs the reduce. In some cases you can create more efficient retract-fn implementations. See, for instance, sum...to retract a value from a sum you can just subtract the value, which is of course more efficient than re-running the entire sum with the value removed.</z><z id="t1448913317000076" t="ryanbrush This applies to both automatic and explicit retraction."><y>#</y><d>2015-11-30</d><h>19:55</h><w>ryanbrush</w>This applies to both automatic and explicit retraction.</z><z id="t1448913462000077" t="ryanbrush Really the retract-fn is just to &quot;undo&quot; the presence of an item in the accumulated value, like subtraction undoes the value in a sum. the reduce-to-accum just offers a &quot;brute force&quot; way to do this for all reduce functions by re-running them. In some very performance-sensitive cases where you don&apos;t care about retraction you can skip supporting it, but I wouldn&apos;t do so unless you have a special need."><y>#</y><d>2015-11-30</d><h>19:57</h><w>ryanbrush</w>Really the retract-fn is just to &quot;undo&quot; the presence of an item in the accumulated value, like subtraction undoes the value in a sum. the reduce-to-accum just offers a &quot;brute force&quot; way to do this for all reduce functions by re-running them. In some very performance-sensitive cases where you don&apos;t care about retraction you can skip supporting it, but I wouldn&apos;t do so unless you have a special need.</z><z id="t1448913599000078" t="ryanbrush FWIW, Clara accumulators work pretty much exactly like the same concept in Jess and Drools. You just write the functions in Clojure. 😉"><y>#</y><d>2015-11-30</d><h>19:59</h><w>ryanbrush</w>FWIW, Clara accumulators work pretty much exactly like the same concept in Jess and Drools. You just write the functions in Clojure. <b>😉</b></z><z id="t1448913616000079" t="ryanbrush (Also, I need to drop offline for a bit but will be back on later today.)"><y>#</y><d>2015-11-30</d><h>20:00</h><w>ryanbrush</w>(Also, I need to drop offline for a bit but will be back on later today.)</z><z id="t1448914185000080" t="devn @ryanbrush: that&apos;s a lovely explanation, thank you!"><y>#</y><d>2015-11-30</d><h>20:09</h><w>devn</w>@ryanbrush: that&apos;s a lovely explanation, thank you!</z><z id="t1448914191000081" t="devn @logbot"><y>#</y><d>2015-11-30</d><h>20:09</h><w>devn</w>@logbot</z><z id="t1448914247000082" t="devn (mentioned the @logbot so there&apos;s actually a log of some of this stuff, it scans every 2 hours, so it should join shortly.)"><y>#</y><d>2015-11-30</d><h>20:10</h><w>devn</w>(mentioned the @logbot so there&apos;s actually a log of some of this stuff, it scans every 2 hours, so it should join shortly.)</z><z id="t1448944861000087" t="ryanbrush Working on some updates that should make clara-tools more useful. (I think at least @devn will be interested in this.) Details here: https://groups.google.com/forum/#!topic/clara-rules/w1GDmxLE_Vo"><y>#</y><d>2015-12-01</d><h>04:41</h><w>ryanbrush</w>Working on some updates that should make clara-tools more useful. (I think at least @devn will be interested in this.) Details here:  <a href="https://groups.google.com/forum/#!topic/clara-rules/w1GDmxLE_Vo" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/w1GDmxLE_Vo</a></z><z id="t1448990304000090" t="devn @ryanbrush: That&apos;s awesome!"><y>#</y><d>2015-12-01</d><h>17:18</h><w>devn</w>@ryanbrush: That&apos;s awesome!</z><z id="t1448990607000091" t="devn @ryanbrush: It would be neat to be able to &quot;step&quot; through a session. I&apos;m not really sure how doable that would be, or if it&apos;d be crazy for large sets of facts, but since you mentioned Bret Victor -- I imagined the Braid example. Being able to step through time and &quot;see&quot; rules fire would be cool."><y>#</y><d>2015-12-01</d><h>17:23</h><w>devn</w>@ryanbrush: It would be neat to be able to &quot;step&quot; through a session. I&apos;m not really sure how doable that would be, or if it&apos;d be crazy for large sets of facts, but since you mentioned Bret Victor -- I imagined the Braid example. Being able to step through time and &quot;see&quot; rules fire would be cool.</z><z id="t1448990795000093" t="devn I&apos;m imagining something like the current show-session tool, but with some sort of temporally inspectable aspect to it."><y>#</y><d>2015-12-01</d><h>17:26</h><w>devn</w>I&apos;m imagining something like the current <code>show-session</code> tool, but with some sort of temporally inspectable aspect to it.</z><z id="t1448990829000094" t="devn Whether that&apos;s a slider, or a split pane that shows what matches and when."><y>#</y><d>2015-12-01</d><h>17:27</h><w>devn</w>Whether that&apos;s a slider, or a split pane that shows what matches and when.</z><z id="t1448990850000095" t="devn Anyway, looking forward to giving it a look later today or tomorrow. Thanks for all of the awesome work!"><y>#</y><d>2015-12-01</d><h>17:27</h><w>devn</w>Anyway, looking forward to giving it a look later today or tomorrow. Thanks for all of the awesome work!</z><z id="t1448995004000096" t="ryanbrush @devn Interesting idea. Should be doable by plugging into listeners for state changes. Might be something to experiment with."><y>#</y><d>2015-12-01</d><h>18:36</h><w>ryanbrush</w>@devn Interesting idea. Should be doable by plugging into listeners for state changes. Might be something to experiment with.</z><z id="t1449022019000097" t="devn @ryanbrush: trying to check out clara-tools 0.1.2-SNAPSHOT from lein checkouts, but: 1. Caused by java.io.FileNotFoundException Could not locate org/httpkit/server__init.class or org/httpkit/server.clj on classpath. "><y>#</y><d>2015-12-02</d><h>02:06</h><w>devn</w>@ryanbrush: trying to check out clara-tools 0.1.2-SNAPSHOT from lein checkouts, but:
<pre>1. Caused by java.io.FileNotFoundException
   Could not locate org/httpkit/server__init.class or
   org/httpkit/server.clj on classpath.
</pre></z><z id="t1449022253000098" t="devn @ryanbrush: looks like there&apos;s just a missing require in clara.tools.impl.server =&gt; clojure.edn"><y>#</y><d>2015-12-02</d><h>02:10</h><w>devn</w>@ryanbrush: looks like there&apos;s just a missing require in <code>clara.tools.impl.server</code> =&gt; <code>clojure.edn</code></z><z id="t1449022932000099" t="devn PR submitted"><y>#</y><d>2015-12-02</d><h>02:22</h><w>devn</w>PR submitted</z><z id="t1449023908000100" t="ryanbrush @devn Ah, thanks for the PR. I&apos;ll be able to take a look and merge tomorrow."><y>#</y><d>2015-12-02</d><h>02:38</h><w>ryanbrush</w>@devn Ah, thanks for the PR. I&apos;ll be able to take a look and merge tomorrow.</z><z id="t1449023926000101" t="devn @ryanbrush: 👍"><y>#</y><d>2015-12-02</d><h>02:38</h><w>devn</w>@ryanbrush: <b>👍</b></z><z id="t1449705757000104" t="devn @ryanbrush: potentially stupid question -- but what&apos;s the best way to try out changes to clara-tools on the dev branch in my project?"><y>#</y><d>2015-12-10</d><h>00:02</h><w>devn</w>@ryanbrush: potentially stupid question -- but what&apos;s the best way to try out changes to clara-tools on the dev branch in my project?</z><z id="t1449705798000105" t="devn i was trying to use lein checkouts , but it is yelling at me for not having cljsbuild/compiler__init.class or cljsbuild/compiler.clj on the classpath"><y>#</y><d>2015-12-10</d><h>00:03</h><w>devn</w>i was trying to use lein <code>checkouts</code>, but it is yelling at me for not having cljsbuild/compiler__init.class or cljsbuild/compiler.clj on the classpath</z><z id="t1449706203000106" t="ryanbrush @devn I just run lein install in the clara-tools 0.2-Dev branch and point my consuming project at the snapshot version."><y>#</y><d>2015-12-10</d><h>00:10</h><w>ryanbrush</w>@devn I just run lein install in the clara-tools 0.2-Dev branch and point my consuming project at the snapshot version.</z><z id="t1449706433000107" t="devn @ryanbrush: well, that worked. thanks. i think that&apos;s what i wound up doing last time i had it working."><y>#</y><d>2015-12-10</d><h>00:13</h><w>devn</w>@ryanbrush: well, that worked. thanks. i think that&apos;s what i wound up doing last time i had it working.</z><z id="t1449706437000108" t="devn this is looking really great!"><y>#</y><d>2015-12-10</d><h>00:13</h><w>devn</w>this is looking really great!</z><z id="t1449706472000109" t="devn looks like you&apos;re tinkering with the logic graph at the moment, or im calling it wrong, not sure which simple_smile"><y>#</y><d>2015-12-10</d><h>00:14</h><w>devn</w>looks like you&apos;re tinkering with the logic graph at the moment, or im calling it wrong, not sure which <b>simple_smile</b></z><z id="t1449706529000110" t="ryanbrush @devn cool! It&apos;s still really rough, and the logic graph definitely needs work. I&apos;m going to start using it against some real data soon so it should improve."><y>#</y><d>2015-12-10</d><h>00:15</h><w>ryanbrush</w>@devn cool! It&apos;s still really rough, and the logic graph definitely needs work. I&apos;m going to start using it against some real data soon so it should improve.</z><z id="t1449706559000111" t="devn im getting a bunch of &quot;No reader function for tag object&quot; from readTagged(LispReader.java)"><y>#</y><d>2015-12-10</d><h>00:15</h><w>devn</w>im getting a bunch of &quot;No reader function for tag object&quot; from readTagged(LispReader.java)</z><z id="t1449706563000112" t="ryanbrush @devn I am also a terrible web developer who is learning Reagent as I go. ;)"><y>#</y><d>2015-12-10</d><h>00:16</h><w>ryanbrush</w>@devn I am also a terrible web developer who is learning Reagent as I go. ;)</z><z id="t1449706575000113" t="ryanbrush Hmm, haven&apos;t sent that one."><y>#</y><d>2015-12-10</d><h>00:16</h><w>ryanbrush</w>Hmm, haven&apos;t sent that one.</z><z id="t1449706594000114" t="ryanbrush Feel free to log issues if you have something reproducible"><y>#</y><d>2015-12-10</d><h>00:16</h><w>ryanbrush</w>Feel free to log issues if you have something reproducible</z><z id="t1449706739000115" t="devn @ryanbrush: looks like i&apos;m getting it for queries that return nothing and when clicking on facts that aren&apos;t actually within the session?"><y>#</y><d>2015-12-10</d><h>00:18</h><w>devn</w>@ryanbrush: looks like i&apos;m getting it for queries that return nothing and when clicking on facts that aren&apos;t actually within the session?</z><z id="t1449706763000116" t="devn just some first blush debugging, not sure if that&apos;s the case, just guessing"><y>#</y><d>2015-12-10</d><h>00:19</h><w>devn</w>just some first blush debugging, not sure if that&apos;s the case, just guessing</z><z id="t1449706870000117" t="devn I&apos;m probably not calling it the way you&apos;d expect... I just call (watch/browse!) after all rules have fired"><y>#</y><d>2015-12-10</d><h>00:21</h><w>devn</w>I&apos;m probably not calling it the way you&apos;d expect... I just call <code>(watch/browse!)</code> after all rules have fired</z><z id="t1449706961000118" t="devn (-&gt; (watch/mk-watched-session &quot;FOO&quot; rules :cache false) (insert-all facts) (fire-rules)) (watch/browse!) "><y>#</y><d>2015-12-10</d><h>00:22</h><w>devn</w><pre>(-&gt; (watch/mk-watched-session &quot;FOO&quot; rules :cache false)
    (insert-all facts)
    (fire-rules))

(watch/browse!)
</pre></z><z id="t1449744173000119" t="thomas Hi, just a quick question... are rules written in Clara Clojure functions? just a thought that crossed my mind."><y>#</y><d>2015-12-10</d><h>10:42</h><w>thomas</w>Hi, just a quick question... are rules written in Clara Clojure functions? just a thought that crossed my mind.</z><z id="t1449798265000120" t="ryanbrush @thomas Sort of. To elaborate a bit: The rules are forms, and the rule constraints and actions are just Clojure expressions. All of these get compiled down into Clojure functions in the end, which are executed as part of a Rete-style rule network. I have no idea if that&apos;s what you&apos;re looking for or not. 😉"><y>#</y><d>2015-12-11</d><h>01:44</h><w>ryanbrush</w>@thomas Sort of. To elaborate a bit: The rules are forms, and the rule constraints and actions are just Clojure expressions. All of these get compiled down into Clojure functions in the end, which are executed as part of a Rete-style rule network. I have no idea if that&apos;s what you&apos;re looking for or not. <b>😉</b></z><z id="t1449798380000121" t="ryanbrush @devn Not sure why that use wouldn&apos;t work. Facts that aren&apos;t in the session should be seen in the UI. I almost certainly have a bug in there somewhere. clara-tools will harden over the next few weeks but the current draft is very much use at your own risk (although bug reports and patches are of course welcome.)"><y>#</y><d>2015-12-11</d><h>01:46</h><w>ryanbrush</w>@devn Not sure why that use wouldn&apos;t work. Facts that aren&apos;t in the session should be seen in the UI. I almost certainly have a bug in there somewhere. clara-tools will harden over the next few weeks but the current draft is very much use at your own risk (although bug reports and patches are of course welcome.)</z><z id="t1449798456000122" t="ryanbrush By the way: Clara 0.9.2 is out: https://groups.google.com/forum/#!topic/clara-rules/kuy-XPUKzLU . It fixes an ugly edge case of truth maintenance and hopefully does a better job reporting errors in a number of scenarios."><y>#</y><d>2015-12-11</d><h>01:47</h><w>ryanbrush</w>By the way: Clara 0.9.2 is out: <a href="https://groups.google.com/forum/#!topic/clara-rules/kuy-XPUKzLU" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/kuy-XPUKzLU</a>.  It fixes an ugly edge case of truth maintenance and hopefully does a better job reporting errors in a number of scenarios.</z><z id="t1449823721000123" t="thomas @ryanbrush: reason for me asking is that I was wondering if Clara could be combined with Onyx and make it some sort of Rule/Event processing engine."><y>#</y><d>2015-12-11</d><h>08:48</h><w>thomas</w>@ryanbrush:  reason for me asking is that I was wondering if Clara could be combined with Onyx and make it some sort of Rule/Event processing engine.</z><z id="t1449846404000124" t="ryanbrush @thomas I don&apos;t know much about Onyx, but I&apos;m sure you could invoke Clara rules and queries from with in a function running within Onyx. The rule engine working memory would be local to that node, which in many cases is fine."><y>#</y><d>2015-12-11</d><h>15:06</h><w>ryanbrush</w>@thomas I don&apos;t know much about Onyx, but I&apos;m sure you could invoke Clara rules and queries from with in a function running within Onyx. The rule engine working memory would be local to that node, which in many cases is fine.</z><z id="t1449846513000125" t="ryanbrush @thomas Ultimately I&apos;d like to have an implementation of Clara&apos;s working memory that is distributed across a processing cluster, so you could just write rules to deal with input and emit outcomes. This is significantly more challenging. I had an experimental extension of Clara where the memory was distributed across a Storm cluster, but this effort was dropped due to other needs. The big challenge is fault tolerance of a distributed working memory. If a node becomes unavailable, how do we recover its part of the Rete network? I&apos;ve been toying with some solutions to this by mapping Clara&apos;s working memory onto existing fault tolerant processing patterns but this is little more than an idea right now."><y>#</y><d>2015-12-11</d><h>15:08</h><w>ryanbrush</w>@thomas Ultimately I&apos;d like to have an implementation of Clara&apos;s working memory that is distributed across a processing cluster, so you could just write rules to deal with input and emit outcomes. This is significantly more challenging. I had an experimental extension of Clara where the memory was distributed across a Storm cluster, but this effort was dropped due to other needs. The big challenge is fault tolerance of a distributed working memory. If a node becomes unavailable, how do we recover its part of the Rete network? I&apos;ve been toying with some solutions to this by mapping Clara&apos;s working memory onto existing fault tolerant processing patterns but this is little more than an idea right now.</z><z id="t1449846536000126" t="thomas @ryanbrush: ok thank you, this is something I would like to look into at some stage"><y>#</y><d>2015-12-11</d><h>15:08</h><w>thomas</w>@ryanbrush:  ok thank you, this is something I would like to look into at some stage</z><z id="t1449846540000127" t="thomas ie. read one day"><y>#</y><d>2015-12-11</d><h>15:09</h><w>thomas</w>ie. read one day</z><z id="t1449846768000128" t="ryanbrush @thomas Yes, me too!"><y>#</y><d>2015-12-11</d><h>15:12</h><w>ryanbrush</w>@thomas Yes, me too!</z><z id="t1449846838000129" t="ryanbrush @thomas Poking around Onyx a bit I think you could use Clara as a stateful aggregator of previously grouped data pretty easily, using Onyx&apos;s state management/windowing capabilities. So you could have a stream of data, inserting updates into a Clara working memory, and computing results like that. Could be useful to solve a number of problems."><y>#</y><d>2015-12-11</d><h>15:13</h><w>ryanbrush</w>@thomas Poking around Onyx a bit I think you could use Clara as a stateful aggregator of previously grouped data pretty easily, using Onyx&apos;s state management/windowing capabilities. So you could have a stream of data, inserting updates into a Clara working memory, and computing results like that. Could be useful to solve a number of problems.</z><z id="t1449846883000130" t="thomas I was wondering if something like that could be done... would be very cool."><y>#</y><d>2015-12-11</d><h>15:14</h><w>thomas</w>I was wondering if something like that could be done... would be very cool.</z><z id="t1449847115000131" t="ryanbrush @thomas Yeah, I haven&apos;t used Onyx but it seems doable from what I can see."><y>#</y><d>2015-12-11</d><h>15:18</h><w>ryanbrush</w>@thomas Yeah, I haven&apos;t used Onyx but it seems doable from what I can see.</z><z id="t1450058702000132" t="devn @ryanbrush: so, i suspect this might be considered out of scope for clara, but all the same: any thoughts on rule persistence/versioning? for instance, i might receive rules over the wire."><y>#</y><d>2015-12-14</d><h>02:05</h><w>devn</w>@ryanbrush: so, i suspect this might be considered out of scope for clara, but all the same: any thoughts on rule persistence/versioning? for instance, i might receive rules over the wire.</z><z id="t1450058741000133" t="devn if this is the case, I may need to for instance, make a function registry so functions within the LHS or RHS are resolvable when I read them in"><y>#</y><d>2015-12-14</d><h>02:05</h><w>devn</w>if this is the case, I may need to for instance, make a function registry so functions within the LHS or RHS are resolvable when I read them in</z><z id="t1450058827000134" t="devn is this something you or anyone else following along has dealt with? what&apos;d you choose as a method of versioning and mapping rule logic?"><y>#</y><d>2015-12-14</d><h>02:07</h><w>devn</w>is this something you or anyone else following along has dealt with? what&apos;d you choose as a method of versioning and mapping rule logic?</z><z id="t1450106088000135" t="ryanbrush @devn We just keep rules in source control and it let it handle versioning. I&apos;d imagine a variety of content management systems would be up to the task. As for a function registry, I just use fully-qualified function names from a library, and just have rules depend on a specific library version to use those functions. So not so much as a &quot;function registry&quot; as just using a versioned dependency JAR and qualified function names."><y>#</y><d>2015-12-14</d><h>15:14</h><w>ryanbrush</w>@devn We just keep rules in source control and it let it handle versioning. I&apos;d imagine a variety of content management systems would be up to the task. As for a function registry, I just use fully-qualified function names from a library, and just have rules depend on a specific library version to use those functions. So not so much as a &quot;function registry&quot; as just using a versioned dependency JAR and qualified function names.</z><z id="t1450106132000136" t="ryanbrush @devn Of course, a more sophisticated solution could be built, but I&apos;ve found just using source control and dependency management sufficient for our needs. And, as you know, Clara rules are just data structures that could be stored wherever convenient."><y>#</y><d>2015-12-14</d><h>15:15</h><w>ryanbrush</w>@devn Of course, a more sophisticated solution could be built, but I&apos;ve found just using source control and dependency management sufficient for our needs. And, as you know, Clara rules are just data structures that could be stored wherever convenient.</z><z id="t1450125440000137" t="xandrews any recommended reading on the subject of rules systems design?"><y>#</y><d>2015-12-14</d><h>20:37</h><w>xandrews</w>any recommended reading on the subject of rules systems design?</z><z id="t1450133009000138" t="devn @xandrews: I&apos;m going old school in my reading list"><y>#</y><d>2015-12-14</d><h>22:43</h><w>devn</w>@xandrews: I&apos;m going old school in my reading list</z><z id="t1450133069000139" t="devn I picked up Expert Systems - Design and Development by John Durkin"><y>#</y><d>2015-12-14</d><h>22:44</h><w>devn</w>I picked up Expert Systems - Design and Development by John Durkin</z><z id="t1450133083000140" t="devn Rule-based programming with OPS5, Programming Expert Systems in OPS5"><y>#</y><d>2015-12-14</d><h>22:44</h><w>devn</w>Rule-based programming with OPS5, Programming Expert Systems in OPS5</z><z id="t1450133143000141" t="devn As someone who&apos;s still quite the newb, I&apos;ve been learning from the simpler systems of the past like CLIPS and OPS5"><y>#</y><d>2015-12-14</d><h>22:45</h><w>devn</w>As someone who&apos;s still quite the newb, I&apos;ve been learning from the simpler systems of the past like CLIPS and OPS5</z><z id="t1450133319000142" t="devn There&apos;s another much more official looking book that I have not picked up"><y>#</y><d>2015-12-14</d><h>22:48</h><w>devn</w>There&apos;s another much more official looking book that I have not picked up</z><z id="t1450133496000143" t="devn Also: http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf"><y>#</y><d>2015-12-14</d><h>22:51</h><w>devn</w>Also: <a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank">http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</a></z><z id="t1450133504000144" t="devn and https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471"><y>#</y><d>2015-12-14</d><h>22:51</h><w>devn</w>and <a href="https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471" target="_blank">https://www.amazon.com/Expert-Systems-Principles-Programming-Edition/dp/0534384471</a></z><z id="t1450140291000146" t="devn @ryanbrush: Is there any way to reference elements of the rule itself, within the rule?"><y>#</y><d>2015-12-15</d><h>00:44</h><w>devn</w>@ryanbrush: Is there any way to reference elements of the rule itself, within the rule?</z><z id="t1450140332000147" t="devn @ryanbrush: for instance, it would be cool if I could bind $?name $?docstring or $?lhs"><y>#</y><d>2015-12-15</d><h>00:45</h><w>devn</w>@ryanbrush: for instance, it would be cool if I could bind $?name $?docstring or $?lhs</z><z id="t1450140391000148" t="devn So I could push forward some additional metadata about the rule which inserted a fact, for instance"><y>#</y><d>2015-12-15</d><h>00:46</h><w>devn</w>So I could push forward some additional metadata about the rule which inserted a fact, for instance</z><z id="t1450141897000149" t="ryanbrush @devn It&apos;s not in the public API, but the clara.rules.engine/rule-context dynamic var is populated when a rule is firing. So you could do something like (get-in clara.rules.engine/rule-context [:node :production]) , which would have :name and :doc properties."><y>#</y><d>2015-12-15</d><h>01:11</h><w>ryanbrush</w>@devn It&apos;s not in the public API, but the clara.rules.engine/rule-context dynamic var is populated when a rule is firing. So you could do something like (get-in clara.rules.engine/rule-context [:node :production]) , which would have :name and :doc properties.</z><z id="t1450141915000150" t="devn @ryanbrush: ah perfect"><y>#</y><d>2015-12-15</d><h>01:11</h><w>devn</w>@ryanbrush: ah perfect</z><z id="t1450141944000151" t="ryanbrush @devn It would be simple to add a (current-rule) function that just returns that to the public namespace as well. I can see how it would be useful."><y>#</y><d>2015-12-15</d><h>01:12</h><w>ryanbrush</w>@devn It would be simple to add a (current-rule) function that just returns that to the public namespace as well. I can see how it would be useful.</z><z id="t1450141975000152" t="devn Do defrules and queries allow meta on them when defining them?"><y>#</y><d>2015-12-15</d><h>01:12</h><w>devn</w>Do defrules and queries allow meta on them when defining them?</z><z id="t1450141990000153" t="devn like (defrule ^{:cool true} &quot;foo&quot; ... =&gt; ...)"><y>#</y><d>2015-12-15</d><h>01:13</h><w>devn</w>like <code>(defrule ^{:cool true} &quot;foo&quot; ... =&gt; ...)</code></z><z id="t1450142005000154" t="devn err forgot the name there"><y>#</y><d>2015-12-15</d><h>01:13</h><w>devn</w>err forgot the name there</z><z id="t1450142008000155" t="devn but you catch my drift"><y>#</y><d>2015-12-15</d><h>01:13</h><w>devn</w>but you catch my drift</z><z id="t1450142106000156" t="ryanbrush It doesn&apos;t use meta (but that would be add-able). This might be a good case for rule properties. You could do (defrule my-rule {:cool true} &quot;doc here&quot; ... =&gt; ...) This is how rule salience is set but you can put arbitrary properties there."><y>#</y><d>2015-12-15</d><h>01:15</h><w>ryanbrush</w>It doesn&apos;t use meta (but that would be add-able). This might be a good case for rule properties. You could do (defrule my-rule {:cool true} &quot;doc here&quot; ... =&gt; ...) This is how rule salience is set but you can put arbitrary properties there.</z><z id="t1450142123000157" t="ryanbrush See the salience example for the structure: http://www.clara-rules.org/docs/conflictsalience/"><y>#</y><d>2015-12-15</d><h>01:15</h><w>ryanbrush</w>See the salience example for the structure: <a href="http://www.clara-rules.org/docs/conflictsalience/" target="_blank">http://www.clara-rules.org/docs/conflictsalience/</a></z><z id="t1450142135000159" t="devn ah, just discovered that while reading the source"><y>#</y><d>2015-12-15</d><h>01:15</h><w>devn</w>ah, just discovered that while reading the source</z><z id="t1450142140000160" t="devn please excuse my laziness"><y>#</y><d>2015-12-15</d><h>01:15</h><w>devn</w>please excuse my laziness</z><z id="t1450142154000161" t="ryanbrush No worries."><y>#</y><d>2015-12-15</d><h>01:15</h><w>ryanbrush</w>No worries.</z><z id="t1450142207000162" t="devn I ran into a situation with salience and accumulators. I don&apos;t have a simple repro as it was a month ago or so now"><y>#</y><d>2015-12-15</d><h>01:16</h><w>devn</w>I ran into a situation with salience and accumulators. I don&apos;t have a simple repro as it was a month ago or so now</z><z id="t1450142284000163" t="devn it was a custom accumulator, so probably a good chance it was my fault"><y>#</y><d>2015-12-15</d><h>01:18</h><w>devn</w>it was a custom accumulator, so probably a good chance it was my fault</z><z id="t1450142301000164" t="devn but i was curious if you were generally aware of any problem that might exist when accumulating and using salience"><y>#</y><d>2015-12-15</d><h>01:18</h><w>devn</w>but i was curious if you were generally aware of any problem that might exist when accumulating and using salience</z><z id="t1450142357000165" t="ryanbrush @devn I&apos;m not aware of any issues with salience and accumulators, although we&apos;ve used both pretty extensively. If you are able to reproduce something we&apos;d definitely want to track it down."><y>#</y><d>2015-12-15</d><h>01:19</h><w>ryanbrush</w>@devn I&apos;m not aware of any issues with salience and accumulators, although we&apos;ve used both pretty extensively. If you are able to reproduce something we&apos;d definitely want to track it down.</z><z id="t1451016189000169" t="devn Is it possible to do something like this in Clara? Cheese( $chedddar : name == &quot;cheddar&quot; ) I find myself doing a lot of: [Foo (= ?x x) (= x &quot;bar&quot;)] Am I missing something, or is there a way to do both binding and equality in one go?"><y>#</y><d>2015-12-25</d><h>04:03</h><w>devn</w>Is it possible to do something like this in Clara?

<code>Cheese( $chedddar : name == &quot;cheddar&quot; )</code>

I find myself doing a lot of:
<pre>[Foo (= ?x x) (= x &quot;bar&quot;)]
</pre>

Am I missing something, or is there a way to do both binding and equality in one go?</z><z id="t1451016315000170" t="devn In general, I think a blurb about this would be a good documentation addition. [Foo (= 2 ?bar bar)] is different from [Foo (= ?bar bar 2)]"><y>#</y><d>2015-12-25</d><h>04:05</h><w>devn</w>In general, I think a blurb about this would be a good documentation addition. <code>[Foo (= 2 ?bar bar)]</code> is different from <code>[Foo (= ?bar bar 2)]</code></z><z id="t1451016340000171" t="devn And, the wiki documentation still references == in some places."><y>#</y><d>2015-12-25</d><h>04:05</h><w>devn</w>And, the wiki documentation still references <code>==</code> in some places.</z><z id="t1451016415000172" t="devn ./cc @ryanbrush -- also, happy holidays simple_smile"><y>#</y><d>2015-12-25</d><h>04:06</h><w>devn</w>./cc @ryanbrush -- also, happy holidays <b>simple_smile</b></z><z id="t1451416252000173" t="ryanbrush @devn Not a way to do that directly today, but it seems like a worthwhile change. Feel free to log something and I&apos;ll take a closer look when I get back from holiday travels."><y>#</y><d>2016-12-29</d><h>19:10</h><w>ryanbrush</w>@devn Not a way to do that directly today, but it seems like a worthwhile change. Feel free to log something and I&apos;ll take a closer look when I get back from holiday travels.</z><z id="t1451515995000174" t="devn @ryanbrush: question for you -- we have rules which are generated dynamically, and we were noticing that our runs with caching turned on were missing the cache. Turns out it was due to ordering."><y>#</y><d>2016-12-30</d><h>22:53</h><w>devn</w>@ryanbrush: question for you -- we have rules which are generated dynamically, and we were noticing that our runs with caching turned on were missing the cache. Turns out it was due to ordering.</z><z id="t1451516048000175" t="devn What do you think about using sets to check for cache hits?"><y>#</y><d>2016-12-30</d><h>22:54</h><w>devn</w>What do you think about using sets to check for cache hits?</z><z id="t1451516512000176" t="devn Honestly, this might be an instance of &quot;not clara&apos;s responsibility&quot; -- I think we&apos;re going to wind up managing our own cache using an LRU or TTL cache"><y>#</y><d>2016-12-30</d><h>23:01</h><w>devn</w>Honestly, this might be an instance of &quot;not clara&apos;s responsibility&quot; -- I think we&apos;re going to wind up managing our own cache using an LRU or TTL cache</z><z id="t1451516526000177" t="devn just curious what you thought -- took a bit of tinkering to figure it out"><y>#</y><d>2016-12-30</d><h>23:02</h><w>devn</w>just curious what you thought -- took a bit of tinkering to figure it out</z><z id="t1451516533000178" t="devn and I guess I don&apos;t see why it couldn&apos;t be a set"><y>#</y><d>2016-12-30</d><h>23:02</h><w>devn</w>and I guess I don&apos;t see why it couldn&apos;t be a set</z><z id="t1451516540000179" t="devn or coerced into one"><y>#</y><d>2016-12-30</d><h>23:02</h><w>devn</w>or coerced into one</z><z id="t1451516556000180" t="devn the generated source rules, i mean"><y>#</y><d>2016-12-30</d><h>23:02</h><w>devn</w>the generated source rules, i mean</z><z id="t1451516729000181" t="ryanbrush @devn I&apos;m open to the idea of using a set to improve cache hits. Come to think of it, if the code that generates rules produces a set (rather than a list) that is passed to mk-session, then that might actually trigger a cache hit by itself. We should be able to think of mk-session as a memoized function. If passing a set of rules into mk-session doesn&apos;t hit the cache then we could probably change that."><y>#</y><d>2016-12-30</d><h>23:05</h><w>ryanbrush</w>@devn I&apos;m open to the idea of using a set to improve cache hits. Come to think of it, if the code that generates rules produces a set (rather than a list) that is passed to mk-session, then that might actually trigger a cache hit by itself.  We should be able to think of mk-session as a memoized function. If passing a set of rules into mk-session doesn&apos;t hit the cache then we could probably change that.</z><z id="t1451516781000182" t="devn yes, making it a set makes it a cache hit"><y>#</y><d>2016-12-30</d><h>23:06</h><w>devn</w>yes, making it a set makes it a cache hit</z><z id="t1451516798000183" t="ryanbrush @devn However, managing your own cache might be a better idea, anyway, since putting all rules into a set (or doing a deep comparison in a sequence) could get expensive for a lot of rules. You could probably do something more efficient in user code if you know that things changed or didn&apos;t."><y>#</y><d>2016-12-30</d><h>23:06</h><w>ryanbrush</w>@devn However, managing your own cache might be a better idea, anyway, since putting all rules into a set (or doing a deep comparison in a sequence) could get expensive for a lot of rules. You could probably do something more efficient in user code if you know that things changed or didn&apos;t.</z><z id="t1451516910000184" t="devn i guess my thinking was that it was a little subtle why at first. i opened up yourkit to figure out what was slow, found myself in mk-session, beta and alpha creation, yadda yadda, noticed a lot of DynamicClassLoader business, saw a bunch of eval&apos;s which i believe are the generate LHS and RHS fns"><y>#</y><d>2016-12-30</d><h>23:08</h><w>devn</w>i guess my thinking was that it was a little subtle why at first. i opened up yourkit to figure out what was slow, found myself in mk-session, beta and alpha creation, yadda yadda, noticed a lot of DynamicClassLoader business, saw a bunch of eval&apos;s which i believe are the generate LHS and RHS fns</z><z id="t1451516962000185" t="devn finally noticed we were just getting cache misses, diff&apos;d the generated rules, noticed the order issue, yadda yadda"><y>#</y><d>2016-12-30</d><h>23:09</h><w>devn</w>finally noticed we were just getting cache misses, diff&apos;d the generated rules, noticed the order issue, yadda yadda</z><z id="t1451517033000186" t="devn i couldn&apos;t really think of a good reason why clara couldn&apos;t just make the decision to take whatever collection is passed to mk-session and make it a set, or if someone really wanted duplicates, (sort-by hash [...]) or something"><y>#</y><d>2016-12-30</d><h>23:10</h><w>devn</w>i couldn&apos;t really think of a good reason why clara couldn&apos;t just make the decision to take whatever collection is passed to mk-session and make it a set, or if someone really wanted duplicates, <code>(sort-by hash [...])</code> or something</z><z id="t1451517163000187" t="ryanbrush Yeah, that&apos;s fair. Just want to understand any performance implications there might be but I think we can do that."><y>#</y><d>2016-12-30</d><h>23:12</h><w>ryanbrush</w>Yeah, that&apos;s fair. Just want to understand any performance implications there might be but I think we can do that.</z><z id="t1451517180000188" t="devn for really large numbers of rules, for instance?"><y>#</y><d>2016-12-30</d><h>23:13</h><w>devn</w>for really large numbers of rules, for instance?</z><z id="t1451517544000189" t="devn @ryanbrush: One More Thing™ -- Do you have any thoughts on analyzing/visualizing the time-complexity of build-network provided a set of rules?"><y>#</y><d>2016-12-30</d><h>23:19</h><w>devn</w>@ryanbrush: One More Thing™ -- Do you have any thoughts on analyzing/visualizing the time-complexity of build-network provided a set of rules?</z><z id="t1451517690000190" t="devn General question is: How much does the design of the rules being added to a session effect the performance of build-network? For instance, a really shallow logic graph vs one with a lot of depth."><y>#</y><d>2016-12-30</d><h>23:21</h><w>devn</w>General question is: How much does the design of the rules being added to a session effect the performance of build-network? For instance, a really shallow logic graph vs one with a lot of depth.</z><z id="t1451517841000191" t="devn Wondering aloud if there&apos;s any potentially actionable information about the complexity of the network that would be useful to someone building an expert system."><y>#</y><d>2016-12-30</d><h>23:24</h><w>devn</w>Wondering aloud if there&apos;s any potentially actionable information about the complexity of the network that would be useful to someone building an expert system.</z><z id="t1451517896000192" t="devn &quot;your logic graph is really shallow, which means build-network is going to be slower&quot;"><y>#</y><d>2016-12-30</d><h>23:24</h><w>devn</w>&quot;your logic graph is really shallow, which means build-network is going to be slower&quot;</z><z id="t1451518194000193" t="ryanbrush @devn good question, but probably not one that I can answer on my mobile right now. ;) I&apos;ll post something more thoughtful when I get the chance."><y>#</y><d>2016-12-30</d><h>23:29</h><w>ryanbrush</w>@devn good question, but probably not one that I can answer on my mobile right now. ;) I&apos;ll post something more thoughtful when I get the chance.</z><z id="t1451518279000194" t="devn @ryanbrush: ha, no worries! @enn and I were working together today and I popped open Slack and realized I asked you a question about Clara at 10PM on Christmas Eve. You owe me nothing, and I&apos;m very grateful for all of your help."><y>#</y><d>2016-12-30</d><h>23:31</h><w>devn</w>@ryanbrush: ha, no worries! @enn and I were working together today and I popped open Slack and realized I asked you a question about Clara at 10PM on Christmas Eve. You owe me nothing, and I&apos;m very grateful for all of your help.</z><z id="t1452475398000197" t="datajohnny hello"><y>#</y><d>2016-01-11</d><h>01:23</h><w>datajohnny</w>hello</z><z id="t1452475437000198" t="datajohnny how can I make this just return the string to the caller? https://gist.github.com/datajohnny/a927c54a56f00035676e"><y>#</y><d>2016-01-11</d><h>01:23</h><w>datajohnny</w>how can I make this just return the string to the caller? <a href="https://gist.github.com/datajohnny/a927c54a56f00035676e" target="_blank">https://gist.github.com/datajohnny/a927c54a56f00035676e</a></z><z id="t1452516839000199" t="jthomson @datajohnny: my understanding is that the RHS of a clara rule should be side-effecting. Sometimes, the side effect will be updating the Clara session itself, via insert! and retract! . A common pattern for what you are trying to do would be to insert! a new fact on the RHS of your rule, then query the session for those facts after fire-rules ."><y>#</y><d>2016-01-11</d><h>12:53</h><w>jthomson</w>@datajohnny: my understanding is that the RHS of a clara rule should be side-effecting.  Sometimes, the side effect will be updating the Clara session itself, via <code>insert!</code> and <code>retract!</code>. A common pattern for what you are trying to do would be to <code>insert!</code> a new fact on the RHS of your rule, then <code>query</code> the session for those facts after <code>fire-rules</code>.</z><z id="t1452516861000200" t="jthomson you could follow one of the examples in the clara-examples project"><y>#</y><d>2016-01-11</d><h>12:54</h><w>jthomson</w>you could follow one of the examples in the <code>clara-examples</code> project</z><z id="t1452516865000201" t="jthomson https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/shopping.clj"><y>#</y><d>2016-01-11</d><h>12:54</h><w>jthomson</w><a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/shopping.clj" target="_blank">https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/shopping.clj</a></z><z id="t1452697352000204" t="datajohnny hello, I been fiddling around and im stuck at this right now: https://gist.github.com/datajohnny/3b82660ba27fd80f448c"><y>#</y><d>2016-01-13</d><h>15:02</h><w>datajohnny</w>hello, I been fiddling around and im stuck at this right now: <a href="https://gist.github.com/datajohnny/3b82660ba27fd80f448c" target="_blank">https://gist.github.com/datajohnny/3b82660ba27fd80f448c</a></z><z id="t1452698040000205" t="ragge (insert! (-&gt;Person)))"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w><code>(insert! (-&gt;Person)))</code></z><z id="t1452698050000206" t="ragge you&apos;re calling the positional constructor for Person"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w>you&apos;re calling the positional constructor for <code>Person</code></z><z id="t1452698060000207" t="ragge it requires two arguments, name and age"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w>it requires two arguments, name and age</z><z id="t1452698065000208" t="ragge you&apos;re only giving one"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w>you&apos;re only giving one</z><z id="t1452698074000209" t="ragge https://gist.github.com/datajohnny/3b82660ba27fd80f448c#file-gistfile1-txt-L29"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w><a href="https://gist.github.com/datajohnny/3b82660ba27fd80f448c#file-gistfile1-txt-L29" target="_blank">https://gist.github.com/datajohnny/3b82660ba27fd80f448c#file-gistfile1-txt-L29</a></z><z id="t1452698082000210" t="ragge Caused by: clojure.lang.ArityException: Wrong number of args (0) passed to: core/eval6101/-&gt;Person--6116"><y>#</y><d>2016-01-13</d><h>15:14</h><w>ragge</w><code>Caused by: clojure.lang.ArityException: Wrong number of args (0) passed to: core/eval6101/-&gt;Person--6116</code></z><z id="t1452698151000211" t="datajohnny @ragge: what I want is to add that record when the rule is true"><y>#</y><d>2016-01-13</d><h>15:15</h><w>datajohnny</w>@ragge: what I want is to add that record when the rule is true</z><z id="t1452698168000212" t="datajohnny I thought I was accomplishing that in that manner"><y>#</y><d>2016-01-13</d><h>15:16</h><w>datajohnny</w>I thought I was accomplishing that in that manner</z><z id="t1452698183000213" t="datajohnny do I need to pass the params in?"><y>#</y><d>2016-01-13</d><h>15:16</h><w>datajohnny</w>do I need to pass the params in?</z><z id="t1452698237000214" t="datajohnny another thing is that for some reason age the (&gt;= 21 age) is not working if I set the age on the session to 21"><y>#</y><d>2016-01-13</d><h>15:17</h><w>datajohnny</w>another thing is that for some reason age the <code>(&gt;= 21 age)</code> is not working if I set the age on the session to 21</z><z id="t1452700848000215" t="ryanbrush @datajohnny That test rule matches a person when the age is &gt;= 21, so it is only true if such a person has already been inserted. The right-hand side of the rule is just a Clojure s-expression that can insert additional facts derived from what matched. So typically you would insert the person (as that example does), match on age &gt;=21, and insert a new fact if that&apos;s the case (like a PersonIsAdult fact)."><y>#</y><d>2016-01-13</d><h>16:00</h><w>ryanbrush</w>@datajohnny That test rule matches a person when the age is &gt;= 21, so it is only true if such a person has already been inserted.  The right-hand side of the rule is just a Clojure s-expression that can insert additional facts derived from what matched. So typically you would insert the person (as that example does), match on age &gt;=21, and insert a new fact if that&apos;s the case (like a PersonIsAdult fact).</z><z id="t1452700867000216" t="ryanbrush @datajohnny: If you want to get an idea of general usage patterns, I&apos;d check out the examples at https://github.com/rbrush/clara-examples/tree/master/src/main/clojure/clara/examples"><y>#</y><d>2016-01-13</d><h>16:01</h><w>ryanbrush</w>@datajohnny: If you want to get an idea of general usage patterns, I&apos;d check out the examples at <a href="https://github.com/rbrush/clara-examples/tree/master/src/main/clojure/clara/examples" target="_blank">https://github.com/rbrush/clara-examples/tree/master/src/main/clojure/clara/examples</a></z><z id="t1452701056000218" t="datajohnny @ryanbrush: thanks"><y>#</y><d>2016-01-13</d><h>16:04</h><w>datajohnny</w>@ryanbrush: thanks</z><z id="t1452701207000219" t="ryanbrush @datajohnny: You bet!"><y>#</y><d>2016-01-13</d><h>16:06</h><w>ryanbrush</w>@datajohnny: You bet!</z><z id="t1452703766000220" t="datajohnny @ryanbrush: can the rules work with just maps instead of records, I am trying to build kinda like the same thing you had in your latest blog post but instead of grammar I am getting a json payload"><y>#</y><d>2016-01-13</d><h>16:49</h><w>datajohnny</w>@ryanbrush: can the rules work with just maps instead of records, I am trying to build kinda like the same thing you had in your latest blog post but instead of grammar I am getting a json payload</z><z id="t1452704200000221" t="ryanbrush @datajohnny: It can use records. You&apos;ll need to provide a function that returns a &quot;type&quot; for map you use, which will match the type of the rule. See the fact-type-fn at http://www.clara-rules.org/docs/expressions/#fact-expressions . There&apos;s also a unit test that shows some usage of it at https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1977 . The test generates rules in place but you can see a provided fact-type-fn that just reads a field from a record in action."><y>#</y><d>2016-01-13</d><h>16:56</h><w>ryanbrush</w>@datajohnny:  It can use records. You&apos;ll need to provide a function that returns a &quot;type&quot; for map you use, which will match the type of the rule. See the fact-type-fn at  <a href="http://www.clara-rules.org/docs/expressions/#fact-expressions" target="_blank">http://www.clara-rules.org/docs/expressions/#fact-expressions</a>. There&apos;s also a unit test that shows some usage of it at <a href="https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1977" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1977</a>. The test generates rules in place but you can see a provided fact-type-fn that just reads a field from a record in action.</z><z id="t1453403705000226" t="pguillebert Hello"><y>#</y><d>2016-01-21</d><h>19:15</h><w>pguillebert</w>Hello</z><z id="t1453403784000227" t="pguillebert I’m new to clara-rules and trying to model a rule with a “must not” condition"><y>#</y><d>2016-01-21</d><h>19:16</h><w>pguillebert</w>I’m new to clara-rules and trying to model a rule with a “must not” condition</z><z id="t1453403805000228" t="pguillebert like “do not trigger if there is this object present&quot;"><y>#</y><d>2016-01-21</d><h>19:16</h><w>pguillebert</w>like “do not trigger if there is this object present&quot;</z><z id="t1453403811000229" t="pguillebert is it doable ?"><y>#</y><d>2016-01-21</d><h>19:16</h><w>pguillebert</w>is it doable ?</z><z id="t1453411076000230" t="devn @pguillebert: sure, totally doable."><y>#</y><d>2016-01-21</d><h>21:17</h><w>devn</w>@pguillebert: sure, totally doable.</z><z id="t1453411481000231" t="devn @pguillebert: (defrecord Foo [a]) (defrecord Bar [b]) (defrecord Baz [b]) (defrule foo [:not [Foo]] [Bar (= ?b b 3)] =&gt; (insert! (-&gt;Baz ?b))) (defquery q:baz [] [?baz &lt;- Baz]) (-&gt; (mk-session [foo q:baz]) (insert-all [;; (-&gt;Foo 1) (-&gt;Bar 3)]) (fire-rules) (query q:baz)) ;; =&gt; ({:?baz #crede.rules.examples.Baz{:b 3}}) "><y>#</y><d>2016-01-21</d><h>21:24</h><w>devn</w>@pguillebert: 

<pre>(defrecord Foo [a])
(defrecord Bar [b])
(defrecord Baz [b])

(defrule foo
  [:not [Foo]]
  [Bar (= ?b b 3)]
  =&gt;
  (insert! (-&gt;Baz ?b)))

(defquery q:baz []
  [?baz &lt;- Baz])

(-&gt; (mk-session [foo q:baz])
    (insert-all [;; (-&gt;Foo 1)
                  (-&gt;Bar 3)])
    (fire-rules)
    (query q:baz))

;; =&gt; ({:?baz #crede.rules.examples.Baz{:b 3}})
</pre></z><z id="t1453411515000232" t="devn With the same setup, but including a Foo : (-&gt; (mk-session [foo q:baz]) (insert-all [(-&gt;Foo 1) (-&gt;Bar 3)]) (fire-rules) (query q:baz)) ;; =&gt; () "><y>#</y><d>2016-01-21</d><h>21:25</h><w>devn</w>With the same setup, but including a <code>Foo</code>:
<pre>(-&gt; (mk-session [foo q:baz])
    (insert-all [(-&gt;Foo 1)
                 (-&gt;Bar 3)])
    (fire-rules)
    (query q:baz))

;; =&gt; ()
</pre></z><z id="t1453411657000233" t="devn There is also [:exists [Foo]] , but I am not sure I understand the nuance there, though:"><y>#</y><d>2016-01-21</d><h>21:27</h><w>devn</w>There is also <code>[:exists [Foo]]</code>, but I am not sure I understand the nuance there, though:</z><z id="t1453411672000234" t="pguillebert ok, with :not"><y>#</y><d>2016-01-21</d><h>21:27</h><w>pguillebert</w>ok, with <code>:not</code></z><z id="t1453411682000235" t="devn (defrule foo [:exists [Foo]] [Bar (= ?b b 3)] =&gt; (insert! (-&gt;Baz ?b))) (defquery q:baz [] [?baz &lt;- Baz]) (-&gt; (mk-session [foo q:baz]) (insert-all [(-&gt;Foo 1) (-&gt;Bar 3)]) (fire-rules) (query q:baz)) ;; =&gt; ({:?baz #crede.rules.examples.Baz{:b 3}}) "><y>#</y><d>2016-01-21</d><h>21:28</h><w>devn</w><pre>(defrule foo
  [:exists [Foo]]
  [Bar (= ?b b 3)]
  =&gt;
  (insert! (-&gt;Baz ?b)))

(defquery q:baz []
  [?baz &lt;- Baz])

(-&gt; (mk-session [foo q:baz])
    (insert-all [(-&gt;Foo 1)
                 (-&gt;Bar 3)])
    (fire-rules)
    (query q:baz))

;; =&gt; ({:?baz #crede.rules.examples.Baz{:b 3}})
</pre></z><z id="t1453411683000236" t="pguillebert I just have to trust the magic"><y>#</y><d>2016-01-21</d><h>21:28</h><w>pguillebert</w>I just have to trust the magic</z><z id="t1453411706000237" t="devn @pguillebert: it&apos;s definitely taken me some getting used to"><y>#</y><d>2016-01-21</d><h>21:28</h><w>devn</w>@pguillebert: it&apos;s definitely taken me some getting used to</z><z id="t1453411755000238" t="devn it&apos;s happened more than once now where we wrote some rules, had some initial facts, and then a week or two later realize: &quot;oh, this could be simplified a whole lot&quot;"><y>#</y><d>2016-01-21</d><h>21:29</h><w>devn</w>it&apos;s happened more than once now where we wrote some rules, had some initial facts, and then a week or two later realize: &quot;oh, this could be simplified a whole lot&quot;</z><z id="t1453411795000239" t="devn or &quot;hmm, this record type is too general, we should fan out to multiple types of records in this rule&quot;"><y>#</y><d>2016-01-21</d><h>21:29</h><w>devn</w>or &quot;hmm, this record type is too general, we should fan out to multiple types of records in this rule&quot;</z><z id="t1453412426000240" t="pguillebert ok thanks"><y>#</y><d>2016-01-21</d><h>21:40</h><w>pguillebert</w>ok thanks</z><z id="t1453412453000241" t="devn @pguillebert: it really helps to keep an up-to-date graph of the logic, how rules are connected"><y>#</y><d>2016-01-21</d><h>21:40</h><w>devn</w>@pguillebert: it really helps to keep an up-to-date graph of the logic, how rules are connected</z><z id="t1453412463000242" t="pguillebert this is really a different way of expressing what I want"><y>#</y><d>2016-01-21</d><h>21:41</h><w>pguillebert</w>this is really a different way of expressing what I want</z><z id="t1453412466000243" t="pguillebert yeah ok"><y>#</y><d>2016-01-21</d><h>21:41</h><w>pguillebert</w>yeah ok</z><z id="t1453412561000244" t="devn @ryanbrush: do you have any thoughts on the following: (defn group &quot;Return a generic grouping accumulator. It behaves like clojure.core/group-by with the exception of specifying the grouping step. Parameters: value-fn - unary function which returns the grouping key. grouping-fn - binary function which recieves the current key value the current reduce value and returns a new key value. combine-fn - function for clara.rules/accumulator :combine-fn. convert-return-fn - function for clara.rules/accumulator :convert-return-fn.&quot; [{:keys [value-fn grouping-fn combine-fn convert-return-fn] :or {value-fn identity combine-fn merge convert-return-fn identity}}] {:pre [(ifn? grouping-fn)]} (clara.acc/accum {:initial-value {} :reduce-fn (fn [m x] (let [v (value-fn x)] (update m v grouping-fn x))) :combine-fn combine-fn :retract-fn #(throw (RuntimeException. &quot;group retract-fn triggered&quot;)) :convert-return-fn convert-return-fn})) (defn group-by &quot;Return an accumulator which behaves like clojure.core/group-by.&quot; [f] (group {:value-fn f :grouping-fn (fnil conj []) :combine-fn (fn [a b] (merge-with (comp vec into) a b))})) "><y>#</y><d>2016-01-21</d><h>21:42</h><w>devn</w>@ryanbrush: do you have any thoughts on the following:
<pre>(defn group
  &quot;Return a generic grouping accumulator. It behaves like
  clojure.core/group-by with the exception of specifying the grouping
  step.

  Parameters:

  value-fn - unary function which returns the grouping key.
  grouping-fn - binary function which recieves the current key
    value the current reduce value and returns a new key value.
  combine-fn - function for clara.rules/accumulator :combine-fn.
  convert-return-fn - function for clara.rules/accumulator :convert-return-fn.&quot;
  [{:keys [value-fn grouping-fn combine-fn convert-return-fn]
    :or {value-fn identity
         combine-fn merge
         convert-return-fn identity}}]
  {:pre [(ifn? grouping-fn)]}
  (clara.acc/accum
   {:initial-value {}
    :reduce-fn
    (fn [m x]
      (let [v (value-fn x)]
        (update m v grouping-fn x)))
    :combine-fn combine-fn
    :retract-fn #(throw (RuntimeException. &quot;group retract-fn triggered&quot;))
    :convert-return-fn convert-return-fn}))

(defn group-by
  &quot;Return an accumulator which behaves like clojure.core/group-by.&quot;
  [f]
  (group
   {:value-fn f
    :grouping-fn (fnil conj [])
    :combine-fn (fn [a b]
                  (merge-with (comp vec into) a b))}))
</pre></z><z id="t1453412572000245" t="devn What should retract-fn be here? /me puzzles"><y>#</y><d>2016-01-21</d><h>21:42</h><w>devn</w>What should <code>retract-fn</code> be here? /me puzzles</z><z id="t1453412685000246" t="devn perhaps I should be using reduce-to-accum here instead"><y>#</y><d>2016-01-21</d><h>21:44</h><w>devn</w>perhaps I should be using <code>reduce-to-accum</code> here instead</z><z id="t1453413644000247" t="devn (defn group-by [f] (clara.acc/reduce-to-accum (fn [m x] (let [v (f x)] (update m v (fnil conj []) x))) {} identity (fn [a b] (merge-with (comp vec into) a b)))) "><y>#</y><d>2016-01-21</d><h>22:00</h><w>devn</w><pre>(defn group-by
  [f]
  (clara.acc/reduce-to-accum
   (fn [m x]
     (let [v (f x)]
       (update m v (fnil conj []) x)))
   {}
   identity
   (fn [a b]
     (merge-with (comp vec into) a b))))
</pre></z><z id="t1453413988000249" t="ryanbrush @devn retract-fn should &quot;undo&quot; the effect of adding an element to the accumulated result. In this case, I think it&apos;s the opposite of a group-by step for a single value...which presumably would be finding that value in its underlying group and removing it. Probably not trivial to implement but seems doable."><y>#</y><d>2016-01-21</d><h>22:06</h><w>ryanbrush</w>@devn retract-fn should &quot;undo&quot; the effect of adding an element to the accumulated result. In this case, I think it&apos;s the opposite of a group-by step for a single value...which presumably would be finding that value in its underlying group and removing it. Probably not trivial to implement but seems doable.</z><z id="t1453414071000250" t="devn @ryanbrush: the behavior of group-by with reduce-to-accum seems to be doing what i&apos;m looking for by default. am i crazy?"><y>#</y><d>2016-01-21</d><h>22:07</h><w>devn</w>@ryanbrush: the behavior of group-by with reduce-to-accum seems to be doing what i&apos;m looking for by default. am i crazy?</z><z id="t1453414141000251" t="devn (defrule foo [?foo &lt;- (my-group-by :a) :from [Foo]] [Bar (= ?b b 3)] [:test (do (println ?foo) ?foo)] =&gt; (println ?foo) (insert! (-&gt;Baz ?foo))) (defquery q:baz [] [?Qux &lt;- Baz]) (let [f (-&gt;Foo 3)] (-&gt; (mk-session [foo q:baz]) (insert-all [(-&gt;Foo 1) (-&gt;Foo 1) (-&gt;Foo 2) f (-&gt;Bar 3)]) (retract f) (fire-rules) (query q:baz))) "><y>#</y><d>2016-01-21</d><h>22:09</h><w>devn</w><pre>(defrule foo
  [?foo &lt;- (my-group-by :a)
   :from [Foo]]
  [Bar (= ?b b 3)]
  [:test (do (println ?foo)
             ?foo)]
  =&gt;
  (println ?foo)
  (insert! (-&gt;Baz ?foo)))

(defquery q:baz []
  [?Qux &lt;- Baz])

(let [f (-&gt;Foo 3)]
  (-&gt; (mk-session [foo q:baz])
      (insert-all [(-&gt;Foo 1)
                   (-&gt;Foo 1)
                   (-&gt;Foo 2)
                   f
                   (-&gt;Bar 3)])
      (retract f)
      (fire-rules)
      (query q:baz)))
</pre></z><z id="t1453414167000252" t="devn prints: {1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}], 3 [#myproject.rules.examples.Foo{:a 3}]} {1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}]} {1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}]} "><y>#</y><d>2016-01-21</d><h>22:09</h><w>devn</w>prints:
<pre>{1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}], 3 [#myproject.rules.examples.Foo{:a 3}]}
{1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}]}
{1 [#myproject.rules.examples.Foo{:a 1} #myproject.rules.examples.Foo{:a 1}], 2 [#myproject.rules.examples.Foo{:a 2}]}
</pre></z><z id="t1453414202000253" t="ryanbrush @devn, no that makes sense. It&apos;s probably not the most efficient implementation if you have lots of retracts since it will redo the entire computation. The retract optimization could do something more efficient by removing a single value rather than re-reducing."><y>#</y><d>2016-01-21</d><h>22:10</h><w>ryanbrush</w>@devn, no that makes sense. It&apos;s probably not the most efficient implementation if you have lots of retracts since it will redo the entire computation. The retract optimization could do something more efficient by removing a single value rather than re-reducing.</z><z id="t1453414221000254" t="devn ahhh, i see what you&apos;re getting at"><y>#</y><d>2016-01-21</d><h>22:10</h><w>devn</w>ahhh, i see what you&apos;re getting at</z><z id="t1453414230000255" t="devn the number of retracts here will be really small, so no worries"><y>#</y><d>2016-01-21</d><h>22:10</h><w>devn</w>the number of retracts here will be really small, so no worries</z><z id="t1453414278000256" t="ryanbrush Yeah, I wouldn&apos;t worry about it unless you have lots of retracts and data, and you can always optimize it later without changing visible behavior."><y>#</y><d>2016-01-21</d><h>22:11</h><w>ryanbrush</w>Yeah, I wouldn&apos;t worry about it unless you have lots of retracts and data, and you can always optimize it later without changing visible behavior.</z><z id="t1453414304000257" t="ryanbrush Cool use of accumulator, by the way."><y>#</y><d>2016-01-21</d><h>22:11</h><w>ryanbrush</w>Cool use of accumulator, by the way.</z><z id="t1453414326000258" t="devn I think we talked about this awhile back, but any interest in pulling something like this into clara&apos;s accumulators?"><y>#</y><d>2016-01-21</d><h>22:12</h><w>devn</w>I think we talked about this awhile back, but any interest in pulling something like this into clara&apos;s accumulators?</z><z id="t1453414350000259" t="devn I suppose you&apos;d be looking for the more efficient impl that undoes a single step"><y>#</y><d>2016-01-21</d><h>22:12</h><w>devn</w>I suppose you&apos;d be looking for the more efficient impl that undoes a single step</z><z id="t1453414386000260" t="ryanbrush I&apos;d bring that one in if you want to put together a pull req and a simple test. "><y>#</y><d>2016-01-21</d><h>22:13</h><w>ryanbrush</w>I&apos;d bring that one in if you want to put together a pull req and a simple test. </z><z id="t1453414394000261" t="devn and honestly, I&apos;m not sure if I&apos;ll spend the time there... really, this group-by is just a tad more complicated"><y>#</y><d>2016-01-21</d><h>22:13</h><w>devn</w>and honestly, I&apos;m not sure if I&apos;ll spend the time there... really, this group-by is just a tad more complicated</z><z id="t1453414416000262" t="devn it&apos;s nice to group-by over a set of facts, and then call a function on the resulting set to bind to ?x"><y>#</y><d>2016-01-21</d><h>22:13</h><w>devn</w>it&apos;s nice to group-by over a set of facts, and then call a function on the resulting set to bind to ?x</z><z id="t1453414422000263" t="devn like you might group by date, and then find the minimum date"><y>#</y><d>2016-01-21</d><h>22:13</h><w>devn</w>like you might group by date, and then find the minimum date</z><z id="t1453414428000264" t="devn and bind that"><y>#</y><d>2016-01-21</d><h>22:13</h><w>devn</w>and bind that</z><z id="t1453414558000265" t="ryanbrush Interesting. It&apos;s not a flow we&apos;ve used directly but makes sense to me. I might actually think about doing so in our own rules."><y>#</y><d>2016-01-21</d><h>22:15</h><w>ryanbrush</w>Interesting. It&apos;s not a flow we&apos;ve used directly but makes sense to me. I might actually think about doing so in our own rules.</z><z id="t1453414651000266" t="devn @ryanbrush: either way i&apos;ll send a PR your way with a simple test and we can talk more there"><y>#</y><d>2016-01-21</d><h>22:17</h><w>devn</w>@ryanbrush: either way i&apos;ll send a PR your way with a simple test and we can talk more there</z><z id="t1453414653000267" t="devn thanks!"><y>#</y><d>2016-01-21</d><h>22:17</h><w>devn</w>thanks!</z><z id="t1453414732000268" t="ryanbrush @devn Sounds good!"><y>#</y><d>2016-01-21</d><h>22:18</h><w>ryanbrush</w>@devn Sounds good!</z><z id="t1453415267000269" t="pguillebert mmmh. apparently this is not working :"><y>#</y><d>2016-01-21</d><h>22:27</h><w>pguillebert</w>mmmh. apparently this is not working :</z><z id="t1453415271000270" t="pguillebert [:not [:test (and (= ?ndate ?sdate) (= ?ndes ?sdes))]]"><y>#</y><d>2016-01-21</d><h>22:27</h><w>pguillebert</w><code>  [:not [:test (and (= ?ndate ?sdate) (= ?ndes ?sdes))]]</code></z><z id="t1453415301000271" t="pguillebert can I negate tests on variables ?"><y>#</y><d>2016-01-21</d><h>22:28</h><w>pguillebert</w>can I negate tests on variables ?</z><z id="t1453416002000272" t="pguillebert same test applied in a when in the RHS does what I want (prevent rule firing based on :test)"><y>#</y><d>2016-01-21</d><h>22:40</h><w>pguillebert</w>same test applied in a <code>when</code> in the RHS does what I want (prevent rule firing based on :test)</z><z id="t1453416027000273" t="pguillebert I mean, a when-not"><y>#</y><d>2016-01-21</d><h>22:40</h><w>pguillebert</w>I mean, a <code>when-not</code></z><z id="t1453416053000274" t="pguillebert is this a limitation or am I missing something ?"><y>#</y><d>2016-01-21</d><h>22:40</h><w>pguillebert</w>is this a limitation or am I missing something ?</z><z id="t1453417324000275" t="devn @ryanbrush: https://github.com/rbrush/clara-rules/pull/164/files"><y>#</y><d>2016-01-21</d><h>23:02</h><w>devn</w>@ryanbrush: <a href="https://github.com/rbrush/clara-rules/pull/164/files" target="_blank">https://github.com/rbrush/clara-rules/pull/164/files</a></z><z id="t1453417400000277" t="devn @pguillebert: does it work if you just (not (and ...)) in a [:test ...] without the wrapping [:not ...] ?"><y>#</y><d>2016-01-21</d><h>23:03</h><w>devn</w>@pguillebert: does it work if you just <code>(not (and ...))</code> in a <code>[:test ...]</code> without the wrapping  <code>[:not ...]</code>?</z><z id="t1453417746000278" t="pguillebert I just killed my emacs simple_smile"><y>#</y><d>2016-01-21</d><h>23:09</h><w>pguillebert</w>I just killed my emacs <b>simple_smile</b></z><z id="t1453417765000279" t="pguillebert I didn’t try, will test tomorrow"><y>#</y><d>2016-01-21</d><h>23:09</h><w>pguillebert</w>I didn’t try, will test tomorrow</z><z id="t1453419098000280" t="devn @pguillebert: my guess is you had an infinite loop"><y>#</y><d>2016-01-21</d><h>23:31</h><w>devn</w>@pguillebert: my guess is you had an infinite loop</z><z id="t1453419118000281" t="devn @pguillebert: feel free to gist code in here if you&apos;d like another set of eyes"><y>#</y><d>2016-01-21</d><h>23:31</h><w>devn</w>@pguillebert: feel free to gist code in here if you&apos;d like another set of eyes</z><z id="t1453493271000286" t="ryanbrush @pguillebert: Ugh, I think you came across a bug here. Issue logged: https://github.com/rbrush/clara-rules/issues/165"><y>#</y><d>2016-01-22</d><h>20:07</h><w>ryanbrush</w>@pguillebert: Ugh, I think you came across a bug here. Issue logged: <a href="https://github.com/rbrush/clara-rules/issues/165" target="_blank">https://github.com/rbrush/clara-rules/issues/165</a></z><z id="t1453493381000288" t="ryanbrush @pguillebert It looks like it&apos;s specific to the case of having a test within a negation, which somehow we haven&apos;t covered. Thanks for reporting it here."><y>#</y><d>2016-01-22</d><h>20:09</h><w>ryanbrush</w>@pguillebert It looks like it&apos;s specific to the case of having a test within a negation, which somehow we haven&apos;t covered. Thanks for reporting it here.</z><z id="t1453493737000289" t="pguillebert you’re welcone"><y>#</y><d>2016-01-22</d><h>20:15</h><w>pguillebert</w>you’re welcone</z><z id="t1453493760000290" t="pguillebert usually when I report something I am the bug simple_smile"><y>#</y><d>2016-01-22</d><h>20:16</h><w>pguillebert</w>usually when I report something I am the bug <b>simple_smile</b></z><z id="t1453496236000291" t="ryanbrush @pguillebert Haha, I know that feeling very well. I got a simple fix for this bug committed on the issue linked above. The fix is a bit ugly and depends on some other refactoring, but I expect to get this into master next week and released soon afterwards. If you do need this sooner then you can build against the issue-165 branch I created."><y>#</y><d>2016-01-22</d><h>20:57</h><w>ryanbrush</w>@pguillebert Haha, I know that feeling very well. I got a simple fix for this bug committed on the issue linked above. The fix is a bit ugly and depends on some other refactoring, but I expect to get this into master next week and released soon afterwards. If you do need this sooner then you can build against the issue-165 branch I created.</z><z id="t1453496729000294" t="pguillebert well thanks but the simple workaround of negating the condition works well for me"><y>#</y><d>2016-01-22</d><h>21:05</h><w>pguillebert</w>well thanks but the simple workaround of negating the condition works well for me</z><z id="t1453496735000295" t="pguillebert so no rush"><y>#</y><d>2016-01-22</d><h>21:05</h><w>pguillebert</w>so no rush</z><z id="t1453496971000296" t="ryanbrush Good to know. I mostly just didn&apos;t want that mistake hanging around out here any longer than it already has. 😉"><y>#</y><d>2016-01-22</d><h>21:09</h><w>ryanbrush</w>Good to know. I mostly just didn&apos;t want that mistake hanging around out here any longer than it already has. <b>😉</b></z><z id="t1453504376000297" t="pguillebert Mmmh what is the preferred way to configure rules ?"><y>#</y><d>2016-01-22</d><h>23:12</h><w>pguillebert</w>Mmmh what is the preferred way to configure rules ?</z><z id="t1453504469000298" t="pguillebert like, should I add a configuration record to my facts or is there a better facility ?"><y>#</y><d>2016-01-22</d><h>23:14</h><w>pguillebert</w>like, should I add a configuration record to my facts or is there a better facility ?</z><z id="t1453522206000299" t="devn @pguillebert: that&apos;s a very good question simple_smile we haven&apos;t come to a strong conclusion on that front"><y>#</y><d>2016-01-23</d><h>04:10</h><w>devn</w>@pguillebert: that&apos;s a very good question <b>simple_smile</b> we haven&apos;t come to a strong conclusion on that front</z><z id="t1453522328000300" t="devn right now, we are grabbing tables from postgres (configuration), importing them and using datascript to &quot;enrich&quot; our base set of facts"><y>#</y><d>2016-01-23</d><h>04:12</h><w>devn</w>right now, we are grabbing tables from postgres (configuration), importing them and using datascript to &quot;enrich&quot; our base set of facts</z><z id="t1453522406000301" t="devn so we might have some basic idea of what IsClean means, but we&apos;ll enrich that fact with :cleanliness-threshold :low based on the information from the external configuration DB"><y>#</y><d>2016-01-23</d><h>04:13</h><w>devn</w>so we might have some basic idea of what <code>IsClean</code> means, but we&apos;ll enrich that fact with <code>:cleanliness-threshold :low</code> based on the information from the external configuration DB</z><z id="t1453522517000302" t="devn not sure if that&apos;s what you&apos;re looking for or not..."><y>#</y><d>2016-01-23</d><h>04:15</h><w>devn</w>not sure if that&apos;s what you&apos;re looking for or not...</z><z id="t1453522563000303" t="devn obviously we&apos;ve punted on guaranteeing we aren&apos;t affected by upstream schema changes for the moment"><y>#</y><d>2016-01-23</d><h>04:16</h><w>devn</w>obviously we&apos;ve punted on guaranteeing we aren&apos;t affected by upstream schema changes for the moment</z><z id="t1453522948000304" t="devn i&apos;d like to talk about the configuration problem in general. we&apos;re going to need to have versioned rules per customer, likely with some kind of function registry, which may be as stupid as associating a set of versioned rules with a pointer to a git SHA where a particular file at that SHA is the mapping of our application&apos;s private functions, to the &quot;public&quot; functions that rules authors indirectly tap into when building rules"><y>#</y><d>2016-01-23</d><h>04:22</h><w>devn</w>i&apos;d like to talk about the configuration problem in general. we&apos;re going to need to have versioned rules per customer, likely with some kind of function registry, which may be as stupid as associating a set of versioned rules with a pointer to a git SHA where a particular file at that SHA is the mapping of our application&apos;s private functions, to the &quot;public&quot; functions that rules authors indirectly tap into when building rules</z><z id="t1453523084000306" t="devn im also curious about persisting durable sessions. that would be interesting for auditing, capturing configuration at a point in time, etc."><y>#</y><d>2016-01-23</d><h>04:24</h><w>devn</w>im also curious about persisting durable sessions. that would be interesting for auditing, capturing configuration at a point in time, etc.</z><z id="t1453523103000307" t="devn would also provide a way to do replays"><y>#</y><d>2016-01-23</d><h>04:25</h><w>devn</w>would also provide a way to do replays</z><z id="t1453761345000003" t="pguillebert Hey"><y>#</y><d>2016-01-25</d><h>22:35</h><w>pguillebert</w>Hey</z><z id="t1453761362000004" t="pguillebert I think I found a bug/unexpected limit in Clara"><y>#</y><d>2016-01-25</d><h>22:36</h><w>pguillebert</w>I think I found a bug/unexpected limit in Clara</z><z id="t1453761558000006" t="pguillebert this changes the rule’s behaviour"><y>#</y><d>2016-01-25</d><h>22:39</h><w>pguillebert</w>this changes the rule’s behaviour</z><z id="t1453761568000007" t="pguillebert without warning"><y>#</y><d>2016-01-25</d><h>22:39</h><w>pguillebert</w>without warning</z><z id="t1453761654000008" t="pguillebert so I think either I’m very tired, or this looks like a bug"><y>#</y><d>2016-01-25</d><h>22:40</h><w>pguillebert</w>so I think either I’m very tired, or this looks like a bug</z><z id="t1453815058000009" t="pguillebert opened issue #166"><y>#</y><d>2016-01-26</d><h>13:30</h><w>pguillebert</w>opened issue  #166</z><z id="t1453911683000010" t="ryanbrush Alright, back on Slack. 😉 For reference, the issue that @pguillebert logged is here and should be fixed. We&apos;re planning on doing a release of 0.10 as soon as we get some unrelated optimizations to accumulators finished which includes this and a number of other improvements. https://github.com/rbrush/clara-rules/issues/166"><y>#</y><d>2016-01-27</d><h>16:21</h><w>ryanbrush</w>Alright, back on Slack. <b>😉</b> For reference, the issue that @pguillebert logged is here and should be fixed. We&apos;re planning on doing a release of 0.10 as soon as we get some unrelated optimizations to accumulators finished which includes this and a number of other improvements.  <a href="https://github.com/rbrush/clara-rules/issues/166" target="_blank">https://github.com/rbrush/clara-rules/issues/166</a></z><z id="t1453911756000011" t="ryanbrush Here&apos;s what is targeted at 0.10, if you&apos;re curious: https://github.com/rbrush/clara-rules/issues?q=milestone%3A0.10.0"><y>#</y><d>2016-01-27</d><h>16:22</h><w>ryanbrush</w>Here&apos;s what is targeted at 0.10, if you&apos;re curious: <a href="https://github.com/rbrush/clara-rules/issues?q=milestone%3A0.10.0" target="_blank">https://github.com/rbrush/clara-rules/issues?q=milestone%3A0.10.0</a></z><z id="t1453913742000013" t="pguillebert ryanbrush: I’ll try to build the issue-166 branch when I get the time"><y>#</y><d>2016-01-27</d><h>16:55</h><w>pguillebert</w>ryanbrush: I’ll try to build the issue-166 branch when I get the time</z><z id="t1453913987000014" t="ryanbrush @pguillebert: Sounds good! I&apos;m pretty sure that addresses what you saw but verification is always a good thing. I do appreciate the bug report and reproducible example."><y>#</y><d>2016-01-27</d><h>16:59</h><w>ryanbrush</w>@pguillebert: Sounds good! I&apos;m pretty sure that addresses what you saw but verification is always a good thing. I do appreciate the bug report and reproducible example.</z><z id="t1454347752000016" t="pguillebert is there a planned date for the release of 0.10 ?"><y>#</y><d>2016-02-01</d><h>17:29</h><w>pguillebert</w>is there a planned date for the release of 0.10 ?</z><z id="t1454348741000017" t="ryanbrush @pguillebert: I&apos;ll release 0.10 by the end of the week. There are a couple more improvements I wanted to include, but they can be delayed if necessary. 0.10 in its current form is a big enough step forward that it makes sense to get out there."><y>#</y><d>2016-02-01</d><h>17:45</h><w>ryanbrush</w>@pguillebert: I&apos;ll release 0.10 by the end of the week. There are a couple more improvements I wanted to include, but they can be delayed if necessary. 0.10 in its current form is a big enough step forward that it makes sense to get out there.</z><z id="t1454348861000018" t="pguillebert ok great"><y>#</y><d>2016-02-01</d><h>17:47</h><w>pguillebert</w>ok great</z><z id="t1454684581000019" t="ryanbrush Aaaand Clara 0.10.0 is up on Clojars! A couple small features, a number of bug fixes, and significantly improved performance for some workloads. Release notes here: https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0100"><y>#</y><d>2016-02-05</d><h>15:03</h><w>ryanbrush</w>Aaaand Clara 0.10.0 is up on Clojars! A couple small features, a number of bug fixes, and significantly improved performance for some workloads. Release notes here: <a href="https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0100" target="_blank">https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0100</a></z><z id="t1455828099000002" t="devn Heya @ryanbrush -- dumb question for you"><y>#</y><d>2016-02-18</d><h>20:41</h><w>devn</w>Heya @ryanbrush -- dumb question for you</z><z id="t1455828142000003" t="devn Say I create a session, and insert 3 (-&gt;Temperature 100 &quot;ABC&quot;) facts, and then retract (-&gt;Temperature 100 &quot;ABC&quot;) once on that session"><y>#</y><d>2016-02-18</d><h>20:42</h><w>devn</w>Say I create a session, and insert 3 (-&gt;Temperature 100 &quot;ABC&quot;) facts, and then retract (-&gt;Temperature 100 &quot;ABC&quot;) once on that session</z><z id="t1455828184000005" t="devn Should there be 0 (-&gt;Temperature 100 &quot;ABC&quot;) facts?"><y>#</y><d>2016-02-18</d><h>20:43</h><w>devn</w>Should there be 0 (-&gt;Temperature 100 &quot;ABC&quot;) facts?</z><z id="t1455829175000007" t="wparker Are these top-level insert calls i.e. (clara.rules/insert session fact) or logical insertions and retractions? @devn"><y>#</y><d>2016-02-18</d><h>20:59</h><w>wparker</w>Are these top-level insert calls i.e. (clara.rules/insert session fact) or logical insertions and retractions? @devn</z><z id="t1455829189000008" t="devn top-level"><y>#</y><d>2016-02-18</d><h>20:59</h><w>devn</w>top-level</z><z id="t1455829210000009" t="wparker A quick trial suggests that top-level retracts one at a time"><y>#</y><d>2016-02-18</d><h>21:00</h><w>wparker</w>A quick trial suggests that top-level retracts one at a time</z><z id="t1455829239000010" t="wparker Logical retractions of equal facts from the same production currently have a truth maintenance bug; see https://github.com/rbrush/clara-rules/issues/171"><y>#</y><d>2016-02-18</d><h>21:00</h><w>wparker</w>Logical retractions of equal facts from the same production currently have a truth maintenance bug; see <a href="https://github.com/rbrush/clara-rules/issues/171" target="_blank">https://github.com/rbrush/clara-rules/issues/171</a></z><z id="t1455829240000011" t="devn session (-&gt; (mk-session [grouping-query grouping-convert-query]) (insert-all [(-&gt;Temperature 30 &quot;MCI&quot;) (-&gt;Temperature 10 &quot;MCI&quot;) (-&gt;Temperature 80 &quot;MCI&quot;) (-&gt;Temperature 80 &quot;MCI&quot;)])) retracted-session (-&gt; session (retract (-&gt;Temperature 80 &quot;MCI&quot;) (-&gt;Temperature 80 &quot;MCI&quot;))) "><y>#</y><d>2016-02-18</d><h>21:00</h><w>devn</w><pre>session (-&gt; (mk-session [grouping-query
                                 grouping-convert-query])
                    (insert-all [(-&gt;Temperature 30 &quot;MCI&quot;)
                                 (-&gt;Temperature 10 &quot;MCI&quot;)
                                 (-&gt;Temperature 80 &quot;MCI&quot;)
                                 (-&gt;Temperature 80 &quot;MCI&quot;)]))

        retracted-session (-&gt; session
                              (retract (-&gt;Temperature 80 &quot;MCI&quot;)
                                       (-&gt;Temperature 80 &quot;MCI&quot;)))
</pre></z><z id="t1455829267000013" t="devn @wparker: oof, good catch."><y>#</y><d>2016-02-18</d><h>21:01</h><w>devn</w>@wparker: oof, good catch.</z><z id="t1455829307000014" t="devn @wparker: I guess my question is, after running the same trial myself is: should it?"><y>#</y><d>2016-02-18</d><h>21:01</h><w>devn</w>@wparker: I guess my question is, after running the same trial myself is: should it?</z><z id="t1455829333000015" t="wparker I’d expect that to have temperatures of 30 and 10"><y>#</y><d>2016-02-18</d><h>21:02</h><w>wparker</w>I’d expect that to have temperatures of 30 and 10</z><z id="t1455829337000016" t="wparker Does it not?"><y>#</y><d>2016-02-18</d><h>21:02</h><w>wparker</w>Does it not?</z><z id="t1455829347000017" t="devn It does."><y>#</y><d>2016-02-18</d><h>21:02</h><w>devn</w>It does.</z><z id="t1455829377000018" t="wparker So you insert 2 temperatures of 80 and then retract 2 of them; I’d expect there to be none left"><y>#</y><d>2016-02-18</d><h>21:02</h><w>wparker</w>So you insert 2 temperatures of 80 and then retract 2 of them; I’d expect there to be none left</z><z id="t1455829387000019" t="devn I guess I halfway expected that, for instance, some deeper identity of a fact beyond just its equality with a corresponding fact in the session would have some bearing."><y>#</y><d>2016-02-18</d><h>21:03</h><w>devn</w>I guess I halfway expected that, for instance, some deeper identity of a fact beyond just its equality with a corresponding fact in the session would have some bearing.</z><z id="t1455829428000020" t="devn So if I bound (-&gt;Temperature 80 &quot;MCI&quot;) to high-temp , and then used high-temp twice in the insert-all"><y>#</y><d>2016-02-18</d><h>21:03</h><w>devn</w>So if I bound <code>(-&gt;Temperature 80 &quot;MCI&quot;)</code> to <code>high-temp</code>, and then used <code>high-temp</code> twice in the <code>insert-all</code></z><z id="t1455829478000021" t="devn When I do a (retract session high-termp) , it would actually retract both facts"><y>#</y><d>2016-02-18</d><h>21:04</h><w>devn</w>When I do a <code>(retract session high-termp)</code>, it would actually retract both facts</z><z id="t1455829539000022" t="devn I was surprised, but I guess after thinking about it, it doesn&apos;t really matter which of the facts is retracted."><y>#</y><d>2016-02-18</d><h>21:05</h><w>devn</w>I was surprised, but I guess after thinking about it, it doesn&apos;t really matter which of the facts is retracted.</z><z id="t1455829542000023" t="wparker Oh, I think I see"><y>#</y><d>2016-02-18</d><h>21:05</h><w>wparker</w>Oh, I think I see</z><z id="t1455829563000024" t="wparker Yeah, at least for now I think the memory just uses equality and retracts one each time"><y>#</y><d>2016-02-18</d><h>21:06</h><w>wparker</w>Yeah, at least for now I think the memory just uses equality and retracts one each time</z><z id="t1455829586000025" t="wparker The key bit of code is the remove-first-of-each calls in the memory"><y>#</y><d>2016-02-18</d><h>21:06</h><w>wparker</w>The key bit of code is the remove-first-of-each calls in the memory</z><z id="t1455829590000026" t="wparker https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc"><y>#</y><d>2016-02-18</d><h>21:06</h><w>wparker</w><a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc</a></z><z id="t1455829608000028" t="devn I was thinking that you know, under the covers, an instance of (-&gt; Foo 1) would have an object ID or something taken into account underneath"><y>#</y><d>2016-02-18</d><h>21:06</h><w>devn</w>I was thinking that you know, under the covers, an instance of <code>(-&gt; Foo 1)</code> would have an object ID or something taken into account underneath</z><z id="t1455829618000029" t="devn but it makes sense that it doesn&apos;t"><y>#</y><d>2016-02-18</d><h>21:06</h><w>devn</w>but it makes sense that it doesn&apos;t</z><z id="t1455829642000030" t="wparker Yes, it just uses Clojure equality"><y>#</y><d>2016-02-18</d><h>21:07</h><w>wparker</w>Yes, it just uses Clojure equality</z><z id="t1455829652000031" t="devn So, @wparker here&apos;s one more question for you simple_smile"><y>#</y><d>2016-02-18</d><h>21:07</h><w>devn</w>So, @wparker here&apos;s one more question for you <b>simple_smile</b></z><z id="t1455829680000032" t="devn https://github.com/rbrush/clara-rules/pull/164/files#diff-d16f31f970a20e4115932869c9aa825dR310"><y>#</y><d>2016-02-18</d><h>21:08</h><w>devn</w><a href="https://github.com/rbrush/clara-rules/pull/164/files#diff-d16f31f970a20e4115932869c9aa825dR310" target="_blank">https://github.com/rbrush/clara-rules/pull/164/files#diff-d16f31f970a20e4115932869c9aa825dR310</a></z><z id="t1455829690000033" t="devn Is this actually a good test of truth maintenance in action for a grouping accumulator?"><y>#</y><d>2016-02-18</d><h>21:08</h><w>devn</w>Is this actually a good test of truth maintenance in action for a grouping accumulator?</z><z id="t1455829707000034" t="devn Or is it merely testing that top-level retract does what it&apos;s supposed to?"><y>#</y><d>2016-02-18</d><h>21:08</h><w>devn</w>Or is it merely testing that top-level <code>retract</code> does what it&apos;s supposed to?</z><z id="t1455829965000036" t="devn @wparker: reading through the issue you filed, and thinking &quot;boy, generative tests in this case would make a lot of sense.&quot;"><y>#</y><d>2016-02-18</d><h>21:12</h><w>devn</w>@wparker: reading through the issue you filed, and thinking &quot;boy, generative tests in this case would make a lot of sense.&quot;</z><z id="t1455830408000037" t="wparker I’m not super familiar with how accumulators work in the engine, but one thing to keep in mind there is that reduce-to-accum creates a retraction function"><y>#</y><d>2016-02-18</d><h>21:20</h><w>wparker</w>I’m not super familiar with how accumulators work in the engine, but one thing to keep in mind there is that reduce-to-accum creates a retraction function</z><z id="t1455830410000038" t="wparker https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc#L91"><y>#</y><d>2016-02-18</d><h>21:20</h><w>wparker</w><a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc#L91" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc#L91</a></z><z id="t1455830646000040" t="wparker Regarding generative tests: that could be helpful, but I haven’t come up with any good ideas on how to make them (I haven’t thought about it that deeply though)."><y>#</y><d>2016-02-18</d><h>21:24</h><w>wparker</w>Regarding generative tests: that could be helpful, but I haven’t come up with any good ideas on how to make them (I haven’t thought about it that deeply though).</z><z id="t1455834858000041" t="ryanbrush @wparker @devn A good suite of generative tests would be great, and may have found a number of issues in logical edge cases. This would require generating rules with different criteria and ensuring consistency to really do well, and how to do so doesn&apos;t seem obvious. But I like the thought if anyone wants to play with it."><y>#</y><d>2016-02-18</d><h>22:34</h><w>ryanbrush</w>@wparker @devn A good suite of generative tests would be great, and may have found a number of issues in logical edge cases. This would require generating rules with different criteria and ensuring consistency to really do well, and how to do so doesn&apos;t seem obvious. But I like the thought if anyone wants to play with it.</z><z id="t1455834966000042" t="ryanbrush As for retraction, Clara used Clojure equality semantics by design. This seems like the least surprising behavior to treat facts as values....just like the number 1 is 1 no matter what its &quot;identity&quot;. Seems like the Clojure way to me, and is analogous to removing an item from a map or set."><y>#</y><d>2016-02-18</d><h>22:36</h><w>ryanbrush</w>As for retraction, Clara used Clojure equality semantics by design. This seems like the least surprising behavior to treat facts as values....just like the number 1 is 1 no matter what its &quot;identity&quot;. Seems like the Clojure way to me, and is analogous to removing an item from a map or set.</z><z id="t1457111106000045" t="enn I’m running into some behavior that I don’t understand. I have a fact type of which I only ever expect 1 or 0 instances. If the session has 0 instances, I’d like to make a rule which inserts an instance with some reasonable default values. Right now I have this rule: (defrule default-event-date &quot;If there is no EventDate, create one far in the future.&quot; [:not [EventDate]] =&gt; (clara.rules/insert! (r/map-&gt;EventDate {:date (time.coerce/to-date-time &quot;30000&quot;)}))) This correctly does not fire if I start the session with an EventDate fact. If I don’t, however, run-rules never returns. It seems to just keep firing. I would expect it to fire once."><y>#</y><d>2016-03-04</d><h>17:05</h><w>enn</w>I’m running into some behavior that I don’t understand. I have a fact type of which I only ever expect 1 or 0 instances. If the session has 0 instances, I’d like to make a rule which inserts an instance with some reasonable default values. Right now I have this rule:

<pre>(defrule default-event-date
  &quot;If there is no EventDate, create one far in the future.&quot;
  [:not [EventDate]]
  =&gt;
  (clara.rules/insert!
   (r/map-&gt;EventDate {:date (time.coerce/to-date-time &quot;30000&quot;)})))
</pre>

This correctly does not fire if I start the session with an EventDate fact. If I don’t, however, <code>run-rules</code> never returns. It seems to just keep firing. I would expect it to fire once.</z><z id="t1457111270000046" t="enn Ah, just found the mailing list thread about this. I guess that the fact gets retracted when the LHS stops being true, which causes it to get re-inserted, which causes the LHS to stop being true, which causes it to get retracted, etc. ad infinitum"><y>#</y><d>2016-03-04</d><h>17:07</h><w>enn</w>Ah, just found the mailing list thread about this. I guess that the fact gets retracted when the LHS stops being true, which causes it to get re-inserted, which causes the LHS to stop being true, which causes it to get retracted, etc. ad infinitum</z><z id="t1457111869000047" t="enn The suggestion is to use insert-unconditional! , but that seems to never fire, even when there are no facts"><y>#</y><d>2016-03-04</d><h>17:17</h><w>enn</w>The suggestion is to use <code>insert-unconditional!</code>, but that seems to never fire, even when there are no facts</z><z id="t1457112227000048" t="ryanbrush @enn Hmm, insert-unconditional! should fire in example above if no EventDate facts are in the working memory when fire-rules is called. It might be worth restarting the REPL in case fact types got reloaded (and rules are looking at a different type). If things are still failing and can be narrowed down to a reproducible test I can take a look."><y>#</y><d>2016-03-04</d><h>17:23</h><w>ryanbrush</w>@enn Hmm, insert-unconditional! should fire in example above if no EventDate facts are in the working memory when fire-rules is called. It might be worth restarting the REPL in case fact types got reloaded (and rules are looking at a different type). If things are still failing and can be narrowed down to a reproducible test I can take a look.</z><z id="t1457112275000049" t="enn @ryanbrush I was mistaken—it does fire, it just doesn’t show up in explain-activations . Is that expected?"><y>#</y><d>2016-03-04</d><h>17:24</h><w>enn</w>@ryanbrush I was mistaken—it does fire, it just doesn’t show up in <code>explain-activations</code>. Is that expected?</z><z id="t1457112773000051" t="ryanbrush @enn So explain-activations uses the truth maintenance facility to figure out what is supporting the fact, which wouldn&apos;t be used in an unconditional insert. I think one could argue the fact that unconditional inserts aren&apos;t seen here is a bug, but there are tradeoffs there. Another use case for unconditional insert is for performance-critical edge cases where users don&apos;t want to pay the accounting cost of tracking truth and activation explanation...which we couldn&apos;t offer if we tracked truth maintenance/explain-activations for unconditional inserts."><y>#</y><d>2016-03-04</d><h>17:32</h><w>ryanbrush</w>@enn So explain-activations uses the truth maintenance facility to figure out what is supporting the fact, which wouldn&apos;t be used in an unconditional insert. I think one could argue the fact that unconditional inserts aren&apos;t seen here is a bug, but there are tradeoffs there. Another use case for unconditional insert is for performance-critical edge cases where users don&apos;t want to pay the accounting cost of tracking truth and activation explanation...which we couldn&apos;t offer if we tracked truth maintenance/explain-activations for unconditional inserts.</z><z id="t1457112854000052" t="ryanbrush @enn In short, I&apos;d be open to adding unconditional activations to explain-activations, but I&apos;d want to consider the tradeoffs and make sure our performance-critical use cases (some inserting more then 100,000 facts) have a path forward as well."><y>#</y><d>2016-03-04</d><h>17:34</h><w>ryanbrush</w>@enn In short, I&apos;d be open to adding unconditional activations to explain-activations, but I&apos;d want to consider the tradeoffs and make sure our performance-critical use cases (some inserting more then 100,000 facts) have a path forward as well.</z><z id="t1457112989000053" t="ryanbrush @enn As for the original problem of an infinite looping rule, this comes up enough that I think we need a better way to expose and explain it to the user. I&apos;ve seen other engines limit the number of recursive activations to a few thousand and throw an exception with context to explain where the failure is coming from. Tempted to add that to Clara as well."><y>#</y><d>2016-03-04</d><h>17:36</h><w>ryanbrush</w>@enn As for the original problem of an infinite looping rule, this comes up enough that I think we need a better way to expose and explain it to the user. I&apos;ve seen other engines limit the number of recursive activations to a few thousand and throw an exception with context to explain where the failure is coming from. Tempted to add that to Clara as well.</z><z id="t1457113364000054" t="enn @ryanbrush: thanks for the explanation. That makes sense. I was just using explain-activations as a debugging tool, so now that I know it has that limitation, it’s not a problem that it’s not showing up."><y>#</y><d>2016-03-04</d><h>17:42</h><w>enn</w>@ryanbrush: thanks for the explanation. That makes sense. I was just using explain-activations as a debugging tool, so now that I know it has that limitation, it’s not a problem that it’s not showing up.</z><z id="t1457113684000055" t="ryanbrush @enn Fair enough. I mostly want to extinguish any sort of surprising behavior, even if it is for debugging purposes. I&apos;ll think about it some more but won&apos;t make any immediate changes here."><y>#</y><d>2016-03-04</d><h>17:48</h><w>ryanbrush</w>@enn Fair enough. I mostly want to extinguish any sort of surprising behavior, even if it is for debugging purposes. I&apos;ll think about it some more but won&apos;t make any immediate changes here.</z><z id="t1457471243000056" t="devn Howdy @ryanbrush -- 2 selfish questions for you: 1) Any guess on when 0.11 might make it out into the wild? 2) Any chance of the new work you began on clara-tools continuing?"><y>#</y><d>2016-03-08</d><h>21:07</h><w>devn</w>Howdy @ryanbrush -- 2 selfish questions for you:
1) Any guess on when 0.11 might make it out into the wild?
2) Any chance of the new work you began on clara-tools continuing?</z><z id="t1457498470000057" t="ryanbrush Hey @devn, there is one more fix I wanted to get into 0.11, but I can see it dropping next week. As for clara-tools, I&apos;m not sure when I&apos;ll get back to it. We found a simpler way to solve some of the internal problems I had been enhancing clara-tools for and other demands are taking most of my time. I&apos;d be happy to collaborate with anyone interested in moving it forward and hope to work more on it starting in mid April, but can&apos;t promise much more than that."><y>#</y><d>2016-03-09</d><h>04:41</h><w>ryanbrush</w>Hey @devn, there is one more fix I wanted to get into 0.11, but I can see it dropping next week. As for clara-tools, I&apos;m not sure when I&apos;ll get back to it. We found a simpler way to solve some of the internal problems I had been enhancing clara-tools for and other demands are taking most of my time. I&apos;d be happy to collaborate with anyone interested in moving it forward and hope to work more on it starting in mid April, but can&apos;t promise much more than that.</z><z id="t1457980319000002" t="kahunamoore @ryanbrush: @devn I’ve started building an IDE-like environment (called Clarity) for clara and have been studying clara-tools. However, I’m looking to take a different approach. Two requirements I would like to meet are integration with Cursive/Intelli-J and as a plugin for other editors"><y>#</y><d>2016-03-14</d><h>18:31</h><w>kahunamoore</w>@ryanbrush: @devn I’ve started building an IDE-like environment (called Clarity) for clara and have been studying clara-tools. However, I’m looking to take a different approach. Two requirements I would like to meet are integration with Cursive/Intelli-J and as a plugin for other editors</z><z id="t1457980439000003" t="kahunamoore opps… hit return before I was done editing. I started it as a plugin for lighttable but abandoned that when the project team abandoned LT. I might revisit it at some point but right now I’m working on the Cursive approach first. The other approach is based on a standalone Electron/Atom editor."><y>#</y><d>2016-03-14</d><h>18:33</h><w>kahunamoore</w>opps… hit return before I was done editing. I started it as a plugin for lighttable but abandoned that when the project team abandoned LT. I might revisit it at some point but right now I’m working on the Cursive approach first. The other approach is based on a standalone Electron/Atom editor.</z><z id="t1457980624000004" t="kahunamoore A lot of code from clara-tools can be used to inform these other platforms. I’m not sure using an HTTP server will be the approach I settle on. I’m trying to leverage the existing JDI infrastructure. While it is much more difficult, long term I think it will provide much better integration… TBD."><y>#</y><d>2016-03-14</d><h>18:37</h><w>kahunamoore</w>A lot of code from clara-tools can be used to inform these other platforms. I’m not sure using an HTTP server will be the approach I settle on. I’m trying to leverage the existing JDI infrastructure. While it is much more difficult, long term I think it will provide much better integration… TBD.</z><z id="t1458008052000005" t="ryanbrush @kahunamoore: sounds cool! IDE integration would be awesome. There might be some code that could be reused or refactored out of clara-tools for this, although I agree having an HTTP server in the middle makes less sense for what you describe."><y>#</y><d>2016-03-15</d><h>02:14</h><w>ryanbrush</w>@kahunamoore: sounds cool! IDE integration would be awesome. There might be some code that could be reused or refactored out of clara-tools for this, although I agree having an HTTP server in the middle makes less sense for what you describe.</z><z id="t1458008567000006" t="kahunamoore I really like what you did with clara-tools - very compact and clean code. The HTTP server was clearly the right call given the requirements (I’m guessing a problem at work and needing visibility…) I’m hoping to write as little code as possible but still integrate with what people are already doing (e.g. IntelliJ debugger, repl). I want to create some visualizations for the debugger, some utilities for the repl, etc. The logic -&gt; graph and session -&gt; graph functions are very helpful."><y>#</y><d>2016-03-15</d><h>02:22</h><w>kahunamoore</w>I really like what you did with clara-tools -  very compact and clean code. The HTTP server was clearly the right call given the requirements (I’m guessing a problem at work and needing visibility…)  I’m hoping to write as little code as possible but still integrate with what people are already doing (e.g. IntelliJ debugger, repl). I want to create some visualizations for the debugger, some utilities for the repl, etc. The logic -&gt; graph and session -&gt; graph functions are very helpful.</z><z id="t1458312558000008" t="ryanbrush Clara 0.11.0 is up on Clojars. It&apos;s a smaller release than 0.10, but has a couple bug fixes that are worth picking up if nothing else. Release notes here: https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0110"><y>#</y><d>2016-03-18</d><h>14:49</h><w>ryanbrush</w>Clara 0.11.0 is up on Clojars. It&apos;s a smaller release than 0.10, but has a couple bug fixes that are worth picking up if nothing else. Release notes here: <a href="https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0110" target="_blank">https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0110</a></z><z id="t1458593590000010" t="devn We may have been experiencing one of those bugs and calling our behavior good"><y>#</y><d>2016-03-21</d><h>20:53</h><w>devn</w>We may have been experiencing one of those bugs and calling our behavior good</z><z id="t1458593632000011" t="devn I suppose it&apos;s also possible there&apos;s a regression, but we&apos;re looking into it now. Will let you know what we find"><y>#</y><d>2016-03-21</d><h>20:53</h><w>devn</w>I suppose it&apos;s also possible there&apos;s a regression, but we&apos;re looking into it now. Will let you know what we find</z><z id="t1458593645000012" t="devn @ryanbrush: ^"><y>#</y><d>2016-03-21</d><h>20:54</h><w>devn</w>@ryanbrush: ^</z><z id="t1458593741000013" t="devn We do not use insert unconditional or salience "><y>#</y><d>2016-03-21</d><h>20:55</h><w>devn</w>We do not use insert unconditional or salience </z><z id="t1458593761000014" t="devn We are using the deprecated accumulator function though."><y>#</y><d>2016-03-21</d><h>20:56</h><w>devn</w>We are using the deprecated accumulator function though.</z><z id="t1458598510000015" t="devn Looks like #171 is what broke us."><y>#</y><d>2016-03-21</d><h>22:15</h><w>devn</w>Looks like #171 is what broke us.</z><z id="t1458598552000016" t="devn We have a couple instances of the RHS using both a retract!, and an insert!"><y>#</y><d>2016-03-21</d><h>22:15</h><w>devn</w>We have a couple instances of the RHS using both a retract!, and an insert!</z><z id="t1458600442000017" t="ryanbrush @devn Traveling right now so can&apos;t look in depth, but using retract with truth maintenance can create difficult to reason about situations in any rule engine. If there is some test case that does not behave as one would expect I&apos;ll take a look at it."><y>#</y><d>2016-03-21</d><h>22:47</h><w>ryanbrush</w>@devn Traveling right now so can&apos;t look in depth, but using retract with truth maintenance can create difficult to reason about situations in any rule engine. If there is some test case that does not behave as one would expect I&apos;ll take a look at it.</z><z id="t1458601382000018" t="devn after thinking about it for a little bit, i see why this is broken."><y>#</y><d>2016-03-21</d><h>23:03</h><w>devn</w>after thinking about it for a little bit, i see why this is broken.</z><z id="t1458601388000019" t="devn clara is doing it&apos;s job correctly."><y>#</y><d>2016-03-21</d><h>23:03</h><w>devn</w>clara is doing it&apos;s job correctly.</z><z id="t1458606099000020" t="devn I guess I&apos;m still interested in understanding exactly what&apos;s going on here"><y>#</y><d>2016-03-22</d><h>00:21</h><w>devn</w>I guess I&apos;m still interested in understanding exactly what&apos;s going on here</z><z id="t1458658494000021" t="mikerod devn: did you have an example of what broke somewhere?"><y>#</y><d>2016-03-22</d><h>14:54</h><w>mikerod</w>devn: did you have an example of what broke somewhere?</z><z id="t1458658501000022" t="mikerod is it the same as https://groups.google.com/forum/#!topic/clara-rules/F-8vcsZC2i4 ?"><y>#</y><d>2016-03-22</d><h>14:55</h><w>mikerod</w>is it the same as <a href="https://groups.google.com/forum/#!topic/clara-rules/F-8vcsZC2i4" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/F-8vcsZC2i4</a> ?</z><z id="t1458666165000023" t="devn @mikerod: yes"><y>#</y><d>2016-03-22</d><h>17:02</h><w>devn</w>@mikerod: yes</z><z id="t1458666180000024" t="devn That&apos;s the situation, which I guess makes good sense to me."><y>#</y><d>2016-03-22</d><h>17:03</h><w>devn</w>That&apos;s the situation, which I guess makes good sense to me.</z><z id="t1458666219000025" t="devn We don&apos;t need to retract here. I pushed back against the use of it, but it worked, until we bumped to 0.11.0 of course simple_smile"><y>#</y><d>2016-03-22</d><h>17:03</h><w>devn</w>We don&apos;t need to retract here. I pushed back against the use of it, but it worked, until we bumped to 0.11.0 of course <b>simple_smile</b></z><z id="t1458678087000026" t="mikerod devn: yeah, in that particular scenario the previous behavior was questionable"><y>#</y><d>2016-03-22</d><h>20:21</h><w>mikerod</w>devn: yeah, in that particular scenario the previous behavior was questionable</z><z id="t1458678119000027" t="mikerod The RHS is retracting the facts that are supporting the truth of the rule in general"><y>#</y><d>2016-03-22</d><h>20:21</h><w>mikerod</w>The RHS is retracting the facts that are supporting the truth of the rule in general</z><z id="t1458678168000028" t="mikerod This goes against the concept of logical truth maintenance of inserted facts. Retracts will often lead you into bad situations when it comes to truth maintenance. In this particular scenario, the rule shouldn&apos;t insert anything because anything it inserts loses its logical support immediately, due to the retract of all the recommendations."><y>#</y><d>2016-03-22</d><h>20:22</h><w>mikerod</w>This goes against the concept of logical truth maintenance of inserted facts.  Retracts will often lead you into bad situations when it comes to truth maintenance.  In this particular scenario, the rule shouldn&apos;t insert anything because anything it inserts loses its logical support immediately, due to the retract of all the recommendations.</z><z id="t1458678192000029" t="mikerod Looks like Will put more details on the Google groups though."><y>#</y><d>2016-03-22</d><h>20:23</h><w>mikerod</w>Looks like Will put more details on the Google groups though.</z><z id="t1458678257000030" t="mikerod In our use-cases, we avoid retracts pretty much completely. We like to rely on the logical truth maintenance of inserts to do any &quot;retracts&quot; for us. It does involve adding new fact types occasionally, which Clara&apos;s default is via :type metadata or the Java class hierarchy (on Java side) or JS hierarchy (on JS side)"><y>#</y><d>2016-03-22</d><h>20:24</h><w>mikerod</w>In our use-cases, we avoid retracts pretty much completely.  We like to rely on the logical truth maintenance of inserts to do any &quot;retracts&quot; for us.  It does involve adding new fact types occasionally, which Clara&apos;s default is via :type metadata or the Java class hierarchy (on Java side) or JS hierarchy (on JS side)</z><z id="t1458741699000032" t="ryanbrush Hey all, still out of town but I think @mikerod&apos;s answer here and @wparker&apos;s answer in the forum are on target. I kind of regret adding retract! at all since it&apos;s such an easy way to shoot oneself in the foot. (This isn&apos;t the first time it has caused confusion.) I&apos;m tempted to deprecate it, or move it into a specialized package to make it clear. I don&apos;t think there is a great way to &quot;fix&quot; retract! when interacting with truth maintenance, since it&apos;s semantics conflict with what the engine does. Looking back on it, it feels like it&apos;s the equivalent of a GOTO statement for expert systems."><y>#</y><d>2016-03-23</d><h>14:01</h><w>ryanbrush</w>Hey all, still out of town but I think @mikerod&apos;s answer here and @wparker&apos;s answer in the forum are on target. I kind of regret adding retract! at all since it&apos;s such an easy way to shoot oneself in the foot. (This isn&apos;t the first time it has caused confusion.) I&apos;m tempted to deprecate it, or move it into a specialized package to make it clear. I don&apos;t think there is a great way to &quot;fix&quot; retract! when interacting with truth maintenance, since it&apos;s semantics conflict with what the engine does. Looking back on it, it feels like it&apos;s the equivalent of a GOTO statement for expert systems.</z><z id="t1458747698000033" t="devn 👍"><y>#</y><d>2016-03-23</d><h>15:41</h><w>devn</w><b>👍</b></z><z id="t1458762891000034" t="mikerod so it is &quot;retract! considered harmful&quot;"><y>#</y><d>2016-03-23</d><h>19:54</h><w>mikerod</w>so it is &quot;retract! considered harmful&quot;</z><z id="t1458762907000035" t="mikerod maybe just a part of Clara docs that gives that big warning"><y>#</y><d>2016-03-23</d><h>19:55</h><w>mikerod</w>maybe just a part of Clara docs that gives that big warning</z><z id="t1460145526000040" t="devn @mikerod I am behind on the ML discussion, but I think there was some discussion of removing it altogether. Frankly, I&apos;m really happy to hear that."><y>#</y><d>2016-04-08</d><h>19:58</h><w>devn</w>@mikerod I am behind on the ML discussion, but I think there was some discussion of removing it altogether. Frankly, I&apos;m really happy to hear that.</z><z id="t1460152736000041" t="mikerod @devn perhaps. I think there may be valid usages, but they need to be constrained and perhaps we could see about reporting errors on the cases that have vague or ambiguous semantics"><y>#</y><d>2016-04-08</d><h>21:58</h><w>mikerod</w>@devn perhaps.  I think there may be valid usages, but they need to be constrained and perhaps we could see about reporting errors on the cases that have vague or ambiguous semantics</z><z id="t1460645810000043" t="saicheong I have just started learning clara. In clara-examples, the facts that are inserted into working memory are typically record type."><y>#</y><d>2016-04-14</d><h>14:56</h><w>saicheong</w>I have just started learning clara. In clara-examples, the facts that are inserted into working memory are typically record type.</z><z id="t1460645851000044" t="saicheong I wonder if &apos;primitive&apos; data can also be inserted - like Strings or Keywords."><y>#</y><d>2016-04-14</d><h>14:57</h><w>saicheong</w>I wonder if &apos;primitive&apos; data can also be inserted - like Strings or Keywords.</z><z id="t1460646054000045" t="saicheong How do we write the condition expression to match a keyword or a string?"><y>#</y><d>2016-04-14</d><h>15:00</h><w>saicheong</w>How do we write the condition expression to match a keyword or a string?</z><z id="t1460649895000046" t="devn @saicheong: https://github.com/rbrush/clara-rules/wiki/Guide#fact-types"><y>#</y><d>2016-04-14</d><h>16:04</h><w>devn</w>@saicheong: <a href="https://github.com/rbrush/clara-rules/wiki/Guide#fact-types" target="_blank">https://github.com/rbrush/clara-rules/wiki/Guide#fact-types</a></z><z id="t1460658917000048" t="ryanbrush @saicheong: By default you can any type known to Clojure&apos;s type function, which includes the Java class hierarchy (including Strings, or clojure.lang.Keyword, but that&apos;s not something I&apos;ve done.) If you need something more sophisticated, the link @devn posted is a good reference."><y>#</y><d>2016-04-14</d><h>18:35</h><w>ryanbrush</w>@saicheong: By default you can any type known to Clojure&apos;s type function, which includes the Java class hierarchy (including Strings, or clojure.lang.Keyword, but that&apos;s not something I&apos;ve done.) If you need something more sophisticated, the link @devn posted is a good reference.</z><z id="t1460676294000051" t="saicheong Say I have a rule that inserts a keyword :exceed-cap. Now I need to this keyword to match other rules. Will this expression in a rule match the keyword?: [clojure.lang.Keyword (= :exceed-cap)]"><y>#</y><d>2016-04-14</d><h>23:24</h><w>saicheong</w>Say I have a rule that inserts a keyword :exceed-cap. Now I need to this keyword to match other rules. Will this expression in a rule match the keyword?:
[clojure.lang.Keyword (= :exceed-cap)]</z><z id="t1460680717000052" t="devn @saicheong: I haven&apos;t done what you&apos;re describing. You could try it but something tells me that won&apos;t work."><y>#</y><d>2016-04-15</d><h>00:38</h><w>devn</w>@saicheong: I haven&apos;t done what you&apos;re describing. You could try it but something tells me that won&apos;t work.</z><z id="t1460680747000053" t="devn I am heading out otherwise I&apos;d help you out."><y>#</y><d>2016-04-15</d><h>00:39</h><w>devn</w>I am heading out otherwise I&apos;d help you out.</z><z id="t1460688693000054" t="wparker @saicheong: I believe the problem with the constraint you have there is that you’re calling = with one argument, which always returns false. The symbol “this” in rule constraints is bound to the fact under consideration; I believe you need to test that “this” is equal to :exceed-cap. Example gist: https://gist.github.com/WilliamParker/9cafbe73b2c3b99153fd3fcfc8daa4c3"><y>#</y><d>2016-04-15</d><h>02:51</h><w>wparker</w>@saicheong: I believe the problem with the constraint you have there is that you’re calling = with one argument, which always returns false.  The symbol “this” in rule constraints is bound to the fact under consideration; I believe you need to test that “this” is equal to :exceed-cap.  Example gist: <a href="https://gist.github.com/WilliamParker/9cafbe73b2c3b99153fd3fcfc8daa4c3" target="_blank">https://gist.github.com/WilliamParker/9cafbe73b2c3b99153fd3fcfc8daa4c3</a></z><z id="t1460689230000055" t="wparker One thing to keep in mind (without knowing anything about your use-case of course) is that one of the major optimizations of Clara (and the Rete algorithm it is based on more generally) is only testing facts against conditions that their type allows them to match. That is, if you inserted something that isn’t a Keyword into the example in the gist above, that equality check wouldn’t ever be tried. Checking equality against a keyword should be very, very fast though, just something to be aware of more generally. Of course, if your use case is small enough even thinking about that could be premature optimization."><y>#</y><d>2016-04-15</d><h>03:00</h><w>wparker</w>One thing to keep in mind (without knowing anything about your use-case of course) is that one of the major optimizations of Clara (and the Rete algorithm it is based on more generally) is only testing facts against conditions that their type allows them to match.  That is, if you inserted something that isn’t a Keyword into the example in the gist above, that equality check wouldn’t ever be tried.  Checking equality against a keyword should be very, very fast though, just something to be aware of more generally.  Of course, if your use case is small enough even thinking about that could be premature optimization.</z><z id="t1460689246000056" t="saicheong @devn: Thanks. I&apos;ll try it out when I get some time. "><y>#</y><d>2016-04-15</d><h>03:00</h><w>saicheong</w>@devn: Thanks. I&apos;ll try it out when I get some time. </z><z id="t1460689618000057" t="saicheong @wparker: thanks for the tip on using &apos;this&apos; in the expression. I&apos;ll try that out too. "><y>#</y><d>2016-04-15</d><h>03:06</h><w>saicheong</w>@wparker: thanks for the tip on using &apos;this&apos; in the expression. I&apos;ll try that out too. </z><z id="t1461598992000003" t="ryanbrush clara-rules 0.11.1 is up on Clojars. It&apos;s a fix release with some nice performance optimizations from @mikerod. Details in the change log: https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0111"><y>#</y><d>2016-04-25</d><h>15:43</h><w>ryanbrush</w>clara-rules 0.11.1 is up on Clojars. It&apos;s a fix release with some nice performance optimizations from @mikerod. Details in the change log: <a href="https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0111" target="_blank">https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0111</a></z><z id="t1461778412000005" t="devn Huzzah"><y>#</y><d>2016-04-27</d><h>17:33</h><w>devn</w>Huzzah</z><z id="t1461787141000006" t="mikerod devn: Is that a delayed celebration of the 0.11.1 release?"><y>#</y><d>2016-04-27</d><h>19:59</h><w>mikerod</w>devn: Is that a delayed celebration of the 0.11.1 release?</z><z id="t1461787143000007" t="mikerod 😛"><y>#</y><d>2016-04-27</d><h>19:59</h><w>mikerod</w><b>😛</b></z><z id="t1461787156000008" t="devn @mikerod: yes simple_smile"><y>#</y><d>2016-04-27</d><h>19:59</h><w>devn</w>@mikerod: yes <b>simple_smile</b></z><z id="t1461787188000009" t="mikerod Yeah, try it out. Report if you notice anything - good or bad."><y>#</y><d>2016-04-27</d><h>19:59</h><w>mikerod</w>Yeah, try it out.  Report if you notice anything - good or bad.</z><z id="t1461787206000010" t="mikerod In our case, it actually had a few fairly subtle changes that did help our performance"><y>#</y><d>2016-04-27</d><h>20:00</h><w>mikerod</w>In our case, it actually had a few fairly subtle changes that did help our performance</z><z id="t1461787209000011" t="devn will do, we&apos;re picking up development on the rules engine side of things in a week or so"><y>#</y><d>2016-04-27</d><h>20:00</h><w>devn</w>will do, we&apos;re picking up development on the rules engine side of things in a week or so</z><z id="t1461787217000012" t="devn but i can at least bump the version and run tests"><y>#</y><d>2016-04-27</d><h>20:00</h><w>devn</w>but i can at least bump the version and run tests</z><z id="t1461787220000013" t="devn and see how things shake out"><y>#</y><d>2016-04-27</d><h>20:00</h><w>devn</w>and see how things shake out</z><z id="t1461787228000014" t="mikerod Cool"><y>#</y><d>2016-04-27</d><h>20:00</h><w>mikerod</w>Cool</z><z id="t1461787241000015" t="devn thanks for all of your work"><y>#</y><d>2016-04-27</d><h>20:00</h><w>devn</w>thanks for all of your work</z><z id="t1461787266000016" t="mikerod No big deal. We are getting a lot of good use out of Clara so far and it is fun to work on."><y>#</y><d>2016-04-27</d><h>20:01</h><w>mikerod</w>No big deal.  We are getting a lot of good use out of Clara so far and it is fun to work on.</z><z id="t1461787367000017" t="mikerod Thanks for your feedback and contributions to it too!"><y>#</y><d>2016-04-27</d><h>20:02</h><w>mikerod</w>Thanks for your feedback and contributions to it too!</z><z id="t1465231096000002" t="devn Hello friends"><y>#</y><d>2016-06-06</d><h>16:38</h><w>devn</w>Hello friends</z><z id="t1465231211000003" t="devn Question for you... Provided: (defrecord DatedFact [date whatever]) (defrecord LatestFact [date whatever]) (def latest &quot;Accumulator for finding the maximum value of a :date field.&quot; (clara.acc/max (comp time.coerce/to-long :date) :returns-fact true)) (clara/defrule simple-latest-rule [?result &lt;- latest :from [DatedFact (= ?date date)]] =&gt; (clara.rules/insert! (map-&gt;LatestFact ?result))) (clara/defquery query-latest [] [?latest &lt;- LatestFact]) "><y>#</y><d>2016-06-06</d><h>16:40</h><w>devn</w>Question for you...

Provided:
<pre>(defrecord DatedFact [date whatever])
(defrecord LatestFact [date whatever])

(def latest
  &quot;Accumulator for finding the maximum value of a :date field.&quot;
  (clara.acc/max (comp time.coerce/to-long :date)
                 :returns-fact true))

(clara/defrule simple-latest-rule
  [?result &lt;- latest :from [DatedFact (= ?date date)]]
  =&gt;
  (clara.rules/insert! (map-&gt;LatestFact ?result)))

(clara/defquery query-latest [] [?latest &lt;- LatestFact])
</pre></z><z id="t1465231255000004" t="devn This will insert! for all DatedFacts ."><y>#</y><d>2016-06-06</d><h>16:40</h><w>devn</w>This will <code>insert!</code> for all <code>DatedFacts</code>.</z><z id="t1465231348000006" t="devn Without the constraint on (= ?date date) , it will fire only once."><y>#</y><d>2016-06-06</d><h>16:42</h><w>devn</w>Without the constraint on <code>(= ?date date)</code>, it will fire only once.</z><z id="t1465231437000008" t="devn I understand why this is so, but I guess I&apos;m interested to know what you think about how you&apos;d prevent this sort of thing from happening by rule authors."><y>#</y><d>2016-06-06</d><h>16:43</h><w>devn</w>I understand why this is so, but I guess I&apos;m interested to know what you think about how you&apos;d prevent this sort of thing from happening by rule authors.</z><z id="t1465232713000009" t="devn On second thought, I could use a good plain english explanation of why this is the case."><y>#</y><d>2016-06-06</d><h>17:05</h><w>devn</w>On second thought, I could use a good plain english explanation of why this is the case.</z><z id="t1465319844000010" t="ryanbrush Hey @devn, a good rule of thumb is that Clara will have one activation for each unique combination of bound variables. So when you remove the ?date binding in that accumulator, it just grabs the latest for all records and fires once. If you add a binding in an accumulator, it accumulates separately for each binding (?date in this case) and fires once per unique binding."><y>#</y><d>2016-06-07</d><h>17:17</h><w>ryanbrush</w>Hey @devn, a good rule of thumb is that Clara will have one activation for each unique combination of bound variables. So when you remove the ?date binding in that accumulator, it just grabs the latest for all records and fires once. If you add a binding in an accumulator, it accumulates separately for each binding (?date in this case) and fires once per unique binding.</z><z id="t1465320045000011" t="devn Thanks for that explanation. I was thinking about the binding on ?date being a sort of bucketing/grouping operation, so for each bucket of unique ?date values, capture the greatest date."><y>#</y><d>2016-06-07</d><h>17:20</h><w>devn</w>Thanks for that explanation. I was thinking about the binding on ?date being a sort of bucketing/grouping operation, so for each bucket of unique ?date values, capture the greatest date.</z><z id="t1465320122000012" t="devn using ?date there doesn&apos;t make much sense from a practical standpoint, since the accumulator pulls :date anyhow"><y>#</y><d>2016-06-07</d><h>17:22</h><w>devn</w>using ?date there doesn&apos;t make much sense from a practical standpoint, since the accumulator pulls :date anyhow</z><z id="t1465320128000013" t="ryanbrush Yeah, that&apos;s he idea."><y>#</y><d>2016-06-07</d><h>17:22</h><w>ryanbrush</w>Yeah, that&apos;s he idea.</z><z id="t1465320200000014" t="devn @ryanbrush: a loaded question: any thoughts on multiple sessions vs a single, shared session?"><y>#</y><d>2016-06-07</d><h>17:23</h><w>devn</w>@ryanbrush: a loaded question: any thoughts on multiple sessions vs a single, shared session?</z><z id="t1465320215000015" t="ryanbrush If you need richer semantics, you can always access any fields in the resulting accumulated value in the RHS, or even use a custom accumulator. But that depends on the use case"><y>#</y><d>2016-06-07</d><h>17:23</h><w>ryanbrush</w>If you need richer semantics, you can always access any fields in the resulting accumulated value in the RHS, or even use a custom accumulator. But that depends on the use case</z><z id="t1465320231000016" t="devn my question is sort of intentionally vague"><y>#</y><d>2016-06-07</d><h>17:23</h><w>devn</w>my question is sort of intentionally vague</z><z id="t1465320284000017" t="devn the big question is: are there common triggers in your mind for when to split out a new session using the results of queries on another session?"><y>#</y><d>2016-06-07</d><h>17:24</h><w>devn</w>the big question is: are there common triggers in your mind for when to split out a new session using the results of queries on another session?</z><z id="t1465320313000018" t="ryanbrush As for a single vs multiple sessions, just depends on what&apos;s easier to work with. We tend to use multiple sessions since there is very little overlap between them so it makes sense to keep separate. But YMMV."><y>#</y><d>2016-06-07</d><h>17:25</h><w>ryanbrush</w>As for a single vs multiple sessions, just depends on what&apos;s easier to work with. We tend to use multiple sessions since there is very little overlap between them so it makes sense to keep separate. But YMMV.</z><z id="t1465320388000019" t="ryanbrush But big sessions should perform pretty well, so whatever is simpler seems like a good starting point. We have sessions with 100k records and thousands of rules easily."><y>#</y><d>2016-06-07</d><h>17:26</h><w>ryanbrush</w>But big sessions should perform pretty well, so whatever is simpler seems like a good starting point. We have sessions with 100k records and thousands of rules  easily.</z><z id="t1465320436000020" t="devn thinking out loud: i guess it&apos;s like namespacing or anything else, it&apos;s just that there is a pretty pipeline-ish feel to what we&apos;ve built, and with the number of facts that are inserted for specific rule firings, it seems like there might be some valuable in splitting things out a bit more to make inspection easier"><y>#</y><d>2016-06-07</d><h>17:27</h><w>devn</w>thinking out loud: i guess it&apos;s like namespacing or anything else, it&apos;s just that there is a pretty pipeline-ish feel to what we&apos;ve built, and with the number of facts that are inserted for specific rule firings, it seems like there might be some valuable in splitting things out a bit more to make inspection easier</z><z id="t1465320464000021" t="devn then again, from the standpoint of providing explanations, there&apos;s some overhead associated with passing those facts through to another session"><y>#</y><d>2016-06-07</d><h>17:27</h><w>devn</w>then again, from the standpoint of providing explanations, there&apos;s some overhead associated with passing those facts through to another session</z><z id="t1465320518000022" t="devn since, for the purposes of a UI for instance, you need to capture the explanations from different sessions and cobble them together"><y>#</y><d>2016-06-07</d><h>17:28</h><w>devn</w>since, for the purposes of a UI for instance, you need to capture the explanations from different sessions and cobble them together</z><z id="t1465320531000023" t="devn not hard, really"><y>#</y><d>2016-06-07</d><h>17:28</h><w>devn</w>not hard, really</z><z id="t1465320538000024" t="devn just easier to have the single session"><y>#</y><d>2016-06-07</d><h>17:28</h><w>devn</w>just easier to have the single session</z><z id="t1465320554000025" t="ryanbrush Yeah. The old loose coupling/high cohesion design trade offs never really go away."><y>#</y><d>2016-06-07</d><h>17:29</h><w>ryanbrush</w>Yeah. The old loose coupling/high cohesion design trade offs never really go away.</z><z id="t1465320566000026" t="devn Speaking of UIs... 😉"><y>#</y><d>2016-06-07</d><h>17:29</h><w>devn</w>Speaking of UIs... <b>😉</b></z><z id="t1465320610000027" t="devn IIRC I think you said the tools.ui work is on hold/not gonna happen"><y>#</y><d>2016-06-07</d><h>17:30</h><w>devn</w>IIRC I think you said the tools.ui work is on hold/not gonna happen</z><z id="t1465320693000028" t="ryanbrush Yeah, not much is going on in that space now. It hasn&apos;t been a big need for us, so other demands have moved up. Happy to work with others that might be interested though."><y>#</y><d>2016-06-07</d><h>17:31</h><w>ryanbrush</w>Yeah, not much is going on in that space now. It hasn&apos;t been a big need for us, so other demands have moved up. Happy to work with others that might be interested though.</z><z id="t1465320733000029" t="ryanbrush (Oops....Need to drop offline for a bit here, but will be back on later in the day.)"><y>#</y><d>2016-06-07</d><h>17:32</h><w>ryanbrush</w>(Oops....Need to drop offline for a bit here, but will be back on later in the day.)</z><z id="t1465320842000030" t="devn It hasn&apos;t been a big need for us either, but generally speaking, onboarding people who haven&apos;t worked with a rules engine could be easier. I&apos;ve been thinking about whether it&apos;s a UI that I want, or if it&apos;s just better editor tooling to bring &quot;focus&quot; to specific rules, or parts of rules."><y>#</y><d>2016-06-07</d><h>17:34</h><w>devn</w>It hasn&apos;t been a big need for us either, but generally speaking, onboarding people who haven&apos;t worked with a rules engine could be easier. I&apos;ve been thinking about whether it&apos;s a UI that I want, or if it&apos;s just better editor tooling to bring &quot;focus&quot; to specific rules, or parts of rules.</z><z id="t1465321356000031" t="devn clara provides an opportunity to deliver good explanations. so, i wonder about a sort of meta-explain that could provide a more readable version of why a rule fired. I imagine in the above case seeing something like: For each DatedFact (of which there were 10), retrieve the latest fact for each unique ?foo value grouping. There were 3 unique ?foo values (`&quot;A&quot;, &quot;B&quot;, &quot;C&quot;`). As a result, 3 LatestFact facts were inserted into the session. Since you&apos;ve requested I focus my attention on the date field of LatestFact in my summaries, these are the date values on LatestFact which were inserted: 2016-05-10 , ..."><y>#</y><d>2016-06-07</d><h>17:42</h><w>devn</w>clara provides an opportunity to deliver good explanations. so, i wonder about a sort of meta-explain that could provide a more readable version of why a rule fired. I imagine in the above case seeing something like: For each DatedFact (of which there were 10), retrieve the <code>latest</code> fact for each unique <code>?foo</code> value grouping. There were 3 unique ?foo values (`&quot;A&quot;, &quot;B&quot;, &quot;C&quot;`). As a result, 3 <code>LatestFact</code> facts were inserted into the session. Since you&apos;ve requested I focus my attention on the <code>date</code> field of <code>LatestFact</code> in my summaries, these are the <code>date</code> values on <code>LatestFact</code> which were inserted: <code>2016-05-10</code>, ...</z><z id="t1465321669000033" t="devn I would of course settle for: &quot;Me take DatedFact , put unique ?foo in many bucket, put LatestFact with date of 2016-05-10 .&quot; 🙂"><y>#</y><d>2016-06-07</d><h>17:47</h><w>devn</w>I would of course settle for: &quot;Me take <code>DatedFact</code>, put unique <code>?foo</code> in many bucket, put <code>LatestFact</code> with <code>date</code> of <code>2016-05-10</code>.&quot; <b>🙂</b></z><z id="t1465321741000035" t="devn BTW, @mikerod &amp;&amp; @ryanbrush -- Excited to see the work and thought going into session durability. Thank you."><y>#</y><d>2016-06-07</d><h>17:49</h><w>devn</w>BTW, @mikerod &amp;&amp; @ryanbrush -- Excited to see the work and thought going into session durability. Thank you.</z><z id="t1465323001000036" t="mikerod devn: I&apos;d echo sort of what Ryan said that smaller sessions can work alright. If you have heavy-weight logic in rules though, it is good to share that if it applies to many other sessions. One idea would be to just derive facts for the common logic in one session, and then insert those facts into another new session later. That isn&apos;t too expensive if the hard-work is in the rules that make those derived facts."><y>#</y><d>2016-06-07</d><h>18:10</h><w>mikerod</w>devn: I&apos;d echo sort of what Ryan said that smaller sessions can work alright.  If you have heavy-weight logic in rules though, it is good to share that if it applies to many other sessions.  One idea would be to just derive facts for the common logic in one session, and then insert those facts into another new session later.  That isn&apos;t too expensive if the hard-work is in the rules that make those derived facts.</z><z id="t1465323066000037" t="mikerod devn: And yes, the durability stuff will be coming along hopefully in a timely manner. I&apos;m working on a prototype for it still currently and will keep design thoughts and discussions posted on the https://github.com/rbrush/clara-rules/issues/198 issue"><y>#</y><d>2016-06-07</d><h>18:11</h><w>mikerod</w>devn: And yes, the durability stuff will be coming along hopefully in a timely manner.  I&apos;m working on a prototype for it still currently and will keep design thoughts and discussions posted on the <a href="https://github.com/rbrush/clara-rules/issues/198" target="_blank">https://github.com/rbrush/clara-rules/issues/198</a> issue</z><z id="t1465323161000039" t="mikerod If you have any input there on how you&apos;d want it to work, I&apos;d be interested to hear that too. I have a use-case in mind, but it is good to know if there are any differing needs. I had a really rough demo of some thoughts @ https://github.com/mrrodriguez/clara-durability-demo but that would not be the expected way everyone would need to interface. I was just toying with an idea of being able to use an extension point like clojure.core/print-dup to give hooks for serialization."><y>#</y><d>2016-06-07</d><h>18:12</h><w>mikerod</w>If you have any input there on how you&apos;d want it to work, I&apos;d be interested to hear that too.  I have a use-case in mind, but it is good to know if there are any differing needs.  I had a really rough demo of some thoughts @ <a href="https://github.com/mrrodriguez/clara-durability-demo" target="_blank">https://github.com/mrrodriguez/clara-durability-demo</a> but that would not be the expected way everyone would need to interface.  I was just toying with an idea of being able to use an extension point like clojure.core/print-dup to give hooks for serialization.</z><z id="t1465323186000041" t="mikerod In our case, our working memory of the rules session will actually have different types of objects in them, like Java Serializable, Avro, Clojure records"><y>#</y><d>2016-06-07</d><h>18:13</h><w>mikerod</w>In our case, our working memory of the rules session will actually have different types of objects in them, like Java Serializable, Avro, Clojure records</z><z id="t1465323226000042" t="mikerod So I am messing around with ideas on how to efficiently provide capabilities to serialize this data when the serialization formats of groups of the data points actually, likely needs to vary.."><y>#</y><d>2016-06-07</d><h>18:13</h><w>mikerod</w>So I am messing around with ideas on how to efficiently provide capabilities to serialize this data when the serialization formats of groups of the data points actually, likely needs to vary..</z><z id="t1465428085000043" t="devn @mikerod: interesting to hear that you can even do that (have serializable, avro, clojure recs floating around in the session)"><y>#</y><d>2016-06-08</d><h>23:21</h><w>devn</w>@mikerod: interesting to hear that you can even do that (have serializable, avro, clojure recs floating around in the session)</z><z id="t1465428694000044" t="devn @mikerod: what does that look like in practice? Like, where do you use avro in a session?"><y>#</y><d>2016-06-08</d><h>23:31</h><w>devn</w>@mikerod: what does that look like in practice? Like, where do you use avro in a session?</z><z id="t1465605520000046" t="wparker @devn: There isn’t any barrier to having non-Clojure types in a session. For fields, Clara will just fall back to using JavaBean properties if it can. https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L165 You might get into trouble using things like Java primitives or maybe a falsey value, but I’d expect normal Java objects to work. As far as why, I work with @mikerod so I can speak to that; the short answer without saying too much is that while our group"><y>#</y><d>2016-06-11</d><h>00:38</h><w>wparker</w>@devn: There isn’t any barrier to having non-Clojure types in a session.  For fields, Clara will just fall back to using JavaBean properties if it can. <a href="https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L165" target="_blank">https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L165</a>  You might get into trouble using things like Java primitives or maybe a falsey value, but I’d expect normal Java objects to work.  As far as why, I work with @mikerod so I can speak to that; the short answer without saying too much is that while our group</z><z id="t1465605577000048" t="wparker group’s code is mostly in Clojure, we’re part of a larger Java system, and our external interaction points involve Avro records."><y>#</y><d>2016-06-11</d><h>00:39</h><w>wparker</w>group’s code is mostly in Clojure, we’re part of a larger Java system, and our external interaction points involve Avro records.</z><z id="t1465605883000049" t="wparker Oh, btw even though random Java objects are fine mutating them Java-style underneath the rules engine after inserting them isn’t, at least if you want predictable results 🙂"><y>#</y><d>2016-06-11</d><h>00:44</h><w>wparker</w>Oh, btw even though random Java objects are fine mutating them Java-style underneath the rules engine after inserting them isn’t, at least if you want predictable results <b>🙂</b></z><z id="t1465606783000050" t="devn @wparker: ah, so the avro records you deal with are beans?"><y>#</y><d>2016-06-11</d><h>00:59</h><w>devn</w>@wparker: ah, so the avro records you deal with are beans?</z><z id="t1465612692000051" t="wparker @devn correct. Not that facts have to be beans, it is just convenient for field access. You can always just use whatever functions/interop you want on the fact instead."><y>#</y><d>2016-06-11</d><h>02:38</h><w>wparker</w>@devn correct.  Not that facts have to be beans, it is just convenient for field access.  You can always just use whatever functions/interop you want on the fact instead.</z><z id="t1465612733000052" t="devn @wparker: i feel pretty daft asking, but again, im curious what an example of this looks like in clara&apos;s DSL"><y>#</y><d>2016-06-11</d><h>02:38</h><w>devn</w>@wparker: i feel pretty daft asking, but again, im curious what an example of this looks like in clara&apos;s DSL</z><z id="t1465612757000053" t="devn Are you talking about :fact-type-fn ?"><y>#</y><d>2016-06-11</d><h>02:39</h><w>devn</w>Are you talking about <code>:fact-type-fn</code>?</z><z id="t1465612792000054" t="devn Either way, I&apos;m curious to see (even a hackish, half-working) sample of this"><y>#</y><d>2016-06-11</d><h>02:39</h><w>devn</w>Either way, I&apos;m curious to see (even a hackish, half-working) sample of this</z><z id="t1465612808000055" t="devn We&apos;re talking about Avro a bit lately"><y>#</y><d>2016-06-11</d><h>02:40</h><w>devn</w>We&apos;re talking about Avro a bit lately</z><z id="t1465612890000056" t="devn i&apos;ve been musing about rules existing at other layers of our platform, which may select an existing avro schema, or produce a new one, for instance"><y>#</y><d>2016-06-11</d><h>02:41</h><w>devn</w>i&apos;ve been musing about rules existing at other layers of our platform, which may select an existing avro schema, or produce a new one, for instance</z><z id="t1465613043000057" t="devn @wparker: also, regarding #157 -- i honestly don&apos;t recall when we made that change, only that we observed cache misses due to ordering concerns"><y>#</y><d>2016-06-11</d><h>02:44</h><w>devn</w>@wparker: also, regarding #157 -- i honestly don&apos;t recall when we made that change, only that we observed cache misses due to ordering concerns</z><z id="t1465613087000058" t="wparker It would just look like anything else, say"><y>#</y><d>2016-06-11</d><h>02:44</h><w>wparker</w>It would just look like anything else, say</z><z id="t1465613175000059" t="wparker (defrule rule-using-bean [?fact &lt;- AvroFact (meets-some-condition? field-on-AvroFact)] =&gt; whatever-RHS-you-want)"><y>#</y><d>2016-06-11</d><h>02:46</h><w>wparker</w>(defrule rule-using-bean [?fact &lt;- AvroFact (meets-some-condition? field-on-AvroFact)] =&gt; whatever-RHS-you-want)</z><z id="t1465613213000060" t="wparker I suppose you could do interesting things with the fact-type-fn and Avro schemas, but that wasn’t what I was referring to"><y>#</y><d>2016-06-11</d><h>02:46</h><w>wparker</w>I suppose you could do interesting things with the fact-type-fn and Avro schemas, but that wasn’t what I was referring to</z><z id="t1465613247000061" t="wparker Say a fact-type-fn that used an Avro schema to determine the type."><y>#</y><d>2016-06-11</d><h>02:47</h><w>wparker</w>Say a fact-type-fn that used an Avro schema to determine the type.</z><z id="t1465613270000062" t="wparker But a generated Avro class can just be used like any other class"><y>#</y><d>2016-06-11</d><h>02:47</h><w>wparker</w>But a generated Avro class can just be used like any other class</z><z id="t1465613338000063" t="devn huh, i assumed there must be magic to make that work, but i must confess that my journey in programming has omitted serious java work, so while i understand chunks of the clojure compiler and such, i am often missing context w/r/t things like java beans"><y>#</y><d>2016-06-11</d><h>02:48</h><w>devn</w>huh, i assumed there must be magic to make that work, but i must confess that my journey in programming has omitted serious java work, so while i understand chunks of the clojure compiler and such, i am often missing context w/r/t things like java beans</z><z id="t1465613368000064" t="devn @wparker: thanks much for the explanation"><y>#</y><d>2016-06-11</d><h>02:49</h><w>devn</w>@wparker: thanks much for the explanation</z><z id="t1465613379000065" t="wparker Well, I haven’t personally created those Avro models, so I can’t exclude magic completely 🙂"><y>#</y><d>2016-06-11</d><h>02:49</h><w>wparker</w>Well, I haven’t personally created those Avro models, so I can’t exclude magic completely <b>🙂</b></z><z id="t1465613388000066" t="wparker But once you have classes, they are just that"><y>#</y><d>2016-06-11</d><h>02:49</h><w>wparker</w>But once you have classes, they are just that</z><z id="t1465613455000067" t="wparker You’re welcome"><y>#</y><d>2016-06-11</d><h>02:50</h><w>wparker</w>You’re welcome</z><z id="t1465613480000068" t="devn @wparker: also regarding 199 and your question about clojure equality, I don&apos;t think we&apos;ve ever done anything with activation groups"><y>#</y><d>2016-06-11</d><h>02:51</h><w>devn</w>@wparker: also regarding 199 and your question about clojure equality, I don&apos;t think we&apos;ve ever done anything with activation groups</z><z id="t1465613551000070" t="wparker Well, it wouldn’t have to be activation groups in particular, I was just choosing that as an example of one of the options to mk-session"><y>#</y><d>2016-06-11</d><h>02:52</h><w>wparker</w>Well, it wouldn’t have to be activation groups in particular, I was just choosing that as an example of one of the options to mk-session</z><z id="t1465613582000071" t="devn Date: Wed Dec 30 16:46:15 2015 -0600"><y>#</y><d>2016-06-11</d><h>02:53</h><w>devn</w><code>Date:   Wed Dec 30 16:46:15 2015 -0600</code></z><z id="t1465613595000072" t="wparker Caching is on rules + options, which makes sense since the options impact the session semantics"><y>#</y><d>2016-06-11</d><h>02:53</h><w>wparker</w>Caching is on rules + options, which makes sense since the options impact the session semantics</z><z id="t1465613648000073" t="devn so, #157 was Jan 12"><y>#</y><d>2016-06-11</d><h>02:54</h><w>devn</w>so, #157 was Jan 12</z><z id="t1465613651000074" t="devn 😄"><y>#</y><d>2016-06-11</d><h>02:54</h><w>devn</w><b>😄</b></z><z id="t1465613663000075" t="devn err, but closed Feb 4"><y>#</y><d>2016-06-11</d><h>02:54</h><w>devn</w>err, but closed Feb 4</z><z id="t1465613673000076" t="devn but, yeah, makes sense."><y>#</y><d>2016-06-11</d><h>02:54</h><w>devn</w>but, yeah, makes sense.</z><z id="t1465613777000077" t="devn Now I&apos;m curious to see if removing that call to (set) changes behavior"><y>#</y><d>2016-06-11</d><h>02:56</h><w>devn</w>Now I&apos;m curious to see if removing that call to <code>(set)</code> changes behavior</z><z id="t1465613863000078" t="wparker Do you mean trying with it removed on your code on the case that had a cache miss?"><y>#</y><d>2016-06-11</d><h>02:57</h><w>wparker</w>Do you mean trying with it removed on your code on the case that had a cache miss?</z><z id="t1465613873000080" t="devn yes"><y>#</y><d>2016-06-11</d><h>02:57</h><w>devn</w>yes</z><z id="t1465679148000002" t="devn @mikerod: http://dev.clojure.org/jira/browse/CLJ-1733"><y>#</y><d>2016-06-11</d><h>21:05</h><w>devn</w>@mikerod: <a href="http://dev.clojure.org/jira/browse/CLJ-1733" target="_blank">http://dev.clojure.org/jira/browse/CLJ-1733</a></z><z id="t1465679190000003" t="devn Was just walking through open clojure issues and wanted to drop it here since I saw you wrapping with #="><y>#</y><d>2016-06-11</d><h>21:06</h><w>devn</w>Was just walking through open clojure issues and wanted to drop it here since I saw you wrapping with <code>#=</code></z><z id="t1465784367000004" t="mikerod devn: thanks for the heads up. Yeah, my original demo is likely to not be all that close to what I end up going with. However, it is good to know where the hiccups are right now with the default impl&apos;s of print-dup and I forgot about this existing issue there."><y>#</y><d>2016-06-13</d><h>02:19</h><w>mikerod</w>devn: thanks for the heads up.  Yeah, my original demo is likely to not be all that close to what I end up going with.  However, it is good to know where the hiccups are right now with the default impl&apos;s of <code>print-dup</code> and I forgot about this existing issue there.</z><z id="t1465784432000005" t="devn @mikerod: it actually prompted me to do a general jira survey for &quot;dup&quot; issues. I was unable to figure out how to get JIRA to search for #= despite several attempts at various quoting and escaping schemes"><y>#</y><d>2016-06-13</d><h>02:20</h><w>devn</w>@mikerod: it actually prompted me to do a general jira survey for &quot;dup&quot; issues. I was unable to figure out how to get JIRA to search for #= despite several attempts at various quoting and escaping schemes</z><z id="t1465784517000006" t="devn actually, i wound up doing a walk over most of JIRA yesterday. I don&apos;t know that it was &quot;enjoyable&quot;, but focusing on the critical and high priority issues and reading them through was worth the time I think"><y>#</y><d>2016-06-13</d><h>02:21</h><w>devn</w>actually, i wound up doing a walk over most of JIRA yesterday. I don&apos;t know that it was &quot;enjoyable&quot;, but focusing on the critical and high priority issues and reading them through was worth the time I think</z><z id="t1465785485000007" t="mikerod devn: I think that is often a good idea&apos;"><y>#</y><d>2016-06-13</d><h>02:38</h><w>mikerod</w>devn: I think that is often a good idea&apos;</z><z id="t1465785500000008" t="mikerod I try to keep up with it somewhat, but it&apos;d be good to get a refresher over the bigger existing issues"><y>#</y><d>2016-06-13</d><h>02:38</h><w>mikerod</w>I try to keep up with it somewhat, but it&apos;d be good to get a refresher over the bigger existing issues</z><z id="t1465785514000009" t="mikerod I agree that searching for print-dup stuff is certainly a non-trivial one 🙂"><y>#</y><d>2016-06-13</d><h>02:38</h><w>mikerod</w>I agree that searching for print-dup stuff is certainly a non-trivial one <b>🙂</b></z><z id="t1465785524000010" t="devn it moves slow enough that if you give it a good look post-release, you&apos;ll know what&apos;s up for awhile"><y>#</y><d>2016-06-13</d><h>02:38</h><w>devn</w>it moves slow enough that if you give it a good look post-release, you&apos;ll know what&apos;s up for awhile</z><z id="t1465785545000011" t="mikerod I&apos;ve done a reasonable amount with print-dup before, but it is a lesser documented area and as you&apos;ve shown here, there are caveats"><y>#</y><d>2016-06-13</d><h>02:39</h><w>mikerod</w>I&apos;ve done a reasonable amount with <code>print-dup</code> before, but it is a lesser documented area and as you&apos;ve shown here, there are caveats</z><z id="t1465785555000012" t="mikerod yeah, I&apos;d think so"><y>#</y><d>2016-06-13</d><h>02:39</h><w>mikerod</w>yeah, I&apos;d think so</z><z id="t1465785591000013" t="devn heh, speaking of print-dup: I wrote a thing awhile back that took all of the sexps from the #C03S1KBA2 IRC channel going back to 2009"><y>#</y><d>2016-06-13</d><h>02:39</h><w>devn</w>heh, speaking of print-dup: I wrote a thing awhile back that took all of the sexps from the #C03S1KBA2 IRC channel going back to 2009</z><z id="t1465785605000014" t="devn and ran them in a sandbox, capturing output (if any), and value"><y>#</y><d>2016-06-13</d><h>02:40</h><w>devn</w>and ran them in a sandbox, capturing output (if any), and value</z><z id="t1465785679000015" t="devn I used print-dup to serialize the entire collection of results out to a file at some point, and i remember finding some tricky bits, but i don&apos;t remember details anymore"><y>#</y><d>2016-06-13</d><h>02:41</h><w>devn</w>I used print-dup to serialize the entire collection of results out to a file at some point, and i remember finding some tricky bits, but i don&apos;t remember details anymore</z><z id="t1465785745000016" t="devn despite the &quot;first rule of hash equals club is don&apos;t talk about hash equals&quot;, i remember it being quite solid back in 1.2, 1.3"><y>#</y><d>2016-06-13</d><h>02:42</h><w>devn</w>despite the &quot;first rule of hash equals club is don&apos;t talk about hash equals&quot;, i remember it being quite solid back in 1.2, 1.3</z><z id="t1465785793000017" t="devn there were at least 30k random examples serialized to a file, and read successfully, including Swing and all sorts of other nonsense"><y>#</y><d>2016-06-13</d><h>02:43</h><w>devn</w>there were at least 30k random examples serialized to a file, and read successfully, including Swing and all sorts of other nonsense</z><z id="t1465785884000018" t="devn though it&apos;s one of those things that Rich and Co. have basically said: use at your own risk, i have a hard time imagining it going away"><y>#</y><d>2016-06-13</d><h>02:44</h><w>devn</w>though it&apos;s one of those things that Rich and Co. have basically said: use at your own risk, i have a hard time imagining it going away</z><z id="t1465785967000019" t="devn Anyway, as long as I mentioned that project: http://getclojure.org/"><y>#</y><d>2016-06-13</d><h>02:46</h><w>devn</w>Anyway, as long as I mentioned that project: <a href="http://getclojure.org/" target="_blank">http://getclojure.org/</a></z><z id="t1465786023000020" t="devn It&apos;s nothing to write home about, and since it was all sandboxed, there are plenty of things which didn&apos;t pass the sniff test and were subsequently not run in the sandbox, but there&apos;s some interesting stuff in there, usually further into a search. A search for comp has results for the first few pages that are like (comp comp comp comp) for example, which is not very interesting."><y>#</y><d>2016-06-13</d><h>02:47</h><w>devn</w>It&apos;s nothing to write home about, and since it was all sandboxed, there are plenty of things which didn&apos;t pass the sniff test and were subsequently not run in the sandbox, but there&apos;s some interesting stuff in there, usually further into a search. A search for <code>comp</code> has results for the first few pages that are like <code>(comp comp comp comp)</code> for example, which is not very interesting.</z><z id="t1465786221000021" t="mikerod devn: sounds interesting"><y>#</y><d>2016-06-13</d><h>02:50</h><w>mikerod</w>devn: sounds interesting</z><z id="t1465786223000022" t="mikerod I&apos;ll ahve to look at that"><y>#</y><d>2016-06-13</d><h>02:50</h><w>mikerod</w>I&apos;ll ahve to look at that</z><z id="t1465786232000023" t="devn it&apos;s not really, i assure you 🙂"><y>#</y><d>2016-06-13</d><h>02:50</h><w>devn</w>it&apos;s not really, i assure you <b>🙂</b></z><z id="t1465786267000024" t="mikerod yeah, print-dup is weird. It seems to be, in some ways, a recommended approach to serialization of Clojure structures, but it is still not really fully &quot;official&quot;"><y>#</y><d>2016-06-13</d><h>02:51</h><w>mikerod</w>yeah, <code>print-dup</code> is weird.  It seems to be, in some ways, a recommended approach to serialization of Clojure structures, but it is still not really fully &quot;official&quot;</z><z id="t1465786268000025" t="devn i had dreams of building a sort of hoogle for clojure. codeq + clojure.tools.analyze + query over sexps, something like that"><y>#</y><d>2016-06-13</d><h>02:51</h><w>devn</w>i had dreams of building a sort of hoogle for clojure. codeq + clojure.tools.analyze + query over sexps, something like that</z><z id="t1465786280000026" t="mikerod it is primitive though. to use it successfully, you have to implement your own back references etc."><y>#</y><d>2016-06-13</d><h>02:51</h><w>mikerod</w>it is primitive though.  to use it successfully, you have to implement your own back references etc.</z><z id="t1465786294000028" t="mikerod if you have a lot of pointers to the same objects in memory or something like that."><y>#</y><d>2016-06-13</d><h>02:51</h><w>mikerod</w>if you have a lot of pointers to the same objects in memory or something like that.</z><z id="t1465786317000029" t="devn @mikerod: do you work with ryan, out of curiosity?"><y>#</y><d>2016-06-13</d><h>02:51</h><w>devn</w>@mikerod: do you work with ryan, out of curiosity?</z><z id="t1465786353000030" t="mikerod this website is interesting GetClojure"><y>#</y><d>2016-06-13</d><h>02:52</h><w>mikerod</w>this website is interesting GetClojure</z><z id="t1465786360000031" t="mikerod I think I remember looking at this a long while back perhaps?"><y>#</y><d>2016-06-13</d><h>02:52</h><w>mikerod</w>I think I remember looking at this a long while back perhaps?</z><z id="t1465786366000032" t="mikerod maybe you posted it somewhere before and I was curious"><y>#</y><d>2016-06-13</d><h>02:52</h><w>mikerod</w>maybe you posted it somewhere before and I was curious</z><z id="t1465786368000033" t="devn yeah, it&apos;s my first clojure project from the olden days"><y>#</y><d>2016-06-13</d><h>02:52</h><w>devn</w>yeah, it&apos;s my first clojure project from the olden days</z><z id="t1465786372000034" t="mikerod ah I see"><y>#</y><d>2016-06-13</d><h>02:52</h><w>mikerod</w>ah I see</z><z id="t1465786386000035" t="mikerod Yeah I work at the same company as Ryan. Also Will on here"><y>#</y><d>2016-06-13</d><h>02:53</h><w>mikerod</w>Yeah I work at the same company as Ryan.  Also Will on here</z><z id="t1465786398000036" t="mikerod w parker"><y>#</y><d>2016-06-13</d><h>02:53</h><w>mikerod</w>w parker</z><z id="t1465786437000037" t="devn i&apos;d like to understand clara internals better, but i think i need to start smaller and implement a dumb version of rete before I&apos;ll be of much use"><y>#</y><d>2016-06-13</d><h>02:53</h><w>devn</w>i&apos;d like to understand clara internals better, but i think i need to start smaller and implement a dumb version of rete before I&apos;ll be of much use</z><z id="t1465786450000038" t="devn (mostly for the purposes of contributing)"><y>#</y><d>2016-06-13</d><h>02:54</h><w>devn</w>(mostly for the purposes of contributing)</z><z id="t1465786457000039" t="mikerod devn: yeah, I actually find the codebase to be approachable, but it is good to have some background"><y>#</y><d>2016-06-13</d><h>02:54</h><w>mikerod</w>devn: yeah, I actually find the codebase to be approachable, but it is good to have some background</z><z id="t1465786486000040" t="mikerod clara.rules.engine is almost something you could look at stand-alone to reason about the way the Rete network propagates data around"><y>#</y><d>2016-06-13</d><h>02:54</h><w>mikerod</w>clara.rules.engine is almost something you could look at stand-alone to reason about the way the Rete network propagates data around</z><z id="t1465786497000041" t="mikerod clara.rules.compiler is more compilation complexity"><y>#</y><d>2016-06-13</d><h>02:54</h><w>mikerod</w>clara.rules.compiler is more compilation complexity</z><z id="t1465786520000042" t="mikerod builds the rete graph etc, but I think you can sort of gloss over that and just look at clara.rules.engine to get a good feel for how data moves around"><y>#</y><d>2016-06-13</d><h>02:55</h><w>mikerod</w>builds the rete graph etc, but I think you can sort of gloss over that and just look at clara.rules.engine to get a good feel for how data moves around</z><z id="t1465786537000043" t="devn is it crazy to think about building some instrumented visualization of the graph construction?"><y>#</y><d>2016-06-13</d><h>02:55</h><w>devn</w>is it crazy to think about building some instrumented visualization of the graph construction?</z><z id="t1465786538000044" t="mikerod writing a toy version of your own could be a good learning experience though I&apos;d imagine"><y>#</y><d>2016-06-13</d><h>02:55</h><w>mikerod</w>writing a toy version of your own could be a good learning experience though I&apos;d imagine</z><z id="t1465786549000045" t="mikerod I think that could be a cool and useful thing"><y>#</y><d>2016-06-13</d><h>02:55</h><w>mikerod</w>I think that could be a cool and useful thing</z><z id="t1465786551000046" t="devn sort of a stepping debugger or something"><y>#</y><d>2016-06-13</d><h>02:55</h><w>devn</w>sort of a stepping debugger or something</z><z id="t1465786561000047" t="mikerod I know that Ryan played some with some visualizations here and there"><y>#</y><d>2016-06-13</d><h>02:56</h><w>mikerod</w>I know that Ryan played some with some visualizations here and there</z><z id="t1465786595000048" t="mikerod however, nothing too serious yet. just demo&apos;s or trials of things I think"><y>#</y><d>2016-06-13</d><h>02:56</h><w>mikerod</w>however, nothing too serious yet.  just demo&apos;s or trials of things I think</z><z id="t1465786601000049" t="mikerod https://github.com/rbrush/clara-tools"><y>#</y><d>2016-06-13</d><h>02:56</h><w>mikerod</w><a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a></z><z id="t1465786623000051" t="mikerod and also, it may not visualize the graph like you are saying. Visualization has different sort of levels you may be interested in."><y>#</y><d>2016-06-13</d><h>02:57</h><w>mikerod</w>and also, it may not visualize the graph like you are saying.   Visualization has different sort of levels you may be interested in.</z><z id="t1465786637000052" t="devn yes, exactly"><y>#</y><d>2016-06-13</d><h>02:57</h><w>devn</w>yes, exactly</z><z id="t1465786653000053" t="devn there are layers to the explanation/visualization"><y>#</y><d>2016-06-13</d><h>02:57</h><w>devn</w>there are layers to the explanation/visualization</z><z id="t1465786673000054" t="mikerod There is an older paper referred to in the Clara wiki too"><y>#</y><d>2016-06-13</d><h>02:57</h><w>mikerod</w>There is an older paper referred to in the Clara wiki too</z><z id="t1465786673000055" t="mikerod https://github.com/rbrush/clara-rules/wiki/Introduction#the-rules-engine"><y>#</y><d>2016-06-13</d><h>02:57</h><w>mikerod</w><a href="https://github.com/rbrush/clara-rules/wiki/Introduction#the-rules-engine" target="_blank">https://github.com/rbrush/clara-rules/wiki/Introduction#the-rules-engine</a></z><z id="t1465786674000056" t="devn some of them useful at a domain level so people using our stuff can understand why a decision was rendered"><y>#</y><d>2016-06-13</d><h>02:57</h><w>devn</w>some of them useful at a domain level so people using our stuff can understand why a decision was rendered</z><z id="t1465786680000058" t="mikerod http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf this paper"><y>#</y><d>2016-06-13</d><h>02:58</h><w>mikerod</w><a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank">http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</a> this paper</z><z id="t1465786706000059" t="devn and then there&apos;s the &quot;i&apos;m a programmer, show me the hairier view, with data&quot;"><y>#</y><d>2016-06-13</d><h>02:58</h><w>devn</w>and then there&apos;s the &quot;i&apos;m a programmer, show me the hairier view, with data&quot;</z><z id="t1465786710000060" t="mikerod I found it to have a really good overview of Rete. It is certainly dated and lacking many of the optimizations and extensions to Rete present in Clara, but it is a good base."><y>#</y><d>2016-06-13</d><h>02:58</h><w>mikerod</w>I found it to have a really good overview of Rete.  It is certainly dated and lacking many of the optimizations and extensions to Rete present in Clara, but it is a good base.</z><z id="t1465786717000061" t="devn and then there&apos;s the &quot;i know kung fu, show me the internals&quot;"><y>#</y><d>2016-06-13</d><h>02:58</h><w>devn</w>and then there&apos;s the &quot;i know kung fu, show me the internals&quot;</z><z id="t1465786737000062" t="mikerod Yes. Visualization does seem to be a complex subject."><y>#</y><d>2016-06-13</d><h>02:58</h><w>mikerod</w>Yes.  Visualization does seem to be a complex subject.</z><z id="t1465786751000063" t="devn @mikerod: this is the paper clara is based off of yes?"><y>#</y><d>2016-06-13</d><h>02:59</h><w>devn</w>@mikerod: this is the paper clara is based off of yes?</z><z id="t1465786776000064" t="mikerod Yeah, I&apos;d say so. However, it is really just an overview of Rete more than anything."><y>#</y><d>2016-06-13</d><h>02:59</h><w>mikerod</w>Yeah, I&apos;d say so.  However, it is really just an overview of Rete more than anything.</z><z id="t1465786778000065" t="devn the question i had was: is it better start simpler, with rete - optimizations?"><y>#</y><d>2016-06-13</d><h>02:59</h><w>devn</w>the question i had was: is it better start simpler, with rete - optimizations?</z><z id="t1465786810000066" t="mikerod there are a few key chapters to it. it is long, but some of it isn&apos;t really all that relevant unless you are curious about the test system they were writing back in the 90s or whenever it was. 😛"><y>#</y><d>2016-06-13</d><h>03:00</h><w>mikerod</w>there are a few key chapters to it.  it is long, but some of it isn&apos;t really all that relevant unless you are curious about the test system they were writing back in the 90s or whenever it was.  <b>😛</b></z><z id="t1465786811000067" t="devn i have some books i picked up on CLIPS and OPS5. Some interesting stuff!"><y>#</y><d>2016-06-13</d><h>03:00</h><w>devn</w>i have some books i picked up on CLIPS and OPS5. Some interesting stuff!</z><z id="t1465786826000068" t="mikerod yeah, clips has good material"><y>#</y><d>2016-06-13</d><h>03:00</h><w>mikerod</w>yeah, clips has good material</z><z id="t1465786840000069" t="devn i mean, it&apos;s cool to see something lispy"><y>#</y><d>2016-06-13</d><h>03:00</h><w>devn</w>i mean, it&apos;s cool to see something lispy</z><z id="t1465786840000070" t="mikerod and OPS5. I&apos;ve read at least most of the Forgy paper"><y>#</y><d>2016-06-13</d><h>03:00</h><w>mikerod</w>and OPS5.  I&apos;ve read at least most of the Forgy paper</z><z id="t1465786851000071" t="devn even if the material is quite dated"><y>#</y><d>2016-06-13</d><h>03:00</h><w>devn</w>even if the material is quite dated</z><z id="t1465786864000072" t="mikerod I won&apos;t speak completely for Ryan, but I think he had some inspiration from http://herzberg.ca.sandia.gov/"><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>I won&apos;t speak completely for Ryan, but I think he had some inspiration from <a href="http://herzberg.ca.sandia.gov/" target="_blank">http://herzberg.ca.sandia.gov/</a></z><z id="t1465786866000073" t="mikerod as well"><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>as well</z><z id="t1465786868000074" t="mikerod Jess"><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>Jess</z><z id="t1465786879000075" t="mikerod At least in the fact that it used a Lisp DSL, ran on the JVM"><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>At least in the fact that it used a Lisp DSL, ran on the JVM</z><z id="t1465786887000076" t="devn oh, nice! this is great! thanks!"><y>#</y><d>2016-06-13</d><h>03:01</h><w>devn</w>oh, nice! this is great! thanks!</z><z id="t1465786891000077" t="mikerod Clojure is just here now, and makes it more awesome (in my opinion)"><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>Clojure is just here now, and makes it more awesome (in my opinion)</z><z id="t1465786910000078" t="mikerod Jess has good documentation here though. Including on some Rete extensions like accumulators."><y>#</y><d>2016-06-13</d><h>03:01</h><w>mikerod</w>Jess has good documentation here though.  Including on some Rete extensions like accumulators.</z><z id="t1465786926000079" t="mikerod I&apos;ve read most, if not all, of the Jess wiki docs accessible via this link."><y>#</y><d>2016-06-13</d><h>03:02</h><w>mikerod</w>I&apos;ve read most, if not all, of the Jess wiki docs accessible via this link.</z><z id="t1465786961000080" t="devn i keep tinkering with the idea (yet another project that is on hold due to the amount of time i have) of a datomic-driven rules engine"><y>#</y><d>2016-06-13</d><h>03:02</h><w>devn</w>i keep tinkering with the idea (yet another project that is on hold due to the amount of time i have) of a datomic-driven rules engine</z><z id="t1465786996000081" t="mikerod Yeah, that has seemed like an interesting idea to me before as well"><y>#</y><d>2016-06-13</d><h>03:03</h><w>mikerod</w>Yeah, that has seemed like an interesting idea to me before as well</z><z id="t1465787018000082" t="devn reified transactions a la Tim Ewald (sagas) here: http://www.datomic.com/videos.html"><y>#</y><d>2016-06-13</d><h>03:03</h><w>devn</w>reified transactions a la Tim Ewald (sagas) here: <a href="http://www.datomic.com/videos.html" target="_blank">http://www.datomic.com/videos.html</a></z><z id="t1465787020000084" t="mikerod I haven&apos;t done much with Datomic other than listen to a bunch about it and read up on it. I&apos;ve liked a lot of the ideas etc there and hope to work with it at some point"><y>#</y><d>2016-06-13</d><h>03:03</h><w>mikerod</w>I haven&apos;t done much with Datomic other than listen to a bunch about it and read up on it.  I&apos;ve liked a lot of the ideas etc there and hope to work with it at some point</z><z id="t1465787058000085" t="mikerod I don&apos;t think I&apos;ve watched these ones yet. I will. Looks like a good set of videos"><y>#</y><d>2016-06-13</d><h>03:04</h><w>mikerod</w>I don&apos;t think I&apos;ve watched these ones yet.  I will.  Looks like a good set of videos</z><z id="t1465787069000086" t="devn i know that there have been at least two rules engines built on datomic which are not open source (sad face)"><y>#</y><d>2016-06-13</d><h>03:04</h><w>devn</w>i know that there have been at least two rules engines built on datomic which are not open source (sad face)</z><z id="t1465787088000087" t="devn one of them, as i understand it, had all the fixins (truth maintenance, etc.)"><y>#</y><d>2016-06-13</d><h>03:04</h><w>devn</w>one of them, as i understand it, had all the fixins (truth maintenance, etc.)</z><z id="t1465787094000088" t="mikerod Oh, also on Rete. I follow Drools stuff a fair amount too. Drools has pushed the bar with optimizations and has a lot of good extensions and documentation as well."><y>#</y><d>2016-06-13</d><h>03:04</h><w>mikerod</w>Oh, also on Rete.  I follow Drools stuff a fair amount too.  Drools has pushed the bar with optimizations and has a lot of good extensions and documentation as well.</z><z id="t1465787118000089" t="mikerod Oh. Unfortunate neither is open source then"><y>#</y><d>2016-06-13</d><h>03:05</h><w>mikerod</w>Oh.  Unfortunate neither is open source then</z><z id="t1465787148000090" t="devn yeah, though it just makes my curiosity a bit more intense"><y>#</y><d>2016-06-13</d><h>03:05</h><w>devn</w>yeah, though it just makes my curiosity a bit more intense</z><z id="t1465787186000091" t="devn query in datomic is basically the LHS."><y>#</y><d>2016-06-13</d><h>03:06</h><w>devn</w>query in datomic is basically the LHS.</z><z id="t1465787253000092" t="devn the datomic thing is most interesting to me i think because most rules engines (as far as i understand it) do not address temporal concerns"><y>#</y><d>2016-06-13</d><h>03:07</h><w>devn</w>the datomic thing is most interesting to me i think because most rules engines (as far as i understand it) do not address temporal concerns</z><z id="t1465787292000093" t="devn this is partly why durability is interesting to me: &quot;show me what would have happened as of a point in time&quot;, or &quot;show me what it would look like if the rule base contained this rule, without committing it&quot;"><y>#</y><d>2016-06-13</d><h>03:08</h><w>devn</w>this is partly why durability is interesting to me: &quot;show me what would have happened as of a point in time&quot;, or &quot;show me what it would look like if the rule base contained this rule, without committing it&quot;</z><z id="t1465787310000094" t="mikerod devn: yeah, temporal concerns can be a wrench"><y>#</y><d>2016-06-13</d><h>03:08</h><w>mikerod</w>devn: yeah, temporal concerns can be a wrench</z><z id="t1465787313000095" t="mikerod in things*"><y>#</y><d>2016-06-13</d><h>03:08</h><w>mikerod</w>in things*</z><z id="t1465787320000096" t="mikerod I think Drools has tried to work with temporal concerns some"><y>#</y><d>2016-06-13</d><h>03:08</h><w>mikerod</w>I think Drools has tried to work with temporal concerns some</z><z id="t1465787324000097" t="mikerod I haven&apos;t read up on it much at this point"><y>#</y><d>2016-06-13</d><h>03:08</h><w>mikerod</w>I haven&apos;t read up on it much at this point</z><z id="t1465787328000098" t="mikerod &quot;events&quot; i think they ccall it"><y>#</y><d>2016-06-13</d><h>03:08</h><w>mikerod</w>&quot;events&quot; i think they ccall it</z><z id="t1465787340000099" t="devn interesting, googles"><y>#</y><d>2016-06-13</d><h>03:09</h><w>devn</w>interesting, googles</z><z id="t1465787375000100" t="devn so, i&apos;ve only read a couple of sentences while skimming the docs, but very interesting"><y>#</y><d>2016-06-13</d><h>03:09</h><w>devn</w>so, i&apos;ve only read a couple of sentences while skimming the docs, but very interesting</z><z id="t1465787387000101" t="mikerod http://docs.jboss.org/drools/release/6.4.0.Final/drools-docs/html_single/#DroolsComplexEventProcessingChapter"><y>#</y><d>2016-06-13</d><h>03:09</h><w>mikerod</w><a href="http://docs.jboss.org/drools/release/6.4.0.Final/drools-docs/html_single/#DroolsComplexEventProcessingChapter" target="_blank">http://docs.jboss.org/drools/release/6.4.0.Final/drools-docs/html_single/#DroolsComplexEventProcessingChapter</a></z><z id="t1465787388000102" t="devn &quot;Complex Event Processing, or CEP, is primarily an event processing concept that deals with the task of processing multiple events with the goal of identifying the meaningful events within the event cloud. CEP employs techniques such as detection of complex patterns of many events, event correlation and abstraction, event hierarchies, and relationships between events such as causality, membership, and timing, and event-driven processes.&quot; "><y>#</y><d>2016-06-13</d><h>03:09</h><w>devn</w><pre>&quot;Complex Event Processing, or CEP, is primarily an event processing concept that deals with the task of processing multiple events with the goal of identifying the meaningful events within the event cloud. CEP employs techniques such as detection of complex patterns of many events, event correlation and abstraction, event hierarchies, and relationships between events such as causality, membership, and timing, and event-driven processes.&quot;
</pre></z><z id="t1465787417000103" t="mikerod yeah, that may be the sort of thought you&apos;re thinking about"><y>#</y><d>2016-06-13</d><h>03:10</h><w>mikerod</w>yeah, that may be the sort of thought you&apos;re thinking about</z><z id="t1465787439000104" t="mikerod I know Ryan has said a little on the topic of dealing with temporal &quot;events&quot; as well, but I&apos;m not sure how much its been thought out yet"><y>#</y><d>2016-06-13</d><h>03:10</h><w>mikerod</w>I know Ryan has said a little on the topic of dealing with temporal &quot;events&quot; as well, but I&apos;m not sure how much its been thought out yet</z><z id="t1465787481000105" t="mikerod Clara durability of session state (working memory) is going to be important to the work I&apos;m doing right now, so that should keep progressing. We haven&apos;t needed anything more complex as of yet."><y>#</y><d>2016-06-13</d><h>03:11</h><w>mikerod</w>Clara durability of session state (working memory) is going to be important to the work I&apos;m doing right now, so that should keep progressing.  We haven&apos;t needed anything more complex as of yet.</z><z id="t1465787499000106" t="mikerod To us, we&apos;ve just thought of retracted facts if things change in the future"><y>#</y><d>2016-06-13</d><h>03:11</h><w>mikerod</w>To us, we&apos;ve just thought of retracted facts if things change in the future</z><z id="t1465787518000107" t="mikerod and inserted a new fact if there was a &quot;change&quot;"><y>#</y><d>2016-06-13</d><h>03:11</h><w>mikerod</w>and inserted a new fact if there was a &quot;change&quot;</z><z id="t1465787527000108" t="mikerod I&apos;m sure this can be limiting if you have more complex use-cases"><y>#</y><d>2016-06-13</d><h>03:12</h><w>mikerod</w>I&apos;m sure this can be limiting if you have more complex use-cases</z><z id="t1465787529000109" t="devn we deal with a lot of sparse data, and so a fair amount of work is done to validate concepts, those concepts are then turned into facts. i&apos;d sort of like to extend rules to the problem of validation and creation of concepts"><y>#</y><d>2016-06-13</d><h>03:12</h><w>devn</w>we deal with a lot of sparse data, and so a fair amount of work is done to validate concepts, those concepts are then turned into facts. i&apos;d sort of like to extend rules to the problem of validation and creation of concepts</z><z id="t1465787580000110" t="mikerod interesting"><y>#</y><d>2016-06-13</d><h>03:13</h><w>mikerod</w>interesting</z><z id="t1465787631000111" t="devn we of course build up concepts inside the engine, too"><y>#</y><d>2016-06-13</d><h>03:13</h><w>devn</w>we of course build up concepts inside the engine, too</z><z id="t1465787681000112" t="devn but there&apos;s a sort of ETL-like process that varies a lot. i imagine a sort of rule-based ETL"><y>#</y><d>2016-06-13</d><h>03:14</h><w>devn</w>but there&apos;s a sort of ETL-like process that varies a lot. i imagine a sort of rule-based ETL</z><z id="t1465787693000113" t="mikerod sounds doable"><y>#</y><d>2016-06-13</d><h>03:14</h><w>mikerod</w>sounds doable</z><z id="t1465787738000114" t="devn yeah, certainly, just haven&apos;t had the stomach for it, because i think there&apos;s tooling i&apos;d want to build to manage this process and have decent visibility into it"><y>#</y><d>2016-06-13</d><h>03:15</h><w>devn</w>yeah, certainly, just haven&apos;t had the stomach for it, because i think there&apos;s tooling i&apos;d want to build to manage this process and have decent visibility into it</z><z id="t1465787803000115" t="mikerod well if you come up with good tooling ideas that&apos;d help on the Clara end, I&apos;m sure we&apos;d all be happy to hear about them"><y>#</y><d>2016-06-13</d><h>03:16</h><w>mikerod</w>well if you come up with good tooling ideas that&apos;d help on the Clara end, I&apos;m sure we&apos;d all be happy to hear about them</z><z id="t1465787825000116" t="devn I mean, I&apos;m as much interested in providing ideas as I am hearing about them."><y>#</y><d>2016-06-13</d><h>03:17</h><w>devn</w>I mean, I&apos;m as much interested in providing ideas as I am hearing about them.</z><z id="t1465787849000117" t="mikerod haha"><y>#</y><d>2016-06-13</d><h>03:17</h><w>mikerod</w>haha</z><z id="t1465787864000118" t="mikerod yeah, visibility is something we should strive for"><y>#</y><d>2016-06-13</d><h>03:17</h><w>mikerod</w>yeah, visibility is something we should strive for</z><z id="t1465787887000119" t="mikerod our current push this release round is probably going to center on performance and then this durability thing"><y>#</y><d>2016-06-13</d><h>03:18</h><w>mikerod</w>our current push this release round is probably going to center on performance and then this durability thing</z><z id="t1465787919000120" t="devn As I said, I don&apos;t feel like I have a good enough handle on internals to say: &quot;here&apos;s a great idea!&quot; because I worry that the performance overhead will be insane, or that i&apos;ll be unable to capture some key piece of information necessary to the idea without reworking some significant piece of Clara"><y>#</y><d>2016-06-13</d><h>03:18</h><w>devn</w>As I said, I don&apos;t feel like I have a good enough handle on internals to say: &quot;here&apos;s a great idea!&quot; because I worry that the performance overhead will be insane, or that i&apos;ll be unable to capture some key piece of information necessary to the idea without reworking some significant piece of Clara</z><z id="t1465787935000121" t="mikerod but thinking more on what can be done for visualization, &quot;explainability&quot;, etc should stay imoprtant"><y>#</y><d>2016-06-13</d><h>03:18</h><w>mikerod</w>but thinking more on what can be done for visualization, &quot;explainability&quot;, etc should stay imoprtant</z><z id="t1465787962000122" t="devn the explanation piece is one of many reasons why we chose a rules engine"><y>#</y><d>2016-06-13</d><h>03:19</h><w>devn</w>the explanation piece is one of many reasons why we chose a rules engine</z><z id="t1465787966000123" t="devn but it&apos;s a really, really big one"><y>#</y><d>2016-06-13</d><h>03:19</h><w>devn</w>but it&apos;s a really, really big one</z><z id="t1465787985000124" t="mikerod https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc"><y>#</y><d>2016-06-13</d><h>03:19</h><w>mikerod</w><a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc</a></z><z id="t1465787997000126" t="mikerod the listener stuff here has some leverage"><y>#</y><d>2016-06-13</d><h>03:19</h><w>mikerod</w>the listener stuff here has some leverage</z><z id="t1465788006000127" t="devn it&apos;s extremely important for us to say: &quot;We recommend these actions based on the following information related to the patient, provider, etc.&quot;"><y>#</y><d>2016-06-13</d><h>03:20</h><w>devn</w>it&apos;s extremely important for us to say: &quot;We recommend these actions based on the following information related to the patient, provider, etc.&quot;</z><z id="t1465788022000128" t="mikerod mostly just keeping tracing sort of information in data structures that can be hooked on by whatever tooling"><y>#</y><d>2016-06-13</d><h>03:20</h><w>mikerod</w>mostly just keeping tracing sort of information in data structures that can be hooked on by whatever tooling</z><z id="t1465788022000129" t="devn with a sort of decision tree that people with a clinical background can use to validate those recommendations"><y>#</y><d>2016-06-13</d><h>03:20</h><w>devn</w>with a sort of decision tree that people with a clinical background can use to validate those recommendations</z><z id="t1465788039000130" t="mikerod devn: yeah, we&apos;ve had similar sort of use-cases with rules"><y>#</y><d>2016-06-13</d><h>03:20</h><w>mikerod</w>devn: yeah, we&apos;ve had similar sort of use-cases with rules</z><z id="t1465788058000131" t="mikerod so far, what we&apos;ve mostly done - which has been sufficient - was to just show the support &quot;chain&quot;"><y>#</y><d>2016-06-13</d><h>03:20</h><w>mikerod</w>so far, what we&apos;ve mostly done - which has been sufficient - was to just show the support &quot;chain&quot;</z><z id="t1465788070000132" t="mikerod we either manually write rules to do so, or we built some automatic helpers around insert&apos;s"><y>#</y><d>2016-06-13</d><h>03:21</h><w>mikerod</w>we either manually write rules to do so, or we built some automatic helpers around insert&apos;s</z><z id="t1465788119000133" t="mikerod (defrule my-rule [?s &lt;- SomeFact] =&gt; (insert! (map-&gt;AnotherFact {:something blah :support [?s]})))"><y>#</y><d>2016-06-13</d><h>03:21</h><w>mikerod</w><code>(defrule my-rule [?s &lt;- SomeFact] =&gt; (insert! (map-&gt;AnotherFact {:something blah :support [?s]})))</code></z><z id="t1465788121000134" t="devn I committed some code as part of an early spike on clara which added a :contributing-factors {} k/v in the RHS"><y>#</y><d>2016-06-13</d><h>03:22</h><w>devn</w>I committed some code as part of an early spike on clara which added a <code>:contributing-factors {}</code> k/v in the RHS</z><z id="t1465788126000135" t="devn ha! so i&apos;m not crazy!"><y>#</y><d>2016-06-13</d><h>03:22</h><w>devn</w>ha! so i&apos;m not crazy!</z><z id="t1465788143000136" t="mikerod yes, we have implemented some ideas around this. not in Clara directly, just in our own projects"><y>#</y><d>2016-06-13</d><h>03:22</h><w>mikerod</w>yes, we have implemented some ideas around this.  not in Clara directly, just in our own projects</z><z id="t1465788146000137" t="devn i&apos;ve been looking at that sideways and thinking: hmmm, this feels weird to me"><y>#</y><d>2016-06-13</d><h>03:22</h><w>devn</w>i&apos;ve been looking at that sideways and thinking: hmmm, this feels weird to me</z><z id="t1465788167000138" t="devn particularly because over the course of the &quot;chain&quot;, things can get a little sticky"><y>#</y><d>2016-06-13</d><h>03:22</h><w>devn</w>particularly because over the course of the &quot;chain&quot;, things can get a little sticky</z><z id="t1465788168000139" t="mikerod we&apos;ve defined protocols or something as well that can sort of walk the &quot;contributing facts&quot; chain"><y>#</y><d>2016-06-13</d><h>03:22</h><w>mikerod</w>we&apos;ve defined protocols or something as well that can sort of walk the &quot;contributing facts&quot; chain</z><z id="t1465788184000140" t="devn you might need to merge multiple :contributing-factors across the results of queries in order to get the real picture"><y>#</y><d>2016-06-13</d><h>03:23</h><w>devn</w>you might need to merge multiple :contributing-factors across the results of queries in order to get the real picture</z><z id="t1465788190000141" t="mikerod yeah"><y>#</y><d>2016-06-13</d><h>03:23</h><w>mikerod</w>yeah</z><z id="t1465788192000142" t="devn and then you have to wrestle with order"><y>#</y><d>2016-06-13</d><h>03:23</h><w>devn</w>and then you have to wrestle with order</z><z id="t1465788199000143" t="mikerod visualizing it int he end can get interesting"><y>#</y><d>2016-06-13</d><h>03:23</h><w>mikerod</w>visualizing it int he end can get interesting</z><z id="t1465788208000144" t="devn or overwhelming 😄"><y>#</y><d>2016-06-13</d><h>03:23</h><w>devn</w>or overwhelming <b>😄</b></z><z id="t1465788216000145" t="mikerod yeah"><y>#</y><d>2016-06-13</d><h>03:23</h><w>mikerod</w>yeah</z><z id="t1465788236000146" t="mikerod we&apos;ve sort of just &quot;flattened&quot; the chain up to certain points where there is a meaningful user-defined name"><y>#</y><d>2016-06-13</d><h>03:23</h><w>mikerod</w>we&apos;ve sort of just &quot;flattened&quot; the chain up to certain points where there is a meaningful user-defined name</z><z id="t1465788239000147" t="devn or at least, the visualizations ive come up with are like: oh god, no nurse is ever going to look at this"><y>#</y><d>2016-06-13</d><h>03:23</h><w>devn</w>or at least, the visualizations ive come up with are like: oh god, no nurse is ever going to look at this</z><z id="t1465788267000148" t="mikerod so it&apos;s sort of hierarchical, but flattened out just to where we have some sort of meaningful name to show end-users"><y>#</y><d>2016-06-13</d><h>03:24</h><w>mikerod</w>so it&apos;s sort of hierarchical, but flattened out just to where we have some sort of meaningful name to show end-users</z><z id="t1465788270000149" t="devn @mikerod: yeah, i think i was close, but the user-defined name is important"><y>#</y><d>2016-06-13</d><h>03:24</h><w>devn</w>@mikerod: yeah, i think i was close, but the user-defined name is important</z><z id="t1465788299000150" t="devn InternalRecordThatExposesImplementationDetails {?x 1, ...} =&gt; no bueno"><y>#</y><d>2016-06-13</d><h>03:24</h><w>devn</w><code>InternalRecordThatExposesImplementationDetails {?x 1, ...}</code> =&gt; no bueno</z><z id="t1465788307000151" t="mikerod yeah, definitely don&apos;t want that"><y>#</y><d>2016-06-13</d><h>03:25</h><w>mikerod</w>yeah, definitely don&apos;t want that</z><z id="t1465788333000152" t="devn the bindings which wind up being worth a damn, again due to sparse data, can be troublesome also"><y>#</y><d>2016-06-13</d><h>03:25</h><w>devn</w>the bindings which wind up being worth a damn, again due to sparse data, can be troublesome also</z><z id="t1465788344000153" t="mikerod yep"><y>#</y><d>2016-06-13</d><h>03:25</h><w>mikerod</w>yep</z><z id="t1465788346000154" t="devn you don&apos;t want to expose bindings which didn&apos;t matter at a particular conceptual level"><y>#</y><d>2016-06-13</d><h>03:25</h><w>devn</w>you don&apos;t want to expose bindings which didn&apos;t matter at a particular conceptual level</z><z id="t1465788353000155" t="devn but then, they turn out to be valuable in some future rule"><y>#</y><d>2016-06-13</d><h>03:25</h><w>devn</w>but then, they turn out to be valuable in some future rule</z><z id="t1465788358000156" t="mikerod yeah, so it is hard to automate and just assume &quot;all bindings&quot;"><y>#</y><d>2016-06-13</d><h>03:25</h><w>mikerod</w>yeah, so it is hard to automate and just assume &quot;all bindings&quot;</z><z id="t1465788382000157" t="mikerod you could mark fact types in some way or another htat are &quot;internal details&quot; vs meaningful though"><y>#</y><d>2016-06-13</d><h>03:26</h><w>mikerod</w>you could mark fact types in some way or another htat are &quot;internal details&quot; vs meaningful though</z><z id="t1465788427000158" t="mikerod (defrule [?f &lt;- ImplDetailThing] [?f2 &lt;- Meaningful] =&gt; (insert! (map-&gt;Fact {:val something :support [?f ?f2]})))"><y>#</y><d>2016-06-13</d><h>03:27</h><w>mikerod</w><code>(defrule [?f &lt;- ImplDetailThing] [?f2 &lt;- Meaningful] =&gt; (insert! (map-&gt;Fact {:val something :support [?f ?f2]})))</code></z><z id="t1465788429000159" t="devn I&apos;m now generating records (using eval, don&apos;t hate me) that pull from a big old map of domain concepts =&gt; data definitions"><y>#</y><d>2016-06-13</d><h>03:27</h><w>devn</w>I&apos;m now generating records (using eval, don&apos;t hate me) that pull from a big old map of domain concepts =&gt; data definitions</z><z id="t1465788434000160" t="mikerod so just like automate attaching all bindings as support"><y>#</y><d>2016-06-13</d><h>03:27</h><w>mikerod</w>so just like automate attaching all bindings as support</z><z id="t1465788448000161" t="mikerod but then when walking the chain later, dropping out stuff in the chain/tree that isn&apos;t useful"><y>#</y><d>2016-06-13</d><h>03:27</h><w>mikerod</w>but then when walking the chain later, dropping out stuff in the chain/tree that isn&apos;t useful</z><z id="t1465788449000162" t="devn @mikerod: ah, that&apos;s a good idea."><y>#</y><d>2016-06-13</d><h>03:27</h><w>devn</w>@mikerod: ah, that&apos;s a good idea.</z><z id="t1465788469000163" t="devn haven&apos;t played with a specific fact type"><y>#</y><d>2016-06-13</d><h>03:27</h><w>devn</w>haven&apos;t played with a specific fact type</z><z id="t1465788475000164" t="devn (for capturing the meaningful bits)"><y>#</y><d>2016-06-13</d><h>03:27</h><w>devn</w>(for capturing the meaningful bits)</z><z id="t1465788500000165" t="mikerod yeah, could think of a protocol like ISupported (depending on how you like to name things)"><y>#</y><d>2016-06-13</d><h>03:28</h><w>mikerod</w>yeah, could think of a protocol like ISupported (depending on how you like to name things)</z><z id="t1465788501000166" t="devn i wonder: any ideas on a query that pulls &quot;ordered&quot; Meaningful facts?"><y>#</y><d>2016-06-13</d><h>03:28</h><w>devn</w>i wonder: any ideas on a query that pulls &quot;ordered&quot; Meaningful facts?</z><z id="t1465788520000167" t="mikerod yeah, not sure on ordered, unless you had somehting to order by"><y>#</y><d>2016-06-13</d><h>03:28</h><w>mikerod</w>yeah, not sure on ordered, unless you had somehting to order by</z><z id="t1465788535000168" t="mikerod generating records with eval sounds fun 😛"><y>#</y><d>2016-06-13</d><h>03:28</h><w>mikerod</w>generating records with eval sounds fun <b>😛</b></z><z id="t1465788537000169" t="devn right, but i mean, i am willing to throw some of my pride away"><y>#</y><d>2016-06-13</d><h>03:28</h><w>devn</w>right, but i mean, i am willing to throw some of my pride away</z><z id="t1465788552000170" t="mikerod it may make sense if you are syaing you are trying to make data types dynamically driven off of config"><y>#</y><d>2016-06-13</d><h>03:29</h><w>mikerod</w>it may make sense if you are syaing you are trying to make data types dynamically driven off of config</z><z id="t1465788555000171" t="devn so an atom per session that increments using the RHS of rules could work, maybe"><y>#</y><d>2016-06-13</d><h>03:29</h><w>devn</w>so an atom per session that increments using the RHS of rules could work, maybe</z><z id="t1465788569000172" t="mikerod yeah, maybe something like a counter"><y>#</y><d>2016-06-13</d><h>03:29</h><w>mikerod</w>yeah, maybe something like a counter</z><z id="t1465788583000173" t="mikerod just be aware the the rules engine has some liberties it can take as far as when it fires rules"><y>#</y><d>2016-06-13</d><h>03:29</h><w>mikerod</w>just be aware the the rules engine has some liberties it can take as far as when it fires rules</z><z id="t1465788601000174" t="mikerod rules may fire in different orders due to non-determinism (we&apos;d like to minimize), optimizations, etc"><y>#</y><d>2016-06-13</d><h>03:30</h><w>mikerod</w>rules may fire in different orders due to non-determinism (we&apos;d like to minimize), optimizations, etc</z><z id="t1465788625000175" t="devn yeah, i desperately avoid order where i can"><y>#</y><d>2016-06-13</d><h>03:30</h><w>devn</w>yeah, i desperately avoid order where i can</z><z id="t1465788644000176" t="mikerod just never get too reliant on rule order unless you have logical rule order that with eventually be consistent due to truth maintanence"><y>#</y><d>2016-06-13</d><h>03:30</h><w>mikerod</w>just never get too reliant on rule order unless you have logical rule order that with eventually be consistent due to truth maintanence</z><z id="t1465788662000177" t="devn i&apos;d rather not ever pay the cost of needing to think about that"><y>#</y><d>2016-06-13</d><h>03:31</h><w>devn</w>i&apos;d rather not ever pay the cost of needing to think about that</z><z id="t1465788664000178" t="mikerod and :salience when desperate"><y>#</y><d>2016-06-13</d><h>03:31</h><w>mikerod</w>and <code>:salience</code> when desperate</z><z id="t1465788670000179" t="mikerod yeah, it is complexity"><y>#</y><d>2016-06-13</d><h>03:31</h><w>mikerod</w>yeah, it is complexity</z><z id="t1465788680000180" t="mikerod and ruins the declarative nature of the rules"><y>#</y><d>2016-06-13</d><h>03:31</h><w>mikerod</w>and ruins the declarative nature of the rules</z><z id="t1465788695000181" t="mikerod and eventually becomes brittle when you get many rules involved etc"><y>#</y><d>2016-06-13</d><h>03:31</h><w>mikerod</w>and eventually becomes brittle when you get many rules involved etc</z><z id="t1465788713000182" t="mikerod we certainly often see rules with logical dependencies between each other though"><y>#</y><d>2016-06-13</d><h>03:31</h><w>mikerod</w>we certainly often see rules with logical dependencies between each other though</z><z id="t1465788754000183" t="mikerod (defrule rule-1 [MyFact] =&gt; (insert! (-&gt;AnotherFact ))) (defrule rule-2 [:not [AnotherFact]] =&gt; (insert! (-&gt;AlternativeFact)))` etc"><y>#</y><d>2016-06-13</d><h>03:32</h><w>mikerod</w><code>(defrule rule-1 [MyFact] =&gt; (insert! (-&gt;AnotherFact )))</code> (defrule rule-2 [:not [AnotherFact]] =&gt; (insert! (-&gt;AlternativeFact)))` etc</z><z id="t1465788761000184" t="mikerod but I think that is obvous usages"><y>#</y><d>2016-06-13</d><h>03:32</h><w>mikerod</w>but I think that is obvous usages</z><z id="t1465788765000185" t="devn yes, that&apos;s really what we deal with, but i do worry a bit that if that&apos;s not the case in the future, we&apos;re going to be sad pandas"><y>#</y><d>2016-06-13</d><h>03:32</h><w>devn</w>yes, that&apos;s really what we deal with, but i do worry a bit that if that&apos;s not the case in the future, we&apos;re going to be sad pandas</z><z id="t1465788776000186" t="devn 99% of our stuff is a DAG"><y>#</y><d>2016-06-13</d><h>03:32</h><w>devn</w>99% of our stuff is a DAG</z><z id="t1465788791000187" t="mikerod yep"><y>#</y><d>2016-06-13</d><h>03:33</h><w>mikerod</w>yep</z><z id="t1465788793000188" t="devn err let&apos;s go with 90%"><y>#</y><d>2016-06-13</d><h>03:33</h><w>devn</w>err let&apos;s go with 90%</z><z id="t1465788795000189" t="devn 😉"><y>#</y><d>2016-06-13</d><h>03:33</h><w>devn</w><b>😉</b></z><z id="t1465788797000190" t="mikerod hah"><y>#</y><d>2016-06-13</d><h>03:33</h><w>mikerod</w>hah</z><z id="t1465788804000191" t="mikerod well, I&apos;m logging off for the night though."><y>#</y><d>2016-06-13</d><h>03:33</h><w>mikerod</w>well, I&apos;m logging off for the night though.</z><z id="t1465788808000192" t="devn yeah, same here"><y>#</y><d>2016-06-13</d><h>03:33</h><w>devn</w>yeah, same here</z><z id="t1465788816000193" t="mikerod good talking with you. It&apos;s nice to hear of others use-cases etc."><y>#</y><d>2016-06-13</d><h>03:33</h><w>mikerod</w>good talking with you.  It&apos;s nice to hear of others use-cases etc.</z><z id="t1465788836000194" t="mikerod Have a good night!"><y>#</y><d>2016-06-13</d><h>03:33</h><w>mikerod</w>Have a good night!</z><z id="t1465788841000195" t="devn appreciate the conversation, and am pleased to hear that i&apos;m not the only one who&apos;s doing this whole :support thing. people on our team just started using it"><y>#</y><d>2016-06-13</d><h>03:34</h><w>devn</w>appreciate the conversation, and am pleased to hear that i&apos;m not the only one who&apos;s doing this whole :support thing. people on our team just started using it</z><z id="t1465788848000196" t="devn and i was like: oh god, did i just open pandora&apos;s box?"><y>#</y><d>2016-06-13</d><h>03:34</h><w>devn</w>and i was like: oh god, did i just open pandora&apos;s box?</z><z id="t1465788854000197" t="mikerod 😛"><y>#</y><d>2016-06-13</d><h>03:34</h><w>mikerod</w><b>😛</b></z><z id="t1465788856000198" t="devn but it&apos;s been doing the job, so ¯\(ツ)/¯"><y>#</y><d>2016-06-13</d><h>03:34</h><w>devn</w>but it&apos;s been doing the job, so ¯\(ツ)/¯</z><z id="t1465788862000199" t="devn anyway, have a good night, see you around 🙂"><y>#</y><d>2016-06-13</d><h>03:34</h><w>devn</w>anyway, have a good night, see you around <b>🙂</b></z><z id="t1465788864000200" t="devn 👋"><y>#</y><d>2016-06-13</d><h>03:34</h><w>devn</w><b>👋</b></z><z id="t1465855157000201" t="wparker @devn: FWIW, I agree with Mike that the engine and (I’ll add) the memory are probably the best places to start. When I was first getting familiar with the internals of Clara I found it useful, and still do if I’m unsure of what some rule will look like in the network, to just create a session from that rule and look at the rulebase generated. That is, something like (-&gt; (mk-session [rule-in-question] :cache false) .rulebase :alpha-roots) and just poke around the rules network generated."><y>#</y><d>2016-06-13</d><h>21:59</h><w>wparker</w>@devn: FWIW, I agree with Mike that the engine and (I’ll add) the memory are probably the best places to start.  When I was first getting familiar with the internals of Clara I found it useful, and still do if I’m unsure of what some rule will look like in the network, to just create a session from that rule and look at the rulebase generated.  That is, something like (-&gt; (mk-session [rule-in-question] :cache false) .rulebase :alpha-roots) and just poke around the rules network generated.</z><z id="t1465855252000202" t="wparker I’ve found that if I’m not dealing with the compiler, it is very possible to just deal with the rules network and forget where it came from. The memory is even more isolated in some ways in that it mostly is just a composite data structure, albeit one very much tailored to the needs of the engine."><y>#</y><d>2016-06-13</d><h>22:00</h><w>wparker</w>I’ve found that if I’m not dealing with the compiler, it is very possible to just deal with the rules network and forget where it came from.  The memory is even more isolated in some ways in that it mostly is just a composite data structure, albeit one very much tailored to the needs of the engine.</z><z id="t1465855333000203" t="wparker The reason I put the :alpha-roots in the call above is that facts inserted start there and propagate downward to the children of those alpha-roots"><y>#</y><d>2016-06-13</d><h>22:02</h><w>wparker</w>The reason I put the :alpha-roots in the call above is that facts inserted start there and propagate downward to the children of those alpha-roots</z><z id="t1467878277000206" t="raymcdermott anyone using the durability feature? want to try it out on heroku with redis as a backend, wondering if there are any experience reports out there"><y>#</y><d>2016-07-07</d><h>07:57</h><w>raymcdermott</w>anyone using the durability feature? want to try it out on heroku with redis as a backend, wondering if there are any experience reports out there</z><z id="t1467878305000207" t="raymcdermott also @ryanbrush I note that the durability feature is experimental"><y>#</y><d>2016-07-07</d><h>07:58</h><w>raymcdermott</w>also @ryanbrush I note that the durability feature is experimental</z><z id="t1467878357000208" t="raymcdermott what is your thinking about what extra work needs doing there to conclude the experiment?"><y>#</y><d>2016-07-07</d><h>07:59</h><w>raymcdermott</w>what is your thinking about what extra work needs doing there to conclude the experiment?</z><z id="t1467911329000210" t="wparker @raymcdermott: The current durability implementation has some significant problems that are described at https://github.com/rbrush/clara-rules/issues/198 . Please feel free to ask questions here or there if anything is unclear. @mikerod is working on a more robust durability implementation that will be targeted at speed of rule execution after deserialization; I’ll let him speak to the current state of that. Do you mind elaborating a bit on your use-case for durability? For less taxing use cases performance-wise just re-executing the rules from your serialized facts might well be a good approach."><y>#</y><d>2016-07-07</d><h>17:08</h><w>wparker</w>@raymcdermott: The current durability implementation has some significant problems that are described at <a href="https://github.com/rbrush/clara-rules/issues/198" target="_blank">https://github.com/rbrush/clara-rules/issues/198</a> .  Please feel free to ask questions here or there if anything is unclear.  @mikerod is working on a more robust durability implementation that will be targeted at speed of rule execution after deserialization; I’ll let him speak to the current state of that.  Do you mind elaborating a bit on your use-case for durability?  For less taxing use cases performance-wise just re-executing the rules from your serialized facts might well be a good approach.</z><z id="t1467914051000212" t="mikerod raymcdermott: I’d definitely say to suspect the durability of Clara to get a full overhaul. What is there right now hasn’t really been maintained and probably will fail or produce incorrect results for modern-day Clara sessions."><y>#</y><d>2016-07-07</d><h>17:54</h><w>mikerod</w>raymcdermott: I’d definitely say to suspect the durability of Clara to get a full overhaul. What is there right now hasn’t really been maintained and probably will fail or produce incorrect results for modern-day Clara sessions.</z><z id="t1467914071000213" t="mikerod I’d definitely recommend reading through https://github.com/rbrush/clara-rules/issues/198 and I’d really like to know if these goals align with what you’d want out of it"><y>#</y><d>2016-07-07</d><h>17:54</h><w>mikerod</w>I’d definitely recommend reading through <a href="https://github.com/rbrush/clara-rules/issues/198" target="_blank">https://github.com/rbrush/clara-rules/issues/198</a> and I’d really like to know if these goals align with what you’d want out of it</z><z id="t1467914079000214" t="mikerod (ass Will said above)"><y>#</y><d>2016-07-07</d><h>17:54</h><w>mikerod</w>(ass Will said above)</z><z id="t1467914083000215" t="mikerod as* 😛"><y>#</y><d>2016-07-07</d><h>17:54</h><w>mikerod</w>as* <b>😛</b></z><z id="t1467921300000216" t="raymcdermott k thanks - will take a look and give some feedback"><y>#</y><d>2016-07-07</d><h>19:55</h><w>raymcdermott</w>k thanks - will take a look and give some feedback</z><z id="t1467921946000217" t="raymcdermott Serialising facts using transit out to REDIS would be enough in my case. I can imagine that vast rulesets would benefits but its not the case for my first set of use cases."><y>#</y><d>2016-07-07</d><h>20:05</h><w>raymcdermott</w>Serialising facts using transit out to REDIS would be enough in my case. I can imagine that vast rulesets would benefits but its not the case for my first set of use cases.</z><z id="t1467922046000218" t="raymcdermott I want to make a simple way to check a web user&apos;s disposition based on a small number of rules"><y>#</y><d>2016-07-07</d><h>20:07</h><w>raymcdermott</w>I want to make a simple way to check a web user&apos;s disposition based on a small number of rules</z><z id="t1467922120000219" t="raymcdermott with Heroku any dyno should be able to answer any query and obtaining the facts from the back-end should be kept to a minimum, hence REDIS"><y>#</y><d>2016-07-07</d><h>20:08</h><w>raymcdermott</w>with Heroku any dyno should be able to answer any query and obtaining the facts from the back-end should be kept to a minimum, hence REDIS</z><z id="t1467922335000220" t="raymcdermott was also thinking that I could keep the data in a memoized set since I’m not talking about a huge number of user sessions and I can limit the size of the set with the help of core.memoize"><y>#</y><d>2016-07-07</d><h>20:12</h><w>raymcdermott</w>was also thinking that I could keep the data in a memoized set since I’m not talking about a huge number of user sessions and I can limit the size of the set with the help of core.memoize</z><z id="t1467922377000221" t="raymcdermott so it’s good to understand where the work is happening 🙂"><y>#</y><d>2016-07-07</d><h>20:12</h><w>raymcdermott</w>so it’s good to understand where the work is happening <b>🙂</b></z><z id="t1467930692000222" t="wparker Yeah, if you’re OK with just running everything again to retrieve your state performance-wise that would probably be easiest. You’d want to just use your top-level input of course or account for the use of generated facts in your rules of course; inserting logically generated facts by Clara back into a session that then generates facts not in the original session is a problem with the current durability implementation as Mike mentions in that issue. Regarding the number of user sessions, just in case you don’t know, Clara sessions are immutable so you can just have a single base session without user-session-specific facts that you then add things into."><y>#</y><d>2016-07-07</d><h>22:31</h><w>wparker</w>Yeah, if you’re OK with just running everything again to retrieve your state performance-wise that would probably be easiest.  You’d want to just use your top-level input of course or account for the use of generated facts in your rules of course; inserting logically generated facts by Clara back into a session that then generates facts not in the original session is a problem with the current durability implementation as Mike mentions in that issue.  Regarding the number of user sessions, just in case you don’t know, Clara sessions are immutable so you can just have a single base session without user-session-specific facts that you then add things into.</z><z id="t1467960551000223" t="raymcdermott To play that back my understanding is that I create an empty session (as in (def empty-session (mk-session)) ) and insert facts on a per customer basis and fire the rules per customer - I hope that’s what you mean. If not, I would like to understand more!"><y>#</y><d>2016-07-08</d><h>06:49</h><w>raymcdermott</w>To play that back my understanding is that I create an empty session (as in <code>(def empty-session (mk-session))</code>) and insert facts on a per customer basis and fire the rules per customer - I hope that’s what you mean. If not, I would like to understand more!</z><z id="t1467960713000224" t="raymcdermott the issue seems to revolve around cases where side effects or where establishing truth is expensive in complex sessions but I don’t have that issue - my case is very much operating like a pure function where Clara is simply used to improve expressivity"><y>#</y><d>2016-07-08</d><h>06:51</h><w>raymcdermott</w>the issue seems to revolve around cases where side effects or where establishing truth is expensive in complex sessions but I don’t have that issue - my case is very much operating like a pure function where Clara is simply used to improve expressivity</z><z id="t1467961957000225" t="raymcdermott dumb question - are the facts from previous sessions GCd? If not, must I retract them? It would be simpler to take the hit on running mksession every time and TBH I have not profiled that so maybe it’s also not such a biggie!"><y>#</y><d>2016-07-08</d><h>07:12</h><w>raymcdermott</w>dumb question - are the facts from previous sessions GCd? If not, must I retract them? It would be simpler to take the hit on running mksession every time and TBH I have not profiled that so maybe it’s also not such a biggie!</z><z id="t1467987489000226" t="wparker @raymcdermott: Clara sessions are intended to be data structures that obey Clojure idioms, that is, they are value-based and immutable. When you insert a fact into a session, a new session is returned that is independent of the previous session. So, for example, if you create an empty session and insert a fact into it, the original empty session still exists and can be reused. I created a quick demo of this at https://gist.github.com/WilliamParker/c6be14cb249d55b6d2e3ff42500a9334"><y>#</y><d>2016-07-08</d><h>14:18</h><w>wparker</w>@raymcdermott:  Clara sessions are intended to be data structures that obey Clojure idioms, that is, they are value-based and immutable.  When you insert a fact into a session, a new session is returned that is independent of the previous session.  So, for example, if you create an empty session and insert a fact into it, the original empty session still exists and can be reused.   I created a quick demo of this at <a href="https://gist.github.com/WilliamParker/c6be14cb249d55b6d2e3ff42500a9334" target="_blank">https://gist.github.com/WilliamParker/c6be14cb249d55b6d2e3ff42500a9334</a></z><z id="t1467987659000227" t="wparker The “com/clear-session-cache!” clears a cache of created sessions that Clara automatically creates unless it is explicitly turned off. The sessions without facts are cached by Clara on the set of rules, queries, and session options to save compilation time. However, this cache should never contain sessions with facts. The relevant code for that cache is at https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L1530"><y>#</y><d>2016-07-08</d><h>14:20</h><w>wparker</w>The “com/clear-session-cache!” clears a cache of created sessions that Clara automatically creates unless it is explicitly turned off.  The sessions without facts are cached by Clara on the set of rules, queries, and session options to save compilation time.  However, this cache should never contain sessions with facts.  The relevant code for that cache is at <a href="https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L1530" target="_blank">https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L1530</a></z><z id="t1467987710000229" t="wparker Clara should only maintain references to facts through sessions. Once all sessions containing a given fact are GC’able then that fact itself should be GC’able as far as Clara is concerned."><y>#</y><d>2016-07-08</d><h>14:21</h><w>wparker</w>Clara should only maintain references to facts through sessions.  Once all sessions containing a given fact are GC’able then that fact itself should be GC’able as far as Clara is concerned.</z><z id="t1467987809000230" t="wparker To clarify too, Clara doesn’t copy the facts between sessions that contain them; if you have a session that contains FactA and then you insert FactB in it you’ll have two sessions that both contain a reference to the same FactA object. Clara expects that facts won’t be mutated after insertion."><y>#</y><d>2016-07-08</d><h>14:23</h><w>wparker</w>To clarify too, Clara doesn’t copy the facts between sessions that contain them; if you have a session that contains FactA and then you insert FactB in it you’ll have two sessions that both contain a reference to the same FactA object.  Clara expects that facts won’t be mutated after insertion.</z><z id="t1468001117000231" t="raymcdermott thanks - I appreciate the effort put into your answer"><y>#</y><d>2016-07-08</d><h>18:05</h><w>raymcdermott</w>thanks - I appreciate the effort put into your answer</z><z id="t1468001150000232" t="raymcdermott it’s also nice to see answers from two people that are not @ryanbrush 😉"><y>#</y><d>2016-07-08</d><h>18:05</h><w>raymcdermott</w>it’s also nice to see answers from two people that are not @ryanbrush <b>😉</b></z><z id="t1468001186000233" t="raymcdermott seriously, I&apos;m a fan and it’s good to see the community growing"><y>#</y><d>2016-07-08</d><h>18:06</h><w>raymcdermott</w>seriously, I&apos;m a fan and it’s good to see the community growing</z><z id="t1468084797000234" t="devn Anyone going to strangeloop this year?"><y>#</y><d>2016-07-09</d><h>17:19</h><w>devn</w>Anyone going to strangeloop this year?</z><z id="t1468538448000238" t="devn Anyone have thoughts on clojure.spec and clara? Also, I was wondering: If I I decided to move to using :fact-type-fn on plain old maps to determine type, would it be possible to automatically bind the syms the same way they&apos;re bound for Java beans and Clojure Records?"><y>#</y><d>2016-07-14</d><h>23:20</h><w>devn</w>Anyone have thoughts on clojure.spec and clara? Also, I was wondering: If I I decided to move to using :fact-type-fn on plain old maps to determine type, would it be possible to automatically bind the syms the same way they&apos;re bound for Java beans and Clojure Records?</z><z id="t1468538670000239" t="devn Mainly, I&apos;m interested in preserving provenance of the data that is being used to create the records. Given what&apos;s showing up in alpha10: user&gt; #:person{:age 42, :name &quot;Fred&quot;} =&gt; {:person/age 42 :person/age &quot;Fred&quot;} , and the fact that destructuring is going to work with namespaced keys, I wondered what y&apos;all would think about automatically binding from namespaced keys in maps."><y>#</y><d>2016-07-14</d><h>23:24</h><w>devn</w>Mainly, I&apos;m interested in preserving provenance of the data that is being used to create the records. Given what&apos;s showing up in alpha10: <code>user&gt; #:person{:age 42, :name &quot;Fred&quot;}</code> =&gt; <code>{:person/age 42 :person/age &quot;Fred&quot;}</code>, and the fact that destructuring is going to work with namespaced keys, I wondered what y&apos;all would think about automatically binding from namespaced keys in maps.</z><z id="t1468850780000002" t="wparker Regarding using the fact-type-fn, the automatic field lookup is determined by the type; see https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L152 So right now the auto field access will just be by the record or bean properties. I could conceivably see this is an extension point if there were use-cases for it. However, I don’t see any reason why you can’t use hash bindings for other types. So, for example, something like"><y>#</y><d>2016-07-18</d><h>14:06</h><w>wparker</w>Regarding using the fact-type-fn, the automatic field lookup is determined by the type; see <a href="https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L152" target="_blank">https://github.com/rbrush/clara-rules/blob/0.11.1/src/main/clojure/clara/rules/compiler.clj#L152</a>  So right now the auto field access will just be by the record or bean properties.  I could conceivably see this is an extension point if there were use-cases for it.  However, I don’t see any reason why you can’t use hash bindings for other types.  So, for example, something like</z><z id="t1468850802000004" t="wparker [FactClass (= ?fieldA (.someNonBeanAccessorMethod this))]"><y>#</y><d>2016-07-18</d><h>14:06</h><w>wparker</w>[FactClass (= ?fieldA (.someNonBeanAccessorMethod this))]</z><z id="t1468850819000005" t="wparker @devn:"><y>#</y><d>2016-07-18</d><h>14:06</h><w>wparker</w>@devn:</z><z id="t1468854609000006" t="mattdarling I&apos;m actually interested in achieving something similar, is there any kind of field access aside from &quot;auto field access&quot;?"><y>#</y><d>2016-07-18</d><h>15:10</h><w>mattdarling</w>I&apos;m actually interested in achieving something similar, is there any kind of field access aside from &quot;auto field access&quot;?</z><z id="t1468863313000007" t="wparker @mattdarling: The fact itself is bound to “this” in the constraints on the RHS (right-hand side) so you can do arbitrary things with it there. So"><y>#</y><d>2016-07-18</d><h>17:35</h><w>wparker</w>@mattdarling: The fact itself is bound to “this” in the constraints on the RHS (right-hand side) so you can do arbitrary things with it there.  So</z><z id="t1468863319000008" t="wparker (defrule some-rule"><y>#</y><d>2016-07-18</d><h>17:35</h><w>wparker</w>(defrule some-rule</z><z id="t1468863339000009" t="wparker [FactClass (= ?fieldA (some-arbitrary-operation this))]"><y>#</y><d>2016-07-18</d><h>17:35</h><w>wparker</w>[FactClass (= ?fieldA (some-arbitrary-operation this))]</z><z id="t1468863360000010" t="wparker =&gt; ;; whatever RHS"><y>#</y><d>2016-07-18</d><h>17:36</h><w>wparker</w>=&gt; ;; whatever RHS</z><z id="t1468863371000011" t="wparker Note: I meant constraints on the LHS above, not RHS 😛"><y>#</y><d>2016-07-18</d><h>17:36</h><w>wparker</w>Note: I meant constraints on the LHS above, not RHS <b>😛</b></z><z id="t1468863376000012" t="wparker so left-hand-side"><y>#</y><d>2016-07-18</d><h>17:36</h><w>wparker</w>so left-hand-side</z><z id="t1468863413000013" t="wparker So the lack of automatic field access shouldn’t prevent you from doing anything functionality, it is purely a bit of syntax sugar"><y>#</y><d>2016-07-18</d><h>17:36</h><w>wparker</w>So the lack of automatic field access shouldn’t prevent you from doing anything functionality, it is purely a bit of syntax sugar</z><z id="t1468863418000014" t="wparker *functionally"><y>#</y><d>2016-07-18</d><h>17:36</h><w>wparker</w>*functionally</z><z id="t1468863774000015" t="wparker That said, no, I don’t believe anything other than records or beans is supported for that syntax sugar now. I don’t think it would be terribly difficult to change the compiler to make that an extension point, perhaps making clara.rules.compiler/get-fields a multifunction ( http://clojuredocs.org/clojure.core/defmulti ) if someone was interested in doing so and Ryan agreed (I haven’t thought deeply on the issue though, it is possible there would be a complication I’m not seeing immediately)."><y>#</y><d>2016-07-18</d><h>17:42</h><w>wparker</w>That said, no, I don’t believe anything other than records or beans is supported for that syntax sugar now.  I don’t think it would be terribly difficult to change the compiler to make that an extension point, perhaps making clara.rules.compiler/get-fields a multifunction (<a href="http://clojuredocs.org/clojure.core/defmulti" target="_blank">http://clojuredocs.org/clojure.core/defmulti</a>) if someone was interested in doing so and Ryan agreed (I haven’t thought deeply on the issue though, it is possible there would be a complication I’m not seeing immediately).</z><z id="t1468865861000016" t="mattdarling Got it working as I wanted with &quot;this&quot;, thank you! I thought that was just example syntax, not an existing feature"><y>#</y><d>2016-07-18</d><h>18:17</h><w>mattdarling</w>Got it working as I wanted with &quot;this&quot;, thank you! I thought that was just example syntax, not an existing feature</z><z id="t1468867646000017" t="wparker Ah no, the “this” binding and field bindings for Clojure records and JavaBeans exist already and have for some time; they aren’t an experimental feature or anything like that"><y>#</y><d>2016-07-18</d><h>18:47</h><w>wparker</w>Ah no, the “this” binding and field bindings for Clojure records and JavaBeans exist already and have for some time; they aren’t an experimental feature or anything like that</z><z id="t1468868109000018" t="mattdarling I had used the bindings for Clojure records initially, but wanted to introduce a bit of polymorphism, so I switched to maps with a key to indicate their type + made that the fact-type-fn"><y>#</y><d>2016-07-18</d><h>18:55</h><w>mattdarling</w>I had used the bindings for Clojure records initially, but wanted to introduce a bit of polymorphism, so I switched to maps with a key to indicate their type + made that the fact-type-fn</z><z id="t1469186263000019" t="mikerod mattdarling in case you like the “syntax sugar” of it you can also use destructuring in rule conditions the same way you’d use it in the arglist of a fn"><y>#</y><d>2016-07-22</d><h>11:17</h><w>mikerod</w>mattdarling in case you like the “syntax sugar” of it you can also use destructuring in rule conditions the same way you’d use it in the arglist of a fn</z><z id="t1469186291000020" t="mikerod [:my-type-thing [{:keys [x y z]}] (&lt; x 10) (= ?y y)]"><y>#</y><d>2016-07-22</d><h>11:18</h><w>mikerod</w><code>[:my-type-thing [{:keys [x y z]}] (&lt; x 10) (= ?y y)]</code></z><z id="t1469186315000021" t="mikerod so that just destructures the map as normal in clj and then you have “direct access” to “fields” x y z"><y>#</y><d>2016-07-22</d><h>11:18</h><w>mikerod</w>so that just destructures the map as normal in clj and then you have “direct access” to “fields” <code>x</code> <code>y</code> <code>z</code></z><z id="t1469186335000022" t="mikerod it’s just syntax sugar though really. performs the same as destructuring"><y>#</y><d>2016-07-22</d><h>11:18</h><w>mikerod</w>it’s just syntax sugar though really.  performs the same as destructuring</z><z id="t1470722833000025" t="ramkumarkb Hi, I am new to Clara and trying it in one the projects. Has anyone tried to use Clara with Hazelcast as its working memory? In general, any tips on the WorkingMemory management for an enterprise app with many domain objects (50 types, each about 100k objects) would be really helpful."><y>#</y><d>2016-08-09</d><h>06:07</h><w>ramkumarkb</w>Hi, I am new to Clara and trying it in one the projects. Has anyone tried to use Clara with Hazelcast as its working memory? In general, any tips on the WorkingMemory management for an enterprise app with many domain objects (50 types, each about 100k objects) would be really helpful.</z><z id="t1470722882000026" t="ramkumarkb Btw, I hope this is the right forum to ask Clara related questions."><y>#</y><d>2016-08-09</d><h>06:08</h><w>ramkumarkb</w>Btw, I hope this is the right forum to ask Clara related questions.</z><z id="t1470730170000027" t="wparker @ramkumarkb: This is indeed the correct place to ask questions about Clara. 🙂 We’ve used Clara in some heavy-hitting scenarios, although perhaps not quite as many as 5 million total objects, at least intentionally. In general, my instinct is that bad scenarios would probably be a combination of both the number of facts, the rules, and the data scenarios, rather than just the number of facts though. That’s generally what we’ve seen, except in some cases where we’ve had bad rules create a number of facts that was a problem for the heap. I’m not sure what you mean by using Hazelcast as the memory - are you implementing your own memory as a replacement for the Clara defaults, considering using it in combination with the persistence stuff @mikerod is working on with https://github.com/rbrush/clara-rules/issues/198 , or something else? I’m not an expert on Hazelcast, this is the first time I’ve heard of it. It would certainly be interesting to me to hear about other perf-intensive use-cases."><y>#</y><d>2016-08-09</d><h>08:09</h><w>wparker</w>@ramkumarkb: This is indeed the correct place to ask questions about Clara. <b>🙂</b>  We’ve used Clara in some heavy-hitting scenarios, although perhaps not quite as many as 5 million total objects, at least intentionally.  In general, my instinct is that bad scenarios would probably be a combination of both the number of facts, the rules, and the data scenarios, rather than just the number of facts though.  That’s generally what we’ve seen, except in some cases where we’ve had bad rules create a number of facts that was a problem for the heap.  I’m not sure what you mean by using Hazelcast as the memory - are you implementing your own memory as a replacement for the Clara defaults, considering using it in combination with the persistence stuff @mikerod is working on with <a href="https://github.com/rbrush/clara-rules/issues/198" target="_blank">https://github.com/rbrush/clara-rules/issues/198</a>, or something else?  I’m not an expert on Hazelcast, this is the first time I’ve heard of it.  It would certainly be interesting to me to hear about other perf-intensive use-cases.</z><z id="t1471485660000030" t="flavio Hello, I&apos;m new to Clara and Clojure and stumbled upon a case, which is expected behaviour but I am not sure what to do with it, so maybe you can enlighten me: I have a rule with an or condition on two boolean member variables of a Java object passed into the Clojure namespace. The rule is if either of the booleans is true, then fire. Now I have a case where both variables are true and it seems that the same rule fires twice, which seems expected behaviour. I do not understand how to proceed as I do not need it to fire twice... Thanks for any input."><y>#</y><d>2016-08-18</d><h>02:01</h><w>flavio</w>Hello,  I&apos;m new to Clara and Clojure  and stumbled upon a case, which is expected behaviour but I am not sure what to do with it,  so maybe you can enlighten me: I have a rule with an or condition on two boolean member variables of a Java object passed into the Clojure namespace. The rule is if either of the booleans is true, then fire. Now I have a case where both variables are true and it seems that the same rule fires twice, which seems expected behaviour. I do not understand how to proceed as I do not need it to fire twice...  Thanks for any input.</z><z id="t1471491294000031" t="ramkumarkb @wparker: Thank you for the reply and suggestions. Will get back after we run some tests and see if we indeed have trouble fitting into a single JVM. "><y>#</y><d>2016-08-18</d><h>03:34</h><w>ramkumarkb</w>@wparker: Thank you for the reply and suggestions. Will get back after we run some tests and see if we indeed have trouble fitting into a single JVM. </z><z id="t1471594369000032" t="wparker @flavio : So the or is on two different conditions on the same fact? It sounds like this need not fire twice. Or conditions in the constraints on a single fact condition don’t produce multiple firings, that is only for :or conditions that are actually part of the Rete network. I think of something like [:or B C] as firing for all elements of the union of B and C, to put it differently, whereas conditions like [B (or pred1 pred2)] are still one set that just calls clojure.core/or to determine what facts of type B should be members of that set. A concrete example might help; https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L41 will fire once per matching Order, while https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19 will fire once per matching NewCustomer or ValuedCustomer. If you have a single fact that you’re trying to test it sounds like you want something more like new-or-valued-customer-basic-coupons in that examples page; the :or condition functionality is really just shorthand for writing multiple rules in a single defrule in the code. Does this help? It is a bit confusing because we’re using the same word “or” to mean fundamentally different things."><y>#</y><d>2016-08-19</d><h>08:12</h><w>wparker</w>@flavio : So the or is on two different conditions on the same fact?  It sounds like this need not fire twice.  Or conditions in the constraints on a single fact condition don’t produce multiple firings, that is only for :or conditions that are actually part of the Rete network.  I think of something like [:or B C] as firing for all elements of the union of B and C, to put it differently, whereas conditions like [B (or pred1 pred2)] are still one set that just calls clojure.core/or to determine what facts of type B should be members of that set.  A concrete example might help; <a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L41" target="_blank">https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L41</a> will fire once per matching Order, while <a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19" target="_blank">https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19</a> will fire once per matching NewCustomer or ValuedCustomer.  If you have a single fact that you’re trying to test it sounds like you want something more like new-or-valued-customer-basic-coupons in that examples page; the :or condition functionality is really just shorthand for writing multiple rules in a single defrule in the code.  Does this help?  It is a bit confusing because we’re using the same word “or” to mean fundamentally different things.</z><z id="t1471594486000034" t="wparker Also, you may have seen http://www.clara-rules.org/docs/booleans , but if you haven’t that could be helpful. The key point though is that that only addresses booleans created like https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19 ; the way to distinguish the cases visibly is what is a clojure keyword (:or :and) versus a normal Clojure function call like (or… or (and..."><y>#</y><d>2016-08-19</d><h>08:14</h><w>wparker</w>Also, you may have seen <a href="http://www.clara-rules.org/docs/booleans" target="_blank">http://www.clara-rules.org/docs/booleans</a>, but if you haven’t that could be helpful.  The key point though is that that only addresses booleans created like <a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19" target="_blank">https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/booleans.clj#L19</a> ; the way to distinguish the cases visibly is what is a clojure keyword (:or :and) versus a normal Clojure function call like (or… or  (and...</z><z id="t1471783201000036" t="flavio @wparker: thanks for your explanation. It is as you say: [:or B C ] is firing as an union, whereas what I am looking for is [B (or pred1 pred2)]"><y>#</y><d>2016-08-21</d><h>12:40</h><w>flavio</w>@wparker: thanks for your explanation. It is as you say: [:or B C ] is firing as an union, whereas what I am looking for is [B (or pred1 pred2)]</z><z id="t1471872408000039" t="ramji013 Hi All, I have posted my query in different group instead Clara. Anyone in the group please help to look into this. regarding 2nd question, we have found the answer. response type of queryString() from QueryResult is Object type, that can be typecasted to respective object. https://clojurians.slack.com/archives/clojurescript/p1471836222005217"><y>#</y><d>2016-08-22</d><h>13:26</h><w>ramji013</w>Hi All, I have posted my query in different group instead Clara.

Anyone in the group please help to look into this. 

regarding 2nd question, we have found the answer. response type of queryString() from QueryResult is Object type, that can be typecasted to respective object.

 <a href="https://clojurians.slack.com/archives/clojurescript/p1471836222005217" target="_blank">https://clojurians.slack.com/archives/clojurescript/p1471836222005217</a></z><z id="t1471879230000042" t="ryanbrush Hi @ramji013, if you&apos;re having a specific issue the best way to troubleshoot is to post a minimal runnable example that shows the problem you&apos;re having, possibly as a gist or issue on github. def&apos;d variables should be visible from within rules; we do it frequently. If you&apos;re doing something in ClojureScript I&apos;m less sure, since I haven&apos;t used that in earnest."><y>#</y><d>2016-08-22</d><h>15:20</h><w>ryanbrush</w>Hi @ramji013, if you&apos;re having a specific issue the best way to troubleshoot is to post a minimal runnable example that shows the problem you&apos;re having, possibly as a gist or issue on github. def&apos;d variables should be visible from within rules; we do it frequently. If you&apos;re doing something in ClojureScript I&apos;m less sure, since I haven&apos;t used that in earnest.</z><z id="t1471879272000043" t="ryanbrush As for getting to nested fields, you can use Clojure&apos;s destructuring to get to the top-level field (or fact itself), and then access nested fields just using Clojure expressions as part of the rule left-hand side. Some details on restructuring are here: http://www.clara-rules.org/docs/expressions/"><y>#</y><d>2016-08-22</d><h>15:21</h><w>ryanbrush</w>As for getting to nested fields, you can use Clojure&apos;s destructuring to get to the top-level field (or fact itself), and then access nested fields just using Clojure expressions as part of the rule left-hand side. Some details on restructuring are here: <a href="http://www.clara-rules.org/docs/expressions/" target="_blank">http://www.clara-rules.org/docs/expressions/</a></z><z id="t1471879647000045" t="ryanbrush An announcement: Clara 0.12.0 has been released! There have been a bunch of performance enhancements from @wparker and @mikerod, and a handful of bug fixes as well. Details are in the change log: https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0120"><y>#</y><d>2016-08-22</d><h>15:27</h><w>ryanbrush</w>An announcement: Clara 0.12.0 has been released! There have been a bunch of performance enhancements from @wparker and @mikerod, and a handful of bug fixes as well. Details are in the change log: <a href="https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0120" target="_blank">https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md#0120</a></z><z id="t1472485117000002" t="ramji013 Hi All, I am new to Clara rules. One of my usecase I supposed to iterate list of object and perform validations in clojure. Anyone could you please suggest an approach, how it can be done? "><y>#</y><d>2016-08-29</d><h>15:38</h><w>ramji013</w>Hi All, I am new to Clara rules. One of my usecase I supposed to iterate list of object and perform validations in clojure. Anyone could you please suggest an approach, how it can be done? </z><z id="t1472546999000003" t="wparker @ramji013 : It seems like something like (filter valid-object? object) if you just want the collection of invalid objects or something like (when (some invalid-object? objects) (throw code-to-create-exception-here)) if you want to fail on an invalid object would work if you have a simple predicate. From your comment I’m not sure why Clara would be helpful. Perhaps there is some other complication to your use-case though."><y>#</y><d>2016-08-30</d><h>08:49</h><w>wparker</w>@ramji013 : It seems like something like (filter valid-object? object) if you just want the collection of invalid objects or something like (when (some invalid-object? objects) (throw code-to-create-exception-here)) if you want to fail on an invalid object would work if you have a simple predicate.  From your comment I’m not sure why Clara would be helpful. Perhaps there is some other complication to your use-case though.</z><z id="t1472649439000004" t="mikerod ramji013 without a little more context, it is hard to assist much, as wparker pointed out. I will also add that if you have large collections of objects though, it is often better to insert them all into the Clara session separately or “extract” them in a rule and perform the inserts in the RHS (right-hand side) of the rule. From there you can assert the validity of objects in a object-at-a-time sort of pattern matching. This can be helpful if you wish to then perform joins to/assertions with types of objects in the session’s working memory with these objects that you have decided were “valid&quot;."><y>#</y><d>2016-08-31</d><h>13:17</h><w>mikerod</w>ramji013 without a little more context, it is hard to assist much, as wparker pointed out.  I will also add that if you have large collections of objects though, it is often better to insert them all into the Clara session separately or “extract” them in a rule and perform the inserts in the RHS (right-hand side) of the rule.  From there you can assert the validity of objects in a object-at-a-time sort of pattern matching.  This can be helpful if you wish to then perform joins to/assertions with  types of objects in the session’s working memory with these objects that you have decided were “valid&quot;.</z><z id="t1472889599000002" t="flavio hello all, I am experimenting with accumulators and face following problem where I would need your expertise. I have following rule: (def oldest-person (acc/max :age :returns-fact true)) (defrule get-oldest-person [?senile-person &lt;- oldest-person :from [Person (= ?name name)]] =&gt; (println (str &quot;The oldest person is aged &quot; (.getAge ?senile-person) &quot;. The person&apos;s name is &quot; ?name)) ) The Person fact is a java bean. The accumulator doesn&apos;t seem to do anything with the :age variable, as the output is not accumulated: The oldest person is aged 50. The person&apos;s name is Person 3 The oldest person is aged 150. The person&apos;s name is Person 4 The oldest person is aged 200. The person&apos;s name is Person 1 The oldest person is aged 100. The person&apos;s name is Person 2 I suspect I am not passing the right variable binding to the accumulator, but I am not sure what to change. (.getAge) instead of :age throws an exception when compiling. Thanks for any pointers."><y>#</y><d>2016-09-03</d><h>07:59</h><w>flavio</w>hello all, I am experimenting with accumulators and face following problem where I would need your expertise. I have following rule: 

(def oldest-person (acc/max :age :returns-fact true))

(defrule get-oldest-person
         [?senile-person &lt;- oldest-person :from [Person (= ?name name)]]
         =&gt;
         (println (str  &quot;The oldest person is aged &quot; (.getAge ?senile-person)  &quot;. The person&apos;s name is &quot; ?name))
         )
The Person fact is a java bean. The accumulator doesn&apos;t seem to do anything with the :age variable, as the output is not accumulated:

The oldest person is aged 50. The person&apos;s name is Person 3
The oldest person is aged 150. The person&apos;s name is Person 4
The oldest person is aged 200. The person&apos;s name is Person 1
The oldest person is aged 100. The person&apos;s name is Person 2

I suspect I am not passing the right variable binding to the accumulator, but I am not sure what to change. (.getAge) instead of :age throws an exception when compiling.

Thanks for any pointers.</z><z id="t1472950472000007" t="wparker @flavio Do you mean that you were trying to do something like (def oldest-person (acc/max (.getAge) :returns-fact true)) ? (.getAge) isn’t a valid Clojure expression; an interop form needs a target to invoke on. http://clojure.org/reference/java_interop might be helpful if you’re unfamiliar. Introducing the ?name binding in the accumulator will cause you to accumulate once per name, which doesn’t seem like what you would want in this example case. As chance would have it, I have a PR open to clara-site that discusses the subject. https://github.com/rbrush/clara-site/pull/8"><y>#</y><d>2016-09-04</d><h>00:54</h><w>wparker</w>@flavio Do you mean that you were trying to do something like  (def oldest-person (acc/max (.getAge) :returns-fact true))  ?  (.getAge) isn’t a valid Clojure expression; an interop form needs a target to invoke on.  <a href="http://clojure.org/reference/java_interop" target="_blank">http://clojure.org/reference/java_interop</a> might be helpful if you’re unfamiliar.  Introducing the ?name binding in the accumulator will cause you to accumulate once per name, which doesn’t seem like what you would want in this example case.  As chance would have it, I have a PR open to clara-site that discusses the subject. <a href="https://github.com/rbrush/clara-site/pull/8" target="_blank">https://github.com/rbrush/clara-site/pull/8</a></z><z id="t1472950628000009" t="wparker That grouping behavior isn’t new to 0.12, but there were some bugs around it before that were fixed in 0.12"><y>#</y><d>2016-09-04</d><h>00:57</h><w>wparker</w>That grouping behavior isn’t new to 0.12, but there were some bugs around it before that were fixed in 0.12</z><z id="t1473003039000010" t="flavio @wparker , thanks for the updated documentation on the accumulators. This explains the constraint part of the accumulator. I have now successfully run following example: (defrule get-old-person-count [?old-person-count &lt;- (acc/count) :from [Person]] =&gt; (println (str &quot;The number of elderly persons is &quot; ?old-person-count)) ) Which returns the number of Person facts as expected. However, I am still struggling with accumulators expecting a field to work with: (defrule get-old-person-max-age [?oldest-age &lt;- (acc/max :age ) :from [Person]] =&gt; (println (str &quot;The oldest person is aged: &quot; ?oldest-age)) ) Above rule throws a null pointer exception as it doesn&apos;t know what :age is. My question is how can I pass a field name to an accumulator where the field name comes from a Java Bean. I went through the Interop documentation multiple times but I can&apos;t seem to get it right. Thanks"><y>#</y><d>2016-09-04</d><h>15:30</h><w>flavio</w>@wparker , thanks for the updated documentation on the accumulators. This explains the constraint part of the accumulator. I have now successfully run following example: 
(defrule get-old-person-count
         [?old-person-count &lt;- (acc/count) :from [Person]]
         =&gt;
         (println (str &quot;The number of elderly persons is &quot; ?old-person-count))
         )
Which returns the number of Person facts as expected. 
However, I am still struggling with accumulators expecting a field to work with:

(defrule get-old-person-max-age
         [?oldest-age &lt;- (acc/max :age ) :from [Person]]
         =&gt;
         (println (str &quot;The oldest person is aged: &quot; ?oldest-age))
         )

Above rule throws a null pointer exception as it doesn&apos;t know what :age is. My question is how can I pass a field name to an accumulator where the field name comes from a Java Bean. I went through the Interop documentation multiple times but I can&apos;t seem to get it right. 
Thanks</z><z id="t1473064680000013" t="wparker I’d surmise that you’re doing numeric comparisons on nil, though I can’t be sure without a stack trace. You probably need something like (def oldest-person (acc/max #(.getAge %) :returns-fact true)). In your original you use :age as a function, but when you look a keyword up on something that is not a Clojure map you just get nil. You can refer to fields by name in Clara rules and queries due to some special handling by Clara’s compiler, but that isn’t the case when you define accumulators, which are really just maps of keywords to Clojure functions if you take a look at what the value of oldest-person ends up being in a REPL."><y>#</y><d>2016-09-05</d><h>08:38</h><w>wparker</w>I’d surmise that you’re doing numeric comparisons on nil, though I can’t be sure without a stack trace.  You probably need something like (def oldest-person (acc/max #(.getAge %) :returns-fact true)).  In your original you use :age as a function, but when you look a keyword up on something that is not a Clojure map you just get nil.  You can refer to fields by name in Clara rules and queries due to some special handling by Clara’s compiler, but that isn’t the case when you define accumulators, which are really just maps of keywords to Clojure functions if you take a look at what the value of oldest-person ends up being in a REPL.</z><z id="t1473064688000014" t="wparker @flavio"><y>#</y><d>2016-09-05</d><h>08:38</h><w>wparker</w>@flavio</z><z id="t1473065819000015" t="flavio @wparker: thanks a lot for the response, this was the syntax I was looking for. I couldn&apos;t find it on the Java interop page. "><y>#</y><d>2016-09-05</d><h>08:56</h><w>flavio</w>@wparker: thanks a lot for the response,  this was the syntax I was looking for. I couldn&apos;t find it on the Java interop page. </z><z id="t1473257573000016" t="mikerod flavio is you want to avoid reflection, you’ll have to type-hint the .getAge call too"><y>#</y><d>2016-09-07</d><h>14:12</h><w>mikerod</w>flavio is you want to avoid reflection, you’ll have to type-hint the <code>.getAge</code> call too</z><z id="t1473257584000017" t="mikerod Same as any other Clojure expression and Java interop"><y>#</y><d>2016-09-07</d><h>14:13</h><w>mikerod</w>Same as any other Clojure expression and Java interop</z><z id="t1473337910000018" t="flavio @mikerod, is it generally good practise to type-hint for perfomance reasons? Are you guys recommending it? or, why should I not do it?"><y>#</y><d>2016-09-08</d><h>12:31</h><w>flavio</w>@mikerod, is it generally good practise to type-hint for perfomance reasons? Are you guys recommending it?
or, why should I not do it?</z><z id="t1473368383000020" t="wparker I suggest reading https://kotka.de/blog/2012/06/Did_you_know_IX.html . A very short explanation is that the JVM can compile something like (.someMethod x) to run faster if the type of x is known at compile time. In absolute terms, though, even without type hints the calls are still fast. In our codebase we make a point of avoiding reflection since 1. We work at a very large scale that makes such bottlenecks matter. 2. It is easier to avoid reflection entirely than to have to release our code again when it turns out there is a major perf problem. What you should do depends on your use-case and the attendant tradeoffs; some people don’t (and shouldn’t for their use-cases) care about reflection"><y>#</y><d>2016-09-08</d><h>20:59</h><w>wparker</w>I suggest reading <a href="https://kotka.de/blog/2012/06/Did_you_know_IX.html" target="_blank">https://kotka.de/blog/2012/06/Did_you_know_IX.html</a> .  A very short explanation is that the JVM can compile something like (.someMethod x) to run faster if the type of x is known at compile time.  In absolute terms, though, even without type hints the calls are still fast.  In our codebase we make a point of avoiding reflection since 1. We work at a very large scale that makes such bottlenecks matter. 2. It is easier to avoid reflection entirely than to have to release our code again when it turns out there is a major perf problem.  What you should do depends on your use-case and the attendant tradeoffs; some people don’t (and shouldn’t for their use-cases) care about reflection</z><z id="t1473868654000021" t="mikerod @flavio yeah, I would say that reflection does have a significant performance penalty, but all of what Will had to say about it is probably the standard advice there."><y>#</y><d>2016-09-14</d><h>15:57</h><w>mikerod</w>@flavio yeah, I would say that reflection does have a significant performance penalty, but all of what Will had to say about it is probably the standard advice there.</z><z id="t1473868709000022" t="mikerod Also, see the official Clojure stance http://clojure.org/reference/java_interop#typehints which I believe is written by Rich himself"><y>#</y><d>2016-09-14</d><h>15:58</h><w>mikerod</w>Also, see the official Clojure stance <a href="http://clojure.org/reference/java_interop#typehints" target="_blank">http://clojure.org/reference/java_interop#typehints</a> which I believe is written by Rich himself</z><z id="t1473868781000023" t="mikerod In our applications, we don’t want to risk/spend the performance penalty though, so we aggressively eliminate reflection warnings. The Clara compiler does give some effort in ensuring type hints are automatically added where the Clara compiler can effectively infer the types. However, that only goes so far."><y>#</y><d>2016-09-14</d><h>15:59</h><w>mikerod</w>In our applications, we don’t want to risk/spend the performance penalty though, so we aggressively eliminate reflection warnings.  The Clara compiler does give some effort in ensuring type hints are automatically added where the Clara compiler can effectively infer the types.  However, that only goes so far.</z><z id="t1474094160000025" t="flavio Thanks for the advice. Will definitely try to avoid reflection. "><y>#</y><d>2016-09-17</d><h>06:36</h><w>flavio</w>Thanks for the advice. Will definitely try to avoid reflection. </z><z id="t1474296828000027" t="ramkumarkb Hello, I am trying to use Clara in a project and was wondering if there is any way to insert facts both from Java &amp; Clojure, before firing the rules. The idea is that one could transition from Java for existing facts but use Clojure for inserting new facts, before firing all the rules (which is in Clara DSL). I was trying to read the docs here : http://www.clara-rules.org/docs/java/ But could not find any example where facts are inserted both from Java &amp; Clojure. Any pointers would be immensely helpful. Thank you!"><y>#</y><d>2016-09-19</d><h>14:53</h><w>ramkumarkb</w>Hello, I am trying to use Clara in a project and was wondering if there is any way to insert facts both from Java &amp; Clojure, before firing the rules. The idea is that one could transition from Java for existing facts but use Clojure for inserting new facts, before firing all the rules (which is in Clara DSL).

I was trying to read the docs here : <a href="http://www.clara-rules.org/docs/java/" target="_blank">http://www.clara-rules.org/docs/java/</a>  But could not find any example where facts are inserted both from Java &amp; Clojure. Any pointers would be immensely helpful.

Thank you!</z><z id="t1474313731000031" t="devn Thoughts on generating a graph based on rule firings?"><y>#</y><d>2016-09-19</d><h>19:35</h><w>devn</w>Thoughts on generating a graph based on rule firings?</z><z id="t1474362198000032" t="wparker @ramkumarkb : If you mean that the facts are Java objects, I don’t see any barrier to that; JavaBeans are a very normal Clara fact. If you mean working in Clojure with a Java session of the sort in the docs you linked, you can interact with it via Clojure’s Java interop; see https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_java.clj#L42 for an example"><y>#</y><d>2016-09-20</d><h>09:03</h><w>wparker</w>@ramkumarkb : If you mean that the facts are Java objects, I don’t see any barrier to that; JavaBeans are a very normal Clara fact.  If you mean working in Clojure with a Java session of the sort in the docs you linked, you can interact with it via Clojure’s Java interop; see <a href="https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_java.clj#L42" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/test/clojure/clara/test_java.clj#L42</a> for an example</z><z id="t1474387531000034" t="wparker @devn I think https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.clj#L67 has the info you’d need for truth maintenance governed facts anyway, clara-tools builds on this https://github.com/rbrush/clara-tools/blob/master/src/main/clojure/clara/tools/impl/facts.clj"><y>#</y><d>2016-09-20</d><h>16:05</h><w>wparker</w>@devn I think <a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.clj#L67" target="_blank">https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.clj#L67</a> has the info you’d need for truth maintenance governed facts anyway, clara-tools builds on this <a href="https://github.com/rbrush/clara-tools/blob/master/src/main/clojure/clara/tools/impl/facts.clj" target="_blank">https://github.com/rbrush/clara-tools/blob/master/src/main/clojure/clara/tools/impl/facts.clj</a></z><z id="t1474387566000036" t="wparker My understanding is that this ultimately works because Clara stores logical insertions in the activation-memory"><y>#</y><d>2016-09-20</d><h>16:06</h><w>wparker</w>My understanding is that this ultimately works because Clara stores logical insertions in the activation-memory</z><z id="t1474387641000037" t="wparker I’m curious - do you have a particular sort of case in mind?"><y>#</y><d>2016-09-20</d><h>16:07</h><w>wparker</w>I’m curious - do you have a particular sort of case in mind?</z><z id="t1474387685000038" t="wparker The graphs in clara-tools seem to work OK, though when I last poked around at them there seemed to be some oddities around accumulators, but I haven’t looked at it much yet"><y>#</y><d>2016-09-20</d><h>16:08</h><w>wparker</w>The graphs in clara-tools seem to work OK, though when I last poked around at them there seemed to be some oddities around accumulators, but I haven’t looked at it much yet</z><z id="t1474387705000039" t="devn @wparker Our rules are pretty DAG-y, and continue to grow in number"><y>#</y><d>2016-09-20</d><h>16:08</h><w>devn</w>@wparker Our rules are pretty DAG-y, and continue to grow in number</z><z id="t1474387741000040" t="devn for the sake of development, understanding the flow, it&apos;d be nice to output the rules as a graph for a particular run"><y>#</y><d>2016-09-20</d><h>16:09</h><w>devn</w>for the sake of development, understanding the flow, it&apos;d be nice to output the rules as a graph for a particular run</z><z id="t1474387773000041" t="wparker Ah, so more of a static thing than as a web app like clara-tools perhaps"><y>#</y><d>2016-09-20</d><h>16:09</h><w>wparker</w>Ah, so more of a static thing than as a web app like clara-tools perhaps</z><z id="t1474387786000043" t="devn I want to show someone who works directly with a customer the decision tree"><y>#</y><d>2016-09-20</d><h>16:09</h><w>devn</w>I want to show someone who works directly with a customer the decision tree</z><z id="t1474387849000044" t="devn though, as time goes on, a more interactive tool could be nice, to simulate what might happen if a rule were added to do X"><y>#</y><d>2016-09-20</d><h>16:10</h><w>devn</w>though, as time goes on, a more interactive tool could be nice, to simulate what might happen if a rule were added to do X</z><z id="t1474387890000045" t="wparker yeah, something like a static doc visualization to hand someone could be useful"><y>#</y><d>2016-09-20</d><h>16:11</h><w>wparker</w>yeah, something like a static doc visualization to hand someone could be useful</z><z id="t1474661302000047" t="devn I&apos;m havin&apos; a lot of thoughts..."><y>#</y><d>2016-09-23</d><h>20:08</h><w>devn</w>I&apos;m havin&apos; a lot of thoughts...</z><z id="t1474661331000048" t="devn @wparker you specifically said in the above &quot;the info you&apos;d need for truth maintenance governed facts&quot;"><y>#</y><d>2016-09-23</d><h>20:08</h><w>devn</w>@wparker you specifically said in the above &quot;the info you&apos;d need for truth maintenance governed facts&quot;</z><z id="t1474661364000049" t="devn it got me wondering about some of our logic. there are places in our rules where im thinking unconditional insertion would improve our ability to reason about the rules"><y>#</y><d>2016-09-23</d><h>20:09</h><w>devn</w>it got me wondering about some of our logic. there are places in our rules where im thinking unconditional insertion would improve our ability to reason about the rules</z><z id="t1474661386000050" t="devn it&apos;s kind of a place to hang your hat: &quot;You can always rely on me being there. Nothing can undo this.&quot;"><y>#</y><d>2016-09-23</d><h>20:09</h><w>devn</w>it&apos;s kind of a place to hang your hat: &quot;You can always rely on me being there. Nothing can undo this.&quot;</z><z id="t1474661434000051" t="devn It strikes me a bit like the convention of using do--- on functions which have side effects"><y>#</y><d>2016-09-23</d><h>20:10</h><w>devn</w>It strikes me a bit like the convention of using <code>do---</code> on functions which have side effects</z><z id="t1474661480000052" t="devn in the same way, im thinking about unconditional insertion to mark the territory of where branching will never happen, or ought to be expected not to happen"><y>#</y><d>2016-09-23</d><h>20:11</h><w>devn</w>in the same way, im thinking about unconditional insertion to mark the territory of where branching will never happen, or ought to be expected not to happen</z><z id="t1474973114000053" t="wparker @devn the reason for truth maintenance governed facts to have more information available is that when facts are inserted using truth maintenance, the memory stores information to the effective of “this fact was inserted from this rule based on X other facts”. The code in the memory is at https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/memory.cljc#L685 This is only called if truth maintenance is used; if you use unconditional insertions it won’t be. You can see the conditional on that at https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L228 It is a little confusing because the ProductionNode will add “activations” in any case, but Clara batches insertions from them in the activation-memory as a sort of queue, then pops them off when you call fire-rules https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L1483 As far as the reasoning behind this, truth maintenance does have some performance cost. If you do want to keep track of unconditional assertions, I suspect a way to do it with listeners could be found."><y>#</y><d>2016-09-27</d><h>10:45</h><w>wparker</w>@devn the reason for truth maintenance governed facts to have more information available is that when facts are inserted using truth maintenance, the memory stores information to the effective of “this fact was inserted from this rule based on X other facts”.  The code in the memory is at <a href="https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/memory.cljc#L685" target="_blank">https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/memory.cljc#L685</a>  This is only called if truth maintenance is used; if you use unconditional insertions it won’t be.  You can see the conditional on that at <a href="https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L228" target="_blank">https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L228</a>  It is a little confusing because the ProductionNode will add “activations” in any case, but Clara batches insertions from them in the activation-memory as a sort of queue, then pops them off when you call fire-rules <a href="https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L1483" target="_blank">https://github.com/rbrush/clara-rules/blob/0.12.0/src/main/clojure/clara/rules/engine.cljc#L1483</a>  As far as the reasoning behind this, truth maintenance does have some performance cost.  If you do want to keep track of unconditional assertions, I suspect a way to do it with listeners could be found.</z><z id="t1474973530000055" t="wparker As far as simplicity, I’d suggest keeping in mind that rules can fire based on intermediate state in the rules engine that won’t be reflected in the final state after the fire-rules loop finishes, and unconditional insertions can thus reflect such intermediate state. In our case, we have a mostly stark dividing line between “types of facts that can be inserted from outside the session” and “facts that can be created by rules”; our unconditional insertions tend to be from rules whose LHS looks for things of the former types. Thinking through how the intermediate state of the rules engine will play out can get pretty tricky and may be non-guaranteed behavior depending on the use case. There are certainly many legitimate use cases for unconditional insertions though."><y>#</y><d>2016-09-27</d><h>10:52</h><w>wparker</w>As far as simplicity, I’d suggest keeping in mind that rules can fire based on intermediate state in the rules engine that won’t be reflected in the final state after the fire-rules loop finishes, and unconditional insertions can thus reflect such intermediate state.  In our case, we have a mostly stark dividing line between “types of facts that can be inserted from outside the session” and “facts that can be created by rules”; our unconditional insertions tend to be from rules whose LHS looks for things of the former types.  Thinking through how the intermediate state of the rules engine will play out can get pretty tricky and may be non-guaranteed behavior depending on the use case.  There are certainly many legitimate use cases for unconditional insertions though.</z><z id="t1476795606000057" t="tbrooke I started playing with the protege IDE associated with Rete4frames https://github.com/rururu/rete4frames and wondered about using protege with Clara -I am not sure how it is integrated but it might be a nice way to build up an ontology for use in a Clara rules system"><y>#</y><d>2016-10-18</d><h>13:00</h><w>tbrooke</w>I started playing with the protege IDE associated with Rete4frames <a href="https://github.com/rururu/rete4frames" target="_blank">https://github.com/rururu/rete4frames</a> and wondered about using protege with Clara -I am not sure how it is integrated but it might be a nice way to build up an ontology for use in a Clara rules system</z><z id="t1476891636000059" t="ryanbrush @tbrooke I haven&apos;t used Protege, so it&apos;s not obvious to me how this would plug in. Clara&apos;s core Rete implementation could be invoked by external tools that generate rules. Most of our usage of Clara is based around rules working with arbitrary Clojure records rather than specialized templates or RDF-style tuples, so we typically use a more conventional development environment."><y>#</y><d>2016-10-19</d><h>15:40</h><w>ryanbrush</w>@tbrooke I haven&apos;t used Protege, so it&apos;s not obvious to me how this would plug in. Clara&apos;s core Rete implementation could be invoked by external tools that generate rules. Most of our usage of Clara is based around rules working with arbitrary Clojure records rather than specialized templates or RDF-style tuples, so we typically use a more conventional development environment.</z><z id="t1476891755000060" t="ryanbrush That said, a template-style approach could certainly use Clara&apos;s rete implementation. To illustrate this, rules could be generated from an external structure like how I describe here: http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/ So some front end tool could produce the rule structure that is then converted to Clara rules using a pattern similar to that post."><y>#</y><d>2016-10-19</d><h>15:42</h><w>ryanbrush</w>That said, a template-style approach could certainly use Clara&apos;s rete implementation. To illustrate this, rules could be generated from an external structure like how I describe here: <a href="http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/" target="_blank">http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/</a> So some front end tool could produce the rule structure that is then converted to Clara rules using a pattern similar to that post.</z><z id="t1477189640000062" t="alex-dixon Anyone made a clara app with reagent yet? 😄"><y>#</y><d>2016-10-23</d><h>02:27</h><w>alex-dixon</w>Anyone made a clara app with reagent yet? <b>😄</b></z><z id="t1477383521000063" t="wparker The (experimental) clara-tools project uses Reagent https://github.com/rbrush/clara-tools , but it is focused on displaying the logic from a JVM rules session, not using rules in cljs to drive an application. I’d be curious too if there is any such usage."><y>#</y><d>2016-10-25</d><h>08:18</h><w>wparker</w>The (experimental) clara-tools project uses Reagent <a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a>, but it is focused on displaying the logic from a JVM rules session, not using rules in cljs to drive an application.  I’d be curious too if there is any such usage.</z><z id="t1477624363000066" t="ramkumarkb @wparker: Hi William, With reference to your discussion thread on conditional activation: https://groups.google.com/forum/#!searchin/clara-rules/conditional$20activation%7Csort:relevance/clara-rules/w_Iq7zom2bU/OFcbeFZlCwAJ We have a similar requirement when we want to fire rule-3, when either rule-1 or rule-2 does not fire for a fact of TypeA We find that the [:not [Logicamarker ]] approach is not working as it appears that RETE engine fires the rule bcos before the rule-1 or rule-2 creates the LogicalMarker, rule-3 LHS seems to be satisfied. Any tips would be really helpful. (defrecord LogicalMarker [marker prop1 prop2] (defrule rule-1 [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)] [?x &lt;- TypeX] =&gt; (insert! (map-&gt;LogicalMarker {:marker &quot;1&quot; :prop1 ?prop1 :prop2 ?prop2})) (defrule rule-2 [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)] [?y &lt;- TypeY] =&gt; (insert! (map-&gt;LogicalMarker {:marker &quot;2&quot; :prop1 ?prop1 :prop2 ?prop2})) (defrule rule-3 [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)] [:not [LogicalMarker (= ?prop1 :prop1) (= ?prop2 :prop2)]] =&gt; (println &quot;Conditional Rule executed successfully!&quot;)"><y>#</y><d>2016-10-28</d><h>03:12</h><w>ramkumarkb</w>@wparker: Hi William, 

With reference to your discussion thread on conditional activation:
<a href="https://groups.google.com/forum/#!searchin/clara-rules/conditional$20activation%7Csort:relevance/clara-rules/w_Iq7zom2bU/OFcbeFZlCwAJ" target="_blank">https://groups.google.com/forum/#!searchin/clara-rules/conditional$20activation%7Csort:relevance/clara-rules/w_Iq7zom2bU/OFcbeFZlCwAJ</a> 

We have a similar requirement when we want to fire rule-3, when either rule-1 or rule-2 does not fire for a fact of TypeA

We find that the [:not [Logicamarker ]] approach is not working as it appears that RETE engine fires the rule bcos before the rule-1 or rule-2 creates the LogicalMarker, rule-3 LHS seems to be satisfied.

Any tips would be really helpful.

(defrecord LogicalMarker [marker prop1 prop2]
(defrule rule-1
    [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)]
    [?x &lt;- TypeX]
    =&gt;
   (insert! (map-&gt;LogicalMarker {:marker &quot;1&quot; :prop1 ?prop1 :prop2 ?prop2}))
   
(defrule rule-2
    [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)]
    [?y &lt;- TypeY]
    =&gt;
    (insert! (map-&gt;LogicalMarker {:marker &quot;2&quot; :prop1 ?prop1 :prop2 ?prop2}))
    
(defrule rule-3
    [?a &lt;- TypeA (= ?prop1 prop1) (= ?prop2 prop2)]
    [:not [LogicalMarker (= ?prop1 :prop1) (= ?prop2 :prop2)]]
    =&gt;
   (println &quot;Conditional Rule executed successfully!&quot;)</z><z id="t1477681176000067" t="ryanbrush Hey @ramkumarkb, I posted a response on the Google Group thread. Hopefully that helps."><y>#</y><d>2016-10-28</d><h>18:59</h><w>ryanbrush</w>Hey @ramkumarkb, I posted a response on the Google Group thread. Hopefully that helps.</z><z id="t1478875632000069" t="ryanbrush Hey everyone, a quick announcement regarding Clara: we&apos;ve been using it heavily in production at Cerner for some time, so we&apos;re making it official an open source project sponsored by Cerner."><y>#</y><d>2016-11-11</d><h>14:47</h><w>ryanbrush</w>Hey everyone, a quick announcement regarding Clara: we&apos;ve been using it heavily in production at Cerner for some time, so we&apos;re making it official an open source project sponsored by Cerner.</z><z id="t1478875683000070" t="ryanbrush You can see the announcement here: http://engineering.cerner.com/blog/clara-rules-joins-cerner-open-source/"><y>#</y><d>2016-11-11</d><h>14:48</h><w>ryanbrush</w>You can see the announcement here: <a href="http://engineering.cerner.com/blog/clara-rules-joins-cerner-open-source/" target="_blank">http://engineering.cerner.com/blog/clara-rules-joins-cerner-open-source/</a></z><z id="t1478875797000071" t="ryanbrush This is a good thing for Clara. It reflects its importance to our production systems, and shows this project will be maintained far into the future. Otherwise, not much else will change from the users&apos; perspective; it&apos;s the same code in a new location, with all future releases in the com.cerner group on Clojars."><y>#</y><d>2016-11-11</d><h>14:49</h><w>ryanbrush</w>This is a good thing for Clara. It reflects its importance to our production systems, and shows this project will be maintained far into the future. Otherwise, not much else will change from the users&apos; perspective; it&apos;s the same code in a new location, with all future releases in the com.cerner group on Clojars.</z><z id="t1479334901000073" t="surreal.analysis I think I’m missing something with accumulators - I’d like to have some sort of collection of reasons that something failed"><y>#</y><d>2016-11-16</d><h>22:21</h><w>surreal.analysis</w>I think I’m missing something with accumulators - I’d like to have some sort of collection of reasons that something failed</z><z id="t1479334911000074" t="surreal.analysis Originally I thought the best way to do that would be to have rules for each mode of failure"><y>#</y><d>2016-11-16</d><h>22:21</h><w>surreal.analysis</w>Originally I thought the best way to do that would be to have rules for each mode of failure</z><z id="t1479334919000075" t="surreal.analysis And those rules would add a fact with a reason"><y>#</y><d>2016-11-16</d><h>22:21</h><w>surreal.analysis</w>And those rules would add a fact with a reason</z><z id="t1479334933000076" t="surreal.analysis Test code here: (defrecord DomainObject [name1 name2]) (defrecord Invalid [reason]) (defrule name1-not-test [DomainObject (not= name1 &quot;test&quot;)] =&gt; (insert! (-&gt;Invalid &quot;test&quot;))) (defrule name2-is-test [DomainObject (= name2 &quot;test&quot;)] =&gt; (insert! (-&gt;Invalid &quot;name2 test&quot;))) (defrule collect-invalids [?reasons &lt;- (acc/all) :from [Invalid]] =&gt; (prn &quot;Invalid for: &quot; (map :reason ?reasons))) "><y>#</y><d>2016-11-16</d><h>22:22</h><w>surreal.analysis</w>Test code here:

<pre>(defrecord DomainObject [name1 name2])
(defrecord Invalid [reason])

(defrule name1-not-test
  [DomainObject (not= name1 &quot;test&quot;)]
  =&gt;
  (insert! (-&gt;Invalid &quot;test&quot;)))

(defrule name2-is-test
  [DomainObject (= name2 &quot;test&quot;)]
  =&gt;
  (insert! (-&gt;Invalid &quot;name2 test&quot;)))

(defrule collect-invalids
  [?reasons &lt;- (acc/all) :from [Invalid]]
  =&gt;
  (prn &quot;Invalid for: &quot; (map :reason ?reasons)))
</pre></z><z id="t1479334947000077" t="surreal.analysis When run with: (-&gt; (mk-session &apos;clara-playground.core) (insert (-&gt;DomainObject &quot;nottest&quot; &quot;test&quot;)) (fire-rules))"><y>#</y><d>2016-11-16</d><h>22:22</h><w>surreal.analysis</w>When run with:
<pre>(-&gt; (mk-session &apos;clara-playground.core)
                           (insert (-&gt;DomainObject &quot;nottest&quot; &quot;test&quot;))
                           (fire-rules))</pre></z><z id="t1479334954000078" t="surreal.analysis The output is &quot;Invalid for: &quot; () &quot;Invalid for: &quot; (&quot;test&quot; &quot;name2 test&quot;) "><y>#</y><d>2016-11-16</d><h>22:22</h><w>surreal.analysis</w>The output is <pre>&quot;Invalid for: &quot; ()
&quot;Invalid for: &quot; (&quot;test&quot; &quot;name2 test&quot;)
</pre></z><z id="t1479334966000079" t="surreal.analysis After reading more on the accumulator side, I added a restriction"><y>#</y><d>2016-11-16</d><h>22:22</h><w>surreal.analysis</w>After reading more on the accumulator side, I added a restriction</z><z id="t1479334979000080" t="surreal.analysis And rewrote collect-invalids as (defrule collect-invalids [?reasons &lt;- (acc/all) :from [Invalid (= ?reason reason)]] =&gt; (prn &quot;Invalid for: &quot; (map :reason ?reasons))) "><y>#</y><d>2016-11-16</d><h>22:22</h><w>surreal.analysis</w>And rewrote <code>collect-invalids</code> as <pre>(defrule collect-invalids
  [?reasons &lt;- (acc/all) :from [Invalid (= ?reason reason)]]
  =&gt;
  (prn &quot;Invalid for: &quot; (map :reason ?reasons)))
</pre></z><z id="t1479334989000081" t="surreal.analysis But that output is &quot;Invalid for: &quot; (&quot;test&quot;) &quot;Invalid for: &quot; (&quot;name2 test&quot;) "><y>#</y><d>2016-11-16</d><h>22:23</h><w>surreal.analysis</w>But that output is <pre>&quot;Invalid for: &quot; (&quot;test&quot;)
&quot;Invalid for: &quot; (&quot;name2 test&quot;)
</pre></z><z id="t1479334993000082" t="surreal.analysis Any suggestions on what I’m missing?"><y>#</y><d>2016-11-16</d><h>22:23</h><w>surreal.analysis</w>Any suggestions on what I’m missing?</z><z id="t1479335095000083" t="surreal.analysis If it’s unclear, I want collect-invalids to fire a single time, with all the reasons"><y>#</y><d>2016-11-16</d><h>22:24</h><w>surreal.analysis</w>If it’s unclear, I want <code>collect-invalids</code> to fire a single time, with all the reasons</z><z id="t1479335346000084" t="surreal.analysis Or is this something that’s better left to queries?"><y>#</y><d>2016-11-16</d><h>22:29</h><w>surreal.analysis</w>Or is this something that’s better left to queries?</z><z id="t1479375098000085" t="wparker @surreal.analysis I think this is expected behavior. The contract from Clara is that the state after all rules finish firing will be consistent with the rules, but the steps Clara takes to get there inside fire-rules are undefined except if you provide salience. Your print statements are reflecting intermediate state in the rules engine that is eliminated before fire-rules returns. So in your first example, collect-invalids fired with no Invalid facts because none had been created yet; once Invalid facts were created it fired with them. If collect-invalids had inserted other fact(s) the facts inserted by the firing with no Invalid facts yet would be removed before fire-rules returned to the caller. For something like this I’d suggest using queries or inserting another fact using insert! since these will be adjusted by the truth maintenance system when Invalid facts are added to the session."><y>#</y><d>2016-11-17</d><h>09:31</h><w>wparker</w>@surreal.analysis I think this is expected behavior.  The contract from Clara is that the state after all rules finish firing will be consistent with the rules, but the steps Clara takes to get there inside fire-rules are undefined except if you provide salience.  Your print statements are reflecting intermediate state in the rules engine that is eliminated before fire-rules returns.  So in your first example, collect-invalids fired with no Invalid facts because none had been created yet; once Invalid facts were created it fired with them.  If collect-invalids had inserted other fact(s) the facts inserted by the firing with no Invalid facts yet would be removed before fire-rules returned to the caller.  For something like this I’d suggest using queries or inserting another fact using insert! since these will be adjusted by the truth maintenance system when Invalid facts are added to the session.</z><z id="t1479375137000086" t="wparker So something like (defquery invalid-query “query for Invalid” [Invalid (= reason ?reason)])"><y>#</y><d>2016-11-17</d><h>09:32</h><w>wparker</w>So something like  (defquery invalid-query “query for Invalid” [Invalid (= reason ?reason)])</z><z id="t1479375162000087" t="wparker Or (defrecord CollectedInvalid [all-invalid-reasons])"><y>#</y><d>2016-11-17</d><h>09:32</h><w>wparker</w>Or (defrecord CollectedInvalid [all-invalid-reasons])</z><z id="t1479375204000088" t="wparker (defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt; ;; for exame"><y>#</y><d>2016-11-17</d><h>09:33</h><w>wparker</w>(defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt; ;; for exame</z><z id="t1479375211000089" t="wparker ``"><y>#</y><d>2016-11-17</d><h>09:33</h><w>wparker</w><code></code>``</z><z id="t1479375216000090" t="wparker (defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt;"><y>#</y><d>2016-11-17</d><h>09:33</h><w>wparker</w>(defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt;</z><z id="t1479375241000091" t="wparker =&gt; ;; do something here that doesn’t depend on intermediate state"><y>#</y><d>2016-11-17</d><h>09:34</h><w>wparker</w>=&gt; ;; do something here that doesn’t depend on intermediate state</z><z id="t1479375286000092" t="wparker Ignore &quot;(defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt; ;; for exame [9:33] ``” please, I was trying to set up a code block but apparently don’t know how to do so in Slack 😛"><y>#</y><d>2016-11-17</d><h>09:34</h><w>wparker</w>Ignore &quot;(defrule get-all-invalid [?invalids &lt;- (acc/all) :from [Invalid]] =&gt; ;; for exame

[9:33]  
<code></code>``” please, I was trying to set up a code block but apparently don’t know how to do so in Slack <b>😛</b></z><z id="t1479375302000093" t="wparker When you did"><y>#</y><d>2016-11-17</d><h>09:35</h><w>wparker</w>When you did</z><z id="t1479375304000094" t="wparker (defrule collect-invalids [?reasons &lt;- (acc/all) :from [Invalid (= ?reason reason)]] =&gt; (prn &quot;Invalid for: &quot; (map :reason ?reasons)))"><y>#</y><d>2016-11-17</d><h>09:35</h><w>wparker</w>(defrule collect-invalids
  [?reasons &lt;- (acc/all) :from [Invalid (= ?reason reason)]]
  =&gt;
  (prn &quot;Invalid for: &quot; (map :reason ?reasons)))</z><z id="t1479375450000095" t="wparker You don’t fire when there are no Invalid facts since ?reason is not bound elsewhere (this is the behavior as of 0.12.0 at least, we fixed some bugs around accumulators that release). However, the effect of adding the ?reason binding in the accumulator condition is that you collect all Invalid facts for each reason and fire once per distinct reason."><y>#</y><d>2016-11-17</d><h>09:37</h><w>wparker</w>You don’t fire when there are no Invalid facts since ?reason is not bound elsewhere (this is the behavior as of 0.12.0 at least, we fixed some bugs around accumulators that release).  However, the effect of adding the ?reason binding in the accumulator condition is that you collect all Invalid facts for each reason and fire once per distinct reason.</z><z id="t1479375500000096" t="wparker So something like (defrule get-windspeeds-at-location [?wind &lt;- (acc/all) :from [WindSpeed (= ?location location)]] =&gt; ;; do something )"><y>#</y><d>2016-11-17</d><h>09:38</h><w>wparker</w>So something like (defrule get-windspeeds-at-location
  [?wind &lt;- (acc/all) :from [WindSpeed (= ?location location)]]
  =&gt;
  ;; do something
)</z><z id="t1479375589000097" t="wparker given four windspeeds, where two come from LocationA and two come from LocationB, would fire twice, once with ?wind bound to the WindSpeed from LocationA and once with ?wind bound to the WindSpeed facts from LocationB"><y>#</y><d>2016-11-17</d><h>09:39</h><w>wparker</w>given four windspeeds, where two come from LocationA and two come from LocationB, would fire twice, once with ?wind bound to the WindSpeed from LocationA and once with ?wind bound to the WindSpeed facts from LocationB</z><z id="t1479375676000098" t="wparker Hopefully this clears things up, please ask if it doesn’t and if anyone has thoughts on things at http://www.clara-rules.org/docs/accumulators/ that could be cleared up to reduce confusion I’d be interested"><y>#</y><d>2016-11-17</d><h>09:41</h><w>wparker</w>Hopefully this clears things up, please ask if it doesn’t and if anyone has thoughts on things at <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a> that could be cleared up to reduce confusion I’d be interested</z><z id="t1479937266000101" t="devn Query on queries: I’d like to find all the facts in the session of type MyFact, where myfact looks like this: #MyFact{:stuff #{{:a 1} {:b #AnotherFact{:c true}}}"><y>#</y><d>2016-11-23</d><h>21:41</h><w>devn</w>Query on queries: I’d like to find all the facts in the session of type MyFact, where myfact looks like this: <code>#MyFact{:stuff #{{:a 1} {:b #AnotherFact{:c true}}}</code></z><z id="t1479937335000102" t="devn I’d only like to find MyFact where #AnotherFact{:c true}"><y>#</y><d>2016-11-23</d><h>21:42</h><w>devn</w>I’d only like to find <code>MyFact</code> where <code>#AnotherFact{:c true}</code></z><z id="t1479939624000103" t="devn It’s unclear to me how parameterization of queries works. I have an arg :?foo to the query which is a keyword, but it does not correspond to a field on the fact."><y>#</y><d>2016-11-23</d><h>22:20</h><w>devn</w>It’s unclear to me how parameterization of queries works.

I have an arg :?foo to the query which is a keyword, but it does not correspond to a field on the fact.</z><z id="t1479940255000104" t="ryanbrush Query parameters just check for equality on a bound variable. So to query on a value in a nested structure, you&apos;ll need to bind that value itself to a variable. You can do this by just having an expression on the left-hand side that gets the nested field, e.g. (= ?foo (some-expr-to-get-a-value this)."><y>#</y><d>2016-11-23</d><h>22:30</h><w>ryanbrush</w>Query parameters just check for equality on a bound variable. So to query on a value in a nested structure, you&apos;ll need to bind that value itself to a variable. You can do this by just having an expression on the left-hand side that gets the nested field, e.g. (= ?foo (some-expr-to-get-a-value this).</z><z id="t1479940635000105" t="devn @ryanbrush ok that makes sense, but what if I need the parameter as an argument to the expr that retrieves a value?"><y>#</y><d>2016-11-23</d><h>22:37</h><w>devn</w>@ryanbrush ok that makes sense, but what if I need the parameter as an argument to the expr that retrieves a value?</z><z id="t1479940652000106" t="devn (= ?foo (get-in [:a ?foo :b] some-declared-field-on-the-toplevel-record))"><y>#</y><d>2016-11-23</d><h>22:37</h><w>devn</w><code>(= ?foo (get-in [:a ?foo :b] some-declared-field-on-the-toplevel-record))</code></z><z id="t1479940705000107" t="devn where ?foo is the parameter (defquery myquery [:?foo] …)"><y>#</y><d>2016-11-23</d><h>22:38</h><w>devn</w>where <code>?foo</code> is the parameter <code>(defquery myquery [:?foo] …)</code></z><z id="t1479940910000109" t="ryanbrush Yeah, queries only do equality checks on bound variables. You could either bind all combinations of the nested path if it&apos;s small enough, or have your query return more than you need and filter it out afterwards, or consider other ways to model the data. Not sure what would work best for your model."><y>#</y><d>2016-11-23</d><h>22:41</h><w>ryanbrush</w>Yeah, queries only do equality checks on bound variables. You could either bind all combinations of the nested path if it&apos;s small enough, or have your query return more than you need and filter it out afterwards, or consider other ways to model the data. Not sure what would work best for your model.</z><z id="t1479941004000110" t="devn @ryanbrush ok, that’s kind of where i guessed we were heading. though i dont totally grok the binding of all combinations of the nested path."><y>#</y><d>2016-11-23</d><h>22:43</h><w>devn</w>@ryanbrush ok, that’s kind of where i guessed we were heading. though i dont totally grok the binding of all combinations of the nested path.</z><z id="t1479941193000111" t="devn the use case is that there’s a blob of :contributing-facts that gets populated by a big collection of prior rules firing, and i want to write a query that finds all of the facts where the thing that contributed is :x . short of writing a ton of queries, or generating them dynamically, i’m not sure that changing the model will help much. this is the typical “let’s have one place where we can dump a grab bag of metadata”"><y>#</y><d>2016-11-23</d><h>22:46</h><w>devn</w>the use case is that there’s a blob of <code>:contributing-facts</code> that gets populated by a big collection of prior rules firing, and i want to write a query that finds all of the facts where the thing that contributed is <code>:x</code>. short of writing a ton of queries, or generating them dynamically, i’m not sure that changing the model will help much. this is the typical “let’s have one place where we can dump a grab bag of metadata”</z><z id="t1479941829000112" t="ryanbrush Yeah, I suspect having a function that scans query results, or finding another way to bind your additional criteria, would be your best bet."><y>#</y><d>2016-11-23</d><h>22:57</h><w>ryanbrush</w>Yeah, I suspect having a function that scans query results, or finding another way to bind your additional criteria, would be your best bet.</z><z id="t1479941880000113" t="devn @ryanbrush thanks for the help"><y>#</y><d>2016-11-23</d><h>22:58</h><w>devn</w>@ryanbrush thanks for the help</z><z id="t1479941897000114" t="ryanbrush Sure thing!"><y>#</y><d>2016-11-23</d><h>22:58</h><w>ryanbrush</w>Sure thing!</z><z id="t1480034393000115" t="nlessa Hi, is there any way to set an observable to a clara session to get any new insertion/rectraction fo facts? (I am wondering if it would be possible to use a clara session as a source of a stream of facts)."><y>#</y><d>2016-11-25</d><h>00:39</h><w>nlessa</w>Hi, is there any way to set an observable to a clara session to get any new insertion/rectraction fo facts? (I am wondering if it would be possible to use a clara session as a source of a stream of facts).</z><z id="t1480075085000116" t="wparker @nlessa Clara only returns new sessions in response to external calls to insert, retract, fire-rules etc. so if you’re looking to listen for changes in response to those actions I’d suggest just querying the session after those calls. It is also possible to add arbitrary listeners to a session - you can see the protocol at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc and an example that simply records all operations listened upon at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj - but keep in mind that listeners often take you into internal implementation details that could change. Also Clara sessions are immutable, in keeping with typical Clojure data structure semantics. Inserting/retracting facts and firing rules returns a new session with the relevant operation applied but leaves the original unchanged. It might be possible to give a better answer if we had a better idea what you’re trying to accomplish."><y>#</y><d>2016-11-25</d><h>11:58</h><w>wparker</w>@nlessa Clara only returns new sessions in response to external calls to insert, retract, fire-rules etc. so if you’re looking to listen for changes in response to those actions I’d suggest just querying the session after those calls.  It is also possible to add arbitrary listeners to a session - you can see the protocol at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc</a> and an example that simply records all operations listened upon at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj</a> - but keep in mind that listeners often take you into internal implementation details that could change.  Also Clara sessions are immutable, in keeping with typical Clojure data structure semantics.  Inserting/retracting facts and firing rules returns a new session with the relevant operation applied but leaves the original unchanged.  It might be possible to give a better answer if we had a better idea what you’re trying to accomplish.</z><z id="t1480449928000119" t="nlessa Hi @wparker, thanks for your explanation. What I had thought was to try to treat a session as a source of streaming data. As soon as a new fact is inserted/retracted another job would examine it and take another necessary actions. I see that I can easily obtain a similar effect composing the insert! with sending the fact to a Kafka cluster (for example) but not sure how to deal with the retracts that happens automatically in a clara session."><y>#</y><d>2016-11-29</d><h>20:05</h><w>nlessa</w>Hi @wparker, thanks for your explanation. What I had thought was to try to treat a session as a source of streaming data. As soon as a new fact is inserted/retracted another job would examine it and take another necessary actions. I see that I can easily obtain a similar effect composing the insert! with sending the fact to a Kafka cluster (for example) but not sure how to deal with the retracts that happens automatically in a clara session.</z><z id="t1480513288000121" t="wparker I think comparing the result of queries, which will reflect the state of the session before and after you fire rules, is what you’re looking for. So if you have something like"><y>#</y><d>2016-11-30</d><h>13:41</h><w>wparker</w>I think comparing the result of queries, which will reflect the state of the session before and after you fire rules, is what you’re looking for.  So if you have something like</z><z id="t1480513324000122" t="wparker (defrule lousy-weather-rule [?c &lt;- Cold] =&gt; (insert! (-&gt;LousyWeather)))"><y>#</y><d>2016-11-30</d><h>13:42</h><w>wparker</w>(defrule lousy-weather-rule [?c &lt;- Cold] =&gt; (insert! (-&gt;LousyWeather)))</z><z id="t1480513351000123" t="wparker (defquery lousy-weather-query “” [] [LousyWeather])"><y>#</y><d>2016-11-30</d><h>13:42</h><w>wparker</w>(defquery lousy-weather-query “” [] [LousyWeather])</z><z id="t1480513374000124" t="wparker Then (def empty-session (mk-session [lousy-weather-rule lousy-weather-query]))"><y>#</y><d>2016-11-30</d><h>13:42</h><w>wparker</w>Then (def empty-session (mk-session [lousy-weather-rule lousy-weather-query]))</z><z id="t1480513388000125" t="wparker (query empty-session lousy-weather-query) will return nothing"><y>#</y><d>2016-11-30</d><h>13:43</h><w>wparker</w>(query empty-session lousy-weather-query) will return nothing</z><z id="t1480513413000126" t="wparker However, (def not-empty-session (-&gt; empty-session (insert (-&gt;Cold)) fire-rules))"><y>#</y><d>2016-11-30</d><h>13:43</h><w>wparker</w>However, (def not-empty-session (-&gt; empty-session (insert (-&gt;Cold)) fire-rules))</z><z id="t1480513437000127" t="wparker (query not-empty-session lousy-weather-query) would find a LousyWeather fact"><y>#</y><d>2016-11-30</d><h>13:43</h><w>wparker</w>(query not-empty-session lousy-weather-query) would find a LousyWeather fact</z><z id="t1480513475000128" t="wparker You could query both before and after inserting/retracting + firing rules afterward and see what changed, then dispatch on that"><y>#</y><d>2016-11-30</d><h>13:44</h><w>wparker</w>You could query both before and after inserting/retracting + firing rules afterward and see what changed, then dispatch on that</z><z id="t1480513739000129" t="wparker One perhaps non-obvious part of this is when you query the session, you’re not actually performing much work since Clara basically computes the results for queries after fire-rules. When you run a query you’re really basically retrieving the results already computed with a little data manipulation to get just the bindings you use in your query. You can see that implementation at https://github.com/cerner/clara-rules/blob/0.13.0-RC4/src/main/clojure/clara/rules/engine.cljc#L1605"><y>#</y><d>2016-11-30</d><h>13:48</h><w>wparker</w>One perhaps non-obvious part of this is when you query the session, you’re not actually performing much work since Clara basically computes the results for queries after fire-rules.  When you run a query you’re really basically retrieving the results already computed with a little data manipulation to get just the bindings you use in your query.  You can see that implementation at <a href="https://github.com/cerner/clara-rules/blob/0.13.0-RC4/src/main/clojure/clara/rules/engine.cljc#L1605" target="_blank">https://github.com/cerner/clara-rules/blob/0.13.0-RC4/src/main/clojure/clara/rules/engine.cljc#L1605</a></z><z id="t1480513808000131" t="wparker Basically a query and a rule look the same to the rules engine mostly when you look at determine what facts match, a rule just does more things (i.e. it is activated and can insert more facts) once you find matches"><y>#</y><d>2016-11-30</d><h>13:50</h><w>wparker</w>Basically a query and a rule look the same to the rules engine mostly when you look at determine what facts match, a rule just does more things (i.e. it is activated and can insert more facts) once you find matches</z><z id="t1480514062000132" t="wparker You can think of it as large trees of the different node types in engine.cljc where ProductionNode corresponds to rules, QueryNode corresponds to queries, facts are given to the root nodes of these trees and passed down to the leaf nodes, which are ProductionNodes and QueryNodes"><y>#</y><d>2016-11-30</d><h>13:54</h><w>wparker</w>You can think of it as large trees of the different node types in engine.cljc where ProductionNode corresponds to rules, QueryNode corresponds to queries, facts are given to the root nodes of these trees and passed down to the leaf nodes, which are ProductionNodes and QueryNodes</z><z id="t1480514271000133" t="wparker Just comparing the results before and after for the queries would work, albeit somewhat inefficiently since you’d be performing work even when nothing at all changed. I think there are ways Clara could return changes in queries more efficiently than that if you were interested in contributing an enhancement like that though."><y>#</y><d>2016-11-30</d><h>13:57</h><w>wparker</w>Just comparing the results before and after for the queries would work, albeit somewhat inefficiently since you’d be performing work even when nothing at all changed.  I think there are ways Clara could return changes in queries more efficiently than that if you were interested in contributing an enhancement like that though.</z><z id="t1480514277000134" t="wparker @nlessa"><y>#</y><d>2016-11-30</d><h>13:57</h><w>wparker</w>@nlessa</z><z id="t1480516226000135" t="nlessa Thank you very much @wparker. Based in your answer I will try some approaches and let you know what I got."><y>#</y><d>2016-11-30</d><h>14:30</h><w>nlessa</w>Thank you very much @wparker. Based in your answer I will try some approaches and let you know what I got.</z><z id="t1480767536000002" t="svenhuster I&apos;m looking to build an appointment scheduling system and am contemplating if clara would be useful in this context. I&apos;ve got multiple constraints around field engineer work schedules, travel time matrices for a currently small number of locations we have, expected duration etc. I need to gather a number of appointment options that fulfill the constraint to the select one through user input. Is this at a high-level a suitable problem to approach with clara?"><y>#</y><d>2016-12-03</d><h>12:18</h><w>svenhuster</w>I&apos;m looking to build an appointment scheduling system and am contemplating if clara would be useful in this context. I&apos;ve got multiple constraints around field engineer work schedules, travel time matrices for a currently small number of locations we have, expected duration etc. 
I need to gather a number of appointment options that fulfill the constraint to the select one through user input. 
Is this at a high-level a suitable problem to approach with clara?</z><z id="t1480974668000004" t="devn @svenhuster we do some scheduling logic, but not the actual creation of events. My advice would be to spike on it and see where you get. Pick a nontrivial subset of your logic, and see whether it gives you what you’re looking for"><y>#</y><d>2016-12-05</d><h>21:51</h><w>devn</w>@svenhuster we do some scheduling logic, but not the actual creation of events. My advice would be to spike on it and see where you get. Pick a nontrivial subset of your logic, and see whether it gives you what you’re looking for</z><z id="t1480974710000005" t="devn @mikerod Thanks again for the talk, and for the chat afterwards. It was awfully cathartic to talk to folks with similar problems in healthcare, and the rules engine space in particular."><y>#</y><d>2016-12-05</d><h>21:51</h><w>devn</w>@mikerod Thanks again for the talk, and for the chat afterwards. It was awfully cathartic to talk to folks with similar problems in healthcare, and the rules engine space in particular.</z><z id="t1480975577000006" t="mikerod svenhuster I agree with devn that one of the best things you can do is try to reason about your problem through some examples actually trying to use Clara rules and a rule-driven approach"><y>#</y><d>2016-12-05</d><h>22:06</h><w>mikerod</w>svenhuster I agree with devn that one of the best things you can do is try to reason about your problem through some examples actually trying to use Clara rules and a rule-driven approach</z><z id="t1480975588000007" t="mikerod see if it is naturally working or if you are hitting major barriers"><y>#</y><d>2016-12-05</d><h>22:06</h><w>mikerod</w>see if it is naturally working or if you are hitting major barriers</z><z id="t1480975668000008" t="mikerod I often thing that http://www.jessrules.com/guidelines.shtml"><y>#</y><d>2016-12-05</d><h>22:07</h><w>mikerod</w>I often thing that <a href="http://www.jessrules.com/guidelines.shtml" target="_blank">http://www.jessrules.com/guidelines.shtml</a></z><z id="t1480975691000009" t="mikerod Jess (an older rules engine written in Java, with a Lisp-like DSL) has some reasonable guidelines"><y>#</y><d>2016-12-05</d><h>22:08</h><w>mikerod</w>Jess (an older rules engine written in Java, with a Lisp-like DSL) has some reasonable guidelines</z><z id="t1480975701000010" t="mikerod I think we could do better to get some guidelines on this up on Clara rules"><y>#</y><d>2016-12-05</d><h>22:08</h><w>mikerod</w>I think we could do better to get some guidelines on this up on Clara rules</z><z id="t1480975726000011" t="mikerod However, the most powerful I’d say is to try demo’ing out solving one of your problems (even if simplified) by using rules and see if it can make any sense."><y>#</y><d>2016-12-05</d><h>22:08</h><w>mikerod</w>However, the most powerful I’d say is to try demo’ing out solving one of your problems (even if simplified) by using rules and see if it can make any sense.</z><z id="t1480975752000012" t="mikerod devn It was good to talk with you. It was nice to hear your perspective and things you’ve been working through."><y>#</y><d>2016-12-05</d><h>22:09</h><w>mikerod</w>devn It was good to talk with you.  It was nice to hear your perspective and things you’ve been working through.</z><z id="t1480990131000013" t="devn @mikerod william byrd is a friend of mine"><y>#</y><d>2016-12-06</d><h>02:08</h><w>devn</w>@mikerod william byrd is a friend of mine</z><z id="t1480990157000014" t="devn what if Barliman (his code synthesis project) could synthesize rules"><y>#</y><d>2016-12-06</d><h>02:09</h><w>devn</w>what if Barliman (his code synthesis project) could synthesize rules</z><z id="t1480990230000015" t="devn i’ve found there’s a sort of typical “well i know i need to join X and Y on field :q&quot;"><y>#</y><d>2016-12-06</d><h>02:10</h><w>devn</w>i’ve found there’s a sort of typical “well i know i need to join X and Y on field :q&quot;</z><z id="t1480990256000016" t="devn “and i expect a Z to be inserted&quot;"><y>#</y><d>2016-12-06</d><h>02:10</h><w>devn</w>“and i expect a Z to be inserted&quot;</z><z id="t1480990359000017" t="devn this is a kind of partial description of both arity and return value"><y>#</y><d>2016-12-06</d><h>02:12</h><w>devn</w>this is a kind of partial description of both arity and return value</z><z id="t1480990374000018" t="devn you may have a function cool? in the same namespace"><y>#</y><d>2016-12-06</d><h>02:12</h><w>devn</w>you may have a function <code>cool?</code> in the same namespace</z><z id="t1480990549000019" t="devn he showed an example of: provided a definition of reduce-right, you can define concat"><y>#</y><d>2016-12-06</d><h>02:15</h><w>devn</w>he showed an example of: provided a definition of reduce-right, you can define concat</z><z id="t1480990556000020" t="devn imagine a smallish rulebase in a namespace under test"><y>#</y><d>2016-12-06</d><h>02:15</h><w>devn</w>imagine a smallish rulebase in a namespace under test</z><z id="t1480990681000021" t="devn i’m talking a bit of gibberish i suppose, but will was talking about synthesizing the “last 10%” of your program"><y>#</y><d>2016-12-06</d><h>02:18</h><w>devn</w>i’m talking a bit of gibberish i suppose, but will was talking about synthesizing the “last 10%” of your program</z><z id="t1480990709000022" t="devn i wonder if generating the “last rule” in a smallish rulebase would be an interesting place to try that out"><y>#</y><d>2016-12-06</d><h>02:18</h><w>devn</w>i wonder if generating the “last rule” in a smallish rulebase would be an interesting place to try that out</z><z id="t1480991332000023" t="jonsmock For me, the writing the rules is the &quot;easy part&quot; but knowing if my rules cover what I think they do is the hard part"><y>#</y><d>2016-12-06</d><h>02:28</h><w>jonsmock</w>For me, the writing the rules is the &quot;easy part&quot; but knowing if my rules cover what I think they do is the hard part</z><z id="t1480991361000024" t="jonsmock (I&apos;m saying this as someone who is completely entranced by Barliman. I love that stuff, and I cloned the repo for the flight home)"><y>#</y><d>2016-12-06</d><h>02:29</h><w>jonsmock</w>(I&apos;m saying this as someone who is completely entranced by Barliman. I love that stuff, and I cloned the repo for the flight home)</z><z id="t1480991424000025" t="jonsmock But at least at work (we use clara-rules), I want tooling around the rules I have"><y>#</y><d>2016-12-06</d><h>02:30</h><w>jonsmock</w>But at least at work (we use clara-rules), I want tooling around the rules I have</z><z id="t1480991436000026" t="jonsmock Could just be me, not trying to dismiss what you&apos;re saying"><y>#</y><d>2016-12-06</d><h>02:30</h><w>jonsmock</w>Could just be me, not trying to dismiss what you&apos;re saying</z><z id="t1480991475000027" t="jonsmock i.e. here&apos;s a ns of rules, did I cover all cases"><y>#</y><d>2016-12-06</d><h>02:31</h><w>jonsmock</w>i.e. here&apos;s a ns of rules, did I cover all cases</z><z id="t1480991503000028" t="jonsmock Or our actual situation: here&apos;s a ns of rules, is it possible more than one can fire?"><y>#</y><d>2016-12-06</d><h>02:31</h><w>jonsmock</w>Or our actual situation:  here&apos;s a ns of rules, is it possible more than one can fire?</z><z id="t1480991536000029" t="jonsmock Again might be unique to the way I use clara-rules, but I have a hierarchy that looks like:"><y>#</y><d>2016-12-06</d><h>02:32</h><w>jonsmock</w>Again might be unique to the way I use clara-rules, but I have a hierarchy that looks like:</z><z id="t1480991555000030" t="jonsmock basic fact rules -&gt; intermediate level deduction rules -&gt; final action rules"><y>#</y><d>2016-12-06</d><h>02:32</h><w>jonsmock</w>basic fact rules -&gt; intermediate level deduction rules -&gt; final action rules</z><z id="t1480991605000031" t="jonsmock And I want just one final action rule to fire (this doesn&apos;t actually do a side effect. Something else uses the output of the rule engine to take an action)"><y>#</y><d>2016-12-06</d><h>02:33</h><w>jonsmock</w>And I want just one final action rule to fire (this doesn&apos;t actually do a side effect. Something else uses the output of the rule engine to take an action)</z><z id="t1480991647000032" t="jonsmock But yeah, Barliman looks sick. I seriously eat that stuff up"><y>#</y><d>2016-12-06</d><h>02:34</h><w>jonsmock</w>But yeah, Barliman looks sick. I seriously eat that stuff up</z><z id="t1481010205000033" t="svenhuster @devn @mikerod thanks a lot. I shall have a go. "><y>#</y><d>2016-12-06</d><h>07:43</h><w>svenhuster</w>@devn @mikerod thanks a lot. I shall have a go. </z><z id="t1481037902000035" t="mikerod devn if nothing else, I think it’d be an interesting experiment"><y>#</y><d>2016-12-06</d><h>15:25</h><w>mikerod</w>devn if nothing else, I think it’d be an interesting experiment</z><z id="t1481037917000036" t="mikerod That was an interesting talk."><y>#</y><d>2016-12-06</d><h>15:25</h><w>mikerod</w>That was an interesting talk.</z><z id="t1481037971000037" t="mikerod jonsmock I agree that more tooling would be a big win and is one of the harder parts."><y>#</y><d>2016-12-06</d><h>15:26</h><w>mikerod</w>jonsmock I agree that more tooling would be a big win and is one of the harder parts.</z><z id="t1481037982000038" t="mikerod I’ll repeat since I missed the tags:"><y>#</y><d>2016-12-06</d><h>15:26</h><w>mikerod</w>I’ll repeat since I missed the tags:</z><z id="t1481037992000039" t="jonsmock Yeah, sorry, I was thinking more about devn&apos;s thing"><y>#</y><d>2016-12-06</d><h>15:26</h><w>jonsmock</w>Yeah, sorry, I was thinking more about devn&apos;s thing</z><z id="t1481037996000040" t="mikerod @devn if nothing else, I think it’d be an interesting experiment"><y>#</y><d>2016-12-06</d><h>15:26</h><w>mikerod</w>@devn if nothing else, I think it’d be an interesting experiment</z><z id="t1481037999000041" t="jonsmock Sounds cool, and I shouldn&apos;t poopoo it"><y>#</y><d>2016-12-06</d><h>15:26</h><w>jonsmock</w>Sounds cool, and I shouldn&apos;t poopoo it</z><z id="t1481038009000042" t="jonsmock (Not that I was trying to, but I think I sounded negative)"><y>#</y><d>2016-12-06</d><h>15:26</h><w>jonsmock</w>(Not that I was trying to, but I think I sounded negative)</z><z id="t1481038036000043" t="jonsmock btw @mikerod I&apos;m about half-way through your talk now - nice work!"><y>#</y><d>2016-12-06</d><h>15:27</h><w>jonsmock</w>btw @mikerod I&apos;m about half-way through your talk now - nice work!</z><z id="t1481038057000044" t="mikerod thanks. it’s a bit basic I’m sure given how much you are already entrenched in the details of working with rules."><y>#</y><d>2016-12-06</d><h>15:27</h><w>mikerod</w>thanks.  it’s a bit basic I’m sure given how much you are already entrenched in the details of working with rules.</z><z id="t1481038154000045" t="mikerod @jonsmock Maybe a SAT solver can be used in some sort of tooling around rule analysis 🙂"><y>#</y><d>2016-12-06</d><h>15:29</h><w>mikerod</w>@jonsmock Maybe a SAT solver can be used in some sort of tooling around rule analysis <b>🙂</b></z><z id="t1481038511000046" t="devn @jonsmock: agreed on tooling, and I didn&apos;t read it as negative "><y>#</y><d>2016-12-06</d><h>15:35</h><w>devn</w>@jonsmock: agreed on tooling, and I didn&apos;t read it as negative </z><z id="t1481038579000047" t="devn Some of the tooling stuff you describe is I think pretty straightforward "><y>#</y><d>2016-12-06</d><h>15:36</h><w>devn</w>Some of the tooling stuff you describe is I think pretty straightforward </z><z id="t1481038611000048" t="devn I would really like to know coverage of my rules under test "><y>#</y><d>2016-12-06</d><h>15:36</h><w>devn</w>I would really like to know coverage of my rules under test </z><z id="t1481038655000049" t="devn The inspect session output I believe can answer that, but it would require carrying around some state between tests"><y>#</y><d>2016-12-06</d><h>15:37</h><w>devn</w>The inspect session output I believe can answer that, but it would require carrying around some state between tests</z><z id="t1481038929000052" t="jonsmock I think I&apos;ve played around with property tests and rules, but I don&apos;t know if we have any at the moment"><y>#</y><d>2016-12-06</d><h>15:42</h><w>jonsmock</w>I think I&apos;ve played around with property tests and rules, but I don&apos;t know if we have any at the moment</z><z id="t1481038971000053" t="jonsmock With a large rule system, it seems harder to synthesize the right data"><y>#</y><d>2016-12-06</d><h>15:42</h><w>jonsmock</w>With a large rule system, it seems harder to synthesize the right data</z><z id="t1481038990000054" t="devn @jonsmock: indeed"><y>#</y><d>2016-12-06</d><h>15:43</h><w>devn</w>@jonsmock: indeed</z><z id="t1481039067000055" t="jonsmock I should think about it more though hmm"><y>#</y><d>2016-12-06</d><h>15:44</h><w>jonsmock</w>I should think about it more though hmm</z><z id="t1481039080000056" t="devn Our tests are easy to write in the small "><y>#</y><d>2016-12-06</d><h>15:44</h><w>devn</w>Our tests are easy to write in the small </z><z id="t1481039106000057" t="devn But terribly difficult to do integration tests "><y>#</y><d>2016-12-06</d><h>15:45</h><w>devn</w>But terribly difficult to do integration tests </z><z id="t1481039113000058" t="devn Because there is a truckload of data"><y>#</y><d>2016-12-06</d><h>15:45</h><w>devn</w>Because there is a truckload of data</z><z id="t1481039122000059" t="devn Not Clara&apos;s fault"><y>#</y><d>2016-12-06</d><h>15:45</h><w>devn</w>Not Clara&apos;s fault</z><z id="t1481039132000060" t="devn Just a function of the domain"><y>#</y><d>2016-12-06</d><h>15:45</h><w>devn</w>Just a function of the domain</z><z id="t1481039150000061" t="jonsmock Yeah that&apos;s basically what we have at the moment"><y>#</y><d>2016-12-06</d><h>15:45</h><w>jonsmock</w>Yeah that&apos;s basically what we have at the moment</z><z id="t1481039161000062" t="jonsmock A handful of integration tests and some unit tests on specific namespaces"><y>#</y><d>2016-12-06</d><h>15:46</h><w>jonsmock</w>A handful of integration tests and some unit tests on specific namespaces</z><z id="t1481039179000063" t="devn We&apos;ve talked about doing test generators that compose across a couple/few namespaces "><y>#</y><d>2016-12-06</d><h>15:46</h><w>devn</w>We&apos;ve talked about doing test generators that compose across a couple/few namespaces </z><z id="t1481039202000064" t="devn So we can improve coverage without doing massive integration tests"><y>#</y><d>2016-12-06</d><h>15:46</h><w>devn</w>So we can improve coverage without doing massive integration tests</z><z id="t1481039234000065" t="jonsmock I&apos;m curious if you have the same organization to your rules. We basically have 3 tiers ... oh I guess I said this above"><y>#</y><d>2016-12-06</d><h>15:47</h><w>jonsmock</w>I&apos;m curious if you have the same organization to your rules. We basically have 3 tiers ... oh I guess I said this above</z><z id="t1481039237000066" t="jonsmock basic fact rules -&gt; intermediate level deduction rules -&gt; final action rules"><y>#</y><d>2016-12-06</d><h>15:47</h><w>jonsmock</w>basic fact rules -&gt; intermediate level deduction rules -&gt; final action rules</z><z id="t1481039255000067" t="jonsmock the basic fact rules are basically digging out important stuff from giant maps from other systems"><y>#</y><d>2016-12-06</d><h>15:47</h><w>jonsmock</w>the basic fact rules are basically digging out important stuff from giant maps from other systems</z><z id="t1481039270000068" t="jonsmock So I probably could write generators after that level"><y>#</y><d>2016-12-06</d><h>15:47</h><w>jonsmock</w>So I probably could write generators after that level</z><z id="t1481039279000069" t="jonsmock And property test the intermediate and action rules together"><y>#</y><d>2016-12-06</d><h>15:47</h><w>jonsmock</w>And property test the intermediate and action rules together</z><z id="t1481039289000070" t="devn we built a library that builds facts, and their variants (intermediate facts) using a bit of macro sugar"><y>#</y><d>2016-12-06</d><h>15:48</h><w>devn</w>we built a library that builds facts, and their variants (intermediate facts) using a bit of macro sugar</z><z id="t1481039295000071" t="devn so that’s your step 1"><y>#</y><d>2016-12-06</d><h>15:48</h><w>devn</w>so that’s your step 1</z><z id="t1481039387000072" t="devn (deffact FooFact “Blah blah&quot; (alias foo-fact (field some_id :spec string? :doc “blah blah”) (variant InterestingFooFact (field additional_field :spec number? :doc “…”))) "><y>#</y><d>2016-12-06</d><h>15:49</h><w>devn</w><pre>(deffact FooFact
  “Blah blah&quot;
  (alias foo-fact

  (field some_id :spec string? :doc “blah blah”)

  (variant InterestingFooFact
    (field additional_field :spec number? :doc “…”)))
</pre></z><z id="t1481039401000073" t="jonsmock Oh neat"><y>#</y><d>2016-12-06</d><h>15:50</h><w>jonsmock</w>Oh neat</z><z id="t1481039405000074" t="devn err sorry, i guess that’s not your step 1, but it’s kind of interesting"><y>#</y><d>2016-12-06</d><h>15:50</h><w>devn</w>err sorry, i guess that’s not your step 1, but it’s kind of interesting</z><z id="t1481039411000075" t="jonsmock Yeah that&apos;s really neat"><y>#</y><d>2016-12-06</d><h>15:50</h><w>jonsmock</w>Yeah that&apos;s really neat</z><z id="t1481039430000076" t="jonsmock It would be cool to put more relational info int hat"><y>#</y><d>2016-12-06</d><h>15:50</h><w>jonsmock</w>It would be cool to put more relational info int hat</z><z id="t1481039431000077" t="devn then we can use it to validate our facts conform"><y>#</y><d>2016-12-06</d><h>15:50</h><w>devn</w>then we can use it to validate our facts conform</z><z id="t1481039434000078" t="devn yeah absolutely"><y>#</y><d>2016-12-06</d><h>15:50</h><w>devn</w>yeah absolutely</z><z id="t1481039464000079" t="jonsmock For us, it&apos;s all about what the insurance has paid, etc"><y>#</y><d>2016-12-06</d><h>15:51</h><w>jonsmock</w>For us, it&apos;s all about what the insurance has paid, etc</z><z id="t1481039468000080" t="devn we also introduced a trace_id on all fact types, which is carried around, so you can track the lineage of a fact a bit easier"><y>#</y><d>2016-12-06</d><h>15:51</h><w>devn</w>we also introduced a trace_id on all fact types, which is carried around, so you can track the lineage of a fact a bit easier</z><z id="t1481039517000081" t="jonsmock So I&apos;m thinking like (deffact TotalCharges ...) and having other facts declaratively say that they are less than TotalCharges"><y>#</y><d>2016-12-06</d><h>15:51</h><w>jonsmock</w>So I&apos;m thinking like (deffact TotalCharges ...) and having other facts declaratively say that they are less than TotalCharges</z><z id="t1481039521000082" t="devn and, we have a :contributing_factors field on many (not all) facts, which captures interesting “why” information"><y>#</y><d>2016-12-06</d><h>15:52</h><w>devn</w>and, we have a :contributing_factors field on many (not all) facts, which captures interesting “why” information</z><z id="t1481039531000083" t="jonsmock Ah cool"><y>#</y><d>2016-12-06</d><h>15:52</h><w>jonsmock</w>Ah cool</z><z id="t1481039539000084" t="devn but some assembly required"><y>#</y><d>2016-12-06</d><h>15:52</h><w>devn</w>but some assembly required</z><z id="t1481039563000085" t="devn @jonsmock yeah, this fact library was a first pass"><y>#</y><d>2016-12-06</d><h>15:52</h><w>devn</w>@jonsmock yeah, this fact library was a first pass</z><z id="t1481039576000086" t="devn there’s more that could be done there for sure"><y>#</y><d>2016-12-06</d><h>15:52</h><w>devn</w>there’s more that could be done there for sure</z><z id="t1481039673000087" t="devn @jonsmock we also have (optional-field …), and a way of specifying an explanation for each fact, so if you call (explain the-fact), it’ll give you the view you’re looking for"><y>#</y><d>2016-12-06</d><h>15:54</h><w>devn</w>@jonsmock we also have (optional-field …), and a way of specifying an explanation for each fact, so if you call (explain the-fact), it’ll give you the view you’re looking for</z><z id="t1481039726000089" t="devn to date we haven’t actually used explain, which is just a function of the history of this project"><y>#</y><d>2016-12-06</d><h>15:55</h><w>devn</w>to date we haven’t actually used explain, which is just a function of the history of this project</z><z id="t1481039733000090" t="devn we should have done it earlier, but there were bigger fish to fry"><y>#</y><d>2016-12-06</d><h>15:55</h><w>devn</w>we should have done it earlier, but there were bigger fish to fry</z><z id="t1481039742000091" t="devn now we’re overdue for adding better explanations"><y>#</y><d>2016-12-06</d><h>15:55</h><w>devn</w>now we’re overdue for adding better explanations</z><z id="t1481039808000092" t="devn “why did we make an InterestingRecommendation?” =&gt; “Patient is over 50 and has a recent encounter (&lt; 45 days) where X happened…&quot;"><y>#</y><d>2016-12-06</d><h>15:56</h><w>devn</w>“why did we make an InterestingRecommendation?” =&gt; “Patient is over 50 and has a recent encounter (&lt; 45 days) where X happened…&quot;</z><z id="t1481039848000093" t="devn Speaking more on the topic of tooling"><y>#</y><d>2016-12-06</d><h>15:57</h><w>devn</w>Speaking more on the topic of tooling</z><z id="t1481039891000094" t="devn We built a graph you can traverse by clicking from nodes to rules and such, but textual explanation seems to be more fundamentally valuable"><y>#</y><d>2016-12-06</d><h>15:58</h><w>devn</w>We built a graph you can traverse by clicking from nodes to rules and such, but textual explanation seems to be more fundamentally valuable</z><z id="t1481039984000095" t="devn Ryan’s clara.tools project is on the right-ish track, but the sheer volume of information for a graph of any decent size can quickly turn into wading in a swamp of facts which aren’t all that interesting"><y>#</y><d>2016-12-06</d><h>15:59</h><w>devn</w>Ryan’s clara.tools project is on the right-ish track, but the sheer volume of information for a graph of any decent size can quickly turn into wading in a swamp of facts which aren’t all that interesting</z><z id="t1481040006000096" t="devn it’s not an easy problem. views need to be tailored to your domain, and to your audience"><y>#</y><d>2016-12-06</d><h>16:00</h><w>devn</w>it’s not an easy problem. views need to be tailored to your domain, and to your audience</z><z id="t1481040019000097" t="devn but perhaps there’s some meta way of specifying views that could be shared"><y>#</y><d>2016-12-06</d><h>16:00</h><w>devn</w>but perhaps there’s some meta way of specifying views that could be shared</z><z id="t1481042606000098" t="jonsmock @mikerod That was a solid talk"><y>#</y><d>2016-12-06</d><h>16:43</h><w>jonsmock</w>@mikerod That was a solid talk</z><z id="t1481049003000100" t="mikerod @jonsmock thanks!"><y>#</y><d>2016-12-06</d><h>18:30</h><w>mikerod</w>@jonsmock thanks!</z><z id="t1482238041000106" t="fabrao Hello all"><y>#</y><d>2016-12-20</d><h>12:47</h><w>fabrao</w>Hello all</z><z id="t1484400792000125" t="skuro hi *"><y>#</y><d>2017-01-14</d><h>13:33</h><w>skuro</w>hi *</z><z id="t1484400846000126" t="skuro I’m just exploring clara these days, and I had a question"><y>#</y><d>2017-01-14</d><h>13:34</h><w>skuro</w>I’m just exploring clara these days, and I had a question</z><z id="t1484400883000127" t="skuro in my model, some of the facts have a timestamp property, which can be used to let facts expire when they become too old"><y>#</y><d>2017-01-14</d><h>13:34</h><w>skuro</w>in my model, some of the facts have a timestamp property, which can be used to let facts expire when they become too old</z><z id="t1484401075000128" t="skuro so far I have this in my little experiment: (defrecord Fact [timestamp ...]) (defn too-old [t] (&lt; max-age (- (now) t))) (defrule ignore-old-facts [?fact &lt;- Fact (too-old timestamp)] =&gt; (retract! ?fact))"><y>#</y><d>2017-01-14</d><h>13:37</h><w>skuro</w>so far I have this in my little experiment: <pre>(defrecord Fact [timestamp ...])

(defn too-old [t]
  (&lt; max-age (- (now) t)))

(defrule ignore-old-facts
  [?fact &lt;- Fact (too-old timestamp)]
  =&gt;
  (retract! ?fact))</pre></z><z id="t1484401141000129" t="skuro is it the right strategy? I guess facts won’t be re-evaluated over time in a given session, so if I go for this I would have to recreate it periodically"><y>#</y><d>2017-01-14</d><h>13:39</h><w>skuro</w>is it the right strategy? I guess facts won’t be re-evaluated over time in a given session, so if I go for this I would have to recreate it periodically</z><z id="t1484401155000130" t="skuro but maybe I’m not understanding clara yet 🙂"><y>#</y><d>2017-01-14</d><h>13:39</h><w>skuro</w>but maybe I’m not understanding clara yet <b>🙂</b></z><z id="t1484578896000131" t="wparker @skuro You’re correct that facts won’t be re-evaluated in this case. My suggestion would be to write something like"><y>#</y><d>2017-01-16</d><h>15:01</h><w>wparker</w>@skuro You’re correct that facts won’t be re-evaluated in this case.  My suggestion would be to write something like</z><z id="t1484578962000132" t="wparker (defrule ignore-old-facts [TimeFact (= ?time time)] [?fact &lt;- Fact (too-old timestamp ?time)] =&gt; (retract! ?fact))"><y>#</y><d>2017-01-16</d><h>15:02</h><w>wparker</w>(defrule ignore-old-facts [TimeFact (= ?time time)] [?fact &lt;- Fact (too-old timestamp ?time)] =&gt; (retract! ?fact))</z><z id="t1484578994000133" t="wparker If you retract an old TimeFact and then insert with a newer TimeFact this will force re-evaluation of the join"><y>#</y><d>2017-01-16</d><h>15:03</h><w>wparker</w>If you retract an old TimeFact and then insert with a newer TimeFact this will force re-evaluation of the join</z><z id="t1484579113000134" t="wparker There’s been some discussion on the mailing list of providing support for this sort of use case (events that expire with reference to them in Clara removed) but at this time there isn’t anything in Clara to directly support it."><y>#</y><d>2017-01-16</d><h>15:05</h><w>wparker</w>There’s been some discussion on the mailing list of providing support for this sort of use case (events that expire with reference to them in Clara removed) but at this time there isn’t anything in Clara to directly support it.</z><z id="t1484582818000135" t="skuro ok, thanks"><y>#</y><d>2017-01-16</d><h>16:06</h><w>skuro</w>ok, thanks</z><z id="t1484586192000136" t="wparker you’re welcome"><y>#</y><d>2017-01-16</d><h>17:03</h><w>wparker</w>you’re welcome</z><z id="t1484834458000139" t="dm3 do I understand correctly that a rule like the one in https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L48 : (defrule get-current-temperature &quot;Get the current temperature at a location by simply looking at the newest reading.&quot; [?current-temp &lt;- newest-temp :from [TemperatureReading (= ?location location)]] =&gt; (insert! (-&gt;CurrentTemperature (:value ?current-temp) ?location))) will accumulate CurrentTemperature facts, never retracting them?"><y>#</y><d>2017-01-19</d><h>14:00</h><w>dm3</w>do I understand correctly that a rule like the one in <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L48" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L48</a>:
<pre>(defrule get-current-temperature
  &quot;Get the current temperature at a location by simply looking at the newest reading.&quot;
  [?current-temp &lt;- newest-temp :from [TemperatureReading (= ?location location)]]
  =&gt;
  (insert! (-&gt;CurrentTemperature (:value ?current-temp) ?location)))
</pre>
will accumulate <code>CurrentTemperature</code> facts, never retracting them?</z><z id="t1484844768000141" t="dm3 seems the above is retracted on every new TemperatureReading . Is my intuition right in this case - the retraction happens because when the new TemperatureReading (t+1) arrives, the condition under which the previous CurrentTemperature became true (t+0) is now false?"><y>#</y><d>2017-01-19</d><h>16:52</h><w>dm3</w>seems the above is retracted on every new <code>TemperatureReading</code>. Is my intuition right in this case - the retraction happens because when the new <code>TemperatureReading</code> (t+1) arrives, the condition under which the previous <code>CurrentTemperature</code> became true (t+0) is now false?</z><z id="t1484847400000142" t="wparker @dm3 that is correct"><y>#</y><d>2017-01-19</d><h>17:36</h><w>wparker</w>@dm3 that is correct</z><z id="t1484847441000143" t="wparker When the conditions that caused a logical fact insertion to occur Clara will adjust the session to reflect the new status of those conditions"><y>#</y><d>2017-01-19</d><h>17:37</h><w>wparker</w>When the conditions that caused a logical fact insertion to occur Clara will adjust the session to reflect the new status of those conditions</z><z id="t1484847451000144" t="wparker Logical insertions are those done with insert!"><y>#</y><d>2017-01-19</d><h>17:37</h><w>wparker</w>Logical insertions are those done with insert!</z><z id="t1484847509000145" t="wparker If you used insert-unconditional! you’d end up with multiple CurrentTemperature facts potentially depending on your rules firing pattern"><y>#</y><d>2017-01-19</d><h>17:38</h><w>wparker</w>If you used insert-unconditional! you’d end up with multiple CurrentTemperature facts potentially depending on your rules firing pattern</z><z id="t1484847573000146" t="wparker But as long as you stay away from uncondition insertions and manual fact retractions inside rules you can just think of the rules as pure logical relationships that “if as session has these things in it it will also have these other things in it&quot;"><y>#</y><d>2017-01-19</d><h>17:39</h><w>wparker</w>But as long as you stay away from uncondition insertions and manual fact retractions inside rules you can just think of the rules as pure logical relationships that “if as session has these things in it it will also have these other things in it&quot;</z><z id="t1484847589000147" t="wparker “a session” not “as session&quot;"><y>#</y><d>2017-01-19</d><h>17:39</h><w>wparker</w>“a session” not “as session&quot;</z><z id="t1484847728000148" t="wparker After you call fire-rules at least, i.e. (-&gt; your-session (insert your-facts-here) ;;no-contract-about-status-now fire-rules ;; now-there-is-a-contract-about-the-status)"><y>#</y><d>2017-01-19</d><h>17:42</h><w>wparker</w>After you call fire-rules at least, i.e. (-&gt; your-session (insert your-facts-here) ;;no-contract-about-status-now fire-rules ;; now-there-is-a-contract-about-the-status)</z><z id="t1484847755000149" t="wparker Also note that you’ll group on the location of the TemperatureReading in the above"><y>#</y><d>2017-01-19</d><h>17:42</h><w>wparker</w>Also note that you’ll group on the location of the TemperatureReading in the above</z><z id="t1484847792000150" t="wparker So if you have TemperatureReading facts with different locations you can have a CurrentTemperature fact for each distinct location"><y>#</y><d>2017-01-19</d><h>17:43</h><w>wparker</w>So if you have TemperatureReading facts with different locations you can have a CurrentTemperature fact for each distinct location</z><z id="t1484847796000151" t="wparker Does that make sense?"><y>#</y><d>2017-01-19</d><h>17:43</h><w>wparker</w>Does that make sense?</z><z id="t1484848082000152" t="dm3 yeah"><y>#</y><d>2017-01-19</d><h>17:48</h><w>dm3</w>yeah</z><z id="t1484848087000153" t="dm3 running into some other issues now"><y>#</y><d>2017-01-19</d><h>17:48</h><w>dm3</w>running into some other issues now</z><z id="t1484848210000154" t="dm3 what if I have facts that change with time and do an insert CurrentTimestamp -&gt; fire-rules -&gt; retract CurrentTimestamp periodically? Are there any obvious issues I&apos;ll run into?"><y>#</y><d>2017-01-19</d><h>17:50</h><w>dm3</w>what if I have facts that change with time and do an <code>insert CurrentTimestamp -&gt; fire-rules -&gt; retract CurrentTimestamp</code> periodically? Are there any obvious issues I&apos;ll run into?</z><z id="t1484851484000155" t="wparker @dm3 As long as you use truth maintenance Clara will resolve all transitive impacts on rules"><y>#</y><d>2017-01-19</d><h>18:44</h><w>wparker</w>@dm3 As long as you use truth maintenance Clara will resolve all transitive impacts on rules</z><z id="t1484851518000156" t="wparker i.e. if you insert Fact1 which causes RuleA to insert fact2, and fact2 causes ruleB to insert fact3"><y>#</y><d>2017-01-19</d><h>18:45</h><w>wparker</w>i.e. if you insert Fact1 which causes RuleA to insert fact2, and fact2 causes ruleB to insert fact3</z><z id="t1484851558000157" t="wparker a retraction of fact1 will cause fact3 to be removed from the session if appropriate based on the rules"><y>#</y><d>2017-01-19</d><h>18:45</h><w>wparker</w>a retraction of fact1 will cause fact3 to be removed from the session if appropriate based on the rules</z><z id="t1484851655000158" t="wparker Regarding “facts that change with time”:"><y>#</y><d>2017-01-19</d><h>18:47</h><w>wparker</w>Regarding “facts that change with time”:</z><z id="t1484851667000159" t="wparker Clara assumes that facts are immutable"><y>#</y><d>2017-01-19</d><h>18:47</h><w>wparker</w>Clara assumes that facts are immutable</z><z id="t1484851719000160" t="wparker If you do something like (insert JavaBeanFact) fire-rules (.setSomeFieldUsedInRules JavaBeanFact newValue)"><y>#</y><d>2017-01-19</d><h>18:48</h><w>wparker</w>If you do something like (insert JavaBeanFact) fire-rules (.setSomeFieldUsedInRules JavaBeanFact newValue)</z><z id="t1484851729000161" t="wparker the behavior will be undefined"><y>#</y><d>2017-01-19</d><h>18:48</h><w>wparker</w>the behavior will be undefined</z><z id="t1484851748000162" t="wparker if you want to change fields you’ll need to retract the fact and then insert a new one with the modifications you want"><y>#</y><d>2017-01-19</d><h>18:49</h><w>wparker</w>if you want to change fields you’ll need to retract the fact and then insert a new one with the modifications you want</z><z id="t1484851828000163" t="wparker Actually I’d consider mutation of facts after insertion to result in undefined behavior in general, apart from whether the field is used"><y>#</y><d>2017-01-19</d><h>18:50</h><w>wparker</w>Actually I’d consider mutation of facts after insertion to result in undefined behavior in general, apart from whether the field is used</z><z id="t1484851904000164" t="wparker Mutating fields after insertion used in rules would definitely cause problems with the current implementation, would need to think about mutations not impacting rule bindings but either way the behavior isn’t guaranteed and I wouldn’t advise doing it"><y>#</y><d>2017-01-19</d><h>18:51</h><w>wparker</w>Mutating fields after insertion used in rules would definitely cause problems with the current implementation, would need to think about mutations not impacting rule bindings but either way the behavior isn’t guaranteed and I wouldn’t advise doing it</z><z id="t1484851941000165" t="dm3 thx"><y>#</y><d>2017-01-19</d><h>18:52</h><w>dm3</w>thx</z><z id="t1484851945000166" t="dm3 I wasn&apos;t considering mutations"><y>#</y><d>2017-01-19</d><h>18:52</h><w>dm3</w>I wasn&apos;t considering mutations</z><z id="t1484851954000167" t="wparker :+1:"><y>#</y><d>2017-01-19</d><h>18:52</h><w>wparker</w><b>:+1:</b></z><z id="t1484852017000168" t="dm3 I&apos;m thinking of batching the input stream of events and reducing the batch with (fn [sess batch] (-&gt; (insert sess timestamp) (insert-all batch) (fire-rules) (retract timestamp)))"><y>#</y><d>2017-01-19</d><h>18:53</h><w>dm3</w>I&apos;m thinking of batching the input stream of events and reducing the batch with <code>(fn [sess batch] (-&gt; (insert sess timestamp) (insert-all batch) (fire-rules) (retract timestamp)))</code></z><z id="t1484852092000169" t="wparker yeah obviously the existence of problems depends on the specific use-case but I don’t see problems in general with inserting and then retracting a timestamp fact that would have downstream impact through various rules"><y>#</y><d>2017-01-19</d><h>18:54</h><w>wparker</w>yeah obviously the existence of problems depends on the specific use-case but I don’t see problems in general with inserting and then retracting a timestamp fact that would have downstream impact through various rules</z><z id="t1484852123000170" t="wparker truth maintenance will sort out all the impacts to downstream rules"><y>#</y><d>2017-01-19</d><h>18:55</h><w>wparker</w>truth maintenance will sort out all the impacts to downstream rules</z><z id="t1484852168000171" t="wparker also remember Clara sessions are immutable"><y>#</y><d>2017-01-19</d><h>18:56</h><w>wparker</w>also remember Clara sessions are immutable</z><z id="t1484852174000172" t="wparker so you could do something like this as well"><y>#</y><d>2017-01-19</d><h>18:56</h><w>wparker</w>so you could do something like this as well</z><z id="t1484852192000173" t="wparker (def session-with-facts-no-timestamp)"><y>#</y><d>2017-01-19</d><h>18:56</h><w>wparker</w>(def session-with-facts-no-timestamp)</z><z id="t1484852248000174" t="wparker (def time1-session (-&gt; session-with-facts-no-timestamp (insert time1) fire-rules))"><y>#</y><d>2017-01-19</d><h>18:57</h><w>wparker</w>(def time1-session (-&gt; session-with-facts-no-timestamp (insert time1) fire-rules))</z><z id="t1484852264000175" t="wparker (def time2-session (-&gt; session-with-facts-no-timestamp (insert time2) fire-rules))"><y>#</y><d>2017-01-19</d><h>18:57</h><w>wparker</w>(def time2-session (-&gt; session-with-facts-no-timestamp (insert time2) fire-rules))</z><z id="t1484853681000176" t="dm3 I&apos;m now trying to do the following: (ns rulebot.test (:require [clara.rules :as clara] [clara.rules.accumulators :as acc] [clara.tools.tracing :as tt])) (defrecord Value [value instant]) (defrecord Step [step instant]) (defrecord CurrentValue [value]) (defrecord CurrentStep [step]) (defrecord CurrentTimestamp [instant]) (clara/defrule current-value [?e &lt;- (acc/max :instant :returns-fact true) :from [Value]] =&gt; (clara/insert! (-&gt;CurrentValue (:value ?e)))) (clara/defrule current-step [?e &lt;- (acc/max :instant :returns-fact true) :from [Step]] =&gt; (clara/insert! (-&gt;CurrentStep (:step ?e)))) (clara/defrule step [CurrentValue (= ?value value)] [CurrentStep (= ?prev-step step) (= ?curr-step (int (/ ?value 10)))] [CurrentTimestamp (= ?instant instant)] [:test (&gt; ?curr-step ?prev-step)] =&gt; (clara/insert! (-&gt;Step ?curr-step ?instant))) (defn go [] (let [session (-&gt; (clara/mk-session &apos;rulebot.test) (tt/with-tracing))] (-&gt; session (clara/insert (-&gt;CurrentTimestamp 0)) (clara/insert (-&gt;Value 1 0)) (clara/insert (-&gt;Step 0 0)) (clara/fire-rules) (clara/retract (-&gt;CurrentTimestamp 0)) (clara/insert (-&gt;CurrentTimestamp 1)) (clara/insert (-&gt;Value 11 1)) (clara/fire-rules) (tt/get-trace)))) which fails on the step rule because ?prev-step gets bound to an {:ns-name .., :lhs ..., :rhs ...} map for some reason..."><y>#</y><d>2017-01-19</d><h>19:21</h><w>dm3</w>I&apos;m now trying to do the following:
<pre>(ns rulebot.test
  (:require [clara.rules :as clara]
            [clara.rules.accumulators :as acc]
            [clara.tools.tracing :as tt]))

(defrecord Value [value instant])
(defrecord Step [step instant])
(defrecord CurrentValue [value])
(defrecord CurrentStep [step])
(defrecord CurrentTimestamp [instant])

(clara/defrule current-value
  [?e &lt;- (acc/max :instant :returns-fact true) :from [Value]]
  =&gt;
  (clara/insert! (-&gt;CurrentValue (:value ?e))))

(clara/defrule current-step
  [?e &lt;- (acc/max :instant :returns-fact true) :from [Step]]
  =&gt;
  (clara/insert! (-&gt;CurrentStep (:step ?e))))

(clara/defrule step
  [CurrentValue (= ?value value)]
  [CurrentStep (= ?prev-step step)
               (= ?curr-step (int (/ ?value 10)))]
  [CurrentTimestamp (= ?instant instant)]
  [:test (&gt; ?curr-step ?prev-step)]
  =&gt;
  (clara/insert! (-&gt;Step ?curr-step ?instant)))

(defn go []
  (let [session (-&gt; (clara/mk-session &apos;rulebot.test)
                    (tt/with-tracing))]
    (-&gt; session
        (clara/insert (-&gt;CurrentTimestamp 0))
        (clara/insert (-&gt;Value 1 0))
        (clara/insert (-&gt;Step 0 0))
        (clara/fire-rules)
        (clara/retract (-&gt;CurrentTimestamp 0))

        (clara/insert (-&gt;CurrentTimestamp 1))
        (clara/insert (-&gt;Value 11 1))
        (clara/fire-rules)
        (tt/get-trace))))
</pre>
which fails on the <code>step</code> rule because <code>?prev-step</code> gets bound to an <code>{:ns-name .., :lhs ..., :rhs ...}</code> map for some reason...</z><z id="t1484854296000180" t="dm3 @wparker can you see anything obviously wrong with that?"><y>#</y><d>2017-01-19</d><h>19:31</h><w>dm3</w>@wparker can you see anything obviously wrong with that?</z><z id="t1484858419000181" t="wparker {:ns-name .., :lhs ..., :rhs …} is what the internal representation of a rule looks like; its the map structure that defrule stores in a var"><y>#</y><d>2017-01-19</d><h>20:40</h><w>wparker</w>{:ns-name .., :lhs ..., :rhs …} is what the internal representation of a rule looks like; its the map structure that defrule stores in a var</z><z id="t1484858463000182" t="wparker I don’t have time to look into it in detail at the moment but I’d guess that the “step” field is being resolved to the “step” var instead"><y>#</y><d>2017-01-19</d><h>20:41</h><w>wparker</w>I don’t have time to look into it in detail at the moment but I’d guess that the “step” field is being resolved to the “step” var instead</z><z id="t1484858475000183" t="wparker If you type “step” in a REPL in that namespace you should see the same value"><y>#</y><d>2017-01-19</d><h>20:41</h><w>wparker</w>If you type “step” in a REPL in that namespace you should see the same value</z><z id="t1484858596000184" t="wparker I’d say this edge case merits a GitHub issue to determine what to do with it but for the moment I think you can resolve this by naming your rule something that isn’t the name of one of your fact fields"><y>#</y><d>2017-01-19</d><h>20:43</h><w>wparker</w>I’d say this edge case merits a GitHub issue to determine what to do with it but for the moment I think you can resolve this by naming your rule something that isn’t the name of one of your fact fields</z><z id="t1484858605000185" t="wparker @dm3"><y>#</y><d>2017-01-19</d><h>20:43</h><w>wparker</w>@dm3</z><z id="t1484860664000186" t="dm3 you&apos;re right. Once that&apos;s fixed, the example goes into infinite loop"><y>#</y><d>2017-01-19</d><h>21:17</h><w>dm3</w>you&apos;re right. Once that&apos;s fixed, the example goes into infinite loop</z><z id="t1484860679000187" t="dm3 so your help will still be appreciated! 🙂"><y>#</y><d>2017-01-19</d><h>21:17</h><w>dm3</w>so your help will still be appreciated! <b>🙂</b></z><z id="t1484866146000188" t="wparker I see you’re inserting Step in one of your rules that looks for facts that are inserted due to Step"><y>#</y><d>2017-01-19</d><h>22:49</h><w>wparker</w>I see you’re inserting Step in one of your rules that looks for facts that are inserted due to Step</z><z id="t1484866218000189" t="wparker At first glance I’d say you’re likely doing something where you’re inserting a Step that then causes itself to be retracted and entering an infinite loop that way"><y>#</y><d>2017-01-19</d><h>22:50</h><w>wparker</w>At first glance I’d say you’re likely doing something where you’re inserting a Step that then causes itself to be retracted and entering an infinite loop that way</z><z id="t1484866246000190" t="wparker I’d need to take a closer look at it to work out exactly what"><y>#</y><d>2017-01-19</d><h>22:50</h><w>wparker</w>I’d need to take a closer look at it to work out exactly what</z><z id="t1484866333000191" t="dm3 hmm"><y>#</y><d>2017-01-19</d><h>22:52</h><w>dm3</w>hmm</z><z id="t1484866390000192" t="dm3 the step rule does insert a new Step , which should then retract the old CurrentStep and insert a new one, unless I&apos;m misunderstanding something"><y>#</y><d>2017-01-19</d><h>22:53</h><w>dm3</w>the <code>step</code> rule does insert a new <code>Step</code>, which should then retract the old <code>CurrentStep</code> and insert a new one, unless I&apos;m misunderstanding something</z><z id="t1484866568000193" t="dm3 however, after the step rule runs, the current-step rule is still executed with the previous Step fact"><y>#</y><d>2017-01-19</d><h>22:56</h><w>dm3</w>however, after the <code>step</code> rule runs, the <code>current-step</code> rule is still executed with the previous <code>Step</code> fact</z><z id="t1484866821000194" t="dm3 it&apos;s probably the truth maintenance screwing with me - Step (t0) is inserted outside the rules, Step (t1) is inserted by the next-step rule with CurrentStep (t0) . After Step (t1) triggers current-step to retract the CurrentStep (t0) , the Step (t1) also gets retracted which again triggers next-step with CurrentStep (t0)"><y>#</y><d>2017-01-19</d><h>23:00</h><w>dm3</w>it&apos;s probably the truth maintenance screwing with me - <code>Step (t0)</code> is inserted outside the rules, <code>Step (t1)</code> is inserted by the <code>next-step</code> rule with <code>CurrentStep (t0)</code>. After <code>Step (t1)</code> triggers <code>current-step</code> to retract the <code>CurrentStep (t0)</code>, the <code>Step (t1)</code> also gets retracted which again triggers <code>next-step</code> with <code>CurrentStep (t0)</code></z><z id="t1484866958000198" t="dm3 what should I do in order to accumulate the Step facts (more like events in this case) instead of having the above happening?"><y>#</y><d>2017-01-19</d><h>23:02</h><w>dm3</w>what should I do in order to accumulate the <code>Step</code> facts (more like events in this case) instead of having the above happening?</z><z id="t1484867635000199" t="wparker to be honest I’m not sure what sort of logic you’re trying to represent with the recursion there so an alternative isn’t obvious to me"><y>#</y><d>2017-01-19</d><h>23:13</h><w>wparker</w>to be honest I’m not sure what sort of logic you’re trying to represent with the recursion there so an alternative isn’t obvious to me</z><z id="t1484868893000200" t="dm3 I&apos;m trying to capture increases in Value as Step s. There&apos;s a stream of Value s coming in, which I batch and fire with a new CurrentTimestamp every N ms. Some of the batches might trigger a new Step , which I&apos;ve imagined would appear as a new fact in the session. I guess the culprit of my troubles is the recursive relation between the CurrentStep and Step ."><y>#</y><d>2017-01-19</d><h>23:34</h><w>dm3</w>I&apos;m trying to capture increases in <code>Value</code> as <code>Step</code>s. There&apos;s a stream of <code>Value</code>s coming in, which I batch and <code>fire</code> with a new <code>CurrentTimestamp</code> every N ms. Some of the batches might trigger a new <code>Step</code>, which I&apos;ve imagined would appear as a new fact in the session. I guess the culprit of my troubles is the recursive relation between the <code>CurrentStep</code> and <code>Step</code>.</z><z id="t1484869076000201" t="dm3 tried reformulating the next-step rule as follows (becuase the CurrentStep is just the MAX of all steps): (clara/defrule next-step [CurrentValue (= ?value value)] [?s &lt;- (acc/max :step :returns-fact true) :from [Step (= ?prev-step step)]] [CurrentTimestamp (= ?instant instant)] [:test (&gt; (int (/ ?value 10)) ?prev-step)] =&gt; (clara/insert! (-&gt;Step (int (/ ?value 10)) ?instant))) "><y>#</y><d>2017-01-19</d><h>23:37</h><w>dm3</w>tried reformulating the <code>next-step</code> rule as follows (becuase the CurrentStep is just the MAX of all steps):
<pre>(clara/defrule next-step
  [CurrentValue (= ?value value)]
  [?s &lt;- (acc/max :step :returns-fact true) :from [Step (= ?prev-step step)]]
  [CurrentTimestamp (= ?instant instant)]
  [:test (&gt; (int (/ ?value 10)) ?prev-step)]
  =&gt;
  (clara/insert! (-&gt;Step (int (/ ?value 10)) ?instant)))
</pre></z><z id="t1484869112000202" t="dm3 the above works, except I couldn&apos;t figure out how to bind the ?curr-step = (int (/ ?value 10)) inside the condition"><y>#</y><d>2017-01-19</d><h>23:38</h><w>dm3</w>the above works, except I couldn&apos;t figure out how to bind the <code>?curr-step = (int (/ ?value 10))</code> inside the condition</z><z id="t1484907274000203" t="dm3 seems I need something like a merged RETE/ECA engine (e.g. as described http://ceur-ws.org/Vol-412/paper3.pdf ) as I first need to distill events into state"><y>#</y><d>2017-01-20</d><h>10:14</h><w>dm3</w>seems I need something like a merged RETE/ECA engine (e.g. as described <a href="http://ceur-ws.org/Vol-412/paper3.pdf" target="_blank">http://ceur-ws.org/Vol-412/paper3.pdf</a>) as I first need to distill events into state</z><z id="t1484933331000204" t="wparker Thanks for the link, now I’m curious and will have to read that paper 🙂"><y>#</y><d>2017-01-20</d><h>17:28</h><w>wparker</w>Thanks for the link, now I’m curious and will have to read that paper <b>🙂</b></z><z id="t1485047586000205" t="wparker FYI @dm3 I logged an issue for the issue you were having with the field symbol resolving to the rule var discussed here above. https://github.com/cerner/clara-rules/issues/259"><y>#</y><d>2017-01-22</d><h>01:13</h><w>wparker</w>FYI @dm3 I logged an issue for the issue you were having with the field symbol resolving to the rule var discussed here above.  <a href="https://github.com/cerner/clara-rules/issues/259" target="_blank">https://github.com/cerner/clara-rules/issues/259</a></z><z id="t1485079131000207" t="dm3 thx"><y>#</y><d>2017-01-22</d><h>09:58</h><w>dm3</w>thx</z><z id="t1485448571000211" t="mike_ananev hi, there! Question about types. Does it necessary to use defrecord in order to declare fact? Can I use ordinary clojure maps to derive a fact and validate them by clojre.spec?"><y>#</y><d>2017-01-26</d><h>16:36</h><w>mike_ananev</w>hi, there! Question about types. Does it necessary to use defrecord in order to declare fact? Can I use ordinary clojure maps to derive a fact and validate them by clojre.spec?</z><z id="t1485452375000214" t="wparker @mike1452 Clara will use the fact-type-fn to determine what type a fact is for matching against conditions. The docs/examples can probably be improved in this regard but it is alluded to in the generated API docs at http://www.clara-rules.org/apidocs/0.13.0-RC4/clojure/clara.rules.html#var-mk-session"><y>#</y><d>2017-01-26</d><h>17:39</h><w>wparker</w>@mike1452 Clara will use the fact-type-fn to determine what type a fact is for matching against conditions.  The docs/examples can probably be improved in this regard but it is alluded to in the generated API docs at <a href="http://www.clara-rules.org/apidocs/0.13.0-RC4/clojure/clara.rules.html#var-mk-session" target="_blank">http://www.clara-rules.org/apidocs/0.13.0-RC4/clojure/clara.rules.html#var-mk-session</a></z><z id="t1485452409000215" t="wparker Defrecord is just convenient for some people’s use-cases because it creates a type to match against out of the box"><y>#</y><d>2017-01-26</d><h>17:40</h><w>wparker</w>Defrecord is just convenient for some people’s use-cases because it creates a type to match against out of the box</z><z id="t1485452433000216" t="wparker when you use clojure’s type function as the fact-type-fn (which is the default)"><y>#</y><d>2017-01-26</d><h>17:40</h><w>wparker</w>when you use clojure’s type function as the fact-type-fn (which is the default)</z><z id="t1485452773000217" t="wparker also because it allows you to use field names in a rule condition directly i.e."><y>#</y><d>2017-01-26</d><h>17:46</h><w>wparker</w>also because it allows you to use field names in a rule condition directly i.e.</z><z id="t1485452780000218" t="wparker (defrecord Cold [temperature])"><y>#</y><d>2017-01-26</d><h>17:46</h><w>wparker</w>(defrecord Cold [temperature])</z><z id="t1485452789000219" t="wparker (&lt; temperature 0)"><y>#</y><d>2017-01-26</d><h>17:46</h><w>wparker</w>(&lt; temperature 0)</z><z id="t1485452800000220" t="wparker rather than (&lt; (:temperature this) 0))"><y>#</y><d>2017-01-26</d><h>17:46</h><w>wparker</w>rather than (&lt; (:temperature this) 0))</z><z id="t1485455090000221" t="mike_ananev @wparker thanks! awesome rule engine!"><y>#</y><d>2017-01-26</d><h>18:24</h><w>mike_ananev</w>@wparker thanks! awesome rule engine!</z><z id="t1485457005000222" t="wparker @mike1452 this has come up several times. Ideally we’d have an explanation of the option at http://clara-rules.org at some point when someone gets time to write one but in the meantime I added a quick example at https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj"><y>#</y><d>2017-01-26</d><h>18:56</h><w>wparker</w>@mike1452 this has come up several times.  Ideally we’d have an explanation of the option at <a href="http://clara-rules.org" target="_blank">http://clara-rules.org</a> at some point when someone gets time to write one but in the meantime I added a quick example at <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj</a></z><z id="t1485458229000224" t="mike_ananev @wparker cool! thanx!"><y>#</y><d>2017-01-26</d><h>19:17</h><w>mike_ananev</w>@wparker cool! thanx!</z><z id="t1485458283000225" t="mike_ananev @wparker btw, is it possible to use Clara rules with Apache Flink? We are building online anti-fraud system and evaluating several engines."><y>#</y><d>2017-01-26</d><h>19:18</h><w>mike_ananev</w>@wparker btw, is it possible to use Clara rules with Apache Flink? We are building online anti-fraud system and evaluating several engines.</z><z id="t1485462233000226" t="wparker Clara currently always runs in a single JVM, although it can be used in a distributed environment if it itself isn’t distributed, and we actually do so. Clara’s architecture would likely facilitate an enhancement to distribute it and if someone were interested in driving that it could be discussed."><y>#</y><d>2017-01-26</d><h>20:23</h><w>wparker</w>Clara currently always runs in a single JVM, although it can be used in a distributed environment if it itself isn’t distributed, and we actually do so.  Clara’s architecture would likely facilitate an enhancement to distribute it and if someone were interested in driving that it could be discussed.</z><z id="t1485892652000228" t="apbleonard Looking for options for debugging rules. Would have saved some time discovering typos etc today if I could have switched on debug logging evaluating every condition of a given rule say. Or even had &quot;explain-non-activations&quot;. Any tips?"><y>#</y><d>2017-01-31</d><h>19:57</h><w>apbleonard</w>Looking for options for debugging rules. Would have saved some time discovering typos etc today if I could have switched on debug logging evaluating every condition of a given rule say. Or even had &quot;explain-non-activations&quot;. Any tips?</z><z id="t1485899389000230" t="apbleonard Ok. So it looks like inspect would have helped me. Will also try tracing tomorrow..."><y>#</y><d>2017-01-31</d><h>21:49</h><r>apbleonard</r>Ok. So it looks like inspect would have helped me. Will also try tracing tomorrow...</z><z id="t1485899684000232" t="wparker Inspect might be more helpful if you’re looking at ordinary sorts of errors like a bad rule etc. Tracing can be useful too but definitely gets into implementation details"><y>#</y><d>2017-01-31</d><h>21:54</h><r>wparker</r>Inspect might be more helpful if you’re looking at ordinary sorts of errors like a bad rule etc.  Tracing can be useful too but definitely gets into implementation details</z><z id="t1485899735000234" t="wparker If it concerns exceptions running against the branch that is out and in progress for https://github.com/cerner/clara-rules/issues/255 could be helpful too"><y>#</y><d>2017-01-31</d><h>21:55</h><r>wparker</r>If it concerns exceptions running against the branch that is out and in progress for <a href="https://github.com/cerner/clara-rules/issues/255" target="_blank">https://github.com/cerner/clara-rules/issues/255</a> could be helpful too</z><z id="t1485905975000237" t="apbleonard Thanks :) Was more about straightforward debugging. Just getting started with Clara! "><y>#</y><d>2017-01-31</d><h>23:39</h><r>apbleonard</r>Thanks :) Was more about straightforward debugging. Just getting started with Clara! </z><z id="t1485906326000239" t="apbleonard Also - looking at source of load-rules in clara/rules.cljc you can just supply a list of symbols resolving to individual rules, not just namespaces - is that correct? Would love an example of this. Flexibility around how rules are assembled would be great."><y>#</y><d>2017-01-31</d><h>23:45</h><w>apbleonard</w>Also - looking at source of load-rules in clara/rules.cljc you can just supply a list of symbols resolving to individual rules, not just namespaces - is that correct? Would love an example of this. Flexibility around how rules are assembled would be great.</z><z id="t1485907148000240" t="wparker I think a call to mk-session like the one at https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj#L20 is what you’re talking about, ignoring the :fact-type-fn and :ancestors-fn options"><y>#</y><d>2017-01-31</d><h>23:59</h><w>wparker</w>I think a call to mk-session like the one at <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj#L20" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj#L20</a> is what you’re talking about, ignoring the :fact-type-fn and :ancestors-fn options</z><z id="t1485962178000242" t="mikerod @apbleonard Think of it as clara.rules/mk-session accepts any number of “rule sources”. This can be anything that implements the clara.rules.compiler/IRuleSource protocol or just a collection of rule/query structures."><y>#</y><d>2017-02-01</d><h>15:16</h><w>mikerod</w>@apbleonard Think of it as <code>clara.rules/mk-session</code> accepts any number of “rule sources”.  This can be anything that implements the <code>clara.rules.compiler/IRuleSource</code> protocol or just a collection of rule/query structures.</z><z id="t1485962255000243" t="mikerod Clojure’s Symbol implements the clara.rules.compiler/IRuleSource protocol. The function to implement is clara.rules.compiler/load-rules which must return a collection of rule/query structures."><y>#</y><d>2017-02-01</d><h>15:17</h><w>mikerod</w>Clojure’s Symbol implements the <code>clara.rules.compiler/IRuleSource</code> protocol.  The function to implement is <code>clara.rules.compiler/load-rules</code> which must return a collection of rule/query structures.</z><z id="t1485962292000244" t="mikerod However, Will had a good example if all you want to do is something simple like pass rules in"><y>#</y><d>2017-02-01</d><h>15:18</h><w>mikerod</w>However, Will had a good example if all you want to do is something simple like pass rules in</z><z id="t1485962339000245" t="mikerod (defrule one-rule &lt;etc&gt;) (defrule another-rule &lt;etc&gt;) (defquery some-query &lt;etc&gt;) ;;;; Make session (mk-session [one-rule another-rule some-query]) "><y>#</y><d>2017-02-01</d><h>15:18</h><w>mikerod</w><pre>(defrule one-rule &lt;etc&gt;)
(defrule another-rule &lt;etc&gt;)
(defquery some-query &lt;etc&gt;)

;;;; Make session
(mk-session [one-rule another-rule some-query])
</pre></z><z id="t1485962381000246" t="mikerod you can also mix and match. Symbol implements IRuleSource by expecting the symbol to resolve to a namespace name. It scans the whole namespace and finds all rules/queries in vars of that namespace."><y>#</y><d>2017-02-01</d><h>15:19</h><w>mikerod</w>you can also mix and match.  <code>Symbol</code> implements <code>IRuleSource</code> by expecting the symbol to resolve to a namespace name.  It scans the whole namespace and finds all rules/queries in vars of that namespace.</z><z id="t1485962439000247" t="mikerod (mk-session [one-rule another-rule some-query] &apos;some.ns.with.rules)"><y>#</y><d>2017-02-01</d><h>15:20</h><w>mikerod</w><code>(mk-session [one-rule another-rule some-query] &apos;some.ns.with.rules)</code></z><z id="t1485962599000248" t="mikerod @mike1452 Will mentioned that records allow you to refer to record fields directly in the rule. For non-records, you can use destructuring though. Just so you kmow (defrule my-rule [:my-type-thing [{:keys [x y]}] (= x “hello”)] &lt;etc&gt;) "><y>#</y><d>2017-02-01</d><h>15:23</h><w>mikerod</w>@mike1452 Will mentioned that records allow you to refer to record fields directly in the rule.  For non-records, you can use destructuring though.  Just so you kmow
<pre>(defrule my-rule [:my-type-thing [{:keys [x y]}] (= x “hello”)] 
&lt;etc&gt;)
</pre></z><z id="t1485962623000249" t="mikerod There should probably be documented examples of that sort of destructuring."><y>#</y><d>2017-02-01</d><h>15:23</h><w>mikerod</w>There should probably be documented examples of that sort of destructuring.</z><z id="t1485962821000250" t="mike_ananev thanks"><y>#</y><d>2017-02-01</d><h>15:27</h><w>mike_ananev</w>thanks</z><z id="t1486072834000252" t="apbleonard @wparker @mikerod Thanks so much - that&apos;s exactly the examples I was looking for. Assembling rules dynamically will help us handle our mostly similar (but slightly different) rule-sets for different products. Btw destructuring maps also good to know, as records are not often used in our Clojure codebase."><y>#</y><d>2017-02-02</d><h>22:00</h><w>apbleonard</w>@wparker @mikerod Thanks so much - that&apos;s exactly the examples I was looking for. Assembling rules dynamically will help us handle our mostly similar (but slightly different) rule-sets for different products. Btw destructuring maps also good to know, as records are not often used in our Clojure codebase.</z><z id="t1486072971000253" t="mikerod It’s probably good to be aware that if you can order rules in a meaningful order of precedence, Clara will attempt to use that as a heuristic during conflict resolution (picking which rule to fire first, when multiple are eligible)."><y>#</y><d>2017-02-02</d><h>22:02</h><w>mikerod</w>It’s probably good to be aware that if you can order rules in a meaningful order of precedence, Clara will attempt to use that as a heuristic during conflict resolution (picking which rule to fire first, when multiple are eligible).</z><z id="t1486073017000254" t="mikerod So if you have rules or sets of rules that naturally depend on other rules/sets of rules, you want to put the dependents after the dependencies. This may not matter to you and may not be worth worrying about until you have a concrete performance concern."><y>#</y><d>2017-02-02</d><h>22:03</h><w>mikerod</w>So if you have rules or sets of rules that naturally depend on other rules/sets of rules, you want to put the dependents after the dependencies.  This may not matter to you and may not be worth worrying about until you have a concrete performance concern.</z><z id="t1486073175000255" t="apbleonard We have relatively low numbers of rules (no more than 100s depending on how granular we make them), but enough for Clara to really help sort out the complexity. 🙂 "><y>#</y><d>2017-02-02</d><h>22:06</h><w>apbleonard</w>We have relatively low numbers of rules (no more than 100s depending on how granular we make them), but enough for Clara to really help sort out the complexity. <b>🙂</b> </z><z id="t1486073218000256" t="mikerod If I had rules like: (defrule a [(acc/all) :from [A]] =&gt; (insert! (-&gt;B))) (defrule b [(acc/all) :from [B]] =&gt; (insert! (-&gt;C))) (defrule c [(acc/all) :from [C]] =&gt; (insert! (-&gt;D))) All three rules would be “eligible” to be fired immediately, since the acc/all accumulator is always considered “true”. It will just fire with an empty collection if it has no matches, yet. If I mk-session like (mk-session [c b a]) This would cause Clara to choose to fire the rules in the opposite order that you would want. The Truth Maintenance System will be sure that your rules logically are correct after firing the rules, however, it will waste cycles firing rules too soon and having to retract and re-fire them later as their dependencies in their LHS change. So you want mk-session like (mk-session [a b c]) "><y>#</y><d>2017-02-02</d><h>22:06</h><w>mikerod</w>If I had rules like:
<pre>(defrule a [(acc/all) :from [A]] =&gt; (insert! (-&gt;B)))
(defrule b [(acc/all) :from [B]] =&gt; (insert! (-&gt;C)))
(defrule c [(acc/all) :from [C]] =&gt; (insert! (-&gt;D)))
</pre>
All three rules would be “eligible” to be fired immediately, since the <code>acc/all</code> accumulator is always considered “true”.  It will just fire with an empty collection if it has no matches, yet.

If I <code>mk-session</code> like
<pre>(mk-session [c b a])
</pre>
This would cause Clara to choose to fire the rules in the opposite order that you would want.  The Truth Maintenance System will be sure that your rules logically are correct after firing the rules, however, it will waste cycles firing rules too soon and having to retract and re-fire them later as their dependencies in their LHS change.

So you want <code>mk-session</code> like
<pre>(mk-session [a b c])
</pre></z><z id="t1486073273000257" t="mikerod @apbleonard Yeah, it likely isn’t something to concern yourself with now. I’m just brining it to your attention since when you start to consider generating rules, etc, it may be something to consider later on if performance becomes and sort of concern."><y>#</y><d>2017-02-02</d><h>22:07</h><w>mikerod</w>@apbleonard Yeah, it likely isn’t something to concern yourself with now.  I’m just brining it to your attention since when you start to consider generating rules, etc, it may be something to consider later on if performance becomes and sort of concern.</z><z id="t1486676182000261" t="gamecubate Hello. Clojurescript doesn’t seem to be supported at this time. Bummer. Was just what I needed for a project at work."><y>#</y><d>2017-02-09</d><h>21:36</h><w>gamecubate</w>Hello. Clojurescript doesn’t seem to be supported at this time. Bummer. Was just what I needed for a project at work.</z><z id="t1486679844000264" t="wparker @gamecubate ClojureScript is definitely intended to be supported, although it isn’t used as much as the Clojure version as far as I can tell and not at all at Cerner."><y>#</y><d>2017-02-09</d><h>22:37</h><w>wparker</w>@gamecubate ClojureScript is definitely intended to be supported, although it isn’t used as much as the Clojure version as far as I can tell and not at all at Cerner.</z><z id="t1486679865000265" t="wparker Those don’t look like fatal warnings to me, did you run into further problems?"><y>#</y><d>2017-02-09</d><h>22:37</h><w>wparker</w>Those don’t look like fatal warnings to me, did you run into further problems?</z><z id="t1486698618000266" t="gamecubate @wparker I didn’t want to spend too much time digging into this. So, I’ve switched over to core.logic but I have to say progress is glacial (this said less than 2 hours after the switch). Clara’s eloquent DSL I miss already."><y>#</y><d>2017-02-10</d><h>03:50</h><w>gamecubate</w>@wparker I didn’t want to spend too much time digging into this. So, I’ve switched over to core.logic but I have to say progress is glacial (this said less than 2 hours after the switch). Clara’s eloquent DSL I miss already.</z><z id="t1486740037000267" t="wparker To elaborate a bit, those are basically linter warnings that seem related to the rebinding, in a particular namespace, of core Clojure library definitions to new values. You can look at the source in both cases for whatever version of ClojureScript and Plumatic Schema you’re using to see those redefinitions happening. Whether that is good style in any particular case is a matter of opinion, but I don’t think the linter warnings are actually errors. Obviously your choice to use Clara in any project or not, but nothing I see here makes me think there is a bug with Clara’s ClojureScript support. That said, Clara’s ClojureScript certainly isn’t as hardened as the JVM version and bug reports are welcome."><y>#</y><d>2017-02-10</d><h>15:20</h><w>wparker</w>To elaborate a bit, those are basically linter warnings that seem related to the rebinding, in a particular namespace, of core Clojure library definitions to new values.  You can look at the source in both cases for whatever version of ClojureScript and Plumatic Schema you’re using to see those redefinitions happening. Whether that is good style in any particular case is a matter of opinion, but I don’t think the linter warnings are actually errors.  Obviously your choice to use Clara in any project or not, but nothing I see here makes me think there is a bug with Clara’s ClojureScript support.  That said, Clara’s ClojureScript certainly isn’t as hardened as the JVM version and bug reports are welcome.</z><z id="t1486740073000268" t="wparker Against master: https://github.com/plumatic/schema/blob/master/src/cljx/schema/core.cljx#L402 and https://github.com/clojure/clojurescript/blob/master/src/main/cljs/clojure/reflect.cljs#L33"><y>#</y><d>2017-02-10</d><h>15:21</h><w>wparker</w>Against master: <a href="https://github.com/plumatic/schema/blob/master/src/cljx/schema/core.cljx#L402" target="_blank">https://github.com/plumatic/schema/blob/master/src/cljx/schema/core.cljx#L402</a> and <a href="https://github.com/clojure/clojurescript/blob/master/src/main/cljs/clojure/reflect.cljs#L33" target="_blank">https://github.com/clojure/clojurescript/blob/master/src/main/cljs/clojure/reflect.cljs#L33</a></z><z id="t1486742644000270" t="gamecubate @wparker End of day when I wrote this. I wasn’t thinking. Of course they were warnings! I gave up there and then instead of doing what I normally do (which is to ignore warnings) and proceed. Will resume Clara tests. Thanks for the nudge. 🙂"><y>#</y><d>2017-02-10</d><h>16:04</h><w>gamecubate</w>@wparker End of day when I wrote this. I wasn’t thinking. Of course they were warnings! I gave up there and then instead of doing what I normally do (which is to ignore warnings) and proceed. Will resume Clara tests. Thanks for the nudge. <b>🙂</b></z><z id="t1486745353000274" t="gamecubate Macros… Checking Clara docs, I see mk-session is a macro indeed. I need to probably add a (:require-macros [???]) directive. Will try..."><y>#</y><d>2017-02-10</d><h>16:49</h><w>gamecubate</w>Macros… Checking Clara docs, I see mk-session is a macro indeed. I need to probably add a <pre>(:require-macros [???])</pre> directive. Will try...</z><z id="t1486745484000275" t="ryanbrush @gamecubate I&apos;d check out the ClojureScript examples, like the one at https://github.com/cerner/clara-examples/blob/master/src/main/clojurescript/clara/examples/shopping.cljs ."><y>#</y><d>2017-02-10</d><h>16:51</h><w>ryanbrush</w>@gamecubate I&apos;d check out the ClojureScript examples, like the one at <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojurescript/clara/examples/shopping.cljs" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojurescript/clara/examples/shopping.cljs</a>.</z><z id="t1486745550000277" t="ryanbrush Note that mk-session doesn&apos;t exist and isn&apos;t support in ClojureScript, since it dynamically compiles rules. You&apos;ll need to use defsession (which compiles them upfront), as seen in that example. In fact, starting with that example, running it, and experimenting with changes to it is probably a pretty good way to get started with the ClojureScript flow."><y>#</y><d>2017-02-10</d><h>16:52</h><w>ryanbrush</w>Note that mk-session doesn&apos;t exist and isn&apos;t support in ClojureScript, since it dynamically compiles rules. You&apos;ll need to use defsession (which compiles them upfront), as seen in that example. In fact, starting with that example, running it, and experimenting with changes to it is probably a pretty good way to get started with the ClojureScript flow.</z><z id="t1486745593000278" t="gamecubate @ryanbrush Thanks. Going through the example now."><y>#</y><d>2017-02-10</d><h>16:53</h><w>gamecubate</w>@ryanbrush Thanks. Going through the example now.</z><z id="t1486745701000279" t="ryanbrush @gamecubate Sure thing! If you find problems, please log bugs or let us know. Just to warn you, we&apos;ve used only the Clojure version in production and therefore haven&apos;t deeply optimized the CLJS flow so you might run into more issues there. But bug reports, and especially help tuning or optimizing the CLJS flow against real workloads, would be welcome."><y>#</y><d>2017-02-10</d><h>16:55</h><w>ryanbrush</w>@gamecubate Sure thing! If you find problems, please log bugs or let us know. Just to warn you, we&apos;ve used only the Clojure version in production and therefore haven&apos;t deeply optimized the CLJS flow so you might run into more issues there. But bug reports, and especially help tuning or optimizing the CLJS flow against real workloads, would be welcome.</z><z id="t1486745759000280" t="ryanbrush @gamecubate I think we&apos;re also behind on the version of ClojureScript we&apos;ve tested against, so validating against newer versions is welcome as well."><y>#</y><d>2017-02-10</d><h>16:55</h><w>ryanbrush</w>@gamecubate I think we&apos;re also behind on the version of ClojureScript we&apos;ve tested against, so validating against newer versions is welcome as well.</z><z id="t1486745775000281" t="gamecubate @ryanbrush :+1:"><y>#</y><d>2017-02-10</d><h>16:56</h><w>gamecubate</w>@ryanbrush <b>:+1:</b></z><z id="t1486746008000284" t="gamecubate @ryanbrush Would you recommend I run my code against 0.13.0-RC4 (as per README.md) or, per your example, 0.13.0-RC7?"><y>#</y><d>2017-02-10</d><h>17:00</h><w>gamecubate</w>@ryanbrush Would you recommend I run my code against 0.13.0-RC4 (as per README.md) or, per your example, 0.13.0-RC7?</z><z id="t1486746073000285" t="ryanbrush @gamecubate Probably doesn&apos;t matter for your needs, but the readme is just out of date. 0.13.0-RC7 will be good. (We&apos;re overdue in just releasing 0.13.0 itself, so expect that in a release soon.)"><y>#</y><d>2017-02-10</d><h>17:01</h><w>ryanbrush</w>@gamecubate Probably doesn&apos;t matter for your needs, but the readme is just out of date. 0.13.0-RC7 will be good. (We&apos;re overdue in just releasing 0.13.0 itself, so expect that in a release soon.)</z><z id="t1486746084000286" t="gamecubate got it"><y>#</y><d>2017-02-10</d><h>17:01</h><w>gamecubate</w>got it</z><z id="t1486746358000287" t="gamecubate Wow. This is one great example."><y>#</y><d>2017-02-10</d><h>17:05</h><w>gamecubate</w>Wow. This is one great example.</z><z id="t1486746387000288" t="gamecubate Just need to replace dommy with (my chosen) Reagent code."><y>#</y><d>2017-02-10</d><h>17:06</h><w>gamecubate</w>Just need to replace dommy with (my chosen) Reagent code.</z><z id="t1486746725000289" t="ryanbrush Yeah, we probably should update the example to use a more modern approach. 🙂"><y>#</y><d>2017-02-10</d><h>17:12</h><w>ryanbrush</w>Yeah, we probably should update the example to use a more modern approach. <b>🙂</b></z><z id="t1486747081000290" t="gamecubate It works nicely, though."><y>#</y><d>2017-02-10</d><h>17:18</h><w>gamecubate</w>It works nicely, though.</z><z id="t1486747126000291" t="gamecubate fire-rules successful. Am plugging in reactive (test) UI right now."><y>#</y><d>2017-02-10</d><h>17:18</h><w>gamecubate</w><pre>fire-rules</pre> successful. Am plugging in reactive (test) UI right now.</z><z id="t1486747190000292" t="gamecubate My first instinct (as with all Reagent app data) would be to wrap the session in a (reagent) atom, but defsession being a macro and all, not sure this is even feasible, nor desirable, nor useful."><y>#</y><d>2017-02-10</d><h>17:19</h><w>gamecubate</w>My first instinct (as with all Reagent app data) would be to wrap the session in a (reagent) atom, but defsession being a macro and all, not sure this is even feasible, nor desirable, nor useful.</z><z id="t1486750436000293" t="gamecubate Done. Works nicely. Will now try and compile with advanced-optimizations."><y>#</y><d>2017-02-10</d><h>18:13</h><w>gamecubate</w>Done. Works nicely. Will now try and compile with advanced-optimizations.</z><z id="t1486750608000294" t="gamecubate Works!"><y>#</y><d>2017-02-10</d><h>18:16</h><w>gamecubate</w>Works!</z><z id="t1486750646000295" t="gamecubate Clara it is, then. 🙂"><y>#</y><d>2017-02-10</d><h>18:17</h><w>gamecubate</w>Clara it is, then. <b>🙂</b></z><z id="t1486752963000296" t="ryanbrush @gamecubate Glad it works! Note that defsession will create the initial, empty session as a static var, but that can be referenced and manipulated like any other Clojure data structure. I haven&apos;t thought a ton of good design patterns with Reagent...but just thinking of the session as any other complex, immutable structure is probably a good start."><y>#</y><d>2017-02-10</d><h>18:56</h><w>ryanbrush</w>@gamecubate Glad it works! Note that defsession will create the initial, empty session as a static var, but that can be referenced and manipulated like any other Clojure data structure. I haven&apos;t thought a ton of good design patterns with Reagent...but just thinking of the session as any other complex, immutable structure is probably a good start.</z><z id="t1486753034000297" t="ryanbrush @gamecubate if you do come up with good patterns for using this with Reagent and are interested in sharing examples of doing so, we could look at including them in the examples project (possibly replacing the dommy example that exists today)."><y>#</y><d>2017-02-10</d><h>18:57</h><w>ryanbrush</w>@gamecubate if you do come up with good patterns for using this with Reagent and are interested in sharing examples of doing so, we could look at including them in the examples project (possibly replacing the dommy example that exists today).</z><z id="t1486753413000298" t="gamecubate So far still exploring. What I have done thus far is for my event handlers (someone enters data in a field and clicks on add button -&gt; triggers handler) to insert new session data: (-&gt; my-session (insert (-&gt;Customer “Alex”)) (fire-rules)) . Now am trying to figure out what to do for my reagent components to show the changes. Normally, without Clara, the event handler would simply update the atom that my components are watching. But now, with Clara, inserted data is held in the session and I need to find a way for my components to track that instead."><y>#</y><d>2017-02-10</d><h>19:03</h><w>gamecubate</w>So far still exploring. What I have done thus far is for my event handlers (someone enters data in a field and clicks on add button -&gt; triggers handler) to insert new session data: <pre>(-&gt; my-session (insert (-&gt;Customer “Alex”)) (fire-rules))</pre>. Now am trying to figure out what to do for my reagent components to show the changes. Normally, without Clara, the event handler would simply update the atom that my components are watching. But now, with Clara, inserted data is held in the session and I need to find a way for my components to track that instead.</z><z id="t1486753987000301" t="gamecubate Now, with rules, the handler changes to:"><y>#</y><d>2017-02-10</d><h>19:13</h><w>gamecubate</w>Now, with rules, the handler changes to:</z><z id="t1486754096000303" t="gamecubate My customer-list component should change as well, and that’s where I am not sure how to proceed to get session data I need."><y>#</y><d>2017-02-10</d><h>19:14</h><w>gamecubate</w>My customer-list component should change as well, and that’s where I am not sure how to proceed to get session data I need.</z><z id="t1486754465000305" t="ryanbrush Not a Reagent expert, but I think it should be possible to keep a Clara session in a Reagent atom, and swap it out every time you update facts or fire rules."><y>#</y><d>2017-02-10</d><h>19:21</h><w>ryanbrush</w>Not a Reagent expert, but I think it should be possible to keep a Clara session in a Reagent atom, and swap it out every time you update facts or fire rules.</z><z id="t1486754514000306" t="gamecubate How do I access records of a certain type, say ClientRepresentative?"><y>#</y><d>2017-02-10</d><h>19:21</h><w>gamecubate</w>How do I access records of a certain type, say ClientRepresentative?</z><z id="t1486754542000307" t="gamecubate (def session-db (reagent/atom my-session))"><y>#</y><d>2017-02-10</d><h>19:22</h><w>gamecubate</w><pre>(def session-db (reagent/atom my-session))</pre></z><z id="t1486754553000308" t="gamecubate Not sure."><y>#</y><d>2017-02-10</d><h>19:22</h><w>gamecubate</w>Not sure.</z><z id="t1486754575000309" t="ryanbrush All access goes through queries. http://www.clara-rules.org/docs/queries/"><y>#</y><d>2017-02-10</d><h>19:22</h><w>ryanbrush</w>All access goes through queries. <a href="http://www.clara-rules.org/docs/queries/" target="_blank">http://www.clara-rules.org/docs/queries/</a></z><z id="t1486754797000311" t="gamecubate How does one write a query that retrieves all records of a certain type? Something like (defquery get-clients “” [] [???])"><y>#</y><d>2017-02-10</d><h>19:26</h><w>gamecubate</w>How does one write a query that retrieves all records of a certain type? Something like <pre>(defquery get-clients “” [] [???])</pre></z><z id="t1486754852000312" t="gamecubate with that type defined as (defrecord Client [name]) ."><y>#</y><d>2017-02-10</d><h>19:27</h><w>gamecubate</w>with that type defined as <pre>(defrecord Client [name])</pre>.</z><z id="t1486754992000313" t="gamecubate I might need an example for using accumulators/all. That looks like the one I need."><y>#</y><d>2017-02-10</d><h>19:29</h><w>gamecubate</w>I might need an example for using accumulators/all. That looks like the one I need.</z><z id="t1486755303000314" t="gamecubate Oh I see. might be [?client &lt;- Client]"><y>#</y><d>2017-02-10</d><h>19:35</h><w>gamecubate</w>Oh I see. might be <pre>[?client &lt;- Client]</pre></z><z id="t1486759765000315" t="gamecubate Got it. Just need to set a rule that updates the (reagent atom) db whenever a new session insert takes place."><y>#</y><d>2017-02-10</d><h>20:49</h><w>gamecubate</w>Got it. Just need to set a rule that updates the (reagent atom) db whenever a new session insert takes place.</z><z id="t1486761281000326" t="gamecubate So, this works. I am not sure however that this should be added to examples because it only serves to demonstrate that using Clara and Reagent together requires (in my solution at least) an extra level of indirection (view -&gt; event handler -&gt; clara insert -&gt; reagent atom db update -&gt; view …). The business logic that Clara offers a DSL for is too simple in this case. I’ll try and think of something more convoluted before submitting said example."><y>#</y><d>2017-02-10</d><h>21:14</h><w>gamecubate</w>So, this works. I am not sure however that this should be added to examples because it only serves to demonstrate that using Clara and Reagent together requires (in my solution at least) an extra level of indirection (view -&gt; event handler -&gt; clara insert -&gt; reagent atom db update -&gt; view …). The business logic that Clara offers a DSL for is too simple in this case. I’ll try and think of something more convoluted before submitting said example.</z><z id="t1486763517000328" t="ryanbrush Cool, glad it&apos;s working. No rush in adding something to the examples...it&apos;s just nice to see a pattern that works with Reagent."><y>#</y><d>2017-02-10</d><h>21:51</h><w>ryanbrush</w>Cool, glad it&apos;s working. No rush in adding something to the examples...it&apos;s just nice to see a pattern that works with Reagent.</z><z id="t1486763617000329" t="ryanbrush One thing to note: the session itself is immutable, so you&apos;ll probably want to keep it in atom itself and swap out when you make changes. The rules you have above will work because they are just appending state, but you&apos;re actually resetting back to an old session state every time."><y>#</y><d>2017-02-10</d><h>21:53</h><w>ryanbrush</w>One thing to note: the session itself is immutable, so you&apos;ll probably want to keep it in atom itself and swap out when you make changes. The rules you have above will work because they are just appending state, but you&apos;re actually resetting back to an old session state every time.</z><z id="t1486764208000330" t="ryanbrush There are probably other interesting variations on this. For instance, we could have reactions that fire on a swap of an atom containing the session, and those reactions would query the session and update other state. This could be a little closer to the purely &quot;reactive&quot; ideals of Reagent, rather than having rules that actively update state."><y>#</y><d>2017-02-10</d><h>22:03</h><w>ryanbrush</w>There are probably other interesting variations on this. For instance, we could have reactions that fire on a swap of an atom containing the session, and those reactions would query the session and update other state. This could be a little closer to the purely &quot;reactive&quot; ideals of Reagent, rather than having rules that actively update state.</z><z id="t1486764480000331" t="gamecubate I see. Changes needed then; will think about it to see where and how. Thanks! Gotta go pick up kid @ daycare (immutable task for me :). Cheers."><y>#</y><d>2017-02-10</d><h>22:08</h><w>gamecubate</w>I see. Changes needed then; will think about it to see where and how. Thanks! Gotta go pick up kid @ daycare (immutable task for me :). Cheers.</z><z id="t1486924958000332" t="mike_ananev Hi! Can Clara detect a rule collisions? If rule C contradicts to rule A ?"><y>#</y><d>2017-02-12</d><h>18:42</h><w>mike_ananev</w>Hi! Can Clara detect a rule collisions? If rule C contradicts to rule A ?</z><z id="t1486933197000333" t="apbleonard Fairly new to Clara but ... it probably depends slightly what you mean. If you have a rules like &quot;if A then B = 1&quot; and &quot;if A then B = 2&quot;, then when you query the session for values of B (assuming A is true) you&apos;ll find two values in the lazy sequence returned by the query function."><y>#</y><d>2017-02-12</d><h>20:59</h><w>apbleonard</w>Fairly new to Clara but ... it probably depends slightly what you mean. If you have a rules like &quot;if A then B = 1&quot; and &quot;if A then B = 2&quot;, then when you query the session for values of B (assuming A is true) you&apos;ll find two values in the lazy sequence returned by the query function.</z><z id="t1486933307000334" t="apbleonard If you have rules like &quot;if A then B&quot; and &quot;if B then retract A&quot; ... well, I haven&apos;t got that far yet!"><y>#</y><d>2017-02-12</d><h>21:01</h><w>apbleonard</w>If you have rules like &quot;if A then B&quot; and &quot;if B then retract A&quot; ... well, I haven&apos;t got that far yet!</z><z id="t1486937843000335" t="mike_ananev @apbleonard yeah, first variant with two answers is correct, i think. second variant is not, cause &quot;if A then B&quot; will insert fact B, but if retract A then B will be retracted automatically. my question about contradiction was about case if some big organization issues new policy about smth, i want to check that rules in new policy are not contradict to older policies. so i want to find collisions before new policy is issued."><y>#</y><d>2017-02-12</d><h>22:17</h><w>mike_ananev</w>@apbleonard yeah, first variant with two answers is correct, i think. second variant is not,  cause &quot;if A then B&quot; will insert fact B, but if retract A then B will be retracted automatically. my question about contradiction was about case if some big organization issues new policy about smth, i want to check that rules in new policy are not contradict to older policies. so i want to find collisions before new policy is issued.</z><z id="t1487020958000336" t="mikerod @mike1452 @apbleonard the 2nd variant could actually cause an infinite loop since Clara’s insert! will do some automatic truth-maintenance which can hang indefinitely if you have a “logical loop&quot;"><y>#</y><d>2017-02-13</d><h>21:22</h><w>mikerod</w>@mike1452 @apbleonard the 2nd variant could actually cause an infinite loop since Clara’s <code>insert!</code> will do some automatic truth-maintenance which can hang indefinitely if you have a “logical loop&quot;</z><z id="t1487021069000337" t="mikerod However, the 1st variant sounds to be more of what you were asking. You have to deal with duplicated inserts yourself. You could have rules all insert some fact like B there, then have some “final”/”outcome&quot; rule(s) or query(s) that use an accumulator that you can make decide which facts are the most relevant or correct when you get into a situation of “contradictions&quot;"><y>#</y><d>2017-02-13</d><h>21:24</h><w>mikerod</w>However, the 1st variant sounds to be more of what you were asking.  You have to deal with duplicated inserts yourself.  You could have rules all insert some fact like B there, then have some “final”/”outcome&quot; rule(s) or query(s) that use an accumulator that you can make decide which facts are the most relevant or correct when you get into a situation of “contradictions&quot;</z><z id="t1487021236000338" t="mikerod However, I think you were also wanting the engine to tell you about these rules so you could remove them perhaps? That would be something you’d probably have to workout yourself. Sounds domain-specific."><y>#</y><d>2017-02-13</d><h>21:27</h><w>mikerod</w>However, I think you were also wanting the engine to tell you about these rules so you could remove them perhaps?  That would be something you’d probably have to workout yourself.  Sounds domain-specific.</z><z id="t1487021270000339" t="mikerod It isn’t really clear what a “contradicting” rule means from the rules engine’s perspective. With the exception of logical contradictions, but those also aren’t even clear in the engine right now since the RHS can insert basically anthing"><y>#</y><d>2017-02-13</d><h>21:27</h><w>mikerod</w>It isn’t really clear what a “contradicting” rule means from the rules engine’s perspective.  With the exception of logical contradictions, but those also aren’t even clear in the engine right now since the RHS can insert basically anthing</z><z id="t1487021297000340" t="mikerod and the LHS can test constraints that aren’t simple to statically analyze."><y>#</y><d>2017-02-13</d><h>21:28</h><w>mikerod</w>and the LHS can test constraints that aren’t simple to statically analyze.</z><z id="t1487089804000341" t="wparker @mike1452 @apbleonard If you use manual retractions in the RHS you become responsible for ensuring that the rule execution order works out so that you get your desired results. It is basically the same idea as with logical vs unconditional insertions discussed at http://www.clara-rules.org/docs/truthmaint/ This can be done with salience and/or strategic structuring of your rules, but in my experience adds significant complication and room for error"><y>#</y><d>2017-02-14</d><h>16:30</h><w>wparker</w>@mike1452 @apbleonard If you use manual retractions in the RHS you become responsible for ensuring that the rule execution order works out so that you get your desired results.  It is basically the same idea as with logical vs unconditional insertions discussed at <a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a>  This can be done with salience and/or strategic structuring of your rules, but in my experience adds significant complication and room for error</z><z id="t1487089887000343" t="wparker My suggestion would be to use accumulators or negation conditions as Mike alluded to above. If you have a priority order of different logical states it wouldn’t be too hard to get the state with the highest priority in an accumulator and use that state in a rule RHS. Alternatively, you can write rules like"><y>#</y><d>2017-02-14</d><h>16:31</h><w>wparker</w>My suggestion would be to use accumulators or negation conditions as Mike alluded to above.  If you have a priority order of different logical states it wouldn’t be too hard to get the state with the highest priority in an accumulator and use that state in a rule RHS.  Alternatively, you can write rules like</z><z id="t1487090045000344" t="wparker (defrule negation-rule-1 [?a &lt;- A (some-predicate-here)] [:not [B (other-predicate-here)]] =&gt; (insert something))"><y>#</y><d>2017-02-14</d><h>16:34</h><w>wparker</w>(defrule negation-rule-1 [?a &lt;- A (some-predicate-here)] [:not [B (other-predicate-here)]] =&gt; (insert something))</z><z id="t1487090262000345" t="wparker manual RHS retractions can be useful for getting things out of memory or for performance, in general wouldn’t be my first resort though"><y>#</y><d>2017-02-14</d><h>16:37</h><w>wparker</w>manual RHS retractions can be useful for getting things out of memory or for performance, in general wouldn’t be my first resort though</z><z id="t1487090820000346" t="mike_ananev @wparker thanks for suggestions! btw, what is most biggest rules database you&apos;ve ever seen in production memory that Clara worked with? 10,100, 500?"><y>#</y><d>2017-02-14</d><h>16:47</h><w>mike_ananev</w>@wparker thanks for suggestions! btw, what is most biggest rules database  you&apos;ve ever seen in production memory that Clara worked with? 10,100, 500?</z><z id="t1487090838000347" t="wparker do you mean the number of rules?"><y>#</y><d>2017-02-14</d><h>16:47</h><w>wparker</w>do you mean the number of rules?</z><z id="t1487090849000348" t="mike_ananev yeah"><y>#</y><d>2017-02-14</d><h>16:47</h><w>mike_ananev</w>yeah</z><z id="t1487091319000349" t="wparker I think we have some rulesets with at least 10K rules now, can’t say exactly off the top of my head since we autogenerate a lot of rules with some internal framework code"><y>#</y><d>2017-02-14</d><h>16:55</h><w>wparker</w>I think we have some rulesets with at least 10K rules now, can’t say exactly off the top of my head since we autogenerate a lot of rules with some internal framework code</z><z id="t1487091493000350" t="wparker there’s a reason we’ve spent a lot of effort optimizing performance 😛"><y>#</y><d>2017-02-14</d><h>16:58</h><w>wparker</w>there’s a reason we’ve spent a lot of effort optimizing performance <b>😛</b></z><z id="t1487095459000351" t="mike_ananev wow, cool!"><y>#</y><d>2017-02-14</d><h>18:04</h><w>mike_ananev</w>wow, cool!</z><z id="t1487099946000352" t="apbleonard @mike1452 FWIW I have exactly the same challenges. We handle complex government policies introduced atop of older policies, and half the battle is understanding pathways through the logic, and the total space of inputs and the variety of resulting outputs. I&apos;d love to implement the rules trivially enough to give fast feedback to policy makers on what their new policy just did to the complexity of the problem. I feel like clojure&apos;s core.logic should be able to help with this...? If that makes sense, anyone know of people using core.logic with Clara?"><y>#</y><d>2017-02-14</d><h>19:19</h><w>apbleonard</w>@mike1452 FWIW I have exactly the same challenges. We handle complex government policies introduced atop of older policies, and half the battle is understanding pathways through the logic, and the total space of inputs and the variety of resulting outputs. I&apos;d love to implement the rules trivially enough to give fast feedback to policy makers on what their new policy just did to the complexity of the problem. I feel like clojure&apos;s core.logic should be able to help with this...? If that makes sense, anyone know of people using core.logic with Clara?</z><z id="t1487105346000353" t="ryanbrush @apbleonard I&apos;m a fan of core.logic, but am unaware of anyone using it tightly with Clara. I think core.logic works great for problems that can be described as a set of constraints, and core.logic will search that constraint space for a solution. Clara is more centered around encoding business rules or domain expertise. It&apos;s not always obvious which tool is best for a given job, so I always think it&apos;s a good idea to experiment with both in your problem space before choosing a direction."><y>#</y><d>2017-02-14</d><h>20:49</h><w>ryanbrush</w>@apbleonard I&apos;m a fan of core.logic, but am unaware of anyone using it tightly with Clara. I think core.logic works great for problems that can be described as a set of constraints, and core.logic will search that constraint space for a solution. Clara is more centered around encoding business rules or domain expertise. It&apos;s not always obvious which tool is best for a given job, so I always think it&apos;s a good idea to experiment with both in your problem space before choosing a direction.</z><z id="t1487106625000354" t="wparker Clara-rules 0.13.0 is released. - The replacement of the previous durability API with a more robust and performant one. This is discussed at issue 198. Note that this is experimental and is subject to further change; that said we&apos;re successfully using it in production at Cerner. - Improvements in error reporting in rule and query conditions, discussed at issue 255. Thanks to Carlos Phillips for this one. - Various performance improvements and bug fixes discussed on the changelog."><y>#</y><d>2017-02-14</d><h>21:10</h><w>wparker</w>Clara-rules 0.13.0 is released.  - The replacement of the previous durability API with a more robust and performant one. This is discussed at issue 198.  Note that this is experimental and is subject to further change; that said we&apos;re successfully using it in production at Cerner.
- Improvements in error reporting in rule and query conditions, discussed at issue 255. Thanks to Carlos Phillips for this one.
- Various performance improvements and bug fixes discussed on the changelog.</z><z id="t1487106664000355" t="wparker I meant to say “highlights include” before my bullets.. I fail at Slack formatting 😛"><y>#</y><d>2017-02-14</d><h>21:11</h><w>wparker</w>I meant to say “highlights include” before my bullets.. I fail at Slack formatting <b>😛</b></z><z id="t1487106679000356" t="wparker Anyway, basically a cross-post from https://groups.google.com/forum/#!topic/clara-rules/Q2p7l-Vmcr0"><y>#</y><d>2017-02-14</d><h>21:11</h><w>wparker</w>Anyway, basically a cross-post from <a href="https://groups.google.com/forum/#!topic/clara-rules/Q2p7l-Vmcr0" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/Q2p7l-Vmcr0</a></z><z id="t1487281932000362" t="jarrodctaylor Could anyone be so kind as to help me understand how variable definition works? This is the most concise example I have to illustrate my confusion. (require &apos;[clara.rules :as rule]) (rule/defrule wat [1 (= ?a &quot;a&quot;)] [1 (= ?b &quot;b&quot;) (nil? (println ?a)) ;; =&gt; &quot;a&quot; (nil? (println ?b)) ;; =&gt; &quot;b&quot; (nil? (println ?a ?b)) ;; =&gt; &quot;a nil&quot; ] =&gt; nil) (-&gt; (rule/mk-session [wat] :fact-type-fn (constantly 1)) (rule/insert 1) (rule/fire-rules)) "><y>#</y><d>2017-02-16</d><h>21:52</h><w>jarrodctaylor</w>Could anyone be so kind as to help me understand how variable definition works? This is the most concise example I have to illustrate my confusion.
<pre>(require &apos;[clara.rules :as rule])

(rule/defrule wat
  [1 (= ?a &quot;a&quot;)]
  [1 (= ?b &quot;b&quot;)
   (nil? (println ?a))    ;; =&gt; &quot;a&quot;
   (nil? (println ?b))    ;; =&gt; &quot;b&quot;
   (nil? (println ?a ?b)) ;; =&gt; &quot;a nil&quot;
   ] =&gt; nil)

(-&gt; (rule/mk-session [wat] :fact-type-fn (constantly 1))
    (rule/insert 1)
    (rule/fire-rules))
</pre></z><z id="t1487281994000364" t="jarrodctaylor Why does ?b disappear when printed together with ?a ?"><y>#</y><d>2017-02-16</d><h>21:53</h><w>jarrodctaylor</w>Why does <code>?b</code> disappear when printed together with <code>?a</code>?</z><z id="t1487284893000367" t="wparker I wouldn’t expect that to happen, but I can see the behavior you describe when I drop your example in a REPL"><y>#</y><d>2017-02-16</d><h>22:41</h><w>wparker</w>I wouldn’t expect that to happen, but I can see the behavior you describe when I drop your example in a REPL</z><z id="t1487285046000368" t="wparker It is a weird case in that you’d normally expect the bindings to come off the actual fact in some way, but it still seems like incorrect behavior at first glance, probably merits a GitHub issue"><y>#</y><d>2017-02-16</d><h>22:44</h><w>wparker</w>It is a weird case in that you’d normally expect the bindings to come off the actual fact in some way, but it still seems like incorrect behavior at first glance, probably merits a GitHub issue</z><z id="t1487285104000369" t="wparker @jarrodctaylor"><y>#</y><d>2017-02-16</d><h>22:45</h><w>wparker</w>@jarrodctaylor</z><z id="t1487285553000370" t="jarrodctaylor I was experiencing the behavior with a more traditional rule in my application. This above was as too the point of an example to demonstrate it as possible. I will open a issue on GitHub. "><y>#</y><d>2017-02-16</d><h>22:52</h><w>jarrodctaylor</w>I was experiencing the behavior with a more traditional rule in my application. This above was as too the point of an example to demonstrate it as possible. I will open a issue on GitHub. </z><z id="t1487285567000371" t="zylox i know ive had issues when i try to refer to a binding in the same condition (might be the wrong term) where it was bound."><y>#</y><d>2017-02-16</d><h>22:52</h><w>zylox</w>i know ive had issues when i try to refer to a binding in the same condition (might be the wrong term) where it was bound.</z><z id="t1487285584000372" t="zylox but if i used the raw field version it worked fine"><y>#</y><d>2017-02-16</d><h>22:53</h><w>zylox</w>but if i used the raw field version it worked fine</z><z id="t1487286633000373" t="wparker I suspect that the reason adding ?a causes ?b to be different is that if you have ?a in the constraint it will become a join with the previous fact, and if it is absent it is a condition on a single fact"><y>#</y><d>2017-02-16</d><h>23:10</h><w>wparker</w>I suspect that the reason adding ?a causes ?b to be different is that if you have ?a in the constraint it will become a join with the previous fact, and if it is absent it is a condition on a single fact</z><z id="t1487286656000374" t="wparker Those are different paths in the compiler so one could have a bug the other doesn&apos;t"><y>#</y><d>2017-02-16</d><h>23:10</h><w>wparker</w>Those are different paths in the compiler so one could have a bug the other doesn&apos;t</z><z id="t1487286697000375" t="wparker Doing a quick test like"><y>#</y><d>2017-02-16</d><h>23:11</h><w>wparker</w>Doing a quick test like</z><z id="t1487286702000376" t="wparker ` (rule/defrule wat [1 (= ?a &quot;a&quot;)] [1 (= ?b &quot;b&quot;) (and (nil? (println ?a)) (nil? (println ?b))) ] =&gt; nil) `"><y>#</y><d>2017-02-16</d><h>23:11</h><w>wparker</w><pre>` (rule/defrule wat
  [1 (= ?a &quot;a&quot;)]
  [1 (= ?b &quot;b&quot;)
   (and (nil? (println ?a))
         (nil? (println ?b))) 
   ] =&gt; nil) </pre>`</z><z id="t1487286719000377" t="wparker makes b be nil as well"><y>#</y><d>2017-02-16</d><h>23:11</h><w>wparker</w>makes b be nil as well</z><z id="t1487286738000378" t="wparker with ?a and ?b in the same constraint"><y>#</y><d>2017-02-16</d><h>23:12</h><w>wparker</w>with ?a and ?b in the same constraint</z><z id="t1487286774000379" t="wparker @zylox : a “condition” contains constraints, that is you can have a condition like [FactType constraint1 constraint2]"><y>#</y><d>2017-02-16</d><h>23:12</h><w>wparker</w>@zylox : a “condition” contains constraints, that is you can have a condition like [FactType constraint1 constraint2]</z><z id="t1488079310000382" t="mikerod https://leanpub.com/readevalprintlove004/read I don&apos;t recall if this was shared in this channel yet. It is an interesting read on rules engines by Fogus. I particularly like the simplified implementation of a (naive and simplistic) rules system. The &quot;fruit fly&quot; system. Hah. It does shed some light on some ideas at a high level. There is a little mention of Clara in the end &quot;credits&quot; too. So there is that. 😜 "><y>#</y><d>2017-02-26</d><h>03:21</h><w>mikerod</w><a href="https://leanpub.com/readevalprintlove004/read" target="_blank">https://leanpub.com/readevalprintlove004/read</a>
I don&apos;t recall if this was shared in this channel yet. It is an interesting read on rules engines by Fogus.
 I particularly like the simplified implementation of a (naive and simplistic) rules system. The &quot;fruit fly&quot; system. Hah. It does shed some light on some ideas at a high level. There is a little mention of Clara in the end &quot;credits&quot; too. So there is that. <b>😜</b> </z><z id="t1488452228000389" t="newres I have a question about using guards on rules in Clara. I am aiming to create rules that can never insert a fact that already exist. The guard statement works fine if I am manually inserting the fact that the guard stops, but if the rule itself is creating this statement the guard does not stop the rule from triggering again and I get an infinite loop."><y>#</y><d>2017-03-02</d><h>10:57</h><w>newres</w>I have a question about using guards on rules in Clara. I am aiming to create rules that can never insert a fact that already exist. The guard statement works fine if I am manually inserting the fact that the guard stops, but if the rule itself is creating this statement the guard does not stop the rule from triggering again and I get an infinite loop.</z><z id="t1488470706000390" t="zylox ya thats a tricky one ive dealt with too. i&apos;m not sure what the solution is either."><y>#</y><d>2017-03-02</d><h>16:05</h><w>zylox</w>ya thats a tricky one ive dealt with too. i&apos;m not sure what the solution is either.</z><z id="t1488471566000391" t="newres with a naive implementation of rules where each rule is checked separately I can see this not being an issue as after each insertion the guard would be checked and with the new fact that guard would be passed. Could this be a bug in the implementation, where somehow not the full condition of the rule is checked for it to fire again?"><y>#</y><d>2017-03-02</d><h>16:19</h><w>newres</w>with a naive implementation of rules where each rule is checked separately I can see this not being an issue as after each insertion the guard would be checked and with the new fact that guard would be passed. Could this be a bug in the implementation, where somehow not the full condition of the rule is checked for it to fire again?</z><z id="t1488472461000392" t="zylox maybe i didnt understand what you meant by gaurds, but if a rule inserts something that that same rule looks at, its pretty much always going to cause another firing"><y>#</y><d>2017-03-02</d><h>16:34</h><w>zylox</w>maybe i didnt understand what you meant by gaurds, but if a rule inserts something that that same rule looks at, its pretty much always going to cause another firing</z><z id="t1488472473000393" t="zylox is my understanding"><y>#</y><d>2017-03-02</d><h>16:34</h><w>zylox</w>is my understanding</z><z id="t1488474988000394" t="newres I think i figured out the roof of the problem"><y>#</y><d>2017-03-02</d><h>17:16</h><w>newres</w>I think i figured out the roof of the problem</z><z id="t1488475006000395" t="newres I compeltely glanced over the fact that clara does truth maintenance"><y>#</y><d>2017-03-02</d><h>17:16</h><w>newres</w>I compeltely glanced over the fact that clara does truth maintenance</z><z id="t1488475085000396" t="newres this means if the result of the rule puts in the guard of the rule the fact loses support gets retracted and the rule fires again"><y>#</y><d>2017-03-02</d><h>17:18</h><w>newres</w>this means if the result of the rule puts in the guard of the rule the fact loses support gets retracted and the rule fires again</z><z id="t1488475134000397" t="wparker Sounds correct, looking through https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/truth_maintenance.clj and http://www.clara-rules.org/docs/truthmaint/ might be helpful 🙂"><y>#</y><d>2017-03-02</d><h>17:18</h><w>wparker</w>Sounds correct, looking through <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/truth_maintenance.clj" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/truth_maintenance.clj</a> and <a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a> might be helpful <b>🙂</b></z><z id="t1488475137000399" t="zylox truestory"><y>#</y><d>2017-03-02</d><h>17:18</h><w>zylox</w><b>truestory</b></z><z id="t1488475158000400" t="newres I feel very dense about this"><y>#</y><d>2017-03-02</d><h>17:19</h><w>newres</w>I feel very dense about this</z><z id="t1488475205000401" t="wparker You can use unconditional insertions that won’t use truth maintenance if necessary. In our use cases we strongly prefer truth maintenance and find that it makes the code simpler to reason about, but obviously use-cases differ"><y>#</y><d>2017-03-02</d><h>17:20</h><w>wparker</w>You can use unconditional insertions that won’t use truth maintenance if necessary.  In our use cases we strongly prefer truth maintenance and find that it makes the code simpler to reason about, but obviously use-cases differ</z><z id="t1488475220000402" t="newres i was staring at this like a whole evening thinking what the problem could be, whoops."><y>#</y><d>2017-03-02</d><h>17:20</h><w>newres</w>i was staring at this like a whole evening thinking what the problem  could be, whoops.</z><z id="t1488475223000403" t="wparker It is a common point of confusion 🙂"><y>#</y><d>2017-03-02</d><h>17:20</h><w>wparker</w>It is a common point of confusion <b>🙂</b></z><z id="t1488475264000405" t="newres It kind of solves pretty much every problem I had with clara though, so that is a relief"><y>#</y><d>2017-03-02</d><h>17:21</h><w>newres</w>It kind of solves pretty much every problem I had with clara though, so that is a relief</z><z id="t1488475327000406" t="zylox so you are saying you were stuck in an infinite loop about the infinite loop and the truth about truth maintenence resolved it"><y>#</y><d>2017-03-02</d><h>17:22</h><w>zylox</w>so you are saying you were stuck in an infinite loop about the infinite loop and the truth about truth maintenence resolved it</z><z id="t1488475451000407" t="newres yeah basically using a guard with truth maintenance, where the result of the rule (or another) triggers the guard can start an infinite loop"><y>#</y><d>2017-03-02</d><h>17:24</h><w>newres</w>yeah basically using a guard with truth maintenance, where the result of the rule (or another) triggers the guard can start an infinite loop</z><z id="t1488475485000408" t="newres especially in the case where it is just a single rule that triggers the guard"><y>#</y><d>2017-03-02</d><h>17:24</h><w>newres</w>especially in the case where it is just a single rule that triggers the guard</z><z id="t1488475512000409" t="zylox (i was just making a light hearted joke about how your proccess of realizing how it was working was similar to a rules network) though your understanding sounds correct to me"><y>#</y><d>2017-03-02</d><h>17:25</h><w>zylox</w>(i was just making a light hearted joke about how your proccess of realizing how it was working was similar to a rules network) though your understanding sounds correct to me</z><z id="t1488475528000410" t="newres ah LOL"><y>#</y><d>2017-03-02</d><h>17:25</h><w>newres</w>ah LOL</z><z id="t1488475541000411" t="newres well like I said I feel dense today"><y>#</y><d>2017-03-02</d><h>17:25</h><w>newres</w>well like I said I feel dense today</z><z id="t1488484367000412" t="nrayapati http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html"><y>#</y><d>2017-03-02</d><h>19:52</h><w>nrayapati</w><a href="http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html" target="_blank">http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html</a></z><z id="t1488484444000414" t="nrayapati Overview of the talk @mikerod gave at the Clojure/conj 2016 conference."><y>#</y><d>2017-03-02</d><h>19:54</h><w>nrayapati</w>Overview of the talk @mikerod  gave at the Clojure/conj 2016 conference.</z><z id="t1488486677000416" t="mikerod Oh yes. Still cleaning up that site some. Going to change the theme since it sucks on mobile. However the content is there. "><y>#</y><d>2017-03-02</d><h>20:31</h><w>mikerod</w>Oh yes. Still cleaning up that site some. Going to change the theme since it sucks on mobile. However the content is there. </z><z id="t1488486789000417" t="zylox nope this is permanent now"><y>#</y><d>2017-03-02</d><h>20:33</h><w>zylox</w>nope this is permanent now</z><z id="t1488486803000418" t="zylox weve seen everything"><y>#</y><d>2017-03-02</d><h>20:33</h><w>zylox</w>weve seen everything</z><z id="t1488490861000419" t="ryanbrush @mikerod Okay, I&apos;ll resist the urge to tweet about it until you have the finishing touches in place. 😄"><y>#</y><d>2017-03-02</d><h>21:41</h><w>ryanbrush</w>@mikerod Okay, I&apos;ll resist the urge to tweet about it until you have the finishing touches in place. <b>😄</b></z><z id="t1488490957000420" t="mikerod Haha. Thanks. I&apos;ll fix it within a day or so. Out of town so I&apos;m a bit slow. "><y>#</y><d>2017-03-02</d><h>21:42</h><w>mikerod</w>Haha. Thanks. I&apos;ll fix it within a day or so. Out of town so I&apos;m a bit slow. </z><z id="t1488571240000423" t="mikerod @ryanbrush FYI I changed the visual theme to something that is reasonable on mobile and desktop. So I&apos;d consider the Clara blog good to go at this point. "><y>#</y><d>2017-03-03</d><h>20:00</h><w>mikerod</w>@ryanbrush FYI I changed the visual theme to something that is reasonable on mobile and desktop. So I&apos;d consider the Clara blog good to go at this point. </z><z id="t1488572235000424" t="ryanbrush @mikerod Looks great, and nice post!"><y>#</y><d>2017-03-03</d><h>20:17</h><w>ryanbrush</w>@mikerod Looks great, and nice post!</z><z id="t1488573625000425" t="mikerod Thanks!"><y>#</y><d>2017-03-03</d><h>20:40</h><w>mikerod</w>Thanks!</z><z id="t1490201675400212" t="wparker Version 0.14.0 of clara-rules is released. I posted at https://groups.google.com/forum/#!topic/clara-rules/UscQQgDtN-Y with a description of the changes relative to 0.13.0 (the previous version)."><y>#</y><d>2017-03-22</d><h>16:54</h><w>wparker</w>Version 0.14.0 of clara-rules is released.  I posted at <a href="https://groups.google.com/forum/#!topic/clara-rules/UscQQgDtN-Y" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/UscQQgDtN-Y</a> with a description of the changes relative to 0.13.0 (the previous version).</z><z id="t1492037426168960" t="souenzzo Hi. How to make an &quot;or&quot; in &quot;match&quot; part of rule. Example: ;; There is 2 types: groups and items ;; Example: ;; :group [1 false 2] ;; :group [1 false 3] ;; :item [2 true] ;; :item [3 false] ;; :group [4 true 5] ;; :item [5 false] ;; Group &apos;1&apos; contains items &apos;2&apos; and &apos;3&apos; ;; Group &apos;4&apos; contains item &apos;5&apos; ;; My `select` query shoud find [[4][1]] ;; because they are groups and they are selected ;; or contains a selected item (defrule selected-groups ;; Or this [:group [[id selected _]] (= ?id group) (= selected true)] ;; Or this [:group [[id _ item-id]] (= ?id id) (= item-id ?item-id)] [:item [[item-id selected]] (= ?item-id item-id) (= selected true)] =&gt; (insert! ^{:type :select} [?id])) (sorry for big example) (yes, I know how to do it with 2 rules.) (I dont care with duplicate entries)"><y>#</y><d>2017-04-12</d><h>22:50</h><w>souenzzo</w>Hi. How to make an &quot;or&quot; in &quot;match&quot; part of rule.
Example:
<pre>;; There is 2 types: groups and items
;; Example:
;; :group [1 false 2]
;; :group [1 false 3]
;; :item [2 true]
;; :item [3 false]
;; :group [4 true 5]
;; :item [5 false]
;; Group &apos;1&apos; contains items &apos;2&apos; and &apos;3&apos;
;; Group &apos;4&apos; contains item &apos;5&apos;
;; My `select` query shoud find [[4][1]]
;; because they are groups and they are selected
;; or contains a selected item
(defrule selected-groups
         ;; Or this
         [:group [[id selected _]] (= ?id group) (= selected true)]

         ;; Or this
         [:group [[id _ item-id]] (= ?id id) (= item-id ?item-id)]
         [:item [[item-id selected]] (= ?item-id item-id) (= selected true)]
         =&gt;
         (insert! ^{:type :select} [?id]))
</pre>
(sorry for big example)
(yes, I know how to do it with 2 rules.)
(I dont care with duplicate entries)</z><z id="t1492122559657482" t="wparker @souenzzo Would something like [:or [:group …] [:and {:group ..] [:item]] meet your needs? There are some docs at http://www.clara-rules.org/docs/booleans"><y>#</y><d>2017-04-13</d><h>22:29</h><w>wparker</w>@souenzzo Would something like [:or [:group …] [:and {:group ..] [:item]] meet your needs?  There are some docs at <a href="http://www.clara-rules.org/docs/booleans" target="_blank">http://www.clara-rules.org/docs/booleans</a></z><z id="t1492651690426654" t="devn @wparker thanks for session-&gt;fact-graph"><y>#</y><d>2017-04-20</d><h>01:28</h><w>devn</w>@wparker thanks for session-&gt;fact-graph</z><z id="t1492651703428374" t="devn i&apos;m pretty excited about that change"><y>#</y><d>2017-04-20</d><h>01:28</h><w>devn</w>i&apos;m pretty excited about that change</z><z id="t1492697945931464" t="zylox same"><y>#</y><d>2017-04-20</d><h>14:19</h><w>zylox</w>same</z><z id="t1492701546396461" t="alex-dixon Haven&apos;t made time to try it yet 😕"><y>#</y><d>2017-04-20</d><h>15:19</h><w>alex-dixon</w>Haven&apos;t made time to try it yet <b>😕</b></z><z id="t1492702786908674" t="mac @devn I musty be missing something, which commit contains session-&gt;fact-graph ?"><y>#</y><d>2017-04-20</d><h>15:39</h><w>mac</w>@devn I musty be missing something, which commit contains <pre>session-&gt;fact-graph</pre> ?</z><z id="t1492705377920078" t="wparker @mac it isn’t in master yet. https://github.com/cerner/clara-rules/pull/283"><y>#</y><d>2017-04-20</d><h>16:22</h><w>wparker</w>@mac it isn’t in master yet. <a href="https://github.com/cerner/clara-rules/pull/283" target="_blank">https://github.com/cerner/clara-rules/pull/283</a></z><z id="t1492705418934996" t="mac @wparker Ah, got it. Thanks."><y>#</y><d>2017-04-20</d><h>16:23</h><w>mac</w>@wparker Ah, got it. Thanks.</z><z id="t1492705582993997" t="wparker glad to hear it could be useful for others as well. I’d be interested to hear about experiences with it or any tools, visualizations, etc. anyone comes up with and wants to share"><y>#</y><d>2017-04-20</d><h>16:26</h><w>wparker</w>glad to hear it could be useful for others as well.  I’d be interested to hear about experiences with it or any tools, visualizations, etc. anyone comes up with and wants to share</z><z id="t1492705730048922" t="wparker for the use-case I had in mind I’ll probably be looking at ways to show particular parts of the graph since the session is so large that showing the entire graph would be an information overload"><y>#</y><d>2017-04-20</d><h>16:28</h><w>wparker</w>for the use-case I had in mind I’ll probably be looking at ways to show particular parts of the graph since the session is so large that showing the entire graph would be an information overload</z><z id="t1492804555406206" t="devn @wparker we built something hackish to build graphviz, and for the entire session the graph was way too big to be useful"><y>#</y><d>2017-04-21</d><h>19:55</h><w>devn</w>@wparker we built something hackish to build graphviz, and for the entire session the graph was way too big to be useful</z><z id="t1492804580412950" t="devn then there was an attempt at using cytoscape.js to make it traversable"><y>#</y><d>2017-04-21</d><h>19:56</h><w>devn</w>then there was an attempt at using cytoscape.js to make it traversable</z><z id="t1492804586414862" t="devn so you could see a few nodes away from YOU ARE HERE"><y>#</y><d>2017-04-21</d><h>19:56</h><w>devn</w>so you could see a few nodes away from YOU ARE HERE</z><z id="t1492804658435427" t="devn what i found myself wanting was a way to define views over the graph, like, i may not care about all the edges and nodes between Node A and Node B, so I&apos;d like to define a view that shows me Node A -&gt; Node B without all of the intermediate steps"><y>#</y><d>2017-04-21</d><h>19:57</h><w>devn</w>what i found myself wanting was a way to define views over the graph, like, i may not care about all the edges and nodes between Node A and Node B, so I&apos;d like to define a view that shows me Node A -&gt; Node B without all of the intermediate steps</z><z id="t1492804813480866" t="devn I imagine having something like: (def views {:everything [FactA FactB ...], :simple [FactA FactC FactF]})"><y>#</y><d>2017-04-21</d><h>20:00</h><w>devn</w>I imagine having something like:

<code>(def views {:everything [FactA FactB ...], :simple [FactA FactC FactF]})</code></z><z id="t1492804874499666" t="devn :simple automatically collapses nodes and edges along the path of A-&gt;C-&gt;F"><y>#</y><d>2017-04-21</d><h>20:01</h><w>devn</w><code>:simple</code> automatically collapses nodes and edges along the path of A-&gt;C-&gt;F</z><z id="t1492804958525590" t="devn @wparker another thing that I think would be nice would be to generate a static graph"><y>#</y><d>2017-04-21</d><h>20:02</h><w>devn</w>@wparker another thing that I think would be nice would be to generate a static graph</z><z id="t1492805013541401" t="devn of all the facts in the project, regardless of whether they are ever used"><y>#</y><d>2017-04-21</d><h>20:03</h><w>devn</w>of all the facts in the project, regardless of whether they are ever used</z><z id="t1492805054552652" t="devn but maybe your PR achieves this?"><y>#</y><d>2017-04-21</d><h>20:04</h><w>devn</w>but maybe your PR achieves this?</z><z id="t1492805111569034" t="devn what we built relied on the data returned from inspect, which IIRC required us to fire-rules"><y>#</y><d>2017-04-21</d><h>20:05</h><w>devn</w>what we built relied on the data returned from inspect, which IIRC required us to fire-rules</z><z id="t1492805167585402" t="devn im interested in building the graph of all the relationships, not just the relationships that survive after running the rules"><y>#</y><d>2017-04-21</d><h>20:06</h><w>devn</w>im interested in building the graph of all the relationships, not just the relationships that survive after running the rules</z><z id="t1492805273614810" t="wparker The graph would include all logical insertions regardless of whether they were used for anything, but unconditional/external insertions wouldn’t be if they weren’t used for anything"><y>#</y><d>2017-04-21</d><h>20:07</h><w>wparker</w>The graph would include all logical insertions regardless of whether they were used for anything, but unconditional/external insertions wouldn’t be if they weren’t used for anything</z><z id="t1492805295620480" t="wparker Since Clara allows them to be garbage-collected if they aren’t used"><y>#</y><d>2017-04-21</d><h>20:08</h><w>wparker</w>Since Clara allows them to be garbage-collected if they aren’t used</z><z id="t1492805400649392" t="wparker My general line of thinking here was to build a graph, and then"><y>#</y><d>2017-04-21</d><h>20:10</h><w>wparker</w>My general line of thinking here was to build a graph, and then</z><z id="t1492805443661344" t="wparker provide functions to retrieve particular subsets of the graph, potentially modify it, etc."><y>#</y><d>2017-04-21</d><h>20:10</h><w>wparker</w>provide functions to retrieve particular subsets of the graph, potentially modify it, etc.</z><z id="t1492805503677564" t="wparker and then look at how to display those views. Basically have a data-oriented approach to the problem that different views could layer on top of"><y>#</y><d>2017-04-21</d><h>20:11</h><w>wparker</w>and then look at how to display those views.  Basically have a data-oriented approach to the problem that different views could layer on top of</z><z id="t1492805509679157" t="zylox you can always reduce the data in a graph, thats the wonder of them"><y>#</y><d>2017-04-21</d><h>20:11</h><w>zylox</w>you can always reduce the data in a graph, thats the wonder of them</z><z id="t1492805549690414" t="wparker In particular, in our case we’d probably want to combine fact graphs with some other indicators that our specific to our internal frameworks"><y>#</y><d>2017-04-21</d><h>20:12</h><w>wparker</w>In particular, in our case we’d probably want to combine fact graphs with some other indicators that our specific to our internal frameworks</z><z id="t1492805570696145" t="wparker so I’m looking for composability"><y>#</y><d>2017-04-21</d><h>20:12</h><w>wparker</w>so I’m looking for composability</z><z id="t1492805635713273" t="wparker I’m not clear on what :simple would be - do you mean that if you had A -&gt; B -&gt; C you’d have a direct edge of A -&gt; C?"><y>#</y><d>2017-04-21</d><h>20:13</h><w>wparker</w>I’m not clear on what :simple would be - do you mean that if you had A -&gt; B -&gt; C you’d have a direct edge of A -&gt; C?</z><z id="t1492805756747200" t="wparker Also, @devn I’d be curious about why cytoscape.js versus any other graph visualization options you tried or considered - the visualization layer isn’t something I know much about yet"><y>#</y><d>2017-04-21</d><h>20:15</h><w>wparker</w>Also, @devn I’d be curious about why cytoscape.js versus any other graph visualization options you tried or considered - the visualization layer isn’t something I know much about yet</z><z id="t1492808765562869" t="devn @wparker I did not directly participate in the decision to use cytoscape, but as I recall it was chosen partly for performance, and partly because it made the traversal of subgraphs relatively easy."><y>#</y><d>2017-04-21</d><h>21:06</h><w>devn</w>@wparker I did not directly participate in the decision to use cytoscape, but as I recall it was chosen partly for performance, and partly because it made the traversal of subgraphs relatively easy.</z><z id="t1492808792569659" t="devn @wparker RE: direct edge on A-&gt;C, yes, that was what I was thinking"><y>#</y><d>2017-04-21</d><h>21:06</h><w>devn</w>@wparker RE: direct edge on A-&gt;C, yes, that was what I was thinking</z><z id="t1492808847583551" t="devn or perhaps you have A-&gt;[summary collection of intermediate nodes]-&gt;C"><y>#</y><d>2017-04-21</d><h>21:07</h><w>devn</w>or perhaps you have A-&gt;[summary collection of intermediate nodes]-&gt;C</z><z id="t1492808934604736" t="devn basically anything to make it easy to skip the display of 382910 nodes and edges that don&apos;t actually tell you much that you care to know about getting from A to C"><y>#</y><d>2017-04-21</d><h>21:08</h><w>devn</w>basically anything to make it easy to skip the display of 382910 nodes and edges that don&apos;t actually tell you much that you care to know about getting from A to C</z><z id="t1492808977615147" t="devn i think it&apos;s often the case that the fact that you got to C suggests everything you&apos;d need to understand about B"><y>#</y><d>2017-04-21</d><h>21:09</h><w>devn</w>i think it&apos;s often the case that the fact that you got to C suggests everything you&apos;d need to understand about B</z><z id="t1492809274685939" t="devn for instance, there is a big fan out and fan in between A and C, like A-&gt;[B1, B2, B3, B4, B5, BN]-&gt;C If C is a specific fact like: MoreThanThreeBs, then who really cares what those Bs were? all I really care about is that by virtue of A, I have the possibility of many Bs, and all I care to know is if I get to state C from A"><y>#</y><d>2017-04-21</d><h>21:14</h><w>devn</w>for instance, there is a big fan out and fan in between A and C, like A-&gt;[B1, B2, B3, B4, B5, BN]-&gt;C

If C is a specific fact like: MoreThanThreeBs, then who really cares what those Bs were? all I really care about is that by virtue of A, I have the possibility of many Bs, and all I care to know is if I get to state C from A</z><z id="t1492809715788008" t="devn We have a lot of scenarios where we need to look at hundreds of thousands of facts on our way to a state, but in the end all we really care about is that given a Lab, we determine whether it is normal or abnormal according to a massive set of facts, and then produce an AbnormalLabResult or NormalLabResult. Labl-&gt;AbnormalLab/NormalLab is how I&apos;d prefer to view it in a UI rather than render the 500k+ nodes and corresponding edges in between"><y>#</y><d>2017-04-21</d><h>21:21</h><w>devn</w>We have a lot of scenarios where we need to look at hundreds of thousands of facts on our way to a state, but in the end all we really care about is that given a Lab, we determine whether it is normal or abnormal according to a massive set of facts, and then produce an AbnormalLabResult or NormalLabResult. Labl-&gt;AbnormalLab/NormalLab is how I&apos;d prefer to view it in a UI rather than render the 500k+ nodes and corresponding edges in between</z><z id="t1492809879824695" t="devn being able to express something like: &quot;Provided #{A}, render direct edges to #{C, D} through nodes of type #{B}&quot; would be nice"><y>#</y><d>2017-04-21</d><h>21:24</h><w>devn</w>being able to express something like: &quot;Provided #{A}, render direct edges to #{C, D} through nodes of type #{B}&quot; would be nice</z><z id="t1492810063864953" t="devn Stop me if what I&apos;m saying doesn&apos;t make any sense"><y>#</y><d>2017-04-21</d><h>21:27</h><w>devn</w>Stop me if what I&apos;m saying doesn&apos;t make any sense</z><z id="t1492810160886416" t="devn I suppose I imagine that for any collection of rules and facts, there are layers to the view. For instance, I don&apos;t care about seeing the source of a rule by default, that&apos;s another layer. Similarly, I don&apos;t care which specific constraints in that rule were met, unless I do."><y>#</y><d>2017-04-21</d><h>21:29</h><w>devn</w>I suppose I imagine that for any collection of rules and facts, there are layers to the view. For instance, I don&apos;t care about seeing the source of a rule by default, that&apos;s another layer. Similarly, I don&apos;t care which specific constraints in that rule were met, unless I do.</z><z id="t1492810212897765" t="wparker I can see where that would be useful for some rules patterns, yes. I’m thinking that it probably wouldn’t be too hard to transform the graph down to that level though?"><y>#</y><d>2017-04-21</d><h>21:30</h><w>wparker</w>I can see where that would be useful for some rules patterns, yes.  I’m thinking that it probably wouldn’t be too hard to transform the graph down to that level though?</z><z id="t1492810229901814" t="devn @wparker no, sure, that&apos;s doable"><y>#</y><d>2017-04-21</d><h>21:30</h><w>devn</w>@wparker no, sure, that&apos;s doable</z><z id="t1492810251906682" t="devn I&apos;m just listing stuff that I don&apos;t think would be totally out of bounds for clara.tools.*"><y>#</y><d>2017-04-21</d><h>21:30</h><w>devn</w>I&apos;m just listing stuff that I don&apos;t think would be totally out of bounds for clara.tools.*</z><z id="t1492810261908826" t="wparker Ah, I see"><y>#</y><d>2017-04-21</d><h>21:31</h><w>wparker</w>Ah, I see</z><z id="t1492810314920405" t="wparker By the way, I think having transformation functions in the fact-graph namespace could be useful, I just haven’t gotten to that point yet"><y>#</y><d>2017-04-21</d><h>21:31</h><w>wparker</w>By the way, I think having transformation functions in the fact-graph namespace could be useful, I just haven’t gotten to that point yet</z><z id="t1492810335925058" t="devn I totally understand for instance, that if you have the raw data, you can do whatever you please, but it would be really nice to not leave that as an exercise for the reader, and instead have a couple of basic built-in tools for specifying what you want to look at"><y>#</y><d>2017-04-21</d><h>21:32</h><w>devn</w>I totally understand for instance, that if you have the raw data, you can do whatever you please, but it would be really nice to not leave that as an exercise for the reader, and instead have a couple of basic built-in tools for specifying what you want to look at</z><z id="t1492810344927150" t="wparker or other namespace as appropriate as you say “clara.tools.*”"><y>#</y><d>2017-04-21</d><h>21:32</h><w>wparker</w>or other namespace as appropriate as you say “clara.tools.*”</z><z id="t1492810411942110" t="devn Like, a function which dumps graphviz, even if there is no dependency within clara to actually render it, seems like it might be useful"><y>#</y><d>2017-04-21</d><h>21:33</h><w>devn</w>Like, a function which dumps graphviz, even if there is no dependency within clara to actually render it, seems like it might be useful</z><z id="t1492810482957199" t="devn and then adding on to that: Dumps graphviz where you specify the starting node (the type of fact), and how many hops should be rendered"><y>#</y><d>2017-04-21</d><h>21:34</h><w>devn</w>and then adding on to that: Dumps graphviz where you specify the starting node (the type of fact), and how many hops should be rendered</z><z id="t1492810522965515" t="devn or: Dumps graphviz, and lets you set the color for nodes based on their fact type"><y>#</y><d>2017-04-21</d><h>21:35</h><w>devn</w>or: Dumps graphviz, and lets you set the color for nodes based on their fact type</z><z id="t1492810524966057" t="devn etc."><y>#</y><d>2017-04-21</d><h>21:35</h><w>devn</w>etc.</z><z id="t1492810536968643" t="wparker For that, I’m thinking you’d do something like (-&gt; original-graph remove-intermediate-steps render-to-graphviz)"><y>#</y><d>2017-04-21</d><h>21:35</h><w>wparker</w>For that, I’m thinking you’d do something like (-&gt; original-graph remove-intermediate-steps render-to-graphviz)</z><z id="t1492810572975974" t="devn sure, yeah"><y>#</y><d>2017-04-21</d><h>21:36</h><w>devn</w>sure, yeah</z><z id="t1492810688000242" t="devn It would be interesting to generate some anonymized graphs for all of our projects just to get a sense for what transformation functions would be generally useful"><y>#</y><d>2017-04-21</d><h>21:38</h><w>devn</w>It would be interesting to generate some anonymized graphs for all of our projects just to get a sense for what transformation functions would be generally useful</z><z id="t1492810808025647" t="devn I know there are Reasons™ to not include the transformation kitchen sink or unnecessary deps, but I feel like a simple toolkit for rules engine graph generation would be super helpful to have, maybe even as part of core"><y>#</y><d>2017-04-21</d><h>21:40</h><w>devn</w>I know there are Reasons™ to not include the transformation kitchen sink or unnecessary deps, but I feel like a simple toolkit for rules engine graph generation would be super helpful to have, maybe even as part of core</z><z id="t1492810860036711" t="devn as opposed to an external lib"><y>#</y><d>2017-04-21</d><h>21:41</h><w>devn</w>as opposed to an external lib</z><z id="t1492811566178907" t="wparker Yeah, there is often a tradeoff of not tying things together too much versus not providing enough functionality especially if you get into needing other libraries as dependencies. Adding generic data transforms doesn’t seem like it adds too much burden though since it is very easily ignorable if you don’t need them"><y>#</y><d>2017-04-21</d><h>21:52</h><w>wparker</w>Yeah, there is often a tradeoff of not tying things together too much versus not providing enough functionality especially if you get into needing other libraries as dependencies.  Adding generic data transforms doesn’t seem like it adds too much burden though since it is very easily ignorable if you don’t need them</z><z id="t1492811740212703" t="wparker I’m guessing the types of transforms needed will depend heavily on the domain. For example, in our case, I think a lot of it would revolve around taking a given fact and showing everything either upstream or downstream from that fact, and potentially “backtracking” a bit from some joins on that path, but not the rest of the rules session"><y>#</y><d>2017-04-21</d><h>21:55</h><w>wparker</w>I’m guessing the types of transforms needed will depend heavily on the domain.  For example, in our case, I think a lot of it would revolve around taking a given fact and showing everything either upstream or downstream from that fact, and potentially “backtracking” a bit from some joins on that path, but not the rest of the rules session</z><z id="t1492811821228564" t="wparker If you have a fact A that flows through rules B-&gt;C-&gt;D-&gt;E-&gt;F and you don’t get the expected F it would be nice to be able to easily see where it “stopped”"><y>#</y><d>2017-04-21</d><h>21:57</h><w>wparker</w>If you have a fact A that flows through rules B-&gt;C-&gt;D-&gt;E-&gt;F and you don’t get the expected F it would be nice to be able to easily see where it “stopped”</z><z id="t1492811862236886" t="wparker or in the case of accumulation how it interacted with other facts in that chain"><y>#</y><d>2017-04-21</d><h>21:57</h><w>wparker</w>or in the case of accumulation how it interacted with other facts in that chain</z><z id="t1492812180299073" t="wparker The first step is to make the full data set available for manipulation though"><y>#</y><d>2017-04-21</d><h>22:03</h><w>wparker</w>The first step is to make the full data set available for manipulation though</z><z id="t1492812205303751" t="wparker You could get most of it from inspect already but not when you go through accumulators"><y>#</y><d>2017-04-21</d><h>22:03</h><w>wparker</w>You could get most of it from inspect already but not when you go through accumulators</z><z id="t1492812217305809" t="wparker which we use a lot of"><y>#</y><d>2017-04-21</d><h>22:03</h><w>wparker</w>which we use a lot of</z><z id="t1493368597644444" t="puzzler How does the performance of Clara queries compare to something like Datascript?"><y>#</y><d>2017-04-28</d><h>08:36</h><w>puzzler</w>How does the performance of Clara queries compare to something like Datascript?</z><z id="t1493652784680755" t="enn Can anyone suggest how I might instrument my rules to figure out which one is throwing an NPE? The NPE is during &gt; during an accumulator’s reduction which makes me assume it’s the max accumulator, which I use in only a handful of rules. I’d like to narrow down which specifically is throwing the exception, but I’m not sure how I’d go about putting logging in the LHS of a rule. (The RHS is too late as the accumulators are used only in LHSs.)"><y>#</y><d>2017-05-01</d><h>15:33</h><w>enn</w>Can anyone suggest how I might instrument my rules to figure out which one is throwing an NPE?

The NPE is during <code>&gt;</code> during an accumulator’s reduction which makes me assume it’s the <code>max</code> accumulator, which I use in only a handful of rules. I’d like to narrow down which specifically is throwing the exception, but I’m not sure how I’d go about putting logging in the LHS of a rule. (The RHS is too late as the accumulators are used only in LHSs.)</z><z id="t1493655187363575" t="zylox do you have an example stack trace?"><y>#</y><d>2017-05-01</d><h>16:13</h><w>zylox</w>do you have an example stack trace?</z><z id="t1493655433431449" t="enn yes:"><y>#</y><d>2017-05-01</d><h>16:17</h><w>enn</w>yes:</z><z id="t1493655545461092" t="enn @zylox http://paste.lisp.org/display/345606"><y>#</y><d>2017-05-01</d><h>16:19</h><w>enn</w>@zylox <a href="http://paste.lisp.org/display/345606" target="_blank">http://paste.lisp.org/display/345606</a></z><z id="t1493657224928723" t="zylox ya i got nothing unfortunately. https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj might be of some help"><y>#</y><d>2017-05-01</d><h>16:47</h><w>zylox</w>ya i got nothing unfortunately. <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.clj</a> might be of some help</z><z id="t1493659734669994" t="wparker @enn unfortunately errors during accumulation aren’t handled as well as errors in non-accumulator conditions; https://github.com/cerner/clara-rules/issues/265 is logged to improve that (non-accumulator conditions were improved in https://github.com/cerner/clara-rules/issues/255 )"><y>#</y><d>2017-05-01</d><h>17:28</h><w>wparker</w>@enn unfortunately errors during accumulation aren’t handled as well as errors in non-accumulator conditions; <a href="https://github.com/cerner/clara-rules/issues/265" target="_blank">https://github.com/cerner/clara-rules/issues/265</a> is logged to improve that (non-accumulator conditions were improved in <a href="https://github.com/cerner/clara-rules/issues/255" target="_blank">https://github.com/cerner/clara-rules/issues/255</a> )</z><z id="t1493659788686924" t="wparker In the meantime your best option is probably to wrap the accumulator in question in a way that indicates what rules you’re in when it throw an exception"><y>#</y><d>2017-05-01</d><h>17:29</h><w>wparker</w>In the meantime your best option is probably to wrap the accumulator in question in a way that indicates what rules you’re in when it throw an exception</z><z id="t1493659845704991" t="wparker Clara accumulators are just maps containing functions, and the accumulator can be modified by adding a new value onto one of the keys"><y>#</y><d>2017-05-01</d><h>17:30</h><w>wparker</w>Clara accumulators are just maps containing functions, and the accumulator can be modified by adding a new value onto one of the keys</z><z id="t1493659863710823" t="wparker Your stacktrace tells me you’re throwing in the reduce-fn"><y>#</y><d>2017-05-01</d><h>17:31</h><w>wparker</w>Your stacktrace tells me you’re throwing in the reduce-fn</z><z id="t1493659988749348" t="wparker So you could do something like (defn -&gt;wrapped-reduce-fn [original-reduce-fn rule-name] (fn [&amp; args] (try (apply original-reduce-fn args) (catch Exception e (throw (ex-info (str “Threw exception in accumulation in ” rule-name) {} e))))"><y>#</y><d>2017-05-01</d><h>17:33</h><w>wparker</w>So you could do something like (defn -&gt;wrapped-reduce-fn [original-reduce-fn rule-name] (fn [&amp; args] (try (apply original-reduce-fn args) (catch Exception e (throw (ex-info (str “Threw exception in accumulation in ” rule-name) {} e))))</z><z id="t1493660074775418" t="wparker and (defrule [?result-binding &lt;- (update (acc/min :field) :reduce-fn -&gt;wrapped-reduce-fn rule-name) …"><y>#</y><d>2017-05-01</d><h>17:34</h><w>wparker</w>and (defrule [?result-binding &lt;- (update (acc/min :field) :reduce-fn -&gt;wrapped-reduce-fn rule-name) …</z><z id="t1493660127791507" t="wparker actually to work with the update you’d need to reverse the args order of -&gt;wrapped-reduce-fn, but that is the basic idea"><y>#</y><d>2017-05-01</d><h>17:35</h><w>wparker</w>actually to work with the update you’d need to reverse the args order of -&gt;wrapped-reduce-fn, but that is the basic idea</z><z id="t1493660232823280" t="wparker The problem with tracing is that when you throw an exception and exit the rules firing loop you’ll lose the transient listener that has the info you want"><y>#</y><d>2017-05-01</d><h>17:37</h><w>wparker</w>The problem with tracing is that when you throw an exception and exit the rules firing loop you’ll lose the transient listener that has the info you want</z><z id="t1493660261831540" t="wparker When a RHS exception is thrown we call to-persistent on the listeners but that won’t happen in an exception during accumulation https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1787"><y>#</y><d>2017-05-01</d><h>17:37</h><w>wparker</w>When a RHS exception is thrown we call to-persistent on the listeners but that won’t happen in an exception during accumulation <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1787" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1787</a></z><z id="t1493660297843044" t="wparker You could write your own listener that had global side effects or some such to get around that if you wanted though"><y>#</y><d>2017-05-01</d><h>17:38</h><w>wparker</w>You could write your own listener that had global side effects or some such to get around that if you wanted though</z><z id="t1493660496904501" t="wparker There are some docs on what the different accum function fields do at http://www.clara-rules.org/docs/accumulators/ , you can also look at the structures created at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc"><y>#</y><d>2017-05-01</d><h>17:41</h><w>wparker</w>There are some docs on what the different accum function fields do at <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a>, you can also look at the structures created at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/accumulators.cljc</a></z><z id="t1493661017068622" t="enn Thank you, the wrapping idea makes sense"><y>#</y><d>2017-05-01</d><h>17:50</h><w>enn</w>Thank you, the wrapping idea makes sense</z><z id="t1493661129104985" t="enn though a little clunky as we are not specifying the reduce-fn directly (it’s created via acc/max and comparison-based )"><y>#</y><d>2017-05-01</d><h>17:52</h><w>enn</w>though a little clunky as we are not specifying the reduce-fn directly (it’s created via <code>acc/max</code> and <code>comparison-based</code>)</z><z id="t1493661796326021" t="wparker Yeah, it is clunky, but hopefully if you have just a handful of rules and a particular exception it won’t be too bad. Obviously not as nice as having built-in error handling i.e. issue 265 but hopefully solves your immediate need"><y>#</y><d>2017-05-01</d><h>18:03</h><w>wparker</w>Yeah, it is clunky, but hopefully if you have just a handful of rules and a particular exception it won’t be too bad.  Obviously not as nice as having built-in error handling i.e. issue 265 but hopefully solves your immediate need</z><z id="t1495136549516189" t="wparker Clara-rules 0.15.0 is released and available on Clojars. Highlights include a variety of improvements to session inspection, including functionality to create a graph data structure of facts to facts they caused to be logically inserted, and a fix to a memory leak that caused the memory to retain references to bindings from retracted facts in some cases."><y>#</y><d>2017-05-18</d><h>19:42</h><w>wparker</w>Clara-rules 0.15.0 is released and available on Clojars.  Highlights include a variety of improvements to session inspection, including functionality to create a graph data structure of facts to facts they caused to be logically inserted, and a fix to a memory leak that caused the memory to retain references to bindings from retracted facts in some cases.</z><z id="t1495136585526693" t="zylox 🎊"><y>#</y><d>2017-05-18</d><h>19:43</h><w>zylox</w><b>🎊</b></z><z id="t1495136811601833" t="wparker The changelog has further details on the changes: https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md"><y>#</y><d>2017-05-18</d><h>19:46</h><w>wparker</w>The changelog has further details on the changes: <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md</a></z><z id="t1495137532842240" t="ryanbrush Awesome, Will!"><y>#</y><d>2017-05-18</d><h>19:58</h><w>ryanbrush</w>Awesome, Will!</z><z id="t1495512297552482" t="devn @wparker thank you for all of your work."><y>#</y><d>2017-05-23</d><h>04:04</h><w>devn</w>@wparker thank you for all of your work.</z><z id="t1495512305553439" t="devn You&apos;ve made my job easier."><y>#</y><d>2017-05-23</d><h>04:05</h><w>devn</w>You&apos;ve made my job easier.</z><z id="t1495621962164393" t="nkabrich can anyone recommend a good tool/library to visualize the output of clara.tools.fact-graph/session-&gt;fact-graph ?"><y>#</y><d>2017-05-24</d><h>10:32</h><w>nkabrich</w>can anyone recommend a good tool/library to visualize the output of <code>clara.tools.fact-graph/session-&gt;fact-graph</code>?</z><z id="t1495630053905265" t="skuro rhizome?"><y>#</y><d>2017-05-24</d><h>12:47</h><w>skuro</w>rhizome?</z><z id="t1495630082912824" t="skuro https://github.com/ztellman/rhizome"><y>#</y><d>2017-05-24</d><h>12:48</h><w>skuro</w><a href="https://github.com/ztellman/rhizome" target="_blank">https://github.com/ztellman/rhizome</a></z><z id="t1495790307695996" t="puzzler Can someone point me to documentation about how to construct clara rules dynamically?"><y>#</y><d>2017-05-26</d><h>09:18</h><w>puzzler</w>Can someone point me to documentation about how to construct clara rules dynamically?</z><z id="t1495796525880947" t="nkabrich AFAIK defrule just generates a data structure so you can either build that by hand dynamically or check out clara.rules.dsl/parse-rule"><y>#</y><d>2017-05-26</d><h>11:02</h><w>nkabrich</w>AFAIK <code>defrule</code> just generates a data structure so you can either build that by hand dynamically or check out <code>clara.rules.dsl/parse-rule</code></z><z id="t1495807985499776" t="wparker @puzzler There are a number of examples of dynamic rule creation in https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj You can also just build the rule data structures yourself if that is more convenient for your use-case; see the schema at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/schema.clj#L62"><y>#</y><d>2017-05-26</d><h>14:13</h><w>wparker</w>@puzzler There are a number of examples of dynamic rule creation in <a href="https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj</a>  You can also just build the rule data structures yourself if that is more convenient for your use-case; see the schema at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/schema.clj#L62" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/schema.clj#L62</a></z><z id="t1495808194568288" t="wparker You’ll need to fully qualify reference in your LHS (left-hand side) code if you use that approach, although in the RHS code it will evaluated in the ns you give if you give one as noted in the comment on the schema; that would be good to do in the LHS too, it just hasn’t been implemented yet"><y>#</y><d>2017-05-26</d><h>14:16</h><w>wparker</w>You’ll need to fully qualify reference in your LHS (left-hand side) code if you use that approach, although in the RHS code it will evaluated in the ns you give if you give one as noted in the comment on the schema; that would be good to do in the LHS too, it just hasn’t been implemented yet</z><z id="t1495809613053548" t="ryanbrush There is also an example of generating rules from an external DSL on this blog post. Towards the bottom you&apos;ll see the Clojure data structure that defines the rules themselves. http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/"><y>#</y><d>2017-05-26</d><h>14:40</h><w>ryanbrush</w>There is also an example of generating rules from an external DSL on this blog post. Towards the bottom you&apos;ll see the Clojure data structure that defines the rules themselves. <a href="http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/" target="_blank">http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/</a></z><z id="t1495809669072974" t="ryanbrush But often just writing defrule for your rules, then looking at the data structure it creates can give you a good idea of what you need, as @nkabrich suggests."><y>#</y><d>2017-05-26</d><h>14:41</h><w>ryanbrush</w>But often just writing defrule for your rules, then looking at the data structure it creates can give you a good idea of what you need, as @nkabrich suggests.</z><z id="t1495911342805072" t="newres oh wow I was just about to ask about dynamic rule creation"><y>#</y><d>2017-05-27</d><h>18:55</h><w>newres</w>oh wow I was just about to ask about dynamic rule creation</z><z id="t1495911422809526" t="newres The issue I have would be that the list of conditions in the lhs (and some part of the rhs) would be based on the elements of a list that is bound with a condition"><y>#</y><d>2017-05-27</d><h>18:57</h><w>newres</w>The issue I have would be that the list of conditions in the lhs (and some part of the rhs) would be based on the elements of a list that is bound with a condition</z><z id="t1495911513814492" t="newres The problem is I can not seem to express it right with defrule nor the underlying code datastructure"><y>#</y><d>2017-05-27</d><h>18:58</h><w>newres</w>The problem is I can not seem to express it right with defrule nor the underlying code datastructure</z><z id="t1495911826834559" t="newres I might be stepping too much over what the rete network does so it might be slow, but if nothing else there should be a way to look into the underying knowledge base for a set of checks the very least based on which I could bind a variable on the right hand side"><y>#</y><d>2017-05-27</d><h>19:03</h><w>newres</w>I might be stepping too much over what the rete network does so it might be slow, but if nothing else there should be a way to look into the underying knowledge base for a set of checks the very least based on which I could bind a variable on the right hand side</z><z id="t1495911890838314" t="newres but this seems like internal stuff to clara the very least"><y>#</y><d>2017-05-27</d><h>19:04</h><w>newres</w>but this seems like internal stuff to clara the very least</z><z id="t1495913386922220" t="newres was thinking maybe having a test expression that uses a functon and perhaps some internal way of peering into the current knowledge base, based on which it would return variables"><y>#</y><d>2017-05-27</d><h>19:29</h><w>newres</w>was thinking maybe having a test expression that uses a functon and perhaps some internal way of peering into the current knowledge base, based on which it would return variables</z><z id="t1495914239968707" t="ryanbrush @newres I&apos;m not sure I entirely follow your use case, but it seems possible in principle with some of the rule generation patterns described above. However, I&apos;m not sure I&apos;d suggest that approach if you can avoid it. It might be better to, for example, put the needed data in some structure on the left-hand side, and bind the entire structure to a variable...and then de-structure that variable on the right-hand side to get the nested structure out."><y>#</y><d>2017-05-27</d><h>19:43</h><w>ryanbrush</w>@newres I&apos;m not sure I entirely follow your use case, but it seems possible in principle with some of the rule generation patterns described above. However, I&apos;m not sure I&apos;d suggest that approach if you can avoid it. It might be better to, for example, put the needed data in some structure on the left-hand side, and bind the entire structure to a variable...and then de-structure that variable on the right-hand side to get the nested structure out.</z><z id="t1495914755998097" t="newres @ryanbrush The problem I would have in binding everything and move it to the right hand side is that in the current implementation I need to use the conclusion in the guard."><y>#</y><d>2017-05-27</d><h>19:52</h><w>newres</w>@ryanbrush The problem I would have in binding everything and move it to the right hand side is that in the current implementation I need to use the conclusion in the guard.</z><z id="t1495915005011214" t="newres @ryanbrush is there a way on the lhs to reach into the current knowledge base with an expression, without resorting to unification and bindings? Basically with regular programming with some datastructure as a knowledge base the problem is pretty easily solvable, I would not mind skipping any optimizations clara provides just in a few cases."><y>#</y><d>2017-05-27</d><h>19:56</h><w>newres</w>@ryanbrush  is there a way on the lhs to reach into the current knowledge base with an expression, without resorting to unification and bindings? Basically with regular programming with some datastructure as a knowledge base the problem is pretty easily solvable, I would not mind skipping any optimizations clara provides just in a few cases.</z><z id="t1495915254025919" t="newres @ryanbrush to describe the problem I have a bit better, suppose I have bound a list to the variable ?L. Based on this list I need to check x number of conditions where x is the length of that list and the conditions vary based the the list elements."><y>#</y><d>2017-05-27</d><h>20:00</h><w>newres</w>@ryanbrush to describe the problem I have a bit better, suppose I have bound a list to the variable ?L. Based on this list I need to check x number of conditions where x is the length of that list and the conditions vary based the the list elements.</z><z id="t1495915637048051" t="ryanbrush The left hand side can only see the fact it is analyzing, and previously bound variables. Unfortunately there isn&apos;t a way to dynamically peek into the memory more than that...and there isn&apos;t a way to really make that visible that will be stable, either, since the order of evaluation of each rule constraint isn&apos;t defined, and we use a mutable structure underneath that can change at any time."><y>#</y><d>2017-05-27</d><h>20:07</h><w>ryanbrush</w>The left hand side can only see the fact it is analyzing, and previously bound variables. Unfortunately there isn&apos;t a way to dynamically peek into the memory more than that...and there isn&apos;t a way to really make that visible that will be stable, either, since the order of evaluation of each rule constraint isn&apos;t defined, and we use a mutable structure underneath that can change at any time.</z><z id="t1495915712052175" t="ryanbrush Generating rules ahead of creating the session can be done, but it&apos;s not clear whether that helps much. The visibility of the LHS to the fact its evaluating and previous, explicitly bound variables in earlier constraints on the LHS is a pretty firmly build in."><y>#</y><d>2017-05-27</d><h>20:08</h><w>ryanbrush</w>Generating rules ahead of creating the session can be done, but it&apos;s not clear whether that helps much. The visibility of the LHS to the fact its evaluating and previous, explicitly bound variables in earlier constraints on the LHS is a pretty firmly build in.</z><z id="t1495915748054150" t="ryanbrush But you can still bind a list or other structure in one LHS constraint, and then analyze it in a subsequent LHS constraint, if that helps."><y>#</y><d>2017-05-27</d><h>20:09</h><w>ryanbrush</w>But you can still bind a list or other structure in one LHS constraint, and then analyze it in a subsequent LHS constraint, if that helps.</z><z id="t1495915763055029" t="ryanbrush ...which includes test guards"><y>#</y><d>2017-05-27</d><h>20:09</h><w>ryanbrush</w>...which includes test guards</z><z id="t1495916087073735" t="newres The problem there is I do not know how I would express the fact that for all elements in that list I need a new slightly different constrained. For example suppose I have in the list 3 variables ?p1, ?p2, ?p3 I would need 3 conditions that check like [T (= ?a s) (= ?p1 p) (= b o)] [T (= ?b s) (= ?p2 p) (= c o)] [T (= ?c s) (= ?p3 p) (= d o)]"><y>#</y><d>2017-05-27</d><h>20:14</h><w>newres</w>The problem there is I do not know how I would express the fact that for all elements in that list I need a new slightly different constrained. For example suppose I have in the list 3 variables ?p1, ?p2, ?p3 I would need 3 conditions that check like [T (= ?a s) (= ?p1 p) (= b o)]  [T (= ?b s) (= ?p2 p) (= c o)] [T (= ?c s) (= ?p3 p) (= d o)]</z><z id="t1495916188079006" t="newres I can probably generate or write up such rules for the length of x manually if writing it for arbitary lengths is not possible"><y>#</y><d>2017-05-27</d><h>20:16</h><w>newres</w>I can probably generate or write up such rules for the length of x manually if writing it for arbitary lengths is not possible</z><z id="t1495916240081682" t="ryanbrush Another simpler option (which may or may not work for your needs) is to use an accumulator to match a list of all items of type T, and then analyze that list in your guard."><y>#</y><d>2017-05-27</d><h>20:17</h><w>ryanbrush</w>Another simpler option (which may or may not work for your needs) is to use an accumulator to match a list of all items of type T, and then analyze that list in your guard.</z><z id="t1495916299084566" t="ryanbrush The accumulator might not bind anything but the result, so it just passes a list down, and you can call an arbitrarily sophisticated function in the guard to sort it out. Some documentation here: http://www.clara-rules.org/docs/accumulators/"><y>#</y><d>2017-05-27</d><h>20:18</h><w>ryanbrush</w>The accumulator might not bind anything but the result, so it just passes a list down, and you can call an arbitrarily sophisticated function in the guard to sort it out. Some documentation here:  <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a></z><z id="t1495916540097363" t="newres so I could get all the values of T where the middle variable is a member of the list (In my implementation nearly everything is T, so I need to narrow some things down), than have test as a guard that pretty much checks what the conditions would do in a normal case"><y>#</y><d>2017-05-27</d><h>20:22</h><w>newres</w>so I could get all the values of T where the middle variable is a member of the list (In my implementation nearly everything is T, so I need to narrow some things down), than have test as a guard that pretty much checks what the conditions would do in a normal case</z><z id="t1495916568098677" t="ryanbrush Yeah, that should work."><y>#</y><d>2017-05-27</d><h>20:22</h><w>ryanbrush</w>Yeah, that should work.</z><z id="t1495916602100493" t="ryanbrush It&apos;s probably not the most idiomatic way to structure rules, but we&apos;ve done things like this as well."><y>#</y><d>2017-05-27</d><h>20:23</h><w>ryanbrush</w>It&apos;s probably not the most idiomatic way to structure rules, but we&apos;ve done things like this as well.</z><z id="t1495916646102664" t="ryanbrush If you really want to get fancy you can write your own accumulator...but just grabbing everything (or just using simple filters if that works) can get you there."><y>#</y><d>2017-05-27</d><h>20:24</h><w>ryanbrush</w>If you really want to get fancy you can write your own accumulator...but just grabbing everything (or just using simple filters if that works) can get you there.</z><z id="t1495916764108672" t="newres is there a simple way to say that i want [T (= ?b s) (= ?pl p) (= c o)] where ?pl is a member of a list l"><y>#</y><d>2017-05-27</d><h>20:26</h><w>newres</w>is there a simple way to say that i want  [T (= ?b s) (= ?pl p) (= c o)] where ?pl is a member of a list l</z><z id="t1495916811111107" t="ryanbrush Yeah, you can pass ?pl to any function on the LHS after it is declared, including checks for inclusion in a list."><y>#</y><d>2017-05-27</d><h>20:26</h><w>ryanbrush</w>Yeah, you can pass ?pl to any function on the LHS after it is declared, including checks for inclusion in a list.</z><z id="t1495916850113081" t="newres aha yes that would work, not sure about the efficiency but right now getting it working would be a good step"><y>#</y><d>2017-05-27</d><h>20:27</h><w>newres</w>aha yes that would work, not sure about the efficiency but right now getting it working would be a good step</z><z id="t1495916925116648" t="newres Thanks for the help! i am probably pushing clara in some really weird and unexpected ways but the docs really help"><y>#</y><d>2017-05-27</d><h>20:28</h><w>newres</w>Thanks for the help! i am probably pushing clara in some really weird and unexpected ways but the docs really help</z><z id="t1495916943117544" t="ryanbrush Cool. Glad I could help and good luck with your system!"><y>#</y><d>2017-05-27</d><h>20:29</h><w>ryanbrush</w>Cool. Glad I could help and good luck with your system!</z><z id="t1495916954118079" t="newres and the board and the slack, thanks !"><y>#</y><d>2017-05-27</d><h>20:29</h><w>newres</w>and the board and the slack, thanks !</z><z id="t1496069097455930" t="nkabrich Why is this rule creating an infinite loop? I&apos;m trying to insert a &quot;default fact&quot; if no other rule has yet inserted that fact. Or is there a better pattern for this? (defrule infinite-loop [:not [SomeFact]] =&gt; (rules/insert! (map-&gt;SomeFact {:a 1}))) Also if I add {:salience -1} to this rule, it seems to hang in the LHS? I&apos;m not exactly sure but in any case when I set the salience a (println &quot;looping&quot;) in the RHS fails to print and thread hangs."><y>#</y><d>2017-05-29</d><h>14:44</h><w>nkabrich</w>Why is this rule creating an infinite loop? I&apos;m trying to insert a &quot;default fact&quot; if no other rule has yet inserted that fact. Or is there a better pattern for this?
<pre>(defrule infinite-loop
  [:not [SomeFact]]
  =&gt;
  (rules/insert! (map-&gt;SomeFact {:a 1})))</pre>

Also if I add <code>{:salience -1}</code> to this rule, it seems to hang in the LHS? I&apos;m not exactly sure but in any case when I set the salience a (println &quot;looping&quot;) in the RHS fails to print and thread hangs.</z><z id="t1496069328505325" t="souenzzo not sure but, i think you can: first accumulate some fact, if it&apos;s equal zero, then insert the default."><y>#</y><d>2017-05-29</d><h>14:48</h><w>souenzzo</w>not sure but, i think you can: first accumulate some fact, if it&apos;s equal zero, then insert the default.</z><z id="t1496071222889484" t="alex-dixon @ryanbrush Would it be ok to add a Clara channel here? https://discord.gg/v9QMy9D"><y>#</y><d>2017-05-29</d><h>15:20</h><w>alex-dixon</w>@ryanbrush Would it be ok to add a Clara channel here? <a href="https://discord.gg/v9QMy9D" target="_blank">https://discord.gg/v9QMy9D</a></z><z id="t1496071397922953" t="nkabrich @souenzzo hmm thanks, but I&apos;m still running into an infinite loop using an accumulator and :test to insert a default"><y>#</y><d>2017-05-29</d><h>15:23</h><w>nkabrich</w>@souenzzo hmm thanks, but I&apos;m still running into an infinite loop using an accumulator and <code>:test</code> to insert a default</z><z id="t1496071910019205" t="alex-dixon @nkabrich Are you using (acc/count)?"><y>#</y><d>2017-05-29</d><h>15:31</h><w>alex-dixon</w>@nkabrich Are you using (acc/count)?</z><z id="t1496072014038139" t="alex-dixon [?nfacts &lt;- (acc/count) :from SomeFact] [:test (= 0 ?nfacts)] "><y>#</y><d>2017-05-29</d><h>15:33</h><w>alex-dixon</w><pre>[?nfacts &lt;- (acc/count) :from SomeFact]
[:test (= 0 ?nfacts)]
</pre></z><z id="t1496072015038374" t="alex-dixon ?"><y>#</y><d>2017-05-29</d><h>15:33</h><w>alex-dixon</w>?</z><z id="t1496072042043058" t="nkabrich @alex-dixon nope, ill give that a whirl"><y>#</y><d>2017-05-29</d><h>15:34</h><w>nkabrich</w>@alex-dixon nope, ill give that a whirl</z><z id="t1496072176067501" t="ryanbrush If an insert on the RHS causes the LHS to become false, the insert is retracted since it is no longer supported...causing the LHS to become true again and an infinite loop occurs."><y>#</y><d>2017-05-29</d><h>15:36</h><w>ryanbrush</w>If an insert on the RHS causes the LHS to become false, the insert is retracted since it is no longer supported...causing the LHS to become true again and an infinite loop occurs.</z><z id="t1496072229076706" t="ryanbrush The key is for the RHS insert to not match the LHS. Like check in the LHS for not a default value that the RHS could insert, so it doesn&apos;t retract the RHS inserted fact."><y>#</y><d>2017-05-29</d><h>15:37</h><w>ryanbrush</w>The key is for the RHS insert to not match the LHS. Like check in the LHS for not a default value that the RHS could insert, so it doesn&apos;t retract the RHS inserted fact.</z><z id="t1496072283086203" t="ryanbrush You can also use insert-unconditional to avoid this truth maintenance loop outright, but that can cause other headaches that depend on the order of facts inserted."><y>#</y><d>2017-05-29</d><h>15:38</h><w>ryanbrush</w>You can also use insert-unconditional to avoid this truth maintenance loop outright, but that can cause other headaches that depend on the order of facts inserted.</z><z id="t1496072301089335" t="nkabrich ahh, makes total sense thanks for the explanation."><y>#</y><d>2017-05-29</d><h>15:38</h><w>nkabrich</w>ahh, makes total sense thanks for the explanation.</z><z id="t1496072353098122" t="ryanbrush Sure thing. It&apos;s probably the biggest pitfall of rules engines like this....but can be overcome with some care"><y>#</y><d>2017-05-29</d><h>15:39</h><w>ryanbrush</w>Sure thing. It&apos;s probably the biggest pitfall of rules engines like this....but can be overcome with some care</z><z id="t1496072514125853" t="ryanbrush @alex-dixon I&apos;m not familiar with that service. Let me take a look at it later today"><y>#</y><d>2017-05-29</d><h>15:41</h><w>ryanbrush</w>@alex-dixon I&apos;m not familiar with that service. Let me take a look at it later today</z><z id="t1496072718161290" t="alex-dixon @ryanbrush Thanks. There’s some discussion within the community to converting from Slack to it. Seems like we’re in a trial period right now. I know from the JS community that Slack’s message limit is a problem and Discord is generally looked to as the solution (they keep unlimited message history) https://github.com/reactjs/redux for example is a popular JS library that has moved to Discord"><y>#</y><d>2017-05-29</d><h>15:45</h><w>alex-dixon</w>@ryanbrush Thanks. There’s some discussion within the community to converting from Slack to it. Seems like we’re in a trial period right now. I know from the JS community that Slack’s message limit is a problem and Discord is generally looked to as the solution (they keep unlimited message history) <a href="https://github.com/reactjs/redux" target="_blank">https://github.com/reactjs/redux</a> for example is a popular JS library that has moved to Discord</z><z id="t1496156575768348" t="ryanbrush As for the Discord conversation, if the bulk of the Clojure community goes over there then we should go along. That said, I feel like I already have too many collaboration tools I use...so I&apos;ll probably only be active on the forums where most of Clojure is. I have no objections if users want to create a Clara channel there...I just won&apos;t promise to frequent all of these."><y>#</y><d>2017-05-30</d><h>15:02</h><w>ryanbrush</w>As for the Discord conversation, if the bulk of the Clojure community goes over there then we should go along. That said, I feel like I already have too many collaboration tools I use...so I&apos;ll probably only be active on the forums where most of Clojure is. I have no objections if users want to create a Clara channel there...I just won&apos;t promise to frequent  all of these.</z><z id="t1496928916776734" t="jfntn I’m not familiar with clara but I’ve been wondering if it could be used to model a HFSM/Statechart by defining a hierarchy of rules?"><y>#</y><d>2017-06-08</d><h>13:35</h><w>jfntn</w>I’m not familiar with clara but I’ve been wondering if it could be used to model a HFSM/Statechart by defining a hierarchy of rules?</z><z id="t1496929336932837" t="jfntn I.e. in any given state, only a subset of the engines rules are loaded, and generally you’d want children states to activate their parent’s rules"><y>#</y><d>2017-06-08</d><h>13:42</h><w>jfntn</w>I.e. in  any given state, only a subset of the engines rules are loaded, and generally you’d want children states to activate their parent’s rules</z><z id="t1496929498995499" t="jfntn The OOP like mechanics can easily be achieved with a custom hierarchy in clojure, but I’m wondering if scoping rules to their respective state in clara would involve instantiating different rulesets, or dynamically mutating a global rules registry"><y>#</y><d>2017-06-08</d><h>13:44</h><w>jfntn</w>The OOP like mechanics can easily be achieved with a custom hierarchy in clojure, but I’m wondering if scoping rules to their respective state in clara would involve instantiating different rulesets, or dynamically mutating a global rules registry</z><z id="t1497015354148841" t="fabrao Well @jfntn , I used to classify I kind of link status to avoid chains of ifs, but my experience is that it was more complex than I thougth, so I changed to datascript to be more clear and simple"><y>#</y><d>2017-06-09</d><h>13:35</h><w>fabrao</w>Well @jfntn , I used to classify I kind of link status to avoid chains of ifs, but my experience is that it was more complex than I thougth, so I changed to datascript to be more clear and simple</z><z id="t1497015372154964" t="fabrao here is an example what I did (defn limite [chave] (read-string (chave (:referencia (:config sistema))))) (defrecord IcmpLocalizacao [nome-link localidade jitter latencia perda]) (defrecord Problema [mensagem nome-link localidade]) (defrule ligacao-fragmentada [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; perda (limite :perda))] =&gt; (insert! (-&gt;Problema :fragmentada ?nome-link ?localidade))) (defrule telefonia-degradada [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; jitter (limite :jitter)) (&gt; latencia (limite :latencia)) (&lt;= perda (limite :perda))] =&gt; (insert! (-&gt;Problema :degradada ?nome-link ?localidade))) (defrule perda-qualidade [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; jitter (limite :jitter)) (&lt;= latencia (limite :latencia)) (&lt;= perda (limite :perda))] =&gt; (insert! (-&gt;Problema :qualidade ?nome-link ?localidade))) (defrule atraso-telefonia [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&lt;= jitter (limite :jitter)) (&gt; latencia (limite :latencia)) (&lt;= perda (limite :perda))] =&gt; (insert! (-&gt;Problema :atraso ?nome-link ?localidade))) (defrule sem-comunicacao [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (= jitter -1) (= latencia -1) (= perda -1)] =&gt; (insert! (-&gt;Problema :comunicacao_locais ?nome-link ?localidade))) (defquery problemas-comunicacao [] [Problema (= ?mensagem mensagem) (= ?nome-link nome-link) (= ?localidade localidade)]) (defn gerar-fatos [fatos] (let [regras (atom #{})] (doseq [fato fatos] (let [link (first (first fato)) valor (second (first fato)) localidade (:localidade valor) icmp (:icmp valor) jitter (:jitter icmp) perda (:perda icmp) latencia (:latencia icmp)] (swap! regras conj (-&gt;IcmpLocalizacao link localidade jitter latencia perda)))) @regras)) (defn compilar-regras [fatos] (into #{} (-&gt; (mk-session &apos;correlacao.item.regraslink) (insert-all (gerar-fatos fatos)) (fire-rules) (query problemas-comunicacao)))) "><y>#</y><d>2017-06-09</d><h>13:36</h><w>fabrao</w>here is an example what I did 
<pre>(defn limite [chave]
  (read-string (chave (:referencia (:config sistema)))))

(defrecord IcmpLocalizacao [nome-link localidade jitter latencia perda])
(defrecord Problema [mensagem nome-link localidade])

(defrule ligacao-fragmentada
         [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; perda (limite :perda))]
         =&gt;
         (insert! (-&gt;Problema :fragmentada ?nome-link ?localidade)))

(defrule telefonia-degradada
         [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; jitter (limite :jitter)) (&gt; latencia (limite :latencia)) (&lt;= perda (limite :perda))]
         =&gt;
         (insert! (-&gt;Problema :degradada ?nome-link ?localidade)))

(defrule perda-qualidade
         [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&gt; jitter (limite :jitter)) (&lt;= latencia (limite :latencia)) (&lt;= perda (limite :perda))]
         =&gt;
         (insert! (-&gt;Problema :qualidade ?nome-link ?localidade)))

(defrule atraso-telefonia
         [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (&lt;= jitter (limite :jitter)) (&gt; latencia (limite :latencia)) (&lt;= perda (limite :perda))]
         =&gt;
         (insert! (-&gt;Problema :atraso ?nome-link ?localidade)))

(defrule sem-comunicacao
         [?local &lt;- IcmpLocalizacao (= ?nome-link nome-link) (= ?localidade localidade) (= jitter -1) (= latencia -1) (= perda -1)]
         =&gt;
         (insert! (-&gt;Problema :comunicacao_locais ?nome-link ?localidade)))

(defquery problemas-comunicacao []
          [Problema (= ?mensagem mensagem) (= ?nome-link nome-link) (= ?localidade localidade)])

(defn gerar-fatos [fatos]
  (let [regras (atom #{})]
    (doseq [fato fatos]
    (let [link (first (first fato))
          valor (second (first fato))
          localidade (:localidade valor)
          icmp (:icmp valor)
          jitter (:jitter icmp)
          perda (:perda icmp)
          latencia (:latencia icmp)]
    (swap! regras conj (-&gt;IcmpLocalizacao link localidade jitter latencia perda))))
    @regras))

(defn compilar-regras [fatos]
  (into #{}
        (-&gt; (mk-session &apos;correlacao.item.regraslink)
            (insert-all (gerar-fatos fatos))
            (fire-rules)
            (query problemas-comunicacao))))
</pre></z><z id="t1497015487193562" t="fabrao in datascript (defn- classificar-elemento [conn tipo op-jitter op-perda op-latencia jitter perda latencia] (let [resultado (d/q &apos;[:find ?localidade ?link :in $ ?op-jitter ?op-perda ?op-latencia ?ref-jitter ?ref-perda ?ref-latencia :where [?e :link ?link] [?e :localidade ?localidade] [?e :jitter ?jitter] [?e :perda ?perda] [?e :latencia ?latencia] [(?op-jitter ?jitter ?ref-jitter)] [(?op-perda ?perda ?ref-perda)] [(?op-latencia ?latencia ?ref-latencia)] ] conn op-jitter op-perda op-latencia jitter perda latencia)] (if (= #{} resultado) [] (resultado-&gt;set resultado tipo) )))"><y>#</y><d>2017-06-09</d><h>13:38</h><w>fabrao</w>in datascript <pre>(defn- classificar-elemento [conn tipo op-jitter op-perda op-latencia jitter perda latencia]
  (let [resultado (d/q &apos;[:find ?localidade ?link
                         :in $ ?op-jitter ?op-perda ?op-latencia ?ref-jitter ?ref-perda ?ref-latencia
                         :where 
                         [?e :link ?link]
                         [?e :localidade ?localidade]
                         [?e :jitter ?jitter]
                         [?e :perda ?perda]
                         [?e :latencia ?latencia]
                         [(?op-jitter ?jitter ?ref-jitter)]
                         [(?op-perda ?perda ?ref-perda)]
                         [(?op-latencia ?latencia ?ref-latencia)]
                         ]
                       conn op-jitter op-perda op-latencia jitter perda latencia)]
    (if (= #{} resultado)
      []
      (resultado-&gt;set resultado tipo)
      )))</pre></z><z id="t1497015582225587" t="fabrao (classificar-elemento @conn :fragmentada nevermind &gt; nevermind jitter perda latencia)"><y>#</y><d>2017-06-09</d><h>13:39</h><w>fabrao</w><code>(classificar-elemento @conn :fragmentada nevermind &gt; nevermind jitter perda latencia)</code></z><z id="t1497015811305138" t="fabrao I see that datascript was more flexible, but you can use any other ways to define rules for your job, like in https://github.com/threatgrid/naga or even clojure.logic"><y>#</y><d>2017-06-09</d><h>13:43</h><w>fabrao</w>I see that datascript was more flexible, but you can use any other ways to define rules for your job, like in <a href="https://github.com/threatgrid/naga" target="_blank">https://github.com/threatgrid/naga</a> or even <code>clojure.logic</code></z><z id="t1497031181024041" t="mikerod @jfntn I guess I don’t fully grasp your problem statement"><y>#</y><d>2017-06-09</d><h>17:59</h><w>mikerod</w>@jfntn I guess I don’t fully grasp your problem statement</z><z id="t1497031207035176" t="mikerod However, Clara has certainly been used in a way that creates logical “groups” and/or “hierarchies” of rules"><y>#</y><d>2017-06-09</d><h>18:00</h><w>mikerod</w>However, Clara has certainly been used in a way that creates logical “groups” and/or “hierarchies” of rules</z><z id="t1497031248051136" t="mikerod You can have intermediary facts inserted that act as “blockers” for some rules, or have some rules not be able to be satisfied until certain facts are present"><y>#</y><d>2017-06-09</d><h>18:00</h><w>mikerod</w>You can have intermediary facts inserted that act as “blockers” for some rules, or have some rules not be able to be satisfied until certain facts are present</z><z id="t1497031278063062" t="mikerod However, this isn’t done by “turning off” rules or by excluding rules from the rulebase/session created, instead it is done purely through logical relationships the rules express"><y>#</y><d>2017-06-09</d><h>18:01</h><w>mikerod</w>However, this isn’t done by “turning off” rules or by excluding rules from the rulebase/session created, instead it is done purely through logical relationships the rules express</z><z id="t1497031332082846" t="mikerod Also, the “type” dispatch function used by Clara rules LHS conditions is pluggable. So you could do things with ad hoc hierarchies of Clojure"><y>#</y><d>2017-06-09</d><h>18:02</h><w>mikerod</w>Also, the “type” dispatch function used by Clara rules LHS conditions is pluggable. So you could do things with ad hoc hierarchies of Clojure</z><z id="t1497031368095809" t="mikerod http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2017-06-09</d><h>18:02</h><w>mikerod</w><a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1497031384101883" t="mikerod has some details on the custom “fact type” fn (and similarly the associated “ancestors” fn"><y>#</y><d>2017-06-09</d><h>18:03</h><w>mikerod</w>has some details on the custom “fact type” fn (and similarly the associated “ancestors” fn</z><z id="t1497031402108693" t="mikerod I may be speaking way too vague to help answer your question though"><y>#</y><d>2017-06-09</d><h>18:03</h><w>mikerod</w>I may be speaking way too vague to help answer your question though</z><z id="t1497031437121764" t="jfntn Ok interesting, I guess I was wondering if it was valid to consider an approach where the app dynamically loads/unoads a different session depending on some external state machine"><y>#</y><d>2017-06-09</d><h>18:03</h><w>jfntn</w>Ok interesting, I guess I was wondering if it was valid to consider an approach where the app dynamically loads/unoads a different session depending on some external state machine</z><z id="t1497031454127498" t="mikerod I think @fabrao may have had some interesting points above too. There is a chance that forward-chaining rules aren’t the best approach to certain sorts of problems"><y>#</y><d>2017-06-09</d><h>18:04</h><w>mikerod</w>I think @fabrao may have had some interesting points above too. There is a chance that forward-chaining rules aren’t the best approach to certain sorts of problems</z><z id="t1497031506145689" t="mikerod I would say it is not a good situation to have when your rules end up being of the form: A -&gt; B; B -&gt; C; C -&gt; D; D -&gt; E - when that chain starts to get really long and only one linear flow of logic"><y>#</y><d>2017-06-09</d><h>18:05</h><w>mikerod</w>I would say it is not a good situation to have when your rules end up being of the form: A -&gt; B; B -&gt; C; C -&gt; D; D -&gt; E - when that chain starts to get really long and only one linear flow of logic</z><z id="t1497031578171387" t="mikerod @jfntn well consider one of the compelling strengths of a Rete-based forward chaining rules impl like Clara - it stores a bunch of state to avoid re-calculation of join and non-joining constraints done in previous states of the system"><y>#</y><d>2017-06-09</d><h>18:06</h><w>mikerod</w>@jfntn well consider one of the compelling strengths of a Rete-based forward chaining rules impl like Clara - it stores a bunch of state to avoid re-calculation of join and non-joining constraints done in previous states of  the  system</z><z id="t1497031601179468" t="mikerod if you flip from session to session, they will not share any of this state with one another. there is a chance that that is suitable for your needs. I’m just calling it out."><y>#</y><d>2017-06-09</d><h>18:06</h><w>mikerod</w>if you flip from session to session, they will not share any of this state with one another. there is a chance that that is suitable for your needs. I’m just calling it out.</z><z id="t1497031702214483" t="mikerod Also, the time to create a session is typically non-trivial if you have a fair number of rules involved. So often the pattern is to keep the sessions in memory. There will be limitations to how many rule sessions you can store in memory at a time. The size of them is mostly dependent on the number or rules and conditions involved"><y>#</y><d>2017-06-09</d><h>18:08</h><w>mikerod</w>Also, the time to create a session is typically non-trivial if you have a fair number of rules involved. So often the pattern is to keep the sessions in memory. There will be limitations to how many rule sessions you can store in memory at a time. The size of them is mostly dependent on the number or rules and conditions involved</z><z id="t1497031703215080" t="fabrao https://github.com/hraberg/mimir"><y>#</y><d>2017-06-09</d><h>18:08</h><w>fabrao</w><a href="https://github.com/hraberg/mimir" target="_blank">https://github.com/hraberg/mimir</a></z><z id="t1497031774238158" t="jfntn So I guess I was assuming you could somehow keep the facts but change the rules, not sure if that makes sense in practice"><y>#</y><d>2017-06-09</d><h>18:09</h><w>jfntn</w>So I guess I was assuming you could somehow keep the facts but change the rules, not sure if that makes sense in practice</z><z id="t1497031786243493" t="jfntn http://blog.cognitect.com/blog/2017/5/22/restate-your-ui-using-state-machines-to-simplify-user-interface-development"><y>#</y><d>2017-06-09</d><h>18:09</h><w>jfntn</w><a href="http://blog.cognitect.com/blog/2017/5/22/restate-your-ui-using-state-machines-to-simplify-user-interface-development" target="_blank">http://blog.cognitect.com/blog/2017/5/22/restate-your-ui-using-state-machines-to-simplify-user-interface-development</a></z><z id="t1497031801248753" t="mikerod @jfntn you could query the facts produced from a fire-rules execution of a session"><y>#</y><d>2017-06-09</d><h>18:10</h><w>mikerod</w>@jfntn you could query the facts produced from a <code>fire-rules</code> execution of a session</z><z id="t1497031810252088" t="jfntn This article includes this definition for an fsm:"><y>#</y><d>2017-06-09</d><h>18:10</h><w>jfntn</w>This article includes this definition for an fsm:</z><z id="t1497031812252421" t="mikerod and you could insert those facts into any other sessoin that uses them"><y>#</y><d>2017-06-09</d><h>18:10</h><w>mikerod</w>and you could insert those facts into any other sessoin that uses them</z><z id="t1497031824256894" t="jfntn (def fsm {&apos;Start {:init &apos;Ready} &apos;Ready {:missing-password &apos;Password-Error :missing-email &apos;Email-Error :submit &apos;Submitting} &apos;Password-Error {:change-password &apos;Ready} &apos;Email-Error {:change-email &apos;Ready} &apos;Submitting {:receive-success &apos;Success}}) "><y>#</y><d>2017-06-09</d><h>18:10</h><w>jfntn</w><pre>(def fsm {&apos;Start          {:init             &apos;Ready}
          &apos;Ready          {:missing-password &apos;Password-Error
                           :missing-email    &apos;Email-Error
                           :submit           &apos;Submitting}
          &apos;Password-Error {:change-password  &apos;Ready}
          &apos;Email-Error    {:change-email     &apos;Ready}
          &apos;Submitting     {:receive-success  &apos;Success}})
</pre></z><z id="t1497031832259773" t="mikerod I believe I just read this a few days ago"><y>#</y><d>2017-06-09</d><h>18:10</h><w>mikerod</w>I believe I just read this a few days ago</z><z id="t1497031840262598" t="mikerod I hadn’t really thought much about it though."><y>#</y><d>2017-06-09</d><h>18:10</h><w>mikerod</w>I hadn’t really thought much about it though.</z><z id="t1497031878275674" t="jfntn I was imagining something like rules as transitions instead of keywords, and a sort of recursive definition where the Symbols on the right-hand side could be whole FSMs"><y>#</y><d>2017-06-09</d><h>18:11</h><w>jfntn</w>I was imagining something like rules as transitions instead of keywords, and a sort of recursive definition where the Symbols on the right-hand side could be whole FSMs</z><z id="t1497031882277077" t="mikerod Have you found that it is difficult to express the FSM sort of logic just using 1 session?"><y>#</y><d>2017-06-09</d><h>18:11</h><w>mikerod</w>Have you found that it is difficult to express the FSM sort of logic just using 1 session?</z><z id="t1497031992315255" t="jfntn Wouldn’t you have to encode the transitions across many rules though? Maybe I just want something that will define a valid session from recursing over this tree"><y>#</y><d>2017-06-09</d><h>18:13</h><w>jfntn</w>Wouldn’t you have to encode the transitions across many rules though? Maybe I just want something that will define a valid session from recursing over this tree</z><z id="t1497032090349218" t="mikerod It isn’t immediately clear to me how it would look"><y>#</y><d>2017-06-09</d><h>18:14</h><w>mikerod</w>It isn’t immediately clear to me how it would look</z><z id="t1497032103353749" t="mikerod Perhaps this article is enough to go off to make a toy example in Clara with 1 session"><y>#</y><d>2017-06-09</d><h>18:15</h><w>mikerod</w>Perhaps this article is enough to go off to make a toy example in Clara with 1 session</z><z id="t1497032123360382" t="mikerod But it may not be sophisticated enough to show anything useful - I don’t know"><y>#</y><d>2017-06-09</d><h>18:15</h><w>mikerod</w>But it may not be sophisticated enough to show anything useful - I don’t know</z><z id="t1497032166375402" t="mikerod I’m just trying to find the simplest solution the the problem and I’d hope there would be a nice mapping of the idea to a single session. Just to avoid the details of bouncing around between them"><y>#</y><d>2017-06-09</d><h>18:16</h><w>mikerod</w>I’m just trying to find the simplest solution the the problem and I’d hope there would be a nice mapping of the idea to a single session. Just to avoid the details of bouncing around between them</z><z id="t1497032179380103" t="mikerod You could certainly have a map of “session name key” -&gt; session"><y>#</y><d>2017-06-09</d><h>18:16</h><w>mikerod</w>You could certainly have a map of “session name key” -&gt; session</z><z id="t1497032198386893" t="mikerod and have RHS’s produce a fact that says what is the “next session” to evaluate"><y>#</y><d>2017-06-09</d><h>18:16</h><w>mikerod</w>and have RHS’s produce a fact that says what is the “next session” to evaluate</z><z id="t1497032240401209" t="mikerod Or to flip that and just have the RHS produce a fact that your outer FSM uses to transition to the next step - I think that is what you said above"><y>#</y><d>2017-06-09</d><h>18:17</h><w>mikerod</w>Or to flip that and just have the RHS produce a fact that your outer FSM uses to transition to the next step - I think that is what you said above</z><z id="t1497032329432521" t="fabrao it seems like workflow engine"><y>#</y><d>2017-06-09</d><h>18:18</h><w>fabrao</w>it seems like workflow engine</z><z id="t1497032430467382" t="mikerod Funny"><y>#</y><d>2017-06-09</d><h>18:20</h><w>mikerod</w>Funny</z><z id="t1497032437470080" t="mikerod JBoss had jBPM I think"><y>#</y><d>2017-06-09</d><h>18:20</h><w>mikerod</w>JBoss had jBPM I think</z><z id="t1497032455476237" t="mikerod which basically (I believe) is a FSM sort of system that triggers Drools rules at certain stages"><y>#</y><d>2017-06-09</d><h>18:20</h><w>mikerod</w>which basically (I believe) is a FSM sort of system that triggers Drools rules at certain stages</z><z id="t1497032458477283" t="mikerod (among other things)"><y>#</y><d>2017-06-09</d><h>18:20</h><w>mikerod</w>(among other things)</z><z id="t1497032482485601" t="mikerod So I guess the idea came up there as well. I’m still just curious about whether or not a single session can’t express an FSM in the sense of the web app article though"><y>#</y><d>2017-06-09</d><h>18:21</h><w>mikerod</w>So I guess the idea came up there as well. I’m still just curious about whether or not a single session can’t express an FSM in the sense of the web app article  though</z><z id="t1497033126713406" t="jfntn Seems like it should be possible, but the article is only trying to represent a single FSM, and to extend that definition to a Statechart you have to imagine that each state on the right is not final but can have recursive fsm definitions."><y>#</y><d>2017-06-09</d><h>18:32</h><w>jfntn</w>Seems like it should be possible, but the article is only trying to represent a single FSM, and to extend that definition to a Statechart you have to imagine that each state on the right is not final but can have recursive fsm definitions.</z><z id="t1497033149720300" t="jfntn You’d be able to chart the whole app with something along those lines:"><y>#</y><d>2017-06-09</d><h>18:32</h><w>jfntn</w>You’d be able to chart the whole app with something along those lines:</z><z id="t1497033153721619" t="jfntn (def app-statechart {&apos;Visitor {:login {&apos;LoginForm {&apos;Start {:init &apos;Ready} &apos;Ready {:missing-password &apos;Password-Error :missing-email &apos;Email-Error :submit &apos;Submitting} &apos;Password-Error {:change-password &apos;Ready} &apos;Email-Error {:change-email &apos;Ready} &apos;Submitting {:receive-success &apos;Success}}} :signup {... }} &apos;User {...} &apos;Admin {...}}) "><y>#</y><d>2017-06-09</d><h>18:32</h><w>jfntn</w><pre>(def app-statechart
  {&apos;Visitor
   {:login
    {&apos;LoginForm
     {&apos;Start          {:init &apos;Ready}
      &apos;Ready          {:missing-password &apos;Password-Error
                       :missing-email    &apos;Email-Error
                       :submit           &apos;Submitting}
      &apos;Password-Error {:change-password &apos;Ready}
      &apos;Email-Error    {:change-email &apos;Ready}
      &apos;Submitting     {:receive-success &apos;Success}}}
    :signup {... }}
   &apos;User  {...}
   &apos;Admin {...}})
</pre></z><z id="t1497033659897096" t="jfntn The key distinction is that for a given node in the tree, valid transitions at that state are the union of its and its parents’ transitions (or rules in our case), so rules that are not in this set are illegal"><y>#</y><d>2017-06-09</d><h>18:40</h><w>jfntn</w>The key distinction is that for a given node in the tree, valid transitions at that state are the union of its and its parents’ transitions (or rules in our case), so rules that are not in this set are illegal</z><z id="t1497034261102235" t="mikerod interesting"><y>#</y><d>2017-06-09</d><h>18:51</h><w>mikerod</w>interesting</z><z id="t1497035810619279" t="fabrao Dont you think clara is too complex for that?"><y>#</y><d>2017-06-09</d><h>19:16</h><w>fabrao</w>Dont you think clara is too complex for that?</z><z id="t1497035973670649" t="fabrao take a look here https://github.com/vvvvalvalval/datalog-rules"><y>#</y><d>2017-06-09</d><h>19:19</h><w>fabrao</w>take a look here <a href="https://github.com/vvvvalvalval/datalog-rules" target="_blank">https://github.com/vvvvalvalval/datalog-rules</a></z><z id="t1497036051694861" t="fabrao you can define many ruleset and apply it in your context, so you can dynamic it for your needs"><y>#</y><d>2017-06-09</d><h>19:20</h><w>fabrao</w>you can define many <code>ruleset</code> and apply it in your context, so you can dynamic it for your needs</z><z id="t1497039589762871" t="mikerod There is no engine there, but I’m assuming you put it on top of something like datascript"><y>#</y><d>2017-06-09</d><h>20:19</h><w>mikerod</w>There is no engine there, but I’m assuming you put it on top of something like datascript</z><z id="t1497039598765491" t="mikerod and I think you end up in a backwards-chaining situation there"><y>#</y><d>2017-06-09</d><h>20:19</h><w>mikerod</w>and I think you end up in a backwards-chaining situation there</z><z id="t1497039608768440" t="mikerod which may be find and fit the need. I think it just comes down to what you want out of it."><y>#</y><d>2017-06-09</d><h>20:20</h><w>mikerod</w>which may be find and fit the need. I think it just comes down to what you want out of it.</z><z id="t1497039657782360" t="mikerod also, you have to consider any performance concerns you may have, clj/cljs support (I think datalog-rules would be fine in either), etc"><y>#</y><d>2017-06-09</d><h>20:20</h><w>mikerod</w>also, you have to consider any performance concerns you may have, clj/cljs support (I think datalog-rules would be fine in either), etc</z><z id="t1497046055365498" t="jfntn No I think conceptually we do want forward chaining and all the caching goodness from clara, just trying to wrap my head around what type of application-level integration we could have"><y>#</y><d>2017-06-09</d><h>22:07</h><w>jfntn</w>No I think conceptually we do want forward chaining and all the caching goodness from clara, just trying to wrap my head around what type of application-level integration we could have</z><z id="t1497053869406274" t="mikegai @jfntn modeling a statechart should be no problem within a single session -- you just need to gate each rule controlling exit/enter with a &quot;gating condition&quot; that matches the current state."><y>#</y><d>2017-06-10</d><h>00:17</h><w>mikegai</w>@jfntn modeling a statechart should be no problem within a single session -- you just need to gate each rule controlling exit/enter with a &quot;gating condition&quot; that matches the current state.</z><z id="t1497053931411442" t="mikegai The state chart syntax you supplied could be operated over and expanded to a set of rules, each of which begins with matching the state from which those entry/exits apply"><y>#</y><d>2017-06-10</d><h>00:18</h><w>mikegai</w>The state chart syntax you supplied could be operated over and expanded to a set of rules, each of which begins with matching the state from which those entry/exits apply</z><z id="t1497055725552508" t="mikegai Maybe something like this (in tuple / #precept syntax instead of default Clara): (def-tuple-rule ready-exit-missing-password [[:app :state :login]] [[:login :state :ready]] [[_ :missing-email]] =&gt; (insert-unconditional! [[:login :state :password-error]]))"><y>#</y><d>2017-06-10</d><h>00:48</h><w>mikegai</w>Maybe something like this (in tuple / #precept syntax instead of default Clara):
 <pre>(def-tuple-rule ready-exit-missing-password
  [[:app :state :login]]
  [[:login :state :ready]]
  [[_ :missing-email]]
  =&gt;
  (insert-unconditional! [[:login :state :password-error]]))</pre></z><z id="t1497055782556648" t="mikegai a macro would expand the concise statechart syntax to rules like that."><y>#</y><d>2017-06-10</d><h>00:49</h><w>mikegai</w>a macro would expand the concise statechart syntax to rules like that.</z><z id="t1497055820559460" t="mikegai and then of course you could define/derive :missing-email elsewhere"><y>#</y><d>2017-06-10</d><h>00:50</h><w>mikegai</w>and then of course you could define/derive <code>:missing-email</code> elsewhere</z><z id="t1497055852561845" t="mikegai @jfntn do I have what you&apos;re thinking right?"><y>#</y><d>2017-06-10</d><h>00:50</h><w>mikegai</w>@jfntn do I have what you&apos;re thinking right?</z><z id="t1498472399348657" t="misha greetings! Is using clara for sessions as small as single UI form – an overkill in context of mobile applications (e.g. React Native apps, where performance is more expensive than on desktop websites or backend)?"><y>#</y><d>2017-06-26</d><h>10:19</h><w>misha</w>greetings!
Is using clara for sessions as small as single UI form – an overkill in context of mobile applications (e.g. React Native apps, where performance is more expensive than on desktop websites or backend)?</z><z id="t1498487859530002" t="mikerod @misha It could be. Even if not for performance, it may just be too complex of a tool for the job. What sort of reasons were you thinking that it may be helpful for a single form?"><y>#</y><d>2017-06-26</d><h>14:37</h><w>mikerod</w>@misha It could be. Even if not for performance, it may just be too complex of a tool for the job. What sort of reasons were you thinking that it may be helpful for a single form?</z><z id="t1498487870534274" t="mikerod I guess I wouldn’t think a form would have enough complex control flow"><y>#</y><d>2017-06-26</d><h>14:37</h><w>mikerod</w>I guess I wouldn’t think a form would have enough complex control flow</z><z id="t1498488634844871" t="misha by form I mean registration/billing/etc. form (just to clarify)"><y>#</y><d>2017-06-26</d><h>14:50</h><w>misha</w>by <code>form</code> I mean <code>registration/billing/etc.</code> form (just to clarify)</z><z id="t1498488719879664" t="misha forms can get pretty complex, with all the fetching, autosuggesting, autocompleting, validation, etc."><y>#</y><d>2017-06-26</d><h>14:51</h><w>misha</w>forms can get pretty complex, with all the fetching, autosuggesting, autocompleting, validation, etc.</z><z id="t1498488919963819" t="misha but what I am really after, is a way to manage lots of state, it can be as complex, as entire application state: think many dependent and independent widgets on the same screen, or even many screens, but with routing implemented with rules too, instead of having it as a standalone thing with its own tools and approaches."><y>#</y><d>2017-06-26</d><h>14:55</h><w>misha</w>but what I am really after, is a way to manage lots of state, it can be as complex, as entire application state: think many dependent and independent widgets on the same screen, or  even many screens, but with routing implemented with rules too, instead of having it as a standalone thing with its own tools and approaches.</z><z id="t1498490626696835" t="mikerod @misha yeah, that sounds interesting. I don’t know on the performance concerns. I’m not sure I’ve heard of someone using Clara on mobile applications to have anything to go off of."><y>#</y><d>2017-06-26</d><h>15:23</h><w>mikerod</w>@misha yeah, that sounds interesting. I don’t know on the performance concerns. I’m not sure I’ve heard of someone using Clara on mobile applications to have anything to go off of.</z><z id="t1498490652707293" t="mikerod Also, precept seems to be using Clara in a somewhat similar way as you describe. However, I’m not sure it is handling routing."><y>#</y><d>2017-06-26</d><h>15:24</h><w>mikerod</w>Also, <code>precept</code> seems to be using Clara in a somewhat similar way as you describe. However, I’m not sure it is handling routing.</z><z id="t1498490663712191" t="mikerod https://github.com/CoNarrative/precept"><y>#</y><d>2017-06-26</d><h>15:24</h><w>mikerod</w><a href="https://github.com/CoNarrative/precept" target="_blank">https://github.com/CoNarrative/precept</a></z><z id="t1498490706730691" t="mikerod The space/time complexity of Clara is going to be reliant on the number of rules, complexity of the join conditions within the rules, and the size of facts in working memory."><y>#</y><d>2017-06-26</d><h>15:25</h><w>mikerod</w>The space/time complexity of Clara is going to be reliant on the number of rules, complexity of the join conditions within the rules, and the size of facts in working memory.</z><z id="t1498490722737327" t="mikerod So you can get a pretty large range of performance characteristics depending on your use-case"><y>#</y><d>2017-06-26</d><h>15:25</h><w>mikerod</w>So you can get a pretty large range of performance characteristics depending on your use-case</z><z id="t1498490768757030" t="mikerod The tendency of the rules network is to favor time over space. e.g. intermediate match state is saved to avoid recomputing values later. So a space vs time tradeoff."><y>#</y><d>2017-06-26</d><h>15:26</h><w>mikerod</w>The tendency of the rules network is to favor time over space. e.g. intermediate match state is saved to avoid recomputing values later. So a space vs time tradeoff.</z><z id="t1498490806773491" t="mikerod If your working memory state isn’t prohibitively large though, the space may still be reasonable"><y>#</y><d>2017-06-26</d><h>15:26</h><w>mikerod</w>If your working memory state isn’t prohibitively large though, the space may still be reasonable</z><z id="t1498490808774002" t="misha I am yet to read into precept, but guys do not hesitate to call it framework , so I am being &quot;careful&quot; there :)"><y>#</y><d>2017-06-26</d><h>15:26</h><w>misha</w>I am yet to read into precept, but guys do not hesitate to call it <code>framework</code>, so I am being &quot;careful&quot; there :)</z><z id="t1498490981848788" t="misha as far as mobile apps performance concerns go, I am worried about cpu speed at the moment, since I was forced to move datascript to a separate RN thread because of pull calls speed on a somewhat large db."><y>#</y><d>2017-06-26</d><h>15:29</h><w>misha</w>as far as mobile apps performance concerns go, I am worried about cpu speed at the moment, since I was forced to move datascript to a separate RN thread because of <code>pull</code> calls speed on a somewhat large db.</z><z id="t1498491073890480" t="misha But I am looking at rule based systems™ from an application state management pov, which might be only few hundred kvs at most, I think"><y>#</y><d>2017-06-26</d><h>15:31</h><w>misha</w>But I am looking at rule based systems™ from an application state management pov, which might be only few hundred kvs at most, I think</z><z id="t1498496931183255" t="zylox EDIT: i need to read better"><y>#</y><d>2017-06-26</d><h>17:08</h><w>zylox</w>EDIT: i need to read better</z><z id="t1498512716805979" t="mikerod @misha well if cpu is your worry than at least Clara favors that over space usage"><y>#</y><d>2017-06-26</d><h>21:31</h><w>mikerod</w>@misha well if cpu is your worry than at least Clara favors that over space usage</z><z id="t1498512749815442" t="mikerod It’d be cool if you could try it out and report back with how it performs in this mobile case"><y>#</y><d>2017-06-26</d><h>21:32</h><w>mikerod</w>It’d be cool if you could try it out and report back with how it performs in this mobile case</z><z id="t1498512771822019" t="mikerod Nothing stands out to me as being too prohibitive"><y>#</y><d>2017-06-26</d><h>21:32</h><w>mikerod</w>Nothing stands out to me as being too prohibitive</z><z id="t1498514114178726" t="misha @mikerod first, I need to start thinking in terms of rules, but as soon as will have something to show – I&apos;ll let you know."><y>#</y><d>2017-06-26</d><h>21:55</h><w>misha</w>@mikerod first, I need to start thinking in terms of rules, but as soon as will have something to show – I&apos;ll let you know.</z><z id="t1498514426258049" t="mikerod sounds fun!"><y>#</y><d>2017-06-26</d><h>22:00</h><w>mikerod</w>sounds fun!</z><z id="t1498514477271277" t="misha opieop"><y>#</y><d>2017-06-26</d><h>22:01</h><w>misha</w><b>opieop</b></z><z id="t1498583503232134" t="devn howdy folks -- so, i have a base session which contains a bunch of configuration facts and what-not"><y>#</y><d>2017-06-27</d><h>17:11</h><w>devn</w>howdy folks -- so, i have a base session which contains a bunch of configuration facts and what-not</z><z id="t1498583575259622" t="devn when the application receives a payload, we push those facts into the session and fire rules"><y>#</y><d>2017-06-27</d><h>17:12</h><w>devn</w>when the application receives a payload, we push those facts into the session and fire rules</z><z id="t1498583590265186" t="devn but, if we have 10 concurrent requests 😬"><y>#</y><d>2017-06-27</d><h>17:13</h><w>devn</w>but, if we have 10 concurrent requests <b>😬</b></z><z id="t1498583612273652" t="devn we had been doing these serially via a queue, but design is a-changin&apos; a bit"><y>#</y><d>2017-06-27</d><h>17:13</h><w>devn</w>we had been doing these serially via a queue, but design is a-changin&apos; a bit</z><z id="t1498699031507541" t="cfleming Hi everyone - I develop Cursive, and I’ve been chatting to @zylox about the possibility of adding support for the Clara macros to Cursive."><y>#</y><d>2017-06-29</d><h>01:17</h><w>cfleming</w>Hi everyone - I develop Cursive, and I’ve been chatting to @zylox about the possibility of adding support for the Clara macros to Cursive.</z><z id="t1498699074513550" t="cfleming Since Cursive indexes source, it needs some support to understand macro forms - I’m planning to open an API for that, but that’s way off since it’s a large project."><y>#</y><d>2017-06-29</d><h>01:17</h><w>cfleming</w>Since Cursive indexes source, it needs some support to understand macro forms - I’m planning to open an API for that, but that’s way off since it’s a large project.</z><z id="t1498699116519342" t="cfleming One thing I’m interested in is being able to add support using grammars migrated from specs for macros, since I expect there will be more of them in the future."><y>#</y><d>2017-06-29</d><h>01:18</h><w>cfleming</w>One thing I’m interested in is being able to add support using grammars migrated from specs for macros, since I expect there will be more of them in the future.</z><z id="t1498699160525390" t="cfleming Has anyone investigated or thought about creating specs for the Clara macro forms? That would be a big help in adding support for them to Cursive."><y>#</y><d>2017-06-29</d><h>01:19</h><w>cfleming</w>Has anyone investigated or thought about creating specs for the Clara macro forms? That would be a big help in adding support for them to Cursive.</z><z id="t1498699181528414" t="cfleming As well as selfishly meaning that I can actually try to migrate some macro specs to Cursive - I haven’t seen any in the wild yet."><y>#</y><d>2017-06-29</d><h>01:19</h><w>cfleming</w>As well as selfishly meaning that I can actually try to migrate some macro specs to Cursive - I haven’t seen any in the wild yet.</z><z id="t1498699229534859" t="cfleming Since the macro forms also seem quite complex, it seems like having specs for them would also be generally useful to developers using Clara."><y>#</y><d>2017-06-29</d><h>01:20</h><w>cfleming</w>Since the macro forms also seem quite complex, it seems like having specs for them would also be generally useful to developers using Clara.</z><z id="t1498702306961398" t="ryanbrush @cfleming Hey, cool idea. I haven&apos;t really used specs for macros yet, but I think it would be straightforward to do so for Clara&apos;s macros. The structure is pretty well defined (the defrule and defquery macros already have a schema defining their return values) and has been stable for some time."><y>#</y><d>2017-06-29</d><h>02:11</h><w>ryanbrush</w>@cfleming Hey, cool idea. I haven&apos;t really used specs for macros yet, but I think it would be straightforward to do so for Clara&apos;s macros. The structure is pretty well defined (the defrule and defquery macros already have a schema defining their return values) and has been stable for some time.</z><z id="t1498702350967335" t="cfleming @ryanbrush Nice. So is there actually a grammar for the macros themselves anywhere? I see some railroad docs, but they seem incomplete."><y>#</y><d>2017-06-29</d><h>02:12</h><w>cfleming</w>@ryanbrush Nice. So is there actually a grammar for the macros themselves anywhere? I see some railroad docs, but they seem incomplete.</z><z id="t1498702373970216" t="cfleming The schema I guess is for the returned data, right? Not the actual macros?"><y>#</y><d>2017-06-29</d><h>02:12</h><w>cfleming</w>The schema I guess is for the returned data, right? Not the actual macros?</z><z id="t1498702387971828" t="ryanbrush We had written quite a bit of error handling code for malformed defrule macros to make it easier to debug, but we don&apos;t have a formal grammer besides the (incomplete) EBNF we used for the railroad docs.)"><y>#</y><d>2017-06-29</d><h>02:13</h><w>ryanbrush</w>We had written quite a bit of error handling code for malformed defrule macros to make it easier to debug, but we don&apos;t have a formal grammer besides the (incomplete) EBNF we used for the railroad docs.)</z><z id="t1498702411974753" t="ryanbrush Right, the schema is for the returned data."><y>#</y><d>2017-06-29</d><h>02:13</h><w>ryanbrush</w>Right, the schema is for the returned data.</z><z id="t1498702432977410" t="ryanbrush I agree this could be helpful for rule authors."><y>#</y><d>2017-06-29</d><h>02:13</h><w>ryanbrush</w>I agree this could be helpful for rule authors.</z><z id="t1498702468981826" t="cfleming Are there examples of Clara rules in any OSS projects? I don’t work with it myself so I’m not sure how a lot of the tricky cases (destructuring etc) work."><y>#</y><d>2017-06-29</d><h>02:14</h><w>cfleming</w>Are there examples of Clara rules in any OSS projects? I don’t work with it myself so I’m not sure how a lot of the tricky cases (destructuring etc) work.</z><z id="t1498702619001494" t="ryanbrush Sort of. The precent project ( https://github.com/CoNarrative/precept ) uses Clara, but is more of a wrapper so isn&apos;t the most common usage."><y>#</y><d>2017-06-29</d><h>02:16</h><w>ryanbrush</w>Sort of. The precent project (<a href="https://github.com/CoNarrative/precept" target="_blank">https://github.com/CoNarrative/precept</a>) uses Clara, but is more of a wrapper so isn&apos;t the most common usage.</z><z id="t1498702629002728" t="ryanbrush The best place for examples is probably the clara-examples project itself: https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples"><y>#</y><d>2017-06-29</d><h>02:17</h><w>ryanbrush</w>The best place for examples is probably the clara-examples project itself: <a href="https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples" target="_blank">https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples</a></z><z id="t1498702706013009" t="cfleming Thanks, I’ll take a look at those."><y>#</y><d>2017-06-29</d><h>02:18</h><w>cfleming</w>Thanks, I’ll take a look at those.</z><z id="t1498729520511383" t="flipmokid Hi, I&apos;d like to use Clara in my app which uses Component. I&apos;m currently scratching my head on how I can create a rule that when matched writes to a channel supplied by Component when the application starts. Would anyone be able to give me guidance on how I might do it?"><y>#</y><d>2017-06-29</d><h>09:45</h><w>flipmokid</w>Hi, I&apos;d like to use Clara in my app which uses Component. I&apos;m currently scratching my head on how I can create a rule that when matched writes to a channel supplied by Component when the application starts. Would anyone be able to give me guidance on how I might do it?</z><z id="t1498752034015660" t="flipmokid Okay silly me, I&apos;m adding the required components as facts and I can pull them out as needed in the rule for use in the right hand side."><y>#</y><d>2017-06-29</d><h>16:00</h><w>flipmokid</w>Okay silly me, I&apos;m adding the required components as facts and I can pull them out as needed in the rule for use in the right hand side.</z><z id="t1498752556245561" t="zylox i thought as much but i didnt know enough about Component to say anything haha"><y>#</y><d>2017-06-29</d><h>16:09</h><w>zylox</w>i thought as much but i didnt know enough about Component to say anything haha</z><z id="t1498772440688041" t="devn @cfleming FWIW, I have a cursive license, we have 100s of hand-written rules, and would be happy to be a guinea pig"><y>#</y><d>2017-06-29</d><h>21:40</h><w>devn</w>@cfleming FWIW, I have a cursive license, we have 100s of hand-written rules, and would be happy to be a guinea pig</z><z id="t1498772548718310" t="devn i could also share sanitized rules"><y>#</y><d>2017-06-29</d><h>21:42</h><w>devn</w>i could also share sanitized rules</z><z id="t1498817429227175" t="flipmokid Hopefully a quick one, I&apos;m using clara with :fact-type-fn (fn [[e a _]] a) . I&apos;m inserting a bunch of facts e.g. (rules/insert-all session [[1 :event/eventTypeId 1] [1 :state/timeElapsed 19] [2 :event/eventTypeId 1] [2 :state/timeElapsed 23]]) to match with an example rule of (def football-over-20-mins-rule (clara-dsl/parse-rule [[:event/eventTypeId [[e a v]] (= 1 v) (= ?e e)] [:state/timeElapsed [[e a v]] (&gt; v 20) (= ?time v) (= ?e e)]] (println &quot;Event &quot; ?e &quot; has gone over 20 mins with &quot; ?time))) At some point I want to retract all facts for a given &apos;e&apos;, as the event might have finished and I want to keep my facts lean. What is the best way of collecting all facts for matching &apos;e&apos; so that I can retract them all?"><y>#</y><d>2017-06-30</d><h>10:10</h><w>flipmokid</w>Hopefully a quick one, I&apos;m using clara with <code>:fact-type-fn (fn [[e a _]] a)</code>. I&apos;m inserting a bunch of facts  e.g.

<pre>(rules/insert-all session [[1 :event/eventTypeId 1]
                                          [1 :state/timeElapsed 19]
                                          [2 :event/eventTypeId 1]
                                          [2 :state/timeElapsed 23]])
</pre>

to match with an example rule of

<pre>(def football-over-20-mins-rule
  (clara-dsl/parse-rule
   [[:event/eventTypeId [[e a v]] (= 1 v) (= ?e e)]
    [:state/timeElapsed [[e a v]] (&gt; v 20) (= ?time v) (= ?e e)]]
   (println &quot;Event &quot; ?e &quot; has gone over 20 mins with &quot; ?time)))
</pre>

At some point I want to retract all facts for a given &apos;e&apos;, as the event might have finished and I want to keep my facts lean. What is the best way of collecting all facts for matching &apos;e&apos; so that I can retract them all?</z><z id="t1498826538167293" t="ryanbrush @flipmokid Your best bet is probably to write a query (via defquery) to get all facts for a given e, and then use retract to remove them. There isn&apos;t a retract-all (yet), but since it&apos;s a multi-arity function you can call it arbitrarily like (apply retract session [my-facts])"><y>#</y><d>2017-06-30</d><h>12:42</h><w>ryanbrush</w>@flipmokid Your best bet is probably to write a query (via defquery) to get all facts for a given e, and then use retract to remove them. There isn&apos;t a retract-all (yet), but since it&apos;s a multi-arity function you can call it arbitrarily like (apply retract session [my-facts])</z><z id="t1498826770228509" t="flipmokid Sorry, it&apos;s probably my bad understanding of rules but for my [e a v] fact type how would I get all e&apos;s out. As far as I understand the first part of a rule is the type (which is a) and so I&apos;m not sure how I would specify how to pull all entities of a particular number. I&apos;m currently inserting a fact [e :event/retract true] and then trying to find these [:event/retract [[e a v]] (= v true) (= ?e e)] but not sure how to get all matching facts that have the same e"><y>#</y><d>2017-06-30</d><h>12:46</h><w>flipmokid</w>Sorry, it&apos;s probably my bad understanding of rules but for my [e a v] fact type how would I get all e&apos;s out. As far as I understand the first part of a rule is the type (which is a) and so I&apos;m not sure how I would specify how to pull all entities of a particular number.

I&apos;m currently inserting a fact [e :event/retract true] and then trying to find these

[:event/retract [[e a v]] (= v true) (= ?e e)] but not sure how to get all matching facts that have the same e</z><z id="t1498827539440917" t="flipmokid I guess I just need someone to help me understand how to write a rule/query that can pull the e&apos;s (it&apos;s having to write the type at the start that is throwing me). I&apos;m not sure if I can check for the :event/retract fact and then have an accumulator to get all e&apos;s for it"><y>#</y><d>2017-06-30</d><h>12:58</h><w>flipmokid</w>I guess I just need someone to help me understand how to write a rule/query that can pull the e&apos;s (it&apos;s having to write the type at the start that is throwing me). I&apos;m not sure if I can check for the :event/retract fact and then have an accumulator to get all e&apos;s for it</z><z id="t1498828102614147" t="ryanbrush I think I see the sticking point here. You&apos;ll probably want to match a query on a special &quot;parent&quot; type of all (you can use clojure.core/derive to declare a parent type, which Clara will honor if it&apos;s done before the session is created.) Then the query can have a predicate to match on whatever subset you want."><y>#</y><d>2017-06-30</d><h>13:08</h><w>ryanbrush</w>I think I see the sticking point here. You&apos;ll probably want to match a query on a special &quot;parent&quot; type of all (you can use clojure.core/derive to declare a parent type, which Clara will honor if it&apos;s done before the session is created.) Then the query can have a predicate to match on whatever subset you want.</z><z id="t1498828169634719" t="ryanbrush ...or I suppose you could just have your fact match on java.lang.Object (assuming your running the Clojure rather than the ClojureScript version) and have your predicate check that."><y>#</y><d>2017-06-30</d><h>13:09</h><w>ryanbrush</w>...or I suppose you could just have your fact match on java.lang.Object (assuming your running the Clojure rather than the ClojureScript version) and have your predicate check that.</z><z id="t1498829516075420" t="flipmokid I&apos;m not sure derive will be of much help. For a fact [e a v] e will always be a number (the id of the sporting event) which is not known in advance, a will be the attribute and v can be anything e.g. [1 :state/timeElapsed 19] So do you think if I wanted to stick with my tuple-shaped facts it would be difficult to extract all e s of the same value if my fact-type-fn is (fn [[e a v]] a) ? Out of interest do you know how Precept handles retractions of its tupled shaped facts?"><y>#</y><d>2017-06-30</d><h>13:31</h><w>flipmokid</w>I&apos;m not sure derive will be of much help. For a fact <code>[e a v]</code> <code>e</code> will always be a number (the id of the sporting event) which is not known in advance, <code>a</code> will be the attribute and <code>v</code> can be anything e.g. [1 :state/timeElapsed 19]

So do you think if I wanted to stick with my tuple-shaped facts it would be difficult to extract all <code>e</code>s of the same value if my fact-type-fn is <code>(fn [[e a v]] a)</code>?

Out of interest do you know how Precept handles retractions of its tupled shaped facts?</z><z id="t1498829791171323" t="ryanbrush If you know the values of a ahead of time then it derive could work, but might be painful to derive all of that. But a defquery approach might work like:"><y>#</y><d>2017-06-30</d><h>13:36</h><w>ryanbrush</w>If you know the values of a ahead of time then it derive could work, but might be painful to derive all of that. But a defquery approach might work like:</z><z id="t1498829858194801" t="ryanbrush `(defquery [:e-to-remove] [Object [my-tuple] (= ?e-to-remove (first my-tuple))])"><y>#</y><d>2017-06-30</d><h>13:37</h><w>ryanbrush</w><code></code>`(defquery [:e-to-remove] [Object [my-tuple] (= ?e-to-remove (first my-tuple))])</z><z id="t1498829879202177" t="ryanbrush Haven&apos;t actually tried that, but it&apos;s an idea to try with. I&apos;m not familiar with how Precept handles this sort of thing."><y>#</y><d>2017-06-30</d><h>13:37</h><w>ryanbrush</w>Haven&apos;t actually tried that, but it&apos;s an idea to try with. I&apos;m not familiar with how Precept handles this sort of thing.</z><z id="t1498829935221798" t="flipmokid That looks interesting, let me give it a go"><y>#</y><d>2017-06-30</d><h>13:38</h><w>flipmokid</w>That looks interesting, let me give it a go</z><z id="t1498830103283213" t="ryanbrush Sounds good. There are some steps I left out...you&apos;ll want to return the full tuples from the query, for instance, so they can be retracted."><y>#</y><d>2017-06-30</d><h>13:41</h><w>ryanbrush</w>Sounds good. There are some steps I left out...you&apos;ll want to return the full tuples from the query, for instance, so they can be retracted.</z><z id="t1498831116664196" t="flipmokid Actually, I&apos;m not sure the Object part will match as I&apos;m not using the type function (please let me know if I&apos;m being stupid though, I often am!) (defquery [:e-to-remove] [Object [my-tuple] (= ?e-to-remove (first my-tuple))])"><y>#</y><d>2017-06-30</d><h>13:58</h><w>flipmokid</w>Actually, I&apos;m not sure the Object part will match as I&apos;m not using the type function (please let me know if I&apos;m being stupid though, I often am!)

(defquery [:e-to-remove] [Object [my-tuple] (= ?e-to-remove (first my-tuple))])</z><z id="t1498831802937401" t="ryanbrush Ah, of course. You&apos;ll need a custom ancestors function to complement the custom type function. There is an example here: http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2017-06-30</d><h>14:10</h><w>ryanbrush</w>Ah, of course. You&apos;ll need a custom ancestors function to complement the custom type function. There is an example here: <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1498831838951854" t="ryanbrush So your custom ancestor could just return :all-facts if you wanted to match everything. 😉"><y>#</y><d>2017-06-30</d><h>14:10</h><w>ryanbrush</w>So your custom ancestor could just return :all-facts if you wanted to match everything. <b>😉</b></z><z id="t1498831872964948" t="ryanbrush (:all-facts is just an arbitrary keyword here that could be returned by the ancestors function.)"><y>#</y><d>2017-06-30</d><h>14:11</h><w>ryanbrush</w>(:all-facts is just an arbitrary keyword here that could be returned by the ancestors function.)</z><z id="t1498834095057825" t="flipmokid Ah okay. I&apos;ll try that. Thanks for your help so far, I really appreciate it"><y>#</y><d>2017-06-30</d><h>14:48</h><w>flipmokid</w>Ah okay. I&apos;ll try that. Thanks for your help so far, I really appreciate it</z><z id="t1498836138916786" t="flipmokid Brilliant that worked! (def retractions-rule (clara-dsl/parse-rule [[:event/retract [[e a v]] (= v true) (= e ?e)] [?elems &lt;- (acc/all) :from [::all [[e _ _]] (= e ?e)]]] (println &quot;RETRACTION MATCHED &quot; ?elems))) Many thanks for your help"><y>#</y><d>2017-06-30</d><h>15:22</h><w>flipmokid</w>Brilliant that worked!

<pre>(def retractions-rule
  (clara-dsl/parse-rule
   [[:event/retract [[e a v]] (= v true) (= e ?e)]
    [?elems &lt;- (acc/all) :from [::all [[e _ _]] (= e ?e)]]]
   (println &quot;RETRACTION MATCHED &quot; ?elems)))
</pre>
Many thanks for your help</z><z id="t1498836815192456" t="ryanbrush Nice!"><y>#</y><d>2017-06-30</d><h>15:33</h><w>ryanbrush</w>Nice!</z><z id="t1499000793919491" t="ryanbrush Just released clara-rules 0.15.1! Details in the change log: https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0151"><y>#</y><d>2017-07-02</d><h>13:06</h><w>ryanbrush</w>Just released clara-rules 0.15.1! Details in the change log: <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0151" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0151</a></z><z id="t1499348270876070" t="souenzzo Can I write a rule that check if there is some other rule that match facts of type x"><y>#</y><d>2017-07-06</d><h>13:37</h><w>souenzzo</w>Can I write a rule that check if <code>there is some other rule that match facts of type x</code></z><z id="t1499348273877551" t="souenzzo ?"><y>#</y><d>2017-07-06</d><h>13:37</h><w>souenzzo</w>?</z><z id="t1499349661698443" t="zylox unless you fed rules into the session as facts, not that i know of"><y>#</y><d>2017-07-06</d><h>14:01</h><w>zylox</w>unless you fed rules into the session as facts, not that i know of</z><z id="t1499349718734682" t="zylox if you had the rules stored somewhere your right hand side could execute some sort of static introspection i guess"><y>#</y><d>2017-07-06</d><h>14:01</h><w>zylox</w>if you had the rules stored somewhere your right hand side could execute some sort of static introspection i guess</z><z id="t1499475203628554" t="dragoncube Withing REPL are newly defined rules are picking up? I create session with mk-session and :cache false"><y>#</y><d>2017-07-08</d><h>00:53</h><w>dragoncube</w>Withing REPL are newly defined rules are picking up? I create session with mk-session and :cache false</z><z id="t1499477302835704" t="ryanbrush mk-session should pick up new rules in the REPL. It will only look in the current namespace, though, unless you are explicitly passing namespaces."><y>#</y><d>2017-07-08</d><h>01:28</h><w>ryanbrush</w>mk-session should pick up new rules in the REPL. It will only look in the current namespace, though, unless you are explicitly passing namespaces.</z><z id="t1499495667124166" t="dragoncube @ryanbrush so I need to call mk-session again? if so, is there any way to transfer facts from one session to another? or maybe fire-rules would be enough?"><y>#</y><d>2017-07-08</d><h>06:34</h><w>dragoncube</w>@ryanbrush so I need to call mk-session again? if so, is there any way to transfer facts from one session to another? or maybe fire-rules would be enough?</z><z id="t1499525700142665" t="ryanbrush You&apos;ll need to pass in your facts into the new session again. Clara won&apos;t do this automatically, but I usually reload the facts or keep them in a list."><y>#</y><d>2017-07-08</d><h>14:55</h><w>ryanbrush</w>You&apos;ll need to pass in your facts into the new session again. Clara won&apos;t do this automatically, but I usually reload the facts or keep them in a list.</z><z id="t1499547807116234" t="dragoncube I see, so I need to write small wrapper for insert-fact, retract-fact which would store facts in separate collection. Then use this collection then I need to re-init session."><y>#</y><d>2017-07-08</d><h>21:03</h><w>dragoncube</w>I see, so I need to write small wrapper for insert-fact, retract-fact which would store facts in separate collection. Then use this collection then I need to re-init session.</z><z id="t1499549248225562" t="ryanbrush Yes, that would do it."><y>#</y><d>2017-07-08</d><h>21:27</h><w>ryanbrush</w>Yes, that would do it.</z><z id="t1499550257299068" t="dragoncube Thanks!"><y>#</y><d>2017-07-08</d><h>21:44</h><w>dragoncube</w>Thanks!</z><z id="t1499966567470134" t="fmjrey Hi, new to clara here, and having difficulties with query parameters, is there an example of query with parameters that I could look at somewhere?"><y>#</y><d>2017-07-13</d><h>17:22</h><w>fmjrey</w>Hi, new to clara here, and having difficulties with query parameters, is there an example of query with parameters that I could look at somewhere?</z><z id="t1499967120794597" t="nickowsy hey @fmjrey, have you taken a look at https://github.com/cerner/clara-examples ?"><y>#</y><d>2017-07-13</d><h>17:32</h><w>nickowsy</w>hey @fmjrey, have you taken a look at <a href="https://github.com/cerner/clara-examples" target="_blank">https://github.com/cerner/clara-examples</a>?</z><z id="t1499967161819254" t="fmjrey yes I did, unless I missed it I have only seen query without params"><y>#</y><d>2017-07-13</d><h>17:32</h><w>fmjrey</w>yes I did, unless I missed it I have only seen query without params</z><z id="t1499967305903004" t="nickowsy ahh, that could be. A very simple example (defquery get-promotions &quot;Query to find promotions for the purchase.&quot; [:?type] [?promotion &lt;- Promotion (= ?type type)])"><y>#</y><d>2017-07-13</d><h>17:35</h><w>nickowsy</w>ahh, that could be.  A very simple example <pre>(defquery get-promotions
  &quot;Query to find promotions for the purchase.&quot;
  [:?type]
  [?promotion &lt;- Promotion (= ?type type)])</pre></z><z id="t1499967316909165" t="nickowsy (query session get-promotions :?type :lunch)"><y>#</y><d>2017-07-13</d><h>17:35</h><w>nickowsy</w><pre>(query session get-promotions :?type :lunch)</pre></z><z id="t1499967349928401" t="nickowsy that example is from the docs. Are you trying to do something more complicated?"><y>#</y><d>2017-07-13</d><h>17:35</h><w>nickowsy</w>that example is from the docs. Are you trying to do something more complicated?</z><z id="t1499967384949041" t="fmjrey yeah I saw that example, and now looking at this: https://github.com/cerner/clara-rules/blob/cbecbdf916625a46ee93e7c84ed411aab3f1dbc1/src/test/clojure/clara/test_java.clj#L51"><y>#</y><d>2017-07-13</d><h>17:36</h><w>fmjrey</w>yeah I saw that example, and now looking at this:
<a href="https://github.com/cerner/clara-rules/blob/cbecbdf916625a46ee93e7c84ed411aab3f1dbc1/src/test/clojure/clara/test_java.clj#L51" target="_blank">https://github.com/cerner/clara-rules/blob/cbecbdf916625a46ee93e7c84ed411aab3f1dbc1/src/test/clojure/clara/test_java.clj#L51</a></z><z id="t1499967428974844" t="fmjrey this is a java based example, which looks like it uses strings as map keys, will try that now"><y>#</y><d>2017-07-13</d><h>17:37</h><w>fmjrey</w>this is a java based example, which looks like it uses strings as map keys, will try that now</z><z id="t1499972876179787" t="fmjrey I think I found the issue, I use query variables in some nested part of the expression, as the long error message says."><y>#</y><d>2017-07-13</d><h>19:07</h><w>fmjrey</w>I think I found the issue, I use query variables in some nested part of the expression, as the long error message says.</z><z id="t1499972940213620" t="fmjrey Basically this does not work: (defquery get-feature [:?type :?name :?data] [?feature &lt;- Feature (= descriptor [?type ?name ?data])]) "><y>#</y><d>2017-07-13</d><h>19:09</h><w>fmjrey</w>Basically this does not work:
<pre>(defquery get-feature
  [:?type :?name :?data]
  [?feature &lt;- Feature (= descriptor [?type ?name ?data])])
</pre></z><z id="t1499972987238507" t="fmjrey But this does: (defquery get-feature [:?d] [?feature &lt;- Feature (= descriptor ?d)]) "><y>#</y><d>2017-07-13</d><h>19:09</h><w>fmjrey</w>But this does:
<pre>(defquery get-feature
  [:?d]
  [?feature &lt;- Feature (= descriptor ?d)])
</pre></z><z id="t1499973042267318" t="fmjrey Thanks @nickowsy for trying 🙂"><y>#</y><d>2017-07-13</d><h>19:10</h><w>fmjrey</w>Thanks @nickowsy for trying <b>🙂</b></z><z id="t1499973236368632" t="nickowsy :+1:"><y>#</y><d>2017-07-13</d><h>19:13</h><w>nickowsy</w><b>:+1:</b></z><z id="t1499982815197746" t="wparker @fmjrey the params have to be in the query conditions (defquery get-feature [:?type :?name :?data] [?feature &lt;- Feature (= descriptor [?type ?name ?data])]) is trying to use bindings in the Feature condition without creating them"><y>#</y><d>2017-07-13</d><h>21:53</h><w>wparker</w>@fmjrey the params have to be in the query conditions <pre>(defquery get-feature
  [:?type :?name :?data]
  [?feature &lt;- Feature (= descriptor [?type ?name ?data])]) </pre> is trying to use bindings in the Feature condition without creating them</z><z id="t1499982828202879" t="wparker the use in the params doesn’t create them, that is for indexing into the query results later"><y>#</y><d>2017-07-13</d><h>21:53</h><w>wparker</w>the use in the params doesn’t create them, that is for indexing into the query results later</z><z id="t1499982935243888" t="wparker Basically the query params won’t make an otherwise-invalid query valid, they just control how you’ll view the data later when using the query results"><y>#</y><d>2017-07-13</d><h>21:55</h><w>wparker</w>Basically the query params won’t make an otherwise-invalid query valid, they just control how you’ll view the data later when using the query results</z><z id="t1499983039284009" t="wparker So in the “promotion type” example in the doc, you’ll provide a type to query for, and you’ll only get results back of that type; without the param you’d get back other types as well"><y>#</y><d>2017-07-13</d><h>21:57</h><w>wparker</w>So in the “promotion type” example in the doc, you’ll provide a type to query for, and you’ll only get results back of that type; without the param you’d get back other types as well</z><z id="t1499983057290843" t="wparker This is the key line of code: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1960"><y>#</y><d>2017-07-13</d><h>21:57</h><w>wparker</w>This is the key line of code: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1960" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1960</a></z><z id="t1499989225170834" t="dadair Is there a way to react to retractions? I&apos;m using facts to generate tree manipulation functions (i.e., if FactA, AddChildToSomeTree), and want to be able to remove that tree node if the Fact is retracted"><y>#</y><d>2017-07-13</d><h>23:40</h><w>dadair</w>Is there a way to react to retractions? I&apos;m using facts to generate tree manipulation functions (i.e., if FactA, AddChildToSomeTree), and want to be able to remove that tree node if the Fact is retracted</z><z id="t1499993416108925" t="dadair Sorry I should add that these are automatic retractions of derived/sourced facts"><y>#</y><d>2017-07-14</d><h>00:50</h><w>dadair</w>Sorry I should add that these are automatic retractions of derived/sourced facts</z><z id="t1500044094391412" t="wparker @dadair it sounds like you’re describing truth maintenance so perhaps that will meet your needs http://www.clara-rules.org/docs/truthmaint/"><y>#</y><d>2017-07-14</d><h>14:54</h><w>wparker</w>@dadair it sounds like you’re describing truth maintenance so perhaps that will meet your needs <a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a></z><z id="t1500319890026048" t="wparker clara-rules 0.15.2 is released and on Clojars. This was a fix release for a bug in the distinct accumulator."><y>#</y><d>2017-07-17</d><h>19:31</h><w>wparker</w>clara-rules 0.15.2 is released and on Clojars.  This was a fix release for a bug in the distinct accumulator.</z><z id="t1500567004613661" t="misha greetings! What can I read on combining event sourcing with rule engines? Or about any rules&lt;-&gt; (finite) state machines transitions."><y>#</y><d>2017-07-20</d><h>16:10</h><w>misha</w>greetings! What can I read on combining event sourcing with rule engines? Or about any <code>rules&lt;-&gt; (finite) state machines</code> transitions.</z><z id="t1500936948345390" t="wparker @misha you might try the Google Groups mailing list as well, I know some people have considered using Clara for event processing before. Regarding finite state machines, keep in mind that Clara supports arbitrary code, notably in the RHS (consequences) of rules, so the ability to introspect is limited if your application doesn’t add further restrictions."><y>#</y><d>2017-07-24</d><h>22:55</h><w>wparker</w>@misha you might try the Google Groups mailing list as well, I know some people have considered using Clara for event processing before.  Regarding finite state machines, keep in mind that Clara supports arbitrary code, notably in the RHS (consequences) of rules, so the ability to introspect is limited if your application doesn’t add further restrictions.</z><z id="t1500970596617619" t="misha @wparker thanks, will check it out. to have a real life value, FSMs need to support arbitrary code (i/o) execution as part (or as a consequence) of the state&apos;s transitions as well, so that comes down to a design decisions in both cases. In the exercise app I am (re)writing now - html5 video/audio tags are basically i/o, as far as the rest of the buttons in UI are concerned, despite those tags being their own FSMs."><y>#</y><d>2017-07-25</d><h>08:16</h><w>misha</w>@wparker thanks, will check it out.
to have a real life value, FSMs need to support arbitrary code (i/o) execution as part (or as a consequence) of the state&apos;s transitions as well, so that comes down to a design decisions in both cases.
In the exercise app I am (re)writing now - html5 video/audio tags are basically i/o, as far as the rest of the buttons in UI are concerned, despite those tags being their own FSMs.</z><z id="t1501104444522141" t="wparker @U051HUZLD I was thinking of mainly what types the rules could insert; given an arbitrary set of rules one can’t infer which other rules a given rule could trigger. It is possible to add metadata of some kind specifying this or to parse it if you restrict the RHS code you write to something you can reliably parse. This seemed possibly relevant if you were trying to translate rules to a FSM, specifically w.r.t. the allowed state transitions."><y>#</y><d>2017-07-26</d><h>21:27</h><r>wparker</r>@U051HUZLD I was thinking of mainly what types the rules could insert; given an arbitrary set of rules one can’t infer which other rules a given rule could trigger.  It is possible to add metadata of some kind specifying this or to parse it if you restrict the RHS code you write to something you can reliably parse.  This seemed possibly relevant if you were trying to translate rules to a FSM, specifically w.r.t. the allowed state transitions.</z><z id="t1500998915773029" t="iku000888 Is it possible to use protocol methods in the left hand side of rules?"><y>#</y><d>2017-07-25</d><h>16:08</h><w>iku000888</w>Is it possible to use protocol methods in the left hand side of rules?</z><z id="t1500998950795420" t="iku000888 I have a vague feeling it would violate clara&apos;s design but cannot articulate why 🙂"><y>#</y><d>2017-07-25</d><h>16:09</h><w>iku000888</w>I have a vague feeling it would violate clara&apos;s design but cannot articulate why <b>🙂</b></z><z id="t1500999160932944" t="ryanbrush Yes, the LHS supports arbitrary Clojure expressions, including protocol methods."><y>#</y><d>2017-07-25</d><h>16:12</h><w>ryanbrush</w>Yes, the LHS supports arbitrary Clojure expressions, including protocol methods.</z><z id="t1500999621223019" t="iku000888 Would you be kind to give an example?"><y>#</y><d>2017-07-25</d><h>16:20</h><w>iku000888</w>Would you be kind to give an example?</z><z id="t1500999666250502" t="iku000888 Having trouble wrapping my head around how to refer to the instance showing up in the LHS"><y>#</y><d>2017-07-25</d><h>16:21</h><w>iku000888</w>Having trouble wrapping my head around how to refer to the instance showing up in the LHS</z><z id="t1500999740297338" t="iku000888 (defprotocol IFoo (test-foo [this])) (defrule is-foo [IFoo (test-foo ?not sure how to express?)] =&gt;...)"><y>#</y><d>2017-07-25</d><h>16:22</h><w>iku000888</w><pre>(defprotocol IFoo
  (test-foo [this]))

(defrule is-foo
  [IFoo (test-foo ?not sure how to express?)]
  =&gt;...)</pre></z><z id="t1500999784324767" t="iku000888 @ryanbrush Thanks for the help in advance 🙂"><y>#</y><d>2017-07-25</d><h>16:23</h><w>iku000888</w>@ryanbrush Thanks for the help in advance <b>🙂</b></z><z id="t1500999876381627" t="ryanbrush @iku000888 Ahh, I thought you meant calling protocol-based methods on the LHS. The type the rules matches needs to be an actual type, either a Java type or a Clojure type via deftype."><y>#</y><d>2017-07-25</d><h>16:24</h><w>ryanbrush</w>@iku000888 Ahh, I thought you meant calling protocol-based methods on the LHS. The type the rules matches needs to be an actual type, either a Java type or a Clojure type via deftype.</z><z id="t1500999913404868" t="ryanbrush (The one exception is customized &quot;types&quot; discussed here, but this probably isn&apos;t applicable to your discussion: http://www.clara-rules.org/docs/fact_type_customization/)"><y>#</y><d>2017-07-25</d><h>16:25</h><w>ryanbrush</w>(The one exception is customized &quot;types&quot; discussed here, but this probably isn&apos;t applicable to your discussion: <a href="http://www.clara-rules.org/docs/fact_type_customization/)" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/)</a></z><z id="t1500999964436506" t="ryanbrush One correction: I meant clojure.core/derive rather than deftype above."><y>#</y><d>2017-07-25</d><h>16:26</h><w>ryanbrush</w>One correction: I meant clojure.core/derive rather than deftype above.</z><z id="t1501000015468909" t="iku000888 I think I understand"><y>#</y><d>2017-07-25</d><h>16:26</h><w>iku000888</w>I think I understand</z><z id="t1501000072503938" t="iku000888 Just thought at first glance I could reify a bunch of stuff and passing it through rules would be a usecase"><y>#</y><d>2017-07-25</d><h>16:27</h><w>iku000888</w>Just thought at first glance I could reify a bunch of stuff and passing it through rules would be a usecase</z><z id="t1501000131540435" t="iku000888 Thanks for clarifying! Much appreciate your time."><y>#</y><d>2017-07-25</d><h>16:28</h><w>iku000888</w>Thanks for clarifying! Much appreciate your time.</z><z id="t1501000138544419" t="iku000888 🙇"><y>#</y><d>2017-07-25</d><h>16:28</h><w>iku000888</w><b>🙇</b></z><z id="t1501000397706730" t="iku000888 (defprotocol IFoo (test-foo [this])) (deftype Foo [] IFoo (test-foo [this] true)) (defrule is-foo [Foo (test-foo ?not sure how to express?)] =&gt; (println &quot;is a foo&quot;))"><y>#</y><d>2017-07-25</d><h>16:33</h><w>iku000888</w><pre>(defprotocol IFoo
  (test-foo [this]))

(deftype Foo []
  IFoo
  (test-foo [this] true))

(defrule is-foo
  [Foo (test-foo ?not sure how to express?)]
  =&gt; (println &quot;is a foo&quot;))</pre></z><z id="t1501000432728706" t="iku000888 Wait, so if it is an actual type I can invoke protocol methods?"><y>#</y><d>2017-07-25</d><h>16:33</h><w>iku000888</w>Wait, so if it is an actual type I can invoke protocol methods?</z><z id="t1501105196870531" t="wparker Heads up about something potentially tricky: If you’re on the JVM when you create a protocol, behind the scenes Clojure creates a corresponding Java interface of the same name. An interface is a type that you can write rules against, but it might not do what you expect. Only types that Clojure knows satisfy the protocol at the time of their creation will implement the interface. For example:"><y>#</y><d>2017-07-26</d><h>21:39</h><r>wparker</r>Heads up about something potentially tricky: If you’re on the JVM when you create a protocol, behind the scenes Clojure creates a corresponding Java interface of the same name.  An interface is a type that you can write rules against, but it might not do what you expect.  Only types that Clojure knows satisfy the protocol at the time of their creation will implement the interface.  For example:</z><z id="t1501105220881389" t="wparker ` user=&gt; (defprotocol MyProtocol (proto-method [_])) MyProtocol user=&gt; (defrecord MyRecord1 [] MyProtocol (proto-method [_] &quot;Hello World&quot;)) user.MyRecord1 user=&gt; (defrecord MyRecord2 []) user.MyRecord2 user=&gt; (extend-type MyRecord2 MyProtocol (proto-method [_] &quot;Hi World&quot;)) nil user=&gt; (proto-method (-&gt;MyRecord1)) &quot;Hello World&quot; user=&gt; (proto-method (-&gt;MyRecord2)) &quot;Hi World&quot; user=&gt; (instance? user.MyProtocol (-&gt;MyRecord1)) true user=&gt; (instance? user.MyProtocol (-&gt;MyRecord2)) false `"><y>#</y><d>2017-07-26</d><h>21:40</h><r>wparker</r><pre>` user=&gt; (defprotocol MyProtocol (proto-method [_]))
MyProtocol
user=&gt; (defrecord MyRecord1 [] MyProtocol (proto-method [_] &quot;Hello World&quot;))
user.MyRecord1
user=&gt; (defrecord MyRecord2 [])
user.MyRecord2
user=&gt; (extend-type MyRecord2 MyProtocol (proto-method [_] &quot;Hi World&quot;))
nil
user=&gt; (proto-method (-&gt;MyRecord1))
&quot;Hello World&quot;
user=&gt; (proto-method (-&gt;MyRecord2))
&quot;Hi World&quot;
user=&gt; (instance? user.MyProtocol (-&gt;MyRecord1))
true
user=&gt; (instance? user.MyProtocol (-&gt;MyRecord2))
false </pre>`</z><z id="t1501105378952224" t="wparker In another ns you could potentially import the interface rather than the protocol depending on how you set up your ns header i.e. import vs require on it"><y>#</y><d>2017-07-26</d><h>21:42</h><r>wparker</r>In another ns you could potentially import the interface rather than the protocol depending on how you set up your ns header i.e. import vs require on it</z><z id="t1501105421970419" t="wparker @iku000888"><y>#</y><d>2017-07-26</d><h>21:43</h><r>wparker</r>@iku000888</z><z id="t1501121275280836" t="iku000888 @wparker thanks! Did not know about that."><y>#</y><d>2017-07-27</d><h>02:07</h><r>iku000888</r>@wparker thanks! Did not know about that.</z><z id="t1501000439733499" t="iku000888 @ryanbrush"><y>#</y><d>2017-07-25</d><h>16:33</h><w>iku000888</w>@ryanbrush</z><z id="t1501000543797508" t="ryanbrush Yes, if Foo is a type, you should be able to invoke the test-foo protocol method on it like you show."><y>#</y><d>2017-07-25</d><h>16:35</h><w>ryanbrush</w>Yes, if Foo is a type, you should be able to invoke the test-foo protocol method on it like you show.</z><z id="t1501000558807039" t="iku000888 (defrule is-foo [Foo (test-foo this)] =&gt; (println &quot;is a foo&quot;))"><y>#</y><d>2017-07-25</d><h>16:35</h><w>iku000888</w>(defrule is-foo
  [Foo (test-foo this)]
  =&gt; (println &quot;is a foo&quot;))</z><z id="t1501000574816346" t="iku000888 Works!"><y>#</y><d>2017-07-25</d><h>16:36</h><w>iku000888</w>Works!</z><z id="t1501000643858314" t="iku000888 Thanks again and sorry for the noob noise 🙇"><y>#</y><d>2017-07-25</d><h>16:37</h><w>iku000888</w>Thanks again and sorry for the noob noise <b>🙇</b></z><z id="t1501000662870104" t="ryanbrush Sure thing! I&apos;m glad it works for you."><y>#</y><d>2017-07-25</d><h>16:37</h><w>ryanbrush</w>Sure thing! I&apos;m glad it works for you.</z><z id="t1501000701893328" t="ryanbrush Just be aware you might have to reload your rules if you redefine the types in a REPL, since the type will change when you do that. 😉"><y>#</y><d>2017-07-25</d><h>16:38</h><w>ryanbrush</w>Just be aware you might have to reload your rules if you redefine the types in a REPL, since the type will change when you do that. <b>😉</b></z><z id="t1501000712899627" t="iku000888 :+1:"><y>#</y><d>2017-07-25</d><h>16:38</h><w>iku000888</w><b>:+1:</b></z><z id="t1501002431940768" t="iku000888 @ryanbrush blogged about my first glance of clara-rules (for people in Japan) and thanked you there. Hope that is okay."><y>#</y><d>2017-07-25</d><h>17:07</h><w>iku000888</w>@ryanbrush blogged about my first glance of clara-rules (for people in Japan) and thanked you there. Hope that is okay.</z><z id="t1501002433941944" t="iku000888 http://qiita.com/iku000888/items/72525cd34cd3c0b44b31"><y>#</y><d>2017-07-25</d><h>17:07</h><w>iku000888</w><a href="http://qiita.com/iku000888/items/72525cd34cd3c0b44b31" target="_blank">http://qiita.com/iku000888/items/72525cd34cd3c0b44b31</a></z><z id="t1501006466421717" t="ryanbrush @iku000888 Nice! Thanks for blogging about our little project. 😉"><y>#</y><d>2017-07-25</d><h>18:14</h><w>ryanbrush</w>@iku000888 Nice! Thanks for blogging about our little project. <b>😉</b></z><z id="t1501087876094536" t="iku000888 The first impression motivated me to learn more abt clara-rules and thus another blogpost with a personally cooked up example http://qiita.com/iku000888/items/17ad5f7fa2f0da069997#_reference-37f1c943ec03175da6b6"><y>#</y><d>2017-07-26</d><h>16:51</h><w>iku000888</w>The first impression motivated me to learn more abt clara-rules and thus another blogpost with a personally cooked up example <a href="http://qiita.com/iku000888/items/17ad5f7fa2f0da069997#_reference-37f1c943ec03175da6b6" target="_blank">http://qiita.com/iku000888/items/17ad5f7fa2f0da069997#_reference-37f1c943ec03175da6b6</a></z><z id="t1501189679211698" t="iku000888 Man one can write so many blogs out of clara-rules! (This one shows it can be used for cross entity join logic) http://qiita.com/iku000888/items/7bb53bd3af51ea2e9e68"><y>#</y><d>2017-07-27</d><h>21:07</h><w>iku000888</w>Man one can write so many blogs out of clara-rules! (This one shows it can be used for cross entity join logic) <a href="http://qiita.com/iku000888/items/7bb53bd3af51ea2e9e68" target="_blank">http://qiita.com/iku000888/items/7bb53bd3af51ea2e9e68</a></z><z id="t1501189761251718" t="iku000888 I am about to start this project with a gigantic hari-bally specification and feel like clara-rules is a great match. Going to explore more!"><y>#</y><d>2017-07-27</d><h>21:09</h><w>iku000888</w>I am about to start this project with a gigantic hari-bally specification and feel like clara-rules is a great match. Going to explore more!</z><z id="t1501267845718325" t="nickowsy hi, I&apos;m new to clara and I&apos;m having a bit of trouble understanding clara&apos;s durability. I&apos;m serialize the data, storing the rule base separately. When I restore everything, insert new facts, and fire-rules...my rules are not running again. Rules fire great if I use the original session. i.e. not the one that was restored. I have been looking at https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_durability.clj and my broken test is at https://github.com/nfox2004/clara-durability/blob/master/test/clara_durability_help/core_test.clj . Any suggestions would be awesome! thanks"><y>#</y><d>2017-07-28</d><h>18:50</h><w>nickowsy</w>hi, I&apos;m new to clara and I&apos;m having a bit of trouble understanding  clara&apos;s durability.  I&apos;m serialize the data, storing the rule base separately. When I restore everything, insert new facts, and fire-rules...my rules are not running again. Rules fire great if I use the original session. i.e. not the one that was restored. I have been looking at <a href="https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_durability.clj" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_durability.clj</a>  and my broken test is at <a href="https://github.com/nfox2004/clara-durability/blob/master/test/clara_durability_help/core_test.clj" target="_blank">https://github.com/nfox2004/clara-durability/blob/master/test/clara_durability_help/core_test.clj</a>.  Any suggestions would be awesome! thanks</z><z id="t1501270683091449" t="wparker @nickowsy from a quick glance over your test I see your original session has a custom :fact-type-fn. You’ll need to supply the same :fact-type-fn that the original function had when deserializing the rulebase. See the 2-argument version of deserialize-rulebase: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability.clj#L653"><y>#</y><d>2017-07-28</d><h>19:38</h><w>wparker</w>@nickowsy from a quick glance over your test I see your original session has a custom :fact-type-fn.   You’ll need to supply the same :fact-type-fn that the original function had when deserializing the rulebase.  See the 2-argument version of deserialize-rulebase: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability.clj#L653" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability.clj#L653</a></z><z id="t1501270713105385" t="wparker So something like (deserialize-rulebase session-serializer {:fact-type-fn your-fact-type-function})"><y>#</y><d>2017-07-28</d><h>19:38</h><w>wparker</w>So something like (deserialize-rulebase session-serializer {:fact-type-fn your-fact-type-function})</z><z id="t1501270863174071" t="wparker The reason it is that way is that arbitrary Clojure function objects aren’t serializable, so you have to either impose some kind of restriction on the functions used that gives you serializability or require the user to handle it; we went with the latter"><y>#</y><d>2017-07-28</d><h>19:41</h><w>wparker</w>The reason it is that way is that arbitrary Clojure function objects aren’t serializable, so you have to either impose some kind of restriction on the functions used that gives you serializability or require the user to handle it; we went with the latter</z><z id="t1501272701017051" t="nickowsy @wparker thanks a ton! makes total sense 🙂"><y>#</y><d>2017-07-28</d><h>20:11</h><w>nickowsy</w>@wparker thanks a ton! makes total sense <b>🙂</b></z><z id="t1501282888484138" t="dadair Not sure if this question goes against the design of fact-based systems, but is there a way to &quot;update&quot; a fact? That is, say we insert -&gt;Fact x , and then we insert -&gt;Fact y , is it possible to only get a single Fact with updated value y in a query?"><y>#</y><d>2017-07-28</d><h>23:01</h><w>dadair</w>Not sure if this question goes against the design of fact-based systems, but is there a way to &quot;update&quot; a fact? That is, say we insert <code>-&gt;Fact x</code>, and then we insert <code>-&gt;Fact y</code>, is it possible to only get a single <code>Fact</code> with updated value <code>y</code> in a query?</z><z id="t1501283137536753" t="dadair concrete example: (-&gt; (handle test-file test-action) (r/query fields-for :?formRef &quot;/forms/aae-form&quot;)) =&gt; ({:?formRef &quot;/forms/aae-form&quot;, :?fieldRef &quot;/forms/aae-form/data/order/reason&quot;, :?field #{#justice.rules.forms.FormField{:formRef &quot;/forms/aae-form&quot;, :fieldRef &quot;/forms/aae-form/data/order/reason&quot;, :descriptor {:type &quot;VALUE&quot;, :valueType &quot;STRING&quot;, :value &quot;foo&quot;, :constraints {:minLength 1, :required true}}} #justice.rules.forms.FormField{:formRef &quot;/forms/aae-form&quot;, :fieldRef &quot;/forms/aae-form/data/order/reason&quot;, :descriptor {:type &quot;VALUE&quot;, :valueType &quot;STRING&quot;, :value &quot;&quot;, :constraints {:minLength 1, :required true}}}}}) I&apos;d like the query to return all FormField &apos;s with unique :fieldRef ; so in the above example if I update the :descriptor :value from &quot;&quot; to &quot;foo&quot;, I only want the single fact returned"><y>#</y><d>2017-07-28</d><h>23:05</h><w>dadair</w>concrete example:
<pre>(-&gt; (handle test-file test-action) (r/query fields-for :?formRef &quot;/forms/aae-form&quot;))
=&gt;
({:?formRef &quot;/forms/aae-form&quot;,
  :?fieldRef &quot;/forms/aae-form/data/order/reason&quot;,
  :?field #{#justice.rules.forms.FormField{:formRef &quot;/forms/aae-form&quot;,
                                           :fieldRef &quot;/forms/aae-form/data/order/reason&quot;,
                                           :descriptor {:type &quot;VALUE&quot;,
                                                        :valueType &quot;STRING&quot;,
                                                        :value &quot;foo&quot;,
                                                        :constraints {:minLength 1, :required true}}}
            #justice.rules.forms.FormField{:formRef &quot;/forms/aae-form&quot;,
                                           :fieldRef &quot;/forms/aae-form/data/order/reason&quot;,
                                           :descriptor {:type &quot;VALUE&quot;,
                                                        :valueType &quot;STRING&quot;,
                                                        :value &quot;&quot;,
                                                        :constraints {:minLength 1, :required true}}}}})
</pre>

I&apos;d like the query to return all <code>FormField</code>&apos;s with unique <code>:fieldRef</code>; so in the above example if I update the <code>:descriptor</code> <code>:value</code> from &quot;&quot; to &quot;foo&quot;, I only want the single fact returned</z><z id="t1501344551366229" t="zylox Generational data is kind of tricky. I think you could do what you want though (assuming im understanding) if, externally, you have some way to track &quot;newest&quot;, having some sort of version field (whether this is datetime or incremented or whatever). Then, in the rules network, have an accumulator for the &quot;newest&quot; value of that field, and insert -&gt;NewestFact and then depend on that instead. Logical retractions should take care of the rest. @dadair"><y>#</y><d>2017-07-29</d><h>16:09</h><w>zylox</w>Generational data is kind of tricky. I think you could do what you want though (assuming im understanding) if, externally, you have some way to track &quot;newest&quot;, having some sort of version field (whether this is datetime or incremented or whatever). Then, in the rules network, have an accumulator for the &quot;newest&quot; value of that field, and insert <code>-&gt;NewestFact</code> and then depend on that instead. Logical retractions should take care of the rest. @dadair</z><z id="t1501344687378470" t="zylox i just realized you probably meant internal insertions not external."><y>#</y><d>2017-07-29</d><h>16:11</h><w>zylox</w>i just realized you probably meant internal insertions not external.</z><z id="t1501344896397813" t="zylox if its internal (so inserting on the rhs), thats trickier because in my experience execution order dependent rules get you in trouble real quick, and without that i&apos;m not sure how you would know what fact is &quot;newer&quot;. If your goal is actually whatever fact has the most fields populated, you could still do a check on that in the accumulator, or probably better with rules with checks on the fields you care about."><y>#</y><d>2017-07-29</d><h>16:14</h><w>zylox</w>if its internal (so inserting on the rhs), thats trickier because in my experience execution order dependent rules get you in trouble real quick, and without that i&apos;m not sure how you would know what fact is &quot;newer&quot;. If your goal is actually whatever fact has the most fields populated, you could still do a check on that in the accumulator, or probably better with rules with checks on the fields you care about.</z><z id="t1501892655427566" t="mrchance Hi! Is it possible to cause side effects when a fact gets retracted by the truth maintenance mechanism? I am building something that builds a network of core.async pipes and am thinking about establishing and severing connections based on Clara facts."><y>#</y><d>2017-08-05</d><h>00:24</h><w>mrchance</w>Hi! Is it possible to cause side effects when a fact gets retracted by the truth maintenance mechanism? I am building something that builds a network of core.async pipes and am thinking about establishing and severing connections based on Clara facts.</z><z id="t1501972131402743" t="mikerod @mrchance could you just make a :not style “negation rule” to logically handle the condition you are going for?"><y>#</y><d>2017-08-05</d><h>22:28</h><w>mikerod</w>@mrchance could you just make a <code>:not</code> style “negation rule” to logically handle the condition you are going for?</z><z id="t1501972155404349" t="mikerod Whatever you are wanting to monitor for being logically retracted via truth maintenance. It seems you should be able to make an explicit rule looking for that situation"><y>#</y><d>2017-08-05</d><h>22:29</h><w>mikerod</w>Whatever you are wanting to monitor for being logically retracted via truth maintenance. It seems you should be able to make an explicit rule looking for that situation</z><z id="t1501972523430107" t="mikerod However, this side-effect of severing connections would certainly have to be resilient to any issues of being executed multiple times on the RHS. don’t rely on it only being “called once”"><y>#</y><d>2017-08-05</d><h>22:35</h><w>mikerod</w>However, this side-effect of severing connections would certainly have to be resilient to any issues of being executed multiple times on the RHS. don’t rely on it only being “called once”</z><z id="t1501979687892983" t="mrchance @mikerod hm, ok. Idempotency shouldn&apos;t be an issue, good hint though. Gonna try that, although I am not 100% clear on how you mean that. In my use case, there would be rules that produce a [Linked a b] fact which would call something like core.async/pipe on a and b, only it returns something that can be called or closed when the respective Linked fact goes away in order to sever the connection again. How would I address that using :not rules?"><y>#</y><d>2017-08-06</d><h>00:34</h><w>mrchance</w>@mikerod hm, ok. Idempotency shouldn&apos;t be an issue, good hint though. Gonna try that, although I am not 100% clear on how you mean that. In my use case, there would be rules that produce a [Linked a b] fact which would call something like core.async/pipe on a and b, only it returns something that can be called or closed when the respective Linked fact goes away in order to sever the connection again. How would I address that using :not rules?</z><z id="t1501979864903953" t="mrchance Clara is awesome btw. ! Played with it a bit more in the meantime"><y>#</y><d>2017-08-06</d><h>00:37</h><w>mrchance</w>Clara is awesome btw. ! Played with it a bit more in the meantime</z><z id="t1501980155922591" t="mikerod @mrchance an alternative that comes to mind is to hook into Clara’s listeners to try to watch for the particular retraction you are interested in. However, I’d probably say it is best if that isn’t necessary."><y>#</y><d>2017-08-06</d><h>00:42</h><w>mikerod</w>@mrchance an alternative that comes to mind is to hook into Clara’s listeners to try to watch for the particular retraction you are interested in. However, I’d probably say it is best if that isn’t necessary.</z><z id="t1501980172923561" t="mikerod I hate to suggest things like insert-unconditional! but I see an approach with that at least…"><y>#</y><d>2017-08-06</d><h>00:42</h><w>mikerod</w>I hate to suggest things like <code>insert-unconditional!</code> but I see an approach with that at least…</z><z id="t1501980181924101" t="mikerod I’d like to think of something better though"><y>#</y><d>2017-08-06</d><h>00:43</h><w>mikerod</w>I’d like to think of something better though</z><z id="t1501980186924444" t="mrchance Yeah, I saw the ns in the docs and thought about that"><y>#</y><d>2017-08-06</d><h>00:43</h><w>mrchance</w>Yeah, I saw the ns in the docs and thought about that</z><z id="t1501980188924598" t="mikerod demo:"><y>#</y><d>2017-08-06</d><h>00:43</h><w>mikerod</w>demo:</z><z id="t1501980317932890" t="mikerod (defrule makes-chan [?a &lt;- A] [?b &lt;- B] =&gt; (let [chan (somehow-make it)] ;; Not sure what you do with `chan` here (r/insert! (-&gt;LogicalThing ?a ?b)) (r/insert-unconditional! (-&gt;OpenedChan chan)))) (defrule closes-chan [:not [LogicalThing]] [?oc &lt;- OpenedChan (= ?chan chan)] =&gt; (r/retract! ?oc) (close-the ?chan)) "><y>#</y><d>2017-08-06</d><h>00:45</h><w>mikerod</w><pre>(defrule makes-chan
  [?a &lt;- A]
  [?b &lt;- B]
  =&gt;
  (let [chan (somehow-make it)]
    ;; Not sure what you do with `chan` here
    (r/insert! (-&gt;LogicalThing ?a ?b))
    (r/insert-unconditional! (-&gt;OpenedChan chan))))

(defrule closes-chan
  [:not [LogicalThing]]
  [?oc &lt;- OpenedChan (= ?chan chan)]
  =&gt;
  (r/retract! ?oc)
  (close-the ?chan))

</pre></z><z id="t1501980396938220" t="mikerod I think it just gets sort of dirty when you are managing your own unconditional facts and retracts - typically a pattern to avoid"><y>#</y><d>2017-08-06</d><h>00:46</h><w>mikerod</w>I think it just gets sort of dirty when you are managing your own unconditional facts and retracts - typically a pattern to avoid</z><z id="t1501980426940291" t="mikerod not sure how prevalent this would be for you though in terms of managing it. also, not positive my solution is really a solution to the issue at all"><y>#</y><d>2017-08-06</d><h>00:47</h><w>mikerod</w>not sure how prevalent this would be for you though in terms of managing it. also, not positive my solution is really a solution to the issue at all</z><z id="t1501980431940571" t="mrchance Ok, I can see what you&apos;re getting at, but I agree it looks suboptimal"><y>#</y><d>2017-08-06</d><h>00:47</h><w>mrchance</w>Ok, I can see what you&apos;re getting at, but I agree it looks suboptimal</z><z id="t1501980445941405" t="mikerod Clara has a listener protocol you can attach onto"><y>#</y><d>2017-08-06</d><h>00:47</h><w>mikerod</w>Clara has a listener protocol you can attach onto</z><z id="t1501980453941905" t="mikerod and I believe you can find the relevant retract events there"><y>#</y><d>2017-08-06</d><h>00:47</h><w>mikerod</w>and I believe you can find the relevant retract events there</z><z id="t1501980464942583" t="mikerod not sure there have been docs posted up on that"><y>#</y><d>2017-08-06</d><h>00:47</h><w>mikerod</w>not sure there have been docs posted up on that</z><z id="t1501980504945065" t="mrchance Not many, from what I browsed yet 😉"><y>#</y><d>2017-08-06</d><h>00:48</h><w>mrchance</w>Not many, from what I browsed yet <b>😉</b></z><z id="t1501980505945098" t="mikerod https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc"><y>#</y><d>2017-08-06</d><h>00:48</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/listener.cljc</a></z><z id="t1501980559948281" t="mikerod The ITransientEventListener"><y>#</y><d>2017-08-06</d><h>00:49</h><w>mikerod</w>The <code>ITransientEventListener</code></z><z id="t1501980601951024" t="mikerod even when looking at this though, I think it is perhaps opaque which retraction you’d want to listen to"><y>#</y><d>2017-08-06</d><h>00:50</h><w>mikerod</w>even when looking at this though, I think it is perhaps opaque which retraction you’d want to listen to</z><z id="t1501980648954102" t="mrchance Hm, maybe. I&apos;ll give it a try"><y>#</y><d>2017-08-06</d><h>00:50</h><w>mrchance</w>Hm, maybe. I&apos;ll give it a try</z><z id="t1501980651954229" t="mikerod I believe (retract-facts! [listener facts]) &amp; (retract-facts-logical! [listener node token facts]) would have the info"><y>#</y><d>2017-08-06</d><h>00:50</h><w>mikerod</w>I believe <code>(retract-facts! [listener facts])</code> &amp; <code>(retract-facts-logical! [listener node token facts])</code> would have the info</z><z id="t1501980675955790" t="mikerod retract-facts! I believe is retracts from the RHS and retract-facts-logical! is retracts from truth maintenance"><y>#</y><d>2017-08-06</d><h>00:51</h><w>mikerod</w><code>retract-facts!</code> I believe is retracts from the RHS and <code>retract-facts-logical!</code> is retracts from truth maintenance</z><z id="t1501980685956343" t="mikerod other “retract” things I believe are more internal node-to-node activity"><y>#</y><d>2017-08-06</d><h>00:51</h><w>mikerod</w>other “retract” things I believe are more internal node-to-node activity</z><z id="t1501980689956574" t="mrchance Ah, ok"><y>#</y><d>2017-08-06</d><h>00:51</h><w>mrchance</w>Ah,  ok</z><z id="t1501980723959642" t="mrchance Thanks! I&apos;ll test it "><y>#</y><d>2017-08-06</d><h>00:52</h><w>mrchance</w>Thanks! I&apos;ll test it </z><z id="t1501980797963573" t="mikerod (mk-session rules :listeners [my-listener-impl])"><y>#</y><d>2017-08-06</d><h>00:53</h><w>mikerod</w><code>(mk-session rules :listeners [my-listener-impl])</code></z><z id="t1501980803963894" t="mrchance I think there is some big potential here, like a completely reactive description of stateful systems, something that&apos;s always awful when it moves past what e.g. component can handle "><y>#</y><d>2017-08-06</d><h>00:53</h><w>mrchance</w>I think there is some big potential here, like a completely reactive description of stateful systems, something that&apos;s always awful when it moves past what e.g. component can handle </z><z id="t1501980821964972" t="mrchance That&apos;s simple enough 😉 "><y>#</y><d>2017-08-06</d><h>00:53</h><w>mrchance</w>That&apos;s simple enough <b>😉</b> </z><z id="t1501980890968921" t="mikerod yeah, it isn’t actually documented on mk-session , not sure why. I don’t think those ns’s are really called “experimental” around this at this point"><y>#</y><d>2017-08-06</d><h>00:54</h><w>mikerod</w>yeah, it isn’t actually documented on <code>mk-session</code>, not sure why. I don’t think those ns’s are really called “experimental” around this at this point</z><z id="t1501980972973929" t="mikerod the only thing I’m concerned about is if you do not impl all the functions of the protocol"><y>#</y><d>2017-08-06</d><h>00:56</h><w>mikerod</w>the only thing I’m concerned about is if you do not impl all the functions of the protocol</z><z id="t1501980979974337" t="mikerod I can’t remember if you have to “pad” those with a no-op in some way"><y>#</y><d>2017-08-06</d><h>00:56</h><w>mikerod</w>I can’t remember if you have to “pad” those with a no-op in some way</z><z id="t1501980979974348" t="mrchance Typical case of documentation not growing as fast as its software"><y>#</y><d>2017-08-06</d><h>00:56</h><w>mrchance</w>Typical case of documentation not growing as fast as its software</z><z id="t1501981018976683" t="mrchance Shouldn&apos;t be a problem, it&apos;s a one time thing so some boilerplate is no issue"><y>#</y><d>2017-08-06</d><h>00:56</h><w>mrchance</w>Shouldn&apos;t be a problem, it&apos;s a one time thing so some boilerplate is no issue</z><z id="t1501981029977379" t="mikerod there is the clara.rules.listener/default-listener though"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mikerod</w>there is the <code>clara.rules.listener/default-listener</code> though</z><z id="t1501981035977730" t="mikerod you could just delegate everything else through that"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mikerod</w>you could just delegate everything else through that</z><z id="t1501981043978218" t="mikerod but it’s just a no-op"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mikerod</w>but it’s just a no-op</z><z id="t1501981068979568" t="mikerod yeah, idk. I’ve done stuff with this before too. I just can’t remember"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mikerod</w>yeah, idk. I’ve done stuff with this before too. I just can’t remember</z><z id="t1501981073979931" t="mrchance Ok, then actually delegating is probably more work ;)"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mrchance</w>Ok, then actually delegating is probably more work ;)</z><z id="t1501981078980260" t="mikerod hah yes"><y>#</y><d>2017-08-06</d><h>00:57</h><w>mikerod</w>hah yes</z><z id="t1501981086980806" t="mikerod I could have swore there was a smoother way"><y>#</y><d>2017-08-06</d><h>00:58</h><w>mikerod</w>I could have swore there was a smoother way</z><z id="t1501981129983271" t="mrchance I think this one is good enough, if it works"><y>#</y><d>2017-08-06</d><h>00:58</h><w>mrchance</w>I think this one is good enough, if it works</z><z id="t1501981135983637" t="mikerod &gt; I think there is some big potential here, like a completely reactive description of stateful systems, something that’s always awful when it moves past what e.g. component can handle That is cool though"><y>#</y><d>2017-08-06</d><h>00:58</h><w>mikerod</w>&gt; I think there is some big potential here, like a completely reactive description of stateful systems, something that’s always awful when it moves past what e.g. component can handle
That is cool though</z><z id="t1501981151984477" t="mrchance Yeah"><y>#</y><d>2017-08-06</d><h>00:59</h><w>mrchance</w>Yeah</z><z id="t1501981152984538" t="mikerod would be interesting to hear what success you have with that"><y>#</y><d>2017-08-06</d><h>00:59</h><w>mikerod</w>would be interesting to hear what success you have with that</z><z id="t1501981171985661" t="mrchance Sure, I&apos;ll let you know"><y>#</y><d>2017-08-06</d><h>00:59</h><w>mrchance</w>Sure, I&apos;ll let you know</z><z id="t1501981248991313" t="mikerod btw, looks like precept uses Clara :listeners when I did a quick GitHub search"><y>#</y><d>2017-08-06</d><h>01:00</h><w>mikerod</w>btw, looks like <code>precept</code> uses Clara <code>:listeners</code> when I did a quick GitHub search</z><z id="t1501981249991360" t="mikerod https://github.com/CoNarrative/precept/blob/6d919a91f846c9e5ca2d53384efe4da7981f1914/src/cljc/precept/listeners.cljc"><y>#</y><d>2017-08-06</d><h>01:00</h><w>mikerod</w><a href="https://github.com/CoNarrative/precept/blob/6d919a91f846c9e5ca2d53384efe4da7981f1914/src/cljc/precept/listeners.cljc" target="_blank">https://github.com/CoNarrative/precept/blob/6d919a91f846c9e5ca2d53384efe4da7981f1914/src/cljc/precept/listeners.cljc</a></z><z id="t1501981265992449" t="mikerod I knew they were doing interesting things in using Clara for app state mgmt (may be saying that wrong)"><y>#</y><d>2017-08-06</d><h>01:01</h><w>mikerod</w>I knew they were doing interesting things in using Clara for app state mgmt (may be saying that wrong)</z><z id="t1501981272993033" t="mrchance Right, I stumbled across that too "><y>#</y><d>2017-08-06</d><h>01:01</h><w>mrchance</w>Right, I stumbled across that too </z><z id="t1501981296994864" t="mikerod they impl’ed the protocols though and included the no-ops"><y>#</y><d>2017-08-06</d><h>01:01</h><w>mikerod</w>they impl’ed the protocols though and included the no-ops</z><z id="t1501981329997132" t="mrchance Probably going to have a look into their code, I like the idea of precept as well"><y>#</y><d>2017-08-06</d><h>01:02</h><w>mrchance</w>Probably going to have a look into their code, I like the idea of precept as well</z><z id="t1501981531010350" t="mikerod yeah, I’ve wanted to look at that codebase sometime soon"><y>#</y><d>2017-08-06</d><h>01:05</h><w>mikerod</w>yeah, I’ve wanted to look at that codebase sometime soon</z><z id="t1501981537010693" t="mikerod seems like some interesting stuff"><y>#</y><d>2017-08-06</d><h>01:05</h><w>mikerod</w>seems like some interesting stuff</z><z id="t1501996696873675" t="wparker Several people have had use cases that sounded like what they were looking for was the ability to get the changes in query results relative to an earlier state, and it sounds like that sort of functionality might be what you’re looking for as well @mrchance . That could be done with some wrappers in your code around the session along the lines of “Query the session, store the results, insert/retract facts, fire the rules, then query again and diff the results”. It could be done as a Clara listener too by tracking on the listening calls in QueryNode: https://github.com/cerner/clara-rules/blob/0.15.2/src/main/clojure/clara/rules/engine.cljc#L430"><y>#</y><d>2017-08-06</d><h>05:18</h><w>wparker</w>Several people have had use cases that sounded like what they were looking for was the ability to get the changes in query results relative to an earlier state, and it sounds like that sort of functionality might be what you’re looking for as well @mrchance .  That could be done with some wrappers in your code around the session along the lines of “Query the session, store the results, insert/retract facts, fire the rules, then query again and diff the results”.  It could be done as a Clara listener too by tracking on the listening calls in QueryNode: <a href="https://github.com/cerner/clara-rules/blob/0.15.2/src/main/clojure/clara/rules/engine.cljc#L430" target="_blank">https://github.com/cerner/clara-rules/blob/0.15.2/src/main/clojure/clara/rules/engine.cljc#L430</a></z><z id="t1501996937885927" t="wparker It is functionality that I think would be useful for Clara itself to provide at some point, a listener to do that would probably get into Clara’s internal impl details somewhat e.g. “is this node a QueryNode?” logic. Wouldn’t matter if it was part of Clara and tested there though."><y>#</y><d>2017-08-06</d><h>05:22</h><w>wparker</w>It is functionality that I think would be useful for Clara itself to provide at some point, a listener to do that would probably get into Clara’s internal impl details somewhat e.g. “is this node a QueryNode?” logic.  Wouldn’t matter if it was part of Clara and tested there though.</z><z id="t1502025000460842" t="mrchance @wparker True, that&apos;s another way to look at it. This might work too. Your answer also makes me wonder if Datascript would be the better choice for this usecase though, since there you get the transaction logs anyway"><y>#</y><d>2017-08-06</d><h>13:10</h><w>mrchance</w>@wparker True, that&apos;s another way to look at it. This might work too. Your answer also makes me wonder if Datascript would be the better choice for this usecase though, since there you get the transaction logs anyway</z><z id="t1502114632596343" t="wparker I haven’t had occasion to use DataScript, but it also seems like something that could be useful for a use-case like what you describe @mrchance . I suspect much depends on what the simplest way to model the logic you have in mind is and what performance characteristics you’re looking for."><y>#</y><d>2017-08-07</d><h>14:03</h><r>wparker</r>I haven’t had occasion to use DataScript, but it also seems like something that could be useful for a use-case like what you describe @mrchance .  I suspect much depends on what the simplest way to model the logic you have in mind is and what performance characteristics you’re looking for.</z><z id="t1502126437483724" t="mrchance Yes, it all depends on the details. From the FactUi readme it looks like they took a bit from both worlds as well"><y>#</y><d>2017-08-07</d><h>17:20</h><r>mrchance</r>Yes, it all depends on the details. From the FactUi readme it looks like they took a bit from both worlds as well</z><z id="t1502071200653256" t="mikerod https://github.com/arachne-framework/factui Looks like more fun with rules (and Clara)"><y>#</y><d>2017-08-07</d><h>02:00</h><w>mikerod</w> <a href="https://github.com/arachne-framework/factui" target="_blank">https://github.com/arachne-framework/factui</a>
Looks like more fun with rules (and Clara)</z><z id="t1502619616702895" t="olivergeorge I&apos;m interested in how Clara (or rule engines more generally) would work in an environment where a relational database is used as the repository of all information."><y>#</y><d>2017-08-13</d><h>10:20</h><w>olivergeorge</w>I&apos;m interested in how Clara (or rule engines more generally) would work in an environment where a relational database is used as the repository of all information.</z><z id="t1502619632703970" t="olivergeorge I&apos;m only learning about this stuff so I could be missing something obvious."><y>#</y><d>2017-08-13</d><h>10:20</h><w>olivergeorge</w>I&apos;m only learning about this stuff so I could be missing something obvious.</z><z id="t1502619755710825" t="olivergeorge Perhaps the key is not letting anyone directly write to the database which would bypassing the rule engine causing it to get out of sync with reality."><y>#</y><d>2017-08-13</d><h>10:22</h><w>olivergeorge</w>Perhaps the key is not letting anyone directly write to the database which would bypassing the rule engine causing it to get out of sync with reality.</z><z id="t1502619795713066" t="olivergeorge A simple &quot;typical architecture&quot; might answer my question."><y>#</y><d>2017-08-13</d><h>10:23</h><w>olivergeorge</w>A simple &quot;typical architecture&quot; might answer my question.</z><z id="t1502653908356519" t="hagmonk Can anyone explain why the following case doesn&apos;t do what I expect?"><y>#</y><d>2017-08-13</d><h>19:51</h><w>hagmonk</w>Can anyone explain why the following case doesn&apos;t do what I expect?</z><z id="t1502653920357589" t="hagmonk (let [matched (dsl/parse-rule [[:eav (= ?attribute (:attribute this)) (= ?attribute_value (:attribute_value this)) (= ?id (:id this))]] (insert! {:type ?attribute :id ?id :value ?attribute_value})) unscreened (dsl/parse-rule [[:state (= (:value this) 2) (= ?id (:id this))] [:milestone (= (:value this) -1) (= ?id (:id this))]] (insert! {:type :unscreened :id ?id})) type-query (dsl/parse-query [] [[?unscreened &lt;- :unscreened]]) session (mk-session [matched unscreened type-query] :fact-type-fn :type :cache false)] (time (-&gt; session (insert {:type :eav :attribute :state :attribute_value 2 :id 33695360}) (insert {:type :eav :attribute :milestone :attribute_value -1 :id 33695360}) fire-rules (insert {:type :eav :attribute :milestone :attribute_value 123456 :id 33695360}) fire-rules (query type-query)))) "><y>#</y><d>2017-08-13</d><h>19:52</h><w>hagmonk</w><pre>(let [matched    (dsl/parse-rule
                   [[:eav
                     (= ?attribute (:attribute this))
                     (= ?attribute_value (:attribute_value this))
                     (= ?id (:id this))]]
                   (insert! {:type ?attribute :id ?id :value ?attribute_value}))

      unscreened (dsl/parse-rule
                   [[:state
                     (= (:value this) 2)
                     (= ?id (:id this))]
                    [:milestone
                     (= (:value this) -1)
                     (= ?id (:id this))]]
                   (insert! {:type :unscreened :id ?id}))

      type-query (dsl/parse-query [] [[?unscreened &lt;- :unscreened]])

      session    (mk-session [matched unscreened type-query] :fact-type-fn :type :cache false)]
  (time (-&gt; session
            (insert {:type :eav :attribute :state :attribute_value 2 :id 33695360})
            (insert {:type :eav :attribute :milestone :attribute_value -1 :id 33695360})
            fire-rules
            (insert {:type :eav :attribute :milestone :attribute_value 123456 :id 33695360})
            fire-rules
            (query type-query))))
</pre></z><z id="t1502653954360448" t="hagmonk I insert two facts which cause a third fact of type :unscreened to be inserted"><y>#</y><d>2017-08-13</d><h>19:52</h><w>hagmonk</w>I insert two facts which cause a third fact of type :unscreened to be inserted</z><z id="t1502653996363852" t="hagmonk I then fire the rules, and insert another fact which should negate the earlier fact"><y>#</y><d>2017-08-13</d><h>19:53</h><w>hagmonk</w>I then fire the rules, and insert another fact which should negate the earlier fact</z><z id="t1502654016365569" t="hagmonk Instead, when I query the session for :unscreened, I see that fact still present"><y>#</y><d>2017-08-13</d><h>19:53</h><w>hagmonk</w>Instead, when I query the session for :unscreened, I see that fact still present</z><z id="t1502723918216239" t="curtis.shaffer @olivergeorge authorization on the database is something that can be done; certain databases (Oracle is the one that comes to mind) support triggers which you could use to detect changes"><y>#</y><d>2017-08-14</d><h>15:18</h><w>curtis.shaffer</w>@olivergeorge authorization on the database is something that can be done; certain databases (Oracle is the one that comes to mind) support triggers which you could use to detect changes</z><z id="t1502724132349966" t="curtis.shaffer @hagmonk as far as I can tell, all three of those facts will still be in the session; the 3rd fact insertion does not negate the 2nd fact insertion. the :id field makes me think that you want it to be an update, which is not what is done"><y>#</y><d>2017-08-14</d><h>15:22</h><w>curtis.shaffer</w>@hagmonk as far as I can tell, all three of those facts will still be in the session; the 3rd fact insertion does not negate the 2nd fact insertion. the :id field makes me think that you want it to be an update, which is not what is done</z><z id="t1502725136977442" t="zylox @hagmonk What Curtis said. You could use an accumlator to grab the highest valued :milestone fact. or if you are looking for all non negative, you could add a :not constraint. Depends on what you are looking for."><y>#</y><d>2017-08-14</d><h>15:38</h><w>zylox</w>@hagmonk What Curtis said. You could use an accumlator to grab the highest valued :milestone fact. or if you are looking for all non negative, you could add a :not constraint. Depends on what you are looking for.</z><z id="t1502733033533975" t="wparker @olivergeorge it might help if you can clarify your question. From Clara’s point of view, it doesn’t matter what the ultimate source of the data it processes is. Note though that if rules do things that depend on ordering you have to be careful since Clara can fire and then retract a rule; the contract when using truth maintenance is that the state of the rules engine works out before fire-rules returns. But if you, say, performed operations on a database in a rule RHS you’d have to be careful about controlling rule ordering with salience etc. Our workflows typically involve something retrieving data, providing the data to Clara, firing the rules, querying the resulting session, and then saving the query results - does that help?"><y>#</y><d>2017-08-14</d><h>17:50</h><w>wparker</w>@olivergeorge it might help if you can clarify your question.  From Clara’s point of view, it doesn’t matter what the ultimate source of the data it processes is.  Note though that if rules do things that depend on ordering you have to be careful since Clara can fire and then retract a rule; the contract when using truth maintenance is that the state of the rules engine works out before fire-rules returns.  But if you, say, performed operations on a database in a rule RHS you’d have to be careful about controlling rule ordering with salience etc.  Our workflows typically involve something retrieving data, providing the data to Clara, firing the rules, querying the resulting session, and then saving the query results - does that help?</z><z id="t1502771893000126" t="olivergeorge Yes thanks. That makes sense. "><y>#</y><d>2017-08-15</d><h>04:38</h><w>olivergeorge</w>Yes thanks. That makes sense. </z><z id="t1502804676000078" t="souenzzo I can/I should run a query inside a rule? (query the &quot;self&quot;)"><y>#</y><d>2017-08-15</d><h>13:44</h><w>souenzzo</w>I can/I should run a query inside a rule? (query the &quot;self&quot;)</z><z id="t1502809386000630" t="mikerod @souenzzo it isn’t clear to me what you are trying to do"><y>#</y><d>2017-08-15</d><h>15:03</h><w>mikerod</w>@souenzzo it isn’t clear to me what you are trying to do</z><z id="t1502809397000155" t="mikerod Currently you can’t run a query directly from within a rule"><y>#</y><d>2017-08-15</d><h>15:03</h><w>mikerod</w>Currently you can’t run a query directly from within a rule</z><z id="t1502809426000697" t="mikerod but it’d probably be good to have some sort of example of what you are trying to accomplish or thinking about"><y>#</y><d>2017-08-15</d><h>15:03</h><w>mikerod</w>but it’d probably be good to have some sort of example of what you are trying to accomplish or thinking about</z><z id="t1502809578000706" t="souenzzo I was trying to run a query on &quot;right side&quot; of a defrule . But I already find another solution."><y>#</y><d>2017-08-15</d><h>15:06</h><w>souenzzo</w>I was trying to run a query on &quot;right side&quot; of a <code>defrule</code>. But I already find another solution.</z><z id="t1503000442000001" t="enn Can an accumulator accumulate across more than one fact type (joined on some field)? All of the examples show only a single fact type in the :from clause."><y>#</y><d>2017-08-17</d><h>20:07</h><w>enn</w>Can an accumulator accumulate across more than one fact type (joined on some field)? All of the examples show only a single fact type in the <code>:from</code> clause.</z><z id="t1503008432000163" t="wparker @enn Strictly speaking no, but with a custom ancestors fn you can create a new type that is the parent of multiple types for whatever fact types you’re working with"><y>#</y><d>2017-08-17</d><h>22:20</h><w>wparker</w>@enn Strictly speaking no, but with a custom ancestors fn you can create a new type that is the parent of multiple types for whatever fact types you’re working with</z><z id="t1503008485000064" t="wparker Same goes for other condition types as well"><y>#</y><d>2017-08-17</d><h>22:21</h><w>wparker</w>Same goes for other condition types as well</z><z id="t1503008506000153" t="wparker e.g. if you have FactTypeA and FactTypeB, you can make FactTypeC a parent of both"><y>#</y><d>2017-08-17</d><h>22:21</h><w>wparker</w>e.g. if you have FactTypeA and FactTypeB, you can make FactTypeC a parent of both</z><z id="t1503008541000172" t="wparker then [?facts &lt;- (acc/all) :from [FactTypeC (…)]] would accumulate on both FactTypeA and FactTypeC"><y>#</y><d>2017-08-17</d><h>22:22</h><w>wparker</w>then [?facts &lt;- (acc/all) :from [FactTypeC (…)]] would accumulate on both FactTypeA and FactTypeC</z><z id="t1503008578000215" t="wparker see http://www.clara-rules.org/docs/fact_type_customization/ for more info"><y>#</y><d>2017-08-17</d><h>22:22</h><w>wparker</w>see <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a> for more info</z><z id="t1503009920000366" t="enn Interesting."><y>#</y><d>2017-08-17</d><h>22:45</h><w>enn</w>Interesting.</z><z id="t1503009924000216" t="enn I hadn’t thought of that approach."><y>#</y><d>2017-08-17</d><h>22:45</h><w>enn</w>I hadn’t thought of that approach.</z><z id="t1503010029000072" t="wparker Edit: “would accumulate on both FactTypeA and FactTypeB”"><y>#</y><d>2017-08-17</d><h>22:47</h><w>wparker</w>Edit: “would accumulate on both FactTypeA and FactTypeB”</z><z id="t1503031863000085" t="iku000888 Has anyone tried using clara-rules via a self hosted cljs compiler?"><y>#</y><d>2017-08-18</d><h>04:51</h><w>iku000888</w>Has anyone tried using clara-rules via a self hosted cljs compiler?</z><z id="t1503031939000101" t="iku000888 I run into errors like this"><y>#</y><d>2017-08-18</d><h>04:52</h><w>iku000888</w>I run into errors like this</z><z id="t1503031943000174" t="iku000888 cljs.user=&gt; (require &apos;clara.rules) ⬆ WARNING: macroexpand already refers to: cljs.core/macroexpand being replaced by: clojure.reflect/macroexpand at line 33 clojure/reflect.cljs ⬆ WARNING: Use of undeclared Var schema.utils$macros/class at line 25 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/class at line 32 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/format at line 36 schema/utils.clj ⬆ WARNING: No such namespace: clojure.lang.Compiler, could not locate clojure/lang/Compiler.cljs, clojure/lang/Compiler.cljc, or Closure namespace &quot;&quot; at line 49 schema/utils.clj ⬆ WARNING: Use of undeclared Var clojure.lang.Compiler/CHAR_MAP at line 49 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/class at line 64 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/print-method at line 95 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/print-method at line 96 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/print-method at line 116 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/print-method at line 117 schema/utils.clj ⬆ WARNING: No such namespace: java.util.Collections, could not locate java/util/Collections.cljs, java/util/Collections.cljc, or Closure namespace &quot;&quot; at line 141 schema/utils.clj ⬆ WARNING: Use of undeclared Var java.util.Collections/synchronizedMap at line 141 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/class? at line 147 schema/utils.clj ⬆ WARNING: Use of undeclared Var schema.utils$macros/class at line 148 schema/utils.clj ERROR in file schema/utils.clj (new) Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1935:200) Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2482:92) (NO_SOURCE_FILE &lt;embedded&gt;:5947:100) z (NO_SOURCE_FILE &lt;embedded&gt;:5948:13) (NO_SOURCE_FILE &lt;embedded&gt;:5942:232) (NO_SOURCE_FILE &lt;embedded&gt;:5862:482) Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5838:464) (NO_SOURCE_FILE &lt;embedded&gt;:5857:20) Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5838:464) No protocol method IMultiFn.-add-method defined for type undefined: Object.cljs.core.missing_protocol (NO_SOURCE_FILE &lt;embedded&gt;:179:229) cljs.core._add_method (NO_SOURCE_FILE &lt;embedded&gt;:1841:468) (evalmachine.&lt;anonymous&gt;:272:23) ContextifyScript.Script.runInThisContext (vm.cljs:44:33) Object.runInThisContext (vm.cljs:116:38) (Object.lumoEval) lumo.repl.caching_node_eval (NO_SOURCE_FILE &lt;embedded&gt;:6211:68) (NO_SOURCE_FILE &lt;embedded&gt;:5947:29) z (NO_SOURCE_FILE &lt;embedded&gt;:5948:13) (NO_SOURCE_FILE &lt;embedded&gt;:5942:232) "><y>#</y><d>2017-08-18</d><h>04:52</h><w>iku000888</w><pre>cljs.user=&gt; (require &apos;clara.rules)
            ⬆
WARNING: macroexpand already refers to: cljs.core/macroexpand being replaced by: clojure.reflect/macroexpand at line 33 clojure/reflect.cljs
                     ⬆
WARNING: Use of undeclared Var schema.utils$macros/class at line 25 schema/utils.clj
                     ⬆
WARNING: Use of undeclared Var schema.utils$macros/class at line 32 schema/utils.clj
                           ⬆
WARNING: Use of undeclared Var schema.utils$macros/format at line 36 schema/utils.clj
              ⬆
WARNING: No such namespace: clojure.lang.Compiler, could not locate clojure/lang/Compiler.cljs, clojure/lang/Compiler.cljc, or Closure namespace &quot;&quot; at line 49 schema/utils.clj
              ⬆
WARNING: Use of undeclared Var clojure.lang.Compiler/CHAR_MAP at line 49 schema/utils.clj
                                       ⬆
WARNING: Use of undeclared Var schema.utils$macros/class at line 64 schema/utils.clj
            ⬆
WARNING: Use of undeclared Var schema.utils$macros/print-method at line 95 schema/utils.clj
               ⬆
WARNING: Use of undeclared Var schema.utils$macros/print-method at line 96 schema/utils.clj
            ⬆
WARNING: Use of undeclared Var schema.utils$macros/print-method at line 116 schema/utils.clj
               ⬆
WARNING: Use of undeclared Var schema.utils$macros/print-method at line 117 schema/utils.clj
                                                   ⬆
WARNING: No such namespace: java.util.Collections, could not locate java/util/Collections.cljs, java/util/Collections.cljc, or Closure namespace &quot;&quot; at line 141 schema/utils.clj
                                                   ⬆
WARNING: Use of undeclared Var java.util.Collections/synchronizedMap at line 141 schema/utils.clj
                         ⬆
WARNING: Use of undeclared Var schema.utils$macros/class? at line 147 schema/utils.clj
                                                                                 ⬆
WARNING: Use of undeclared Var schema.utils$macros/class at line 148 schema/utils.clj
ERROR in file schema/utils.clj
	 (new)
	 Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1935:200)
	 Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2482:92)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5947:100)
	 z (NO_SOURCE_FILE &lt;embedded&gt;:5948:13)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5942:232)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5862:482)
	 Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5838:464)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5857:20)
	 Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5838:464)

No protocol method IMultiFn.-add-method defined for type undefined: 
	 Object.cljs.core.missing_protocol (NO_SOURCE_FILE &lt;embedded&gt;:179:229)
	 cljs.core._add_method (NO_SOURCE_FILE &lt;embedded&gt;:1841:468)
	 (evalmachine.&lt;anonymous&gt;:272:23)
	 ContextifyScript.Script.runInThisContext (vm.cljs:44:33)
	 Object.runInThisContext (vm.cljs:116:38)
	 (Object.lumoEval)
	 lumo.repl.caching_node_eval (NO_SOURCE_FILE &lt;embedded&gt;:6211:68)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5947:29)
	 z (NO_SOURCE_FILE &lt;embedded&gt;:5948:13)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5942:232)
</pre></z><z id="t1503031991000175" t="iku000888 I was testing out calvin and have a pretty tiny repro, if there is interest."><y>#</y><d>2017-08-18</d><h>04:53</h><w>iku000888</w>I was testing out calvin and have a pretty tiny repro, if there is interest.</z><z id="t1503033101000019" t="iku000888 https://github.com/iku000888/tiny-samples/tree/master/node-and-cljs"><y>#</y><d>2017-08-18</d><h>05:11</h><w>iku000888</w><a href="https://github.com/iku000888/tiny-samples/tree/master/node-and-cljs" target="_blank">https://github.com/iku000888/tiny-samples/tree/master/node-and-cljs</a></z><z id="t1503070100000040" t="wparker @iku000888 supporting self-hosted ClojureScript in Clara isn’t something we’ve looked at to my knowledge, and I would anticipate that changes would need to be made to support it. If anyone has gotten that to work it would be interesting to know though. From the looks of your errors Schema has some problems with self-hosted ClojureScript as well, so there might need to be changes there as well for self-hosted CLJS Clara to work. Feel free to log an issue to Clara and anyone who wants to look at what that would take is welcome to do so. It would be nice to have, it just hasn’t been a priority. I canof how Schema would approach any problems with self-hosted ClojureScript in their codebase,"><y>#</y><d>2017-08-18</d><h>15:28</h><w>wparker</w>@iku000888 supporting self-hosted ClojureScript in Clara isn’t something we’ve looked at to my knowledge, and I would anticipate that changes would need to be made to support it.   If anyone has gotten that to work it would be interesting to know though.  From the looks of your errors Schema has some problems with self-hosted ClojureScript as well, so there might need to be changes there as well for self-hosted CLJS Clara to work.  Feel free to log an issue to Clara and anyone who wants to look at what that would take is welcome to do so.  It would be nice to have, it just hasn’t been a priority.   I canof how Schema would approach any problems with self-hosted ClojureScript in their codebase,</z><z id="t1503070164000708" t="wparker I can’t speak to how Schema would approach any problems with self-hosted ClojureScript in their codebase, and I don’t know if there have been any previous discussions on the subject, but in my observation they’ve been pretty open to PRs, issues, etc. in the past"><y>#</y><d>2017-08-18</d><h>15:29</h><w>wparker</w>I can’t speak to how Schema would approach any problems with self-hosted ClojureScript in their codebase, and I don’t know if there have been any previous discussions on the subject, but in my observation they’ve been pretty open to PRs, issues, etc. in the past</z><z id="t1503070227000667" t="iku000888 @wparker thanks for the feedback!"><y>#</y><d>2017-08-18</d><h>15:30</h><w>iku000888</w>@wparker thanks for the feedback!</z><z id="t1503070294000452" t="iku000888 Will log an issue on the clara repo and schema (after checking they have an issue on self host)"><y>#</y><d>2017-08-18</d><h>15:31</h><w>iku000888</w>Will log an issue on the clara repo and schema (after checking they have an issue on self host)</z><z id="t1503070348000208" t="iku000888 Would be super cool if self host support lands though, just saying 🙂"><y>#</y><d>2017-08-18</d><h>15:32</h><w>iku000888</w>Would be super cool if self host support lands though, just saying <b>🙂</b></z><z id="t1503070934000143" t="iku000888 https://github.com/cerner/clara-rules/issues/337"><y>#</y><d>2017-08-18</d><h>15:42</h><w>iku000888</w><a href="https://github.com/cerner/clara-rules/issues/337" target="_blank">https://github.com/cerner/clara-rules/issues/337</a></z><z id="t1503070970000548" t="iku000888 @wparker Is there is anything else I can provide?"><y>#</y><d>2017-08-18</d><h>15:42</h><w>iku000888</w>@wparker Is there is anything else I can provide?</z><z id="t1503071382000310" t="wparker that works thanks @iku000888"><y>#</y><d>2017-08-18</d><h>15:49</h><w>wparker</w>that works thanks @iku000888</z><z id="t1503071393000043" t="iku000888 Thanks again!"><y>#</y><d>2017-08-18</d><h>15:49</h><w>iku000888</w>Thanks again!</z><z id="t1503071531000094" t="wparker There would need to be some changes to Clara as well for this, not just Schema. A quick one that jumps out is that clara.rules.compiler is a clj file and has a java.beans.PropertyDescriptor import"><y>#</y><d>2017-08-18</d><h>15:52</h><w>wparker</w>There would need to be some changes to Clara as well for this, not just Schema.  A quick one that jumps out is that clara.rules.compiler is a clj file and has a java.beans.PropertyDescriptor import</z><z id="t1503071540000504" t="wparker https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L1"><y>#</y><d>2017-08-18</d><h>15:52</h><w>wparker</w><a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L1" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L1</a></z><z id="t1503071575000145" t="wparker That’s the compiler from rules/queries to an executable structure"><y>#</y><d>2017-08-18</d><h>15:52</h><w>wparker</w>That’s the compiler from rules/queries to an executable structure</z><z id="t1503089558000115" t="mikerod @enn I’ll add on more possibility to this: &gt; Can an accumulator accumulate across more than one fact type (joined on some field)? All of the examples show only a single fact type in the :from clause. You can also “wrap” multiple types of facts in a common fact type and accumulate instead on that."><y>#</y><d>2017-08-18</d><h>20:52</h><w>mikerod</w>@enn  I’ll add on more possibility to this:
&gt; Can an accumulator accumulate across more than one fact type (joined on some field)? All of the examples show only a single fact type in the <code>:from</code> clause.

You can also “wrap” multiple types of facts in a common fact type and accumulate instead on that.</z><z id="t1503089574000354" t="mikerod without a need of actually creating a real ancestor, hierarchical change"><y>#</y><d>2017-08-18</d><h>20:52</h><w>mikerod</w>without a need of actually creating a real ancestor, hierarchical change</z><z id="t1503089728000312" t="mikerod (defrecord CommonWrap [wrapped]) (r/defrule wrap-fact-a [?a &lt;- FactA] =&gt; (r/insert! (-&gt;CommonWrap ?a))) (r/defrule wrap-fact-b [?b &lt;- FactB] =&gt; (r/insert! (-&gt;CommonWrap ?b))) (r/defrule accum-them [?acc &lt;- my-accumulator :from [CommonWrap]] &lt;etc&gt; =&gt; &lt;rhs&gt;) "><y>#</y><d>2017-08-18</d><h>20:55</h><w>mikerod</w><pre>(defrecord CommonWrap [wrapped])

(r/defrule wrap-fact-a
[?a &lt;- FactA]
=&gt;
(r/insert! (-&gt;CommonWrap ?a)))

(r/defrule wrap-fact-b
[?b &lt;- FactB]
=&gt;
(r/insert! (-&gt;CommonWrap ?b)))


(r/defrule accum-them
[?acc &lt;- my-accumulator :from [CommonWrap]]
&lt;etc&gt;
=&gt;
&lt;rhs&gt;)
</pre></z><z id="t1503089770000350" t="mikerod the accumulator could just access the original, field “x”, like (-&gt; w :wrapped :x)"><y>#</y><d>2017-08-18</d><h>20:56</h><w>mikerod</w>the accumulator could just access the original, field “x”, like <code>(-&gt; w :wrapped :x)</code></z><z id="t1503089789000236" t="mikerod or you could make it have the same fields as the original even with (r/insert! (-&gt;CommonWrap ?a)) "><y>#</y><d>2017-08-18</d><h>20:56</h><w>mikerod</w>or you could make it have the same fields as the original even with
<pre>(r/insert! (-&gt;CommonWrap ?a))
</pre></z><z id="t1503089927000187" t="mikerod &gt; There would need to be some changes to Clara as well for this, not just Schema. Yeah, I think clara.rules.compiler would probably require the most work on self-hosting"><y>#</y><d>2017-08-18</d><h>20:58</h><w>mikerod</w>&gt; There would need to be some changes to Clara as well for this, not just Schema.
Yeah, I think <code>clara.rules.compiler</code> would probably require the most work on self-hosting</z><z id="t1503089937000017" t="mikerod (aside from schema breaking clara anyways)"><y>#</y><d>2017-08-18</d><h>20:58</h><w>mikerod</w>(aside from schema breaking clara anyways)</z><z id="t1503089947000381" t="mikerod unless there is a way to just not use the schema on the self-host side"><y>#</y><d>2017-08-18</d><h>20:59</h><w>mikerod</w>unless there is a way to just not use the schema on the self-host side</z><z id="t1503089967000126" t="mikerod I think technically, the schema are just used for testing and documentation purposes"><y>#</y><d>2017-08-18</d><h>20:59</h><w>mikerod</w>I think technically, the schema are just used for testing and documentation purposes</z><z id="t1503089974000078" t="mikerod but wouldn’t be too trivial I don’t think still"><y>#</y><d>2017-08-18</d><h>20:59</h><w>mikerod</w>but wouldn’t be too trivial I don’t think still</z><z id="t1503089987000080" t="mikerod Also, the “durability” feature of Clara would likely have trouble"><y>#</y><d>2017-08-18</d><h>20:59</h><w>mikerod</w>Also, the “durability” feature of Clara would likely have trouble</z><z id="t1503090001000305" t="mikerod but may not be needed anyways and probably could just be skipped for that sort of build"><y>#</y><d>2017-08-18</d><h>21:00</h><w>mikerod</w>but may not be needed anyways and probably could just be skipped for that sort of build</z><z id="t1503347865000379" t="souenzzo How to test [:test (is-it-possible? ?foo ?bar)] ??"><y>#</y><d>2017-08-21</d><h>20:37</h><w>souenzzo</w>How to test <code>[:test (is-it-possible? ?foo ?bar)]</code>??</z><z id="t1503418299000675" t="wparker I don’t understand your question - could you clarify?"><y>#</y><d>2017-08-22</d><h>16:11</h><r>wparker</r>I don’t understand your question - could you clarify?</z><z id="t1503427406000048" t="souenzzo I find out that (= ?foo ?bar) isn&apos;t a function. For now I&apos;m using [?res &lt;- (my-fn? ?foo ?bar)] [:test (= ?res true)]"><y>#</y><d>2017-08-22</d><h>18:43</h><r>souenzzo</r>I find out that <code>(= ?foo ?bar)</code> isn&apos;t a function. For now I&apos;m using <code>[?res &lt;- (my-fn? ?foo ?bar)] [:test (= ?res true)]</code></z><z id="t1503431491000455" t="souenzzo I&apos;m having trouble with: lein test - pass all my tests *on repl* - I can test multiple times and get ok, but when I reload the rules namespace, all rules behavior change (my test fail) How to debug?"><y>#</y><d>2017-08-22</d><h>19:51</h><w>souenzzo</w>I&apos;m having trouble with:
<code>lein test</code> - pass all my tests
<code>*on repl*</code> - I can test multiple times and get ok, but when I reload the rules namespace, all rules behavior change (my test fail)
How to debug?</z><z id="t1503495522000415" t="ryanbrush @souenzzo There are a couple pitfalls on the that can happen. One is that the rule session is being cached, so you&apos;re re-running previous rules. This can be turned off by passing :cache false to mk-session as described at http://www.clara-rules.org/apidocs/0.15.2/clojure/clara.rules.html#var-mk-session"><y>#</y><d>2017-08-23</d><h>13:38</h><w>ryanbrush</w>@souenzzo There are a couple pitfalls on the that can happen.  One is that the rule session is being cached, so you&apos;re re-running previous rules. This can be turned off by passing :cache false to mk-session as described at <a href="http://www.clara-rules.org/apidocs/0.15.2/clojure/clara.rules.html#var-mk-session" target="_blank">http://www.clara-rules.org/apidocs/0.15.2/clojure/clara.rules.html#var-mk-session</a></z><z id="t1503495570000119" t="ryanbrush The other pitfall that can happen is if you&apos;re reloading your fact types, the reloaded types may be a different class than what Clara was compiled against, so the facts won&apos;t match."><y>#</y><d>2017-08-23</d><h>13:39</h><w>ryanbrush</w>The other pitfall that can happen is if you&apos;re reloading your fact types, the reloaded types may be a different class than what Clara was compiled against, so the facts won&apos;t match.</z><z id="t1503495598000439" t="ryanbrush This can also be addressed by not caching the rules session as described above, or by placing the fact types in a namespace that isn&apos;t reloaded in your REPL."><y>#</y><d>2017-08-23</d><h>13:39</h><w>ryanbrush</w>This can also be addressed by not caching the rules session as described above, or by placing the fact types in a namespace that isn&apos;t reloaded in your REPL.</z><z id="t1503495621000705" t="ryanbrush Of course, this only applies if you&apos;re using the Java or Clojure type system for your facts (which is the default) rather than using a custom fact type."><y>#</y><d>2017-08-23</d><h>13:40</h><w>ryanbrush</w>Of course, this only applies if you&apos;re using the Java or Clojure type system for your facts (which is the default) rather than using a custom fact type.</z><z id="t1503497539000035" t="souenzzo Already tryied with :cache false , :cache true ..."><y>#</y><d>2017-08-23</d><h>14:12</h><w>souenzzo</w>Already tryied with <code>:cache false</code>, <code>:cache true</code>...</z><z id="t1503497562000302" t="souenzzo I will try to move defrecord to another ns"><y>#</y><d>2017-08-23</d><h>14:12</h><w>souenzzo</w>I will try to move <code>defrecord</code> to another ns</z><z id="t1503498598000757" t="souenzzo Oh. I noticed that my problems started when I started importing records in different namespaces. (still moving to test if records in a &quot;standalone&quot; ns will solve)"><y>#</y><d>2017-08-23</d><h>14:29</h><w>souenzzo</w>Oh. I noticed that my problems started when I started importing records in different namespaces. (still moving to test if records in a &quot;standalone&quot; ns will solve)</z><z id="t1503499587000726" t="souenzzo fixed. @ryanbrush clara docs should contains this info."><y>#</y><d>2017-08-23</d><h>14:46</h><w>souenzzo</w>fixed. @ryanbrush clara docs should contains this info.</z><z id="t1503516337000352" t="mikerod @souenzzo Just to add to this conversation: This does sound like something that may be a good idea to point out in some sort of Clara docs, especially concerning development time. However, records getting redefined I think is often at odds with a dynamic repl reloading workflow. I don’t think Clara is the only place affected."><y>#</y><d>2017-08-23</d><h>19:25</h><w>mikerod</w>@souenzzo Just to add to this conversation: 
This does sound like something that may be a good idea to point out in some sort of Clara docs, especially concerning development time.
However, records getting redefined I think is often at odds with a dynamic repl reloading workflow. I don’t think Clara is the only place affected.</z><z id="t1503516460000276" t="mikerod Not to suggest to use this lib or not, just to point out I’ve seen the same concern addressed before https://github.com/ztellman/potemkin/blob/0.4.4/src/potemkin/types.clj#L326"><y>#</y><d>2017-08-23</d><h>19:27</h><w>mikerod</w>Not to suggest to use this lib or not, just to point out I’ve seen the same concern addressed before <a href="https://github.com/ztellman/potemkin/blob/0.4.4/src/potemkin/types.clj#L326" target="_blank">https://github.com/ztellman/potemkin/blob/0.4.4/src/potemkin/types.clj#L326</a></z><z id="t1503516539000173" t="mikerod At one point Plumatic (formerly prismatic) Schema actually defaulted to using potemkin s defrecord+ to avoid recreated classes with the same name, that have no impl change, in a new dynamic classloader during (probably repl) reloads"><y>#</y><d>2017-08-23</d><h>19:28</h><w>mikerod</w>At one point Plumatic (formerly prismatic) Schema actually defaulted to using <code>potemkin</code>s <code>defrecord+</code> to avoid recreated classes with the same name,  that have no impl change, in a new dynamic classloader during (probably repl) reloads</z><z id="t1503516599000217" t="mikerod (still exists in schema now, but as an “optional” dependency https://github.com/plumatic/schema/blob/schema-1.1.6/src/clj/schema/potemkin.clj )"><y>#</y><d>2017-08-23</d><h>19:29</h><w>mikerod</w>(still exists in schema now, but as an “optional” dependency <a href="https://github.com/plumatic/schema/blob/schema-1.1.6/src/clj/schema/potemkin.clj" target="_blank">https://github.com/plumatic/schema/blob/schema-1.1.6/src/clj/schema/potemkin.clj</a>)</z><z id="t1503516633000292" t="mikerod I’m just pointing this out because in the past I used this “non reloading” style of defrecord to avoid weird issues with a record class getting reloading, with references still around to the old version of the class"><y>#</y><d>2017-08-23</d><h>19:30</h><w>mikerod</w>I’m just pointing this out because in the past I used this “non reloading” style of defrecord to avoid weird issues with a record class getting reloading, with references still around to the old version of the class</z><z id="t1503516658000079" t="mikerod you can get away with moving record definitions into some namespace you are careful to not :reload though"><y>#</y><d>2017-08-23</d><h>19:30</h><w>mikerod</w>you can get away with moving record definitions into some namespace you are careful to not <code>:reload</code> though</z><z id="t1503516670000437" t="mikerod as long as you don’t want to do something like :reload-all"><y>#</y><d>2017-08-23</d><h>19:31</h><w>mikerod</w>as long as you don’t want to do something like <code>:reload-all</code></z><z id="t1503516741000071" t="souenzzo There is a document about repl development https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL just add a mention/reference/tip about &quot;be warning on reload types/records across namespaces&quot;."><y>#</y><d>2017-08-23</d><h>19:32</h><w>souenzzo</w>There is a document about repl development
<a href="https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL" target="_blank">https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL</a>
just add a mention/reference/tip about &quot;be warning on reload types/records across namespaces&quot;.</z><z id="t1503516822000213" t="mikerod nice"><y>#</y><d>2017-08-23</d><h>19:33</h><w>mikerod</w>nice</z><z id="t1503520124000546" t="dadair Is it possible to specify multiple namespaces for mk-session ? I have rules organized across a couple namespaces (to guarantee zero collaboration between two distinct rule sets that use common facts), and want to share common queries in a shared namespace. I&apos;ve tried both (mk-session &apos;ns.one &apos;ns.shared) and (mk-session [&apos;ns.one &apos;ns.shared]) and get a query invalid or not in rule base error for the shared queries"><y>#</y><d>2017-08-23</d><h>20:28</h><w>dadair</w>Is it possible to specify multiple namespaces for <code>mk-session</code>? I have rules organized across a couple namespaces (to guarantee zero collaboration between two distinct rule sets that use common facts), and want to share common queries in a <code>shared</code> namespace. I&apos;ve tried both <code>(mk-session &apos;ns.one &apos;ns.shared)</code> and <code>(mk-session [&apos;ns.one &apos;ns.shared])</code> and get a <code>query invalid or not in rule base</code> error for the shared queries</z><z id="t1503523466000291" t="wparker Example of such usage: https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1144"><y>#</y><d>2017-08-23</d><h>21:24</h><r>wparker</r>Example of such usage: <a href="https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1144" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1144</a></z><z id="t1503520366000283" t="souenzzo (mk-session &apos;full-ns.name &apos;full-ns.name2) works for me"><y>#</y><d>2017-08-23</d><h>20:32</h><w>souenzzo</w><code>(mk-session &apos;full-ns.name &apos;full-ns.name2)</code> works for me</z><z id="t1503520699000220" t="dadair seams to be working now 😕 shrug"><y>#</y><d>2017-08-23</d><h>20:38</h><w>dadair</w>seams to be working now <b>😕</b> shrug</z><z id="t1503520709000330" t="dadair must have had some weird REPL state"><y>#</y><d>2017-08-23</d><h>20:38</h><w>dadair</w>must have had some weird REPL state</z><z id="t1503647666000049" t="iku000888 Not sure how I can express this, but is there a way to express a left-join type of a rule?"><y>#</y><d>2017-08-25</d><h>07:54</h><w>iku000888</w>Not sure how I can express this, but is there a way to express a left-join type of a rule?</z><z id="t1503668643000177" t="mikerod @iku000888 I’m thinking you’d probably write 2 rules in that case"><y>#</y><d>2017-08-25</d><h>13:44</h><w>mikerod</w>@iku000888 I’m thinking you’d probably write 2 rules in that case</z><z id="t1503668656000584" t="mikerod or do some of the joining on the RHS - which I often hesitate to think is a good idea"><y>#</y><d>2017-08-25</d><h>13:44</h><w>mikerod</w>or do some of the joining on the RHS - which I often hesitate to think is a good idea</z><z id="t1503668720000418" t="mikerod (r/defrule joins [A (= ?id id)] [B (= ?id id)] =&gt; (r/insert! (-&gt;C))) (r/defrule nil-joins [A (= ?id id)] [:not [B (= ?id id)]] =&gt; (r/insert! (-&gt;C))) "><y>#</y><d>2017-08-25</d><h>13:45</h><w>mikerod</w><pre>(r/defrule joins
  [A (= ?id id)]
  [B (= ?id id)]
  =&gt;
  (r/insert! (-&gt;C)))

(r/defrule nil-joins
  [A (= ?id id)]
  [:not [B (= ?id id)]]
  =&gt;
  (r/insert! (-&gt;C)))
</pre></z><z id="t1503668725000333" t="mikerod is that the “left join” sort of thing?"><y>#</y><d>2017-08-25</d><h>13:45</h><w>mikerod</w>is that the “left join” sort of thing?</z><z id="t1503668782000476" t="mikerod A always produce a C , just sometimes there is no B to go with an A"><y>#</y><d>2017-08-25</d><h>13:46</h><w>mikerod</w><code>A</code> always produce a <code>C</code>, just sometimes there is no <code>B</code> to go with an <code>A</code></z><z id="t1503668795000283" t="mikerod C can hold whatever info you wanted out of the join"><y>#</y><d>2017-08-25</d><h>13:46</h><w>mikerod</w><code>C</code> can hold whatever info you wanted out of the join</z><z id="t1503879997000004" t="iku000888 @mikerod Thanks! I was struggling because for this specific problem coming up it was not clear how to create facts that are [:not [B (= ?id id)]]"><y>#</y><d>2017-08-28</d><h>00:26</h><w>iku000888</w>@mikerod Thanks! I was struggling because for this specific problem coming up it was not clear how to create facts that are <code>[:not [B (= ?id id)]]</code></z><z id="t1503880025000062" t="iku000888 (I would only have facts that are [B (= ?id id)] )"><y>#</y><d>2017-08-28</d><h>00:27</h><w>iku000888</w>(I would only have facts that are   <code>[B (= ?id id)]</code>)</z><z id="t1503880088000049" t="iku000888 But over the weekend I thought of retracting A&apos;s that do have a matching B"><y>#</y><d>2017-08-28</d><h>00:28</h><w>iku000888</w>But over the weekend I thought of retracting A&apos;s that do have a matching B</z><z id="t1503880097000093" t="iku000888 Seems it should do the job"><y>#</y><d>2017-08-28</d><h>00:28</h><w>iku000888</w>Seems it should do the job</z><z id="t1503880098000072" t="iku000888 🙂"><y>#</y><d>2017-08-28</d><h>00:28</h><w>iku000888</w><b>🙂</b></z><z id="t1504027259000050" t="dadair I have a shared entry point into a rule session where a namespace associated with specific rules/queries can be applied: (defn run-rules &quot;Runs a rule session given a rule namespace, a root state tree node, and a performed action.&quot; [ns root action] (let [session (-&gt; (r/mk-session &apos;justice.rules.shared ns) (r/insert (-&gt;Tree (walk/prewalk tree/augment-if-node root)) (-&gt;Action action)) (r/fire-rules))] ... However, I get a No namespace exception when I pass a namespace in eg. (run-rules &apos;justice.rules.x ..) . I&apos;ve &quot;fixed&quot; the issue by adding (require ns) inside run-rules , but is there a better way to accomplish this? I could for example just require the namespaces in the ns declaration, or I could have a whitelist of namespaces to require, but I&apos;d like to keep adding new namespaces to be as simple as creating a new namespace and passing it in to the generic shared entrypoint."><y>#</y><d>2017-08-29</d><h>17:20</h><w>dadair</w>I have a shared entry point into a rule session where a namespace associated with specific rules/queries can be applied:
<pre>(defn run-rules
  &quot;Runs a rule session given a rule namespace, a root state tree node, and a performed action.&quot;
  [ns root action]
  (let [session (-&gt; (r/mk-session &apos;justice.rules.shared ns)
                    (r/insert (-&gt;Tree (walk/prewalk tree/augment-if-node root))
                              (-&gt;Action action))
                    (r/fire-rules))]
  ...
</pre>
However, I get a <code>No namespace</code> exception when I pass a namespace in <code>eg. (run-rules &apos;justice.rules.x ..)</code>. I&apos;ve &quot;fixed&quot; the issue by adding <code>(require ns)</code> inside <code>run-rules</code>, but is there a better way to accomplish this? I could for example just require the namespaces in the <code>ns</code> declaration, or I could have a whitelist of namespaces to require, but I&apos;d like to keep adding new namespaces to be as simple as creating a new namespace and passing it in to the generic shared entrypoint.</z><z id="t1504034496000360" t="mikerod &gt; Thanks! I was struggling because for this specific problem coming up it was not clear how to create facts that are [:not [B (= ?id id)]] @iku000888 sorry for long delay, just saw your response. I’m not sure what you mean to create a fact to match a negation (ie condition with a :not ). The negation condition is used in conjuction with the [A (= ?id id)] in my example. This together forms a “join” sort of query for all A that do not have a matching B . So back to that example, repeating for clarity: (r/defrule joins [A (= ?id id)] [B (= ?id id)] =&gt; (r/insert! (-&gt;C))) (r/defrule nil-joins [A (= ?id id)] [:not [B (= ?id id)]] =&gt; (r/insert! (-&gt;C))) The rule names may not be the best, but sticking with them: * The rule joins is for the typical “inner join” matches - it matches A with B s they go with * The rule nil-joins is for the “outer left” part of the join - it keeps the A results that do not have any actual join with a B This may not be the specific issue you had, but that was my interpretation of your “left-join” type of rule question. Given that you have something with retraction working, I’m thinking this is a different problem you are wanting to solve."><y>#</y><d>2017-08-29</d><h>19:21</h><w>mikerod</w>&gt; Thanks! I was struggling because for this specific problem coming up it was not clear how to create facts that are <code>[:not [B (= ?id id)]]</code>
@iku000888 sorry for long delay, just saw your response. I’m not sure what you mean to create a fact to match a negation (ie condition with a <code>:not</code>). The negation condition is used in conjuction with the <code>[A (= ?id id)]</code> in my example. This together forms a “join” sort of query for all <code>A</code> that do not have a matching <code>B</code>.  So back to that example, repeating for clarity:

<pre>(r/defrule joins
  [A (= ?id id)]
  [B (= ?id id)]
  =&gt;
  (r/insert! (-&gt;C)))

(r/defrule nil-joins
  [A (= ?id id)]
  [:not [B (= ?id id)]]
  =&gt;
  (r/insert! (-&gt;C)))
</pre>

The rule names may not be the best, but sticking with them: 
* The rule <code>joins</code> is for the typical “inner join”  matches - it matches <code>A</code> with <code>B</code>s they go with
* The rule <code>nil-joins</code> is for the “outer left” part of the join - it keeps the <code>A</code> results that do not have any actual join with a <code>B</code>

This may not be the specific issue you had, but that was my interpretation of your “left-join” type of rule question.

Given that you have something with retraction working, I’m thinking this is a different problem you are wanting to solve.</z><z id="t1504034565000081" t="mikerod @dadair Clojure or ClojureScript?"><y>#</y><d>2017-08-29</d><h>19:22</h><w>mikerod</w>@dadair  Clojure or ClojureScript?</z><z id="t1504034700000284" t="mikerod Either way though, r/mk-session doesn’t attempt to require namespace for you."><y>#</y><d>2017-08-29</d><h>19:25</h><w>mikerod</w>Either way though, <code>r/mk-session</code> doesn’t attempt to require namespace for you.</z><z id="t1504034739000218" t="mikerod I’m not positive that would be a great idea either. Best practice in clj would be to be sure to appropriately declare the namespace you want to have compiled - most preferably in the ns header :require s"><y>#</y><d>2017-08-29</d><h>19:25</h><w>mikerod</w>I’m not positive that would be a great idea either. Best practice in clj would be to be sure to appropriately declare the namespace you want to have compiled - most preferably in the <code>ns</code> header <code>:require</code>s</z><z id="t1504034776000101" t="mikerod You could get away with a dynamic require call in your run-rules though. I’ve had use-cases doing that before to load rules from arbitrary namespaces"><y>#</y><d>2017-08-29</d><h>19:26</h><w>mikerod</w>You could get away with a dynamic <code>require</code> call in your <code>run-rules</code> though. I’ve had use-cases doing that before to load rules from arbitrary namespaces</z><z id="t1504034797000044" t="mikerod I don’t think there is a “better way to accomplish it” though in terms of what Clara currently offers."><y>#</y><d>2017-08-29</d><h>19:26</h><w>mikerod</w>I don’t think there is a “better way to accomplish it” though in terms of what Clara currently offers.</z><z id="t1504034811000436" t="mikerod It expects things to already be compiled"><y>#</y><d>2017-08-29</d><h>19:26</h><w>mikerod</w>It expects things to already be compiled</z><z id="t1504035658000063" t="dadair @mikerod thanks, this would be regular clojure. I&apos;ve moved away from dynamic require, as it was adding unnecessary compilation overhead (in terms of performance). I&apos;m still using a ns-whitelist var though rather than using the (ns .. (:require ..)) form as I&apos;ve had some formatters remove the references as they are &quot;unused&quot;."><y>#</y><d>2017-08-29</d><h>19:40</h><w>dadair</w>@mikerod thanks, this would be regular clojure. I&apos;ve moved away from dynamic require, as it was adding unnecessary compilation overhead (in terms of performance). I&apos;m still using a ns-whitelist var though rather than using the <code>(ns .. (:require ..))</code> form as I&apos;ve had some formatters remove the references as they are &quot;unused&quot;.</z><z id="t1504035707000184" t="mikerod Yeah, if you wait to do a require in the fn, it could be a pretty big slowdown depending on the size of it"><y>#</y><d>2017-08-29</d><h>19:41</h><w>mikerod</w>Yeah, if you wait to do a <code>require</code> in the fn, it could be a pretty big slowdown depending on the size of it</z><z id="t1504035722000503" t="mikerod and perhaps could be better suited at “compilation time” with whatever else you have to start up the app"><y>#</y><d>2017-08-29</d><h>19:42</h><w>mikerod</w>and perhaps could be better suited at “compilation time” with whatever else you have to start up the app</z><z id="t1504035761000439" t="mikerod Not to get too lost in the weeds, but Clara does have a few other alternatives instead of loading whole ns’s of rules"><y>#</y><d>2017-08-29</d><h>19:42</h><w>mikerod</w>Not to get too lost in the weeds, but Clara does have a few other alternatives instead of loading whole ns’s of rules</z><z id="t1504035941000646" t="mikerod For example, you can provide collections of rules to r/mk-session (defrule r1 &lt;etc&gt;) (defrule r2 &lt;etc&gt;) (defrule r3 &lt;etc&gt;) (def rule-group1 [r1 r2 r3]) (defrule r4 &lt;etc&gt;) (defrule r5 &lt;etc&gt;) (defquery q1 &lt;etc&gt;) (def rule-group2 [r4 r5 q1]) (defrule r6 &lt;etc&gt;) &lt;....&gt; (r/mk-session rule-group1 rule-group2 [r6]) "><y>#</y><d>2017-08-29</d><h>19:45</h><w>mikerod</w>For example, you can provide collections of rules to <code>r/mk-session</code>
<pre>(defrule r1 &lt;etc&gt;)
(defrule r2 &lt;etc&gt;)
(defrule r3 &lt;etc&gt;)

(def rule-group1 [r1 r2 r3])

(defrule r4 &lt;etc&gt;)
(defrule r5 &lt;etc&gt;)
(defquery q1 &lt;etc&gt;)

(def rule-group2 [r4 r5 q1])

(defrule r6 &lt;etc&gt;)


&lt;....&gt;

(r/mk-session rule-group1 rule-group2 [r6])
</pre></z><z id="t1504117488000105" t="wparker @dadair Agreed with @mikerod ‘s previous comments. I wanted to add that namespace compilation can have arbitrary effects in Clojure; one notable one is protocol extensions. That is, a linter removing namespace whose vars you aren’t directly using from your requires could be dangerous to things other than Clara. Also, note that require will short-circuits if the namespace already exists unless you specifically request reloading, so the performance question is really whether you pay the cost at initialization of your Clojure environment or the first time you build the relevant session."><y>#</y><d>2017-08-30</d><h>18:24</h><r>wparker</r>@dadair Agreed with @mikerod ‘s previous comments.  I wanted to add that namespace compilation can have arbitrary effects in Clojure; one notable one is protocol extensions.    That is, a linter removing namespace whose vars you aren’t directly using from your requires could be dangerous to things other than Clara.  Also, note that require will short-circuits if the namespace already exists unless you specifically request reloading, so the performance question is really whether you pay the cost at initialization of your Clojure environment or the first time you build the relevant session.</z><z id="t1504035961000433" t="mikerod so you can pick in choose at different granularities is my point"><y>#</y><d>2017-08-29</d><h>19:46</h><w>mikerod</w>so you can pick in choose at different granularities is my point</z><z id="t1504114693000117" t="mmer Hi I am a newbie who is looking to use clara to help understand large nested maps. Is there an easy way to turn a large nested map into a series of facts?"><y>#</y><d>2017-08-30</d><h>17:38</h><w>mmer</w>Hi I am a newbie who is looking to use clara to help understand large nested maps.  Is there an easy way to turn a large nested map into a series of facts?</z><z id="t1504117659000375" t="wparker @U4C3ZU6KX Not quite sure what your use-case is, but it seems like you could just use the normal map manipulation functions in clojure.core to create a “derived” sequence of facts to insert. Perhaps just a recursive function that concatenates the facts at each nested level of the map/level of recursion?"><y>#</y><d>2017-08-30</d><h>18:27</h><r>wparker</r>@U4C3ZU6KX Not quite sure what your use-case is, but it seems like you could just use the normal map manipulation functions in clojure.core to create a “derived” sequence of facts to insert.  Perhaps just a recursive function that concatenates the facts at each nested level of the map/level of recursion?</z><z id="t1504196571000209" t="dadair is it safe to call insert! from different threads? e.g., within a future ? I have a way to not need this (e.g., gather data with the future and then insert! from the main thread), I&apos;m more just curious."><y>#</y><d>2017-08-31</d><h>16:22</h><w>dadair</w>is it safe to call <code>insert!</code> from different threads? e.g., within a <code>future</code>? I have a way to not need this (e.g., gather data with the future and then insert! from the main thread), I&apos;m more just curious.</z><z id="t1504201341000112" t="mikerod @dadair I think that is a sort of tough question"><y>#</y><d>2017-08-31</d><h>17:42</h><w>mikerod</w>@dadair I think that is a sort of tough question</z><z id="t1504201352000649" t="mikerod It seems dangerous to assume semantically"><y>#</y><d>2017-08-31</d><h>17:42</h><w>mikerod</w>It seems dangerous to assume semantically</z><z id="t1504201383000043" t="mikerod I do think that implementation-wise, as long as every thread has fully completed their r/insert! prior to r/fire-rules it may work"><y>#</y><d>2017-08-31</d><h>17:43</h><w>mikerod</w>I do think that implementation-wise, as long as every thread has fully completed their <code>r/insert!</code> prior to <code>r/fire-rules</code> it may work</z><z id="t1504201392000571" t="mikerod That isn’t to say I think it is a supported use-case"><y>#</y><d>2017-08-31</d><h>17:43</h><w>mikerod</w>That isn’t to say I think it is a supported use-case</z><z id="t1504201429000078" t="mikerod So in general, during the “fire rules loop” cycle of the rules engine, the memory is in a mutable state"><y>#</y><d>2017-08-31</d><h>17:43</h><w>mikerod</w>So in general, during the “fire rules loop” cycle of the rules engine, the memory is in a mutable state</z><z id="t1504201472000435" t="mikerod This is done primarily for performance. The caller perceives the working memory to be a persistent, immutable data structure that is returned after each call to r/fire-rules on a given sesion"><y>#</y><d>2017-08-31</d><h>17:44</h><w>mikerod</w>This is done primarily for performance. The caller perceives the working memory to be a persistent, immutable data structure that is returned after each call to <code>r/fire-rules</code> on a given sesion</z><z id="t1504201511000017" t="mikerod However, r/insert! (and a few other similar ones) is called from rule RHS’s. That means it is sort of in that “fire rules loop” part of the lifecycle"><y>#</y><d>2017-08-31</d><h>17:45</h><w>mikerod</w>However, <code>r/insert!</code> (and a few other similar ones) is called from rule RHS’s. That means it is sort of in that “fire rules loop” part of the lifecycle</z><z id="t1504201834000444" t="dadair yeah that makes sense, I thought as much"><y>#</y><d>2017-08-31</d><h>17:50</h><w>dadair</w>yeah that makes sense, I thought as much</z><z id="t1504213648000234" t="souenzzo accumulators respect saliency?"><y>#</y><d>2017-08-31</d><h>21:07</h><w>souenzzo</w>accumulators respect saliency?</z><z id="t1504220427000341" t="wparker @souenzzo salience controls when a rule RHS (right-hand side, or consequence in other terms) fires; whether an accumulator is in the rule doesn’t impact it either way. It won’t control the time you actually run the accumulator, though I’m not sure why you’d want to do that."><y>#</y><d>2017-08-31</d><h>23:00</h><w>wparker</w>@souenzzo salience controls when a rule RHS (right-hand side, or consequence in other terms) fires; whether an accumulator is in the rule doesn’t impact it either way.  It won’t control the time you actually run the accumulator, though I’m not sure why you’d want to do that.</z><z id="t1504276281000476" t="mikerod Well, I know Drools (popular Java-based rules engine)(prior to v6) used to have a good amount of performance issues around accumulators."><y>#</y><d>2017-09-01</d><h>14:31</h><w>mikerod</w>Well, I know Drools (popular Java-based rules engine)(prior to v6) used to have a good amount of performance issues around accumulators.</z><z id="t1504276288000110" t="mikerod Especially several in a rule"><y>#</y><d>2017-09-01</d><h>14:31</h><w>mikerod</w>Especially several in a rule</z><z id="t1504276316000174" t="mikerod so people used to wish that salience would “delay” their evaluation"><y>#</y><d>2017-09-01</d><h>14:31</h><w>mikerod</w>so people used to wish that salience would “delay” their evaluation</z><z id="t1504276346000146" t="mikerod Later on, a lot of laziness was added to Drools, but even more importantly (in my opinion) “batched” propagations of facts and it mostly solved the common issues around performance that came up."><y>#</y><d>2017-09-01</d><h>14:32</h><w>mikerod</w>Later on, a lot of laziness was added to Drools, but even more importantly (in my opinion) “batched” propagations of facts and it mostly solved the common issues around performance that came up.</z><z id="t1504276367000497" t="mikerod Clara has “batched” propagation of facts, which seems to typically work out well. The engine basically “gathers” up collections of facts at a time that are matching conditions before propagating down the network. This results in typically less churn/rework as the data flows."><y>#</y><d>2017-09-01</d><h>14:32</h><w>mikerod</w>Clara has “batched” propagation of facts, which seems to typically work out well. The engine basically “gathers” up collections of facts at a time that are matching conditions before propagating down the network. This results in typically less churn/rework as the data flows.</z><z id="t1504276393000470" t="mikerod Just pointing that out if the question of salience was more about performance than ordering semantics"><y>#</y><d>2017-09-01</d><h>14:33</h><w>mikerod</w>Just pointing that out if the question of salience was more about performance than ordering semantics</z><z id="t1504288881000270" t="dadair I&apos;m not sure if this is directly tied to clara, but I am noticing a severe processing time drop the first time I run a rules session with a specific namespace. So for example, (-&gt; (r/mk-session &apos;some.ns) (r/insert ..) .. (r/fire-rules)) takes 1000ms the first time it is called, but 50ms the second time. Is there some way I can reduce that first performance hit?"><y>#</y><d>2017-09-01</d><h>18:01</h><w>dadair</w>I&apos;m not sure if this is directly tied to clara, but I am noticing a severe processing time drop the first time I run a rules session with a specific namespace. So for example, <code>(-&gt; (r/mk-session &apos;some.ns) (r/insert ..) .. (r/fire-rules))</code> takes 1000ms the first time it is called, but 50ms the second time. Is there some way I can reduce that first performance hit?</z><z id="t1504288948000374" t="dadair I know I need to profile the app to be sure what&apos;s going on, just darn jprofiler is too expensive &gt;.&lt;"><y>#</y><d>2017-09-01</d><h>18:02</h><w>dadair</w>I know I need to profile the app to be sure what&apos;s going on, just darn jprofiler is too expensive &gt;.&lt;</z><z id="t1504292423000587" t="mikerod @dadair well, you can use visualvm for free"><y>#</y><d>2017-09-01</d><h>19:00</h><w>mikerod</w>@dadair well, you can use <code>visualvm</code> for free</z><z id="t1504292434000180" t="mikerod which I’ve had enough luck with when profiling rules before"><y>#</y><d>2017-09-01</d><h>19:00</h><w>mikerod</w>which I’ve had enough luck with when profiling rules before</z><z id="t1504292483000211" t="mikerod Oh, r/mk-session creates and then caches the rulebase (Rete graph)"><y>#</y><d>2017-09-01</d><h>19:01</h><w>mikerod</w>Oh, <code>r/mk-session</code> creates and then caches the rulebase (Rete graph)</z><z id="t1504292506000057" t="mikerod Can you (r/mk-session &apos;some.ns) sometime earlier - like “startup”?"><y>#</y><d>2017-09-01</d><h>19:01</h><w>mikerod</w>Can you <code>(r/mk-session &apos;some.ns)</code> sometime earlier - like “startup”?</z><z id="t1504292545000148" t="mikerod You’ll still take the hit though. Just maybe you could move the hit out of the processing where it is more painful."><y>#</y><d>2017-09-01</d><h>19:02</h><w>mikerod</w>You’ll still take the hit though. Just maybe you could move the hit out of the processing where it is more painful.</z><z id="t1504294447000283" t="dadair awesome thank you, that will solve my issues (and thanks for the nudge at visualvm, looks good too!)"><y>#</y><d>2017-09-01</d><h>19:34</h><w>dadair</w>awesome thank you, that will solve my issues (and thanks for the nudge at visualvm, looks good too!)</z><z id="t1504294741000301" t="dadair @mikerod if I different collections of ns (i.e., (r/mk-session &apos;ns.a &apos;ns.b &apos;ns.c) vs (r/mk-session &apos;ns.d &apos;ns.e &apos;ns.f) can I pre-cache individual namespaces e.g. (r/mk-session &apos;ns.a) ? Or would I have to pre-cache full collections (r/mk-session &apos;ns.a &apos;ns.b &apos;ns.c) ? Basically, can I init each individually, if they are used in collections? Or will it only cache on the full collection."><y>#</y><d>2017-09-01</d><h>19:39</h><w>dadair</w>@mikerod if I different collections of ns (i.e., <code>(r/mk-session &apos;ns.a &apos;ns.b &apos;ns.c)</code> vs <code>(r/mk-session &apos;ns.d &apos;ns.e &apos;ns.f)</code> can I pre-cache individual namespaces e.g. <code>(r/mk-session &apos;ns.a)</code>? Or would I have to pre-cache full collections <code>(r/mk-session &apos;ns.a &apos;ns.b &apos;ns.c)</code>? Basically, can I init each individually, if they are used in collections? Or will it only cache on the full collection.</z><z id="t1504296319000173" t="mikerod @dadair glad you can work with that. Building the rulebase graph can be a fairly expensive operation. It could perhaps be further optimized in Clara, but there are tricky aspects."><y>#</y><d>2017-09-01</d><h>20:05</h><w>mikerod</w>@dadair glad you can work with that. Building the rulebase graph can be a fairly expensive operation. It could perhaps be further optimized in Clara, but there are tricky aspects.</z><z id="t1504296342000045" t="mikerod For one, there is some eval going on, which means it is running the clj compiler and I often see that time dominate for larger rulebase’s"><y>#</y><d>2017-09-01</d><h>20:05</h><w>mikerod</w>For one, there is some <code>eval</code> going on, which means it is running the clj compiler and I often see that time dominate for larger rulebase’s</z><z id="t1504296375000135" t="mikerod (terminology things: the “rulebase” term just means the underlying “statess” Rete-based graph that is wired together with working memory within the “session”)"><y>#</y><d>2017-09-01</d><h>20:06</h><w>mikerod</w>(terminology things: the “rulebase” term just means the underlying “statess” Rete-based graph that is wired together with working memory within the “session”)</z><z id="t1504296396000027" t="mikerod To answer your next question, you have to build the r/mk-session with all rules/queries involved at once"><y>#</y><d>2017-09-01</d><h>20:06</h><w>mikerod</w>To answer your next question, you have to build the <code>r/mk-session</code> with all rules/queries involved at once</z><z id="t1504296402000028" t="mikerod Can’t build piece-by-piece"><y>#</y><d>2017-09-01</d><h>20:06</h><w>mikerod</w>Can’t build piece-by-piece</z><z id="t1504303001000144" t="dadair ok great thank you @mikerod"><y>#</y><d>2017-09-01</d><h>21:56</h><w>dadair</w>ok great thank you @mikerod</z><z id="t1504728238000019" t="mmer Hi there - very simple question - what is the best way to insert a list of records? I am banging my head against a wall - hence the request for help"><y>#</y><d>2017-09-06</d><h>20:03</h><w>mmer</w>Hi there - very simple question - what is the best way to insert a list of records?  I am banging my head against a wall - hence the request for help</z><z id="t1504728506000541" t="enn @mmer see insert-all!"><y>#</y><d>2017-09-06</d><h>20:08</h><w>enn</w>@mmer see <code>insert-all!</code></z><z id="t1504728560000394" t="mmer I tried that and when I look at the trace it is not inserting anything?"><y>#</y><d>2017-09-06</d><h>20:09</h><w>mmer</w>I tried that and when I look at the trace it is not inserting anything?</z><z id="t1504728768000388" t="wparker @mmer are you doing this insertion from outside the session or in a rule right-hand side (consequence)?"><y>#</y><d>2017-09-06</d><h>20:12</h><w>wparker</w>@mmer are you doing this insertion from outside the session or in a rule right-hand side (consequence)?</z><z id="t1504728840000311" t="mmer The problem is that I have a function returning a lazySeq and that is preventing it from being loaded! Thanks -not a clara issue at all."><y>#</y><d>2017-09-06</d><h>20:14</h><w>mmer</w>The problem is that I have a function returning a lazySeq and that is preventing it from being loaded!  Thanks -not a clara issue at all.</z><z id="t1504729874000235" t="wparker :+1: just for completeness - the ! variants are to be used in rules, the variants without ! are to be used outside the session"><y>#</y><d>2017-09-06</d><h>20:31</h><w>wparker</w><b>:+1:</b> just for completeness - the ! variants are to be used in rules, the variants without ! are to be used outside the session</z><z id="t1504737573000058" t="mmer Thanks - I got it working - highly nested maps caught me out along with laziness."><y>#</y><d>2017-09-06</d><h>22:39</h><w>mmer</w>Thanks - I got it working - highly nested maps caught me out along with laziness.</z><z id="t1504737612000291" t="mmer I do have another question - in the [:test] block what expressions can be used. For example is the following valid?"><y>#</y><d>2017-09-06</d><h>22:40</h><w>mmer</w>I do have another question - in the [:test] block what expressions can be used.  For example is the following valid?</z><z id="t1504737649000026" t="mmer I seem to be getting a NullPointer error."><y>#</y><d>2017-09-06</d><h>22:40</h><w>mmer</w>I seem to be getting a NullPointer error.</z><z id="t1504738417000025" t="mmer The reason for the NullPointer was that I was passing nil into :test."><y>#</y><d>2017-09-06</d><h>22:53</h><w>mmer</w>The reason for the NullPointer was that I was passing nil into :test.</z><z id="t1504760245000094" t="dadair Is there any reason why a LHS such as [A (= ?x x)] [B (= ?y y)] where x and y definitely exist (non-nil), would not fire with the order [A ..] [B ..] but would fire with [B ..] [A ..] ?"><y>#</y><d>2017-09-07</d><h>04:57</h><w>dadair</w>Is there any reason why a LHS such as <code>[A (= ?x x)] [B (= ?y y)]</code> where <code>x</code> and <code>y</code> definitely exist (non-nil), would not fire with the order <code>[A ..] [B ..]</code> but would fire with <code>[B ..] [A ..]</code>?</z><z id="t1504791761000255" t="mikerod @dadair I don’t see how it should be different. Do you have a more complete rule example?"><y>#</y><d>2017-09-07</d><h>13:42</h><w>mikerod</w>@dadair I don’t see how it should be different. Do you have a more complete rule example?</z><z id="t1504791773000036" t="mikerod Just to be sure you don’t have any extra constructs in play?"><y>#</y><d>2017-09-07</d><h>13:42</h><w>mikerod</w>Just to be sure you don’t have any extra constructs in play?</z><z id="t1504796028000276" t="wparker @dadair @U0LK1552A I wouldn’t expect that kind of ordering to make a difference for non-accumulator rule conditions normally. If you are using manual retractions in rule RHS’s (right-hand-sides) you might be able to get yourself into some odd situations with undefined behavior that could be impacted. A more concrete reproducing example would be helpful to see if there’s a bug. For accumulators, it isn’t the easiest edge case to hit, but https://github.com/cerner/clara-rules/issues/218 is outstanding."><y>#</y><d>2017-09-07</d><h>14:53</h><r>wparker</r>@dadair @U0LK1552A I wouldn’t expect that kind of ordering to make a difference for non-accumulator rule conditions normally.  If you are using manual retractions in rule RHS’s (right-hand-sides) you might be able to get yourself into some odd situations with undefined behavior that could be impacted.  A more concrete reproducing example would be helpful to see if there’s a bug.  For accumulators, it isn’t the easiest edge case to hit, but <a href="https://github.com/cerner/clara-rules/issues/218" target="_blank">https://github.com/cerner/clara-rules/issues/218</a> is outstanding.</z><z id="t1504796093000146" t="wparker Also, regarding your example `[A (= ?x x)] [B (= ?y y)] ` I wouldn’t actually expect whether x or y is nil to impact whether the rule fires at least based on those conditions alone"><y>#</y><d>2017-09-07</d><h>14:54</h><r>wparker</r>Also, regarding your example <pre>`[A (= ?x x)] [B (= ?y y)]</pre>` I wouldn’t actually expect whether x or y is nil to impact whether the rule fires at least based on those conditions alone</z><z id="t1504796212000100" t="wparker those aren’t result bindings, having a field value of a fact be nil (but the fact itself being nil) is a reasonable possibility and Clara will handle that"><y>#</y><d>2017-09-07</d><h>14:56</h><r>wparker</r>those aren’t result bindings, having a field value of a fact be nil (but the fact itself being nil) is a reasonable possibility and Clara will handle that</z><z id="t1504796591000133" t="mikerod Yep, that’s the reason was asking for more details to be sure there aren’t things like accumulators in play. Things get more complicated then."><y>#</y><d>2017-09-07</d><h>15:03</h><r>mikerod</r>Yep, that’s the reason was asking for more details to be sure there aren’t things like accumulators in play. Things get more complicated then.</z><z id="t1504801244000183" t="dadair There seemed to be an issue with using a pre-cached rule session. I was looping through some known mk-session configurations and swapping them into an atom so I could avoid the first performance hit. Then later I&apos;d pull the specific session out of the atom and would insert some facts and fire rules. For some reason this was causing really weird rule activation problems"><y>#</y><d>2017-09-07</d><h>16:20</h><r>dadair</r>There seemed to be an issue with using a pre-cached rule session. I was looping through some known mk-session configurations and swapping them into an atom so I could avoid the first performance hit. Then later I&apos;d pull the specific session out of the atom and would insert some facts and fire rules. For some reason this was causing really weird rule activation problems</z><z id="t1504801315000642" t="dadair So for now I&apos;ve inlined the mk-session and am taking the performance hit until I can figure out what was going on"><y>#</y><d>2017-09-07</d><h>16:21</h><r>dadair</r>So for now I&apos;ve inlined the mk-session and am taking the performance hit until I can figure out what was going on</z><z id="t1504793002000004" t="mmer Could someone please explain the rhs please - I have put a print and an insert! following on from each other on the rhs and the print always happens even if the rule fails?"><y>#</y><d>2017-09-07</d><h>14:03</h><w>mmer</w>Could someone please explain the rhs please - I have put a print and an insert! following on from each other on the rhs and the print always happens even if the rule fails?</z><z id="t1504793546000663" t="mikerod @mmer The most typical way to structure rules is in a way that they logically express their constraints, but do not necessarily have a guaranteed order the RHS may fire in. insert! inserts facts that are subject to the “truth maintenance system” (aka the TMS) of the rules engine. If a rule fires at some point due to a, potentially transient, match of some facts, but later some of those facts are retracted, the engine will automatically retract the facts that relied on that match being present."><y>#</y><d>2017-09-07</d><h>14:12</h><w>mikerod</w>@mmer The most typical way to structure rules is in a way that they logically express their constraints, but do not necessarily have a guaranteed order the RHS may fire in. <code>insert!</code> inserts facts that are subject to the “truth maintenance system” (aka the TMS) of the rules engine. If a rule fires at some point due to a, potentially transient, match of some facts, but later some of those facts are retracted, the engine will automatically retract the facts that relied on that match being present.</z><z id="t1504793564000621" t="mikerod When you do a side-effect like a print , there is no way to “retract” the side effect"><y>#</y><d>2017-09-07</d><h>14:12</h><w>mikerod</w>When you do a side-effect like a <code>print</code>, there is no way to “retract” the side effect</z><z id="t1504793679000031" t="mikerod There are ways to structure rules that would prevent them from being able to ever fire their RHS “early”. This can be done with setting up the rule to not be able to fire due to some “blocking” or “guarding” criteria in the LHS that you know will not change it’s truthiness later. Also, you can sometimes do some tricks with :salience . However, in many cases, the best idea may be to just avoid the side-effects in the RHS and perhaps do them outside of the rules based on the facts that are found via queries after performing a fire-rules cycle."><y>#</y><d>2017-09-07</d><h>14:14</h><w>mikerod</w>There are ways to structure rules that would prevent them from being able to ever fire their RHS “early”. This can be done with setting up the rule to not be able to fire due to some “blocking” or “guarding” criteria in the LHS that you know will not change it’s truthiness later. Also, you can sometimes do some tricks with <code>:salience</code>.

However, in many cases, the best idea may be to just avoid the side-effects in the RHS and perhaps do them outside of the rules based on the facts that are found via queries after performing a <code>fire-rules</code> cycle.</z><z id="t1504793722000683" t="mikerod There is some documentation on the TMS @ http://www.clara-rules.org/docs/truthmaint/"><y>#</y><d>2017-09-07</d><h>14:15</h><w>mikerod</w>There is some documentation on the TMS @ <a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a></z><z id="t1504794354000467" t="mmer That helps. I thought I was going mad!"><y>#</y><d>2017-09-07</d><h>14:25</h><w>mmer</w>That helps.  I thought I was going mad!</z><z id="t1504795008000738" t="mikerod @mmer yeah, it can be a tricky detail"><y>#</y><d>2017-09-07</d><h>14:36</h><w>mikerod</w>@mmer yeah, it can be a tricky detail</z><z id="t1504795103000294" t="mmer The docs say you can nest the boolean operators [:not, :or] etc. I have tried to do something like [:not [:or [] []] without much success. Is this just plain wrong on my part?"><y>#</y><d>2017-09-07</d><h>14:38</h><w>mmer</w>The docs say you can nest the boolean operators [:not, :or] etc.  I have tried to do something like [:not [:or [] []]  without much success.  Is this just plain wrong on my part?</z><z id="t1504796204000013" t="mikerod @mmer things can get a little tricky with that"><y>#</y><d>2017-09-07</d><h>14:56</h><w>mikerod</w>@mmer things can get a little tricky with that</z><z id="t1504796233000098" t="mikerod So it is good to note that :or is sort of “syntactic sugar” in rules"><y>#</y><d>2017-09-07</d><h>14:57</h><w>mikerod</w>So it is good to note that <code>:or</code> is sort of “syntactic sugar” in rules</z><z id="t1504796256000483" t="mikerod It can almost be thought of as just splitting the rule into 2 (or more depending on logic in use) rules"><y>#</y><d>2017-09-07</d><h>14:57</h><w>mikerod</w>It can almost be thought of as just splitting the rule into 2 (or more depending on logic in use) rules</z><z id="t1504796371000081" t="mikerod e.g. (r/defrule with-or [A (= ?id id)] [:or [B (= ?id id)] [C (= ?id id)]] =&gt; (r/insert! (-&gt;D))) Is similar to just writing (r/defrule side-one [A (= ?id id)] [B (= ?id id)] =&gt; (r/insert! (-&gt;D))) (r/defrule side-two [A (= ?id id)] [C (= ?id id)] =&gt; (r/insert! (-&gt;D))) "><y>#</y><d>2017-09-07</d><h>14:59</h><w>mikerod</w>e.g.
<pre>(r/defrule with-or
  [A (= ?id id)]
  [:or
   [B (= ?id id)]
   [C (= ?id id)]]
  =&gt;
  (r/insert! (-&gt;D)))
</pre>
Is similar to just writing
<pre>(r/defrule side-one
  [A (= ?id id)]
  [B (= ?id id)]
  =&gt;
  (r/insert! (-&gt;D)))

(r/defrule side-two
  [A (= ?id id)]
  [C (= ?id id)]
  =&gt;
  (r/insert! (-&gt;D)))

</pre></z><z id="t1504796382000121" t="mikerod The point in that case is that there isn’t something like “short-circuiting”"><y>#</y><d>2017-09-07</d><h>14:59</h><w>mikerod</w>The point in that case is that there isn’t something like “short-circuiting”</z><z id="t1504796402000376" t="mikerod and the :or has certain variable visibility issues due to how that works out"><y>#</y><d>2017-09-07</d><h>15:00</h><w>mikerod</w>and the <code>:or</code> has certain variable visibility issues due to how that works out</z><z id="t1504796425000586" t="mikerod When it comes to :not + :or and/or nested :and , it may also be good to note that the engine will convert to DNF (disjunctive normal form)"><y>#</y><d>2017-09-07</d><h>15:00</h><w>mikerod</w>When it comes to <code>:not</code> + <code>:or</code> and/or nested <code>:and</code>, it may also be good to note that the engine will convert to DNF (disjunctive normal form)</z><z id="t1504796457000457" t="mikerod There may be some variable visibility issues in that transition in certain complex cases"><y>#</y><d>2017-09-07</d><h>15:00</h><w>mikerod</w>There may be some variable visibility issues in that transition in certain complex cases</z><z id="t1504797193000035" t="mikerod @mmer but if you have an example that demonstrates an issue you are seeing, it’d be probably clearer to just look at that one and explain what is going on"><y>#</y><d>2017-09-07</d><h>15:13</h><w>mikerod</w>@mmer but if you have an example that demonstrates an issue you are seeing, it’d be probably clearer to just look at that one and explain what is going on</z><z id="t1504797276000088" t="mmer I have eventually just split the rules in two so I do not need the not"><y>#</y><d>2017-09-07</d><h>15:14</h><w>mmer</w>I have eventually just split the rules in two so I do not need the not</z><z id="t1504797719000820" t="mikerod sometimes it is clearer to split things up from an comprehension perspective anyways"><y>#</y><d>2017-09-07</d><h>15:21</h><w>mikerod</w>sometimes it is clearer to split things up from an comprehension perspective anyways</z><z id="t1504797887000294" t="mikerod Probably the most details on this subject can be found in the lengthy old issue comments @ https://github.com/cerner/clara-rules/issues/149"><y>#</y><d>2017-09-07</d><h>15:24</h><w>mikerod</w>Probably the most details on this subject can be found in the lengthy old issue comments @ <a href="https://github.com/cerner/clara-rules/issues/149" target="_blank">https://github.com/cerner/clara-rules/issues/149</a></z><z id="t1504797896000043" t="mikerod as far as some of the transformations that happen"><y>#</y><d>2017-09-07</d><h>15:24</h><w>mikerod</w>as far as some of the transformations that happen</z><z id="t1504797933000845" t="mikerod Only if you were interesting in details though. 😛 Probably not super easy to read through."><y>#</y><d>2017-09-07</d><h>15:25</h><w>mikerod</w>Only if you were interesting in details though. <b>😛</b> Probably not super easy to read through.</z><z id="t1504799081000152" t="mmer Thanks"><y>#</y><d>2017-09-07</d><h>15:44</h><w>mmer</w>Thanks</z><z id="t1504800282000056" t="mmer To be more precise - when I load up the rules/queries into the session I get :"><y>#</y><d>2017-09-07</d><h>16:04</h><w>mmer</w>To be more precise - when I load up the rules/queries into the session I get :</z><z id="t1504800286000477" t="mmer ExceptionInfo Value does not match schema: {:constraints [(not (&quot;s-expression&quot; ?composition)) (not (&quot;s-expression&quot; a-clojure.lang.Symbol))]} schema.core/validator/fn--1296 (core.clj:155)"><y>#</y><d>2017-09-07</d><h>16:04</h><w>mmer</w>ExceptionInfo Value does not match schema: {:constraints [(not (&quot;s-expression&quot; ?composition)) (not (&quot;s-expression&quot; a-clojure.lang.Symbol))]}  schema.core/validator/fn--1296 (core.clj:155)</z><z id="t1504801335000406" t="wparker @mmer that looks like a syntax error in a rule/query"><y>#</y><d>2017-09-07</d><h>16:22</h><r>wparker</r>@mmer that looks like a syntax error in a rule/query</z><z id="t1504800305000341" t="mmer What sort of thing am I looking for in my rule etc?"><y>#</y><d>2017-09-07</d><h>16:05</h><w>mmer</w>What sort of thing am I looking for in my rule etc?</z><z id="t1504803500000123" t="mikerod It’s hard to decipher without the actual rule DSL that was written (probably could be improved in Clara to try to capture that better) There is probably some missing [ ] if not just having syntax out of order"><y>#</y><d>2017-09-07</d><h>16:58</h><w>mikerod</w>It’s hard to decipher without the actual rule DSL that was written (probably could be improved in Clara to try to capture that better)
There is probably some missing <code>[ ]</code> if not just having syntax out of order</z><z id="t1505225461000401" t="dadair I have a singleton fact that I insert for referencing that contains a large map (hundreds of KB), and is a part of the LHS of most of my rules, so that the RHS can use the map when inserting more rules. Are there any performance issues to consider here? Or ways to exploit the fact that it is a singleton and will never need to be compared between multiple instances? I know with persistent structures it isn&apos;t inefficient to have the large map in multiple places, but was wondering last night if perhaps there was a better way to reference it. The LHS query for it is dead simple: [Tree (= ?root root)] in all cases"><y>#</y><d>2017-09-12</d><h>14:11</h><w>dadair</w>I have a singleton fact that I insert for referencing that contains a large map (hundreds of KB), and is a part of the LHS of most of my rules, so that the RHS can use the map when inserting more rules. Are there any performance issues to consider here? Or ways to exploit the fact that it is a singleton and will never need to be compared between multiple instances? I know with persistent structures it isn&apos;t inefficient to have the large map in multiple places, but was wondering last night if perhaps there was a better way to reference it. The LHS query for it is dead simple: <code>[Tree (= ?root root)]</code> in all cases</z><z id="t1505234994000108" t="mikerod @dadair I don’t know of anything particularly harmful in the big fact like that"><y>#</y><d>2017-09-12</d><h>16:49</h><w>mikerod</w>@dadair I don’t know of anything particularly harmful in the big fact like that</z><z id="t1505235010000314" t="mikerod It’s probably best to make sure it has a “type” that is distinct from anything else"><y>#</y><d>2017-09-12</d><h>16:50</h><w>mikerod</w>It’s probably best to make sure it has a “type” that is distinct from anything else</z><z id="t1505235054000319" t="mikerod beyond that, assuming it is immutable (as facts should be), a cached hashcode may become important"><y>#</y><d>2017-09-12</d><h>16:50</h><w>mikerod</w>beyond that, assuming it is immutable (as facts should be), a cached hashcode may become important</z><z id="t1505235080000351" t="mikerod Clojure persistent maps cache hashcode"><y>#</y><d>2017-09-12</d><h>16:51</h><w>mikerod</w>Clojure persistent maps cache hashcode</z><z id="t1505235127000392" t="mikerod You could also consider wrapping the big map in a custom type that optimizes equality checking and hashing too if you had noticeable perf issues come up"><y>#</y><d>2017-09-12</d><h>16:52</h><w>mikerod</w>You could also consider wrapping the big map in a custom type that optimizes equality checking and hashing too if you had noticeable perf issues come up</z><z id="t1505235269000485" t="mikerod You’re example does look like you have a type on it called Tree though, so I am not sure what implications that type has"><y>#</y><d>2017-09-12</d><h>16:54</h><w>mikerod</w>You’re example does look like you have a type on it called <code>Tree</code> though, so I am not sure what implications that type has</z><z id="t1505235410000476" t="dadair Tree is just a record wrapper around a map so it works with the default Fact type identification"><y>#</y><d>2017-09-12</d><h>16:56</h><w>dadair</w><code>Tree</code> is just a record wrapper around a map so it works with the default Fact type identification</z><z id="t1505235499000168" t="mikerod For clarity: There are basically 2 situations that come to mind in this scenario: 1) How often is this big fact going to be compared to other different facts? 2) This big fact will be part of a token that is stored in memory. This token is sometimes used as a hash map sort of key. If this is hashed too often, the hash code may become a bottleneck. For (1) If the fact has a unique type that no other facts have, it should only ever be compared to maybe itself. The equals check should be fast tehre since most equals impl’s will short-circuit on the identical? (or Java == case) For (2) Clojure maps default to caching hash codes. Clojure records do not, prior to what looks like 1.9 (not yet fully released at least (see https://dev.clojure.org/jira/browse/CLJ-1224 ))"><y>#</y><d>2017-09-12</d><h>16:58</h><w>mikerod</w>For clarity: There are basically 2 situations that come to mind in this scenario:
1) How often is this big fact going to be compared to other different facts?
2) This big fact will be part of a token that is stored in memory. This token is sometimes used as a hash map sort of key. If this is hashed too often, the hash code may become  a bottleneck.

For (1)
If the fact has a unique type that no other facts have, it should only ever be compared to maybe itself. The equals check should be fast tehre since most equals impl’s will short-circuit on the <code>identical?</code> (or Java <code>==</code> case)

For (2)
Clojure maps default to caching hash codes. Clojure records do not, prior to what looks like 1.9 (not yet fully released at least (see <a href="https://dev.clojure.org/jira/browse/CLJ-1224" target="_blank">https://dev.clojure.org/jira/browse/CLJ-1224</a>))</z><z id="t1505235547000773" t="mikerod So if anything, if your Tree wrapper is made via defrecord , you may be able to see some time spent recalculating the hash code when if this fact ends up being involved in a lot of rules LHS “tokens”"><y>#</y><d>2017-09-12</d><h>16:59</h><w>mikerod</w>So if anything, if your <code>Tree</code> wrapper is made via <code>defrecord</code>, you may be able to see some time spent recalculating the hash code when if this fact ends up being involved in a lot of rules LHS “tokens”</z><z id="t1505235570000241" t="mikerod Tokens contain a sequence of all the facts that matched for a particular successful invocation of the rule"><y>#</y><d>2017-09-12</d><h>16:59</h><w>mikerod</w>Tokens contain a sequence of all the facts that matched for a particular successful invocation of the rule</z><z id="t1505235615000182" t="mikerod Then again, I may not get worked up about this situation unless you can see measurable issues with perf"><y>#</y><d>2017-09-12</d><h>17:00</h><w>mikerod</w>Then again, I may not get worked up about this situation unless you can see measurable issues with perf</z><z id="t1505235778000301" t="dadair Thanks for the advice, I&apos;m just trying to keep some performance considerations in my back pocket in case I need to improve performance. This Tree is somewhat like a database, so it will continue to grow over time. I&apos;m already seeing processing times approach &gt;= 100ms for the rule engine and I generally want things to be below ~50ms for some soft real-time constraints we have"><y>#</y><d>2017-09-12</d><h>17:02</h><w>dadair</w>Thanks for the advice, I&apos;m just trying to keep some performance considerations in my back pocket in case I need to improve performance. This <code>Tree</code> is somewhat like a database, so it will continue to grow over time. I&apos;m already seeing processing times approach &gt;= 100ms for the rule engine and I generally want things to be below ~50ms for some soft real-time constraints we have</z><z id="t1505235840000045" t="mikerod hmm"><y>#</y><d>2017-09-12</d><h>17:04</h><w>mikerod</w>hmm</z><z id="t1505235868000212" t="mikerod I typically use VisualVM"><y>#</y><d>2017-09-12</d><h>17:04</h><w>mikerod</w>I typically use VisualVM</z><z id="t1505235873000001" t="mikerod start the “sampling CPU” profiler"><y>#</y><d>2017-09-12</d><h>17:04</h><w>mikerod</w>start the “sampling CPU” profiler</z><z id="t1505235877000240" t="dadair to clarify: the tree does not change within a rule session, only between rule sessions"><y>#</y><d>2017-09-12</d><h>17:04</h><w>dadair</w>to clarify: the tree does not change within a rule session, only between rule sessions</z><z id="t1505235880000397" t="mikerod then run whatever takes the tiem I’m interested in"><y>#</y><d>2017-09-12</d><h>17:04</h><w>mikerod</w>then run whatever takes the tiem I’m interested in</z><z id="t1505235900000064" t="mikerod then you take a “snapshot”, view the snapshot by drilling down through a fairly large callstack"><y>#</y><d>2017-09-12</d><h>17:05</h><w>mikerod</w>then you take a “snapshot”, view the snapshot by drilling down through a fairly large callstack</z><z id="t1505235909000174" t="mikerod it has visuals to show how much time is being spent where in the callstacks"><y>#</y><d>2017-09-12</d><h>17:05</h><w>mikerod</w>it has visuals to show how much time is being spent where in the callstacks</z><z id="t1505235960000584" t="mikerod For this particular concern I had above, I’d just try to get to the “bottom” of the larger time callstacks and see if I can find references to, in this example, the Tree object getting equiv or hash sort of calls on it"><y>#</y><d>2017-09-12</d><h>17:06</h><w>mikerod</w>For this particular concern I had above, I’d just try to get to the “bottom” of the larger time callstacks and see if I can find references to, in this example, the <code>Tree</code> object getting <code>equiv</code> or <code>hash</code> sort of calls on it</z><z id="t1505236070000417" t="dadair great I&apos;ll give that a try, thanks"><y>#</y><d>2017-09-12</d><h>17:07</h><w>dadair</w>great I&apos;ll give that a try, thanks</z><z id="t1505236220000475" t="mikerod no problem. I’m always willing to take a look at a profiler snapshot, a portion of it, or just say “I see lots of time in Clara function X, any ideas?” too if you find those parts to be hard to sort through. I’m not sure how easy it may be to read profiler snapshots sometimes if not familiar with the codebase and/or the way clj compiles out java class names"><y>#</y><d>2017-09-12</d><h>17:10</h><w>mikerod</w>no problem. I’m always willing to take a look at a profiler snapshot, a portion of it, or just say “I see lots of time in Clara function X, any ideas?” too if you find those parts to be hard to sort through. I’m not sure how easy it may be to read profiler snapshots sometimes if not familiar with the codebase and/or the way clj compiles out java class names</z><z id="t1505261166000189" t="olivergeorge I&apos;m experimenting to see if I can rewrite my webapp form logic using Clara rules."><y>#</y><d>2017-09-13</d><h>00:06</h><w>olivergeorge</w>I&apos;m experimenting to see if I can rewrite my webapp form logic using Clara rules.</z><z id="t1505261317000191" t="olivergeorge The existing code does multiple passes: Field definitions and values used to generate cleaned field data and errors Field data and errors used by logic which might (1) show/hide fields, (2) disable/enable fields, (3) change field values, (4) manage relationships between fields... (lots of stuff). I borrowed the approach Django uses for form and field validation, they document it well here: https://docs.djangoproject.com/en/1.11/ref/forms/validation/"><y>#</y><d>2017-09-13</d><h>00:08</h><w>olivergeorge</w>The existing code does multiple passes:
Field definitions and values used to generate cleaned field data and errors
Field data and errors used by logic which might (1) show/hide fields, (2) disable/enable fields, (3) change field values, (4) manage relationships between fields... (lots of stuff).
I borrowed the approach Django uses for form and field validation, they document it well here: <a href="https://docs.djangoproject.com/en/1.11/ref/forms/validation/" target="_blank">https://docs.djangoproject.com/en/1.11/ref/forms/validation/</a></z><z id="t1505261338000152" t="olivergeorge The current approach has functions which take the form (field definitions, values...) and return a modified version"><y>#</y><d>2017-09-13</d><h>00:08</h><w>olivergeorge</w>The current approach has functions which take the form (field definitions, values...) and return a modified version</z><z id="t1505261352000087" t="olivergeorge Iteratively manipulating the data"><y>#</y><d>2017-09-13</d><h>00:09</h><w>olivergeorge</w>Iteratively manipulating the data</z><z id="t1505261364000050" t="olivergeorge I don&apos;t think Clara would work in this way"><y>#</y><d>2017-09-13</d><h>00:09</h><w>olivergeorge</w>I don&apos;t think Clara would work in this way</z><z id="t1505261469000238" t="olivergeorge My guess is I need each phase to have it&apos;s own facts so that each phase of the form processing can use previous phase&apos;s facts as inputs."><y>#</y><d>2017-09-13</d><h>00:11</h><w>olivergeorge</w>My guess is I need each phase to have it&apos;s own facts so that each phase of the form processing can use previous phase&apos;s facts as inputs.</z><z id="t1505261481000086" t="olivergeorge Not sure if I&apos;m explaining that well"><y>#</y><d>2017-09-13</d><h>00:11</h><w>olivergeorge</w>Not sure if I&apos;m explaining that well</z><z id="t1505261588000037" t="olivergeorge Specific question: Am I correct that it&apos;s a bad idea to try and reproduce the &quot;modify data&quot; approach I&apos;m currently using."><y>#</y><d>2017-09-13</d><h>00:13</h><w>olivergeorge</w>Specific question: Am I correct that it&apos;s a bad idea to try and reproduce the &quot;modify data&quot; approach I&apos;m currently using.</z><z id="t1505262342000015" t="dadair @olivergeorge correct, mutating data in Clara is discouraged (though not impossible). I am doing something similar actually with form field- and form-level validation. I don&apos;t do multi-pass internally in the rule engine, but rather the rule engine is called multiple times from (essentially) a reduce, which collects the final modifications to perform at the end"><y>#</y><d>2017-09-13</d><h>00:25</h><w>dadair</w>@olivergeorge correct, mutating data in Clara is discouraged (though not impossible). I am doing something similar actually with form field- and form-level validation. I don&apos;t do multi-pass internally in the rule engine, but rather the rule engine is called multiple times from (essentially) a reduce, which collects the final modifications to perform at the end</z><z id="t1505262360000183" t="dadair so the rule engine doesn&apos;t actually modify the forms, rather it returns what operations to perform in order to modify it"><y>#</y><d>2017-09-13</d><h>00:26</h><w>dadair</w>so the rule engine doesn&apos;t actually modify the forms, rather it returns what operations to perform in order to modify it</z><z id="t1505262382000030" t="dadair then the reduce can take those, perform them, and send the modified form back to the rule engine, and it goes until it stabilizes"><y>#</y><d>2017-09-13</d><h>00:26</h><w>dadair</w>then the reduce can take those, perform them, and send the modified form back to the rule engine, and it goes until it stabilizes</z><z id="t1505263235000051" t="olivergeorge Gotcha, thanks @dadair that makes sense"><y>#</y><d>2017-09-13</d><h>00:40</h><w>olivergeorge</w>Gotcha, thanks @dadair that makes sense</z><z id="t1505266668000085" t="olivergeorge @dadair how do you check for stability? data comparison or does clara provide a &quot;no new facts&quot; test"><y>#</y><d>2017-09-13</d><h>01:37</h><w>olivergeorge</w>@dadair how do you check for stability?  data comparison or does clara provide a &quot;no new facts&quot; test</z><z id="t1505266792000130" t="dadair stability from the rules side of things would be it returning from fire-rules , otherwise it wouldn keep going. &quot;stability&quot; in terms of your domain is different. For example, in that external reduce you would query the session for operations , if the query returns nothing, you could know that &quot;the form is stable&quot;"><y>#</y><d>2017-09-13</d><h>01:39</h><w>dadair</w>stability from the rules side of things would be it returning from <code>fire-rules</code>, otherwise it wouldn keep going. &quot;stability&quot; in terms of your domain is different. For example, in that external reduce you would <code>query</code> the session for <code>operations</code>, if the query returns nothing, you could know that &quot;the form is stable&quot;</z><z id="t1505266809000057" t="dadair it all depends on how you set up your system"><y>#</y><d>2017-09-13</d><h>01:40</h><w>dadair</w>it all depends on how you set up your system</z><z id="t1505266848000077" t="olivergeorge Thanks again"><y>#</y><d>2017-09-13</d><h>01:40</h><w>olivergeorge</w>Thanks again</z><z id="t1505266893000044" t="dadair I am in no way an expert on rule systems though, I&apos;m just getting into it myself, that&apos;s just the approach I&apos;ve taken so far"><y>#</y><d>2017-09-13</d><h>01:41</h><w>dadair</w>I am in no way an expert on rule systems though, I&apos;m just getting into it myself, that&apos;s just the approach I&apos;ve taken so far</z><z id="t1505266958000050" t="olivergeorge Right, interesting stuff. I imagine there&apos;s typical examples we can learn from in other similar rule systems."><y>#</y><d>2017-09-13</d><h>01:42</h><w>olivergeorge</w>Right, interesting stuff.  I imagine there&apos;s typical examples we can learn from in other similar rule systems.</z><z id="t1505272889000079" t="dadair Anyone have any advice re: calming Cursive x cannot be resolved warnings when using Clara?"><y>#</y><d>2017-09-13</d><h>03:21</h><w>dadair</w>Anyone have any advice re: calming Cursive <code>x cannot be resolved</code> warnings when using Clara?</z><z id="t1505272951000089" t="dadair eg ^"><y>#</y><d>2017-09-13</d><h>03:22</h><w>dadair</w>eg ^</z><z id="t1505272964000020" t="dadair for all the LHS bindings"><y>#</y><d>2017-09-13</d><h>03:22</h><w>dadair</w>for all the LHS bindings</z><z id="t1505272988000118" t="cfleming @dadair Unfortunately there isn’t a good solution for that yet. If the warnings bother you you can turn them off at Settings-&amp;gt;Languages &amp;amp; Frameworks-&amp;gt;Clojure-&amp;gt;Highlight unresolved symbols."><y>#</y><d>2017-09-13</d><h>03:23</h><w>cfleming</w>@dadair Unfortunately there isn’t a good solution for that yet. If the warnings bother you you can turn them off at Settings-&amp;gt;Languages &amp;amp; Frameworks-&amp;gt;Clojure-&amp;gt;Highlight unresolved symbols.</z><z id="t1505273012000040" t="cfleming The drawback to that is that you also won’t get symbols that really are undefined highlighted."><y>#</y><d>2017-09-13</d><h>03:23</h><w>cfleming</w>The drawback to that is that you also won’t get symbols that really are undefined highlighted.</z><z id="t1505273040000081" t="cfleming Sadly until Cursive understands Clara better (which I am hoping to get to soon-ish) that’s the best option."><y>#</y><d>2017-09-13</d><h>03:24</h><w>cfleming</w>Sadly until Cursive understands Clara better (which I am hoping to get to soon-ish) that’s the best option.</z><z id="t1505273122000116" t="dadair Is there a pluggable way for lib maintainers/etc to help with those endeavours?"><y>#</y><d>2017-09-13</d><h>03:25</h><w>dadair</w>Is there a pluggable way for lib maintainers/etc to help with those endeavours?</z><z id="t1505273178000141" t="cfleming Not yet, but it’s planned."><y>#</y><d>2017-09-13</d><h>03:26</h><w>cfleming</w>Not yet, but it’s planned.</z><z id="t1505273200000155" t="cfleming If you were really keen, one thing that would help a lot would be to develop specs for the Clara macro forms."><y>#</y><d>2017-09-13</d><h>03:26</h><w>cfleming</w>If you were really keen, one thing that would help a lot would be to develop specs for the Clara macro forms.</z><z id="t1505273235000038" t="cfleming I’m hoping to be able to semi-automatically migrate those to Cursive, and I’m sure it would be a valuable contribution to Clara too."><y>#</y><d>2017-09-13</d><h>03:27</h><w>cfleming</w>I’m hoping to be able to semi-automatically migrate those to Cursive, and I’m sure it would be a valuable contribution to Clara too.</z><z id="t1505273313000069" t="cfleming We’ve discussed doing that in this channel previously, but AFAIK no-one has taken up the torch."><y>#</y><d>2017-09-13</d><h>03:28</h><w>cfleming</w>We’ve discussed doing that in this channel previously, but AFAIK no-one has taken up the torch.</z><z id="t1505273320000094" t="cfleming (me included)"><y>#</y><d>2017-09-13</d><h>03:28</h><w>cfleming</w>(me included)</z><z id="t1505273545000037" t="olivergeorge @cfleming what format would you prefer specs in? (no promises but curious)"><y>#</y><d>2017-09-13</d><h>03:32</h><w>olivergeorge</w>@cfleming what format would you prefer specs in?  (no promises but curious)</z><z id="t1505273580000077" t="cfleming @olivergeorge Just the specs themselves, i.e. the specs defining the grammar of the macro forms."><y>#</y><d>2017-09-13</d><h>03:33</h><w>cfleming</w>@olivergeorge Just the specs themselves, i.e. the specs defining the grammar of the macro forms.</z><z id="t1505273580000083" t="dadair Maybe we can get specs done through group effort?"><y>#</y><d>2017-09-13</d><h>03:33</h><w>dadair</w>Maybe we can get specs done through group effort?</z><z id="t1505273598000017" t="cfleming @dadair That would be awesome, and I’d like to help."><y>#</y><d>2017-09-13</d><h>03:33</h><w>cfleming</w>@dadair That would be awesome, and I’d like to help.</z><z id="t1505273623000029" t="dadair Clara is integral to my work so don&apos;t mind putting some time in if it gets better integrated into cursive"><y>#</y><d>2017-09-13</d><h>03:33</h><w>dadair</w>Clara is integral to my work so don&apos;t mind putting some time in if it gets better integrated into cursive</z><z id="t1505273661000187" t="cfleming I don’t actually use Clara myself, but I’m keen to use it as an example of migrating a real-world spec to Cursive."><y>#</y><d>2017-09-13</d><h>03:34</h><w>cfleming</w>I don’t actually use Clara myself, but I’m keen to use it as an example of migrating a real-world spec to Cursive.</z><z id="t1505273715000136" t="cfleming @olivergeorge This sort of thing is what I have in mind: https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj"><y>#</y><d>2017-09-13</d><h>03:35</h><w>cfleming</w>@olivergeorge This sort of thing is what I have in mind: <a href="https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj" target="_blank">https://github.com/clojure/core.specs.alpha/blob/master/src/main/clojure/clojure/core/specs/alpha.clj</a></z><z id="t1505273731000022" t="cfleming i.e. specs in a form that would be useful for Clara itself too."><y>#</y><d>2017-09-13</d><h>03:35</h><w>cfleming</w>i.e. specs in a form that would be useful for Clara itself too.</z><z id="t1505273747000084" t="olivergeorge Good stuff. Wondered if that&apos;s what you meant."><y>#</y><d>2017-09-13</d><h>03:35</h><w>olivergeorge</w>Good stuff.  Wondered if that&apos;s what you meant.</z><z id="t1505273784000005" t="olivergeorge Shouldn&apos;t be too bad given they&apos;ve taken the time to document the syntax with railway tracks in the doco (is that the right term)"><y>#</y><d>2017-09-13</d><h>03:36</h><w>olivergeorge</w>Shouldn&apos;t be too bad given they&apos;ve taken the time to document the syntax with railway tracks in the doco (is that the right term)</z><z id="t1505273797000061" t="cfleming Railroad diagrams, yeah"><y>#</y><d>2017-09-13</d><h>03:36</h><w>cfleming</w>Railroad diagrams, yeah</z><z id="t1505273808000005" t="cfleming They’re not complete, but they should be a good start."><y>#</y><d>2017-09-13</d><h>03:36</h><w>cfleming</w>They’re not complete, but they should be a good start.</z><z id="t1505273864000161" t="cfleming I suspect there are lots of gnarly corners though, or at least that’s what I’m given to understand. But I think there’s a lot of code using Clara out there so hopefully if we can convince users to test it then we should get the edge cases out fairly quickly."><y>#</y><d>2017-09-13</d><h>03:37</h><w>cfleming</w>I suspect there are lots of gnarly corners though, or at least that’s what I’m given to understand. But I think there’s a lot of code using Clara out there so hopefully if we can convince users to test it then we should get the edge cases out fairly quickly.</z><z id="t1505273884000154" t="olivergeorge Sounds good"><y>#</y><d>2017-09-13</d><h>03:38</h><w>olivergeorge</w>Sounds good</z><z id="t1505273955000023" t="cfleming Having specs would also help non-Cursive users check the grammars too."><y>#</y><d>2017-09-13</d><h>03:39</h><w>cfleming</w>Having specs would also help non-Cursive users check the grammars too.</z><z id="t1505274078000083" t="cfleming Previous discussion: https://clojurians-log.clojureverse.org/clara/2017-06-29.html"><y>#</y><d>2017-09-13</d><h>03:41</h><w>cfleming</w>Previous discussion: <a href="https://clojurians-log.clojureverse.org/clara/2017-06-29.html" target="_blank">https://clojurians-log.clojureverse.org/clara/2017-06-29.html</a></z><z id="t1505274116000079" t="cfleming One question would be whether the Clara specs would be best developed in Clara itself or in a separate project."><y>#</y><d>2017-09-13</d><h>03:41</h><w>cfleming</w>One question would be whether the Clara specs would be best developed in Clara itself or in a separate project.</z><z id="t1505274157000033" t="olivergeorge Yeah, I wondered that. I guess it&apos;s less intrusive to start with a separate repo. Taking lead from clojure..."><y>#</y><d>2017-09-13</d><h>03:42</h><w>olivergeorge</w>Yeah, I wondered that.  I guess it&apos;s less intrusive to start with a separate repo.  Taking lead from clojure...</z><z id="t1505274164000019" t="olivergeorge I have a meeting soon so signing off"><y>#</y><d>2017-09-13</d><h>03:42</h><w>olivergeorge</w>I have a meeting soon so signing off</z><z id="t1505274179000089" t="olivergeorge If anyone can tell me what I&apos;m doing wrong with acc/all here I&apos;d love to know: https://gist.github.com/olivergeorge/e37ff239783e1de8f97804bf472047a4"><y>#</y><d>2017-09-13</d><h>03:42</h><w>olivergeorge</w>If anyone can tell me what I&apos;m doing wrong with acc/all here I&apos;d love to know: <a href="https://gist.github.com/olivergeorge/e37ff239783e1de8f97804bf472047a4" target="_blank">https://gist.github.com/olivergeorge/e37ff239783e1de8f97804bf472047a4</a></z><z id="t1505286056000138" t="olivergeorge Worked it out. bidi required an earlier version of prismatic so I missed this fix https://github.com/cerner/clara-rules/issues/306"><y>#</y><d>2017-09-13</d><h>07:00</h><r>olivergeorge</r>Worked it out.  bidi required an earlier version of prismatic so I missed this fix  
<a href="https://github.com/cerner/clara-rules/issues/306" target="_blank">https://github.com/cerner/clara-rules/issues/306</a></z><z id="t1505274186000086" t="cfleming Ok, cool - I’d definitely like to pursue this."><y>#</y><d>2017-09-13</d><h>03:43</h><w>cfleming</w>Ok, cool - I’d definitely like to pursue this.</z><z id="t1505274210000042" t="olivergeorge I&apos;ll put up my hand to help on the spec front but not familar with clara so someone else would need to lead."><y>#</y><d>2017-09-13</d><h>03:43</h><w>olivergeorge</w>I&apos;ll put up my hand to help on the spec front but not familar with clara so someone else would need to lead.</z><z id="t1505274297000006" t="cfleming Ok. I can create a project to hold the WIP specs and have a go at it, hopefully later this week."><y>#</y><d>2017-09-13</d><h>03:44</h><w>cfleming</w>Ok. I can create a project to hold the WIP specs and have a go at it, hopefully later this week.</z><z id="t1505276448000005" t="dadair I&apos;ll help where I can if you post the repo"><y>#</y><d>2017-09-13</d><h>04:20</h><w>dadair</w>I&apos;ll help where I can if you post the repo</z><z id="t1505276640000090" t="cfleming @dadair Great, thanks."><y>#</y><d>2017-09-13</d><h>04:24</h><w>cfleming</w>@dadair Great, thanks.</z><z id="t1505323107000475" t="dadair What&apos;s the best way for debugging rules? Cursive breakpoints aren&apos;t reachable it seems (not surprising since the rules aren&apos;t &quot;called&quot;, but rather exist within a session registry and are also macros). Currently I just add print statements and try to reason things out"><y>#</y><d>2017-09-13</d><h>17:18</h><w>dadair</w>What&apos;s the best way for debugging rules? Cursive breakpoints aren&apos;t reachable it seems (not surprising since the rules aren&apos;t &quot;called&quot;, but rather exist within a session registry and are also macros). Currently I just add print statements and try to reason things out</z><z id="t1505323832000352" t="mikerod @dadair some of this may be helpful http://www.clara-rules.org/docs/inspection/"><y>#</y><d>2017-09-13</d><h>17:30</h><w>mikerod</w>@dadair some of this may be helpful <a href="http://www.clara-rules.org/docs/inspection/" target="_blank">http://www.clara-rules.org/docs/inspection/</a></z><z id="t1505323910000031" t="mikerod Sometimes I end up just mutating some testing atoms state from various points in rules though when I’m confused. The inspection may be a bit of a nicer approach."><y>#</y><d>2017-09-13</d><h>17:31</h><w>mikerod</w>Sometimes I end up just mutating some testing atoms state from various points in rules though when I’m confused. The inspection may be a bit of a nicer approach.</z><z id="t1505323950000334" t="mikerod There is clara.tools.inspect and clara.tools.trace that could both potentially be useful. The tests for these features in src/test may be helpful to see some usages."><y>#</y><d>2017-09-13</d><h>17:32</h><w>mikerod</w>There is <code>clara.tools.inspect</code> and <code>clara.tools.trace</code> that could both potentially be useful. The tests for these features in <code>src/test</code> may be helpful to see some usages.</z><z id="t1505324243000124" t="dadair great I&apos;ll take a look at that thanks"><y>#</y><d>2017-09-13</d><h>17:37</h><w>dadair</w>great I&apos;ll take a look at that thanks</z><z id="t1505325653000786" t="mikerod @dadair Tests of the tracing like https://github.com/cerner/clara-rules/blob/0.15.2/src/test/common/clara/tools/test_tracing.cljc#L67 may be useful"><y>#</y><d>2017-09-13</d><h>18:00</h><w>mikerod</w>@dadair Tests of the tracing like <a href="https://github.com/cerner/clara-rules/blob/0.15.2/src/test/common/clara/tools/test_tracing.cljc#L67" target="_blank">https://github.com/cerner/clara-rules/blob/0.15.2/src/test/common/clara/tools/test_tracing.cljc#L67</a> may be useful</z><z id="t1505325659000277" t="mikerod inspection is more human-readable I think"><y>#</y><d>2017-09-13</d><h>18:00</h><w>mikerod</w>inspection is more human-readable I think</z><z id="t1505325676000454" t="mikerod but the tracing sometimes has good data to work with, but can be a lot so have to pikc it apart some"><y>#</y><d>2017-09-13</d><h>18:01</h><w>mikerod</w>but the tracing sometimes has good data to work with, but can be a lot so have to pikc it apart some</z><z id="t1505331736000405" t="wparker Clara-rules 0.16.0 is released and on Clojars. Relative to 0.15.2 (the previous released version) this is a bugfix release for https://github.com/cerner/clara-rules/issues/303"><y>#</y><d>2017-09-13</d><h>19:42</h><w>wparker</w>Clara-rules 0.16.0 is released and on Clojars.  Relative to 0.15.2 (the previous released version) this is a bugfix release for <a href="https://github.com/cerner/clara-rules/issues/303" target="_blank">https://github.com/cerner/clara-rules/issues/303</a></z><z id="t1505332802000309" t="dadair Is there a benefit/drawback to doing: [A (false? x)] instead of [A (= ?x x)] [:test (false? ?x)] "><y>#</y><d>2017-09-13</d><h>20:00</h><w>dadair</w>Is there a benefit/drawback to doing:
<pre>[A (false? x)]
</pre>
instead of
<pre>[A (= ?x x)]
[:test (false? ?x)]
</pre></z><z id="t1505333009000421" t="wparker For constraints that can be determined to be true or false without any reference to other facts Clara will evaluate them upfront without trying to join them with anything and if they are false Clara won’t retain a reference to them"><y>#</y><d>2017-09-13</d><h>20:03</h><r>wparker</r>For constraints that can be determined to be true or false without any reference to other facts Clara will evaluate them upfront without trying to join them with anything and if they are false Clara won’t retain a reference to them</z><z id="t1505333039000231" t="wparker So for example, in the latter case, I’d expect Clara to retain a hard reference to every A inserted"><y>#</y><d>2017-09-13</d><h>20:03</h><r>wparker</r>So for example, in the latter case, I’d expect Clara to retain a hard reference to every A inserted</z><z id="t1505333062000443" t="wparker while in the former case, it wouldn’t retain a reference to an A without a value of false in field x"><y>#</y><d>2017-09-13</d><h>20:04</h><r>wparker</r>while in the former case, it wouldn’t retain a reference to an A without a value of false in field x</z><z id="t1505333157000455" t="wparker In cases where you do joins it can also be more efficient to have Clara do as much filtering as it can on each fact in isolation - apart from evaluating your join criteria, there is some (highly optimized) overhead to keeping track of joins"><y>#</y><d>2017-09-13</d><h>20:05</h><r>wparker</r>In cases where you do joins it can also be more efficient to have Clara do as much filtering as it can on each fact in isolation - apart from evaluating your join criteria, there is some (highly optimized) overhead to keeping track of joins</z><z id="t1505333307000437" t="dadair ok great thanks"><y>#</y><d>2017-09-13</d><h>20:08</h><r>dadair</r>ok great thanks</z><z id="t1505332821000026" t="dadair other than if you want to use ?x later in the RHS"><y>#</y><d>2017-09-13</d><h>20:00</h><w>dadair</w>other than if you want to use ?x later in the RHS</z><z id="t1505337582000474" t="mikerod @dadair I’d tend to just suggest to not use :test unless you have a use-case that it can’t be avoided"><y>#</y><d>2017-09-13</d><h>21:19</h><w>mikerod</w>@dadair I’d tend to just suggest to not use <code>:test</code> unless you have a use-case that it can’t be avoided</z><z id="t1505337595000369" t="mikerod it just is more opaque to the engine and could mean you’re skipping out on optimizations"><y>#</y><d>2017-09-13</d><h>21:19</h><w>mikerod</w>it just is more opaque to the engine and could mean you’re skipping out on optimizations</z><z id="t1505337768000167" t="dadair makes sense, thanks!"><y>#</y><d>2017-09-13</d><h>21:22</h><w>dadair</w>makes sense, thanks!</z><z id="t1505338402000057" t="mikerod As far as the actual effects of the example you give here, I don’t know there is a big difference. There is definitely a “little” more overhead to adding the :test node, but I’m not sure you lose any particular optimizations in this particular case. I’d have to mess with it more to be sure though. However, still, I’d just go with my general rule here. 🙂"><y>#</y><d>2017-09-13</d><h>21:33</h><w>mikerod</w>As far as the actual effects of the example you give here, I don’t know there is a big difference. There is definitely a “little” more overhead to adding the <code>:test</code> node, but I’m not sure you lose any particular optimizations in this particular case. I’d have to mess with it more to be sure though. However, still, I’d just go with my general rule here. <b>🙂</b></z><z id="t1505338556000276" t="dadair absolutely, thanks for the help!"><y>#</y><d>2017-09-13</d><h>21:35</h><w>dadair</w>absolutely, thanks for the help!</z><z id="t1505342904000057" t="olivergeorge I&apos;m trying to encode some form logic which disables dependent fields (e.g. can&apos;t pick building if site isn&apos;t set, can&apos;t pick floor if building isn&apos;t set...)"><y>#</y><d>2017-09-13</d><h>22:48</h><w>olivergeorge</w>I&apos;m trying to encode some form logic which disables dependent fields (e.g. can&apos;t pick building if site isn&apos;t set, can&apos;t pick floor if building isn&apos;t set...)</z><z id="t1505342938000273" t="olivergeorge My rules don&apos;t terminate"><y>#</y><d>2017-09-13</d><h>22:48</h><w>olivergeorge</w>My rules don&apos;t terminate</z><z id="t1505342958000211" t="olivergeorge (ns spike-rules.core (:require [clara.rules :as rules :refer [insert! defrule defquery defsession]] [clara.rules.accumulators :as acc])) (defrecord Field [field-key field-state]) (defrecord FieldState [field-key field-state]) (defrecord Operation [field-key field-state]) (defrule rule1 &quot;Insert FieldState based on Field and Operations&quot; [?field &lt;- Field (= field-key ?field-key)] [?ops &lt;- (acc/all :field-state) :from [Operation (= field-key ?field-key)]] =&gt; (println :update-fieldstate ?field-key) (insert! (-&gt;FieldState ?field-key (reduce merge (:field-state ?field) ?ops)))) (defrule rule2 &quot;Insert field disable operation if a field depends on a field which is not set&quot; [FieldState (= ?nil-field-key field-key) (= (nil? (:value field-state)))] [FieldState (= ?disable-field-key field-key) (contains? (:depends-on field-state) ?nil-field-key)] =&gt; (println :disable-dependent ?disable-field-key) (insert! (-&gt;Operation ?disable-field-key {:disabled true}))) (defsession form-session [rule1 rule2]) (-&gt; form-session (rules/insert (-&gt;Field :site {:value nil}) (-&gt;Field :bl {:value nil :depends-on #{:site}}) (-&gt;Field :fl {:value nil :depends-on #{:bl}})) (rules/fire-rules))"><y>#</y><d>2017-09-13</d><h>22:49</h><w>olivergeorge</w><pre>(ns spike-rules.core
  (:require [clara.rules :as rules :refer [insert! defrule defquery defsession]]
            [clara.rules.accumulators :as acc]))

(defrecord Field [field-key field-state])
(defrecord FieldState [field-key field-state])
(defrecord Operation [field-key field-state])

(defrule rule1
  &quot;Insert FieldState based on Field and Operations&quot;
  [?field &lt;- Field (= field-key ?field-key)]
  [?ops &lt;- (acc/all :field-state) :from [Operation (= field-key ?field-key)]]
  =&gt;
  (println :update-fieldstate ?field-key)
  (insert! (-&gt;FieldState ?field-key (reduce merge (:field-state ?field) ?ops))))

(defrule rule2
  &quot;Insert field disable operation if a field depends on a field which is not set&quot;
  [FieldState (= ?nil-field-key field-key) (= (nil? (:value field-state)))]
  [FieldState (= ?disable-field-key field-key) (contains? (:depends-on field-state) ?nil-field-key)]
  =&gt;
  (println :disable-dependent ?disable-field-key)
  (insert! (-&gt;Operation ?disable-field-key {:disabled true})))

(defsession form-session [rule1 rule2])

(-&gt; form-session
    (rules/insert
      (-&gt;Field :site {:value nil})
      (-&gt;Field :bl {:value nil :depends-on #{:site}})
      (-&gt;Field :fl {:value nil :depends-on #{:bl}}))
    (rules/fire-rules))</pre></z><z id="t1505343014000307" t="olivergeorge Perhaps rule1 is bad practice. I&apos;m using it to combine the original field state with any operations which modify it. (in this case adding a :disable flag)"><y>#</y><d>2017-09-13</d><h>22:50</h><w>olivergeorge</w>Perhaps rule1 is bad practice.  I&apos;m using it to combine the original field state with any operations which modify it.  (in this case adding a :disable flag)</z><z id="t1505343096000372" t="olivergeorge @dadair I was trying to avoid having to do the &quot;merge field with ops&quot; manually and refiring rules. That&apos;s the approach you were describing, correct?"><y>#</y><d>2017-09-13</d><h>22:51</h><w>olivergeorge</w>@dadair I was trying to avoid having to do the &quot;merge field with ops&quot; manually and refiring rules.  That&apos;s the approach you were describing, correct?</z><z id="t1505343488000054" t="dadair We actually do it slightly differently. In our case, the rule engine inserts the current state of the form, and the operation the user is trying to perform. Then there are rules that check if that operation is valid given the current state of the form. If it&apos;s valid, it returns a transformation of the input action that can actually be performed/persisted by an external state management service. If it&apos;s invalid, it transforms the input action to an action that will invalidate the field (or reject the action out-right), which is then again carried out by the external state management service"><y>#</y><d>2017-09-13</d><h>22:58</h><w>dadair</w>We actually do it slightly differently. In our case, the rule engine inserts the current state of the form, and the operation the user is trying to perform. Then there are rules that check if that operation is valid given the current state of the form. If it&apos;s valid, it returns a transformation of the input action that can actually be performed/persisted by an external state management service.  If it&apos;s invalid, it transforms the input action to an action that will invalidate the field (or reject the action out-right), which is then again carried out by the external state management service</z><z id="t1505343546000162" t="defndaines Might add in a (println &quot;?ops &quot; ?ops) as part of rule1 ."><y>#</y><d>2017-09-13</d><h>22:59</h><w>defndaines</w>Might add in a
<pre>(println &quot;?ops &quot; ?ops)
</pre> as part of <code>rule1</code>.</z><z id="t1505344272000164" t="olivergeorge @defndaines that shows that rule1 is firing repeatedly for the empty ops case. Loading src/spike_rules/round1.clj... :update-fieldstate :site [] :update-fieldstate :fl [] :update-fieldstate :bl [] :disable-dependent :fl :disable-dependent :bl :update-fieldstate :fl [] :update-fieldstate :bl [] :disable-dependent :bl :disable-dependent :fl :update-fieldstate :bl [] :update-fieldstate :fl [] Hmm, that makes me think it&apos;s not doing what I expect. It should have an operation for disabling that field."><y>#</y><d>2017-09-13</d><h>23:11</h><w>olivergeorge</w>@defndaines that shows that rule1 is firing repeatedly for the empty ops case.
<pre>Loading src/spike_rules/round1.clj... 
:update-fieldstate :site []
:update-fieldstate :fl []
:update-fieldstate :bl []
:disable-dependent :fl
:disable-dependent :bl
:update-fieldstate :fl []
:update-fieldstate :bl []
:disable-dependent :bl
:disable-dependent :fl
:update-fieldstate :bl []
:update-fieldstate :fl []</pre>

Hmm, that makes me think it&apos;s not doing what I expect.   It should have an operation for disabling that field.</z><z id="t1505344339000218" t="olivergeorge @dadair thanks, as you say it&apos;s slightly different to what I&apos;m focused on but sounds interesting... I&apos;ll get to that I expect."><y>#</y><d>2017-09-13</d><h>23:12</h><w>olivergeorge</w>@dadair thanks, as you say it&apos;s slightly different to what I&apos;m focused on but sounds interesting... I&apos;ll get to that I expect.</z><z id="t1505344769000244" t="olivergeorge Looks like I&apos;m not best friends with acc/all yet"><y>#</y><d>2017-09-13</d><h>23:19</h><w>olivergeorge</w>Looks like I&apos;m not best friends with acc/all yet</z><z id="t1505345075000119" t="defndaines Maybe check with some?"><y>#</y><d>2017-09-13</d><h>23:24</h><w>defndaines</w>Maybe check with <code>some?</code></z><z id="t1505345205000198" t="olivergeorge @defndaines I don&apos;t think that would work. I want field -&gt; fieldstate even if ops is empty. That way rule2 has a full list of field-state facts to consider."><y>#</y><d>2017-09-13</d><h>23:26</h><w>olivergeorge</w>@defndaines I don&apos;t think that would work.  I want field -&gt; fieldstate even if ops is empty.  That way rule2 has a full list of field-state facts to consider.</z><z id="t1505345232000206" t="olivergeorge Problem is that acc/all doesn&apos;t seem to ever return the inserted Operations facts"><y>#</y><d>2017-09-13</d><h>23:27</h><w>olivergeorge</w>Problem is that acc/all doesn&apos;t seem to ever return the inserted Operations facts</z><z id="t1505345397000113" t="olivergeorge There&apos;s a feedback loop which seems a possible problem: * rule 1 inserts FieldState (before any Operations are inserted) * rule 2 fires because it sees a FieldState which should be disabled * rule 1 sees a new Operation and does truth maintenance to update the field&apos;s FieldState"><y>#</y><d>2017-09-13</d><h>23:29</h><w>olivergeorge</w>There&apos;s a feedback loop which seems a possible problem:
* rule 1 inserts FieldState (before any Operations are inserted)
* rule 2 fires because it sees a FieldState which should be disabled
* rule 1 sees a new Operation and does truth maintenance to update the field&apos;s FieldState</z><z id="t1505345426000060" t="olivergeorge Odd thing is that I don&apos;t ever see the Operation in Rule 1 via acc/all (the third step described)"><y>#</y><d>2017-09-13</d><h>23:30</h><w>olivergeorge</w>Odd thing is that I don&apos;t ever see the Operation in Rule 1 via acc/all  (the third step described)</z><z id="t1505345455000097" t="olivergeorge I&apos;m new to this, likely user error or bad assumptions on how things should work"><y>#</y><d>2017-09-13</d><h>23:30</h><w>olivergeorge</w>I&apos;m new to this, likely user error or bad assumptions on how things should work</z><z id="t1505346180000058" t="mikerod @olivergeorge acc/all returns an empty collection when no matches."><y>#</y><d>2017-09-13</d><h>23:43</h><w>mikerod</w>@olivergeorge <code>acc/all</code> returns an empty collection when no matches.</z><z id="t1505346196000188" t="mikerod I’m not sure that you’ve already realized that, so pointing it out"><y>#</y><d>2017-09-13</d><h>23:43</h><w>mikerod</w>I’m not sure that you’ve already realized that, so pointing it out</z><z id="t1505346254000337" t="mikerod (r/defrule foo [?xs &lt;- (acc/all) :from [X]] [:test (seq ?xs)] =&gt; (prn :foo)) Something like that would ensure that the rule wasn’t activated with no matches"><y>#</y><d>2017-09-13</d><h>23:44</h><w>mikerod</w><pre>(r/defrule foo
 [?xs &lt;- (acc/all) :from [X]]
 [:test (seq ?xs)]
 =&gt;
 (prn :foo))
</pre>
Something like that would ensure that the rule wasn’t activated with no matches</z><z id="t1505346306000006" t="mikerod Looks like the acc/all docs could be a bit clearer on that"><y>#</y><d>2017-09-13</d><h>23:45</h><w>mikerod</w>Looks like the <code>acc/all</code> docs could be a bit clearer on that</z><z id="t1505346350000132" t="mikerod Believe it or not, it actually can be useful for it to match with the empty collection in other use-cases."><y>#</y><d>2017-09-13</d><h>23:45</h><w>mikerod</w>Believe it or not, it actually can be useful for it to match with the empty collection in other use-cases.</z><z id="t1505346550000139" t="olivergeorge @mikerod Thanks Mike. The curious thing is that an inserted Operation is never returned from (all). I&apos;ll take a step back to understand truth maintenance better."><y>#</y><d>2017-09-13</d><h>23:49</h><w>olivergeorge</w>@mikerod Thanks Mike.  The curious thing is that an inserted Operation is never returned from (all).  I&apos;ll take a step back to understand truth maintenance better.</z><z id="t1505346768000248" t="olivergeorge Simpler example (ns spike-rules.round1 (:require [clara.rules :as rules :refer [insert! defrule defquery defsession]] [clara.rules.accumulators :as acc])) (defrecord Field [field-key field-state]) (defrecord FieldState [field-key field-state]) (defrecord Operation [field-key field-state]) (defrule rule1 &quot;Insert FieldState based on Field and Operations&quot; [?field &lt;- Field (= field-key ?field-key)] [?ops &lt;- (acc/all) :from [Operation (= field-key ?field-key)]] =&gt; (println :rule1.ops ?ops) (println :rule1.insert! `(-&gt;FieldState ~?field-key ~(reduce merge (:field-state ?field) ?ops))) (insert! (-&gt;FieldState ?field-key (reduce merge (:field-state ?field) ?ops)))) (defrule rule2 &quot;disable if read-only&quot; [FieldState (= ?field-key field-key) (:read-only field-state)] =&gt; (println :rule2.insert! `(-&gt;Operation ~?field-key {:disabled true})) (insert! (-&gt;Operation ?field-key {:disabled true}))) (defsession form-session [rule1 rule2]) (-&gt; form-session (rules/insert (-&gt;Field :site {:value nil :read-only true})) (rules/fire-rules)) Returns Loading src/spike_rules/round1.clj... :rule1.ops [] :rule1.insert! (spike-rules.round1/-&gt;FieldState :site {:value nil, :read-only true}) :rule2.insert! (spike-rules.round1/-&gt;Operation :site {:disabled true}) :rule1.ops [] :rule1.insert! (spike-rules.round1/-&gt;FieldState :site {:value nil, :read-only true}) :rule2.insert! (spike-rules.round1/-&gt;Operation :site {:disabled true}) ..."><y>#</y><d>2017-09-13</d><h>23:52</h><w>olivergeorge</w>Simpler example 
<pre>(ns spike-rules.round1
  (:require [clara.rules :as rules :refer [insert! defrule defquery defsession]]
            [clara.rules.accumulators :as acc]))

(defrecord Field [field-key field-state])
(defrecord FieldState [field-key field-state])
(defrecord Operation [field-key field-state])

(defrule rule1
  &quot;Insert FieldState based on Field and Operations&quot;
  [?field &lt;- Field (= field-key ?field-key)]
  [?ops &lt;- (acc/all) :from [Operation (= field-key ?field-key)]]
  =&gt;
  (println :rule1.ops ?ops)
  (println :rule1.insert! `(-&gt;FieldState ~?field-key ~(reduce merge (:field-state ?field) ?ops)))
  (insert! (-&gt;FieldState ?field-key (reduce merge (:field-state ?field) ?ops))))

(defrule rule2
  &quot;disable if read-only&quot;
  [FieldState (= ?field-key field-key) (:read-only field-state)]
  =&gt;
  (println :rule2.insert! `(-&gt;Operation ~?field-key {:disabled true}))
  (insert! (-&gt;Operation ?field-key {:disabled true})))

(defsession form-session [rule1 rule2])

(-&gt; form-session
    (rules/insert
      (-&gt;Field :site {:value nil :read-only true}))
    (rules/fire-rules))</pre>

Returns

<pre>Loading src/spike_rules/round1.clj... 
:rule1.ops []
:rule1.insert! (spike-rules.round1/-&gt;FieldState :site {:value nil, :read-only true})
:rule2.insert! (spike-rules.round1/-&gt;Operation :site {:disabled true})
:rule1.ops []
:rule1.insert! (spike-rules.round1/-&gt;FieldState :site {:value nil, :read-only true})
:rule2.insert! (spike-rules.round1/-&gt;Operation :site {:disabled true})
...</pre></z><z id="t1505346769000099" t="dadair You could write a query to return all operations, if that query returns anything, then your memory does have operations inserted and it&apos;s your LHS of rule 1 that is incorrect "><y>#</y><d>2017-09-13</d><h>23:52</h><w>dadair</w>You could write a query to return all operations, if that query returns anything, then your memory does have operations inserted and it&apos;s your LHS of rule 1 that is incorrect </z><z id="t1505346786000329" t="olivergeorge Okay, thanks will do."><y>#</y><d>2017-09-13</d><h>23:53</h><w>olivergeorge</w>Okay, thanks will do.</z><z id="t1505346902000218" t="olivergeorge Actually, not sure how to do a query when it won&apos;t terminate."><y>#</y><d>2017-09-13</d><h>23:55</h><w>olivergeorge</w>Actually, not sure how to do a query when it won&apos;t terminate.</z><z id="t1505346905000319" t="olivergeorge I appreciate all the help"><y>#</y><d>2017-09-13</d><h>23:55</h><w>olivergeorge</w>I appreciate all the help</z><z id="t1505346912000037" t="olivergeorge I&apos;ll take some time to learn more and try again."><y>#</y><d>2017-09-13</d><h>23:55</h><w>olivergeorge</w>I&apos;ll take some time to learn more and try again.</z><z id="t1505347340000046" t="dadair oh right it isn&apos;t terminating"><y>#</y><d>2017-09-14</d><h>00:02</h><w>dadair</w>oh right it isn&apos;t terminating</z><z id="t1505347354000258" t="dadair in that case I&apos;d write a rule that should match on ANY Operation, and have a println on the RHS"><y>#</y><d>2017-09-14</d><h>00:02</h><w>dadair</w>in that case I&apos;d write a rule that should match on ANY Operation, and have a println on the RHS</z><z id="t1505347364000011" t="dadair that way it should activate if an Operation is ever inserted"><y>#</y><d>2017-09-14</d><h>00:02</h><w>dadair</w>that way it should activate if an Operation is ever inserted</z><z id="t1505347439000034" t="mikerod @olivergeorge This is rough, but hopefully correct (thought about it quickly) So I think the loop goes like this (only including relevant fields): 1) insert Field{:field-key :site :read-only true} 2) activate rule1 3) fire rule1 - insert FieldState{:field-key :site :read-only true} 4) activate rule2 5) fire rule2 - insert Operation{:field-key :site} 6) retract previous rule1 results since (acc/all) changed 7) retract previous rule2 results since rule1 retracted the matching fact changed ;; due to (6) 8) retract previous rule1 results since (acc/all) changed ;; due to (7) - no actual retraction needed here, just updates the accumulator again (6) already retracted 9) (re-)activate rule1 ;; due to (8) 10) insert Field{:field-key :site :read-only true} ;; no Op1 anymore 11) repeat (4) and (5) 12) repeat (6) (7) ( 8 ) (9) 13) keep repeating (11) (12)"><y>#</y><d>2017-09-14</d><h>00:03</h><w>mikerod</w>@olivergeorge This is rough, but hopefully correct (thought about it quickly)
So I think the loop goes like this (only including relevant fields):

1) insert <code>Field{:field-key :site :read-only true}</code>

2) activate <code>rule1</code>

3) fire <code>rule1</code>
- insert <code>FieldState{:field-key :site :read-only true}</code>

4) activate <code>rule2</code>

5) fire <code>rule2</code>
- insert <code>Operation{:field-key :site}</code>

6) retract previous <code>rule1</code> results since <code>(acc/all)</code> changed
7) retract previous <code>rule2</code> results since <code>rule1</code> retracted the matching fact changed ;; due to (6)
8) retract previous <code>rule1</code> results since <code>(acc/all)</code> changed ;; due to (7) - no actual retraction needed here, just updates the accumulator again (6) already retracted

9) (re-)activate <code>rule1</code> ;; due to (8)

10) insert <code>Field{:field-key :site :read-only true}</code> ;; no Op1 anymore

11) repeat (4) and (5)
12) repeat (6) (7) ( 8 ) (9)

13) keep repeating (11) (12)</z><z id="t1505347570000096" t="olivergeorge Ah! right. That makes sense. Thank you."><y>#</y><d>2017-09-14</d><h>00:06</h><w>olivergeorge</w>Ah! right.  That makes sense.  Thank you.</z><z id="t1505347588000177" t="olivergeorge I missed the op retraction."><y>#</y><d>2017-09-14</d><h>00:06</h><w>olivergeorge</w>I missed the op retraction.</z><z id="t1505347593000191" t="mikerod so you have to do something to avoid the cycle that starts there"><y>#</y><d>2017-09-14</d><h>00:06</h><w>mikerod</w>so you have to do something to avoid the cycle that starts there</z><z id="t1505347605000163" t="mikerod perhaps checking some field that would stop the “feedback loop”"><y>#</y><d>2017-09-14</d><h>00:06</h><w>mikerod</w>perhaps checking some field that would stop the “feedback loop”</z><z id="t1505347618000036" t="mikerod but it’d be domain dependent I think to know the answer in that particular case"><y>#</y><d>2017-09-14</d><h>00:06</h><w>mikerod</w>but it’d be domain dependent I think to know the answer in that particular case</z><z id="t1505347697000191" t="olivergeorge I wondered about having a fire-rules loop and doing (field+ops =&gt; field-state) aggregation between iterations."><y>#</y><d>2017-09-14</d><h>00:08</h><w>olivergeorge</w>I wondered about having a fire-rules loop and doing (field+ops =&gt; field-state) aggregation between iterations.</z><z id="t1505347743000119" t="olivergeorge I can see other possibilities."><y>#</y><d>2017-09-14</d><h>00:09</h><w>olivergeorge</w>I can see other possibilities.</z><z id="t1505347748000025" t="olivergeorge Thanks for putting me on track"><y>#</y><d>2017-09-14</d><h>00:09</h><w>olivergeorge</w>Thanks for putting me on track</z><z id="t1505347816000263" t="dadair @mikerod do you know of any solid references for designing forward inference rule systems? Or some common design patterns, etc?"><y>#</y><d>2017-09-14</d><h>00:10</h><w>dadair</w>@mikerod do you know of any solid references for designing forward inference rule systems? Or some common design patterns, etc?</z><z id="t1505349541000302" t="mikerod @dadair good question. I’m don’t really think I know a lot off the top of my head. Which is unfortunate"><y>#</y><d>2017-09-14</d><h>00:39</h><w>mikerod</w>@dadair good question. I’m don’t really think I know a lot off the top of my head. Which is unfortunate</z><z id="t1505349545000148" t="mikerod I’ll have to think about that one"><y>#</y><d>2017-09-14</d><h>00:39</h><w>mikerod</w>I’ll have to think about that one</z><z id="t1505353976000204" t="olivergeorge Is there a simple way to extract all facts from a session?"><y>#</y><d>2017-09-14</d><h>01:52</h><w>olivergeorge</w>Is there a simple way to extract all facts from a session?</z><z id="t1505354001000172" t="olivergeorge My best guess is query with an expression whose fact type is an ancestor of all records which seems to work just fine for records using [?ret &lt;- Object] ."><y>#</y><d>2017-09-14</d><h>01:53</h><w>olivergeorge</w>My best guess is query with an expression whose fact type is an ancestor of all records which seems to work just fine for records using <code>[?ret &lt;- Object]</code>.</z><z id="t1505356704000065" t="olivergeorge @dadairI was going to suggest that perhaps the Doorenbos paper might be worth checking for references but it&apos;s 150 pages long."><y>#</y><d>2017-09-14</d><h>02:38</h><w>olivergeorge</w>@dadairI was going to suggest that perhaps the Doorenbos paper might be worth checking for references but it&apos;s 150 pages long.</z><z id="t1505362374000128" t="olivergeorge One technique which might have resolved my problem is using insert-unconditional! for Operations as that would ensure they aren&apos;t retracted (no feedback loop)."><y>#</y><d>2017-09-14</d><h>04:12</h><w>olivergeorge</w>One technique which might have resolved my problem is using <code>insert-unconditional!</code> for Operations as that would ensure they aren&apos;t retracted (no feedback loop).</z><z id="t1505362399000039" t="olivergeorge Not sure if using insert-unconditional! is considered a code smell / something to be avoided rather than common usage."><y>#</y><d>2017-09-14</d><h>04:13</h><w>olivergeorge</w>Not sure if using insert-unconditional! is considered a code smell / something to be avoided rather than common usage.</z><z id="t1505363251000072" t="olivergeorge (ns spike-rules.round1 (:require [clara.rules :as rules :refer [insert! insert-unconditional! defrule defquery defsession]] [clara.rules.accumulators :as acc])) (defrecord Field [field-key field-state]) (defrecord FieldState [field-key field-state]) (defrecord Disabled [field-key]) (defn exists ([] (acc/accum {:initial-value false :reduce-fn (constantly true)}))) (defrule rule1 &quot;Insert FieldState based on Field and Operations&quot; [?field &lt;- Field (= field-key ?field-key)] [?disabled &lt;- (exists) :from [Disabled (= field-key ?field-key)]] =&gt; (insert! (cond-&gt; (-&gt;FieldState ?field-key (:field-state ?field)) ?disabled (assoc :disabled true)))) (defrule rule2 &quot;disable if read-only&quot; [FieldState (= ?field-key field-key) (:read-only field-state)] [:not [Disabled (= ?field-key field-key)]] =&gt; (insert-unconditional! (-&gt;Disabled ?field-key))) (defquery export-facts [] [?ret &lt;- Object]) (defsession form-session [rule1 rule2 export-facts]) (-&gt; form-session (rules/insert (-&gt;Field :site {:value nil :read-only true})) (rules/fire-rules) (rules/query export-facts))"><y>#</y><d>2017-09-14</d><h>04:27</h><r>olivergeorge</r><pre>(ns spike-rules.round1
  (:require [clara.rules :as rules :refer [insert! insert-unconditional! defrule defquery defsession]]
            [clara.rules.accumulators :as acc]))

(defrecord Field [field-key field-state])
(defrecord FieldState [field-key field-state])
(defrecord Disabled [field-key])

(defn exists
  ([]
   (acc/accum
     {:initial-value     false
      :reduce-fn         (constantly true)})))

(defrule rule1
  &quot;Insert FieldState based on Field and Operations&quot;
  [?field &lt;- Field (= field-key ?field-key)]
  [?disabled &lt;- (exists) :from [Disabled (= field-key ?field-key)]]
  =&gt;
  (insert!
    (cond-&gt; (-&gt;FieldState ?field-key (:field-state ?field))
      ?disabled (assoc :disabled true))))

(defrule rule2
  &quot;disable if read-only&quot;
  [FieldState (= ?field-key field-key) (:read-only field-state)]
  [:not [Disabled (= ?field-key field-key)]]
  =&gt;
  (insert-unconditional! (-&gt;Disabled ?field-key)))

(defquery export-facts [] [?ret &lt;- Object])

(defsession form-session [rule1 rule2 export-facts])

(-&gt; form-session
    (rules/insert
      (-&gt;Field :site {:value nil :read-only true}))
    (rules/fire-rules)
    (rules/query export-facts))</pre></z><z id="t1505405364000548" t="mikerod &gt; I was going to suggest that perhaps the Doorenbos paper might be worth checking for references but it’s 150 pages long. @olivergeorge I do think that this paper is a great explanation of Rete (skipping some of the out-dated about some of the “testbed” system parts). I’m not sure it has a lot on “how to structure and design rules in practice” though."><y>#</y><d>2017-09-14</d><h>16:09</h><w>mikerod</w>&gt; I was going to suggest that perhaps the Doorenbos paper might be worth checking for references but it’s 150 pages long.

@olivergeorge I do think that this paper is a great explanation of Rete (skipping some of the out-dated about some of the “testbed” system parts). I’m not sure it has a lot on “how to structure and design rules in practice” though.</z><z id="t1505405487000380" t="mikerod When looking for that sort of guidance I think I’ve sort of just hunted around the internet searching for like “rules engines best practices”"><y>#</y><d>2017-09-14</d><h>16:11</h><w>mikerod</w>When looking for that sort of guidance I think I’ve sort of just hunted around the internet searching for like “rules engines best practices”</z><z id="t1505405530000482" t="mikerod I think Drools (popular Java/JVM based rules engine) had a fairly large amount of material with some general guidance on things. It’s still a search though. I wish I knew more direct sources though."><y>#</y><d>2017-09-14</d><h>16:12</h><w>mikerod</w>I think Drools (popular Java/JVM based rules engine) had a fairly large amount of material with some general guidance on things. It’s still a search though. I wish I knew more direct sources though.</z><z id="t1505405548000315" t="mikerod @olivergeorge I’d be careful using insert-unconditional!"><y>#</y><d>2017-09-14</d><h>16:12</h><w>mikerod</w>@olivergeorge I’d be careful using <code>insert-unconditional!</code></z><z id="t1505405561000258" t="mikerod You start to get into an order dependent situation with your rules"><y>#</y><d>2017-09-14</d><h>16:12</h><w>mikerod</w>You start to get into an order dependent situation with your rules</z><z id="t1505405596000022" t="mikerod if an “upstream” fact from a different rule is logically inserted and later retracted, but a downstream insert-unconditional! has already happened, it won’t be retracted and you’ll get into an inconsistent state"><y>#</y><d>2017-09-14</d><h>16:13</h><w>mikerod</w>if an “upstream” fact from a different rule is logically inserted and later retracted, but a downstream <code>insert-unconditional!</code> has already happened, it won’t be retracted and you’ll get into an inconsistent state</z><z id="t1505405623000518" t="mikerod So then you end up having to do things like add :salience to try to force the rule to fire later than another and this ends up just becoming increasingly brittle"><y>#</y><d>2017-09-14</d><h>16:13</h><w>mikerod</w>So then you end up having to do things like add <code>:salience</code> to try to force the rule to fire later than another and this ends up just becoming increasingly brittle</z><z id="t1505405670000433" t="mikerod Also, loses the “declarative” sort of property that you get with rules all being under control of the truth maintenance system"><y>#</y><d>2017-09-14</d><h>16:14</h><w>mikerod</w>Also, loses the “declarative” sort of property that you get with rules all being under control of the truth maintenance system</z><z id="t1505408357000562" t="mmer Organizing rules sets - My rule set has become reasonably large within a short time. I keep getting issues with Exceptions against the schema. These are really difficult to resolve. I wonder if this is because I am running in a repl rather than outside? However, I thought I would divide my project into 4 namespaces - rules (for those I know work) worker (for any functions that help with processing my data into the working memory) queries . This then leave me with an issue about what to do with the record definitions that need to be available in all of these and in the core where I am creating the session. I either get cyclical dependencies if I put the record defs in any of these files - so I move them out into another records namespace and each of the above and the core require and refer this namespace. However when I run the mk-&gt;session if fails to find the record defs. Any ideas?"><y>#</y><d>2017-09-14</d><h>16:59</h><w>mmer</w>Organizing rules sets - My rule set has become reasonably large within a short time.  I keep getting issues with Exceptions against the schema.  These are really difficult to resolve.  I wonder if this is because I am running in a repl rather than outside?  However,  I thought I would divide my project into 4 namespaces - rules (for those I know work) worker (for any functions that help with processing my data into the working memory) queries .  This then leave me with an issue about what to do with the record definitions that need to be available in all of these and in the core where I am creating the session.  I either get cyclical dependencies if I put the record defs in any of these files - so I move them out into another records namespace and each of the above and the core require and refer this namespace.  However when I run the mk-&gt;session if fails to find the record defs.  Any ideas?</z><z id="t1505413955000473" t="wparker “However when I run the mk-&gt;session if fails to find the record defs. ” It sounds like the namespace defining the records wasn’t compiled then. In case you don’t know, Clojure won’t actually compile a namespace until something requires it. It can be weird in that if you have a fully qualified reference, it will resolve even if the namespace in question doesn’t require the namespace, but only if something required the namespace already. I personally think of Clojure’s compiler as a “procedural” one that takes in code and alters the state of the runtime environment accordingly."><y>#</y><d>2017-09-14</d><h>18:32</h><r>wparker</r>“However when I run the mk-&gt;session if fails to find the record defs. ” It sounds like the namespace defining the records wasn’t compiled then.  In case you don’t know, Clojure won’t actually compile a namespace until something requires it.  It can be weird in that if you have a fully qualified reference, it will resolve even if the namespace in question doesn’t require the namespace, but only if something required the namespace already.  I personally think of Clojure’s compiler as a “procedural” one that takes in code and alters the state of the runtime environment accordingly.</z><z id="t1505408503000163" t="dadair I have a shared namespace for shared records, then I build sessions like so: (r/mk-session &apos;rules.shared &apos;rules.x &apos;rules.y)"><y>#</y><d>2017-09-14</d><h>17:01</h><w>dadair</w>I have a shared namespace for shared records, then I build sessions like so: <code>(r/mk-session &apos;rules.shared &apos;rules.x &apos;rules.y)</code></z><z id="t1505408541000453" t="dadair you need to make sure you are requiring the namespace too before making the session, I&apos;ve run into that before"><y>#</y><d>2017-09-14</d><h>17:02</h><w>dadair</w>you need to make sure you are requiring the namespace too before making the session, I&apos;ve run into that before</z><z id="t1505408581000178" t="dadair so either put rules.shared into the (ns .. (:require ..)) or do an explicit (require &apos;rules.shared)"><y>#</y><d>2017-09-14</d><h>17:03</h><w>dadair</w>so either put <code>rules.shared</code> into the <code>(ns .. (:require ..))</code> or do an explicit <code>(require &apos;rules.shared)</code></z><z id="t1505422946000339" t="mmer Thanks - what if you have helper functions that need the shared? Do you lead them into the session as well? i.e. if a rule uses a function (private-ref? ?value) its namespace have to be made available to the session?"><y>#</y><d>2017-09-14</d><h>21:02</h><w>mmer</w>Thanks - what if you have helper functions that need the shared?  Do you lead them into the session as well?  i.e. if a rule uses a function (private-ref? ?value) its namespace have to be made available to the session?</z><z id="t1505422966000039" t="mmer Thanks for the reply, BTW?"><y>#</y><d>2017-09-14</d><h>21:02</h><w>mmer</w>Thanks for the reply, BTW?</z><z id="t1505426424000033" t="dadair shared functions can live in the shared namespace"><y>#</y><d>2017-09-14</d><h>22:00</h><w>dadair</w>shared functions can live in the shared namespace</z><z id="t1505426445000243" t="dadair then in rules.x you can require rules.shared so you can use the functions"><y>#</y><d>2017-09-14</d><h>22:00</h><w>dadair</w>then in <code>rules.x</code> you can require <code>rules.shared</code> so you can use the functions</z><z id="t1505426471000316" t="dadair I only call (mk-session &apos;rules.shared &apos;rules.x ..) in a &quot;core&quot; namespace"><y>#</y><d>2017-09-14</d><h>22:01</h><w>dadair</w>I only call <code>(mk-session &apos;rules.shared &apos;rules.x ..)</code> in a &quot;core&quot; namespace</z><z id="t1505426527000318" t="dadair so for example, rules.x , rules.y , and rules.z can require and use records/functions from rules.shared , and then in some other namespace rules.engine , you can require all the namespaces and call the mk-session function: (r/mk-session &apos;rules.shared &apos;rules.x ..)"><y>#</y><d>2017-09-14</d><h>22:02</h><w>dadair</w>so for example, <code>rules.x</code>, <code>rules.y</code>, and <code>rules.z</code> can require and use records/functions from <code>rules.shared</code>, and then in some other namespace <code>rules.engine</code>, you can require all the namespaces and call the mk-session function: <code>(r/mk-session &apos;rules.shared &apos;rules.x ..)</code></z><z id="t1505426538000482" t="dadair that&apos;s how I&apos;ve avoided circular dependencies"><y>#</y><d>2017-09-14</d><h>22:02</h><w>dadair</w>that&apos;s how I&apos;ve avoided circular dependencies</z><z id="t1505427040000036" t="mmer Thanks - re-organised the project as you said. I am still getting the issue where the first record typr encountered by the rules engine in the session is saying that the Record type can&apos;t be found. This namespace stuff is so hard to handle with the level of error messages from clojure"><y>#</y><d>2017-09-14</d><h>22:10</h><w>mmer</w>Thanks - re-organised the project as you said. I am still getting the issue where the first record typr encountered by the rules engine in the session is saying that the Record type can&apos;t be found.  This namespace stuff is so hard to handle with the level of error messages from clojure</z><z id="t1505428019000094" t="olivergeorge Thanks for the tips @mikerod"><y>#</y><d>2017-09-14</d><h>22:26</h><w>olivergeorge</w>Thanks for the tips @mikerod</z><z id="t1505429356000101" t="dadair depends how you are using Operation"><y>#</y><d>2017-09-14</d><h>22:49</h><w>dadair</w>depends how you are using Operation</z><z id="t1505429361000372" t="dadair can you post an example rule?"><y>#</y><d>2017-09-14</d><h>22:49</h><w>dadair</w>can you post an example rule?</z><z id="t1505429636000094" t="dadair or the exact line of the error?"><y>#</y><d>2017-09-14</d><h>22:53</h><w>dadair</w>or the exact line of the error?</z><z id="t1505645530000039" t="mmer More details:"><y>#</y><d>2017-09-17</d><h>10:52</h><w>mmer</w>More details:</z><z id="t1505645641000026" t="mmer This must be something very simple about classpaths etc that I am not grasping. The Operation is defined as:"><y>#</y><d>2017-09-17</d><h>10:54</h><w>mmer</w>This must be something very simple about classpaths etc that I am not grasping.  The Operation is defined as:</z><z id="t1505645643000027" t="mmer (defrecord Operation [assemblyName name src])"><y>#</y><d>2017-09-17</d><h>10:54</h><w>mmer</w>(defrecord Operation [assemblyName name src])</z><z id="t1505675954000077" t="mmer The erro I am getting is: ClassNotFoundException Thing java.net.URLClassLoader.findClass (URLClassLoader.java:381) - I am trying to isolate the issue into a simple set of files - hence the reference to Thing rather than Operation"><y>#</y><d>2017-09-17</d><h>19:19</h><w>mmer</w>The erro I am getting is: ClassNotFoundException Thing  java.net.URLClassLoader.findClass (URLClassLoader.java:381)  - I am trying to isolate the issue into a simple set of files - hence the reference to Thing rather than Operation</z><z id="t1505682130000016" t="mikerod @mmer I don’t see enough information here to be able to see what the problem coulud be"><y>#</y><d>2017-09-17</d><h>21:02</h><w>mikerod</w>@mmer I don’t see enough information here to be able to see what the problem coulud be</z><z id="t1505682145000103" t="mikerod the class not found’s name is AssemblyOperation which you don’t even refer to in the rule debug-rules"><y>#</y><d>2017-09-17</d><h>21:02</h><w>mikerod</w>the class not found’s name is <code>AssemblyOperation</code> which you don’t even refer to in the rule <code>debug-rules</code></z><z id="t1505682153000023" t="mikerod So I’m not sure how they are connected"><y>#</y><d>2017-09-17</d><h>21:02</h><w>mikerod</w>So I’m not sure how they are connected</z><z id="t1505682202000139" t="mikerod However, if classes are missing, I’d make sure you are appropriately requiring all necessary namespaces, including those that define types via things like defrecord"><y>#</y><d>2017-09-17</d><h>21:03</h><w>mikerod</w>However, if classes are missing, I’d make sure you are appropriately requiring all necessary namespaces, including those that define types via things like <code>defrecord</code></z><z id="t1505685966000047" t="mmer Hi @mikerod - in trying to get a simple example out I have confused you all. Sorry. I now have a very simple project which is showing the issue."><y>#</y><d>2017-09-17</d><h>22:06</h><w>mmer</w>Hi @mikerod - in trying to get a simple example out I have confused you all.  Sorry.  I now have a very simple project which is showing the issue.</z><z id="t1505686153000028" t="mmer (apply-rules &quot;name&quot; &quot;description&quot;) and I get the errors"><y>#</y><d>2017-09-17</d><h>22:09</h><w>mmer</w>(apply-rules &quot;name&quot; &quot;description&quot;) and I get the errors</z><z id="t1505686165000053" t="mmer ClassNotFoundException Thing java.net.URLClassLoader.findClass (URLClassLoader.java:381)"><y>#</y><d>2017-09-17</d><h>22:09</h><w>mmer</w>ClassNotFoundException Thing  java.net.URLClassLoader.findClass (URLClassLoader.java:381)</z><z id="t1505686242000008" t="mmer Everything to my eyes looks OK and follows the scheme of project layout that avoids cyclical dependencies, yet I can&apos;t get the reference to the rule to see the record defined in the shared files."><y>#</y><d>2017-09-17</d><h>22:10</h><w>mmer</w>Everything to my eyes looks OK and follows the scheme of project layout that avoids cyclical dependencies, yet I can&apos;t get the reference to the rule to see the record defined in the shared files.</z><z id="t1505686590000097" t="mikerod @mmer when defining types via defrecord (and similarly, deftype ), a :refer from a :require does not import the class name to be used shorthand. So you need to refer to the class either by it’s fully qualified name, or add something like (:import [rules.shared Thing]) to your rules namespaces using the class"><y>#</y><d>2017-09-17</d><h>22:16</h><w>mikerod</w>@mmer when defining types  via <code>defrecord</code> (and similarly, <code>deftype</code>), a <code>:refer</code> from a <code>:require</code> does not import the class name to be used shorthand. 
So you need to refer to the class either by it’s fully qualified name, or add something like
<pre>(:import [rules.shared Thing])
</pre>
to your rules namespaces using the class</z><z id="t1505747563000636" t="wparker https://stackoverflow.com/questions/7143406/what-are-the-differences-among-require-import-and-use has an (IMO) nice concise summary of the differences @mmer. One other potential gotcha - if you define a record with hyphens in the namespace path, the Java class created will have underscores in the corresponding class name, and import needs the Java class name"><y>#</y><d>2017-09-18</d><h>15:12</h><w>wparker</w><a href="https://stackoverflow.com/questions/7143406/what-are-the-differences-among-require-import-and-use" target="_blank">https://stackoverflow.com/questions/7143406/what-are-the-differences-among-require-import-and-use</a> has an (IMO) nice concise summary of the differences @mmer.  One other potential gotcha - if you define a record with hyphens in the namespace path, the Java class created will have underscores in the corresponding class name, and import needs the Java class name</z><z id="t1505747768000519" t="mmer Thanks - Just what I needed."><y>#</y><d>2017-09-18</d><h>15:16</h><w>mmer</w>Thanks - Just what I needed.</z><z id="t1505798850000109" t="devn @mmer we built a lib such that you can require a single ns and have access to the records via an alias in addition to some other niceties like inheriting fields and specs on those fields from a parent fact"><y>#</y><d>2017-09-19</d><h>05:27</h><w>devn</w>@mmer we built a lib such that you can require a single ns and have access to the records via an alias in addition to some other niceties like inheriting fields and specs on those fields from a parent fact</z><z id="t1505799032000129" t="devn fact/my-fact, (deffact abc (alias abc) :a integer? (variant qrs (alias qrs) :q ::some-spec)))"><y>#</y><d>2017-09-19</d><h>05:30</h><w>devn</w>fact/my-fact, (deffact abc (alias abc) :a integer? (variant qrs (alias qrs) :q ::some-spec)))</z><z id="t1505835697000722" t="mmer Where is this library?"><y>#</y><d>2017-09-19</d><h>15:41</h><w>mmer</w>Where is this library?</z><z id="t1505843058000422" t="devn @mmer closed source at the moment but will talk to folks about opening it up"><y>#</y><d>2017-09-19</d><h>17:44</h><w>devn</w>@mmer closed source at the moment but will talk to folks about opening it up</z><z id="t1505846925000030" t="mmer ok"><y>#</y><d>2017-09-19</d><h>18:48</h><w>mmer</w>ok</z><z id="t1506041796000196" t="dadair Do facts inserted by rules with accumulators in the LHS observe truth maintenance retractions if the accumulator changes? i.e., if I have a max accumulator, and 5 facts are inserted, will the RHS facts be retracted for the four facts that aren&apos;t the max?"><y>#</y><d>2017-09-22</d><h>00:56</h><w>dadair</w>Do facts inserted by rules with accumulators in the LHS observe truth maintenance retractions if the accumulator changes? i.e., if I have a <code>max</code> accumulator, and 5 facts are inserted, will the RHS facts be retracted for the four facts that aren&apos;t the max?</z><z id="t1506091208000236" t="wparker @U0E2EQFME: Yes, accumulator conditions will adjust as necessary to respect truth maintenance. This test is a concrete example: https://github.com/cerner/clara-rules/blob/master/src/test/common/clara/test_accumulation.cljc#L1102"><y>#</y><d>2017-09-22</d><h>14:40</h><r>wparker</r>@U0E2EQFME: Yes, accumulator conditions will adjust as necessary to respect truth maintenance.  This test is a concrete example: <a href="https://github.com/cerner/clara-rules/blob/master/src/test/common/clara/test_accumulation.cljc#L1102" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/common/clara/test_accumulation.cljc#L1102</a></z><z id="t1506100973000151" t="dadair awesome thanks!"><y>#</y><d>2017-09-22</d><h>17:22</h><r>dadair</r>awesome thanks!</z><z id="t1506357926000393" t="enn I have this clause in an LHS: [?last-performed-date &lt;- (acc/max :date) :from [fact/test-result (= ?test-id test-id)]] Because the initial value of the max accumulator is nil, it never fires when there are no test-result facts. Am I missing some idiomatic way to have it fire in that case? Do I need to write my own accumulator with a different initial value? Can I do this with :or?"><y>#</y><d>2017-09-25</d><h>16:45</h><w>enn</w>I have this clause in an LHS:

<pre>[?last-performed-date &lt;- (acc/max :date)
   :from [fact/test-result
          (= ?test-id test-id)]]
</pre>

Because the initial value of the max accumulator is nil, it never fires when there are no test-result facts. Am I missing some idiomatic way to have it fire in that case? Do I need to write my own accumulator with a different initial value? Can I do this with :or?</z><z id="t1506369149000197" t="mikerod @enn you should just structure the rules in a way to handle the missing case"><y>#</y><d>2017-09-25</d><h>19:52</h><w>mikerod</w>@enn you should just structure the rules in a way to handle the missing case</z><z id="t1506369165000524" t="mikerod since acc/max doesn’t necessarily make sense for no facts - that may not always be the behavior that was desired"><y>#</y><d>2017-09-25</d><h>19:52</h><w>mikerod</w>since <code>acc/max</code> doesn’t necessarily make sense for no facts - that may not always be the behavior that was desired</z><z id="t1506369188000001" t="mikerod You could give it an :initial-value if you wanted to I suppose though"><y>#</y><d>2017-09-25</d><h>19:53</h><w>mikerod</w>You could give it an <code>:initial-value</code> if you wanted to I suppose though</z><z id="t1506369225000421" t="mikerod [?last-performed-date &lt;- (assoc (acc/max :date) :initial-value &lt;my-date&gt;) :from [fact/test-result (= ?test-id test-id)]] not sure it will always be clear what happened though"><y>#</y><d>2017-09-25</d><h>19:53</h><w>mikerod</w><pre>[?last-performed-date &lt;- (assoc (acc/max :date) :initial-value &lt;my-date&gt;)
   :from [fact/test-result
          (= ?test-id test-id)]]
</pre>
not sure it will always be clear what happened though</z><z id="t1506369447000682" t="enn @mikerod thanks--I ended up adding an [:or ... [:not [fact/test-result (= ?test-id test-id)]]] 1"><y>#</y><d>2017-09-25</d><h>19:57</h><w>enn</w>@mikerod thanks--I ended up adding an <code>[:or ... [:not [fact/test-result (= ?test-id test-id)]]]</code>1</z><z id="t1506374208000192" t="nickowsy Is there a way to use accumulate with multiple fact_contraints? For example, if I have the facts {:e 2, :a :type, :v :dog} {:e 2, :a :age, :v 12} {:e 3, :a :type, :v :cat} {:e 3, :a :age, :v 2} {:e 4, :a :type, :v :dog} {:e 4, :a :age, :v 10} I would like to acc/all :type facts, matching :type is :dog and :age &gt; 4. The :fact-type-fn is :a."><y>#</y><d>2017-09-25</d><h>21:16</h><w>nickowsy</w>Is there a way to use accumulate with multiple fact_contraints?  For example, if I have the facts 
<pre>{:e 2, :a :type, :v :dog}
{:e 2, :a :age, :v  12}
{:e 3, :a :type, :v :cat}
{:e 3, :a :age, :v 2}
{:e 4, :a :type, :v :dog}
{:e 4, :a :age, :v 10}</pre>  I would like to acc/all :type facts, matching :type is :dog and :age &gt; 4. The  :fact-type-fn is :a.</z><z id="t1506375191000421" t="mikerod [:type (= (:v this) :dog) (= ?id (:e this))] [?all &lt;- (acc/all) :from [:age (= ?id (:e this)) (&gt; (:v this) 4)] @nickowsy perhaps?"><y>#</y><d>2017-09-25</d><h>21:33</h><w>mikerod</w><pre>[:type
 (= (:v this) :dog)
 (= ?id (:e this))]

[?all &lt;- (acc/all)
 :from [:age
        (= ?id (:e this))
        (&gt; (:v this) 4)]
</pre>
@nickowsy perhaps?</z><z id="t1506375208000318" t="mikerod So an accumulator that does a join with another fact"><y>#</y><d>2017-09-25</d><h>21:33</h><w>mikerod</w>So an accumulator that does a join with another fact</z><z id="t1506375649000284" t="nickowsy @mikerod, cool thanks. I had something similar but was seeing the rule run multiple times. Once for each [:type (= (:v this) :dog) (= ?id (:e this))] match"><y>#</y><d>2017-09-25</d><h>21:40</h><w>nickowsy</w>@mikerod, cool thanks.  I had something similar but was seeing the rule run multiple times.  Once for each <pre>[:type
 (= (:v this) :dog)
 (= ?id (:e this))]</pre> match</z><z id="t1506375771000277" t="mikerod @nickowsy yes, it would"><y>#</y><d>2017-09-25</d><h>21:42</h><w>mikerod</w>@nickowsy yes, it would</z><z id="t1506635319000191" t="souenzzo How to print/debug all fired rules?"><y>#</y><d>2017-09-28</d><h>21:48</h><w>souenzzo</w>How to print/debug all fired rules?</z><z id="t1506641956000298" t="dadair http://www.clara-rules.org/docs/inspection/"><y>#</y><d>2017-09-28</d><h>23:39</h><w>dadair</w><a href="http://www.clara-rules.org/docs/inspection/" target="_blank">http://www.clara-rules.org/docs/inspection/</a></z><z id="t1506641972000080" t="dadair @souenzzo"><y>#</y><d>2017-09-28</d><h>23:39</h><w>dadair</w>@souenzzo</z><z id="t1506646408000025" t="olivergeorge In my early experimentation with clara I ended up with infinite loops when firing rules. They were non-terminating due to rules which are directly or indirectly affected by the facts they insert."><y>#</y><d>2017-09-29</d><h>00:53</h><w>olivergeorge</w>In my early experimentation with clara I ended up with infinite loops when firing rules.  They were non-terminating due to rules which are directly or indirectly affected by the facts they insert.</z><z id="t1506646486000218" t="olivergeorge I went looking for documentation around this. I can&apos;t see anything apart from an issue about a :no-loop flag."><y>#</y><d>2017-09-29</d><h>00:54</h><w>olivergeorge</w>I went looking for documentation around this.  I can&apos;t see anything apart from an issue about a :no-loop flag.</z><z id="t1506646538000140" t="olivergeorge Direct question: is Clara smart enough to avoid infinite loops based on bad rules?"><y>#</y><d>2017-09-29</d><h>00:55</h><w>olivergeorge</w>Direct question: is Clara smart enough to avoid infinite loops based on bad rules?</z><z id="t1506689996000281" t="souenzzo @dadair not sure if I understand. But my rules was in a loop inside the fire-rules."><y>#</y><d>2017-09-29</d><h>12:59</h><w>souenzzo</w>@dadair not sure if I understand. But my rules was in a loop inside the fire-rules.</z><z id="t1506697794000156" t="mikerod @olivergeorge are you asking if Clara can solve the Halting problem?"><y>#</y><d>2017-09-29</d><h>15:09</h><w>mikerod</w>@olivergeorge are you asking if Clara can solve the Halting problem?</z><z id="t1506697797000114" t="mikerod 😛"><y>#</y><d>2017-09-29</d><h>15:09</h><w>mikerod</w><b>😛</b></z><z id="t1506697817000107" t="mikerod Joking aside: No Clara can’t really detect the loops"><y>#</y><d>2017-09-29</d><h>15:10</h><w>mikerod</w>Joking aside: No Clara can’t really detect the loops</z><z id="t1506697824000134" t="mikerod The RHS can do arbitrary things"><y>#</y><d>2017-09-29</d><h>15:10</h><w>mikerod</w>The RHS can do arbitrary things</z><z id="t1506697839000573" t="mikerod There is no way to know that something that “looks like a cycle” at runtime isn’t going to eventually stop cycling"><y>#</y><d>2017-09-29</d><h>15:10</h><w>mikerod</w>There is no way to know that something that “looks like a cycle” at runtime isn’t going to eventually stop cycling</z><z id="t1506697878000095" t="mikerod Clara could assume if a cycle of rules was happening “too many times” that it should stop"><y>#</y><d>2017-09-29</d><h>15:11</h><w>mikerod</w>Clara could assume if a cycle of rules was happening “too many times” that it should stop</z><z id="t1506697972000246" t="mikerod In Drools (popular Java-based rules engine that I often reference since it was used a lot in the industry) there was a “fire until halt” sort of method I believe it was called. This allowed to have a sort of “timeout” feature that the rules would stop if they reached a certain threshold of time, steps, # rule firings, etc. So something like that is feasible to implement, but not in Clara right now."><y>#</y><d>2017-09-29</d><h>15:12</h><w>mikerod</w>In Drools (popular Java-based rules engine that I often reference since it was used a lot in the industry) there was a “fire until halt” sort of method I believe it was called. This allowed to have a sort of “timeout” feature that the rules would stop if they reached a certain threshold of time, steps, # rule firings, etc. So something like that is feasible to implement, but not in Clara right now.</z><z id="t1506698025000326" t="mikerod I do tend to try to avoid using something like :no-loop too and instead setup the rules in a way where they logically won’t loop. :no-loop starts to go against the logical truth maintenance in some cases."><y>#</y><d>2017-09-29</d><h>15:13</h><w>mikerod</w>I do tend to try to avoid using something like <code>:no-loop</code> too and instead setup the rules in a way where they logically won’t loop. <code>:no-loop</code> starts to go against the logical truth maintenance in some cases.</z><z id="t1506698063000114" t="mikerod Understandably, there are cases where it is sort of hard to think about how you can make the rule logic you want not form a logical loop."><y>#</y><d>2017-09-29</d><h>15:14</h><w>mikerod</w>Understandably, there are cases where it is sort of hard to think about how you can make the rule logic you want not form a logical loop.</z><z id="t1506700753000159" t="wparker There is work logged for Clara to assume by default that after a certain number of iterations of looping that the rules were written incorrectly and throw an exception: https://github.com/cerner/clara-rules/issues/275"><y>#</y><d>2017-09-29</d><h>15:59</h><w>wparker</w>There is work logged for Clara to assume by default that after a certain number of iterations of looping that the rules were written incorrectly and throw an exception: <a href="https://github.com/cerner/clara-rules/issues/275" target="_blank">https://github.com/cerner/clara-rules/issues/275</a></z><z id="t1506700881000280" t="wparker I agree with @mikerod ‘s comments - perhaps another way of thinking about it is that if you just write a normal infinitely recursive function, Clojure or any other programming language can throw a StackOverflowException but can’t automatically recover from it - the language would have to guess what the programmer actually wanted to do in order to accomplish that"><y>#</y><d>2017-09-29</d><h>16:01</h><w>wparker</w>I agree with @mikerod ‘s comments - perhaps another way of thinking about it is that if you just write a normal infinitely recursive function, Clojure or any other programming language can throw a StackOverflowException but can’t automatically recover from it - the language would have to guess what the programmer actually wanted to do in order to accomplish that</z><z id="t1506700946000468" t="wparker I see Clara’s handling of infinitely looping rules as similar - there’s no way for Clara to guess what the user actually wanted to do"><y>#</y><d>2017-09-29</d><h>16:02</h><w>wparker</w>I see Clara’s handling of infinitely looping rules as similar - there’s no way for Clara to guess what the user actually wanted to do</z><z id="t1506701020000271" t="mikerod Cool, forgot you logged that issue before"><y>#</y><d>2017-09-29</d><h>16:03</h><w>mikerod</w>Cool, forgot you logged that issue before</z><z id="t1506722310000065" t="dadair Is there a way for someone to override what is printed when an exception is thrown? I have a fact with a very large map and when an exception is thrown it tries to print it as a binding and the REPL basically becomes unresponsive."><y>#</y><d>2017-09-29</d><h>21:58</h><w>dadair</w>Is there a way for someone to override what is printed when an exception is thrown? I have a fact with a very large map and when an exception is thrown it tries to print it as a binding and the REPL basically becomes unresponsive.</z><z id="t1506724646000125" t="mikerod @dadair I’ve had similar issues before"><y>#</y><d>2017-09-29</d><h>22:37</h><w>mikerod</w>@dadair I’ve had similar issues before</z><z id="t1506724719000058" t="mikerod Trying to think of a workaround"><y>#</y><d>2017-09-29</d><h>22:38</h><w>mikerod</w>Trying to think of a workaround</z><z id="t1506724765000095" t="mikerod I think printing the bindings directly in the exception message can be a little ambitious since sometimes there are really large bindings. They can be really big due to things like acc/all too"><y>#</y><d>2017-09-29</d><h>22:39</h><w>mikerod</w>I think printing the bindings directly in the exception message can be a little ambitious since sometimes there are really large bindings. They can be really big due to things like <code>acc/all</code> too</z><z id="t1506724781000244" t="mikerod From the REPL, you may be able to get by with try + catch around when you run the rules?"><y>#</y><d>2017-09-29</d><h>22:39</h><w>mikerod</w>From the REPL, you may be able to get by with <code>try</code> + <code>catch</code> around when you run the rules?</z><z id="t1506724795000079" t="mikerod so catch the exception to not let it print its default dump"><y>#</y><d>2017-09-29</d><h>22:39</h><w>mikerod</w>so <code>catch</code> the exception to not let it print its default dump</z><z id="t1506724818000020" t="mikerod if you are encountering the error using something like clojure.test it automatically catches and prints exceptions I think. You may be able to override that behavior as well"><y>#</y><d>2017-09-29</d><h>22:40</h><w>mikerod</w>if you are encountering the error using something like <code>clojure.test</code> it automatically catches and prints exceptions I think. You may be able to override that behavior as well</z><z id="t1506733206000166" t="souenzzo Does &quot;query&quot; is a slow operation? For lage sets, witch shoud be optimal? - One big query with &quot;all&quot;(possible) facts, with some &quot;garbage&quot; and use just what I really need - Many little query, with just what I really need,"><y>#</y><d>2017-09-30</d><h>01:00</h><w>souenzzo</w>Does &quot;query&quot; is a slow operation?
For lage sets, witch shoud be optimal?
- One big query with &quot;all&quot;(possible) facts, with some &quot;garbage&quot; and use just what I really need
- Many little query, with just  what I really need,</z><z id="t1506833656000024" t="wparker Queries are really just rules without a RHS, at least in the current implementation. There are some optimizations that could be done on queries that aren’t valid for rules; for my part none of my use-cases have yet had enough of a problem to warrant spending the time implementing them. Note that the results are calculated during fire-rules, and calling “query” is really just a map get operation. Filters that can be expressed as values of bindings can end up being expressed as just map gets if the query parameters are set appropriately. Otherwise, to be honest its hard to say much about perf without knowing more specifics. My personal bias would be to express as much as possible in declarative logic e.g. “little queries” and then address any concrete perf problems that come up, but obviously the optimal strategy depends a lot on your use-case."><y>#</y><d>2017-10-01</d><h>04:54</h><r>wparker</r>Queries are really just rules without a RHS, at least in the current implementation. There are some optimizations that could be done on queries that aren’t valid for rules; for my part none of my use-cases have yet had enough of a problem to warrant spending the time implementing them.  Note that the results are calculated during fire-rules, and calling “query” is really just a map get operation.  Filters that can be expressed as values of bindings can end up being expressed as just map gets if the query parameters are set appropriately.  Otherwise, to be honest its hard to say much about perf without knowing more specifics.  My personal bias would be to express as much as possible in declarative logic e.g. “little queries” and then address any concrete perf problems that come up, but obviously the optimal strategy depends a lot on your use-case.</z><z id="t1506826579000049" t="olivergeorge Thanks @mikerod &amp; @wparker. No great surprise. I did wonder if keeping track of inputs for truth maintenance provided a mechanism to detect a loop. e.g. If one of my inputs is based on my output then raise exception."><y>#</y><d>2017-10-01</d><h>02:56</h><w>olivergeorge</w>Thanks @mikerod &amp; @wparker.  No great surprise.  I did wonder if keeping track of inputs for truth maintenance provided a mechanism to detect a loop.  e.g. If one of my inputs is based on my output then raise exception.</z><z id="t1506829211000020" t="mikerod Yeah I’m not sure. There may be some possibility for the truth maintenance to detect a cycle in the automatic retraction stuff. Haven’t thought that one through before. "><y>#</y><d>2017-10-01</d><h>03:40</h><w>mikerod</w>Yeah I’m not sure. There may be some possibility for the truth maintenance to detect  a cycle in the automatic retraction stuff. Haven’t thought that one through before. </z><z id="t1507229529000603" t="dg has anyone ever seen an exception from (explain-activations session) when the rules are all working well? UnsupportedOperationException nth not supported on this type: PersistentArrayMap clojure.lang.RT.nthFrom (RT.java:947) "><y>#</y><d>2017-10-05</d><h>18:52</h><w>dg</w>has anyone ever seen an exception from <code>(explain-activations session)</code> when the rules are all working well?
<pre>UnsupportedOperationException nth not supported on this type: PersistentArrayMap  clojure.lang.RT.nthFrom (RT.java:947)
</pre></z><z id="t1507230113000323" t="dg it seems like explain-activations may just be broken. it expects (:matches explanation) to be a vector of [fact condition] but it&apos;s actually a map of {:fact .. :condition ... }"><y>#</y><d>2017-10-05</d><h>19:01</h><w>dg</w>it seems like explain-activations may just be broken.  it expects <code>(:matches explanation)</code> to be a vector of <code>[fact condition]</code> but it&apos;s actually a map of <code>{:fact .. :condition ... }</code></z><z id="t1507230208000058" t="enn I have a clause like this: [:not [:and (x (= ?foo foo)) (y (= ?foo bar))]] When it fires, I get this error: &gt; Using variable that is not previously bound…. Note that variables used in negations are not bound for subsequent rules since the negation can never match. To my thinking, the y clause is not a subsequent rule since it’s part of the same :and . I want the clause to match cases where this combination of x and y facts doesn’t exist, though an individual x or y fact may exist. How can I express this?"><y>#</y><d>2017-10-05</d><h>19:03</h><w>enn</w>I have a clause like this:

<pre>[:not
   [:and
    (x (= ?foo foo))
    (y (= ?foo bar))]]
</pre>

When it fires, I get this error:

&gt; Using variable that is not previously bound…. Note that variables used in negations are not bound for subsequent rules since the negation can never match.

To my thinking, the <code>y</code> clause is not a subsequent rule since it’s part of the same <code>:and</code>. I want the clause to match cases where this combination of <code>x</code> and <code>y</code> facts doesn’t exist, though an individual <code>x</code> or <code>y</code> fact may exist. How can I express this?</z><z id="t1507232877000414" t="mikerod @dg looks like you took care of that with https://github.com/cerner/clara-rules/pull/346 ?"><y>#</y><d>2017-10-05</d><h>19:47</h><w>mikerod</w>@dg looks like you took care of that with <a href="https://github.com/cerner/clara-rules/pull/346" target="_blank">https://github.com/cerner/clara-rules/pull/346</a> ?</z><z id="t1507232909000650" t="dg yeah"><y>#</y><d>2017-10-05</d><h>19:48</h><w>dg</w>yeah</z><z id="t1507233183000241" t="mikerod @enn So Clara (similar to some other rete-based engines) convert the logical structures to DNF (disjunctive normal form). This is typically done to simplify the Rete tree construction and data flow."><y>#</y><d>2017-10-05</d><h>19:53</h><w>mikerod</w>@enn So Clara (similar to some other rete-based engines) convert the logical structures to DNF (disjunctive normal form). This is typically done to simplify the Rete tree construction and data flow.</z><z id="t1507233208000085" t="mikerod So in this case, it’d be NOT (X AND Y) converted to NOT X OR NOT Y and the OR divides the two clauses into distinct chunks. To deal with this, there is typical special handling for “negated conjunctions”."><y>#</y><d>2017-10-05</d><h>19:53</h><w>mikerod</w>So in this case, it’d be <code>NOT (X AND Y)</code> converted to <code>NOT X OR NOT Y</code> and the OR divides the two clauses into distinct chunks. To deal with this, there is typical special handling for “negated conjunctions”.</z><z id="t1507233226000474" t="mikerod I wouldn’t expect this behavior since Clara has some special handling of a negated conjunction like this."><y>#</y><d>2017-10-05</d><h>19:53</h><w>mikerod</w>I wouldn’t expect this behavior since Clara has some special handling of a negated conjunction like this.</z><z id="t1507233234000124" t="mikerod Is your rule more complex than just what you posted here?"><y>#</y><d>2017-10-05</d><h>19:53</h><w>mikerod</w>Is your rule more complex than just what you posted here?</z><z id="t1507233845000434" t="enn @mikerod yes, a bit more complex--here’s a more accurate version of that clause, and there are also other clauses in the rule: [:not [:and (x (= ?foo foo)) (y ((set (map :id ?foo)) foo_id) (= ?previously_bound_lvar other_id))]] "><y>#</y><d>2017-10-05</d><h>20:04</h><w>enn</w>@mikerod yes, a bit more complex--here’s a more accurate version of that clause, and there are also other clauses in the rule:

<pre>[:not
   [:and
    (x
     (= ?foo foo))
    (y
     ((set (map :id ?foo)) foo_id)
     (= ?previously_bound_lvar other_id))]]
</pre></z><z id="t1507233854000047" t="enn I wonder if the set membership check was messing things up?"><y>#</y><d>2017-10-05</d><h>20:04</h><w>enn</w>I wonder if the set membership check was messing things up?</z><z id="t1507233894000454" t="enn I ended up working around it by getting all values of x.foo in an accumulator, then doing a :not clause checking those values (if any) against y.foo_id"><y>#</y><d>2017-10-05</d><h>20:04</h><w>enn</w>I ended up working around it by getting all values of <code>x.foo</code> in an accumulator, then doing a <code>:not</code> clause checking those values (if any) against <code>y.foo_id</code></z><z id="t1507233906000323" t="mikerod &gt; I wonder if the set membership check was messing things up? I don’t think it should"><y>#</y><d>2017-10-05</d><h>20:05</h><w>mikerod</w>&gt; I wonder if the set membership check was messing things up?
I don’t think it should</z><z id="t1507233916000177" t="mikerod So the :not clause is not nested within anything else though right?"><y>#</y><d>2017-10-05</d><h>20:05</h><w>mikerod</w>So the <code>:not</code> clause is not nested within anything else though right?</z><z id="t1507233926000058" t="enn no"><y>#</y><d>2017-10-05</d><h>20:05</h><w>enn</w>no</z><z id="t1507234026000201" t="mikerod I’d have to mess around with that one to see what may be teh issue"><y>#</y><d>2017-10-05</d><h>20:07</h><w>mikerod</w>I’d have to mess around with that one to see what may be teh issue</z><z id="t1507234045000118" t="mikerod However, https://github.com/cerner/clara-rules/pull/342 could also be related to that sort of logic. There was some edge cases to how it was handled."><y>#</y><d>2017-10-05</d><h>20:07</h><w>mikerod</w>However, <a href="https://github.com/cerner/clara-rules/pull/342" target="_blank">https://github.com/cerner/clara-rules/pull/342</a> could also be related to that sort of logic. There was some edge cases to how it was handled.</z><z id="t1507234058000255" t="mikerod This isn’t the same as the binding not being present in the rule though"><y>#</y><d>2017-10-05</d><h>20:07</h><w>mikerod</w>This isn’t the same as the binding not being present in the rule though</z><z id="t1507234109000046" t="enn It’s interesting to hear that it should work. I’ll see if I can come up with a minimal test case, and open a ticket if so."><y>#</y><d>2017-10-05</d><h>20:08</h><w>enn</w>It’s interesting to hear that it should work. I’ll see if I can come up with a minimal test case, and open a ticket if so.</z><z id="t1507234379000123" t="mikerod that’d be good to see"><y>#</y><d>2017-10-05</d><h>20:12</h><w>mikerod</w>that’d be good to see</z><z id="t1507234646000163" t="mikerod (r/mk-session [(dsl/parse-query [] [[:not [:and [:x (= ?z (:z this))]]]])]) "><y>#</y><d>2017-10-05</d><h>20:17</h><w>mikerod</w><pre>(r/mk-session
 [(dsl/parse-query []
                   [[:not
                     [:and
                      [:x (= ?z (:z this))]]]])])
</pre></z><z id="t1507234666000270" t="mikerod ExceptionInfo Using variable that is not previously bound. This can happen when an expression uses a previously unbound variable, or if a variable is referenced in a nested part of a parent expression, such as (or (= ?my-expression my-field) ...). Note that variables used in negations are not bound for subsequent rules since the negation can never match. Production: {:lhs [[:not [:and {:type :x, :constraints [(= ?z (:z this))]}]]], :params #{}} Unbound variables: #{?z} clojure.core/ex-info (core.clj:4593) "><y>#</y><d>2017-10-05</d><h>20:17</h><w>mikerod</w><pre>ExceptionInfo Using variable that is not previously bound. This can happen when an expression uses a previously unbound variable, or if a variable is referenced in a nested part of a parent expression, such as (or (= ?my-expression my-field) ...). 
Note that variables used in negations are not bound for subsequent
                                    rules since the negation can never match.
Production: 
{:lhs [[:not [:and {:type :x, :constraints [(= ?z (:z this))]}]]], :params #{}}
Unbound variables: #{?z}  clojure.core/ex-info (core.clj:4593)
</pre></z><z id="t1507234705000420" t="mikerod That is pretty minimal"><y>#</y><d>2017-10-05</d><h>20:18</h><w>mikerod</w>That is pretty minimal</z><z id="t1507235617000001" t="mikerod @enn I think the issue is that Clara it not allowing a condition within a negation to introduce a new bound variable"><y>#</y><d>2017-10-05</d><h>20:33</h><w>mikerod</w>@enn I think the issue is that Clara it not allowing a condition within a negation to introduce a new bound variable</z><z id="t1507235714000508" t="mikerod This gets even more minimal: (mk-session [(dsl/parse-query [] [[:not [:x (= ?z (:z this))]]])]) fails due to Unbound variables: #{?z} yet this is ok: (mk-session [(dsl/parse-query [] [[:y ( = ?z (:z this))] [:not [:x (= ?z (:z this))]]])]) "><y>#</y><d>2017-10-05</d><h>20:35</h><w>mikerod</w>This gets even more minimal:
<pre>(mk-session
 [(dsl/parse-query []
                   [[:not [:x (= ?z (:z this))]]])])
</pre>

fails due to <code>Unbound variables: #{?z}</code>

yet this is ok:
<pre>(mk-session
 [(dsl/parse-query []
                   [[:y ( = ?z (:z this))]
                    [:not [:x (= ?z (:z this))]]])])
</pre></z><z id="t1507235757000189" t="mikerod The case of a single condition making a bound variable within a negation doesn’t make sense. However, in negated conjunction like in your previous example it does. I think this may be an edge case that Clara isn’t appropriately handling."><y>#</y><d>2017-10-05</d><h>20:35</h><w>mikerod</w>The case  of a single condition making a bound variable within a negation doesn’t make sense. However, in negated conjunction like in your previous example it does. I think this may be an edge case that Clara isn’t appropriately handling.</z><z id="t1507235766000642" t="mikerod I can log the issue"><y>#</y><d>2017-10-05</d><h>20:36</h><w>mikerod</w>I can log the issue</z><z id="t1507236313000058" t="mikerod Logged https://github.com/cerner/clara-rules/issues/347"><y>#</y><d>2017-10-05</d><h>20:45</h><w>mikerod</w>Logged <a href="https://github.com/cerner/clara-rules/issues/347" target="_blank">https://github.com/cerner/clara-rules/issues/347</a></z><z id="t1507238858000037" t="enn Thank you!"><y>#</y><d>2017-10-05</d><h>21:27</h><w>enn</w>Thank you!</z><z id="t1507239217000063" t="afurmanov Hi, I wonder if I have facts like Shape , Rectangle , Square , what would be recommended way to query all shapes?"><y>#</y><d>2017-10-05</d><h>21:33</h><w>afurmanov</w>Hi, I wonder if I have facts like <code>Shape</code>, <code>Rectangle</code>, <code>Square</code>, what would be recommended way to query all shapes?</z><z id="t1507240690000213" t="afurmanov I am new to Clojure/Clara, and what I am trying to achieve is to make query find-all-shapes to return rectangles as well as squares: (ns dsl.test (:require [clara.rules :refer :all] )) (defrecord Shape [center]) (defrecord Rectangle [center width height]) (defrecord Square [center width]) (defquery find-all-shapes [] [?result &lt;- Shape] ) (println (-&gt; (mk-session &apos;dsl.test) (insert (-&gt;Rectangle [1 1] 2 3) (-&gt;Square [3 3] 5)) (fire-rules) (query find-all-shapes))) "><y>#</y><d>2017-10-05</d><h>21:58</h><w>afurmanov</w>I am new to Clojure/Clara, and what I am trying to achieve is to make query <code>find-all-shapes</code> to return rectangles as well as squares: <pre>(ns dsl.test
  (:require
    [clara.rules :refer :all]
    ))

(defrecord Shape [center])
(defrecord Rectangle [center width height])
(defrecord Square [center width])


(defquery find-all-shapes
  []
  [?result &lt;- Shape]
  )

(println (-&gt; (mk-session &apos;dsl.test)
           (insert
             (-&gt;Rectangle [1 1] 2 3)
             (-&gt;Square [3 3] 5))
           (fire-rules)
           (query find-all-shapes)))
</pre></z><z id="t1507240763000218" t="afurmanov From clara documentation I guess I have to make Shape an ancestor of Rectangle and Square , but not sure how to do this and wether it is right direction at all."><y>#</y><d>2017-10-05</d><h>21:59</h><w>afurmanov</w>From clara documentation I guess I have to make <code>Shape</code> an ancestor of <code>Rectangle</code> and <code>Square</code>, but not sure how to do this and wether it is right direction at all.</z><z id="t1507240842000345" t="mikerod @alex.furmanov Clara’s defaults are to use the type and ancestors fn’s from Clojure"><y>#</y><d>2017-10-05</d><h>22:00</h><w>mikerod</w>@alex.furmanov Clara’s defaults are to use the <code>type</code> and <code>ancestors</code> fn’s from Clojure</z><z id="t1507240867000157" t="mikerod So you can work it into those in several different ways"><y>#</y><d>2017-10-05</d><h>22:01</h><w>mikerod</w>So you can work it into those in several different ways</z><z id="t1507240893000197" t="mikerod I’m not sure if you are using clj or cljs"><y>#</y><d>2017-10-05</d><h>22:01</h><w>mikerod</w>I’m not sure if you are using clj or cljs</z><z id="t1507240902000048" t="afurmanov clj"><y>#</y><d>2017-10-05</d><h>22:01</h><w>afurmanov</w>clj</z><z id="t1507240963000001" t="mikerod if you are using clj and like defrecord to define your types you could just make a marker interface and use the standard Java type hierarchy (definterface Shape) (defrecord Rectangle [center width height] Shape) &lt;etc&gt; "><y>#</y><d>2017-10-05</d><h>22:02</h><w>mikerod</w>if you are using clj and like <code>defrecord</code> to define your types you could just make a marker interface and use the standard Java type hierarchy
<pre>(definterface Shape)
(defrecord Rectangle [center width height] Shape)
&lt;etc&gt;
</pre></z><z id="t1507240978000130" t="mikerod You could also utilize Clojure’s derive"><y>#</y><d>2017-10-05</d><h>22:02</h><w>mikerod</w>You could also utilize Clojure’s <code>derive</code></z><z id="t1507241010000102" t="mikerod From your example it isn’t completely clear, but I don’t think you actually have facts that are actually the type Shape e.g. (-&gt;Shape [1 1]) right?"><y>#</y><d>2017-10-05</d><h>22:03</h><w>mikerod</w>From your example it isn’t completely clear, but I don’t think you actually have facts that are actually the type <code>Shape</code> e.g. <code>(-&gt;Shape [1 1])</code> right?</z><z id="t1507241081000161" t="afurmanov No, the real case is different: facts are indications of some sort of progress."><y>#</y><d>2017-10-05</d><h>22:04</h><w>afurmanov</w>No, the real case is different: facts are indications of some sort of progress.</z><z id="t1507241165000256" t="afurmanov Some could be as simple as counter, others are pairs [invites, money], other type of progress possible"><y>#</y><d>2017-10-05</d><h>22:06</h><w>afurmanov</w>Some  could be as simple as counter, others are pairs [invites, money], other type of progress possible</z><z id="t1507241252000390" t="afurmanov Thanks, @mikerod! The (definterface ...) works!"><y>#</y><d>2017-10-05</d><h>22:07</h><w>afurmanov</w>Thanks, @mikerod! The <code>(definterface ...)</code> works!</z><z id="t1507241495000264" t="mikerod No problem. Technical note: for Clojure I would choose definterface as the way to mark the record hierarchy just because using defprotocol for it’s underlying generated interface is a bit of a gray area. You could get away with defprotocol as well though. It has edge cases though and it may be better to avoid."><y>#</y><d>2017-10-05</d><h>22:11</h><w>mikerod</w>No problem. Technical note: for Clojure I would choose <code>definterface</code> as the way to mark the record hierarchy just because using <code>defprotocol</code> for it’s underlying generated interface is a bit of a gray area. You could get away with <code>defprotocol</code> as well though. It has edge cases though and it may be better to avoid.</z><z id="t1507241652000003" t="mikerod If you are still interested, what I mean is, e.g. (defprotocol Shape) (extend-type String Shape) Doesn’t mean that String’s are now considered to be Shape’s by the built-in Clojure type hierarchy. Also, the protocol will leave a var by the name of Shape that will clash with the classname produced in your ns and that is confusing as well."><y>#</y><d>2017-10-05</d><h>22:14</h><w>mikerod</w>If you are still interested, what I mean is, e.g.
<pre>(defprotocol Shape)

(extend-type String Shape)
</pre>
Doesn’t mean that String’s are now considered to be Shape’s by the built-in Clojure type hierarchy. Also, the protocol will leave a var by the name of <code>Shape</code> that will clash with the classname produced in your ns and that is confusing as well.</z><z id="t1507242332000306" t="afurmanov I did not know that, thanks for explanations!"><y>#</y><d>2017-10-05</d><h>22:25</h><w>afurmanov</w>I did not know that, thanks for explanations!</z><z id="t1507246888000087" t="afurmanov How to call interface method in LHS constraint? (definterface IProgress (^int counter []) (^int customer []) ) (defrecord SpecialIProgress [counter_ customer_ details] IProgress (counter [this] (+ counter_ 1)) (customer [this] 1) ) (defquery find-all-i-progresses [] ;; [?result &lt;- IProgress (= 1 .customer)] ;; DOES NOT WORK [?result &lt;- IProgress] ) (println (-&gt; (mk-session &apos;dsl.test) (insert (-&gt;SpecialIProgress 2 1 &quot;2 out of 3&quot;)) (fire-rules) (query find-all-i-progresses))) "><y>#</y><d>2017-10-05</d><h>23:41</h><w>afurmanov</w>How to call interface method in LHS constraint? <pre>(definterface IProgress
  (^int counter [])
  (^int customer [])
  )

(defrecord SpecialIProgress [counter_ customer_ details] IProgress
  (counter [this] (+ counter_ 1))
  (customer [this] 1)
  )

(defquery find-all-i-progresses
  []
;;  [?result &lt;- IProgress (= 1 .customer)] ;; DOES NOT WORK
  [?result &lt;- IProgress]
  )

(println (-&gt; (mk-session &apos;dsl.test)
  (insert
    (-&gt;SpecialIProgress 2 1 &quot;2 out of 3&quot;))
  (fire-rules)
  (query find-all-i-progresses)))
</pre></z><z id="t1507246976000071" t="afurmanov If I uncomment [?result &lt;- IProgress (= 1 .customer)] line I am getting an error: &quot;Unable to resolve symbol: .customer in this context&quot;"><y>#</y><d>2017-10-05</d><h>23:42</h><w>afurmanov</w>If I uncomment <code>[?result &lt;- IProgress (= 1 .customer)]</code> line I am getting an error: &quot;Unable to resolve symbol: .customer in this context&quot;</z><z id="t1507247065000223" t="afurmanov Cannot use customer in constraint either, same type of error"><y>#</y><d>2017-10-05</d><h>23:44</h><w>afurmanov</w>Cannot use <code>customer</code> in constraint either, same type of error</z><z id="t1507247256000166" t="afurmanov This: https://clojuredocs.org/clojure.core/definterface#example-5568aadfe4b03e2132e7d175 is saying that &quot;Using an interface, only the dot form of the method is available with defrecord&quot;"><y>#</y><d>2017-10-05</d><h>23:47</h><w>afurmanov</w>This: <a href="https://clojuredocs.org/clojure.core/definterface#example-5568aadfe4b03e2132e7d175" target="_blank">https://clojuredocs.org/clojure.core/definterface#example-5568aadfe4b03e2132e7d175</a> is saying that &quot;Using an interface, only the dot form of the method is available with defrecord&quot;</z><z id="t1507295769000374" t="zylox .customer is a method isnt it?"><y>#</y><d>2017-10-06</d><h>13:16</h><w>zylox</w><code>.customer</code> is a method isnt it?</z><z id="t1507295789000402" t="zylox have you tried (= 1 (.customer this))"><y>#</y><d>2017-10-06</d><h>13:16</h><w>zylox</w>have you tried <code>(= 1 (.customer this))</code></z><z id="t1507295939000052" t="zylox just tried it with your code and it worked for me"><y>#</y><d>2017-10-06</d><h>13:18</h><w>zylox</w>just tried it with your code and it worked for me</z><z id="t1507295947000108" t="zylox @alex.furmanov"><y>#</y><d>2017-10-06</d><h>13:19</h><w>zylox</w>@alex.furmanov</z><z id="t1507297447000413" t="huwigs I have a question about accumulators — is there a reason to do aggregation in a clara accumulator vs. in a RHS of something that uses all to get the values?"><y>#</y><d>2017-10-06</d><h>13:44</h><w>huwigs</w>I have a question about accumulators — is there a reason to do aggregation in a clara accumulator vs. in a RHS of something that uses <code>all</code> to get the values?</z><z id="t1507297502000058" t="huwigs use case is a value computed from each fact that is then averaged"><y>#</y><d>2017-10-06</d><h>13:45</h><w>huwigs</w>use case is a value computed from each fact that is then averaged</z><z id="t1507299185000663" t="afurmanov Thanks @zylox - that is indeed working!"><y>#</y><d>2017-10-06</d><h>14:13</h><w>afurmanov</w>Thanks @zylox - that is indeed working!</z><z id="t1507299286000192" t="mikerod @steve313 Technically there may be performance advantages in that you are allowing the engine to have potential optimizations to avoid doing unnecessary work. However, some of that would relate to how performant the accumulator implementation is."><y>#</y><d>2017-10-06</d><h>14:14</h><w>mikerod</w>@steve313 Technically there may be performance advantages in that you are allowing the engine to have potential optimizations to avoid doing unnecessary work. However, some of that would relate to how performant the accumulator implementation is.</z><z id="t1507299302000245" t="huwigs thanks"><y>#</y><d>2017-10-06</d><h>14:15</h><w>huwigs</w>thanks</z><z id="t1507299304000099" t="mikerod Also, you keep things a bit more structured and declarative to pull as much out of the RHS as you can"><y>#</y><d>2017-10-06</d><h>14:15</h><w>mikerod</w>Also, you keep things a bit more structured and declarative to pull as much out of the RHS as you can</z><z id="t1507299332000327" t="mikerod However, there are times when the RHS may be justified just due to it being too complicated to try to fit into an accumulator. There is somewhat of a judgement call at times."><y>#</y><d>2017-10-06</d><h>14:15</h><w>mikerod</w>However, there are times when the RHS may be justified just due to it being too complicated to try to fit into an accumulator. There is somewhat of a judgement call at times.</z><z id="t1507299356000090" t="mikerod It’s a good question for sure. I’ve seen it come up fairly often."><y>#</y><d>2017-10-06</d><h>14:15</h><w>mikerod</w>It’s a good question for sure. I’ve seen it come up fairly often.</z><z id="t1507299600000332" t="huwigs I am still early in the learning curve; think I figured out how to do the LHS relatively simply"><y>#</y><d>2017-10-06</d><h>14:20</h><w>huwigs</w>I am still early in the learning curve; think I figured out how to do the LHS relatively simply</z><z id="t1507299622000432" t="mikerod that’s good"><y>#</y><d>2017-10-06</d><h>14:20</h><w>mikerod</w>that’s good</z><z id="t1507299664000365" t="mikerod One pattern that is easy to fall into, when new to trying to implement logic via rules, is to have a tendency to put a lot of code in the RHS"><y>#</y><d>2017-10-06</d><h>14:21</h><w>mikerod</w>One pattern that is easy to fall into, when new to trying to implement logic via rules, is to have a tendency to put a lot of code in the RHS</z><z id="t1507299717000411" t="mikerod which sort of defeats the purpose. Accumulators are a bit of a more complex case, but in general it is often beneficial to try to keep the RHS as minimal as possible. Typically just “insert some facts”"><y>#</y><d>2017-10-06</d><h>14:21</h><w>mikerod</w>which sort of defeats the purpose. Accumulators are a bit of a more complex case, but in general it is often beneficial to try to keep the RHS as minimal as possible. Typically just “insert some facts”</z><z id="t1507302583000035" t="huwigs I have pretty large tables of values… do people find that it’s often necessary to do some “fact” lookups outside of the engine?"><y>#</y><d>2017-10-06</d><h>15:09</h><w>huwigs</w>I have pretty large tables of values… do people find that it’s often necessary to do some “fact” lookups outside of the engine?</z><z id="t1507305930000696" t="zylox Not really no, but im not 100% sure what you mean."><y>#</y><d>2017-10-06</d><h>16:05</h><w>zylox</w>Not really no, but im not 100% sure what you mean.</z><z id="t1507306748000171" t="huwigs Well, there are facts related to combinations of values (i.e. if a person is female, 18, and single, the value of some new fact should be X, but if they are male, 29, and married, the value of some new fact should be Y) — seems like I could use unification and declare each one of those mappings to be facts (-&gt;MyValue :female 18 :single X), (-&gt;MyValue :male 29 :married Y)"><y>#</y><d>2017-10-06</d><h>16:19</h><w>huwigs</w>Well, there are facts related to combinations of values (i.e. if a person is female, 18, and single, the value of some new fact should be X, but if they are male, 29, and married, the value of some new fact should be Y) — seems like I could use unification and declare each one of those mappings to be facts (-&gt;MyValue :female 18 :single X), (-&gt;MyValue :male 29 :married Y)</z><z id="t1507306777000420" t="huwigs or i could just look up those values in an RHS that takes a Person fact"><y>#</y><d>2017-10-06</d><h>16:19</h><w>huwigs</w>or i could just look up those values in an RHS that takes a Person fact</z><z id="t1507306799000017" t="dadair Couldn&apos;t you use a DSL to parse your table into rules?"><y>#</y><d>2017-10-06</d><h>16:19</h><w>dadair</w>Couldn&apos;t you use a DSL to parse your table into rules?</z><z id="t1507306845000440" t="dadair Or you could have condition facts"><y>#</y><d>2017-10-06</d><h>16:20</h><w>dadair</w>Or you could have condition facts</z><z id="t1507306846000324" t="huwigs I’m sure I could generate rules from the table values but I’m not sure if that is a good approach"><y>#</y><d>2017-10-06</d><h>16:20</h><w>huwigs</w>I’m sure I could generate rules from the table values but I’m not sure if that is a good approach</z><z id="t1507306857000459" t="huwigs some tables have thousands or tens of thousands of rows"><y>#</y><d>2017-10-06</d><h>16:20</h><w>huwigs</w>some tables have thousands or tens of thousands of rows</z><z id="t1507312053000102" t="mikerod @steve313 I am trying to understand the situation still. It isn’t clear to me what a row of this table represents or what information it has"><y>#</y><d>2017-10-06</d><h>17:47</h><w>mikerod</w>@steve313 I am trying to understand the situation still. It isn’t clear to me what a row of this table represents or what information it has</z><z id="t1507312057000081" t="mikerod any dummy example?"><y>#</y><d>2017-10-06</d><h>17:47</h><w>mikerod</w>any dummy example?</z><z id="t1507312161000224" t="huwigs The table itself is structured like (k1, k2, k3, v1, v2, v3, v4, v5)… imagine something like that"><y>#</y><d>2017-10-06</d><h>17:49</h><w>huwigs</w>The table itself is structured like (k1, k2, k3, v1, v2, v3, v4, v5)… imagine something like that</z><z id="t1507312167000348" t="huwigs er, like this:"><y>#</y><d>2017-10-06</d><h>17:49</h><w>huwigs</w>er, like this:</z><z id="t1507312170000473" t="huwigs `"><y>#</y><d>2017-10-06</d><h>17:49</h><w>huwigs</w><code></code>`</z><z id="t1507312312000304" t="huwigs For many many permutations of k1,k2,k3"><y>#</y><d>2017-10-06</d><h>17:51</h><w>huwigs</w>For many many permutations of k1,k2,k3</z><z id="t1507312363000607" t="huwigs not sure if that snippet came through? slack saying i ran out of space"><y>#</y><d>2017-10-06</d><h>17:52</h><w>huwigs</w>not sure if that snippet came through? slack saying i ran out of space</z><z id="t1507312374000218" t="huwigs k1 k2 k3 v1 v2 v3 v4 v5 v6 v7 v8 17 F S 2.1647 3.8128 2.9743 1.4490 2.7630 0.3837 3.4900 1.1400 3.1700 18 F S 2.8955 3.4350 1.4777 1.4490 2.4809 0.9656 2.9640 1.1058 2.6980 19 F S 2.2341 2.7573 1.3664 1.4490 2.2500 0.8800 2.5947 1.1058 2.3622 20 F S 1.8131 2.1821 1.9299 1.4490 1.7000 0.8900 2.2692 1.0944 2.0646 21 F S 1.7448 2.0645 1.9294 1.4490 1.6500 0.8800 2.2176 1.1286 2.0196 "><y>#</y><d>2017-10-06</d><h>17:52</h><w>huwigs</w><pre>k1  k2  k3  v1  v2  v3  v4  v5  v6  v7  v8
17  F   S   2.1647  3.8128  2.9743  1.4490  2.7630  0.3837  3.4900  1.1400  3.1700
18  F   S   2.8955  3.4350  1.4777  1.4490  2.4809  0.9656  2.9640  1.1058  2.6980
19  F   S   2.2341  2.7573  1.3664  1.4490  2.2500  0.8800  2.5947  1.1058  2.3622
20  F   S   1.8131  2.1821  1.9299  1.4490  1.7000  0.8900  2.2692  1.0944  2.0646
21  F   S   1.7448  2.0645  1.9294  1.4490  1.6500  0.8800  2.2176  1.1286  2.0196
</pre></z><z id="t1507312421000331" t="huwigs now, in the rules engine we have facts that can provide (k1, k2, k3) values and want to know what a v1 value for that combination is"><y>#</y><d>2017-10-06</d><h>17:53</h><w>huwigs</w>now, in the rules engine we have facts that can provide (k1, k2, k3) values and want to know what a v1 value for that combination is</z><z id="t1507312461000208" t="huwigs right now i just looked it up in a map i read from the file in an rhs"><y>#</y><d>2017-10-06</d><h>17:54</h><w>huwigs</w>right now i just looked it up in a map i read from the file in an rhs</z><z id="t1507312465000184" t="mikerod ok, that does make the idea clearer to me to think about"><y>#</y><d>2017-10-06</d><h>17:54</h><w>mikerod</w>ok, that does make the idea clearer to me to think about</z><z id="t1507312467000741" t="huwigs but in theory those could all be facts"><y>#</y><d>2017-10-06</d><h>17:54</h><w>huwigs</w>but in theory those could all be facts</z><z id="t1507312476000432" t="mikerod You could put the table as a fact"><y>#</y><d>2017-10-06</d><h>17:54</h><w>mikerod</w>You could put the table as a fact</z><z id="t1507312489000301" t="mikerod It’s still a bit odd since the table would be big of course"><y>#</y><d>2017-10-06</d><h>17:54</h><w>mikerod</w>It’s still a bit odd since the table would be big of course</z><z id="t1507312538000018" t="mikerod However, I’m not too sure it would even be an issue to just put each row in as a fact"><y>#</y><d>2017-10-06</d><h>17:55</h><w>mikerod</w>However, I’m not too sure it would even be an issue to just put each row in as a fact</z><z id="t1507312550000179" t="mikerod and then do a join between Person to one of those rows based on the k-criteria"><y>#</y><d>2017-10-06</d><h>17:55</h><w>mikerod</w>and then do a join between Person to one of those rows based on the k-criteria</z><z id="t1507312557000248" t="mikerod From the looks of it, these would be = based joins"><y>#</y><d>2017-10-06</d><h>17:55</h><w>mikerod</w>From the looks of it, these would be <code>=</code> based joins</z><z id="t1507312567000513" t="mikerod Which are going to be the most efficient type in the engine too"><y>#</y><d>2017-10-06</d><h>17:56</h><w>mikerod</w>Which are going to be the most efficient type in the engine too</z><z id="t1507312593000082" t="huwigs Well, I am ignoring the &lt;lowest and &gt;highest for the first column"><y>#</y><d>2017-10-06</d><h>17:56</h><w>huwigs</w>Well, I am ignoring the &lt;lowest and &gt;highest for the first column</z><z id="t1507312609000794" t="mikerod Clara will automatically hash on binding keys and use that hash-based lookup for equal-based joins"><y>#</y><d>2017-10-06</d><h>17:56</h><w>mikerod</w>Clara will automatically hash on binding keys and use that hash-based lookup for equal-based joins</z><z id="t1507312623000203" t="huwigs there are values that aren’t strict equality based for that. I can probably hack it so the engine would only use equality based"><y>#</y><d>2017-10-06</d><h>17:57</h><w>huwigs</w>there are values that aren’t strict equality based for that. I can probably hack it so the engine would only use equality based</z><z id="t1507312654000373" t="mikerod So if the majority are equal based you may be fine still. Not completely sure though."><y>#</y><d>2017-10-06</d><h>17:57</h><w>mikerod</w>So if the majority are equal based you may be fine still. Not completely sure though.</z><z id="t1507312666000383" t="huwigs yeah the comparison ones are edge cases"><y>#</y><d>2017-10-06</d><h>17:57</h><w>huwigs</w>yeah the comparison ones are edge cases</z><z id="t1507312666000415" t="mikerod However, if it is like 10K sort of facts doing &lt; comparisons"><y>#</y><d>2017-10-06</d><h>17:57</h><w>mikerod</w>However, if it is like 10K sort of facts doing <code>&lt;</code> comparisons</z><z id="t1507312675000136" t="mikerod I’m not convinced you’d see much perf issues anwyasy"><y>#</y><d>2017-10-06</d><h>17:57</h><w>mikerod</w>I’m not convinced you’d see much perf issues anwyasy</z><z id="t1507312712000473" t="mikerod It may be a good idea to use a different fact type"><y>#</y><d>2017-10-06</d><h>17:58</h><w>mikerod</w>It may be a good idea to use a different fact type</z><z id="t1507312717000377" t="mikerod for the ones that aren’t equal based"><y>#</y><d>2017-10-06</d><h>17:58</h><w>mikerod</w>for the ones that aren’t equal based</z><z id="t1507312725000064" t="mikerod may help partition up the network"><y>#</y><d>2017-10-06</d><h>17:58</h><w>mikerod</w>may help partition up the network</z><z id="t1507312752000393" t="mikerod some of this is just high-level talk to. so may be too vague for you to go off of"><y>#</y><d>2017-10-06</d><h>17:59</h><w>mikerod</w>some of this is just high-level talk to. so may be too vague for you to go off of</z><z id="t1507312806000416" t="mikerod but at a really high level"><y>#</y><d>2017-10-06</d><h>18:00</h><w>mikerod</w>but at a really high level</z><z id="t1507312814000116" t="mikerod say you have 10K people - call that P"><y>#</y><d>2017-10-06</d><h>18:00</h><w>mikerod</w>say you have 10K people - call that P</z><z id="t1507312826000697" t="mikerod and 100K rows that are eq join capable - call that E"><y>#</y><d>2017-10-06</d><h>18:00</h><w>mikerod</w>and 100K rows that are eq join capable - call that E</z><z id="t1507312844000310" t="mikerod Then only 100 rows that are more expensive than eq - call it F"><y>#</y><d>2017-10-06</d><h>18:00</h><w>mikerod</w>Then only 100 rows that are more expensive than eq - call it F</z><z id="t1507312871000115" t="mikerod You’ll have the P joining to E part will all be done with hash-based lookups/joins"><y>#</y><d>2017-10-06</d><h>18:01</h><w>mikerod</w>You’ll have the P joining to E part will all be done with hash-based lookups/joins</z><z id="t1507312886000160" t="mikerod so you’ll just have P x F comparisons on the non-eq, “more expensive” join tests"><y>#</y><d>2017-10-06</d><h>18:01</h><w>mikerod</w>so you’ll just have P x F comparisons on the non-eq, “more expensive” join tests</z><z id="t1507312898000637" t="mikerod So the P, E factor is “constant”"><y>#</y><d>2017-10-06</d><h>18:01</h><w>mikerod</w>So the P, E factor is “constant”</z><z id="t1507312926000266" t="mikerod But the non-eq-based table rows I’d put under a differnet fact type since that would ensure partitioning into groups like this"><y>#</y><d>2017-10-06</d><h>18:02</h><w>mikerod</w>But the non-eq-based table rows I’d put under a differnet fact type since that would ensure partitioning into groups like this</z><z id="t1507312978000177" t="mikerod ignore my “more expensive” phrase"><y>#</y><d>2017-10-06</d><h>18:02</h><w>mikerod</w>ignore my “more expensive” phrase</z><z id="t1507312983000026" t="huwigs so if we have a fact type for the E and a fact type for the F cases"><y>#</y><d>2017-10-06</d><h>18:03</h><w>huwigs</w>so if we have a fact type for the E and a fact type for the F cases</z><z id="t1507312986000198" t="mikerod not that relevant, it’s more about the multiplier"><y>#</y><d>2017-10-06</d><h>18:03</h><w>mikerod</w>not that relevant, it’s more about the multiplier</z><z id="t1507312999000259" t="huwigs would there be two rules, one joining PxE and one joining PxF ?"><y>#</y><d>2017-10-06</d><h>18:03</h><w>huwigs</w>would there be two rules, one joining PxE and one joining PxF ?</z><z id="t1507313012000001" t="mikerod yeah"><y>#</y><d>2017-10-06</d><h>18:03</h><w>mikerod</w>yeah</z><z id="t1507313012000475" t="huwigs or use :or in one rule?"><y>#</y><d>2017-10-06</d><h>18:03</h><w>huwigs</w>or use <code>:or</code> in one rule?</z><z id="t1507313018000474" t="mikerod I’d probably do 2 rules"><y>#</y><d>2017-10-06</d><h>18:03</h><w>mikerod</w>I’d probably do 2 rules</z><z id="t1507313034000189" t="mikerod :or may be able to get you equivalent, but it may just be less readable"><y>#</y><d>2017-10-06</d><h>18:03</h><w>mikerod</w><code>:or</code> may be able to get you equivalent, but it may just be less readable</z><z id="t1507313040000345" t="huwigs right"><y>#</y><d>2017-10-06</d><h>18:04</h><w>huwigs</w>right</z><z id="t1507313041000459" t="mikerod or more confusing"><y>#</y><d>2017-10-06</d><h>18:04</h><w>mikerod</w>or more confusing</z><z id="t1507313049000608" t="mikerod :or is for the most part “syntax sugar”"><y>#</y><d>2017-10-06</d><h>18:04</h><w>mikerod</w><code>:or</code> is for the most part “syntax sugar”</z><z id="t1507313057000362" t="mikerod it isn’t short-circuiting"><y>#</y><d>2017-10-06</d><h>18:04</h><w>mikerod</w>it isn’t short-circuiting</z><z id="t1507313063000537" t="huwigs OK"><y>#</y><d>2017-10-06</d><h>18:04</h><w>huwigs</w>OK</z><z id="t1507313068000120" t="mikerod it splits at that point and all the data flow goes down both “branches” of logic"><y>#</y><d>2017-10-06</d><h>18:04</h><w>mikerod</w>it splits at that point and all the data flow goes down both “branches” of logic</z><z id="t1507313109000620" t="mikerod the only reason I’d use :or in a case like this is something like"><y>#</y><d>2017-10-06</d><h>18:05</h><w>mikerod</w>the only reason I’d use <code>:or</code> in a case like this is something like</z><z id="t1507313188000666" t="mikerod (r/defrule tester [A (= ?id id)] [B (= ?id id)] [:or &lt;your P,E and P,F joins here using the result from A,B above&gt;] =&gt; &lt;etc&gt;) "><y>#</y><d>2017-10-06</d><h>18:06</h><w>mikerod</w><pre>(r/defrule tester
  [A (= ?id id)]
  [B (= ?id id)]
  [:or
   &lt;your P,E and P,F joins here using the result from A,B above&gt;]
=&gt;
&lt;etc&gt;)
   
</pre></z><z id="t1507313199000193" t="mikerod Meaning if you had some more conditions needed by both joins"><y>#</y><d>2017-10-06</d><h>18:06</h><w>mikerod</w>Meaning if you had some more conditions needed by both joins</z><z id="t1507313226000150" t="mikerod Using :or above makes it so the network will share the work done in the prior conditions in the rule before the :or . So “node sharing”, as it is called in Rete terminology."><y>#</y><d>2017-10-06</d><h>18:07</h><w>mikerod</w>Using <code>:or</code> above makes it so the network will share the work done in the prior conditions in the rule before the <code>:or</code>.  So “node sharing”, as it is called in Rete terminology.</z><z id="t1507313255000210" t="mikerod If you do it in separate rules, there still may be node sharing though. Clara tries to detect duplicate conditions."><y>#</y><d>2017-10-06</d><h>18:07</h><w>mikerod</w>If you do it in separate rules, there still may be node sharing though. Clara tries to detect duplicate conditions.</z><z id="t1507313262000332" t="huwigs OK"><y>#</y><d>2017-10-06</d><h>18:07</h><w>huwigs</w>OK</z><z id="t1507313272000556" t="huwigs It probably reads better as multiple rules almost always?"><y>#</y><d>2017-10-06</d><h>18:07</h><w>huwigs</w>It probably reads better as multiple rules almost always?</z><z id="t1507313273000122" t="mikerod Just pointing out times when :or may be nice. It also lets you not write stuff twice."><y>#</y><d>2017-10-06</d><h>18:07</h><w>mikerod</w>Just pointing out times when <code>:or</code> may be nice. It also lets you not write stuff twice.</z><z id="t1507313286000502" t="mikerod I tend to say avoid :or unless you have noticeable/annoying duplication"><y>#</y><d>2017-10-06</d><h>18:08</h><w>mikerod</w>I tend to say avoid <code>:or</code> unless you have noticeable/annoying duplication</z><z id="t1507313305000222" t="mikerod of previous conditions before the :or branching"><y>#</y><d>2017-10-06</d><h>18:08</h><w>mikerod</w>of previous conditions before the <code>:or</code> branching</z><z id="t1507313362000360" t="mikerod and back on your topic"><y>#</y><d>2017-10-06</d><h>18:09</h><w>mikerod</w>and back on your topic</z><z id="t1507313372000024" t="mikerod if you have 10-100K rows in a table, I may think inserting all these facts is fine"><y>#</y><d>2017-10-06</d><h>18:09</h><w>mikerod</w>if you have 10-100K rows in a table, I may think inserting all these facts is fine</z><z id="t1507313386000159" t="mikerod if it were like 1 million rows, then maybe be a bit more concerned"><y>#</y><d>2017-10-06</d><h>18:09</h><w>mikerod</w>if it were like 1 million rows, then maybe be a bit more concerned</z><z id="t1507313426000598" t="mikerod and I’d still probably try it and profile/ take note of the runtime degradation before trying a non-fact based approach"><y>#</y><d>2017-10-06</d><h>18:10</h><w>mikerod</w>and I’d still probably try it and profile/ take note of the runtime degradation before trying a non-fact based approach</z><z id="t1507313520000707" t="mikerod Also, it’s good to be aware of your “hot spots”. A rule like (r/defrule joining [P (= ?age age)] [F (&lt; ?age (:threshold this))] =&gt; &lt;etc&gt;) Is going to evaluate (&lt; ?age (:threshold this)) (number of P) X (number of F) times"><y>#</y><d>2017-10-06</d><h>18:12</h><w>mikerod</w>Also, it’s good to be aware of your “hot spots”. A rule like
<pre>(r/defrule joining
  [P (= ?age age)]
  [F (&lt; ?age (:threshold this))]
=&gt;
&lt;etc&gt;)
</pre>
Is going to evaluate <code>(&lt; ?age (:threshold this))</code>   (number of P) X (number of F) times</z><z id="t1507313542000307" t="mikerod so if that is a big number, then it becomes a hot spot and you may end up just being able to improve whatever test is done tehre"><y>#</y><d>2017-10-06</d><h>18:12</h><w>mikerod</w>so if that is a big number, then it becomes a hot spot and you may end up just being able to improve whatever test is done tehre</z><z id="t1507313551000248" t="huwigs OK. So if many of these facts would be reused from case to case, is the right thing to do to load the standard facts (from the tables above), keep around a binding to the initial session, and then for each subsequent set of queries, reuse the initial session?"><y>#</y><d>2017-10-06</d><h>18:12</h><w>huwigs</w>OK. So if many of these facts would be reused from case to case, is the right thing to do to load the standard facts (from the tables above), keep around a binding to the initial session, and then for each subsequent set of queries, reuse the initial session?</z><z id="t1507313560000341" t="mikerod Or eliminate P facts that you know won’t match F (because they match something else with eq already perhaps)."><y>#</y><d>2017-10-06</d><h>18:12</h><w>mikerod</w>Or eliminate <code>P</code> facts that you know won’t match <code>F</code> (because they match something else with eq already perhaps).</z><z id="t1507313572000300" t="huwigs assuming that works on account of persistent data structures etc., just don’t want to load stuff from files many times"><y>#</y><d>2017-10-06</d><h>18:12</h><w>huwigs</w>assuming that works on account of persistent data structures etc., just don’t want to load stuff from files many times</z><z id="t1507313590000321" t="mikerod I think what you said makes sense"><y>#</y><d>2017-10-06</d><h>18:13</h><w>mikerod</w>I think what you said makes sense</z><z id="t1507313595000083" t="mikerod as long as your rules aren’t changing"><y>#</y><d>2017-10-06</d><h>18:13</h><w>mikerod</w>as long as your rules aren’t changing</z><z id="t1507313599000764" t="huwigs nope"><y>#</y><d>2017-10-06</d><h>18:13</h><w>huwigs</w>nope</z><z id="t1507313616000459" t="mikerod you can reuse an “initially loaded” working memory state for those rules for different runs of new facts"><y>#</y><d>2017-10-06</d><h>18:13</h><w>mikerod</w>you can reuse an “initially loaded” working memory state for those rules for different runs of new facts</z><z id="t1507313634000285" t="mikerod definitely a big win of Clara’s persistent, immutable working memory approach"><y>#</y><d>2017-10-06</d><h>18:13</h><w>mikerod</w>definitely a big win of Clara’s persistent, immutable working memory approach</z><z id="t1507323404000043" t="souenzzo There is some way to dedup on insert? Example, if I insert (insert! ^{:type :foo}{:foo 33}) and then (insert! ^{:type :foo}{:foo 33}) , then querty all :foo get just one?"><y>#</y><d>2017-10-06</d><h>20:56</h><w>souenzzo</w>There is some way to dedup on insert?
Example, if I insert <code>(insert! ^{:type :foo}{:foo 33})</code> and then <code>(insert! ^{:type :foo}{:foo 33})</code>, then querty all <code>:foo</code> get just one?</z><z id="t1507323471000041" t="souenzzo Yes, I know that (= ^{:type :foo}{} ^{:type :bar}{}) ;=&gt; true"><y>#</y><d>2017-10-06</d><h>20:57</h><w>souenzzo</w>Yes, I know that <code>(= ^{:type :foo}{} ^{:type :bar}{}) ;=&gt; true</code></z><z id="t1507323660000050" t="wparker @souenzzo if you’re using queries, you could put an accumulator or an :exists on your query conditions to remove duplication in your results"><y>#</y><d>2017-10-06</d><h>21:01</h><w>wparker</w>@souenzzo if you’re using queries, you could put an accumulator or an :exists on your query conditions to remove duplication in your results</z><z id="t1507323996000487" t="souenzzo It&apos;s not about query... It&apos;s about session Duplicated facts are fire&apos;ing rules in a loop.."><y>#</y><d>2017-10-06</d><h>21:06</h><w>souenzzo</w>It&apos;s not about query... It&apos;s about session
Duplicated facts are fire&apos;ing rules in a loop..</z><z id="t1507324237000106" t="mikerod @souenzzo one approach I’ve done"><y>#</y><d>2017-10-06</d><h>21:10</h><w>mikerod</w>@souenzzo one approach I’ve done</z><z id="t1507324243000298" t="mikerod introduce an “intermediate fact”"><y>#</y><d>2017-10-06</d><h>21:10</h><w>mikerod</w>introduce an “intermediate fact”</z><z id="t1507324247000040" t="mikerod that can be duplicated"><y>#</y><d>2017-10-06</d><h>21:10</h><w>mikerod</w>that can be duplicated</z><z id="t1507324261000384" t="mikerod then have a rule that uses an accumulator acc/all on those possible duplicates"><y>#</y><d>2017-10-06</d><h>21:11</h><w>mikerod</w>then have a rule that uses an accumulator <code>acc/all</code> on those possible duplicates</z><z id="t1507324275000204" t="mikerod and inserts only one in the presence of any number of them"><y>#</y><d>2017-10-06</d><h>21:11</h><w>mikerod</w>and inserts only one in the presence of any number of them</z><z id="t1507324365000095" t="souenzzo Got it. I will try;"><y>#</y><d>2017-10-06</d><h>21:12</h><w>souenzzo</w>Got it. I will try;</z><z id="t1507324429000029" t="mikerod Assuming you want to go from X facts to B facts, but do not want duplicates of B “downstream”: (r/defrule a-rule [X (= ?v v)] =&gt; (r/insert! (-&gt;Intermediate ?v))) (r/defrule aggregate-rule [?all &lt;- (acc/all) :from [Intermediate]] [:test (seq ?all)] =&gt; ;; Assume everything in `?all` is `=` otherwise do some merge, etc (r/insert! (map-&gt;B (first ?all)))) (r/defrule b-rule [B] =&gt; &lt;etc&gt;) "><y>#</y><d>2017-10-06</d><h>21:13</h><w>mikerod</w>Assuming you want to go from <code>X</code> facts to <code>B</code> facts, but do not want duplicates of <code>B</code> “downstream”:

<pre>(r/defrule a-rule
  [X (= ?v v)]
  =&gt;
  (r/insert! (-&gt;Intermediate ?v)))

(r/defrule aggregate-rule
  [?all &lt;- (acc/all) :from [Intermediate]]
  [:test (seq ?all)]
  =&gt;
  ;; Assume everything in `?all` is `=` otherwise do some merge, etc
  (r/insert! (map-&gt;B (first ?all))))

(r/defrule b-rule
  [B]
  =&gt;
  &lt;etc&gt;)
</pre></z><z id="t1507553984000109" t="souenzzo This method is not working because I need acc both Intermediate and &apos;B`, to ensure that there are no repeated elements"><y>#</y><d>2017-10-09</d><h>12:59</h><r>souenzzo</r>This method is not working because I need <code>acc</code> both <code>Intermediate</code> and &apos;B`, to ensure that there are no repeated elements</z><z id="t1507324507000006" t="mikerod I’d use better naming though 😛"><y>#</y><d>2017-10-06</d><h>21:15</h><w>mikerod</w>I’d use better naming though <b>😛</b></z><z id="t1507559700000221" t="zylox why. no amount of intermediates can insert more than one B under this pattern. If you are saying you want to insert B only if there is only distinct Intermediates, you will need to use a smarter accumulator."><y>#</y><d>2017-10-09</d><h>14:35</h><w>zylox</w>why. no amount of intermediates can insert more than one B under this pattern. If you are saying you want to insert B only if there is only distinct Intermediates, you will need to use a smarter accumulator.</z><z id="t1507753272000278" t="devn Who&apos;s gonna be at the conj?"><y>#</y><d>2017-10-11</d><h>20:21</h><w>devn</w>Who&apos;s gonna be at the conj?</z><z id="t1507753281000238" t="devn Anyone?"><y>#</y><d>2017-10-11</d><h>20:21</h><w>devn</w>Anyone?</z><z id="t1507753461000143" t="mikerod @devn not me this time around unfortunately"><y>#</y><d>2017-10-11</d><h>20:24</h><w>mikerod</w>@devn not me this time around unfortunately</z><z id="t1507753470000130" t="devn ah, too bad"><y>#</y><d>2017-10-11</d><h>20:24</h><w>devn</w>ah, too bad</z><z id="t1507753471000345" t="mikerod I’m jealous too. An anniversary"><y>#</y><d>2017-10-11</d><h>20:24</h><w>mikerod</w>I’m jealous too. An anniversary</z><z id="t1507753476000020" t="mikerod and lots of good speakers"><y>#</y><d>2017-10-11</d><h>20:24</h><w>mikerod</w>and lots of good speakers</z><z id="t1507753478000200" t="devn there wil be cake"><y>#</y><d>2017-10-11</d><h>20:24</h><w>devn</w>there wil be cake</z><z id="t1507753480000547" t="devn will*"><y>#</y><d>2017-10-11</d><h>20:24</h><w>devn</w>will*</z><z id="t1507753489000156" t="mikerod I’ve never been on a cake one"><y>#</y><d>2017-10-11</d><h>20:24</h><w>mikerod</w>I’ve never been on a cake one</z><z id="t1507769970000267" t="ryanbrush Unfortunately I&apos;m not able to make it, either. Too many things going on this fall."><y>#</y><d>2017-10-12</d><h>00:59</h><w>ryanbrush</w>Unfortunately I&apos;m not able to make it, either. Too many things going on this fall.</z><z id="t1507885350000191" t="mmer Is there a way to change facts that have been inserted - what I want to do is to change the Records to include more information as it becomes available."><y>#</y><d>2017-10-13</d><h>09:02</h><w>mmer</w>Is there a way to change facts that have been inserted - what I want to do is to change the Records to include more information as it becomes available.</z><z id="t1507898622000499" t="mmer Another question - is it possible to reference the name of a rule in a rule?"><y>#</y><d>2017-10-13</d><h>12:43</h><w>mmer</w>Another question - is it possible to reference the name of a rule in a rule?</z><z id="t1507908231000225" t="zylox as for the first question, you would want to retract the original and insert the newer one. This will require some logic outside of the rules network. Clara assumes immutability in its facts im pretty sure."><y>#</y><d>2017-10-13</d><h>15:23</h><w>zylox</w>as for the first question, you would want to retract the original and insert the newer one. This will require some logic outside of the rules network. Clara assumes immutability in its facts im pretty sure.</z><z id="t1507908343000121" t="zylox second one: What are you wanting to do with a rule reference? You should be relying on the consequences of the right hand side of said rule on the state of the facts in the session to infer things. Maybe if you had a more specific case of what you are trying to do i can provide more specific advice there."><y>#</y><d>2017-10-13</d><h>15:25</h><w>zylox</w>second one: What are you wanting to do with a rule reference? You should be relying on the consequences of the right hand side of said rule on the state of the facts in the session to infer things. Maybe if you had a more specific case of what you are trying to do i can provide more specific advice there.</z><z id="t1507909861000513" t="mikerod &gt; as for the first question, you would want to retract the original and insert the newer one. This will require some logic outside of the rules network. Clara assumes immutability in its facts im pretty sure. Yeah, I think that is common. If you aren’t concerned with a constantly growing working memory, i.e. append-only, you can get by with doing it all in rules"><y>#</y><d>2017-10-13</d><h>15:51</h><w>mikerod</w>&gt; as for the first question, you would want to retract the original and insert the newer one. This will require some logic outside of the rules network. Clara assumes immutability in its facts im pretty sure.
Yeah, I think that is common. If you aren’t concerned with a constantly growing working memory, i.e. append-only, you can get by with doing it all in rules</z><z id="t1507909881000317" t="mikerod It seems to me that Clara should offer something to better support the “update” pattern"><y>#</y><d>2017-10-13</d><h>15:51</h><w>mikerod</w>It seems to me that Clara should offer something to better support the “update” pattern</z><z id="t1507910005000089" t="mikerod Something like: (r/defrule update-fact [?current &lt;- FactType (= ?id id)] [?update &lt;- (acc/max :timestamp) :from [UpdateFact (= ?id id)]] =&gt; (r/retract! ?current) ;; or if you wanted to remove updates altogether - with no accumulator on LHS `(apply r/retract! [?current ?update])` (r/insert! (do-update ?current ?update))) To me seems like a pretty natural thing to do, but it violates truth maintenance since the supporting facts ?current and ?update are retracted that logically supported the r/insert!"><y>#</y><d>2017-10-13</d><h>15:53</h><w>mikerod</w>Something like:
<pre>(r/defrule update-fact
  [?current &lt;- FactType (= ?id id)]
  [?update &lt;- (acc/max :timestamp) :from [UpdateFact (= ?id id)]]
  =&gt;
  (r/retract! ?current) ;; or if you wanted to remove updates altogether - with no accumulator on LHS `(apply r/retract! [?current ?update])`
  (r/insert! (do-update ?current ?update)))

</pre>

To me seems like a pretty natural thing to do, but it violates truth maintenance since the supporting facts <code>?current</code> and <code>?update</code> are retracted that logically supported the <code>r/insert!</code></z><z id="t1507910042000448" t="mikerod However, r/retract! is a bit at odds with Truth maintenance since it is “order-dependent”"><y>#</y><d>2017-10-13</d><h>15:54</h><w>mikerod</w>However, <code>r/retract!</code> is a bit at odds with Truth maintenance since it is “order-dependent”</z><z id="t1507910075000096" t="mikerod if you r/retract! something, but later the rule is found to be invalidated by some other retractions, you’d expect the r/retract! operation to be rolled back"><y>#</y><d>2017-10-13</d><h>15:54</h><w>mikerod</w>if you <code>r/retract!</code> something, but later the rule is found to be invalidated by some other retractions, you’d expect the <code>r/retract!</code> operation to be rolled back</z><z id="t1507910559000171" t="mikerod if you do append-only style, I think something like this works though: (defrecord UpdateFact [id timestamp stuff]) (defrecord FactType [id timestamp x y]) (defrecord FactTypeSnapshot [id timestamp x y]) (r/defrule current-fact [?current &lt;- (acc/max :timestamp) :from [FactTypeSnapshot (= ?id id)]] =&gt; (r/insert! (map-&gt;FactType ?current))) (r/defrule update-fact-type [?update &lt;- (acc/all) :from [UpdateFact (= ?id id) (= ?ts timestamp)]] [?current &lt;- FactType (= ?id id) (&lt; timestamp ?ts)] =&gt; ;; Inserts a `FactTypeSnapshot w/ updates applied and `:timestamp` = `?ts` (r/insert! (do-update ?current ?update ?ts))) (r/defrule using-fact-type [FactType (= ?id id) (= ?x x) (= ?y y)] =&gt; (prn ?x)) "><y>#</y><d>2017-10-13</d><h>16:02</h><w>mikerod</w>if you do append-only style, I think something like this works though:
<pre>(defrecord UpdateFact [id timestamp stuff])
(defrecord FactType [id timestamp x y])
(defrecord FactTypeSnapshot [id timestamp x y])

(r/defrule current-fact
  [?current &lt;- (acc/max :timestamp) :from [FactTypeSnapshot (= ?id id)]]
  =&gt;
  (r/insert! (map-&gt;FactType ?current)))

(r/defrule update-fact-type

  [?update &lt;- (acc/all) :from [UpdateFact (= ?id id) (= ?ts timestamp)]]
  [?current &lt;- FactType (= ?id id) (&lt; timestamp ?ts)]
  =&gt;

  ;; Inserts a `FactTypeSnapshot w/ updates applied and `:timestamp` = `?ts`
  (r/insert! (do-update ?current ?update ?ts)))

(r/defrule using-fact-type
  [FactType (= ?id id) (= ?x x) (= ?y y)]
  =&gt;
  (prn ?x))


</pre></z><z id="t1507911074000635" t="mikerod The key is to have way to represent snapshots of a fact over time - the FactTypeSnapshot , a way to select the one you want to use in rules - the FactType , a way to apply updates - via UpdateFact to those facts in a way that doesn’t cause a logical loop. Didn’t test this specifically, but I believe the idea plays out alright (for append-only working memory). Externally may tend to be smoother, as @zylox said, so often I’d go with that. I wonder if Clara could provide some sort of helpers for that though ;;; Add a query to your ruleset to fetch facts you want to update (r/defquery find-fact [find-id] [?fact &lt;- FactType (= id find-id)]) ;;; Example external update fn (defn do-update [session update] ;; Assumes :id uniquely identifies facts here (let [old (first (mapv :?fact (r/query sesssion find-fact :id (:id update))))] (-&gt; session (r/retract old) (r/insert (update-fact old update)) r/fire-rules))) "><y>#</y><d>2017-10-13</d><h>16:11</h><w>mikerod</w>The key is to have way to represent snapshots of a fact over time - the <code>FactTypeSnapshot</code>, a way to select the one you want to use in rules - the <code>FactType</code>, a way to apply updates - via <code>UpdateFact</code> to those facts in a way that doesn’t cause a logical loop.
Didn’t test this specifically, but I believe the idea plays out alright (for append-only working memory).

Externally may tend to be smoother, as @zylox said, so often I’d go with that. I wonder if Clara could provide some sort of helpers for that though
<pre>;;; Add a query to your ruleset to fetch facts you want to update 
(r/defquery find-fact [find-id]
  [?fact &lt;- FactType (= id find-id)])

;;; Example external update fn
(defn do-update [session update]

  ;; Assumes :id uniquely identifies facts here
  (let [old (first (mapv :?fact (r/query sesssion find-fact :id (:id update))))]
    (-&gt; session
        (r/retract old)
        (r/insert (update-fact old update))
        r/fire-rules)))

</pre></z><z id="t1507990927000060" t="mmer @zylox Thanks for the reply."><y>#</y><d>2017-10-14</d><h>14:22</h><w>mmer</w>@zylox Thanks for the reply.</z><z id="t1507994427000031" t="mmer Sorry another simple question - do all facts have to be records?"><y>#</y><d>2017-10-14</d><h>15:20</h><w>mmer</w>Sorry another simple question - do all facts have to be records?</z><z id="t1508005270000033" t="mikerod @mmer no. Clara allows for you to provide your own :fact-type-fn , for arbitrary “type dispatch”, as well as :ancestors-fn for setting up “type hierarchies”. This is all in much the same was as Clojure’s ad hoc hierarchies work via derive and isa? etc"><y>#</y><d>2017-10-14</d><h>18:21</h><w>mikerod</w>@mmer no. Clara allows for you to provide your own <code>:fact-type-fn</code>, for arbitrary “type dispatch”, as well as <code>:ancestors-fn</code> for setting up “type hierarchies”. This is all in much the same was as Clojure’s ad hoc hierarchies work via <code>derive</code> and <code>isa?</code> etc</z><z id="t1508005286000104" t="mikerod By default, Clara uses clojure.core/type as to map a fact to type"><y>#</y><d>2017-10-14</d><h>18:21</h><w>mikerod</w>By default, Clara uses <code>clojure.core/type</code> as to map a fact to type</z><z id="t1508005302000089" t="mikerod and clojure.core/ancestors to determine the isa? style relationships"><y>#</y><d>2017-10-14</d><h>18:21</h><w>mikerod</w>and <code>clojure.core/ancestors</code> to determine the <code>isa?</code> style relationships</z><z id="t1508005316000060" t="mikerod So changing nothing, you can use plain maps with :type metadata"><y>#</y><d>2017-10-14</d><h>18:21</h><w>mikerod</w>So changing nothing, you can use plain maps with <code>:type</code> metadata</z><z id="t1508005411000011" t="mikerod (r/defrule my-rule [:my-fact-type (= (:x this) ?x)] =&gt; (println &quot;hello&quot;)) (-&gt; (r/mk-session [my-rule]) (r/insert (with-meta {:x 10} {:type :my-fact-type})) r/fire-rules) "><y>#</y><d>2017-10-14</d><h>18:23</h><w>mikerod</w><pre>(r/defrule my-rule
 [:my-fact-type (= (:x this) ?x)]
 =&gt;
 (println &quot;hello&quot;))
</pre>

<pre>(-&gt; (r/mk-session [my-rule])
     (r/insert (with-meta {:x 10} {:type :my-fact-type}))
    r/fire-rules)
</pre></z><z id="t1508005452000102" t="mikerod Here are some docs on it http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2017-10-14</d><h>18:24</h><w>mikerod</w>Here are some docs on it <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1508074996000004" t="mmer As usual thanks"><y>#</y><d>2017-10-15</d><h>13:43</h><w>mmer</w>As usual thanks</z><z id="t1508613854000059" t="wadi.chemkhi Hello"><y>#</y><d>2017-10-21</d><h>19:24</h><w>wadi.chemkhi</w>Hello</z><z id="t1508613950000045" t="wadi.chemkhi i find my self having to restart the repl every time i change the rules in a different namespace"><y>#</y><d>2017-10-21</d><h>19:25</h><w>wadi.chemkhi</w>i find my self having to restart the repl every time i change the rules in a different namespace</z><z id="t1508613959000091" t="wadi.chemkhi i require it with :reload"><y>#</y><d>2017-10-21</d><h>19:25</h><w>wadi.chemkhi</w>i require it with :reload</z><z id="t1508613968000011" t="wadi.chemkhi but still changes are ignored"><y>#</y><d>2017-10-21</d><h>19:26</h><w>wadi.chemkhi</w>but still changes are ignored</z><z id="t1508614051000054" t="wadi.chemkhi i have a main namespace with (defsession my-session &apos;myapp.corerules &apos;myapp.module.morerules)"><y>#</y><d>2017-10-21</d><h>19:27</h><w>wadi.chemkhi</w>i have a main namespace with (defsession my-session &apos;myapp.corerules &apos;myapp.module.morerules)</z><z id="t1508614932000015" t="wadi.chemkhi i&apos;m new both to clojure and clara"><y>#</y><d>2017-10-21</d><h>19:42</h><w>wadi.chemkhi</w>i&apos;m new both to clojure and clara</z><z id="t1508614943000047" t="wadi.chemkhi is there a way to simplify the workflow"><y>#</y><d>2017-10-21</d><h>19:42</h><w>wadi.chemkhi</w>is there a way to simplify the workflow</z><z id="t1508616733000040" t="ryanbrush @wadi.chemkhi By default Clara caches rule sessions for efficiency, but this&apos; isn&apos;t great for a REPL-based workflow. I like to set :cache false when working from the REPL to avoid this. The page is a bit old, but there&apos;s an example here: https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL"><y>#</y><d>2017-10-21</d><h>20:12</h><w>ryanbrush</w>@wadi.chemkhi By default Clara caches rule sessions for efficiency, but this&apos; isn&apos;t great for a REPL-based workflow. I like to set :cache false when working from the REPL to avoid this. The page is a bit old, but there&apos;s an example here: <a href="https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL" target="_blank">https://github.com/cerner/clara-rules/wiki/Using-Clara-from-the-REPL</a></z><z id="t1508616826000011" t="wadi.chemkhi thnx @ryanbrush 😄"><y>#</y><d>2017-10-21</d><h>20:13</h><w>wadi.chemkhi</w>thnx @ryanbrush <b>😄</b></z><z id="t1508616962000040" t="ryanbrush Sure thing!"><y>#</y><d>2017-10-21</d><h>20:16</h><w>ryanbrush</w>Sure thing!</z><z id="t1508623221000002" t="wadi.chemkhi with clojurescript is it possible to define facts in different namespaces and have defsession work properly and require everything ?"><y>#</y><d>2017-10-21</d><h>22:00</h><w>wadi.chemkhi</w>with clojurescript is it possible to define facts in different namespaces and have defsession work properly and require everything ?</z><z id="t1508623248000026" t="wadi.chemkhi or do i need to require all facts from each rules namespace"><y>#</y><d>2017-10-21</d><h>22:00</h><w>wadi.chemkhi</w>or do i need to require all facts from each rules namespace</z><z id="t1508623250000042" t="wadi.chemkhi ?"><y>#</y><d>2017-10-21</d><h>22:00</h><w>wadi.chemkhi</w>?</z><z id="t1508623533000023" t="ryanbrush I don&apos;t use the Clojurescript version much but it should be as long everything is properly required."><y>#</y><d>2017-10-21</d><h>22:05</h><w>ryanbrush</w>I don&apos;t use the Clojurescript version much but it should be as long everything is properly required.</z><z id="t1508623840000002" t="wadi.chemkhi I see, thnx again @ryanbrush"><y>#</y><d>2017-10-21</d><h>22:10</h><w>wadi.chemkhi</w>I see, thnx again @ryanbrush</z><z id="t1508893128000237" t="souenzzo {:salience java.lang.Long/MIN_VALUE} is a bad idea?? It&apos;s a &quot;final&quot; accumulator."><y>#</y><d>2017-10-25</d><h>00:58</h><w>souenzzo</w><code>{:salience java.lang.Long/MIN_VALUE}</code> is a bad idea?? It&apos;s a &quot;final&quot; accumulator.</z><z id="t1508905847000055" t="devn @souenzzo in what sense do you mean?"><y>#</y><d>2017-10-25</d><h>04:30</h><w>devn</w>@souenzzo in what sense do you mean?</z><z id="t1508905997000040" t="devn Why do you think it might be a bad idea?"><y>#</y><d>2017-10-25</d><h>04:33</h><w>devn</w>Why do you think it might be a bad idea?</z><z id="t1508933928000153" t="souenzzo There is another way to tell &quot;this should be the last one&quot;?"><y>#</y><d>2017-10-25</d><h>12:18</h><w>souenzzo</w>There is another way to tell &quot;this should be the last one&quot;?</z><z id="t1508941236000268" t="wparker @souenzzo using MIN_VALUE would work, it just wouldn’t necessarily be the last thing if you accidentally added another rule with the same salience value. If the rulesets are small and/or you’re the only one working on them that might not be a problem. For our large rulesets with lots of people working on them we find it convenient to have salience with domain-specific categories defined in a single location. If you do need other functionality the salience function is user-configurable, although it defaults to a simple numeric comparison."><y>#</y><d>2017-10-25</d><h>14:20</h><w>wparker</w>@souenzzo using MIN_VALUE would work, it just wouldn’t necessarily be the last thing if you accidentally added another rule with the same salience value.  If the rulesets are small and/or you’re the only one working on them that might not be a problem.  For our large rulesets with lots of people working on them we find it convenient to have salience with domain-specific categories defined in a single location.  If you do need other functionality the salience function is user-configurable, although it defaults to a simple numeric comparison.</z><z id="t1509569381000355" t="wparker Clara-rules release 0.16.1 is now available on Clojars. This contains several bugfixes and other minor improvements relative to 0.16.0. See the changelog for further details. As always please log an issue if you encounter regressions or other problems. https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md"><y>#</y><d>2017-11-01</d><h>20:49</h><w>wparker</w>Clara-rules release 0.16.1 is now available on Clojars.  This contains several bugfixes and other minor improvements relative to 0.16.0. See the changelog for further details.   As always please log an issue if you encounter regressions or other problems. <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md</a></z><z id="t1509569635000125" t="wparker Also, thanks to everyone who contributed to the release - @zylox @ethanc \@dgoeke"><y>#</y><d>2017-11-01</d><h>20:53</h><w>wparker</w>Also, thanks to everyone who contributed to the release - @zylox @ethanc \@dgoeke</z><z id="t1509988491000515" t="souenzzo Can you put a time on each rule? Or a route to view the profile/debug the rules? There is something slow in my engine but I&apos;m not sure how to find what it is."><y>#</y><d>2017-11-06</d><h>17:14</h><w>souenzzo</w>Can you put a <code>time</code> on each rule?
Or a route to view the profile/debug the rules?
There is something slow in my engine but I&apos;m not sure how to find what it is.</z><z id="t1509989343000100" t="dadair maybe run your engine under a profiler like VisualVM? can see what methods may be using the most time and go from there?"><y>#</y><d>2017-11-06</d><h>17:29</h><w>dadair</w>maybe run your engine under a profiler like VisualVM? can see what methods may be using the most time and go from there?</z><z id="t1510000020000545" t="wparker If the problem is a function in your rules (RHS, accumulator function, etc.) that’s taking a lot of time then something like VisualVM would likely be helpful. That’s where I’d start. If the problem is that the rules are firing in a bad/suboptimal way then Clara’s tracing could provide some info, but that is harder to use. https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.cljc , the discussion on https://github.com/cerner/clara-rules/issues/344 around potential tracing enhancements could give some insight into how it works as well"><y>#</y><d>2017-11-06</d><h>20:27</h><w>wparker</w>If the problem is a function in your rules (RHS, accumulator function, etc.) that’s taking a lot of time then something like VisualVM would likely be helpful.  That’s where I’d start.  If the problem is that the rules are firing in a bad/suboptimal way then Clara’s tracing could provide some info, but that is harder to use. <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/tracing.cljc</a>, the discussion on <a href="https://github.com/cerner/clara-rules/issues/344" target="_blank">https://github.com/cerner/clara-rules/issues/344</a> around potential tracing enhancements could give some insight into how it works as well</z><z id="t1510006570000482" t="souenzzo @wparker I made a macro that wrap rhs inside a time -like macro, that time RHS and store it&apos;s time on a global atom (just for use on repl). It allow&apos;s me to see how many times each rule is fired, how many time each &quot;burn&quot; takes, avg, &quot;total time&quot; from each rule. Simple and usefull 😄"><y>#</y><d>2017-11-06</d><h>22:16</h><w>souenzzo</w>@wparker I made a macro that wrap <code>rhs</code> inside a <code>time</code>-like macro, that time RHS and store it&apos;s time on a global atom (just for use on repl).
It allow&apos;s me to see how many times each rule is fired, how many time each &quot;burn&quot; takes, avg, &quot;total time&quot; from each rule. Simple and usefull <b>😄</b></z><z id="t1510006614000308" t="souenzzo (now I&apos;m using my-ns/defrule in place of clara.rules/defrule )"><y>#</y><d>2017-11-06</d><h>22:16</h><w>souenzzo</w>(now I&apos;m using <code>my-ns/defrule</code> in place of <code>clara.rules/defrule</code>)</z><z id="t1510007871000220" t="wparker Glad you’ve found a working solution @souenzzo FYI, there are some cases where Clara could repeatedly add a rule to the queue of things waiting to be fired, remove it, add it again, etc. without ever actually firing it (and thus avoiding that macro) but my guess is those cases are a small though nontrivial minority of perf problems"><y>#</y><d>2017-11-06</d><h>22:37</h><w>wparker</w>Glad you’ve found a working solution @souenzzo FYI, there are some cases where Clara could repeatedly add a rule to the queue of things waiting to be fired, remove it, add it again, etc. without ever actually firing it (and thus avoiding that macro) but my guess is those cases are a small though nontrivial minority of perf problems</z><z id="t1510008318000068" t="souenzzo @wparker I&apos;m just trying to find any slow rhs . Insert or not insert, use or not, not matters. I find a single rule that takes 100x more time that any other. I think that not matter if it will be used or not, in this case."><y>#</y><d>2017-11-06</d><h>22:45</h><r>souenzzo</r>@wparker I&apos;m just trying to find any slow <code>rhs</code>. Insert or not insert, use or not, not matters.
I find a single rule that takes 100x more time that any other.
I think that not matter if it will be used or not, in this case.</z><z id="t1510069760000056" t="wparker Excellent, sounds like you’ve found your performance problem. :+1:"><y>#</y><d>2017-11-07</d><h>15:49</h><r>wparker</r>Excellent, sounds like you’ve found your performance problem. <b>:+1:</b></z><z id="t1510007881000129" t="wparker so that sounds like it would work most of the time"><y>#</y><d>2017-11-06</d><h>22:38</h><w>wparker</w>so that sounds like it would work most of the time</z><z id="t1510591411000332" t="ggaillard Hi ! I have troubles understanding how destructuring works in clara. If I understand the documentation correctly, I would expect this rule to match any record of type Foo and bind the symbol foo to the record itself, so I can use it afterward. (defrule do-something-with-foo [Foo [foo]] =&gt; (do-something-with foo)) I always get an Unable to resolve symbol: foo in this context , where context is the RHS. Am I missing something ?"><y>#</y><d>2017-11-13</d><h>16:43</h><w>ggaillard</w>Hi ! I have troubles understanding how destructuring works in clara. If I understand the documentation correctly, I would expect this rule to match any record of type <code>Foo</code> and bind the symbol <code>foo</code> to the record itself, so I can use it afterward.
<pre>(defrule do-something-with-foo
  [Foo [foo]]
  =&gt;
  (do-something-with  foo))
</pre>
I always get an <code>Unable to resolve symbol: foo in this context</code>, where context is the RHS. 
Am I missing something ?</z><z id="t1510592860000332" t="mikerod @ggaillard the destructured bound symbols are scoped locally to the expressions of the single condition doing the destructuring bind"><y>#</y><d>2017-11-13</d><h>17:07</h><w>mikerod</w>@ggaillard the destructured bound symbols are scoped locally to the expressions of the single condition doing the destructuring bind</z><z id="t1510592885000272" t="mikerod You have to bind a variable to use throughout other conditions or the rule and/or the RHS"><y>#</y><d>2017-11-13</d><h>17:08</h><w>mikerod</w>You have to bind a variable to use throughout other conditions or the rule and/or the RHS</z><z id="t1510592905000457" t="mikerod (defrule do-something-with-foo [Foo [foo] (= ?foo foo)] =&gt; (do-something-with ?foo)) "><y>#</y><d>2017-11-13</d><h>17:08</h><w>mikerod</w><pre>(defrule do-something-with-foo
  [Foo [foo] (= ?foo foo)]
  =&gt;
  (do-something-with  ?foo))
</pre></z><z id="t1510593064000172" t="mikerod In this case, it isn’t too useful"><y>#</y><d>2017-11-13</d><h>17:11</h><w>mikerod</w>In this case, it isn’t too useful</z><z id="t1510593081000369" t="mikerod This would make more sense (defrule do-something-with-foo [?foo &lt;- Foo] =&gt; (do-something-with ?foo)) "><y>#</y><d>2017-11-13</d><h>17:11</h><w>mikerod</w>This would make more sense
<pre>(defrule do-something-with-foo
  [?foo &lt;- Foo]
  =&gt;
  (do-something-with  ?foo))
</pre></z><z id="t1510593120000286" t="ggaillard Oh I get it ! Thank you !"><y>#</y><d>2017-11-13</d><h>17:12</h><w>ggaillard</w>Oh I get it ! Thank you !</z><z id="t1510593148000512" t="mikerod times like: (defrule do-something-with-foo [Foo [{:keys [x y]}] (&lt; 10 x) (= ?y y)] =&gt; (do-something-with ?y)) are where it may be more useful"><y>#</y><d>2017-11-13</d><h>17:12</h><w>mikerod</w>times like:
<pre>(defrule do-something-with-foo
  [Foo [{:keys [x y]}] (&lt; 10 x) (= ?y y)]
  =&gt;
  (do-something-with  ?y))

</pre>
are where it may be more useful</z><z id="t1510593250000595" t="mikerod Also note that when using Clojure records (i.e. defrecord classes) and/or, on the JVM side, Java POJOs adhering to the Java bean spec, Clara automatically makes the field names visible in the local scope of a condition’s experssions (defrecord Foo [x y]) (defrule do-something-with-foo [Foo (&lt; 10 x) (= ?y y)] =&gt; (do-something-with ?y)) Would work without the explicit destructuring syntax"><y>#</y><d>2017-11-13</d><h>17:14</h><w>mikerod</w>Also note that when using Clojure records (i.e. <code>defrecord</code> classes) and/or, on the JVM side, Java POJOs adhering to the Java bean spec, Clara automatically makes the field names visible in the local scope of a condition’s experssions
<pre>(defrecord Foo [x y])

(defrule do-something-with-foo
  [Foo (&lt; 10 x) (= ?y y)]
  =&gt;
  (do-something-with  ?y))
</pre>
Would work without the explicit destructuring syntax</z><z id="t1510593868000463" t="ggaillard I was using your last example until now to extract my records&apos; fields, and since I missed the &lt;- part of facts expressions it quickly became inconvenient when I needed to work with every fields … Thanks for this clarification 🙂"><y>#</y><d>2017-11-13</d><h>17:24</h><w>ggaillard</w>I was using your last example until now to extract my records&apos; fields, and since I missed the <code>&lt;-</code> part of facts expressions it quickly became inconvenient when I needed to work with every fields … Thanks for this clarification <b>🙂</b></z><z id="t1510598804000737" t="mikerod @dave.dixon that is surprising to me"><y>#</y><d>2017-11-13</d><h>18:46</h><w>mikerod</w>@dave.dixon that is surprising to me</z><z id="t1510598865000781" t="mikerod I want to take a look"><y>#</y><d>2017-11-13</d><h>18:47</h><w>mikerod</w>I want to take a look</z><z id="t1510599628000010" t="mikerod @dave.dixon I think there is some sort of compilation issue happening with that rule"><y>#</y><d>2017-11-13</d><h>19:00</h><w>mikerod</w>@dave.dixon I think there is some sort of compilation issue happening with that rule</z><z id="t1510599640000741" t="mikerod (defrule lost-game [?ships &lt;- (acc/count) :from [Ship]] [?destroyed &lt;- (acc/count) :from [Destroyed]] [:test (do (= ?ships ?destroyed))] =&gt; (insert! (-&gt;Loser))) "><y>#</y><d>2017-11-13</d><h>19:00</h><w>mikerod</w><pre>(defrule lost-game
  [?ships &lt;- (acc/count) :from [Ship]]
  [?destroyed &lt;- (acc/count) :from [Destroyed]]
  [:test (do (= ?ships ?destroyed))]
  =&gt;
  (insert! (-&gt;Loser)))
</pre></z><z id="t1510599643000188" t="mikerod worksaround it"><y>#</y><d>2017-11-13</d><h>19:00</h><w>mikerod</w>worksaround it</z><z id="t1510599656000683" t="mikerod I’m not sure the cause still"><y>#</y><d>2017-11-13</d><h>19:00</h><w>mikerod</w>I’m not sure the cause still</z><z id="t1510599749000135" t="sparkofreason @mikerod Thanks. I had several puzzling cases like this, will try the work-around when I get home "><y>#</y><d>2017-11-13</d><h>19:02</h><w>sparkofreason</w>@mikerod Thanks. I had several puzzling cases like this, will try the work-around when I get home </z><z id="t1510599750000436" t="mikerod To me it is looking likely to be worthy of logging an issue to clara github though"><y>#</y><d>2017-11-13</d><h>19:02</h><w>mikerod</w>To me it is looking likely to be worthy of logging an issue to clara github though</z><z id="t1510599776000683" t="mikerod if you have more examples of different shapes, that’d be interesting too"><y>#</y><d>2017-11-13</d><h>19:02</h><w>mikerod</w>if you have more examples of different shapes, that’d be interesting too</z><z id="t1510600038000672" t="zylox Is the test node making a binding somehow instead?....thatd be weird"><y>#</y><d>2017-11-13</d><h>19:07</h><w>zylox</w>Is the test node making a binding somehow instead?....thatd be weird</z><z id="t1510600235000409" t="mikerod @zylox I think it is misintepreting it somehow along those lines"><y>#</y><d>2017-11-13</d><h>19:10</h><w>mikerod</w>@zylox I think it is misintepreting it somehow along those lines</z><z id="t1510600236000651" t="mikerod no good"><y>#</y><d>2017-11-13</d><h>19:10</h><w>mikerod</w>no good</z><z id="t1510600258000335" t="mikerod I looked a a bit in clara.rules.compiler but I don’t see the issue yet"><y>#</y><d>2017-11-13</d><h>19:10</h><w>mikerod</w>I looked a a bit in <code>clara.rules.compiler</code> but I don’t see the issue yet</z><z id="t1510600302000136" t="mikerod If you look at the rulebase for the network without the do (the problem case), the TestNode is a beta root with no parents"><y>#</y><d>2017-11-13</d><h>19:11</h><w>mikerod</w>If you look at the <code>rulebase</code> for the network without the <code>do</code> (the problem case), the <code>TestNode</code> is a beta root with no parents</z><z id="t1510600320000675" t="mikerod And it’s children are the accumulate nodes"><y>#</y><d>2017-11-13</d><h>19:12</h><w>mikerod</w>And it’s children are the accumulate nodes</z><z id="t1510600354000462" t="mikerod This made me suspicious of the function clara.rules.compiler/sort-conditions which does a topological type of sort of accumulators that rearranges some conditions"><y>#</y><d>2017-11-13</d><h>19:12</h><w>mikerod</w>This made me suspicious of the function <code>clara.rules.compiler/sort-conditions</code> which does a topological type of sort of accumulators that rearranges some conditions</z><z id="t1510600369000722" t="mikerod The topo sort is supposed ensure that any used variable binding is pushed below it’s creation unification binding condition"><y>#</y><d>2017-11-13</d><h>19:12</h><w>mikerod</w>The topo sort is supposed ensure that any used variable binding is pushed below it’s creation unification binding condition</z><z id="t1510600546000309" t="mikerod Adding the do in the :test node pushes it down as a child of the accumulate nodes in the network and then it works"><y>#</y><d>2017-11-13</d><h>19:15</h><w>mikerod</w>Adding the <code>do</code> in the <code>:test</code> node pushes it down as a child of the accumulate nodes in the network and then it works</z><z id="t1510600954000754" t="mikerod It may be completely a problem with the sort, as the below demonstrates (ns test.ns (:require [clara.rules :as r] [clara.rules.accumulators :as acc] [clara.rules.compiler :as com])) (defrecord Ship []) (defrecord Destroyed []) (defrecord Loser []) (r/defrule lost-game-fixed [?ships &lt;- (acc/count) :from [Ship]] [?destroyed &lt;- (acc/count) :from [Destroyed]] [:test (do (= ?ships ?destroyed))] ;; Notice the `do` surrounding form is important for the sort =&gt; (r/insert! (-&gt;Loser))) (r/defrule lost-game-broken [?ships &lt;- (acc/count) :from [Ship]] [?destroyed &lt;- (acc/count) :from [Destroyed]] [:test (= ?ships ?destroyed)] ;; Condition with problem, doesn&apos;t work without surrounding form (`do` above) =&gt; (r/insert! (-&gt;Loser))) (com/sort-conditions (-&gt; lost-game-fixed :lhs)) (comment ({:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Ship, :constraints []}, :result-binding :?ships} {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Destroyed, :constraints []}, :result-binding :?destroyed} {:constraints [(do (= ?ships ?destroyed))]})) (com/sort-conditions (-&gt; lost-game-broken :lhs)) (comment ({:constraints [(= ?ships ?destroyed)]} {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Ship, :constraints []}, :result-binding :?ships} {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Destroyed, :constraints []}, :result-binding :?destroyed})) "><y>#</y><d>2017-11-13</d><h>19:22</h><w>mikerod</w>It may be completely a problem with the sort, as the below demonstrates
<pre>(ns test.ns
  (:require [clara.rules :as r]
            [clara.rules.accumulators :as acc]
            [clara.rules.compiler :as com]))

(defrecord Ship [])
(defrecord Destroyed [])
(defrecord Loser [])

(r/defrule lost-game-fixed
  [?ships &lt;- (acc/count) :from [Ship]]
  [?destroyed &lt;- (acc/count) :from [Destroyed]]
  [:test (do (= ?ships ?destroyed))]                           ;; Notice the `do` surrounding form is important for the sort
  =&gt;
  (r/insert! (-&gt;Loser)))

(r/defrule lost-game-broken
  [?ships &lt;- (acc/count) :from [Ship]]
  [?destroyed &lt;- (acc/count) :from [Destroyed]]
  [:test (= ?ships ?destroyed)]                                  ;; Condition with problem, doesn&apos;t work without surrounding form (`do` above)
  =&gt;
  (r/insert! (-&gt;Loser)))


(com/sort-conditions (-&gt; lost-game-fixed :lhs))
(comment
  ({:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Ship, :constraints []}, :result-binding :?ships}
   {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Destroyed, :constraints []}, :result-binding :?destroyed}
   {:constraints [(do (= ?ships ?destroyed))]}))

(com/sort-conditions (-&gt; lost-game-broken :lhs))
(comment
  ({:constraints [(= ?ships ?destroyed)]}
   {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Ship, :constraints []}, :result-binding :?ships}
   {:accumulator (clara.rules.accumulators/count), :from {:type test.ns.Destroyed, :constraints []}, :result-binding :?destroyed}))


</pre></z><z id="t1510600962000270" t="mikerod Unless I’m missing something else prior to this"><y>#</y><d>2017-11-13</d><h>19:22</h><w>mikerod</w>Unless I’m missing something else prior to this</z><z id="t1510601405000058" t="zylox juxt"><y>#</y><d>2017-11-13</d><h>19:30</h><w>zylox</w><b>juxt</b></z><z id="t1510602510000443" t="zylox seems to be that classify-variables considers it an equality-expression? , resulting in them being considered &quot;bound&quot;, but &quot;unbound&quot; in the workaround case"><y>#</y><d>2017-11-13</d><h>19:48</h><w>zylox</w>seems to be that <code>classify-variables</code> considers it an <code>equality-expression?</code>, resulting in them being considered &quot;bound&quot;, but &quot;unbound&quot; in the workaround case</z><z id="t1510604256000077" t="zylox and when they are bound, this fn https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L790 will consider it satisfied because #{} is a subset of #{?ships ?destroyed} , meaning newly-satisfied will contain the test constraint ( https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L797 ) and be put in the front of the order in the into at the end https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L828"><y>#</y><d>2017-11-13</d><h>20:17</h><w>zylox</w>and when they are bound, this fn <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L790" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L790</a> will consider it satisfied because <code>#{}</code> is a subset of <code>#{?ships ?destroyed}</code>, meaning <code>newly-satisfied</code> will contain the test constraint (<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L797" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L797</a>) and be put in the front of the order in the <code>into</code> at the end <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L828" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L828</a></z><z id="t1510604350000339" t="zylox im not sure of a good way to fix this. i can see why it thinks its a bound variable."><y>#</y><d>2017-11-13</d><h>20:19</h><w>zylox</w>im not sure of a good way to fix this. i can see why it thinks its a bound variable.</z><z id="t1510604911000044" t="sparkofreason That fixed it, as well as the other cases, which were essentially the same, with an equality check inside of [:test] ."><y>#</y><d>2017-11-13</d><h>20:28</h><w>sparkofreason</w>That fixed it, as well as the other cases, which were essentially the same, with an equality check inside of <code>[:test]</code>.</z><z id="t1510605213000537" t="wparker The compilation of this rule does seem to be wrong. When I inspect the rule network the :test condition seems to completely not exist in the network. Gist with the pretty-printed network: https://gist.github.com/WilliamParker/a3adaa3db730229bc01586009bb7178a"><y>#</y><d>2017-11-13</d><h>20:33</h><w>wparker</w>The compilation of this rule does seem to be wrong.  When I inspect the rule network the :test condition seems to completely not exist in the network.  Gist with the pretty-printed network: <a href="https://gist.github.com/WilliamParker/a3adaa3db730229bc01586009bb7178a" target="_blank">https://gist.github.com/WilliamParker/a3adaa3db730229bc01586009bb7178a</a></z><z id="t1510605320000445" t="wparker However, if I use join-filter-equals it is there: https://gist.github.com/WilliamParker/347ba6ca3f7e0afc2c9f183e0731111e"><y>#</y><d>2017-11-13</d><h>20:35</h><w>wparker</w>However, if I use join-filter-equals it is there: <a href="https://gist.github.com/WilliamParker/347ba6ca3f7e0afc2c9f183e0731111e" target="_blank">https://gist.github.com/WilliamParker/347ba6ca3f7e0afc2c9f183e0731111e</a></z><z id="t1510605355000060" t="wparker Join-filter-equals just dispatches to =:"><y>#</y><d>2017-11-13</d><h>20:35</h><w>wparker</w>Join-filter-equals just dispatches to =:</z><z id="t1510605370000365" t="wparker (defn join-filter-equals &quot;Intended to be a test function that is the same as equals, but is not visible to Clara as such and thus forces usage of join filters instead of hash joins&quot; [&amp; args] (apply = args)) it is a helper function for Clara’s tests"><y>#</y><d>2017-11-13</d><h>20:36</h><w>wparker</w><pre>(defn join-filter-equals
  &quot;Intended to be a test function that is the same as equals, but is not visible to Clara as such
  and thus forces usage of join filters instead of hash joins&quot;
  [&amp; args]
  (apply = args)) </pre> it is a helper function for Clara’s tests</z><z id="t1510605386000367" t="wparker Same idea really as wrapping in a do like @mikerod did"><y>#</y><d>2017-11-13</d><h>20:36</h><w>wparker</w>Same idea really as wrapping in a do like @mikerod did</z><z id="t1510605534000346" t="wparker Clara has special cases around constraints having = as the first symbol in order to create variable bindings, but when the first symbol is something else if becomes a “normal” call to clojure.core/=. @zylox is probably on the right track here with looking at different paths depending on whether equality-expression? returns true"><y>#</y><d>2017-11-13</d><h>20:38</h><w>wparker</w>Clara has special cases around constraints having = as the first symbol in order to create variable bindings, but when the first symbol is something else if becomes a “normal” call to clojure.core/=.  @zylox is probably on the right track here with looking at different paths depending on whether equality-expression? returns true</z><z id="t1510605620000188" t="wparker I’ll need to look more closely at it to have an informed opinion on the exact cause and what to do about it but this does look like a bug to me @dave.dixon You should be able to avoid it for the moment with strategies that prevent = from being the first symbol in a :test constraint for the moment though"><y>#</y><d>2017-11-13</d><h>20:40</h><w>wparker</w>I’ll need to look more closely at it to have an informed opinion on the exact cause and what to do about it but this does look like a bug to me @dave.dixon You should be able to avoid it for the moment with strategies that prevent = from being the first symbol in a :test constraint for the moment though</z><z id="t1510611235000180" t="wparker I logged https://github.com/cerner/clara-rules/issues/357 for this @dave.dixon @zylox @mikerod"><y>#</y><d>2017-11-13</d><h>22:13</h><w>wparker</w>I logged <a href="https://github.com/cerner/clara-rules/issues/357" target="_blank">https://github.com/cerner/clara-rules/issues/357</a> for this @dave.dixon @zylox @mikerod</z><z id="t1510611319000355" t="mikerod @wparker thanks for making it"><y>#</y><d>2017-11-13</d><h>22:15</h><w>mikerod</w>@wparker thanks for making it</z><z id="t1510611330000175" t="mikerod the only thing maybe worth adding is my comment showing how the sort conditions comes out incorrect"><y>#</y><d>2017-11-13</d><h>22:15</h><w>mikerod</w>the only thing maybe worth adding is my comment showing how the sort conditions comes out incorrect</z><z id="t1510611344000584" t="mikerod I can add as a comment though, or perhaps it isn’t necessary since everyone looking at it already knows anyways 😛"><y>#</y><d>2017-11-13</d><h>22:15</h><w>mikerod</w>I can add as a comment though, or perhaps it isn’t necessary since everyone looking at it already knows anyways <b>😛</b></z><z id="t1510611346000605" t="wparker Feel free to comment on it with thoughts anyone 🙂"><y>#</y><d>2017-11-13</d><h>22:15</h><w>wparker</w>Feel free to comment on it with thoughts anyone <b>🙂</b></z><z id="t1510611378000373" t="wparker I haven’t dug too deeply into it yet"><y>#</y><d>2017-11-13</d><h>22:16</h><w>wparker</w>I haven’t dug too deeply into it yet</z><z id="t1510611917000169" t="mikerod same"><y>#</y><d>2017-11-13</d><h>22:25</h><w>mikerod</w>same</z><z id="t1510683671000531" t="zylox when are you getting that exception"><y>#</y><d>2017-11-14</d><h>18:21</h><w>zylox</w>when are you getting that exception</z><z id="t1510683819000605" t="zylox session creation time it would appear"><y>#</y><d>2017-11-14</d><h>18:23</h><w>zylox</w>session creation time it would appear</z><z id="t1510684393000157" t="sparkofreason Yes, it&apos;s at session creation."><y>#</y><d>2017-11-14</d><h>18:33</h><w>sparkofreason</w>Yes, it&apos;s at session creation.</z><z id="t1510684591000118" t="zylox ya sort-conditions specifically it would appear. im not as versed on queries though"><y>#</y><d>2017-11-14</d><h>18:36</h><w>zylox</w>ya <code>sort-conditions</code> specifically it would appear. im not as versed on queries though</z><z id="t1510684641000303" t="zylox i cant get parameters to work unless they are used in a binding though. that doesnt seem right."><y>#</y><d>2017-11-14</d><h>18:37</h><w>zylox</w>i cant get parameters to work unless they are used in a binding though. that doesnt seem right.</z><z id="t1510685119000095" t="zylox (clara.rules/defquery ship-destroyed-at? [:?point] [?destroyed &lt;- Destroyed (= ?ship ship)] [?placement &lt;- ValidPlacement (= ?ship ship) ((spaces this) ?point)]) for the record this doesnt seem to work either so its not the test node"><y>#</y><d>2017-11-14</d><h>18:45</h><w>zylox</w><pre>(clara.rules/defquery ship-destroyed-at?
          [:?point]
          [?destroyed &lt;- Destroyed (= ?ship ship)]
          [?placement &lt;- ValidPlacement 
           (= ?ship ship)
           ((spaces this) ?point)])</pre> for the record this doesnt seem to work either so its not the test node</z><z id="t1510685144000179" t="mikerod Yeah, my first recommendation was going to be to not use a :test node when it isn’t necessary (although I’d still expect that to work)"><y>#</y><d>2017-11-14</d><h>18:45</h><w>mikerod</w>Yeah, my first recommendation was going to be to not use a <code>:test</code> node when it isn’t necessary (although I’d still expect that to work)</z><z id="t1510685156000448" t="mikerod However, @zylox has found that that is still a problem"><y>#</y><d>2017-11-14</d><h>18:45</h><w>mikerod</w>However, @zylox has found that that is still a problem</z><z id="t1510685254000574" t="zylox if i had to guess, the check this exception uses is too special cased and doesnt consider parameters."><y>#</y><d>2017-11-14</d><h>18:47</h><w>zylox</w>if i had to guess, the check this exception uses is too special cased and doesnt consider parameters.</z><z id="t1510685278000377" t="zylox its the whole unbound vs bound thing again"><y>#</y><d>2017-11-14</d><h>18:47</h><w>zylox</w>its the whole unbound vs bound thing again</z><z id="t1510685289000415" t="zylox so its at least partially related to the thing from yesterday"><y>#</y><d>2017-11-14</d><h>18:48</h><w>zylox</w>so its at least partially related to the thing from yesterday</z><z id="t1510685519000397" t="ryanbrush The above queries won&apos;t work because ?point is not bound, although we could be more clear in our error messaging here."><y>#</y><d>2017-11-14</d><h>18:51</h><w>ryanbrush</w>The above queries won&apos;t work because ?point is not bound, although we could be more clear in our error messaging here.</z><z id="t1510685558000080" t="ryanbrush The :?point is a query parameter, which just does a lookup. A query parameter is not &quot;bound&quot; when the rule engine is processing...it is simple used to look up bound values."><y>#</y><d>2017-11-14</d><h>18:52</h><w>ryanbrush</w>The :?point is a query parameter, which just does a lookup. A query parameter is not &quot;bound&quot; when the rule engine is processing...it is simple used to look up bound values.</z><z id="t1510685575000652" t="ryanbrush Since ?point is never bound in the query itself, we get that error message."><y>#</y><d>2017-11-14</d><h>18:52</h><w>ryanbrush</w>Since ?point is never bound in the query itself, we get that error message.</z><z id="t1510685655000323" t="ryanbrush These semantics are a bit confusing in this case because we&apos;re conflating query parameters (which do not bind a variable) with variables that must be bound with an (= ?my-variable ...) or similar expression."><y>#</y><d>2017-11-14</d><h>18:54</h><w>ryanbrush</w>These semantics are a bit confusing in this case because we&apos;re conflating query parameters (which do not bind a variable) with variables that must be bound with an (= ?my-variable ...) or similar expression.</z><z id="t1510685938000695" t="mikerod Woops, that makes sense to me. I blanked about how they were supposed to work here."><y>#</y><d>2017-11-14</d><h>18:58</h><w>mikerod</w>Woops, that makes sense to me. I blanked about how they were supposed to work here.</z><z id="t1510686024000237" t="sparkofreason So presumably the way to attack this is to make a new fact using those conditions, rather than trying to just query?"><y>#</y><d>2017-11-14</d><h>19:00</h><w>sparkofreason</w>So presumably the way to attack this is to make a new fact using those conditions, rather than trying to just query?</z><z id="t1510686367000388" t="zylox Clearly I need to brush up on queries"><y>#</y><d>2017-11-14</d><h>19:06</h><w>zylox</w>Clearly I need to brush up on queries</z><z id="t1510686374000235" t="zylox ...pun not intended"><y>#</y><d>2017-11-14</d><h>19:06</h><w>zylox</w>...pun not intended</z><z id="t1510688310000255" t="ryanbrush @dave.dixon Separating this out into another fact makes sense. I&apos;m not quite sure what your objective for these rules is, but any approach that explicitly binds ?point in the query logic (not just the parameter) should work."><y>#</y><d>2017-11-14</d><h>19:38</h><w>ryanbrush</w>@dave.dixon Separating this out into another fact makes sense. I&apos;m not quite sure what your objective for these rules is, but any approach that explicitly binds ?point in the query logic (not just the parameter) should work.</z><z id="t1510700611000327" t="sparkofreason That worked great, thanks."><y>#</y><d>2017-11-14</d><h>23:03</h><w>sparkofreason</w>That worked great, thanks.</z><z id="t1511130583000122" t="sparkofreason Sorry if this is documented somewhere, but I didn&apos;t catch it. Is there some best practice around handling fact identity for updates? For example, if have (defrecord Person [name address]) , and I want to update the address, or perhaps even insert the same Person (by value) twice. Is there some way to tell clara to use name to identify the Person and change the replace the existing fact, or do I have to explicitly retract the existing instance? Or am I totally missing something for modeling this situation?"><y>#</y><d>2017-11-19</d><h>22:29</h><w>sparkofreason</w>Sorry if this is documented somewhere, but I didn&apos;t catch it. Is there some best practice around handling fact identity for updates? For example, if have <code>(defrecord Person [name address])</code>, and I want to update the address, or perhaps even insert the same <code>Person</code> (by value) twice. Is there some way to tell clara to use <code>name</code> to identify the Person and change the replace the existing fact, or do I have to explicitly retract the existing instance? Or am I totally missing something for modeling this situation?</z><z id="t1511134251000023" t="mikerod &gt; do I have to explicitly retract the existing instance? Yes, the idea is to do this sort of change explicitly"><y>#</y><d>2017-11-19</d><h>23:30</h><w>mikerod</w>&gt; do I have to explicitly retract the existing instance?
Yes, the idea is to do this sort of change explicitly</z><z id="t1511134260000016" t="mikerod and there is no concept of mutating a fact “in place”"><y>#</y><d>2017-11-19</d><h>23:31</h><w>mikerod</w>and there is no concept of mutating a fact “in place”</z><z id="t1511134276000121" t="mikerod There are several ways to approach the problem"><y>#</y><d>2017-11-19</d><h>23:31</h><w>mikerod</w>There are several ways to approach the problem</z><z id="t1511134460000088" t="mikerod @dave.dixon one idea is if you don’t actually care about deleting old data (perhaps you want to have it for historical rules etc), you could put an intermediary between external “person data at a point in time” vs the “current person” being processed: (r/defrule current-person [?latest &lt;- latest-person-acc :from [PersonSnapshot (= ?name name)]] =&gt; (r/insert! (-&gt;Person ?latest))) "><y>#</y><d>2017-11-19</d><h>23:34</h><w>mikerod</w>@dave.dixon one idea is if you don’t actually care about deleting old data (perhaps you want to have it for historical rules etc), you could put an intermediary between external “person data at a point in time” vs the “current person” being processed:
<pre>(r/defrule current-person
  [?latest &lt;- latest-person-acc :from [PersonSnapshot (= ?name name)]]
  =&gt;
  (r/insert! (-&gt;Person ?latest)))
</pre></z><z id="t1511134483000134" t="mikerod This is if you made some sort of latest-person-acc that chose the latest by some criteria of yours (like a PersonSnapshot timestamp)"><y>#</y><d>2017-11-19</d><h>23:34</h><w>mikerod</w>This is if you made some sort of <code>latest-person-acc</code> that chose the latest by some criteria of yours (like a <code>PersonSnapshot</code> timestamp)</z><z id="t1511134496000016" t="mikerod You could use the clara.rules.accumulators/max for this"><y>#</y><d>2017-11-19</d><h>23:34</h><w>mikerod</w>You could use the <code>clara.rules.accumulators/max</code> for this</z><z id="t1511134516000105" t="mikerod (r/defrule current-person [?latest &lt;- (acc/max :timestamp) :from [PersonSnapshot (= ?name name)]] =&gt; (r/insert! (-&gt;Person ?latest))) "><y>#</y><d>2017-11-19</d><h>23:35</h><w>mikerod</w><pre>(r/defrule current-person
  [?latest &lt;- (acc/max :timestamp) :from [PersonSnapshot (= ?name name)]]
  =&gt;
  (r/insert! (-&gt;Person ?latest)))
</pre></z><z id="t1511134580000018" t="mikerod You may not want to leave facts in though due to a concern, like memory use or something. Then a common way to deal with the update is somewhat external to the rules processing themselves"><y>#</y><d>2017-11-19</d><h>23:36</h><w>mikerod</w>You may not want to leave facts in though due to a concern, like memory use or something. Then a common way to deal with the update is somewhat external to the rules processing themselves</z><z id="t1511135317000013" t="mikerod (defrecord Person [name x]) (r/defquery person-with-name [:?name] [?p &lt;- Person (= ?name name)]) (def init (-&gt; (r/mk-session [person-with-name]) (r/insert (-&gt;Person &quot;joe&quot; 10) (-&gt;Person &quot;mary&quot; 20)) r/fire-rules)) (defn find-person-by-name [session pname] ;; Assumes name is unique (you could do something different) (-&gt; session (r/query person-with-name :?name pname) first :?p)) (defn update-person [session new-person] (let [existing (find-person-by-name session (:name new-person))] (-&gt; session (r/retract existing) (r/insert new-person) r/fire-rules))) (def updated (update-person init (-&gt;Person &quot;joe&quot; 50))) ;; Then try: (find-person-by-name init &quot;joe&quot;) (find-person-by-name updated &quot;joe&quot;) "><y>#</y><d>2017-11-19</d><h>23:48</h><w>mikerod</w><pre>(defrecord Person [name x])

(r/defquery person-with-name [:?name]
  [?p &lt;- Person (= ?name name)])

(def init
  (-&gt; (r/mk-session [person-with-name])
      (r/insert (-&gt;Person &quot;joe&quot; 10)
                (-&gt;Person &quot;mary&quot; 20))
      r/fire-rules))

(defn find-person-by-name [session pname]
  ;; Assumes name is unique (you could do something different)
  (-&gt; session
      (r/query person-with-name :?name pname)
      first
      :?p))

(defn update-person [session new-person]
  (let [existing (find-person-by-name session (:name new-person))]
    (-&gt; session
        (r/retract existing)
        (r/insert new-person)
        r/fire-rules)))

(def updated
  (update-person init (-&gt;Person &quot;joe&quot; 50)))



;; Then try:

(find-person-by-name init &quot;joe&quot;)
(find-person-by-name updated &quot;joe&quot;)
</pre></z><z id="t1511135344000058" t="mikerod That sort of pattern would allow you take rm and old version of the person and insert an update"><y>#</y><d>2017-11-19</d><h>23:49</h><w>mikerod</w>That sort of pattern would allow you take rm and old version of the person and insert an update</z><z id="t1511135377000018" t="mikerod and it avoids getting into situations within the engine where you have to deal with logical loops in the truth maintenance system and/or unconditional inserts, RHS retracts, etc"><y>#</y><d>2017-11-19</d><h>23:49</h><w>mikerod</w>and it avoids getting into situations within the engine where you have to deal with logical loops in the truth maintenance system and/or unconditional inserts, RHS retracts, etc</z><z id="t1511135405000123" t="mikerod You could impl the update-person differently where you just make a change to the existing fact to get some data structural sharing too though instead of a brand new fact like I had"><y>#</y><d>2017-11-19</d><h>23:50</h><w>mikerod</w>You could impl the <code>update-person</code> differently where you just make a change to the <code>existing</code> fact to get some data structural sharing too though instead of a brand new fact like I had</z><z id="t1511135561000038" t="mikerod e.g. (defn update-person [session new-person-data] (let [existing (find-person-by-name session (:name new-person-data)) up (merge existing new-person-data)] (-&gt; session (r/retract existing) (r/insert up) r/fire-rules))) ;; e.g. (update-person init {:name &quot;joe&quot; :x 50}) "><y>#</y><d>2017-11-19</d><h>23:52</h><w>mikerod</w>e.g.
<pre>(defn update-person [session new-person-data]
  (let [existing (find-person-by-name session (:name new-person-data))
        up (merge existing new-person-data)]
    (-&gt; session
        (r/retract existing)
        (r/insert up)
        r/fire-rules)))

;; e.g.
(update-person init {:name &quot;joe&quot; :x 50})

</pre></z><z id="t1511137909000026" t="sparkofreason @mikerod Thanks for the excellent and detailed answer!"><y>#</y><d>2017-11-20</d><h>00:31</h><w>sparkofreason</w>@mikerod Thanks for the excellent and detailed answer!</z><z id="t1511458386000173" t="sparkofreason I think I found the problem. The call to resolve-vars at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/macros.clj#L183 only binds the Clojure namespace. At this point in compilation, the CLJS namespace is not correct. Adding this to the binding fixes the issue: cljs.analyzer/*cljs-ns* (:ns-name production)"><y>#</y><d>2017-11-23</d><h>17:33</h><w>sparkofreason</w>I think I found the problem. The call to <code>resolve-vars</code> at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/macros.clj#L183" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/macros.clj#L183</a> only binds the Clojure namespace. At this point in compilation, the CLJS namespace is not correct. Adding this to the binding fixes the issue: <code>cljs.analyzer/*cljs-ns* (:ns-name production)</code></z><z id="t1512222685000087" t="mikerod It’s on Twitter, but I thought it was cool enough to share here too: Clara on the ThoughtWorks Technology Radar https://www.thoughtworks.com/es/radar/languages-and-frameworks/clara-rules"><y>#</y><d>2017-12-02</d><h>13:51</h><w>mikerod</w>It’s on Twitter, but I thought it was cool enough to share here too:
 Clara on the ThoughtWorks Technology Radar
<a href="https://www.thoughtworks.com/es/radar/languages-and-frameworks/clara-rules" target="_blank">https://www.thoughtworks.com/es/radar/languages-and-frameworks/clara-rules</a></z><z id="t1512259163000059" t="alex-dixon Just came to say congratulations!"><y>#</y><d>2017-12-02</d><h>23:59</h><w>alex-dixon</w>Just came to say congratulations!</z><z id="t1513195889000463" t="dadair Is there any way to get cloverage coverage statistics for clara defrules?"><y>#</y><d>2017-12-13</d><h>20:11</h><w>dadair</w>Is there any way to get <code>cloverage</code> coverage statistics for clara defrules?</z><z id="t1513205257000130" t="wparker I suspect that Clara does enough code generation and evaluation behind the scenes to confuse tooling like Cloverage, at least without some modification to specifically support Clara, but it isn’t something I’ve looked into. I don’t think the rules network could be effectively statically analyzed but perhaps something could be created that looked at what rules were interacted with; that information is available via Clara’s tracing"><y>#</y><d>2017-12-13</d><h>22:47</h><r>wparker</r>I suspect that Clara does enough code generation and evaluation behind the scenes to confuse tooling like Cloverage, at least without some modification to specifically support Clara, but it isn’t something I’ve looked into.  I don’t think the rules network could be effectively statically analyzed but perhaps something could be created that looked at what rules were interacted with; that information is available via Clara’s tracing</z><z id="t1513216619000082" t="mikerod I’m not even sure how Cloverage performs its analysis. Is it via tools.analyzer ?"><y>#</y><d>2017-12-14</d><h>01:56</h><r>mikerod</r>I’m not even sure how Cloverage performs its analysis. Is it via <code>tools.analyzer</code> ?</z><z id="t1513275373000124" t="dadair I&apos;m not exactly sure how it works; but a search in the repo for tools.analyzer returns empty"><y>#</y><d>2017-12-14</d><h>18:16</h><r>dadair</r>I&apos;m not exactly sure how it works; but a search in the repo for <code>tools.analyzer</code> returns empty</z><z id="t1513275421000058" t="dadair I&apos;m mostly just interested in seeing what rules are firing during tests, to make sure I have sufficient tests."><y>#</y><d>2017-12-14</d><h>18:17</h><r>dadair</r>I&apos;m mostly just interested in seeing what rules are firing during tests, to make sure I have sufficient tests.</z><z id="t1513282221000391" t="devn @U0E2EQFME you could do some reading of the inspected session "><y>#</y><d>2017-12-14</d><h>20:10</h><r>devn</r>@U0E2EQFME you could do some reading of the inspected session </z><z id="t1513282235000182" t="devn Or maybe attach a tracing listener to track the rules fired "><y>#</y><d>2017-12-14</d><h>20:10</h><r>devn</r>Or maybe attach a tracing listener to track the rules fired </z><z id="t1513282249000350" t="devn That information should be available via either method "><y>#</y><d>2017-12-14</d><h>20:10</h><r>devn</r>That information should be available via either method </z><z id="t1513282818000020" t="mikerod Yeah, I think I looked at it before and it didn’t use analyzer. Not sure how it can check coverage. Especially via macros."><y>#</y><d>2017-12-14</d><h>20:20</h><r>mikerod</r>Yeah, I think I looked at it before and it didn’t use analyzer. Not sure how it can check coverage. Especially via macros.</z><z id="t1513282823000138" t="mikerod perhaps magic"><y>#</y><d>2017-12-14</d><h>20:20</h><r>mikerod</r>perhaps magic</z><z id="t1513713887000030" t="mikerod @amarjeet you cut it off I think"><y>#</y><d>2017-12-19</d><h>20:04</h><w>mikerod</w>@amarjeet you cut it off I think</z><z id="t1513714044000174" t="mikerod It only shows about 5 lines"><y>#</y><d>2017-12-19</d><h>20:07</h><w>mikerod</w>It only shows about 5 lines</z><z id="t1513718856000458" t="wparker @mikerod I can see a larger snippet after I expand it in my OS X Slack client. @amarjeet I’d have to see lines creating sessions and inserting facts to fully understand what you’re doing, but it sounds like you may believe that a fact {:some :value} will match a condition like [{:some :value}]. This is not the case; Clara uses the fact type, not the fact itself, to match on conditions. So for example {:some :value} would match [java.util.Map] by default, though you can customize the function used for this dispatch. This is documented at http://clara-rules.org ; I can’t hit the site right now but the page’s markdown source is https://github.com/cerner/clara-site/blob/gh-pages/_docs/fact_type_customization.md"><y>#</y><d>2017-12-19</d><h>21:27</h><w>wparker</w>@mikerod I can see a larger snippet after I expand it in my OS X Slack client.  @amarjeet I’d have to see lines creating sessions and inserting facts to fully understand what you’re doing, but it sounds like you may believe that a fact {:some :value} will match a condition like [{:some :value}].  This is not the case; Clara uses the fact type, not the fact itself, to match on conditions.  So for example {:some :value} would match [java.util.Map] by default, though you can customize the function used for this dispatch.  This is documented at <a href="http://clara-rules.org" target="_blank">http://clara-rules.org</a>; I can’t hit the site right now but the page’s markdown source is <a href="https://github.com/cerner/clara-site/blob/gh-pages/_docs/fact_type_customization.md" target="_blank">https://github.com/cerner/clara-site/blob/gh-pages/_docs/fact_type_customization.md</a></z><z id="t1513718926000357" t="mikerod @wparker I can see it on the side bar (same client as you), not sure why it won’t expand otherwise. Anyways, irrelevant than woops."><y>#</y><d>2017-12-19</d><h>21:28</h><w>mikerod</w>@wparker I can see it on the side bar (same client as you), not sure why it won’t expand otherwise. Anyways, irrelevant than woops.</z><z id="t1513749033000052" t="amarjeet @wparker"><y>#</y><d>2017-12-20</d><h>05:50</h><w>amarjeet</w>@wparker</z><z id="t1513781437000067" t="mikerod @amarjeet thatnks for sharing more there"><y>#</y><d>2017-12-20</d><h>14:50</h><w>mikerod</w>@amarjeet thatnks for sharing more there</z><z id="t1513781453000055" t="mikerod So the first level of discrimination in the rules network is going always “fact type”"><y>#</y><d>2017-12-20</d><h>14:50</h><w>mikerod</w>So the first level of discrimination in the rules network is going always “fact type”</z><z id="t1513781468000609" t="mikerod However, the combination of :fact-type-fn and :ancestors-fn give you flexibility into what that means"><y>#</y><d>2017-12-20</d><h>14:51</h><w>mikerod</w>However, the combination of <code>:fact-type-fn</code> and <code>:ancestors-fn</code> give you flexibility into what that means</z><z id="t1513781539000139" t="mikerod The default :fact-type-fn is Clojure’s clojure.core/type , which is just (or (get (meta x) :type) (class x))"><y>#</y><d>2017-12-20</d><h>14:52</h><w>mikerod</w>The default <code>:fact-type-fn</code> is Clojure’s <code>clojure.core/type</code>, which is just <code>(or (get (meta x) :type) (class x))</code></z><z id="t1513781560000314" t="mikerod The default :ancestors-fn is clojure.core/ancestors which respects the “global hierarchy” in Clj which can be altered via things like derive"><y>#</y><d>2017-12-20</d><h>14:52</h><w>mikerod</w>The default <code>:ancestors-fn</code> is <code>clojure.core/ancestors</code> which respects the “global hierarchy” in Clj which can be altered via things like <code>derive</code></z><z id="t1513781585000089" t="mikerod :ancestors-fn is just for making the supertype subtype relationships that factor into the fact type dispatch"><y>#</y><d>2017-12-20</d><h>14:53</h><w>mikerod</w><code>:ancestors-fn</code> is just for making the supertype subtype relationships that factor into the fact type dispatch</z><z id="t1513781615000035" t="mikerod You don’t necessarily have to have a “fact type” if you really don’t want, or you can make it something that is based on the data of the map entities you have"><y>#</y><d>2017-12-20</d><h>14:53</h><w>mikerod</w>You don’t necessarily have to have a “fact type” if you really don’t want, or you can make it something that is based on the data of the map entities you have</z><z id="t1513781693000040" t="mikerod (def session-one (mk-session &apos;modelxt.absmodel :fact-type :name)) for example, although that isn’t very suitable for the rule add-entity that you have"><y>#</y><d>2017-12-20</d><h>14:54</h><w>mikerod</w><code>(def session-one (mk-session &apos;modelxt.absmodel :fact-type :name))</code>
for example, although that isn’t very suitable for the rule <code>add-entity</code> that you have</z><z id="t1513785800000667" t="amarjeet hmm, understood"><y>#</y><d>2017-12-20</d><h>16:03</h><w>amarjeet</w>hmm, understood</z><z id="t1513785897000870" t="amarjeet Will re-look at the fact-type-fn/ancestors-fn"><y>#</y><d>2017-12-20</d><h>16:04</h><w>amarjeet</w>Will re-look at the fact-type-fn/ancestors-fn</z><z id="t1513785906000473" t="amarjeet thanks @mikerod"><y>#</y><d>2017-12-20</d><h>16:05</h><w>amarjeet</w>thanks @mikerod</z><z id="t1513786135000262" t="mikerod No problem"><y>#</y><d>2017-12-20</d><h>16:08</h><w>mikerod</w>No problem</z><z id="t1513908170000138" t="cfleming Is Clara’s fact destructuring as described here: http://www.clara-rules.org/docs/expressions/ the same as Clojure’s destructuring?"><y>#</y><d>2017-12-22</d><h>02:02</h><w>cfleming</w>Is Clara’s fact destructuring as described here: <a href="http://www.clara-rules.org/docs/expressions/" target="_blank">http://www.clara-rules.org/docs/expressions/</a> the same as Clojure’s destructuring?</z><z id="t1513909055000115" t="mikerod @cfleming the part of the syntax shown there uses Clojure destructuring. It basically ends up being a clojure function arglist that takes a single object. "><y>#</y><d>2017-12-22</d><h>02:17</h><w>mikerod</w>@cfleming the part of the syntax shown there uses Clojure destructuring. It basically ends up being a clojure function arglist that takes a single object. </z><z id="t1513909080000068" t="mikerod But yes. It just “flows through” to standard destructuring. "><y>#</y><d>2017-12-22</d><h>02:18</h><w>mikerod</w>But yes. It just “flows through” to standard destructuring. </z><z id="t1513909084000011" t="cfleming Ok, great, thanks."><y>#</y><d>2017-12-22</d><h>02:18</h><w>cfleming</w>Ok, great, thanks.</z><z id="t1513909120000127" t="mikerod No problem. "><y>#</y><d>2017-12-22</d><h>02:18</h><w>mikerod</w>No problem. </z><z id="t1513909459000080" t="cfleming @mikerod One more question while I have you - in the doc, is FACT_CONSTRAINT always a Fact Expression as defined in the doc, or is it any condition?"><y>#</y><d>2017-12-22</d><h>02:24</h><w>cfleming</w>@mikerod One more question while I have you - in the doc, is <code>FACT_CONSTRAINT</code> always a Fact Expression as defined in the doc, or is it any condition?</z><z id="t1513909505000172" t="cfleming (I’m working on specs for the Clara macros right now)"><y>#</y><d>2017-12-22</d><h>02:25</h><w>cfleming</w>(I’m working on specs for the Clara macros right now)</z><z id="t1513909645000032" t="mikerod taking a look"><y>#</y><d>2017-12-22</d><h>02:27</h><w>mikerod</w>taking a look</z><z id="t1513909720000124" t="mikerod I don’t see a FACT_CONSTRAINT referenced in http://www.clara-rules.org/docs/expressions/ ?"><y>#</y><d>2017-12-22</d><h>02:28</h><w>mikerod</w>I don’t see a <code>FACT_CONSTRAINT</code> referenced in <a href="http://www.clara-rules.org/docs/expressions/" target="_blank">http://www.clara-rules.org/docs/expressions/</a> ?</z><z id="t1513909731000116" t="mikerod nevermind see it"><y>#</y><d>2017-12-22</d><h>02:28</h><w>mikerod</w>nevermind see it</z><z id="t1513909752000005" t="cfleming It’s in Boolean Expressions and also Accumulators"><y>#</y><d>2017-12-22</d><h>02:29</h><w>cfleming</w>It’s in Boolean Expressions and also Accumulators</z><z id="t1513909843000072" t="mikerod Ok, it is a fact expression as referred to above"><y>#</y><d>2017-12-22</d><h>02:30</h><w>mikerod</w>Ok, it is a fact expression as referred to above</z><z id="t1513909860000016" t="cfleming Great, thanks."><y>#</y><d>2017-12-22</d><h>02:31</h><w>cfleming</w>Great, thanks.</z><z id="t1513909889000224" t="cfleming Hopefully I’ll have something basic working soon, I’ll push it for comments - there are still a bunch of TODOs in there."><y>#</y><d>2017-12-22</d><h>02:31</h><w>cfleming</w>Hopefully I’ll have something basic working soon, I’ll push it for comments - there are still a bunch of TODOs in there.</z><z id="t1513909912000091" t="mikerod There may be times when it is odd to do something like bind a fact to a variable, but I think the syntax typically allows these cases - even if they don’t end up being useful."><y>#</y><d>2017-12-22</d><h>02:31</h><w>mikerod</w>There may be times when it is odd to do something like bind a fact to a variable, but I think the syntax typically allows these cases - even if they don’t end up being useful.</z><z id="t1513909918000008" t="mikerod That is cool. Sounds interesting"><y>#</y><d>2017-12-22</d><h>02:31</h><w>mikerod</w>That is cool. Sounds interesting</z><z id="t1513909935000058" t="mikerod I’ll try to give a look at it too once you have it out there."><y>#</y><d>2017-12-22</d><h>02:32</h><w>mikerod</w>I’ll try to give a look at it too once you have it out there.</z><z id="t1513909942000148" t="cfleming Great, thanks - this is re: https://github.com/cerner/clara-rules/issues/367"><y>#</y><d>2017-12-22</d><h>02:32</h><w>cfleming</w>Great, thanks - this is re: <a href="https://github.com/cerner/clara-rules/issues/367" target="_blank">https://github.com/cerner/clara-rules/issues/367</a></z><z id="t1513909943000008" t="mikerod I’m still catching up on the GitHub conversation from earlier"><y>#</y><d>2017-12-22</d><h>02:32</h><w>mikerod</w>I’m still catching up on the GitHub conversation from earlier</z><z id="t1513909957000158" t="cfleming Cool, no rush."><y>#</y><d>2017-12-22</d><h>02:32</h><w>cfleming</w>Cool, no rush.</z><z id="t1513912179000106" t="cfleming I’ve pushed https://github.com/cursive-ide/clara-specs"><y>#</y><d>2017-12-22</d><h>03:09</h><w>cfleming</w>I’ve pushed <a href="https://github.com/cursive-ide/clara-specs" target="_blank">https://github.com/cursive-ide/clara-specs</a></z><z id="t1513912222000151" t="cfleming It contains a first cut at specs to match the macros in the Clara DSL - they match all the examples from the documentation correctly as far as I can tell."><y>#</y><d>2017-12-22</d><h>03:10</h><w>cfleming</w>It contains a first cut at specs to match the macros in the Clara DSL - they match all the examples from the documentation correctly as far as I can tell.</z><z id="t1513912245000062" t="cfleming There are still some TODOs in there which weren’t clear to me from the doc, mostly stubbed out with any?"><y>#</y><d>2017-12-22</d><h>03:10</h><w>cfleming</w>There are still some TODOs in there which weren’t clear to me from the doc, mostly stubbed out with <code>any?</code></z><z id="t1513912271000176" t="cfleming My next task is to try it on the clara-examples repo and make sure it works for the examples there too."><y>#</y><d>2017-12-22</d><h>03:11</h><w>cfleming</w>My next task is to try it on the clara-examples repo and make sure it works for the examples there too.</z><z id="t1513912324000061" t="cfleming @alex-dixon @mikerod ^^ FYI"><y>#</y><d>2017-12-22</d><h>03:12</h><w>cfleming</w>@alex-dixon @mikerod ^^ FYI</z><z id="t1513912745000078" t="mikerod @cfleming nice. This is looking pretty good. I have looked over it fairly quick. I see a few things to tweak but mostly it is looking pretty close to what I’d think is right"><y>#</y><d>2017-12-22</d><h>03:19</h><w>mikerod</w>@cfleming nice. This is looking pretty good. I have looked over it fairly quick. I see a few things to tweak but mostly it is looking pretty close to what I’d think is right</z><z id="t1513912793000204" t="cfleming Great, thanks - feel free to file an issue or just let me know what to change and I’ll update it."><y>#</y><d>2017-12-22</d><h>03:19</h><w>cfleming</w>Great, thanks - feel free to file an issue or just let me know what to change and I’ll update it.</z><z id="t1513912871000075" t="cfleming I’ll have to figure out how the symbol resolution should work for unification variables too."><y>#</y><d>2017-12-22</d><h>03:21</h><w>cfleming</w>I’ll have to figure out how the symbol resolution should work for unification variables too.</z><z id="t1513912883000147" t="cfleming (in Cursive, that is, not required for the specs)."><y>#</y><d>2017-12-22</d><h>03:21</h><w>cfleming</w>(in Cursive, that is, not required for the specs).</z><z id="t1513912917000092" t="mikerod Tomorrow I can give some better notes. A GitHub issue there perhaps to hold them. "><y>#</y><d>2017-12-22</d><h>03:21</h><w>mikerod</w>Tomorrow I can give some better notes. A GitHub issue there perhaps to hold them. </z><z id="t1513912940000041" t="mikerod Easier things: the LHS can have 0 conditions. "><y>#</y><d>2017-12-22</d><h>03:22</h><w>mikerod</w>Easier things: the LHS can have 0 conditions. </z><z id="t1513912951000023" t="cfleming Great, thanks. I’m going to be in and out over the holiday period but I’ll try to get it fixed up when I get a moment."><y>#</y><d>2017-12-22</d><h>03:22</h><w>cfleming</w>Great, thanks. I’m going to be in and out over the holiday period but I’ll try to get it fixed up when I get a moment.</z><z id="t1513912952000200" t="mikerod The RHS can have multiple forms now I believe. "><y>#</y><d>2017-12-22</d><h>03:22</h><w>mikerod</w>The RHS can have multiple forms now I believe. </z><z id="t1513912966000163" t="cfleming Ok, so the RHS is like a body?"><y>#</y><d>2017-12-22</d><h>03:22</h><w>cfleming</w>Ok, so the RHS is like a body?</z><z id="t1513912991000097" t="mikerod Fact type really can be like anything. So that’s a harder one I think. "><y>#</y><d>2017-12-22</d><h>03:23</h><w>mikerod</w>Fact type really can be like anything. So that’s a harder one I think. </z><z id="t1513913012000138" t="mikerod Yeah RHS is just like an implicit do"><y>#</y><d>2017-12-22</d><h>03:23</h><w>mikerod</w>Yeah RHS is just like an implicit <code>do</code></z><z id="t1513913015000049" t="mikerod Block"><y>#</y><d>2017-12-22</d><h>03:23</h><w>mikerod</w>Block</z><z id="t1513913019000087" t="cfleming Ok."><y>#</y><d>2017-12-22</d><h>03:23</h><w>cfleming</w>Ok.</z><z id="t1513913056000031" t="cfleming But I guess it should always have at least one form?"><y>#</y><d>2017-12-22</d><h>03:24</h><w>cfleming</w>But I guess it should always have at least one form?</z><z id="t1513913079000131" t="mikerod Yeah I believe the RHS needs at least one form. "><y>#</y><d>2017-12-22</d><h>03:24</h><w>mikerod</w>Yeah I believe the RHS needs at least one form. </z><z id="t1513913100000102" t="mikerod If it didn’t it wouldn’t be a useful rule at least. Hah"><y>#</y><d>2017-12-22</d><h>03:25</h><w>mikerod</w>If it didn’t it wouldn’t be a useful rule at least. Hah</z><z id="t1513913140000139" t="cfleming Hehe"><y>#</y><d>2017-12-22</d><h>03:25</h><w>cfleming</w>Hehe</z><z id="t1513913154000106" t="mikerod Thanks for trying this out!"><y>#</y><d>2017-12-22</d><h>03:25</h><w>mikerod</w>Thanks for trying this out!</z><z id="t1513913173000003" t="cfleming Also, in the defquery doc it shows CONDITION repeated inside []"><y>#</y><d>2017-12-22</d><h>03:26</h><w>cfleming</w>Also, in the defquery doc it shows <code>CONDITION</code> repeated inside <code>[]</code></z><z id="t1513970057000377" t="mikerod This is just a mistake in the docs. it should be the same as a rule in this part of a query"><y>#</y><d>2017-12-22</d><h>19:14</h><r>mikerod</r>This is just a mistake in the docs. it should be the same as a rule in this part of a query</z><z id="t1513970200000274" t="mikerod what you have @ https://github.com/cursive-ide/clara-specs/commit/fa9f7aca57b7a4735d356f54e22399efc4534f72#diff-21ed98cbfbc6578b6ba48146b1f5b9aaR44 looks right"><y>#</y><d>2017-12-22</d><h>19:16</h><r>mikerod</r>what you have @ <a href="https://github.com/cursive-ide/clara-specs/commit/fa9f7aca57b7a4735d356f54e22399efc4534f72#diff-21ed98cbfbc6578b6ba48146b1f5b9aaR44" target="_blank">https://github.com/cursive-ide/clara-specs/commit/fa9f7aca57b7a4735d356f54e22399efc4534f72#diff-21ed98cbfbc6578b6ba48146b1f5b9aaR44</a> looks right</z><z id="t1513994893000063" t="cfleming Great, thanks Mike"><y>#</y><d>2017-12-23</d><h>02:08</h><r>cfleming</r>Great, thanks Mike</z><z id="t1513994948000072" t="cfleming Looks like these are pretty close to correct then. Thanks for the great doc, a few ambiguities and mistakes like the above aside, it was great and really helpful in making these."><y>#</y><d>2017-12-23</d><h>02:09</h><r>cfleming</r>Looks like these are pretty close to correct then. Thanks for the great doc, a few ambiguities and mistakes like the above aside, it was great and really helpful in making these.</z><z id="t1513994970000083" t="cfleming Once these are done perhaps the doc could be created from them in the future."><y>#</y><d>2017-12-23</d><h>02:09</h><r>cfleming</r>Once these are done perhaps the doc could be created from them in the future.</z><z id="t1513995836000085" t="mikerod Yeah t is looking good. I agree too that it would be nice to align the docs to it potentially could help ensure they stay correct too. "><y>#</y><d>2017-12-23</d><h>02:23</h><r>mikerod</r>Yeah t is looking good. I agree too that it would be nice to align the docs to it potentially could help ensure they stay correct too. </z><z id="t1513995920000103" t="mikerod So I guess we need to figure out how to go about getting the specs in the repo. I think it’d be good to hear some feedback from at least @U0KRSVDHR on it too. He is on vacation and traveling a bit I believe (common for many right now in US). That’s probably why he hasn’t said much on the subject yet. "><y>#</y><d>2017-12-23</d><h>02:25</h><r>mikerod</r>So I guess we need to figure out how to go about getting the specs in the repo. I think it’d be good to hear some feedback from at least @U0KRSVDHR on it too. He is on vacation and traveling a bit I believe (common for many right now in US). That’s probably why he hasn’t said much on the subject yet. </z><z id="t1513995971000014" t="cfleming Ok, no problem. They could be provided as a separate clara-specs artifact, too, if getting them in the main repo were undesirable."><y>#</y><d>2017-12-23</d><h>02:26</h><r>cfleming</r>Ok, no problem. They could be provided as a separate clara-specs artifact, too, if getting them in the main repo were undesirable.</z><z id="t1513996050000166" t="mikerod Yeah a separate artifact is easy enough. I am thinking the main repo may be a good place too though. I just wanted to hear a bit of feedback from others there. It looks like it could be like an optional require sort of thing too so it wouldn’t mean that Clara couldn’t still support older clj for those not using it yet. "><y>#</y><d>2017-12-23</d><h>02:27</h><r>mikerod</r>Yeah a separate artifact is easy enough. I am thinking the main repo may be a good place too though. I just wanted to hear a bit of feedback from others there. It looks like it could be like an optional require sort of thing too so it wouldn’t mean that Clara couldn’t still support older clj for those not using it yet. </z><z id="t1513996083000026" t="cfleming Right, as long as users on &lt;=1.8 don’t require that ns, they won’t have a problem."><y>#</y><d>2017-12-23</d><h>02:28</h><r>cfleming</r>Right, as long as users on &lt;=1.8 don’t require that ns, they won’t have a problem.</z><z id="t1513996094000056" t="mikerod Clara already has an “optional” sort of dependency on Fressian (for a default durability layer impl). So it wouldn’t be the first of that sort. "><y>#</y><d>2017-12-23</d><h>02:28</h><r>mikerod</r>Clara already has an “optional” sort of dependency on Fressian (for a default durability layer impl). So it wouldn’t be the first of that sort. </z><z id="t1513996136000059" t="mikerod We should reference your repo in the github issue on Clara related to this spec’ing too to be sure everyone sees it"><y>#</y><d>2017-12-23</d><h>02:28</h><r>mikerod</r>We should reference your repo in the github issue on Clara related to this spec’ing too to be sure everyone sees it</z><z id="t1513996273000065" t="mikerod I’m sure people will like to get some cursive support from this too. That seems like it could be really useful"><y>#</y><d>2017-12-23</d><h>02:31</h><r>mikerod</r>I’m sure people will like to get some cursive support from this too. That seems like it could be really useful</z><z id="t1513996313000067" t="cfleming Yeah, Cerner are big Cursive users so it will help a lot of people there (and elsewhere) I think."><y>#</y><d>2017-12-23</d><h>02:31</h><r>cfleming</r>Yeah, Cerner are big Cursive users so it will help a lot of people there (and elsewhere) I think.</z><z id="t1513996352000049" t="cfleming I’ll probably have some questions about how the symbol resolution in conditions works too, once I get that far."><y>#</y><d>2017-12-23</d><h>02:32</h><r>cfleming</r>I’ll probably have some questions about how the symbol resolution in conditions works too, once I get that far.</z><z id="t1513996365000096" t="cfleming That looks a little tricky."><y>#</y><d>2017-12-23</d><h>02:32</h><r>cfleming</r>That looks a little tricky.</z><z id="t1513996400000029" t="mikerod Yeah it sounds like there is a good audience for it. It is a good way to get the cursive functionality some good exposure and perhaps testing too. "><y>#</y><d>2017-12-23</d><h>02:33</h><r>mikerod</r>Yeah it sounds like there is a good audience for it. It is a good way to get the cursive functionality some good exposure and perhaps testing too. </z><z id="t1513996450000094" t="mikerod Yeah. Let me know if you have any questions about Clara concerning that. I can try to assist with what I can in terms of Clara semantics or whatever. "><y>#</y><d>2017-12-23</d><h>02:34</h><r>mikerod</r>Yeah. Let me know if you have any questions about Clara concerning that. I can try to assist with what I can in terms of Clara semantics or whatever. </z><z id="t1513996513000081" t="cfleming Great, thanks. I’m unlikely to get much done until the beginning of Jan now, but I might tinker a bit over the holidays."><y>#</y><d>2017-12-23</d><h>02:35</h><r>cfleming</r>Great, thanks. I’m unlikely to get much done until the beginning of Jan now, but I might tinker a bit over the holidays.</z><z id="t1513996573000048" t="mikerod Sounds good"><y>#</y><d>2017-12-23</d><h>02:36</h><r>mikerod</r>Sounds good</z><z id="t1513996624000032" t="cfleming Thanks for all the help, and happy holidays!"><y>#</y><d>2017-12-23</d><h>02:37</h><r>cfleming</r>Thanks for all the help, and happy holidays!</z><z id="t1513996635000068" t="mikerod Thanks. You too!"><y>#</y><d>2017-12-23</d><h>02:37</h><r>mikerod</r>Thanks. You too!</z><z id="t1513913202000194" t="cfleming I’m not sure what that’s supposed to look like, the examples don’t have repeated vectors inside that."><y>#</y><d>2017-12-22</d><h>03:26</h><w>cfleming</w>I’m not sure what that’s supposed to look like, the examples don’t have repeated vectors inside that.</z><z id="t1513913216000025" t="mikerod I’ll have to check that one out. "><y>#</y><d>2017-12-22</d><h>03:26</h><w>mikerod</w>I’ll have to check that one out. </z><z id="t1513913222000102" t="cfleming Ok, thanks."><y>#</y><d>2017-12-22</d><h>03:27</h><w>cfleming</w>Ok, thanks.</z><z id="t1513913272000091" t="cfleming Ok, I’ve got to step out now, thanks for the feedback! It’s already Friday afternoon here so if you can file an issue or something with any further feedback I’ll get to it when I can."><y>#</y><d>2017-12-22</d><h>03:27</h><w>cfleming</w>Ok, I’ve got to step out now, thanks for the feedback! It’s already Friday afternoon here so if you can file an issue or something with any further feedback I’ll get to it when I can.</z><z id="t1513913334000047" t="mikerod Sounds good. Thursday night here. Hah. I’ll see what else I can point on there likely tomorrow morning. "><y>#</y><d>2017-12-22</d><h>03:28</h><w>mikerod</w>Sounds good. Thursday night here. Hah. I’ll see what else I can point on there likely tomorrow morning. </z><z id="t1513913345000043" t="cfleming Perfect, thanks Mike!"><y>#</y><d>2017-12-22</d><h>03:29</h><w>cfleming</w>Perfect, thanks Mike!</z><z id="t1513945865000132" t="amarjeet @mikerod I experimented after your notes. Have better understanding now. Your note helped 🙂"><y>#</y><d>2017-12-22</d><h>12:31</h><w>amarjeet</w>@mikerod I experimented after your notes. Have better understanding now. Your note helped <b>🙂</b></z><z id="t1513949518000282" t="souenzzo There is docs about props ? http://www.clara-rules.org/docs/rules/ :salience is the unique &quot;relevant&quot; value inside this map?"><y>#</y><d>2017-12-22</d><h>13:31</h><w>souenzzo</w>There is docs about <code>props</code>?
<a href="http://www.clara-rules.org/docs/rules/" target="_blank">http://www.clara-rules.org/docs/rules/</a>
<code>:salience</code> is the unique &quot;relevant&quot; value inside this map?</z><z id="t1513952156000322" t="mikerod @souenzzo I’m not sure if there are docs about all props"><y>#</y><d>2017-12-22</d><h>14:15</h><w>mikerod</w>@souenzzo I’m not sure if there are docs about all <code>props</code></z><z id="t1513952177000306" t="mikerod It is a map of keyword to anything. :salience is one supported one. The only other I can think of is :no-loop"><y>#</y><d>2017-12-22</d><h>14:16</h><w>mikerod</w>It is a map of keyword to anything. <code>:salience</code> is one supported one. The only other I can think of is <code>:no-loop</code></z><z id="t1513952280000212" t="mikerod and usually you shouldn’t need to worry about :no-loop"><y>#</y><d>2017-12-22</d><h>14:18</h><w>mikerod</w>and usually you shouldn’t need to worry about <code>:no-loop</code></z><z id="t1513952753000490" t="souenzzo I&apos;m annotating some data to use on inspect. outside a name conflict, should not be a problem, right?"><y>#</y><d>2017-12-22</d><h>14:25</h><w>souenzzo</w>I&apos;m annotating some data to use on inspect. outside a name conflict, should not be a problem, right?</z><z id="t1513952812000495" t="mikerod You want to put additional information in the props map for your own purposes you mean?"><y>#</y><d>2017-12-22</d><h>14:26</h><w>mikerod</w>You want to put additional information in the <code>props</code> map for your own purposes you mean?</z><z id="t1513952820000181" t="souenzzo Yep"><y>#</y><d>2017-12-22</d><h>14:27</h><w>souenzzo</w>Yep</z><z id="t1513952832000622" t="mikerod I think that should be ok. You probably want to do something like use namespaced keywords though as keys"><y>#</y><d>2017-12-22</d><h>14:27</h><w>mikerod</w>I think that should be ok. You probably want to do something like use namespaced keywords though as keys</z><z id="t1513966465000074" t="alex-dixon @mikerod Could no loop could be used as a modify? Like if I wanted to increment each match at most once per fire rules?"><y>#</y><d>2017-12-22</d><h>18:14</h><w>alex-dixon</w>@mikerod Could no loop could be used as a modify? Like if I wanted to increment each match at most once per fire rules?</z><z id="t1513967756000376" t="mikerod @alex-dixon like:"><y>#</y><d>2017-12-22</d><h>18:35</h><w>mikerod</w>@alex-dixon like:</z><z id="t1513967761000012" t="mikerod (r/defrule demo {:no-loop true} [?a &lt;- A] =&gt; (r/insert! (update ?a :some-val inc))) "><y>#</y><d>2017-12-22</d><h>18:36</h><w>mikerod</w><pre>(r/defrule demo
  {:no-loop true}
  [?a &lt;- A]
  =&gt;
  (r/insert! (update ?a :some-val inc)))
</pre></z><z id="t1513967762000450" t="mikerod ?"><y>#</y><d>2017-12-22</d><h>18:36</h><w>mikerod</w>?</z><z id="t1513967796000448" t="mikerod and perhaps with a RHS (r/retract! ?a) before - actually not sure on this part - it is a secondary part of the question"><y>#</y><d>2017-12-22</d><h>18:36</h><w>mikerod</w>and perhaps with a RHS <code>(r/retract! ?a)</code> before - actually not sure on this part - it is a secondary part of the question</z><z id="t1513968048000119" t="alex-dixon With retract yeah. To simulate mutation "><y>#</y><d>2017-12-22</d><h>18:40</h><w>alex-dixon</w>With retract yeah. To simulate mutation </z><z id="t1513968600000373" t="mikerod It may be feasible, something you’d want to be careful for proliferating everywhere"><y>#</y><d>2017-12-22</d><h>18:50</h><w>mikerod</w>It may be feasible, something you’d want to be careful for proliferating everywhere</z><z id="t1513968617000101" t="mikerod with r/retract! I actually dont’ know"><y>#</y><d>2017-12-22</d><h>18:50</h><w>mikerod</w>with <code>r/retract!</code> I actually dont’ know</z><z id="t1513968636000381" t="mikerod I can’t remember if :no-loop will stop a truth maintenance retraction sort of loop - perhaps you’ve tried?"><y>#</y><d>2017-12-22</d><h>18:50</h><w>mikerod</w>I can’t remember if <code>:no-loop</code> will stop a truth maintenance retraction sort of loop - perhaps you’ve tried?</z><z id="t1513968714000033" t="mikerod I’ve mentioned on here before as well, if you don’t have a big concern with an always growing set of facts in working memory, you don’t need to retract. You can just “modify” and only base downstream logic on the “latest”"><y>#</y><d>2017-12-22</d><h>18:51</h><w>mikerod</w>I’ve mentioned on here before as well, if you don’t have a big concern with an always growing set of facts in working memory, you don’t need to retract. You can just “modify” and only base downstream logic on the “latest”</z><z id="t1513968758000176" t="mikerod however, for something long running or with many of these changes, memory use would get too high"><y>#</y><d>2017-12-22</d><h>18:52</h><w>mikerod</w>however, for something long running or with many of these changes, memory use would get too high</z><z id="t1513981202000074" t="alex-dixon @mikerod This is the first I’ve heard of no loop! I’m excited by it. Here’s an issue you raised a few years ago, looks like it led to truth maintenance being brought under the “no loop” umbrella as well: https://github.com/cerner/clara-rules/issues/99"><y>#</y><d>2017-12-22</d><h>22:20</h><w>alex-dixon</w>@mikerod This is the first I’ve heard of no loop! I’m excited by it. Here’s an issue you raised a few years ago, looks like it led to truth maintenance being brought under the “no loop” umbrella as well: <a href="https://github.com/cerner/clara-rules/issues/99" target="_blank">https://github.com/cerner/clara-rules/issues/99</a></z><z id="t1513983882000143" t="mikerod @alex-dixon oh nice. The memory has returned to me now (after reading that issue and comments again) hah"><y>#</y><d>2017-12-22</d><h>23:04</h><w>mikerod</w>@alex-dixon oh nice. The memory has returned to me now (after reading that issue and comments again) hah</z><z id="t1513983936000025" t="mikerod It’d be interesting to see how doing something like you said would go then"><y>#</y><d>2017-12-22</d><h>23:05</h><w>mikerod</w>It’d be interesting to see how doing something like you said would go then</z><z id="t1513983943000058" t="mikerod if you retract the fact and insert the updated version of it"><y>#</y><d>2017-12-22</d><h>23:05</h><w>mikerod</w>if you retract the fact and insert the updated version of it</z><z id="t1513983986000151" t="mikerod then all other rules that were based (or transitively based) only that removed fact would be retracted. However, the new updated version of the fact would then be available to rebuild those downstream results"><y>#</y><d>2017-12-22</d><h>23:06</h><w>mikerod</w>then all other rules that were based (or transitively based) only that removed fact would be retracted. However, the new updated version of the fact would then be available to rebuild those downstream results</z><z id="t1513983991000058" t="mikerod That ma work out alright."><y>#</y><d>2017-12-22</d><h>23:06</h><w>mikerod</w>That ma work out alright.</z><z id="t1513984238000013" t="mikerod @alex-dixon but be aware there are some edge cases to RHS retracts still."><y>#</y><d>2017-12-22</d><h>23:10</h><w>mikerod</w>@alex-dixon but be aware there are some edge cases to RHS retracts still.</z><z id="t1513984250000094" t="mikerod https://github.com/cerner/clara-rules/issues/229 https://github.com/cerner/clara-rules/issues/321 are 2 I can immediately find"><y>#</y><d>2017-12-22</d><h>23:10</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/issues/229" target="_blank">https://github.com/cerner/clara-rules/issues/229</a>
<a href="https://github.com/cerner/clara-rules/issues/321" target="_blank">https://github.com/cerner/clara-rules/issues/321</a>
 are 2 I can immediately find</z><z id="t1513984722000020" t="alex-dixon I’m trying to understand the difference with that behavior and insert logical vs insert unconditional with an explicit retraction….kind of a head spinner. It seems a lot of the landmines and complexity are tied up with insert logical. Would you agree?"><y>#</y><d>2017-12-22</d><h>23:18</h><w>alex-dixon</w>I’m trying to understand the difference with that behavior and insert logical vs insert unconditional with an explicit retraction….kind of a head spinner. It seems a lot of the landmines and complexity are tied up with insert logical. Would you agree?</z><z id="t1513985737000171" t="mikerod @alex-dixon Hmm. I think sticking to all logical insert is a reduction of complexity"><y>#</y><d>2017-12-22</d><h>23:35</h><w>mikerod</w>@alex-dixon Hmm. I think sticking to all logical insert is a reduction of complexity</z><z id="t1513985767000030" t="mikerod There are just cases when it is difficult to express what you want with only the built-in logical truth maintenance."><y>#</y><d>2017-12-22</d><h>23:36</h><w>mikerod</w>There are just cases when it is difficult to express what you want with only the built-in logical truth maintenance.</z><z id="t1513985804000010" t="mikerod Doing things like unconditional insert and RHS retracts are subversions to the truth maintenance system (aka TMS). With that comes difficulty"><y>#</y><d>2017-12-22</d><h>23:36</h><w>mikerod</w>Doing things like unconditional insert and RHS retracts are subversions to the truth maintenance system (aka TMS). With that comes difficulty</z><z id="t1513985847000001" t="mikerod The reason TMS and logical insertion are so useful is that they allow for a much larger degree of rule order evaluation independence."><y>#</y><d>2017-12-22</d><h>23:37</h><w>mikerod</w>The reason TMS and logical insertion are so useful is that they allow for a much larger degree of rule order evaluation independence.</z><z id="t1513985871000178" t="mikerod I think what Clara may be lacking most is a way to explicitly “update” a fact."><y>#</y><d>2017-12-22</d><h>23:37</h><w>mikerod</w>I think what Clara may be lacking most is a way to explicitly “update” a fact.</z><z id="t1513985905000029" t="mikerod The more I think of it coming up, the more it seems like it’d be a nice first-class thing that ensured that it had well defined semantics with how it interacted with TMS."><y>#</y><d>2017-12-22</d><h>23:38</h><w>mikerod</w>The more I think of it coming up, the more it seems like it’d be a nice first-class thing that ensured that it had well defined semantics with how it interacted with TMS.</z><z id="t1513985965000168" t="mikerod However, I have mentioned before, that you can also make an external process that handles “updates” or retractions - leaving the rules part all logical insert + TMS."><y>#</y><d>2017-12-22</d><h>23:39</h><w>mikerod</w>However, I have mentioned before, that you can also make an external process that handles “updates” or retractions - leaving the rules part all logical insert + TMS.</z><z id="t1513985988000030" t="mikerod However, that is still a manual thing right now. I’ve posted on here a few times what that sort of thing looks like though."><y>#</y><d>2017-12-22</d><h>23:39</h><w>mikerod</w>However, that is still a manual thing right now. I’ve posted on here a few times what that sort of thing looks like though.</z><z id="t1513989970000097" t="alex-dixon Interesting. And yeah seems we’re talking about the same with update/modify. I’m only slightly familiar with it from Drools."><y>#</y><d>2017-12-23</d><h>00:46</h><w>alex-dixon</w>Interesting. And yeah seems we’re talking about the same with update/modify. I’m only slightly familiar with it from Drools.</z><z id="t1513990080000069" t="alex-dixon I searched the slack history at clojureverse and wasn’t able to find your explanation 😞 . Sounds very intriguing. I’ll keep looking and thinking about this over the holiday. Thanks so much for your responses they give me a lot to think about 🙂"><y>#</y><d>2017-12-23</d><h>00:48</h><w>alex-dixon</w>I searched the slack history at clojureverse and wasn’t able to find your explanation <b>😞</b>. Sounds very intriguing. I’ll keep looking and thinking about this over the holiday. Thanks so much for your responses they give me a lot to think about <b>🙂</b></z><z id="t1513990119000081" t="mikerod I think I’ll just make a blog post on the external update thing"><y>#</y><d>2017-12-23</d><h>00:48</h><w>mikerod</w>I think I’ll just make a blog post on the external update thing</z><z id="t1513990198000086" t="mikerod Yeah, Drools had an update mechanism. I think they had some interesting optimizations done with it. Even more so in 6+ of it when they had a large overhaul to how the fact propagation of the rule network worked I think."><y>#</y><d>2017-12-23</d><h>00:49</h><w>mikerod</w>Yeah, Drools had an update mechanism. I think they had some interesting optimizations done with it. Even more so in 6+ of it when they had a large overhaul to how the fact propagation of the rule network worked I think.</z><z id="t1513990224000033" t="mikerod I used to spend quite a bit of time trying to parse through the Drools codebase. It’s pretty “intense” though 😛"><y>#</y><d>2017-12-23</d><h>00:50</h><w>mikerod</w>I used to spend quite a bit of time trying to parse through the Drools codebase. It’s pretty “intense” though <b>😛</b></z><z id="t1514046280000037" t="alex-dixon Have you read Clara’s source? 😄"><y>#</y><d>2017-12-23</d><h>16:24</h><r>alex-dixon</r>Have you read Clara’s source? <b>😄</b></z><z id="t1514046327000040" t="mikerod Haha. Oh yes. I’m all caught up on that one. "><y>#</y><d>2017-12-23</d><h>16:25</h><r>mikerod</r>Haha. Oh yes. I’m all caught up on that one. </z><z id="t1514046179000103" t="alex-dixon Is 6+ with the Phreak algorithm instead of Rete?"><y>#</y><d>2017-12-23</d><h>16:22</h><w>alex-dixon</w>Is 6+ with the Phreak algorithm instead of Rete?</z><z id="t1514046204000083" t="alex-dixon Sorry…I should just google that….:)"><y>#</y><d>2017-12-23</d><h>16:23</h><w>alex-dixon</w>Sorry…I should just google that….:)</z><z id="t1514046353000003" t="mikerod Yep"><y>#</y><d>2017-12-23</d><h>16:25</h><w>mikerod</w>Yep</z><z id="t1514046407000050" t="mikerod I don’t know that I fully consider it separate. But they do. It does have a lot of modifications over rete. However all modern rete impl’s do. "><y>#</y><d>2017-12-23</d><h>16:26</h><w>mikerod</w>I don’t know that I fully consider it separate. But they do. It does have a lot of modifications over rete. However all modern rete impl’s do. </z><z id="t1514046469000057" t="mikerod There are some good ideas there though. I think Clara is competitive with the optimization it has though in many cases. "><y>#</y><d>2017-12-23</d><h>16:27</h><w>mikerod</w>There are some good ideas there though. I think Clara is competitive with the optimization it has though in many cases. </z><z id="t1514046554000050" t="mikerod Drools 5 vs 6 added a lot of things at once. It makes it hard to know which ones are paying off the most. At least from what is public. I think the most important optimization was just the batched fact propagation across the network. That is done in Drools 6 phreak via a “lazy” sort of evaluation of rules. "><y>#</y><d>2017-12-23</d><h>16:29</h><w>mikerod</w>Drools 5 vs 6 added a lot of things at once. It makes it hard to know which ones are paying off the most. At least from what is public. I think the most important optimization was just the batched fact propagation across the network. That is done in Drools 6 phreak via a “lazy” sort of evaluation of rules. </z><z id="t1514046622000037" t="mikerod Clara could potentially do a bit better with lazy propagation. However just having the batched propagation seems to work pretty well already. "><y>#</y><d>2017-12-23</d><h>16:30</h><w>mikerod</w>Clara could potentially do a bit better with lazy propagation.  However just having the batched propagation seems to work pretty well already. </z><z id="t1514046710000021" t="alex-dixon I thought Phreak was more eager"><y>#</y><d>2017-12-23</d><h>16:31</h><w>alex-dixon</w>I thought Phreak was more eager</z><z id="t1514046793000032" t="alex-dixon Overall I’m under the impression Clara was written with distributed computing in mind…I don’t know if other rule engines compete with that, and to me it seems like a ridiculously powerful feature"><y>#</y><d>2017-12-23</d><h>16:33</h><w>alex-dixon</w>Overall I’m under the impression Clara was written with distributed computing in mind…I don’t know if other rule engines compete with that, and to me it seems like a ridiculously powerful feature</z><z id="t1514047230000077" t="mikerod Hmm. It should be more lazy. Hah. There are lots of blogs on it by Drools people. Good blogs really. They put out some good content that is helpful more generally"><y>#</y><d>2017-12-23</d><h>16:40</h><w>mikerod</w>Hmm. It should be more lazy. Hah. There are lots of blogs on it by Drools people. Good blogs really. They put out some good content that is helpful more generally</z><z id="t1514047269000065" t="mikerod But yes Clara does a good job in terms of its flexibility to be used in different ways. "><y>#</y><d>2017-12-23</d><h>16:41</h><w>mikerod</w>But yes Clara does a good job in terms of its flexibility to be used in different ways. </z><z id="t1514047290000066" t="mikerod Some good abstractions in place. "><y>#</y><d>2017-12-23</d><h>16:41</h><w>mikerod</w>Some good abstractions in place. </z><z id="t1514047583000063" t="alex-dixon Have you used clara-storm or have any desire to run Clara across multiple instances?"><y>#</y><d>2017-12-23</d><h>16:46</h><w>alex-dixon</w>Have you used clara-storm or have any desire to run Clara across multiple instances?</z><z id="t1514048236000036" t="mikerod That was Something Ryan put together early on with Clara. I believe he said it was mostly an experiment or demonstration of how it might be done. Not a production worthy product. "><y>#</y><d>2017-12-23</d><h>16:57</h><w>mikerod</w>That was Something Ryan put together early on with Clara. I believe he said it was mostly an experiment or demonstration of how it might be done. Not a production worthy product. </z><z id="t1514048324000111" t="mikerod And early on I think he had some thoughts about where to apply it but went in a different direction instead. I haven’t had the need but I’ve spent a little time thinking about it. I think it’d be cool to see Clara used across Something like distributed processes"><y>#</y><d>2017-12-23</d><h>16:58</h><w>mikerod</w>And early on I think he had some thoughts about where to apply it but went in a different direction instead. I haven’t had the need but I’ve spent a little time thinking about it. I think it’d be cool to see Clara used across Something like distributed processes</z><z id="t1514052465000016" t="ryanbrush Yeah, Storm support was just an experiment for a need that never really materialized so we didn&apos;t pursue it further. The internals of Clara were designed to support a distributed working memory, so it could be something we pick up at some point."><y>#</y><d>2017-12-23</d><h>18:07</h><w>ryanbrush</w>Yeah, Storm support was just an experiment for a need that never really materialized so we didn&apos;t pursue it further. The internals of Clara were designed to support a distributed working memory, so it could be something we pick up at some point.</z><z id="t1514053177000048" t="alex-dixon All tests are passing last I checked 🙂"><y>#</y><d>2017-12-23</d><h>18:19</h><w>alex-dixon</w>All tests are passing last I checked <b>🙂</b></z><z id="t1514053332000085" t="alex-dixon I’ve been interested in two applications related to it. Mainly stream processing with Kafka but also web workers in the browser"><y>#</y><d>2017-12-23</d><h>18:22</h><w>alex-dixon</w>I’ve been interested in two applications related to it. Mainly stream processing with Kafka but also web workers in the browser</z><z id="t1514060204000034" t="ryanbrush The test coverage in that project is pretty weak, though. We&apos;re using Clara in Spark now, but are keeping working memory local to each worker...basically our workload lets us do groupby operations to group needed facts into a common process and then using Clara there."><y>#</y><d>2017-12-23</d><h>20:16</h><w>ryanbrush</w>The test coverage in that project is pretty weak, though. We&apos;re using Clara in Spark now,  but are keeping working memory local to each worker...basically our workload lets us do groupby operations to group needed facts into a common process and then using Clara there.</z><z id="t1514076258000006" t="mikerod @alex-dixon I made a blog post on the topic of “fact updates” in Clara @ http://www.metasimple.org/2017/12/23/clara-updating-facts.html Perhaps something like it could be added to Clara docs later."><y>#</y><d>2017-12-24</d><h>00:44</h><w>mikerod</w>@alex-dixon I made a blog post on the topic of “fact updates” in Clara @ <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a>
Perhaps something like it could be added to Clara docs later.</z><z id="t1514076285000018" t="mikerod It is basically just reiterating things I’ve discussed before in this Slack channel on the topic. We discussed this a little a day or so ago."><y>#</y><d>2017-12-24</d><h>00:44</h><w>mikerod</w>It is basically just reiterating things I’ve discussed before in this Slack channel on the topic. We discussed this a little a day or so ago.</z><z id="t1514076330000036" t="alex-dixon Awesome. Thanks. Will read and share"><y>#</y><d>2017-12-24</d><h>00:45</h><w>alex-dixon</w>Awesome. Thanks. Will read and share</z><z id="t1514076368000005" t="mikerod cool. feel free to let me know if you see problems with it or anything too"><y>#</y><d>2017-12-24</d><h>00:46</h><w>mikerod</w>cool. feel free to let me know if you see problems with it or anything too</z><z id="t1514132290000035" t="alex-dixon Very well written. Really impressed at how quickly you were able to produce that… 🙂"><y>#</y><d>2017-12-24</d><h>16:18</h><r>alex-dixon</r>Very well written. Really impressed at how quickly you were able to produce that… <b>🙂</b></z><z id="t1514132668000059" t="mikerod Thanks!"><y>#</y><d>2017-12-24</d><h>16:24</h><r>mikerod</r>Thanks!</z><z id="t1514133072000012" t="alex-dixon I haven’t figured out a good solution for “default values” of facts. E.g. I have some rules I’m working on now for precept-devtools where I’m trying to allow the user to view history for a rule. When the user first selects “show history”, I want to provide a default (e.g. the first rule firing). After that I want the user to be able to switch through the selected history. I’d like to have one “selected history” fact. If it doesn’t exist because the user hasn’t set it, it should be derived from other facts. If the user sets it though, then “selected history” should be whatever the user says."><y>#</y><d>2017-12-24</d><h>16:31</h><r>alex-dixon</r>I haven’t figured out a good solution for “default values” of facts. E.g. I have some rules I’m working on now for precept-devtools where I’m trying to allow the user to view history for a rule. When the user first selects “show history”, I want to provide a default (e.g. the first rule firing). After that I want the user to be able to switch through the selected history. I’d like to have one “selected history” fact. If it doesn’t exist because the user hasn’t set it, it should be derived from other facts. If the user sets it though, then “selected history” should be whatever the user says.</z><z id="t1514133185000107" t="mikerod That sounds like you could encode that as 2 separate rules that both insert the selected history fact"><y>#</y><d>2017-12-24</d><h>16:33</h><r>mikerod</r>That sounds like you could encode that as 2 separate rules that both insert the selected history fact</z><z id="t1514133196000002" t="alex-dixon To get a default I’m writing something like “[:not {SelectedHistory} =&gt; (insert-unconditional! [SelectedHistory 0])”"><y>#</y><d>2017-12-24</d><h>16:33</h><r>alex-dixon</r>To get a default I’m writing something like “[:not {SelectedHistory} =&gt; (insert-unconditional! [SelectedHistory 0])”</z><z id="t1514133204000045" t="mikerod One rule would only fire if some user provided fact is not present. "><y>#</y><d>2017-12-24</d><h>16:33</h><r>mikerod</r>One rule would only fire if some user provided fact is not present. </z><z id="t1514133223000045" t="mikerod Yeah. Use a different fact type as the “trigger”"><y>#</y><d>2017-12-24</d><h>16:33</h><r>mikerod</r>Yeah. Use a different fact type as the “trigger”</z><z id="t1514133251000095" t="mikerod And no need for unconditional "><y>#</y><d>2017-12-24</d><h>16:34</h><r>mikerod</r>And no need for unconditional </z><z id="t1514133381000057" t="mikerod [:not [SelectHistoryEvent]] =&gt; (insert! (-&gt;SelectedHistory 0)) "><y>#</y><d>2017-12-24</d><h>16:36</h><r>mikerod</r><pre>[:not [SelectHistoryEvent]]
=&gt;
(insert! (-&gt;SelectedHistory 0))
</pre></z><z id="t1514133435000062" t="mikerod The other rule would be the same, but would use the event to build the SelectedHistory with the provided value"><y>#</y><d>2017-12-24</d><h>16:37</h><r>mikerod</r>The other rule would be the same, but would use the event to build the SelectedHistory with the provided value</z><z id="t1514133469000015" t="mikerod And if you want the ability to retract/toggle do some sort of external retract like I described in blog perhaps."><y>#</y><d>2017-12-24</d><h>16:37</h><r>mikerod</r>And if you want the ability to retract/toggle do some sort of external retract like I described in blog perhaps.</z><z id="t1514133515000025" t="alex-dixon Ok. I’ll try that. Thanks"><y>#</y><d>2017-12-24</d><h>16:38</h><r>alex-dixon</r>Ok. I’ll try that. Thanks</z><z id="t1514137516000076" t="mikerod Time to write a “defaulting facts” blog! 😛"><y>#</y><d>2017-12-24</d><h>17:45</h><r>mikerod</r>Time to write a “defaulting facts” blog! <b>😛</b></z><z id="t1514142119000053" t="alex-dixon Sorry….don’t mean to create work for you. I’m still figuring out patterns. I think UI might be different from the way Clara is normally used? Maybe not but there are facts coming from the outside virtually all the time and I’ve often wondered if that’s significantly different from the use case at Cerner"><y>#</y><d>2017-12-24</d><h>19:01</h><r>alex-dixon</r>Sorry….don’t mean to create work for you. I’m still figuring out patterns. I think UI might be different from the way Clara is normally used? Maybe not but there are facts coming from the outside virtually all the time and I’ve often wondered if that’s significantly different from the use case at Cerner</z><z id="t1514143490000034" t="mikerod Oh no not a problem. I want to do things like write more blogs anyways. Hah. But yeah I think the UI usage of Clara pushes new things up to the forefront. But that is a good thing"><y>#</y><d>2017-12-24</d><h>19:24</h><r>mikerod</r>Oh no not a problem. I want to do things like write more blogs anyways. Hah. But yeah I think the UI usage of Clara pushes new things up to the forefront. But that is a good thing</z><z id="t1514143524000086" t="mikerod I’m doing quite a bit of UI things recently and I think some stuff you’ve been doing seems really interesting. I really want to look at it a bit more soon. "><y>#</y><d>2017-12-24</d><h>19:25</h><r>mikerod</r>I’m doing quite a bit of UI things recently and I think some stuff you’ve been doing seems really interesting. I really want to look at it a bit more soon. </z><z id="t1514387698000124" t="alex-dixon Thanks! That means a lot coming from you 🙂 . If it’d make things easier or faster maybe we could screenshare or just chat and go over example UI rules. Your feedback on some of the patterns we’ve used in Precept so far would be invaluable"><y>#</y><d>2017-12-27</d><h>15:14</h><r>alex-dixon</r>Thanks! That means a lot coming from you <b>🙂</b>. If it’d make things easier or faster maybe we could screenshare or just chat and go over example UI rules. Your feedback on some of the patterns we’ve used in Precept so far would be invaluable</z><z id="t1514395207000178" t="mikerod Yeah, that could work. I’ll try to find some time available soon for something like that. I want to do a little bit of a read through of precept to have some insight too. I like to read open-source libs doing interesting things anyways."><y>#</y><d>2017-12-27</d><h>17:20</h><r>mikerod</r>Yeah, that could work. I’ll try to find some time available soon for something like that. I want to do a little bit of a read through of <code>precept</code> to have some insight too. I like to read open-source libs doing interesting things anyways.</z><z id="t1514082463000012" t="sparkofreason Brain bubble: clara and onyx might be a great match for distributed processing. "><y>#</y><d>2017-12-24</d><h>02:27</h><w>sparkofreason</w>Brain bubble: clara and onyx might be a great match for distributed processing. </z><z id="t1514154765000018" t="sparkofreason After reading this ( https://clojurians-log.clojureverse.org/clara/2015-12-11.html ) and @mikerod&apos;s article ( http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html ), I think there may be something there. It&apos;s all sky pie at this point, but it certainly seems like the network should be translatable to an onyx job. Onyx has fault tolerance for stateful tasks, and has taken a pretty good beating from jepsen."><y>#</y><d>2017-12-24</d><h>22:32</h><w>sparkofreason</w>After reading this (<a href="https://clojurians-log.clojureverse.org/clara/2015-12-11.html" target="_blank">https://clojurians-log.clojureverse.org/clara/2015-12-11.html</a>) and @mikerod&apos;s article (<a href="http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html" target="_blank">http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html</a>), I think there may be something there. It&apos;s all sky pie at this point, but it certainly seems like the network should be translatable to an onyx job. Onyx has fault tolerance for stateful tasks, and has taken a pretty good beating from jepsen.</z><z id="t1514236500000011" t="alex-dixon Thanks for the links. Read both and very helpful. This was the inspiration for me: https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/"><y>#</y><d>2017-12-25</d><h>21:15</h><w>alex-dixon</w>Thanks for the links. Read both and very helpful. This was the inspiration for me: <a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/" target="_blank">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a></z><z id="t1514236714000040" t="alex-dixon I’ve only worked with Kafka a bit, but I like it a lot. Its weakness right now seems to be “materialized views” and stream processing in general. There’s ksql and kafka-streams to deal with joins between topics, but neither seem as good a solution as a rules engine"><y>#</y><d>2017-12-25</d><h>21:18</h><r>alex-dixon</r>I’ve only worked with Kafka a bit, but I like it a lot. Its weakness right now seems to be “materialized views” and stream processing in general. There’s ksql and kafka-streams to deal with joins between topics, but neither seem as good a solution as a rules engine</z><z id="t1514593600000053" t="sparkofreason Agreed. I think Kafka is suitable as a source of facts, but the rules engine gives you both logic and materialized views for &quot;complex event processing&quot;. If we could implement the distributed working menu in Onyx and feed the whole thing with Kafka, it seems pretty cool."><y>#</y><d>2017-12-30</d><h>00:26</h><r>sparkofreason</r>Agreed. I think Kafka is suitable as a source of facts, but the rules engine gives you both logic and materialized views for &quot;complex event processing&quot;. If we could implement the distributed working menu in Onyx and feed the whole thing with Kafka, it seems pretty cool.</z><z id="t1514372355000014" t="amarjeet When i inspect a session, the value of :fact-&gt;explanations key is always nil, despite facts being inserted into the session. My goal is to check what all facts are in the session. Help? CC: @mikerod"><y>#</y><d>2017-12-27</d><h>10:59</h><w>amarjeet</w>When i inspect a session, the value of :fact-&gt;explanations key is always nil, despite facts being inserted into the session. My goal is to check what all facts are in the session. Help? CC: @mikerod</z><z id="t1514372596000204" t="amarjeet The session-&gt;fact-graph too returns nil: {:forward-edges {}, :backward-edges {}}"><y>#</y><d>2017-12-27</d><h>11:03</h><w>amarjeet</w>The session-&gt;fact-graph too returns nil: {:forward-edges {}, :backward-edges {}}</z><z id="t1514386765000376" t="mikerod @amarjeet I think I’d need more of an example to see what you mean"><y>#</y><d>2017-12-27</d><h>14:59</h><w>mikerod</w>@amarjeet I think I’d need more of an example to see what you mean</z><z id="t1514386805000152" t="mikerod However, if you are just doing this for some sort of debugging, you could also add a query that matched any fact and use that to see what is in the session. This query could be a performance issue in a production usage though,."><y>#</y><d>2017-12-27</d><h>15:00</h><w>mikerod</w>However, if you are just doing this for some sort of debugging, you could also add a query that matched any fact and use that to see what is in the session. This query could be a performance issue in a production usage though,.</z><z id="t1514387114000313" t="amarjeet I was debugging basically, so with queries I can test things"><y>#</y><d>2017-12-27</d><h>15:05</h><w>amarjeet</w>I was debugging basically, so with queries I can test things</z><z id="t1514387152000381" t="amarjeet in the process of debugging, I tried inspect and fact-graph...thats when I came across nil values"><y>#</y><d>2017-12-27</d><h>15:05</h><w>amarjeet</w>in the process of debugging, I tried inspect and fact-graph...thats when I came across nil values</z><z id="t1514387218000191" t="amarjeet But, queries clearly shows that facts are there. So, now just wondering if :fact-explanation or fact-graph should be looked at or not?"><y>#</y><d>2017-12-27</d><h>15:06</h><w>amarjeet</w>But, queries clearly shows that facts are there. So, now just wondering if :fact-explanation or fact-graph should be looked at or not?</z><z id="t1514388493000334" t="mikerod @amarjeet your code snipet looks wrong. Perhaps just a typo? You have (insert-all facts base-session) when it should be (insert-all base-session facts) - base-session is first arg"><y>#</y><d>2017-12-27</d><h>15:28</h><w>mikerod</w>@amarjeet your code snipet looks wrong. Perhaps just a typo? You have <code>(insert-all facts base-session)</code> when it should be <code>(insert-all base-session facts)</code>  - <code>base-session</code> is first arg</z><z id="t1514388730000016" t="mikerod Also, I only see 2 def in your example. One for base-session and one for mysession . I don’t see what you called to try inspecting and looking at the inspection results. That’d be useful too. Pending the above comment I had was just a typo"><y>#</y><d>2017-12-27</d><h>15:32</h><w>mikerod</w>Also, I only see 2 <code>def</code> in your example. One for <code>base-session</code> and one for <code>mysession</code>. I don’t see what you called to try inspecting and looking at the inspection results. That’d be useful too. Pending the above comment I had was just a typo</z><z id="t1514390583000287" t="mikerod @amarjeet did you call fire-rules on the mysession ?"><y>#</y><d>2017-12-27</d><h>16:03</h><w>mikerod</w>@amarjeet did you call <code>fire-rules</code> on the <code>mysession</code>?</z><z id="t1514390670000226" t="amarjeet no actually"><y>#</y><d>2017-12-27</d><h>16:04</h><w>amarjeet</w>no actually</z><z id="t1514390699000376" t="amarjeet I see thats the problem? Because, I just tried with fire-rules, and I see the facts"><y>#</y><d>2017-12-27</d><h>16:04</h><w>amarjeet</w>I see thats the problem? Because, I just tried with fire-rules, and I see the facts</z><z id="t1514390763000152" t="amarjeet But, without firing the rules, the insertion is happening"><y>#</y><d>2017-12-27</d><h>16:06</h><w>amarjeet</w>But, without firing the rules, the insertion is happening</z><z id="t1514390823000290" t="amarjeet with fire-rules, only matched facts are being returned under the fact-&gt;explanation"><y>#</y><d>2017-12-27</d><h>16:07</h><w>amarjeet</w>with fire-rules, only matched facts are being returned under the fact-&gt;explanation</z><z id="t1514390851000398" t="amarjeet I thought, with inspect, I could see all inserted facts, not just the matched ones"><y>#</y><d>2017-12-27</d><h>16:07</h><w>amarjeet</w>I thought, with inspect, I could see all inserted facts, not just the matched ones</z><z id="t1514391053000302" t="mikerod @amarjeet I think in general you shouldn’t assume much about the state of working memory prior to fire-rules"><y>#</y><d>2017-12-27</d><h>16:10</h><w>mikerod</w>@amarjeet I think in general you shouldn’t assume much about the state of working memory prior to <code>fire-rules</code></z><z id="t1514391070000280" t="mikerod Take that as a general principle. Things are done sometimes “lazily” in some respects"><y>#</y><d>2017-12-27</d><h>16:11</h><w>mikerod</w>Take that as a general principle. Things are done sometimes “lazily” in some respects</z><z id="t1514391096000014" t="mikerod That doesn’t answer the 2nd part of your question as to what is missing post-rule firing though"><y>#</y><d>2017-12-27</d><h>16:11</h><w>mikerod</w>That doesn’t answer the 2nd part of your question as to what is missing post-rule firing though</z><z id="t1514391278000164" t="amarjeet hmm, understood the issue now regarding &apos;before fire-rule&apos; part."><y>#</y><d>2017-12-27</d><h>16:14</h><w>amarjeet</w>hmm, understood the issue now regarding &apos;before fire-rule&apos; part.</z><z id="t1514391659000358" t="amarjeet I re-checked, post fire-rules, I can see only matched facts, not all inserted ones (in that session)"><y>#</y><d>2017-12-27</d><h>16:20</h><w>amarjeet</w>I re-checked, post fire-rules, I can see only matched facts, not all inserted ones (in that session)</z><z id="t1514392348000141" t="mikerod I’ll have to take a look at things a bit to have a better answer on that"><y>#</y><d>2017-12-27</d><h>16:32</h><w>mikerod</w>I’ll have to take a look at things a bit to have a better answer on that</z><z id="t1514392422000260" t="amarjeet cool cool, thanks much"><y>#</y><d>2017-12-27</d><h>16:33</h><w>amarjeet</w>cool cool, thanks much</z><z id="t1514394614000039" t="mikerod @amarjeet it seems the purpose of the key :fact-&gt;explanations is to explain derived facts within working memory"><y>#</y><d>2017-12-27</d><h>17:10</h><w>mikerod</w>@amarjeet it seems the purpose of the key <code>:fact-&gt;explanations</code> is to explain derived facts within working memory</z><z id="t1514394625000017" t="mikerod not facts explicitly given via an external insert or insert-all"><y>#</y><d>2017-12-27</d><h>17:10</h><w>mikerod</w>not facts explicitly given via an external <code>insert</code> or <code>insert-all</code></z><z id="t1514394657000168" t="amarjeet okay, that makes sense then"><y>#</y><d>2017-12-27</d><h>17:10</h><w>amarjeet</w>okay, that makes sense then</z><z id="t1514394660000069" t="mikerod You can dig out that info in some sense"><y>#</y><d>2017-12-27</d><h>17:11</h><w>mikerod</w>You can dig out that info in some sense</z><z id="t1514394673000214" t="amarjeet yeah"><y>#</y><d>2017-12-27</d><h>17:11</h><w>amarjeet</w>yeah</z><z id="t1514394688000148" t="mikerod Take for example: :fact-&gt;explanations {#clara.test_rules.B{} [{:rule {:ns-name clara.test-rules, :lhs [{:type clara.test_rules.A, :constraints []}], :rhs (do (insert! (-&gt;B))), :name &quot;clara.test-rules/test-a&quot;}, :explanation #clara.tools.inspect.Explanation{:matches ({:fact #clara.test_rules.A{}, :condition {:type clara.test_rules.A, :constraints []}}), :bindings {}}}]} "><y>#</y><d>2017-12-27</d><h>17:11</h><w>mikerod</w>Take for example:
<pre>:fact-&gt;explanations
{#clara.test_rules.B{}
[{:rule {:ns-name clara.test-rules, :lhs [{:type clara.test_rules.A, :constraints []}], :rhs (do (insert! (-&gt;B))), :name &quot;clara.test-rules/test-a&quot;},
:explanation #clara.tools.inspect.Explanation{:matches ({:fact #clara.test_rules.A{}, :condition {:type clara.test_rules.A, :constraints []}}), :bindings {}}}]}
</pre></z><z id="t1514394713000024" t="mikerod clara.test_rules.B is the derived fact"><y>#</y><d>2017-12-27</d><h>17:11</h><w>mikerod</w><code>clara.test_rules.B</code> is the derived fact</z><z id="t1514394744000232" t="mikerod the value under it is a list of rules deriving it. There’d be more than one if multiple of these facts were = in working memory."><y>#</y><d>2017-12-27</d><h>17:12</h><w>mikerod</w>the value under it is a list of rules deriving it. There’d be more than one if multiple of these facts were <code>=</code> in working memory.</z><z id="t1514394821000161" t="amarjeet yes, I did got that when I checked with fire-rules"><y>#</y><d>2017-12-27</d><h>17:13</h><w>amarjeet</w>yes, I did got that when I checked with fire-rules</z><z id="t1514394834000029" t="amarjeet understood it now"><y>#</y><d>2017-12-27</d><h>17:13</h><w>amarjeet</w>understood it now</z><z id="t1514394886000136" t="mikerod (into [] (comp cat (map :explanation) (mapcat :matches) (map :fact)) (vals (:fact-&gt;explanations inspect-results))) combined with (keys (:fact-&gt;explanations inspect-results)) sort of gets you there"><y>#</y><d>2017-12-27</d><h>17:14</h><w>mikerod</w><pre>(into []
      (comp cat
            (map :explanation)
            (mapcat :matches)
            (map :fact))
      (vals (:fact-&gt;explanations inspect-results)))
</pre>
combined with <code>(keys (:fact-&gt;explanations inspect-results))</code> sort of gets you there</z><z id="t1514394914000299" t="mikerod Also, an important consideration is that Clara doesn’t hold references to any inserted facts that cannot contribute to any rule"><y>#</y><d>2017-12-27</d><h>17:15</h><w>mikerod</w>Also, an important consideration is that Clara doesn’t hold references to any inserted facts that cannot contribute to any rule</z><z id="t1514394926000218" t="mikerod So those effectively are not in working memory at all anymore"><y>#</y><d>2017-12-27</d><h>17:15</h><w>mikerod</w>So those effectively are not in working memory at all anymore</z><z id="t1514394957000448" t="amarjeet hmm, yeah, got it"><y>#</y><d>2017-12-27</d><h>17:15</h><w>amarjeet</w>hmm, yeah, got it</z><z id="t1514394974000140" t="amarjeet makes sense now"><y>#</y><d>2017-12-27</d><h>17:16</h><w>amarjeet</w>makes sense now</z><z id="t1514394978000056" t="mikerod (defrecord A []) (defrule not-using-a [:not-a] =&gt; (insert! {:not-a true})) (-&gt; (mk-session [not-using-a]) (insert (-&gt;A)) fire-rules) "><y>#</y><d>2017-12-27</d><h>17:16</h><w>mikerod</w><pre>(defrecord A [])

(defrule not-using-a
  [:not-a]
  =&gt;
  (insert! {:not-a true}))

(-&gt; (mk-session [not-using-a])
    (insert (-&gt;A))
    fire-rules)
</pre></z><z id="t1514394989000362" t="mikerod you’d find no references to A fact instance in working memory at all"><y>#</y><d>2017-12-27</d><h>17:16</h><w>mikerod</w>you’d find no references to <code>A</code> fact instance in working memory at all</z><z id="t1514395015000046" t="mikerod @alex-dixon has done some more interesting things with session inspection I believe. He may have thoughts on this though."><y>#</y><d>2017-12-27</d><h>17:16</h><w>mikerod</w>@alex-dixon has done some more interesting things with session inspection I believe. He may have thoughts on this though.</z><z id="t1514395069000145" t="mikerod On the topic of analyzing all facts inserted or that sort of thing. Then again, for dev only, if you are using the typical type hierarchy you could just do (defquery find-any-fact [] [?f &lt;- Object]) "><y>#</y><d>2017-12-27</d><h>17:17</h><w>mikerod</w>On the topic of analyzing all facts inserted or that sort of thing. Then again, for dev only, if you are using the typical type hierarchy you could just do 
<pre>(defquery find-any-fact []
   [?f &lt;- Object])
</pre></z><z id="t1514395212000212" t="amarjeet yeah, this testing trick works, I tried testing with different types of queries."><y>#</y><d>2017-12-27</d><h>17:20</h><w>amarjeet</w>yeah, this testing trick works, I tried testing with different types of queries.</z><z id="t1514395407000163" t="alex-dixon https://github.com/CoNarrative/precept/blob/master/src/cljc/precept/listeners.cljc"><y>#</y><d>2017-12-27</d><h>17:23</h><w>alex-dixon</w><a href="https://github.com/CoNarrative/precept/blob/master/src/cljc/precept/listeners.cljc" target="_blank">https://github.com/CoNarrative/precept/blob/master/src/cljc/precept/listeners.cljc</a></z><z id="t1514395443000135" t="alex-dixon Example of abusing clara.listeners 😊"><y>#</y><d>2017-12-27</d><h>17:24</h><w>alex-dixon</w>Example of abusing clara.listeners <b>😊</b></z><z id="t1514395782000364" t="alex-dixon It’s a tremendously well designed interface. This is just one implementation. We set up a core async pipeline to process insertions from outside the session (see in precept.core if interested). Each time there’s an insert we add and remove a listener and divide the listener ops into additions and removals"><y>#</y><d>2017-12-27</d><h>17:29</h><w>alex-dixon</w>It’s a tremendously well designed interface. This is just one implementation. We set up a core async pipeline to process insertions from outside the session (see in precept.core if interested). Each time there’s an insert we add and remove a listener and divide the listener ops into additions and removals</z><z id="t1514395880000293" t="alex-dixon From there we apply the ops to an atom that represents “current state”"><y>#</y><d>2017-12-27</d><h>17:31</h><w>alex-dixon</w>From there we apply the ops to an atom that represents “current state”</z><z id="t1514396044000352" t="alex-dixon Part of motivation over a query is that queries become part of the rete network so having one that matches on everything wasn’t performant"><y>#</y><d>2017-12-27</d><h>17:34</h><w>alex-dixon</w>Part of motivation over a query is that queries become part of the rete network so having one that matches on everything wasn’t performant</z><z id="t1514399255000173" t="alex-dixon @amarjeet Just making sure you saw this in case it might be helpful"><y>#</y><d>2017-12-27</d><h>18:27</h><w>alex-dixon</w>@amarjeet Just making sure you saw this in case it might be helpful</z><z id="t1514399331000239" t="amarjeet oh, just saw, gonna look at it"><y>#</y><d>2017-12-27</d><h>18:28</h><w>amarjeet</w>oh, just saw, gonna look at it</z><z id="t1514399342000165" t="amarjeet thanks 🙂"><y>#</y><d>2017-12-27</d><h>18:29</h><w>amarjeet</w>thanks <b>🙂</b></z><z id="t1514566214000134" t="amarjeet @alex-dixon In general, the approach behind precept is interesting. I m gonna dig into it a bit. A few months ago I was thinking about logic-based UIs, using core.logic, before I had explored Clara. I think, understanding precept will help."><y>#</y><d>2017-12-29</d><h>16:50</h><w>amarjeet</w>@alex-dixon In general, the approach behind precept is interesting. I m gonna dig into it a bit. A few months ago I was thinking about logic-based UIs, using core.logic, before I had explored Clara. I think, understanding precept will help.</z><z id="t1514566306000085" t="alex-dixon @amarjeet Awesome. Don’t hesitate to ask any questions you may have I’m happy to answer as best I can. You can DM me or there’s also a #precept channel if you like 🙂"><y>#</y><d>2017-12-29</d><h>16:51</h><w>alex-dixon</w>@amarjeet Awesome. Don’t hesitate to ask any questions you may have I’m happy to answer as best I can. You can DM me or there’s also a #precept channel if you like <b>🙂</b></z><z id="t1514566331000309" t="amarjeet oh, great, will join the precept channel as well"><y>#</y><d>2017-12-29</d><h>16:52</h><w>amarjeet</w>oh, great, will join the precept channel as well</z><z id="t1514921874000561" t="wparker @mikerod @alex-dixon I see that there was some discussion of patterns for updating facts; just a heads up/reminder of the “cancelling” functionality added in https://github.com/cerner/clara-rules/issues/249 and documented at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L38 It doesn’t really solve the hassles of updates though, more of a perf optimization. Also, we haven’t ended using it at Cerner yet due to the work involved in testing, so there could well be problems I missed."><y>#</y><d>2018-01-02</d><h>19:37</h><w>wparker</w>@mikerod @alex-dixon I see that there was some discussion of patterns for updating facts; just a heads up/reminder of the “cancelling” functionality added in <a href="https://github.com/cerner/clara-rules/issues/249" target="_blank">https://github.com/cerner/clara-rules/issues/249</a> and documented at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L38" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L38</a> It doesn’t really solve the hassles of updates though, more of a perf optimization.  Also, we haven’t ended using it at Cerner yet due to the work involved in testing, so there could well be problems I missed.</z><z id="t1514922460000364" t="alex-dixon Thanks for bringing this up again. This is really exciting. I only skimmed 249 but will review it more later. If I’m understanding correctly the modify would increase performance because it would basically be “mutable data structures”. I really, really at the same time don’t like the sounds of that …but if it allows us to easily trade immutability for performance in certain situations then it seems like a great feature"><y>#</y><d>2018-01-02</d><h>19:47</h><r>alex-dixon</r>Thanks for bringing this up again. This is really exciting. I only skimmed 249 but will review it more later. If I’m understanding correctly the modify would increase performance because it would basically be “mutable data structures”. I really, really at the same time don’t like the sounds of that …but if it allows us to easily trade immutability for performance in certain situations then it seems like a great feature</z><z id="t1514922589000178" t="wparker The mutability is purely internal to Clara, not user-facing. Or at least if it is user-facing that would be a bug. 🙂"><y>#</y><d>2018-01-02</d><h>19:49</h><r>wparker</r>The mutability is purely internal to Clara, not user-facing.  Or at least if it is user-facing that would be a bug. <b>🙂</b></z><z id="t1514922627000133" t="wparker Similar to the way the memory is mutable internally, but that isn’t shown to the user"><y>#</y><d>2018-01-02</d><h>19:50</h><r>wparker</r>Similar to the way the memory is mutable internally, but that isn’t shown to the user</z><z id="t1514922695000028" t="alex-dixon Ah! Ok. I was thinking about a (modify!) which I think was discussed if only briefly"><y>#</y><d>2018-01-02</d><h>19:51</h><r>alex-dixon</r>Ah! Ok. I was thinking about a <code>(modify!)</code> which I think was discussed if only briefly</z><z id="t1514928260000357" t="mikerod @wparker yes, this thing you wrote came to mind and then I realized you actually had parts of it already merged to master. I forgot you didn’t just have it on a branch."><y>#</y><d>2018-01-02</d><h>21:24</h><r>mikerod</r>@wparker yes, this thing you wrote came to mind and then I realized you actually had parts of it already merged to master. I forgot you didn’t just have it on a branch.</z><z id="t1514928276000389" t="mikerod However, it is not the same thing as the update! or modify! proposal I was considering."><y>#</y><d>2018-01-02</d><h>21:24</h><r>mikerod</r>However, it is not the same thing as the <code>update!</code> or <code>modify!</code> proposal I was considering.</z><z id="t1514928309000315" t="mikerod I think there is likely some value for the engine to explicitly “understand” the idea of doing a RHS retract + insert of an entity that logically represents the “same fact”."><y>#</y><d>2018-01-02</d><h>21:25</h><r>mikerod</r>I think there is likely some value for the engine to explicitly “understand” the idea of doing a RHS retract + insert of an entity that logically represents the “same fact”.</z><z id="t1514928357000198" t="mikerod Reasoning is: 1) RHS retract is clunky right now and even worse has some fairly broken behavior with truth maintenance/batched logical insertion etc. 2) Optimizations similar to your “update facts” optimizations posted above here may also be applicable."><y>#</y><d>2018-01-02</d><h>21:25</h><r>mikerod</r>Reasoning is:
1) RHS retract is clunky right now and even worse has some fairly broken behavior with truth maintenance/batched logical insertion etc.
2) Optimizations similar to your “update facts” optimizations posted above here may also be applicable.</z><z id="t1514928397000388" t="mikerod Drools does have some optimization to the path of modifying a fact in place - via some of the property reactive hooks. I think Drools also has an explicit “modify” sort of statement that gives it awareness of a fact in working memory that needs to change."><y>#</y><d>2018-01-02</d><h>21:26</h><r>mikerod</r>Drools does have some optimization to the path of modifying a fact in place - via some of the property reactive hooks. I think Drools also has an explicit “modify” sort of statement that gives it awareness of a fact in working memory that needs to change.</z><z id="t1514928452000312" t="mikerod In our case, we’d not do any in-place mutation of course (structural sharing is good though). I think something like a modify! or, I prefer, update! could be done in a way that was sure to have well defined behavior with the truth maintenance as well as batching behavior of logical inserts etc"><y>#</y><d>2018-01-02</d><h>21:27</h><r>mikerod</r>In our case, we’d not do any in-place mutation of course (structural sharing is good though). I think something like a <code>modify!</code> or, I prefer, <code>update!</code> could be done in a way that was sure to have well defined behavior with the truth maintenance as well as batching behavior of logical inserts etc</z><z id="t1514928520000071" t="mikerod I think the update! scenario is one of prominent use-cases for retract! on the RHS. Although I think there are other reasons to retract, such as “no longer relevant event” scenarios perhaps, so retract! isn’t completely useless still (and needs to get fixed to behave sanely with batched inserts and truth maintenance)."><y>#</y><d>2018-01-02</d><h>21:28</h><r>mikerod</r>I think the <code>update!</code> scenario is one of prominent use-cases for <code>retract!</code> on the RHS.
Although I think there are other reasons to retract, such as “no longer relevant event” scenarios perhaps, so <code>retract!</code> isn’t completely useless still (and needs to get fixed to behave sanely with batched inserts and truth maintenance).</z><z id="t1514929063000148" t="wparker Yeah, I realize there’s some other stuff being discussed. I’ll have to read up on those features in Drools. Re updates and truth maintenance - it isn’t clear to me what sorts of semantics would make sense to manually mess with a logically inserted fact. My intuition there is that manual modification to something that is logically derived doesn’t make sense, since if A implies B, then A should continue to imply B until/unless A changes."><y>#</y><d>2018-01-02</d><h>21:37</h><r>wparker</r>Yeah, I realize there’s some other stuff being discussed.  I’ll have to read up on those features in Drools.  Re updates and truth maintenance - it isn’t clear to me what sorts of semantics would make sense to manually mess with a logically inserted fact.  My intuition there is that manual modification to something that is logically derived doesn’t make sense, since if A implies B, then A should continue to imply B until/unless A changes.</z><z id="t1514929135000013" t="wparker I realize that isn’t the current implementation though - I’ve toyed with changing things so that a RHS retract of a logically inserted fact simply wouldn’t happen in the same way that an external retract of a fact not in the session doesn’t do anything. The fact that it does do something now always seemed like a leaky impl detail/bug to me actually"><y>#</y><d>2018-01-02</d><h>21:38</h><r>wparker</r>I realize that isn’t the current implementation though - I’ve toyed with changing things so that a RHS retract of a logically inserted fact simply wouldn’t happen in the same way that an external retract of a fact not in the session doesn’t do anything.  The fact that it does do something now always seemed like a leaky impl detail/bug to me actually</z><z id="t1514929452000170" t="mikerod I think there is a lot of value to be had in the ability to “update a fact”"><y>#</y><d>2018-01-02</d><h>21:44</h><r>mikerod</r>I think there is a lot of value to be had in the ability to “update a fact”</z><z id="t1514929484000321" t="mikerod Which would require something like a retract/insert at some level conceptually to the rest of the network - something may not be affected by the thing that changed though"><y>#</y><d>2018-01-02</d><h>21:44</h><r>mikerod</r>Which would require something like a retract/insert at some level conceptually to the rest of the network - something may not be affected by the thing that changed though</z><z id="t1514929523000207" t="mikerod and with truth maintenance and all logical inserts (something I think is very valuable), it gets near impossible to actually retract something because you immediately invalidate it against the truth maintenance"><y>#</y><d>2018-01-02</d><h>21:45</h><r>mikerod</r>and with truth maintenance and all logical inserts (something I think is very valuable), it gets near impossible to actually retract something because you immediately invalidate it against the truth maintenance</z><z id="t1514929583000079" t="mikerod I think something liek this: (defrule update-it [?a &lt;- A] =&gt; (update! ?a #(update % :value inc))) "><y>#</y><d>2018-01-02</d><h>21:46</h><r>mikerod</r>I think something liek this:
<pre>(defrule update-it
  [?a &lt;- A]
  =&gt;
  (update! ?a #(update % :value inc)))

</pre></z><z id="t1514929618000064" t="mikerod The truth maintenance should not have an issue with this. and it should propagate and participate in the truth maintenance downstream as expected"><y>#</y><d>2018-01-02</d><h>21:46</h><r>mikerod</r>The truth maintenance should not have an issue with this. and it should propagate and participate in the truth maintenance downstream as expected</z><z id="t1514929624000256" t="mikerod more interesting even"><y>#</y><d>2018-01-02</d><h>21:47</h><r>mikerod</r>more interesting even</z><z id="t1514929650000076" t="mikerod (defrule update-it [?a &lt;- A (= value 10)] =&gt; (update! ?a #(update % :value inc))) Here the update! actually contradicts the LHS condition - I still think that should be ok"><y>#</y><d>2018-01-02</d><h>21:47</h><r>mikerod</r><pre>(defrule update-it
  [?a &lt;- A (= value 10)]
  =&gt;
  (update! ?a #(update % :value inc)))
</pre>
Here the <code>update!</code> actually contradicts the LHS condition - I still think that should be ok</z><z id="t1514929677000137" t="mikerod It should participate in a well-defined way with the truth maintenance is the point."><y>#</y><d>2018-01-02</d><h>21:47</h><r>mikerod</r>It should participate in a well-defined way with the truth maintenance is the point.</z><z id="t1514929716000252" t="mikerod Then there would have to be considertaion of something like: (defrule update-it [?a &lt;- A (= value 10)] =&gt; (update! ?a #(update % :value inc)) (insert! (-&gt;B))) "><y>#</y><d>2018-01-02</d><h>21:48</h><r>mikerod</r>Then there would have to be considertaion of something like:
<pre>(defrule update-it
  [?a &lt;- A (= value 10)]
  =&gt;
  (update! ?a #(update % :value inc))
  (insert! (-&gt;B)))
</pre></z><z id="t1514929758000524" t="mikerod Here you have a new fact that relies on truth maintenance and this rule as it’s “logical support”. It’s a tougher case to consider due to the LHS no longer being true. I’m thinking the token should be constructed in a way taht makes the updated ?a support the new B"><y>#</y><d>2018-01-02</d><h>21:49</h><r>mikerod</r>Here you have a new fact that relies on truth maintenance and this rule as it’s “logical support”. It’s a tougher case to consider due to the LHS no longer being true. I’m thinking the token should be constructed in a way taht makes the updated <code>?a</code> support the new <code>B</code></z><z id="t1514929920000332" t="mikerod I might agree that retraction of a logically derived fact doesn’t make sense. You could always just retract the “root facts” that caused it. I do think that would make sense to be able to be done in the RHS and behave as expected with respect to the batched insertions of other rules in the same activation group though"><y>#</y><d>2018-01-02</d><h>21:52</h><r>mikerod</r>I might agree that retraction of a logically derived fact doesn’t make sense. You could always just retract the “root facts” that caused it. I do think that would make sense to be able to be done in the RHS and behave as expected with respect to the batched insertions of other rules in the same activation group though</z><z id="t1514931603000081" t="wparker By “batched insertions” do you mean the stuff in https://github.com/cerner/clara-rules/issues/229 ?"><y>#</y><d>2018-01-02</d><h>22:20</h><r>wparker</r>By “batched insertions” do you mean the stuff in <a href="https://github.com/cerner/clara-rules/issues/229" target="_blank">https://github.com/cerner/clara-rules/issues/229</a> ?</z><z id="t1514932101000013" t="mikerod yep"><y>#</y><d>2018-01-02</d><h>22:28</h><r>mikerod</r>yep</z><z id="t1514922533000041" t="alex-dixon @wparker Also over the break @mikerod and I discussed short circuiting the evaluation of LHS along with Drools’ “property reactive”"><y>#</y><d>2018-01-02</d><h>19:48</h><w>alex-dixon</w>@wparker Also over the break @mikerod and I discussed short circuiting the evaluation of LHS along with Drools’ “property reactive”</z><z id="t1514929966000290" t="mikerod This one is unrelated a bit to our other thread concerning update! ."><y>#</y><d>2018-01-02</d><h>21:52</h><r>mikerod</r>This one is unrelated a bit to our other thread concerning <code>update!</code>.</z><z id="t1514930003000101" t="mikerod It shouldn’t be too difficult to have Clara do something like “unlinking” conditions from evaluation when required prior conditions haven’t been satisfied yet."><y>#</y><d>2018-01-02</d><h>21:53</h><r>mikerod</r>It shouldn’t be too difficult to have Clara do something like “unlinking” conditions from evaluation when required prior conditions haven’t been satisfied yet.</z><z id="t1514930094000200" t="mikerod A good example of the problem is something like: (defrule do-things [A (= ?id id)] [B (= ?id id) (expensive-constraint x)] =&gt; (insert! (-&gt;C))) Clara will currently do the (expensive-constraint x) when B s are inserted, with no A in working memory at all, even if this condition is only used in this rule"><y>#</y><d>2018-01-02</d><h>21:54</h><r>mikerod</r>A good example of the problem is something like:

<pre>(defrule do-things
  [A (= ?id id)]
  [B (= ?id id) (expensive-constraint x)]
  =&gt;
  (insert! (-&gt;C)))

</pre>
Clara will currently do the <code> (expensive-constraint x)</code> when <code>B</code>s are inserted, with no <code>A</code> in working memory at all, even if this condition is only used in this rule</z><z id="t1514930167000105" t="mikerod You can write rules to avoid it like: (defrule find-things [A (= ?id id)] [?b &lt;- B (= ?id id)] =&gt; (insert! (-&gt;ReadyB ?b))) (defrule do-things [ReadyB (expensive-constraint x)] =&gt; (insert! (-&gt;C))) "><y>#</y><d>2018-01-02</d><h>21:56</h><r>mikerod</r>You can write rules to avoid it like:
<pre>(defrule find-things
  [A (= ?id id)]
  [?b &lt;- B (= ?id id)]
  =&gt;
  (insert! (-&gt;ReadyB ?b)))

(defrule do-things
  [ReadyB (expensive-constraint x)]
  =&gt;
  (insert! (-&gt;C)))
</pre></z><z id="t1514930187000587" t="mikerod However, that is not super obvious and also may not always be so straightforward to correctly split"><y>#</y><d>2018-01-02</d><h>21:56</h><r>mikerod</r>However, that is not super obvious and also may not always be so straightforward to correctly split</z><z id="t1514931778000143" t="wparker If you have ideas on how to implement that in a simple way I’d be interested. 🙂 It seems like it could get complicated though."><y>#</y><d>2018-01-02</d><h>22:22</h><r>wparker</r>If you have ideas on how to implement that in a simple way I’d be interested. <b>🙂</b>  It seems like it could get complicated though.</z><z id="t1514931855000177" t="wparker On a possibly similar note, I’ve toyed with changing the structure where a rule only has one parent before - if there are independent conditions, they don’t inherently need to propagate through each other. That would be a lot of work to change though"><y>#</y><d>2018-01-02</d><h>22:24</h><r>wparker</r>On a possibly similar note, I’ve toyed with changing the structure where a rule only has one parent before - if there are independent conditions, they don’t inherently need to propagate through each other.  That would be a lot of work to change though</z><z id="t1514932192000023" t="mikerod I think the case you are describing is interesting. I’m not sure how great it is to have a rule with unrelated conditions, but I know that idea comes up for doing things like aggregations onto a larger “aggregated fact”"><y>#</y><d>2018-01-02</d><h>22:29</h><r>mikerod</r>I think the case you are describing is interesting. I’m not sure how great it is to have a rule with unrelated conditions, but I know that idea comes up for doing things like aggregations onto a larger “aggregated fact”</z><z id="t1514932204000083" t="mikerod In terms of what I mentioned above, I’m not sure it’d be that difficult"><y>#</y><d>2018-01-02</d><h>22:30</h><r>mikerod</r>In terms of what I mentioned above, I’m not sure it’d be that difficult</z><z id="t1514932219000484" t="mikerod I am at least thinking about it like:"><y>#</y><d>2018-01-02</d><h>22:30</h><r>mikerod</r>I am at least thinking about it like:</z><z id="t1514932233000182" t="mikerod 1) during compilation, track if rule conditions rely on others"><y>#</y><d>2018-01-02</d><h>22:30</h><r>mikerod</r>1) during compilation, track if rule conditions rely on others</z><z id="t1514932272000041" t="mikerod 2) during rule evaluation, avoid testing conditions if their upstream dependencies haven’t yet had any matches. Just batch the facts to test “later”"><y>#</y><d>2018-01-02</d><h>22:31</h><r>mikerod</r>2) during rule evaluation, avoid testing conditions if their upstream dependencies haven’t yet had any matches. Just batch the facts to test “later”</z><z id="t1514932293000290" t="mikerod 3) the batch is “flushed” when the condition is reached via the left activation"><y>#</y><d>2018-01-02</d><h>22:31</h><r>mikerod</r>3) the batch is “flushed” when the condition is reached via the left activation</z><z id="t1514932311000482" t="mikerod Negation nodes sort of work by batching fact evaluation already"><y>#</y><d>2018-01-02</d><h>22:31</h><r>mikerod</r>Negation nodes sort of work by batching fact evaluation already</z><z id="t1514932331000215" t="mikerod I think it may not be too terribly difficult at least. Of course I haven’t tried at all yet 😛"><y>#</y><d>2018-01-02</d><h>22:32</h><r>mikerod</r>I think it may not be too terribly difficult at least. Of course I haven’t tried at all yet <b>😛</b></z><z id="t1514932235000210" t="tcarls Hmm -- the railroad diagram link in https://github.com/cerner/clara-rules/wiki/guide appears to be broken."><y>#</y><d>2018-01-02</d><h>22:30</h><w>tcarls</w>Hmm -- the railroad diagram link in <a href="https://github.com/cerner/clara-rules/wiki/guide" target="_blank">https://github.com/cerner/clara-rules/wiki/guide</a> appears to be broken.</z><z id="t1514932894000423" t="ryanbrush @tcarls Thanks. All of that content now lives over on the web site at http://www.clara-rules.org/docs/rules/ , so we need to delete/redirect those wiki pages."><y>#</y><d>2018-01-02</d><h>22:41</h><w>ryanbrush</w>@tcarls Thanks. All of that content now lives over on the web site at <a href="http://www.clara-rules.org/docs/rules/" target="_blank">http://www.clara-rules.org/docs/rules/</a>, so we need to delete/redirect those wiki pages.</z><z id="t1515032765000260" t="cfleming I have some questions about the fact-expr grammar over here: https://github.com/cursive-ide/clara-specs/issues/4"><y>#</y><d>2018-01-04</d><h>02:26</h><w>cfleming</w>I have some questions about the fact-expr grammar over here: <a href="https://github.com/cursive-ide/clara-specs/issues/4" target="_blank">https://github.com/cursive-ide/clara-specs/issues/4</a></z><z id="t1515032889000130" t="cfleming Actually, looking at the schema I see that FactCondition :type is s/Any , bummer."><y>#</y><d>2018-01-04</d><h>02:28</h><w>cfleming</w>Actually, looking at the schema I see that <code>FactCondition :type</code> is <code>s/Any</code>, bummer.</z><z id="t1515070487000047" t="mikerod @cfleming Yeah, I can see where that is difficult and yes the “fact type” being anything makes things complicated"><y>#</y><d>2018-01-04</d><h>12:54</h><w>mikerod</w>@cfleming Yeah, I can see where that is difficult and yes the “fact type” being anything makes things complicated</z><z id="t1515070546000387" t="mikerod I’m pretty sure you can break Clara parsing if you try to use a fact type that seems too much like something else."><y>#</y><d>2018-01-04</d><h>12:55</h><w>mikerod</w>I’m pretty sure you can break Clara parsing if you try to use a fact type that seems too much like something else.</z><z id="t1515070574000476" t="mikerod One thing that is interesting and probably should be part of the spec (I don’t believe it is now), is that variable bindings should always start with “?”"><y>#</y><d>2018-01-04</d><h>12:56</h><w>mikerod</w>One thing that is interesting and probably should be part of the spec (I don’t believe it is now), is that variable bindings should always start with “?”</z><z id="t1515070594000399" t="mikerod So in the case of the fact binding, it is the ::variable-binding from that PR"><y>#</y><d>2018-01-04</d><h>12:56</h><w>mikerod</w>So in the case of the fact binding, it is the <code>::variable-binding</code> from that PR</z><z id="t1515070634000229" t="mikerod And perhaps we should just list a few things that a fact type should not be, like it shouldn’t be a symbol that starts with a “?”"><y>#</y><d>2018-01-04</d><h>12:57</h><w>mikerod</w>And perhaps we should just list a few things that a fact type should not be, like it shouldn’t be a symbol that starts with a “?”</z><z id="t1515070664000210" t="mikerod I think it may not be ok for it to be a vector either. I seem to recall a bad parse example from long back where a fact type as a vector would mess up things."><y>#</y><d>2018-01-04</d><h>12:57</h><w>mikerod</w>I think it may not be ok for it to be a vector either. I seem to recall a bad parse example from long back where a fact type as a vector would mess up things.</z><z id="t1515072354000015" t="tcarls Are there suggested patterns for rules that can require potentially-expensive lookups? If I have a rule that depends on content that could be retrieved from an API call / database hit / etc., is there a way to trigger that retrieval (and insert any facts it results in) only when the rule&apos;s other conditions are satisfied?"><y>#</y><d>2018-01-04</d><h>13:25</h><w>tcarls</w>Are there suggested patterns for rules that can require potentially-expensive lookups? If I have a rule that depends on content that could be retrieved from an API call / database hit / etc., is there a way to trigger that retrieval (and insert any facts it results in) only when the rule&apos;s other conditions are satisfied?</z><z id="t1515072722000324" t="mikerod @tcarls that’s funny you bring that up since this topic came up fairly recently here"><y>#</y><d>2018-01-04</d><h>13:32</h><w>mikerod</w>@tcarls that’s funny you bring that up since this topic came up fairly recently here</z><z id="t1515072748000133" t="mikerod In short: I think in the future Clara could do better to avoid doing work when required previous conditions aren’t yet satisfied."><y>#</y><d>2018-01-04</d><h>13:32</h><w>mikerod</w>In short: I think in the future Clara could do better to avoid doing work when required previous conditions aren’t yet satisfied.</z><z id="t1515072753000254" t="mikerod However, there is a workaround pattern:"><y>#</y><d>2018-01-04</d><h>13:32</h><w>mikerod</w>However, there is a workaround pattern:</z><z id="t1515072880000374" t="mikerod ;; Say you have this: (defrule original [A (= ?id id)] [B (= ?id id) (do-expensive-thing x)] =&gt; (insert (-&gt;C))) It can be transformed to this: (defrule part-1 [A (= ?id id)] [?b &lt;- B (= ?id id)] =&gt; (insert (-&gt;MatchedB ?b))) (defrule part-2 [MatchedB (do-expensive-thing x)] =&gt; (insert (-&gt;C))) "><y>#</y><d>2018-01-04</d><h>13:34</h><w>mikerod</w><pre>;; Say you have this:
(defrule original
  [A (= ?id id)]
  [B (= ?id id) (do-expensive-thing x)]
  =&gt;
  (insert (-&gt;C)))


It can be transformed to this:
(defrule part-1
  [A (= ?id id)]
  [?b &lt;- B (= ?id id)]
  =&gt;
  (insert (-&gt;MatchedB ?b)))

(defrule part-2
  [MatchedB (do-expensive-thing x)]
  =&gt;
  (insert (-&gt;C)))
</pre></z><z id="t1515073104000208" t="mikerod If you are in a situation where there may be some thrash of insert/retracts of A and B (from example) due to the truth maintenance of the network, then you can also consider adding either :salience or setup “activation groups” for rules like part-2 . However, I’d only do that if there is actually a situation where it could be an issue."><y>#</y><d>2018-01-04</d><h>13:38</h><w>mikerod</w>If you are in a situation where there may be some thrash of insert/retracts of <code>A</code> and <code>B</code> (from example) due to the truth maintenance of the network, then you can also consider adding either <code>:salience</code> or setup “activation groups” for rules like <code>part-2</code>. However, I’d only do that if there is actually a situation where it could be an issue.</z><z id="t1515073808000470" t="tcarls Thank you -- that&apos;s useful advice."><y>#</y><d>2018-01-04</d><h>13:50</h><w>tcarls</w>Thank you -- that&apos;s useful advice.</z><z id="t1515074111000010" t="mikerod Some details on salience and activations groups is written here: http://www.clara-rules.org/docs/conflictsalience/ If you end up needing it. However, like I said, avoid it if unnecessary. It is additional complexity to deal with."><y>#</y><d>2018-01-04</d><h>13:55</h><w>mikerod</w>Some details on salience and activations groups is written here: <a href="http://www.clara-rules.org/docs/conflictsalience/" target="_blank">http://www.clara-rules.org/docs/conflictsalience/</a> 
If you end up needing it. However, like I said, avoid it if unnecessary. It is additional complexity to deal with.</z><z id="t1515104549000192" t="sparkofreason Is there a way to establish a conditional relationship between facts outside of a rule RHS? The case I&apos;m thinking of is something like an article app, where articles have comments. Selecting an article makes it &quot;active&quot;, and also triggers a request to fetch comments from the server. When the async request completes, comments will be inserted. It would be slick if retracting the active article fact also automagically retracted the inserted comments, but since the response handler for the comments request executes outside of a rule context, I don&apos;t see an obvious way to enforce that logical connection."><y>#</y><d>2018-01-04</d><h>22:22</h><w>sparkofreason</w>Is there a way to establish a conditional relationship between facts outside of a rule RHS? The case I&apos;m thinking of is something like an article app, where articles have comments. Selecting an article makes it &quot;active&quot;, and also triggers a request to fetch comments from the server. When the async request completes, comments will be inserted. It would be slick if retracting the active article fact also automagically retracted the inserted comments, but since the response handler for the comments request executes outside of a rule context, I don&apos;t see an obvious way to enforce that logical connection.</z><z id="t1515106103000441" t="zylox You could write something fairly easily to &quot;deactivate&quot; them (by joining the comment fact to the article and inserting an ActiveComment or something) but that wouldnt retract the base comment fact which could lead to build up over time. I don&apos;t know of any way to do what you are talking about without an external handler atm"><y>#</y><d>2018-01-04</d><h>22:48</h><w>zylox</w>You could write something fairly easily to &quot;deactivate&quot; them (by joining the comment fact to the article and inserting an ActiveComment or something) but that wouldnt retract the base comment fact which could lead to build up over time. I don&apos;t know of any way to do what you are talking about without an external handler atm</z><z id="t1515106238000106" t="zylox they would have to come in on the same data object into the session which doesnt match the timeline you describe"><y>#</y><d>2018-01-04</d><h>22:50</h><w>zylox</w>they would have to come in on the same data object into the session which doesnt match the timeline you describe</z><z id="t1515164253000437" t="mikerod @dave.dixon I think that works. The only caveat is just that there are a few outstanding issues with RHS retract! . There are some edge cases with how they may work with logical insertions. I think it doesn’t typically come up. https://github.com/cerner/clara-rules/issues/229 https://github.com/cerner/clara-rules/issues/321 I mention both in http://www.metasimple.org/2017/12/23/clara-updating-facts.html"><y>#</y><d>2018-01-05</d><h>14:57</h><w>mikerod</w>@dave.dixon I think that works. The only caveat is just that there are a few outstanding issues with RHS <code>retract!</code>.  There are some edge cases with how they may work with logical insertions. I think it doesn’t typically come up.
<a href="https://github.com/cerner/clara-rules/issues/229" target="_blank">https://github.com/cerner/clara-rules/issues/229</a>
<a href="https://github.com/cerner/clara-rules/issues/321" target="_blank">https://github.com/cerner/clara-rules/issues/321</a>

I mention both in <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a></z><z id="t1515164484000279" t="mikerod Other than that though, the rules above seem reasonable. That is something I’d expect should work. To the point @zylox made: It looks like you do have some sort of external retract that is removing the ActiveArticle in your example."><y>#</y><d>2018-01-05</d><h>15:01</h><w>mikerod</w>Other than that though, the rules above seem reasonable. That is something I’d expect should work. To the point @zylox made: It looks like you do have some sort of external retract that is removing the <code>ActiveArticle</code> in your example.</z><z id="t1515164628000064" t="zylox Ya, i was approaching it from the perspective of using truth maintenance for it because of the &quot;outside of a rule RHS?&quot;. glad you found something that works for you."><y>#</y><d>2018-01-05</d><h>15:03</h><w>zylox</w>Ya, i was approaching it from the perspective of using truth maintenance for it because of the &quot;outside of a rule RHS?&quot;. glad you found something that works for you.</z><z id="t1515164725000520" t="sparkofreason Yes, ActiveArticle is removed externally. It does work nicely."><y>#</y><d>2018-01-05</d><h>15:05</h><w>sparkofreason</w>Yes, <code>ActiveArticle</code> is removed externally. It does work nicely.</z><z id="t1515165331000504" t="sparkofreason ::handle-cancelled-response is arguably just &quot;nice to have&quot;, catches the case of ActiveArticle changing before the response to the comments request is received. If one ran into the edge-cases around retract! I think you could just have some sort of periodic clean-up of dangling CommentsResponse facts."><y>#</y><d>2018-01-05</d><h>15:15</h><w>sparkofreason</w><code>::handle-cancelled-response</code> is arguably just &quot;nice to have&quot;, catches the case of <code>ActiveArticle</code> changing before the response to the comments request is received. If one ran into the edge-cases around <code>retract!</code> I think you could just have some sort of periodic clean-up of dangling <code>CommentsResponse</code> facts.</z><z id="t1515165564000761" t="mikerod I like it overall. I really would like to try to get the edge cases of retract! removed. The issue it has is mostly how it interacts with the truth maintenance of other rules that are firing in the same “cycle”"><y>#</y><d>2018-01-05</d><h>15:19</h><w>mikerod</w>I like it overall. I really would like to try to get the edge cases of <code>retract!</code> removed. The issue it has is mostly how it interacts with the truth maintenance of other rules that are firing in the same “cycle”</z><z id="t1515165619000461" t="mikerod The removal of the CommentsResponse cleans up all the Comment due to truth maintenance, which is nice."><y>#</y><d>2018-01-05</d><h>15:20</h><w>mikerod</w>The removal of the <code>CommentsResponse</code> cleans up all the <code>Comment</code> due to truth maintenance, which is nice.</z><z id="t1515165643000418" t="mikerod Oh, I guess the ActiveArticle does too - woops. But either way, it is nice to be able to cleanup old facts liek that"><y>#</y><d>2018-01-05</d><h>15:20</h><w>mikerod</w>Oh, I guess the <code>ActiveArticle</code> does too - woops. But either way, it is nice to be able to cleanup old facts liek that</z><z id="t1515253446000028" t="alex-dixon May not have had enough coffee yet but….how do I do something like this without getting an unbound variable error? [SomeFact (= a ?a) (= b ?b)] [:not [:and [Fact1 (= e ?e) (= a ?a)] [Fact2 (= e ?e) (= b ?b]]] "><y>#</y><d>2018-01-06</d><h>15:44</h><w>alex-dixon</w>May not have had enough coffee yet but….how do I do something like this without getting an unbound variable error? 
<pre>[SomeFact (= a ?a) (= b ?b)]
[:not [:and [Fact1 (= e ?e) (= a ?a)]
                   [Fact2 (= e ?e) (= b ?b]]] 
</pre></z><z id="t1515258407000128" t="mikerod @alex-dixon I am not sure if @wparker has an issue logged on this subject but odd things can happen sometime in rule compilation due to how Clara compiler converts these Boolean conditions to disjunctive normal form. DNF"><y>#</y><d>2018-01-06</d><h>17:06</h><w>mikerod</w>@alex-dixon I am not sure if @wparker has an issue logged on this subject but odd things can happen sometime in rule compilation due to how Clara compiler converts these Boolean conditions to disjunctive normal form. DNF</z><z id="t1515258445000023" t="mikerod So the conditions in the :and are being split by an :or. "><y>#</y><d>2018-01-06</d><h>17:07</h><w>mikerod</w>So the conditions in the :and are being split by an :or. </z><z id="t1515258726000040" t="mikerod I need to look a bit though. Thought the case above was covered. "><y>#</y><d>2018-01-06</d><h>17:12</h><w>mikerod</w>I need to look a bit though. Thought the case above was covered. </z><z id="t1515258752000005" t="mikerod Basic negated conjunctions should be supported. "><y>#</y><d>2018-01-06</d><h>17:12</h><w>mikerod</w>Basic negated conjunctions should be supported. </z><z id="t1515258840000155" t="alex-dixon Hm ok"><y>#</y><d>2018-01-06</d><h>17:14</h><w>alex-dixon</w>Hm ok</z><z id="t1515258858000059" t="alex-dixon By the way is [:not {:exists valid in any way?"><y>#</y><d>2018-01-06</d><h>17:14</h><w>alex-dixon</w>By the way is [:not {:exists valid in any way?</z><z id="t1515258998000134" t="alex-dixon @mikerod or is that just equivalent to [:not .. ] ?"><y>#</y><d>2018-01-06</d><h>17:16</h><w>alex-dixon</w>@mikerod or is that just equivalent to [:not .. ] ?</z><z id="t1515259349000167" t="mikerod Should mean the same thing. "><y>#</y><d>2018-01-06</d><h>17:22</h><w>mikerod</w>Should mean the same thing. </z><z id="t1515259358000063" t="mikerod Not sure if it works out that way though. Hah"><y>#</y><d>2018-01-06</d><h>17:22</h><w>mikerod</w>Not sure if it works out that way though. Hah</z><z id="t1515259362000005" t="mikerod I’d avoid it. "><y>#</y><d>2018-01-06</d><h>17:22</h><w>mikerod</w>I’d avoid it. </z><z id="t1515259410000073" t="mikerod Some of the negation transformation stuff probably could be improved. I think Will had thoughts on that. I thought he logged an issue. I want to look at what is compiled in your example about to see why you’d have an inbound variable issue "><y>#</y><d>2018-01-06</d><h>17:23</h><w>mikerod</w>Some of the negation transformation stuff probably could be improved. I think Will had thoughts on that. I thought he logged an issue. I want to look at what is compiled in your example about to see why you’d have an inbound variable issue </z><z id="t1515259423000023" t="mikerod I am not on laptop now. Will be in a few. "><y>#</y><d>2018-01-06</d><h>17:23</h><w>mikerod</w>I am not on laptop now. Will be in a few. </z><z id="t1515259438000015" t="mikerod (I don’t run Clara repl experiments on my phone unfortunately)"><y>#</y><d>2018-01-06</d><h>17:23</h><w>mikerod</w>(I don’t run Clara repl experiments on my phone unfortunately)</z><z id="t1515263876000035" t="alex-dixon Ok. Started working on spec stuff. Equally stuck there so let me know lol"><y>#</y><d>2018-01-06</d><h>18:37</h><w>alex-dixon</w>Ok. Started working on spec stuff. Equally stuck there so let me know lol</z><z id="t1515275984000023" t="mikerod @alex-dixon See https://github.com/cerner/clara-rules/issues/347"><y>#</y><d>2018-01-06</d><h>21:59</h><w>mikerod</w>@alex-dixon See <a href="https://github.com/cerner/clara-rules/issues/347" target="_blank">https://github.com/cerner/clara-rules/issues/347</a></z><z id="t1515275995000001" t="alex-dixon Was just looking at it hah"><y>#</y><d>2018-01-06</d><h>21:59</h><w>alex-dixon</w>Was just looking at it hah</z><z id="t1515276042000027" t="mikerod There are severael issues here. The work that was done before only worked in a fairly small set of situations"><y>#</y><d>2018-01-06</d><h>22:00</h><w>mikerod</w>There are severael issues here. The work that was done before only worked in a fairly small set of situations</z><z id="t1515276042000099" t="alex-dixon So that’s identical"><y>#</y><d>2018-01-06</d><h>22:00</h><w>alex-dixon</w>So that’s identical</z><z id="t1515276060000036" t="mikerod if you can, the workaround is to just move out the conjunction to a different rule I believe"><y>#</y><d>2018-01-06</d><h>22:01</h><w>mikerod</w>if you can, the workaround is to just move out the conjunction to a different rule I believe</z><z id="t1515276092000113" t="alex-dixon Ok. Let me unwind my attempts that aren’t working and attempt that"><y>#</y><d>2018-01-06</d><h>22:01</h><w>alex-dixon</w>Ok. Let me unwind my attempts that aren’t working and attempt that</z><z id="t1515276124000021" t="mikerod (defrule r1 [Fact1 (= e ?e) (= a ?a)] [Fact2 (= e ?e) (= b ?b)] =&gt; (insert! (-&gt;Fact3 ?e ?a ?b))) (defrule r2 [SomeFact (= a ?a) (= b ?b)] [:not [Fact3 (= a ?a) (= b ?b)]] =&gt; (prn {:a ?a :b ?b :e ?e})) "><y>#</y><d>2018-01-06</d><h>22:02</h><w>mikerod</w><pre>(defrule r1
  
   [Fact1 (= e ?e) (= a ?a)]
   [Fact2 (= e ?e) (= b ?b)]
  =&gt;
  (insert! (-&gt;Fact3 ?e ?a ?b)))


(defrule r2
  [SomeFact (= a ?a) (= b ?b)]
  [:not [Fact3 (= a ?a) (= b ?b)]]
  =&gt;
  (prn {:a ?a
        :b ?b
        :e ?e}))
</pre></z><z id="t1515276136000041" t="mikerod I believe that is the extraction"><y>#</y><d>2018-01-06</d><h>22:02</h><w>mikerod</w>I believe that is the extraction</z><z id="t1515276180000053" t="mikerod That would pair all Fact1 and Fact2 facts together in the r1 join to make the Fact3 facts"><y>#</y><d>2018-01-06</d><h>22:03</h><w>mikerod</w>That would pair all <code>Fact1</code> and <code>Fact2</code> facts together in the <code>r1</code> join to make the <code>Fact3</code> facts</z><z id="t1515276203000009" t="mikerod Then r2 would be looking for the non-existence of any of those join results to match the same a and b of a SomeFact fact"><y>#</y><d>2018-01-06</d><h>22:03</h><w>mikerod</w>Then <code>r2</code> would be looking for the non-existence of any of those join results to match the same <code>a</code> and <code>b</code> of a <code>SomeFact</code> fact</z><z id="t1515276285000058" t="alex-dixon Just to clarify my understanding is the :and necessary in r1?"><y>#</y><d>2018-01-06</d><h>22:04</h><w>alex-dixon</w>Just to clarify my understanding is the :and necessary in r1?</z><z id="t1515276838000046" t="mikerod @alex-dixon no, sorry"><y>#</y><d>2018-01-06</d><h>22:13</h><w>mikerod</w>@alex-dixon no, sorry</z><z id="t1515276850000104" t="mikerod I just quickly extracted it and forgot I had the :and there still"><y>#</y><d>2018-01-06</d><h>22:14</h><w>mikerod</w>I just quickly extracted it and forgot I had the <code>:and</code> there still</z><z id="t1515276856000054" t="mikerod I’d leave it out 😛"><y>#</y><d>2018-01-06</d><h>22:14</h><w>mikerod</w>I’d leave it out <b>😛</b></z><z id="t1515276871000059" t="mikerod edited to avoid more confusion"><y>#</y><d>2018-01-06</d><h>22:14</h><w>mikerod</w>edited to avoid more confusion</z><z id="t1515276910000091" t="alex-dixon Will try asap. Had to take a break "><y>#</y><d>2018-01-06</d><h>22:15</h><w>alex-dixon</w>Will try asap. Had to take a break </z><z id="t1515276925000006" t="alex-dixon Thanks for your responses"><y>#</y><d>2018-01-06</d><h>22:15</h><w>alex-dixon</w>Thanks for your responses</z><z id="t1515277025000048" t="mikerod No problem. That is unfortunate that there are still several caveats to nesting conditions within negation"><y>#</y><d>2018-01-06</d><h>22:17</h><w>mikerod</w>No problem. That is unfortunate that there are still several caveats to nesting conditions within negation</z><z id="t1515277074000053" t="mikerod A lot of the time it can be solved by just pulling everything complex out of the :not and put it into a different rule where an “bridge”/intermediate fact is used to communicate the logic across the rules"><y>#</y><d>2018-01-06</d><h>22:17</h><w>mikerod</w>A lot of the time it can be solved by just pulling everything complex out of the <code>:not</code> and put it into a different rule where an “bridge”/intermediate fact is used to communicate the logic across the rules</z><z id="t1515277135000022" t="mikerod I read through some of the outstanding issues on negation. However, I thought that I remember Will mentioning that he maybe had a few more broad concerns with the current way of dealing with them"><y>#</y><d>2018-01-06</d><h>22:18</h><w>mikerod</w>I read through some of the outstanding issues on negation. However, I thought that I remember Will mentioning that he maybe had a few more broad concerns with the current way of dealing with them</z><z id="t1515277156000065" t="mikerod Basically, the currently process is to extract rules out from within the :not transparently"><y>#</y><d>2018-01-06</d><h>22:19</h><w>mikerod</w>Basically, the currently process is to extract rules out from within the <code>:not</code> transparently</z><z id="t1515277170000063" t="mikerod In a way that is similar to what I proposed that you do in the above."><y>#</y><d>2018-01-06</d><h>22:19</h><w>mikerod</w>In a way that is similar to what I proposed that you do in the above.</z><z id="t1515277261000088" t="mikerod I’m surprised that https://github.com/cerner/clara-rules/issues/347 is still an issue though. I think the fix for it to me seems to be very similar to the work that was done in https://github.com/cerner/clara-rules/pull/342 If so, I think that one would be pretty easy to fix."><y>#</y><d>2018-01-06</d><h>22:21</h><w>mikerod</w>I’m surprised that <a href="https://github.com/cerner/clara-rules/issues/347" target="_blank">https://github.com/cerner/clara-rules/issues/347</a> is still an issue though. I think the fix for it to me seems to be very similar to the work that was done in <a href="https://github.com/cerner/clara-rules/pull/342" target="_blank">https://github.com/cerner/clara-rules/pull/342</a>
If so, I think that one would be pretty easy to fix.</z><z id="t1515371562000003" t="cfleming In the docs, there’s an example rule: (defrule get-windspeeds-from-location [?temp &lt;- [Temperature (= ?location location)]] [?wind &lt;- (acc/all) :from [WindSpeed (= ?location location)]] =&gt; ;; do something ) "><y>#</y><d>2018-01-08</d><h>00:32</h><w>cfleming</w>In the docs, there’s an example rule:
<pre>(defrule get-windspeeds-from-location
  [?temp &lt;- [Temperature (= ?location location)]]
  [?wind &lt;- (acc/all) :from [WindSpeed (= ?location location)]]
  =&gt;
  ;; do something
)
</pre></z><z id="t1515371602000117" t="cfleming Am I correct in thinking that the first condition should actually be [?temp &lt;- Temperature (= ?location location)] , i.e. with no nested vectors?"><y>#</y><d>2018-01-08</d><h>00:33</h><w>cfleming</w>Am I correct in thinking that the first condition should actually be <code>[?temp &lt;- Temperature (= ?location location)]</code>, i.e. with no nested vectors?</z><z id="t1515372293000111" t="alex-dixon It can be either insofar as I know"><y>#</y><d>2018-01-08</d><h>00:44</h><w>alex-dixon</w>It can be either insofar as I know</z><z id="t1515372398000084" t="alex-dixon @cfleming I have some changes that I’m not totally happy with that try to accommodate that"><y>#</y><d>2018-01-08</d><h>00:46</h><w>alex-dixon</w>@cfleming I have some changes that I’m not totally happy with that try to accommodate that</z><z id="t1515373905000070" t="alex-dixon Oops. Looks like that would entail an “extraneous vcector error”"><y>#</y><d>2018-01-08</d><h>01:11</h><w>alex-dixon</w>Oops. Looks like that would entail an “extraneous vcector error”</z><z id="t1515373907000155" t="mikerod @alex-dixon @cfleming I think the first condition of that rule is incorrect"><y>#</y><d>2018-01-08</d><h>01:11</h><w>mikerod</w>@alex-dixon @cfleming I think the first condition of that rule is incorrect</z><z id="t1515373955000003" t="mikerod There shouldn’t be a vector around Temperature in the non-accumulator case. What @cfleming said is right on that one. "><y>#</y><d>2018-01-08</d><h>01:12</h><w>mikerod</w>There shouldn’t be a vector around Temperature in the non-accumulator case. What @cfleming said is right on that one. </z><z id="t1515373970000072" t="mikerod If Clara accepts it. I think it would be with the wrong semantics. "><y>#</y><d>2018-01-08</d><h>01:12</h><w>mikerod</w>If Clara accepts it. I think it would be with the wrong semantics. </z><z id="t1515373974000045" t="cfleming Great, thanks Mike"><y>#</y><d>2018-01-08</d><h>01:12</h><w>cfleming</w>Great, thanks Mike</z><z id="t1515373980000065" t="alex-dixon [?order &lt;- [WorkOrder (= ?clientid clientid) (= scale :big) (&lt; (days-between requestdate duedate) 14)]] =&gt; CompilerException clojure.lang.ExceptionInfo: Type [WorkOrder (= ?clientid clientid) (= scale :big) (&lt; (days-between requestdate duedate) 14)] is a vector and appears to contain expressions. Is there an extraneous set of brackets in the condition? "><y>#</y><d>2018-01-08</d><h>01:13</h><w>alex-dixon</w><pre>[?order &lt;- [WorkOrder (= ?clientid clientid)
              (= scale :big)
              (&lt; (days-between requestdate duedate) 14)]]
=&gt;
CompilerException clojure.lang.ExceptionInfo: Type [WorkOrder (= ?clientid clientid) (= scale :big) (&lt; (days-between requestdate duedate) 14)] is a vector and appears to contain expressions. Is there an extraneous set of brackets in the condition? 
</pre></z><z id="t1515374015000030" t="mikerod It’d consider the whole thing to be the “fact type”. Which is related to the issue of ambiguity of syntax when you allow any arbitrary structure for a fact type. We discussed this on some issue recently"><y>#</y><d>2018-01-08</d><h>01:13</h><w>mikerod</w>It’d consider the whole thing to be the “fact type”. Which is related to the issue of ambiguity of syntax when you allow any arbitrary structure for a fact type. We discussed this on some issue recently</z><z id="t1515374023000127" t="cfleming As the unofficial ranter about macro error messages, that’s a very nice message indeed."><y>#</y><d>2018-01-08</d><h>01:13</h><w>cfleming</w>As the unofficial ranter about macro error messages, that’s a very nice message indeed.</z><z id="t1515374055000076" t="mikerod Oh nice. Yeah I guess that case was special cased. Due to it being fairly easy to mistakenly do"><y>#</y><d>2018-01-08</d><h>01:14</h><w>mikerod</w>Oh nice. Yeah I guess that case was special cased. Due to it being fairly easy to mistakenly do</z><z id="t1515426702000153" t="wparker @mikerod I haven’t gotten around to doing a comprehensive writeup, but basically I was looking at how to address https://github.com/cerner/clara-rules/issues/343 and ran into what I think are some issues with to-dnf. Basically since the :or operation is actually more of a union in the set theory sense, I think the to-dnf transforms can end up messing with cardinality. For example, [:not [:and A B]] is equivalent to [:or [:not A] [:not B]] in a boolean sense, but the second can match twice and the first can’t in the context of Clara."><y>#</y><d>2018-01-08</d><h>15:51</h><w>wparker</w>@mikerod I haven’t gotten around to doing a comprehensive writeup, but basically I was looking at how to address <a href="https://github.com/cerner/clara-rules/issues/343" target="_blank">https://github.com/cerner/clara-rules/issues/343</a> and ran into what I think are some issues with to-dnf.  Basically since the :or operation is actually more of a union in the set theory sense, I think the to-dnf transforms can end up messing with cardinality.  For example, [:not [:and A B]] is equivalent to [:or [:not A] [:not B]] in a boolean sense, but the second can match twice and the first can’t in the context of Clara.</z><z id="t1515427977000174" t="mikerod @wparker thanks. I remember the topic better now."><y>#</y><d>2018-01-08</d><h>16:12</h><w>mikerod</w>@wparker thanks. I remember the topic better now.</z><z id="t1515462534000204" t="cfleming In the example query: (defquery get-promotions &quot;Query to find promotions for the purchase.&quot; [:?type] [?promotion &lt;- Promotion (= ?type type)]) "><y>#</y><d>2018-01-09</d><h>01:48</h><w>cfleming</w>In the example query:
<pre>(defquery get-promotions
  &quot;Query to find promotions for the purchase.&quot;
  [:?type]
  [?promotion &lt;- Promotion (= ?type type)])
</pre></z><z id="t1515462578000048" t="cfleming Does the parameter :?type create a unification variable? i.e. are the param and the local variable ?type then the same thing?"><y>#</y><d>2018-01-09</d><h>01:49</h><w>cfleming</w>Does the parameter <code>:?type</code> create a unification variable? i.e. are the param and the local variable <code>?type</code> then the same thing?</z><z id="t1515462590000321" t="cfleming I’m not sure I’m explaining that correctly."><y>#</y><d>2018-01-09</d><h>01:49</h><w>cfleming</w>I’m not sure I’m explaining that correctly.</z><z id="t1515467912000076" t="mikerod @cfleming the keyword arg allows the caller to bind a value to the variable. The same variable name as a symbol then should appear somewhere in the query conditions. "><y>#</y><d>2018-01-09</d><h>03:18</h><w>mikerod</w>@cfleming the keyword arg allows the caller to bind a value to the variable. The same variable name as a symbol then should appear somewhere in the query conditions. </z><z id="t1515467921000091" t="mikerod So I think that is what you were saying. "><y>#</y><d>2018-01-09</d><h>03:18</h><w>mikerod</w>So I think that is what you were saying. </z><z id="t1515491732000125" t="cfleming @mikerod Thanks, that’s what I meant, yes."><y>#</y><d>2018-01-09</d><h>09:55</h><w>cfleming</w>@mikerod Thanks, that’s what I meant, yes.</z><z id="t1515509318000748" t="wparker Put differently: looking at the example in http://www.clara-rules.org/docs/queries/ if you removed the :?type from the get-promotions query definition you wouldn’t have “:?type :lunch” in the arguments in this call: (query session get-promotions :?type :lunch) @cfleming"><y>#</y><d>2018-01-09</d><h>14:48</h><w>wparker</w>Put differently: looking at the example in <a href="http://www.clara-rules.org/docs/queries/" target="_blank">http://www.clara-rules.org/docs/queries/</a>  if you removed the :?type from the get-promotions query definition you wouldn’t have “:?type :lunch” in the arguments in this call: (query session get-promotions :?type :lunch) @cfleming</z><z id="t1515526273000002" t="wparker Clara-rules 0.17.0 is released and on Clojars. This release is most significant for ClojureScript users, both because of a ClojureScript-specific bugfix and some enhancements with more impact to the ClojureScript side, but there are some enhancements for Clojure as well. See the changelog for details. Thanks to @dave.dixon and @alex-dixon for their contributions to the release."><y>#</y><d>2018-01-09</d><h>19:31</h><w>wparker</w>Clara-rules 0.17.0 is released and on Clojars.  This release is most significant for ClojureScript users, both because of a ClojureScript-specific bugfix and some enhancements with more impact to the ClojureScript side, but there are some enhancements for Clojure as well.  See the changelog for details.  Thanks to @dave.dixon and @alex-dixon for their contributions to the release.</z><z id="t1515535751000190" t="zylox are the dixon&apos;s related"><y>#</y><d>2018-01-09</d><h>22:09</h><w>zylox</w>are the dixon&apos;s related</z><z id="t1515535756000112" t="zylox a question for the ages"><y>#</y><d>2018-01-09</d><h>22:09</h><w>zylox</w>a question for the ages</z><z id="t1515594374000226" t="sparkofreason Not to my knowledge. But we do seem to think alike 😉"><y>#</y><d>2018-01-10</d><h>14:26</h><w>sparkofreason</w>Not to my knowledge. But we do seem to think alike <b>😉</b></z><z id="t1515715683000086" t="alex-dixon High praise"><y>#</y><d>2018-01-12</d><h>00:08</h><r>alex-dixon</r>High praise</z><z id="t1515594554000063" t="zylox darn"><y>#</y><d>2018-01-10</d><h>14:29</h><w>zylox</w>darn</z><z id="t1515715874000159" t="alex-dixon Do any changes proposed in https://github.com/cerner/clara-rules/issues/373 affect short circuiting the evaluation of all LHS conditions? My understanding is that if the first condition doesn’t match the remaining ones are still processed"><y>#</y><d>2018-01-12</d><h>00:11</h><w>alex-dixon</w>Do any changes proposed in <a href="https://github.com/cerner/clara-rules/issues/373" target="_blank">https://github.com/cerner/clara-rules/issues/373</a> affect short circuiting the evaluation of all LHS conditions? My understanding is that if the first condition doesn’t match the remaining ones are still processed</z><z id="t1515763656000145" t="mikerod @alex-dixon right now the alpha network is “eagerly” evaluated"><y>#</y><d>2018-01-12</d><h>13:27</h><w>mikerod</w>@alex-dixon right now the alpha network is “eagerly” evaluated</z><z id="t1515763667000233" t="mikerod So constraints within conditions that are independent of a join with another condition"><y>#</y><d>2018-01-12</d><h>13:27</h><w>mikerod</w>So constraints within conditions that are independent of a join with another condition</z><z id="t1515763740000149" t="mikerod Clara has had this sort of “re-ordering” property since way back (maybe always) now. The discusses we have had before about trying to be “lazier” in evaluation by not evaluating any part of a condition if the prior conditions were satisfied, would be affected by this re-ordering logic"><y>#</y><d>2018-01-12</d><h>13:29</h><w>mikerod</w>Clara has had this sort of “re-ordering” property since way back (maybe always) now. The discusses we have had before about trying to be “lazier” in evaluation by not evaluating any part of a condition if the prior conditions were satisfied, would be affected by this re-ordering logic</z><z id="t1515777766000119" t="alex-dixon Thanks. Printed out ch 2 of the paper you recommended. It’s awesome. Working my way through. Will try to avoid asking you to explain rete to me in the interim:blush: That said: If Clara’s reordering doesn’t honor the order of conditions in the lhs as they are written (even if just for alphas) would any of the changes in @wparker ‘s proposal make it so the developer’s ordering is honored when evaluating a lhs? My understanding is that’s part of the proposal, but only for Boolean conditions. If that’s right and it’s developed, could the behavior be extended to apply to all conditions using much of the same code? Outside Boolean conditions, would this be a massive breaking change? I think so just want to confirm. I’m asking because I think there would be an appreciable performance difference between the two for CEP. I think Drools made changes along these lines for that reason "><y>#</y><d>2018-01-12</d><h>17:22</h><w>alex-dixon</w>Thanks. Printed out ch 2 of the paper you recommended. It’s awesome. Working my way through. Will try to avoid asking you to explain rete to me in the interim:blush:

That said:
If Clara’s reordering doesn’t honor the order of conditions in the lhs as they are written (even if just for alphas) would any of the changes in @wparker ‘s proposal make it so the developer’s ordering is honored when evaluating a lhs? My understanding is that’s part of the proposal, but only for Boolean conditions. If that’s right and it’s developed, could  the behavior be extended to apply to all conditions using much of the same code? 

Outside Boolean conditions, would this be a massive breaking change? I think so just want to confirm. 

I’m asking because I think there would be an appreciable performance difference between the two for CEP. I think Drools made changes along these lines for that reason </z><z id="t1515780545000415" t="mikerod @alex-dixon I think the re-ordering (or not) is still being discussed in the 373 linked above. There already is re-ordering happening. It sounds like there may be some lean towards not needing to do that anymore. You should check out some of the comments in that issue now. I did mention the lazier evaluation thing there, but there are still concerns I’d have with that overall."><y>#</y><d>2018-01-12</d><h>18:09</h><w>mikerod</w>@alex-dixon I think the re-ordering (or not) is still being discussed in the 373 linked above.
There already is re-ordering happening. It sounds like there may be some lean towards not needing to do that anymore. You should check out some of the comments in that issue now.
 I did mention the lazier evaluation thing there, but there are still concerns I’d have with that overall.</z><z id="t1515780703000505" t="mikerod And yes, that paper is good. I first heard of it from Ryan putting a reference to it in the Clara GitHub repo @ https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine"><y>#</y><d>2018-01-12</d><h>18:11</h><w>mikerod</w>And yes, that paper is good. I first heard of it from Ryan putting a reference to it in the Clara GitHub repo @ <a href="https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine" target="_blank">https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine</a></z><z id="t1515782074000313" t="sparkofreason If I were to call insert! from within an async callback for an effect triggered on the rhs of a rule, I assume that the context would be goofy and result in an exception or other undesirable behavior. Is there a best practice for capturing that context? The use case would be leveraging truth maintenance for facts inserted async, e.g. results from an http request. "><y>#</y><d>2018-01-12</d><h>18:34</h><w>sparkofreason</w>If I were to call <code>insert!</code> from within an async callback for an effect triggered on the rhs of a rule, I assume that the context would be goofy and result in an exception or other undesirable behavior. Is there a best practice for capturing that context? The use case would be leveraging truth maintenance for facts inserted async, e.g. results from an http request. </z><z id="t1515785717000155" t="mikerod @dave.dixon I’d expect the async response to be do an external insert when it is done"><y>#</y><d>2018-01-12</d><h>19:35</h><w>mikerod</w>@dave.dixon I’d expect the async response to be do an external <code>insert</code> when it is done</z><z id="t1515785733000096" t="mikerod You’d “capture context” just via the variable bindings you passed to the async call"><y>#</y><d>2018-01-12</d><h>19:35</h><w>mikerod</w>You’d “capture context” just via the variable bindings you passed to the async call</z><z id="t1515785764000220" t="mikerod Oh, woops, missed part of your purpose"><y>#</y><d>2018-01-12</d><h>19:36</h><w>mikerod</w>Oh, woops, missed part of your purpose</z><z id="t1515785804000296" t="mikerod I think you’d have to model the fact that you caused the effect externally as a fact for TMS to help you. Example:"><y>#</y><d>2018-01-12</d><h>19:36</h><w>mikerod</w>I think you’d have to model the fact that you caused the effect externally as a fact for TMS to help you. Example:</z><z id="t1515786224000564" t="mikerod I don’t really like the maybe-undo-async-thing part of that. It doesn’t know which DownstreamResult may now be invalid and offloads it all to the external fn ext-maybe-undo-async-thing"><y>#</y><d>2018-01-12</d><h>19:43</h><w>mikerod</w>I don’t really like the <code>maybe-undo-async-thing</code> part of that. It doesn’t know which <code>DownstreamResult</code> may now be invalid and offloads it all to the external fn <code>ext-maybe-undo-async-thing</code></z><z id="t1515786236000310" t="mikerod I think there may be a better way around that"><y>#</y><d>2018-01-12</d><h>19:43</h><w>mikerod</w>I think there may be a better way around that</z><z id="t1515786421000115" t="mikerod I made it so original-rule is always satisfied via the accumulator"><y>#</y><d>2018-01-12</d><h>19:47</h><w>mikerod</w>I made it so <code>original-rule</code> is always satisfied via the accumulator</z><z id="t1515786435000581" t="mikerod So you can carry that information forward on which path you should take"><y>#</y><d>2018-01-12</d><h>19:47</h><w>mikerod</w>So you can carry that information forward on which path you should take</z><z id="t1515786437000492" t="sparkofreason Yes, that&apos;s how I&apos;m doing it now. Like you say, it&apos;s fine when all the relationships are clean, but otherwise gets messy. "><y>#</y><d>2018-01-12</d><h>19:47</h><w>sparkofreason</w>Yes, that&apos;s how I&apos;m doing it now. Like you say, it&apos;s fine when all the relationships are clean, but otherwise gets messy. </z><z id="t1515786455000682" t="sparkofreason Referring to the first example. "><y>#</y><d>2018-01-12</d><h>19:47</h><w>sparkofreason</w>Referring to the first example. </z><z id="t1515786487000644" t="mikerod So in my 2nd example, you can actually filter DownstreamResult if you track which bs they originally were associated with via that information being conveyed externally and back on the inserted new facts"><y>#</y><d>2018-01-12</d><h>19:48</h><w>mikerod</w>So in my 2nd example, you can actually filter <code>DownstreamResult</code> if you track which <code>bs</code> they originally were associated with via that information being conveyed externally and back on the inserted new facts</z><z id="t1515786512000430" t="mikerod It isn’t perfect, you still have to make an association on the facts, however, I think it could be practical"><y>#</y><d>2018-01-12</d><h>19:48</h><w>mikerod</w>It isn’t perfect, you still have to make an association on the facts, however, I think it could be practical</z><z id="t1515786536000175" t="mikerod This is regarding one part of the overall problem"><y>#</y><d>2018-01-12</d><h>19:48</h><w>mikerod</w>This is regarding one part of the overall problem</z><z id="t1515786560000320" t="mikerod You also have the problem of when the async request is finished, ensuring it inserts to the session that it came from in its final state"><y>#</y><d>2018-01-12</d><h>19:49</h><w>mikerod</w>You also have the problem of when the async request is finished, ensuring it inserts to the session that it came from in its final state</z><z id="t1515786583000003" t="mikerod so after the fire-rules that triggered the async request has completed"><y>#</y><d>2018-01-12</d><h>19:49</h><w>mikerod</w>so after the <code>fire-rules</code> that triggered the async request has completed</z><z id="t1515786591000774" t="mikerod In a single-thread, I think that is not an issue"><y>#</y><d>2018-01-12</d><h>19:49</h><w>mikerod</w>In a single-thread, I think that is not an issue</z><z id="t1515786605000507" t="mikerod And you may be doing this single-threadedly"><y>#</y><d>2018-01-12</d><h>19:50</h><w>mikerod</w>And you may be doing this single-threadedly</z><z id="t1515786644000736" t="mikerod The async call though would need to have a way to access the session when it is finished"><y>#</y><d>2018-01-12</d><h>19:50</h><w>mikerod</w>The async call though would need to have a way to access the session when it is finished</z><z id="t1515786863000315" t="sparkofreason I have a way of handling session. But what I really want is to be able to do the final insert such that the fact is a logical consequence of the rule lhs. Not sure if that actually is meaningful given how rete works. "><y>#</y><d>2018-01-12</d><h>19:54</h><w>sparkofreason</w>I have a way of handling session. But what I really want is to be able to do the final insert such that the fact is a logical consequence of the rule lhs. Not sure if that actually is meaningful given how rete works. </z><z id="t1515870131000097" t="alex-dixon I’m not sure whether using Clara’s truth maintenance directly allows that, but you should be able to simulate it using unconditional inserts/retracts, other rules, and facts that represent the async event cycle. A poor attempt: (defrule make-request-when [?task &lt;- AsyncTask] =&gt; (retract! ?task) (insert-unconditional (-&gt;AsyncRequest ?task)) (async-side-effect! my-session ?task) (defn async-side-effect! [session fact] (request! fact (fn [err res] (if err (insert session (-&gt;AsyncTaskError err fact) (insert session (-&gt;AsyncTaskSuccess res fact)) (defrule on-async-task-success [?success &lt;- AsyncTaskSuccess ?res ?fact] [?request &lt;- AsyncTaskRequest ?fact] =&gt; (retract! ?success ?request) (insert-unconditional! (-&gt;SomeFactRepresentingResponseFromThisKindOfRequest ?res) ;; similarly with error "><y>#</y><d>2018-01-13</d><h>19:02</h><r>alex-dixon</r>I’m not sure whether using Clara’s truth maintenance directly allows that, but you should be able to simulate it  using unconditional inserts/retracts, other rules, and facts that represent the async event cycle.

A poor attempt:

<pre>(defrule make-request-when
  [?task &lt;- AsyncTask]
  =&gt;
  (retract! ?task)
  (insert-unconditional (-&gt;AsyncRequest ?task))
 (async-side-effect! my-session ?task)

(defn async-side-effect! [session fact] (request! fact (fn [err res] 
(if err (insert session (-&gt;AsyncTaskError err fact)
(insert session (-&gt;AsyncTaskSuccess res fact))

(defrule on-async-task-success
  [?success &lt;- AsyncTaskSuccess ?res ?fact]
  [?request &lt;- AsyncTaskRequest ?fact]
=&gt;
(retract! ?success ?request)
(insert-unconditional! (-&gt;SomeFactRepresentingResponseFromThisKindOfRequest ?res)
 
  ;; similarly with error
</pre></z><z id="t1515871603000037" t="sparkofreason I have something similar, and it works nicely. But it would be nice if I could avoid the manual truth maintenance. "><y>#</y><d>2018-01-13</d><h>19:26</h><r>sparkofreason</r>I have something similar, and it works nicely. But it would be nice if I could avoid the manual truth maintenance. </z><z id="t1515791783000250" t="mikerod I don’t think anything built-in would allow you to reliable have an actual “handle” on the mutable session state during fire rules for an insert! to go off later yet, still correctly be tracked with TMS"><y>#</y><d>2018-01-12</d><h>21:16</h><w>mikerod</w>I don’t think anything built-in would allow you to reliable have an actual “handle” on the mutable session state during fire rules for an <code>insert!</code> to go off later yet, still correctly be tracked with TMS</z><z id="t1515791795000404" t="mikerod there’d be quite a bit of complications for the engine to try to support that even I think"><y>#</y><d>2018-01-12</d><h>21:16</h><w>mikerod</w>there’d be quite a bit of complications for the engine to try to support that even I think</z><z id="t1515791810000440" t="mikerod Not to mention the fire-rules wouldn’t be able to be “done” until all async actions were done"><y>#</y><d>2018-01-12</d><h>21:16</h><w>mikerod</w>Not to mention the fire-rules wouldn’t be able to be “done” until all async actions were done</z><z id="t1515791833000115" t="mikerod and it’d have concurrency issues in a multi-threaded environment"><y>#</y><d>2018-01-12</d><h>21:17</h><w>mikerod</w>and it’d have concurrency issues in a multi-threaded environment</z><z id="t1515794385000366" t="sparkofreason Agreed. Maybe the right(ish) answer is to model facts as something like a promise. The semantics and behavior would have to be constrained, so it isn&apos;t just mutating facts behind your back without properly updating the session. But the basic concept seems like a way forward, because conditionally inserting a promise as a fact means it and whatever value it returns will get retracted when TMS requires it."><y>#</y><d>2018-01-12</d><h>21:59</h><w>sparkofreason</w>Agreed. Maybe the right(ish) answer is to model facts as something like a promise. The semantics and behavior would have to be constrained, so it isn&apos;t just mutating facts behind your back without properly updating the session. But the basic concept seems like a way forward, because conditionally inserting a promise as a fact means it and whatever value it returns will get retracted when TMS requires it.</z><z id="t1515794560000185" t="sparkofreason The thing I&apos;m trying to avoid is having to manually perform truth management for facts inserted as the result of async effects. In the big picture, those facts are logical consequents of whatever condition triggered the async effect."><y>#</y><d>2018-01-12</d><h>22:02</h><w>sparkofreason</w>The thing I&apos;m trying to avoid is having to manually perform truth management for facts inserted as the result of async effects. In the big picture, those facts are logical consequents of whatever condition triggered the async effect.</z><z id="t1515797199000136" t="mikerod Yeah,I think the case is interesting"><y>#</y><d>2018-01-12</d><h>22:46</h><w>mikerod</w>Yeah,I think the case is interesting</z><z id="t1515859349000081" t="sparkofreason I took a shot at forcing conditional inserts in the async handler, if only as an exercise to understand the code better. I got as far as actually getting the insert to occur, basically grabbing the *rule-context* and making it available to the handler, and adding an overload of fire-rules that would accept that as an extra parameter. The rule context was modified so it only contained non-empty :batched-logical-insertions with the facts being inserted as a logical consequence of the rule triggering the async effect. clara.rules.engine/*fire-rules* then also had an extra arity to deal with externally supplied rule context. At this point, I guessed that this approach probably wouldn&apos;t work in general, because it looks to me like the :token in the rule context contains the fact bindings which are the logical antecedent. If any of those facts had been retracted in the session between the request and response of the async effect, I assume that clara.rules.memory/add-insertions! would be unhappy, as the token would be inconsistent with the state of working memory. Is that correct?"><y>#</y><d>2018-01-13</d><h>16:02</h><w>sparkofreason</w>I took a shot at forcing conditional inserts in the async handler, if only as an  exercise to understand the code better. I got as far as actually getting the insert to occur, basically grabbing the <code>*rule-context*</code> and making it available to the handler, and adding an overload of <code>fire-rules</code> that would accept that as an extra parameter. The rule context was modified so it only contained non-empty <code>:batched-logical-insertions</code> with the facts being inserted as a logical consequence of the rule triggering the async effect. <code>clara.rules.engine/*fire-rules*</code> then also had an extra arity to deal with externally supplied rule context. At this point, I guessed that this approach probably wouldn&apos;t work in general, because it looks to me like the <code>:token</code> in the rule context contains the fact bindings which are the logical antecedent. If any of those facts had been retracted in the session between the request and response of the async effect, I assume that <code>clara.rules.memory/add-insertions!</code> would be unhappy, as the token would be inconsistent with the state of working memory. Is that correct?</z><z id="t1515862358000099" t="mikerod Yeah. I don’t think that’d be very tractable. "><y>#</y><d>2018-01-13</d><h>16:52</h><w>mikerod</w>Yeah. I don’t think that’d be very tractable. </z><z id="t1515862377000053" t="mikerod Also working memory is in a mutable state. I think things could easily become inconsistent. "><y>#</y><d>2018-01-13</d><h>16:52</h><w>mikerod</w>Also working memory is in a mutable state. I think things could easily become inconsistent. </z><z id="t1515867205000050" t="sparkofreason Makes sense."><y>#</y><d>2018-01-13</d><h>18:13</h><w>sparkofreason</w>Makes sense.</z><z id="t1515867298000023" t="sparkofreason Is there a way to force a rule to fire, even if the fact values don&apos;t change? I&apos;m playing around with using an atom to solve this case, but of course the atom reference doesn&apos;t change when the atom is reset, only the wrapped value changes, so the rule won&apos;t fire after the first time."><y>#</y><d>2018-01-13</d><h>18:14</h><w>sparkofreason</w>Is there a way to force a rule to fire, even if the fact values don&apos;t change? I&apos;m playing around with using an atom to solve this case, but of course the atom reference doesn&apos;t change when the atom is reset, only the wrapped value changes, so the rule won&apos;t fire after the first time.</z><z id="t1515870366000040" t="alex-dixon @dave.dixon &gt; Is there a way to force a rule to fire, even if the fact values don’t change? No offense intended at all but that seems off to a bad start even to me…. 😄 What are you trying to do?"><y>#</y><d>2018-01-13</d><h>19:06</h><w>alex-dixon</w>@dave.dixon 
&gt; Is there a way to force a rule to fire, even if the fact values don’t change?
No offense intended at all but that seems off to a bad start even to me…. <b>😄</b> What are you trying to do?</z><z id="t1515871495000066" t="sparkofreason Yeah, it sounds bad. I&apos;m trying to get the rhs to evaluate when a fact refers to an atom and the atom value changes. "><y>#</y><d>2018-01-13</d><h>19:24</h><r>sparkofreason</r>Yeah, it sounds bad. I&apos;m trying to get the rhs to evaluate when a fact refers to an atom and the atom value changes. </z><z id="t1515871633000161" t="alex-dixon Interesting. Why an atom?"><y>#</y><d>2018-01-13</d><h>19:27</h><r>alex-dixon</r>Interesting. Why an atom?</z><z id="t1515871787000006" t="sparkofreason So I can put the response from an async request in it. "><y>#</y><d>2018-01-13</d><h>19:29</h><r>sparkofreason</r>So I can put the response from an async request in it. </z><z id="t1515872037000112" t="alex-dixon Hm ok. Have you tried calling deref on the atom in the condition "><y>#</y><d>2018-01-13</d><h>19:33</h><r>alex-dixon</r>Hm ok. Have you tried calling deref on the atom in the condition </z><z id="t1515872220000088" t="sparkofreason Yes. Doesn&apos;t help. In fact, it doesn&apos;t work in general for making the bindings, which seems odd. "><y>#</y><d>2018-01-13</d><h>19:37</h><r>sparkofreason</r>Yes. Doesn&apos;t help. In fact, it doesn&apos;t work in general for making the bindings, which seems odd. </z><z id="t1515872396000034" t="alex-dixon Hm. Potentially wild things I’d try: 1. (deref a) instead of the macro if you’re not already, 2. :test expression"><y>#</y><d>2018-01-13</d><h>19:39</h><r>alex-dixon</r>Hm. Potentially wild things I’d try: 1. (deref a) instead of the macro if you’re not already, 2. :test expression</z><z id="t1515872495000070" t="sparkofreason Have tried both. Deref doesn&apos;t help, but the reader macro works in a test and rhs. "><y>#</y><d>2018-01-13</d><h>19:41</h><r>sparkofreason</r>Have tried both. Deref doesn&apos;t help, but the reader macro works in a test and rhs. </z><z id="t1515873201000060" t="alex-dixon Well I’m confused. @mikerod might be able to shine light on it"><y>#</y><d>2018-01-13</d><h>19:53</h><r>alex-dixon</r>Well I’m confused. @mikerod might be able to shine light on it</z><z id="t1515875609000035" t="mikerod I am not sure I understand still. Been traveling today though so somewhat on and off here "><y>#</y><d>2018-01-13</d><h>20:33</h><r>mikerod</r>I am not sure I understand still. Been traveling today though so somewhat on and off here </z><z id="t1515876066000154" t="mikerod I think I’d have to see an example here. Hah"><y>#</y><d>2018-01-13</d><h>20:41</h><r>mikerod</r>I think I’d have to see an example here. Hah</z><z id="t1515878242000019" t="sparkofreason I&apos;ll post it when I get home. "><y>#</y><d>2018-01-13</d><h>21:17</h><r>sparkofreason</r>I&apos;ll post it when I get home. </z><z id="t1515871221000057" t="dadair Does Clara support namespace aliases in Fact matching? The following throws an exception, but the long-form works: [encounter-actions/EncounterFindingChanged ..] ;; short -- throws ex [justice.models.core.actions.encounter.EncounterFindingChanged ..] ;; long "><y>#</y><d>2018-01-13</d><h>19:20</h><w>dadair</w>Does Clara support namespace aliases in Fact matching? The following throws an exception, but the long-form works:
<pre>[encounter-actions/EncounterFindingChanged ..] ;; short -- throws ex
[justice.models.core.actions.encounter.EncounterFindingChanged ..] ;; long
</pre></z><z id="t1515871699000075" t="sparkofreason I hit a similar issue using a macro in a rule definition. "><y>#</y><d>2018-01-13</d><h>19:28</h><w>sparkofreason</w>I hit a similar issue using a macro in a rule definition. </z><z id="t1515872518000062" t="mikerod @dadair it should. If it doesn’t it probably needs to be looked at. "><y>#</y><d>2018-01-13</d><h>19:41</h><w>mikerod</w>@dadair it should. If it doesn’t it probably needs to be looked at. </z><z id="t1515872523000020" t="mikerod As an issue I mean"><y>#</y><d>2018-01-13</d><h>19:42</h><w>mikerod</w>As an issue I mean</z><z id="t1515875501000061" t="dadair @mikerod I&apos;ll file an issue, I replicated it with the intro to clara example just moving the defrecords into another ns"><y>#</y><d>2018-01-13</d><h>20:31</h><w>dadair</w>@mikerod I&apos;ll file an issue, I replicated it with the intro to clara example just moving the defrecords into another ns</z><z id="t1515875547000007" t="mikerod @dadair if it’s cljs perhaps it relates to some recent issues already out there. I thought it was fixed though. "><y>#</y><d>2018-01-13</d><h>20:32</h><w>mikerod</w>@dadair if it’s cljs perhaps it relates to some recent issues already out there. I thought it was fixed though. </z><z id="t1515875554000136" t="dadair nope just .clj"><y>#</y><d>2018-01-13</d><h>20:32</h><w>dadair</w>nope just <code>.clj</code></z><z id="t1515875559000026" t="dadair on 0.17.0"><y>#</y><d>2018-01-13</d><h>20:32</h><w>dadair</w>on <code>0.17.0</code></z><z id="t1515875567000068" t="mikerod Hmm. I’m traveling today so can’t look. "><y>#</y><d>2018-01-13</d><h>20:32</h><w>mikerod</w>Hmm. I’m traveling today so can’t look. </z><z id="t1515875642000119" t="mikerod It should definitely support aliasing. "><y>#</y><d>2018-01-13</d><h>20:34</h><w>mikerod</w>It should definitely support aliasing. </z><z id="t1515875684000016" t="mikerod Unless you didn’t include the alias in the ns or something. Hah. If you could make like a small example where it isn’t working that’d be nice to see. "><y>#</y><d>2018-01-13</d><h>20:34</h><w>mikerod</w>Unless you didn’t include the alias in the ns or something. Hah. If you could make like a small example where it isn’t working that’d be nice to see. </z><z id="t1515875801000045" t="dadair (ns abc.other) (defrecord SupportRequest [client level]) (defrecord ClientRepresentative [name client]) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (ns abc.core (:require [clara.rules :refer :all] [abc.other :as other])) (defrule is-important &quot;Find important support requests.&quot; [abc.other.SupportRequest (= :high level)] ;; full path here works; change to other/SupportRequest and an exception is thrown =&gt; (println &quot;High support requested!&quot;)) (defrule notify-client-rep &quot;Find the client representative and request support.&quot; [abc.other.SupportRequest (= ?client client)] [abc.other.ClientRepresentative (= ?client client) (= ?name name)] =&gt; (println &quot;Notify&quot; ?name &quot;that&quot; ?client &quot;has a new support request!&quot;)) (-&gt; (mk-session &apos;abc.core) (insert (other/-&gt;ClientRepresentative &quot;Alice&quot; &quot;Acme&quot;) (other/-&gt;SupportRequest &quot;Acme&quot; :high)) (fire-rules)) "><y>#</y><d>2018-01-13</d><h>20:36</h><w>dadair</w><pre>(ns abc.other)

(defrecord SupportRequest [client level])

(defrecord ClientRepresentative [name client])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(ns abc.core
  (:require [clara.rules :refer :all]
            [abc.other :as other]))

(defrule is-important
  &quot;Find important support requests.&quot;
  [abc.other.SupportRequest (= :high level)] ;; full path here works; change to other/SupportRequest and an exception is thrown
  =&gt;
  (println &quot;High support requested!&quot;))

(defrule notify-client-rep
  &quot;Find the client representative and request support.&quot;
  [abc.other.SupportRequest (= ?client client)]
  [abc.other.ClientRepresentative (= ?client client) (= ?name name)]
  =&gt;
  (println &quot;Notify&quot; ?name &quot;that&quot;
          ?client &quot;has a new support request!&quot;))

(-&gt; (mk-session &apos;abc.core)
    (insert (other/-&gt;ClientRepresentative &quot;Alice&quot; &quot;Acme&quot;)
            (other/-&gt;SupportRequest &quot;Acme&quot; :high))
    (fire-rules))
</pre></z><z id="t1515875849000051" t="dadair the above example reproduces the problem"><y>#</y><d>2018-01-13</d><h>20:37</h><w>dadair</w>the above example reproduces the problem</z><z id="t1515875936000055" t="mikerod Record types in clojure are referred to by their Java Class name"><y>#</y><d>2018-01-13</d><h>20:38</h><w>mikerod</w>Record types in clojure are referred to by their Java Class name</z><z id="t1515875942000044" t="mikerod You have to use import for those. "><y>#</y><d>2018-01-13</d><h>20:39</h><w>mikerod</w>You have to use import for those. </z><z id="t1515875957000106" t="dadair ah right"><y>#</y><d>2018-01-13</d><h>20:39</h><w>dadair</w>ah right</z><z id="t1515875962000128" t="mikerod They don’t support ns aliasing. Their builder functions do but not the type class itsel"><y>#</y><d>2018-01-13</d><h>20:39</h><w>mikerod</w>They don’t support ns aliasing. Their builder functions do but not the type class itsel</z><z id="t1515875972000125" t="mikerod Sort of a clj quirk that is unfortunate. "><y>#</y><d>2018-01-13</d><h>20:39</h><w>mikerod</w>Sort of a clj quirk that is unfortunate. </z><z id="t1515875992000054" t="mikerod Clara is just using clj for the symbol resolution there though. "><y>#</y><d>2018-01-13</d><h>20:39</h><w>mikerod</w>Clara is just using clj for the symbol resolution there though. </z><z id="t1515876153000071" t="dadair I always forget about imports, thanks!"><y>#</y><d>2018-01-13</d><h>20:42</h><w>dadair</w>I always forget about imports, thanks!</z><z id="t1515885748000030" t="alex-dixon @dave.dixon so in the one that works are there different time facts with different time values?"><y>#</y><d>2018-01-13</d><h>23:22</h><w>alex-dixon</w>@dave.dixon so in the one that works are there different time facts with different time values?</z><z id="t1515885883000068" t="sparkofreason @alex-dixon I haven&apos;t tried multiple time facts. I think it should work correctly with upsert, though. Retracting existing fact would lead to retraction of the generated Tag facts, and the subsequent insert would generate an updated set."><y>#</y><d>2018-01-13</d><h>23:24</h><w>sparkofreason</w>@alex-dixon I haven&apos;t tried multiple time facts. I think it should work correctly with upsert, though. Retracting existing fact would lead to retraction of the generated Tag facts, and the subsequent insert would generate an updated set.</z><z id="t1515886068000024" t="sparkofreason I was hoping to get away from having auxiliary unconditional facts like Time . The other version of async is structurally similar, but there the external fact is Response , which is correlated via a rule with the original Request . There&apos;s an additional rule that forces retract of Response when the corresponding Request no longer exists."><y>#</y><d>2018-01-13</d><h>23:27</h><w>sparkofreason</w>I was hoping to get away from having auxiliary unconditional facts like <code>Time</code>. The other version of async is structurally similar, but there the external fact is <code>Response</code>, which is correlated via a rule with the original <code>Request</code>. There&apos;s an additional rule that forces retract of <code>Response</code> when the corresponding <code>Request</code> no longer exists.</z><z id="t1515886197000035" t="sparkofreason Given that both approaches require unconditional inserts, the Request /`Response` pattern is arguably cleaner, as the atom approach requires some extra coordination outside of the rulebase to correctly update the session when the atom value changes."><y>#</y><d>2018-01-13</d><h>23:29</h><w>sparkofreason</w>Given that both approaches require unconditional inserts, the <code>Request</code>/`Response` pattern is arguably cleaner, as the atom approach requires some extra coordination outside of the rulebase to correctly update the session when the atom value changes.</z><z id="t1515886631000040" t="alex-dixon I’ll definitely keep this in mind as I try to do similar things. Wish I could be more help but it gets hard for me to reason about and I find my thinking tending toward more immutable approaches which seems like the opposite of the overall approach (fewer intermediate facts/garbage). I’ll try to experiment next time I’m at a laptop "><y>#</y><d>2018-01-13</d><h>23:37</h><w>alex-dixon</w>I’ll definitely keep this in mind as I try to do similar things. Wish I could be more help but it gets hard for me to reason about and I find my thinking tending toward more immutable approaches which seems like the opposite of the overall approach (fewer intermediate facts/garbage). I’ll try to experiment next time I’m at a laptop </z><z id="t1515886728000063" t="alex-dixon Curious, did you try a callback in the rhs and logical insert? Seem to recall that being your first approach. If so what happened? Loss of session context?"><y>#</y><d>2018-01-13</d><h>23:38</h><w>alex-dixon</w>Curious, did you try a callback in the rhs and logical insert? Seem to recall that being your first approach. If so what happened? Loss of session context?</z><z id="t1515889746000094" t="sparkofreason I have it working with a callback and unconditional insert. I don&apos;t think there&apos;s a way to do a logical insert in the context of the callback. The session has already moved forward, could have been modified further by the time the callback is called, etc."><y>#</y><d>2018-01-14</d><h>00:29</h><w>sparkofreason</w>I have it working with a callback and unconditional insert. I don&apos;t think there&apos;s a way to do a logical insert in the context of the callback. The session has already moved forward, could have been modified further by the time the callback is called, etc.</z><z id="t1515940984000010" t="alex-dixon I haven’t played around with it much. Typically I do the same as you I think….wait to handle it on the next fire-rules iteration, but that can be problematic in certain cases. So I’m kind of curious about being able to park/block within the RHS but I haven’t thought about it much. It might be convenient for Javascript but in a parallel or multiple thread environment…I dunno. I forget the case I ran into where I really did want to stop the world / rule activations until I could get a result, but I feel like that’s more an error in my thinking than a feature I need to figure out how to support. Don’t know though"><y>#</y><d>2018-01-14</d><h>14:43</h><r>alex-dixon</r>I haven’t played around with it much. Typically I do the same as you I think….wait to handle it on the next fire-rules iteration, but that can be problematic in certain cases. So I’m kind of curious about being able to park/block within the RHS but I haven’t thought about it much. It might be convenient for Javascript but in a parallel or multiple thread environment…I dunno. I forget the case I ran into where I really did want to stop the world / rule activations until I could get a result, but I feel like that’s more an error in my thinking than a feature I need to figure out how to support. Don’t know though</z><z id="t1515890546000021" t="sparkofreason Part of what I was finding was that beyond the simple request/response case there was a proliferation of auxiliary fact types to deal with requests from the UI. For example, if the user toggled the &quot;Favorite&quot; button on an article, I would insert a FavoritedArticle fact, which in turn triggered Request to be inserted, along with a rule to handle the response to that Request . I also had to add clean up rules to get rid of these FavoritedArticle facts when the page changed, as well as properly manage upsertion vs. insertion, etc. It was all starting to feel a bit fiddly. But I think you could actually do this with the same Request /`Response` pattern, just replacing making an HTTP request with rendering the UI which will generate the Response ."><y>#</y><d>2018-01-14</d><h>00:42</h><w>sparkofreason</w>Part of what I was finding was that beyond the simple request/response case there was a proliferation of auxiliary fact types to deal with requests from the UI. For example, if the user toggled the &quot;Favorite&quot; button on an article, I would insert a <code>FavoritedArticle</code> fact, which in turn triggered <code>Request</code> to be inserted, along with a rule to handle the response to that <code>Request</code>. I also had to add clean up rules to get rid of these <code>FavoritedArticle</code> facts when the page changed, as well as properly manage upsertion vs. insertion, etc. It was all starting to feel a bit fiddly. But I think you could actually do this with the same <code>Request</code>/`Response` pattern, just replacing making an HTTP request with rendering the UI which will generate the <code>Response</code>.</z><z id="t1515940490000068" t="alex-dixon So for precept I implemented something like the following. Below is somewhat similar to Redux in Javascript which also reifies this and request/response/fail for api calls for front-end state management. (defrecord Action [type payload]) (defrule actions-only-survive-one-call-to-fire-rules {:salience -100} [?fact &lt;- Action] =&gt; (retract! Action) (defrule on-article-favorited {:salience 100} [Action (= ?type :article-favorited) (= ?payload payload)] =&gt; ;; Still have the async dance but Action facts are automatically cleaned up at the end (do) "><y>#</y><d>2018-01-14</d><h>14:34</h><r>alex-dixon</r>So for precept I implemented something like the following. Below is somewhat similar to Redux in Javascript which also reifies this and request/response/fail for api calls for front-end state management. 

<pre>(defrecord Action [type payload])

(defrule actions-only-survive-one-call-to-fire-rules
{:salience -100}
 [?fact &lt;- Action]
=&gt;
(retract! Action)

(defrule on-article-favorited
{:salience 100}
[Action (= ?type :article-favorited) (= ?payload payload)]
=&gt;
;; Still have the async dance but Action facts are automatically cleaned up at the end
(do)
</pre></z><z id="t1515944195000027" t="sparkofreason Right. I&apos;m trying to do this without salience, just to see where it takes me in terms of design, possible changes to clara, etc. One thing that has fallen out is that I think the fact-based immutable history approach of precept is probably the way to go, as opposed to using whole entities as facts and trying to update &quot;in place&quot;."><y>#</y><d>2018-01-14</d><h>15:36</h><r>sparkofreason</r>Right. I&apos;m trying to do this without salience, just to see where it takes me in terms of design, possible changes to clara, etc. One thing that has fallen out is that I think the fact-based immutable history approach of precept is probably the way to go, as opposed to using whole entities as facts and trying to update &quot;in place&quot;.</z><z id="t1515951565000034" t="alex-dixon Would you consider agenda groups? I’ve very little experience with systems that use them but we try to simulate them partially in precept by using Clara’s :activation-groups and :activation-group-sort-fn http://www.clara-rules.org/docs/conflictsalience/"><y>#</y><d>2018-01-14</d><h>17:39</h><r>alex-dixon</r>Would you consider agenda groups? I’ve very little experience with systems that use them but we try to simulate them partially in precept by using Clara’s :activation-groups and :activation-group-sort-fn <a href="http://www.clara-rules.org/docs/conflictsalience/" target="_blank">http://www.clara-rules.org/docs/conflictsalience/</a></z><z id="t1515951651000100" t="alex-dixon So we have :group :cleanup I think, which is given least precedence in the sort fn"><y>#</y><d>2018-01-14</d><h>17:40</h><r>alex-dixon</r>So we have :group :cleanup I think, which is given least precedence in the sort fn</z><z id="t1515952057000010" t="alex-dixon I still run into wanting update in place but I’m on the fence about it because immutability is easier for me to understand. Case that comes up a lot is a default value: (rule when-no-user-selected-article [:not SelectedArticleId] [?most-recent &lt;- (acc/min :time :returns-fact true) :from [Article]] =&gt; (insert! (-&gt;SelectedArticleId (:id ?most-recent))) "><y>#</y><d>2018-01-14</d><h>17:47</h><r>alex-dixon</r>I still run into wanting update in place but I’m on the fence about it because immutability is easier for me to understand. Case that comes up a lot is a default value:

<pre>(rule when-no-user-selected-article
 [:not SelectedArticleId]
  [?most-recent &lt;- (acc/min :time :returns-fact true) :from [Article]]
=&gt;
(insert! (-&gt;SelectedArticleId (:id ?most-recent)))
</pre></z><z id="t1515952184000098" t="alex-dixon So that loops"><y>#</y><d>2018-01-14</d><h>17:49</h><r>alex-dixon</r>So that loops</z><z id="t1515952659000121" t="alex-dixon There’s a :no-loop prop that’s relatively undocumented. Haven’t played with it but seems like it would solve this case. A (modify!) wouldn’t I guess because the SelectedArticleId doesn’t exist. If it did as something like (SelectedArticleId :unset) then you could match on (= id :unset) and (modify! ?selected-article :id (:id ?most-recent))"><y>#</y><d>2018-01-14</d><h>17:57</h><r>alex-dixon</r>There’s a :no-loop prop that’s relatively undocumented. Haven’t played with it but seems like it would solve this case. A (modify!) wouldn’t I guess because the SelectedArticleId doesn’t exist. If it did as something like (SelectedArticleId :unset) then you could match on (= id :unset) and (modify! ?selected-article :id (:id ?most-recent))</z><z id="t1515961706000049" t="sparkofreason I need to think about it. But I really am trying, as an exercise, to see what happens if you constrain yourself solely to the logical consistency implied by clara. I think I&apos;m converging on something, but I&apos;ve thought that before only to trip over an ugly fact that ruined my beautiful theory."><y>#</y><d>2018-01-14</d><h>20:28</h><r>sparkofreason</r>I need to think about it. But I really am trying, as an exercise, to see what happens if you constrain yourself solely to the logical consistency implied by clara. I think I&apos;m converging on something, but I&apos;ve thought that before only to trip over an ugly fact that ruined my beautiful theory.</z><z id="t1515961808000005" t="sparkofreason BTW, the &quot;real world&quot; example app (conduit) is proving to be a great way to exercise this stuff. You might find it useful for precept development. https://github.com/jacekschae/conduit"><y>#</y><d>2018-01-14</d><h>20:30</h><r>sparkofreason</r>BTW, the &quot;real world&quot; example app (conduit) is proving to be a great way to exercise this stuff. You might find it useful for precept development. <a href="https://github.com/jacekschae/conduit" target="_blank">https://github.com/jacekschae/conduit</a></z><z id="t1515961925000147" t="alex-dixon Yeah was thinking same! Would be nice to see it and Clara on their official list as well"><y>#</y><d>2018-01-14</d><h>20:32</h><r>alex-dixon</r>Yeah was thinking same! Would be nice to see it and Clara on their official list as well</z><z id="t1516039348000474" t="alex-dixon @dave.dixon just curious Re part of issue 371: if you had something like s/querydef would you still want ns kw names for defquery?"><y>#</y><d>2018-01-15</d><h>18:02</h><w>alex-dixon</w>@dave.dixon just curious Re part of issue 371: if you had something like s/querydef would you still want ns kw names for defquery?</z><z id="t1516039505000236" t="sparkofreason What is s/querydef ?"><y>#</y><d>2018-01-15</d><h>18:05</h><r>sparkofreason</r>What is <code>s/querydef</code>?</z><z id="t1516039566000486" t="alex-dixon Doesn’t exist. 🙂 Thinking it could be like s/fdef for queries"><y>#</y><d>2018-01-15</d><h>18:06</h><r>alex-dixon</r>Doesn’t exist. <b>🙂</b> Thinking it could be like s/fdef for queries</z><z id="t1516040811000147" t="sparkofreason That&apos;s a good idea. But I&apos;d still want keyword names. It&apos;s not a big deal, just a nice option to give more flexibility to DSL authors. I have it working in my local branch in CLJS, pretty minor change."><y>#</y><d>2018-01-15</d><h>18:26</h><r>sparkofreason</r>That&apos;s a good idea. But I&apos;d still want keyword names. It&apos;s not a big deal, just a nice option to give more flexibility to DSL authors. I have it working in my local branch in CLJS, pretty minor change.</z><z id="t1516040996000453" t="alex-dixon What do the vars end up being named? e.g. (defquery ::some-alias/my-spec ..) =&gt; #’rule-ns/ … ?"><y>#</y><d>2018-01-15</d><h>18:29</h><r>alex-dixon</r>What do the vars end up being named? e.g. (defquery ::some-alias/my-spec ..) =&gt; #’rule-ns/ … ?</z><z id="t1516041507000334" t="sparkofreason There are no vars. I&apos;m not defining the queries as ns-level defs. They&apos;re grouped inside of a named object, and that symbol winds up holding the collection of productions that is provided to defsession ."><y>#</y><d>2018-01-15</d><h>18:38</h><r>sparkofreason</r>There are no vars. I&apos;m not defining the queries as ns-level defs. They&apos;re grouped inside of a named object, and that symbol winds up holding the collection of productions that is provided to <code>defsession</code>.</z><z id="t1516047693000415" t="alex-dixon Like most of your suggestions and changes I like that. Using defs/the ns as a kind of data structure is something I like sometimes and not others"><y>#</y><d>2018-01-15</d><h>20:21</h><r>alex-dixon</r>Like most of your suggestions and changes I like that. Using defs/the ns as a kind of data structure is something I like sometimes and not others</z><z id="t1516047857000299" t="alex-dixon Is that part of your proposal? If not how would you envision this working for users of Clara? Would it affect session reloading?"><y>#</y><d>2018-01-15</d><h>20:24</h><r>alex-dixon</r>Is that part of your proposal? If not how would you envision this working for users of Clara? Would it affect session reloading?</z><z id="t1516051681000225" t="sparkofreason I&apos;m putting together my own DSL that has those characteristics, not proposing to alter the existing rules DSL packaged with clara. I handle reloading in the implementation of my DSL. Since rules are just grouped in vars, it&apos;s pretty straightforward, don&apos;t have to deal with the subtleties of CLJS namespace reloading etc."><y>#</y><d>2018-01-15</d><h>21:28</h><r>sparkofreason</r>I&apos;m putting together my own DSL that has those characteristics, not proposing to alter the existing rules DSL packaged with clara. I handle reloading in the implementation of my DSL. Since rules are just grouped in vars, it&apos;s pretty straightforward, don&apos;t have to deal with the subtleties of CLJS namespace reloading etc.</z><z id="t1516074202000236" t="dadair is there a way to compose accumulators outside of writing a custom reducer? e.g., I want to get the latest timestamp of all facts, so some combination of (acc/all) and (acc/max :tx)"><y>#</y><d>2018-01-16</d><h>03:43</h><w>dadair</w>is there a way to compose accumulators outside of writing a custom reducer? e.g., I want to get <code>the latest timestamp</code> of <code>all</code> facts, so some combination of <code>(acc/all)</code> and <code>(acc/max :tx)</code></z><z id="t1516084436000172" t="mikerod @dadair there isn’t anything directly for that. On a case by case you may able to get the behavior you want from an accumulator like the max above. "><y>#</y><d>2018-01-16</d><h>06:33</h><w>mikerod</w>@dadair there isn’t anything directly for that. On a case by case you may able to get the behavior you want from an accumulator like the max above. </z><z id="t1516084516000075" t="mikerod If you had a unique ID on all facts for example, you could just do ?l &lt;- (acc/max :tx) :from [A (= id? ?id)] "><y>#</y><d>2018-01-16</d><h>06:35</h><w>mikerod</w>If you had a unique ID on all facts for example, you could just do
?l &lt;- (acc/max :tx) :from [A (= id? ?id)]
</z><z id="t1516084577000016" t="mikerod I’m not sure that makes much sense though. acc/max is intended to find the max among all facts. Accumulators are mostly for reasoning about aggregates. I may have misunderstood your usage you were looking for. "><y>#</y><d>2018-01-16</d><h>06:36</h><w>mikerod</w>I’m not sure that makes much sense though. acc/max is intended to find the max among all facts. Accumulators are mostly for reasoning about aggregates. I may have misunderstood your usage you were looking for. </z><z id="t1516085685000112" t="dadair The rule engine I work on takes the general from (state, action) -&gt; actions , where action and actions are actions to perform (in aggregate) to transition state to a new state (basically the RE is a reduce, but instead of reducing to a new state, it returns “diff” operations through querying the resulting state that external service(s) can use to transition the state). A difficulty that I’ve had in general with this pattern is that I need to track changes to state as rules propagate, and then insert output actions based on those changes. So for example, given an initial entity A {:id 1, :x true} , there may be cascading changes over the (short) life of the session that cause it to transition to any number of {true,false} values. I always want the stable result, so I have added tx values to track “time”. Given that, I may have a rule that “subscribes” to a number of those facts (e.g., all :id s), but I want the max :tx of each of those entities."><y>#</y><d>2018-01-16</d><h>06:54</h><w>dadair</w>The rule engine I work on takes the general from <code>(state, action) -&gt; actions</code>, where <code>action</code> and <code>actions</code> are actions to perform (in aggregate) to transition <code>state</code> to a new state (basically the RE is a reduce, but instead of reducing to a new state, it returns “diff” operations through querying the resulting state that external service(s) can use to transition the state). A difficulty that I’ve had in general with this pattern is that I need to track changes to <code>state</code> as rules propagate, and then insert output actions based on those changes. So for example, given an initial entity A <code>{:id 1, :x true}</code>, there may be cascading changes over the (short) life of the session that cause it to transition to any number of <code>{true,false}</code> values. I always want the stable result, so I have added <code>tx</code> values to track “time”. Given that, I may have a rule that “subscribes” to a number of those facts (e.g., <code>all</code> <code>:id</code>s), but I want the <code>max</code> <code>:tx</code> of each of those entities.</z><z id="t1516085734000117" t="dadair In summary: [?entities &lt;- (acc/all) :from [TimestampedEntity]] ;; ?entities =&gt; [{:id 1, :x true, :tx 1} {:id 1, :x false, :tx 2} {:id 2, :x true, :tx 3}] but I only want the latest :tx for each unique entity, so desired: ?entities =&gt; [{:id 1, :x false, :tx 2} {:id 2, :x true, :tx 3}]"><y>#</y><d>2018-01-16</d><h>06:55</h><w>dadair</w>In summary: <code>[?entities &lt;- (acc/all) :from [TimestampedEntity]] ;; ?entities =&gt; [{:id 1, :x true, :tx 1} {:id 1, :x false, :tx 2} {:id 2, :x true, :tx 3}]</code> but I only want the latest <code>:tx</code> for each unique entity, so desired: <code>?entities =&gt; [{:id 1, :x false, :tx 2} {:id 2, :x true, :tx 3}]</code></z><z id="t1516086027000152" t="dadair e.g., to calculate a ratio of true entities over all entities (but only for their final states)"><y>#</y><d>2018-01-16</d><h>07:00</h><w>dadair</w>e.g., to calculate a ratio of true entities over all entities (but only for their final states)</z><z id="t1516118534000763" t="mikerod @dadair if you use a variable binding bound to the :id field then the accumulator will give you the latest :tx per :id "><y>#</y><d>2018-01-16</d><h>16:02</h><w>mikerod</w>@dadair if you use a variable binding bound to the :id field then the accumulator will give you the latest :tx per :id </z><z id="t1516118696000096" t="mikerod [?latest &lt;- (acc/max :tx) :from [TsEntity (= ?id id)]] "><y>#</y><d>2018-01-16</d><h>16:04</h><w>mikerod</w><pre>[?latest &lt;- (acc/max :tx) :from [TsEntity (= ?id id)]]
</pre></z><z id="t1516118757000105" t="mikerod That’s the “latest :tx “ of each fact group where they are grouped by :id "><y>#</y><d>2018-01-16</d><h>16:05</h><w>mikerod</w>That’s the “latest :tx “ of each fact group where they are grouped by :id </z><z id="t1516155309000097" t="cfleming What is the logic by which class members from fact types are used to create local variables for the constraints?"><y>#</y><d>2018-01-17</d><h>02:15</h><w>cfleming</w>What is the logic by which class members from fact types are used to create local variables for the constraints?</z><z id="t1516155398000073" t="cfleming In clara.examples.java.shopping , there are some examples [Customer (= true VIP)] and [Order (&gt; total 200)] . I assume VIP is mapped to the isVIP() method and total is mapped to the getTotal() method?"><y>#</y><d>2018-01-17</d><h>02:16</h><w>cfleming</w>In <code>clara.examples.java.shopping</code>, there are some examples <code>[Customer (= true VIP)]</code> and <code>[Order (&gt; total 200)]</code>. I assume <code>VIP</code> is mapped to the <code>isVIP()</code> method and <code>total</code> is mapped to the <code>getTotal()</code> method?</z><z id="t1516155425000035" t="cfleming Are the rules around this defined anywhere, or could someone point me to the relevant DSL code?"><y>#</y><d>2018-01-17</d><h>02:17</h><w>cfleming</w>Are the rules around this defined anywhere, or could someone point me to the relevant DSL code?</z><z id="t1516155685000186" t="alex-dixon @cfleming https://github.com/cerner/clara-rules/blob/941b776221690edab4904e3728715d0680bd6121/src/main/clojure/clara/rules/compiler.clj#L308"><y>#</y><d>2018-01-17</d><h>02:21</h><w>alex-dixon</w>@cfleming <a href="https://github.com/cerner/clara-rules/blob/941b776221690edab4904e3728715d0680bd6121/src/main/clojure/clara/rules/compiler.clj#L308" target="_blank">https://github.com/cerner/clara-rules/blob/941b776221690edab4904e3728715d0680bd6121/src/main/clojure/clara/rules/compiler.clj#L308</a></z><z id="t1516155724000214" t="cfleming @alex-dixon Isn’t that dealing with unification vars?"><y>#</y><d>2018-01-17</d><h>02:22</h><w>cfleming</w>@alex-dixon Isn’t that dealing with unification vars?</z><z id="t1516155764000339" t="cfleming Oh, it looks like field-name-&gt;accessors-used , right?"><y>#</y><d>2018-01-17</d><h>02:22</h><w>cfleming</w>Oh, it looks like <code>field-name-&gt;accessors-used</code>, right?</z><z id="t1516155846000279" t="alex-dixon https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L149"><y>#</y><d>2018-01-17</d><h>02:24</h><w>alex-dixon</w><a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L149" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L149</a></z><z id="t1516155962000081" t="alex-dixon @cfleming Er. get-fields a few down from there what you’re looking for?"><y>#</y><d>2018-01-17</d><h>02:26</h><w>alex-dixon</w>@cfleming Er. get-fields a few down from there what you’re looking for?</z><z id="t1516155990000277" t="cfleming Yes, I think so - thanks!"><y>#</y><d>2018-01-17</d><h>02:26</h><w>cfleming</w>Yes, I think so - thanks!</z><z id="t1516317069000296" t="zylox so you essentially want a history as long as all members of that history are present"><y>#</y><d>2018-01-18</d><h>23:11</h><w>zylox</w>so you essentially want a history as long as all members of that history are present</z><z id="t1516317146000318" t="zylox given how much the tms relies on present state alone that would be quite a doozy"><y>#</y><d>2018-01-18</d><h>23:12</h><w>zylox</w>given how much the tms relies on present state alone that would be quite a doozy</z><z id="t1516317615000436" t="sparkofreason Yeah, digging around the code, I&apos;m not sure it even makes sense with how rete works. It seems like it would require some modification."><y>#</y><d>2018-01-18</d><h>23:20</h><w>sparkofreason</w>Yeah, digging around the code, I&apos;m not sure it even makes sense with how rete works. It seems like it would require some modification.</z><z id="t1516317696000371" t="sparkofreason Seems similar to a join-node, but has to appear in a different place in the network or something."><y>#</y><d>2018-01-18</d><h>23:21</h><w>sparkofreason</w>Seems  similar to a join-node, but has to appear in a different place in the network or something.</z><z id="t1516317777000049" t="zylox you could envisions something like layered sessions that join their nodes (3d memory from a visulization point of view) and query &quot;downward&quot; but thats all a ton of work"><y>#</y><d>2018-01-18</d><h>23:22</h><w>zylox</w>you could envisions something like layered sessions that join their nodes (3d memory from a visulization point of view) and query &quot;downward&quot; but thats all a ton of work</z><z id="t1516317785000432" t="zylox but ya i agree....doesnt really mesh with rete imo"><y>#</y><d>2018-01-18</d><h>23:23</h><w>zylox</w>but ya i agree....doesnt really mesh with rete imo</z><z id="t1516374247000545" t="mikerod @dave.dixon I mostly never would recommend many patterns that make pervasive use of insert-unconditional!"><y>#</y><d>2018-01-19</d><h>15:04</h><w>mikerod</w>@dave.dixon I mostly never would recommend many patterns that make pervasive use of <code>insert-unconditional!</code></z><z id="t1516374312000933" t="mikerod The one case I keep seeing that is difficult to work around is when needing to retract internally for something like “old events”. Other than that, I think it’s best to avoid. Even then, there are several RHS retract related issues outstanding that can be seen in the GitHub"><y>#</y><d>2018-01-19</d><h>15:05</h><w>mikerod</w>The one case I keep seeing that is difficult to work around is when needing to retract internally for something like “old events”. Other than that, I think it’s best to avoid. Even then, there are several RHS retract related issues outstanding that can be seen in the GitHub</z><z id="t1516374328000554" t="mikerod I’m looking at your example to see if I see anything you could do"><y>#</y><d>2018-01-19</d><h>15:05</h><w>mikerod</w>I’m looking at your example to see if I see anything you could do</z><z id="t1516376480000378" t="mikerod Woops missing a part in that, will edit"><y>#</y><d>2018-01-19</d><h>15:41</h><w>mikerod</w>Woops missing a part in that, will edit</z><z id="t1516377487001020" t="sparkofreason @mikerod Interesting. Let me ponder that."><y>#</y><d>2018-01-19</d><h>15:58</h><w>sparkofreason</w>@mikerod Interesting. Let me ponder that.</z><z id="t1516377568000570" t="mikerod I am missing a part still. Trying to get that done. The concept I think can work though in terms of marking a timestamp at each stage. However, the above fails because it is letting TMS remove the intermediary collections from previous runs"><y>#</y><d>2018-01-19</d><h>15:59</h><w>mikerod</w>I am missing a part still. Trying to get that done. The concept I think can work though in terms of marking a timestamp at each stage. However, the above fails because it is letting TMS remove the intermediary collections from previous runs</z><z id="t1516377614000424" t="mikerod I think you have to signal each “stage” as an explicit fact though. Without something like that, the network never knows what each conceptual step is to you. It doesn’t distinguish one fire-rules from another really"><y>#</y><d>2018-01-19</d><h>16:00</h><w>mikerod</w>I think you have to signal each “stage” as an explicit fact though. Without something like that, the network never knows what each conceptual step is to you. It doesn’t distinguish one <code>fire-rules</code> from another really</z><z id="t1516377634000619" t="mikerod So usually when that sort of info is missing, you end up adding it as a fact to represent the idea"><y>#</y><d>2018-01-19</d><h>16:00</h><w>mikerod</w>So usually when that sort of info is missing, you end up adding it as a fact to represent the idea</z><z id="t1516380754000528" t="mikerod @dave.dixon I updated it now"><y>#</y><d>2018-01-19</d><h>16:52</h><w>mikerod</w>@dave.dixon I updated it now</z><z id="t1516380789000084" t="mikerod It is hard to say that it exactly captures what you want. If you look at :before-retract though, you get the multiple accumulated groups idea that you were wanting"><y>#</y><d>2018-01-19</d><h>16:53</h><w>mikerod</w>It is hard to say that it exactly captures what you want. If you look at <code>:before-retract</code> though, you get the multiple accumulated groups idea that you were wanting</z><z id="t1516380803000420" t="mikerod Just requires each fact to be externally stamped with the same “timestamp” as the “fire event” that they were inserted with"><y>#</y><d>2018-01-19</d><h>16:53</h><w>mikerod</w>Just requires each fact to be externally stamped with the same “timestamp” as the “fire event” that they were inserted with</z><z id="t1516380814000327" t="mikerod I couldn’t work out a way for rules to express that stamping due to logical TMS."><y>#</y><d>2018-01-19</d><h>16:53</h><w>mikerod</w>I couldn’t work out a way for rules to express that stamping due to logical TMS.</z><z id="t1516380835000180" t="mikerod Retracting is slightly harder, since you need to retract all matching facts across all timestamps (at least from your sort of example)"><y>#</y><d>2018-01-19</d><h>16:53</h><w>mikerod</w>Retracting is slightly harder, since you need to retract all matching facts across all timestamps (at least from your sort of example)</z><z id="t1516380861001006" t="mikerod This retraction results in all prior groups being updated as well to remove the fact that is gone. That isn’t exactly what you wanted I dont’ think, but it conveys somewhat similar information."><y>#</y><d>2018-01-19</d><h>16:54</h><w>mikerod</w>This retraction results in all prior groups being updated as well to remove the fact that is gone. That isn’t exactly what you wanted I dont’ think, but it conveys somewhat similar information.</z><z id="t1516381052000568" t="mikerod The accumulation for Nums could tag it with the FireEvent ts it went with. Then that could be used to do a duplicate removal and/or “newest” result lookup on the :before-retract vs :after-retract"><y>#</y><d>2018-01-19</d><h>16:57</h><w>mikerod</w>The accumulation for <code>Nums</code> could tag it with the <code>FireEvent</code> <code>ts</code> it went with. Then that could be used to do a duplicate removal and/or “newest” result lookup on the <code>:before-retract</code> vs <code>:after-retract</code></z><z id="t1516388275000579" t="wparker @dave.dixon Perhaps a model like the following might work if you’re OK with accumulating some “garbage” over time. - Logically insert a &quot;Request&quot; fact. - Have a query like [Request (= ?id id)] [:not [RequestResponse (= ?id id)]]. - The client would externally insert a RequestResponse fact when it wanted to &quot;close&quot; a request. - A todo could be done like [Request (= ?id id)] [:not [RequestResponse (= ?id id)]] =&gt; (insert! (-&gt;ToDo ?id)). Then further logic downstream could dispatch on the TODOs as required, say if too many were outstanding. If you need to clean up garbage, it almost sounds like you’re asking about retracting a fact without removing downstream insertions due to it.. is that on target at all?"><y>#</y><d>2018-01-19</d><h>18:57</h><w>wparker</w>@dave.dixon Perhaps a model like the following might work if you’re OK with accumulating some “garbage” over time.
<pre>- Logically insert a &quot;Request&quot; fact.
- Have a query like [Request (= ?id id)] [:not [RequestResponse (= ?id id)]].
- The client would externally insert a RequestResponse fact when it wanted to &quot;close&quot; a request.
- A todo could be done like [Request (= ?id id)] [:not [RequestResponse (= ?id id)]] =&gt; (insert! (-&gt;ToDo ?id)).
Then further logic downstream could dispatch on the TODOs as required, say if too many were outstanding.
</pre>
If you need to clean up garbage, it almost sounds like you’re asking about retracting a fact without removing downstream insertions due to it.. is that on target at all?</z><z id="t1516390099000106" t="sparkofreason @wparker I think in your 4th bullet you would remove the :not . But otherwise, that&apos;s basically it. The &quot;garbage&quot; is okay, I&apos;m experimenting with rulesets that enforce logical consistency over time, e.g. of some process of interacting with the user and an external server. So the &quot;garbage&quot; is really the history. What I&apos;m finding is that you generally have some &quot;anchor&quot; facts from which the rest of the process logic flows, so when you change the anchor the &quot;garbage&quot; gets collected. For example, in the conduit example, an anchor fact is the filter which retrieves a set of articles from the server, So articles wind up inserted with conditional dependence on the filter fact. Then the user can do a number of things, like change the favorite status of an article, edit if they are the author, etc. So all of that history gets accumulated, but when you change the filter it&apos;s all retracted."><y>#</y><d>2018-01-19</d><h>19:28</h><w>sparkofreason</w>@wparker I think in your 4th bullet you would remove the <code>:not</code>. But otherwise, that&apos;s basically it. The &quot;garbage&quot; is okay, I&apos;m experimenting with rulesets that enforce logical consistency over time, e.g. of some process of interacting with the user and an external server. So the &quot;garbage&quot; is really the history. What I&apos;m finding is that you generally have some &quot;anchor&quot; facts from which the rest of the process logic flows, so when you change the anchor the &quot;garbage&quot; gets collected. For example, in the conduit example, an anchor fact is the filter which retrieves a set of articles from the server, So articles wind up inserted with conditional dependence on the filter fact. Then the user can do a number of things, like change the favorite status of an article, edit if they are the author, etc. So all of that history gets accumulated, but when you change the filter it&apos;s all retracted.</z><z id="t1516390339000068" t="sparkofreason @wparker It wasn&apos;t specifically that I was looking to retract a fact without removing downstream insertions, rather modify the set of facts that went into an accumulator without retracting downstream insertions created by previous activations of the accumulator rule. It makes sense from a purely logical standpoint (I think), but the semantics of accumulators in the rule network are slightly different - not wrong, just making a different logical assertion, and one that is feasible within rule network architecture."><y>#</y><d>2018-01-19</d><h>19:32</h><w>sparkofreason</w>@wparker It wasn&apos;t specifically that I was looking to retract a fact without removing downstream insertions, rather modify the set of facts that went into an accumulator without retracting downstream insertions created by previous activations of the accumulator rule. It makes sense from a purely logical standpoint (I think), but the semantics of accumulators in the rule network are slightly different - not wrong, just making a different logical assertion, and one that is feasible within rule network architecture.</z><z id="t1517188686000157" t="tcarls If I have records having a field used for ordering -- like a timestamp -- and want to make rules that reason about or refer to &quot;the immediately preceding X&quot;, or &quot;the most recent X to have attribute Y&quot;, is Clara well-suited to the purpose?"><y>#</y><d>2018-01-29</d><h>01:18</h><w>tcarls</w>If I have records having a field used for ordering -- like a timestamp -- and want to make rules that reason about or refer to &quot;the immediately preceding X&quot;, or &quot;the most recent X to have attribute Y&quot;, is Clara well-suited to the purpose?</z><z id="t1517188714000149" t="tcarls (&quot;immediately preceding&quot; relative to another record, that is, as opposed to, say, an accumulator reflecting the globally most recent insert/assertion)."><y>#</y><d>2018-01-29</d><h>01:18</h><w>tcarls</w>(&quot;immediately preceding&quot; relative to another record, that is, as opposed to, say, an accumulator reflecting the globally most recent insert/assertion).</z><z id="t1517194472000013" t="dadair It can be, I’m currently using it to reason about entities that change over time. I have to admit though that I don’t find it that easy to model (although I could be doing things horribly wrong)."><y>#</y><d>2018-01-29</d><h>02:54</h><w>dadair</w>It can be, I’m currently using it to reason about entities that change over time. I have to admit though that I don’t find it that easy to model (although I could be doing things horribly wrong).</z><z id="t1517194562000119" t="dadair e.g., I have entities of type A that can change over time (tracked through a timestamp), and other entities of type B that can change over time in response to the changes to type A (that is, there is a relation B = f(A)) , and other entities of type C = f(B) that also change over time in response to changes in B"><y>#</y><d>2018-01-29</d><h>02:56</h><w>dadair</w>e.g., I have entities of type <code>A</code> that can change over time (tracked through a timestamp), and other entities of type <code>B</code> that can change over time in response to the changes to type <code>A</code> (that is, there is a relation <code>B = f(A))</code>, and other entities of type <code>C = f(B)</code> that also change over time in response to changes in B</z><z id="t1517194626000038" t="dadair I find the rules I’m writing to be quite.. cumbersome, and I find myself inserting special facts just to facilitate rule propagation, to prevent e.g., infinite activations"><y>#</y><d>2018-01-29</d><h>02:57</h><w>dadair</w>I find the rules I’m writing to be quite.. cumbersome, and I find myself inserting special facts just to facilitate rule propagation, to prevent e.g., infinite activations</z><z id="t1517194745000134" t="dadair however, the challenges I face come from the /fact/ that changes are inserted as a consequence of rules, if all history was known prior to rule activation, and I wasn’t inserting new facts from rules (that is, growing/extending time within a given session’s fire-rules ), and I was simply querying certain states throughout a known and unchanging history, that would be perfectly suitable"><y>#</y><d>2018-01-29</d><h>02:59</h><w>dadair</w>however, the challenges I face come from the /fact/ that changes are inserted as a consequence of rules, if all history was known prior to rule activation, and I wasn’t inserting new facts from rules (that is, growing/extending <code>time</code> within a given session’s <code>fire-rules</code>), and I was simply querying certain states throughout a known and unchanging history, that would be perfectly suitable</z><z id="t1517239247000212" t="mikerod @tcarls I think that @dadair has some good things to think about in terms of what you are trying to accomplish. Some of it varies according to the situation. Here is an example that I think meets at least one part of your question though (defrule immediately-preceding [A (= timestamp ?ts)] [?preceding &lt;- (acc/max :timestamp :returns-fact true) :from [B (&lt; timestamp ?ts)]] =&gt; &lt;etc&gt;) "><y>#</y><d>2018-01-29</d><h>15:20</h><w>mikerod</w>@tcarls I think that @dadair has some good things to think about in terms of what you are trying to accomplish. Some of it varies according to the situation. 
Here is an example that I think meets at least one part of your question though
<pre>(defrule immediately-preceding
  [A (= timestamp ?ts)]
  [?preceding &lt;- (acc/max :timestamp :returns-fact true) :from [B (&lt; timestamp ?ts)]]
  =&gt;
  &lt;etc&gt;)
</pre></z><z id="t1517239317000312" t="mikerod You can use an accumulator that constrains the facts that it accumulates over. By doing this, you can match things more specific/localized/“parameterized”, rather than “global” accumulations."><y>#</y><d>2018-01-29</d><h>15:21</h><w>mikerod</w>You can use an accumulator that constrains the facts that it accumulates over. By doing this, you can match things more specific/localized/“parameterized”, rather than “global” accumulations.</z><z id="t1517241828000303" t="tcarls @mikerod, that&apos;s extremely helpful; thank you."><y>#</y><d>2018-01-29</d><h>16:03</h><w>tcarls</w>@mikerod, that&apos;s extremely helpful; thank you.</z><z id="t1517328327000629" t="afurmanov Hello, I have question about acc/all behavior, the following snippet of code: (ns rules-acc-all (require [clara.rules :as rules] [clara.rules.accumulators :as acc] [clojure.pprint :refer [pprint]])) (defrecord Customer [id]) (defrecord Reward [id]) (defrecord CustomerReward [id customer-id reward-id]) (rules/defrule quals [Customer (= ?C id)] [Reward (= ?R id) (= id &quot;bonus-1&quot;)] ;;[?items &lt;- (acc/all) :from [CustomerReward (= id ?I) (= ?C customer-id)]] [?items &lt;- (acc/all) :from [CustomerReward (= ?C customer-id)]] =&gt; (pprint {&quot;?items&quot; ?items})) (let [session (-&gt; (rules/mk-session &apos;rules-acc-all) (rules/insert (-&gt;Customer &quot;customer-1&quot;) (-&gt;Reward &quot;bonus-1&quot;) (-&gt;Reward &quot;offer-1&quot;) (-&gt;Reward &quot;offer-2&quot;) (-&gt;CustomerReward &quot;cr-1&quot; &quot;customer-1&quot; &quot;offer-1&quot;) (-&gt;CustomerReward &quot;cr-2&quot; &quot;customer-1&quot; &quot;offer-2&quot;))) fired (rules/fire-rules session)] ) "><y>#</y><d>2018-01-30</d><h>16:05</h><w>afurmanov</w>Hello, I have question about <code>acc/all</code> behavior, the following snippet of code: <pre>(ns rules-acc-all
  (require [clara.rules :as rules]
           [clara.rules.accumulators :as acc]
           [clojure.pprint :refer [pprint]]))

(defrecord Customer [id])
(defrecord Reward [id])
(defrecord CustomerReward [id customer-id reward-id])

(rules/defrule quals
  [Customer (= ?C id)]
  [Reward (= ?R id) (= id &quot;bonus-1&quot;)]
  ;;[?items &lt;- (acc/all) :from [CustomerReward (= id ?I) (= ?C customer-id)]]
  [?items &lt;- (acc/all) :from [CustomerReward (= ?C customer-id)]]
  =&gt;
  (pprint {&quot;?items&quot; ?items}))


(let [session (-&gt; (rules/mk-session &apos;rules-acc-all)
                  (rules/insert (-&gt;Customer &quot;customer-1&quot;)
                                (-&gt;Reward &quot;bonus-1&quot;)
                                (-&gt;Reward &quot;offer-1&quot;)
                                (-&gt;Reward &quot;offer-2&quot;)
                                (-&gt;CustomerReward &quot;cr-1&quot; &quot;customer-1&quot; &quot;offer-1&quot;)
                                (-&gt;CustomerReward &quot;cr-2&quot; &quot;customer-1&quot; &quot;offer-2&quot;)))
      fired (rules/fire-rules session)]
  )
</pre></z><z id="t1517328348000071" t="afurmanov Prints {&quot;?items&quot; [{:id &quot;cr-1&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-1&quot;} {:id &quot;cr-2&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-2&quot;}]} "><y>#</y><d>2018-01-30</d><h>16:05</h><w>afurmanov</w>Prints <pre>{&quot;?items&quot;
 [{:id &quot;cr-1&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-1&quot;}
  {:id &quot;cr-2&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-2&quot;}]}
</pre></z><z id="t1517328364000005" t="afurmanov i.e. ?items contain two elements."><y>#</y><d>2018-01-30</d><h>16:06</h><w>afurmanov</w>i.e. <code>?items</code> contain two elements.</z><z id="t1517328440000673" t="afurmanov However if condition [?items &lt;- (acc/all) :from [CustomerReward (= ?C customer-id)]] is replaced with [?items &lt;- (acc/all) :from [CustomerReward (= id ?I) (= ?C customer-id)]] (pretty much same with unification added for CustomerReward (= id ?I) the the output would be:"><y>#</y><d>2018-01-30</d><h>16:07</h><w>afurmanov</w>However if condition <code>[?items &lt;- (acc/all) :from [CustomerReward (= ?C customer-id)]]</code> is replaced with <code>[?items &lt;- (acc/all) :from [CustomerReward (= id ?I) (= ?C customer-id)]]</code> (pretty much same with unification added for CustomerReward <code>(= id ?I)</code> the the output would be:</z><z id="t1517328455000366" t="afurmanov {&quot;?items&quot; [{:id &quot;cr-1&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-1&quot;}]} {&quot;?items&quot; [{:id &quot;cr-2&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-2&quot;}]}"><y>#</y><d>2018-01-30</d><h>16:07</h><w>afurmanov</w><pre>{&quot;?items&quot;
 [{:id &quot;cr-1&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-1&quot;}]}
{&quot;?items&quot;
 [{:id &quot;cr-2&quot;, :customer-id &quot;customer-1&quot;, :reward-id &quot;offer-2&quot;}]}</pre></z><z id="t1517328476000768" t="afurmanov I.e. ?items contain single element, but rule gets triggered twice."><y>#</y><d>2018-01-30</d><h>16:07</h><w>afurmanov</w>I.e. ?items contain single element, but rule gets triggered twice.</z><z id="t1517328566000051" t="afurmanov I am trying to wrap my mind around this, but cannot - those two rules set look pretty much same to me"><y>#</y><d>2018-01-30</d><h>16:09</h><w>afurmanov</w>I am trying to wrap my mind around this, but cannot - those two rules set look pretty much same to me</z><z id="t1517331671000711" t="sparkofreason I believe it&apos;s because when you specify (= id ?I) in the accumulator, clara will now make a unique binding for each unique value of id , so the rule fires once for each id of CustomerReward rather than accumulating over all CustomerReward &apos;s with different id &apos;s."><y>#</y><d>2018-01-30</d><h>17:01</h><w>sparkofreason</w>I believe it&apos;s because when you specify <code>(= id ?I)</code> in the accumulator, clara will now make a unique binding for each unique value of <code>id</code>, so the rule fires once for each <code>id</code> of <code>CustomerReward</code> rather than accumulating over all <code>CustomerReward</code>&apos;s with different <code>id</code>&apos;s.</z><z id="t1517332344000194" t="afurmanov Thanks @dave.dixon - that kind of explains it. I guess my confusion was due thinking that binding (= id ?I) is kind of &quot;local&quot; to accumulator, in other words it works as sub-select in SQL, however it appears such binding makes ?I &quot;available&quot; to &quot;outer scope&quot;, i.e. I could refer it for unification in clauses which are siblings of accumulator."><y>#</y><d>2018-01-30</d><h>17:12</h><w>afurmanov</w>Thanks @dave.dixon - that kind of explains it. I guess my confusion was due thinking that binding <code>(= id ?I)</code> is kind of &quot;local&quot; to accumulator, in other words it works as sub-select in SQL, however it appears such binding makes <code>?I</code> &quot;available&quot; to &quot;outer scope&quot;, i.e. I could refer it for unification in clauses which are siblings of accumulator.</z><z id="t1517332394000524" t="sparkofreason Correct. Or you could refer to ?I in the RHS of the rule, where it would have to be unique."><y>#</y><d>2018-01-30</d><h>17:13</h><w>sparkofreason</w>Correct. Or you could refer to <code>?I</code> in the RHS of the rule, where it would have to be unique.</z><z id="t1517332417000611" t="afurmanov Yep, then it makes sense"><y>#</y><d>2018-01-30</d><h>17:13</h><w>afurmanov</w>Yep, then it makes sense</z><z id="t1517364441000198" t="tcarls I&apos;m seeing rules no longer firing after I reloaded the namespace that contains them in the REPL, even if I create an entirely new session with (mk-session :cache false) . What am I missing?"><y>#</y><d>2018-01-31</d><h>02:07</h><w>tcarls</w>I&apos;m seeing rules no longer firing after I reloaded the namespace that contains them in the REPL, even if I create an entirely new session with <code>(mk-session :cache false)</code>. What am I missing?</z><z id="t1517373928000031" t="dadair @tcarls might need a code example, numerous things could be happening, depending on the state of the namespace"><y>#</y><d>2018-01-31</d><h>04:45</h><w>dadair</w>@tcarls might need a code example, numerous things could be happening, depending on the state of the namespace</z><z id="t1517415115000980" t="tcarls @dadair, in hindsight, I&apos;m pretty sure what&apos;s happening is caused by new defrecord s being run, but trying to run rules against data from an atom that includes (expensive-to-calculate) cached previous instances of input data. Going to move the definitions into their own namespace; I expect that&apos;ll help."><y>#</y><d>2018-01-31</d><h>16:11</h><w>tcarls</w>@dadair, in hindsight, I&apos;m pretty sure what&apos;s happening is caused by new <code>defrecord</code>s being run, but trying to run rules against data from an atom that includes (expensive-to-calculate) cached previous instances of input data. Going to move the definitions into their own namespace; I expect that&apos;ll help.</z><z id="t1517415173000635" t="mikerod @tcarls that is common"><y>#</y><d>2018-01-31</d><h>16:12</h><w>mikerod</w>@tcarls that is common</z><z id="t1517415213000129" t="mikerod The potemkin lib had some extensions to defrecord and other related macros to avoid that sort of redefinition of classes to help with reloading workflows in the REPL"><y>#</y><d>2018-01-31</d><h>16:13</h><w>mikerod</w>The <code>potemkin</code> lib had some extensions to <code>defrecord</code> and other related macros to avoid that sort of redefinition of classes to help with reloading workflows in the REPL</z><z id="t1517415234000406" t="mikerod I think one workaround people do for Clara has been to do defrecord in a separate ns that you don’t plan to reload much"><y>#</y><d>2018-01-31</d><h>16:13</h><w>mikerod</w>I think one workaround people do for Clara has been to do <code>defrecord</code> in a separate ns that you don’t plan to reload much</z><z id="t1517415248000539" t="mikerod So the rules don’t get mismatched definitions of the “same class”"><y>#</y><d>2018-01-31</d><h>16:14</h><w>mikerod</w>So the rules don’t get mismatched definitions of the “same class”</z><z id="t1517437150000278" t="tcarls One thing that&apos;s surprising me in using Clara is how one needs to take explicit steps to avoid getting two equal records created if arriving at the same fact via two different rules."><y>#</y><d>2018-01-31</d><h>22:19</h><w>tcarls</w>One thing that&apos;s surprising me in using Clara is how one needs to take explicit steps to avoid getting two equal records created if arriving at the same fact via two different rules.</z><z id="t1517438438000082" t="mikerod @tcarls yeah, there are pro’s and con’s to that"><y>#</y><d>2018-01-31</d><h>22:40</h><w>mikerod</w>@tcarls yeah, there are pro’s and con’s to that</z><z id="t1517438453000298" t="mikerod There are definitely use-cases where “cardinality” matters"><y>#</y><d>2018-01-31</d><h>22:40</h><w>mikerod</w>There are definitely use-cases where “cardinality” matters</z><z id="t1517438476000283" t="mikerod I’ve had quite a few of those before. So if you “removed the duplicates” you’d fail to meet the needs of someone who wanted to count things"><y>#</y><d>2018-01-31</d><h>22:41</h><w>mikerod</w>I’ve had quite a few of those before. So if you “removed the duplicates” you’d fail to meet the needs of someone who wanted to count things</z><z id="t1517438483000447" t="mikerod For whatever purpose"><y>#</y><d>2018-01-31</d><h>22:41</h><w>mikerod</w>For whatever purpose</z><z id="t1517438521000344" t="mikerod In Drools (popular Java-based rules engine), they went with “logical inserts” never are duplicated, but “unconditional inserts” are duplicated if they are not identical?"><y>#</y><d>2018-01-31</d><h>22:42</h><w>mikerod</w>In Drools (popular Java-based rules engine), they went with “logical inserts” never are duplicated, but “unconditional inserts” are duplicated if they are not <code>identical?</code></z><z id="t1517438535000267" t="mikerod It was nice, when you really just didn’t want duplicates, but difficult to work with when you did"><y>#</y><d>2018-01-31</d><h>22:42</h><w>mikerod</w>It was nice, when you really just didn’t want duplicates, but difficult to work with when you did</z><z id="t1517438554000006" t="mikerod In Clara, if you need some “single count” fact in the end, you can just use an aggregation sort of rule"><y>#</y><d>2018-01-31</d><h>22:42</h><w>mikerod</w>In Clara, if you need some “single count” fact in the end, you can just use an aggregation sort of rule</z><z id="t1517438737000093" t="mikerod I do think it could be interesting if Clara had an options where it made working memory “set-like” and duplicates didn’t show up. There are definitely costs to doing this though."><y>#</y><d>2018-01-31</d><h>22:45</h><w>mikerod</w>I do think it could be interesting if Clara had an options where it made working memory “set-like” and duplicates didn’t show up. There are definitely costs to doing this though.</z><z id="t1517440717000066" t="tcarls headscratch"><y>#</y><d>2018-01-31</d><h>23:18</h><w>tcarls</w>headscratch</z><z id="t1517441050000242" t="tcarls {:lhs [{:type pdfsort.types.Warning, :constraints [], :fact-binding :?warning}], :params #{}, :name &quot;pdfsort.core/get-warnings&quot;} is invalid or not included in the rule base. ...seems to be happening consistently for me right now when invoking code from lein run , but not when invoking the same functions from Emacs/Cider."><y>#</y><d>2018-01-31</d><h>23:24</h><w>tcarls</w><pre>{:lhs [{:type pdfsort.types.Warning, :constraints [], :fact-binding :?warning}], :params #{}, :name &quot;pdfsort.core/get-warnings&quot;} is invalid or not included in the rule base.
</pre>

...seems to be happening consistently for me right now when invoking code from <code>lein run</code>, but not when invoking the same functions from Emacs/Cider.</z><z id="t1517441598000307" t="dadair @tcarls where is the mk-session you’re using (e.g., same ns as the rule? other ns?), and what does the function call look like?"><y>#</y><d>2018-01-31</d><h>23:33</h><w>dadair</w>@tcarls where is the <code>mk-session</code> you’re using (e.g., same ns as the rule? other ns?), and what does the function call look like?</z><z id="t1517441622000462" t="dadair and can you post a snippet of the rule?"><y>#</y><d>2018-01-31</d><h>23:33</h><w>dadair</w>and can you post a snippet of the rule?</z><z id="t1517445022000194" t="tcarls @dadair, same ns, called from the -main function with :cache false . The get-warnings rule is basically as simple as the above implies -- it just retrieves every single record we have of type Warning with no filters/joins/etc: (r/defquery get-warnings [] [?warning &lt;- Warning])"><y>#</y><d>2018-02-01</d><h>00:30</h><w>tcarls</w>@dadair, same ns, called from the <code>-main</code> function with <code>:cache false</code>. The <code>get-warnings</code> rule is basically as simple as the above implies -- it just retrieves every single record we have of type Warning with no filters/joins/etc: <code>(r/defquery get-warnings [] [?warning &lt;- Warning])</code></z><z id="t1517446096000386" t="tcarls Hmm. Unrelated issue, but I have a theory on why I&apos;m getting more fact insertions than I expected. Looking through the explain output... {:ns-name pdfsort.core, :lhs [{:type pdfsort.types.Document, :constraints [(= ?type (or name-type header-type))], :fact-binding :?doc}], :rhs (do (r/insert! (-&gt;DocumentType ?doc ?type))), :name &quot;pdfsort.core/use-document-type&quot;} I expected the (or name-type header-type) to mean that we bind the first non-falsey item of name-type or header-type to ?type , but it looks like it actually results in both paths being followed. Changing it to (if name-type name-type header-type) results in the initially-expected behavior, of performing one DocumentType insertion per Document."><y>#</y><d>2018-02-01</d><h>00:48</h><w>tcarls</w>Hmm. Unrelated issue, but I have a theory on why I&apos;m getting more fact insertions than I expected. Looking through the <code>explain</code> output...
<pre>{:ns-name pdfsort.core,
   :lhs
   [{:type pdfsort.types.Document,
     :constraints [(= ?type (or name-type header-type))],
     :fact-binding :?doc}],
   :rhs (do (r/insert! (-&gt;DocumentType ?doc ?type))),
   :name &quot;pdfsort.core/use-document-type&quot;}
</pre>
I expected the <code>(or name-type header-type)</code> to mean that we bind the first non-falsey item of <code>name-type</code> or <code>header-type</code> to <code>?type</code>, but it looks like it actually results in both paths being followed. Changing it to <code>(if name-type name-type header-type)</code> results in the initially-expected behavior, of performing one DocumentType insertion per Document.</z><z id="t1517500205000146" t="wparker @U2V9F98N8 I’d expect the or in the above rule to be short-circuiting i.e. just clojure.core/or. Something like this is a Clara-specific non-short-circuiting or: [:or [DocumentType1] [DocumentType2]] but that doesn’t apply to the case you describe; note the keyword :or not the function invocation of “or”. If you can create a reproducing case it would be helpful if you could log a GitHub issue - tbh I suspect something else is going on, but you never know"><y>#</y><d>2018-02-01</d><h>15:50</h><r>wparker</r>@U2V9F98N8 I’d expect the or in the above rule to be short-circuiting i.e. just clojure.core/or.  Something like this is a Clara-specific non-short-circuiting or: <pre>[:or [DocumentType1] [DocumentType2]] </pre> but that doesn’t apply to the case you describe; note the keyword :or not the function invocation of “or”.  If you can create a reproducing case it would be helpful if you could log a GitHub issue - tbh I suspect something else is going on, but you never know</z><z id="t1517606212000174" t="mjmeintjes What&apos;s the best way to ensure that a fact doesn&apos;t get inserted twice. Is there a way to ensure that duplicate facts don&apos;t get inserted into the same session?"><y>#</y><d>2018-02-02</d><h>21:16</h><w>mjmeintjes</w>What&apos;s the best way to ensure that a fact doesn&apos;t get inserted twice. Is there a way to ensure that duplicate facts don&apos;t get inserted into the same session?</z><z id="t1517607029000361" t="mikerod @mjmeintjes I talked about this in a few posts above if you can see them?"><y>#</y><d>2018-02-02</d><h>21:30</h><w>mikerod</w>@mjmeintjes I talked about this in a few posts above if you can see them?</z><z id="t1517607052000341" t="mikerod I discussed “cardinality” of equal facts in clara and ways to work with it"><y>#</y><d>2018-02-02</d><h>21:30</h><w>mikerod</w>I discussed “cardinality” of equal facts in clara and ways to work with it</z><z id="t1517607056000261" t="mikerod and tradeoffs etc"><y>#</y><d>2018-02-02</d><h>21:30</h><w>mikerod</w>and tradeoffs etc</z><z id="t1517607639000358" t="mjmeintjes Thanks for the information. I was thinking more about how to efficiently update the session - for example, I have a list of rows from the database. Before firing the rules I need to make sure that all the db rows are included in the session. However, I do not want all the rules to be inserted each time (which causes lots of duplicates), and I also don&apos;t want the session to be recreated each time. What I&apos;ve done now is create a query to retrieve the already inserted rules from the session, and then I&apos;m comparing that against the db rows, and then I only insert the new ones. I was just wondering whether that is the best solution."><y>#</y><d>2018-02-02</d><h>21:40</h><w>mjmeintjes</w>Thanks for the information. I was thinking more about how to efficiently update the session - for example, I have a list of rows from the database. Before firing the rules I need to make sure that all the db rows are included in the session. However, I do not want all the rules to be inserted each time (which causes lots of duplicates), and I also don&apos;t want the session to be recreated each time. What I&apos;ve done now is create a query to retrieve the already inserted rules from the session, and then I&apos;m comparing that against the db rows, and then I only insert the new ones. I was just wondering whether that is the best solution.</z><z id="t1517607958000178" t="mikerod @mjmeintjes I think that is a fine way to do it. I think there may be a potential enhancement to clara to do something like an “update” of facts and/or a “mode” that had the working memory act in a set-based way there weren’t duplicates. For now though, the external query idea is good if it can work for you"><y>#</y><d>2018-02-02</d><h>21:45</h><w>mikerod</w>@mjmeintjes I think that is a fine way to do it. I think there may be a potential enhancement to clara to do something like an “update” of facts and/or a “mode” that had the working memory act in a set-based way there weren’t duplicates. For now though, the external query idea is good if it can work for you</z><z id="t1517608108000031" t="mjmeintjes Yeah, being able to efficiently update the session would be great, as each time I&apos;ve used Clara that&apos;s something that I&apos;ve run up against. The only problem with the query approach is that queries are only updated once fire-rules has run, which means you can still get duplicates if you aren&apos;t careful to run fire-rules before inserting any new data."><y>#</y><d>2018-02-02</d><h>21:48</h><w>mjmeintjes</w>Yeah, being able to efficiently update the session would be great, as each time I&apos;ve used Clara that&apos;s something that I&apos;ve run up against. The only problem with the query approach is that queries are only updated once <code>fire-rules</code> has run, which means you can still get duplicates if you aren&apos;t careful to run <code>fire-rules</code> before inserting any new data.</z><z id="t1517608346000400" t="mikerod @mjmeintjes Yeah, you should never query prior to fire-rules . I’d call that an “undefined” state"><y>#</y><d>2018-02-02</d><h>21:52</h><w>mikerod</w>@mjmeintjes Yeah, you should never query prior to <code>fire-rules</code>. I’d call that an “undefined” state</z><z id="t1517608375000241" t="mikerod Clara does some “lazy” sort of batching that isn’t forced until fire-rules . It can do some good optimizations with this and could even get more “lazy” in the future I’d think."><y>#</y><d>2018-02-02</d><h>21:52</h><w>mikerod</w>Clara does some “lazy” sort of batching that isn’t forced until <code>fire-rules</code>. It can do some good optimizations with this and could even get more “lazy” in the future I’d think.</z><z id="t1517608411000492" t="mikerod I think it can be difficult to do “logical updates” to facts with what Clara currently offers"><y>#</y><d>2018-02-02</d><h>21:53</h><w>mikerod</w>I think it can be difficult to do “logical updates” to facts with what Clara currently offers</z><z id="t1517608466000118" t="mikerod it relies basically entirely on the caller to query facts and figure out what inserts/retracts to make externally. That is if the rules are going to be written in a way that can smoothly work with the truth maintenance system and logical inserts (ie not insert-unconditional! and right-hand-side based retract! )."><y>#</y><d>2018-02-02</d><h>21:54</h><w>mikerod</w>it relies basically entirely on the caller to query facts and figure out what inserts/retracts to make externally. That is if the rules are going to be written in a way that can smoothly work with the truth maintenance system and logical inserts (ie not <code>insert-unconditional!</code> and right-hand-side based <code>retract!</code>).</z><z id="t1517608476000531" t="mikerod These sort of discussions have came up quite a bit here lately."><y>#</y><d>2018-02-02</d><h>21:54</h><w>mikerod</w>These sort of discussions have came up quite a bit here lately.</z><z id="t1517608509000107" t="mikerod I wrote this a while back http://www.metasimple.org/2017/12/23/clara-updating-facts.html Not sure if it is really useful to you. You seem to already have a setup you’ve been using to do your de-duping anyways"><y>#</y><d>2018-02-02</d><h>21:55</h><w>mikerod</w>I wrote this a while back <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a>
Not sure if it is really useful to you. You seem to already have a setup you’ve been using to do your de-duping anyways</z><z id="t1517608560000532" t="mjmeintjes Thanks for that post, I&apos;ll have a read. Love reading information about Clara, as it is such a great programming model. Always trying to find places to use it."><y>#</y><d>2018-02-02</d><h>21:56</h><w>mjmeintjes</w>Thanks for that post, I&apos;ll have a read. Love reading information about Clara, as it is such a great programming model. Always trying to find places to use it.</z><z id="t1517608643000102" t="mikerod Well that’s good."><y>#</y><d>2018-02-02</d><h>21:57</h><w>mikerod</w>Well that’s good.</z><z id="t1517608673000240" t="mikerod Yeah, I’d like to try out some ideas to deal with these sorts of things. I think some sort of rule-triggered “update” would be interesting."><y>#</y><d>2018-02-02</d><h>21:57</h><w>mikerod</w>Yeah, I’d like to try out some ideas to deal with these sorts of things. I think some sort of rule-triggered “update” would be interesting.</z><z id="t1517608685000082" t="mikerod As well as externally specified updates"><y>#</y><d>2018-02-02</d><h>21:58</h><w>mikerod</w>As well as externally specified updates</z><z id="t1517608716000332" t="mikerod The challenge would be to do so in a way that interacted in a well-defined way with the truth maintenance system and logically inserted/retracted facts."><y>#</y><d>2018-02-02</d><h>21:58</h><w>mikerod</w>The challenge would be to do so in a way that interacted in a well-defined way with the truth maintenance system and logically inserted/retracted facts.</z><z id="t1517610296000319" t="mjmeintjes Thanks, useful post, helped clarify/validate the approach I&apos;m taking."><y>#</y><d>2018-02-02</d><h>22:24</h><w>mjmeintjes</w>Thanks, useful post, helped clarify/validate the approach I&apos;m taking.</z><z id="t1517610308000220" t="mikerod Oh, good"><y>#</y><d>2018-02-02</d><h>22:25</h><w>mikerod</w>Oh, good</z><z id="t1517803134000124" t="cfleming BTW Cursive 1.6.3-eap3 is out now, which contains support for Clara! Many thanks to @mikerod and @alex-dixon for help with that. I’m interested in any feedback, as always, either here or over in #cursive."><y>#</y><d>2018-02-05</d><h>03:58</h><w>cfleming</w>BTW Cursive 1.6.3-eap3 is out now, which contains support for Clara! Many thanks to @mikerod and @alex-dixon for help with that. I’m interested in any feedback, as always, either here or over in #cursive.</z><z id="t1517828036000330" t="urzds Hi!"><y>#</y><d>2018-02-05</d><h>10:53</h><w>urzds</w>Hi!</z><z id="t1517882871000293" t="sparkofreason Is there any documentation of the :exists feature? I saw some discussion about it on google groups and maybe in an issue, but haven&apos;t found much else."><y>#</y><d>2018-02-06</d><h>02:07</h><w>sparkofreason</w>Is there any documentation of the <code>:exists</code> feature? I saw some discussion about it on google groups and maybe in an issue, but haven&apos;t found much else.</z><z id="t1517929360000694" t="mikerod @dave.dixon not sure if there are any docs on it"><y>#</y><d>2018-02-06</d><h>15:02</h><w>mikerod</w>@dave.dixon not sure if there are any docs on it</z><z id="t1517929365000113" t="mikerod https://github.com/cerner/clara-rules/issues/130 has some discussion"><y>#</y><d>2018-02-06</d><h>15:02</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/issues/130" target="_blank">https://github.com/cerner/clara-rules/issues/130</a> has some discussion</z><z id="t1517929392000283" t="mikerod that’s the best I’ve found as far as docs on it"><y>#</y><d>2018-02-06</d><h>15:03</h><w>mikerod</w>that’s the best I’ve found as far as docs on it</z><z id="t1517929407000857" t="mikerod (didn’t do an exhaustive search)"><y>#</y><d>2018-02-06</d><h>15:03</h><w>mikerod</w>(didn’t do an exhaustive search)</z><z id="t1517929955000126" t="wparker @dave.dixon I don’t see any docs on it based on a search for “exists” in the clara-site repo. Having doc would be desirable. In the meantime it is really a pretty form of syntax sugar - you can just mentally make the substitution the compiler does at https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L618 if you’re trying to understand the behavior"><y>#</y><d>2018-02-06</d><h>15:12</h><w>wparker</w>@dave.dixon I don’t see any docs on it based on a search for “exists” in the clara-site repo.  Having doc would be desirable.  In the meantime it is really a pretty form of syntax sugar - you can just mentally make the substitution the compiler does at <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L618" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L618</a> if you’re trying to understand the behavior</z><z id="t1517931709000792" t="sparkofreason @wparker Thanks. So looking at that, [:not [:exists ...]] should work as expected, i.e. that &quot;no fact satisfying the conditions exists&quot; as opposed to &quot;maybe some fact exists that doesn&apos;t satisfy the conditions&quot;?"><y>#</y><d>2018-02-06</d><h>15:41</h><w>sparkofreason</w>@wparker Thanks. So looking at that, <code>[:not [:exists ...]]</code> should work as expected, i.e. that &quot;no fact satisfying the conditions exists&quot; as opposed to &quot;maybe some fact exists that doesn&apos;t satisfy the conditions&quot;?</z><z id="t1517931816000584" t="wparker Unfortunately not at the moment; see https://github.com/cerner/clara-rules/issues/329"><y>#</y><d>2018-02-06</d><h>15:43</h><w>wparker</w>Unfortunately not at the moment; see <a href="https://github.com/cerner/clara-rules/issues/329" target="_blank">https://github.com/cerner/clara-rules/issues/329</a></z><z id="t1517931851000849" t="wparker In the case of :not :exists there isn’t much reason to write it like that though, as I mentioned on the issue"><y>#</y><d>2018-02-06</d><h>15:44</h><w>wparker</w>In the case of :not :exists there isn’t much reason to write it like that though, as I mentioned on the issue</z><z id="t1517931883000257" t="sparkofreason Ah. Okay, I thought maybe I was just writing the expression, wrong. I&apos;ll take a look at the discussion."><y>#</y><d>2018-02-06</d><h>15:44</h><w>sparkofreason</w>Ah. Okay, I thought maybe I was just writing the expression, wrong. I&apos;ll take a look at the discussion.</z><z id="t1517931887000940" t="wparker as a general API concern, it is something that seems like it should work.. but haven’t gotten around to fixing it"><y>#</y><d>2018-02-06</d><h>15:44</h><w>wparker</w>as a general API concern, it is something that seems like it should work.. but haven’t gotten around to fixing it</z><z id="t1517935253000418" t="sparkofreason It does seem to work. I was having some issues and thought this may be the culprit, but it was other things (which had nothing to do with clara per se). I was a little suspicious of that binding inside the negation as well, but is seems to operate as intended, i.e. &quot;There is no Request fact equal to the Request entry on the Response fact&quot;."><y>#</y><d>2018-02-06</d><h>16:40</h><w>sparkofreason</w>It does seem to work. I was having some issues and thought this may be the culprit, but it was other things (which had nothing to do with clara per se). I was a little suspicious of that binding inside the negation as well, but is seems to operate as intended, i.e. &quot;There is no Request fact equal to the Request entry on the Response fact&quot;.</z><z id="t1517953564000584" t="sparkofreason It looks like the current behavior of parameterized queries is to just return an empty seq if all of the arguments are not bound in the call to query . It would be useful sometimes if leaving out a parameter just treated it as unbound, though I think you could only get away with this when the parameters are used in simple equality constraints, e.g. [?:foo] [Foo (= ?foo foo)] . I can get this behavior by wrapping query , but was wondering if there was a way to achieve it directly in clara."><y>#</y><d>2018-02-06</d><h>21:46</h><w>sparkofreason</w>It looks like the current behavior of parameterized queries is to just return an empty seq if all of the arguments are not bound in the call to <code>query</code>. It would be useful sometimes if leaving out a parameter just treated it as unbound, though I think you could only get away with this when the parameters are used in simple equality constraints, e.g. <code>[?:foo] [Foo (= ?foo foo)]</code>. I can get this behavior by wrapping <code>query</code>, but was wondering if there was a way to achieve it directly in clara.</z><z id="t1518022555000862" t="wparker @dave.dixon the query params are defined at query creation time and then used to key the results for the query in a map. This results in the actual call to “query” basically just being a map lookup. If arbitrary keys could be missing, I don’t think you could look things up that way without creating a lookup table for every possible permutation of absent and present bindings during fire-rules time, which could become costly. Looking at the code it seems perhaps we could add logic allowing the user to either pass all present params or none, providing all results regardless of bindings in the later case. Relevant code sections: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1959 for the query implementation in the engine, note the mem/get-tokens call. In QueryNode note the memory calls as well: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L431 with the join-bindings coming from the param-keys via this: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L149 Then see get-tokens and get-tokens-all: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc#L451 ; get-tokens-all would ignore the bindings"><y>#</y><d>2018-02-07</d><h>16:55</h><w>wparker</w>@dave.dixon the query params are defined at query creation time and then used to key the results for the query in a map.  This results in the actual call to “query” basically just being a map lookup.  If arbitrary keys could be missing, I don’t think you could look things up that way without creating a lookup table for every possible permutation of absent and present bindings during fire-rules time, which could become costly.  Looking at the code it seems perhaps we could add logic allowing the user to either pass all present params or none, providing all results regardless of bindings in the later case.  Relevant code sections: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1959" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1959</a> for the query implementation in the engine, note the mem/get-tokens call.  In QueryNode note the memory calls as well: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L431" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L431</a> with the join-bindings coming from the param-keys via this: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L149" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L149</a>  Then see get-tokens and get-tokens-all: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc#L451" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/memory.cljc#L451</a> ; get-tokens-all would ignore the bindings</z><z id="t1518026729000447" t="sparkofreason @wparker Thanks, good insight on working memory. It looks like the inspect function illustrates how to get at the bindings via get-tokens-all ."><y>#</y><d>2018-02-07</d><h>18:05</h><w>sparkofreason</w>@wparker Thanks, good insight on working memory. It looks like the <code>inspect</code> function illustrates how to get at the bindings via <code>get-tokens-all</code>.</z><z id="t1518100499000689" t="alex-dixon Anyone tried the new Cursive yet?"><y>#</y><d>2018-02-08</d><h>14:34</h><w>alex-dixon</w>Anyone tried the new Cursive yet?</z><z id="t1518101766000694" t="zylox ive been using it"><y>#</y><d>2018-02-08</d><h>14:56</h><w>zylox</w>ive been using it</z><z id="t1518101791000828" t="zylox though i havent had tooo much time to actually code in it"><y>#</y><d>2018-02-08</d><h>14:56</h><w>zylox</w>though i havent had tooo much time to actually code in it</z><z id="t1518102223000787" t="zylox but it works"><y>#</y><d>2018-02-08</d><h>15:03</h><w>zylox</w>but it works</z><z id="t1518102418000360" t="alex-dixon Awesome. Think it might be available in non-eap now. Haven’t tried yet"><y>#</y><d>2018-02-08</d><h>15:06</h><w>alex-dixon</w>Awesome. Think it might be available in non-eap now. Haven’t tried yet</z><z id="t1518102519000688" t="zylox ah, ya im still on eap"><y>#</y><d>2018-02-08</d><h>15:08</h><w>zylox</w>ah, ya im still on eap</z><z id="t1518113398000024" t="cfleming @alex-dixon Yes, 1.6.3 went out yesterday."><y>#</y><d>2018-02-08</d><h>18:09</h><w>cfleming</w>@alex-dixon Yes, 1.6.3 went out yesterday.</z><z id="t1518452167000534" t="yyoncho Here is simplified example of what I am trying to accomplish: I have fact FnHolder which contains how the Temperature facts will be compared/processed. I want to have a rule which produces another fact from the FnHolder and the Temperature but it doesn&apos;t trigger the depending rules when a new Temperature which doesn&apos;t change the produced value(thus I cannot do the accumulation in the body). This behavior is similar to acc/max which does not trigger if a non-maximal Temperature is inserted. Ideally I would have been able to write the following code but it doesn&apos;t run since ?fn is not visible in the custom-accum block. Can you advice? code (defrecord Temperature [location temperature]) (defrecord FnHolder [location other-params]) (defrule chaning [?fn &lt;- FnHolder (= location ?loc)] [?t &lt;- (custom-accum ?fn) :from [Temperature]] =&gt; ;; insert facts... ) code"><y>#</y><d>2018-02-12</d><h>16:16</h><w>yyoncho</w>Here is simplified example of what I am trying to accomplish:

I have fact FnHolder which contains how the Temperature facts will be compared/processed. I want to have a rule which produces another fact from the FnHolder and the Temperature but it doesn&apos;t trigger the depending rules when a new Temperature which doesn&apos;t change the produced value(thus I cannot do the accumulation in  the body). This behavior is similar to acc/max which does not trigger if a non-maximal Temperature is inserted. Ideally I would have been able to write the following code but it doesn&apos;t run since ?fn is not visible in the custom-accum block. Can you advice?

<code>code</code>
(defrecord Temperature [location temperature])
(defrecord FnHolder [location other-params])

(defrule chaning
  [?fn &lt;- FnHolder  (= location ?loc)]
  [?t &lt;- (custom-accum ?fn) :from [Temperature]]
  =&gt;
  ;; insert facts...
)
<code>code</code></z><z id="t1518458007000219" t="mikerod @yyoncho I don’t have an immediate complete answer to that question, but perhaps you could accomplish what you are wanting with a :test condition after the accumulation. Accumulate with something that doesn’t need to be “parameterized”."><y>#</y><d>2018-02-12</d><h>17:53</h><w>mikerod</w>@yyoncho I don’t have an immediate complete answer to that question, but perhaps you could accomplish what you are wanting with a <code>:test</code> condition after the accumulation. Accumulate with something that doesn’t need to be “parameterized”.</z><z id="t1518458055000397" t="mikerod Another possibility is to use a sort of joined fact. I’m not sure how appropriate it will be for you, but it would look like:"><y>#</y><d>2018-02-12</d><h>17:54</h><w>mikerod</w>Another possibility is to use a sort of joined fact. I’m not sure how appropriate it will be for you, but it would look like:</z><z id="t1518458154000055" t="mikerod (defrecord Temperature [location temperature]) (defrecord FnHolder [location other-params]) (defrecord TempWithFn [temp fn-holder]) (defrule combine [?fn &lt;- FnHolder (= location ?loc)] [?t &lt;- Temperature] =&gt; (insert (-&gt;TempWithFn ?t ?fn))) (defrule chaning [?t &lt;- (custom-accum :fn-holder) :from [TempWithFn]] =&gt; ;; insert facts... ) "><y>#</y><d>2018-02-12</d><h>17:55</h><w>mikerod</w><pre>(defrecord Temperature [location temperature])
(defrecord FnHolder [location other-params])
(defrecord TempWithFn [temp fn-holder])

(defrule combine
  [?fn &lt;- FnHolder  (= location ?loc)]
  [?t &lt;- Temperature]
  =&gt;
  (insert (-&gt;TempWithFn ?t ?fn)))

(defrule chaning
  [?t &lt;- (custom-accum :fn-holder) :from [TempWithFn]]
  =&gt;
  ;; insert facts...
)
</pre></z><z id="t1518458195000549" t="mikerod I think the custom-accum doesn’t really need the :fn-holder key anymore though. it has the whole fact with all that info on it."><y>#</y><d>2018-02-12</d><h>17:56</h><w>mikerod</w>I think the <code>custom-accum</code> doesn’t really need the <code>:fn-holder</code> key anymore though. it has the whole fact with all that info on it.</z><z id="t1518506155000253" t="yyoncho @mikerod if I do that I will be able to process the Temperature facts one by one in FnHolder which won&apos;t work since FnHolder is stateful processing over the whole collection of Temperature facts, e. g. find the max Temperature for particular day of the week."><y>#</y><d>2018-02-13</d><h>07:15</h><w>yyoncho</w>@mikerod if I do that I will be able to process the Temperature facts one by one in FnHolder which won&apos;t work since FnHolder is stateful processing over the whole collection of Temperature facts, e. g. find the max Temperature for particular day of the week.</z><z id="t1519080208000001" t="souenzzo 48260 facts is something that I can call &quot;huge&quot;? Or there is other problem on my rules?"><y>#</y><d>2018-02-19</d><h>22:43</h><w>souenzzo</w><code>48260</code> facts is something that I can call &quot;huge&quot;? Or there is other problem on my rules?</z><z id="t1519080265000096" t="souenzzo (my application hangs/out-of-memory/stranges exceptions on fire-rules)"><y>#</y><d>2018-02-19</d><h>22:44</h><w>souenzzo</w>(my application hangs/out-of-memory/stranges exceptions on fire-rules)</z><z id="t1519086231000150" t="mikerod @souenzzo I wouldn’t normally expect that number of facts to be much of a problem"><y>#</y><d>2018-02-20</d><h>00:23</h><w>mikerod</w>@souenzzo I wouldn’t normally expect that number of facts to be much of a problem</z><z id="t1519086246000091" t="mikerod however, you can certainly write rules in a way that cause a problem (for smaller numbers even)"><y>#</y><d>2018-02-20</d><h>00:24</h><w>mikerod</w>however, you can certainly write rules in a way that cause a problem (for smaller numbers even)</z><z id="t1519141142000785" t="wparker @souenzzo what do you mean by “strange exceptions”? In terms of number of facts, the only real limit in Clara should be the memory available.. but of course if you have problematic rules (not necessarily incorrectly written, just poorly performing) you can run into problems. If you can find a reproducing case that seems like it performs more poorly than it should feel free to log an issue. We’ve mostly optimized Clara against the examples we have at Cerner but representative benchmarks of other workloads could be interesting/useful."><y>#</y><d>2018-02-20</d><h>15:39</h><w>wparker</w>@souenzzo what do you mean by “strange exceptions”?  In terms of number of facts, the only real limit in Clara should be the memory available.. but of course if you have problematic rules (not necessarily incorrectly written, just poorly performing) you can run into problems.  If you can find a reproducing case that seems like it performs more poorly than it should feel free to log an issue.  We’ve mostly optimized Clara against the examples we have at Cerner but representative benchmarks of other workloads could be interesting/useful.</z><z id="t1519825896000604" t="wdullaer I&apos;m doing some stress testing of clara and i&apos;m seeing some weird behaviour"><y>#</y><d>2018-02-28</d><h>13:51</h><w>wdullaer</w>I&apos;m doing some stress testing of clara and i&apos;m seeing some weird behaviour</z><z id="t1519825917000427" t="wdullaer the background is that I want to build a sort of access control engine"><y>#</y><d>2018-02-28</d><h>13:51</h><w>wdullaer</w>the background is that I want to build a sort of access control engine</z><z id="t1519825951000296" t="wdullaer there are 3 fact types: a consent, a processor and a processingallowed fact"><y>#</y><d>2018-02-28</d><h>13:52</h><w>wdullaer</w>there are 3 fact types: a consent, a processor and a processingallowed fact</z><z id="t1519825973000516" t="wdullaer there&apos;s just one rule which inserts processingallowed if there is sufficient amount of concent for a given processor"><y>#</y><d>2018-02-28</d><h>13:52</h><w>wdullaer</w>there&apos;s just one rule which inserts processingallowed if there is sufficient amount of concent for a given processor</z><z id="t1519826004000666" t="wdullaer when I insert 1 million random consents, firing the rules takes just a few seconds"><y>#</y><d>2018-02-28</d><h>13:53</h><w>wdullaer</w>when I insert 1 million random consents, firing the rules takes just a few seconds</z><z id="t1519826027000085" t="wdullaer if I insert 1 million more into the previous session, firing the rules takes over an hour (I never waiting long enough for it to complete)"><y>#</y><d>2018-02-28</d><h>13:53</h><w>wdullaer</w>if I insert 1 million more into the previous session, firing the rules takes over an hour (I never waiting long enough for it to complete)</z><z id="t1519826048000019" t="wdullaer if I insert 2 million random consents in an empty session, firing the rules still only takes a few seconds"><y>#</y><d>2018-02-28</d><h>13:54</h><w>wdullaer</w>if I insert 2 million random consents in an empty session, firing the rules still only takes a few seconds</z><z id="t1519826182000331" t="wdullaer while this isn&apos;t a truly realistic scenario (updates to consent would arrive in batches of a few 100 once initialised), I&apos;m still kind of surprised by this behaviour"><y>#</y><d>2018-02-28</d><h>13:56</h><w>wdullaer</w>while this isn&apos;t a truly realistic scenario (updates to consent would arrive in batches of a few 100 once initialised), I&apos;m still kind of surprised by this behaviour</z><z id="t1519829836000004" t="mikerod @wdullaer that is interesting. it would seem that the insert 1 mil then 1 mil later is triggering some heavy “retraction” work"><y>#</y><d>2018-02-28</d><h>14:57</h><w>mikerod</w>@wdullaer that is interesting. it would seem that the insert 1 mil then 1 mil later is triggering some heavy “retraction” work</z><z id="t1519829858000250" t="mikerod However, with that sort of time being taken up, it’d be good to have some profiling"><y>#</y><d>2018-02-28</d><h>14:57</h><w>mikerod</w>However, with that sort of time being taken up, it’d be good to have some profiling</z><z id="t1519829891000106" t="wdullaer there is no rule which retracts facts"><y>#</y><d>2018-02-28</d><h>14:58</h><w>wdullaer</w>there is no rule which retracts facts</z><z id="t1519829899000296" t="mikerod Unless you can reproduce it in a small case, which may not be easy. I wonder if you could do some CPU sampling snapshot while it is running excessively via a tool like “visual vm” or similar"><y>#</y><d>2018-02-28</d><h>14:58</h><w>mikerod</w>Unless you can reproduce it in a small case, which may not be easy.

I wonder if you could do some CPU sampling snapshot while it is running excessively via a tool like “visual vm” or similar</z><z id="t1519829907000636" t="wdullaer I haven&apos;t found a good way to do detailed profiling / tracing yet, so all suggestions are welcome 🙂"><y>#</y><d>2018-02-28</d><h>14:58</h><w>wdullaer</w>I haven&apos;t found a good way to do detailed profiling / tracing yet, so all suggestions are welcome <b>🙂</b></z><z id="t1519829938000752" t="mikerod Well, retracts can happen due to logical inserts (normal insert! in Clara). Also, accumulators may be updated and have to retract previous results. There are quite a few reasons to have “implicit” retracts happening in working memory"><y>#</y><d>2018-02-28</d><h>14:58</h><w>mikerod</w>Well, retracts can happen due to logical inserts (normal <code>insert!</code> in Clara). Also, accumulators may be updated and have to retract previous results. There are quite a few reasons to have “implicit” retracts happening in working memory</z><z id="t1519829960000137" t="wdullaer make sense"><y>#</y><d>2018-02-28</d><h>14:59</h><w>wdullaer</w>make sense</z><z id="t1519829971000143" t="wdullaer I am using an all accumulator in the rule"><y>#</y><d>2018-02-28</d><h>14:59</h><w>wdullaer</w>I am using an <code>all</code> accumulator in the rule</z><z id="t1519829978000071" t="mikerod VisualVM is free. I’ve used it mostly just since it was good enough for seeing many things like this."><y>#</y><d>2018-02-28</d><h>14:59</h><w>mikerod</w>VisualVM is free. I’ve used it mostly just since it was good enough for seeing many things like this.</z><z id="t1519829991000242" t="wdullaer but the funny thing is that it works just fine when doing 2 million in bulk on an empty session"><y>#</y><d>2018-02-28</d><h>14:59</h><w>wdullaer</w>but the funny thing is that it works just fine when doing 2 million in bulk on an empty session</z><z id="t1519830000000537" t="wdullaer I&apos;ll give that a spin"><y>#</y><d>2018-02-28</d><h>15:00</h><w>wdullaer</w>I&apos;ll give that a spin</z><z id="t1519830007000907" t="mikerod That isn’t entirely surprising to me - if you’ve found a bad retraction sort of scenario"><y>#</y><d>2018-02-28</d><h>15:00</h><w>mikerod</w>That isn’t entirely surprising to me - if you’ve found a bad retraction sort of scenario</z><z id="t1519830017000940" t="mikerod In bulk, Clara does a lot of work in batches"><y>#</y><d>2018-02-28</d><h>15:00</h><w>mikerod</w>In bulk, Clara does a lot of work in batches</z><z id="t1519830043000334" t="mikerod Which has one benefit of avoiding “rework” - aka retractions/insertions to update “incorrect” earlier working memory states"><y>#</y><d>2018-02-28</d><h>15:00</h><w>mikerod</w>Which has one benefit of avoiding “rework” - aka retractions/insertions to update “incorrect” earlier working memory states</z><z id="t1519830078000489" t="wdullaer I&apos;m comparing 2 million in 1 go, vs 2 batches of 1 million"><y>#</y><d>2018-02-28</d><h>15:01</h><w>wdullaer</w>I&apos;m comparing 2 million in 1 go, vs 2 batches of 1 million</z><z id="t1519830093000894" t="wdullaer (I was expecting memory usage to be a bottleneck, but it&apos;s doing pretty fine on that front)"><y>#</y><d>2018-02-28</d><h>15:01</h><w>wdullaer</w>(I was expecting memory usage to be a bottleneck, but it&apos;s doing pretty fine on that front)</z><z id="t1519830101000924" t="wdullaer anyway, visualvm it is 🙂"><y>#</y><d>2018-02-28</d><h>15:01</h><w>wdullaer</w>anyway, visualvm it is <b>🙂</b></z><z id="t1519830119000253" t="mikerod So running with the VisualVM idea. 1) Download it, 2) open it, 3) find your JVM process (it has a list on in the UI) running the bad performance case with"><y>#</y><d>2018-02-28</d><h>15:01</h><w>mikerod</w>So running with the VisualVM idea.
1) Download it, 2) open it, 3) find your JVM process (it has a list on in the UI) running the bad performance case with</z><z id="t1519830165000077" t="mikerod (4) click “Sampler” tab (5) click “CPU” (6) start running whatever is taking a long time"><y>#</y><d>2018-02-28</d><h>15:02</h><w>mikerod</w>(4) click “Sampler” tab (5) click “CPU” (6) start running whatever is taking a long time</z><z id="t1519830188000715" t="mikerod (7) let it run for a bit, perhaps like a minute or so, then click “snapshot”"><y>#</y><d>2018-02-28</d><h>15:03</h><w>mikerod</w>(7) let it run for a bit, perhaps like a minute or so, then click “snapshot”</z><z id="t1519830219000700" t="wdullaer :+1:"><y>#</y><d>2018-02-28</d><h>15:03</h><w>wdullaer</w><b>:+1:</b></z><z id="t1519830324000807" t="mikerod Once you have a snapshot, you can dig around the callstack to see where the time is. If you want help with that, you can perhaps explain what is taking such a long time in the Clara functions of the callstack and perhaps I (or someone) will know enough by that. Or you can you can “export to” via an icon in the UI and it’ll give you an nps file to share. If you have proprietary stuff (I don’t think much proprietary info shows up in these though, but still.) you don’t want to show, you could try to just find good screenshots that cut the callstack down to just the Clara functions parts."><y>#</y><d>2018-02-28</d><h>15:05</h><w>mikerod</w>Once you have a snapshot, you can dig around the callstack to see where the time is. 
If you want help with that, you can perhaps explain what is taking such a long time in the Clara functions of the callstack and perhaps I (or someone) will know enough by that.

Or you can you can “export to” via an icon in the UI and it’ll give you an nps file to share.

If you have proprietary stuff (I don’t think much proprietary info shows up in these though, but still.) you don’t want to show, you could try to just find good screenshots that cut the callstack down to just the Clara functions parts.</z><z id="t1519830340000532" t="wdullaer I have to run now, but I&apos;ll do the test later today and post back with the results"><y>#</y><d>2018-02-28</d><h>15:05</h><w>wdullaer</w>I have to run now, but I&apos;ll do the test later today and post back with the results</z><z id="t1519830345000131" t="wdullaer thanks a lot already!"><y>#</y><d>2018-02-28</d><h>15:05</h><w>wdullaer</w>thanks a lot already!</z><z id="t1519830353000169" t="mikerod It’s probably not a bad idea to get some familiarity with digging through some cpu sampling snapshot results though. Can definitely be useful for finding bottlenecks quickly"><y>#</y><d>2018-02-28</d><h>15:05</h><w>mikerod</w>It’s probably not a bad idea to get some familiarity with digging through some cpu sampling snapshot results though. Can definitely be useful for finding bottlenecks quickly</z><z id="t1519830359000779" t="mikerod No problem"><y>#</y><d>2018-02-28</d><h>15:05</h><w>mikerod</w>No problem</z><z id="t1519834899000062" t="wparker @wdullaer are you inserting the facts like this: (-&gt; session (insert first-fact) .... (insert millionth-fact)) or like this: (insert session [first-fact .. millionth-fact] It seems odd to me that simply breaking a single batch into two would have such a huge performance impact - OTOH smaller batching could do it. Arguably Clara should try to batch the first case together anyway, but it doesn’t. See how facts are added into the “pending-operations” on insertion at https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1818 and removed from the queue in fire-rules at https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1870"><y>#</y><d>2018-02-28</d><h>16:21</h><w>wparker</w>@wdullaer are you inserting the facts like this: <pre>(-&gt; session (insert first-fact) .... (insert millionth-fact)) </pre> or like this: <pre>(insert session [first-fact .. millionth-fact] </pre> It seems odd to me that simply breaking a single batch into two would have such a huge performance impact - OTOH smaller batching could do it.  Arguably Clara should try to batch the first case together anyway, but it doesn’t.  See how facts are added into the “pending-operations” on insertion at <a href="https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1818" target="_blank">https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1818</a> and removed from the queue in fire-rules at <a href="https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1870" target="_blank">https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/rules/engine.cljc#L1870</a></z><z id="t1519835176000215" t="wparker If a simple division into two batches really does increase runtime like that I’d be curious to see a reproducing case and if there is some performance optimization we could do - at first glance it doesn’t seem like it should happen, but as always it is hard to say without a concrete case. On profiling, seconding mikerod’s suggestion of VisualVM. Another possible route would be to look at the trace of the rule execution for a smaller number of facts - manual examination wouldn’t be practical for millions of facts, but a batch of 2 facts vs 2 batches of 1 fact each might show insights. I’d probably start with VisualVM though especially since traces generally require some understanding of Clara’s internals to yield much insight. https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/tools/tracing.cljc"><y>#</y><d>2018-02-28</d><h>16:26</h><w>wparker</w>If a simple division into two batches really does increase runtime like that I’d be curious to see a reproducing case and if there is some performance optimization we could do - at first glance it doesn’t seem like it should happen, but as always it is hard to say without a concrete case.  On profiling, seconding mikerod’s suggestion of VisualVM.  Another possible route would be to look at the trace of the rule execution for a smaller number of facts - manual examination wouldn’t be practical for millions of facts, but a batch of 2 facts vs 2 batches of 1 fact each might show insights.  I’d probably start with VisualVM though especially since traces generally require some understanding of Clara’s internals to yield much insight. <a href="https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/tools/tracing.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/0.17.0/src/main/clojure/clara/tools/tracing.cljc</a></z><z id="t1519835520001022" t="mikerod @wparker sounded like he had batches of 1 million. so not really “small” hah"><y>#</y><d>2018-02-28</d><h>16:32</h><w>mikerod</w>@wparker sounded like he had batches of 1 million. so not really “small” hah</z><z id="t1519835553000750" t="mikerod however, I was thinking that the scenario was “insert 1 million, then fire”, later on, “insert 1 million, then fire”"><y>#</y><d>2018-02-28</d><h>16:32</h><w>mikerod</w>however, I was thinking that the scenario was “insert 1 million, then fire”, later on, “insert 1 million, then fire”</z><z id="t1519837807000493" t="wdullaer that&apos;s exactly it"><y>#</y><d>2018-02-28</d><h>17:10</h><r>wdullaer</r>that&apos;s exactly it</z><z id="t1519835565000816" t="mikerod Trying to reuse and old session state basically"><y>#</y><d>2018-02-28</d><h>16:32</h><w>mikerod</w>Trying to reuse and old session state basically</z><z id="t1519835588000429" t="mikerod It certainly sounds like the batching behavior was critical to the performance of the scenario they were having."><y>#</y><d>2018-02-28</d><h>16:33</h><w>mikerod</w>It certainly sounds like the batching behavior was critical to the performance of the scenario they were having.</z><z id="t1519835640000166" t="mikerod It seems that there is potentially found some bad performing case in terms of updating working memory state that this uncovered. Also, I think I assumed this was on the JVM. Not sure if that was actually stated before. I’m guessing so with the millions of facts and the discussion around using visualvm"><y>#</y><d>2018-02-28</d><h>16:34</h><w>mikerod</w>It seems that there is potentially found some bad performing case in terms of updating working memory state that this uncovered.
Also, I think I assumed this was on the JVM. Not sure if that was actually stated before. I’m guessing so with the millions of facts and the discussion around using visualvm</z><z id="t1519835682000052" t="wparker My point was that I think it would be possible to think the batch was a million, but actually end up being one at a time when rules fire, so just wanted to make sure that it was batched"><y>#</y><d>2018-02-28</d><h>16:34</h><w>wparker</w>My point was that I think it would be possible to think the batch was a million, but actually end up being one at a time when rules fire, so just wanted to make sure that it was batched</z><z id="t1519835693000299" t="mikerod yeah, true"><y>#</y><d>2018-02-28</d><h>16:34</h><w>mikerod</w>yeah, true</z><z id="t1519835723000635" t="wparker Perhaps Clara should probably take (-&gt; session (insert A) (insert B) fire-rules) and turn it into a single batch - but I think it is 2 at present"><y>#</y><d>2018-02-28</d><h>16:35</h><w>wparker</w>Perhaps Clara should probably take (-&gt; session (insert A) (insert B) fire-rules) and turn it into a single batch - but I think it is 2 at present</z><z id="t1519835744000137" t="mikerod Yeah"><y>#</y><d>2018-02-28</d><h>16:35</h><w>mikerod</w>Yeah</z><z id="t1519835760000904" t="mikerod If they were inserting a million things though, they probably did it in a single insert"><y>#</y><d>2018-02-28</d><h>16:36</h><w>mikerod</w>If they were inserting a million things though, they probably did it in a single insert</z><z id="t1519835774000841" t="mikerod otherwise they’d have to do something like (reduce insert session million-things)"><y>#</y><d>2018-02-28</d><h>16:36</h><w>mikerod</w>otherwise they’d have to do something like <code>(reduce insert session million-things)</code></z><z id="t1519835799000642" t="mikerod I don’t think they’d write out a million (insert thing1) by hand 😛"><y>#</y><d>2018-02-28</d><h>16:36</h><w>mikerod</w>I don’t think they’d write out a million <code>(insert thing1)</code> by hand <b>😛</b></z><z id="t1519835817000465" t="wparker anyway a VisualVM snapshot would be informative, spending time in memory updates would be a possible culprit"><y>#</y><d>2018-02-28</d><h>16:36</h><w>wparker</w>anyway a VisualVM snapshot would be informative, spending time in memory updates would be a possible culprit</z><z id="t1519836054000378" t="mikerod yeah, I thought it would be good to se"><y>#</y><d>2018-02-28</d><h>16:40</h><w>mikerod</w>yeah, I thought it would be good to se</z><z id="t1519836059000936" t="mikerod hopefully some can be obtained"><y>#</y><d>2018-02-28</d><h>16:40</h><w>mikerod</w>hopefully some can be obtained</z><z id="t1519836094000551" t="mikerod I agree in general though that Clara should just batch the work from multiple insert calls"><y>#</y><d>2018-02-28</d><h>16:41</h><w>mikerod</w>I agree in general though that Clara should just batch the work from multiple insert calls</z><z id="t1519836100000813" t="mikerod Should batch as much as possible"><y>#</y><d>2018-02-28</d><h>16:41</h><w>mikerod</w>Should batch as much as possible</z><z id="t1519836131000247" t="alex-dixon Would insert-all be preferable here?"><y>#</y><d>2018-02-28</d><h>16:42</h><w>alex-dixon</w>Would insert-all be preferable here?</z><z id="t1519836219000025" t="mikerod If you have a big collection of things to insert, yes insert-all"><y>#</y><d>2018-02-28</d><h>16:43</h><w>mikerod</w>If you have a big collection of things to insert, yes <code>insert-all</code></z><z id="t1519836232000834" t="mikerod or you call insert via varargs if you have compile-time known ones"><y>#</y><d>2018-02-28</d><h>16:43</h><w>mikerod</w>or you call <code>insert</code> via varargs if you have compile-time known ones</z><z id="t1519836245000289" t="mikerod You could also do apply insert , but no reason too since insert-all exists"><y>#</y><d>2018-02-28</d><h>16:44</h><w>mikerod</w>You could also do <code>apply insert</code>, but no reason too since <code>insert-all</code> exists</z><z id="t1519836272000851" t="mikerod Batched propagation through the rete network can be a big performance boost"><y>#</y><d>2018-02-28</d><h>16:44</h><w>mikerod</w>Batched propagation through the rete network can be a big performance boost</z><z id="t1519836281000440" t="mikerod So it’s best to be as batch’ful as you can be"><y>#</y><d>2018-02-28</d><h>16:44</h><w>mikerod</w>So it’s best to be as batch’ful as you can be</z><z id="t1519836365000641" t="alex-dixon A while ago I think I noticed retracts were slow. Not the result of insert logical though"><y>#</y><d>2018-02-28</d><h>16:46</h><w>alex-dixon</w>A while ago I think I noticed retracts were slow. Not the result of insert logical though</z><z id="t1519836394000099" t="mikerod to clarify, external retract or RHS retract! ?"><y>#</y><d>2018-02-28</d><h>16:46</h><w>mikerod</w>to clarify, external <code>retract</code> or RHS <code>retract!</code>?</z><z id="t1519836519000685" t="mikerod For no good reason (that I’m aware of) there isn’t a retract-all for external retraction right now. So you should use apply retract if you have a batch there."><y>#</y><d>2018-02-28</d><h>16:48</h><w>mikerod</w>For no good reason (that I’m aware of) there isn’t a <code>retract-all</code> for external retraction right now.
So you should use <code>apply retract</code> if you have a batch there.</z><z id="t1519844179000444" t="alex-dixon External "><y>#</y><d>2018-02-28</d><h>18:56</h><r>alex-dixon</r>External </z><z id="t1519844755000352" t="mikerod So yep, apply retract"><y>#</y><d>2018-02-28</d><h>19:05</h><r>mikerod</r>So yep, <code>apply retract</code></z><z id="t1519844780000020" t="mikerod (we should get a retract-all added for convenience and symmetry with insert"><y>#</y><d>2018-02-28</d><h>19:06</h><r>mikerod</r>(we should get a <code>retract-all</code> added for convenience and symmetry with <code>insert</code></z><z id="t1519844800000589" t="alex-dixon Faster than doseq?"><y>#</y><d>2018-02-28</d><h>19:06</h><r>alex-dixon</r>Faster than doseq?</z><z id="t1519844832000544" t="mikerod I don’t know how you would doseq external retract - returns a new version of the session, not mutation"><y>#</y><d>2018-02-28</d><h>19:07</h><r>mikerod</r>I don’t know how you would <code>doseq</code> external <code>retract</code> - returns a new version of the session, not mutation</z><z id="t1519844868000011" t="mikerod If you have a collection of facts to externally retract Instead of (reduce retract session facts) do (apply retract session facts)"><y>#</y><d>2018-02-28</d><h>19:07</h><r>mikerod</r>If you have a collection of facts to externally retract
Instead of
<code>(reduce retract session facts)</code>
do
<code>(apply retract session facts)</code></z><z id="t1519837948000359" t="wdullaer here&apos;s roughly what&apos;s happening:"><y>#</y><d>2018-02-28</d><h>17:12</h><w>wdullaer</w>here&apos;s roughly what&apos;s happening:</z><z id="t1519838010000695" t="wdullaer (-&gt;session (insert-all (generate-consents 1000000 test-purposes test-attributes)) (fire-rules) (insert-all (generate-consents 1000000 test-purposes test-attributes)) (fire-rules)) "><y>#</y><d>2018-02-28</d><h>17:13</h><w>wdullaer</w><pre>(-&gt;session 
    (insert-all (generate-consents 1000000 test-purposes test-attributes))
    (fire-rules)
    (insert-all (generate-consents 1000000 test-purposes test-attributes))
    (fire-rules))
</pre></z><z id="t1519838019000738" t="wdullaer with some log statements to see where I am"><y>#</y><d>2018-02-28</d><h>17:13</h><w>wdullaer</w>with some log statements to see where I am</z><z id="t1519838022000208" t="wdullaer this is on the jvm"><y>#</y><d>2018-02-28</d><h>17:13</h><w>wdullaer</w>this is on the jvm</z><z id="t1519838060000460" t="wdullaer I still have to take the snapshot"><y>#</y><d>2018-02-28</d><h>17:14</h><w>wdullaer</w>I still have to take the snapshot</z><z id="t1519838080000427" t="wdullaer maybe I&apos;ll try to reduce the code to the size of a gist so I can share it"><y>#</y><d>2018-02-28</d><h>17:14</h><w>wdullaer</w>maybe I&apos;ll try to reduce the code to the size of a gist so I can share it</z><z id="t1519838184000377" t="mikerod &gt; maybe I’ll try to reduce the code to the size of a gist so I can share it Yeah, that is best-case scenario"><y>#</y><d>2018-02-28</d><h>17:16</h><w>mikerod</w>&gt; maybe I’ll try to reduce the code to the size of a gist so I can share it
Yeah, that is best-case scenario</z><z id="t1519839130000410" t="wdullaer I&apos;ll report back tomorrow"><y>#</y><d>2018-02-28</d><h>17:32</h><w>wdullaer</w>I&apos;ll report back tomorrow</z><z id="t1519893226000058" t="wdullaer So I fired up visualVM"><y>#</y><d>2018-03-01</d><h>08:33</h><w>wdullaer</w>So I fired up visualVM</z><z id="t1519893256000328" t="wdullaer and it seems to be spending all the time in clara.rules.engine$retract_accumulated.invoke()"><y>#</y><d>2018-03-01</d><h>08:34</h><w>wdullaer</w>and it seems to be spending all the time in <code>clara.rules.engine$retract_accumulated.invoke()</code></z><z id="t1519893304000110" t="wdullaer which lines up with the theory that implicit retractions are causing this"><y>#</y><d>2018-03-01</d><h>08:35</h><w>wdullaer</w>which lines up with the theory that implicit retractions are causing this</z><z id="t1519893362000430" t="wdullaer I can share the snapshot if that would be interesting for people"><y>#</y><d>2018-03-01</d><h>08:36</h><w>wdullaer</w>I can share the snapshot if that would be interesting for people</z><z id="t1519893380000283" t="wdullaer I&apos;ll spend some time trimming the example down to a bare bones app I can put in a gist"><y>#</y><d>2018-03-01</d><h>08:36</h><w>wdullaer</w>I&apos;ll spend some time trimming the example down to a bare bones app I can put in a gist</z><z id="t1519908559000178" t="wdullaer the gist can be found here: https://gist.github.com/wdullaer/cecf88b3266ba0ac90b4f060eefe5208"><y>#</y><d>2018-03-01</d><h>12:49</h><w>wdullaer</w>the gist can be found here: <a href="https://gist.github.com/wdullaer/cecf88b3266ba0ac90b4f060eefe5208" target="_blank">https://gist.github.com/wdullaer/cecf88b3266ba0ac90b4f060eefe5208</a></z><z id="t1519908599000339" t="wdullaer when making this I noticed that the 2 million case is not exactly the same as 2x 1 million, because of how the attributes are randomly generated"><y>#</y><d>2018-03-01</d><h>12:49</h><w>wdullaer</w>when making this I noticed that the 2 million case is not exactly the same as 2x 1 million, because of how the attributes are randomly generated</z><z id="t1519908617000241" t="wdullaer 2x 1 million will generate much more consent for a given personId"><y>#</y><d>2018-03-01</d><h>12:50</h><w>wdullaer</w>2x 1 million will generate much more consent for a given personId</z><z id="t1519908627000159" t="wdullaer (giving the accumulator more work)"><y>#</y><d>2018-03-01</d><h>12:50</h><w>wdullaer</w>(giving the accumulator more work)</z><z id="t1519908645000395" t="wdullaer 2x 1 million goes fast enough if I make sure they generate distinct sets"><y>#</y><d>2018-03-01</d><h>12:50</h><w>wdullaer</w>2x 1 million goes fast enough if I make sure they generate distinct sets</z><z id="t1519908678000143" t="wdullaer however 1x 2 million tweaked to have the same overlap in consent as 2x 1 million still goes an order of magnitude faster"><y>#</y><d>2018-03-01</d><h>12:51</h><w>wdullaer</w>however 1x 2 million tweaked to have the same overlap in consent as 2x 1 million still goes an order of magnitude faster</z><z id="t1519908733000098" t="wdullaer I know clara doesn&apos;t deduplicate facts, but I think in this case that would prevent me from running into this scenario"><y>#</y><d>2018-03-01</d><h>12:52</h><w>wdullaer</w>I know clara doesn&apos;t deduplicate facts, but I think in this case that would prevent me from running into this scenario</z><z id="t1519913408000639" t="mikerod @wdullaer thanks for the details"><y>#</y><d>2018-03-01</d><h>14:10</h><w>mikerod</w>@wdullaer thanks for the details</z><z id="t1519913458000690" t="mikerod I will take a look. It may be about an hour or so though. Doing a few other things at the moment."><y>#</y><d>2018-03-01</d><h>14:10</h><w>mikerod</w>I will take a look. It may be about an hour or so though. Doing a few other things at the moment.</z><z id="t1519913469000206" t="wdullaer no worries, take all the time you need"><y>#</y><d>2018-03-01</d><h>14:11</h><w>wdullaer</w>no worries, take all the time you need</z><z id="t1519913481000582" t="wdullaer I can supply the vm snapshot as well (just need to find a quick place to upload it)"><y>#</y><d>2018-03-01</d><h>14:11</h><w>wdullaer</w>I can supply the vm snapshot as well (just need to find a quick place to upload it)</z><z id="t1519913506000426" t="mikerod Yeah, if you have one you can share, that’d be good to take a glance at."><y>#</y><d>2018-03-01</d><h>14:11</h><w>mikerod</w>Yeah, if you have one you can share, that’d be good to take a glance at.</z><z id="t1519913510000447" t="mikerod How to share hmm"><y>#</y><d>2018-03-01</d><h>14:11</h><w>mikerod</w>How to share hmm</z><z id="t1519913586000036" t="wdullaer I&apos;ll put it into dropbox, just a sec"><y>#</y><d>2018-03-01</d><h>14:13</h><w>wdullaer</w>I&apos;ll put it into dropbox, just a sec</z><z id="t1519913673000597" t="wdullaer https://www.dropbox.com/s/no6h9pwa03hzt7w/clara-perf.nps?dl=0"><y>#</y><d>2018-03-01</d><h>14:14</h><w>wdullaer</w><a href="https://www.dropbox.com/s/no6h9pwa03hzt7w/clara-perf.nps?dl=0" target="_blank">https://www.dropbox.com/s/no6h9pwa03hzt7w/clara-perf.nps?dl=0</a></z><z id="t1519913674000632" t="mikerod ok"><y>#</y><d>2018-03-01</d><h>14:14</h><w>mikerod</w>ok</z><z id="t1519921408000585" t="mikerod @wdullaer I’ve only got to look at this briefly so far today"><y>#</y><d>2018-03-01</d><h>16:23</h><w>mikerod</w>@wdullaer I’ve only got to look at this briefly so far today</z><z id="t1519921529000582" t="mikerod It seems like these collections created via acc/distinct would be fairly large. Also, there are many of them after the first 1mil facts. There’d be a big acc/distinct collection associated with each personId + purpose grouped Consent facts. When the next 1mil facts come in, I believe they will contribute to many (or perhaps even all) of those same big collections."><y>#</y><d>2018-03-01</d><h>16:25</h><w>mikerod</w>It seems like these collections created via <code>acc/distinct</code> would be fairly large. Also, there are many of them after the first 1mil facts. There’d be a big <code>acc/distinct</code> collection associated with each personId + purpose grouped Consent facts. When the next 1mil facts come in, I believe they will contribute to many  (or perhaps even all) of those same big collections.</z><z id="t1519921574000125" t="mikerod The work from the first 1 mil facts is stored in working memory. Clara builds the new collections on the 2nd wave of inserts. It then must remove the old accumulated work it did from working memory - in order to replace it with the updates."><y>#</y><d>2018-03-01</d><h>16:26</h><w>mikerod</w>The work from the first 1 mil facts is stored in working memory. Clara builds the new collections on the 2nd wave of inserts. It then must remove the old accumulated work it did from working memory - in order to replace it with the updates.</z><z id="t1519921611000144" t="mikerod I think the fact that there are many of these large collections in working memory is making it get really expensive to remove them all from working memory. Clara tries to be efficient in finding and removing things in memory. I think huge collections may be a pitfall."><y>#</y><d>2018-03-01</d><h>16:26</h><w>mikerod</w>I think the fact that there are many of these large collections in working memory is making it get really expensive to remove them all from working memory. Clara tries to be efficient in finding and removing things in memory. I think huge collections may be a pitfall.</z><z id="t1519921699000796" t="mikerod I’d like to look a little deeper at it, but haven’t been able to yet. I’m not sure what a reasonable workaround may be, other than inserting everything in one batch (as you’ve found)."><y>#</y><d>2018-03-01</d><h>16:28</h><w>mikerod</w>I’d like to look a little deeper at it, but haven’t been able to yet. I’m not sure what a reasonable workaround may be, other than inserting everything in one batch (as you’ve found).</z><z id="t1519921717000405" t="mikerod It’s an interesting case to explore some more for sure."><y>#</y><d>2018-03-01</d><h>16:28</h><w>mikerod</w>It’s an interesting case to explore some more for sure.</z><z id="t1519926102000602" t="wdullaer thanks for the input"><y>#</y><d>2018-03-01</d><h>17:41</h><w>wdullaer</w>thanks for the input</z><z id="t1519926116000349" t="wdullaer I can see how this is a worst case scenario"><y>#</y><d>2018-03-01</d><h>17:41</h><w>wdullaer</w>I can see how this is a worst case scenario</z><z id="t1519926183000104" t="wdullaer we probably won’t see this amount of massive updates in a real life scenario, and if it does (say a big data migration), we can always consider starting from scratch"><y>#</y><d>2018-03-01</d><h>17:43</h><w>wdullaer</w>we probably won’t see this amount of massive updates in a real life scenario, and if it does (say a big data migration), we can always consider starting from scratch</z><z id="t1519926229000255" t="wdullaer it was a bit surprising that updating these structures is a lot more expensive than creating them"><y>#</y><d>2018-03-01</d><h>17:43</h><w>wdullaer</w>it was a bit surprising that updating these structures is a lot more expensive than creating them</z><z id="t1519926259000074" t="wdullaer if I can help in any way here, just let me know"><y>#</y><d>2018-03-01</d><h>17:44</h><w>wdullaer</w>if I can help in any way here, just let me know</z><z id="t1519926274000475" t="wdullaer I have a few other benchmarks I’m going to run over the coming days as well"><y>#</y><d>2018-03-01</d><h>17:44</h><w>wdullaer</w>I have a few other benchmarks I’m going to run over the coming days as well</z><z id="t1519927107000104" t="mikerod I need to look deeper at what is happening to have a stronger sense of what could be done"><y>#</y><d>2018-03-01</d><h>17:58</h><w>mikerod</w>I need to look deeper at what is happening to have a stronger sense of what could be done</z><z id="t1519931439000179" t="wparker I’ve logged https://github.com/cerner/clara-rules/issues/385 for this @mikerod @wdullaer , I’d suggest that we post findings there when we have them"><y>#</y><d>2018-03-01</d><h>19:10</h><w>wparker</w>I’ve logged <a href="https://github.com/cerner/clara-rules/issues/385" target="_blank">https://github.com/cerner/clara-rules/issues/385</a> for this @mikerod @wdullaer , I’d suggest that we post findings there when we have them</z><z id="t1519931710000398" t="wparker From the snapshot it looks like the memory is the bottleneck, which isn’t too surprising. From my first glance over it I suspect there are some performance optimizations we can make for cases like this, but it may be a bit before I have time to write my thoughts down in a sufficiently articulate form. The benchmark and snapshot are really helpful and make diagnosing things like this much easier - thanks for that. It is useful to have benchmarks of realistic rule patterns that stress-test Clara."><y>#</y><d>2018-03-01</d><h>19:15</h><w>wparker</w>From the snapshot it looks like the memory is the bottleneck, which isn’t too surprising.  From my first glance over it I suspect there are some performance optimizations we can make for cases like this, but it may be a bit before I have time to write my thoughts down in a sufficiently articulate form.  The benchmark and snapshot are really helpful and make diagnosing things like this much easier - thanks for that.  It is useful to have benchmarks of realistic rule patterns that stress-test Clara.</z><z id="t1519984370000223" t="wdullaer the insert 1 million is realistic, the update 1 million slightly less so"><y>#</y><d>2018-03-02</d><h>09:52</h><w>wdullaer</w>the insert 1 million is realistic, the update 1 million slightly less so</z><z id="t1519984383000431" t="wdullaer thanks for all the help so far!"><y>#</y><d>2018-03-02</d><h>09:53</h><w>wdullaer</w>thanks for all the help so far!</z><z id="t1520007034000315" t="alex-dixon @wparker @mikerod Thanks for the clarification on https://github.com/cerner/clara-rules/issues/386 . Re: breaking changes, Precept recently experienced some with 0.17.0 and realized I should probably speak up about anything that might affect the implementation since I’m the only one that would really know 🙂 Sorry if I’m being overly concerned. It’s hard for me to investigate the effects of changes in detail myself due to time constraints lately, and hard in general since to me there’s a fair amount of complexity at work in Clara 🙂"><y>#</y><d>2018-03-02</d><h>16:10</h><w>alex-dixon</w>@wparker @mikerod Thanks for the clarification on <a href="https://github.com/cerner/clara-rules/issues/386" target="_blank">https://github.com/cerner/clara-rules/issues/386</a>. Re: breaking changes, Precept recently experienced some with 0.17.0 and realized I should probably speak up about anything that might affect the implementation since I’m the only one that would really know <b>🙂</b> Sorry if I’m being overly concerned. It’s hard for me to investigate the effects of changes in detail myself due to time constraints lately, and hard in general since to me there’s a fair amount of complexity at work in Clara <b>🙂</b></z><z id="t1520007521000434" t="wparker @alex-dixon what sorts of breaking changes? Have you tracked down the cause(s)? I totally understand not wanting to be blindsided by breaking changes and am glad you’re looking over the issue list. 🙂 If we created a regression of some kind or need to more clearly communicate public vs private boundaries of some API(s) in Clara that’d be good info to have."><y>#</y><d>2018-03-02</d><h>16:18</h><w>wparker</w>@alex-dixon what sorts of breaking changes?  Have you tracked down the cause(s)?  I totally understand not wanting to be blindsided by breaking changes and am glad you’re looking over the issue list. <b>🙂</b>  If we created a regression of some kind or need to more clearly communicate public vs private boundaries of some API(s) in Clara that’d be good info to have.</z><z id="t1520007721000249" t="alex-dixon Meh. It’s my responsibility. You guys do a great job. It’s been inspiring to me to see how much effort is put into backward compatibility. I’ve narrowed it down to a couple of commits but since it’s not something that’s fun to solve I haven’t looked very far 😄 https://github.com/CoNarrative/precept/issues/112"><y>#</y><d>2018-03-02</d><h>16:22</h><w>alex-dixon</w>Meh. It’s my responsibility. You guys do a great job. It’s been inspiring to me to see how much effort is put into backward compatibility. I’ve narrowed it down to a couple of commits but since it’s not something that’s fun to solve I haven’t looked very far <b>😄</b> <a href="https://github.com/CoNarrative/precept/issues/112" target="_blank">https://github.com/CoNarrative/precept/issues/112</a></z><z id="t1520008147000607" t="alex-dixon Basically I had some rules that I baked into every Precept session and in 0.17 they’re not making it in. Relevant spots in Precept code (which echoes Clara’s implementation considerably) may include: https://github.com/CoNarrative/precept/blob/master/src/clj/precept/macros.clj#L87 https://github.com/CoNarrative/precept/blob/690ba6cd30064901ce830b67ca92caaab9a68c93/src/cljc/precept/rules.cljc#L38"><y>#</y><d>2018-03-02</d><h>16:29</h><r>alex-dixon</r>Basically I had some rules that I baked into every Precept session and in 0.17 they’re not making it in. Relevant spots in Precept code (which echoes Clara’s implementation considerably) may include:
<a href="https://github.com/CoNarrative/precept/blob/master/src/clj/precept/macros.clj#L87" target="_blank">https://github.com/CoNarrative/precept/blob/master/src/clj/precept/macros.clj#L87</a>
<a href="https://github.com/CoNarrative/precept/blob/690ba6cd30064901ce830b67ca92caaab9a68c93/src/cljc/precept/rules.cljc#L38" target="_blank">https://github.com/CoNarrative/precept/blob/690ba6cd30064901ce830b67ca92caaab9a68c93/src/cljc/precept/rules.cljc#L38</a></z><z id="t1520008303000593" t="alex-dixon Pretty confident I can figure it out…seems related to namespace resolution changes that fix rules not being able to see vars defined in their namespace in CLJS. That’s definitely a fix I want so just need to take some time to make this work on my end"><y>#</y><d>2018-03-02</d><h>16:31</h><r>alex-dixon</r>Pretty confident I can figure it out…seems related to namespace resolution changes that fix rules not being able to see vars defined in their namespace in CLJS. That’s definitely a fix I want so just need to take some time to make this work on my end</z><z id="t1520008361000842" t="wparker Yeah, just giving it a fast glance it seems like you’re doing custom stuff with loading rules and such, and the changes in 359 could have impacted that somehow (again without looking at it in any detail). 359 was an obvious bug that needed to be fixed, but if we broke something else with it that ought to work let us know"><y>#</y><d>2018-03-02</d><h>16:32</h><r>wparker</r>Yeah, just giving it a fast glance it seems like you’re doing custom stuff with loading rules and such, and the changes in 359 could have impacted that somehow (again without looking at it in any detail).  359 was an obvious bug that needed to be fixed, but if we broke something else with it that ought to work let us know</z><z id="t1520019464000349" t="ProbablyJody @wdullaer for a workaround in your use case, would it make sense to first filter the consents? Your example shows 1/10th as many persons as events. Shrinking the search space by explicitly filtering the duplicates may speed things up."><y>#</y><d>2018-03-02</d><h>19:37</h><w>ProbablyJody</w>@wdullaer for a workaround in your use case, would it make sense to first filter the consents?  Your example shows 1/10th as many persons as events. Shrinking the search space by explicitly filtering the duplicates may speed things up.</z><z id="t1520019734000654" t="ProbablyJody So adding an additional defrecord DistinctConsent and a new rule to map from Consent to DistinctConsent The rest of the rules would just use DistinctConsent going forward"><y>#</y><d>2018-03-02</d><h>19:42</h><w>ProbablyJody</w>So adding an additional defrecord <code>DistinctConsent</code> and a new rule to map from <code>Consent</code> to <code>DistinctConsent</code>
The rest of the rules would just use DistinctConsent going forward</z><z id="t1520019750000050" t="ProbablyJody as an example"><y>#</y><d>2018-03-02</d><h>19:42</h><w>ProbablyJody</w>as an example</z><z id="t1520019750000160" t="wdullaer yes, I’ll probably try to prevent duplicate consent from being created"><y>#</y><d>2018-03-02</d><h>19:42</h><w>wdullaer</w>yes, I’ll probably try to prevent duplicate consent from being created</z><z id="t1520019781000546" t="wdullaer that’s also a cool way to handle it actually, I thought about querying before inserting"><y>#</y><d>2018-03-02</d><h>19:43</h><w>wdullaer</w>that’s also a cool way to handle it actually, I thought about querying before inserting</z><z id="t1520019828000654" t="ProbablyJody acc/distinct will still be managing a large object for retractions"><y>#</y><d>2018-03-02</d><h>19:43</h><w>ProbablyJody</w>acc/distinct will still be managing a large object for retractions</z><z id="t1520019855000441" t="ProbablyJody but it will be smaller than the cross product of Consents and Processors"><y>#</y><d>2018-03-02</d><h>19:44</h><w>ProbablyJody</w>but it will be smaller than the cross product of Consents and Processors</z><z id="t1520019934000117" t="wdullaer I don’t fully control how many consent items we’ll have for a given user"><y>#</y><d>2018-03-02</d><h>19:45</h><w>wdullaer</w>I don’t fully control how many consent items we’ll have for a given user</z><z id="t1520019952000520" t="wdullaer it depends on the granularity at which this will be recorded and that is not fully within my control"><y>#</y><d>2018-03-02</d><h>19:45</h><w>wdullaer</w>it depends on the granularity at which this will be recorded and that is not fully within my control</z><z id="t1520019975000476" t="ProbablyJody But you expect duplicate consents?"><y>#</y><d>2018-03-02</d><h>19:46</h><w>ProbablyJody</w>But you expect duplicate consents?</z><z id="t1520019989000276" t="wdullaer most certainly"><y>#</y><d>2018-03-02</d><h>19:46</h><w>wdullaer</w>most certainly</z><z id="t1520020000000467" t="ProbablyJody cool"><y>#</y><d>2018-03-02</d><h>19:46</h><w>ProbablyJody</w>cool</z><z id="t1520020696000697" t="ProbablyJody another thought (possibly in addition to the previous one) was to explode the Processor facts into something like DesiredConsent [processorId purpose attribute] , use a rule to match them to a Consent and dump into another intermediate fact ApprovedDesiredConsent [processorId personId purpose attribute] . Then accumulate and match your ApprovedDesiredConsent to the Processor. I haven’t tested it, so I don’t know if it’s more performant, but the idea/hope is that you’d accumulate less when creating the AllowedProcessor"><y>#</y><d>2018-03-02</d><h>19:58</h><w>ProbablyJody</w>another thought (possibly in addition to the previous one) was to explode the Processor facts into something like <code>DesiredConsent [processorId purpose attribute]</code>, use a rule to match them to a Consent and dump into another intermediate fact <code>ApprovedDesiredConsent [processorId personId purpose attribute]</code>. Then accumulate and match your ApprovedDesiredConsent to the Processor.

I haven’t tested it, so I don’t know if it’s more performant, but the idea/hope is that you’d accumulate less when creating the AllowedProcessor</z><z id="t1520022553000594" t="wdullaer I’ll experiment with some of these on Monday"><y>#</y><d>2018-03-02</d><h>20:29</h><w>wdullaer</w>I’ll experiment with some of these on Monday</z><z id="t1520022596000499" t="wdullaer the easiest I think is to just ensure that no duplicate consents are asserted, which I think I can do out of band (the consent will intially be put on a log)"><y>#</y><d>2018-03-02</d><h>20:29</h><w>wdullaer</w>the easiest I think is to just ensure that no duplicate consents are asserted, which I think I can do out of band (the consent will intially be put on a log)</z><z id="t1520057606000012" t="olivergeorge Newbie question... I&apos;m struggling to write a rule which boils down to &quot;This or that&quot;."><y>#</y><d>2018-03-03</d><h>06:13</h><w>olivergeorge</w>Newbie question... I&apos;m struggling to write a rule which boils down to &quot;This or that&quot;.</z><z id="t1520057612000015" t="olivergeorge (defrecord This [x]) (defrecord That [y]) (defrule this-or-that &quot;Print This if fact exists, else print That.&quot; [:or [?x &lt;- This] [?x &lt;- That]] =&gt; (println :this-or-that ?x)) (-&gt; (mk-session &apos;labs-costs-clara.core) (insert (-&gt;This 1) (-&gt;That 2)) (fire-rules))"><y>#</y><d>2018-03-03</d><h>06:13</h><w>olivergeorge</w><pre>(defrecord This [x])
  (defrecord That [y])
  (defrule this-or-that
    &quot;Print This if fact exists, else print That.&quot;
    [:or [?x &lt;- This] [?x &lt;- That]]
    =&gt;
    (println :this-or-that ?x))

  (-&gt; (mk-session &apos;labs-costs-clara.core)
      (insert
        (-&gt;This 1)
        (-&gt;That 2))
      (fire-rules))</pre></z><z id="t1520057627000114" t="olivergeorge This will print twice which isn&apos;t what I&apos;m after."><y>#</y><d>2018-03-03</d><h>06:13</h><w>olivergeorge</w>This will print twice which isn&apos;t what I&apos;m after.</z><z id="t1520057650000083" t="olivergeorge (my real example is patching data... if X exists use it else use some other facts to fill in the gap)"><y>#</y><d>2018-03-03</d><h>06:14</h><w>olivergeorge</w>(my real example is patching data... if X exists use it else use some other facts to fill in the gap)</z><z id="t1520057665000005" t="zylox ya, or isnt a xor, it can indeed follow both paths"><y>#</y><d>2018-03-03</d><h>06:14</h><w>zylox</w>ya, or isnt a xor, it can indeed follow both paths</z><z id="t1520057688000086" t="zylox i tend to think of it as if you had two disjunct rules"><y>#</y><d>2018-03-03</d><h>06:14</h><w>zylox</w>i tend to think of it as if you had two disjunct rules</z><z id="t1520057697000063" t="zylox because that is pretty close to what it does"><y>#</y><d>2018-03-03</d><h>06:14</h><w>zylox</w>because that is pretty close to what it does</z><z id="t1520057734000058" t="zylox if you want one but not the other...well you are going to want to use two rules with :not on This in one and That on the other"><y>#</y><d>2018-03-03</d><h>06:15</h><w>zylox</w>if you want one but not the other...well you are going to want to use two rules with <code>:not</code> on <code>This</code> in one and <code>That</code> on the other</z><z id="t1520057747000077" t="olivergeorge That makes sense. My rules got a bit verbose which is what got me wondering."><y>#</y><d>2018-03-03</d><h>06:15</h><w>olivergeorge</w>That makes sense.  My rules got a bit verbose which is what got me wondering.</z><z id="t1520057749000014" t="olivergeorge Thanks"><y>#</y><d>2018-03-03</d><h>06:15</h><w>olivergeorge</w>Thanks</z><z id="t1520057775000065" t="olivergeorge The only alternative I could imagine was some kind of maybe accumulator"><y>#</y><d>2018-03-03</d><h>06:16</h><w>olivergeorge</w>The only alternative I could imagine was some kind of <code>maybe</code> accumulator</z><z id="t1520057784000030" t="olivergeorge (e.g. distinct but expecting one fact)"><y>#</y><d>2018-03-03</d><h>06:16</h><w>olivergeorge</w>(e.g. distinct but expecting one fact)</z><z id="t1520057820000024" t="zylox are you expecting only one, or potentially many"><y>#</y><d>2018-03-03</d><h>06:17</h><w>zylox</w>are you expecting only one, or potentially many</z><z id="t1520057862000013" t="olivergeorge My code was really &quot;if summary value exists use it, else calculate from many other facts&quot; but that&apos;s not critical to the general question."><y>#</y><d>2018-03-03</d><h>06:17</h><w>olivergeorge</w>My code was really &quot;if summary value exists use it, else calculate from many other facts&quot; but that&apos;s not critical to the general question.</z><z id="t1520057926000002" t="olivergeorge Thanks for your thoughts @zylox that makes me feel more confident"><y>#</y><d>2018-03-03</d><h>06:18</h><w>olivergeorge</w>Thanks for your thoughts @zylox that makes me feel more confident</z><z id="t1520058009000059" t="zylox gotcha. id suggest something like (defrule with-summary &quot;&quot; [Summary (= ?data data)] =&gt; (println ?data)) (defrule without-summary &quot;&quot; [:not [Summary]] [?others &lt;- (acc/all) :from [SecondaryFacts]] =&gt; (println ?others)) then"><y>#</y><d>2018-03-03</d><h>06:20</h><w>zylox</w>gotcha. id suggest something like <pre>(defrule with-summary
  &quot;&quot;
  [Summary (= ?data data)]
  =&gt;
  (println ?data))

(defrule without-summary
  &quot;&quot;
  [:not [Summary]]
  [?others &lt;- (acc/all) :from [SecondaryFacts]]
  
  =&gt;
  (println ?others))</pre> then</z><z id="t1520058015000060" t="zylox best of luck"><y>#</y><d>2018-03-03</d><h>06:20</h><w>zylox</w>best of luck</z><z id="t1520058034000001" t="olivergeorge Thank you"><y>#</y><d>2018-03-03</d><h>06:20</h><w>olivergeorge</w>Thank you</z><z id="t1520058100000026" t="zylox without all the horrible syntax errors i just edited out haha"><y>#</y><d>2018-03-03</d><h>06:21</h><w>zylox</w>without all the horrible syntax errors i just edited out haha</z><z id="t1520180997000005" t="sekao hey, has anyone tried clara with clojurescript 1.10.126? i&apos;m getting a bunch of arity warnings about MapEntry and at runtime i&apos;m getting Maximum call stack size exceeded from schema.core (where mapentry is defined)"><y>#</y><d>2018-03-04</d><h>16:29</h><w>sekao</w>hey, has anyone tried clara with clojurescript 1.10.126? i&apos;m getting a bunch of arity warnings about <code>MapEntry</code> and at runtime i&apos;m getting <code>Maximum call stack size exceeded</code> from <code>schema.core</code> (where mapentry is defined)</z><z id="t1520181048000004" t="sekao i&apos;m guessing schema is not playing well with it. i noticed in their changelog that they had to fix some MapEntry warnings in 1.1.6, but clara is already using that version so this must be a new problem"><y>#</y><d>2018-03-04</d><h>16:30</h><w>sekao</w>i&apos;m guessing schema is not playing well with it. i noticed in their changelog that they had to fix some <code>MapEntry</code> warnings in 1.1.6, but clara is already using that version so this must be a new problem</z><z id="t1520181969000134" t="alex-dixon @sekao Haven’t tried that version. I’m on 1.9.854"><y>#</y><d>2018-03-04</d><h>16:46</h><w>alex-dixon</w>@sekao Haven’t tried that version. I’m on 1.9.854</z><z id="t1520182058000030" t="alex-dixon I’ve had problems with the schema library in the past though. I think I got around it by excluding clara’s version and using a newer one. That might not work in this case though"><y>#</y><d>2018-03-04</d><h>16:47</h><w>alex-dixon</w>I’ve had problems with the schema library in the past though. I think I got around it by excluding clara’s version and using a newer one. That might not work in this case though</z><z id="t1520182069000031" t="alex-dixon What version of Clara are you using?"><y>#</y><d>2018-03-04</d><h>16:47</h><w>alex-dixon</w>What version of Clara are you using?</z><z id="t1520182168000038" t="sekao i&apos;m using 0.17.0 but it happens with master as well. i just mentioned it on the clojurescript channel and it sounds like it is conflicting with MapEntry in cljs.core"><y>#</y><d>2018-03-04</d><h>16:49</h><w>sekao</w>i&apos;m using 0.17.0 but it happens with master as well. i just mentioned it on the clojurescript channel and it sounds like it is conflicting with <code>MapEntry</code> in cljs.core</z><z id="t1520191217000095" t="mikerod @sekao so this is a schema issue with the new cljs version then?"><y>#</y><d>2018-03-04</d><h>19:20</h><w>mikerod</w>@sekao so this is a schema issue with the new cljs version then?</z><z id="t1520191874000017" t="sekao yep it seems so"><y>#</y><d>2018-03-04</d><h>19:31</h><w>sekao</w>yep it seems so</z><z id="t1520192008000137" t="mikerod Alright. Hmm. I guess schema needs to get fixed..."><y>#</y><d>2018-03-04</d><h>19:33</h><w>mikerod</w>Alright. Hmm. I guess schema needs to get fixed...</z><z id="t1520192035000105" t="sekao is it still actively maintained?"><y>#</y><d>2018-03-04</d><h>19:33</h><w>sekao</w>is it still actively maintained?</z><z id="t1520196582000075" t="mikerod @sekao yeah I wasn’t sure on that. "><y>#</y><d>2018-03-04</d><h>20:49</h><w>mikerod</w>@sekao yeah I wasn’t sure on that. </z><z id="t1520196626000080" t="mikerod I think they at least probably still take pull requests"><y>#</y><d>2018-03-04</d><h>20:50</h><w>mikerod</w>I think they at least probably still take pull requests</z><z id="t1521051648000261" t="afurmanov Why this code (ns experiments.a (:require [clara.rules :as rules] [clojure.pprint :refer [pprint]])) (defrecord A [id]) (rules/defrule create-a-if-not-exists &quot;&quot; [:not [A]] =&gt; (println &quot;creating A&quot;) (rules/insert! (-&gt;A &quot;a&quot;))) (-&gt; (rules/mk-session) (rules/fire-rules)) "><y>#</y><d>2018-03-14</d><h>18:20</h><w>afurmanov</w>Why this code <pre>(ns experiments.a
  (:require [clara.rules :as rules]

            [clojure.pprint :refer [pprint]]))

(defrecord A [id])

(rules/defrule create-a-if-not-exists
  &quot;&quot;
  [:not [A]]
  =&gt;
  (println &quot;creating A&quot;)
  (rules/insert! (-&gt;A &quot;a&quot;)))

(-&gt; (rules/mk-session)
    (rules/fire-rules))
</pre></z><z id="t1521051659000261" t="afurmanov creates infinite recursion?"><y>#</y><d>2018-03-14</d><h>18:20</h><w>afurmanov</w>creates infinite recursion?</z><z id="t1521052060000284" t="ethanc The initial state of the session makes the LHS of your rule evaluate as true thus it inserts an A , which then makes your rule&apos;s LHS evaluate as false causing the truth maintenance of clara to logically retract the A that was insert. repeat"><y>#</y><d>2018-03-14</d><h>18:27</h><w>ethanc</w>The initial state of the session makes the LHS of your rule evaluate as <code>true</code> thus it inserts an <code>A</code>,
 which then makes your rule&apos;s LHS evaluate as <code>false</code> causing the truth maintenance of clara to logically retract the <code>A</code> that was insert.
repeat</z><z id="t1521052075000715" t="ethanc forever"><y>#</y><d>2018-03-14</d><h>18:27</h><w>ethanc</w>forever</z><z id="t1521052081000731" t="ethanc @alex.furmanov"><y>#</y><d>2018-03-14</d><h>18:28</h><w>ethanc</w>@alex.furmanov</z><z id="t1521052121000764" t="zylox &quot;ok i&apos;ll insert a if there is no A. Inserting. Ok now lets look at the state of things. Oh there is an A. Retract That thing i inserted. Ok now lets look at the state of things. Oh there is no A. Time to insert A....&quot; ~ Internal monologue of the session repeat ad infinitum"><y>#</y><d>2018-03-14</d><h>18:28</h><w>zylox</w>&quot;ok i&apos;ll insert a if there is no A. Inserting. Ok now lets look at the state of things. Oh there is an A. Retract That thing i inserted. Ok now lets look at the state of things. Oh there is no A. Time to insert A....&quot; ~ Internal monologue of the session repeat ad infinitum</z><z id="t1521052206000651" t="zylox http://www.clara-rules.org/docs/truthmaint/ truth maintenance is the name of the game"><y>#</y><d>2018-03-14</d><h>18:30</h><w>zylox</w><a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a> truth maintenance is the name of the game</z><z id="t1521052504000104" t="afurmanov Thanks!"><y>#</y><d>2018-03-14</d><h>18:35</h><w>afurmanov</w>Thanks!</z><z id="t1521385836000111" t="sparkofreason The trace listener feature is very helpful for finding the cause of loops."><y>#</y><d>2018-03-18</d><h>15:10</h><w>sparkofreason</w>The trace listener feature is very helpful for finding the cause of loops.</z><z id="t1521648062000129" t="talgiat is there a way to query for all types but one?"><y>#</y><d>2018-03-21</d><h>16:01</h><w>talgiat</w>is there a way to query for all types but one?</z><z id="t1521648310000503" t="mikerod @talgiat the main problem I’d see with doing something like that is that the query may become a performance problem"><y>#</y><d>2018-03-21</d><h>16:05</h><w>mikerod</w>@talgiat the main problem I’d see with doing something like that is that the query may become a performance problem</z><z id="t1521648340000937" t="mikerod It would be heavily hit since it’s working memory will change any time any fact in working memory is inserted/retracted (including from truth maintenance)"><y>#</y><d>2018-03-21</d><h>16:05</h><w>mikerod</w>It would be heavily hit since it’s working memory will change any time any fact in working memory is inserted/retracted (including from truth maintenance)</z><z id="t1521648436000603" t="mikerod You could probably do what you ask though: (r/defquery [] [?o &lt;- Object] [:test (not (isa? (type ?o) ExcludedType))]) "><y>#</y><d>2018-03-21</d><h>16:07</h><w>mikerod</w>You could probably do what you ask though:
<pre>(r/defquery []
  [?o &lt;- Object]
  [:test (not (isa? (type ?o) ExcludedType))])

</pre></z><z id="t1521648452000613" t="mikerod If you have a custom :fact-type-fn you could still accomplish similar"><y>#</y><d>2018-03-21</d><h>16:07</h><w>mikerod</w>If you have a custom <code>:fact-type-fn</code> you could still accomplish similar</z><z id="t1521649818000479" t="talgiat I do have a :fact-type-fn"><y>#</y><d>2018-03-21</d><h>16:30</h><w>talgiat</w>I do have a :fact-type-fn</z><z id="t1521651683000927" t="mikerod @talgiat you’d have to define an hierarchy then more than likely"><y>#</y><d>2018-03-21</d><h>17:01</h><w>mikerod</w>@talgiat you’d have to define an hierarchy then more than likely</z><z id="t1521651731000367" t="mikerod See http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2018-03-21</d><h>17:02</h><w>mikerod</w>See <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1521651763000747" t="mikerod Potentially you could derive all your types to a common ancestor type."><y>#</y><d>2018-03-21</d><h>17:02</h><w>mikerod</w>Potentially you could <code>derive</code> all your types to a common ancestor type.</z><z id="t1521651808000342" t="mikerod You could leave out the excluded type from that grouping too, and then your query would just be r/defquery my-q [] [?x &lt;- :parent-type]"><y>#</y><d>2018-03-21</d><h>17:03</h><w>mikerod</w>You could leave out the excluded type from that grouping too, and then your query would just be <code>r/defquery my-q [] [?x &lt;- :parent-type]</code></z><z id="t1521652373000314" t="talgiat yeah, thought about that"><y>#</y><d>2018-03-21</d><h>17:12</h><w>talgiat</w>yeah, thought about that</z><z id="t1521652389000778" t="talgiat prob. better with records implementing a common protocol that will be the parent"><y>#</y><d>2018-03-21</d><h>17:13</h><w>talgiat</w>prob. better with records implementing a common protocol that will be the parent</z><z id="t1521655355000087" t="mikerod @talgiat it can go either way really"><y>#</y><d>2018-03-21</d><h>18:02</h><w>mikerod</w>@talgiat it can go either way really</z><z id="t1522266714000241" t="talgiat Is there a way to have a short circuiting :or in clara, not sure why it is designed that way"><y>#</y><d>2018-03-28</d><h>19:51</h><w>talgiat</w>Is there a way to have a short circuiting :or in clara, not sure why it is designed that way</z><z id="t1522266770000546" t="mikerod @talgiat they aren’t meant for that. They are mostly just syntax sugar for multiple rules"><y>#</y><d>2018-03-28</d><h>19:52</h><w>mikerod</w>@talgiat they aren’t meant for that. They are mostly just syntax sugar for multiple rules</z><z id="t1522266787000656" t="mikerod In the case of you were sharing the stuff around the :or (prior conditions) and the RHS"><y>#</y><d>2018-03-28</d><h>19:53</h><w>mikerod</w>In the case of you were sharing the stuff around the <code>:or</code> (prior conditions) and the RHS</z><z id="t1522266809000175" t="mikerod you can implement a “short circuit ” pattern via multiple rules by making rules that are prioritized over one another"><y>#</y><d>2018-03-28</d><h>19:53</h><w>mikerod</w>you can implement a “short circuit ” pattern via multiple rules by making rules that are prioritized over one another</z><z id="t1522266835000211" t="talgiat can you give an example?"><y>#</y><d>2018-03-28</d><h>19:53</h><w>talgiat</w>can you give an example?</z><z id="t1522266972000517" t="mikerod here is one I made for unrelated reasons mostly https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac"><y>#</y><d>2018-03-28</d><h>19:56</h><w>mikerod</w>here is one I made for unrelated reasons mostly <a href="https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac" target="_blank">https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac</a></z><z id="t1522266990000023" t="mikerod I can probably do a shorter one in a min"><y>#</y><d>2018-03-28</d><h>19:56</h><w>mikerod</w>I can probably do a shorter one in a min</z><z id="t1522267055000416" t="talgiat yeah this example is in response to my colleague"><y>#</y><d>2018-03-28</d><h>19:57</h><w>talgiat</w>yeah this example is in response to my colleague</z><z id="t1522267061000641" t="talgiat we’re working on the same problem"><y>#</y><d>2018-03-28</d><h>19:57</h><w>talgiat</w>we’re working on the same problem</z><z id="t1522267087000527" t="talgiat just seems kinda hackish"><y>#</y><d>2018-03-28</d><h>19:58</h><w>talgiat</w>just seems kinda hackish</z><z id="t1522267096000353" t="talgiat also you need to know about the other rules"><y>#</y><d>2018-03-28</d><h>19:58</h><w>talgiat</w>also you need to know about the other rules</z><z id="t1522267118000182" t="mikerod (r/defrule short-circuit [X] ;; whatever here =&gt; (r/insert! &lt;your fact here&gt; :rule-marker/short-circuit)) (defrule fallback [:not [:rule-marker/short-circuit]] [Y] =&gt; (r/insert! &lt;your fact here&gt;)) "><y>#</y><d>2018-03-28</d><h>19:58</h><w>mikerod</w><pre>(r/defrule short-circuit
  [X] ;; whatever here
  =&gt;
  (r/insert! &lt;your fact here&gt;
             :rule-marker/short-circuit))

(defrule fallback
  [:not [:rule-marker/short-circuit]]
  [Y]
  =&gt;
  (r/insert! &lt;your fact here&gt;))
</pre></z><z id="t1522267124000564" t="mikerod I see"><y>#</y><d>2018-03-28</d><h>19:58</h><w>mikerod</w>I see</z><z id="t1522267158000742" t="mikerod I don’t know that I see it as hackish. I do understand it could be brittle to more rules added"><y>#</y><d>2018-03-28</d><h>19:59</h><w>mikerod</w>I don’t know that I see it as hackish. I do understand it could be brittle to more rules added</z><z id="t1522267160000551" t="talgiat here is what we have"><y>#</y><d>2018-03-28</d><h>19:59</h><w>talgiat</w>here is what we have</z><z id="t1522267162000319" t="talgiat `"><y>#</y><d>2018-03-28</d><h>19:59</h><w>talgiat</w><code></code>`</z><z id="t1522267163000320" t="talgiat (defrule premium-video [Video (= ?id id)] [:or [PremiumChannels (= id ?id)] [LessThanTwoHours (= id ?id)] [PremiumTopics (= id ?id)]] =&gt; (insert! (create-rule-result -&gt;MarketplacePremiumVideoContent ?id (-&gt;Rule 1 “Premium Video” :points 6)))))"><y>#</y><d>2018-03-28</d><h>19:59</h><w>talgiat</w>(defrule premium-video
  [Video (= ?id id)]
  [:or
    [PremiumChannels (= id ?id)]
    [LessThanTwoHours (= id ?id)]
    [PremiumTopics (= id ?id)]]
  =&gt;
  (insert! (create-rule-result -&gt;MarketplacePremiumVideoContent ?id (-&gt;Rule 1 “Premium Video” :points 6)))))</z><z id="t1522267165000392" t="talgiat `"><y>#</y><d>2018-03-28</d><h>19:59</h><w>talgiat</w><code></code>`</z><z id="t1522267177000548" t="talgiat ignore the create rule-result"><y>#</y><d>2018-03-28</d><h>19:59</h><w>talgiat</w>ignore the create rule-result</z><z id="t1522267181000103" t="mikerod however a big short-circuiting :or would also be just order dependent on all the logic pushed into it"><y>#</y><d>2018-03-28</d><h>19:59</h><w>mikerod</w>however a big short-circuiting <code>:or</code> would also be just order dependent on all the logic pushed into it</z><z id="t1522267213000036" t="mikerod another thing you can do"><y>#</y><d>2018-03-28</d><h>20:00</h><w>mikerod</w>another thing you can do</z><z id="t1522267219000677" t="mikerod Is let the :or fire as much as it can"><y>#</y><d>2018-03-28</d><h>20:00</h><w>mikerod</w>Is let the <code>:or</code> fire as much as it can</z><z id="t1522267227000412" t="mikerod then reconcile in a separate rule to “choose the best”"><y>#</y><d>2018-03-28</d><h>20:00</h><w>mikerod</w>then reconcile in a separate rule to “choose the best”</z><z id="t1522267238000577" t="talgiat there is no best per se"><y>#</y><d>2018-03-28</d><h>20:00</h><w>talgiat</w>there is no best per se</z><z id="t1522267247000598" t="talgiat they are all equal importance"><y>#</y><d>2018-03-28</d><h>20:00</h><w>talgiat</w>they are all equal importance</z><z id="t1522267260000089" t="mikerod so what is the reason to want short-circuit"><y>#</y><d>2018-03-28</d><h>20:01</h><w>mikerod</w>so what is the reason to want short-circuit</z><z id="t1522267274000546" t="mikerod Do you just not want multiple facts inserted?"><y>#</y><d>2018-03-28</d><h>20:01</h><w>mikerod</w>Do you just not want multiple facts inserted?</z><z id="t1522267284000526" t="talgiat `"><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w><code></code>`</z><z id="t1522267291000314" t="talgiat (defrule premium-video [Video (= ?id id)] [:not [MarketplacePremiumVideoContent (= id ?id)]] [:or [PremiumChannels (= id ?id)] [LessThanTwoHours (= id ?id)] [PremiumTopics (= id ?id)]] =&gt; (insert! (create-rule-result -&gt;MarketplacePremiumVideoContent ?id (-&gt;Rule 1 &quot;Premium Video&quot; :points 6))))) "><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w><pre>(defrule premium-video
  [Video (= ?id id)]
  [:not [MarketplacePremiumVideoContent (= id ?id)]]
  [:or
    [PremiumChannels (= id ?id)]
    [LessThanTwoHours (= id ?id)]
    [PremiumTopics (= id ?id)]]
  =&gt;
  (insert! (create-rule-result -&gt;MarketplacePremiumVideoContent ?id (-&gt;Rule 1 &quot;Premium Video&quot; :points 6)))))
</pre></z><z id="t1522267293000844" t="talgiat I tried this"><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w>I tried this</z><z id="t1522267301000560" t="talgiat but it went to an infinite loop"><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w>but it went to an infinite loop</z><z id="t1522267303000544" t="talgiat not sure why"><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w>not sure why</z><z id="t1522267313000332" t="talgiat yeah I just want one fact to be inserted"><y>#</y><d>2018-03-28</d><h>20:01</h><w>talgiat</w>yeah I just want one fact to be inserted</z><z id="t1522267338000403" t="mikerod (r/defrule rule-with-or [:or [A] [B] [C]] =&gt; (r/insert! (-&gt;FoundIt))) (r/defrule aggregate-found [?found &lt;- (acc/all) :from [FoundIt]] [:test (seq ?found)] =&gt; (r/insert! (do-aggregation ?found))) "><y>#</y><d>2018-03-28</d><h>20:02</h><w>mikerod</w><pre>(r/defrule rule-with-or
  [:or
   [A]
   [B]
   [C]]
  =&gt;
  (r/insert! (-&gt;FoundIt)))

(r/defrule aggregate-found
  [?found &lt;- (acc/all) :from [FoundIt]]
 [:test (seq ?found)]
  =&gt;
  (r/insert! (do-aggregation ?found)))
</pre></z><z id="t1522267343000084" t="mikerod Insert a middle-fact"><y>#</y><d>2018-03-28</d><h>20:02</h><w>mikerod</w>Insert a middle-fact</z><z id="t1522267350000324" t="mikerod that you aggregate to a single fact"><y>#</y><d>2018-03-28</d><h>20:02</h><w>mikerod</w>that you aggregate to a single fact</z><z id="t1522267356000616" t="mikerod for “downstream” rules to only see 1 fact"><y>#</y><d>2018-03-28</d><h>20:02</h><w>mikerod</w>for “downstream” rules to only see 1 fact</z><z id="t1522267373000349" t="mikerod this can be either a merge or just pick one if they are all the same, etc"><y>#</y><d>2018-03-28</d><h>20:02</h><w>mikerod</w>this can be either a <code>merge</code> or just pick one if they are all the same, etc</z><z id="t1522267396000311" t="mikerod (r/defrule aggregate-found [?found &lt;- (acc/all) :from [FoundIt]] [:test (seq ?found)] =&gt; ;; They are all the same, so I dont&apos; care (r/insert! (first ?found))) "><y>#</y><d>2018-03-28</d><h>20:03</h><w>mikerod</w><pre>(r/defrule aggregate-found
  [?found &lt;- (acc/all) :from [FoundIt]]
 [:test (seq ?found)]
  =&gt;
;; They are all the same, so I dont&apos; care
  (r/insert! (first ?found)))

</pre></z><z id="t1522267417000123" t="mikerod I should add a non-empty check to just avoid useless fires"><y>#</y><d>2018-03-28</d><h>20:03</h><w>mikerod</w>I should add a non-empty check to just avoid useless fires</z><z id="t1522267510000414" t="mikerod &gt; but it went to an infinite loop I believe your rule is invalidating itself"><y>#</y><d>2018-03-28</d><h>20:05</h><w>mikerod</w>&gt; but it went to an infinite loop

I believe your rule is invalidating itself</z><z id="t1522267513000245" t="mikerod logically"><y>#</y><d>2018-03-28</d><h>20:05</h><w>mikerod</w>logically</z><z id="t1522267521000376" t="mikerod however, I don’t know for sure not knowing what create-rule-result does"><y>#</y><d>2018-03-28</d><h>20:05</h><w>mikerod</w>however, I don’t know for sure not knowing what <code>create-rule-result</code> does</z><z id="t1522267544000650" t="talgiat it just creates a record and adds some other metadata to it"><y>#</y><d>2018-03-28</d><h>20:05</h><w>talgiat</w>it just creates a record and adds some other metadata to it</z><z id="t1522267547000549" t="mikerod if somehow the RHS (or later rule) leads to a MarketplacePremiumVideoContent to be inserted with that ?id then you’d get a loop"><y>#</y><d>2018-03-28</d><h>20:05</h><w>mikerod</w>if somehow the RHS (or later rule) leads to a <code>MarketplacePremiumVideoContent</code> to be inserted with that <code>?id</code> then you’d get a loop</z><z id="t1522267563000082" t="mikerod because it’d get inserted, which would make the :not become false"><y>#</y><d>2018-03-28</d><h>20:06</h><w>mikerod</w>because it’d get inserted, which would make the <code>:not</code> become false</z><z id="t1522267566000751" t="mikerod so it’d be retracted"><y>#</y><d>2018-03-28</d><h>20:06</h><w>mikerod</w>so it’d be retracted</z><z id="t1522267589000018" t="mikerod but then :not would be true again, so it’d get reinserted, but then :not would be false again, so it’d be retracted - and repeat"><y>#</y><d>2018-03-28</d><h>20:06</h><w>mikerod</w>but then <code>:not</code> would be true again, so it’d get reinserted, but then <code>:not</code> would be false again, so it’d be retracted - and repeat</z><z id="t1522267593000515" t="talgiat I see"><y>#</y><d>2018-03-28</d><h>20:06</h><w>talgiat</w>I see</z><z id="t1522267606000186" t="talgiat yeah, a bit of a mind bender"><y>#</y><d>2018-03-28</d><h>20:06</h><w>talgiat</w>yeah, a bit of a mind bender</z><z id="t1522267608000304" t="talgiat 🙂"><y>#</y><d>2018-03-28</d><h>20:06</h><w>talgiat</w><b>🙂</b></z><z id="t1522267617000504" t="mikerod it’s best to try to think of the rules as declarative and order-independent"><y>#</y><d>2018-03-28</d><h>20:06</h><w>mikerod</w>it’s best to try to think of the rules as declarative and order-independent</z><z id="t1522267620000621" t="mikerod where possible"><y>#</y><d>2018-03-28</d><h>20:07</h><w>mikerod</w>where possible</z><z id="t1522267623000295" t="talgiat at least for people who are not used to rule engines or logic programming"><y>#</y><d>2018-03-28</d><h>20:07</h><w>talgiat</w>at least for people who are not used to rule engines or logic programming</z><z id="t1522267647000485" t="mikerod and their job is to bring working memory into a steady and logically consistent state with all of the LHS of all rules"><y>#</y><d>2018-03-28</d><h>20:07</h><w>mikerod</w>and their job is to bring working memory into a steady and logically consistent state with all of the LHS of all rules</z><z id="t1522267661000682" t="mikerod It can be a trick sometimes"><y>#</y><d>2018-03-28</d><h>20:07</h><w>mikerod</w>It can be a trick sometimes</z><z id="t1522267687000461" t="talgiat the multiple inserts don’t impact our end results correctness"><y>#</y><d>2018-03-28</d><h>20:08</h><w>talgiat</w>the multiple inserts don’t impact our end results correctness</z><z id="t1522267696000224" t="talgiat I just noticed it when testing and didn’t understand why"><y>#</y><d>2018-03-28</d><h>20:08</h><w>talgiat</w>I just noticed it when testing and didn’t understand why</z><z id="t1522267707000258" t="talgiat but thanks so much for the clarification"><y>#</y><d>2018-03-28</d><h>20:08</h><w>talgiat</w>but thanks so much for the clarification</z><z id="t1522267774000529" t="mikerod yeah, I find the “aggregating” to one idea common"><y>#</y><d>2018-03-28</d><h>20:09</h><w>mikerod</w>yeah, I find the “aggregating” to one idea common</z><z id="t1522267790000057" t="mikerod I think the main takeaway is that the rules don’t short-circuit or control “duplcates” for you"><y>#</y><d>2018-03-28</d><h>20:09</h><w>mikerod</w>I think the main takeaway is that the rules don’t short-circuit or control “duplcates” for you</z><z id="t1522267795000488" t="mikerod it lets you decide what makes sense there"><y>#</y><d>2018-03-28</d><h>20:09</h><w>mikerod</w>it lets you decide what makes sense there</z><z id="t1522267811000097" t="mikerod I’d say though, don’t be afraid to introduce “intermediate facts”"><y>#</y><d>2018-03-28</d><h>20:10</h><w>mikerod</w>I’d say though, don’t be afraid to introduce “intermediate facts”</z><z id="t1522267817000463" t="mikerod to tie multiple rules together"><y>#</y><d>2018-03-28</d><h>20:10</h><w>mikerod</w>to tie multiple rules together</z><z id="t1522267854000429" t="talgiat Yeah that makes sense"><y>#</y><d>2018-03-28</d><h>20:10</h><w>talgiat</w>Yeah that makes sense</z><z id="t1522267874000561" t="mikerod So rule-with-multiple-duplicate-inserts-possible and aggregate-the-duplicates rules with an intermediate/ephemeral fact between the two"><y>#</y><d>2018-03-28</d><h>20:11</h><w>mikerod</w>So <code>rule-with-multiple-duplicate-inserts-possible</code> and <code>aggregate-the-duplicates</code> rules with an intermediate/ephemeral fact between the two</z><z id="t1522267887000546" t="mikerod then most other “downstream” rules just take the aggregated selection fact"><y>#</y><d>2018-03-28</d><h>20:11</h><w>mikerod</w>then most other “downstream” rules just take the aggregated selection fact</z><z id="t1522267907000320" t="mikerod Later on, there may be more complex reasoning in the aggregate-the-duplicates than just “take one”"><y>#</y><d>2018-03-28</d><h>20:11</h><w>mikerod</w>Later on, there may be more complex reasoning in the <code>aggregate-the-duplicates</code> than just “take one”</z><z id="t1522267926000658" t="talgiat yeah in our case it really doesn’t matter"><y>#</y><d>2018-03-28</d><h>20:12</h><w>talgiat</w>yeah in our case it really doesn’t matter</z><z id="t1522267930000410" t="mikerod if for example, they are no longer complete duplicates, or perhaps you want to count how many times it was “true” by counting the duplicates"><y>#</y><d>2018-03-28</d><h>20:12</h><w>mikerod</w>if for example, they are no longer complete duplicates, or perhaps you want to count how many times it was “true” by counting the duplicates</z><z id="t1522267933000772" t="mikerod sure"><y>#</y><d>2018-03-28</d><h>20:12</h><w>mikerod</w>sure</z><z id="t1522267947000620" t="talgiat but I see the point"><y>#</y><d>2018-03-28</d><h>20:12</h><w>talgiat</w>but I see the point</z><z id="t1522267955000140" t="mikerod It’s been discussed before to have a working-memory-as-a-set sort of Clara mode"><y>#</y><d>2018-03-28</d><h>20:12</h><w>mikerod</w>It’s been discussed before to have a working-memory-as-a-set sort of Clara mode</z><z id="t1522267962000021" t="talgiat I just think it’ll helpful to have a real or"><y>#</y><d>2018-03-28</d><h>20:12</h><w>talgiat</w>I just think it’ll helpful to have a real or</z><z id="t1522267974000039" t="talgiat instead of doing the heavy lifting yourself"><y>#</y><d>2018-03-28</d><h>20:12</h><w>talgiat</w>instead of doing the heavy lifting yourself</z><z id="t1522267982000542" t="talgiat like a purposeful or"><y>#</y><d>2018-03-28</d><h>20:13</h><w>talgiat</w>like a purposeful or</z><z id="t1522268006000676" t="mikerod where there were never duplicates inserted, etc. Drools does that by default with logical insert (managed by truth maintenance). However, it does have a performance cost to manage a set for working memory (frequent hash code calculations etc) and also, it isn’t always what people want"><y>#</y><d>2018-03-28</d><h>20:13</h><w>mikerod</w>where there were never duplicates inserted, etc. Drools does that by default with logical insert (managed by truth maintenance). However, it does have a performance cost to manage a set for working memory (frequent hash code calculations etc) and also, it isn’t always what people want</z><z id="t1522268019000574" t="mikerod sometimes “cardinality” of duplicate facts inserted can matter to the rule logic"><y>#</y><d>2018-03-28</d><h>20:13</h><w>mikerod</w>sometimes “cardinality” of duplicate facts inserted can matter to the rule logic</z><z id="t1522268037000269" t="talgiat true it can"><y>#</y><d>2018-03-28</d><h>20:13</h><w>talgiat</w>true it can</z><z id="t1522268043000174" t="mikerod Something like a “short circuit” or could be done"><y>#</y><d>2018-03-28</d><h>20:14</h><w>mikerod</w>Something like a “short circuit” or could be done</z><z id="t1522268050000440" t="talgiat but can’t I control which behavior I want"><y>#</y><d>2018-03-28</d><h>20:14</h><w>talgiat</w>but can’t I control which behavior I want</z><z id="t1522268052000547" t="mikerod Easiest would be to just have it generate several rules"><y>#</y><d>2018-03-28</d><h>20:14</h><w>mikerod</w>Easiest would be to just have it generate several rules</z><z id="t1522268059000452" t="mikerod that all do the “tiered” blocking pattern one one another"><y>#</y><d>2018-03-28</d><h>20:14</h><w>mikerod</w>that all do the “tiered” blocking pattern one one another</z><z id="t1522268073000394" t="mikerod just generically"><y>#</y><d>2018-03-28</d><h>20:14</h><w>mikerod</w>just generically</z><z id="t1522268153000525" t="mikerod also, there is nothing stopping you from making a higher-level macro that did the short-circuit rule generation pattern to normal Clara rules"><y>#</y><d>2018-03-28</d><h>20:15</h><w>mikerod</w>also, there is nothing stopping you from making a higher-level macro that did the short-circuit rule generation pattern to normal Clara rules</z><z id="t1522268167000496" t="mikerod If you were sufficiently motivated and had enough places you foudn it useful hah"><y>#</y><d>2018-03-28</d><h>20:16</h><w>mikerod</w>If you were sufficiently motivated and had enough places you foudn it useful hah</z><z id="t1522268899000407" t="talgiat Yeah, can do a macro"><y>#</y><d>2018-03-28</d><h>20:28</h><w>talgiat</w>Yeah, can do a macro</z><z id="t1522269351000381" t="wparker Agreed on all @mikerod’s comments - I just wanted to mention that you don’t necessarily have to use a macro generating “defrule” calls, Clara can take rules as data structures if you prefer to go that way (easier in clj than cljs though)"><y>#</y><d>2018-03-28</d><h>20:35</h><w>wparker</w>Agreed on all @mikerod’s comments - I just wanted to mention that you don’t necessarily have to use a macro generating “defrule” calls, Clara can take rules as data structures if you prefer to go that way (easier in clj than cljs though)</z><z id="t1522269426000353" t="wparker It seems the infinite looping behavior has tripped a lot of people up - we should probably add a page to the http://clara-rules.org site on that somewhere. I’ve also logged an issue before to fail in that scenario analogously to StackOverflowException, just haven’t ever gotten around to it"><y>#</y><d>2018-03-28</d><h>20:37</h><w>wparker</w>It seems the infinite looping behavior has tripped a lot of people up - we should probably add a page to the <a href="http://clara-rules.org" target="_blank">http://clara-rules.org</a> site on that somewhere.  I’ve also logged an issue before to fail in that scenario analogously to StackOverflowException, just haven’t ever gotten around to it</z><z id="t1522726003000115" t="alex-dixon May have seen this. Was the proposal for a max number of iterations per rule?"><y>#</y><d>2018-04-03</d><h>03:26</h><r>alex-dixon</r>May have seen this. Was the proposal for a max number of iterations per rule?</z><z id="t1522269543000730" t="wparker My personal mental model of rules is (I think similar to his) that when using truth maintenance they are like statements that “for each join of things in these sets, these other things must exist”. Declarative logic, like SQL or even Excel"><y>#</y><d>2018-03-28</d><h>20:39</h><w>wparker</w>My personal mental model of rules is (I think similar to his) that when using truth maintenance they are like statements that “for each join of things in these sets, these other things must exist”.  Declarative logic, like SQL or even Excel</z><z id="t1522705861000406" t="ggaillard I have some business processes that end up reading/saving data from and to a relational database. Some of my logic is pure, and some of it need this shared mutable state. Is there an idiomatic or clean way to handle side effects in clara ? It would be great if I could, for example, rollback a transaction in my database when the fact that caused the corresponding side effect is retracted … don&apos;t know if it&apos;s a sane way to tackle the problem thought…"><y>#</y><d>2018-04-02</d><h>21:51</h><w>ggaillard</w>I have some business processes that end up reading/saving data from and to a relational database. Some of my logic is pure, and some of it need this shared mutable state. Is there an idiomatic or clean way to handle side effects in clara ? It would be great if I could, for example, rollback a transaction in my database when the fact that caused the corresponding side effect is retracted … don&apos;t know if it&apos;s a sane way to tackle the problem thought…</z><z id="t1522723085000069" t="mikerod @ggaillard when you perform the side-effect, you can insert a fact that indicates that the side effect was performed"><y>#</y><d>2018-04-03</d><h>02:38</h><w>mikerod</w>@ggaillard when you perform the side-effect, you can insert a fact that indicates that the side effect was performed</z><z id="t1522723124000103" t="mikerod you can then have a rule that uses that to “retract” the side effects"><y>#</y><d>2018-04-03</d><h>02:38</h><w>mikerod</w>you can then have a rule that uses that to “retract” the side effects</z><z id="t1522723168000034" t="mikerod you likely need to make these effects “idempotent” so they can be replaced multiple times without causing issues"><y>#</y><d>2018-04-03</d><h>02:39</h><w>mikerod</w>you likely need to make these effects “idempotent” so they can be replaced multiple times without causing issues</z><z id="t1522723349000039" t="mikerod maybe something like (r/defrule do-thing [A (= v :something) (= ?id id)] =&gt; (do-side-effect ?a) (r/insert! (-&gt;DidSideEffectFor ?id))) (r/defrule undo-thing [?effect-data &lt;- DidSideEffectFor (= ?id id)] [:not [A (= ?id id)]] =&gt; (retract-side-effect ?effect-data)) Assumes you have a way to link facts up, like an ID. This doesn’t attempt to remove the DidSideEffectFor facts. So if this is a long running process, this may start to add up as too much data in memory"><y>#</y><d>2018-04-03</d><h>02:42</h><w>mikerod</w>maybe something like
<pre>(r/defrule do-thing
  [A (= v :something) (= ?id id)]
  =&gt;
  (do-side-effect ?a)
  (r/insert! (-&gt;DidSideEffectFor ?id)))

(r/defrule undo-thing
  [?effect-data &lt;- DidSideEffectFor (= ?id id)]
  [:not [A (= ?id id)]]
  =&gt;
  (retract-side-effect ?effect-data))
</pre>

Assumes you have a way to link facts up, like an ID. This doesn’t attempt to remove the 
<code>DidSideEffectFor</code> facts. So if this is a long running process, this may start to add up as too much data in memory</z><z id="t1522723377000062" t="mikerod If that’s the case, you may just want to handle the side-effects externally and clean up the DidSideEffectFor as well"><y>#</y><d>2018-04-03</d><h>02:42</h><w>mikerod</w>If that’s the case, you may just want to handle the side-effects externally and clean up the <code>DidSideEffectFor</code> as well</z><z id="t1522723649000149" t="mikerod My post on ways to update facts may be somewhat related to, if you are interested http://www.metasimple.org/2017/12/23/clara-updating-facts.html"><y>#</y><d>2018-04-03</d><h>02:47</h><w>mikerod</w>My post on ways to update facts may be somewhat related to, if you are interested
<a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a></z><z id="t1522747572000347" t="ggaillard Awesome answer! Thank you!"><y>#</y><d>2018-04-03</d><h>09:26</h><w>ggaillard</w>Awesome answer! Thank you!</z><z id="t1522869551000193" t="wparker Clara-rules 0.18.0 is released. The release includes performance optimizations, a bugfix in error handling code, and new APIs targeted at ClojureScript library/platform developers consuming Clara. The release adds a new listening method that anyone creating a custom listener will need to implement, but the implementation can just be an empty body so it is an easy uplift. Additionally, the :rule-matches key in session inspection will now only have rules that led to logical insertions, with a new :unfiltered-rule-matches key now optionally available with a superset of the data previously in the :rule-matches. For a discussion of the rationale behind this change see https://github.com/cerner/clara-rules/issues/386"><y>#</y><d>2018-04-04</d><h>19:19</h><w>wparker</w>Clara-rules 0.18.0 is released.  The release includes performance optimizations, a bugfix in error handling code, and new APIs targeted at ClojureScript library/platform developers consuming Clara.  The release adds a new listening method that anyone creating a custom listener will need to implement, but the implementation can just be an empty body so it is an easy uplift.  Additionally, the :rule-matches key in session inspection will now only have rules that led to logical insertions, with a new :unfiltered-rule-matches key now optionally available with a superset of the data previously in the :rule-matches.  For a discussion of the rationale behind this change see <a href="https://github.com/cerner/clara-rules/issues/386" target="_blank">https://github.com/cerner/clara-rules/issues/386</a></z><z id="t1522961646000665" t="sparkofreason Fellow clarians (?): linked is a draft of an article of describing some of the fun I&apos;ve been having using clara for UX. Any feedback greatly appreciated. https://sparkofreason.gitbooks.io/maali/content/"><y>#</y><d>2018-04-05</d><h>20:54</h><w>sparkofreason</w>Fellow clarians (?): linked is a draft of an article of describing some of the fun I&apos;ve been having using clara for UX. Any feedback greatly appreciated. <a href="https://sparkofreason.gitbooks.io/maali/content/" target="_blank">https://sparkofreason.gitbooks.io/maali/content/</a></z><z id="t1522967052000067" t="sparkofreason Please DM or comment in the git book unless the topic is of broader relevance to clara."><y>#</y><d>2018-04-05</d><h>22:24</h><w>sparkofreason</w>Please DM or comment in the git book unless the topic is of broader relevance to clara.</z><z id="t1523305189000181" t="whilo hi"><y>#</y><d>2018-04-09</d><h>20:19</h><w>whilo</w>hi</z><z id="t1523305212000358" t="whilo i have just stumbled over factui and finally realized that clara is like reactive dataflow base programming"><y>#</y><d>2018-04-09</d><h>20:20</h><w>whilo</w>i have just stumbled over factui and finally realized that clara is like reactive dataflow base programming</z><z id="t1523305220000116" t="whilo https://github.com/frankmcsherry/differential-dataflow"><y>#</y><d>2018-04-09</d><h>20:20</h><w>whilo</w><a href="https://github.com/frankmcsherry/differential-dataflow" target="_blank">https://github.com/frankmcsherry/differential-dataflow</a></z><z id="t1523305256000203" t="whilo i am working on datahike: https://github.com/replikativ/datahike and am wondering how i would stream datoms properly into clients with factui"><y>#</y><d>2018-04-09</d><h>20:20</h><w>whilo</w>i am working on datahike: <a href="https://github.com/replikativ/datahike" target="_blank">https://github.com/replikativ/datahike</a> and am wondering how i would stream datoms properly into clients with factui</z><z id="t1523312855000118" t="whilo one idea would be to make clara&apos;s memory durable and do a joint database"><y>#</y><d>2018-04-09</d><h>22:27</h><w>whilo</w>one idea would be to make clara&apos;s memory durable and do a joint database</z><z id="t1523313684000353" t="whilo so a simple approach would realize the web after tomorrow scenario of @tonsky http://tonsky.me/blog/the-web-after-tomorrow/"><y>#</y><d>2018-04-09</d><h>22:41</h><w>whilo</w>so a simple approach would realize the web after tomorrow scenario of @tonsky <a href="http://tonsky.me/blog/the-web-after-tomorrow/" target="_blank">http://tonsky.me/blog/the-web-after-tomorrow/</a></z><z id="t1523313813000312" t="whilo on a next step one can introduce CRDTs for intermediary result sets. this would allow local and offline edits in p2p fashion, which can occur with a parallel addition of the fact to the main central database that will acknowledge the intermediary result set"><y>#</y><d>2018-04-09</d><h>22:43</h><w>whilo</w>on a next step one can introduce CRDTs for intermediary result sets. this would allow local and offline edits in p2p fashion, which can occur with a parallel addition of the fact to the main central database that will acknowledge the intermediary result set</z><z id="t1523314033000025" t="whilo the latter is necessary for the facts to be joinable in a synchronized fashion with other parts of the system. that would yield a very good tradeoff for data driven application development in my opinion"><y>#</y><d>2018-04-09</d><h>22:47</h><w>whilo</w>the latter is necessary for the facts to be joinable in a synchronized fashion with other parts of the system. that would yield a very good tradeoff for data driven application development in my opinion</z><z id="t1523314155000155" t="whilo i can provide a durable sorted-map with the hitchhiker tree as a fast and transparent building blog: https://github.com/datacrypt-project/hitchhiker-tree"><y>#</y><d>2018-04-09</d><h>22:49</h><w>whilo</w>i can provide a durable sorted-map with the hitchhiker tree as a fast and transparent building blog: <a href="https://github.com/datacrypt-project/hitchhiker-tree" target="_blank">https://github.com/datacrypt-project/hitchhiker-tree</a></z><z id="t1523314174000364" t="whilo operations can be done in memory and flushed at distinct points in time"><y>#</y><d>2018-04-09</d><h>22:49</h><w>whilo</w>operations can be done in memory and flushed at distinct points in time</z><z id="t1523314297000310" t="whilo just to be clear the hitchhiker-tree is not from me, but david greenberg, but i have ported it to clojurescript with core.async and have used it to make datascript durable in datahike"><y>#</y><d>2018-04-09</d><h>22:51</h><w>whilo</w>just to be clear the hitchhiker-tree is not from me, but david greenberg, but i have ported it to clojurescript with core.async and have used it to make datascript durable in datahike</z><z id="t1523314458000290" t="whilo i guess i would have to implement IPersistentMemory, IMemoryReader and ITransientMemory for durability, right?"><y>#</y><d>2018-04-09</d><h>22:54</h><w>whilo</w>i guess i would have to implement IPersistentMemory, IMemoryReader and ITransientMemory for durability, right?</z><z id="t1523314496000327" t="whilo i am not sure whether this makes sense in your opinion, would be nice to chat a bit about how do it right"><y>#</y><d>2018-04-09</d><h>22:54</h><w>whilo</w>i am not sure whether this makes sense in your opinion, would be nice to chat a bit about how do it right</z><z id="t1523386637000393" t="mikerod @whilo I’m not completely up-to-speed on all of the various references you posted here. I can at least (for now) add a bit of light on the “durability” side of things. Clara does currently have some (fairly raw) support for session and working memory durability. More on that can be read about first @ http://www.clara-rules.org/docs/durability/"><y>#</y><d>2018-04-10</d><h>18:57</h><w>mikerod</w>@whilo I’m not completely up-to-speed on all of the various references you posted here. I can at least (for now) add a bit of light on the “durability” side of things.
Clara does currently have some (fairly raw) support for session and working memory durability.
More on that can be read about first @ <a href="http://www.clara-rules.org/docs/durability/" target="_blank">http://www.clara-rules.org/docs/durability/</a></z><z id="t1523386660000153" t="mikerod Much of the working memory side of the durability implementation is up to your particular use-case"><y>#</y><d>2018-04-10</d><h>18:57</h><w>mikerod</w>Much of the working memory side of the durability implementation is up to your particular use-case</z><z id="t1523386683000096" t="mikerod Clara does provide a Fressian backed impl of durability for the Clara infrastructure part of the rule sessions themselves"><y>#</y><d>2018-04-10</d><h>18:58</h><w>mikerod</w>Clara does provide a Fressian backed impl of durability for the Clara infrastructure part of the rule sessions themselves</z><z id="t1523386708000103" t="mikerod it offloads all facts in working memory to a separate protocol, that the consumer would implement to effectively serialize their facts."><y>#</y><d>2018-04-10</d><h>18:58</h><w>mikerod</w>it offloads all facts in working memory to a separate protocol, that the consumer would implement to effectively serialize their facts.</z><z id="t1523386740000070" t="mikerod Since I’m not familiar with each of the points you mention above though, this may or may not suit the goals you have"><y>#</y><d>2018-04-10</d><h>18:59</h><w>mikerod</w>Since I’m not familiar with each of the points you mention above though, this may or may not suit the goals you have</z><z id="t1523386763000515" t="mikerod I need to read a bit deeper into some of your links to have anything else to say on the subject I think"><y>#</y><d>2018-04-10</d><h>18:59</h><w>mikerod</w>I need to read a bit deeper into some of your links to have anything else to say on the subject I think</z><z id="t1523386909000574" t="mikerod It seems to me that you may be interested in a way to store facts in a way that are out-of-memory, perhaps because the set of facts will grow to potentially too many to fit all in memory at once."><y>#</y><d>2018-04-10</d><h>19:01</h><w>mikerod</w>It seems to me that you may be interested in a way to store facts in a way that are out-of-memory, perhaps because the set of facts will grow to potentially too many to fit all in memory at once.</z><z id="t1523386968000793" t="mikerod In that case, the durability alone won’t be enough. I think you’d then have to do a custom implementation of the memory layer of Clara, as you’ve mentioned. In Clara’s early days, Ryan Brush (the creator of Clara) had a demo project that prototyped how Clara’s working memory could be realized over a distribution cluster using Apache Storm"><y>#</y><d>2018-04-10</d><h>19:02</h><w>mikerod</w>In that case, the durability alone won’t be enough. I think you’d then have to do a custom implementation of the memory layer of Clara, as you’ve mentioned. In Clara’s early days, Ryan Brush (the creator of Clara) had a demo project that prototyped how Clara’s working memory could be realized over a distribution cluster using Apache Storm</z><z id="t1523387000000079" t="mikerod https://github.com/rbrush/clara-storm This isn’t maintained and very likely doesn’t work now. However, perhaps it is inspiration or at least related to some of your ideas you’ve mentioned above."><y>#</y><d>2018-04-10</d><h>19:03</h><w>mikerod</w><a href="https://github.com/rbrush/clara-storm" target="_blank">https://github.com/rbrush/clara-storm</a> This isn’t maintained and very likely doesn’t work now. However, perhaps it is inspiration or at least related to some of your ideas you’ve mentioned above.</z><z id="t1523567145000391" t="whilo @mikerod ok thanks 🙂"><y>#</y><d>2018-04-12</d><h>21:05</h><w>whilo</w>@mikerod ok thanks <b>🙂</b></z><z id="t1523567252000048" t="whilo actually i would like to have a datahike database somewhere central, stream data out of it in some places that pre-computes datalog queries for clients and writes them to CRDTs which are then replicated. the client can then use these replicated CRDTs to render its views and write to them offline in many cases while sending to the server as well. anyway, i will think it through a bit more and get more familiar with clara."><y>#</y><d>2018-04-12</d><h>21:07</h><w>whilo</w>actually i would like to have a datahike database somewhere central, stream data out of it in some places that pre-computes datalog queries for clients and writes them to CRDTs which are then replicated. the client can then use these replicated CRDTs to render its views and write to them offline in many cases while sending to the server as well. anyway, i will think it through a bit more and get more familiar with clara.</z><z id="t1525708399000624" t="jimbob Has anyone explored the area of exploration for why rules left-hand-side did not meet the rules prerequisites for firing of the RHS?"><y>#</y><d>2018-05-07</d><h>15:53</h><w>jimbob</w>Has anyone explored the area of exploration for why rules left-hand-side did not meet the rules prerequisites for firing of the RHS?</z><z id="t1525709150000055" t="mikerod @ben.borders In a way yes. That is, if I understand your question."><y>#</y><d>2018-05-07</d><h>16:05</h><w>mikerod</w>@ben.borders In a way yes. That is, if I understand your question.</z><z id="t1525709208000380" t="mikerod Not directly that though, instead you could consider a pattern to create complementary rules to the primary rules. These complementary rules were meant to catch the opposite case of the assertions."><y>#</y><d>2018-05-07</d><h>16:06</h><w>mikerod</w>Not directly that though, instead you could consider a pattern to create complementary rules to the primary rules. These complementary rules were meant to catch the opposite case of the assertions.</z><z id="t1525709380000241" t="jimbob yes, thats exactly it."><y>#</y><d>2018-05-07</d><h>16:09</h><w>jimbob</w>yes, thats exactly it.</z><z id="t1525709486000662" t="jimbob Interesting.. im assuming then there are multiple complements to each core “rule”. maybe the # of complements = the number of left hand constrints or something similar? unless your compllement rule that is generated has more complex logic"><y>#</y><d>2018-05-07</d><h>16:11</h><w>jimbob</w>Interesting..  im assuming then there are multiple complements to each core “rule”.  maybe the # of complements = the number of left hand constrints or something similar?  unless your compllement rule that  is generated has more complex logic</z><z id="t1525709510000502" t="mikerod I think the structure of generated rules may depend on which sorts of things you need to capture"><y>#</y><d>2018-05-07</d><h>16:11</h><w>mikerod</w>I think the structure of generated rules may depend on which sorts of things you need to capture</z><z id="t1525709542000242" t="mikerod You could end up writing rules in an alternative fixed format that can generated several “tiers” of rules from it. so there was the typically rule where you tried to match, but then there were tiers of unsatisfied matches where different parts of the rule were successively removed"><y>#</y><d>2018-05-07</d><h>16:12</h><w>mikerod</w>You could end up writing rules in an alternative fixed format that can generated several “tiers” of rules from it. so there was the typically rule where you tried to match, but then there were tiers of unsatisfied matches where different parts of the rule were successively removed</z><z id="t1525709730000436" t="jimbob ah interesting, so you made the rules very granular so that the complements might be easier to generate?"><y>#</y><d>2018-05-07</d><h>16:15</h><w>jimbob</w>ah interesting, so you made the rules very granular so that the complements might be easier to generate?</z><z id="t1525709755000042" t="jimbob well.. the main rule you cared about at least."><y>#</y><d>2018-05-07</d><h>16:15</h><w>jimbob</w>well.. the main rule you cared about at least.</z><z id="t1525709877000252" t="mikerod In that example, you can see it’d get carried away if you tried to capture everything perhaps"><y>#</y><d>2018-05-07</d><h>16:17</h><w>mikerod</w>In that example, you can see it’d get carried away if you tried to capture everything perhaps</z><z id="t1525709893000375" t="mikerod but maybe you could split the “constraints” you want to test for into logical “chunks”"><y>#</y><d>2018-05-07</d><h>16:18</h><w>mikerod</w>but maybe you could split the “constraints” you want to test for into logical “chunks”</z><z id="t1525709932000451" t="mikerod And when it comes to joining to other facts, you can do somewhat similar things"><y>#</y><d>2018-05-07</d><h>16:18</h><w>mikerod</w>And when it comes to joining to other facts, you can do somewhat similar things</z><z id="t1525709953000442" t="mikerod but you have to capture the case that facts you are joining to may not be satisfied themselves"><y>#</y><d>2018-05-07</d><h>16:19</h><w>mikerod</w>but you have to capture the case that facts you are joining to may not be satisfied themselves</z><z id="t1525710161000661" t="mikerod So you have to basically just come up with a way to structure these aspects you care about, then probably write something to generate the rules via some extra metadata markup on what is hand-written"><y>#</y><d>2018-05-07</d><h>16:22</h><w>mikerod</w>So you have to basically just come up with a way to structure these aspects you care about, then probably write something to generate the rules via some extra metadata markup on what is hand-written</z><z id="t1525710210000582" t="mikerod I don’t think it is a trivial problem to solve and is going to end up being domain dependent. I think that this may also bring up another interesting question though regarding perhaps comparing the forward-chaining (as used in Clara) vs a backwards chaining approach to the problem"><y>#</y><d>2018-05-07</d><h>16:23</h><w>mikerod</w>I don’t think it is a trivial problem to solve and is going to end up being domain dependent. I think that this may also bring up another interesting question though regarding perhaps comparing the forward-chaining (as used in Clara) vs a backwards chaining approach to the problem</z><z id="t1525710452000516" t="jimbob definitely! Thanks Mike this helps a lot!"><y>#</y><d>2018-05-07</d><h>16:27</h><w>jimbob</w>definitely!  Thanks Mike this helps a lot!</z><z id="t1525710460000144" t="jimbob @alex.furmanov"><y>#</y><d>2018-05-07</d><h>16:27</h><w>jimbob</w>@alex.furmanov</z><z id="t1525710533000469" t="mikerod No problem"><y>#</y><d>2018-05-07</d><h>16:28</h><w>mikerod</w>No problem</z><z id="t1525883213000564" t="wparker @ben.borders the :condition-matches in session inspection might be of interest as well: https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/tools/inspect.cljc#L183"><y>#</y><d>2018-05-09</d><h>16:26</h><w>wparker</w>@ben.borders the :condition-matches in session inspection might be of interest as well: <a href="https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/tools/inspect.cljc#L183" target="_blank">https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/tools/inspect.cljc#L183</a></z><z id="t1525883318000346" t="jimbob great point!"><y>#</y><d>2018-05-09</d><h>16:28</h><w>jimbob</w>great point!</z><z id="t1525883470000223" t="wparker So that should be the matches on constraints that don’t depend on joins - if you do [Fact (and (= field 1) (&lt; field2 ?binding-from-ancestor))] you’re forcing those constraints together in Clara’s view, where [Fact (= field 1) (&lt; field2 ?binding-from-ancestor)] keeps them separate"><y>#</y><d>2018-05-09</d><h>16:31</h><w>wparker</w>So that should be the matches on constraints that don’t depend on joins - if you do [Fact (and (= field 1) (&lt; field2 ?binding-from-ancestor))] you’re forcing those constraints together in Clara’s view, where [Fact (= field 1) (&lt; field2 ?binding-from-ancestor)] keeps them separate</z><z id="t1525883500000470" t="wparker The latter is also better for perf reasons, Clara can optimize it more"><y>#</y><d>2018-05-09</d><h>16:31</h><w>wparker</w>The latter is also better for perf reasons, Clara can optimize it more</z><z id="t1525883527000844" t="wparker Also note that :condition-matches doesn’t work for accumulator conditions yet: https://github.com/cerner/clara-rules/issues/293"><y>#</y><d>2018-05-09</d><h>16:32</h><w>wparker</w>Also note that :condition-matches doesn’t work for accumulator conditions yet: <a href="https://github.com/cerner/clara-rules/issues/293" target="_blank">https://github.com/cerner/clara-rules/issues/293</a></z><z id="t1526166234000049" t="devn Anyone here familiar with any work or have ideas on taking a medium to large rulebase, and then teasing out the underlying order?"><y>#</y><d>2018-05-12</d><h>23:03</h><w>devn</w>Anyone here familiar with any work or have ideas on taking a medium to large rulebase, and then teasing out the underlying order?</z><z id="t1526166272000018" t="devn By, for instance, running a bunch of examples through, and capturing logical &quot;groupings&quot; of rule firings? By namespace, for instance."><y>#</y><d>2018-05-12</d><h>23:04</h><w>devn</w>By, for instance, running a bunch of examples through, and capturing logical &quot;groupings&quot; of rule firings? By namespace, for instance.</z><z id="t1526250138000100" t="wparker @devn Would the fact-graph functionality help? https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/fact_graph.cljc I know I never got around to building graphical tools on top of it and frankly probably won’t at this point, but even in a REPL or with text-based visualization maybe it could be useful. The main ways you’d get at that sort of info would be session inspection (which the fact graph functionality uses internally) or listeners such as tracing - since the resulting data is just Clojure data you could process it as appropriate to make it more easily understood in your use case. To be honest though, my first thought is that if you need to go from the actual rule firing patterns backwards to the logical order, something is probably suboptimal about the organization of the codebase in question. Code organization is a tricky thing to get right and IMO highly domain-dependent but FWIW the rulebases I’ve worked with tended to either be DAGs or have broad groupings of rules that could be sketched out with their relationships to each other on a single piece of paper (with each of those groupings potentially containing other groupings and so forth)"><y>#</y><d>2018-05-13</d><h>22:22</h><w>wparker</w>@devn Would the fact-graph functionality help? <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/fact_graph.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/fact_graph.cljc</a> I know I never got around to building graphical tools on top of it and frankly probably won’t at this point, but even in a REPL or with text-based visualization maybe it could be useful.  The main ways you’d get at that sort of info would be session inspection (which the fact graph functionality uses internally) or listeners such as tracing - since the resulting data is just Clojure data you could process it as appropriate to make it more easily understood in your use case.  To be honest though, my first thought is that if you need to go from the actual rule firing patterns backwards to the logical order, something is probably suboptimal about the organization of the codebase in question.  Code organization is a tricky thing to get right and IMO highly domain-dependent but FWIW the rulebases I’ve worked with tended to either be DAGs or have broad groupings of rules that could be sketched out with their relationships to each other on a single piece of paper (with each of those groupings potentially containing other groupings and so forth)</z><z id="t1526250355000047" t="alex-dixon Maybe attach a listener and accumulate rule names"><y>#</y><d>2018-05-13</d><h>22:25</h><w>alex-dixon</w>Maybe attach a listener and accumulate rule names</z><z id="t1526278707000079" t="devn @wparker for large-ish rule sets, visualization is an extremely tricky problem in my experience"><y>#</y><d>2018-05-14</d><h>06:18</h><w>devn</w>@wparker for large-ish rule sets, visualization is an extremely tricky problem in my experience</z><z id="t1526278779000084" t="devn Once it gets past 25-30 fact types and 100+ rules it’s a mess"><y>#</y><d>2018-05-14</d><h>06:19</h><w>devn</w>Once it gets past 25-30 fact types and 100+ rules it’s a mess</z><z id="t1526278931000283" t="devn The graph I’ve produced, even with distinct edges is huge and mostly incomprehensible. "><y>#</y><d>2018-05-14</d><h>06:22</h><w>devn</w>The graph I’ve produced, even with distinct edges is huge and mostly incomprehensible. </z><z id="t1526279110000276" t="devn Imagine this scenario: you walk up to a system like this, and you know nothing about the “steps” that exist within the maze of fact types and rules that operate over them. Assume that 99% of rules produce a fact on the RHS."><y>#</y><d>2018-05-14</d><h>06:25</h><w>devn</w>Imagine this scenario: you walk up to a system like this, and you know nothing about the “steps” that exist within the maze of fact types and rules that operate over them. Assume that 99% of rules produce a fact on the RHS.</z><z id="t1526279216000024" t="devn What you want, is to try and tease out the clusters of logic."><y>#</y><d>2018-05-14</d><h>06:26</h><w>devn</w>What you want, is to try and tease out the clusters of logic.</z><z id="t1526279578000276" t="devn There are so many variables that make this problem difficult to generalize."><y>#</y><d>2018-05-14</d><h>06:32</h><w>devn</w>There are so many variables that make this problem difficult to generalize.</z><z id="t1526280300000121" t="devn For instance, whether people write fat or skinny rules, whether they have a few types with a lot of fields or a number of facts with variants, etc"><y>#</y><d>2018-05-14</d><h>06:45</h><w>devn</w>For instance, whether people write fat or skinny rules, whether they have a few types with a lot of fields or a number of facts with variants, etc</z><z id="t1526339055000066" t="devn @wparker to your point though about code organization. yeah, that&apos;s really important."><y>#</y><d>2018-05-14</d><h>23:04</h><w>devn</w>@wparker to your point though about code organization. yeah, that&apos;s really important.</z><z id="t1526339268000062" t="devn we have ~28 files containing rules"><y>#</y><d>2018-05-14</d><h>23:07</h><w>devn</w>we have ~28 files containing rules</z><z id="t1526339298000362" t="alex-dixon I’ve made some devtools for Precept. There could be some reuse for Clara if there’s interest"><y>#</y><d>2018-05-14</d><h>23:08</h><w>alex-dixon</w>I’ve made some devtools for Precept. There could be some reuse for Clara if there’s interest</z><z id="t1526339374000193" t="devn @alex-dixon interested in taking a look!"><y>#</y><d>2018-05-14</d><h>23:09</h><w>devn</w>@alex-dixon interested in taking a look!</z><z id="t1526339428000240" t="devn @alex-dixon where should i look for that code?"><y>#</y><d>2018-05-14</d><h>23:10</h><w>devn</w>@alex-dixon where should i look for that code?</z><z id="t1526339444000341" t="devn or is there a simple example around that i could use to see what&apos;s there?"><y>#</y><d>2018-05-14</d><h>23:10</h><w>devn</w>or is there a simple example around that i could use to see what&apos;s there?</z><z id="t1526339674000032" t="alex-dixon The visual part is in a private repo I need to make public. The code that gets the data from the session is here https://github.com/CoNarrative/precept/pull/113"><y>#</y><d>2018-05-14</d><h>23:14</h><w>alex-dixon</w>The visual part is in a private repo I need to make public. The code that gets the data from the session  is here <a href="https://github.com/CoNarrative/precept/pull/113" target="_blank">https://github.com/CoNarrative/precept/pull/113</a></z><z id="t1526339707000185" t="devn cool!"><y>#</y><d>2018-05-14</d><h>23:15</h><w>devn</w>cool!</z><z id="t1526339756000335" t="alex-dixon The basic approach is to attach a listener and put what it gives you onto a core async channel "><y>#</y><d>2018-05-14</d><h>23:15</h><w>alex-dixon</w>The basic approach is to attach a listener and put what it gives you onto a core async channel </z><z id="t1526339780000155" t="devn sequential rule operation log, state history over time, etc. are all interesting to me"><y>#</y><d>2018-05-14</d><h>23:16</h><w>devn</w>sequential rule operation log, state history over time, etc. are all interesting to me</z><z id="t1526339841000072" t="devn @alex-dixon this is exciting. thanks for your work."><y>#</y><d>2018-05-14</d><h>23:17</h><w>devn</w>@alex-dixon this is exciting. thanks for your work.</z><z id="t1526339942000359" t="alex-dixon Thanks 😊 . That means a lot"><y>#</y><d>2018-05-14</d><h>23:19</h><w>alex-dixon</w>Thanks <b>😊</b>. That means a lot</z><z id="t1526340050000255" t="devn @alex-dixon lazy clara user writes: please do this for clara too? 🙂"><y>#</y><d>2018-05-14</d><h>23:20</h><w>devn</w>@alex-dixon lazy clara user writes: please do this for clara too? <b>🙂</b></z><z id="t1526340068000004" t="alex-dixon Lol"><y>#</y><d>2018-05-14</d><h>23:21</h><w>alex-dixon</w>Lol</z><z id="t1526340086000241" t="alex-dixon What would be helpful?"><y>#</y><d>2018-05-14</d><h>23:21</h><w>alex-dixon</w>What would be helpful?</z><z id="t1526340258000328" t="devn explanations and sequential rule operation log stick out"><y>#</y><d>2018-05-14</d><h>23:24</h><w>devn</w>explanations and sequential rule operation log stick out</z><z id="t1526340294000063" t="devn fact history, also"><y>#</y><d>2018-05-14</d><h>23:24</h><w>devn</w>fact history, also</z><z id="t1526340438000361" t="devn does that slider at the bottom let you time travel?"><y>#</y><d>2018-05-14</d><h>23:27</h><w>devn</w>does that slider at the bottom let you time travel?</z><z id="t1526340455000001" t="devn and scrub through firings?"><y>#</y><d>2018-05-14</d><h>23:27</h><w>devn</w>and scrub through firings?</z><z id="t1526340458000003" t="alex-dixon Yeah"><y>#</y><d>2018-05-14</d><h>23:27</h><w>alex-dixon</w>Yeah</z><z id="t1526340462000172" t="devn that&apos;s slick!"><y>#</y><d>2018-05-14</d><h>23:27</h><w>devn</w>that&apos;s slick!</z><z id="t1526340487000258" t="alex-dixon There’s also fact tracking and rule tracking outside of that"><y>#</y><d>2018-05-14</d><h>23:28</h><w>alex-dixon</w>There’s also fact tracking and rule tracking outside of that</z><z id="t1526340534000010" t="alex-dixon History of a fact, history of a rule"><y>#</y><d>2018-05-14</d><h>23:28</h><w>alex-dixon</w>History of a fact, history of a rule</z><z id="t1526340615000105" t="devn super cool. gimme gimme gimme"><y>#</y><d>2018-05-14</d><h>23:30</h><w>devn</w>super cool. gimme gimme gimme</z><z id="t1526340618000410" t="devn 😄"><y>#</y><d>2018-05-14</d><h>23:30</h><w>devn</w><b>😄</b></z><z id="t1526340710000105" t="alex-dixon Lol. Thanks. I’m curious about your use case. Not sure how to approach the same with Clara when sessions can be used a lot differently than with ui"><y>#</y><d>2018-05-14</d><h>23:31</h><w>alex-dixon</w>Lol. Thanks. I’m curious about your use case. Not sure how to approach the same with Clara when sessions can be used a lot differently than with ui</z><z id="t1526340854000030" t="devn @alex-dixon one obvious one would be for development/debugging. i want to scrub through what is matching and where."><y>#</y><d>2018-05-14</d><h>23:34</h><w>devn</w>@alex-dixon one obvious one would be for development/debugging. i want to scrub through what is matching and where.</z><z id="t1526341067000108" t="devn it might also be helpful for finding any nasty cases where we walk down a big branch of logic only to undo all of it due to truth maintenance. perhaps we missed a constraint."><y>#</y><d>2018-05-14</d><h>23:37</h><w>devn</w>it might also be helpful for finding any nasty cases where we walk down a big branch of logic only to undo all of it due to truth maintenance. perhaps we missed a constraint.</z><z id="t1526558508000308" t="dominicm I&apos;m trying to figure out Clara with tuples, partially as I&apos;ve been brainwashed by Datomic, and partially because I think I like the independence. Precept looks like it&apos;s covered a lot of the work for that, any reason I couldn&apos;t use it as a general purpose library?"><y>#</y><d>2018-05-17</d><h>12:01</h><w>dominicm</w>I&apos;m trying to figure out Clara with tuples, partially as I&apos;ve been brainwashed by Datomic, and partially because I think I like the independence. Precept looks like it&apos;s covered a lot of the work for that, any reason I couldn&apos;t use it as a general purpose library?</z><z id="t1526559161000235" t="dominicm It&apos;s more than possible I should convert the tuples into maps or something, but I&apos;m entirely uncertain."><y>#</y><d>2018-05-17</d><h>12:12</h><w>dominicm</w>It&apos;s more than possible I should convert the tuples into maps or something, but I&apos;m entirely uncertain.</z><z id="t1526560731000184" t="mikerod @dominicm @alex-dixon is the Precept guru. Clara lets you configure the sort of facts it can work with if you want to do something like tuples. Some of this is explained in http://www.clara-rules.org/docs/fact_type_customization/ "><y>#</y><d>2018-05-17</d><h>12:38</h><w>mikerod</w>@dominicm @alex-dixon is the Precept guru. 
Clara lets you configure the sort of facts it can work with if you want to do something like tuples. 

Some of this is explained in
<a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a>

</z><z id="t1526560753000017" t="mikerod If precept is using tuples already, could look there for example too. "><y>#</y><d>2018-05-17</d><h>12:39</h><w>mikerod</w>If precept is using tuples already, could look there for example too. </z><z id="t1526560905000151" t="dominicm I did the type customisation for a tuple, it&apos;s working out okay, however my rules are full of a lot of destructuring sugar: (defrule app-asg-min-size [:box/type [[e a v]] (= v :server) (= ?app e)] [?tup &lt;- :min-size [[e a v]] (= e ?app)] =&gt; (let [[e a v] ?tup] (insert! [(str e &quot;-asg&quot;) :min-size v]))) "><y>#</y><d>2018-05-17</d><h>12:41</h><w>dominicm</w>I did the type customisation for a tuple, it&apos;s working out okay, however my rules are full of a lot of destructuring sugar:

<pre>(defrule app-asg-min-size
  [:box/type [[e a v]] (= v :server) (= ?app e)]
  [?tup &lt;- :min-size [[e a v]] (= e ?app)]
  =&gt;
  (let [[e a v] ?tup]
    (insert!
      [(str e &quot;-asg&quot;) :min-size v])))
</pre></z><z id="t1526560965000534" t="dominicm precept does seem to have something to allow queries like this one: (rule todo-is-visible [[_ :visibility-filter :active]] [[?e :todo/done false]] =&gt; (println &quot;The todo with this entity id is visible: &quot; ?e) "><y>#</y><d>2018-05-17</d><h>12:42</h><w>dominicm</w>precept does seem to have something to allow queries like this one:

<pre>(rule todo-is-visible
  [[_ :visibility-filter :active]]
  [[?e :todo/done false]]
  =&gt;
  (println &quot;The todo with this entity id is visible: &quot; ?e)
</pre></z><z id="t1526560982000586" t="dominicm I should probably just try it and see what happens 😛"><y>#</y><d>2018-05-17</d><h>12:43</h><w>dominicm</w>I should probably just try it and see what happens <b>😛</b></z><z id="t1526564110000608" t="dominicm It doesn&apos;t seem that precept supports newer clara versions, a shame."><y>#</y><d>2018-05-17</d><h>13:35</h><w>dominicm</w>It doesn&apos;t seem that precept supports newer clara versions, a shame.</z><z id="t1526564491000505" t="mikerod @dominicm I am not aware of anything in a newer clara that broke Precept. That’d be a bit of a surprise to me. Alex has generally been pretty active in the Clara changes etc. hmm. "><y>#</y><d>2018-05-17</d><h>13:41</h><w>mikerod</w>@dominicm I am not aware of anything in a newer clara that broke Precept. That’d be a bit of a surprise to me. Alex has generally been pretty active in the Clara changes etc. hmm. </z><z id="t1526564630000292" t="mikerod As far as the syntactic overhear you mentioned. I think you may be right there. Precept May have defined its own syntax later with something like a macro and then just generated Clara rule forms from it. Not sure. I’d have to check there as well. "><y>#</y><d>2018-05-17</d><h>13:43</h><w>mikerod</w>As far as the syntactic overhear you mentioned. I think you may be right there. Precept May have defined its own syntax later with something like a macro and then just generated Clara rule forms from it. Not sure. I’d have to check there as well. </z><z id="t1526564663000346" t="mikerod Are you wanting to have it look more like a datalog sort of query I guess? "><y>#</y><d>2018-05-17</d><h>13:44</h><w>mikerod</w>Are you wanting to have it look more like a datalog sort of query I guess? </z><z id="t1526564832000507" t="dominicm @mikerod I can report the bug to Precept, if they will be interested. It would certainly suit my data format better if I did that. I don&apos;t think I&apos;m really utilising the &quot;rule type&quot; concept very much. I&apos;m trying to figure out if I can coerce my facts into maps that would be more like what Clara expects, but I&apos;m not sure the type would be more useful there either."><y>#</y><d>2018-05-17</d><h>13:47</h><w>dominicm</w>@mikerod I can report the bug to Precept, if they will be interested. It would certainly suit my data format better if I did that. I don&apos;t think I&apos;m really utilising the &quot;rule type&quot; concept very much. I&apos;m trying to figure out if I can coerce my facts into maps that would be more like what Clara expects, but I&apos;m not sure the type would be more useful there either.</z><z id="t1526564969000418" t="dominicm @mikerod in case you&apos;re interested https://github.com/CoNarrative/precept/issues/115"><y>#</y><d>2018-05-17</d><h>13:49</h><w>dominicm</w>@mikerod in case you&apos;re interested <a href="https://github.com/CoNarrative/precept/issues/115" target="_blank">https://github.com/CoNarrative/precept/issues/115</a></z><z id="t1526638504000227" t="wparker CompilerException java.lang.IllegalArgumentException: Can&apos;t define method not in interfaces: insert_facts_BANG_, compiling:(precept/listeners.cljc:14:1) I believe the protocol method signature there changes in 0.18.0 so that’s probably it without looking at the code at the moment. It should be an easy uplift though since the new info passed was a superset of the previous (i.e. arguments were added not removed). I’ll comment on the Precept issue later. @dominicm"><y>#</y><d>2018-05-18</d><h>10:15</h><r>wparker</r><pre>CompilerException java.lang.IllegalArgumentException: Can&apos;t define method not in interfaces: insert_facts_BANG_, compiling:(precept/listeners.cljc:14:1) </pre> I believe the protocol method signature there changes in 0.18.0 so that’s probably it without looking at the code at the moment.  It should be an easy uplift though since the new info passed was a superset of the previous (i.e. arguments were added not removed).  I’ll comment on the Precept issue later. @dominicm</z><z id="t1526639414000497" t="dominicm yeah, didn&apos;t seem like it would be terrible to fix, but I have no context 🙂"><y>#</y><d>2018-05-18</d><h>10:30</h><r>dominicm</r>yeah, didn&apos;t seem like it would be terrible to fix, but I have no context <b>🙂</b></z><z id="t1526565273000070" t="mikerod That’s strange. I wonder if Alex will give some feedback on that one soon. I guess to mess with precept for now just use the version it has declared. "><y>#</y><d>2018-05-17</d><h>13:54</h><w>mikerod</w>That’s strange. I wonder if Alex will give some feedback on that one soon. I guess to mess with precept for now just use the version it has declared. </z><z id="t1526565292000552" t="mikerod I’ll check that out In a few. Not at laptop at the moment. "><y>#</y><d>2018-05-17</d><h>13:54</h><w>mikerod</w>I’ll check that out In a few. Not at laptop at the moment. </z><z id="t1526565425000256" t="mikerod Yeah it is convenient to model data the same as Clara built in. But not necessary of course. Also making a simpler DSL to interact wouldn’t be too hard potentially. "><y>#</y><d>2018-05-17</d><h>13:57</h><w>mikerod</w>Yeah it is convenient to model data the same as Clara built in. But not necessary of course. Also making a simpler DSL to interact wouldn’t be too hard potentially. </z><z id="t1526565464000883" t="mikerod For tuples. You could make a record type for them that just had an e, a, v fields. Then you’d get more concise Clara syntax at least"><y>#</y><d>2018-05-17</d><h>13:57</h><w>mikerod</w>For tuples. You could make a record type for them that just had an e, a, v fields. Then you’d get more concise Clara syntax at least</z><z id="t1526566358000755" t="alex-dixon @dominicm Hey. I haven’t tried upgrading to 18 yet but there were some breaking changes in 17 that were addressed in this branch https://github.com/CoNarrative/precept/pull/113"><y>#</y><d>2018-05-17</d><h>14:12</h><w>alex-dixon</w>@dominicm Hey. I haven’t tried upgrading to 18 yet but there were some breaking changes in 17 that were addressed in this branch <a href="https://github.com/CoNarrative/precept/pull/113" target="_blank">https://github.com/CoNarrative/precept/pull/113</a></z><z id="t1526566590000397" t="alex-dixon @dominicm Is there something in particular in 0.18.0 that you’re interested in having? I’ve been out of the loop"><y>#</y><d>2018-05-17</d><h>14:16</h><w>alex-dixon</w>@dominicm Is there something in particular in 0.18.0 that you’re interested in having? I’ve been out of the loop</z><z id="t1526566964000158" t="alex-dixon @mikerod I’ve been thinking about the roles/responsibilities of libraries like Precept vs. the Clara core. I’d like the devtools I’ve been working on to be compatible with Clara, but I’m somewhat uncomfortable with thinking of that being part of the core, so I was wondering about the group’s thoughts on revitalizing something like clara.tools to house things like that"><y>#</y><d>2018-05-17</d><h>14:22</h><w>alex-dixon</w>@mikerod I’ve been thinking about the roles/responsibilities of libraries like Precept vs. the Clara core. I’d like the devtools I’ve been working on to be compatible with Clara, but I’m somewhat uncomfortable with thinking of that being part of the core, so I was wondering about the group’s thoughts on revitalizing something like clara.tools to house things like that</z><z id="t1526567265000147" t="mikerod @alex-dixon to me it made sense to have it be a separate library like the clara.tools concept"><y>#</y><d>2018-05-17</d><h>14:27</h><w>mikerod</w>@alex-dixon to me it made sense to have it be a separate library like the clara.tools concept</z><z id="t1526567283000414" t="alex-dixon Now that dominic brings it up, I’m also curious whether Clara would be interested in a Datalog syntax implementation. And yes…I might have asked this a year ago but there’s reasons I didn’t. Namely I didn’t know Clojure at the time, hadn’t really contributed at all to open source, and like now I’m sort of intimidated by Clara’s codebase and not that confident in my ability to work efficiently in it"><y>#</y><d>2018-05-17</d><h>14:28</h><w>alex-dixon</w>Now that dominic brings it up, I’m also curious whether Clara would be interested in a Datalog syntax implementation. And yes…I might have asked this a year ago but there’s reasons I didn’t. Namely I didn’t know Clojure at the time, hadn’t really contributed at all to open source, and like now I’m sort of intimidated by Clara’s codebase and not that confident in my ability to work efficiently in it</z><z id="t1526567285000147" t="dominicm @alex-dixon no idea, I just picked latest and started there."><y>#</y><d>2018-05-17</d><h>14:28</h><w>dominicm</w>@alex-dixon no idea, I just picked latest and started there.</z><z id="t1526567315000647" t="dominicm Datomic syntax for clara in an isolated library would be nice, from a total beginner&apos;s pov."><y>#</y><d>2018-05-17</d><h>14:28</h><w>dominicm</w>Datomic syntax for clara in an isolated library would be nice, from a total beginner&apos;s pov.</z><z id="t1526567351000544" t="mikerod @alex-dixon It doesn’t have to be in that same repo though really unless you had particular reasoning for that. I haven’t had a chance to look at the devtools stuff that was discussed here the other day. It sounded interesting though"><y>#</y><d>2018-05-17</d><h>14:29</h><w>mikerod</w>@alex-dixon It doesn’t have to be in that same repo though really unless you had particular reasoning for that. 
I haven’t had a chance to look at the devtools stuff that was discussed here the other day. It sounded interesting though</z><z id="t1526567582000319" t="mikerod &gt; Datomic syntax for clara in an isolated library would be nice, from a total beginner’s pov. I agree that that sounds cool"><y>#</y><d>2018-05-17</d><h>14:33</h><w>mikerod</w>&gt; Datomic syntax for clara in an isolated library would be nice, from a total beginner’s pov.
I agree that that sounds cool</z><z id="t1526567613000680" t="mikerod Probably would be applicable to people in the clj-ecosystem looking into Clara too if that was the sort of data models they were already using. Interesting if Precept already has that layer implemented"><y>#</y><d>2018-05-17</d><h>14:33</h><w>mikerod</w>Probably would be applicable to people in the clj-ecosystem looking into Clara too if that was the sort of data models they were already using. Interesting if Precept already has that layer implemented</z><z id="t1526567745000127" t="alex-dixon The devtools were conceived in isolation, so before I’d work on porting some of it to Clara I’d really want to know what would be useful for people. As it stands, you can view the history of a rule, history of a fact, “event log” (all inserts and retractions in order), see explanations for all of those (the rule conditions that were defined, the facts they matched on, the bindings of the variables, what was inserted or retracted), whether something was inserted or removed unconditionally, logically, or the result of schema enforcement, if it was schema enforcement which existing fact triggered the schema enforcement and the relevant schema rule, added and removed facts for a particular rule firing (i.e. diff), and the total set of facts that exist in the session at the end of any rule firing"><y>#</y><d>2018-05-17</d><h>14:35</h><w>alex-dixon</w>The devtools were conceived in isolation, so before I’d work on porting some of it to Clara I’d really want to know what would be useful for people. As it stands, you can view the history of a rule, history of a fact, “event log” (all inserts and retractions in order), see explanations for all of those (the rule conditions that were defined, the facts they matched on, the bindings of the variables, what was inserted or retracted), whether something was inserted or removed unconditionally, logically, or the result of schema enforcement, if it was schema enforcement which existing fact triggered the schema enforcement and the relevant schema rule, added and removed facts for a particular rule firing (i.e. diff), and the total set of facts that exist in the session at the end of any rule firing</z><z id="t1526567806000758" t="alex-dixon It’s implemented as a client and server…the client for visualization, the server for receiving messages from the inspected session/app over socket"><y>#</y><d>2018-05-17</d><h>14:36</h><w>alex-dixon</w>It’s implemented as a client and server…the client for visualization, the server for receiving messages from the inspected session/app over socket</z><z id="t1526568375000168" t="mikerod @alex-dixon sounds really useful. You should make it public in a github repo or something for people to try out 🙂"><y>#</y><d>2018-05-17</d><h>14:46</h><w>mikerod</w>@alex-dixon sounds really useful. You should make it public in a github repo or something for people to try out <b>🙂</b></z><z id="t1526569113000293" t="alex-dixon Yeah haha…I definitely will, I’ve been dragging my feet because I’m not completely happy with it"><y>#</y><d>2018-05-17</d><h>14:58</h><w>alex-dixon</w>Yeah haha…I definitely will, I’ve been dragging my feet because I’m not completely happy with it</z><z id="t1526571269000797" t="mikerod call it alpha 😛"><y>#</y><d>2018-05-17</d><h>15:34</h><w>mikerod</w>call it alpha <b>😛</b></z><z id="t1526573220000586" t="dominicm I have been using the fact graph for fact history, it&apos;s been a pretty cool demo. I wired it up to rhizome pretty easily, and was able to see that X created asg Y, and asg Y has property Z because of Rule A"><y>#</y><d>2018-05-17</d><h>16:07</h><w>dominicm</w>I have been using the fact graph for fact history, it&apos;s been a pretty cool demo. I wired it up to rhizome pretty easily, and was able to see that X created asg Y, and asg Y has property Z because of Rule A</z><z id="t1526574006000600" t="zylox im certainly interested as well. i agree with @mikerod, just mark it alpha. works for spec right 😛"><y>#</y><d>2018-05-17</d><h>16:20</h><w>zylox</w>im certainly interested as well. i agree with @mikerod, just mark it alpha. works for spec right <b>😛</b></z><z id="t1526574152000393" t="dominicm the alpha stuff works very well, as long as your namespaces are .alpha too"><y>#</y><d>2018-05-17</d><h>16:22</h><w>dominicm</w>the alpha stuff works very well, as long as your namespaces are .alpha too</z><z id="t1526574931000778" t="alex-dixon I’ll try to publish it this weekend, maybe just mentioning it here will make that easier 🙂"><y>#</y><d>2018-05-17</d><h>16:35</h><w>alex-dixon</w>I’ll try to publish it this weekend, maybe just mentioning it here will make that easier <b>🙂</b></z><z id="t1526574942000820" t="alex-dixon Thanks for the encouragement and feedback"><y>#</y><d>2018-05-17</d><h>16:35</h><w>alex-dixon</w>Thanks for the encouragement and feedback</z><z id="t1526629678000046" t="dominicm http://www.clara-rules.org/docs/fact_type_customization/ Is it possible to set a fact type in such a way that this isn&apos;t needed?"><y>#</y><d>2018-05-18</d><h>07:47</h><w>dominicm</w><a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a>

Is it possible to set a fact type in such a way that this isn&apos;t needed?</z><z id="t1526638392000216" t="wparker @dominicm Could you give a minimal failing example? That doesn’t sound like something that should happen but we might be thinking about different things."><y>#</y><d>2018-05-18</d><h>10:13</h><r>wparker</r>@dominicm Could you give a minimal failing example?  That doesn’t sound like something that should happen but we might be thinking about different things.</z><z id="t1526629965000512" t="dominicm That might not be my problem actually. But when my type-fn is :a I get an error about alpha nodes if I try and refer to e ."><y>#</y><d>2018-05-18</d><h>07:52</h><w>dominicm</w>That might not be my problem actually. But when my type-fn is <code>:a</code> I get an error about alpha nodes if I try and refer to <code>e</code>.</z><z id="t1526649074000025" t="mikerod @dominicm I don’t see any context in your question. Did you post an example? You said where “this isn’t needed”, what were you referring to? "><y>#</y><d>2018-05-18</d><h>13:11</h><w>mikerod</w>@dominicm I don’t see any context in your question. Did you post an example? You said where “this isn’t needed”, what were you referring to? </z><z id="t1526649291000350" t="mikerod FYI I posted an example snippet overriding the fact type for something like tuples above. Well I put them in maps for key access by name. "><y>#</y><d>2018-05-18</d><h>13:14</h><w>mikerod</w>FYI I posted an example snippet overriding the fact type for something like tuples above. Well I put them in maps for key access by name. </z><z id="t1526649413000227" t="mikerod You can’t refer to bare symbols that “represent” lookup keys in a rule condition if you are asking that though with regard to “referring to e . Clara currently only offers special syntactic access directly to record or “Java bean” field/accessors. If you are using generic types it doesn’t attempt to resolve like the symbol e to (:e this) This may be what you’re asking"><y>#</y><d>2018-05-18</d><h>13:16</h><w>mikerod</w>You can’t refer to bare symbols that “represent” lookup keys in a rule condition if you are asking that though with regard to “referring to <code>e</code>. Clara currently only offers special syntactic access directly to record or “Java bean” field/accessors. If you are using generic types it doesn’t attempt to resolve like the symbol <code>e</code> to <code>(:e this)</code>

This may be what you’re asking</z><z id="t1526649437000219" t="mikerod It’d actually be interesting to explore making Clara offer that sort of syntax though on more generic data. "><y>#</y><d>2018-05-18</d><h>13:17</h><w>mikerod</w>It’d actually be interesting to explore making Clara offer that sort of syntax though on more generic data. </z><z id="t1526652120000660" t="dominicm Sorry. I got distracted when I got in and forgot to post it. On phone again, once I&apos;m at the keyboard I will do it."><y>#</y><d>2018-05-18</d><h>14:02</h><w>dominicm</w>Sorry. I got distracted when I got in and forgot to post it. On phone again, once I&apos;m at the keyboard I will do it.</z><z id="t1526655431000813" t="sveri Hi, can someone point me to some literature on how to write my own rules engine? I have trouble finding usefull stuff."><y>#</y><d>2018-05-18</d><h>14:57</h><w>sveri</w>Hi, can someone point me to some literature on how to write my own rules engine? I have trouble finding usefull stuff.</z><z id="t1526655639000832" t="zylox clara is heavily based on this paper if you really want to write your own &quot;engine&quot; http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf"><y>#</y><d>2018-05-18</d><h>15:00</h><w>zylox</w>clara is heavily based on this paper if you really want to write your own &quot;engine&quot; <a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank">http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</a></z><z id="t1526655660000922" t="sveri I am just curious, thank you @zylox"><y>#</y><d>2018-05-18</d><h>15:01</h><w>sveri</w>I am just curious, thank you @zylox</z><z id="t1526655707000774" t="mikerod Caveat: that paper is really old. There are many modern day rete extensions that Clara uses too. The paper is really good at explaining the foundations of rete though. "><y>#</y><d>2018-05-18</d><h>15:01</h><w>mikerod</w>Caveat: that paper is really old. There are many modern day rete extensions that Clara uses too. The paper is really good at explaining the foundations of rete though. </z><z id="t1526655716000149" t="zylox also just about any info you can get on rete will be intersting"><y>#</y><d>2018-05-18</d><h>15:01</h><w>zylox</w>also just about any info you can get on rete will be intersting</z><z id="t1526655744000291" t="mikerod The Drools/Jboss people also had some good blogs out there regarding rete. "><y>#</y><d>2018-05-18</d><h>15:02</h><w>mikerod</w>The Drools/Jboss people also had some good blogs out there regarding rete. </z><z id="t1526655815000053" t="mikerod Then there is also this great blog about Clara/rete here http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html (I wrote it 😛 ) "><y>#</y><d>2018-05-18</d><h>15:03</h><w>mikerod</w>Then there is also this great blog about Clara/rete here 
<a href="http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html" target="_blank">http://www.metasimple.org/2017/02/28/clarifying-rules-engines.html</a>

(I wrote it <b>😛</b> ) </z><z id="t1526655901000409" t="sveri @mikerod thank to you too"><y>#</y><d>2018-05-18</d><h>15:05</h><w>sveri</w>@mikerod thank to you too</z><z id="t1526656044000431" t="dominicm (ns roll-alt (:require [clara.rules :refer :all] [clara.tools.fact-graph :as fg] [clara.rules.accumulators :as accum] [rhizome.viz :as rhizome])) (defrecord D [e a v]) (defrule todos-done-invisible ;; [:todo/title (= ?e e)] [:todo/done (= (:v this) false) (= ?e (:e this))] =&gt; (insert! (-&gt;D ?e :todo/visible true))) (comment (-&gt; (mk-session :fact-type-fn :a :ancestors-fn (constantly [:all])) (insert (-&gt;D &quot;foo&quot; :todo/title &quot;FOO!&quot;) (-&gt;D &quot;foo&quot; :todo/title &quot;FOOBAR!&quot;) (-&gt;D &quot;foo&quot; :todo/done true) (-&gt;D &quot;blah&quot; :todo/done false)) (fire-rules) (query visible-datoms))) @mikerod the first line in the defrule doesn&apos;t work."><y>#</y><d>2018-05-18</d><h>15:07</h><w>dominicm</w><pre>(ns roll-alt
  (:require
    [clara.rules :refer :all]
    [clara.tools.fact-graph :as fg]
    [clara.rules.accumulators :as accum]
    [rhizome.viz :as rhizome]))

(defrecord D [e a v])

(defrule todos-done-invisible
  ;; [:todo/title (= ?e e)]
  [:todo/done (= (:v this) false) (= ?e (:e this))]
  =&gt;
  (insert!
    (-&gt;D ?e :todo/visible true)))

(comment
  (-&gt; (mk-session
        :fact-type-fn :a
        :ancestors-fn (constantly [:all]))
      (insert
        (-&gt;D &quot;foo&quot; :todo/title &quot;FOO!&quot;)
        (-&gt;D &quot;foo&quot; :todo/title &quot;FOOBAR!&quot;)
        (-&gt;D &quot;foo&quot; :todo/done true)
        (-&gt;D &quot;blah&quot; :todo/done false))
      (fire-rules)
      (query visible-datoms)))
</pre>
@mikerod the first line in the defrule doesn&apos;t work.</z><z id="t1526656569000414" t="mikerod @dominicm that seems related to the explanation I at least attempted to give above about when you can refer to “field name” symbols directly in a rule"><y>#</y><d>2018-05-18</d><h>15:16</h><w>mikerod</w>@dominicm that seems related to the explanation I at least attempted to give above about when you can refer to “field name” symbols directly in a rule</z><z id="t1526656595000798" t="mikerod Clara compiler cannot statically/compile time know what those symbols mean since the rule condition has a custom type that can’t be introspected"><y>#</y><d>2018-05-18</d><h>15:16</h><w>mikerod</w>Clara compiler cannot statically/compile time know what those symbols mean since the rule condition has a custom type that can’t be introspected</z><z id="t1526656656000829" t="mikerod It’d be interesting if Clara added support for you to explicitly state “fields” that go with custom fact types. But nothing like that right now. You’d have to do (:e this) instead of e or use destructuring as you have in the past"><y>#</y><d>2018-05-18</d><h>15:17</h><w>mikerod</w>It’d be interesting if Clara added support for you to explicitly state “fields” that go with custom fact types. But nothing like that right now. You’d have to do <code>(:e this)</code> instead of <code>e</code> or use destructuring as you have in the past</z><z id="t1526656826000023" t="mikerod When rules have records or other types of classes directly in the rule condition Clara compiler will reflect on the class to determine its available field names. When it can do that, you can refer to field names directly as their name symbol. "><y>#</y><d>2018-05-18</d><h>15:20</h><w>mikerod</w>When rules have records or other types of classes directly in the rule condition Clara compiler will reflect on the class to determine its available field names. When it can do that, you can refer to field names directly as their name symbol. </z><z id="t1526657389000730" t="dominicm &gt; Clara compiler cannot statically/compile time know what those symbols mean since the rule condition has a custom type that can’t be introspected That explains it to me, that&apos;s entirely what I was missing. It obviously worked when I wrote the form this way: (defrule todos-done-invisible [?d &lt;- D (= a :todo/title)] =&gt; (insert! (-&gt;D (:e ?d) :todo/visible true))) Which has a trade-off."><y>#</y><d>2018-05-18</d><h>15:29</h><w>dominicm</w>&gt; Clara compiler cannot statically/compile time know what those symbols mean since the rule condition has a custom type that can’t be introspected

That explains it to me, that&apos;s entirely what I was missing. It obviously worked when I wrote the form this way:

<pre>(defrule todos-done-invisible
  [?d &lt;- D (= a :todo/title)]
  =&gt;
  (insert!
    (-&gt;D (:e ?d) :todo/visible true)))
</pre>

Which has a trade-off.</z><z id="t1526657421000853" t="dominicm I was a bit confused because it was still a record, ergo it should work (in my head)."><y>#</y><d>2018-05-18</d><h>15:30</h><w>dominicm</w>I was a bit confused because it was still a record, ergo it should work (in my head).</z><z id="t1526657447000785" t="dominicm I looked for something to provide a custom keys function, and when I didn&apos;t find it, I presumed I was missing something."><y>#</y><d>2018-05-18</d><h>15:30</h><w>dominicm</w>I looked for something to provide a custom keys function, and when I didn&apos;t find it, I presumed I was missing something.</z><z id="t1526658300000648" t="mikerod @dominicm It’d be interesting to have a fn that takes your custom “type” and returns a set of “field keys”"><y>#</y><d>2018-05-18</d><h>15:45</h><w>mikerod</w>@dominicm It’d be interesting to have a fn that takes your custom “type” and returns a set of “field keys”</z><z id="t1526658313000323" t="mikerod and that’d be caleld when the compiler was compiling rules and then it’d allow for the shorter accessors"><y>#</y><d>2018-05-18</d><h>15:45</h><w>mikerod</w>and that’d be caleld when the compiler was compiling rules and then it’d allow for the shorter accessors</z><z id="t1526658343000721" t="mikerod Yeah, Clara just has built-in special casing to class types since they have reflection utilities available to find out how to resolve those symbols"><y>#</y><d>2018-05-18</d><h>15:45</h><w>mikerod</w>Yeah, Clara just has built-in special casing to class types since they have reflection utilities available to find out how to resolve those symbols</z><z id="t1526658371000258" t="mikerod I’ll add that you probably don’t want to write all your rules against a single type like D , so that isn’t a pattern I’d advocate"><y>#</y><d>2018-05-18</d><h>15:46</h><w>mikerod</w>I’ll add that you probably don’t want to write all your rules against a single type like <code>D</code>, so that isn’t a pattern I’d advocate</z><z id="t1526658394000810" t="mikerod It’d lead to a lot of thrash in the rules since every insert/retract would potentially affect every rule"><y>#</y><d>2018-05-18</d><h>15:46</h><w>mikerod</w>It’d lead to a lot of thrash in the rules since every insert/retract would potentially affect every rule</z><z id="t1526658412000549" t="mikerod The fact type serves as, what I’d call, the first level of discrimination/partitioning in the network."><y>#</y><d>2018-05-18</d><h>15:46</h><w>mikerod</w>The fact type serves as, what I’d call, the first level of discrimination/partitioning in the network.</z><z id="t1526660053000570" t="dominicm My data set isn&apos;t particularly large I think. I&apos;m struggling to come up with good fact types for my domain. But that&apos;s likely a thing on my side."><y>#</y><d>2018-05-18</d><h>16:14</h><w>dominicm</w>My data set isn&apos;t particularly large I think. I&apos;m struggling to come up with good fact types for my domain. But that&apos;s likely a thing on my side.</z><z id="t1526661350000788" t="dominicm The problem I have is that I&apos;m operating in a large domain, and I&apos;m asserting facts on a per-key level, instead of whole entities."><y>#</y><d>2018-05-18</d><h>16:35</h><w>dominicm</w>The problem I have is that I&apos;m operating in a large domain, and I&apos;m asserting facts on a per-key level, instead of whole entities.</z><z id="t1526661414000435" t="dominicm I suppose I could generate something like S3BucketFact which takes an id, key and value. But it&apos;s not so different from my datom record."><y>#</y><d>2018-05-18</d><h>16:36</h><w>dominicm</w>I suppose I could generate something like S3BucketFact which takes an id, key and value. But it&apos;s not so different from my datom record.</z><z id="t1526895713000428" t="wparker Haven’t read through all this, but FYI the ancestors-fn sounds like it could help you as well. So you could have rules matching all S3BucketFact as well as more rules matching only “subtypes” of S3BucketFact"><y>#</y><d>2018-05-21</d><h>09:41</h><r>wparker</r>Haven’t read through all this, but FYI the ancestors-fn sounds like it could help you as well.  So you could have rules matching all S3BucketFact as well as more rules matching only “subtypes” of S3BucketFact</z><z id="t1526895725000177" t="wparker @dominicm"><y>#</y><d>2018-05-21</d><h>09:42</h><r>wparker</r>@dominicm</z><z id="t1526895857000124" t="dominicm Yeah, I&apos;m deriving all my records, so that I can do a query for all &quot;Props&quot;"><y>#</y><d>2018-05-21</d><h>09:44</h><r>dominicm</r>Yeah, I&apos;m deriving all my records, so that I can do a query for all &quot;Props&quot;</z><z id="t1526895881000306" t="dominicm I&apos;ve introduced a meta &quot;Resource&quot; which goes into the &quot;e&quot; slot too, to make it easier to query for resources without getting the duplicates from props."><y>#</y><d>2018-05-21</d><h>09:44</h><r>dominicm</r>I&apos;ve introduced a meta &quot;Resource&quot; which goes into the &quot;e&quot; slot too, to make it easier to query for resources without getting the duplicates from props.</z><z id="t1526662062000384" t="dominicm Or should I be creating records at the level of S3BucketName, s3bucketYYY, etc.?"><y>#</y><d>2018-05-18</d><h>16:47</h><w>dominicm</w>Or should I be creating records at the level of S3BucketName, s3bucketYYY, etc.?</z><z id="t1526663990000039" t="mikerod don’t know about that"><y>#</y><d>2018-05-18</d><h>17:19</h><w>mikerod</w>don’t know about that</z><z id="t1526664006000302" t="mikerod maybe the “fact type” should be the “attribute” slot of these sorts of facts? I’m not sure"><y>#</y><d>2018-05-18</d><h>17:20</h><w>mikerod</w>maybe the “fact type” should be the “attribute” slot of these sorts of facts? I’m not sure</z><z id="t1526666397000049" t="dominicm I guess I can invent static generation of that somehow later. It feels less &quot;open&quot;."><y>#</y><d>2018-05-18</d><h>17:59</h><w>dominicm</w>I guess I can invent static generation of that somehow later. It feels less &quot;open&quot;.</z><z id="t1526669026000402" t="mikerod @dominicm I think it’d come down to the sort of rules you were needing to write"><y>#</y><d>2018-05-18</d><h>18:43</h><w>mikerod</w>@dominicm I think it’d come down to the sort of rules you were needing to write</z><z id="t1526669059000410" t="mikerod the fact type is just a useful way to group facts across the network that are coming from an external and also to categorize derived data"><y>#</y><d>2018-05-18</d><h>18:44</h><w>mikerod</w>the fact type is just a useful way to group facts across the network that are coming from an external and also to categorize derived data</z><z id="t1526669130000713" t="mikerod I don’t see the fact types as being a closed off concept. They are just what the rules refer to to match things, join things, and check other constraints. All of this is probably too vague though. I don’t have a good enough understand of what your data might be looking like and the sorts of things you want to do with it."><y>#</y><d>2018-05-18</d><h>18:45</h><w>mikerod</w>I don’t see the fact types as being a closed off concept. They are just what the rules refer to to match things, join things, and check other constraints.
All of this is probably too vague though. I don’t have a good enough understand of what your data might be looking like and the sorts of things you want to do with it.</z><z id="t1526669157000342" t="mikerod This now does make me wonder what sort of “fact type”s are used in #precept"><y>#</y><d>2018-05-18</d><h>18:45</h><w>mikerod</w>This now does make me wonder what sort of “fact type”s are used in #precept</z><z id="t1526684483000046" t="alex-dixon We use fact type fn :a https://github.com/CoNarrative/precept/blob/712868374f7339910e1c90596ec41c26283693d7/src/clj/precept/macros.clj#L48"><y>#</y><d>2018-05-18</d><h>23:01</h><r>alex-dixon</r>We use fact type fn :a <a href="https://github.com/CoNarrative/precept/blob/712868374f7339910e1c90596ec41c26283693d7/src/clj/precept/macros.clj#L48" target="_blank">https://github.com/CoNarrative/precept/blob/712868374f7339910e1c90596ec41c26283693d7/src/clj/precept/macros.clj#L48</a></z><z id="t1526669531000625" t="dominicm I&apos;ve been thinking the same, and also how certain problems of querying are solved, particularly around duplicate entities, potentially. There must be a few additional aspects to the querying in precept over what Clara provides alone."><y>#</y><d>2018-05-18</d><h>18:52</h><w>dominicm</w>I&apos;ve been thinking the same, and also how certain problems of querying are solved, particularly around duplicate entities, potentially.

There must be a few additional aspects to the querying in precept over what Clara provides alone.</z><z id="t1526669751000231" t="dominicm It was interesting to see several rules disappear when I got rid of the D record in favour of XFact records. I&apos;m interested to see what happens with X-Y records."><y>#</y><d>2018-05-18</d><h>18:55</h><w>dominicm</w>It was interesting to see several rules disappear when I got rid of the D record in favour of XFact records. I&apos;m interested to see what happens with X-Y records.</z><z id="t1526672195000060" t="dominicm Without having at least the concept of &quot;S3Bucket&quot; and &quot;S3BucketFact&quot; it&apos;s quite difficult to do &quot;All S3 buckets must have :foo 2 &quot;, because the ?e is duplicated across so many facts. I could perhaps use an accumulator, but it seems more natural to have strict types."><y>#</y><d>2018-05-18</d><h>19:36</h><w>dominicm</w>Without having at least the concept of &quot;S3Bucket&quot; and &quot;S3BucketFact&quot; it&apos;s quite difficult to do &quot;All S3 buckets must have <code>:foo 2</code>&quot;, because the <code>?e</code> is duplicated across so many facts. I could perhaps use an accumulator, but it seems more natural to have strict types.</z><z id="t1526674753000025" t="dominicm I&apos;ve written a macro which is run like (defType Box) will generate: - (defrecord Box) - (defrecord BoxFact) - (derive Box ::Type) (derive BoxFact ::Fact) - Function for converting to Box from other types - Function for &quot;scoping&quot; a series of [a v] into Facts. I&apos;m moving rather fast. I haven&apos;t gone really deep yet, but I&apos;m going to see how far I can get without declaring every possible attribute on a Box as a type."><y>#</y><d>2018-05-18</d><h>20:19</h><w>dominicm</w>I&apos;ve written a macro which is run like <code>(defType Box)</code> will generate:

- <code>(defrecord Box)</code>
- <code>(defrecord BoxFact)</code>
- <code>(derive Box ::Type)</code> <code>(derive BoxFact ::Fact)</code>
- Function for converting to Box from other types
- Function for &quot;scoping&quot; a series of <code>[a v]</code> into Facts.

I&apos;m moving rather fast. I haven&apos;t gone really deep yet, but I&apos;m going to see how far I can get without declaring every possible attribute on a Box as a type.</z><z id="t1526674934000372" t="dominicm It&apos;s certainly cool to see the addition of a route to an app cause the subnet to change, and the route53 records &amp; load balancers to be created."><y>#</y><d>2018-05-18</d><h>20:22</h><w>dominicm</w>It&apos;s certainly cool to see the addition of a route to an app cause the subnet to change, and the route53 records &amp; load balancers to be created.</z><z id="t1526681740000082" t="dominicm Sorry, I&apos;m tripping over things I don&apos;t understand again, (defquery created-by [:?for] [?fact &lt;- ::Fact (= ?by (:e this)) (= (:a this) :roll/created-for) (= (:v this) ?for)]) I&apos;m getting back a result where :?for is different to what I input as a parameter: (query s created-by :?for (-&gt;Box &quot;app&quot; nil)) . I don&apos;t really understand why, any advice?"><y>#</y><d>2018-05-18</d><h>22:15</h><w>dominicm</w>Sorry, I&apos;m tripping over things I don&apos;t understand again,

<pre>(defquery created-by
  [:?for]
  [?fact &lt;- ::Fact
   (= ?by (:e this))
   (= (:a this) :roll/created-for)
   (= (:v this) ?for)])
</pre>

I&apos;m getting back a result where <code>:?for</code> is different to what I input as a parameter: <code>(query s created-by :?for (-&gt;Box &quot;app&quot; nil))</code>. I don&apos;t really understand why, any advice?</z><z id="t1526684096000096" t="mikerod the query returns all 3 bound variables and 1 match as expected"><y>#</y><d>2018-05-18</d><h>22:54</h><w>mikerod</w>the query returns all 3 bound variables and 1 match as expected</z><z id="t1526684109000041" t="mikerod if I tweak the query or the inserted ::Fact , the results go away as expected too"><y>#</y><d>2018-05-18</d><h>22:55</h><w>mikerod</w>if I tweak the query or the inserted <code>::Fact</code>, the results go away as expected too</z><z id="t1526710443000060" t="dominicm @mikerod I can&apos;t seem to create a minimal repro of this, which leaves me more confused."><y>#</y><d>2018-05-19</d><h>06:14</h><w>dominicm</w>@mikerod I can&apos;t seem to create a minimal repro of this, which leaves me more confused.</z><z id="t1526710550000019" t="dominicm {:?fact #roll_altc.LaunchConfigurationFact{:e #roll_altc.LaunchConfiguration{:id &quot;app&quot;, :qualifier nil}, :a :roll/created-for, :v #roll_altc.ASG{:id &quot;app&quot;, :qualifier nil}}, :?by #roll_altc.LaunchConfiguration{:id &quot;app&quot;, :qualifier nil}, :?for #roll_altc.ASG{:id &quot;app&quot;, :qualifier nil}} I definitely have this in my results though, which I just can&apos;t grasp."><y>#</y><d>2018-05-19</d><h>06:15</h><w>dominicm</w><pre>{:?fact #roll_altc.LaunchConfigurationFact{:e #roll_altc.LaunchConfiguration{:id &quot;app&quot;, :qualifier nil},
                                            :a :roll/created-for,
                                            :v #roll_altc.ASG{:id &quot;app&quot;, :qualifier nil}},
  :?by #roll_altc.LaunchConfiguration{:id &quot;app&quot;, :qualifier nil},
  :?for #roll_altc.ASG{:id &quot;app&quot;, :qualifier nil}}
</pre>

I definitely have this in my results though, which I just can&apos;t grasp.</z><z id="t1526710857000075" t="dominicm I added a prn to do some debugging, and if I refer to ?for I get: &gt; Using variable that is not previously bound. This can happen when an expression uses a previously unbound variable, or if a variable is referenced in a nested part of a parent expression, such as (or (= ?my-expression my-field) ...). I&apos;m guessing this is suggesting that ?for is unbound, which is weird, but does explain what I am seeing."><y>#</y><d>2018-05-19</d><h>06:20</h><w>dominicm</w>I added a <code>prn</code> to do some debugging, and if I refer to <code>?for</code> I get:

&gt; Using variable that is not previously bound. This can happen when an expression uses a previously unbound variable, or if a variable is referenced in a nested part of a parent expression, such as (or (= ?my-expression my-field) ...).

I&apos;m guessing this is suggesting that <code>?for</code> is unbound, which is weird, but does explain what I am seeing.</z><z id="t1526711023000062" t="dominicm I get that in the minimal case where it works too, so I guess that&apos;s not it."><y>#</y><d>2018-05-19</d><h>06:23</h><w>dominicm</w>I get that in the minimal case where it works too, so I guess that&apos;s not it.</z><z id="t1526711570000005" t="dominicm &gt; A parameter definition, which allow callers to control the scope of the query when it is called. Makes me think that params should be bound when queries start, but instead it seems like they&apos;re unbound, and filtered at the end. Is that true?"><y>#</y><d>2018-05-19</d><h>06:32</h><w>dominicm</w>&gt; A parameter definition, which allow callers to control the scope of the query when it is called.

Makes me think that params should be bound when queries start, but instead it seems like they&apos;re unbound, and filtered at the end. Is that true?</z><z id="t1526756159000057" t="dominicm (defquery created-for-e [:?e] [RollCreatedFor (= e ?e) (= ?v v)]) Is there a reason that :?e is optional, when I execute this query without an :?e I get no results, I thought it might be like in datalog rules where it would be treated as an unbound variable in that case."><y>#</y><d>2018-05-19</d><h>18:55</h><w>dominicm</w><pre>(defquery created-for-e
  [:?e]
  [RollCreatedFor (= e ?e) (= ?v v)])
</pre>

Is there a reason that <code>:?e</code> is optional, when I execute this query without an <code>:?e</code> I get no results, I thought it might be like in datalog rules where  it would be treated as an unbound variable in that case.</z><z id="t1526756380000042" t="alex-dixon Maybe bound to nil?"><y>#</y><d>2018-05-19</d><h>18:59</h><w>alex-dixon</w>Maybe bound to nil?</z><z id="t1526756774000025" t="alex-dixon @dominicm are you using the with meta eav pattern? Also curious if you’re using def session or mk session and how you’re defining rules...I forget whether there’s any potential pitfalls with reloading them in clj"><y>#</y><d>2018-05-19</d><h>19:06</h><w>alex-dixon</w>@dominicm are you using the with meta eav pattern? Also curious if you’re using def session or mk session and how you’re defining rules...I forget whether there’s any potential pitfalls with reloading them in clj</z><z id="t1526757220000009" t="dominicm @alex-dixon I&apos;m onto &quot;namespace d&quot; now, where I&apos;m trying (defrecord AWSDBType [e v]) and (defrecord AWSDB [id qualifier])"><y>#</y><d>2018-05-19</d><h>19:13</h><w>dominicm</w>@alex-dixon I&apos;m onto &quot;namespace d&quot; now, where I&apos;m trying <code>(defrecord AWSDBType [e v])</code> and <code>(defrecord AWSDB [id qualifier])</code></z><z id="t1526757494000074" t="dominicm I have experimented with 4 approaches now 🙂"><y>#</y><d>2018-05-19</d><h>19:18</h><w>dominicm</w>I have experimented with 4 approaches now <b>🙂</b></z><z id="t1526757520000061" t="alex-dixon What’s not working? Sorry kind of got lost"><y>#</y><d>2018-05-19</d><h>19:18</h><w>alex-dixon</w>What’s not working? Sorry kind of got lost</z><z id="t1526757577000085" t="dominicm Oh, in the original question you mean? I was getting the ASG in the results, when I was specifying :?for as (-&gt;DBBox &quot;main&quot; nil)"><y>#</y><d>2018-05-19</d><h>19:19</h><w>dominicm</w>Oh, in the original question you mean? I was getting the ASG in the results, when I was specifying <code>:?for</code> as <code>(-&gt;DBBox &quot;main&quot; nil)</code></z><z id="t1526757721000023" t="alex-dixon Oh ok. Is there anything you’re stuck on still?"><y>#</y><d>2018-05-19</d><h>19:22</h><w>alex-dixon</w>Oh ok. Is there anything you’re stuck on still?</z><z id="t1526760383000074" t="dominicm I&apos;m still confused as to why I&apos;m having issues with the query https://clojurians.slack.com/archives/C08TC9JCS/p1526681740000082 but I&apos;m unable to create a minimal reproducible."><y>#</y><d>2018-05-19</d><h>20:06</h><w>dominicm</w>I&apos;m still confused as to why I&apos;m having issues with the query <a href="https://clojurians.slack.com/archives/C08TC9JCS/p1526681740000082" target="_blank">https://clojurians.slack.com/archives/C08TC9JCS/p1526681740000082</a> but I&apos;m unable to create a minimal reproducible.</z><z id="t1526760551000108" t="dominicm But otherwise, I&apos;m doing okay. I think I&apos;ve got a grip on this generally though."><y>#</y><d>2018-05-19</d><h>20:09</h><w>dominicm</w>But otherwise, I&apos;m doing okay. I think I&apos;ve got a grip on this generally though.</z><z id="t1526762893000091" t="dominicm (defrule DatabaseBox-Engine [?dbi &lt;- AWSDBInstance] [?dbox &lt;- DatabaseBox] [RollCreatedFor (= e ?dbi)] [DatabaseBoxEngine (= e ?dbox) (= ?v v)] =&gt; (insert! (-&gt;AWSDBInstanceEngine ?dbi ?v))) This inserts 2 AWSDBInstanceEngine rules, I think I understand why, it&apos;s due to how the dataset is being queried. Do rule engines / Does clara provide anything around stopping the insertion of facts twice here? I&apos;m quite happy to &quot;defend&quot; on the LHS, rather than attempt to deduplicate on the RHS. I&apos;m somewhat trying to avoid having to figure out conflict resolution in my final state."><y>#</y><d>2018-05-19</d><h>20:48</h><w>dominicm</w><pre>(defrule DatabaseBox-Engine
  [?dbi &lt;- AWSDBInstance]
  [?dbox &lt;- DatabaseBox]
  [RollCreatedFor (= e ?dbi)]
  [DatabaseBoxEngine (= e ?dbox) (= ?v v)]
  =&gt;
  (insert!
    (-&gt;AWSDBInstanceEngine ?dbi ?v)))
</pre>

This inserts 2 <code>AWSDBInstanceEngine</code> rules, I think I understand why, it&apos;s due to how the dataset is being queried. Do rule engines / Does clara provide anything around  stopping the insertion of facts twice here? I&apos;m quite happy to &quot;defend&quot; on the LHS, rather than attempt to deduplicate on the RHS.

I&apos;m somewhat trying to avoid having to figure out conflict resolution in my final state.</z><z id="t1526764634000058" t="mikerod @dominicm I haven’t been able to look at anything today. I can quickly answe your last question though: Clara doesn’t try to prevent duplicates. That’s up to your logical structuring. You can often do something like an accumulate all sort of rule to “de dupe “ or aggregate your duplicate facts and choose how to merge it. So you’d let some “intermediate type” be duplicated but have some downstream aggregate/merged type result from them and then be used in subsequent rules"><y>#</y><d>2018-05-19</d><h>21:17</h><w>mikerod</w>@dominicm I haven’t been able to look at anything today. I can quickly answe your last question though: Clara doesn’t try to prevent duplicates. That’s up to your logical structuring.  You can often do something like an accumulate all sort of rule to “de dupe “ or aggregate your duplicate facts and choose how to merge it. So you’d let some “intermediate type” be duplicated but have some downstream aggregate/merged type result from them and then be used in subsequent rules</z><z id="t1526764688000090" t="mikerod It’d be interesting to have a mode for Clara to prevent duplicates. However there are practical use cases for actually wanting duplicates too. So the default I feel is sane. Think something about logic that cares about cardinality of matches etc. Also removing duplicates tends to be performance overhead. "><y>#</y><d>2018-05-19</d><h>21:18</h><w>mikerod</w>It’d be interesting to have a mode for Clara to prevent duplicates. However there are practical use cases for actually wanting duplicates too. So the default I feel is sane. Think something about logic that cares about cardinality of matches etc. Also removing duplicates tends to be performance overhead. </z><z id="t1526764910000046" t="dominicm @mikerod yeah, I actually want the many cardinality in some cases. I was hoping there might be a way to structure the rule such that there was no duplicates in the query."><y>#</y><d>2018-05-19</d><h>21:21</h><w>dominicm</w>@mikerod yeah, I actually want the many cardinality in some cases. I was hoping there might be a way to structure the rule such that there was no duplicates in the query.</z><z id="t1526765058000043" t="mikerod I could give good example if not on phone. Hah"><y>#</y><d>2018-05-19</d><h>21:24</h><w>mikerod</w>I could give good example if not on phone. Hah</z><z id="t1526765081000090" t="alex-dixon (defrule DatabaseBox-Engine [?dbi &lt;- AWSDBInstance] [?dbox &lt;- DatabaseBox] [RollCreatedFor (= e ?dbi)] [DatabaseBoxEngine (= e ?dbox) (= ?v v)] [:not AWSDBInstanceEngine ?dbi ?v] Maybe something like this? Sry on phone also "><y>#</y><d>2018-05-19</d><h>21:24</h><w>alex-dixon</w><pre>(defrule DatabaseBox-Engine
  [?dbi &lt;- AWSDBInstance]
  [?dbox &lt;- DatabaseBox]
  [RollCreatedFor (= e ?dbi)]
  [DatabaseBoxEngine (= e ?dbox) (= ?v v)]
[:not AWSDBInstanceEngine ?dbi ?v]
</pre>
Maybe something like this? Sry on phone also </z><z id="t1526765088000034" t="mikerod I tend to just let the rules insert duplicates. But make it a intermediate fact type. Then have a single rule that aggregates it. "><y>#</y><d>2018-05-19</d><h>21:24</h><w>mikerod</w>I tend to just let the rules insert duplicates. But make it a intermediate fact type. Then have a single rule that aggregates it. </z><z id="t1526765112000090" t="mikerod There are negation patterns too. Like @alex-dixon just said. You just have to watch out for making a logical infinite loop"><y>#</y><d>2018-05-19</d><h>21:25</h><w>mikerod</w>There are negation patterns too. Like @alex-dixon just said. You just have to watch out for making a logical infinite loop</z><z id="t1526765336000027" t="mikerod Defrule example Lhs Logic =&gt; Insert IntermediateThing data from rule Defrule aggregate-dups ?all &lt;- acc/all :from IntermediateThing (= ?id is) =&gt; Insert RealThing (merge-somehow ?all) "><y>#</y><d>2018-05-19</d><h>21:28</h><w>mikerod</w><pre>Defrule example

Lhs Logic

=&gt;

Insert IntermediateThing data from rule

Defrule aggregate-dups 

?all &lt;- acc/all :from IntermediateThing (= ?id is)

=&gt;

Insert RealThing (merge-somehow ?all)

</pre></z><z id="t1526765356000018" t="mikerod Pseudo code"><y>#</y><d>2018-05-19</d><h>21:29</h><w>mikerod</w>Pseudo code</z><z id="t1526765787000082" t="dominicm Appreciate the help here. I&apos;ll take a shot at this tomorrow"><y>#</y><d>2018-05-19</d><h>21:36</h><w>dominicm</w>Appreciate the help here. I&apos;ll take a shot at this tomorrow</z><z id="t1526765894000005" t="alex-dixon Nb I think my example above would loop with insert logical, not if you were to use insert unconditional "><y>#</y><d>2018-05-19</d><h>21:38</h><w>alex-dixon</w>Nb I think my example above would loop with insert logical, not if you were to use insert unconditional </z><z id="t1526767756000070" t="dominicm I&apos;m worried about unconditional insert, because I don&apos;t want ordering to become a problem. The intermediate facts also feel &quot;icky&quot;, I think because they expose a part of the LHS which isn&apos;t able to match the user&apos;s view of the world. It feels more incidental, and less domain."><y>#</y><d>2018-05-19</d><h>22:09</h><w>dominicm</w>I&apos;m worried about unconditional insert, because I don&apos;t want ordering to become a problem. The intermediate facts also feel &quot;icky&quot;, I think because they expose a part of the LHS which isn&apos;t able to match the user&apos;s view of the world. It feels more incidental, and less domain.</z><z id="t1526769664000035" t="mikerod I like to be able to avoid unconditional inserts. But there are reasons where it can’t be easily avoided currently. Those are mostly around expressing removing old facts etc. I typically don’t use it though. "><y>#</y><d>2018-05-19</d><h>22:41</h><w>mikerod</w>I like to be able to avoid unconditional inserts. But there are reasons where it can’t be easily avoided currently. Those are mostly around expressing removing old facts etc. I typically don’t use it though. </z><z id="t1526769678000108" t="mikerod I don’t see intermediate facts as a bad thing. I think it is really common. "><y>#</y><d>2018-05-19</d><h>22:41</h><w>mikerod</w>I don’t see intermediate facts as a bad thing. I think it is really common. </z><z id="t1526769715000062" t="mikerod Often have to express intermediate concepts to connect rules for more complex logical conditions. At least in my experience with the rules I’ve needed to write. "><y>#</y><d>2018-05-19</d><h>22:41</h><w>mikerod</w>Often have to express intermediate concepts to connect rules for more complex logical conditions. At least in my experience with the rules I’ve needed to write. </z><z id="t1526805637000003" t="dominicm I seem to have identified a big misunderstanding on my part: (ns bugB (:require [clara.rules :refer :all])) (defrecord DatabaseBox [id]) (defrecord AWSDBInstance [id]) (defrecord DatabaseBoxEngine [e v]) (defrecord AWSDBInstanceEngine [e v]) (defrecord RollCreatedFor [e v]) (defrule DatabaseBox-Engine [RollCreatedFor (= e ?dbi) (= v ?dbox)] [DatabaseBoxEngine (= e ?dbox) (= ?v v)] =&gt; (println ?dbi ?dbox ?v)) (comment (clear-ns-productions!) (let [foo (-&gt;DatabaseBox &quot;foo&quot;) foo-db (-&gt;AWSDBInstance &quot;foo&quot;) foo-db-backup (-&gt;AWSDBInstance &quot;foo-backup&quot;)] (-&gt; (mk-session) (insert foo (-&gt;DatabaseBoxEngine foo :postgres) foo-db (-&gt;RollCreatedFor foo-db foo) foo-db-backup (-&gt;RollCreatedFor foo-db-backup foo-db) (-&gt;RollCreatedFor foo-db-backup foo)) (fire-rules)))) I cannot understand why this prints #bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres (among the 2 other results, I expect of AWSDBInstace with a DatabaseBox). I particularly don&apos;t understand how it finds a DatabaseBoxEngine where e is an AWSDBInstance?"><y>#</y><d>2018-05-20</d><h>08:40</h><w>dominicm</w>I seem to have identified a big misunderstanding on my part:

<pre>(ns bugB
  (:require
    [clara.rules :refer :all]))

(defrecord DatabaseBox [id])
(defrecord AWSDBInstance [id])

(defrecord DatabaseBoxEngine [e v])
(defrecord AWSDBInstanceEngine [e v])
(defrecord RollCreatedFor [e v])

(defrule DatabaseBox-Engine
  [RollCreatedFor (= e ?dbi) (= v ?dbox)]
  [DatabaseBoxEngine (= e ?dbox) (= ?v v)]
  =&gt;
  (println ?dbi ?dbox ?v))

(comment
  (clear-ns-productions!)
  (let [foo (-&gt;DatabaseBox &quot;foo&quot;)
        foo-db (-&gt;AWSDBInstance &quot;foo&quot;)
        foo-db-backup (-&gt;AWSDBInstance &quot;foo-backup&quot;)]
    (-&gt; (mk-session)
        (insert
          foo
          (-&gt;DatabaseBoxEngine foo :postgres)
          foo-db
          (-&gt;RollCreatedFor foo-db foo)
          foo-db-backup
          (-&gt;RollCreatedFor foo-db-backup foo-db)
          (-&gt;RollCreatedFor foo-db-backup foo))
        (fire-rules))))
</pre>

I cannot understand why this prints <code>#bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres</code> (among the 2 other results, I expect of AWSDBInstace with a  DatabaseBox). I particularly don&apos;t understand how it finds a DatabaseBoxEngine where <code>e</code> is an AWSDBInstance?</z><z id="t1526805670000062" t="dominicm The total output: #bugB.AWSDBInstance{:id foo} #bugB.DatabaseBox{:id foo} :postgres #bugB.AWSDBInstance{:id foo-backup} #bugB.DatabaseBox{:id foo} :postgres #bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres "><y>#</y><d>2018-05-20</d><h>08:41</h><w>dominicm</w>The total output:

<pre>#bugB.AWSDBInstance{:id foo} #bugB.DatabaseBox{:id foo} :postgres
#bugB.AWSDBInstance{:id foo-backup} #bugB.DatabaseBox{:id foo} :postgres
#bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres
</pre></z><z id="t1526837539000028" t="alex-dixon Looks like the only a database box engine has an e of foo record and if that’s your only rule there’s no way it should match on two different fact types when the fact type function is type"><y>#</y><d>2018-05-20</d><h>17:32</h><w>alex-dixon</w>Looks like the only a database box engine has an e of  foo record and if that’s your only rule there’s no way it should match on two different fact types when the fact type function is type</z><z id="t1526838848000093" t="dominicm @alex-dixon sorry, I&apos;m struggling to understand. Can you try in different terms."><y>#</y><d>2018-05-20</d><h>17:54</h><w>dominicm</w>@alex-dixon sorry, I&apos;m struggling to understand. Can you try in different terms.</z><z id="t1526838883000035" t="alex-dixon What’s happening seems completely wrong"><y>#</y><d>2018-05-20</d><h>17:54</h><w>alex-dixon</w>What’s happening seems completely wrong</z><z id="t1526838927000017" t="alex-dixon Your rule expresses a join your input data can satisfy at most once"><y>#</y><d>2018-05-20</d><h>17:55</h><w>alex-dixon</w>Your rule expresses a join your input data can satisfy at most once</z><z id="t1526839037000107" t="alex-dixon And your rule specifies a join on two different fact types. So a match for it that contains only one fact type should be impossible "><y>#</y><d>2018-05-20</d><h>17:57</h><w>alex-dixon</w>And your rule specifies a join on two different fact types. So a match for it that contains only one fact type should be impossible </z><z id="t1526839102000028" t="alex-dixon Have you tried restarting the repl?"><y>#</y><d>2018-05-20</d><h>17:58</h><w>alex-dixon</w>Have you tried restarting the repl?</z><z id="t1526839162000023" t="alex-dixon Something just seems wildly off. Do you think it could be caused by old repl state?"><y>#</y><d>2018-05-20</d><h>17:59</h><w>alex-dixon</w>Something just seems wildly off. Do you think it could be caused by old repl state?</z><z id="t1526839451000056" t="dominicm I&apos;ll try a restart of the repl. I had presumed a fresh namespace was enough."><y>#</y><d>2018-05-20</d><h>18:04</h><w>dominicm</w>I&apos;ll try a restart of the repl. I had presumed a fresh namespace was enough.</z><z id="t1526839696000031" t="alex-dixon I would too. I’m not sure how records refresh or whether they are repl friendly in general (think they need imported?). I see you were using clear ns productions but it’s not clear to me how rules are being loaded using mk session without passing in the productions?"><y>#</y><d>2018-05-20</d><h>18:08</h><w>alex-dixon</w>I would too. I’m not sure how records refresh or whether they are repl friendly in general (think they need imported?). I see you were using clear ns productions but it’s not clear to me how rules are being loaded using mk session without passing in the productions?</z><z id="t1526839833000089" t="dominicm I&apos;m still getting this behaviour: #bugB.AWSDBInstance{:id foo} #bugB.DatabaseBox{:id foo} :postgres #bugB.AWSDBInstance{:id foo-backup} #bugB.DatabaseBox{:id foo} :postgres #bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres I experimented with (clear-ns-productions!) , but I&apos;m not actually running it anymore."><y>#</y><d>2018-05-20</d><h>18:10</h><w>dominicm</w>I&apos;m still getting this behaviour:

<pre>#bugB.AWSDBInstance{:id foo} #bugB.DatabaseBox{:id foo} :postgres
#bugB.AWSDBInstance{:id foo-backup} #bugB.DatabaseBox{:id foo} :postgres
#bugB.AWSDBInstance{:id foo-backup} #bugB.AWSDBInstance{:id foo} :postgres
</pre>

I experimented with <code>(clear-ns-productions!)</code>, but I&apos;m not actually running it anymore.</z><z id="t1526839867000096" t="alex-dixon I see in the source mk session with no args uses /ns/"><y>#</y><d>2018-05-20</d><h>18:11</h><w>alex-dixon</w>I see in the source mk session with no args uses /ns/</z><z id="t1526839914000123" t="dominicm yes 🙂"><y>#</y><d>2018-05-20</d><h>18:11</h><w>dominicm</w>yes <b>🙂</b></z><z id="t1526839920000047" t="dominicm *ns*"><y>#</y><d>2018-05-20</d><h>18:12</h><w>dominicm</w><code>*ns*</code></z><z id="t1526839922000073" t="alex-dixon With earmuffs "><y>#</y><d>2018-05-20</d><h>18:12</h><w>alex-dixon</w>With earmuffs </z><z id="t1526839927000012" t="alex-dixon Thx lol"><y>#</y><d>2018-05-20</d><h>18:12</h><w>alex-dixon</w>Thx lol</z><z id="t1526839928000004" t="dominicm ` is what you&apos;re after"><y>#</y><d>2018-05-20</d><h>18:12</h><w>dominicm</w>` is what you&apos;re after</z><z id="t1526839956000022" t="alex-dixon Yeah...Apple doesn’t have that on their phones "><y>#</y><d>2018-05-20</d><h>18:12</h><w>alex-dixon</w>Yeah...Apple doesn’t have that on their phones </z><z id="t1526840016000083" t="dominicm oh 😞 silly fruit"><y>#</y><d>2018-05-20</d><h>18:13</h><w>dominicm</w>oh <b>😞</b> silly fruit</z><z id="t1526840021000094" t="alex-dixon The last result is the most glaring"><y>#</y><d>2018-05-20</d><h>18:13</h><w>alex-dixon</w>The last result is the most glaring</z><z id="t1526840102000158" t="alex-dixon Try binding the whole fact and printing that out. I may be confused"><y>#</y><d>2018-05-20</d><h>18:15</h><w>alex-dixon</w>Try binding the whole fact and printing that out. I may be confused</z><z id="t1526840147000111" t="dominicm which fact, first, second or both?"><y>#</y><d>2018-05-20</d><h>18:15</h><w>dominicm</w>which fact, first, second or both?</z><z id="t1526840164000029" t="alex-dixon ?fact1 &lt;- condition 1 ?fact2 &lt;- condition 2"><y>#</y><d>2018-05-20</d><h>18:16</h><w>alex-dixon</w>?fact1 &lt;- condition 1
?fact2 &lt;- condition 2</z><z id="t1526840211000016" t="dominicm (defrule DatabaseBox-Engine [?a &lt;- RollCreatedFor (= e ?dbi) (= v ?dbox)] [?b &lt;- DatabaseBoxEngine (= ?dbox e) (= ?v v)] =&gt; (prn ?a ?b)) =&gt; ; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo&quot;}, :v #bugB.DatabaseBox{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres} ; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo-backup&quot;}, :v #bugB.DatabaseBox{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres} ; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo-backup&quot;}, :v #bugB.AWSDBInstance{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres} "><y>#</y><d>2018-05-20</d><h>18:16</h><w>dominicm</w><pre>(defrule DatabaseBox-Engine
  [?a &lt;- RollCreatedFor (= e ?dbi) (= v ?dbox)]
  [?b &lt;- DatabaseBoxEngine (= ?dbox e) (= ?v v)]
  =&gt;
  (prn ?a ?b))

=&gt;

; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo&quot;}, :v #bugB.DatabaseBox{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres}
; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo-backup&quot;}, :v #bugB.DatabaseBox{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres}
; #bugB.RollCreatedFor{:e #bugB.AWSDBInstance{:id &quot;foo-backup&quot;}, :v #bugB.AWSDBInstance{:id &quot;foo&quot;}} #bugB.DatabaseBoxEngine{:e #bugB.DatabaseBox{:id &quot;foo&quot;}, :v :postgres}
</pre></z><z id="t1526840465000110" t="alex-dixon Ok so the fact types are right I was mistaken on that"><y>#</y><d>2018-05-20</d><h>18:21</h><w>alex-dixon</w>Ok so the fact types are right I was mistaken on that</z><z id="t1526842336000131" t="dominicm I suppose that in [?b &lt;- DatabaseBoxEngine (= ?dbox e) (= ?v v)] The (= ?dbox e) is being ignored."><y>#</y><d>2018-05-20</d><h>18:52</h><w>dominicm</w>I suppose that in <code>  [?b &lt;- DatabaseBoxEngine (= ?dbox e) (= ?v v)]</code> The <code>(= ?dbox e)</code> is being ignored.</z><z id="t1526854287000112" t="thegeez (= (-&gt;DatabaseBox &quot;foo&quot;) (-&gt;AWSDBInstance &quot;foo&quot;)) ;; =&gt; false (.equals (-&gt;DatabaseBox &quot;foo&quot;) (-&gt;AWSDBInstance &quot;foo&quot;)) ;; =&gt; true So there is probably some confusion in some of the java collections used within clara"><y>#</y><d>2018-05-20</d><h>22:11</h><w>thegeez</w><pre>(= (-&gt;DatabaseBox &quot;foo&quot;)
     (-&gt;AWSDBInstance &quot;foo&quot;)) ;; =&gt; false
  (.equals (-&gt;DatabaseBox &quot;foo&quot;)
           (-&gt;AWSDBInstance &quot;foo&quot;)) ;; =&gt; true</pre> So there is probably some confusion in some of the java collections used within clara</z><z id="t1526857563000097" t="thegeez @dominicm the problem is here: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/platform.cljc#L11 Replace the group-by-seq with (seq (group-by f coll)) and it works properly again"><y>#</y><d>2018-05-20</d><h>23:06</h><w>thegeez</w>@dominicm the problem is here: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/platform.cljc#L11" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/platform.cljc#L11</a>
Replace the group-by-seq with <pre>(seq (group-by f coll))</pre> and it works properly again</z><z id="t1526857653000073" t="thegeez (platform/group-by-seq vector [(-&gt;DatabaseBox &quot;foo&quot;) (-&gt;AWSDBInstance &quot;foo&quot;)]) ;; =&gt; [[[#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}] [#clara_bug.core.DatabaseBox{:id &quot;foo&quot;} #clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}]]] (defn group-by-seq [f coll] (seq (group-by f coll))) (group-by-seq vector [(-&gt;DatabaseBox &quot;foo&quot;) (-&gt;AWSDBInstance &quot;foo&quot;)]) ;; =&gt; ([[#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}] [#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}]] [[#clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}] [#clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}]])"><y>#</y><d>2018-05-20</d><h>23:07</h><w>thegeez</w><pre>(platform/group-by-seq vector
                         [(-&gt;DatabaseBox &quot;foo&quot;)
                          (-&gt;AWSDBInstance &quot;foo&quot;)])
  ;; =&gt;   [[[#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}] [#clara_bug.core.DatabaseBox{:id &quot;foo&quot;} #clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}]]]

  (defn group-by-seq [f coll]
    (seq (group-by f coll)))
  (group-by-seq vector
                [(-&gt;DatabaseBox &quot;foo&quot;)
                 (-&gt;AWSDBInstance &quot;foo&quot;)])
  ;; =&gt; ([[#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}] [#clara_bug.core.DatabaseBox{:id &quot;foo&quot;}]] [[#clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}] [#clara_bug.core.AWSDBInstance{:id &quot;foo&quot;}]])</pre></z><z id="t1526880582000054" t="dominicm That equality is crazy! Thanks!"><y>#</y><d>2018-05-21</d><h>05:29</h><w>dominicm</w>That equality is crazy! Thanks!</z><z id="t1526881170000153" t="dominicm https://dev.clojure.org/jira/browse/CLJ-867"><y>#</y><d>2018-05-21</d><h>05:39</h><w>dominicm</w><a href="https://dev.clojure.org/jira/browse/CLJ-867" target="_blank">https://dev.clojure.org/jira/browse/CLJ-867</a></z><z id="t1526882354000077" t="dominicm http://clojuredocs.org/clojure.core/defrecord &gt; and will defined Java .hashCode and .equals consistent with the contract for java.util.Map. Looks like this is intentional"><y>#</y><d>2018-05-21</d><h>05:59</h><w>dominicm</w><a href="http://clojuredocs.org/clojure.core/defrecord" target="_blank">http://clojuredocs.org/clojure.core/defrecord</a>

&gt; and will defined Java .hashCode and .equals consistent with the contract for java.util.Map.

Looks like this is intentional</z><z id="t1526889389000216" t="dominicm (definterface Foo (getB [])) (deftype C [a] Foo (getB [this] a)) (deftype B [a] Foo (getB [this] a)) Onto java beans I go!"><y>#</y><d>2018-05-21</d><h>07:56</h><w>dominicm</w><pre>(definterface Foo
  (getB []))

(deftype C [a]
  Foo
  (getB [this] a))

(deftype B [a]
  Foo
  (getB [this] a))
</pre>

Onto java beans I go!</z><z id="t1526899926000115" t="mikerod Clara just uses clojure =. Not sure the issue above? Clojure = takes type into consideration with records. "><y>#</y><d>2018-05-21</d><h>10:52</h><w>mikerod</w>Clara just uses clojure =. Not sure the issue above? Clojure = takes type into consideration with records. </z><z id="t1526900065000073" t="dominicm @mikerod The code that @thegeez referred to uses a java.util.HashMap, which uses java&apos;s notion of equality."><y>#</y><d>2018-05-21</d><h>10:54</h><w>dominicm</w>@mikerod The code that @thegeez referred to uses a java.util.HashMap, which uses java&apos;s notion of equality.</z><z id="t1526900334000022" t="dominicm Fortunately for me, I am in an intersection of 2 points: 1) My data is all the same keys 2) I use macros for generating my types So I&apos;ve been able to switch to beans with deftype rather trivially, and that&apos;s resolved everything."><y>#</y><d>2018-05-21</d><h>10:58</h><w>dominicm</w>Fortunately for me, I am in an intersection of 2 points:
1) My data is all the same keys
2) I use macros for generating my types

So I&apos;ve been able to switch to beans with <code>deftype</code> rather trivially, and that&apos;s resolved everything.</z><z id="t1526903542000361" t="mikerod @dominicm that’s interesting. I don’t know how you were encountering the use of platform/group-by-seq though. It does sound to me like there could be potential edge cases around platform/group-by-seq though on the jvm-impl since it does make use of Java collections to (a) preserve consistent order (b) do the grouping and order preservation efficiently."><y>#</y><d>2018-05-21</d><h>11:52</h><w>mikerod</w>@dominicm that’s interesting. I don’t know how you were encountering the use of <code>platform/group-by-seq</code> though. It does sound to me like there could be potential edge cases around <code>platform/group-by-seq</code> though on the jvm-impl since it does make use of Java collections to (a) preserve consistent order (b) do the grouping and order preservation efficiently.</z><z id="t1526904145000194" t="thegeez @mikerod if the promise is that clojure = is used, than @dominicm’s example shows a bug"><y>#</y><d>2018-05-21</d><h>12:02</h><w>thegeez</w>@mikerod if the promise is that clojure = is used, than @dominicm’s example shows a bug</z><z id="t1526904310000351" t="thegeez (defrecord ClauseOne [b]) (defrecord ClauseTwo [b]) (defrule rule-one [ClauseOne (= ?b b)] [ClauseTwo (= ?b b)] =&gt; (println &quot;Match found:&quot; ?b ) ) (defrecord WrapAlice [num]) (defrecord WrapBob [num]) (comment (clear-ns-productions!) (let [alice (-&gt;WrapAlice 1) bob (-&gt;WrapBob 1)] (println &quot;(= alice bob)&quot; (= alice bob)) (println &quot;(.equals alice bob)&quot; (.equals alice bob)) (-&gt; (mk-session) (insert (-&gt;ClauseOne alice) ;; Line below is important, without it the wrong behavior does not surface (-&gt;ClauseTwo alice) (-&gt;ClauseTwo bob) ) (fire-rules) )) ;;(= alice bob) false ;;(.equals alice bob) true ;; Match found: #clara_bug.core.WrapAlice{:num 1} ;; Match found: #clara_bug.core.WrapBob{:num 1} ;; &lt;- should not happen ) "><y>#</y><d>2018-05-21</d><h>12:05</h><w>thegeez</w><pre>(defrecord ClauseOne [b])
(defrecord ClauseTwo [b])

(defrule rule-one
  [ClauseOne (= ?b b)]
  [ClauseTwo (= ?b b)]
 =&gt;
  (println &quot;Match found:&quot; ?b )
  )

(defrecord WrapAlice [num])
(defrecord WrapBob [num])

(comment
  (clear-ns-productions!)
  (let [alice (-&gt;WrapAlice 1)
        bob (-&gt;WrapBob 1)]
    (println &quot;(= alice bob)&quot; (= alice bob))
    (println &quot;(.equals alice bob)&quot; (.equals alice bob))
    (-&gt; (mk-session)
        (insert
         (-&gt;ClauseOne alice)
         ;; Line below is important, without it the wrong behavior does not surface
         (-&gt;ClauseTwo alice)
         (-&gt;ClauseTwo bob)
         )
        (fire-rules)
        ))
  ;;(= alice bob) false
  ;;(.equals alice bob) true
  ;; Match found: #clara_bug.core.WrapAlice{:num 1}
  ;; Match found: #clara_bug.core.WrapBob{:num 1} ;; &lt;- should not happen
  )
</pre></z><z id="t1526906848000055" t="mikerod @thegeez I think this actually is a bug"><y>#</y><d>2018-05-21</d><h>12:47</h><w>mikerod</w>@thegeez I think this actually is a bug</z><z id="t1526906866000058" t="mikerod I had suspicion of it being one as soon as I saw this discussion above regarding platform/group-by-seq"><y>#</y><d>2018-05-21</d><h>12:47</h><w>mikerod</w>I had suspicion of it being one as soon as I saw this discussion above regarding <code>platform/group-by-seq</code></z><z id="t1526906985000233" t="mikerod platform/group-by-seq was added on the JVM-Clara to make the operation of grouping more efficient, as well as to have deterministic ordering of the seq it returns on each run to avoid variance in rule performance. The use of Java collections for this can cause subtle problems when the bindings of fact fields are record types that are Object.equals() from Java, but not clojure.core/= . This is the case with Clj record since their Java-interop form uses Java map equality instead of incorporating the type."><y>#</y><d>2018-05-21</d><h>12:49</h><w>mikerod</w><code>platform/group-by-seq</code> was added on the JVM-Clara to make the operation of grouping more efficient, as well as to have deterministic ordering of the seq it returns on each run to avoid variance in rule performance. The use of Java collections for this can cause subtle problems when the bindings of fact fields are record types that are <code>Object.equals()</code> from Java, but not <code>clojure.core/=</code>. This is the case with Clj record since their Java-interop form uses Java map equality instead of incorporating the type.</z><z id="t1526907304000132" t="thegeez @mikerod this might be of use: https://github.com/ztellman/bizarro-collections to get a speedy group-by-seq with the semantics of clojure ="><y>#</y><d>2018-05-21</d><h>12:55</h><w>thegeez</w>@mikerod this might be of use: <a href="https://github.com/ztellman/bizarro-collections" target="_blank">https://github.com/ztellman/bizarro-collections</a> to get a speedy group-by-seq with the semantics of clojure =</z><z id="t1526907357000029" t="mikerod I believe the issue is fairly isolated to the platform/group-by-seq . I think the solution would be to stop using a Java-based equality hashmap impl. A clj based one would be needed instead. It may be slightly tricky to do to keep similar performance characteristics. (it’s a hot spot in the rule engine)."><y>#</y><d>2018-05-21</d><h>12:55</h><w>mikerod</w>I believe the issue is fairly isolated to the <code>platform/group-by-seq</code>. I think the solution would be to stop using a Java-based equality hashmap impl. A clj based one would be needed instead. It may be slightly tricky to do to keep similar performance characteristics. (it’s a hot spot in the rule engine).</z><z id="t1526907385000340" t="mikerod @thegeez maybe, but we need a “linked hash map”"><y>#</y><d>2018-05-21</d><h>12:56</h><w>mikerod</w>@thegeez maybe, but we need a “linked hash map”</z><z id="t1526907397000120" t="mikerod the deterministic “order preservation” is an important characteristic"><y>#</y><d>2018-05-21</d><h>12:56</h><w>mikerod</w>the deterministic “order preservation” is an important characteristic</z><z id="t1526907420000378" t="mikerod I believe the bizarro only has hash map (unordered)"><y>#</y><d>2018-05-21</d><h>12:57</h><w>mikerod</w>I believe the bizarro only has hash map (unordered)</z><z id="t1526907519000375" t="mikerod a java.util.LinkedHashMap is used to do the grouping by operations, then it is seq’ed in platform/group-by-seq . The order the seq comes out, we want to be the same given the same input, independently from one process/machine to another (really, the Java runtime execution)"><y>#</y><d>2018-05-21</d><h>12:58</h><w>mikerod</w>a <code>java.util.LinkedHashMap</code> is used to do the grouping by operations, then it is seq’ed in <code>platform/group-by-seq</code>. The order the <code>seq</code> comes out, we want to be the same given the same input, independently from one process/machine to another (really, the Java runtime execution)</z><z id="t1526907551000369" t="mikerod If we didn’t need the order preservation part, we could just use a clj transient map and likely not have a problem with performance"><y>#</y><d>2018-05-21</d><h>12:59</h><w>mikerod</w>If we didn’t need the order preservation part, we could just use a clj transient map and likely not have a problem with performance</z><z id="t1526907603000704" t="mikerod One solution would just be to write some sort of collection in Clara to fit this goal. That maybe the smoothest path forward."><y>#</y><d>2018-05-21</d><h>13:00</h><w>mikerod</w>One solution would just be to write some sort of collection in Clara to fit this goal. That maybe the smoothest path forward.</z><z id="t1526907814000145" t="dominicm https://github.com/amalloy/ordered supports transients."><y>#</y><d>2018-05-21</d><h>13:03</h><w>dominicm</w><a href="https://github.com/amalloy/ordered" target="_blank">https://github.com/amalloy/ordered</a> supports transients.</z><z id="t1526907836000508" t="thegeez I don&apos;t know of one of the shelve"><y>#</y><d>2018-05-21</d><h>13:03</h><w>thegeez</w>I don&apos;t know of one of the shelve</z><z id="t1526907872000486" t="thegeez But when does the case occur that the order is different between process? And when do these two different orderings meet?"><y>#</y><d>2018-05-21</d><h>13:04</h><w>thegeez</w>But when does the case occur that the order is different between process? And when do these two different orderings meet?</z><z id="t1526908768000210" t="mikerod @dominicm @thegeez I logged https://github.com/cerner/clara-rules/issues/393 - fixed link"><y>#</y><d>2018-05-21</d><h>13:19</h><w>mikerod</w>@dominicm @thegeez I logged <a href="https://github.com/cerner/clara-rules/issues/393" target="_blank">https://github.com/cerner/clara-rules/issues/393</a> - fixed link</z><z id="t1526908796000449" t="mikerod it has quite a bit of detail on this"><y>#</y><d>2018-05-21</d><h>13:19</h><w>mikerod</w>it has quite a bit of detail on this</z><z id="t1526908815000614" t="mikerod determinism from one JVM instance to another is pretty important in some production scenarios"><y>#</y><d>2018-05-21</d><h>13:20</h><w>mikerod</w>determinism from one JVM instance to another is pretty important in some production scenarios</z><z id="t1526908839000347" t="mikerod platform/group-by-seq is hit in a hot spot in the engine - it has a fairly large effect on performance"><y>#</y><d>2018-05-21</d><h>13:20</h><w>mikerod</w><code>platform/group-by-seq</code> is hit in a hot spot in the engine - it has a fairly large effect on performance</z><z id="t1526908866000019" t="mikerod the order of its results can play a large role in the activity that takes place within the engines evaluation of the network facts"><y>#</y><d>2018-05-21</d><h>13:21</h><w>mikerod</w>the order of its results can play a large role in the activity that takes place within the engines evaluation of the network facts</z><z id="t1526908895000104" t="mikerod If the order changes from run to run, then the performance characteristics change too. This can make it hard to track down a bottleneck that comes up only on occasion"><y>#</y><d>2018-05-21</d><h>13:21</h><w>mikerod</w>If the order changes from run to run, then the performance characteristics change too. This can make it hard to track down a bottleneck that comes up only on occasion</z><z id="t1526908937000086" t="mikerod Also, different orders of evaluation could potentially even lead to things like exceptions thrown in defects in written rules. However, may only sometimes these defects would manifest themselves - aka hard to reproduce problems"><y>#</y><d>2018-05-21</d><h>13:22</h><w>mikerod</w>Also, different orders of evaluation could potentially even lead to things like exceptions thrown in defects in written rules. However, may only sometimes these defects would manifest themselves - aka hard to reproduce problems</z><z id="t1526908974000137" t="mikerod A while back, all known places within Clara’s engine evaluation and compiler were made deterministic run-over-run to alleviate these issues"><y>#</y><d>2018-05-21</d><h>13:22</h><w>mikerod</w>A while back, all known places within Clara’s engine evaluation and compiler were made deterministic run-over-run to alleviate these issues</z><z id="t1526909238000694" t="thegeez This is quickly going beyond what I know of rules systems, which is very little. I&apos;m only surprised to see the &quot;order changes from run to run&quot;, I would expect the ordering to be arbitrary, but the same from run to run with the same input data"><y>#</y><d>2018-05-21</d><h>13:27</h><w>thegeez</w>This is quickly going beyond what I know of rules systems, which is very little. I&apos;m only surprised to see the &quot;order changes from run to run&quot;, I would expect the ordering to be arbitrary, but the same from run to run with the same input data</z><z id="t1526910240000097" t="mikerod @thegeez the ordering guarantees are arbitrary from a user-level semantics"><y>#</y><d>2018-05-21</d><h>13:44</h><w>mikerod</w>@thegeez the ordering guarantees are arbitrary from a user-level semantics</z><z id="t1526910250000116" t="mikerod and the outputs are produced in a deterministic way from that level"><y>#</y><d>2018-05-21</d><h>13:44</h><w>mikerod</w>and the outputs are produced in a deterministic way from that level</z><z id="t1526910261000019" t="mikerod I’m talking on more of a low-level evaluation within the engine"><y>#</y><d>2018-05-21</d><h>13:44</h><w>mikerod</w>I’m talking on more of a low-level evaluation within the engine</z><z id="t1526910274000339" t="mikerod It is basically opaque to the user-level semantics"><y>#</y><d>2018-05-21</d><h>13:44</h><w>mikerod</w>It is basically opaque to the user-level semantics</z><z id="t1526910320000787" t="mikerod however, it has real world implications, (a) deterministic performance characteristics (b) deterministic order things actually are evaluated (mostly useful to reproduce error cases)"><y>#</y><d>2018-05-21</d><h>13:45</h><w>mikerod</w>however, it has real world implications, (a) deterministic performance characteristics (b) deterministic order things actually are evaluated (mostly useful to reproduce error cases)</z><z id="t1526910372000468" t="mikerod Things get more involved if you consider using the truth maintenance system within Clara, ie performing a typical clara.rules/insert! on a rule right-hand side (RHS)."><y>#</y><d>2018-05-21</d><h>13:46</h><w>mikerod</w>Things get more involved if you consider using the truth maintenance system within Clara, ie performing a typical <code>clara.rules/insert!</code> on a rule right-hand side (RHS).</z><z id="t1526910395000301" t="mikerod The engine works to put the system into a consistent logical state"><y>#</y><d>2018-05-21</d><h>13:46</h><w>mikerod</w>The engine works to put the system into a consistent logical state</z><z id="t1526910405000034" t="mikerod The “works” part, is where time is spent"><y>#</y><d>2018-05-21</d><h>13:46</h><w>mikerod</w>The “works” part, is where time is spent</z><z id="t1526910436000488" t="mikerod There are different orders/paths to take to reach the same consistent logical state, depending on how rules are chosen for evaluation, how facts are propagated from node to node in the internal network etc"><y>#</y><d>2018-05-21</d><h>13:47</h><w>mikerod</w>There are different orders/paths to take to reach the same consistent logical state, depending on how rules are chosen for evaluation, how facts are propagated from node to node in the internal network etc</z><z id="t1526910452000342" t="mikerod The determinism I’m talking about is in being deterministic in those inner choices taken"><y>#</y><d>2018-05-21</d><h>13:47</h><w>mikerod</w>The determinism I’m talking about is in being deterministic in those inner choices taken</z><z id="t1526910926000423" t="thegeez If &quot;defsomething A, defsomething B, execute&quot; should do the same as &quot;defsomething B, defsomething A, execute&quot; I would expect the usage of a HashMap instead of a LinkedHashMap, with its insertion-order preserving. That part is still fuzzy in my thinking"><y>#</y><d>2018-05-21</d><h>13:55</h><w>thegeez</w>If &quot;defsomething A, defsomething B, execute&quot; should do the same as &quot;defsomething B, defsomething A, execute&quot; I would expect the usage of a HashMap instead of a LinkedHashMap, with its insertion-order preserving. That part is still fuzzy in my thinking</z><z id="t1526911777000696" t="mikerod @thegeez I guess I’m not able to explain it correctly"><y>#</y><d>2018-05-21</d><h>14:09</h><w>mikerod</w>@thegeez I guess I’m not able to explain it correctly</z><z id="t1526911797000580" t="mikerod Yes, they can do the same thing, however, the way they accomplish it may be different depending on the order"><y>#</y><d>2018-05-21</d><h>14:09</h><w>mikerod</w>Yes, they can do the same thing, however, the way they accomplish it may be different depending on the order</z><z id="t1526911808000511" t="mikerod hash map can arbitrarily change the order"><y>#</y><d>2018-05-21</d><h>14:10</h><w>mikerod</w>hash map can arbitrarily change the order</z><z id="t1526911813000448" t="mikerod and it does"><y>#</y><d>2018-05-21</d><h>14:10</h><w>mikerod</w>and it does</z><z id="t1526911837000583" t="mikerod For example, we had correct rules running in a production case before. However, about 1 in 10 times, it performed about 100x worse"><y>#</y><d>2018-05-21</d><h>14:10</h><w>mikerod</w>For example, we had correct rules running in a production case before. However, about 1 in 10 times, it performed about 100x worse</z><z id="t1526911858000207" t="mikerod that 1 in 10 time, was when the hash map ordered 2 groups in a flipped way"><y>#</y><d>2018-05-21</d><h>14:10</h><w>mikerod</w>that 1 in 10 time, was when the hash map ordered 2 groups in a flipped way</z><z id="t1526911874000110" t="mikerod the engine then went on to do extra work, it hit a performance bottleneck case"><y>#</y><d>2018-05-21</d><h>14:11</h><w>mikerod</w>the engine then went on to do extra work, it hit a performance bottleneck case</z><z id="t1526911886000334" t="mikerod it still was functionally correct, it just went down a “bad path” performance-wise"><y>#</y><d>2018-05-21</d><h>14:11</h><w>mikerod</w>it still was functionally correct, it just went down a “bad path” performance-wise</z><z id="t1526911913000683" t="mikerod fixing the determinism allowed the case to be pinpointed and recreated in a consistent way, the bottleneck was then fixed"><y>#</y><d>2018-05-21</d><h>14:11</h><w>mikerod</w>fixing the determinism allowed the case to be pinpointed and recreated in a consistent way, the bottleneck was then fixed</z><z id="t1526911965000397" t="mikerod There are many places within the engine evaluation where the “order things are done” can make measurable performance differences. Even if the outcome is always the same no matter the order."><y>#</y><d>2018-05-21</d><h>14:12</h><w>mikerod</w>There are many places within the engine evaluation where the “order things are done” can make measurable performance differences. Even if the outcome is always the same no matter the order.</z><z id="t1526911995000142" t="mikerod It is hard to explain most of these, since they are detailed things about the engine/network/fact propagation"><y>#</y><d>2018-05-21</d><h>14:13</h><w>mikerod</w>It is hard to explain most of these, since they are detailed things about the engine/network/fact propagation</z><z id="t1526912058000797" t="mikerod Also, truth maintenance can evaluate a rule, evaluated its RHS actions, like insert! , but then later, realize that that rule isn’t satisfied anymore due to some other rule that evaluated. The engine can “retract” the work done by the rule in that case."><y>#</y><d>2018-05-21</d><h>14:14</h><w>mikerod</w>Also, truth maintenance can evaluate a rule, evaluated its RHS actions, like <code>insert!</code>, but then later, realize that that rule isn’t satisfied anymore due to some other rule that evaluated. The engine can “retract” the work done by the rule in that case.</z><z id="t1526912077000074" t="mikerod There are cases (many) where it’d be better to never have evaluated that rule at all, it wasted time"><y>#</y><d>2018-05-21</d><h>14:14</h><w>mikerod</w>There are cases (many) where it’d be better to never have evaluated that rule at all, it wasted time</z><z id="t1526912129000558" t="mikerod The situation is really that the engine can at times “speculatively” evaluate a rule that is later found to be invalidated by other rules. There are ways for user-level directed rule orderings, and also there are engine-level “heuristics” or similar that attempt to avoid premature evaluation"><y>#</y><d>2018-05-21</d><h>14:15</h><w>mikerod</w>The situation is really that the engine can at times “speculatively” evaluate a rule that is later found to be invalidated by other rules. There are ways for user-level directed rule orderings, and also there are engine-level “heuristics” or similar that attempt to avoid premature evaluation</z><z id="t1526912146000049" t="mikerod So a rule could have a RHS that says (throw (Exception.))"><y>#</y><d>2018-05-21</d><h>14:15</h><w>mikerod</w>So a rule could have a RHS that says <code>(throw (Exception.))</code></z><z id="t1526912166000316" t="mikerod This rule may never be true after fire-rules , however, during the truth maintenance cycle, it could actually be evaluated"><y>#</y><d>2018-05-21</d><h>14:16</h><w>mikerod</w>This rule may  never be true after <code>fire-rules</code>, however, during the truth maintenance cycle, it could actually be evaluated</z><z id="t1526912182000337" t="mikerod So if you have non-determinism in that cycle, you may only sometimes hit the exception side-effect"><y>#</y><d>2018-05-21</d><h>14:16</h><w>mikerod</w>So if you have non-determinism in that cycle, you may only sometimes hit the exception side-effect</z><z id="t1526912220000599" t="mikerod It doesn’t (and likely wouldn’t) be something trivial like that. It could be something less obvious like (insert! (call-my-fn-that-has-a-defect-for-some-args ?x))"><y>#</y><d>2018-05-21</d><h>14:17</h><w>mikerod</w>It doesn’t (and likely wouldn’t) be something trivial like that. It could be something less obvious like <code>(insert! (call-my-fn-that-has-a-defect-for-some-args ?x))</code></z><z id="t1526912256000785" t="mikerod If that rule sometimes evaluated, but needs to retract later by the truth maintenance, and this only happens 1 in 10 times, you may have a 1 in 10 times sort of scenario you are trying to recreate to debug your defect in your rules"><y>#</y><d>2018-05-21</d><h>14:17</h><w>mikerod</w>If that rule sometimes evaluated, but needs to retract later by the truth maintenance, and this only happens 1 in 10 times, you may have a 1 in 10 times sort of scenario you are trying to recreate to debug your defect in your rules</z><z id="t1526912310000244" t="mikerod This will manifest itself in cases like, our tests fail arbitrarily at times when run on our build servers, but when we rerun the build/retest the error is gone"><y>#</y><d>2018-05-21</d><h>14:18</h><w>mikerod</w>This will manifest itself in cases like, our tests fail arbitrarily at times when run on our build servers, but when we rerun the build/retest the error is gone</z><z id="t1526912347000628" t="mikerod The determinism of ordering used within these areas of Clara help both of these scenarios, the performance situations, and the finding failures scenarios situation"><y>#</y><d>2018-05-21</d><h>14:19</h><w>mikerod</w>The determinism of ordering used within these areas of Clara help both of these scenarios, the performance situations, and the finding failures scenarios situation</z><z id="t1526918786000617" t="thegeez @mikerod Thanks for the explanation"><y>#</y><d>2018-05-21</d><h>16:06</h><w>thegeez</w>@mikerod Thanks for the explanation</z><z id="t1526919122000759" t="alex-dixon @mikerod ditto that was great"><y>#</y><d>2018-05-21</d><h>16:12</h><w>alex-dixon</w>@mikerod ditto that was great</z><z id="t1526919151000335" t="zylox we should probably codify that mentality somwhere because we do think of it as first class here when considering changes"><y>#</y><d>2018-05-21</d><h>16:12</h><w>zylox</w>we should probably codify that mentality somwhere because we do think of it as first class here when considering changes</z><z id="t1526919160000226" t="zylox (here being cerner)"><y>#</y><d>2018-05-21</d><h>16:12</h><w>zylox</w>(here being cerner)</z><z id="t1526919202000718" t="zylox not sure where though. When writing rules it shouldnt be a consideration or a concern to the user"><y>#</y><d>2018-05-21</d><h>16:13</h><w>zylox</w>not sure where though. When writing rules it shouldnt be a consideration or a concern to the user</z><z id="t1526932843000409" t="curtis.shaffer engine behavior? or guiding principles perhaps?"><y>#</y><d>2018-05-21</d><h>20:00</h><w>curtis.shaffer</w>engine behavior? or guiding principles perhaps?</z><z id="t1526933012000615" t="wparker I think https://github.com/cerner/clara-rules/blob/master/CONTRIBUTING.md is intended for that purpose in the GitHub templates, perhaps something there?"><y>#</y><d>2018-05-21</d><h>20:03</h><w>wparker</w>I think <a href="https://github.com/cerner/clara-rules/blob/master/CONTRIBUTING.md" target="_blank">https://github.com/cerner/clara-rules/blob/master/CONTRIBUTING.md</a> is intended for that purpose in the GitHub templates, perhaps something there?</z><z id="t1526934146000189" t="zylox that makes a degree of sense to me"><y>#</y><d>2018-05-21</d><h>20:22</h><w>zylox</w>that makes a degree of sense to me</z><z id="t1527090692000916" t="jdt Hello all, I&apos;ve been trying a bit of clara-rules to assess it for a project. I&apos;m having some trouble with with-tracing though."><y>#</y><d>2018-05-23</d><h>15:51</h><w>jdt</w>Hello all, I&apos;ve been trying a bit of clara-rules to assess it for a project.  I&apos;m having some trouble with <code>with-tracing</code> though.</z><z id="t1527090774000342" t="jdt If I omit the with-tracing call fire-rules does its work. If I add with-tracing before it, fire-rules no longer works (none of my rules are fired)."><y>#</y><d>2018-05-23</d><h>15:52</h><w>jdt</w>If I omit the <code>with-tracing</code> call <code>fire-rules</code> does its work.  If I add <code>with-tracing</code> before it, <code>fire-rules</code> no longer works (none of my rules are fired).</z><z id="t1527090798000763" t="jdt If I move with-tracing before (insert ...) I get lots of traces."><y>#</y><d>2018-05-23</d><h>15:53</h><w>jdt</w>If I move <code>with-tracing</code> before <code>(insert ...)</code> I get lots of traces.</z><z id="t1527090822000277" t="jdt What am I doing wrong?"><y>#</y><d>2018-05-23</d><h>15:53</h><w>jdt</w>What am I doing wrong?</z><z id="t1527090844000677" t="jdt I&apos;m using [com.cerner/clara-rules &quot;0.18.0&quot;]"><y>#</y><d>2018-05-23</d><h>15:54</h><w>jdt</w>I&apos;m using <code>[com.cerner/clara-rules &quot;0.18.0&quot;]</code></z><z id="t1527090854000915" t="jdt and clojure 1.9"><y>#</y><d>2018-05-23</d><h>15:54</h><w>jdt</w>and clojure 1.9</z><z id="t1527090911000365" t="jdt I don&apos;t want to trace the rete activity on the initial insert, just the activities of fire-rules and the working memory alterations there."><y>#</y><d>2018-05-23</d><h>15:55</h><w>jdt</w>I don&apos;t want to trace the rete activity on the initial insert, just the activities of fire-rules and the working memory alterations there.</z><z id="t1527095519000771" t="mikerod @dave.tenny it’s an interesting point you bring up, but I don’t think it really makes sense to only “partially” have with-tracing enabled"><y>#</y><d>2018-05-23</d><h>17:11</h><w>mikerod</w>@dave.tenny it’s an interesting point you bring up, but I don’t think it really makes sense to only “partially” have <code>with-tracing</code> enabled</z><z id="t1527095542000737" t="mikerod All session interactions prior to fire-rules are susceptible to lazy evaluation and batching."><y>#</y><d>2018-05-23</d><h>17:12</h><w>mikerod</w>All session interactions prior to <code>fire-rules</code> are susceptible to lazy evaluation and batching.</z><z id="t1527095572000488" t="mikerod In general, I’d stress to not rely on any stateful information of a session that has had inserts/retracts performed on it, but no fire-rules"><y>#</y><d>2018-05-23</d><h>17:12</h><w>mikerod</w>In general, I’d stress to not rely on any stateful information of a session that has had inserts/retracts performed on it, but no <code>fire-rules</code></z><z id="t1527095599000521" t="jdt Heh, not sure I was trying to make a point. I didn&apos;t understand why fire-rules didn&apos;t work based on the placement of with-tracing . Since my rules weren&apos;t firing."><y>#</y><d>2018-05-23</d><h>17:13</h><w>jdt</w>Heh, not sure I was trying to make a point.  I didn&apos;t understand why <code>fire-rules</code> didn&apos;t work based on the placement of <code>with-tracing</code>.  Since my rules weren&apos;t firing.</z><z id="t1527095602000091" t="mikerod I’d actually rather it be the case that the API threw an exception if you tried to query or do something like with-tracing when it was in an inconsistent/lazy/batched state prior to fire-rules"><y>#</y><d>2018-05-23</d><h>17:13</h><w>mikerod</w>I’d actually rather it be the case that the API threw an exception if you tried to <code>query</code> or do something like <code>with-tracing</code> when it was in an inconsistent/lazy/batched state prior to <code>fire-rules</code></z><z id="t1527095635000781" t="jdt Naively (since I am naive here), I just figured my session would be upgraded to do tracing."><y>#</y><d>2018-05-23</d><h>17:13</h><w>jdt</w>Naively (since I am naive here), I just figured my session would be upgraded to do tracing.</z><z id="t1527095638000259" t="mikerod It’s an interesting point regarding the limitations of with-tracing and lazy/batched insert/retract behavior I meant"><y>#</y><d>2018-05-23</d><h>17:13</h><w>mikerod</w>It’s an interesting point regarding the limitations of <code>with-tracing</code> and lazy/batched insert/retract behavior I meant</z><z id="t1527095671000655" t="mikerod I certainly haven’t dug into details to diagnose your specific issue, but I’d imaging the with-tracing added late, after the insert missed some listener information it needed"><y>#</y><d>2018-05-23</d><h>17:14</h><w>mikerod</w>I certainly haven’t dug into details to diagnose your specific issue, but I’d imaging the <code>with-tracing</code> added late, after the <code>insert</code> missed some listener information it needed</z><z id="t1527095673000119" t="jdt So how should I be using with-tracing here?"><y>#</y><d>2018-05-23</d><h>17:14</h><w>jdt</w>So how should I be using <code>with-tracing</code> here?</z><z id="t1527095698000163" t="mikerod Only add it when you have a session that doesn’t have insert , insert-all , or retract calls possibly still pending on it"><y>#</y><d>2018-05-23</d><h>17:14</h><w>mikerod</w>Only add it when you have a session that doesn’t have <code>insert</code>, <code>insert-all</code>, or <code>retract</code> calls possibly still pending on it</z><z id="t1527095710000454" t="mikerod so either (a) right after your mk-session , or (b) right after a fire-rules"><y>#</y><d>2018-05-23</d><h>17:15</h><w>mikerod</w>so either (a) right after your <code>mk-session</code>, or (b) right after a <code>fire-rules</code></z><z id="t1527095750000642" t="jdt I&apos;m doing insert! and retract! in my rule RHS&apos;s, but but the only insert was as shown, before the with-tracing call."><y>#</y><d>2018-05-23</d><h>17:15</h><w>jdt</w>I&apos;m doing <code>insert!</code> and <code>retract!</code> in my rule RHS&apos;s, but but the only <code>insert</code> was as shown, before the <code>with-tracing</code> call.</z><z id="t1527095753000482" t="mikerod but you won’t get tracing “only for the fire-rules actions that took place, you’ll get a complete picture, you can looking into tracing details to find out specific things, like facts inserted due to rules firing etc (at least to some degree)"><y>#</y><d>2018-05-23</d><h>17:15</h><w>mikerod</w>but you won’t get tracing “only for the <code>fire-rules</code> actions that took place, you’ll get a complete picture, you can looking into tracing details to find out specific things, like facts inserted due to rules firing etc (at least to some degree)</z><z id="t1527095929000282" t="mikerod @dave.tenny you did this? (-&gt; (mk-session) (with-tracing) (insert ...) (fire-rules)) "><y>#</y><d>2018-05-23</d><h>17:18</h><w>mikerod</w>@dave.tenny you did this?
<pre>(-&gt; (mk-session)
	(with-tracing)
	(insert ...)
	(fire-rules))

</pre></z><z id="t1527095966000154" t="jdt Yes, that way I get tracing, and fire-rules works as expected."><y>#</y><d>2018-05-23</d><h>17:19</h><w>jdt</w>Yes, that way I get tracing, and fire-rules works as expected.</z><z id="t1527095992000224" t="mikerod that’s the way to use it"><y>#</y><d>2018-05-23</d><h>17:19</h><w>mikerod</w>that’s the way to use it</z><z id="t1527096005000293" t="jdt ok, thanks"><y>#</y><d>2018-05-23</d><h>17:20</h><w>jdt</w>ok, thanks</z><z id="t1527096020000016" t="mikerod So I don’t know what your question is beyond that and beyond what I said about it being misleading in the API to let you add it at arbitrary points"><y>#</y><d>2018-05-23</d><h>17:20</h><w>mikerod</w>So I don’t know what your question is beyond that and beyond what I said about it being misleading in the API to let you add it at arbitrary points</z><z id="t1527096037000234" t="jdt I&apos;m trying to get the network activity after the initial bulk load of facts."><y>#</y><d>2018-05-23</d><h>17:20</h><w>jdt</w>I&apos;m trying to get the network activity after the initial bulk load of facts.</z><z id="t1527096042000002" t="mikerod I think it’d be better to reject an attempt to add it at the “wrong times”, enhancement"><y>#</y><d>2018-05-23</d><h>17:20</h><w>mikerod</w>I think it’d be better to reject an attempt to add it at the “wrong times”, enhancement</z><z id="t1527096055000067" t="jdt And when I do that, by moving the trace after the facts are loaded, my fire-rules don&apos;t work."><y>#</y><d>2018-05-23</d><h>17:20</h><w>jdt</w>And when I do that, by moving the trace after the facts are loaded, my <code>fire-rules</code> don&apos;t work.</z><z id="t1527096064000155" t="mikerod yeah, it doesn’t work on that principle"><y>#</y><d>2018-05-23</d><h>17:21</h><w>mikerod</w>yeah, it doesn’t work on that principle</z><z id="t1527096073000238" t="jdt ok, good to know, still learning"><y>#</y><d>2018-05-23</d><h>17:21</h><w>jdt</w>ok, good to know, still learning</z><z id="t1527096163000224" t="jdt That begs the question of when it is safe to use it. Say I make a session, load data, run rules, query results. Then I want to change the data in the session and run it again with tracing. Will it work then? Or is it always safe to use with-tracing after fire-rules calls?"><y>#</y><d>2018-05-23</d><h>17:22</h><w>jdt</w>That begs the question of when it is safe to use it.  Say I make a session, load data, run rules, query results.  Then I want to change the data in the session and run it again with tracing.  Will it work then?  Or is it always safe to use <code>with-tracing</code> after <code>fire-rules</code> calls?</z><z id="t1527096174000044" t="mikerod I’m not actually sure there is a way to look at the listener information and know the different between a fact inserted externally, via insert and a fact inserted from a RHS, via insert! . I don’t know of one off hand."><y>#</y><d>2018-05-23</d><h>17:22</h><w>mikerod</w>I’m not actually sure there is a way to look at the listener information and know the different between a fact inserted externally, via <code>insert</code> and a fact inserted from a RHS, via <code>insert!</code>. I don’t know of one off hand.</z><z id="t1527096232000202" t="mikerod &gt; Or is it always safe to use with-tracing after fire-rules calls? I think so and expect so. If it has issues, it’d be interesting to discuss them. Also, I don’t have any reason to think that it should ever change the semantics of the rules, you may just get bad/invalid tracing results"><y>#</y><d>2018-05-23</d><h>17:23</h><w>mikerod</w>&gt;  Or is it always safe to use <code>with-tracing</code> after <code>fire-rules</code> calls?
I think so and expect so. If it has issues, it’d be interesting to discuss them.

Also, I don’t have any reason to think that it should ever change the semantics of the rules, you may just get bad/invalid tracing results</z><z id="t1527096247000159" t="mikerod Earlier you said it caused your rules to not fire correctly, I’m skeptical on that"><y>#</y><d>2018-05-23</d><h>17:24</h><w>mikerod</w>Earlier you said it caused your rules to not fire correctly, I’m skeptical on that</z><z id="t1527096258000116" t="mikerod the tracing may not have accurately reported the rule firings, but they probably still fired"><y>#</y><d>2018-05-23</d><h>17:24</h><w>mikerod</w>the tracing may not have accurately reported the rule firings, but they probably still fired</z><z id="t1527096276000038" t="mikerod you can test that assumption, by adding a defquery to your session"><y>#</y><d>2018-05-23</d><h>17:24</h><w>mikerod</w>you can test that assumption, by adding a <code>defquery</code> to your session</z><z id="t1527096285000155" t="jdt re: firing, my rules had println in them, which didn&apos;t print when the with-tracing was done after the insert ."><y>#</y><d>2018-05-23</d><h>17:24</h><w>jdt</w>re: firing, my rules had <code>println</code>in them, which didn&apos;t print when the <code>with-tracing</code> was done after the <code>insert</code>.</z><z id="t1527096288000388" t="mikerod and then using a query on the RHS insert! facts that you think didn’t get inserted"><y>#</y><d>2018-05-23</d><h>17:24</h><w>mikerod</w>and then using a <code>query</code> on the RHS <code>insert!</code> facts that you think didn’t get inserted</z><z id="t1527096304000122" t="mikerod Yeah, if you can reproduce that case at all, that’d be valuable"><y>#</y><d>2018-05-23</d><h>17:25</h><w>mikerod</w>Yeah, if you can reproduce that case at all, that’d be valuable</z><z id="t1527096315000317" t="jdt Okay, well it&apos;s pretty simple, I&apos;ll see what I can do."><y>#</y><d>2018-05-23</d><h>17:25</h><w>jdt</w>Okay, well it&apos;s pretty simple, I&apos;ll see what I can do.</z><z id="t1527096323001047" t="mikerod I don’t expect with-tracing to be able to interfere with evaluation in that way"><y>#</y><d>2018-05-23</d><h>17:25</h><w>mikerod</w>I don’t expect <code>with-tracing</code> to be able to interfere with evaluation in that way</z><z id="t1527096399000930" t="mikerod @dave.tenny found it"><y>#</y><d>2018-05-23</d><h>17:26</h><w>mikerod</w>@dave.tenny found it</z><z id="t1527096411001045" t="mikerod yeah, so with-tracing does appear to wipe out pending work"><y>#</y><d>2018-05-23</d><h>17:26</h><w>mikerod</w>yeah, so <code>with-tracing</code> does appear to wipe out pending work</z><z id="t1527096424000015" t="mikerod so you’re right, it’d cause trouble like you saw"><y>#</y><d>2018-05-23</d><h>17:27</h><w>mikerod</w>so you’re right, it’d cause trouble like you saw</z><z id="t1527096434000455" t="mikerod after fire-rules should be safe - there is no pending work"><y>#</y><d>2018-05-23</d><h>17:27</h><w>mikerod</w>after <code>fire-rules</code> should be safe - there is no pending work</z><z id="t1527096520000318" t="mikerod it may be a “good thing” that with-tracing wipes out pending work since it makes a session that it can actually trace"><y>#</y><d>2018-05-23</d><h>17:28</h><w>mikerod</w>it may be a “good thing” that <code>with-tracing</code> wipes out pending work since it makes a session that it can actually trace</z><z id="t1527096545000878" t="mikerod well, idk about that, it’s just a weird situation hah - either needs docs or to throw an exception or something I think 🙂"><y>#</y><d>2018-05-23</d><h>17:29</h><w>mikerod</w>well, idk about that, it’s just a weird situation hah - either needs docs or to throw an exception or something I think <b>🙂</b></z><z id="t1527096554000543" t="jdt Sounds like the documentation should be a bit clearer about restrictions though to avoid noob run-ins like mine."><y>#</y><d>2018-05-23</d><h>17:29</h><w>jdt</w>Sounds like the documentation should be a bit clearer about restrictions though to avoid noob run-ins like mine.</z><z id="t1527096561000111" t="mikerod Yes, it is too mysterious"><y>#</y><d>2018-05-23</d><h>17:29</h><w>mikerod</w>Yes, it is too mysterious</z><z id="t1527096810000579" t="jdt I&apos;m just trying to wrap my head around other things, like the Truth Maintenance capabilities that may or may not have been present in the OPS5 systems I was using 30 years ago. I&apos;m pretty rusty at this. Retracting the preconditions that led to the state of the RHS doing the retraction seems to mean I need to fire rules, query my reults on the session afterward, make changes, then rinse-lather-repeat, where it used to be I&apos;d do more stuff in the RHS clauses. Thus my attempts at ... modular ... tracing."><y>#</y><d>2018-05-23</d><h>17:33</h><w>jdt</w>I&apos;m just trying to wrap my head around other things, like the Truth Maintenance capabilities that may or may not have been present in the OPS5 systems I was using 30 years ago.  I&apos;m pretty rusty at this.  Retracting the preconditions that led to the state of the RHS doing the retraction seems to mean I need to fire rules, query my reults on the session afterward, make changes, then rinse-lather-repeat, where it used to be I&apos;d do more stuff in the RHS clauses.   Thus my attempts at  ... modular ... tracing.</z><z id="t1527096942000627" t="jdt So a bit of catching up for me. I&apos;m investigating clara for the job dispatch logic of a new scheduler I&apos;m writing."><y>#</y><d>2018-05-23</d><h>17:35</h><w>jdt</w>So a bit of catching up for me.  I&apos;m investigating clara for the job dispatch logic of a new scheduler I&apos;m writing.</z><z id="t1527096959000421" t="jdt Meanwhile thanks for the help."><y>#</y><d>2018-05-23</d><h>17:35</h><w>jdt</w>Meanwhile thanks for the help.</z><z id="t1527097056000220" t="mikerod sure"><y>#</y><d>2018-05-23</d><h>17:37</h><w>mikerod</w>sure</z><z id="t1527097092000233" t="mikerod @alex-dixon has done a lot with Clara’s tracing by extending it for his own purposes in the #precept library. Perhaps you can find some inspiration there."><y>#</y><d>2018-05-23</d><h>17:38</h><w>mikerod</w>@alex-dixon has done a lot with Clara’s tracing by extending it for his own purposes in the #precept library. Perhaps you can find some inspiration there.</z><z id="t1527097112000053" t="mikerod https://github.com/CoNarrative/precept"><y>#</y><d>2018-05-23</d><h>17:38</h><w>mikerod</w><a href="https://github.com/CoNarrative/precept" target="_blank">https://github.com/CoNarrative/precept</a></z><z id="t1527097434000001" t="alex-dixon I think I ended up using the listeners namespace only. I forget at the moment how it relates to clara’s tracing"><y>#</y><d>2018-05-23</d><h>17:43</h><w>alex-dixon</w>I think I ended up using the listeners namespace only. I forget at the moment how it relates to clara’s tracing</z><z id="t1527097462000204" t="mikerod @alex-dixon oh, tracing just organizes the data coming from listeners I believe"><y>#</y><d>2018-05-23</d><h>17:44</h><w>mikerod</w>@alex-dixon oh, tracing just organizes the data coming from listeners I believe</z><z id="t1527097508000818" t="mikerod wait no, tracing is a default impl over listeners"><y>#</y><d>2018-05-23</d><h>17:45</h><w>mikerod</w>wait no, tracing is a default impl over listeners</z><z id="t1527097514000506" t="alex-dixon Ah ok. That what I seem to remember but thought I may have been confusing it with explanations "><y>#</y><d>2018-05-23</d><h>17:45</h><w>alex-dixon</w>Ah ok. That what I seem to remember but thought I may have been confusing it with explanations </z><z id="t1527097519000496" t="mikerod (sort of the same as I said)"><y>#</y><d>2018-05-23</d><h>17:45</h><w>mikerod</w>(sort of the same as I said)</z><z id="t1527097529000667" t="mikerod yeah, explanations/inspect are above all that"><y>#</y><d>2018-05-23</d><h>17:45</h><w>mikerod</w>yeah, explanations/inspect are above all that</z><z id="t1527097592000662" t="alex-dixon Yet listeners is very user friendly imho. Though I may have ran into some private things I wanted public "><y>#</y><d>2018-05-23</d><h>17:46</h><w>alex-dixon</w>Yet listeners is very user friendly imho. Though I may have ran into some private things I wanted public </z><z id="t1527097724000388" t="alex-dixon It is nice to have it boxed up and ready to use just at the same time the listeners ns is highly usable in and of itself I mean"><y>#</y><d>2018-05-23</d><h>17:48</h><w>alex-dixon</w>It is nice to have it boxed up and ready to use just at the same time the listeners ns is highly usable in and of itself I mean</z><z id="t1527098932000650" t="alex-dixon @dave.tenny If you end up poking around Precept at all I’d recommend the issue 19 branch"><y>#</y><d>2018-05-23</d><h>18:08</h><w>alex-dixon</w>@dave.tenny If you end up poking around Precept at all I’d recommend the issue 19 branch</z><z id="t1527098991000191" t="jdt Will keep that in mind, so far have only looked at Clara-rules."><y>#</y><d>2018-05-23</d><h>18:09</h><w>jdt</w>Will keep that in mind, so far have only looked at Clara-rules.</z><z id="t1527103108000386" t="jdt (defquery my-query ...) followed by a what is typically another function wrapping the query with a call to (query session my-query) gets old. Is there w away to do a lexical defquery equivalent at the point I&apos;d call query ?"><y>#</y><d>2018-05-23</d><h>19:18</h><w>jdt</w><code>(defquery my-query ...) </code> followed by a what is typically another function wrapping the query with a call to <code>(query session my-query)</code> gets old.  Is there w away to do a lexical <code>defquery</code> equivalent at the point I&apos;d call <code>query</code>?</z><z id="t1527103497000411" t="zylox defquery more or less sets up an endpoint in your rules network, it needs to be known before hand"><y>#</y><d>2018-05-23</d><h>19:24</h><w>zylox</w><code>defquery</code> more or less sets up an endpoint in your rules network, it needs to be known before hand</z><z id="t1527103534000757" t="zylox query goes and grabs the list it generates at when things are fired, it doesnt go calculate it then (to my knowlege)"><y>#</y><d>2018-05-23</d><h>19:25</h><w>zylox</w><code>query</code> goes and grabs the list it generates at when things are fired, it doesnt go calculate it then (to my knowlege)</z><z id="t1527104241000353" t="zylox you can, and i would not reccomend this outside of development, create a defquery for Object that just grabs everything in the session and then filter that as you see fit."><y>#</y><d>2018-05-23</d><h>19:37</h><w>zylox</w>you can, and i would not reccomend this outside of development, create a <code>defquery</code> for <code>Object</code> that just grabs everything in the session and then filter that as you see fit.</z><z id="t1527107735000526" t="mikerod @dave.tenny I’ve only partially read your example so far, but one immediate piece of feedback, don’t query until after fire-rules"><y>#</y><d>2018-05-23</d><h>20:35</h><w>mikerod</w>@dave.tenny I’ve only partially read your example so far, but one immediate piece of feedback, don’t <code>query</code> until after <code>fire-rules</code></z><z id="t1527107753000106" t="mikerod think of query the same as with-tracing earlier, you have to only do it on “consistent” states of a session"><y>#</y><d>2018-05-23</d><h>20:35</h><w>mikerod</w>think of <code>query</code> the same as <code>with-tracing</code> earlier, you have to only do it on “consistent” states of a session</z><z id="t1527107790000610" t="mikerod Clara does some delayed evaluation for performance reasons. Any inserts/retracts that occur prior to a fire-rule cannot be relied upon and I’d consider the session to be in an “undefined” state"><y>#</y><d>2018-05-23</d><h>20:36</h><w>mikerod</w>Clara does some delayed evaluation for performance reasons. Any inserts/retracts that occur prior to a <code>fire-rule</code> cannot be relied upon and I’d consider the session to be in an “undefined” state</z><z id="t1527107861000276" t="mikerod I’d actually prefer Clara to change for query to either (a) throw exception if called prior to a fire-rules or return something that indicates it is not ready yet."><y>#</y><d>2018-05-23</d><h>20:37</h><w>mikerod</w>I’d actually prefer Clara to change for <code>query</code> to either (a) throw exception if called prior to a <code>fire-rules</code> or return something that indicates it is not ready yet.</z><z id="t1527107930000808" t="mikerod Clara takes advantaged of batched insertion and also potentially a few other things, so it does not eagerly perform things like insert or retract . The evaluation is typically pushed to batch up the facts propagating through the network. This can play a major role in performance."><y>#</y><d>2018-05-23</d><h>20:38</h><w>mikerod</w>Clara takes advantaged of batched insertion and also potentially a few other things, so it does not eagerly perform things like <code>insert</code> or <code>retract</code>. The evaluation is typically pushed to batch up the facts propagating through the network. This can play a major role in performance.</z><z id="t1527107989000230" t="mikerod You mentioned OPS5, which you likely wouldn’t have seen behavior like this long ago. It is more common now. Drools is a popular JVM-based rules engine and it similarly has delayed evaluation of things prior to rule firing due to similar concerns."><y>#</y><d>2018-05-23</d><h>20:39</h><w>mikerod</w>You mentioned OPS5, which you likely wouldn’t have seen behavior like this long ago. It is more common now. Drools is a popular JVM-based rules engine and it similarly has delayed evaluation of things prior to rule firing due to similar concerns.</z><z id="t1527108027000423" t="mikerod This issue seems to somewhat often trip people up though. So I don’t think it is clear enough."><y>#</y><d>2018-05-23</d><h>20:40</h><w>mikerod</w>This issue seems to somewhat often trip people up though. So I don’t think it is clear enough.</z><z id="t1527108073000373" t="mikerod For your second question &gt; ;why are my counters still there, I retracted them? I think it is because (query % counters) doesn’t return what you are thinking it does"><y>#</y><d>2018-05-23</d><h>20:41</h><w>mikerod</w>For your second question
&gt;  ;why are my counters still there, I retracted them?

I think it is because <code>(query % counters)</code> doesn’t return what you are thinking it does</z><z id="t1527108112000041" t="mikerod It doesn’t return the bare counter fact, instead it returns a bindings map from the query, so it returns something like: {:?counter &lt;the counter fact&gt;} "><y>#</y><d>2018-05-23</d><h>20:41</h><w>mikerod</w>It doesn’t return the bare counter fact, instead it returns a bindings map from the query, so it returns something like:
<pre>{:?counter &lt;the counter fact&gt;}

</pre></z><z id="t1527108152000415" t="mikerod so you’d probably have to do something like (#(apply retract % (map :?counter (query % counters)))) "><y>#</y><d>2018-05-23</d><h>20:42</h><w>mikerod</w>so you’d probably have to do something like
<pre>(#(apply retract % (map :?counter (query % counters))))

</pre></z><z id="t1527108156000178" t="jdt Oh sorry, forgot to include the output"><y>#</y><d>2018-05-23</d><h>20:42</h><w>jdt</w>Oh sorry, forgot to include the output</z><z id="t1527108160000300" t="jdt It works, just not as expected"><y>#</y><d>2018-05-23</d><h>20:42</h><w>jdt</w>It works, just not as expected</z><z id="t1527108163000286" t="jdt Here comes the output"><y>#</y><d>2018-05-23</d><h>20:42</h><w>jdt</w>Here comes the output</z><z id="t1527108238000182" t="mikerod that output looks consistent with the explanation I just gave"><y>#</y><d>2018-05-23</d><h>20:43</h><w>mikerod</w>that output looks consistent with the explanation I just gave</z><z id="t1527108243000266" t="mikerod so try to apply the things I mentioned"><y>#</y><d>2018-05-23</d><h>20:44</h><w>mikerod</w>so try to apply the things I mentioned</z><z id="t1527108317000628" t="jdt Ah, that fixes it"><y>#</y><d>2018-05-23</d><h>20:45</h><w>jdt</w>Ah, that fixes it</z><z id="t1527108326000127" t="jdt (map :?counter ...)"><y>#</y><d>2018-05-23</d><h>20:45</h><w>jdt</w><code>(map :?counter ...)</code></z><z id="t1527108351000626" t="mikerod 🎉"><y>#</y><d>2018-05-23</d><h>20:45</h><w>mikerod</w><b>🎉</b></z><z id="t1527267457000425" t="jdt I&apos;m guessing the second [Derived 1] is retracted after insertion, though that isn&apos;t what I want, in fact in my POC rule set I&apos;m doing an insert-unconditional! because the fact must survive, subsequent retraction, but I still only one exactly one instance to be inserted, i.e. one-time initialization."><y>#</y><d>2018-05-25</d><h>16:57</h><w>jdt</w>I&apos;m guessing the second [Derived 1] is retracted after insertion, though that isn&apos;t what I want, in fact in my POC rule set I&apos;m doing an <code>insert-unconditional!</code> because the fact must survive, subsequent retraction, but I still only one exactly one instance to be inserted, i.e. one-time initialization.</z><z id="t1527267846000144" t="mikerod @dave.tenny you know you’re inserting a vector there right?"><y>#</y><d>2018-05-25</d><h>17:04</h><w>mikerod</w>@dave.tenny you know you’re inserting a vector there right?</z><z id="t1527267859000693" t="mikerod Just noticed that this seems odd (insert! [Derived ?x])"><y>#</y><d>2018-05-25</d><h>17:04</h><w>mikerod</w>Just noticed that this seems odd <code> (insert! [Derived ?x])</code></z><z id="t1527267877000122" t="jdt Lol, I looked at it thinking &quot;something isn&apos;t right here&quot; too"><y>#</y><d>2018-05-25</d><h>17:04</h><w>jdt</w>Lol, I looked at it thinking &quot;something isn&apos;t right here&quot; too</z><z id="t1527267895000631" t="jdt Just too Friday-minded to see it, thanks for looking"><y>#</y><d>2018-05-25</d><h>17:04</h><w>jdt</w>Just too Friday-minded to see it, thanks for looking</z><z id="t1527267898000612" t="mikerod however, with insert! I think you may get in an infinite loop"><y>#</y><d>2018-05-25</d><h>17:04</h><w>mikerod</w>however, with <code>insert!</code> I think you may get in an infinite loop</z><z id="t1527267907000233" t="mikerod because your rule becomes a logical contradiction"><y>#</y><d>2018-05-25</d><h>17:05</h><w>mikerod</w>because your rule becomes a logical contradiction</z><z id="t1527267936000605" t="mikerod So I think there are just several different topics with this example, 😛"><y>#</y><d>2018-05-25</d><h>17:05</h><w>mikerod</w>So I think there are just several different topics with this example, <b>😛</b></z><z id="t1527267936000643" t="jdt yes indeed, infinite loop"><y>#</y><d>2018-05-25</d><h>17:05</h><w>jdt</w>yes indeed, infinite loop</z><z id="t1527267972000483" t="mikerod you can do an insert-unconditional! of course"><y>#</y><d>2018-05-25</d><h>17:06</h><w>mikerod</w>you can do an <code>insert-unconditional!</code> of course</z><z id="t1527267979000649" t="jdt Amending the snippet"><y>#</y><d>2018-05-25</d><h>17:06</h><w>jdt</w>Amending the snippet</z><z id="t1527267986000419" t="mikerod I’m not a huge fan of those, because they cause rules to become more order dependent’"><y>#</y><d>2018-05-25</d><h>17:06</h><w>mikerod</w>I’m not a huge fan of those, because they cause rules to become more order dependent’</z><z id="t1527268000000054" t="mikerod However, there are times where they are difficult to avoid I know"><y>#</y><d>2018-05-25</d><h>17:06</h><w>mikerod</w>However, there are times where they are difficult to avoid I know</z><z id="t1527268068000295" t="jdt In my case, I need to add a fact to the system, once to &quot;initialize&quot; the absense of a missing fact. The fact needs to survive truth maintenace because I am going to retract the basis for creating it, but not the need for using it later on"><y>#</y><d>2018-05-25</d><h>17:07</h><w>jdt</w>In my case, I need to add a fact to the system, once to &quot;initialize&quot; the absense of a missing fact.  The fact needs to survive truth maintenace because I am going to retract the basis for creating it, but  not the need for using it later on</z><z id="t1527268073000592" t="mikerod Your snippet now has no code, only output"><y>#</y><d>2018-05-25</d><h>17:07</h><w>mikerod</w>Your snippet now has no code, only output</z><z id="t1527268084000295" t="jdt yeah, once sec, reposting the snippet, there was no &quot;edit&quot;"><y>#</y><d>2018-05-25</d><h>17:08</h><w>jdt</w>yeah, once sec, reposting the snippet, there was no &quot;edit&quot;</z><z id="t1527268217000656" t="jdt I deleted the first snippet, it shouldn&apos;t exist at all in slack, actually."><y>#</y><d>2018-05-25</d><h>17:10</h><w>jdt</w>I deleted the first snippet, it shouldn&apos;t exist at all in slack, actually.</z><z id="t1527268319000647" t="jdt Anyway, I&apos;m clearly not yet in the mindset of thinking the way clara wants me to think. I&apos;d expect a rule like [:not [Foo]] =&gt; (insert-unconditional! (-&gt;Foo)) to fire exactly once, but clearly my assumptions are wrong."><y>#</y><d>2018-05-25</d><h>17:11</h><w>jdt</w>Anyway, I&apos;m clearly not yet in the mindset of thinking the way clara wants me to think.  I&apos;d expect a rule like <code>[:not [Foo]] =&gt; (insert-unconditional! (-&gt;Foo))</code> to fire exactly once, but clearly my assumptions are wrong.</z><z id="t1527268421000084" t="alex-dixon Wouldn’t call that a bad assumption but that rule effectively means when not foo foo and when foo not foo"><y>#</y><d>2018-05-25</d><h>17:13</h><w>alex-dixon</w>Wouldn’t call that a bad assumption but that rule effectively means when not foo foo and when foo not foo</z><z id="t1527268453000136" t="mikerod if you use insert! the behavior is a contradiction, with insert-unconditional! it is different"><y>#</y><d>2018-05-25</d><h>17:14</h><w>mikerod</w>if you use <code>insert!</code> the behavior is a contradiction, with <code>insert-unconditional!</code> it is different</z><z id="t1527268476000225" t="mikerod There is also a property you can add to rules, I don’t typically like to add it though, but it is :no-loop"><y>#</y><d>2018-05-25</d><h>17:14</h><w>mikerod</w>There is also a property you can add to rules, I don’t typically like to add it though, but it is <code>:no-loop</code></z><z id="t1527268509000696" t="alex-dixon Oops. with unconditional it should operate as you stated I think"><y>#</y><d>2018-05-25</d><h>17:15</h><w>alex-dixon</w>Oops. with unconditional it should operate as you stated I think</z><z id="t1527268512000289" t="mikerod it may be able to stop a logical loop from a contradicting rule like you have here with insert! , but I’d have to mess with that again"><y>#</y><d>2018-05-25</d><h>17:15</h><w>mikerod</w>it may be able to stop a logical loop from a contradicting rule like you have here with <code>insert!</code>, but I’d have to mess with that again</z><z id="t1527268517000178" t="jdt Oops, yes, my code snippet iwth the infinite loop isn&apos;t interesting. When I use insert-unconditional it&apos;s still firing more than once"><y>#</y><d>2018-05-25</d><h>17:15</h><w>jdt</w>Oops, yes, my code snippet iwth the infinite loop isn&apos;t interesting.  When I use <code>insert-unconditional</code> it&apos;s still firing more than once</z><z id="t1527268526000066" t="mikerod @alex-dixon I haven’t seen an insert-unconditional! example yet 😛"><y>#</y><d>2018-05-25</d><h>17:15</h><w>mikerod</w>@alex-dixon I haven’t seen an <code>insert-unconditional!</code> example yet <b>😛</b></z><z id="t1527268530000011" t="jdt Doing the code snippet and output again, apologies"><y>#</y><d>2018-05-25</d><h>17:15</h><w>jdt</w>Doing the code snippet and output again, apologies</z><z id="t1527268551000175" t="mikerod insert-unconditional! will result in a firing for each of your Fact objects, so 3 is rigth"><y>#</y><d>2018-05-25</d><h>17:15</h><w>mikerod</w><code>insert-unconditional!</code> will result in a firing for each of your <code>Fact</code> objects, so 3 is rigth</z><z id="t1527268601000363" t="alex-dixon What about not exists?"><y>#</y><d>2018-05-25</d><h>17:16</h><w>alex-dixon</w>What about not exists?</z><z id="t1527268618000045" t="jdt I thought [:not [Foo]] was a not-exist check?"><y>#</y><d>2018-05-25</d><h>17:16</h><w>jdt</w>I thought <code>[:not [Foo]]</code> was a not-exist check?</z><z id="t1527268622000428" t="mikerod The rules do not treat the working memory as something like a set. It allows “duplicates”. There are useful cases for that - scratch this"><y>#</y><d>2018-05-25</d><h>17:17</h><w>mikerod</w>The rules do not treat the working memory as something like a set. It allows “duplicates”. There are useful cases for that - scratch this</z><z id="t1527268633000518" t="mikerod oh, I see what you mean"><y>#</y><d>2018-05-25</d><h>17:17</h><w>mikerod</w>oh, I see what you mean</z><z id="t1527268713000592" t="mikerod @dave.tenny you’re correct in what :not is"><y>#</y><d>2018-05-25</d><h>17:18</h><w>mikerod</w>@dave.tenny you’re correct in what <code>:not</code> is</z><z id="t1527268822000531" t="mikerod I think it may be an “edge case” on insert-unconditional! behavior in the engine. I’d probably call it incorrect how the engine is behaving"><y>#</y><d>2018-05-25</d><h>17:20</h><w>mikerod</w>I think it may be an “edge case” on <code>insert-unconditional!</code> behavior in the engine. I’d probably call it incorrect how the engine is behaving</z><z id="t1527268846000305" t="jdt I&apos;m confused because on the one hand, the RHS of one rule can impact the firing of another rule. But in this case it&apos;s like both checks for a [Derived 1] correpesponding to a [Fact 1] took place at the same time, neither aware of the others effect, and unsure how to bridge that."><y>#</y><d>2018-05-25</d><h>17:20</h><w>jdt</w>I&apos;m confused because on the one hand, the RHS of one rule can impact the firing of another rule.  But in this case it&apos;s like both checks for a [Derived 1] correpesponding to a [Fact 1] took place at the same time, neither aware of the others effect, and unsure how to bridge that.</z><z id="t1527268901000429" t="mikerod Like I said, I’m not a fan of insert-unconditional! and try to not use it much because I think it makes things have order dependence and always trickier to reason about as far as “global logical consistency” across the rules"><y>#</y><d>2018-05-25</d><h>17:21</h><w>mikerod</w>Like I said, I’m not a fan of <code>insert-unconditional!</code> and try to not use it much because I think it makes things have order dependence and always trickier to reason about as far as “global logical consistency” across the rules</z><z id="t1527268905000600" t="jdt (reminds me of MVCC transactions, which can be a good thing ... in a database 😉 )"><y>#</y><d>2018-05-25</d><h>17:21</h><w>jdt</w>(reminds me of MVCC transactions, which can be a good thing ... in a database <b>😉</b> )</z><z id="t1527268912000308" t="mikerod However, in this case, I think it is behaving poorly with batched inserts"><y>#</y><d>2018-05-25</d><h>17:21</h><w>mikerod</w>However, in this case, I think it is behaving poorly with batched inserts</z><z id="t1527268942000552" t="mikerod I think all 3 matches are staged independent of one another and all perform insert-unconditional! at the “same time”"><y>#</y><d>2018-05-25</d><h>17:22</h><w>mikerod</w>I think all 3 matches are staged independent of one another and all perform <code>insert-unconditional!</code> at the “same time”</z><z id="t1527268959000083" t="mikerod since they are unconditional, the truth maintenance isn’t used to remove the logical inconsistencies"><y>#</y><d>2018-05-25</d><h>17:22</h><w>mikerod</w>since they are unconditional, the truth maintenance isn’t used to remove the logical inconsistencies</z><z id="t1527268986000244" t="mikerod this is a tougher case to me conceptually to think about"><y>#</y><d>2018-05-25</d><h>17:23</h><w>mikerod</w>this is a tougher case to me conceptually to think about</z><z id="t1527268997000327" t="mikerod as far as a “fix” would go"><y>#</y><d>2018-05-25</d><h>17:23</h><w>mikerod</w>as far as a “fix” would go</z><z id="t1527269083000379" t="jdt Okay, well, I&apos;ll remedy my immediate problem by doing what is fundamentally an initialization step outside of the rule firing and add my initialization outside of the firings (i.e. not in an RHS via insert! , but via insert externally."><y>#</y><d>2018-05-25</d><h>17:24</h><w>jdt</w>Okay, well, I&apos;ll remedy my immediate problem by doing what is fundamentally an initialization step outside of the rule firing and add my initialization outside of the firings (i.e. not in an RHS via <code>insert!</code>, but via <code>insert</code> externally.</z><z id="t1527269085000512" t="alex-dixon Wondering if behavior is different if derived is inserted without ?x...maybe y instead "><y>#</y><d>2018-05-25</d><h>17:24</h><w>alex-dixon</w>Wondering if behavior is different if derived is inserted without ?x...maybe y instead </z><z id="t1527269140000162" t="jdt I&apos;m definitely still struggling with these little things, though logic principles of [not x] =&gt; [x] is a good way ot look at it in my thinking for the future."><y>#</y><d>2018-05-25</d><h>17:25</h><w>jdt</w>I&apos;m definitely still struggling with these little things, though logic principles of <code>[not x] =&gt; [x]</code> is a good way ot look at it in my thinking for the future.</z><z id="t1527269196000312" t="mikerod @dave.tenny oftentimes, and I’ve said this quite a bit here before, I try to separate the desire of “cardinality” into a different rule from the rule that has the logic to derive the fact in question"><y>#</y><d>2018-05-25</d><h>17:26</h><w>mikerod</w>@dave.tenny oftentimes, and I’ve said this quite a bit here before, I try to separate the desire of “cardinality” into a different rule from the rule that has the logic to derive the fact in question</z><z id="t1527269207000705" t="jdt This particular one is very unfortunate though, if it worked it was much nicer and more foolproof when done via a rule firing."><y>#</y><d>2018-05-25</d><h>17:26</h><w>jdt</w>This particular one is very unfortunate though, if it worked it was much nicer and more foolproof when done via a rule firing.</z><z id="t1527269224000030" t="mikerod So instead of worrying about a rule producing too many of something, I let it produce them, and reconcile them with a separate rule and an accumulator"><y>#</y><d>2018-05-25</d><h>17:27</h><w>mikerod</w>So instead of worrying about a rule producing too many of something, I let it produce them, and reconcile them with a separate rule and an accumulator</z><z id="t1527269236000238" t="alex-dixon @mikerod what’s the upside to the batched unconditional insertions implementation? Is it possible to still attain those benefits without eliciting behavior like this?"><y>#</y><d>2018-05-25</d><h>17:27</h><w>alex-dixon</w>@mikerod what’s the upside to the batched unconditional insertions implementation? Is it possible to still attain those benefits without eliciting behavior like this?</z><z id="t1527269246000339" t="mikerod this case is a bit different in a way, but if your real concern is only that you don’t want 2 Derived :y 1 facts, it applies"><y>#</y><d>2018-05-25</d><h>17:27</h><w>mikerod</w>this case is a bit different in a way, but if your real concern is only that you don’t  want 2 <code>Derived :y 1</code> facts, it applies</z><z id="t1527269273000655" t="mikerod @alex-dixon batched &lt;anything&gt; upside is basically always performance"><y>#</y><d>2018-05-25</d><h>17:27</h><w>mikerod</w>@alex-dixon batched &lt;anything&gt; upside is basically always performance</z><z id="t1527269280000040" t="mikerod and the performance can be really significant"><y>#</y><d>2018-05-25</d><h>17:28</h><w>mikerod</w>and the performance can be really significant</z><z id="t1527269314000096" t="mikerod However, in the unconditional case, it now concerns me a bit since the truth maintenance won’t “fix it” when different unconditional inserts cause the other to become untrue"><y>#</y><d>2018-05-25</d><h>17:28</h><w>mikerod</w>However, in the unconditional case, it now concerns me a bit since the truth maintenance won’t “fix it” when different unconditional inserts cause the other to become untrue</z><z id="t1527269340000020" t="mikerod however, that is a really gray area to me. if it did behave right, how would it choose which unconditional insert wins, when they contradict each other? In the general case."><y>#</y><d>2018-05-25</d><h>17:29</h><w>mikerod</w>however, that is a really gray area to me. if it did behave right, how would it choose which unconditional insert wins, when they contradict each other? In the general case.</z><z id="t1527269346000085" t="mikerod I guess it would just have to be order-dependent"><y>#</y><d>2018-05-25</d><h>17:29</h><w>mikerod</w>I guess it would just have to be order-dependent</z><z id="t1527269401000062" t="jdt On an unrelated topic, can you recommend tools for pretty-printing/organizing inspect and get-trace output to assist with reading it? I made my first attempt at decoding that stuff to debug, but as a raw clojure nested structure it&apos;s rough going for a first try."><y>#</y><d>2018-05-25</d><h>17:30</h><w>jdt</w>On an unrelated topic, can you recommend tools for pretty-printing/organizing <code>inspect</code> and <code>get-trace</code> output to assist with reading it?   I made my first attempt at decoding that stuff to debug, but as a raw clojure nested structure it&apos;s rough going for a first try.</z><z id="t1527269478000080" t="mikerod @dave.tenny @alex-dixon is going to release a tool to show tracing stuff nicer 😛"><y>#</y><d>2018-05-25</d><h>17:31</h><w>mikerod</w>@dave.tenny @alex-dixon is going to release a tool to show tracing stuff nicer <b>😛</b></z><z id="t1527269536000577" t="mikerod Joking.. but he has said he had a better visualization thing. The trace results will be pretty verbose and clj data structures. Inspect was supposed to have a few friendlier printers I think. I haven’t used inspect much."><y>#</y><d>2018-05-25</d><h>17:32</h><w>mikerod</w>Joking.. but he has said he had a better visualization thing. The trace results will be pretty verbose and clj data structures. Inspect was supposed to have a few friendlier printers I think. I haven’t used inspect much.</z><z id="t1527269642000682" t="jdt Of course what I really want is a simple movie-mode rule tracing with verbose-mode description of clause evaluation impact on rule consideration/rejection. Heh, or is that [:test (do (prn &quot;here I am&quot;) true)] in the LHS?"><y>#</y><d>2018-05-25</d><h>17:34</h><w>jdt</w>Of course what I really want is a simple movie-mode rule tracing with verbose-mode description of clause evaluation impact on rule consideration/rejection.   Heh, or is that <code>[:test (do (prn &quot;here I am&quot;) true)]</code> in the LHS?</z><z id="t1527269739000160" t="mikerod @dave.tenny yeah, you can print stuff. I think the tracing output can be used alright, but it’s mostly just composing functions on it to show it however is useful."><y>#</y><d>2018-05-25</d><h>17:35</h><w>mikerod</w>@dave.tenny yeah, you can print stuff. I think the tracing output can be used alright, but it’s mostly just composing functions on it to show it however is useful.</z><z id="t1527269769000289" t="mikerod I don’t have any great pointers there still beyond that"><y>#</y><d>2018-05-25</d><h>17:36</h><w>mikerod</w>I don’t have any great pointers there still beyond that</z><z id="t1527269799000055" t="jdt Haven&apos;t seen any &quot;tips and tricks&quot; documentation for the sorts of things a newbie could use for debugging"><y>#</y><d>2018-05-25</d><h>17:36</h><w>jdt</w>Haven&apos;t seen any &quot;tips and tricks&quot; documentation for the sorts of things a newbie could use for debugging</z><z id="t1527269802000714" t="jdt if it&apos;s out there"><y>#</y><d>2018-05-25</d><h>17:36</h><w>jdt</w>if it&apos;s out there</z><z id="t1527270156000134" t="mikerod Yeah, I think this may be something that is lacking (and would be really nice to have)."><y>#</y><d>2018-05-25</d><h>17:42</h><w>mikerod</w>Yeah, I think this may be something that is lacking (and would be really nice to have).</z><z id="t1527270166000182" t="mikerod The most docs I see are just from http://www.clara-rules.org/docs/inspection/"><y>#</y><d>2018-05-25</d><h>17:42</h><w>mikerod</w>The most docs I see are just from <a href="http://www.clara-rules.org/docs/inspection/" target="_blank">http://www.clara-rules.org/docs/inspection/</a></z><z id="t1527276511000482" t="alex-dixon @mikerod It’s not better according to me. And yeah…I’m working on it again this weekend 🙂"><y>#</y><d>2018-05-25</d><h>19:28</h><w>alex-dixon</w>@mikerod It’s not better according to me. And yeah…I’m working on it again this weekend <b>🙂</b></z><z id="t1527276682000470" t="alex-dixon Might open an issue in Clara about adding Datalog syntax as a separate clara library. For something like the precept devtools concept I’m not sure how that would work….would need to think about it or have some direction from others. A lot of the way I thought about it was Precept-specific. I think the main difference is that there’s framework to manage session transitions, so there’s code that’s aware of when rules are firing and when they’re done firing that allows them to be identified and numbered"><y>#</y><d>2018-05-25</d><h>19:31</h><w>alex-dixon</w>Might open an issue in Clara about adding Datalog syntax as a separate clara library. For something like the precept devtools concept I’m not sure how that would work….would need to think about it or have some direction from others. A lot of the way I thought about it was Precept-specific. I think the main difference is that there’s framework to manage session transitions, so there’s code that’s aware of when rules are firing and when they’re done firing that allows them to be identified and numbered</z><z id="t1527276695000168" t="alex-dixon Sorry if that’s incoherent"><y>#</y><d>2018-05-25</d><h>19:31</h><w>alex-dixon</w>Sorry if that’s incoherent</z><z id="t1527286846000295" t="mikerod @alex-dixon Yeah, I’d have to think about that more too. I get what you are saying though I think."><y>#</y><d>2018-05-25</d><h>22:20</h><w>mikerod</w>@alex-dixon Yeah, I’d have to think about that more too. I get what you are saying though I think.</z><z id="t1527473799000070" t="alex-dixon I think I’m about ready to release an alpha preview of precept devtools to anyone who’s interested"><y>#</y><d>2018-05-28</d><h>02:16</h><w>alex-dixon</w>I think I’m about ready to release an alpha preview of precept devtools to anyone who’s interested</z><z id="t1527476706000052" t="alex-dixon @devn https://github.com/CoNarrative/precept-devtools"><y>#</y><d>2018-05-28</d><h>03:05</h><w>alex-dixon</w>@devn <a href="https://github.com/CoNarrative/precept-devtools" target="_blank">https://github.com/CoNarrative/precept-devtools</a></z><z id="t1527476922000162" t="alex-dixon If at all possible I’d prefer not to publicize it (yet) until I make some improvements to the readme and a few other things"><y>#</y><d>2018-05-28</d><h>03:08</h><w>alex-dixon</w>If at all possible I’d prefer not to publicize it (yet) until I make some improvements to the readme and a few other things</z><z id="t1527477264000024" t="alex-dixon I’d definitely appreciate any feedback though"><y>#</y><d>2018-05-28</d><h>03:14</h><w>alex-dixon</w>I’d definitely appreciate any feedback though</z><z id="t1527685046000002" t="jdt I&apos;m just building this little prototype rule-based scheduler in clara to see if it will handle things at scale. It won&apos;t have many rules, but it will have a pragmatic maximum of 1-2 million base facts before firing the rule engine. Am I wasting my time, or will that overwhelm the system? (The bulk of the facts are job requests, from which we then infer things like whether there&apos;s a worker with adequate resources, round robin behaviors, and so on.)"><y>#</y><d>2018-05-30</d><h>12:57</h><w>jdt</w>I&apos;m just building this little prototype rule-based scheduler in clara to see if it will handle things at scale.  It won&apos;t have many rules, but it will have a pragmatic maximum of 1-2 million base facts before firing the rule engine.  Am I wasting my time, or will that overwhelm the system?  (The bulk of the facts are job requests, from which we then infer things like whether there&apos;s a worker with adequate resources, round robin behaviors, and so on.)</z><z id="t1527685942000266" t="jdt (I&apos;m building the new intermediate binding of WorkerViableJob and ActiveUserJobCount, I just wondered if there wasn&apos;t a way to correlate the two records in the :and subclause that considers them without the use if an intermediate fact)."><y>#</y><d>2018-05-30</d><h>13:12</h><w>jdt</w>(I&apos;m building the new intermediate binding of WorkerViableJob and ActiveUserJobCount, I just wondered if there wasn&apos;t a way to correlate the two records in the <code>:and</code> subclause that considers them without the use if an intermediate fact).</z><z id="t1527695306000295" t="mikerod @dave.tenny I’d perhaps worry about that being a fairly slow way to do what you are saying given that you have so many facts in the session"><y>#</y><d>2018-05-30</d><h>15:48</h><w>mikerod</w>@dave.tenny I’d perhaps worry about that being a fairly slow way to do what you are saying given that you have so many facts in the session</z><z id="t1527695347000129" t="jdt &quot;that&quot; being using a rules system?"><y>#</y><d>2018-05-30</d><h>15:49</h><w>jdt</w>&quot;that&quot; being using a rules system?</z><z id="t1527695369000360" t="mikerod I think if you have enough memory for that many objects, then the rules could perform alright. However, you will have to look out for bad algorithmic complexity in some rules if they are going to be processed over a very large amount of facts, like if you do some wide-open joins between sets of facts with size N and size M, you’ll get NxM comparisons in the join criteria"><y>#</y><d>2018-05-30</d><h>15:49</h><w>mikerod</w>I think if you have enough memory for that many objects, then the rules could perform alright. However, you will have to look out for bad algorithmic complexity in some rules if they are going to be processed over a very large amount of facts, like if you do some wide-open joins between sets of facts with size N and size M, you’ll get NxM comparisons in the join criteria</z><z id="t1527695398000045" t="jdt yeah, trying to keep things tightly joined, and avoid derived facts that I don&apos;t need where possible"><y>#</y><d>2018-05-30</d><h>15:49</h><w>jdt</w>yeah, trying to keep things tightly joined, and avoid derived facts that I don&apos;t need where possible</z><z id="t1527695403000849" t="mikerod Oh, I mean the rule you gave above may be slow, if there are millions of WorkerViableJob and ActiveUserJobCount"><y>#</y><d>2018-05-30</d><h>15:50</h><w>mikerod</w>Oh, I mean the rule you gave above may be slow, if there are millions of <code>WorkerViableJob</code> and <code>ActiveUserJobCount</code></z><z id="t1527695417000175" t="jdt No, there&apos;s only millions of raw job request."><y>#</y><d>2018-05-30</d><h>15:50</h><w>jdt</w>No, there&apos;s only millions of raw job request.</z><z id="t1527695423000780" t="mikerod I think that a rules engine, such as Clara, may be capable of having reasonable perf characteristics, but you’d have to be careful for the “hot spots”"><y>#</y><d>2018-05-30</d><h>15:50</h><w>mikerod</w>I think that a rules engine, such as Clara, may be capable of having reasonable perf characteristics, but you’d have to be careful for the “hot spots”</z><z id="t1527695454000049" t="jdt There are relatively fiew WorkerViableJobs (those are jobs for which we know we have worker resources available, and we limit those to a small number of oldest/most-applicable jobs in any fire-rules run)"><y>#</y><d>2018-05-30</d><h>15:50</h><w>jdt</w>There are relatively fiew WorkerViableJobs (those are jobs for which we know we have worker resources available, and we limit those to a small number of oldest/most-applicable jobs in any fire-rules run)</z><z id="t1527695454000287" t="mikerod It’s best to quickly filter down to a smaller set of facts before performing the more involved joins between sets of facts"><y>#</y><d>2018-05-30</d><h>15:50</h><w>mikerod</w>It’s best to quickly filter down to a smaller set of facts before performing the more involved joins between sets of facts</z><z id="t1527695488000318" t="mikerod I would not fear intermediate facts either"><y>#</y><d>2018-05-30</d><h>15:51</h><w>mikerod</w>I would not fear intermediate facts either</z><z id="t1527695501000105" t="mikerod I think it’ll help your rule given above even"><y>#</y><d>2018-05-30</d><h>15:51</h><w>mikerod</w>I think it’ll help your rule given above even</z><z id="t1527695524000839" t="jdt Yeah, already fixed that by asserting facts representing bindings of the clause."><y>#</y><d>2018-05-30</d><h>15:52</h><w>jdt</w>Yeah, already fixed that by asserting facts representing bindings of the clause.</z><z id="t1527695537000360" t="jdt I just wondered if there was a better way"><y>#</y><d>2018-05-30</d><h>15:52</h><w>jdt</w>I just wondered if there was a better way</z><z id="t1527695604000573" t="jdt I also repeatedly fall into the trap of [:not A] =&gt; A in my rules, because I only want to make an A if some other particular thing isn&apos;t true. Finding my way around it, but feels like I fight the problem a lot, whether or not the inserted A is unconditional."><y>#</y><d>2018-05-30</d><h>15:53</h><w>jdt</w>I also repeatedly fall into the trap of  <code>[:not A] =&gt; A</code> in my rules, because I only want to make an A if some other particular thing isn&apos;t true.  Finding my way around it, but feels like I fight the problem a lot, whether or not the inserted A is unconditional.</z><z id="t1527695605000030" t="mikerod perhaps"><y>#</y><d>2018-05-30</d><h>15:53</h><w>mikerod</w>perhaps</z><z id="t1527695688000842" t="jdt Even though I don&apos;t have too many rules now, there&apos;s actually a lot we want to do in our job management, affinities, special cases for &quot;new job submitters&quot; to give them optimal user experience in interacting with the jobs whose results they want, etc."><y>#</y><d>2018-05-30</d><h>15:54</h><w>jdt</w>Even though I don&apos;t have too many rules now, there&apos;s actually a lot we want to do in our job management, affinities, special cases for &quot;new job submitters&quot; to give them optimal user experience in interacting with the jobs whose results they want, etc.</z><z id="t1527695712000096" t="jdt So that&apos;s why I&apos;m spending a bit too much time to see if this is viable, I think rules could be a real win here."><y>#</y><d>2018-05-30</d><h>15:55</h><w>jdt</w>So that&apos;s why I&apos;m spending a bit too much time to see if this is viable, I think rules could be a real win here.</z><z id="t1527695730000520" t="mikerod So in your above example, I wonder if you could make use of an accumulator like: [?lowest &lt;- (acc/min :n-jobs) :from [ActiveUserJobCount (= ?job-type job-type)]] "><y>#</y><d>2018-05-30</d><h>15:55</h><w>mikerod</w>So in  your above example, I wonder if you could make use of an accumulator like:
<pre>[?lowest &lt;- (acc/min :n-jobs) :from [ActiveUserJobCount (= ?job-type job-type)]]
</pre></z><z id="t1527695743000340" t="mikerod however, I don’t know that I immediately get the full semantics (like what the RHS) does"><y>#</y><d>2018-05-30</d><h>15:55</h><w>mikerod</w>however, I don’t know that I immediately get the full semantics (like what the RHS) does</z><z id="t1527695758000852" t="mikerod but doing that would give you the min job count for a given :job-type in terms of the ActiveUserJobCount facts"><y>#</y><d>2018-05-30</d><h>15:55</h><w>mikerod</w>but doing that would give you the min job count for a given <code>:job-type</code> in terms of the <code>ActiveUserJobCount</code> facts</z><z id="t1527695784000735" t="mikerod For this one: &gt; I also repeatedly fall into the trap of [:not A] =&gt; A in my rules, because I only want to make an A if some other particular thing isn’t true I don’t know of a fix-all. It’s a case by case thing. Not sure what sort of scenario keeps getting you into it."><y>#</y><d>2018-05-30</d><h>15:56</h><w>mikerod</w>For this one:
&gt; I also repeatedly fall into the trap of  <code>[:not A] =&gt; A</code> in my rules, because I only want to make an A if some other particular thing isn’t true
I don’t know of a fix-all. It’s a case by case thing. Not sure what sort of scenario keeps getting you into it.</z><z id="t1527695788000511" t="jdt For one of m y [:not A] =&gt; A scenarios I tried [acc/count ... and checked for count &lt; than the limit I wanted, but the problem is it won&apos;t fire if the count is zero, even if the accumulator initializes with zero"><y>#</y><d>2018-05-30</d><h>15:56</h><w>jdt</w>For one of m y <code>[:not A] =&gt; A</code> scenarios I tried <code>[acc/count ...</code> and checked for count &lt; than the limit I wanted, but the problem is it won&apos;t fire if the count is zero, even if the accumulator initializes with zero</z><z id="t1527695888000119" t="jdt My scenarios are things like &quot;this job is something we want to proceed with if some other job isn&apos;t eligible&quot;, a gross generalism, could be any fact, not just jobs. It often boils down to counting situations. E.g. only dispatch at most two at a time on a worker in one fire-rules loop."><y>#</y><d>2018-05-30</d><h>15:58</h><w>jdt</w>My scenarios are things like &quot;this job is something we want to proceed with if some other job isn&apos;t eligible&quot;, a gross generalism, could be any fact, not just jobs.  It often boils down to counting situations.   E.g. only dispatch at most two at a time on a worker in one fire-rules loop.</z><z id="t1527695930000747" t="jdt My approach now is to generate very minimal sets of candidates in a fire-rules session, then query the results, dispatch jobs, update relevant counters-as-facts, then run fire-rules again in a loop."><y>#</y><d>2018-05-30</d><h>15:58</h><w>jdt</w>My approach now is to generate very minimal sets of candidates in a fire-rules session, then query the results, dispatch jobs, update relevant counters-as-facts, then run fire-rules again in a loop.</z><z id="t1527695985000941" t="jdt The counters I need to maintain are mainly worker resource availability and active user job counts partitioned by type of job."><y>#</y><d>2018-05-30</d><h>15:59</h><w>jdt</w>The counters I need to maintain are mainly worker resource availability and active user job counts partitioned by type of job.</z><z id="t1527695999000779" t="jdt Okay, well, hopefully I&apos;m nearing some kind of first load test, we&apos;ll see what happens."><y>#</y><d>2018-05-30</d><h>15:59</h><w>jdt</w>Okay, well, hopefully I&apos;m nearing some kind of first load test, we&apos;ll see what happens.</z><z id="t1527696013000590" t="jdt Advice always appreciated."><y>#</y><d>2018-05-30</d><h>16:00</h><w>jdt</w>Advice always appreciated.</z><z id="t1527700306000565" t="wparker @jdt The Clara count accumulator should fire with an initial value of 0. Do you have an example where it does not? Also keep in mind that you can create your own accumulators with arbitrary domain-specific logic. So say &quot;choose the top two at most&quot; could be done. My instinct here is that it sounds like the problems you describe might be addressable with accumulators without any insert-unconditional logic, although as always hard to say without knowing the problem space. It sounds like @mikerod was suggesting that as well."><y>#</y><d>2018-05-30</d><h>17:11</h><w>wparker</w>@jdt The Clara count accumulator should fire with an initial value of 0.  Do you have an example where it does not?  Also keep in mind that you can create your own accumulators with arbitrary domain-specific logic.  So say &quot;choose the top two at most&quot; could be done.  My instinct here is that it sounds like the problems you describe might be addressable with accumulators without any insert-unconditional logic, although as always hard to say without knowing the problem space.  It sounds like @mikerod was suggesting that as well.</z><z id="t1527700414000400" t="wparker See the writing accumulators section at http://www.clara-rules.org/docs/accumulators/"><y>#</y><d>2018-05-30</d><h>17:13</h><w>wparker</w>See the writing accumulators section at <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a></z><z id="t1527700498000397" t="wparker Also regarding the cost of joins, that varies depending on the type of join, I&apos;d suggest reading http://www.clara-rules.org/docs/hash_joins/ if you&apos;re working with millions of facts"><y>#</y><d>2018-05-30</d><h>17:14</h><w>wparker</w>Also regarding the cost of joins, that varies depending on the type of join, I&apos;d suggest reading <a href="http://www.clara-rules.org/docs/hash_joins/" target="_blank">http://www.clara-rules.org/docs/hash_joins/</a> if you&apos;re working with millions of facts</z><z id="t1527703162000193" t="jdt I thought the behavior I observed with the acc/count condition not firing seemed consistent with the documented behavior on this page: http://www.clara-rules.org/docs/accumulators/ , however I suspect I read it wrong and they were talking about other accumulators not firing when there weren&apos;t facts matching the condition, instead of acc/count . I don&apos;t have the example in code any more so will have to revisit it later if necessary. Meanwhile I&apos;ll checkout those other links you posted."><y>#</y><d>2018-05-30</d><h>17:59</h><w>jdt</w>I thought the behavior I observed with the <code>acc/count</code> condition not firing seemed consistent with the documented behavior on this page: <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a>, however I suspect I read it wrong and they were talking about other accumulators not firing when there weren&apos;t facts matching the condition, instead of <code>acc/count</code>.  I don&apos;t have the example in code any more so will have to revisit it later if necessary.  Meanwhile I&apos;ll checkout those other links you posted.</z><z id="t1527705523000294" t="mikerod @dave.tenny if an accumulator has a “truthy” :initial-value , it’s condition in a rule will be considered satisfied even if no facts exists to match the accumulators fact match criteria"><y>#</y><d>2018-05-30</d><h>18:38</h><w>mikerod</w>@dave.tenny if an accumulator has a “truthy” <code>:initial-value</code>, it’s condition in a rule will be considered satisfied even if no facts exists to match the accumulators fact match criteria</z><z id="t1527705572000367" t="mikerod default :initial-value is nil , so the default would not be true, however acc/count initializes to 0 , so a condition that uses it will be satisfied when no facts match the condition."><y>#</y><d>2018-05-30</d><h>18:39</h><w>mikerod</w>default <code>:initial-value</code> is <code>nil</code>, so the default would not be true, however <code>acc/count</code> initializes to <code>0</code>, so a condition that uses it will be satisfied when no facts match the condition.</z><z id="t1527705612000090" t="mikerod e.g. [?count &lt;- (acc/count) :from [NoMatchEver]] would bind ?count to 0 and the condition would be satisfied."><y>#</y><d>2018-05-30</d><h>18:40</h><w>mikerod</w>e.g. <code>[?count &lt;- (acc/count) :from [NoMatchEver]]</code> would bind <code>?count</code> to <code>0</code> and the condition would be satisfied.</z><z id="t1527705615000330" t="jdt I definitely had a [?x &lt;- (acc/count ...)] that was not being successful, or at least a [:test (do (prn ...) true) ] following that accum condition was not printed, but perhaps they&apos;re not evaluated sequentially. My rule definitely wasn&apos;t firing, but again I no longer have the code to reason about it."><y>#</y><d>2018-05-30</d><h>18:40</h><w>jdt</w>I definitely had a <code>[?x &lt;- (acc/count ...)]</code>  that was not being successful, or at least a [:test (do (prn ...) true) ] following that accum condition was not printed, but perhaps they&apos;re not evaluated sequentially.  My rule definitely wasn&apos;t firing, but again I no longer have the code to reason about it.</z><z id="t1527705660000145" t="mikerod weird, I’d have to see it"><y>#</y><d>2018-05-30</d><h>18:41</h><w>mikerod</w>weird, I’d have to see it</z><z id="t1527771971000222" t="wparker @dave.tenny perhaps your example created new bindings, in that case Clara’s accumulators won’t fire without facts even given an initial value. i.e. for [?result &lt;- (acc/all) :from [Fact (= ?a a)]] if ?a isn’t created elsewhere you need facts to give ?a a meaning so the accumulator won’t fire without them. This is in the accumulator docs pages I posted before IIRC, I think there are some examples in the clara-examples project too"><y>#</y><d>2018-05-31</d><h>13:06</h><w>wparker</w>@dave.tenny perhaps your example created new bindings, in that case Clara’s accumulators won’t fire without facts even given an initial value.  i.e. for [?result &lt;- (acc/all) :from [Fact (= ?a a)]] if ?a isn’t created elsewhere you need facts to give ?a a meaning so the accumulator won’t fire without them.  This is in the accumulator docs pages I posted before IIRC, I think there are some examples in the clara-examples project too</z><z id="t1527772175000067" t="mikerod @wparker I forgot that that was ever changed. I thought they still fire always even without a binding"><y>#</y><d>2018-05-31</d><h>13:09</h><w>mikerod</w>@wparker I forgot that that was ever changed. I thought they still fire always even without a binding</z><z id="t1527772182000554" t="mikerod I see what you are saying in the docs though"><y>#</y><d>2018-05-31</d><h>13:09</h><w>mikerod</w>I see what you are saying in the docs though</z><z id="t1527772583000425" t="wparker I can find it in the history later"><y>#</y><d>2018-05-31</d><h>13:16</h><w>wparker</w>I can find it in the history later</z><z id="t1527772681000528" t="wparker note that only applies if the binding in question is new though - if a previous condition creates it the accumulator will still fire with the initial value"><y>#</y><d>2018-05-31</d><h>13:18</h><w>wparker</w>note that only applies if the binding in question is new though - if a previous condition creates it the accumulator will still fire with the initial value</z><z id="t1527772722000170" t="wparker It is a bit confusing.. but otherwise IMO you end up with bindings that don’t make much logical sense"><y>#</y><d>2018-05-31</d><h>13:18</h><w>wparker</w>It is a bit confusing.. but otherwise IMO you end up with bindings that don’t make much logical sense</z><z id="t1527773122000551" t="mikerod Yep, thanks for clarifying"><y>#</y><d>2018-05-31</d><h>13:25</h><w>mikerod</w>Yep, thanks for clarifying</z><z id="t1527787448000516" t="wparker Looks like the work was done under https://github.com/cerner/clara-rules/issues/102 unfortunately the discussion there is less than simple to understand. PRs https://github.com/cerner/clara-rules/pull/204 https://github.com/cerner/clara-rules/pull/208 https://github.com/cerner/clara-rules/pull/210"><y>#</y><d>2018-05-31</d><h>17:24</h><w>wparker</w>Looks like the work was done under <a href="https://github.com/cerner/clara-rules/issues/102" target="_blank">https://github.com/cerner/clara-rules/issues/102</a> unfortunately the discussion there is less than simple to understand.  PRs <a href="https://github.com/cerner/clara-rules/pull/204" target="_blank">https://github.com/cerner/clara-rules/pull/204</a> <a href="https://github.com/cerner/clara-rules/pull/208" target="_blank">https://github.com/cerner/clara-rules/pull/208</a> <a href="https://github.com/cerner/clara-rules/pull/210" target="_blank">https://github.com/cerner/clara-rules/pull/210</a></z><z id="t1527869375000722" t="jdt So thanks to all for the help so far, but unless I can solve this &quot;if some fact insert this other fact ONCE&quot; problem I&apos;m about ready to throw in the towel. It&apos;s really like I want each rule firing to be sensitive to the prior rule firings in a single call to (fire-rules), but that isn&apos;t what happens."><y>#</y><d>2018-06-01</d><h>16:09</h><w>jdt</w>So thanks to all for the help so far, but unless I can solve this &quot;if some fact insert this other fact ONCE&quot; problem I&apos;m about ready to throw in the towel.  It&apos;s really like I want each rule firing to be sensitive to the prior rule firings in a single call to (fire-rules), but that isn&apos;t what happens.</z><z id="t1527869570000365" t="zylox you absoultely are fighting the engine if you do an insert-unconditional based on an inference, but still want logical retractions. Why are you using unconditional again? i havent followed all the conversations."><y>#</y><d>2018-06-01</d><h>16:12</h><w>zylox</w>you absoultely are fighting the engine if you do an insert-unconditional based on an inference, but still want logical retractions. Why are you using unconditional again? i havent followed all the conversations.</z><z id="t1527869606000687" t="jdt that&apos;s just one way to do it, but it wouldn&apos;t work because that rule is going to fire twice and both firings will NOT see the Derived asserted by the first firing"><y>#</y><d>2018-06-01</d><h>16:13</h><w>jdt</w>that&apos;s just one way to do it, but it wouldn&apos;t work because that rule is going to fire twice and both firings will NOT see the Derived asserted by the first firing</z><z id="t1527869625000598" t="jdt So it&apos;s not even about truth maintenance so much as WHEN the LHS is evaluated"><y>#</y><d>2018-06-01</d><h>16:13</h><w>jdt</w>So it&apos;s not even about truth maintenance so much as WHEN the LHS is evaluated</z><z id="t1527869640000176" t="zylox oh..hmm"><y>#</y><d>2018-06-01</d><h>16:14</h><w>zylox</w>oh..hmm</z><z id="t1527869735000305" t="jdt I&apos;m open to any reasonable way to do it, but given LHS matching those two facts I inserted, the result needs to be ONE derived."><y>#</y><d>2018-06-01</d><h>16:15</h><w>jdt</w>I&apos;m open to any reasonable way to do it, but given LHS matching those two facts I inserted, the result needs to be ONE derived.</z><z id="t1527869743000064" t="zylox I guess i dont understand why you need it only inserted once and not that the final state is one in the session."><y>#</y><d>2018-06-01</d><h>16:15</h><w>zylox</w>I guess i dont understand why you need it only inserted once and not that the final state is one in the session.</z><z id="t1527869759000790" t="zylox because you are going to absolutely end up with two if you are using unconditional"><y>#</y><d>2018-06-01</d><h>16:15</h><w>zylox</w>because you are going to absolutely end up with two if you are using unconditional</z><z id="t1527869783000579" t="jdt Maybe all I need to do is replace the [Fact (= ?ftype ftype)] with use of an accumulator and predicate to express the &quot;if there is some&quot;, and fire the rule once, haven&apos;t tried that"><y>#</y><d>2018-06-01</d><h>16:16</h><w>jdt</w>Maybe all I need to do is replace the [Fact (= ?ftype ftype)] with use of an accumulator and predicate to express the &quot;if there is some&quot;, and fire the rule once, haven&apos;t tried that</z><z id="t1527869809000175" t="jdt Can you give a sample of the merge logic?"><y>#</y><d>2018-06-01</d><h>16:16</h><w>jdt</w>Can you give a sample of the merge logic?</z><z id="t1527869822000744" t="jdt Oops, I see you did, I think"><y>#</y><d>2018-06-01</d><h>16:17</h><w>jdt</w>Oops, I see you did, I think</z><z id="t1527869825000573" t="mikerod the rules don’t assume what a “duplicate” means to you or what you want to do with them. You need an extra rule to configure that yourself."><y>#</y><d>2018-06-01</d><h>16:17</h><w>mikerod</w>the rules don’t assume what a “duplicate” means to you or what you want to do with them. You need an extra rule to configure that yourself.</z><z id="t1527869843000209" t="mikerod Example, Maybe you wanted to know how many duplicates you had"><y>#</y><d>2018-06-01</d><h>16:17</h><w>mikerod</w>Example, Maybe you wanted to know how many duplicates you had</z><z id="t1527869860000526" t="mikerod you could then have (defrecord Derived [ftype matches-count])"><y>#</y><d>2018-06-01</d><h>16:17</h><w>mikerod</w>you could then have <code>(defrecord Derived [ftype matches-count])</code></z><z id="t1527869884000491" t="mikerod Then (defrule merge-derived [?all &lt;- (acc/all) :from [::derived-intermediate (= ?ftype (-&gt; this :derived :ftype))]] =&gt; ;; Merging to one, but include the count of the &quot;duplicates&quot; for whatever reason (insert! (-&gt; ?all first :derived (assoc :matches-count (count ?all)))) "><y>#</y><d>2018-06-01</d><h>16:18</h><w>mikerod</w>Then 
<pre>(defrule merge-derived
  [?all &lt;- (acc/all) :from [::derived-intermediate (= ?ftype (-&gt; this :derived :ftype))]]
  =&gt;
;; Merging to one, but include the count of the &quot;duplicates&quot; for whatever reason
  (insert! (-&gt; ?all first :derived (assoc :matches-count (count ?all))))

</pre></z><z id="t1527869930000617" t="jdt ok, digesting this, back to drawing board"><y>#</y><d>2018-06-01</d><h>16:18</h><w>jdt</w>ok, digesting this, back to drawing board</z><z id="t1527872558000165" t="mikerod @dave.tenny Yep, I don’t see a reason for it there"><y>#</y><d>2018-06-01</d><h>17:02</h><w>mikerod</w>@dave.tenny Yep, I don’t see a reason for it there</z><z id="t1527872566000726" t="mikerod I didn’t use it in the merge-derived rule either"><y>#</y><d>2018-06-01</d><h>17:02</h><w>mikerod</w>I didn’t use it in the <code>merge-derived</code> rule either</z><z id="t1527876865000130" t="jdt That use of with-meta and :type is interesting to know about when doing type based dispatches."><y>#</y><d>2018-06-01</d><h>18:14</h><w>jdt</w>That use of <code>with-meta</code> and <code>:type</code> is interesting to know about when doing <code>type</code> based dispatches.</z><z id="t1527876876000020" t="jdt Interesting tip"><y>#</y><d>2018-06-01</d><h>18:14</h><w>jdt</w>Interesting tip</z><z id="t1527877746000557" t="jdt Anbody got an emacs cider clojure mode switch to adjust LHS condition indentation? My clauses don&apos;t seem to want to indent to the level of the prior clause."><y>#</y><d>2018-06-01</d><h>18:29</h><w>jdt</w>Anbody got an emacs cider clojure mode switch to adjust LHS condition indentation?  My clauses don&apos;t seem to want to indent to the level of the prior clause.</z><z id="t1527877765000615" t="jdt Rather, bindings/predicates, not the clauses."><y>#</y><d>2018-06-01</d><h>18:29</h><w>jdt</w>Rather, bindings/predicates, not the clauses.</z><z id="t1527881591000524" t="mikerod I don’t have special indentation rules"><y>#</y><d>2018-06-01</d><h>19:33</h><w>mikerod</w>I don’t have special indentation rules</z><z id="t1527881600000335" t="mikerod it indents less than ideal for vectors I’d say"><y>#</y><d>2018-06-01</d><h>19:33</h><w>mikerod</w>it indents less than ideal for vectors I’d say</z><z id="t1527881605000424" t="mikerod I’ve mostly just let it happen"><y>#</y><d>2018-06-01</d><h>19:33</h><w>mikerod</w>I’ve mostly just let it happen</z><z id="t1527889823000331" t="mikerod @dave.tenny I agree it isn’t ideal"><y>#</y><d>2018-06-01</d><h>21:50</h><w>mikerod</w>@dave.tenny I agree it isn’t ideal</z><z id="t1527889851000140" t="mikerod for multiline, I typically go with: [WorkerViableJob (= ?user-id user-id) (= ?job-type job-type)] "><y>#</y><d>2018-06-01</d><h>21:50</h><w>mikerod</w>for multiline, I typically go with:
<pre>[WorkerViableJob 
    (= ?user-id user-id)
    (= ?job-type job-type)]
</pre></z><z id="t1527890756000111" t="alex-dixon Clojure in general I find it helps to just give up on making lines short"><y>#</y><d>2018-06-01</d><h>22:05</h><w>alex-dixon</w>Clojure in general I find it helps to just give up on making lines short</z><z id="t1527890887000196" t="alex-dixon Most rules I’ve written have positional syntax so everything on one line works well…joins typically line up nicely. In Clara I’d probably do the same for the same reason…try to group things vertically by joins"><y>#</y><d>2018-06-01</d><h>22:08</h><w>alex-dixon</w>Most rules I’ve written have positional syntax so everything on one line works well…joins typically line up nicely. In Clara I’d probably do the same for the same reason…try to group things vertically by joins</z><z id="t1527948335000008" t="alex-dixon @mikerod Regarding datalog syntax for Clara: Would you want it to be schema based? The implementation I have only enforces a datomic schema’s cardinality and uniqueness … nothing related to types. It enables upsert behavior, which may or may not be desirable for Clara users. Cardinality and uniqueness indices are checked and updated before inserting or retracting facts (within the insert/retract functions), and if anything should be upserted then the appropriate retracts and inserts are made. Only one to one facts are indexed at this time, since there’s no uniqueness or cardinality enforcement that applies to one to many. Overall I tried to follow Datomic’s semantics on this: https://docs.datomic.com/on-prem/schema.html#operational-schema-attributes , https://docs.datomic.com/on-prem/schema.html#required-schema-attributes . If a fact is not mentioned in a schema it defaults to one to one cardinality. I think that could be changed easily if you wanted…the idea there was facts are typically one to one for UI and we didn’t want to force users type out cardinality for every fact."><y>#</y><d>2018-06-02</d><h>14:05</h><w>alex-dixon</w>@mikerod Regarding datalog syntax for Clara: Would you want it to be schema based? The implementation I have only enforces a datomic schema’s cardinality and uniqueness … nothing related to types. It enables upsert behavior, which may or may not be desirable for Clara users. Cardinality and uniqueness indices are checked and updated before inserting or retracting facts (within the insert/retract functions), and if anything should be upserted then the appropriate retracts and inserts are made. Only one to one facts are indexed at this time, since there’s no uniqueness or cardinality enforcement that applies to one to many. Overall I tried to follow Datomic’s semantics on this: <a href="https://docs.datomic.com/on-prem/schema.html#operational-schema-attributes" target="_blank">https://docs.datomic.com/on-prem/schema.html#operational-schema-attributes</a>, <a href="https://docs.datomic.com/on-prem/schema.html#required-schema-attributes" target="_blank">https://docs.datomic.com/on-prem/schema.html#required-schema-attributes</a>. If a fact is not mentioned in a schema it defaults to one to one cardinality. I think that could be changed easily if you wanted…the idea there was facts are typically one to one for UI and we didn’t want to force users type out cardinality for every fact.</z><z id="t1527948817000039" t="alex-dixon This would affect the implementation at the session-ish level. None of this has to be part of a LocalSession and I don’t think it should be, but I’m toying with a LocalDatalogSession that takes a LocalSession and “indexes” argument so the indexes can travel with a session. It should be possible to use with insert/retract per the normal api (`(-&gt; session (insert facts) (fire-rules))`) though the insert/retract functions would need be datalog specific (`(clara.rules.datalog/insert)`) if enforcing a schema the way I described"><y>#</y><d>2018-06-02</d><h>14:13</h><w>alex-dixon</w>This would affect the implementation at the session-ish level. None of this has to be part of a LocalSession and I don’t think it should be, but I’m toying with a LocalDatalogSession that takes a LocalSession and “indexes” argument so the indexes can travel with a session. It should be possible to use with insert/retract per the normal api (`(-&gt; session (insert facts) (fire-rules))`) though the insert/retract functions would need be datalog specific (`(clara.rules.datalog/insert)`) if enforcing a schema the way I described</z><z id="t1528117815000673" t="mikerod @alex-dixon that’s interesting. When I’ve mentioned support for the datalog syntax before, I was only thinking of it at a syntactic level - like an alternative DSL. The one thing I wasn’t sure of in that was how the fact-type-fn would work (what would it be?). It sounds like you’re considering an approach that is a bit more integrated with the semantics of these structures. That may be a reasonable thing to do. I haven’t worked with this sort of thing enough to have any big insight. What you describe above seems like something that may be useful and reasonable to me."><y>#</y><d>2018-06-04</d><h>13:10</h><w>mikerod</w>@alex-dixon that’s interesting. When I’ve mentioned support for the datalog syntax before, I was only thinking of it at a syntactic level - like an alternative DSL. The one thing I wasn’t sure of in that was how the fact-type-fn would work (what would it be?).
It sounds like you’re considering an approach that is a bit more integrated with the semantics of these structures. That may be a reasonable thing to do. I haven’t worked with this sort of thing enough to have any big insight. What you describe above seems like something that may be useful and reasonable to me.</z><z id="t1528123511000333" t="alex-dixon @mikerod &gt; The one thing I wasn’t sure of in that was how the fact-type-fn would work (what would it be?) Precept uses :a with a Tuple record [e a v t] (t is an incremented fact id). We use the clojure’s (derive) to associate cardinality and uniqueness with :a keywords. Clara receives the hierarchy via the :ancestors-fn option in order to be able to match on :all attributes. Every :a descends from :all so you can write conditions that will obtain across attributes (e.g. [?e :all 42]). The ancestry is also used outside Clara for maintaining e-a-v and a-v-e indexes. When facts are inserted or retracted it lets us determine their cardinality and uniqueness constraints. Based on that and the current indexes we determine whether inserts and retracts should be performed so that the schema can be adhered to, or whether an error should be thrown. Over the weekend I worked on a design that doesn’t use global vars for the indexes and ancestors hierarchy. I haven’t figured it out yet. insert! seems like the real challenge. It’s not part of the ISession protocol and only takes facts as arguments. My best guess is that we should bind a session’s indexes and ancestry to a dynamic var (like session-context) when fire rules is called on it. Then we could read from it from within an insert! implementation and update the indexes there. I think that’d require something like a LocalDatalogSession that could take these extra arguments in its constructor."><y>#</y><d>2018-06-04</d><h>14:45</h><w>alex-dixon</w>@mikerod 
&gt; The one thing I wasn’t sure of in that was how the fact-type-fn would work (what would it be?)
Precept uses <code>:a</code> with a Tuple record [e a v t] (t is an incremented fact id). We use the clojure’s (derive) to associate cardinality and uniqueness with <code>:a</code> keywords. Clara receives the hierarchy via the :ancestors-fn option in order to be able to match on <code>:all</code> attributes. Every <code>:a</code> descends from <code>:all</code> so you can write conditions that will obtain across attributes (e.g. [?e :all 42]). 

The ancestry is also used outside Clara for maintaining e-a-v and a-v-e indexes. When facts are inserted or retracted it lets us determine their cardinality and uniqueness constraints. Based on that and the current indexes we determine whether inserts and retracts should be performed so that the schema can be adhered to, or whether an error should be thrown. 

Over the weekend I worked on a design that doesn’t use global vars for the indexes and ancestors hierarchy. I haven’t figured it out yet. insert! seems like the real challenge. It’s not part of the ISession protocol and only takes facts as arguments.

My best guess is that we should bind a session’s indexes and ancestry to a dynamic var (like session-context) when fire rules is called on it. Then we could read from it from within an <code>insert!</code> implementation and update the indexes there. I think that’d require something like a LocalDatalogSession that could take these extra arguments in its constructor.</z><z id="t1528125073000029" t="mikerod @alex-dixon this makes sense to me."><y>#</y><d>2018-06-04</d><h>15:11</h><w>mikerod</w>@alex-dixon this makes sense to me.</z><z id="t1528125091000598" t="mikerod I was thinking that the :a may be the best fact type too, wasn’t sure. And good point on deriving from :all"><y>#</y><d>2018-06-04</d><h>15:11</h><w>mikerod</w>I was thinking that the <code>:a</code> may be the best fact type too, wasn’t sure. And good point on deriving from <code>:all</code></z><z id="t1528203423000462" t="jdt Any tips on analyzing where I&apos;m spending time in rules? (for example, which rules)."><y>#</y><d>2018-06-05</d><h>12:57</h><w>jdt</w>Any tips on analyzing where I&apos;m spending time in rules? (for example, which rules).</z><z id="t1528204208000063" t="mikerod @dave.tenny should be possible to use Clara tracing to take a look at something like that. Although it’s exploratory to find what you want given the data structures it returns. You could get something like count of times things were evaluated that way. "><y>#</y><d>2018-06-05</d><h>13:10</h><w>mikerod</w>@dave.tenny should be possible to use Clara tracing to take a look at something like that. Although it’s exploratory to find what you want given the data structures it returns. You could get something like count of times things were evaluated that way. </z><z id="t1528204247000618" t="mikerod It’d be nice if Clara had more supporting functions for this purpose though. "><y>#</y><d>2018-06-05</d><h>13:10</h><w>mikerod</w>It’d be nice if Clara had more supporting functions for this purpose though. </z><z id="t1528204437000417" t="jdt There are some minimum number of queries in addition to the above rules."><y>#</y><d>2018-06-05</d><h>13:13</h><w>jdt</w>There are some minimum number of queries in addition to the above rules.</z><z id="t1528204596000344" t="jdt Between each fire-rules the dispatcher will select one job per job type (so 15 in this numbers case), dispatch it, update the ActiveUserJobCount, WorkerResource, facts, and retract the dispatched JobRequest facts."><y>#</y><d>2018-06-05</d><h>13:16</h><w>jdt</w>Between each <code>fire-rules</code> the dispatcher will select one job per job type (so 15 in this numbers case), dispatch it, update the ActiveUserJobCount, WorkerResource, facts, and retract the dispatched JobRequest facts.</z><z id="t1528204630000607" t="jdt So I&apos;m averaging about 1-3 seconds per job dispatch, and whacking the hell out of my CPU. (Memory footprint is good however... surprise!)"><y>#</y><d>2018-06-05</d><h>13:17</h><w>jdt</w>So I&apos;m averaging about 1-3 seconds per job dispatch, and whacking the hell out of my CPU.  (Memory footprint is good however... surprise!)</z><z id="t1528205015000768" t="jdt I had originally hoped to do the fact maintenance for active user job counts (used for round robin eligibility consideration), and worker resource stats (to track remaining worker capacity), in the RHS of rules. But I gave that up early in the process because it was a side-effect oriented process with a bunch of [:not A] =&gt; A scenarios, which might have been doable, but it was really the timing of the rule LHS evaluations that killed it, since LHS evaluations are perceptually &quot;in parallel&quot; and not sequential with respect to cause and effect for a given rule."><y>#</y><d>2018-06-05</d><h>13:23</h><w>jdt</w>I had originally hoped to do the fact maintenance for active user job counts (used for round robin eligibility consideration), and worker resource stats (to track remaining worker capacity), in the RHS of rules.  But I gave that up early in the process because it was a side-effect oriented process with a bunch of <code>[:not A] =&gt; A</code> scenarios, which might have been doable, but it was really the timing of the rule LHS evaluations that killed it, since LHS evaluations are perceptually &quot;in parallel&quot; and not sequential with respect to cause and effect for a given rule.</z><z id="t1528205080000557" t="jdt So I compute some eligible things, then do the dispatching and accounting between calls to fire-rules , then do it all over again (always saving and continuing from the updated session)."><y>#</y><d>2018-06-05</d><h>13:24</h><w>jdt</w>So I compute some eligible things, then do the dispatching and accounting between calls to <code>fire-rules</code>, then do it all over again (always saving and continuing from the updated session).</z><z id="t1528206241000390" t="mikerod &gt; but it was really the timing of the rule LHS evaluations that killed it, since LHS evaluations are perceptually “in parallel” and not sequential with respect to cause and effect for a given rule. Only the case for insert-unconditional! (and possibly even a defect), but yeah. if you have to extract these facts after they are “done” it may make most sense to be an external thing anyways."><y>#</y><d>2018-06-05</d><h>13:44</h><w>mikerod</w>&gt;  but it was really the timing of the rule LHS evaluations that killed it, since LHS evaluations are perceptually “in parallel” and not sequential with respect to cause and effect for a given rule.
Only the case for <code>insert-unconditional!</code> (and possibly even a defect), but yeah. if you have to extract these facts after they are “done” it may make most sense to be an external thing anyways.</z><z id="t1528206266000802" t="mikerod @dave.tenny I can look at your rules from above some, sounds too slow"><y>#</y><d>2018-06-05</d><h>13:44</h><w>mikerod</w>@dave.tenny I can look at your rules from above some, sounds too slow</z><z id="t1528206315000190" t="jdt Happy to share the whole module, nothing but some pretty rules and ugly code to do the bookkeeping and setup mock data and such"><y>#</y><d>2018-06-05</d><h>13:45</h><w>jdt</w>Happy to share the whole module, nothing but some pretty rules and ugly code to do the bookkeeping and setup mock data and such</z><z id="t1528206365000802" t="mikerod when something takes long in that range of seconds (like 10+) I tend to do a cpu sampling"><y>#</y><d>2018-06-05</d><h>13:46</h><w>mikerod</w>when something takes long in that range of seconds (like 10+) I tend to do a cpu sampling</z><z id="t1528206369000395" t="jdt Job dispatch and completion is all about accounting then trying again with updated rules."><y>#</y><d>2018-06-05</d><h>13:46</h><w>jdt</w>Job dispatch and completion is all about accounting then trying again with updated rules.</z><z id="t1528206380000497" t="mikerod With a profiler, I tend to use visualVM because it is good enough for this situation"><y>#</y><d>2018-06-05</d><h>13:46</h><w>mikerod</w>With a profiler, I tend to use visualVM because it is good enough for this situation</z><z id="t1528206407000436" t="mikerod sometimes it gives quicker leads to what is causing issues. Sometimes it is too opaque unless you know the rule engine internals, but not necessarily always"><y>#</y><d>2018-06-05</d><h>13:46</h><w>mikerod</w>sometimes it gives quicker leads to what is causing issues. Sometimes it is too opaque unless you know the rule engine internals, but not necessarily always</z><z id="t1528206417000131" t="jdt Yeah, I&apos;m having problems with VisualVM on my Linux system becuase of some JNI/Jar problem I can&apos;t figure out, and HPROF sampling is usually useless"><y>#</y><d>2018-06-05</d><h>13:46</h><w>jdt</w>Yeah, I&apos;m having problems with VisualVM on my Linux system becuase of some JNI/Jar problem I can&apos;t figure out, and HPROF sampling is usually useless</z><z id="t1528206431000071" t="mikerod but also, doing some just blunt counting of times that certain conditions in rules and/or rule RHS were fired sometimes can give you the outliers as well"><y>#</y><d>2018-06-05</d><h>13:47</h><w>mikerod</w>but also, doing some just blunt counting of times that certain conditions in rules and/or rule RHS were fired sometimes can give you the outliers as well</z><z id="t1528206444000872" t="mikerod Hmm"><y>#</y><d>2018-06-05</d><h>13:47</h><w>mikerod</w>Hmm</z><z id="t1528206458000245" t="mikerod Yeah, VisualVM with “cpu sampler” is what I have used. if things are whacky there, not sure hah"><y>#</y><d>2018-06-05</d><h>13:47</h><w>mikerod</w>Yeah, VisualVM with “cpu sampler” is what I have used. if things are whacky there, not sure hah</z><z id="t1528206460000066" t="jdt Yeah, I&apos;m looking at instrumenting, is it possible to capture the time spent, via instrumentation, in each LHS condition?"><y>#</y><d>2018-06-05</d><h>13:47</h><w>jdt</w>Yeah, I&apos;m looking at instrumenting, is it possible to capture the time spent, via instrumentation, in each LHS condition?</z><z id="t1528206478000663" t="mikerod well, time will obviously go to the instrumentation/tracing you do"><y>#</y><d>2018-06-05</d><h>13:47</h><w>mikerod</w>well, time will obviously go to the instrumentation/tracing you do</z><z id="t1528206485000082" t="mikerod but if you do something like just gather counts"><y>#</y><d>2018-06-05</d><h>13:48</h><w>mikerod</w>but if you do something like just gather counts</z><z id="t1528206491000591" t="mikerod that is not time-sensitive anyways"><y>#</y><d>2018-06-05</d><h>13:48</h><w>mikerod</w>that is not time-sensitive anyways</z><z id="t1528206515000387" t="jdt Re the rules, any obvious stupid hash-join failures or things that might be better done in predicates or with accumulators?"><y>#</y><d>2018-06-05</d><h>13:48</h><w>jdt</w>Re the rules, any obvious stupid hash-join failures or things that might be better done in predicates or with accumulators?</z><z id="t1528206516000248" t="mikerod when I’ve tried “counting condition/rhs” firings before in bad performance cases, there are often outliers"><y>#</y><d>2018-06-05</d><h>13:48</h><w>mikerod</w>when I’ve tried “counting condition/rhs” firings before in bad performance cases, there are often outliers</z><z id="t1528206528000825" t="mikerod Like most things evaluation perhaps no more than 1k times for example"><y>#</y><d>2018-06-05</d><h>13:48</h><w>mikerod</w>Like most things evaluation perhaps no more than 1k times for example</z><z id="t1528206536000575" t="mikerod but then you find something that evaluates like 1 mil times"><y>#</y><d>2018-06-05</d><h>13:48</h><w>mikerod</w>but then you find something that evaluates like 1 mil times</z><z id="t1528206546000265" t="mikerod typically its something like that"><y>#</y><d>2018-06-05</d><h>13:49</h><w>mikerod</w>typically its something like that</z><z id="t1528206556000898" t="jdt In my case I&apos;m worried it&apos;s the tests in the conditions that are firing a lot, but I&apos;ll get more data."><y>#</y><d>2018-06-05</d><h>13:49</h><w>jdt</w>In my case I&apos;m worried it&apos;s the tests in the conditions that are firing a lot, but I&apos;ll get more data.</z><z id="t1528206595000400" t="mikerod So even your rule like worker-viable-jobs may be pretty heavy"><y>#</y><d>2018-06-05</d><h>13:49</h><w>mikerod</w>So even your rule like <code>worker-viable-jobs</code> may be pretty heavy</z><z id="t1528206606000242" t="mikerod I’m just looking over what you had and your sort of fact counts"><y>#</y><d>2018-06-05</d><h>13:50</h><w>mikerod</w>I’m just looking over what you had and your sort of fact counts</z><z id="t1528206617000934" t="jdt For example, if I&apos;m doing N^2 firings on the worker-viable-jobs conditions for the 100k job requests and 45 worker-resource facts."><y>#</y><d>2018-06-05</d><h>13:50</h><w>jdt</w>For example, if I&apos;m doing N^2 firings on the worker-viable-jobs conditions for the 100k job requests and 45 worker-resource facts.</z><z id="t1528206626000083" t="mikerod you have 100K job requests facts and 45 workers, and you also have a :not in that rule"><y>#</y><d>2018-06-05</d><h>13:50</h><w>mikerod</w>you have 100K job requests facts and 45 workers, and you also have a <code>:not</code> in that rule</z><z id="t1528206635000202" t="mikerod so you are something like 100K x 100K x 45 territory"><y>#</y><d>2018-06-05</d><h>13:50</h><w>mikerod</w>so you are something like 100K x 100K x 45 territory</z><z id="t1528206684000080" t="jdt Right, is there a way to achieve the semantics there without the combinatorics?"><y>#</y><d>2018-06-05</d><h>13:51</h><w>jdt</w>Right, is there a way to achieve the semantics there without the combinatorics?</z><z id="t1528206694000842" t="mikerod probably just doing millions of comparisons with clj = and &lt; etc and it adds up"><y>#</y><d>2018-06-05</d><h>13:51</h><w>mikerod</w>probably just doing millions of comparisons with clj <code>=</code> and <code>&lt;</code> etc and it adds up</z><z id="t1528206703000324" t="mikerod yes, I think there is a way out of it"><y>#</y><d>2018-06-05</d><h>13:51</h><w>mikerod</w>yes, I think there is a way out of it</z><z id="t1528206738000375" t="jdt This is where, if I could update the worker resources in the RHS and immediately prune the possibilities for the next firing of worker-viable-job it would have been a win, but that doesn&apos;t work because all the worker-viable-jobs are going to fire regardless of whether I update the worker resources because of that seemingly parallel LHS evaluation protocol."><y>#</y><d>2018-06-05</d><h>13:52</h><w>jdt</w>This is where, if I could update the worker resources in the RHS and immediately prune the possibilities for the next firing of worker-viable-job it would have been a win, but that doesn&apos;t work because all the worker-viable-jobs are going to fire regardless of whether I update the worker resources because of that seemingly parallel LHS evaluation protocol.</z><z id="t1528206765000452" t="mikerod Extract a rule, find the oldest jobs first, then only bring those into the join with WorkerResource rule here"><y>#</y><d>2018-06-05</d><h>13:52</h><w>mikerod</w>Extract a rule, find the oldest jobs first, then only bring those into the join with <code>WorkerResource</code> rule here</z><z id="t1528206801000179" t="mikerod in general, you have a lot of JobRequest facts to deal with. You want to avoid any rule that may do a join across that set of facts with itself"><y>#</y><d>2018-06-05</d><h>13:53</h><w>mikerod</w>in general, you have a lot of <code>JobRequest</code> facts to deal with. You want to avoid any rule that may do a join across that set of facts with itself</z><z id="t1528206821000423" t="mikerod I’m not sure how memory and thread factor into an “oldest job” situation"><y>#</y><d>2018-06-05</d><h>13:53</h><w>mikerod</w>I’m not sure how <code>memory</code> and <code>thread</code> factor into an “oldest job” situation</z><z id="t1528206827000122" t="mikerod so hard to give you an example"><y>#</y><d>2018-06-05</d><h>13:53</h><w>mikerod</w>so hard to give you an example</z><z id="t1528206827000920" t="jdt Except we&apos;ll still need to potentially consider the next oldest, and so on, until we find one that fits the avaialble worker resources, so does an extra rule really help?"><y>#</y><d>2018-06-05</d><h>13:53</h><w>jdt</w>Except we&apos;ll still need to potentially consider the next oldest, and so on, until we find one that fits the avaialble worker resources, so does an extra rule really help?</z><z id="t1528206843000259" t="mikerod [:not [JobRequest (&lt; job-id ?job-id) (= ?job-type job-type) (= ?user-id user-id) (&lt;= threads ?threads) (&lt;= memory ?memory)]] "><y>#</y><d>2018-06-05</d><h>13:54</h><w>mikerod</w><pre>[:not [JobRequest (&lt; job-id ?job-id) 
                    (= ?job-type job-type)
                    (= ?user-id user-id)
                    (&lt;= threads ?threads)
                    (&lt;= memory ?memory)]]
</pre></z><z id="t1528206861000277" t="jdt The memory and thread tests are to test only for jobs that can actually execute on the worker resources, i.e. for which enough resources exist."><y>#</y><d>2018-06-05</d><h>13:54</h><w>jdt</w>The memory and thread tests are to test only for jobs that can actually execute on the worker resources, i.e. for which enough resources exist.</z><z id="t1528206894000286" t="jdt That&apos;s the &quot;viable&quot; part of the semantics"><y>#</y><d>2018-06-05</d><h>13:54</h><w>jdt</w>That&apos;s the &quot;viable&quot; part of the semantics</z><z id="t1528206901000341" t="mikerod the rule can help, just have to figure out what the correct rule is"><y>#</y><d>2018-06-05</d><h>13:55</h><w>mikerod</w>the rule can help, just have to figure out what the correct rule is</z><z id="t1528206930000246" t="mikerod thinking about it"><y>#</y><d>2018-06-05</d><h>13:55</h><w>mikerod</w>thinking about it</z><z id="t1528206957000461" t="jdt Any advice for a beginner on how to effectively use the tracing API here? The one time I tried it there was too much data to process, and that was on the simplest most minimal amount of facts."><y>#</y><d>2018-06-05</d><h>13:55</h><w>jdt</w>Any advice for a beginner on how to effectively use the tracing API here?  The one time I tried it there was too much data to process, and that was on the simplest most minimal amount of facts.</z><z id="t1528207033000912" t="jdt re: the &quot;oldest job&quot; stuff, I was wondering if accumulators would in any way help, I have no idea how they&apos;re implemented w.r..t incremental fact maintenance."><y>#</y><d>2018-06-05</d><h>13:57</h><w>jdt</w>re: the &quot;oldest job&quot; stuff, I was wondering if accumulators would in any way help, I have no idea how they&apos;re implemented w.r..t incremental fact maintenance.</z><z id="t1528207888000318" t="mikerod &gt; Any advice for a beginner on how to effectively use the tracing API here? The one time I tried it there was too much data to process, and that was on the simplest most minimal amount of facts. I haven’t used it as much as I’d expect. I was used to rolling my own stuff prior to when tracing stuff was introduced. However, for counting, I believe you can do something like: (let [traced (-&gt; (clara.rules/mk-session &lt;your rules&gt;) (clara.tools.tracing/with-tracing) (insert &lt;your facts&gt;) fire-rules clara.tools.tracing/get-trace)] (frequencies (map :node-id traced))) "><y>#</y><d>2018-06-05</d><h>14:11</h><w>mikerod</w>&gt; Any advice for a beginner on how to effectively use the tracing API here?  The one time I tried it there was too much data to process, and that was on the simplest most minimal amount of facts.
I haven’t used it as much as I’d expect. I was used to rolling my own stuff prior to when tracing stuff was introduced. However, for counting, I believe you can do something like:
<pre>(let [traced (-&gt; (clara.rules/mk-session &lt;your rules&gt;)
                 (clara.tools.tracing/with-tracing)
                 (insert &lt;your facts&gt;)
                 fire-rules
                 clara.tools.tracing/get-trace)]
  (frequencies (map :node-id traced)))
</pre></z><z id="t1528207970000328" t="mikerod or perhaps better sorted: (let [tr (-&gt; (clara.rules/mk-session [temp-rule]) (t/with-tracing) (insert (-&gt;Temperature 10 &quot;MCI&quot;) (-&gt;Temperature 20 &quot;MCI&quot;)) (fire-rules) (t/get-trace ) )] (-&gt;&gt; (map :node-id tr) frequencies (sort-by val) reverse)) "><y>#</y><d>2018-06-05</d><h>14:12</h><w>mikerod</w>or perhaps better sorted:
<pre>(let [tr (-&gt; (clara.rules/mk-session [temp-rule])
                                       (t/with-tracing)
                                       (insert (-&gt;Temperature 10 &quot;MCI&quot;)
                                               (-&gt;Temperature 20 &quot;MCI&quot;))
                                       (fire-rules)
                                       (t/get-trace )
                                       )]
                            (-&gt;&gt;  (map :node-id tr)
                                  frequencies
                                  (sort-by val)
                                  reverse))
</pre></z><z id="t1528207990000169" t="mikerod once you know the highest count :node-id s you can look those up in the rulebase associated with the session"><y>#</y><d>2018-06-05</d><h>14:13</h><w>mikerod</w>once you know the highest count <code>:node-id</code>s you can look those up in the rulebase associated with the session</z><z id="t1528208015000507" t="jdt excellent, thanks"><y>#</y><d>2018-06-05</d><h>14:13</h><w>jdt</w>excellent, thanks</z><z id="t1528208192000604" t="mikerod (let [session (-&gt; (clara.rules/mk-session &lt;your rules&gt;) (t/with-tracing) (insert &lt;your facts&gt;) (fire-rules)) trace (t/get-trace session) node-id &lt;whatever node id in question from `trace`&gt; {:keys [rulebase]} (clara.rules.engine/components session) {:keys [id-to-node]} rulebase] (get id-to-node node-id) ) This is how you could look up the node-id to try to find what node in the engine it is"><y>#</y><d>2018-06-05</d><h>14:16</h><w>mikerod</w><pre>(let [session (-&gt; (clara.rules/mk-session &lt;your rules&gt;)
                  (t/with-tracing)
                  (insert &lt;your facts&gt;)
                  (fire-rules))

      trace (t/get-trace session)
      node-id &lt;whatever node id in question from `trace`&gt;


      {:keys [rulebase]} (clara.rules.engine/components session)
      {:keys [id-to-node]} rulebase]
  (get id-to-node node-id) )
</pre>
This is how you could look up the <code>node-id</code> to try to find what node in the engine it is</z><z id="t1528208212000977" t="mikerod a node will be a defrecord of stuff, not all that readable to you, but you should be able to recognize aspects of it and align it back to your rules typically"><y>#</y><d>2018-06-05</d><h>14:16</h><w>mikerod</w>a node will be a defrecord of stuff, not all that readable to you, but you should be able to recognize aspects of it and align it back to your rules typically</z><z id="t1528211353000724" t="jdt Thanks Mike, I&apos;ll have a look"><y>#</y><d>2018-06-05</d><h>15:09</h><w>jdt</w>Thanks Mike, I&apos;ll have a look</z><z id="t1528216685000178" t="jdt @mikerod as I am still new at accumulators, I&apos;m trying to discern the purpose of the ?user-id binding on line 30 in the above snippet. Is it used so that the rule will fire once for each distinct user id? Does it work given that ?user-id is not otherwise bound?"><y>#</y><d>2018-06-05</d><h>16:38</h><w>jdt</w>@mikerod as I am still new at accumulators, I&apos;m trying to discern the purpose of the ?user-id binding on line 30 in the above snippet.  Is it used so that the rule will fire once for each distinct user id?  Does it work given that ?user-id is not otherwise bound?</z><z id="t1528217038000679" t="mikerod @dave.tenny &gt; Is it used so that the rule will fire once for each distinct user id? yes, in that’s its purpose in that example"><y>#</y><d>2018-06-05</d><h>16:43</h><w>mikerod</w>@dave.tenny
&gt;  Is it used so that the rule will fire once for each distinct user id?
yes, in that’s its purpose in that example</z><z id="t1528217094000120" t="mikerod which makes me realize I had a typo there, it should have been (= ?user-id (-&gt; this :worker-viable-job :user-id)) since it was nested one level lower, will update. Sorry if that caused confusion."><y>#</y><d>2018-06-05</d><h>16:44</h><w>mikerod</w>which makes me realize I had a typo there, it should have been <code>(= ?user-id (-&gt; this :worker-viable-job :user-id))</code> since it was nested one level lower, will update. Sorry if that caused confusion.</z><z id="t1528217203000084" t="mikerod Accumulators behavior with field-level bindings like that is explained more in http://www.clara-rules.org/docs/accumulators/"><y>#</y><d>2018-06-05</d><h>16:46</h><w>mikerod</w>Accumulators behavior with field-level bindings like that is explained more in <a href="http://www.clara-rules.org/docs/accumulators/" target="_blank">http://www.clara-rules.org/docs/accumulators/</a></z><z id="t1528217585000209" t="jdt I&apos;m getting null pointer exceptions on calls to &lt; that I think are the accumulator, but are maybe something else, unfortunately the stack trace doesn&apos;t not clue me in other than it&apos;s in (fire-rules) , pretty much. However the acc/min isn&apos;t documented to accept a :initial-value argument, so it&apos;s probably something else. Just in case something obvious is missing above."><y>#</y><d>2018-06-05</d><h>16:53</h><w>jdt</w>I&apos;m getting null pointer exceptions on calls to <code>&lt;</code> that I think are the accumulator, but are maybe something else, unfortunately the stack trace doesn&apos;t not clue me in other than it&apos;s in <code>(fire-rules)</code>, pretty much.  However the <code>acc/min</code> isn&apos;t documented to accept a <code>:initial-value</code> argument, so it&apos;s probably something else.  Just in case something obvious is missing above.</z><z id="t1528217884000116" t="jdt Ah wait, maybe it&apos;s because I removed an explicit binding of :user-id in the candidate rule."><y>#</y><d>2018-06-05</d><h>16:58</h><w>jdt</w>Ah wait, maybe it&apos;s because I removed an explicit binding of :user-id in the candidate rule.</z><z id="t1528217984000614" t="mikerod @dave.tenny more typo’s because I forgot the thing was neste"><y>#</y><d>2018-06-05</d><h>16:59</h><w>mikerod</w>@dave.tenny more typo’s because I forgot the thing was neste</z><z id="t1528218000000378" t="mikerod (acc/min (comp :job-id :worker-viable-job) :returns-fact true) , I updated the snippet above to reflect that"><y>#</y><d>2018-06-05</d><h>17:00</h><w>mikerod</w><code>(acc/min (comp :job-id :worker-viable-job) :returns-fact true)</code>, I updated the snippet above to reflect that</z><z id="t1528218018000060" t="mikerod if :job-id may be nil though, would have to defend against it"><y>#</y><d>2018-06-05</d><h>17:00</h><w>mikerod</w>if <code>:job-id</code> may be <code>nil</code> though, would have to defend against it</z><z id="t1529029502000004" t="hiredman I&apos;ve just started exploring with Clara, and don&apos;t have a ton of experience with rules systems, and I&apos;ve run into a surprise. When I have a rule something like [Foo (= x 1)] (not [Foo (= x 2)]) =&gt; (insert! (-&gt;Foo 2)) it goes in to an infinite loop"><y>#</y><d>2018-06-15</d><h>02:25</h><w>hiredman</w>I&apos;ve just started exploring with Clara, and don&apos;t have a ton of experience with rules systems, and I&apos;ve run into a surprise. When I have a rule something like <code>[Foo (= x 1)] (not [Foo (= x 2)]) =&gt; (insert! (-&gt;Foo 2))</code> it goes in to an infinite loop</z><z id="t1529032883000075" t="mikerod @hiredman insert! Is a conditional insert. These inserts are monitored by a “truth maintenance system” (aka TMS). The goal of the TMS is to keep all of the rules and their consequences in a logically consistent state"><y>#</y><d>2018-06-15</d><h>03:21</h><w>mikerod</w>@hiredman insert! Is a conditional insert. These inserts are monitored by a “truth maintenance system” (aka TMS). 
The goal of the TMS is to keep all of the rules and their consequences in a logically consistent state</z><z id="t1529032897000180" t="mikerod So the rule you put above is a logical contradiction. "><y>#</y><d>2018-06-15</d><h>03:21</h><w>mikerod</w>So the rule you put above is a logical contradiction. </z><z id="t1529032918000074" t="mikerod There are workarounds. Depending on what it is you are trying to achieve. "><y>#</y><d>2018-06-15</d><h>03:21</h><w>mikerod</w>There are workarounds. Depending on what it is you are trying to achieve. </z><z id="t1529032998000123" t="mikerod Also the TMS is useful to be able to express large numbers of rules in a declarative/non order dependent way. You don’t have to worry about “when something was inserted” to be careful to not check for it “before it was inserted” and that sort of thing. It leads to a less brittle system. "><y>#</y><d>2018-06-15</d><h>03:23</h><w>mikerod</w>Also the TMS is useful to be able to express large numbers of rules in a declarative/non order dependent way. You don’t have to worry about “when something was inserted” to be careful to not check for it “before it was inserted” and that sort of thing. It leads to a less brittle system. </z><z id="t1529033030000143" t="mikerod The concept of a TMS has been around in many of the more modern rule systems. "><y>#</y><d>2018-06-15</d><h>03:23</h><w>mikerod</w>The concept of a TMS has been around in many of the more modern rule systems. </z><z id="t1529086510000096" t="hiredman @mikerod thanks, makes sense, I hadn&apos;t connected those dots"><y>#</y><d>2018-06-15</d><h>18:15</h><w>hiredman</w>@mikerod thanks, makes sense, I hadn&apos;t connected those dots</z><z id="t1529087074000789" t="mikerod @hiredman I will say that the engine going into an infinite loop without trying to help isn’t really user-friendly. The action a rule does on the right-hand side (aka RHS) of the =&gt; is arbitrary from the rules engine perspective, so it cannot “know it is in an infinite loop”. However, something could reasonably be added to allow a configurable upper limit on the times you’d allow what may “look like a loop” to be allowed until the engine halted and reported a possible error. For now though, it could be documented as a FAQ or something as well."><y>#</y><d>2018-06-15</d><h>18:24</h><w>mikerod</w>@hiredman I will say that the engine going into an infinite loop without trying to help isn’t really user-friendly.
The action a rule does on the right-hand side (aka RHS) of the <code>=&gt;</code> is arbitrary from the rules engine perspective, so it cannot “know it is in an infinite loop”. However, something could reasonably be added to allow a configurable upper limit on the times you’d allow what may “look like a loop” to be allowed until the engine halted and reported a possible error. For now though, it could be documented as a FAQ or something as well.</z><z id="t1529087094000580" t="mikerod eg “If the engine seems to be in an infinite loop, this is commonly the cause…”"><y>#</y><d>2018-06-15</d><h>18:24</h><w>mikerod</w>eg “If the engine seems to be in an infinite loop, this is commonly the cause…”</z><z id="t1529087393000449" t="mikerod There are cases that you may think it is hard to see how to not need a rule like you have above. Some of those can actually be tricky to express, but in many cases that I’ve seen, accumulators can be used to achieve the semantics desired, or a new fact type that is used for the derived fact that is different from what is deriving it eg instead of [:not [Foo (= x 2)]] =&gt; (insert! (-&gt;Foo 2)) Something like [:not [Foo (= x 2)]] =&gt; (insert! (-&gt;DerivedFoo 2)) "><y>#</y><d>2018-06-15</d><h>18:29</h><w>mikerod</w>There are cases that you may think it is hard to see how to not need a rule like you have above. Some of those can actually be tricky to express, but in many cases that I’ve seen, accumulators can be used to achieve the semantics desired, or a new fact type that is used for the derived fact that is different from what is deriving it
eg instead of
<pre>[:not [Foo (= x 2)]] =&gt; (insert! (-&gt;Foo 2))
</pre>
Something like
<pre>[:not [Foo (= x 2)]] =&gt; (insert! (-&gt;DerivedFoo 2))
</pre></z><z id="t1529164733000069" t="sparkofreason Just a quick brain-bubble on this topic: I wonder if there could be a sort of &quot;debug mode&quot; where during fire-rules a graph is built for the causal relationships, e.g. Fact A -&gt; Rule B -&gt; Fact C -&gt; Rule D... That graph could be analyzed for cycles. Haven&apos;t thought this through at all, and would guess it isn&apos;t perfect, but perhaps better than nothing?"><y>#</y><d>2018-06-16</d><h>15:58</h><w>sparkofreason</w>Just a quick brain-bubble on this topic: I wonder if there could be a sort of &quot;debug mode&quot; where during <code>fire-rules</code> a graph is built for the causal relationships, e.g. Fact A -&gt; Rule B -&gt; Fact C -&gt; Rule D... That graph could be analyzed for cycles. Haven&apos;t thought this through at all, and would guess it isn&apos;t perfect, but perhaps better than nothing?</z><z id="t1529166982000089" t="alex-dixon I think for Clojure :no-loop true can be provided in the properties map. I’ve heard it mentioned a couple times"><y>#</y><d>2018-06-16</d><h>16:36</h><w>alex-dixon</w>I think for Clojure :no-loop true can be provided in the properties map. I’ve heard it mentioned a couple times</z><z id="t1529167065000086" t="alex-dixon https://github.com/cerner/clara-rules/blob/8c4898498b5bff7a231f5c5ce74d56ab84453a53/src/test/clojure/clara/test_rules.clj#L1108"><y>#</y><d>2018-06-16</d><h>16:37</h><w>alex-dixon</w><a href="https://github.com/cerner/clara-rules/blob/8c4898498b5bff7a231f5c5ce74d56ab84453a53/src/test/clojure/clara/test_rules.clj#L1108" target="_blank">https://github.com/cerner/clara-rules/blob/8c4898498b5bff7a231f5c5ce74d56ab84453a53/src/test/clojure/clara/test_rules.clj#L1108</a></z><z id="t1529171221000039" t="mikerod @dave.dixon the thing is that it isn’t clear it is actually looping just because it goes through the same rule path a few times. RHS can do arbitrary logic. Including have different paths they may take via conditionals. "><y>#</y><d>2018-06-16</d><h>17:47</h><w>mikerod</w>@dave.dixon the thing is that it isn’t clear it is actually looping just because it goes through the same rule path a few times. RHS can do arbitrary logic. Including have different paths they may take via conditionals. </z><z id="t1529171264000008" t="mikerod Some sort of general warnings could be nice perhaps that suggest that “maybe” there is a loop though"><y>#</y><d>2018-06-16</d><h>17:47</h><w>mikerod</w>Some sort of general warnings could be nice perhaps that suggest that “maybe” there is a loop though</z><z id="t1529171409000146" t="mikerod @alex-dixon yep. It exists. Don’t generally recommend it unless the use case really makes sense to use it. "><y>#</y><d>2018-06-16</d><h>17:50</h><w>mikerod</w>@alex-dixon yep. It exists.  Don’t generally recommend it unless the use case really makes sense to use it. </z><z id="t1529171433000037" t="mikerod Typically it’s best to solve the problems just purely via the logical TMS if practical. "><y>#</y><d>2018-06-16</d><h>17:50</h><w>mikerod</w>Typically it’s best to solve the problems just purely via the logical TMS if practical. </z><z id="t1529171569000012" t="sparkofreason Yeah, it&apos;s another version of the halting problem. But it might be a nice way to get some visibility on the causal structure, and highlight loops that are unexpected."><y>#</y><d>2018-06-16</d><h>17:52</h><w>sparkofreason</w>Yeah, it&apos;s another version of the halting problem. But it might be a nice way to get some visibility on the causal structure, and highlight loops that are unexpected.</z><z id="t1529172190000032" t="mikerod Yes indeed"><y>#</y><d>2018-06-16</d><h>18:03</h><w>mikerod</w>Yes indeed</z><z id="t1529949496000553" t="tony.kay Hi, is it ok to use *current-session* ? it isn’t documented, but it would be handy to run queries during rule execution…or is that just a bad idea?"><y>#</y><d>2018-06-25</d><h>17:58</h><w>tony.kay</w>Hi, is it ok to use <code>*current-session*</code>?  it isn’t documented, but it would be handy to run queries during rule execution…or is that just a bad idea?</z><z id="t1529951413000686" t="mikerod @tony.kay sounds like a bad idea 😛"><y>#</y><d>2018-06-25</d><h>18:30</h><w>mikerod</w>@tony.kay sounds like a bad idea <b>😛</b></z><z id="t1529951426000775" t="mikerod Are you wanting to use it for debugging or for more than that?"><y>#</y><d>2018-06-25</d><h>18:30</h><w>mikerod</w>Are you wanting to use it for debugging or for more than that?</z><z id="t1529951474000736" t="tony.kay So, we have facts that are stored in a datomic-fashion…so “insert” needs to know if the fact (as an E/A pair) is already present so we can retract the old value before inserting the new one"><y>#</y><d>2018-06-25</d><h>18:31</h><w>tony.kay</w>So, we have facts that are stored in a datomic-fashion…so “insert” needs to know if the fact (as an E/A pair) is already present so we can retract the old value before inserting the new one</z><z id="t1529951490000141" t="mikerod The thing is (a) it isn’t documented/impl detail, so would be subject to breaking changes (b) but even more worrisome is that there isn’t any strong guarantees about rules firing order or if a rule will be fired/retracted/re-fired etc So arbitrarily looking into the *current-session* could cause problems"><y>#</y><d>2018-06-25</d><h>18:31</h><w>mikerod</w>The thing is (a) it isn’t documented/impl detail, so would be subject to breaking changes (b) but even more worrisome is that there isn’t any strong guarantees about rules firing order or if a rule will be fired/retracted/re-fired etc
So arbitrarily looking into the <code>*current-session*</code> could cause problems</z><z id="t1529951493000077" t="tony.kay so, we need to know what is in the current session"><y>#</y><d>2018-06-25</d><h>18:31</h><w>tony.kay</w>so, we need to know what is in the current session</z><z id="t1529951521000657" t="tony.kay yeah, I understand that, but rule firing order doesn’t matter in that case…I need to know if a fact is in there right as that rule fires"><y>#</y><d>2018-06-25</d><h>18:32</h><w>tony.kay</w>yeah, I understand that, but rule firing order doesn’t matter in that case…I need to know if a fact is in there right as that rule fires</z><z id="t1529951536000233" t="mikerod I think that http://www.metasimple.org/2017/12/23/clara-updating-facts.html relates to this concept of safely “updating” facts"><y>#</y><d>2018-06-25</d><h>18:32</h><w>mikerod</w>I think that <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a> relates to this concept of safely “updating” facts</z><z id="t1529951548000265" t="mikerod although it doesn’t provide an ideal solution"><y>#</y><d>2018-06-25</d><h>18:32</h><w>mikerod</w>although it doesn’t provide an ideal solution</z><z id="t1529951608000349" t="mikerod You can use things like insert-unconditional! and also :no-loop properties on a defrule to attempt to do things like you are describing. However, I try to avoid those since they become more imperative/order-dependent etc in nature. Also, they can have interactions at odds with the rest of the truth maintenance system."><y>#</y><d>2018-06-25</d><h>18:33</h><w>mikerod</w>You can use things like <code>insert-unconditional!</code> and also <code>:no-loop</code> properties on a <code>defrule</code> to attempt to do things like you are describing. However, I try to avoid those since they become more imperative/order-dependent etc in nature. Also, they can have interactions at odds with the rest of the truth maintenance system.</z><z id="t1529951632000616" t="mikerod In the post linked above, I mention “Approach 1: Append only updates”"><y>#</y><d>2018-06-25</d><h>18:33</h><w>mikerod</w>In the post linked above, I mention “Approach 1: Append only updates”</z><z id="t1529951650000220" t="mikerod that’s the easiest, but can run up against memory limits depending on how you are using things"><y>#</y><d>2018-06-25</d><h>18:34</h><w>mikerod</w>that’s the easiest, but can run up against memory limits depending on how you are using things</z><z id="t1529951719000314" t="mikerod I didn’t explain in that post, but I think the “Approach 1: Append only updates” could be extended to have an external process/fn that cleans up old UpdatingFactSnapshot later (using a query to access them externally)."><y>#</y><d>2018-06-25</d><h>18:35</h><w>mikerod</w>I didn’t explain in that post, but I think the “Approach 1: Append only updates” could be extended to have an external process/fn that cleans up old <code>UpdatingFactSnapshot</code> later (using a query to access them externally).</z><z id="t1529951828000021" t="tony.kay cool, thanks. I’ll read the article. I’m sure I’m missing somehting about the TMS that I’m not clear on 🙂 Hopefully that’ll get me squared up"><y>#</y><d>2018-06-25</d><h>18:37</h><w>tony.kay</w>cool, thanks. I’ll read the article. I’m sure I’m missing somehting about the TMS that I’m not clear on <b>🙂</b>  Hopefully that’ll get me squared up</z><z id="t1529953289000066" t="tony.kay @mikerod so, in the project I’m helping with, they are not using the logic tracking facility…so invalidating a truth does not auto-retract anything. Perhaps this is a problem that should be addressed as well, but does that affect your answer at all?"><y>#</y><d>2018-06-25</d><h>19:01</h><w>tony.kay</w>@mikerod so, in the project I’m helping with, they are not using the logic tracking facility…so invalidating a truth does not auto-retract anything.  Perhaps this is a problem that should be addressed as well, but does that affect your answer at all?</z><z id="t1529953318000381" t="tony.kay (e.g. they are using unconditional inserts)"><y>#</y><d>2018-06-25</d><h>19:01</h><w>tony.kay</w>(e.g. they are using unconditional inserts)</z><z id="t1529953342000529" t="tony.kay oh, I guess you mentioned that…unconditional"><y>#</y><d>2018-06-25</d><h>19:02</h><w>tony.kay</w>oh, I guess you mentioned that…unconditional</z><z id="t1529953356000385" t="mikerod If you use unconditional inserts, those rules will rely on order of firing"><y>#</y><d>2018-06-25</d><h>19:02</h><w>mikerod</w>If you use unconditional inserts, those rules will rely on order of firing</z><z id="t1529953359000369" t="tony.kay I lost track while reading the article 😜"><y>#</y><d>2018-06-25</d><h>19:02</h><w>tony.kay</w>I lost track while reading the article <b>😜</b></z><z id="t1529953367000615" t="mikerod since the rules won’t try to “correct” for inconsistencies if a rule fires in the “wrong order”"><y>#</y><d>2018-06-25</d><h>19:02</h><w>mikerod</w>since the rules won’t try to “correct” for inconsistencies if a rule fires in the “wrong order”</z><z id="t1529953393000534" t="mikerod but if you are opting out of truth maintenance, then yeah, you can do unconditional things"><y>#</y><d>2018-06-25</d><h>19:03</h><w>mikerod</w>but if you are opting out of truth maintenance, then yeah, you can do unconditional things</z><z id="t1529953421000239" t="tony.kay ok, I’ll try to get to the bottom of why they want to opt-out as well"><y>#</y><d>2018-06-25</d><h>19:03</h><w>tony.kay</w>ok, I’ll try to get to the bottom of why they want to opt-out as well</z><z id="t1529953436000781" t="tony.kay I agree it would be nice to reason about things in isolation"><y>#</y><d>2018-06-25</d><h>19:03</h><w>tony.kay</w>I agree it would be nice to reason about things in isolation</z><z id="t1529953496000391" t="mikerod (defrule udpate-it [?old-one &lt;- A (= ?e e) (= ?a a)] [?new-one &lt;- NewA (= ?e e) (= ?a a)] =&gt; (retract! ?old-one) (insert-unconditional! (map-&gt;A ?new-one))) "><y>#</y><d>2018-06-25</d><h>19:04</h><w>mikerod</w><pre>(defrule udpate-it
  [?old-one &lt;- A (= ?e e) (= ?a a)]
  [?new-one &lt;- NewA (= ?e e) (= ?a a)]
  =&gt;
  (retract! ?old-one)
  (insert-unconditional! (map-&gt;A ?new-one)))
</pre></z><z id="t1529953507000628" t="mikerod I’d worry a bit about pervasive use of unconditional inserts"><y>#</y><d>2018-06-25</d><h>19:05</h><w>mikerod</w>I’d worry a bit about pervasive use of unconditional inserts</z><z id="t1529953533000028" t="mikerod it misses out on one fairly large advantage of the rules engine - which is a declarative logical truth maintenance system."><y>#</y><d>2018-06-25</d><h>19:05</h><w>mikerod</w>it misses out on one fairly large advantage of the rules engine - which is a declarative logical truth maintenance system.</z><z id="t1529953558000196" t="mikerod If unconditional is used, it’d be best to a least to try to isolate it to some fringe “layer” of the logic"><y>#</y><d>2018-06-25</d><h>19:05</h><w>mikerod</w>If unconditional is used, it’d be best to a least to try to isolate it to some fringe “layer” of the logic</z><z id="t1529954204000518" t="tony.kay yeah, these are more derived new facts…but I see your point about invalidating the condition of the rule you’re running"><y>#</y><d>2018-06-25</d><h>19:16</h><w>tony.kay</w>yeah, these are more derived new facts…but I see your point about invalidating the condition of the rule you’re running</z><z id="t1530020627000360" t="baptiste-from-paris hello friends, is there a way to save the entire LocalSession in a db"><y>#</y><d>2018-06-26</d><h>13:43</h><w>baptiste-from-paris</w>hello friends, is there a way to save the entire LocalSession  in a db</z><z id="t1530022854000170" t="dominicm Is this related to #portkey in some way? 😄"><y>#</y><d>2018-06-26</d><h>14:20</h><r>dominicm</r>Is this related to #portkey in some way? <b>😄</b></z><z id="t1530020648000282" t="baptiste-from-paris I mean serialize/deserialise for later analyse"><y>#</y><d>2018-06-26</d><h>13:44</h><w>baptiste-from-paris</w>I mean serialize/deserialise for later analyse</z><z id="t1530020738000301" t="mikerod @baptiste-from-paris there is some support for this. It’s referred to as durability in the Clara codebase. You do have to implement a protocol though to serialize the working memory facts that are specific to your domain of use"><y>#</y><d>2018-06-26</d><h>13:45</h><w>mikerod</w>@baptiste-from-paris there is some support for this. It’s referred to as durability in the Clara codebase. You do have to implement a protocol though to serialize the working memory facts that are specific to your domain of use</z><z id="t1530020803000742" t="baptiste-from-paris nice 🙂"><y>#</y><d>2018-06-26</d><h>13:46</h><w>baptiste-from-paris</w>nice <b>🙂</b></z><z id="t1530020813000479" t="mikerod Also, the durability is currently targeted at being fast for serialization, but especially for deserialization. It doesn’t attempt to be able to deal with evolution to the stored data structures. If you have a change of rules, or a change of Clara version, sometime you may have to rerun rules and re-serialize. "><y>#</y><d>2018-06-26</d><h>13:46</h><w>mikerod</w>Also, the durability is currently targeted at being fast for serialization, but especially for deserialization. It doesn’t attempt to be able to deal with evolution to the stored data structures. If you have a change of rules, or a change of Clara version, sometime you may have to rerun rules and re-serialize. </z><z id="t1530020834000308" t="baptiste-from-paris ok, got it"><y>#</y><d>2018-06-26</d><h>13:47</h><w>baptiste-from-paris</w>ok, got it</z><z id="t1530020859000275" t="mikerod Well to clarify, any change in rules requires a new run. A change in Clara version may or may not. It just depends on what changes. "><y>#</y><d>2018-06-26</d><h>13:47</h><w>mikerod</w>Well to clarify, any change in rules requires a new run. A change in Clara version may or may not. It just depends on what changes. </z><z id="t1530020868000479" t="baptiste-from-paris yes offcourse"><y>#</y><d>2018-06-26</d><h>13:47</h><w>baptiste-from-paris</w>yes offcourse</z><z id="t1530020888000443" t="baptiste-from-paris thanks for your time 🙂"><y>#</y><d>2018-06-26</d><h>13:48</h><w>baptiste-from-paris</w>thanks  for your time <b>🙂</b></z><z id="t1530020890000035" t="mikerod http://www.clara-rules.org/docs/durability/"><y>#</y><d>2018-06-26</d><h>13:48</h><w>mikerod</w><a href="http://www.clara-rules.org/docs/durability/" target="_blank">http://www.clara-rules.org/docs/durability/</a></z><z id="t1530020910000055" t="baptiste-from-paris was on it, but I had to ask the communuty 😉"><y>#</y><d>2018-06-26</d><h>13:48</h><w>baptiste-from-paris</w>was on it, but I had to ask the communuty <b>😉</b></z><z id="t1530026565000825" t="jeremy How might I accumulate facts of the same type to test if they are: all contain the same value and any contain a certain value?"><y>#</y><d>2018-06-26</d><h>15:22</h><w>jeremy</w>How might I accumulate facts of the same type to test if they are: all contain the same value and any contain a certain value?</z><z id="t1530027240001006" t="mikerod @jeremy642 Sounds like 2 separate things, if so"><y>#</y><d>2018-06-26</d><h>15:34</h><w>mikerod</w>@jeremy642 Sounds like 2 separate things, if so</z><z id="t1530027244000244" t="mikerod ;; ?all contain the same value for :val [?all &lt;- (acc/all) :from [A (= ?val val)]] ;; ?all has at least one containing :some-val for :val [?all &lt;- (acc/all) :from [A]] [:test (some #(= :some-val (:val %)) ?all)] "><y>#</y><d>2018-06-26</d><h>15:34</h><w>mikerod</w><pre>;; ?all contain the same value for :val
[?all &lt;- (acc/all) :from [A (= ?val val)]]


;; ?all has at least one containing :some-val for :val
[?all &lt;- (acc/all) :from [A]]
[:test (some #(= :some-val (:val %))
             ?all)]
</pre></z><z id="t1530027254000136" t="jeremy Yes 😛"><y>#</y><d>2018-06-26</d><h>15:34</h><w>jeremy</w>Yes <b>😛</b></z><z id="t1530027255001016" t="mikerod However, the 2nd accumulator is weird, not sure why you want to accumulate like that"><y>#</y><d>2018-06-26</d><h>15:34</h><w>mikerod</w>However, the 2nd accumulator is weird, not sure why you want to accumulate like that</z><z id="t1530027263000159" t="mikerod but perhaps"><y>#</y><d>2018-06-26</d><h>15:34</h><w>mikerod</w>but perhaps</z><z id="t1530027324000360" t="mikerod “any contain a certain value” sounds like a typical rule match"><y>#</y><d>2018-06-26</d><h>15:35</h><w>mikerod</w>“any contain a certain value”  sounds like a typical rule match</z><z id="t1530027345000297" t="mikerod [?all &lt;- (acc/all) :from [A (= ?val val)]] and this will group each A where they have the same value for val"><y>#</y><d>2018-06-26</d><h>15:35</h><w>mikerod</w><code>[?all &lt;- (acc/all) :from [A (= ?val val)]]</code> and this will group each <code>A</code> where they have the same value for <code>val</code></z><z id="t1530027346000553" t="jeremy Yes it is."><y>#</y><d>2018-06-26</d><h>15:35</h><w>jeremy</w>Yes it is.</z><z id="t1530027360000555" t="mikerod it’ll match and propagate for each grouping possible"><y>#</y><d>2018-06-26</d><h>15:36</h><w>mikerod</w>it’ll match and propagate for each grouping possible</z><z id="t1530027371000334" t="jeremy Yeah, I think any would be a typical rule match."><y>#</y><d>2018-06-26</d><h>15:36</h><w>jeremy</w>Yeah, I think any would be a typical rule match.</z><z id="t1530027380000601" t="jeremy I think my mind was just farting on it."><y>#</y><d>2018-06-26</d><h>15:36</h><w>jeremy</w>I think my mind was just farting on it.</z><z id="t1530027420000681" t="jeremy But on the all, does that work if there is a fact of the same type with a diff value?"><y>#</y><d>2018-06-26</d><h>15:37</h><w>jeremy</w>But on the all, does that work if there is a fact of the same type with a diff value?</z><z id="t1530027460000730" t="jeremy A : 1, A : 1, A : 2, it shouldn&apos;t match since all As don&apos;t have the same value."><y>#</y><d>2018-06-26</d><h>15:37</h><w>jeremy</w>A : 1, A : 1, A : 2, it shouldn&apos;t match since all As don&apos;t have the same value.</z><z id="t1530027566000115" t="jeremy Maybe it&apos;d be more like the 2nd one"><y>#</y><d>2018-06-26</d><h>15:39</h><w>jeremy</w>Maybe it&apos;d be more like the 2nd one</z><z id="t1530027578000349" t="jeremy Where you accumulate them all together, then apply a test to them."><y>#</y><d>2018-06-26</d><h>15:39</h><w>jeremy</w>Where you accumulate them all together, then apply a test to them.</z><z id="t1530030845000429" t="jeremy Got it 👍 Feel so accomplished when a rule works."><y>#</y><d>2018-06-26</d><h>16:34</h><w>jeremy</w>Got it <b>👍</b>  Feel so accomplished when a rule works.</z><z id="t1530041019000318" t="jeremy Did any of the visualization stuff that Ryan talks about in his videos get released?"><y>#</y><d>2018-06-26</d><h>19:23</h><w>jeremy</w>Did any of the visualization stuff that Ryan talks about in his videos get released?</z><z id="t1530056057000455" t="tony.kay I’m not seeing anything in the docs that would allow you to separate rule sets, and defrule seems global…is there support (planned) for having “rule sets” for different things, or is the idea that you just keep your domains separate by having facts that don’t cross over and trust that the optimizations in the engine will make it mostly “not matter” when your rule set gets big because it covers 10 different domains?"><y>#</y><d>2018-06-26</d><h>23:34</h><w>tony.kay</w>I’m not seeing anything in the docs that would allow you to separate rule sets, and <code>defrule</code> seems global…is there support (planned) for having “rule sets” for different things, or is the idea that you just keep your domains separate by having facts that don’t cross over and trust that the optimizations in the engine will make it mostly “not matter” when your rule set gets big because it covers 10 different domains?</z><z id="t1530057630000383" t="mikerod @jeremy642 I believe what you are referring to was a bit of an experimental project and not actively maintained. "><y>#</y><d>2018-06-27</d><h>00:00</h><w>mikerod</w>@jeremy642 I believe what you are referring to was a bit of an experimental project and not actively maintained. </z><z id="t1530057666000223" t="mikerod It maybe this https://github.com/rbrush/clara-tools"><y>#</y><d>2018-06-27</d><h>00:01</h><w>mikerod</w>It maybe this <a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a></z><z id="t1530057785000324" t="mikerod @tony.kay you can provided collections of rule structures to mk-session. It doesn’t only accept namespaces. You can also define a var that holds a collection of rules and give it metadata :production-seq. So that single var name can be passed. "><y>#</y><d>2018-06-27</d><h>00:03</h><w>mikerod</w>@tony.kay you can provided collections of rule structures to mk-session. It doesn’t only accept namespaces. You can also define a var that holds a collection of rules and give it metadata :production-seq. So that single var name can be passed. </z><z id="t1530057798000261" t="mikerod Different ways to do things. Depending on your goals. "><y>#</y><d>2018-06-27</d><h>00:03</h><w>mikerod</w>Different ways to do things. Depending on your goals. </z><z id="t1530057841000024" t="mikerod However sometimes it can be fine to combine into larger rule sets. Rules that don’t match facts won’t contribute much to runtime. "><y>#</y><d>2018-06-27</d><h>00:04</h><w>mikerod</w>However sometimes it can be fine to combine into larger rule sets. Rules that don’t match facts won’t contribute much to runtime. </z><z id="t1530058401000126" t="tony.kay Ah, I misunderstood how mk-session worked…my bad"><y>#</y><d>2018-06-27</d><h>00:13</h><w>tony.kay</w>Ah, I misunderstood how mk-session worked…my bad</z><z id="t1530060850000204" t="mikerod No problem!"><y>#</y><d>2018-06-27</d><h>00:54</h><w>mikerod</w> No problem!</z><z id="t1530066163000210" t="jeremy @mikerod Thanks"><y>#</y><d>2018-06-27</d><h>02:22</h><w>jeremy</w>@mikerod Thanks</z><z id="t1530120058000191" t="jeremy I have a bunch of rules that derive some final state fact. What I run into is that multiple rules might match and in the end I get multiple results. So in the standard decision tree, there is order to the final state precedence. Would it be appropriate to add a priority property to these final state results and then query on that priority to narrow it down to a single result?"><y>#</y><d>2018-06-27</d><h>17:20</h><w>jeremy</w>I have a bunch of rules that derive some final state fact. What I run into is that multiple rules might match and in the end I get multiple results. So in the standard decision tree, there is order to the final state precedence. Would it be appropriate to add a priority property to these final state results and then query on that priority to narrow it down to a single result?</z><z id="t1530122301000335" t="mikerod @jeremy642 that is one approach"><y>#</y><d>2018-06-27</d><h>17:58</h><w>mikerod</w>@jeremy642 that is one approach</z><z id="t1530122313000273" t="mikerod I think I’ve answered variations of this question a lot of times, but don’t think it’s saved anywhere"><y>#</y><d>2018-06-27</d><h>17:58</h><w>mikerod</w>I think I’ve answered variations of this question a lot of times, but don’t think it’s saved anywhere</z><z id="t1530122322000284" t="jeremy 🙂"><y>#</y><d>2018-06-27</d><h>17:58</h><w>jeremy</w><b>🙂</b></z><z id="t1530122323000049" t="mikerod you can prioritize rules by building a tiered structure to them"><y>#</y><d>2018-06-27</d><h>17:58</h><w>mikerod</w>you can prioritize rules by building a tiered structure to them</z><z id="t1530122329000149" t="mikerod or you can let them all fire"><y>#</y><d>2018-06-27</d><h>17:58</h><w>mikerod</w>or you can let them all fire</z><z id="t1530122335000160" t="mikerod insert some “intermediate fact”"><y>#</y><d>2018-06-27</d><h>17:58</h><w>mikerod</w>insert some “intermediate fact”</z><z id="t1530122353000509" t="mikerod then have 1 more rule to accumulate all “intermediate facts” and insert your final fact based on the aggregate of them"><y>#</y><d>2018-06-27</d><h>17:59</h><w>mikerod</w>then have 1 more rule to accumulate all “intermediate facts” and insert your final fact based on the aggregate of them</z><z id="t1530122367000036" t="mikerod I can give examlpes in a bit if needed"><y>#</y><d>2018-06-27</d><h>17:59</h><w>mikerod</w>I can give examlpes in a bit if needed</z><z id="t1530122390000142" t="mikerod I guess I have one example of one approach here https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac#file-clara_tiered_fact_update_rules-clj"><y>#</y><d>2018-06-27</d><h>17:59</h><w>mikerod</w>I guess I have one example of one approach here <a href="https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac#file-clara_tiered_fact_update_rules-clj" target="_blank">https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac#file-clara_tiered_fact_update_rules-clj</a></z><z id="t1530123096000099" t="jeremy Thanks. I&apos;ll check it out and play with it."><y>#</y><d>2018-06-27</d><h>18:11</h><w>jeremy</w>Thanks. I&apos;ll check it out and play with it.</z><z id="t1530300432000326" t="Daniel Hines Hello all. What is the current status of dynamically generated rules in CLJS with Clara? I saw this thread: https://groups.google.com/forum/#!topic/clara-rules/9x-dIBM1hoo , but the last bit of activity was several years ago, and I can&apos;t tell where things landed."><y>#</y><d>2018-06-29</d><h>19:27</h><w>Daniel Hines</w>Hello all. What is the current status of dynamically generated rules in CLJS with Clara? I saw this thread: <a href="https://groups.google.com/forum/#!topic/clara-rules/9x-dIBM1hoo" target="_blank">https://groups.google.com/forum/#!topic/clara-rules/9x-dIBM1hoo</a>, but the last bit of activity was several years ago, and I can&apos;t tell where things landed.</z><z id="t1530304480000005" t="mikerod @d4hines I don’t know of any activity on it really"><y>#</y><d>2018-06-29</d><h>20:34</h><w>mikerod</w>@d4hines I don’t know of any activity on it really</z><z id="t1530304491000381" t="mikerod Rules are compiled in clj. The compiler uses eval"><y>#</y><d>2018-06-29</d><h>20:34</h><w>mikerod</w>Rules are compiled in clj. The compiler uses eval</z><z id="t1530304516000174" t="mikerod What are you wanting to explore in this regard?"><y>#</y><d>2018-06-29</d><h>20:35</h><w>mikerod</w>What are you wanting to explore in this regard?</z><z id="t1530304718000281" t="Daniel Hines I know a major goal of Clara is to &quot;take back rules for the developer&quot;, but a major goal of a project I&apos;m working on is to be able to update rules on the fly based on changing business logic. The rules aren&apos;t that complicated at all, but there are a lot of them, so it would be nice to create an interface for a non-developer to edit and publish the rules. It sounds like that would require deploying a new build, correct?"><y>#</y><d>2018-06-29</d><h>20:38</h><w>Daniel Hines</w>I know a major goal of Clara is to &quot;take back rules for the developer&quot;, but a major goal of a project I&apos;m working on is to be able to update rules on the fly based on changing business logic. The rules aren&apos;t that complicated at all, but there are a lot of them, so it would be nice to create an interface for a non-developer to edit and publish the rules. It sounds like that would require deploying a new build, correct?</z><z id="t1530304788000012" t="mikerod The thread you linked to discussed it some, but you could have a server that compilers rules and sends it back to client"><y>#</y><d>2018-06-29</d><h>20:39</h><w>mikerod</w>The thread you linked to discussed it some, but you could have a server that compilers rules and sends it back to client</z><z id="t1530304794000141" t="mikerod if you are wanting to have a client in cljs"><y>#</y><d>2018-06-29</d><h>20:39</h><w>mikerod</w>if you are wanting to have a client in cljs</z><z id="t1530304820000140" t="mikerod Not sure what your non-developer constraints are - what would they be editing in?"><y>#</y><d>2018-06-29</d><h>20:40</h><w>mikerod</w>Not sure what your non-developer constraints are - what would they be editing in?</z><z id="t1530304834000199" t="mikerod eg (1) a repl (2) some sort of browser-based UI etc"><y>#</y><d>2018-06-29</d><h>20:40</h><w>mikerod</w>eg (1) a repl (2) some sort of browser-based UI etc</z><z id="t1530304969000047" t="Daniel Hines Well, I was definitely leaning towards (2), but having seen an example of instaparse creating clara rules, it might be neat to create a dsl such that the source of truth for the rules is a text file, in which case a fancy UI might not be as necessary."><y>#</y><d>2018-06-29</d><h>20:42</h><w>Daniel Hines</w>Well, I was definitely leaning towards (2), but having seen an example of instaparse creating clara rules, it might be neat to create a dsl such that the source of truth for the rules is a text file, in which case a fancy UI might not be as necessary.</z><z id="t1530305050000423" t="mikerod You can make rulesets in a dynamic way"><y>#</y><d>2018-06-29</d><h>20:44</h><w>mikerod</w>You can make rulesets in a dynamic way</z><z id="t1530305115000100" t="mikerod So bring in some text files, convert format to Clara rules data format, compile them (and ensure you have the right compiling-context for var resolution etc)"><y>#</y><d>2018-06-29</d><h>20:45</h><w>mikerod</w>So bring in some text files, convert format to Clara rules data format, compile them (and ensure you have the right compiling-context for var resolution etc)</z><z id="t1530305130000115" t="mikerod You can do mk-session with collections of rule/query structures"><y>#</y><d>2018-06-29</d><h>20:45</h><w>mikerod</w>You can do <code>mk-session</code> with collections of rule/query structures</z><z id="t1530305143000379" t="mikerod So they do not have to be bound to Clojure namespaces/vars"><y>#</y><d>2018-06-29</d><h>20:45</h><w>mikerod</w>So they do not have to be bound to Clojure namespaces/vars</z><z id="t1530305163000025" t="mikerod So you could build a more dynamic process around that."><y>#</y><d>2018-06-29</d><h>20:46</h><w>mikerod</w>So you could build a more dynamic process around that.</z><z id="t1530305296000025" t="Daniel Hines I&apos;m not sure I follow, but that&apos;s probably due to my unfamiliarity with Clara in general."><y>#</y><d>2018-06-29</d><h>20:48</h><w>Daniel Hines</w>I&apos;m not sure I follow, but that&apos;s probably due to my unfamiliarity with Clara in general.</z><z id="t1530307997000261" t="mikerod Hmm"><y>#</y><d>2018-06-29</d><h>21:33</h><w>mikerod</w>Hmm</z><z id="t1530308039000172" t="mikerod I can try to come up with an example"><y>#</y><d>2018-06-29</d><h>21:33</h><w>mikerod</w>I can try to come up with an example</z><z id="t1530308610000112" t="dominicm Does self hosted Clojure script work?"><y>#</y><d>2018-06-29</d><h>21:43</h><w>dominicm</w>Does self hosted Clojure script work?</z><z id="t1530308614000335" t="mikerod nope"><y>#</y><d>2018-06-29</d><h>21:43</h><w>mikerod</w>nope</z><z id="t1530308633000038" t="mikerod some Clara namespaces are only clj"><y>#</y><d>2018-06-29</d><h>21:43</h><w>mikerod</w>some Clara namespaces are only clj</z><z id="t1530308638000069" t="mikerod (not cljc)"><y>#</y><d>2018-06-29</d><h>21:43</h><w>mikerod</w>(not cljc)</z><z id="t1530308648000090" t="mikerod It’d be cool to make it self-host compatible though 😛"><y>#</y><d>2018-06-29</d><h>21:44</h><w>mikerod</w>It’d be cool to make it self-host compatible though <b>😛</b></z><z id="t1530308665000173" t="mikerod adds a bit of a new layer of trickiness to parts of it, macros etc"><y>#</y><d>2018-06-29</d><h>21:44</h><w>mikerod</w>adds a bit of a new layer of trickiness to parts of it, macros etc</z><z id="t1530308684000074" t="dominicm Yeah. There&apos;s some help for that in macrovich"><y>#</y><d>2018-06-29</d><h>21:44</h><w>dominicm</w>Yeah. There&apos;s some help for that in macrovich</z><z id="t1530308695000052" t="mikerod yep, I’ve seen that one"><y>#</y><d>2018-06-29</d><h>21:44</h><w>mikerod</w>yep, I’ve seen that one</z><z id="t1530308729000063" t="mikerod If I had more time to do it, I’d definitely look at self-hosted support. Would be cool."><y>#</y><d>2018-06-29</d><h>21:45</h><w>mikerod</w>If I had more time to do it, I’d definitely look at self-hosted support. Would be cool.</z><z id="t1530308744000086" t="mikerod It probably isn’t a terribly long way off, but I’m sure there would be some trickiness"><y>#</y><d>2018-06-29</d><h>21:45</h><w>mikerod</w>It probably isn’t a terribly long way off, but I’m sure there would be some trickiness</z><z id="t1530318560000003" t="mikerod @d4hines mk-session would use clj eval. So it’d need to be running in a JVM process. "><y>#</y><d>2018-06-30</d><h>00:29</h><w>mikerod</w>@d4hines mk-session would use clj eval. So it’d need to be running in a JVM process. </z><z id="t1530318607000121" t="mikerod The rule data structure are just plain clj data so could be made wherever and sent to mk-session"><y>#</y><d>2018-06-30</d><h>00:30</h><w>mikerod</w>The rule data structure are just plain clj data so could be made wherever and sent to mk-session</z><z id="t1530318679000046" t="mikerod Also. I don’t know if you are trying to load rules in cljs still hah"><y>#</y><d>2018-06-30</d><h>00:31</h><w>mikerod</w>Also. I don’t know if you are trying to load rules in cljs still hah</z><z id="t1530318884000063" t="Daniel Hines I got a little confused as to which we were doing 😛 . If mk-session requires a JVM, that means I would need to compile it down to CLJS like the google thread described, then require that in a &lt;script&gt; tag or similar, right?"><y>#</y><d>2018-06-30</d><h>00:34</h><w>Daniel Hines</w>I got a little confused as to which we were doing <b>😛</b>. If <code>mk-session</code> requires a JVM, that means I would need to compile it down to CLJS like the google thread described, then require that in a <code>&lt;script&gt;</code> tag or similar, right?</z><z id="t1530318969000042" t="Daniel Hines I think my use case is such that I could justify just doing a new build/deploy of the whole frontend every time they needed to update the rules (which isn&apos;t at rapid speed or anything), which sounds like it would be much easier and not require any more infrastructure than using Clara with cljs in the first place. Is that a bad way to go?"><y>#</y><d>2018-06-30</d><h>00:36</h><w>Daniel Hines</w>I think my use case is such that I could justify just doing a new build/deploy of the whole frontend every time they needed to update the rules (which isn&apos;t at rapid speed or anything), which sounds like it would be much easier and not require any more infrastructure than using Clara with cljs in the first place. Is that a bad way to go?</z><z id="t1530318995000126" t="Daniel Hines Turn it into a CI/CD problem instead of a Clojure problem."><y>#</y><d>2018-06-30</d><h>00:36</h><w>Daniel Hines</w>Turn it into a CI/CD problem instead of a Clojure problem.</z><z id="t1530319171000088" t="mikerod Yeah may be reasonable. I’d have to look more to have any better suggestions there. "><y>#</y><d>2018-06-30</d><h>00:39</h><w>mikerod</w>Yeah may be reasonable. I’d have to look more to have any better suggestions there. </z><z id="t1530319196000044" t="mikerod I guess Clara compiled rules cannot be returned from like an xhrio call? Hmm. "><y>#</y><d>2018-06-30</d><h>00:39</h><w>mikerod</w>I guess Clara compiled rules cannot be returned from like an xhrio call? Hmm. </z><z id="t1530325491000064" t="mikerod Yes. It is useful. You can build rules in more dynamic ways when useful. "><y>#</y><d>2018-06-30</d><h>02:24</h><w>mikerod</w>Yes. It is useful. You can build rules in more dynamic ways when useful. </z><z id="t1530325673000008" t="mikerod http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/ A bit older post but related shows interesting things that can be done. I think that Daniel mentioned in an earlier comment today. "><y>#</y><d>2018-06-30</d><h>02:27</h><w>mikerod</w><a href="http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/" target="_blank">http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/</a>

A bit older post but related shows interesting things that can be done. I think that Daniel mentioned in an earlier comment today. </z><z id="t1530326601000035" t="jeremy I read through it. Instaparse is a bit of gibberish to me right now. I’ll have to look into it more. 🙂"><y>#</y><d>2018-06-30</d><h>02:43</h><w>jeremy</w>I read through it. Instaparse is a bit of gibberish to me right now. I’ll have to look into it more. <b>🙂</b></z><z id="t1530338722000022" t="alex-dixon @d4hines it’s not a path anyone’s cleared that I know of. I’d expect it to be challenging no matter the approach you take. Another one depending on what kind of setup you ultimately want could involve figwheel I think. I’ve had some success getting live reload to work by redefining the session var in cljs and manipulating the keys in the cljs compiler env that Clara stores productions in. I only had it working for changes to source code though"><y>#</y><d>2018-06-30</d><h>06:05</h><w>alex-dixon</w>@d4hines it’s not a path anyone’s cleared that I know of. I’d expect it to be challenging no matter the approach you take. Another one depending on what kind of setup you ultimately want could involve figwheel I think. I’ve had some success getting live reload to work by redefining the session var in cljs and manipulating the keys in the cljs compiler env that Clara stores productions in. I only had it working for changes to source code though</z><z id="t1531706616000090" t="alex-dixon Stupid question time: Is it possible to use Rete with disk storage only for working sets that can’t fit into memory? Would there be any advantage to using it as part of a database implementation?"><y>#</y><d>2018-07-16</d><h>02:03</h><w>alex-dixon</w>Stupid question time: Is it possible to use Rete with disk storage only for working sets that can’t fit into memory? Would there be any advantage to using it as part of a database implementation?</z><z id="t1531730065000152" t="wparker @alex-dixon There isn&apos;t any reason in principle why you can&apos;t use disk storage in a Clara memory implementation. It would obviously be less performant than in memory storage; if every Rete operation resulted in a random disk seek it could be pretty poor at a guess. I&apos;ve toyed with the idea of a memory implementation dumping overflow to disk before though with some kind of heuristics for what to keep in memory. There could be complications to work through if you&apos;re trying to basically serialize random objects too."><y>#</y><d>2018-07-16</d><h>08:34</h><w>wparker</w>@alex-dixon There isn&apos;t any reason in principle why you can&apos;t use disk storage in a Clara memory implementation.  It would obviously be less performant than in memory storage; if every Rete operation resulted in a random disk seek it could be pretty poor at a guess.  I&apos;ve toyed with the idea of a memory implementation dumping overflow to disk before though with some kind of heuristics for what to keep in memory.  There could be complications to work through if you&apos;re trying to basically serialize random objects too.</z><z id="t1531765020000525" t="alex-dixon &gt; I’ve toyed with the idea of a memory implementation dumping overflow to disk before though with some kind of heuristics for what to keep in memory Heh, I was thinking about the same thing yesterday 🙂 I haven’t been able to find any papers or mention of Rete being used with a persistence layer. Do you know of any?"><y>#</y><d>2018-07-16</d><h>18:17</h><w>alex-dixon</w>&gt; I’ve toyed with the idea of a memory implementation dumping overflow to disk before though with some kind of heuristics for what to keep in memory
Heh, I was thinking about the same thing yesterday <b>🙂</b> I haven’t been able to find any papers or mention of Rete being used with a persistence layer. Do you know of any?</z><z id="t1531768171000314" t="wparker @alex-dixon No, I don’t know of any offhand. My (completely untested 🙂 ) guess would be that avoiding internal retractions from truth maintenance would be a big part of it. Maybe if the data were appropriately structured you could use a local database to back the memory - is that what you were getting at with “Would there be any advantage to using it as part of a database implementation?”"><y>#</y><d>2018-07-16</d><h>19:09</h><w>wparker</w>@alex-dixon No, I don’t know of any offhand.  My (completely untested <b>🙂</b> ) guess would be that avoiding internal retractions from truth maintenance would be a big part of it.  Maybe if the data were appropriately structured you could use a local database to back the memory - is that what you were getting at with “Would there be any advantage to using it as part of a database implementation?”</z><z id="t1531773659000266" t="hiredman there is presentation from, uh, maybe it was at a clojurewest, the presenter discusses implementing a rules system on top of a database, it does away with, maybe just alpha nodes, in rete because it expects database indices to do basically the same thing"><y>#</y><d>2018-07-16</d><h>20:40</h><w>hiredman</w>there is presentation from, uh, maybe it was at a clojurewest, the presenter discusses implementing a rules system on top of a database, it does away with, maybe just alpha nodes, in rete because it expects database indices to do basically the same thing</z><z id="t1531773739000313" t="hiredman https://github.com/threatgrid/naga"><y>#</y><d>2018-07-16</d><h>20:42</h><w>hiredman</w><a href="https://github.com/threatgrid/naga" target="_blank">https://github.com/threatgrid/naga</a></z><z id="t1531934137000312" t="alex-dixon @hiredman thanks! The readme says in memory only but plans for persistence with an rdf triple store or graph database. I’ll look into it more"><y>#</y><d>2018-07-18</d><h>17:15</h><w>alex-dixon</w>@hiredman thanks! The readme says in memory only but plans for persistence with an rdf triple store or graph database. I’ll look into it more</z><z id="t1531934574000066" t="alex-dixon @wparker That was poorly phrased but basically yeah. More specifically I’m trying to figure out whether Clara or rete in general could be implemented as a hybrid in memory and persistent db like Datomic that uses rete for in memory processing as well as for querying persistent data that can never fit into memory. "><y>#</y><d>2018-07-18</d><h>17:22</h><w>alex-dixon</w>@wparker That was poorly phrased but basically yeah. More specifically I’m trying to figure out whether Clara or rete in general could be implemented as a hybrid in memory and persistent db like Datomic that uses rete for in memory processing as well as for querying persistent data that can never fit into memory. </z><z id="t1531934668000158" t="alex-dixon Having rules writing to persistent storage would be key too"><y>#</y><d>2018-07-18</d><h>17:24</h><w>alex-dixon</w>Having rules writing to persistent storage would be key too</z><z id="t1531953296000005" t="mikerod @alex-dixon seems doable"><y>#</y><d>2018-07-18</d><h>22:34</h><w>mikerod</w>@alex-dixon seems doable</z><z id="t1531953313000079" t="mikerod but not without a bunch of effort if you were going to try to implement a memory that works well/performant doing that"><y>#</y><d>2018-07-18</d><h>22:35</h><w>mikerod</w>but not without a bunch of effort if you were going to try to implement a memory that works well/performant doing that</z><z id="t1531953347000165" t="mikerod Long ago, Ryan did an example storm cluster-based Clara impl of memory. it was experimental but did show how memory could be extended potentially"><y>#</y><d>2018-07-18</d><h>22:35</h><w>mikerod</w>Long ago, Ryan did an example storm cluster-based Clara impl of memory. it was experimental but did show how memory could be extended potentially</z><z id="t1531953483000245" t="alex-dixon Thanks. Yeah I’ve been looking at that. It’s not clear to me what’s going on there. Best I could figure out is storm is doing a lot of the work"><y>#</y><d>2018-07-18</d><h>22:38</h><w>alex-dixon</w>Thanks. Yeah I’ve been looking at that. It’s not clear to me what’s going on there. Best I could figure out is storm is doing a lot of the work</z><z id="t1531953583000116" t="mikerod yeah, it’d require storm understanding I’m sure"><y>#</y><d>2018-07-18</d><h>22:39</h><w>mikerod</w>yeah, it’d require storm understanding I’m sure</z><z id="t1531953588000179" t="mikerod and it isn’t really the same thing"><y>#</y><d>2018-07-18</d><h>22:39</h><w>mikerod</w>and it isn’t really the same thing</z><z id="t1531953636000018" t="mikerod You could certainly try to hook a memory impl up to have facts potentially in slower storage, you’d just have to deal with that serialization stuff and also the concern of how to make it not super slow"><y>#</y><d>2018-07-18</d><h>22:40</h><w>mikerod</w>You could certainly try to hook a memory impl up to have facts potentially in slower storage, you’d just have to deal with that serialization stuff and also the concern of how to make it not super slow</z><z id="t1531953647000234" t="mikerod also, accumulators are an issue"><y>#</y><d>2018-07-18</d><h>22:40</h><w>mikerod</w>also, accumulators are an issue</z><z id="t1531953673000232" t="mikerod if you are dealing in numbers of facts too large for memory, but then you try to do an accumulator that needs to see them all at once"><y>#</y><d>2018-07-18</d><h>22:41</h><w>mikerod</w>if you are dealing in numbers of facts too large for memory, but then you try to do an accumulator that needs to see them all at once</z><z id="t1531953727000205" t="mikerod I watched the naga talk before too. It was interesting. It seemed a bit more special-purposed than Clara, but still cool to think about"><y>#</y><d>2018-07-18</d><h>22:42</h><w>mikerod</w>I watched the naga talk before too. It was interesting. It seemed a bit more special-purposed than Clara, but still cool to think about</z><z id="t1531953966000221" t="alex-dixon I’m thinking of using RocksDB specifically https://github.com/facebook/rocksdb/wiki/Performance-Benchmarks"><y>#</y><d>2018-07-18</d><h>22:46</h><w>alex-dixon</w>I’m thinking of using RocksDB specifically <a href="https://github.com/facebook/rocksdb/wiki/Performance-Benchmarks" target="_blank">https://github.com/facebook/rocksdb/wiki/Performance-Benchmarks</a></z><z id="t1531956363000255" t="mikerod never saw that one"><y>#</y><d>2018-07-18</d><h>23:26</h><w>mikerod</w>never saw that one</z><z id="t1531956376000069" t="mikerod looks like it could be interesting to experiment with the idea though"><y>#</y><d>2018-07-18</d><h>23:26</h><w>mikerod</w>looks like it could be interesting to experiment with the idea though</z><z id="t1533094472000125" t="jumblemuddle Does it make sense to have singleton facts in my network? Whenver I update one of these I retract the previous fact and insert the updated fact."><y>#</y><d>2018-08-01</d><h>03:34</h><w>jumblemuddle</w>Does it make sense to have singleton facts in my network? Whenver I update one of these I retract the previous fact and insert the updated fact.</z><z id="t1533130852000411" t="mikerod @jumblemuddle maybe something I wrote a while back can go through some of those situations http://www.metasimple.org/2017/12/23/clara-updating-facts.html"><y>#</y><d>2018-08-01</d><h>13:40</h><w>mikerod</w>@jumblemuddle maybe something I wrote a while back can go through some of those situations <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a></z><z id="t1533130912000122" t="mikerod if you are just wanting to skim, perhaps see “Approach 1: Append only updates” and “Approach 2: Externally managed updates” sections"><y>#</y><d>2018-08-01</d><h>13:41</h><w>mikerod</w>if you are just wanting to skim, perhaps see “Approach 1: Append only updates” and “Approach 2: Externally managed updates” sections</z><z id="t1533133158000079" t="jumblemuddle Thanks, @mikerod!"><y>#</y><d>2018-08-01</d><h>14:19</h><w>jumblemuddle</w>Thanks, @mikerod!</z><z id="t1533763368000016" t="jeremy @mikerod Do you know if there is a way to go from Java -&gt; Clojure when rules are keywords and not records/java beans?"><y>#</y><d>2018-08-08</d><h>21:22</h><w>jeremy</w>@mikerod Do you know if there is a way to go from Java -&gt; Clojure when rules are keywords and not records/java beans?</z><z id="t1533763683000376" t="enn I have a Clara rulebase that, for comprehensibility reasons, I’d like to split into “phases.” So, phase 1 gets a bunch of facts, the rules fire, and new facts are generated. Somehow, this becomes the input to phase 2, which fires a new set of rules, generating new facts. Etc. I’m not sure what the best way is to pass the output of one phase into the next. Originally I was thinking I’d just take the session from phase 1 and use that as the starting point for phase 2. But unless I’m missing something, it’s not possible to load new rules into an extant session. So I guess what I need to do is to just grab all the “output” facts out of phase 1 and insert them into a new session for phase 2. Is there a simpler way to do this than by writing (and then executing) a query for each and every fact type?"><y>#</y><d>2018-08-08</d><h>21:28</h><w>enn</w>I have a Clara rulebase that, for comprehensibility reasons, I’d like to split into “phases.” So, phase 1 gets a bunch of facts, the rules fire, and new facts are generated. Somehow, this becomes the input to phase 2, which fires a new set of rules, generating new facts. Etc.

I’m not sure what the best way is to pass the output of one phase into the next. Originally I was thinking I’d just take the session from phase 1 and use that as the starting point for phase 2. But unless I’m missing something, it’s not possible to load new rules into an extant session.

So I guess what I need to do is to just grab all the “output” facts out of phase 1 and insert them into a new session for phase 2. Is there a simpler way to do this than by writing (and then executing) a query for each and every fact type?</z><z id="t1533763801000124" t="mikerod @enn &gt; So I guess what I need to do is to just grab all the “output” facts out of phase 1 and insert them into a new session for phase 2. Is there a simpler way to do this than by writing (and then executing) a query for each and every fact type? I think this is likely a smoother approach (there is an alternative I can mention in a min) As far as worrying about querying for too many types, maybe you can make a “parent” type for the output types you care about and just have a query on that parent type."><y>#</y><d>2018-08-08</d><h>21:30</h><w>mikerod</w>@enn 
&gt; So I guess what I need to do is to just grab all the “output” facts out of phase 1 and insert them into a new session for phase 2. Is there a simpler way to do this than by writing (and then executing) a query for each and every fact type?
I think this is likely a smoother approach (there is an alternative I can mention in a min)

As far as worrying about querying for too many types, maybe you can make a “parent” type for the output types you care about and just have a query on that parent type.</z><z id="t1533763925000364" t="mikerod Another possibility is to just use one session with all the rules. I’m not sure what about your logic makes it where you’d want some rules to be separate from others. Are you worried about them running too early or something, performance?, etc"><y>#</y><d>2018-08-08</d><h>21:32</h><r>mikerod</r>Another possibility is to just use one session with all the rules. I’m not sure what about your logic makes it where you’d want some rules to be separate from others. Are you worried about them running too early or something, performance?, etc</z><z id="t1533764072000043" t="mikerod I don’t understand your situation enough, but there is something called “activation groups” that can also be considered in some cases that may relate to yours https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/rules.cljc#L328-L331"><y>#</y><d>2018-08-08</d><h>21:34</h><r>mikerod</r>I don’t understand your situation enough, but there is something called “activation groups” that can also be considered in some cases that may relate to yours
<a href="https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/rules.cljc#L328-L331" target="_blank">https://github.com/cerner/clara-rules/blob/0.18.0/src/main/clojure/clara/rules.cljc#L328-L331</a></z><z id="t1533764107000284" t="enn No, they’re all in one session now and it works fine performance-wise. It’s more about making it easier for the programmer to understand the universe of rules and fact types in play at a given point in the code."><y>#</y><d>2018-08-08</d><h>21:35</h><r>enn</r>No, they’re all in one session now and it works fine performance-wise. It’s more about making it easier for the programmer to understand the universe of rules and fact types in play at a given point in the code.</z><z id="t1533764351000360" t="enn And making it easy to ensure that an intermediate fact type (used to derive some other final result) does not get inadvertently referenced outside of its intended scope"><y>#</y><d>2018-08-08</d><h>21:39</h><r>enn</r>And making it easy to ensure that an intermediate fact type (used to derive some other final result) does not get inadvertently referenced outside of its intended scope</z><z id="t1533764435000089" t="enn Maybe my whole idea is antithetical to the idea that a rules engine hides some of the order-of-execution concerns of regular code? I’m not sure."><y>#</y><d>2018-08-08</d><h>21:40</h><r>enn</r>Maybe my whole idea is antithetical to the idea that a rules engine hides some of the order-of-execution concerns of regular code? I’m not sure.</z><z id="t1533764961000105" t="mikerod Yeah, I understand your reasoning then"><y>#</y><d>2018-08-08</d><h>21:49</h><r>mikerod</r>Yeah, I understand your reasoning then</z><z id="t1533764970000069" t="mikerod You can separate them to independent rulesets if that helps reasoning"><y>#</y><d>2018-08-08</d><h>21:49</h><r>mikerod</r>You can separate them to independent rulesets if that helps reasoning</z><z id="t1533764992000185" t="mikerod there would be a slight cost of taking facts from queries of one session and inserting again into another session, but that may not really be a concern"><y>#</y><d>2018-08-08</d><h>21:49</h><r>mikerod</r>there would be a slight cost of taking facts from queries of one session and inserting again into another session, but that may not really be a concern</z><z id="t1533765009000237" t="mikerod but yeah, order independence is a key idea"><y>#</y><d>2018-08-08</d><h>21:50</h><r>mikerod</r>but yeah, order independence is a key idea</z><z id="t1533765026000016" t="mikerod and I’d also sort of argue that rules should be able to somewhat function in aggregation with one another"><y>#</y><d>2018-08-08</d><h>21:50</h><r>mikerod</r>and I’d also sort of argue that rules should be able to somewhat function in aggregation with one another</z><z id="t1533765048000294" t="mikerod where they can all share related information when relevant, but they are also fine when the information they need isn’t present etc"><y>#</y><d>2018-08-08</d><h>21:50</h><r>mikerod</r>where they can all share related information when relevant, but they are also fine when the information they need isn’t present etc</z><z id="t1533765105000237" t="mikerod &gt; And making it easy to ensure that an intermediate fact type (used to derive some other final result) does not get inadvertently referenced outside of its intended scope I think this is the most interesting concern though."><y>#</y><d>2018-08-08</d><h>21:51</h><r>mikerod</r>&gt; And making it easy to ensure that an intermediate fact type (used to derive some other final result) does not get inadvertently referenced outside of its intended scope
I think this is the most interesting concern though.</z><z id="t1533765140000250" t="mikerod If everything gets lumped together, I can see how it could become problematic if you were wanting to have a better control on scope"><y>#</y><d>2018-08-08</d><h>21:52</h><r>mikerod</r>If everything gets lumped together, I can see how it could become problematic if you were wanting to have a better control on scope</z><z id="t1533763816000020" t="mikerod @jeremy642 I don’t think I understand the question. You want to use rules with “keyword” sort of type dispatch, but on underlying Java objects? Maybe show a dummy example or something."><y>#</y><d>2018-08-08</d><h>21:30</h><w>mikerod</w>@jeremy642 I don’t think I understand the question. You want to use rules with “keyword” sort of type dispatch, but on underlying Java objects? Maybe show a dummy example or something.</z><z id="t1533763885000245" t="jeremy I have rules built on a keyword type dispatch. I wasn&apos;t sure if there might be a way to create them from Java."><y>#</y><d>2018-08-08</d><h>21:31</h><w>jeremy</w>I have rules built on a keyword type dispatch. I wasn&apos;t sure if there might be a way to create them from Java.</z><z id="t1533763977000212" t="jeremy More a question on Java -&gt; Clojure interop I guess than clara-rules. How I might go about creating the necessary type map for clara-rules from Java."><y>#</y><d>2018-08-08</d><h>21:32</h><w>jeremy</w>More a question on Java -&gt; Clojure interop I guess than clara-rules. How I might go about creating the necessary type map for clara-rules from Java.</z><z id="t1533764030000066" t="jeremy"><y>#</y><d>2018-08-08</d><h>21:33</h><w>jeremy</w></z><z id="t1533764142000234" t="mikerod @jeremy642 you can provide a custom fact-type-fn (and ancestors-fn if relevant) http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2018-08-08</d><h>21:35</h><w>mikerod</w>@jeremy642 you can provide a custom <code>fact-type-fn</code> (and <code>ancestors-fn</code> if relevant)  <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1533764194000138" t="mikerod This may be what you are looking for. e.g. the fact-type-fn could take an arbitrary (Java) object and map it to some keyword/alternative typing system you have within the rules"><y>#</y><d>2018-08-08</d><h>21:36</h><w>mikerod</w>This may be what you are looking for. e.g. the <code>fact-type-fn</code> could take an arbitrary (Java) object and map it to some keyword/alternative typing system you have within the rules</z><z id="t1533764333000396" t="mikerod A likely incomplete example, but perhaps inspiration to think about."><y>#</y><d>2018-08-08</d><h>21:38</h><w>mikerod</w>A likely incomplete example, but perhaps inspiration to think about.</z><z id="t1533764365000370" t="mikerod I’m not sure if you already have a custom fact-type-fn or not though. You might since I see you have a map with :weather-fact-type"><y>#</y><d>2018-08-08</d><h>21:39</h><w>mikerod</w>I’m not sure if you already have a custom <code>fact-type-fn</code> or not though. You might since I see you have a map with <code>:weather-fact-type</code></z><z id="t1533764385000053" t="mikerod Clara’s default is clojure.core/type , which is implemented as (or (get (meta x) :type) (class x))"><y>#</y><d>2018-08-08</d><h>21:39</h><w>mikerod</w>Clara’s default is <code>clojure.core/type</code>, which is implemented as <code>(or (get (meta x) :type) (class x))</code></z><z id="t1533764406000250" t="jeremy Yeah I was just thinking of a way to take Java Maps and Convert it to Keyword Key Map in the fact-type-fn?"><y>#</y><d>2018-08-08</d><h>21:40</h><w>jeremy</w>Yeah I was just thinking of a way to take Java Maps and Convert it to Keyword Key Map in the fact-type-fn?</z><z id="t1533764430000218" t="mikerod depending on what is priority, you may flip the if above and do alternative things. I was just showing the idea of what could be done at least."><y>#</y><d>2018-08-08</d><h>21:40</h><w>mikerod</w>depending on what is priority, you may flip the <code>if</code> above and do alternative things. I was just showing the idea of what could be done at least.</z><z id="t1533764431000290" t="jeremy Currently the custom fact-type-fn looks for :type or something like that. I&apos;ll have to grab the work laptop. This just came to me off the top of my head."><y>#</y><d>2018-08-08</d><h>21:40</h><w>jeremy</w>Currently the custom fact-type-fn looks for :type or something like that. I&apos;ll have to grab the work laptop. This just came to me off the top of my head.</z><z id="t1533764463000124" t="mikerod so for the fact-type-fn you just need to return the type (a keyword in your case I think)"><y>#</y><d>2018-08-08</d><h>21:41</h><w>mikerod</w>so for the <code>fact-type-fn</code> you just need to return the type (a keyword in your case I think)</z><z id="t1533764468000369" t="jeremy Yep"><y>#</y><d>2018-08-08</d><h>21:41</h><w>jeremy</w>Yep</z><z id="t1533764490000207" t="mikerod but if you want to also work with the Java data as clj maps, like this: (&lt; (:temperature this) 0) , you’d have to convert the facts themselves coming into the session"><y>#</y><d>2018-08-08</d><h>21:41</h><w>mikerod</w>but if you want to also work with the Java data as clj maps, like this: <code>(&lt; (:temperature this) 0)</code>, you’d have to convert the facts themselves coming into the session</z><z id="t1533764500000277" t="mikerod which is different than the fact-type-fn"><y>#</y><d>2018-08-08</d><h>21:41</h><w>mikerod</w>which is different than the <code>fact-type-fn</code></z><z id="t1533764525000331" t="jeremy Yeah that&apos;s how the rules work with them currently."><y>#</y><d>2018-08-08</d><h>21:42</h><w>jeremy</w>Yeah that&apos;s how the rules work with them currently.</z><z id="t1533764525000410" t="mikerod the fact-type-fn doesn’t transform the facts that are used during constraint matching. It just gives a value that is used as the “fact type” partitioning of the network"><y>#</y><d>2018-08-08</d><h>21:42</h><w>mikerod</w>the <code>fact-type-fn</code> doesn’t transform the facts that are used during constraint matching. It just gives a value that is used as the “fact type” partitioning of the network</z><z id="t1533764533000072" t="jeremy Hmm ok"><y>#</y><d>2018-08-08</d><h>21:42</h><w>jeremy</w>Hmm ok</z><z id="t1533764554000062" t="mikerod I’ve wrote Clara rules a bunch with external Java type data"><y>#</y><d>2018-08-08</d><h>21:42</h><w>mikerod</w>I’ve wrote Clara rules a bunch with external Java type data</z><z id="t1533764580000163" t="mikerod What I’ve done typically is to have some fairly basic rules to match those types and apply any sort of useful filtering if performance was a conern"><y>#</y><d>2018-08-08</d><h>21:43</h><w>mikerod</w>What I’ve done typically is to have some fairly basic rules to match those types and apply any sort of useful filtering if performance was a conern</z><z id="t1533764593000421" t="mikerod but then just had the RHS insert a clj type to use in all the rest of the rules"><y>#</y><d>2018-08-08</d><h>21:43</h><w>mikerod</w>but then just had the RHS insert a clj type to use in all the rest of the rules</z><z id="t1533764612000048" t="mikerod so the rule was sort of a transformation/mapping from Java to CLJ data structures"><y>#</y><d>2018-08-08</d><h>21:43</h><w>mikerod</w>so the rule was sort of a transformation/mapping from Java to CLJ data structures</z><z id="t1533764647000014" t="jeremy Ahh, might be a decent idea."><y>#</y><d>2018-08-08</d><h>21:44</h><w>jeremy</w>Ahh, might be a decent idea.</z><z id="t1533764705000315" t="mikerod (defrule find-java-things [JavaThing (= x ?x)] =&gt; (insert! {:fact-type :thing :x ?x})) "><y>#</y><d>2018-08-08</d><h>21:45</h><w>mikerod</w><pre>(defrule find-java-things
  [JavaThing (= x ?x)]
  =&gt;
  (insert! {:fact-type :thing
            :x ?x}))
</pre></z><z id="t1533764719000310" t="mikerod but if you need the JavaThing in the end, for the query consumer"><y>#</y><d>2018-08-08</d><h>21:45</h><w>mikerod</w>but if you need the <code>JavaThing</code> in the end, for the query consumer</z><z id="t1533764723000353" t="mikerod you can attach it to the facts"><y>#</y><d>2018-08-08</d><h>21:45</h><w>mikerod</w>you can attach it to the facts</z><z id="t1533764730000340" t="mikerod either as a first-class field, or metadata"><y>#</y><d>2018-08-08</d><h>21:45</h><w>mikerod</w>either as a first-class field, or metadata</z><z id="t1533764743000189" t="jeremy I was thinking about keeping the rules in a seperate jar. And allowing Java applications and Clojure applications import and use the rules in that jar. The question was just how to define the facts when the rules were all in Clojure and no beans were provided that allowed Java to create them."><y>#</y><d>2018-08-08</d><h>21:45</h><w>jeremy</w>I was thinking about keeping the rules in a seperate jar. And allowing Java applications and Clojure applications import and use the rules in that jar. The question was just how to define the facts when the rules were all in Clojure and no beans were provided that allowed Java to create them.</z><z id="t1533764751000291" t="mikerod (defrule find-java-things [?j &lt;- JavaThing (= x ?x)] =&gt; (insert! (with-meta {:fact-type :thing :x ?x} {:source ?j}))) "><y>#</y><d>2018-08-08</d><h>21:45</h><w>mikerod</w><pre>(defrule find-java-things
  [?j &lt;- JavaThing (= x ?x)]
  =&gt;
  (insert! (with-meta {:fact-type :thing
                       :x ?x}
             {:source ?j})))
</pre></z><z id="t1533764783000263" t="mikerod If it’s a classpath issue, where you won’t know the types ahead of time you’ll have to be more tricky"><y>#</y><d>2018-08-08</d><h>21:46</h><w>mikerod</w>If it’s a classpath issue, where you won’t know the types ahead of time you’ll have to be more tricky</z><z id="t1533764798000311" t="mikerod and also, you are going to hit reflection stuff I’d think that way"><y>#</y><d>2018-08-08</d><h>21:46</h><w>mikerod</w>and also, you are going to hit reflection stuff I’d think that way</z><z id="t1533764848000093" t="mikerod or you write your core set of rules in a type-independent rule set/session"><y>#</y><d>2018-08-08</d><h>21:47</h><w>mikerod</w>or you write your core set of rules in a type-independent rule set/session</z><z id="t1533764899000171" t="mikerod and you have to write a separate ruleset that does know about specific type mapping parts - or maybe you don’t need rules for that transformation layer at all."><y>#</y><d>2018-08-08</d><h>21:48</h><w>mikerod</w>and you have to write a separate ruleset that does know about specific type mapping parts - or maybe you don’t need rules for that transformation layer at all.</z><z id="t1533764987000218" t="jeremy I thought about just writing a interface for Java to call and create facts, insert into engine. But the rule engine itself would most likely need to be run in clojure and not instantiated from Java so it&apos;s pretty self contained. It&apos;d save me the hassle of dealing with java vs clojure types."><y>#</y><d>2018-08-08</d><h>21:49</h><w>jeremy</w>I thought about just writing a interface for Java to call and create facts, insert into engine. But the rule engine itself would most likely need to be run in clojure and not instantiated from Java so it&apos;s pretty self contained. It&apos;d save me the hassle of dealing with java vs clojure types.</z><z id="t1533765079000047" t="jeremy Java doesn&apos;t really need much control over the engine. Just to insert facts and get response from the queries."><y>#</y><d>2018-08-08</d><h>21:51</h><w>jeremy</w>Java doesn&apos;t really need much control over the engine. Just to insert facts and get response from the queries.</z><z id="t1533766182000289" t="mikerod yeah, hard to say without fully understanding the setup you have"><y>#</y><d>2018-08-08</d><h>22:09</h><w>mikerod</w>yeah, hard to say without fully understanding the setup you have</z><z id="t1533833276000231" t="wparker @jeremy642 @mikerod this might be useful in combination with Mike’s suggestion of using Java objects as facts that you could translate into Clojure objects if desired: http://www.clara-rules.org/docs/java/ Basically Clara has a wrapper that you can use instead of needing to do the interop glue work yourself. In case you weren’t already aware."><y>#</y><d>2018-08-09</d><h>16:47</h><w>wparker</w>@jeremy642 @mikerod this might be useful in combination with Mike’s suggestion of using Java objects as facts that you could translate into Clojure objects if desired: <a href="http://www.clara-rules.org/docs/java/" target="_blank">http://www.clara-rules.org/docs/java/</a> Basically Clara has a wrapper that you can use instead of needing to do the interop glue work yourself.  In case you weren’t already aware.</z><z id="t1533833384000463" t="wparker Also FYI Clara will use the bean properties on Java objects to allow field use by name in the DSL, that isn’t just for records"><y>#</y><d>2018-08-09</d><h>16:49</h><w>wparker</w>Also FYI Clara will use the bean properties on Java objects to allow field use by name in the DSL, that isn’t just for records</z><z id="t1533833439000040" t="wparker i.e. Object A has a “getB” method, you can just refer to “b” in a condition like [A (= b some-value)]"><y>#</y><d>2018-08-09</d><h>16:50</h><w>wparker</w>i.e. Object A has a “getB” method, you can just refer to “b” in a condition like [A (= b some-value)]</z><z id="t1533833469000412" t="jeremy My rules implementation does not use Java types for fact types. So the question was how to handle the interop."><y>#</y><d>2018-08-09</d><h>16:51</h><w>jeremy</w>My rules implementation does not use Java types for fact types. So the question was how to handle the interop.</z><z id="t1533833484000340" t="jeremy (defrule new-return &quot;The service is a new return.&quot; [:approval-status (= (:value this) :new-return)] =&gt; (insert! {:type :rule/result :id :new-return :priority 2}))"><y>#</y><d>2018-08-09</d><h>16:51</h><w>jeremy</w><pre>(defrule new-return
  &quot;The service is a new return.&quot;
  [:approval-status (= (:value this) :new-return)]
  =&gt;
  (insert! {:type :rule/result
            :id :new-return
            :priority 2}))</pre></z><z id="t1533833547000326" t="jeremy (r/insert {:type :approval-status :value :new-return}) is how I would insert using clojure."><y>#</y><d>2018-08-09</d><h>16:52</h><w>jeremy</w><pre>(r/insert {:type :approval-status :value :new-return})</pre> is how I would insert using clojure.</z><z id="t1533833623000524" t="jeremy Without changing the rules to beans or defining the facts with defrecords. The big ?? was how to allow Java to create maps with the keyword format that matched the rules properly."><y>#</y><d>2018-08-09</d><h>16:53</h><w>jeremy</w>Without changing the rules to beans or defining the facts with defrecords. The big ?? was how to allow Java to create maps with the keyword format that matched the rules properly.</z><z id="t1533833693000201" t="wparker Perhaps write a rule that matches on Java maps and translates them, then inserts the result? That way you could just insert the Java map into the session"><y>#</y><d>2018-08-09</d><h>16:54</h><w>wparker</w>Perhaps write a rule that matches on Java maps and translates them, then inserts the result?  That way you could just insert the Java map into the session</z><z id="t1533833732000177" t="wparker That rule could then just not do anything if only Clojure maps were in the session"><y>#</y><d>2018-08-09</d><h>16:55</h><w>wparker</w>That rule could then just not do anything if only Clojure maps  were in the session</z><z id="t1533833766000087" t="jeremy So that&apos;s one thought. I could write new rules that&apos;s sole job was to convert say a Java map if matches to a clojure map."><y>#</y><d>2018-08-09</d><h>16:56</h><w>jeremy</w>So that&apos;s one thought. I could write new rules that&apos;s sole job was to convert say a Java map if matches to a clojure map.</z><z id="t1533833849000364" t="jeremy I haven&apos;t progressed on any implementation yet. Been busy but I have some ideas to play with."><y>#</y><d>2018-08-09</d><h>16:57</h><w>jeremy</w>I haven&apos;t progressed on any implementation yet. Been busy but I have some ideas to play with.</z><z id="t1533833851000214" t="jeremy 👍"><y>#</y><d>2018-08-09</d><h>16:57</h><w>jeremy</w><b>👍</b></z><z id="t1533834146000201" t="wparker Note that Clojure maps also implement Java’s map, so you’d need to guard against an infinite loop there (i.e. require that it a Java Map but not a Clojure map)"><y>#</y><d>2018-08-09</d><h>17:02</h><w>wparker</w>Note that Clojure maps also implement Java’s map, so you’d need to guard against an infinite loop there (i.e. require that it a Java Map but not a Clojure map)</z><z id="t1533834866000465" t="jeremy Thanks"><y>#</y><d>2018-08-09</d><h>17:14</h><w>jeremy</w>Thanks</z><z id="t1533834914000471" t="jeremy I noticed that clara-rules is on the tech radar by thoughtworks. https://www.thoughtworks.com/radar/languages-and-frameworks"><y>#</y><d>2018-08-09</d><h>17:15</h><w>jeremy</w>I noticed that clara-rules is on the tech radar by thoughtworks. <a href="https://www.thoughtworks.com/radar/languages-and-frameworks" target="_blank">https://www.thoughtworks.com/radar/languages-and-frameworks</a></z><z id="t1533855444000159" t="mikerod Saw this one back when it was new on there. Pretty cool though! "><y>#</y><d>2018-08-09</d><h>22:57</h><r>mikerod</r>Saw this one back when it was new on there. Pretty cool though! </z><z id="t1533882615000016" t="henrik I’m working on an ingestion pipeline for scholarly material. It takes XML files and adds them to a (Datomic) database. There’s a ton of little decisions to be made along the way. Depending on the publisher, the type of material, the presence of related material already in the database, the subject matter, the presence or absence of a myriad of little attributes in the file itself, and so on, the ingestion process behaves differently. This means tons and tons of conditionals all over the place, and it quickly gets hard to get an overview. I’ve been contemplating ways to extract this decision making process into its own place. Would Clara be a suitable tool for this?"><y>#</y><d>2018-08-10</d><h>06:30</h><w>henrik</w>I’m working on an ingestion pipeline for scholarly material. It takes XML files and adds them to a (Datomic) database. There’s a ton of little decisions to be made along the way. Depending on the publisher, the type of material, the presence of related material already in the database, the subject matter, the presence or absence of a myriad of little attributes in the file itself, and so on, the ingestion process behaves differently.

This means tons and tons of conditionals all over the place, and it quickly gets hard to get an overview. I’ve been contemplating ways to extract this decision making process into its own place. Would Clara be a suitable tool for this?</z><z id="t1533896460000246" t="wparker @U06B8J0AJ that sounds like a plausible use-case. Much depends on how much involved the logic is - IMO a rules engine has some upfront cost to bring in especially if the team hasn’t used one before, but at a certain complexity of business logic it helps a lot. Clara does what it can to help by “playing nicely” with the rest of the Clojure ecosystem e.g. by being simple Clojure code rather than an entirely separate framework with its own IDEs etc., but it still is a different way of thinking and is a nontrivial component to introduce to a system. FWIW the analysis in the ThoughtWorks radar linked above seems on-target to me. My guess would be that something like you describe would work best with a rules engine if large chunks of logic can be computed before needing to return to the stateful pipeline, but as always it is hard to say since so often it is the details that are most important."><y>#</y><d>2018-08-10</d><h>10:21</h><r>wparker</r>@U06B8J0AJ that sounds like a plausible use-case.  Much depends on how much involved the logic is - IMO a rules engine has some upfront cost to bring in especially if the team hasn’t used one before, but at a certain complexity of business logic it helps a lot.  Clara does what it can to help by “playing nicely” with the rest of the Clojure ecosystem e.g. by being simple Clojure code rather than an entirely separate framework with its own IDEs etc., but it still is a different way of thinking and is a nontrivial component to introduce to a system.  FWIW the analysis in the ThoughtWorks radar linked above seems on-target to me.  My guess would be that something like you describe would work best with a rules engine if large chunks of logic can be computed before needing to return to the stateful pipeline, but as always it is hard to say since so often it is the details that are most important.</z><z id="t1533923402000302" t="devn howdy folks"><y>#</y><d>2018-08-10</d><h>17:50</h><w>devn</w>howdy folks</z><z id="t1533923407000322" t="devn im interested in partial condition matches"><y>#</y><d>2018-08-10</d><h>17:50</h><w>devn</w>im interested in partial condition matches</z><z id="t1533923434000063" t="devn i want to answer the question: what conditions didn&apos;t match for a given rule"><y>#</y><d>2018-08-10</d><h>17:50</h><w>devn</w>i want to answer the question: what conditions didn&apos;t match for a given rule</z><z id="t1533923472000234" t="devn i&apos;m not sure this is possible at the moment"><y>#</y><d>2018-08-10</d><h>17:51</h><w>devn</w>i&apos;m not sure this is possible at the moment</z><z id="t1533929422000026" t="wparker Could you give a concrete example @devn? I&apos;m not sure what exactly you mean; session inspection has some things that might help."><y>#</y><d>2018-08-10</d><h>19:30</h><w>wparker</w>Could you give a concrete example @devn?  I&apos;m not sure what exactly you mean; session inspection has some things that might help.</z><z id="t1533931776000142" t="devn @wparker I&apos;m looking to answer questions of &quot;what LHS conditions for which rules weren&apos;t satisfiable?&quot; My understanding may be incorrect, but I seem to recall the condition matches from session inspection not including information on when a rule&apos;s conditions were partially satisfied."><y>#</y><d>2018-08-10</d><h>20:09</h><w>devn</w>@wparker I&apos;m looking to answer questions of &quot;what LHS conditions for which rules weren&apos;t satisfiable?&quot;

My understanding may be incorrect, but I seem to recall the condition matches from session inspection not including information on when a rule&apos;s conditions were partially satisfied.</z><z id="t1533931823000289" t="devn truth: I keep avoiding working out a tracing listener setup that will give me the Real Ultimate Power™ I desire"><y>#</y><d>2018-08-10</d><h>20:10</h><w>devn</w>truth: I keep avoiding working out a tracing listener setup that will give me the Real Ultimate Power™ I desire</z><z id="t1533931931000161" t="devn @alex-dixon I am reminded of a previous conversation that was had here about making something akin to precept-devtools work with clara. However, I am failing to remember details. Which parts of precept-devtools would not be possible without modification to clara?"><y>#</y><d>2018-08-10</d><h>20:12</h><w>devn</w>@alex-dixon I am reminded of a previous conversation that was had here about making something akin to precept-devtools work with clara. However, I am failing to remember details. Which parts of precept-devtools would not be possible without modification to clara?</z><z id="t1533933845000330" t="alex-dixon @devn Pretty much all of it would need redone since it’s so Precept specific…"><y>#</y><d>2018-08-10</d><h>20:44</h><w>alex-dixon</w>@devn Pretty much all of it would need redone since it’s so Precept specific…</z><z id="t1533933911000136" t="alex-dixon Clara’s listeners API is what you’re looking for though. You should be able to see every operation the rule engine does"><y>#</y><d>2018-08-10</d><h>20:45</h><w>alex-dixon</w>Clara’s listeners API is what you’re looking for though. You should be able to see every operation the rule engine does</z><z id="t1533933954000002" t="alex-dixon I’ve only ever used the terminal node ones but they have everything…alpha activate, alpha retract…stuff I can’t remember"><y>#</y><d>2018-08-10</d><h>20:45</h><w>alex-dixon</w>I’ve only ever used the terminal node ones but they have everything…alpha activate, alpha retract…stuff I can’t remember</z><z id="t1533933974000333" t="alex-dixon If you’re interested in CR or rule engines whatsoever it’ll pay off I promise 🙂"><y>#</y><d>2018-08-10</d><h>20:46</h><w>alex-dixon</w>If you’re interested in CR or rule engines whatsoever it’ll pay off I promise <b>🙂</b></z><z id="t1534115678000073" t="devn @alex-dixon thanks for the reply. My coworkers and I are working on a (for now) private library called carla. We have a graph view and a rule summary view, a “who produces” and “who depends on” for facts. A tracing listener is coming."><y>#</y><d>2018-08-12</d><h>23:14</h><w>devn</w>@alex-dixon thanks for the reply. My coworkers and I are working on a (for now) private library called carla. We have a graph view and a rule summary view, a “who produces” and “who depends on” for facts. A tracing listener is coming.</z><z id="t1534115760000017" t="devn The question that is most useful to answer for us is often “why didn’t this occur?” (Aka what is the chain of dependent rules that weren’t satisfied, with a root cause)"><y>#</y><d>2018-08-12</d><h>23:16</h><w>devn</w>The question that is most useful to answer for us is often “why didn’t this occur?” (Aka what is the chain of dependent rules that weren’t satisfied, with a root cause)</z><z id="t1534115819000064" t="devn I’m reading a lot of precept code this weekend. Thanks again for putting out a great example of what can be achieved with tooling."><y>#</y><d>2018-08-12</d><h>23:16</h><w>devn</w>I’m reading a lot of precept code this weekend. Thanks again for putting out a great example of what can be achieved with tooling.</z><z id="t1534121970000076" t="alex-dixon @devn rofl Carla "><y>#</y><d>2018-08-13</d><h>00:59</h><w>alex-dixon</w>@devn rofl Carla </z><z id="t1534122015000108" t="devn It makes requires confusing, but hilarious "><y>#</y><d>2018-08-13</d><h>01:00</h><w>devn</w>It makes requires confusing, but hilarious </z><z id="t1534122035000094" t="alex-dixon That sounds awesome. Hickey had a recent podcast interview where he seemed to emphasize the role of what a thing provides and what it requires "><y>#</y><d>2018-08-13</d><h>01:00</h><w>alex-dixon</w>That sounds awesome. Hickey had a recent podcast interview where he seemed to emphasize the role of what a thing provides and what it requires </z><z id="t1534122424000098" t="alex-dixon Testing for a rule not firing seems hard but important from a practical standpoint "><y>#</y><d>2018-08-13</d><h>01:07</h><w>alex-dixon</w>Testing for a rule not firing seems hard but important from a practical standpoint </z><z id="t1534122463000039" t="alex-dixon From a more impractical one I guess we shouldn’t be writing rules expecting them to fire"><y>#</y><d>2018-08-13</d><h>01:07</h><w>alex-dixon</w>From a more impractical one I guess we shouldn’t be writing rules expecting them to fire</z><z id="t1534502316000100" t="Petrus Theron @henrik I&apos;m using Clara for something similar (low-cost housing bond approval process) and I&apos;m curious how you are modelling things like review/verification requests"><y>#</y><d>2018-08-17</d><h>10:38</h><w>Petrus Theron</w>@henrik I&apos;m using Clara for something similar (low-cost housing bond approval process) and I&apos;m curious how you are modelling things like review/verification requests</z><z id="t1534502343000100" t="Petrus Theron e.g. certain kinds of documents need to be reviewed and/or signed by certain kinds of people (e.g. Mortgage Lawyer, vs Transfer Lawyer)"><y>#</y><d>2018-08-17</d><h>10:39</h><w>Petrus Theron</w>e.g. certain kinds of documents need to be reviewed and/or signed by certain kinds of people (e.g. Mortgage Lawyer, vs Transfer Lawyer)</z><z id="t1534516659000100" t="Petrus Theron Is anyone using Clara or FactUI on its own, but with Datomic purely as a persistence layer? I&apos;m dealing with really small-scale volume of records, I just want rapid dev and flexible workflows."><y>#</y><d>2018-08-17</d><h>14:37</h><w>Petrus Theron</w>Is anyone using Clara or FactUI on its own, but with Datomic purely as a persistence layer? I&apos;m dealing with really small-scale volume of records, I just want rapid dev and flexible workflows.</z><z id="t1534522981000100" t="mikerod @petrus I don’t understand what you are asking for there. Do you mean to store the state of the rule network working memory or just the resulting facts?"><y>#</y><d>2018-08-17</d><h>16:23</h><w>mikerod</w>@petrus I don’t understand what you are asking for there. Do you mean to store the state of the rule network working memory or just the resulting facts?</z><z id="t1534522991000100" t="mikerod The resulting facts, can be whatever you want and stored wherever you want."><y>#</y><d>2018-08-17</d><h>16:23</h><w>mikerod</w>The resulting facts, can be whatever you want and stored wherever you want.</z><z id="t1534523017000100" t="mikerod So I think you may be asking about persisting the state of the rule network’s working memory, but not sure if that’s what you meant."><y>#</y><d>2018-08-17</d><h>16:23</h><w>mikerod</w>So I think you may be asking about persisting the state of the rule network’s working memory, but not sure if that’s what you meant.</z><z id="t1534702491000100" t="clyfe ANN https://github.com/clyfe/clara-eav"><y>#</y><d>2018-08-19</d><h>18:14</h><w>clyfe</w>ANN <a href="https://github.com/clyfe/clara-eav" target="_blank">https://github.com/clyfe/clara-eav</a></z><z id="t1534702502000100" t="clyfe ClaraEAV is a thin layer over Clara-Rules API that simplifies working with EAV triplets"><y>#</y><d>2018-08-19</d><h>18:15</h><w>clyfe</w>ClaraEAV is a thin layer over Clara-Rules API that simplifies working with EAV triplets</z><z id="t1534702547000100" t="clyfe Main benefit is updates are local to the attribute, maybe some of you find it useful."><y>#</y><d>2018-08-19</d><h>18:15</h><w>clyfe</w>Main benefit is updates are local to the attribute, maybe some of you find it useful.</z><z id="t1534709131000100" t="mikerod @claudius.nicolae nice. I’ll have to take a look at that some more but seems pretty cool. I’ve heard of people using(or wanting to) EAV data in Clara and this looks like it can help"><y>#</y><d>2018-08-19</d><h>20:05</h><w>mikerod</w>@claudius.nicolae nice. I’ll have to take a look at that some more but seems pretty cool. I’ve heard of people using(or wanting to) EAV data in Clara and this looks like it can help</z><z id="t1534709344000100" t="clyfe Thanks! Credit mainly goes to the precept project, mine is just a rehash. Nevertheless it may be of use."><y>#</y><d>2018-08-19</d><h>20:09</h><w>clyfe</w>Thanks! Credit mainly goes to the precept project, mine is just a rehash. Nevertheless it may be of use.</z><z id="t1534709560000100" t="clyfe The guide explains it all pretty well https://cljdoc.xyz/d/clyfe/clara-eav/0.1.5/doc/guide"><y>#</y><d>2018-08-19</d><h>20:12</h><w>clyfe</w>The guide explains it all pretty well <a href="https://cljdoc.xyz/d/clyfe/clara-eav/0.1.5/doc/guide" target="_blank">https://cljdoc.xyz/d/clyfe/clara-eav/0.1.5/doc/guide</a></z><z id="t1534715766000100" t="mikerod Oh nice. I’ll read it. And yeah I knew Precept had done some interesting stuff around this. "><y>#</y><d>2018-08-19</d><h>21:56</h><w>mikerod</w>Oh nice. I’ll read it. And yeah I knew Precept had done some interesting stuff around this. </z><z id="t1536256121000100" t="mikerod @claudius.nicolae (I believe you were the one who introduced this, but history has lost it) I finally read through the docs of https://github.com/clyfe/clara-eav . I think it looks cool. I plan to read through some of the impl some to see how you’ve accomplished some of this. I think the EAV-as-facts concept is a good one, especially in the Clojure community it seems. I know libs like precept have been doing it a while. It’s good to see a standalone impl now."><y>#</y><d>2018-09-06</d><h>17:48</h><w>mikerod</w>@claudius.nicolae (I believe you were the one who introduced this, but history has lost it) I finally read through the docs of <a href="https://github.com/clyfe/clara-eav" target="_blank">https://github.com/clyfe/clara-eav</a> . I think it looks cool. I plan to read through some of the impl some to see how you’ve accomplished some of this. I think the EAV-as-facts concept is a good one, especially in the Clojure community it seems. I know libs like <code>precept</code> have been doing it a while. It’s good to see a standalone impl now.</z><z id="t1538689598000100" t="ryanbrush Just a heads up: we&apos;ve had a number of performance improvements and bug fixes merged to master since our last release, so it seems worthwhile to push another one. Unless there are objections, I&apos;ll plan on pushing 0.19.0 out of master in the near future."><y>#</y><d>2018-10-04</d><h>21:46</h><w>ryanbrush</w>Just a heads up: we&apos;ve had a number of performance improvements and bug fixes merged to master since our last release, so it seems worthwhile to push another one. Unless there are objections, I&apos;ll plan on pushing 0.19.0 out of master in the near future.</z><z id="t1538693899000100" t="ryanbrush And Clara 0.19.0 is released and up on Clojars! You can see the changelog for details: https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md"><y>#</y><d>2018-10-04</d><h>22:58</h><w>ryanbrush</w>And Clara 0.19.0 is released and up on Clojars! You can see the changelog for details: <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md</a></z><z id="t1540303649000100" t="dhruv1 hello. In clara, how can i write recursive queries?"><y>#</y><d>2018-10-23</d><h>14:07</h><w>dhruv1</w>hello.

In clara, how can i write recursive queries?</z><z id="t1540303664000100" t="dhruv1 here is an example of the data I have:"><y>#</y><d>2018-10-23</d><h>14:07</h><w>dhruv1</w>here is an example of the data I have:</z><z id="t1540303671000100" t="dhruv1 {:type :foo :desc &quot;&apos;Foo&apos; node&quot; :parent :D} {:type :D :desc &quot;&apos;D&apos; node&quot; :parent :C} {:type :C :desc &quot;&apos;C&apos; node&quot; :parent :B} {:type :B :desc &quot;&apos;B&apos; node&quot; :parent :A} {:type :A :desc &quot;&apos;A&apos; node&quot;}"><y>#</y><d>2018-10-23</d><h>14:07</h><w>dhruv1</w><pre>{:type :foo
 :desc &quot;&apos;Foo&apos; node&quot;
 :parent :D}

{:type :D
 :desc &quot;&apos;D&apos; node&quot;
 :parent :C}

{:type :C
 :desc &quot;&apos;C&apos; node&quot;
 :parent :B}

{:type :B
 :desc &quot;&apos;B&apos; node&quot;
 :parent :A}

{:type :A
 :desc &quot;&apos;A&apos; node&quot;}</pre></z><z id="t1540303782000100" t="dhruv1 here is what i would like the output of the query to look like:"><y>#</y><d>2018-10-23</d><h>14:09</h><w>dhruv1</w>here is what i would like the output of the query to look like:</z><z id="t1540303800000100" t="dhruv1 &apos;(:?node {:type :foo :desc &quot;&apos;Foo&apos; node&quot; :parent :D} :?parents [{:type :D :desc &quot;&apos;D&apos; node&quot; :parent :C} {:type :C :desc &quot;&apos;C&apos; node&quot; :parent :B} {:type :B :desc &quot;&apos;B&apos; node&quot; :parent :A} {:type :A :desc &quot;&apos;A&apos; node&quot;}])"><y>#</y><d>2018-10-23</d><h>14:10</h><w>dhruv1</w><pre>&apos;(:?node {:type :foo
          :desc &quot;&apos;Foo&apos; node&quot;
          :parent :D}
         
       :?parents [{:type :D
                      :desc &quot;&apos;D&apos; node&quot;
                     :parent :C}

                    {:type :C
                     :desc &quot;&apos;C&apos; node&quot;
                     :parent :B}

                    {:type :B
                     :desc &quot;&apos;B&apos; node&quot;
                     :parent :A}

                    {:type :A
                     :desc &quot;&apos;A&apos; node&quot;}])</pre></z><z id="t1540303911000100" t="dhruv1 is this possible with a clara query?"><y>#</y><d>2018-10-23</d><h>14:11</h><w>dhruv1</w>is this possible with a clara query?</z><z id="t1540309654000100" t="eraserhd Not with just a query, you&apos;ll need to introduce some facts."><y>#</y><d>2018-10-23</d><h>15:47</h><w>eraserhd</w>Not with just a query, you&apos;ll need to introduce some facts.</z><z id="t1540309874000100" t="eraserhd So you&apos;d have one rule that&apos;s (heavily abbreviating the code): [:test (no-children? ?node)] =&gt; (insert! (-&gt;TreeRep ?node ?node))). And one that&apos;s [:test (children? ?node)] ?children &lt;- (acc/all) :from [Node (= parent ?node)] =&gt; (insert! (-&gt;TreeRep ?node (add-children ?node ?children)))."><y>#</y><d>2018-10-23</d><h>15:51</h><w>eraserhd</w>So you&apos;d have one rule that&apos;s (heavily abbreviating the code): [:test (no-children? ?node)] =&gt; (insert! (-&gt;TreeRep ?node ?node))).  And one that&apos;s [:test (children? ?node)]  ?children &lt;- (acc/all) :from [Node (= parent ?node)] =&gt; (insert! (-&gt;TreeRep ?node (add-children ?node ?children))).</z><z id="t1540309933000100" t="eraserhd Assuming your graph is acyclic. If it isn&apos;t, this will be bad."><y>#</y><d>2018-10-23</d><h>15:52</h><w>eraserhd</w>Assuming your graph is acyclic.  If it isn&apos;t, this will be bad.</z><z id="t1540310012000100" t="eraserhd It might be doable with one rule, actually. But the point is, AFAICT, there&apos;s no way to recurse without inserting facts."><y>#</y><d>2018-10-23</d><h>15:53</h><w>eraserhd</w>It might be doable with one rule, actually.  But the point is, AFAICT, there&apos;s no way to recurse without inserting facts.</z><z id="t1540310510000100" t="dhruv1 Ah understood. "><y>#</y><d>2018-10-23</d><h>16:01</h><w>dhruv1</w>Ah understood.  </z><z id="t1540310524000100" t="dhruv1 Will give that a go. Thank you!"><y>#</y><d>2018-10-23</d><h>16:02</h><w>dhruv1</w>Will give that a go. Thank you!</z><z id="t1540311178000100" t="eraserhd Oh, you want to (acc/all) :from [TreeRep ...], probably."><y>#</y><d>2018-10-23</d><h>16:12</h><w>eraserhd</w>Oh, you want to (acc/all) :from [TreeRep ...], probably.</z><z id="t1540311214000100" t="eraserhd You could also do this with a custom accumulator, but that would be much harder, I&apos;m guessing."><y>#</y><d>2018-10-23</d><h>16:13</h><w>eraserhd</w>You could also do this with a custom accumulator, but that would be much harder, I&apos;m guessing.</z><z id="t1540311370000100" t="mikerod @eraserhd I was thinking along those same lines"><y>#</y><d>2018-10-23</d><h>16:16</h><w>mikerod</w>@eraserhd I was thinking along those same lines</z><z id="t1540311378000100" t="mikerod about having to introduce some facts to model it"><y>#</y><d>2018-10-23</d><h>16:16</h><w>mikerod</w>about having to introduce some facts to model it</z><z id="t1540311940000100" t="eraserhd By the way, 👋 clara people! We are starting to rely heavily on this for work, and it is a good thing."><y>#</y><d>2018-10-23</d><h>16:25</h><w>eraserhd</w>By the way, <b>👋</b> clara people!  We are starting to rely heavily on this for work, and it is a good thing.</z><z id="t1540314249000100" t="mikerod Nice. What sort of things are you using it for (if you can say) and clj or cljs? "><y>#</y><d>2018-10-23</d><h>17:04</h><r>mikerod</r>Nice. What sort of things are you using it for (if you can say) and clj or cljs? </z><z id="t1540314969000100" t="eraserhd clj, only"><y>#</y><d>2018-10-23</d><h>17:16</h><r>eraserhd</r>clj, only</z><z id="t1540315010000100" t="eraserhd We are storing data in Datomic, and importing the facts, and deriving a bunch of stuff from them."><y>#</y><d>2018-10-23</d><h>17:16</h><r>eraserhd</r>We are storing data in Datomic, and importing the facts, and deriving a bunch of stuff from them.</z><z id="t1540315033000100" t="eraserhd This includes constraint validation, what we are calling &quot;synthetic attributes&quot;, which are computed attributes."><y>#</y><d>2018-10-23</d><h>17:17</h><r>eraserhd</r>This includes constraint validation, what we are calling &quot;synthetic attributes&quot;, which are computed attributes.</z><z id="t1540315056000100" t="eraserhd This is all business data about the online degree programs we are hosting."><y>#</y><d>2018-10-23</d><h>17:17</h><r>eraserhd</r>This is all business data about the online degree programs we are hosting.</z><z id="t1540315070000100" t="eraserhd And this system drives the stand up of new systems."><y>#</y><d>2018-10-23</d><h>17:17</h><r>eraserhd</r>And this system drives the stand up of new systems.</z><z id="t1540315237000100" t="mikerod oh that’s cool"><y>#</y><d>2018-10-23</d><h>17:20</h><r>mikerod</r>oh that’s cool</z><z id="t1540315269000100" t="mikerod there was a datomic “datom” integration lib with clara"><y>#</y><d>2018-10-23</d><h>17:21</h><r>mikerod</r>there was a datomic “datom” integration lib with clara</z><z id="t1540315274000100" t="mikerod was that related or something you’ve seen?"><y>#</y><d>2018-10-23</d><h>17:21</h><r>mikerod</r>was that related or something you’ve seen?</z><z id="t1540315322000100" t="eraserhd We built our own, and we have a library we are attempting to Open Source :crossed_fingers:"><y>#</y><d>2018-10-23</d><h>17:22</h><r>eraserhd</r>We built our own, and we have a library we are attempting to Open Source <b>:crossed_fingers:</b></z><z id="t1540315337000100" t="eraserhd Not specifically about Datoms"><y>#</y><d>2018-10-23</d><h>17:22</h><r>eraserhd</r>Not specifically about Datoms</z><z id="t1540315368000100" t="mikerod ah ok"><y>#</y><d>2018-10-23</d><h>17:22</h><r>mikerod</r>ah ok</z><z id="t1540315379000100" t="mikerod I’m trying to find the github link I had for that before, but was interesting"><y>#</y><d>2018-10-23</d><h>17:22</h><r>mikerod</r>I’m trying to find the github link I had for that before, but was interesting</z><z id="t1540315387000100" t="mikerod but would be really interesting if you open sourced hah"><y>#</y><d>2018-10-23</d><h>17:23</h><r>mikerod</r>but would be really interesting if you open sourced hah</z><z id="t1540315407000100" t="mikerod ah yeah, it was this clara-eav https://github.com/clyfe/clara-eav"><y>#</y><d>2018-10-23</d><h>17:23</h><r>mikerod</r>ah yeah, it was this clara-eav <a href="https://github.com/clyfe/clara-eav" target="_blank">https://github.com/clyfe/clara-eav</a></z><z id="t1540316102000100" t="eraserhd @U0LK1552A This actually looks pretty neat. Our library does a different thing, regarding bulk loading facts from datomic and caching intermediate sessions to save work. It seems like we could use them together."><y>#</y><d>2018-10-23</d><h>17:35</h><r>eraserhd</r>@U0LK1552A This actually looks pretty neat.  Our library does a different thing, regarding bulk loading facts from datomic and caching intermediate sessions to save work.  It seems like we could use them together.</z><z id="t1540316377000100" t="mikerod interesting"><y>#</y><d>2018-10-23</d><h>17:39</h><r>mikerod</r>interesting</z><z id="t1540316383000100" t="mikerod caching intermediate sessions seems interesting too"><y>#</y><d>2018-10-23</d><h>17:39</h><r>mikerod</r>caching intermediate sessions seems interesting too</z><z id="t1540316388000100" t="mikerod seems like some durability stuff I messed with before"><y>#</y><d>2018-10-23</d><h>17:39</h><r>mikerod</r>seems like some durability stuff I messed with before</z><z id="t1540316400000100" t="mikerod (well I wrote that stuff in clara originally to try some things out)"><y>#</y><d>2018-10-23</d><h>17:40</h><r>mikerod</r>(well I wrote that stuff in clara originally to try some things out)</z><z id="t1540388542000100" t="eraserhd I found a paper about the LEAPS algorithm, which apparently out-performs RETE by using gasp laziness. I wonder if any LEAPS stuff was incorporated into Clara?"><y>#</y><d>2018-10-24</d><h>13:42</h><w>eraserhd</w>I found a paper about the LEAPS algorithm, which apparently out-performs RETE by using gasp laziness.  I wonder if any LEAPS stuff was incorporated into Clara?</z><z id="t1540388602000100" t="eraserhd This one: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.5371&amp;amp;rep=rep1&amp;amp;type=pdf"><y>#</y><d>2018-10-24</d><h>13:43</h><w>eraserhd</w>This one: <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.5371&amp;amp;rep=rep1&amp;amp;type=pdf" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.5371&amp;amp;rep=rep1&amp;amp;type=pdf</a></z><z id="t1540389738000100" t="mikerod @eraserhd I don’t see the date on this some reason"><y>#</y><d>2018-10-24</d><h>14:02</h><w>mikerod</w>@eraserhd I don’t see the date on this some reason</z><z id="t1540389766000100" t="eraserhd It&apos;s old, like 94 or something."><y>#</y><d>2018-10-24</d><h>14:02</h><w>eraserhd</w>It&apos;s old, like 94 or something.</z><z id="t1540389769000100" t="mikerod but I know I’ve read about LEAPS before."><y>#</y><d>2018-10-24</d><h>14:02</h><w>mikerod</w>but I know I’ve read about LEAPS before.</z><z id="t1540389787000100" t="mikerod It is comparing to the traditional rete used in the OPS5 and perhaps a few others at the time"><y>#</y><d>2018-10-24</d><h>14:03</h><w>mikerod</w>It is comparing to the traditional rete used in the OPS5 and perhaps a few others at the time</z><z id="t1540389794000100" t="mikerod things were quite a bit different in those I believe"><y>#</y><d>2018-10-24</d><h>14:03</h><w>mikerod</w>things were quite a bit different in those I believe</z><z id="t1540389805000100" t="mikerod Clara takes advantage of batch-oriented fact propagation"><y>#</y><d>2018-10-24</d><h>14:03</h><w>mikerod</w>Clara takes advantage of batch-oriented fact propagation</z><z id="t1540389831000100" t="mikerod I am of the opinion that that is the biggest perf win"><y>#</y><d>2018-10-24</d><h>14:03</h><w>mikerod</w>I am of the opinion that that is the biggest perf win</z><z id="t1540389860000100" t="mikerod over any sort of laziness. However, Drools (popular JVM/Java based rules engine) went to a custom algo they decided was sufficiently different enough to get a new name"><y>#</y><d>2018-10-24</d><h>14:04</h><w>mikerod</w>over any sort of laziness. However, Drools (popular JVM/Java based rules engine) went to a custom algo they decided was sufficiently different enough to get a new name</z><z id="t1540389863000100" t="mikerod “PHREAK”"><y>#</y><d>2018-10-24</d><h>14:04</h><w>mikerod</w>“PHREAK”</z><z id="t1540389871000100" t="mikerod in Drools 6, they wrote some good stuff on it"><y>#</y><d>2018-10-24</d><h>14:04</h><w>mikerod</w>in Drools 6, they wrote some good stuff on it</z><z id="t1540389888000100" t="mikerod but it was meant to be lazier and to do things like cut parts of the rete tree off when they aren’t needed"><y>#</y><d>2018-10-24</d><h>14:04</h><w>mikerod</w>but it was meant to be lazier and to do things like cut parts of the rete tree off when they aren’t needed</z><z id="t1540389916000100" t="mikerod the unfortunate part of that upgrade was that Drools went from eager and single fact propagation to this lazier and batched propagation"><y>#</y><d>2018-10-24</d><h>14:05</h><w>mikerod</w>the unfortunate part of that upgrade was that Drools went from eager and single fact propagation to this lazier and batched propagation</z><z id="t1540389922000100" t="mikerod and I think the batching is the bigger win"><y>#</y><d>2018-10-24</d><h>14:05</h><w>mikerod</w>and I think the batching is the bigger win</z><z id="t1540389945000100" t="mikerod So the topic of being lazier in Clara has came up before"><y>#</y><d>2018-10-24</d><h>14:05</h><w>mikerod</w>So the topic of being lazier in Clara has came up before</z><z id="t1540389972000100" t="mikerod but hasn’t been done since it isn’t clear how much you really gain from that over the batched propagations."><y>#</y><d>2018-10-24</d><h>14:06</h><w>mikerod</w>but hasn’t been done since it isn’t clear how much you really gain from that over the batched propagations.</z><z id="t1540389985000100" t="mikerod that is assuming you have queries that you intend to use"><y>#</y><d>2018-10-24</d><h>14:06</h><w>mikerod</w>that is assuming you have queries that you intend to use</z><z id="t1540390011000200" t="mikerod if you had like 10 queries and were only going to want to perform 1 of them a lot of the time or something like that, then there may be a bigger win to delaying things"><y>#</y><d>2018-10-24</d><h>14:06</h><w>mikerod</w>if you had like 10 queries and were only going to want to perform 1 of them a lot of the time or something like that, then there may be a bigger win to delaying things</z><z id="t1540390011000300" t="eraserhd I&apos;m only a little way in, and I haven&apos;t seen the laziness part yet (even though it&apos;s claimed in the abstract). It so far has claimed that the biggest win is not needing to materialize facts in memory. I don&apos;t understand it yet."><y>#</y><d>2018-10-24</d><h>14:06</h><w>eraserhd</w>I&apos;m only a little way in, and I haven&apos;t seen the laziness part yet (even though it&apos;s claimed in the abstract).  It so far has claimed that the biggest win is not needing to materialize facts in memory.  I don&apos;t understand it yet.</z><z id="t1540390026000100" t="mikerod also, keep in mind, these older papers"><y>#</y><d>2018-10-24</d><h>14:07</h><w>mikerod</w>also, keep in mind, these older papers</z><z id="t1540390037000100" t="mikerod they have some good material for sure, but have to be aware of the environments there were dealing with"><y>#</y><d>2018-10-24</d><h>14:07</h><w>mikerod</w>they have some good material for sure, but have to be aware of the environments there were dealing with</z><z id="t1540390077000100" t="mikerod e.g. sometimes they are really emphasizing using minimal memory (was more constrained then), or higher allocation costs etc"><y>#</y><d>2018-10-24</d><h>14:07</h><w>mikerod</w>e.g. sometimes they are really emphasizing using minimal memory (was more constrained then), or higher allocation costs etc</z><z id="t1540390101000100" t="mikerod it’s just something to be aware of, still good material out there and most of it is pretty old"><y>#</y><d>2018-10-24</d><h>14:08</h><w>mikerod</w>it’s just something to be aware of, still good material out there and most of it is pretty old</z><z id="t1540390139000200" t="mikerod also, sometimes things are explaining a situation that is most helpful when dealing with a large number of rules, other times its for dealing with a large number of facts, and occasionally perhaps a large number of both is discussed"><y>#</y><d>2018-10-24</d><h>14:08</h><w>mikerod</w>also, sometimes things are explaining a situation that is most helpful when dealing with a large number of rules, other times its for dealing with a large number of facts, and occasionally perhaps a large number of both is discussed</z><z id="t1540390161000100" t="eraserhd yup. But I read things like this as a hobby, honestly."><y>#</y><d>2018-10-24</d><h>14:09</h><w>eraserhd</w>yup.  But I read things like this as a hobby, honestly.</z><z id="t1540390174000100" t="eraserhd I&apos;m not suddenly suggesting that we must implement this 😄"><y>#</y><d>2018-10-24</d><h>14:09</h><w>eraserhd</w>I&apos;m not suddenly suggesting that we must implement this <b>😄</b></z><z id="t1540390196000200" t="mikerod no, it’s good to discuss and to think about"><y>#</y><d>2018-10-24</d><h>14:09</h><w>mikerod</w>no, it’s good to discuss and to think about</z><z id="t1540390198000100" t="eraserhd In fact, it would be neat if there was a bibliography for Clara Rules."><y>#</y><d>2018-10-24</d><h>14:09</h><w>eraserhd</w>In fact, it would be neat if there was a bibliography for Clara Rules.</z><z id="t1540390224000100" t="mikerod quite a bit of perf-related work has been done in Clara already"><y>#</y><d>2018-10-24</d><h>14:10</h><w>mikerod</w>quite a bit of perf-related work has been done in Clara already</z><z id="t1540390245000200" t="mikerod some of that was just impl details and other things were tweaks to propagation or often accumulators"><y>#</y><d>2018-10-24</d><h>14:10</h><w>mikerod</w>some of that was just impl details and other things were tweaks to propagation or often accumulators</z><z id="t1540390285000100" t="eraserhd Neat... I got that impression. It performs super well for us."><y>#</y><d>2018-10-24</d><h>14:11</h><w>eraserhd</w>Neat... I got that impression.  It performs super well for us.</z><z id="t1540486518000100" t="wparker @eraserhd Agreed with @U0LK1552A’s previous comments - Another interesting way that this played out (both myself and Mike spent a while doing perf optimizations on Clara) is that in practice, it turned out that even for large cases (hundreds of thousands of facts/tens of thousands of rules) the constant factors seemed to be most important. Hashing turned out to be a large percentage of work performed for example. A lot of these optimizations (on the Clojure side) are in the memory.cljc namespace with lots of Java interop etc. That said, this was in use-cases where we didn’t really have lots of data that we were just going to end up discarding, and there’s definitely cases where more laziness could be useful."><y>#</y><d>2018-10-25</d><h>16:55</h><r>wparker</r>@eraserhd Agreed with @U0LK1552A’s previous comments - Another interesting way that this played out (both myself and Mike spent a while doing perf optimizations on Clara) is that in practice, it turned out that even for large cases (hundreds of thousands of facts/tens of thousands of rules) the constant factors seemed to be most important.  Hashing turned out to be a large percentage of work performed for example.  A lot of these optimizations (on the Clojure side) are in the memory.cljc namespace with lots of Java interop etc.  That said, this was in use-cases where we didn’t really have lots of data that we were just going to end up discarding, and there’s definitely cases where more laziness could be useful.</z><z id="t1540390320000100" t="mikerod Clara make some small mention to background here https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine"><y>#</y><d>2018-10-24</d><h>14:12</h><w>mikerod</w>Clara make some small mention to background here <a href="https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine" target="_blank">https://github.com/cerner/clara-rules/wiki/Introduction#the-rules-engine</a></z><z id="t1540390334000100" t="mikerod The paper referenced there is http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf"><y>#</y><d>2018-10-24</d><h>14:12</h><w>mikerod</w>The paper referenced there is <a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" target="_blank">http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</a></z><z id="t1540390371000100" t="mikerod It is concerned with the ops system I think. It’s long and not all that relevant to current stuff, but there are some nice fundamental chapters in it"><y>#</y><d>2018-10-24</d><h>14:12</h><w>mikerod</w>It is concerned with the ops system I think. It’s long and not all that relevant to current stuff, but there are some nice fundamental chapters in it</z><z id="t1540390393000100" t="mikerod Starts with a very basic description of a simple rete impl, and then discusses some interesting ways to improve it, such as left and right unlinking"><y>#</y><d>2018-10-24</d><h>14:13</h><w>mikerod</w>Starts with a very basic description of a simple rete impl, and then discusses some interesting ways to improve it, such as left and right unlinking</z><z id="t1540390442000100" t="mikerod and Drools has a lot of extra stuff going on that is left out of Clara, but they do have some good docs on approaches https://docs.jboss.org/drools/release/6.2.0.CR2/drools-docs/html/HybridReasoningChapter.html#ReteOO"><y>#</y><d>2018-10-24</d><h>14:14</h><w>mikerod</w>and Drools has a lot of extra stuff going on that is left out of Clara, but they do have some good docs on approaches <a href="https://docs.jboss.org/drools/release/6.2.0.CR2/drools-docs/html/HybridReasoningChapter.html#ReteOO" target="_blank">https://docs.jboss.org/drools/release/6.2.0.CR2/drools-docs/html/HybridReasoningChapter.html#ReteOO</a></z><z id="t1540390573000100" t="mikerod That’s their newer one. Not the same as Clara, but there are some commonalities in some the ideas. It also may explain some of the deficiencies in the overly simple approach traditionally taken."><y>#</y><d>2018-10-24</d><h>14:16</h><w>mikerod</w>That’s their newer one. Not the same as Clara, but there are some commonalities in some the ideas. It also may explain some of the deficiencies in the overly simple approach traditionally taken.</z><z id="t1540391216000100" t="eraserhd Nice, thank you! I&apos;ve queued all that up for bedtime reading."><y>#</y><d>2018-10-24</d><h>14:26</h><w>eraserhd</w>Nice, thank you!  I&apos;ve queued all that up for bedtime reading.</z><z id="t1540391931000100" t="mikerod sure, sorry it isn’t super organized - reference dump"><y>#</y><d>2018-10-24</d><h>14:38</h><w>mikerod</w>sure, sorry it isn’t super organized - reference dump</z><z id="t1540419351000100" t="jvtrigueros I&apos;m trying out Clara, but I&apos;m hitting an issue, perhaps I&apos;m using it wrong, here&apos;s the simplest snippet that shows my issue: (defrecord Request [resource]) (defn condition [x y] (= x y)) (defrule some-rule [Request (condition ?resource resource)] =&gt; (println ?resource)) (mk-session) I&apos;m getting an error about ?resource not being bound, however if I replace condition with = this works. I didn&apos;t see anything in the Boolean Expressions documentation about not being able to use other functions, however if that&apos;s the case, how does one go about doing this?"><y>#</y><d>2018-10-24</d><h>22:15</h><w>jvtrigueros</w>I&apos;m trying out Clara, but I&apos;m hitting an issue, perhaps I&apos;m using it wrong, here&apos;s the simplest snippet that shows my issue:
<pre>(defrecord Request [resource])

(defn condition
  [x y]
  (= x y))

(defrule some-rule
  [Request (condition ?resource resource)]
  =&gt;
  (println ?resource))

(mk-session)
</pre>
I&apos;m getting an error about <code>?resource</code> not being bound, however if I replace <code>condition</code> with <code>=</code> this works.

I didn&apos;t see anything in the Boolean Expressions documentation about not being able to use other functions, however if that&apos;s the case, how does one go about doing this?</z><z id="t1540419661000100" t="souenzzo [Request (= ?resource resource)] [:test (condition? ?resource)] =&gt; (prn ?resource) "><y>#</y><d>2018-10-24</d><h>22:21</h><w>souenzzo</w><pre>[Request (= ?resource resource)]
[:test (condition? ?resource)]
=&gt;
(prn ?resource)
</pre></z><z id="t1540473946000100" t="ethanc Probably not relevant and more of an FYI, but if the condition? is simply equality it could be done with a third argument to = . (r/defrule some-rule [Request (= ?resource resource &quot;GET&quot;)] =&gt; (println ?resource)) "><y>#</y><d>2018-10-25</d><h>13:25</h><r>ethanc</r>Probably not relevant and more of an FYI, but if the <code>condition?</code> is simply equality it could be done with a third argument to <code>=</code>.

<pre>(r/defrule some-rule
  [Request (= ?resource resource &quot;GET&quot;)]
  =&gt;
  (println ?resource))
</pre></z><z id="t1540474979000100" t="souenzzo [Request (= resource &quot;GET&quot;)] =&gt; (prn &quot;GET&quot;) Onde it will only match if resource is GET 😅"><y>#</y><d>2018-10-25</d><h>13:42</h><r>souenzzo</r><pre>[Request (= resource &quot;GET&quot;)]
=&gt;
(prn &quot;GET&quot;)
</pre>
Onde it will only match if <code>resource</code> is <code>GET</code> <b>😅</b></z><z id="t1540475031000100" t="souenzzo you can also do [?request &lt;- Request (= resource &quot;GET&quot;)] =&gt; (prn ?request) Will print the &quot;full record&quot;"><y>#</y><d>2018-10-25</d><h>13:43</h><r>souenzzo</r>you can also do
<pre>[?request &lt;- Request (= resource &quot;GET&quot;)]
=&gt;
(prn ?request)
</pre>
Will print the &quot;full record&quot;</z><z id="t1540475970000100" t="jvtrigueros Thanks @U3KC48GHW ! This is actually something that I did need (for a different rule)"><y>#</y><d>2018-10-25</d><h>13:59</h><r>jvtrigueros</r>Thanks @U3KC48GHW ! This is actually something that I did need (for a different rule)</z><z id="t1540419677000100" t="souenzzo @jvtrigueros"><y>#</y><d>2018-10-24</d><h>22:21</h><w>souenzzo</w>@jvtrigueros</z><z id="t1540420408000100" t="jvtrigueros How does this work? In this contrived example condition takes two arguments but here it&apos;s just one. 🤔 Or perhaps you could point me to the literature for this"><y>#</y><d>2018-10-24</d><h>22:33</h><w>jvtrigueros</w>How does this work? In this contrived example <code>condition</code> takes two arguments but here it&apos;s just one. <b>🤔</b>

Or perhaps you could point me to the literature for this</z><z id="t1540420757000100" t="souenzzo (= ?resource resource) it not a function call. it just a DSL to bind the value of resource (form record) to ?resorce (symbol)"><y>#</y><d>2018-10-24</d><h>22:39</h><w>souenzzo</w><code>(= ?resource resource)</code> it not a function call. it just a DSL to bind the value of <code>resource</code> (form record) to <code>?resorce</code> (symbol)</z><z id="t1540421266000100" t="jvtrigueros Ah gotcha, thank you! This points me in the right direction, I&apos;ll continue to play with Clara 😃"><y>#</y><d>2018-10-24</d><h>22:47</h><w>jvtrigueros</w>Ah gotcha, thank you! This points me in the right direction, I&apos;ll continue to play with Clara <b>😃</b></z><z id="t1540425488000100" t="souenzzo some functions you can use like (contains? #{:foo} resource)"><y>#</y><d>2018-10-24</d><h>23:58</h><w>souenzzo</w>some functions you can use like <code>(contains? #{:foo} resource)</code></z><z id="t1540474426000100" t="eraserhd @souenzzo wait, really? Is there a list of functions that Clara handles specially?"><y>#</y><d>2018-10-25</d><h>13:33</h><w>eraserhd</w>@souenzzo wait, really?  Is there a list of functions that Clara handles specially?</z><z id="t1540474442000200" t="eraserhd I mean, knows how to join, other than =?"><y>#</y><d>2018-10-25</d><h>13:34</h><w>eraserhd</w>I mean, knows how to join, other than =?</z><z id="t1540475175000100" t="souenzzo I use = and contanis? . I learned it when I did not understand how clara works then never search for it."><y>#</y><d>2018-10-25</d><h>13:46</h><w>souenzzo</w>I use <code>=</code> and <code>contanis?</code>. I learned it when I did not understand how clara works then never search for it.</z><z id="t1540475820000100" t="jvtrigueros As a newcomer it’s not super clear which functions are built-in. This is definitely an advanced user library :)"><y>#</y><d>2018-10-25</d><h>13:57</h><w>jvtrigueros</w>As a newcomer it’s not super clear which functions are built-in. This is definitely an advanced user library :)</z><z id="t1540477324000100" t="ethanc I&apos;m believe that the only functions that Clara handles specially are the equality expressions: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L213-L223"><y>#</y><d>2018-10-25</d><h>14:22</h><w>ethanc</w>I&apos;m believe that the only functions that Clara handles specially are the equality expressions:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L213-L223" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L213-L223</a></z><z id="t1540478214000100" t="mikerod Yeah, = is the only special thing"><y>#</y><d>2018-10-25</d><h>14:36</h><w>mikerod</w>Yeah, <code>=</code> is the only special thing</z><z id="t1540478237000100" t="mikerod It still means = too, but it can also be used for unification purposes/binding variables"><y>#</y><d>2018-10-25</d><h>14:37</h><w>mikerod</w>It still means <code>=</code> too, but it can also be used for unification purposes/binding variables</z><z id="t1540478267000100" t="mikerod nothing is special about contains? (or anything else)"><y>#</y><d>2018-10-25</d><h>14:37</h><w>mikerod</w>nothing is special about <code>contains?</code> (or anything else)</z><z id="t1540479256000100" t="wparker Agreed with other comments that it is just = that is special when used as a top-level value in the constraint to create/join on bindings (starting with ?)"><y>#</y><d>2018-10-25</d><h>14:54</h><w>wparker</w>Agreed with other comments that it is just = that is special when used as a top-level value in the constraint to create/join on bindings (starting with ?)</z><z id="t1540479280000100" t="wparker that has perf benefits in that those joins are done by hashing"><y>#</y><d>2018-10-25</d><h>14:54</h><w>wparker</w>that has perf benefits in that those joins are done by hashing</z><z id="t1540479312000100" t="wparker otherwise you can use arbitrary functions and they should behave the same as elsewhere"><y>#</y><d>2018-10-25</d><h>14:55</h><w>wparker</w>otherwise you can use arbitrary functions and they should behave the same as elsewhere</z><z id="t1540479346000100" t="jvtrigueros While reading the docs, it goes from straightforward to advanced very quickly. In http://www.clara-rules.org/docs/rules/ , I fully understand the free-lunch-with-gizmo because there&apos;s no ? binding, you&apos;re matching that an item is :gizmo , but then in the sophisticated example: (defrule grant-discount-months [Purchase (= ?month (get-month date))] [DiscountMonth (= ?month month)] =&gt; (insert! (-&gt;GrantDiscount :for-month ?month))) The = doesn&apos;t have the same meaning (in the Purchase condition) as the straightforward example, but it does in the DiscountMonth condition?"><y>#</y><d>2018-10-25</d><h>14:55</h><w>jvtrigueros</w>While reading the docs, it goes from straightforward to advanced very quickly. In <a href="http://www.clara-rules.org/docs/rules/" target="_blank">http://www.clara-rules.org/docs/rules/</a>, I fully understand the <code>free-lunch-with-gizmo</code> because there&apos;s no <code>?</code> binding, you&apos;re matching that an item is <code>:gizmo</code>, but then in the sophisticated example:
<pre>(defrule grant-discount-months  
  [Purchase (= ?month (get-month date))]
  [DiscountMonth (= ?month month)]
  =&gt;
  (insert! (-&gt;GrantDiscount :for-month ?month)))
</pre>
The <code>=</code> doesn&apos;t have the same meaning (in the Purchase condition) as the straightforward example, but it does in the DiscountMonth condition?</z><z id="t1540479431000100" t="wparker it has the same meaning in that it requires equality, but clojure.core/= won’t be called"><y>#</y><d>2018-10-25</d><h>14:57</h><w>wparker</w>it has the same meaning in that it requires equality, but clojure.core/= won’t be called</z><z id="t1540479449000100" t="eraserhd Not quite."><y>#</y><d>2018-10-25</d><h>14:57</h><w>eraserhd</w>Not quite.</z><z id="t1540479496000100" t="eraserhd = is unification. So, it requires the expression to be true. If there are variables in it that do not yet have a value, the variables are &quot;assigned&quot; such to make it true. If the variables are already assigned, it works like clojure.core/="><y>#</y><d>2018-10-25</d><h>14:58</h><w>eraserhd</w><code>=</code> is unification.  So, it requires the expression to be true.  If there are variables in it that do not yet have a value, the variables are &quot;assigned&quot; such to make it true.  If the variables are already assigned, it works like clojure.core/=</z><z id="t1540479511000100" t="mikerod That’s a reasonable way to think about it"><y>#</y><d>2018-10-25</d><h>14:58</h><w>mikerod</w>That’s a reasonable way to think about it</z><z id="t1540479516000100" t="mikerod but Clara may optimize on it"><y>#</y><d>2018-10-25</d><h>14:58</h><w>mikerod</w>but Clara may optimize on it</z><z id="t1540479529000200" t="mikerod when unifying on a ? binding"><y>#</y><d>2018-10-25</d><h>14:58</h><w>mikerod</w>when unifying on a <code>?</code> binding</z><z id="t1540479538000100" t="mikerod it uses it to build the rete graph"><y>#</y><d>2018-10-25</d><h>14:58</h><w>mikerod</w>it uses it to build the rete graph</z><z id="t1540479560000200" t="jvtrigueros &gt; = is unification This distinction is makes sense!"><y>#</y><d>2018-10-25</d><h>14:59</h><w>jvtrigueros</w>&gt; <code>=</code> is unification
This distinction is makes sense!</z><z id="t1540479563000100" t="mikerod makes a hash-based match for nodes known to be doing = based bindings"><y>#</y><d>2018-10-25</d><h>14:59</h><w>mikerod</w>makes a hash-based match for nodes known to be doing <code>=</code> based bindings</z><z id="t1540479576000100" t="mikerod but = is also just = when equating to constant values etc"><y>#</y><d>2018-10-25</d><h>14:59</h><w>mikerod</w>but <code>=</code> is also just <code>=</code> when equating to constant values etc</z><z id="t1540479576000200" t="eraserhd If there are many possible values for a variable, it can assign each value consecutively."><y>#</y><d>2018-10-25</d><h>14:59</h><w>eraserhd</w>If there are many possible values for a variable, it can assign each value consecutively.</z><z id="t1540479593000100" t="mikerod you can do [Purchase (= ?month month &quot;JAN&quot;)] for example"><y>#</y><d>2018-10-25</d><h>14:59</h><w>mikerod</w>you can do <code>[Purchase (= ?month month &quot;JAN&quot;)]</code> for example</z><z id="t1540479595000100" t="eraserhd (*and what @mikerod is saying is true, I&apos;m only describing the semantics, it doesn&apos;t actually work like that.)"><y>#</y><d>2018-10-25</d><h>14:59</h><w>eraserhd</w>(*and what @mikerod is saying is true, I&apos;m only describing the semantics, it doesn&apos;t actually work like that.)</z><z id="t1540479605000100" t="mikerod yeah, semantics are most important"><y>#</y><d>2018-10-25</d><h>15:00</h><w>mikerod</w>yeah, semantics are most important</z><z id="t1540479625000100" t="mikerod just making sure someone may not get carried away and try to print within clojure.core/= or something and wonder why it isn’t always called hah"><y>#</y><d>2018-10-25</d><h>15:00</h><w>mikerod</w>just making sure someone may not get carried away and try to print within <code>clojure.core/=</code> or something and wonder why it isn’t always called hah</z><z id="t1540479633000100" t="mikerod unlikely"><y>#</y><d>2018-10-25</d><h>15:00</h><w>mikerod</w>unlikely</z><z id="t1540479675000100" t="mikerod [Purchase (= ?month month &quot;JAN&quot;)] binds the value of the field month to ?month , when (= month &quot;JAN&quot;) (via clojure.core/= )"><y>#</y><d>2018-10-25</d><h>15:01</h><w>mikerod</w><code>[Purchase (= ?month month &quot;JAN&quot;)]</code> binds the value of the field <code>month</code> to <code>?month</code>, when <code>(= month &quot;JAN&quot;)</code> (via <code>clojure.core/=</code>)</z><z id="t1540479685000100" t="mikerod Of course in this case, ?month would just be “JAN”"><y>#</y><d>2018-10-25</d><h>15:01</h><w>mikerod</w>Of course in this case, <code>?month</code> would just be “JAN”</z><z id="t1540479711000100" t="mikerod so perhaps something a bit more useful than that 😛"><y>#</y><d>2018-10-25</d><h>15:01</h><w>mikerod</w>so perhaps something a bit more useful than that <b>😛</b></z><z id="t1540479805000100" t="wparker This page on the docs might be of interest: http://www.clara-rules.org/docs/hash_joins/"><y>#</y><d>2018-10-25</d><h>15:03</h><w>wparker</w>This page on the docs might be of interest: <a href="http://www.clara-rules.org/docs/hash_joins/" target="_blank">http://www.clara-rules.org/docs/hash_joins/</a></z><z id="t1540479850000100" t="jvtrigueros Woah secret docs"><y>#</y><d>2018-10-25</d><h>15:04</h><w>jvtrigueros</w>Woah secret docs</z><z id="t1540479974000100" t="wparker “`=` is unification” =&gt; correct. Note that this is for top-level constraints though, when nested inside a constraint that isn’t the case i.e. [A (= ?b c)] vs [A (stuff (= ?b c))]"><y>#</y><d>2018-10-25</d><h>15:06</h><w>wparker</w>“`=` is unification” =&gt; correct.  Note that this is for top-level constraints though, when nested inside a constraint that isn’t the case i.e. [A (= ?b c)] vs [A (stuff (= ?b c))]</z><z id="t1540480006000100" t="wparker Hah not secret, just nested inside the “performance optimization” page"><y>#</y><d>2018-10-25</d><h>15:06</h><w>wparker</w>Hah not secret, just nested inside the “performance optimization” page</z><z id="t1540480047000100" t="wparker Or more precisely on my last, that is true if you’re trying to create new bindings - it’s still unification semantically if you’re using bindings from before"><y>#</y><d>2018-10-25</d><h>15:07</h><w>wparker</w>Or more precisely on my last, that is true if you’re trying to create new bindings - it’s still unification semantically if you’re  using bindings from before</z><z id="t1540480157000100" t="jvtrigueros &gt; [A (= ?b c)] vs [A (stuff (= ?b c))] Yes! This is what I ran into immediately, I wanted to use my own equality function, but I got pointed to using :test instead."><y>#</y><d>2018-10-25</d><h>15:09</h><w>jvtrigueros</w>&gt; [A (= ?b c)] vs [A (stuff (= ?b c))]
Yes! This is what I ran into immediately, I wanted to use my own equality function, but I got pointed to using <code>:test</code> instead.</z><z id="t1540480215000200" t="jvtrigueros BTW thank you all for helping me understand this!"><y>#</y><d>2018-10-25</d><h>15:10</h><w>jvtrigueros</w>BTW thank you all for helping me understand this!</z><z id="t1540480997000100" t="mikerod some of the semantics around = can get weird, since it kind of plays 2 roles depending on context"><y>#</y><d>2018-10-25</d><h>15:23</h><w>mikerod</w>some of the semantics around = can get weird, since it kind of plays 2 roles depending on context</z><z id="t1540481007000100" t="mikerod like when how you can’t nest it within another call to do a unification"><y>#</y><d>2018-10-25</d><h>15:23</h><w>mikerod</w>like when how you can’t nest it within another call to do a unification</z><z id="t1540481018000100" t="mikerod but most of the time not a big deal"><y>#</y><d>2018-10-25</d><h>15:23</h><w>mikerod</w>but most of the time not a big deal</z><z id="t1540504892000100" t="jvtrigueros Is it possible to transform the output of defquery or would I need to do that in a wrapper function? The RHS of a defrule is just Clojure but that doesn&apos;t seem to exist in defquery s"><y>#</y><d>2018-10-25</d><h>22:01</h><w>jvtrigueros</w>Is it possible to transform the output of <code>defquery</code> or would I need to do that in a wrapper function? The RHS of a <code>defrule</code> is just Clojure but that doesn&apos;t seem to exist in <code>defquery</code>s</z><z id="t1540505500000100" t="mikerod @jvtrigueros defquery has no RHS"><y>#</y><d>2018-10-25</d><h>22:11</h><w>mikerod</w>@jvtrigueros <code>defquery</code> has  no RHS</z><z id="t1540505531000100" t="mikerod you can create facts in rules with defrule that do some transformations so there is less to transform once you get it from the query"><y>#</y><d>2018-10-25</d><h>22:12</h><w>mikerod</w>you can create facts in rules with <code>defrule</code> that do some transformations so there is less to transform once you get it from the query</z><z id="t1540505548000100" t="mikerod but the query return val will just be the maps with the binding keys to the values they are bound to in the query"><y>#</y><d>2018-10-25</d><h>22:12</h><w>mikerod</w>but the query return val will just be the maps with the binding keys to the values they are bound to in the query</z><z id="t1540505826000100" t="jvtrigueros Thanks! In the query docs, it suggests one can write a query like so: (query session get-by-last-name :last-name “Jones”) How would one write the defquery for that? (defquery get-by-last-name [:last-name] [?person &lt;- Person (= last-name :last-name)]) "><y>#</y><d>2018-10-25</d><h>22:17</h><w>jvtrigueros</w>Thanks! In the <code>query</code> docs, it suggests one can write a query like so:
<pre>(query session get-by-last-name :last-name “Jones”)
</pre>
How would one write the <code>defquery</code> for that?
<pre>(defquery get-by-last-name
  [:last-name]
  [?person &lt;- Person (= last-name :last-name)])
</pre></z><z id="t1540505940000100" t="jvtrigueros I&apos;m only able to create defquery s that have ? : (defquery get-by-last-name [:?last-name] [?person &lt;- Person (= last-name ?last-name)]) But then the query call wouldn&apos;t be using :last-name but :?last-name"><y>#</y><d>2018-10-25</d><h>22:19</h><w>jvtrigueros</w>I&apos;m only able to create <code>defquery</code>s that have <code>?</code>:
<pre>(defquery get-by-last-name
  [:?last-name]
  [?person &lt;- Person (= last-name ?last-name)])
</pre>
But then the query call wouldn&apos;t be using <code>:last-name</code> but <code>:?last-name</code></z><z id="t1540569170003000" t="ethanc @jvtrigueros that is correct, the parameter of the query should be :?last-name , and would work similar to a filter on the ?last-name binding in the lhs of the query. Where did you find that example, it should probably be updated?"><y>#</y><d>2018-10-26</d><h>15:52</h><w>ethanc</w>@jvtrigueros that is correct, the parameter of the query should be <code>:?last-name</code>, and would work similar to a filter on the <code>?last-name</code> binding in the lhs of the query.
Where did you find that example, it should probably be updated?</z><z id="t1540569775003300" t="ethanc nvm, i found it: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L51"><y>#</y><d>2018-10-26</d><h>16:02</h><w>ethanc</w>nvm, i found it:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L51" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L51</a></z><z id="t1540570025003700" t="jvtrigueros Sweet! Thanks 🙂"><y>#</y><d>2018-10-26</d><h>16:07</h><w>jvtrigueros</w>Sweet! Thanks <b>🙂</b></z><z id="t1540576335005000" t="eraserhd I&apos;m curious about a number of Clara&apos;s language restrictions. For example, not being able to use :and inside not, not being able to use :and on the rhs of an accumulator."><y>#</y><d>2018-10-26</d><h>17:52</h><w>eraserhd</w>I&apos;m curious about a number of Clara&apos;s language restrictions.  For example, not being able to use <code>:and</code> inside not, not being able to use <code>:and</code> on the rhs of an accumulator.</z><z id="t1540576383005500" t="eraserhd Are these technical limitations of the underlying matching engine, or front-end limitations?"><y>#</y><d>2018-10-26</d><h>17:53</h><w>eraserhd</w>Are these technical limitations of the underlying matching engine, or front-end limitations?</z><z id="t1540576714006700" t="zylox ya that one is a tangled web of very complicated issues...let me see if i can find the logged issues on them because there is a lot of good conversation on them"><y>#</y><d>2018-10-26</d><h>17:58</h><w>zylox</w>ya that one is a tangled web of very complicated issues...let me see if i can find the logged issues on them because there is a lot of good conversation on them</z><z id="t1540576951007600" t="zylox https://github.com/cerner/clara-rules/issues/373 this is one of them"><y>#</y><d>2018-10-26</d><h>18:02</h><w>zylox</w><a href="https://github.com/cerner/clara-rules/issues/373" target="_blank">https://github.com/cerner/clara-rules/issues/373</a> this is one of them</z><z id="t1540576965008100" t="zylox has a lot of references to other issues"><y>#</y><d>2018-10-26</d><h>18:02</h><w>zylox</w>has a lot of references to other issues</z><z id="t1540577020009300" t="mikerod Yep @zylox has a good point on the issues around the complexities. "><y>#</y><d>2018-10-26</d><h>18:03</h><w>mikerod</w>Yep @zylox has a good point on the issues around the complexities. </z><z id="t1540577137010200" t="mikerod In general negated conjunctions and rete have complexities due to the structure of the network"><y>#</y><d>2018-10-26</d><h>18:05</h><w>mikerod</w>In general negated conjunctions and rete have complexities due to the structure of the network</z><z id="t1540577274010800" t="mikerod Most of the times if things get weird in a rule doing this stuff I think you can typically just break the logic up across more rules to keep the structures simpler "><y>#</y><d>2018-10-26</d><h>18:07</h><w>mikerod</w>Most of the times if things get weird in a rule doing this stuff I think you can typically just break the logic up across more rules to keep the structures simpler </z><z id="t1540579920013000" t="eraserhd How cheap are intermediate facts? I mean, clojure records themselves are cheap, but is memory used by facts interesting? They are alpha-pruned, I assume."><y>#</y><d>2018-10-26</d><h>18:52</h><w>eraserhd</w>How cheap are intermediate facts?  I mean, clojure records themselves are cheap, but is memory used by facts interesting?  They are alpha-pruned, I assume.</z><z id="t1540580024015400" t="eraserhd The idea of a NegatedCondition, for example, is that going to be more memory. (Also, I’m not sure how that could work, because it would need to join on a variable number of bindings.)"><y>#</y><d>2018-10-26</d><h>18:53</h><w>eraserhd</w>The idea of a NegatedCondition, for example, is that going to be more memory. (Also, I’m not sure how that could work, because it would need to join on a variable number of bindings.)</z><z id="t1540581200016000" t="mikerod @eraserhd they aren’t much overhead beyond the fact object itself"><y>#</y><d>2018-10-26</d><h>19:13</h><w>mikerod</w>@eraserhd they aren’t much overhead beyond the fact object itself</z><z id="t1540581253017100" t="mikerod You can make a rule that does the conjunction and inserts a fact if it is true. Then a rule with a negation on that fact. Clara actually sometimes automatically does something similar to that. "><y>#</y><d>2018-10-26</d><h>19:14</h><w>mikerod</w>You can make a rule that does the conjunction and inserts a fact if it is true. Then a rule with a negation on that fact. Clara actually sometimes automatically does something similar to that. </z><z id="t1540581329019100" t="mikerod Intermediate facts in memory are about the same as just making a new record of whatever is what I meant. Cpu timewise just depends on what it interacts with. The actual working memory insert and retract operations are pretty fast (optimized it quite a bit)"><y>#</y><d>2018-10-26</d><h>19:15</h><w>mikerod</w>Intermediate facts in memory are about the same as just making a new record of whatever is what I meant. Cpu timewise just depends on what it interacts with. The actual working memory insert and retract operations are pretty fast (optimized it quite a bit)</z><z id="t1540581344019600" t="mikerod Not sure if that addresses all your questions there"><y>#</y><d>2018-10-26</d><h>19:15</h><w>mikerod</w>Not sure if that addresses all your questions there</z><z id="t1540581357019800" t="eraserhd I think so."><y>#</y><d>2018-10-26</d><h>19:15</h><w>eraserhd</w>I think so.</z><z id="t1540582351021000" t="mikerod When writing rules I typically go pretty heavy on intermediate facts"><y>#</y><d>2018-10-26</d><h>19:32</h><w>mikerod</w>When writing rules I typically go pretty heavy on intermediate facts</z><z id="t1540582389022100" t="mikerod With preference on making simple rules that models smaller concepts at a time and then compose them together for main outcome models for query. If that makes any sense. "><y>#</y><d>2018-10-26</d><h>19:33</h><w>mikerod</w>With preference on making simple rules that models smaller concepts at a time and then compose them together for main outcome models for query. If that makes any sense. </z><z id="t1540582598023300" t="zylox same here"><y>#</y><d>2018-10-26</d><h>19:36</h><w>zylox</w>same here</z><z id="t1540584404024400" t="jimbob what if i have three rules that act on type A and they all output type B while “mutating” some state in the fact. will the final fact be type B with all the “mutations”?"><y>#</y><d>2018-10-26</d><h>20:06</h><w>jimbob</w>what if i have three rules that act on type A and they all output type B while “mutating” some state in the fact.  will the final fact be type B with all the “mutations”?</z><z id="t1540584760024700" t="zylox any time you mutate a fact in the rules network youve opened pandoras box"><y>#</y><d>2018-10-26</d><h>20:12</h><w>zylox</w>any time you mutate a fact in the rules network youve opened pandoras box</z><z id="t1540584780025100" t="zylox if you mean creating new intermediate facts, you will have 3 B facts at the end"><y>#</y><d>2018-10-26</d><h>20:13</h><w>zylox</w>if you mean creating new intermediate facts, you will have 3 B facts at the end</z><z id="t1540584804025500" t="zylox but the foundation of the rules network is immutability."><y>#</y><d>2018-10-26</d><h>20:13</h><w>zylox</w>but the foundation of the rules network is immutability.</z><z id="t1540584873026600" t="zylox you could have a rule that pulls in those 3 B facts (probably with an accumulator), and inserts a FinalB fact that has their combined state. ive seen this pattern used to solve a number of things"><y>#</y><d>2018-10-26</d><h>20:14</h><w>zylox</w>you could have a rule that pulls in those 3 B facts (probably with an accumulator), and inserts a FinalB fact that has their combined state. ive seen this pattern used to solve a number of things</z><z id="t1541010729028500" t="eraserhd Hi! So we&apos;re debugging a performance issue, and it seems like, in our example, fast-token-compare taskes 142 seconds of self time, while PriorityQueue.remove() takes 139 seconds of self time."><y>#</y><d>2018-10-31</d><h>18:32</h><w>eraserhd</w>Hi!  So we&apos;re debugging a performance issue, and it seems like, in our example, fast-token-compare taskes 142 seconds of self time, while PriorityQueue.remove() takes 139 seconds of self time.</z><z id="t1541010821029800" t="eraserhd It&apos;s not clear from VisualVM&apos;s sampling, but it looks like this referring to the PriorityQueue.remove(Object) method, which is consistent with the fast-token-compare times."><y>#</y><d>2018-10-31</d><h>18:33</h><w>eraserhd</w>It&apos;s not clear from VisualVM&apos;s sampling, but it looks like this referring to the PriorityQueue.remove(Object) method, which is consistent with the fast-token-compare times.</z><z id="t1541010879030800" t="eraserhd This method is linear for priority queue. It should be possible to wrap PriorityQueue to make it log(n) by checking when values are extracted. Is there some reason this won&apos;t work?"><y>#</y><d>2018-10-31</d><h>18:34</h><w>eraserhd</w>This method is linear for priority queue.  It should be possible to wrap PriorityQueue to make it log(n) by checking when values are extracted.  Is there some reason this won&apos;t work?</z><z id="t1541011007031300" t="eraserhd Alternately, are we doing something wrong to get runtime dominated by PriorityQueue.remove(Object)?"><y>#</y><d>2018-10-31</d><h>18:36</h><w>eraserhd</w>Alternately, are we doing something wrong to get runtime dominated by PriorityQueue.remove(Object)?</z><z id="t1541012761031900" t="mikerod @eraserhd &gt; Alternately, are we doing something wrong to get runtime dominated by PriorityQueue.remove(Object)? Seems like there is a lot of thrash of rules getting activated, but then subsequently “deactivated”"><y>#</y><d>2018-10-31</d><h>19:06</h><w>mikerod</w>@eraserhd
&gt; Alternately, are we doing something wrong to get runtime dominated by PriorityQueue.remove(Object)?
Seems like there is a lot of thrash of rules getting activated, but then subsequently “deactivated”</z><z id="t1541012787032400" t="mikerod &gt; This method is linear for priority queue. It should be possible to wrap PriorityQueue to make it log(n) by checking when values are extracted. Is there some reason this won’t work? I don’t understand what this is and how it’d make it log(n)."><y>#</y><d>2018-10-31</d><h>19:06</h><w>mikerod</w>&gt; This method is linear for priority queue.  It should be possible to wrap PriorityQueue to make it log(n) by checking when values are extracted.  Is there some reason this won’t work?
I don’t understand what this is and how it’d make it log(n).</z><z id="t1541012822033100" t="mikerod and lastly, fast-token-compare may be slowing down due to large tokens in these rules that are struggling with if they are satisfied/not satisfied"><y>#</y><d>2018-10-31</d><h>19:07</h><w>mikerod</w>and lastly, <code>fast-token-compare</code> may be slowing down due to large tokens in these rules that are struggling with if they are satisfied/not satisfied</z><z id="t1541012855033900" t="mikerod perhaps from large data accumulated via something like (acc/all) ’s or similar"><y>#</y><d>2018-10-31</d><h>19:07</h><w>mikerod</w>perhaps from large data accumulated via something like <code>(acc/all)</code>’s or similar</z><z id="t1541012928035300" t="eraserhd @mikerod if remove/1 stores objects in a hash set, then remove/0 and add/1 skip removed tokens, remove/1 becomes O(1) and I think remove/0 is still O(log N)"><y>#</y><d>2018-10-31</d><h>19:08</h><w>eraserhd</w>@mikerod if remove/1 stores objects in a hash set, then remove/0 and add/1 skip removed tokens, remove/1 becomes O(1) and I think remove/0 is still O(log N)</z><z id="t1541012948035800" t="mikerod We mostly avoid hashing objects"><y>#</y><d>2018-10-31</d><h>19:09</h><w>mikerod</w>We mostly avoid hashing objects</z><z id="t1541012952036000" t="eraserhd Dijkstra&apos;s algorithm is frequently implemented like this, because removing from the priority queue is expensive."><y>#</y><d>2018-10-31</d><h>19:09</h><w>eraserhd</w>Dijkstra&apos;s algorithm is frequently implemented like this, because removing from the priority queue is expensive.</z><z id="t1541012975036300" t="mikerod because then you hit perf barriers with slow hash code impl’s"><y>#</y><d>2018-10-31</d><h>19:09</h><w>mikerod</w>because then you hit perf barriers with slow hash code impl’s</z><z id="t1541012989036600" t="mikerod and often that comes down to the facts being used in the session"><y>#</y><d>2018-10-31</d><h>19:09</h><w>mikerod</w>and often that comes down to the facts being used in the session</z><z id="t1541013016037100" t="mikerod in the particular case where the prio queue is used, the object to remove is a new instance too, so wouldn’t be able to have a reusable cached hashcode"><y>#</y><d>2018-10-31</d><h>19:10</h><w>mikerod</w>in the particular case where the prio queue is used, the object to remove is a new instance too, so wouldn’t be able to have a reusable cached hashcode</z><z id="t1541013067037400" t="eraserhd Hmm."><y>#</y><d>2018-10-31</d><h>19:11</h><w>eraserhd</w>Hmm.</z><z id="t1541013102037900" t="mikerod not to say it isn’t worth consideration at any time, just saying hashing isn’t always as cheap as it seems"><y>#</y><d>2018-10-31</d><h>19:11</h><w>mikerod</w>not to say it isn’t worth consideration at any time, just saying hashing isn’t always as cheap as it seems</z><z id="t1541013123038300" t="mikerod fast-token-compare avoids deep equals most of the time too"><y>#</y><d>2018-10-31</d><h>19:12</h><w>mikerod</w><code>fast-token-compare</code> avoids deep equals most of the time too</z><z id="t1541013139038700" t="mikerod it uses identity-based equivalence as a first-pass, so via identical? in clj semantics"><y>#</y><d>2018-10-31</d><h>19:12</h><w>mikerod</w>it uses identity-based equivalence as a first-pass, so via <code>identical?</code> in clj semantics</z><z id="t1541013150039000" t="mikerod and typically that is all that is needed to find things"><y>#</y><d>2018-10-31</d><h>19:12</h><w>mikerod</w>and typically that is all that is needed to find things</z><z id="t1541013158039300" t="mikerod during the fire-rules loop at least"><y>#</y><d>2018-10-31</d><h>19:12</h><w>mikerod</w>during the <code>fire-rules</code> loop at least</z><z id="t1541013172039800" t="mikerod I’ve seen this problem of large tokens being slow though"><y>#</y><d>2018-10-31</d><h>19:12</h><w>mikerod</w>I’ve seen this problem of large tokens being slow though</z><z id="t1541013209040900" t="mikerod the activation stuff is what uses the prio queue, it has to do with how when rules are satisfied, they are “staged” as available to have their RHS action executed at some future time"><y>#</y><d>2018-10-31</d><h>19:13</h><w>mikerod</w>the activation stuff is what uses the prio queue, it has to do with how when rules are satisfied, they are “staged” as available to have their RHS action executed at some future time</z><z id="t1541013234041600" t="mikerod it is a prio queue since you can have precedence on which rules should be staged ahead of one another - e.g. :salience"><y>#</y><d>2018-10-31</d><h>19:13</h><w>mikerod</w>it is a prio queue since you can have precedence on which rules should be staged ahead of one another - e.g. <code>:salience</code></z><z id="t1541013366043600" t="mikerod I think there are some related issues out there (though not explained the same) https://github.com/cerner/clara-rules/issues/385"><y>#</y><d>2018-10-31</d><h>19:16</h><w>mikerod</w>I think there are some related issues out there (though not explained the same) <a href="https://github.com/cerner/clara-rules/issues/385" target="_blank">https://github.com/cerner/clara-rules/issues/385</a></z><z id="t1541013416043900" t="mikerod well, that’s the only one I see at the moment"><y>#</y><d>2018-10-31</d><h>19:16</h><w>mikerod</w>well, that’s the only one I see at the moment</z><z id="t1541013434044400" t="mikerod I know I’ve messed around with this sort of problem before though, not sure I ever had a good answer"><y>#</y><d>2018-10-31</d><h>19:17</h><w>mikerod</w>I know I’ve messed around with this sort of problem before though, not sure I ever had a good answer</z><z id="t1541013446044800" t="mikerod sometimes you could just avoid a rule setup that is causing it though"><y>#</y><d>2018-10-31</d><h>19:17</h><w>mikerod</w>sometimes you could just avoid a rule setup that is causing it though</z><z id="t1541013456045300" t="eraserhd Those stats look very much like ours."><y>#</y><d>2018-10-31</d><h>19:17</h><w>eraserhd</w>Those stats look very much like ours.</z><z id="t1541013466045600" t="mikerod your hashing thing could be attempted at least, just have to consider a lot of things if it ends up looking like a good path"><y>#</y><d>2018-10-31</d><h>19:17</h><w>mikerod</w>your hashing thing could be attempted at least, just have to consider a lot of things if it ends up looking like a good path</z><z id="t1541013486046000" t="mikerod the issue above talks about a “distinct accumulator”, I think that may be overly specific"><y>#</y><d>2018-10-31</d><h>19:18</h><w>mikerod</w>the issue above talks about a “distinct accumulator”, I think that may be overly specific</z><z id="t1541013490046200" t="mikerod probably a more general problem"><y>#</y><d>2018-10-31</d><h>19:18</h><w>mikerod</w>probably a more general problem</z><z id="t1541013495046400" t="mikerod and I’m fairly sure you have big tokens involved"><y>#</y><d>2018-10-31</d><h>19:18</h><w>mikerod</w>and I’m fairly sure you have big tokens involved</z><z id="t1541013527047100" t="mikerod a big token would come from a rule left-hand side (LHS) that had a lot of facts associated with a single activation of the rule"><y>#</y><d>2018-10-31</d><h>19:18</h><w>mikerod</w>a big token would come from a rule left-hand side (LHS) that had a lot of facts associated with a single activation of the rule</z><z id="t1541013663047600" t="mikerod Take for example something like (r/defrule big-activation-maker [?xs &lt;- (acc/all) :from [X]] =&gt; (do-stuff ?xs)) "><y>#</y><d>2018-10-31</d><h>19:21</h><w>mikerod</w>Take for example something like
<pre>(r/defrule big-activation-maker
  [?xs &lt;- (acc/all) :from [X]]
  =&gt;
  (do-stuff ?xs))
</pre></z><z id="t1541013674047900" t="mikerod now if you can get into a situation where the set of all X changes a lot"><y>#</y><d>2018-10-31</d><h>19:21</h><w>mikerod</w>now if you can get into a situation where the set of all <code>X</code> changes a lot</z><z id="t1541013686048200" t="mikerod and there are a lot of X s in working memory overall"><y>#</y><d>2018-10-31</d><h>19:21</h><w>mikerod</w>and there are a lot of <code>X</code>s in working memory overall</z><z id="t1541013716049000" t="mikerod then this rule may keep activating/cancelling/re-activating, as the set of X grows - and each time there is a big token comparison to do these removals"><y>#</y><d>2018-10-31</d><h>19:21</h><w>mikerod</w>then this rule may keep activating/cancelling/re-activating, as the set of <code>X</code> grows - and each time there is a big token comparison to do these removals</z><z id="t1541013727049300" t="mikerod in a rule as simple as above, it typically wouldn’t thrash though"><y>#</y><d>2018-10-31</d><h>19:22</h><w>mikerod</w>in a rule as simple as above, it typically wouldn’t thrash though</z><z id="t1541013756049900" t="mikerod Most of the time, the network’s “batched propagation” semantics would lead you to a situation where all the X are around in one go with only 1 rule activation resulting"><y>#</y><d>2018-10-31</d><h>19:22</h><w>mikerod</w>Most of the time, the network’s “batched propagation” semantics would lead you to a situation where all the <code>X</code> are around in one go with only 1 rule activation resulting</z><z id="t1541013766050300" t="mikerod but certain setups can cause thrashing when more conditions and things are involved"><y>#</y><d>2018-10-31</d><h>19:22</h><w>mikerod</w>but certain setups can cause thrashing when more conditions and things are involved</z><z id="t1541013784050800" t="mikerod perhaps the distinct accumulator case was a situations like this one, I just don’t remember"><y>#</y><d>2018-10-31</d><h>19:23</h><w>mikerod</w>perhaps the distinct accumulator case was a situations like this one, I just don’t remember</z><z id="t1541014049051300" t="eraserhd This sounds like there is one thing we can write as a custom accumulator to avoid retriggering a whole slew of rules."><y>#</y><d>2018-10-31</d><h>19:27</h><w>eraserhd</w>This sounds like there is one thing we can write as a custom accumulator to avoid retriggering a whole slew of rules.</z><z id="t1541014070051500" t="mikerod perhaps"><y>#</y><d>2018-10-31</d><h>19:27</h><w>mikerod</w>perhaps</z><z id="t1541014106052600" t="ethanc or play with salience , though as a last resort"><y>#</y><d>2018-10-31</d><h>19:28</h><w>ethanc</w>or play with <code>salience</code>, though as a last resort</z><z id="t1541014130053100" t="mikerod yeah, sometimes that’s useful"><y>#</y><d>2018-10-31</d><h>19:28</h><w>mikerod</w>yeah, sometimes that’s useful</z><z id="t1541014149053500" t="mikerod sometimes you can look at the rules and sort of see where an accumulator rule may be getting retriggered in multiple phases of insert"><y>#</y><d>2018-10-31</d><h>19:29</h><w>mikerod</w>sometimes you can look at the rules and sort of see where an accumulator rule may be getting retriggered in multiple phases of insert</z><z id="t1541014177054100" t="mikerod and try to prevent that, there is salience to help, as well as just potentially logical structuring"><y>#</y><d>2018-10-31</d><h>19:29</h><w>mikerod</w>and try to prevent that, there is salience to help, as well as just potentially logical structuring</z><z id="t1541082091055000" t="eraserhd OK, so we&apos;ve just found something really weird with accumulators: retract-fn is never used, though documented in acc/accum."><y>#</y><d>2018-11-01</d><h>14:21</h><w>eraserhd</w>OK, so we&apos;ve just found something really weird with accumulators: retract-fn is never used, though documented in acc/accum.</z><z id="t1541082107055400" t="eraserhd Because retract-fn does not appear in the Accumulator record."><y>#</y><d>2018-11-01</d><h>14:21</h><w>eraserhd</w>Because retract-fn does not appear in the Accumulator record.</z><z id="t1541082117055700" t="eraserhd I&apos;m going to guess this is not how it&apos;s supposed to work?"><y>#</y><d>2018-11-01</d><h>14:21</h><w>eraserhd</w>I&apos;m going to guess this is not how it&apos;s supposed to work?</z><z id="t1541082942056400" t="mikerod @eraserhd odd that it isn’t on the record definition, not sure I know why there, but it is called when provided (well expected to be)"><y>#</y><d>2018-11-01</d><h>14:35</h><w>mikerod</w>@eraserhd odd that it isn’t on the record definition, not sure I know why there, but it is called when provided (well expected to be)</z><z id="t1541082951056700" t="mikerod do you have a custom accumulator you are trying to work with?"><y>#</y><d>2018-11-01</d><h>14:35</h><w>mikerod</w>do you have a custom accumulator you are trying to work with?</z><z id="t1541082969057300" t="mikerod or did you try to add this to the existing acc/accum"><y>#</y><d>2018-11-01</d><h>14:36</h><w>mikerod</w>or did you try to add this to the existing <code>acc/accum</code></z><z id="t1541082996058000" t="eraserhd We are getting ready to build an accumulator with accum , and I was looking for how to extract those functions again so we can test drive it, and I found that retract-fn gets lost."><y>#</y><d>2018-11-01</d><h>14:36</h><w>eraserhd</w>We are getting ready to build an accumulator with <code>accum</code>, and I was looking for how to extract those functions again so we can test drive it, and I found that retract-fn gets lost.</z><z id="t1541083130058600" t="eraserhd uhhh, whoa. I had no idea that you could add arbitrary fields to a defrecord with map-&gt;X."><y>#</y><d>2018-11-01</d><h>14:38</h><w>eraserhd</w>uhhh, whoa.  I had no idea that you could add arbitrary fields to a defrecord with map-&gt;X.</z><z id="t1541083153058900" t="mikerod you are using clara.rules.accumulators/accum to build an accumulator?"><y>#</y><d>2018-11-01</d><h>14:39</h><w>mikerod</w>you are using <code>clara.rules.accumulators/accum</code> to build an accumulator?</z><z id="t1541083172059400" t="eraserhd No, doing nothing but research at this point."><y>#</y><d>2018-11-01</d><h>14:39</h><w>eraserhd</w>No, doing nothing but research at this point.</z><z id="t1541083200060100" t="mikerod yeah, defrecord in clj is often considered more of a perf optimization for a common group of fields you access, they work as regular maps in many cases, and having any number of keys is one of them. the keys not defined on the record are just accessed slower on the impl side"><y>#</y><d>2018-11-01</d><h>14:40</h><w>mikerod</w>yeah, defrecord in clj is often considered more of a perf optimization for a common group of fields you access, they work as regular maps in many cases, and having any number of keys is one of them. the keys not defined on the record are just accessed slower on the impl side</z><z id="t1541083208060300" t="mikerod and you can’t reflect for them etc"><y>#</y><d>2018-11-01</d><h>14:40</h><w>mikerod</w>and you can’t reflect for them etc</z><z id="t1541083232060600" t="mikerod clara.rules.accumulators/accum supports passing the :retract-fn in"><y>#</y><d>2018-11-01</d><h>14:40</h><w>mikerod</w><code>clara.rules.accumulators/accum</code> supports passing the <code>:retract-fn</code> in</z><z id="t1541083258060900" t="mikerod have to be a bit careful on how you do retraction though if I recall correct"><y>#</y><d>2018-11-01</d><h>14:40</h><w>mikerod</w>have to be a bit careful on how you do retraction though if I recall correct</z><z id="t1541083273061300" t="mikerod if you don’t provide one, Clara will default to rebuilding things minus the facts retracted"><y>#</y><d>2018-11-01</d><h>14:41</h><w>mikerod</w>if you don’t provide one, Clara will default to rebuilding things minus the facts retracted</z><z id="t1541083291061700" t="mikerod :retract-fn is meant for when you know how to more efficiently remove a retracted fact from your reduced structure"><y>#</y><d>2018-11-01</d><h>14:41</h><w>mikerod</w><code>:retract-fn</code> is meant for when you know how to more efficiently remove a retracted fact from your reduced structure</z><z id="t1541083350062300" t="mikerod If you had an example situation where you think :retract-fn wasn’t used though, that’d be easier to look at and walk through"><y>#</y><d>2018-11-01</d><h>14:42</h><w>mikerod</w>If you had an example situation where you think <code>:retract-fn</code> wasn’t used though, that’d be easier to look at and walk through</z><z id="t1541083438062600" t="mikerod ohhhh, there may be cases where it isn’t used at all"><y>#</y><d>2018-11-01</d><h>14:43</h><w>mikerod</w>ohhhh, there may be cases where it isn’t used at all</z><z id="t1541083445062800" t="mikerod checking, I’m forgetting things"><y>#</y><d>2018-11-01</d><h>14:44</h><w>mikerod</w>checking, I’m forgetting things</z><z id="t1541083497063700" t="eraserhd We have the ability to do more efficient retraction and combining, so we&apos;re writing a custom accumulator to get around the thrashing from yesterday. It also allows us to get rid of some intermediate facts that are frequently retracted."><y>#</y><d>2018-11-01</d><h>14:44</h><w>eraserhd</w>We have the ability to do more efficient retraction and combining, so we&apos;re writing a custom accumulator to get around the thrashing from yesterday.  It also allows us to get rid of some intermediate facts that are frequently retracted.</z><z id="t1541083668064100" t="mikerod when you use the accumulator"><y>#</y><d>2018-11-01</d><h>14:47</h><w>mikerod</w>when you use the accumulator</z><z id="t1541083672064300" t="mikerod what sort of form does it have"><y>#</y><d>2018-11-01</d><h>14:47</h><w>mikerod</w>what sort of form does it have</z><z id="t1541083688064700" t="mikerod [?acc &lt;- custom-acc :from [&lt;this part&gt;]]"><y>#</y><d>2018-11-01</d><h>14:48</h><w>mikerod</w><code>[?acc &lt;- custom-acc :from [&lt;this part&gt;]]</code></z><z id="t1541083743065600" t="mikerod Are you using some joining conditions there like [X (test-something ?y z)] , or just [X] , or equality based join, like [X (= ?y z)] ?"><y>#</y><d>2018-11-01</d><h>14:49</h><w>mikerod</w>Are you using some joining conditions there like <code>[X (test-something ?y z)]</code>, or just <code>[X]</code>, or equality based join, like <code>[X (= ?y z)]</code>?</z><z id="t1541083772066400" t="mikerod The point is there are 2 variants of accumulate nodes in the rules engine, one for the simpler join cases using = or no joining at all"><y>#</y><d>2018-11-01</d><h>14:49</h><w>mikerod</w>The point is there are 2 variants of accumulate nodes in the rules engine, one for the simpler join cases using <code>=</code> or no joining at all</z><z id="t1541083790066900" t="mikerod that one is optimized for those cases because they can be done better"><y>#</y><d>2018-11-01</d><h>14:49</h><w>mikerod</w>that one is optimized for those cases because they can be done better</z><z id="t1541083808067300" t="mikerod the other variant handles the rest, which are arbitrary other joining criteria"><y>#</y><d>2018-11-01</d><h>14:50</h><w>mikerod</w>the other variant handles the rest, which are arbitrary other joining criteria</z><z id="t1541083898068700" t="mikerod At this point, if I recall all the impl details correctly, providing your own :retract-fn is only a potential perf optimization. If you use the optimized, easier variant of an accumulator, it will be used, otherwise, it is ignored because it can’t be used from within the more generalized case"><y>#</y><d>2018-11-01</d><h>14:51</h><w>mikerod</w>At this point, if I recall all the impl details correctly, providing your own <code>:retract-fn</code> is only a potential perf optimization. If you use the optimized, easier variant of an accumulator, it will be used, otherwise, it is ignored because it can’t be used from within the more generalized case</z><z id="t1541083917069100" t="mikerod or really, it can’t be used to help in the more general case, it would only be slower"><y>#</y><d>2018-11-01</d><h>14:51</h><w>mikerod</w>or really, it can’t be used to help in the more general case, it would only be slower</z><z id="t1541085023071600" t="ProbablyJody Does the accumulator maintain the reduced value before being passed to the :convert-return-fn for the purposes of handing it to the :retract-fn ?"><y>#</y><d>2018-11-01</d><h>15:10</h><w>ProbablyJody</w>Does the accumulator maintain the reduced value before being passed to the <code>:convert-return-fn</code> for the purposes of handing it to the <code>:retract-fn</code>?</z><z id="t1541085046071900" t="ProbablyJody (assuming both are defined)"><y>#</y><d>2018-11-01</d><h>15:10</h><w>ProbablyJody</w>(assuming both are defined)</z><z id="t1541085131072900" t="ProbablyJody To rephrase, should the :retract-fn expect the output of the :reduce-fn or the :convert-return-fn ?"><y>#</y><d>2018-11-01</d><h>15:12</h><w>ProbablyJody</w>To rephrase, should the <code>:retract-fn</code> expect the output of the <code>:reduce-fn</code> or the <code>:convert-return-fn</code>?</z><z id="t1541085502073300" t="mikerod @jody &gt; To rephrase, should the :retract-fn expect the output of the :reduce-fn or the :convert-return-fn ? It should expect the output of :reduce-fn"><y>#</y><d>2018-11-01</d><h>15:18</h><w>mikerod</w>@jody
&gt; To rephrase, should the <code>:retract-fn</code> expect the output of the <code>:reduce-fn</code> or the <code>:convert-return-fn</code>?
It should expect the output of <code>:reduce-fn</code></z><z id="t1541085546074000" t="mikerod it’s part of the “reducing phase”, :convert-return-fn is only done after everything else"><y>#</y><d>2018-11-01</d><h>15:19</h><w>mikerod</w>it’s part of the “reducing phase”, <code>:convert-return-fn</code> is only done after everything else</z><z id="t1541085589074700" t="mikerod Under the current implementation (would have to double check), I don’t think working memory for the accumulate node ever maintains the :convert-return-fn value actually, just the :reduce-fn /`:retract-fn` returned value state"><y>#</y><d>2018-11-01</d><h>15:19</h><w>mikerod</w>Under the current implementation (would have to double check), I don’t think working memory for the accumulate node ever maintains the <code>:convert-return-fn</code> value actually, just the <code>:reduce-fn</code>/`:retract-fn` returned value state</z><z id="t1541085635075200" t="mikerod the reason is that the :convert-return-fn value is not considered useful to use for any subsequent changes"><y>#</y><d>2018-11-01</d><h>15:20</h><w>mikerod</w>the reason is that the <code>:convert-return-fn</code> value is not considered useful to use for any subsequent changes</z><z id="t1541085644075500" t="mikerod the reducing state is"><y>#</y><d>2018-11-01</d><h>15:20</h><w>mikerod</w>the reducing state is</z><z id="t1541100663077100" t="eraserhd Is it possible for an accumulator to get a net negative, e.g. more retractions than insertions. I&apos;m wondering because maybe this is implied by the &quot;combine&quot; function?"><y>#</y><d>2018-11-01</d><h>19:31</h><w>eraserhd</w>Is it possible for an accumulator to get a net negative, e.g. more retractions than insertions.  I&apos;m wondering because maybe this is implied by the &quot;combine&quot; function?</z><z id="t1541102608078800" t="ProbablyJody I believe the combine function is just a performance optimizer for the reduce phase. I’d expect a net-negative to represent a bug in truth maintenance. I might be mis-understanding the question though."><y>#</y><d>2018-11-01</d><h>20:03</h><w>ProbablyJody</w>I believe the combine function is just a performance optimizer for the reduce phase. I’d expect a net-negative to represent a bug in truth maintenance. I might be mis-understanding the question though.</z><z id="t1541105324080600" t="eraserhd I mean, obviously, if you combine all batches, you can&apos;t have more retractions than insertions. But depending on how you are batching, you could have one batch with, say three insertions and another batch with two retractions. That would mean that two retractions were applied to the initial value in that case."><y>#</y><d>2018-11-01</d><h>20:48</h><w>eraserhd</w>I mean, obviously, if you combine all batches, you can&apos;t have more retractions than insertions. But depending on how you are batching, you could have one batch with, say three insertions and another batch with two retractions.  That would mean that two retractions were applied to the initial value in that case.</z><z id="t1541105457082300" t="eraserhd Alternately, you could say that Clara enforces that retractions occur in the same batch as insertions. I&apos;m not sure how it could, though I don&apos;t understand how this is being called."><y>#</y><d>2018-11-01</d><h>20:50</h><w>eraserhd</w>Alternately, you could say that Clara enforces that retractions occur in the same batch as insertions.  I&apos;m not sure how it could, though I don&apos;t understand how this is being called.</z><z id="t1541105794083700" t="eraserhd I guess one possibility is that Clara only uses this for joins where each reduced value is a selection of attributes, such that insertions and retractions are always sorted into the same batch. That actually makes the most sense."><y>#</y><d>2018-11-01</d><h>20:56</h><w>eraserhd</w>I guess one possibility is that Clara only uses this for joins where each reduced value is a selection of attributes, such that insertions and retractions are always sorted into the same batch.  That actually makes the most sense.</z><z id="t1541108398084400" t="mikerod @eraserhd when retracting facts, with respect to an accumulator, the accumulator is only re-ran on facts that were retracted and were found to have previous matches"><y>#</y><d>2018-11-01</d><h>21:39</h><w>mikerod</w>@eraserhd when retracting facts, with respect to an accumulator, the accumulator is only re-ran on facts that were retracted and were found to have previous matches</z><z id="t1541108426085000" t="mikerod so the facts retracted and processed by an accumulator, should only be facts that were processed by the same accumulator before, when they were inserted"><y>#</y><d>2018-11-01</d><h>21:40</h><w>mikerod</w>so the facts retracted and processed by an accumulator, should only be facts that were processed by the same accumulator before, when they were inserted</z><z id="t1541108462085600" t="mikerod if you batched up retracts of facts that were not inserted yet, the accumulator wouldn’t need to retract anything"><y>#</y><d>2018-11-01</d><h>21:41</h><w>mikerod</w>if you batched up retracts of facts that were not inserted yet, the accumulator wouldn’t need to retract anything</z><z id="t1541108482085800" t="mikerod and it wouldn’t try"><y>#</y><d>2018-11-01</d><h>21:41</h><w>mikerod</w>and it wouldn’t try</z><z id="t1541108517086100" t="mikerod facts are considered the “same” via ="><y>#</y><d>2018-11-01</d><h>21:41</h><w>mikerod</w>facts are considered the “same” via <code>=</code></z><z id="t1541108525086300" t="mikerod but respecting cardinality of them"><y>#</y><d>2018-11-01</d><h>21:42</h><w>mikerod</w>but respecting cardinality of them</z><z id="t1541108541086600" t="mikerod ie insert 2 = objects, retract 1, you still have 1 left"><y>#</y><d>2018-11-01</d><h>21:42</h><w>mikerod</w>ie insert 2 <code>=</code> objects, retract 1, you still have 1 left</z><z id="t1541108571087300" t="mikerod if the retracted is identical? to 1 of = instances, that’d like be the one removed - but I think that’s more due to perf optimizations than anything"><y>#</y><d>2018-11-01</d><h>21:42</h><w>mikerod</w>if the retracted is <code>identical?</code> to 1 of <code>=</code> instances, that’d like be the one removed - but I think that’s more due to perf optimizations than anything</z><z id="t1541110367087700" t="eraserhd @mikerod OK, that makes sense. Thanks!"><y>#</y><d>2018-11-01</d><h>22:12</h><w>eraserhd</w>@mikerod OK, that makes sense.  Thanks!</z><z id="t1541159772092500" t="wparker @eraserhd Agreed with @mikerod that the only facts which will be retracted are those that were provided before. Regarding the inefficiencies of accumulation with non-hash join conditions, I think that’s a more general problem than the :retract-fn actually. For example, I believe when a new fact matching the accumulation condition is added the previous facts will have the accumulator rerun on them in their entirety, whereas the simple case with no joins or only-hash based joins will store the previous result and add onto it. Contrast the following in AccumulateNode, the simple case: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1156 with the equivalent in AccumulateWithJoinFilterNode, the more complex case: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1525"><y>#</y><d>2018-11-02</d><h>11:56</h><w>wparker</w>@eraserhd Agreed with @mikerod that the only facts which will be retracted are those that were provided before.  Regarding the inefficiencies of accumulation with non-hash join conditions, I think that’s a more general problem than the :retract-fn actually.  For example, I believe when a new fact matching the accumulation condition is added the previous facts will have the accumulator rerun on them in their entirety, whereas the simple case with no joins or only-hash based joins will store the previous result and add onto it.  Contrast the following in AccumulateNode, the simple case: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1156" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1156</a> with the equivalent in AccumulateWithJoinFilterNode, the more complex case: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1525" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1525</a></z><z id="t1541159891095000" t="wparker The tricky thing is that Clara’s memory is set up to store the elements (facts coming into the current condition) and tokens (facts from ancestor conditions) separately, but in the case of these complex accumulator joins you’d really want to store them together for maximum efficiency. I don’t think there is any fundamental reason why this couldn’t be done though, it"><y>#</y><d>2018-11-02</d><h>11:58</h><w>wparker</w>The tricky thing is that Clara’s memory is set up to store the elements (facts coming into the current condition) and tokens (facts from ancestor conditions) separately, but in the case of these complex accumulator joins you’d really want to store them together for maximum efficiency.  I don’t think there is any fundamental reason why this couldn’t be done though, it</z><z id="t1541159920095600" t="wparker would just be the work to do it and get it right/performant, plus durability changes probably if the memory structure changed"><y>#</y><d>2018-11-02</d><h>11:58</h><w>wparker</w>would just be the work to do it and get it right/performant, plus durability changes probably if the memory structure changed</z><z id="t1541160022097400" t="wparker Clara does avoid downstream thrash from the complex accumulators still when the result didn’t actually change - see https://github.com/cerner/clara-rules/issues/182 and the changes made there - but the internal calculation has some room for improvement perf-wise"><y>#</y><d>2018-11-02</d><h>12:00</h><w>wparker</w>Clara does avoid downstream thrash from the complex accumulators still when the result didn’t actually change - see <a href="https://github.com/cerner/clara-rules/issues/182" target="_blank">https://github.com/cerner/clara-rules/issues/182</a> and the changes made there - but the internal calculation has some room for improvement perf-wise</z><z id="t1541160187098300" t="wparker If you want to understand how the accumulator logic works, some basic terms:"><y>#</y><d>2018-11-02</d><h>12:03</h><w>wparker</w>If you want to understand how the accumulator logic works, some basic terms:</z><z id="t1541160206098700" t="wparker -right-activate: new facts matching the condition at hand"><y>#</y><d>2018-11-02</d><h>12:03</h><w>wparker</w>-right-activate: new facts matching the condition at hand</z><z id="t1541160226099100" t="wparker -right-retract: removal of facts matching the condition at hand"><y>#</y><d>2018-11-02</d><h>12:03</h><w>wparker</w>-right-retract: removal of facts matching the condition at hand</z><z id="t1541160244099600" t="wparker -left-activate: facts were added to ancestor conditions and need to be passed down the network"><y>#</y><d>2018-11-02</d><h>12:04</h><w>wparker</w>-left-activate: facts were added to ancestor conditions and need to be passed down the network</z><z id="t1541160279100300" t="wparker left-retract: facts were removed from ancestor conditions and need to be passed down the network"><y>#</y><d>2018-11-02</d><h>12:04</h><w>wparker</w>left-retract: facts were removed from ancestor conditions and need to be passed down the network</z><z id="t1541160310101000" t="wparker AccumulateNode - simple no-condition or hash-join-only accumulation conditions"><y>#</y><d>2018-11-02</d><h>12:05</h><w>wparker</w>AccumulateNode - simple no-condition or hash-join-only accumulation conditions</z><z id="t1541160356102100" t="wparker AccumulateWithjoinFilterNode - accumulation condition with arbitrary filter logic taking facts from ancestor conditions as input"><y>#</y><d>2018-11-02</d><h>12:05</h><w>wparker</w>AccumulateWithjoinFilterNode - accumulation condition with arbitrary filter logic taking facts from ancestor conditions as input</z><z id="t1541160573105200" t="wparker probably the best source of truth there is the code, fortunately it is a well commented area imo though i’m biased as i wrote many of those comments"><y>#</y><d>2018-11-02</d><h>12:09</h><w>wparker</w>probably the best source of truth there is the code, fortunately it is a well commented area imo though i’m biased as i wrote many of those comments</z><z id="t1541160615106100" t="wparker to be clear: when I say to understand how it works, i mean the algorithms at play - the docs should be sufficient for the behavior and if they’re not they should be improved"><y>#</y><d>2018-11-02</d><h>12:10</h><w>wparker</w>to be clear: when I say to understand how it works, i mean the algorithms at play - the docs should be sufficient for the behavior and if they’re not they should be improved</z><z id="t1541160628106400" t="wparker hopefully this helps"><y>#</y><d>2018-11-02</d><h>12:10</h><w>wparker</w>hopefully this helps</z><z id="t1541160666107000" t="wparker if you’re trying to get a case with complex accumulator joins to perform better, frankly my first reaction would be to use salience most likely"><y>#</y><d>2018-11-02</d><h>12:11</h><w>wparker</w>if you’re trying to get a case with complex accumulator joins to perform better, frankly my first reaction would be to use salience most likely</z><z id="t1541160722108100" t="wparker if you’re using truth maintenance without side effects, the salience shouldn’t impact actual behavior so it doesn’t make the code harder to read/understand in that respect"><y>#</y><d>2018-11-02</d><h>12:12</h><w>wparker</w>if you’re using truth maintenance without side effects, the salience shouldn’t impact actual behavior so it doesn’t make the code harder to read/understand in that respect</z><z id="t1541166252108600" t="eraserhd @wparker thanks! This is all good info."><y>#</y><d>2018-11-02</d><h>13:44</h><w>eraserhd</w>@wparker thanks!  This is all good info.</z><z id="t1541166519109700" t="eraserhd I&apos;m guessing, in [Foo (= ?a a)] [?acc &lt;- (acc/whatever) [Bar (= ?a a)]], Foo would be left and Bar would be right?"><y>#</y><d>2018-11-02</d><h>13:48</h><w>eraserhd</w>I&apos;m guessing, in [Foo (= ?a a)] [?acc &lt;- (acc/whatever) [Bar (= ?a a)]], Foo would be left and Bar would be right?</z><z id="t1541173595110000" t="mikerod @eraserhd basically yes"><y>#</y><d>2018-11-02</d><h>15:46</h><w>mikerod</w>@eraserhd basically yes</z><z id="t1541173607110300" t="mikerod left is the matched-token-so-far in a rule LHS"><y>#</y><d>2018-11-02</d><h>15:46</h><w>mikerod</w>left is the matched-token-so-far in a rule LHS</z><z id="t1541173633110700" t="mikerod tokens consist of all facts involved in a match"><y>#</y><d>2018-11-02</d><h>15:47</h><w>mikerod</w>tokens consist of all facts involved in a match</z><z id="t1541173706112000" t="mikerod In a LHS [A] [B] [C] if we were looking at the network node for the [C] condition, incoming C facts would be right-activate , left-activate to this node would be matched up A +`B`s - represented as a “token”"><y>#</y><d>2018-11-02</d><h>15:48</h><w>mikerod</w>In a LHS <code>[A] [B] [C]</code> if we were looking at the network node for the <code>[C]</code> condition, incoming <code>C</code> facts would be <code>right-activate</code>, <code>left-activate</code> to this node would be matched up <code>A</code>+`B`s - represented as a “token”</z><z id="t1541179475114300" t="wparker And for the [B] condition, incoming B facts would be right-activate, left-activate would be tokens passed down from the [A] condition. For the [A] condition the right-activate would be incoming A facts, the left-activate would basically be a dummy placeholder. Does that make sense?"><y>#</y><d>2018-11-02</d><h>17:24</h><w>wparker</w>And for the [B] condition, incoming B facts would be right-activate, left-activate would be tokens passed down from the [A] condition.  For the [A] condition the right-activate would be incoming A facts, the left-activate would basically be a dummy placeholder.  Does that make sense?</z><z id="t1541539357115100" t="eraserhd queries are prioritized last (in terms of salience ), I hope, right?"><y>#</y><d>2018-11-06</d><h>21:22</h><w>eraserhd</w>queries are prioritized last (in terms of <code>salience</code>), I hope, right?</z><z id="t1541541989115700" t="mikerod @eraserhd I’m can’t think of a reason where it’d matter how queries are “prioritized”"><y>#</y><d>2018-11-06</d><h>22:06</h><w>mikerod</w>@eraserhd I’m can’t think of a reason where it’d matter how queries are “prioritized”</z><z id="t1541542011116400" t="mikerod they just receive matches from facts that are currently in working memory"><y>#</y><d>2018-11-06</d><h>22:06</h><w>mikerod</w>they just receive matches from facts that are currently in working memory</z><z id="t1541542025116900" t="mikerod priority with :salience is about ordering when a rule is eligible to be fired"><y>#</y><d>2018-11-06</d><h>22:07</h><w>mikerod</w>priority with <code>:salience</code> is about ordering when a rule is eligible to be fired</z><z id="t1541542038117500" t="mikerod aka perform the action specified on its RHS, so this concept does not apply to queries"><y>#</y><d>2018-11-06</d><h>22:07</h><w>mikerod</w>aka perform the action specified on its RHS, so this concept does not apply to queries</z><z id="t1541542110118600" t="eraserhd hmm, so if I have rules that insert and retract things that are queried, the query results aren&apos;t updated by the firing of a pseudo-rule?"><y>#</y><d>2018-11-06</d><h>22:08</h><w>eraserhd</w>hmm, so if I have rules that insert and retract things that are queried, the query results aren&apos;t updated by the firing of a pseudo-rule?</z><z id="t1541542319120200" t="eraserhd (bad sentence, but hopefully the question is clear)"><y>#</y><d>2018-11-06</d><h>22:11</h><w>eraserhd</w>(bad sentence, but hopefully the question is clear)</z><z id="t1541543346121000" t="eraserhd OK, I see. They are their own thing."><y>#</y><d>2018-11-06</d><h>22:29</h><w>eraserhd</w>OK, I see.  They are their own thing.</z><z id="t1541545627121900" t="mikerod Not sure I understand that question. But in general always fire rules before query. Not sure if that helps. Hah"><y>#</y><d>2018-11-06</d><h>23:07</h><w>mikerod</w>Not sure I understand that question. But in general always fire rules before query. Not sure if that helps. Hah</z><z id="t1541599596126200" t="wparker @eraserhd Not sure I understand the question either, but the API with queries is that if you call the query function on a rules session after firing rules, the query results will reflect all insertions/retractions prior to the fire-rules call. Under the hood, queries are basically a rule LHS and the results are computed as part of fire-rules - the query function in clara.rules really is more of a “retrieve query results” function than a “run query” in that way. If your concern was performance, there are optimizations that could be made around deferring some query matching work to later in the fire-rules, thus avoiding the need to retract query matches that are invalidated, but that hasn’t been implemented. I’ve found it isn’t often an issue and in the few cases where it was it was fairly easy to work around."><y>#</y><d>2018-11-07</d><h>14:06</h><w>wparker</w>@eraserhd Not sure I understand the question either, but the API with queries is that if you call the query function on a rules session after firing rules, the query results will reflect all insertions/retractions prior to the fire-rules call.  Under the hood, queries are basically a rule LHS and the results are computed as part of fire-rules - the query function in clara.rules really is more of a “retrieve query results” function than a “run query” in that way.  If your concern was performance, there are optimizations that could be made around deferring some query matching work to later in the fire-rules, thus avoiding the need to retract query matches that are invalidated, but that hasn’t been implemented.   I’ve found it isn’t often an issue and in the few cases where it was it was fairly easy to work around.</z><z id="t1542202805129100" t="nlessa Hi, I am having performance problems in my set of rules. Probably some of the rules are performing bad. Is there any way to profile the time spent by each rule when firing-rules in a session? I couldn&apos;t find any obvious way to get this info using the inspect api."><y>#</y><d>2018-11-14</d><h>13:40</h><w>nlessa</w>Hi, I am having performance problems in my set of rules. Probably some of the rules are performing bad. Is there any way to profile the time spent by each rule when firing-rules in a session? I couldn&apos;t find any obvious way to get this info  using the inspect api.</z><z id="t1542205056132800" t="wparker The inspect api is targeted at understanding the end result of the rules, not performance. For performance problems you’ll probably want a profiler or perhaps tracing. Tracing shows all the internal steps of the rules engine, and can produce a lot of data that is probably best sorted through with the REPL rather than manual inspection, but if a single rule is constantly re-firing it can make that clear. I’d probably start with a profiler though. Another approach could be to take separate parts of your use-case and see if you can find a simple subset with the perf problem, particularly one you can share that would be easier for someone else to look at."><y>#</y><d>2018-11-14</d><h>14:17</h><w>wparker</w>The inspect api is targeted at understanding the end result of the rules, not performance.  For performance problems you’ll probably want a profiler or perhaps tracing.   Tracing shows all the internal steps of the rules engine, and can produce a lot of data that is probably best sorted through with the REPL rather than manual inspection, but if a single rule is constantly re-firing it can make that clear.  I’d probably start with a profiler though.  Another approach could be to take separate parts of your use-case and see if you can find a simple subset with the perf problem, particularly one you can share that would be easier for someone else to look at.</z><z id="t1542205078133200" t="wparker Are you on Clojure or ClojureScript?"><y>#</y><d>2018-11-14</d><h>14:17</h><w>wparker</w>Are you on Clojure or ClojureScript?</z><z id="t1542205225133800" t="nlessa Thanks, @wparker! Clojure."><y>#</y><d>2018-11-14</d><h>14:20</h><w>nlessa</w>Thanks, @wparker! Clojure.</z><z id="t1542213621135700" t="mikerod @nlessa and feel free to share profiler sample results with me (or anyone interested) (with anything propriety removes). Sometimes just seeing the Clara internals in a profiling snapshot can help point someone in the right direction. Not always though. "><y>#</y><d>2018-11-14</d><h>16:40</h><w>mikerod</w>@nlessa and feel free to share profiler sample results with me (or anyone interested) (with anything propriety removes). Sometimes just seeing the Clara internals in a profiling snapshot can help point someone in the right direction. Not always though. </z><z id="t1542310997137000" t="eraserhd dsl seems to parse a thing :exists as an operator, but it&apos;s not documented. This sounds like a missing feature we&apos;ve wanted... is it true?"><y>#</y><d>2018-11-15</d><h>19:43</h><w>eraserhd</w>dsl seems to parse a thing <code>:exists</code> as an operator, but it&apos;s not documented.  This sounds like a missing feature we&apos;ve wanted... is it true?</z><z id="t1542311451137600" t="enn Good catch on the missing docs. There was some discussion on the list when it was implemented, see https://github.com/cerner/clara-rules/issues/130 for details."><y>#</y><d>2018-11-15</d><h>19:50</h><w>enn</w>Good catch on the missing docs. There was some discussion on the list when it was implemented, see <a href="https://github.com/cerner/clara-rules/issues/130" target="_blank">https://github.com/cerner/clara-rules/issues/130</a> for details.</z><z id="t1542311583138400" t="mikerod @eraserhd @enn Yeah, if it isn’t documented seems like it probably should be"><y>#</y><d>2018-11-15</d><h>19:53</h><w>mikerod</w>@eraserhd @enn Yeah, if it isn’t documented seems like it probably should be</z><z id="t1542311592138700" t="mikerod good find on the relevant issue"><y>#</y><d>2018-11-15</d><h>19:53</h><w>mikerod</w>good find on the relevant issue</z><z id="t1542322544139600" t="eraserhd @claudius.nicolae We are going to start heavily using clara-eav, and we have three big pieces of functionality to contribute back."><y>#</y><d>2018-11-15</d><h>22:55</h><w>eraserhd</w>@claudius.nicolae We are going to start heavily using clara-eav, and we have three big pieces of functionality to contribute back.</z><z id="t1542322563139900" t="eraserhd Will you be at Clojure/conj?"><y>#</y><d>2018-11-15</d><h>22:56</h><w>eraserhd</w>Will you be at Clojure/conj?</z><z id="t1542658057141200" t="eraserhd I&apos;ve been reading Rete algorithm stuff, and I&apos;ve been wondering why I haven&apos;t seen references to this paper in them: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.5507 -- (I couldn&apos;t remember the name of the paper until it appeared on the Clojure list just recently.)"><y>#</y><d>2018-11-19</d><h>20:07</h><w>eraserhd</w>I&apos;ve been reading Rete algorithm stuff, and I&apos;ve been wondering why I haven&apos;t seen references to this paper in them: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.5507" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.5507</a> -- (I couldn&apos;t remember the name of the paper until it appeared on the Clojure list just recently.)</z><z id="t1542658116142300" t="eraserhd It seems like this is a bunch more thought that applies to how to build an alpha network than I&apos;ve seen mentioned before."><y>#</y><d>2018-11-19</d><h>20:08</h><w>eraserhd</w>It seems like this is a bunch more thought that applies to how to build an alpha network than I&apos;ve seen mentioned before.</z><z id="t1542658580142500" t="mikerod @eraserhd not familiar with this one."><y>#</y><d>2018-11-19</d><h>20:16</h><w>mikerod</w>@eraserhd not familiar with this one.</z><z id="t1542658626143100" t="mikerod looks like it’d take a bit to parse through it to see how the ideas relate to other rete things that are out there"><y>#</y><d>2018-11-19</d><h>20:17</h><w>mikerod</w>looks like it’d take a bit to parse through it to see how the ideas relate to other rete things that are out there</z><z id="t1542658982144600" t="eraserhd I have yet to see anything about optimizing the order of alpha tests, except for specific things like hashing 8 ways to find an alpha memory when using triplets."><y>#</y><d>2018-11-19</d><h>20:23</h><w>eraserhd</w>I have yet to see anything about optimizing the order of alpha tests, except for specific things like hashing 8 ways to find an alpha memory when using triplets.</z><z id="t1542659093145600" t="eraserhd AFAICT, there&apos;s no cases of filtering with user tests before storing in an alpha memory, even, and I presume that&apos;s because it&apos;s hard to know when you can do that and not duplicate memories?"><y>#</y><d>2018-11-19</d><h>20:24</h><w>eraserhd</w>AFAICT, there&apos;s no cases of filtering with user tests before storing in an alpha memory, even, and I presume that&apos;s because it&apos;s hard to know when you can do that and not duplicate memories?</z><z id="t1542659383146100" t="mikerod Clara’s alpha network partitions on how facts match the “type” criteria first"><y>#</y><d>2018-11-19</d><h>20:29</h><w>mikerod</w>Clara’s alpha network partitions on how facts match the “type” criteria first</z><z id="t1542659405146700" t="mikerod if you have alpha-side only constraints like [A (&lt; x 5)]"><y>#</y><d>2018-11-19</d><h>20:30</h><w>mikerod</w>if you have alpha-side only constraints like <code>[A (&lt; x 5)]</code></z><z id="t1542659420147100" t="mikerod those will be filtered as they come in and will not be stored in alpha mem if they don’t match"><y>#</y><d>2018-11-19</d><h>20:30</h><w>mikerod</w>those will be filtered as they come in and will not be stored in alpha mem if they don’t match</z><z id="t1542659470148100" t="mikerod and if you have variable bindings (via the overloaded = semantics), eg. [A (= ?x x)] , facts in the alpha memory will be stored in a hash lookup keyed by that variable binding"><y>#</y><d>2018-11-19</d><h>20:31</h><w>mikerod</w>and if you have variable bindings (via the overloaded <code>=</code> semantics), eg. <code>[A (= ?x x)]</code>, facts in the alpha memory will be stored in a hash lookup keyed by that variable binding</z><z id="t1542659516148500" t="mikerod those are the main alpha-side network details I can think of"><y>#</y><d>2018-11-19</d><h>20:31</h><w>mikerod</w>those are the main alpha-side network details I can think of</z><z id="t1542733378150700" t="souenzzo Case A [:test (my-pred?)] [MyFact [a] (= a ?a)] =&gt; .... Case B [MyFact [a] (= a ?a)] [:test (my-pred?)] =&gt; .... With A , clara will call my-pred? at mk-session With B , clara will call my-pred? at fire-rules There is docs about this behavior?"><y>#</y><d>2018-11-20</d><h>17:02</h><w>souenzzo</w>Case A
<pre>[:test (my-pred?)]
[MyFact [a] (= a ?a)]
=&gt;
....
</pre>
Case B
<pre>[MyFact [a] (= a ?a)]
[:test (my-pred?)]
=&gt;
....
</pre>
With <code>A</code>, clara will call <code>my-pred?</code> at <code>mk-session</code>
With <code>B</code>, clara will call <code>my-pred?</code> at <code>fire-rules</code>
There is docs about this behavior?</z><z id="t1542735939153000" t="ethanc I&apos;m not sure there is any document referencing that behavior. It would be an odd scenario to have a test node that is independent of the other nodes in a production. A typical scenario would make that test node dependent on some upstream fact, thus making the test node evaluate some time during fire-rules"><y>#</y><d>2018-11-20</d><h>17:45</h><w>ethanc</w>I&apos;m not sure there is any document referencing that behavior. It would be an odd scenario to have a test node that is independent of the other nodes in a production. A typical scenario would make that test node dependent on some upstream fact, thus making the test node evaluate some time during <code>fire-rules</code></z><z id="t1542737378153300" t="souenzzo @ethanc can I disable it?"><y>#</y><d>2018-11-20</d><h>18:09</h><w>souenzzo</w>@ethanc can I disable it?</z><z id="t1542737533155600" t="ethanc I&apos;m not sure what you mean by disable it . From your example above i am assuming that my-pred? is some sort of stateful check, and if that is true then i would recommend against imbedding that sort of logic in the network itself, maybe moving it to the RHS of the rule."><y>#</y><d>2018-11-20</d><h>18:12</h><w>ethanc</w>I&apos;m not sure what you mean by <code>disable it</code>. From your example above i am assuming that <code>my-pred?</code> is some sort of stateful check, and if that is true then i would recommend against imbedding that sort of logic in the network itself, maybe moving it to the RHS of the rule.</z><z id="t1542737607156000" t="souenzzo It&apos;s not statefull. it access a *dynamic* env var 🙂"><y>#</y><d>2018-11-20</d><h>18:13</h><w>souenzzo</w>It&apos;s not statefull. it access a <code>*dynamic*</code> env var <b>🙂</b></z><z id="t1542739418163300" t="ethanc The use of a dynamic var would likely be considered stateful, as the state of the var would impact the result from the predicate. Clara makes some pretty big assumptions on statelessness, as in it will not reevaluate conditions that it &quot;doesn&apos;t have to&quot;. Air quoting doesn&apos;t have to because clara determines what must be reevaluated by direct or indirect actions(Truth Maintenance) on the session, ie insertion or retraction of facts. That being said, if there is statefulness in a session&apos;s rules and for some reason that state changes then all bets are off when it comes to the validity of the outcome of said rules."><y>#</y><d>2018-11-20</d><h>18:43</h><w>ethanc</w>The use of a dynamic var would likely be considered stateful, as the state of the var would impact the result from the predicate.

Clara makes some pretty big assumptions on statelessness, as in it will not reevaluate conditions that it &quot;doesn&apos;t have to&quot;. Air quoting <code>doesn&apos;t have to</code> because clara determines what must be reevaluated by direct or indirect actions(Truth Maintenance) on the session, ie insertion or retraction of facts.
That being said, if there is statefulness in a session&apos;s rules and for some reason that state changes then all bets are off when it comes to the validity of the outcome of said rules.</z><z id="t1542739525163800" t="mikerod Perhaps you could instead insert facts that represent the same thing that this dynamic var encapsulates"><y>#</y><d>2018-11-20</d><h>18:45</h><w>mikerod</w>Perhaps you could instead insert facts that represent the same thing that this dynamic var encapsulates</z><z id="t1542739554164500" t="mikerod however, evaluating anything at “compile time” of mk-session seems weird to me. I’d have to see it reproduced probably to understand what may be happening there"><y>#</y><d>2018-11-20</d><h>18:45</h><w>mikerod</w>however, evaluating anything at “compile time” of <code>mk-session</code> seems weird to me. I’d have to see it reproduced probably to understand what may be happening there</z><z id="t1542745393164900" t="souenzzo https://gist.github.com/souenzzo/e38e600d486532308084c2bba0a9b3e9 @mikerod"><y>#</y><d>2018-11-20</d><h>20:23</h><w>souenzzo</w><a href="https://gist.github.com/souenzzo/e38e600d486532308084c2bba0a9b3e9" target="_blank">https://gist.github.com/souenzzo/e38e600d486532308084c2bba0a9b3e9</a> @mikerod</z><z id="t1542745553165300" t="souenzzo #tools-deps is awesme to report bugs ❤️"><y>#</y><d>2018-11-20</d><h>20:25</h><w>souenzzo</w>#tools-deps is awesme to report bugs <b>❤️</b></z><z id="t1542749769173800" t="ethanc @souenzzo, I was looking at your example, it seems that the side effect that you mention is due to: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L2050 which is used during the creation of the session as you described: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L264 The left activate in that snippet seems to be aimed at rules that have no LHS, ex: (r/defrule insert-sentinel =&gt; (r/insert! (-&gt;SomeFact))) the token being passed is empty. This &quot;bootstrapping&quot; operation is likely done because these productions wouldn&apos;t have an alpha-root for them to be triggered later. In your scenario: (defrule rule1 [:test (my-pred? :rule1)] [Fact (= a ?a)] =&gt; (prn [&quot;rule1&quot; ?a])) the first node in the beta-roots would be the test-node, as mentioned before this is not a normal pattern as test nodes are usually dependent on prior facts. When the conditions are reversed the test node would not be evaluated as it would be a child node of a join node."><y>#</y><d>2018-11-20</d><h>21:36</h><w>ethanc</w>@souenzzo,

I was looking at your example, it seems that the side effect that you mention is due to:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L2050" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L2050</a>
which is used during the creation of the session as you described:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L264" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L264</a>

The left activate in that snippet seems to be aimed at rules that have no LHS, ex:
<pre>(r/defrule insert-sentinel 
  =&gt;
  (r/insert! (-&gt;SomeFact)))
</pre>
the token being passed is empty. This &quot;bootstrapping&quot; operation is likely done because these productions wouldn&apos;t have an alpha-root for them to be triggered later.

In your scenario:
<pre>(defrule rule1
  [:test (my-pred? :rule1)]
  [Fact (= a ?a)]
  =&gt;
  (prn [&quot;rule1&quot; ?a]))
</pre>
the first node in the beta-roots would be the test-node, as mentioned before this is not a normal pattern as test nodes are usually dependent on prior facts.

When the conditions are reversed the test node would not be evaluated as it would be a child node of a join node.</z><z id="t1542750267178300" t="souenzzo PROPOSAL: If is possible to reach LHS, then run the RHS. If there is no how to reach LHS, then do not run anything in RHS. Is it possible? Is it reasonable? Should I open a issue? I think that I can try a PR."><y>#</y><d>2018-11-20</d><h>21:44</h><w>souenzzo</w>PROPOSAL: If is possible to reach LHS, then run the RHS. If there is no how to reach LHS, then do not run anything in RHS.
Is it possible? Is it reasonable? Should I open a issue? I think that I can try a PR.</z><z id="t1542754493182300" t="ethanc @souenzzo I&apos;m not sure i fully understand the intent of your proposal. The determination of RHS evaluation is done currently by percolating facts down the nodes until they ideally enter a ProductionNode, assuming all conditions are met. To do this we would still have to evaluate the truthiness of the LHS."><y>#</y><d>2018-11-20</d><h>22:54</h><w>ethanc</w>@souenzzo
I&apos;m not sure i fully understand the intent of your proposal.
The determination of RHS evaluation is done currently by percolating facts down the nodes until they ideally enter a ProductionNode, assuming all conditions are met.
To do this we would still have to evaluate the truthiness of the LHS.</z><z id="t1543266470184400" t="eraserhd Hey, where’s the source for the Clara Rules site? I don’t see it on gh-pages or master in the clara-rules repo. "><y>#</y><d>2018-11-26</d><h>21:07</h><w>eraserhd</w>Hey, where’s the source for the Clara Rules site?  I don’t see it on gh-pages or master in the clara-rules repo. </z><z id="t1543267557184800" t="mikerod @eraserhd https://github.com/cerner/clara-site"><y>#</y><d>2018-11-26</d><h>21:25</h><w>mikerod</w>@eraserhd <a href="https://github.com/cerner/clara-site" target="_blank">https://github.com/cerner/clara-site</a></z><z id="t1543268594185300" t="eraserhd oh, thanks"><y>#</y><d>2018-11-26</d><h>21:43</h><w>eraserhd</w>oh, thanks</z><z id="t1543270918185800" t="mikerod no prob, hopefully it has enough info there to see how to work with it"><y>#</y><d>2018-11-26</d><h>22:21</h><w>mikerod</w>no prob, hopefully it has enough info there to see how to work with it</z><z id="t1543279880188000" t="eraserhd waving Don’t know what it’d look like, but I’m at the Conj and would love to meet any/all people using or contributing to Clara."><y>#</y><d>2018-11-27</d><h>00:51</h><w>eraserhd</w><b>waving</b> Don’t know what it’d look like, but I’m at the Conj and would love to meet any/all people using or contributing to Clara.</z><z id="t1543280006188900" t="jvtrigueros Sad I’m missing Conj this year :( sounded like some really good stuff was gonna be announced"><y>#</y><d>2018-11-27</d><h>00:53</h><w>jvtrigueros</w>Sad I’m missing Conj this year :( sounded like some really good stuff was gonna be announced</z><z id="t1543293384189800" t="mikerod I won’t be at conj this year sadly. I know a few Clara contributors here are though. "><y>#</y><d>2018-11-27</d><h>04:36</h><w>mikerod</w>I won’t be at conj this year sadly. I know a few Clara contributors here are though. </z><z id="t1543520551190100" t="devn waving "><y>#</y><d>2018-11-29</d><h>19:42</h><w>devn</w><b>waving</b> </z><z id="t1543520573190800" t="devn not a contributor, but was a satisfied user for a few years "><y>#</y><d>2018-11-29</d><h>19:42</h><w>devn</w>not a contributor, but was a satisfied user for a few years </z><z id="t1544027024001600" t="eraserhd I&apos;m in the process of documenting :exists , and I see that there is a thing called :condition which also isn&apos;t documented."><y>#</y><d>2018-12-05</d><h>16:23</h><w>eraserhd</w>I&apos;m in the process of documenting <code>:exists</code>, and I see that there is a thing called <code>:condition</code> which also isn&apos;t documented.</z><z id="t1544028541001900" t="mikerod @eraserhd what is this :condition that you are referring to?"><y>#</y><d>2018-12-05</d><h>16:49</h><w>mikerod</w>@eraserhd what is this <code>:condition</code> that you are referring to?</z><z id="t1544028548002200" t="mikerod where do you see it?"><y>#</y><d>2018-12-05</d><h>16:49</h><w>mikerod</w>where do you see it?</z><z id="t1544028885002900" t="eraserhd In compiler.clj... I just realized that I didn&apos;t look at the context. It might be a compiler internal."><y>#</y><d>2018-12-05</d><h>16:54</h><w>eraserhd</w>In compiler.clj... I just realized that I didn&apos;t look at the context.  It might be a compiler internal.</z><z id="t1544028899003200" t="ethanc that sounds right"><y>#</y><d>2018-12-05</d><h>16:54</h><w>ethanc</w>that sounds right</z><z id="t1544028917003600" t="ethanc i would think that we surfaced it in the dsl proper"><y>#</y><d>2018-12-05</d><h>16:55</h><w>ethanc</w>i would think that we surfaced it in the dsl proper</z><z id="t1544029054003800" t="ethanc *wouldn&apos;t"><y>#</y><d>2018-12-05</d><h>16:57</h><w>ethanc</w>*wouldn&apos;t</z><z id="t1544029065004100" t="ethanc sorry about the confusion"><y>#</y><d>2018-12-05</d><h>16:57</h><w>ethanc</w>sorry about the confusion</z><z id="t1544030451004400" t="mikerod yeah, should just be internal compiler stuff"><y>#</y><d>2018-12-05</d><h>17:20</h><w>mikerod</w>yeah, should just be internal compiler stuff</z><z id="t1544030457004600" t="mikerod that’s what I thought :condition was"><y>#</y><d>2018-12-05</d><h>17:20</h><w>mikerod</w>that’s what I thought <code>:condition</code> was</z><z id="t1544102996006700" t="hjrnunes Hello! I&apos;m trying to get some explanations for my rules, but clara.tools.inspect/explain-activations doesn&apos;t print anything at all. With clara.tools.inspect/inspect I get a map but :fact-&gt;explanations is nil: {:rule-matches {{:ns-name validator.typing, :lhs [[:not {:type validator.typing.LowCardinality, :constraints []}]], :rhs (do (c/insert! (-&gt;ColType :t))), :props {:salience -100}, :name &quot;validator.typing/text&quot;, :doc &quot;The column is textual when cardinality is not low&quot;} (), ... :query-matches ... :condition-matches {{:type validator.typing.ColInfo, :constraints [(= 1 non-num-vals)]} (), {:type validator.typing.LowCardinality, :constraints []} (), ... :insertions {{:ns-name validator.typing, :lhs [[:not {:type validator.typing.LowCardinality, :constraints []}]], :rhs (do (c/insert! (-&gt;ColType :t))), :props {:salience -100}, :name &quot;validator.typing/text&quot;, :doc &quot;The column is textual when cardinality is not low&quot;} (), ...}, :fact-&gt;explanations nil} "><y>#</y><d>2018-12-06</d><h>13:29</h><w>hjrnunes</w>Hello! I&apos;m trying to get some explanations for my rules, but <code>clara.tools.inspect/explain-activations</code> doesn&apos;t print anything at all. With <code>clara.tools.inspect/inspect</code> I get a map but <code>:fact-&gt;explanations</code> is nil:
<pre>{:rule-matches
 {{:ns-name validator.typing,
   :lhs
            [[:not {:type validator.typing.LowCardinality, :constraints []}]],
   :rhs     (do (c/insert! (-&gt;ColType :t))),
   :props   {:salience -100},
   :name    &quot;validator.typing/text&quot;,
   :doc     &quot;The column is textual when cardinality is not low&quot;}
  (),
  ...
  :query-matches ...
  :condition-matches
  {{:type validator.typing.ColInfo, :constraints [(= 1 non-num-vals)]}
                                                                   (),
   {:type validator.typing.LowCardinality, :constraints []}        (),
   ...
  :insertions
  {{:ns-name validator.typing,
    :lhs
             [[:not {:type validator.typing.LowCardinality, :constraints []}]],
    :rhs     (do (c/insert! (-&gt;ColType :t))),
    :props   {:salience -100},
    :name    &quot;validator.typing/text&quot;,
    :doc     &quot;The column is textual when cardinality is not low&quot;}
   (),
   ...},
  :fact-&gt;explanations nil}
</pre></z><z id="t1544103013007100" t="hjrnunes Is this a problem with my rules?"><y>#</y><d>2018-12-06</d><h>13:30</h><w>hjrnunes</w>Is this a problem with my rules?</z><z id="t1544103057007500" t="hjrnunes Also, how do I interpret this data?"><y>#</y><d>2018-12-06</d><h>13:30</h><w>hjrnunes</w>Also, how do I interpret this data?</z><z id="t1544103449009200" t="hjrnunes OK, I re-read the docs, and I can&apos;t understand what is meant by &apos;logical insertions&quot;. Isn&apos;t this inserting a fact on the RHS of a rule? The one above is inserted in the RHS of a rule, but there&apos;s no explanation for it..."><y>#</y><d>2018-12-06</d><h>13:37</h><w>hjrnunes</w>OK, I re-read the docs, and I can&apos;t understand what is meant by &apos;logical insertions&quot;. Isn&apos;t this inserting a fact on the RHS of a rule? The one above is inserted in the RHS of a rule, but there&apos;s no explanation for it...</z><z id="t1544108874010300" t="mikerod @hjrnunes logical insertion is the default c/insert! in the RHS of the rules"><y>#</y><d>2018-12-06</d><h>15:07</h><w>mikerod</w>@hjrnunes logical insertion is the default <code>c/insert!</code> in the RHS of the rules</z><z id="t1544108915011300" t="mikerod it is referring to insertions that are managed by the truth maintenance system (TMS) of the engine. If the rule is found to later become unsatisfied in its LHS, the logically inserted fact will be automatically retracted."><y>#</y><d>2018-12-06</d><h>15:08</h><w>mikerod</w>it is referring to insertions that are managed by the truth maintenance system (TMS) of the engine. If the rule is found to later become unsatisfied in its LHS, the logically inserted fact will be automatically retracted.</z><z id="t1544108933011700" t="mikerod I don’t think that is your main question though, you are wondering why :fact-&gt;explanations is nil above"><y>#</y><d>2018-12-06</d><h>15:08</h><w>mikerod</w>I don’t think that is your main question though, you are wondering why <code>:fact-&gt;explanations</code> is nil above</z><z id="t1544109134012400" t="mikerod What you have above, if you look at :insertions , it is saying that the rule :name validator.typing/text had no facts inserted as a result of it."><y>#</y><d>2018-12-06</d><h>15:12</h><w>mikerod</w>What you have above, if you look at <code>:insertions</code>, it is saying that the rule <code>:name</code> <code>validator.typing/text</code> had no facts inserted as a result of it.</z><z id="t1544109155012700" t="mikerod Also, :rule-matches says similar, there were not matches for the rule"><y>#</y><d>2018-12-06</d><h>15:12</h><w>mikerod</w>Also, <code>:rule-matches</code> says similar, there were not matches for the rule</z><z id="t1544109183013200" t="mikerod So the result of this is that you have no facts that were inserted from a rule, so there are no :fact-&gt;explanations to show"><y>#</y><d>2018-12-06</d><h>15:13</h><w>mikerod</w>So the result of this is that you have no facts that were inserted from a rule, so there are no <code>:fact-&gt;explanations</code> to show</z><z id="t1544109205013500" t="mikerod Perhaps you can show how you ran this rule."><y>#</y><d>2018-12-06</d><h>15:13</h><w>mikerod</w>Perhaps you can show how you ran this rule.</z><z id="t1544117126014800" t="hjrnunes @mikerod thanks! I&apos;ll take a better look at the inspect result and rules tomorrow based on your feedback to see if I get it"><y>#</y><d>2018-12-06</d><h>17:25</h><w>hjrnunes</w>@mikerod thanks! I&apos;ll take a better look at the inspect result and rules tomorrow based on your feedback to see if I get it</z><z id="t1544117139015200" t="hjrnunes if not I&apos;ll come back with a fuller example"><y>#</y><d>2018-12-06</d><h>17:25</h><w>hjrnunes</w>if not I&apos;ll come back with a fuller example</z><z id="t1544117848015400" t="mikerod sounds good"><y>#</y><d>2018-12-06</d><h>17:37</h><w>mikerod</w>sounds good</z><z id="t1544472791016900" t="eraserhd AFAICT, I have a situation where a [:not [:or A B]] is being ignored on a rule. Any thoughts about how to troubleshoot this?"><y>#</y><d>2018-12-10</d><h>20:13</h><w>eraserhd</w>AFAICT, I have a situation where a [:not [:or A B]] is being ignored on a rule.  Any thoughts about how to troubleshoot this?</z><z id="t1544473967017800" t="mikerod @eraserhd there are certainly some issues that can happen with negated complex conditions. "><y>#</y><d>2018-12-10</d><h>20:32</h><w>mikerod</w>@eraserhd there are certainly some issues that can happen with negated complex conditions. </z><z id="t1544473976018200" t="mikerod Can find some in the github issues "><y>#</y><d>2018-12-10</d><h>20:32</h><w>mikerod</w>Can find some in the github issues </z><z id="t1544474015018900" t="mikerod One thing I’d do is to not combine it all to see that things work"><y>#</y><d>2018-12-10</d><h>20:33</h><w>mikerod</w>One thing I’d do is to not combine it all to see that things work</z><z id="t1544474131020300" t="mikerod I believe syntax is [:not [:or [A] [B]]]"><y>#</y><d>2018-12-10</d><h>20:35</h><w>mikerod</w>I believe syntax is [:not [:or [A] [B]]]</z><z id="t1544474143020600" t="mikerod But perhaps you were simplifying"><y>#</y><d>2018-12-10</d><h>20:35</h><w>mikerod</w>But perhaps you were simplifying</z><z id="t1544474155020800" t="mikerod Or I’m wrong hah"><y>#</y><d>2018-12-10</d><h>20:35</h><w>mikerod</w>Or I’m wrong hah</z><z id="t1544474873021500" t="eraserhd I&apos;m definitely simplifying. We&apos;re working on making a small reproduction. Maybe it&apos;ll go away, or we&apos;ll figure out we&apos;re doing something boneheaded. :D"><y>#</y><d>2018-12-10</d><h>20:47</h><w>eraserhd</w>I&apos;m definitely simplifying.  We&apos;re working on making a small reproduction.  Maybe it&apos;ll go away, or we&apos;ll figure out we&apos;re doing something boneheaded. :D</z><z id="t1544475442021900" t="mikerod Could do 2 not conditions for that one right"><y>#</y><d>2018-12-10</d><h>20:57</h><w>mikerod</w>Could do 2 not conditions for that one right</z><z id="t1544475469022700" t="mikerod But in general Clara compiler will try to convert things into disjunctive normal form. "><y>#</y><d>2018-12-10</d><h>20:57</h><w>mikerod</w>But in general Clara compiler will try to convert things into disjunctive normal form. </z><z id="t1544475488023400" t="mikerod Sometimes there may be issues with doing this when variable bindings are used across clauses that are moving around. "><y>#</y><d>2018-12-10</d><h>20:58</h><w>mikerod</w>Sometimes there may be issues with doing this when variable bindings are used across clauses that are moving around. </z><z id="t1544475513024300" t="mikerod It may or may not relate to your issue. I just think there were perhaps still a few edge cases pointed out in some gh issues outstanding"><y>#</y><d>2018-12-10</d><h>20:58</h><w>mikerod</w>It may or may not relate to your issue. I just think there were perhaps still a few edge cases pointed out in some gh issues outstanding</z><z id="t1544475567025400" t="mikerod I often will just advocate for breaking more complex expressions into separate rules that have intermediate facts between them to recreate the logic you are looking for"><y>#</y><d>2018-12-10</d><h>20:59</h><w>mikerod</w>I often will just advocate for breaking more complex expressions into separate rules that have intermediate facts between them to recreate the logic you are looking for</z><z id="t1544475600026400" t="mikerod Generally will lead to less confusion and more transparency in introspection since you can look at the intermediate facts. "><y>#</y><d>2018-12-10</d><h>21:00</h><w>mikerod</w>Generally will lead to less confusion and more transparency in introspection since you can look at the intermediate facts. </z><z id="t1544475613026900" t="mikerod Often perf is fine or better that way too, but that can depend. "><y>#</y><d>2018-12-10</d><h>21:00</h><w>mikerod</w>Often perf is fine or better that way too, but that can depend. </z><z id="t1544722457027600" t="eraserhd So, I should follow up. Clara was working correctly. We had an extra rule spelled weirdly enough to defy grep."><y>#</y><d>2018-12-13</d><h>17:34</h><w>eraserhd</w>So, I should follow up.  Clara was working correctly.  We had an extra rule spelled weirdly enough to defy grep.</z><z id="t1544722597028000" t="mikerod Oh good I suppose then. Hah"><y>#</y><d>2018-12-13</d><h>17:36</h><w>mikerod</w>Oh good I suppose then. Hah</z><z id="t1546978297002200" t="eraserhd Had some discussions about performance for our use cases, and I made a bunch of assumptions. 1) In terms of inserts/retracts and fire-rules, Clara is single-threaded and does not take advantage of parallelziation. 2) Working set size and memory bandwidth dominate CPU speed."><y>#</y><d>2019-01-08</d><h>20:11</h><w>eraserhd</w>Had some discussions about performance for our use cases, and I made a bunch of assumptions.  1) In terms of inserts/retracts and fire-rules, Clara is single-threaded and does not take advantage of parallelziation.  2) Working set size and memory bandwidth dominate CPU speed.</z><z id="t1546978327002500" t="eraserhd Do those sound accurate?"><y>#</y><d>2019-01-08</d><h>20:12</h><w>eraserhd</w>Do those sound accurate?</z><z id="t1546979312003100" t="mikerod @eraserhd (1) seems accurate enough; I think (2) isn’t clear enough to me to say yes/no"><y>#</y><d>2019-01-08</d><h>20:28</h><w>mikerod</w>@eraserhd (1) seems accurate enough; I think (2) isn’t clear enough to me to say yes/no</z><z id="t1546979415004000" t="mikerod The CPU is typically dominated by the number of constraints being evaluated against the working set of facts. So yes to that part I believe. What do you mean by memory bandwidth?"><y>#</y><d>2019-01-08</d><h>20:30</h><w>mikerod</w>The CPU is typically dominated by the number of constraints being evaluated against the working set of facts. So yes to that part I believe. What do you mean by memory bandwidth?</z><z id="t1547012699020400" t="devn I think they are saying what I might assume to be true. Large numbers of facts coupled with large numbers of rules are likely to create memory pressure as they scale in number. But, I’ll go on record as saying I doubt physical limits are a bottleneck when it comes to performance in Clara. Mechanical sympathists in the audience?"><y>#</y><d>2019-01-09</d><h>05:44</h><w>devn</w>I think they are saying what I might assume to be true. Large numbers of facts coupled with large numbers of rules are likely to create memory pressure as they scale in number. But, I’ll go on record as saying I doubt physical limits are a bottleneck when it comes to performance in Clara. Mechanical sympathists in the audience?</z><z id="t1547046460031100" t="wparker Agreed with (1), with the proviso that one could create multiple sessions and get parallelization that way. Regarding (2), in part I&apos;d have to give the annoying-but-true answer that much depends on the structure and size of your rule/fact set. For many use cases, particularly on clj since it has gotten most of the perf optimization, perf likely is good enough to be a non-issue. CPU can be a concern, especially for rulesets with lots of truth maintenance work. When you say memory bandwidth, do you just mean memory use or the actual speed of retrieval of data from RAM/the CPU cache? It isn&apos;t clear to me how you&apos;d optimize the latter effectively running on top of the JVM, but TBH I haven&apos;t thought about that level of optimization in the context of Clara. I suspect there&apos;s still much lower hanging fruit to work on in term of perf improvements."><y>#</y><d>2019-01-09</d><h>15:07</h><w>wparker</w>Agreed with (1), with the proviso that one could create multiple sessions and get parallelization that way.  Regarding (2), in part I&apos;d have to give the annoying-but-true answer that much depends on the structure and size of your rule/fact set.  For many use cases, particularly on clj since it has gotten most of the perf optimization, perf likely is good enough to be a non-issue.  CPU can be a concern, especially for rulesets with lots of truth maintenance work.  When you say memory bandwidth, do you just mean memory use or the actual speed of retrieval of data from RAM/the CPU cache?  It isn&apos;t clear to me how you&apos;d optimize the latter effectively running on top of the JVM, but TBH I haven&apos;t thought about that level of optimization in the context of Clara.  I suspect there&apos;s still much lower hanging fruit to work on in term of perf improvements.</z><z id="t1547046553032400" t="eraserhd @mikerod by memory bandwidth, I mean memory bus speed. If the working set is larger than cache, I assume the speed constraint is loading the data to the CPU, not number crunching."><y>#</y><d>2019-01-09</d><h>15:09</h><w>eraserhd</w>@mikerod by memory bandwidth, I mean memory bus speed.  If the working set is larger than cache, I assume the speed constraint is loading the data to the CPU, not number crunching.</z><z id="t1547046628033100" t="eraserhd And the way to optimize it is to choose a different AWS instance type :D"><y>#</y><d>2019-01-09</d><h>15:10</h><w>eraserhd</w>And the way to optimize it is to choose a different AWS instance type :D</z><z id="t1547047559033400" t="mikerod I see. Thanks for clarifying "><y>#</y><d>2019-01-09</d><h>15:25</h><w>mikerod</w>I see. Thanks for clarifying </z><z id="t1547047604034700" t="mikerod Yeah. All of this can contribute. The underlying hardware solution would likely be a last resort time. But if you are seeing a perf issue and can get profiler sampling data that could be useful. "><y>#</y><d>2019-01-09</d><h>15:26</h><w>mikerod</w>Yeah. All of this can contribute. The underlying hardware solution would likely be a last resort time. But if you are seeing a perf issue and can get profiler sampling data that could be useful. </z><z id="t1547047850036300" t="mikerod There are also some ways to look at tracing output to get a sense of count of times parts of the network were evaluated. Sometimes you can look for outliers there "><y>#</y><d>2019-01-09</d><h>15:30</h><w>mikerod</w>There are also some ways to look at tracing output to get a sense of count of times parts of the network were evaluated. Sometimes you can look for outliers there </z><z id="t1547049203041200" t="wparker Keep in mind that the CPU cache will hold more than just what you think of as the data e.g. routines of the JVM itself, methods from the Clojure runtime, Clara itself, etc. If you were trying to make the cache efficient that might dominate the actual “data” you’re working with. I’m a bit skeptical that that’s your dominating performance factor though - agreed with Mike that a profiler snapshot showing what’s taking time in Clara would be helpful."><y>#</y><d>2019-01-09</d><h>15:53</h><w>wparker</w>Keep in mind that the CPU cache will hold more than just what you think of as the data e.g. routines of the JVM itself, methods from the Clojure runtime, Clara itself, etc.  If you were trying to make the cache efficient that might dominate the actual “data” you’re working with.  I’m a bit skeptical that that’s your dominating performance factor though - agreed with Mike that a profiler snapshot showing what’s taking time in Clara would be helpful.</z><z id="t1547132740042100" t="mauricio.szabo Does clara supports creation of a session and firing rules in different threads? I&apos;m having an exception trying to do it: Exception in thread &quot;async-dispatch-24&quot; java.lang.IllegalArgumentException: find not supported on type: clara.rules.engine.Token$reify__26254 "><y>#</y><d>2019-01-10</d><h>15:05</h><w>mauricio.szabo</w>Does clara supports creation of a session and firing rules in different threads?

I&apos;m having an exception trying to do it:
<pre>Exception in thread &quot;async-dispatch-24&quot; java.lang.IllegalArgumentException: find not supported on type: clara.rules.engine.Token$reify__26254
</pre></z><z id="t1547134108042700" t="mikerod @mauricio.szabo I’d expect it to be ok. Can I see (1) more stack trace and (2) an (perhaps simplified) example of how you are setting up for this?"><y>#</y><d>2019-01-10</d><h>15:28</h><w>mikerod</w>@mauricio.szabo I’d expect it to be ok. Can I see (1) more stack trace and (2) an (perhaps simplified) example of how you are setting up for this?</z><z id="t1547137977046200" t="mauricio.szabo Ok, I&apos;ll run some code here and then give you the results"><y>#</y><d>2019-01-10</d><h>16:32</h><r>mauricio.szabo</r>Ok, I&apos;ll run some code here and then give you the results</z><z id="t1547141373052800" t="wparker Are you creating more than one session at a time? The compiler uses eval calls internally, and the Clojure compiler itself isn’t thread-safe."><y>#</y><d>2019-01-10</d><h>17:29</h><r>wparker</r>Are you creating more than one session at a time?  The compiler uses eval calls internally, and the Clojure compiler itself isn’t thread-safe.</z><z id="t1547141868053200" t="mikerod yeah, this is why I’m looking for some example of how it is being tried"><y>#</y><d>2019-01-10</d><h>17:37</h><r>mikerod</r>yeah, this is why I’m looking for some example of how it is being tried</z><z id="t1547143684054100" t="mauricio.szabo @U0KRSVDHR I&apos;ve tried creating more than one, and don&apos;t creating it, and they both gave me the same error"><y>#</y><d>2019-01-10</d><h>18:08</h><r>mauricio.szabo</r>@U0KRSVDHR I&apos;ve tried creating more than one, and don&apos;t creating it, and they both gave me the same error</z><z id="t1547143838054300" t="mikerod @mauricio.szabo can you give at least an outline of hwo you are doing this"><y>#</y><d>2019-01-10</d><h>18:10</h><r>mikerod</r>@mauricio.szabo can you give at least an outline of hwo you are doing this</z><z id="t1547143855054500" t="mikerod like how you create the session, and then how you distribute it to other threads"><y>#</y><d>2019-01-10</d><h>18:10</h><r>mikerod</r>like how you create the session, and then how you distribute it to other threads</z><z id="t1547143874054700" t="mikerod I’m guessing the other threads have the same classloaders too?"><y>#</y><d>2019-01-10</d><h>18:11</h><r>mikerod</r>I’m guessing the other threads have the same classloaders too?</z><z id="t1547143882054900" t="mikerod an example would make that easier to track through"><y>#</y><d>2019-01-10</d><h>18:11</h><r>mikerod</r>an example would make that easier to track through</z><z id="t1547143924055100" t="mauricio.szabo Okay, just give me some minutes 🙂"><y>#</y><d>2019-01-10</d><h>18:12</h><r>mauricio.szabo</r>Okay, just give me some minutes <b>🙂</b></z><z id="t1547144029055300" t="mikerod oh, no problem. not time sensitive (for me at least) hah"><y>#</y><d>2019-01-10</d><h>18:13</h><r>mikerod</r>oh, no problem. not time sensitive (for me at least) hah</z><z id="t1547146420055700" t="mauricio.szabo @U0LK1552A I&apos;m running the code in the following way: (let [session (-&gt; (mk-session &apos;events-reports.reports.deferred &apos;events-reports.reports.normalize-data :fact-type-fn :fact)) res (jdbc/query db &quot;SELECT * FROM my_table WHERE ...&quot;) location-ids (map :id res)] (doseq [id location-ids] (async/go (println &quot;Emitting for&quot; id) (jdbc/with-db-connection [db @smart/db] (let [facts (search-facts db id) rows (-&gt; session (insert-all facts) (fire-rules) (query detailed-anual-report) (-&gt;&gt; (map make-detailed-anual-row)))] (println &quot;Saving for&quot; id) (save-rows rows)))))) "><y>#</y><d>2019-01-10</d><h>18:53</h><r>mauricio.szabo</r>@U0LK1552A I&apos;m running the code in the following way:

<pre>(let [session (-&gt; (mk-session &apos;events-reports.reports.deferred
                              &apos;events-reports.reports.normalize-data
                              :fact-type-fn :fact))
      res (jdbc/query db &quot;SELECT * FROM my_table WHERE ...&quot;)
      location-ids (map :id res)]

  (doseq [id location-ids]
    (async/go
     (println &quot;Emitting for&quot; id)
     (jdbc/with-db-connection [db @smart/db]
        (let [facts (search-facts db id)
              rows (-&gt; session
                       (insert-all facts)
                       (fire-rules)
                       (query detailed-anual-report)
                       (-&gt;&gt; (map make-detailed-anual-row)))]
         (println &quot;Saving for&quot; id)
         (save-rows rows))))))
</pre></z><z id="t1547146493055900" t="mauricio.szabo (it&apos;s a simplified version. search-facts is simply a bunch of JDBC queries)"><y>#</y><d>2019-01-10</d><h>18:54</h><r>mauricio.szabo</r>(it&apos;s a simplified version. <code>search-facts</code> is simply a bunch of JDBC queries)</z><z id="t1547147154056100" t="mauricio.szabo Exception in thread &quot;async-dispatch-4&quot; java.lang.IllegalArgumentException: find not supported on type: clara.rules.engine.Token$reify__26254 at clojure.lang.RT.find(RT.java:863) at clojure.core$select_keys.invokeStatic(core.clj:1539) at clojure.core$select_keys.invoke(core.clj:1532) at clara.rules.engine$propagate_items_to_nodes$fn__26782.invoke(engine.cljc:154) at clara.rules.platform$group_by_seq$fn__26030.invoke(platform.cljc:39) at clojure.core.protocols$naive_seq_reduce.invokeStatic(protocols.clj:62) at clojure.core.protocols$interface_or_naive_reduce.invokeStatic(protocols.clj:72) at clojure.core.protocols$fn__7852.invokeStatic(protocols.clj:169) at clojure.core.protocols$fn__7852.invoke(protocols.clj:124) at clojure.core.protocols$fn__7807$G__7802__7816.invoke(protocols.clj:19) at clojure.core.protocols$seq_reduce.invokeStatic(protocols.clj:31) at clojure.core.protocols$fn__7835.invokeStatic(protocols.clj:75) at clojure.core.protocols$fn__7835.invoke(protocols.clj:75) at clojure.core.protocols$fn__7781$G__7776__7794.invoke(protocols.clj:13) at clojure.core$reduce.invokeStatic(core.clj:6748) at clojure.core$reduce.invoke(core.clj:6730) at clara.rules.platform$group_by_seq.invokeStatic(platform.cljc:38) at clara.rules.platform$group_by_seq.invoke(platform.cljc:27) at clara.rules.engine$propagate_items_to_nodes.invokeStatic(engine.cljc:154) at clara.rules.engine$propagate_items_to_nodes.invoke(engine.cljc:147) at clara.rules.engine.LocalTransport.send_elements(engine.cljc:176) at clara.rules.engine.AlphaNode.alpha_activate(engine.cljc:538) at clara.rules.engine$flush_updates$flush_all__26940.invoke(engine.cljc:269) at clara.rules.engine$flush_updates.invokeStatic(engine.cljc:277) at clara.rules.engine$flush_updates.invoke(engine.cljc:252) at clara.rules.engine$fire_rules_STAR_.invokeStatic(engine.cljc:1825) at clara.rules.engine$fire_rules_STAR_.invoke(engine.cljc:1720) at clara.rules.engine.LocalSession.fire_rules(engine.cljc:1909) at clara.rules$fire_rules.invokeStatic(rules.cljc:44) at clara.rules$fire_rules.invoke(rules.cljc:29) "><y>#</y><d>2019-01-10</d><h>19:05</h><r>mauricio.szabo</r><pre>Exception in thread &quot;async-dispatch-4&quot; java.lang.IllegalArgumentException: find not supported on type: clara.rules.engine.Token$reify__26254
        at clojure.lang.RT.find(RT.java:863)
        at clojure.core$select_keys.invokeStatic(core.clj:1539)
        at clojure.core$select_keys.invoke(core.clj:1532)
        at clara.rules.engine$propagate_items_to_nodes$fn__26782.invoke(engine.cljc:154)
        at clara.rules.platform$group_by_seq$fn__26030.invoke(platform.cljc:39)
        at clojure.core.protocols$naive_seq_reduce.invokeStatic(protocols.clj:62)
        at clojure.core.protocols$interface_or_naive_reduce.invokeStatic(protocols.clj:72)
        at clojure.core.protocols$fn__7852.invokeStatic(protocols.clj:169)
        at clojure.core.protocols$fn__7852.invoke(protocols.clj:124)
        at clojure.core.protocols$fn__7807$G__7802__7816.invoke(protocols.clj:19)
        at clojure.core.protocols$seq_reduce.invokeStatic(protocols.clj:31)
        at clojure.core.protocols$fn__7835.invokeStatic(protocols.clj:75)
        at clojure.core.protocols$fn__7835.invoke(protocols.clj:75)
        at clojure.core.protocols$fn__7781$G__7776__7794.invoke(protocols.clj:13)
        at clojure.core$reduce.invokeStatic(core.clj:6748)
        at clojure.core$reduce.invoke(core.clj:6730)
        at clara.rules.platform$group_by_seq.invokeStatic(platform.cljc:38)
        at clara.rules.platform$group_by_seq.invoke(platform.cljc:27)
        at clara.rules.engine$propagate_items_to_nodes.invokeStatic(engine.cljc:154)
        at clara.rules.engine$propagate_items_to_nodes.invoke(engine.cljc:147)
        at clara.rules.engine.LocalTransport.send_elements(engine.cljc:176)
        at clara.rules.engine.AlphaNode.alpha_activate(engine.cljc:538)
        at clara.rules.engine$flush_updates$flush_all__26940.invoke(engine.cljc:269)
        at clara.rules.engine$flush_updates.invokeStatic(engine.cljc:277)
        at clara.rules.engine$flush_updates.invoke(engine.cljc:252)
        at clara.rules.engine$fire_rules_STAR_.invokeStatic(engine.cljc:1825)
        at clara.rules.engine$fire_rules_STAR_.invoke(engine.cljc:1720)
        at clara.rules.engine.LocalSession.fire_rules(engine.cljc:1909)
        at clara.rules$fire_rules.invokeStatic(rules.cljc:44)
        at clara.rules$fire_rules.invoke(rules.cljc:29)
</pre></z><z id="t1547147163056300" t="mauricio.szabo (More stacktraces :))"><y>#</y><d>2019-01-10</d><h>19:06</h><r>mauricio.szabo</r>(More stacktraces :))</z><z id="t1547148807056600" t="mikerod thanks for the details"><y>#</y><d>2019-01-10</d><h>19:33</h><r>mikerod</r>thanks for the details</z><z id="t1547148817056800" t="mikerod nothing immediately is striking me as odd there"><y>#</y><d>2019-01-10</d><h>19:33</h><r>mikerod</r>nothing immediately is striking me as odd there</z><z id="t1547148858057000" t="mikerod looking some at what could be oging on"><y>#</y><d>2019-01-10</d><h>19:34</h><r>mikerod</r>looking some at what could be oging on</z><z id="t1547148921057200" t="mikerod This type clara.rules.engine.Token$reify__26254 is weird to me"><y>#</y><d>2019-01-10</d><h>19:35</h><r>mikerod</r>This type <code>clara.rules.engine.Token$reify__26254</code> is weird to me</z><z id="t1547148930057400" t="mikerod I’m not aware of any reify going on in relation to tokens"><y>#</y><d>2019-01-10</d><h>19:35</h><r>mikerod</r>I’m not aware of any <code>reify</code> going on in relation to tokens</z><z id="t1547148954057600" t="mikerod which, I’d think that’s what produces a name like that"><y>#</y><d>2019-01-10</d><h>19:35</h><r>mikerod</r>which, I’d think that’s what produces a name like that</z><z id="t1547149022057800" t="mikerod actually, must be thinking about that wrong, since you can’t reify a clara.rules.engine.Token , it’s a record"><y>#</y><d>2019-01-10</d><h>19:37</h><r>mikerod</r>actually, must be thinking about that wrong, since you can’t <code>reify</code> a <code>clara.rules.engine.Token</code>, it’s a record</z><z id="t1547149159058000" t="mikerod that is just relating to a reify happening from within the clj record impl I see - disregard those comments then,"><y>#</y><d>2019-01-10</d><h>19:39</h><r>mikerod</r>that is just relating to a reify happening from within the clj record impl I see - disregard those comments then,</z><z id="t1547149271058200" t="mauricio.szabo Do you want me to open an issue?"><y>#</y><d>2019-01-10</d><h>19:41</h><r>mauricio.szabo</r>Do you want me to open an issue?</z><z id="t1547149530058400" t="mikerod I suppose we can for tracking"><y>#</y><d>2019-01-10</d><h>19:45</h><r>mikerod</r>I suppose we can for tracking</z><z id="t1547149547058600" t="mikerod I think I’ve recreated it to some minimal degree as far as what could cause that type of exception"><y>#</y><d>2019-01-10</d><h>19:45</h><r>mikerod</r>I think I’ve recreated it to some minimal degree as far as what could cause that type of exception</z><z id="t1547149562058800" t="mikerod (find (.getLookupThunk (map-&gt;Token {}) :bindings) :x)"><y>#</y><d>2019-01-10</d><h>19:46</h><r>mikerod</r><code>(find (.getLookupThunk (map-&gt;Token {}) :bindings) :x)</code></z><z id="t1547149581059000" t="mikerod I believe the getLookupThunk can happen via clj keyword lookup compile-time inlining stuff"><y>#</y><d>2019-01-10</d><h>19:46</h><r>mikerod</r>I believe the <code>getLookupThunk</code> can happen via clj keyword lookup compile-time inlining stuff</z><z id="t1547149616059200" t="mikerod so this ends up coming from a call (:bindings &lt;token-obj&gt;) in the fn propagate-items-to-nodes"><y>#</y><d>2019-01-10</d><h>19:46</h><r>mikerod</r>so this ends up coming from a call <code>(:bindings &lt;token-obj&gt;)</code> in the fn <code>propagate-items-to-nodes</code></z><z id="t1547149896059400" t="mikerod Also, can you give me your clj/java/core.async versions?"><y>#</y><d>2019-01-10</d><h>19:51</h><r>mikerod</r>Also, can you give me your clj/java/core.async versions?</z><z id="t1547150527059600" t="mauricio.szabo Clojure version: Clojure 1.9.0 JVM version: Eclipse OpenJ9 VM 1.8.0_181-b13 Core.Async version: 0.4.490"><y>#</y><d>2019-01-10</d><h>20:02</h><r>mauricio.szabo</r>Clojure version: Clojure 1.9.0
JVM version: Eclipse OpenJ9 VM 1.8.0_181-b13
Core.Async version: 0.4.490</z><z id="t1547150535059800" t="mauricio.szabo Also, I&apos;ve opened an issue"><y>#</y><d>2019-01-10</d><h>20:02</h><r>mauricio.szabo</r>Also, I&apos;ve opened an issue</z><z id="t1547153227060000" t="mikerod thanks, I seeit"><y>#</y><d>2019-01-10</d><h>20:47</h><r>mikerod</r>thanks, I seeit</z><z id="t1547153277060200" t="mikerod this problem is weird. asked a bit on #clojure-dev to see if there were any thoughts on how you could end up with a keyword callsite messing up like this. The only possible thing that comes to mind so far is just making sure that you aren’t somehow requiring clara.rules.engine (or other ns’s) multiple times"><y>#</y><d>2019-01-10</d><h>20:47</h><r>mikerod</r>this problem is weird. asked a bit on #clojure-dev to see if there were any thoughts on how you could end up with a keyword callsite messing up like this. The only possible thing that comes to mind so far is just making sure that you aren’t somehow requiring clara.rules.engine (or other ns’s) multiple times</z><z id="t1547153295060400" t="mikerod so somehow getting different versions of the same classes loaded into successive clj dynamic class loaders"><y>#</y><d>2019-01-10</d><h>20:48</h><r>mikerod</r>so somehow getting different versions of the same classes loaded into successive clj dynamic class loaders</z><z id="t1547153816060600" t="mikerod It sort of looks to me now that you may have clojure.rules.engine being loaded more than once, and causing a duplicate class of clojure.rules.engine.Token being created."><y>#</y><d>2019-01-10</d><h>20:56</h><r>mikerod</r>It sort of looks to me now that you may have <code>clojure.rules.engine</code> being loaded more than once, and causing a duplicate class of clojure.rules.engine.Token being created.</z><z id="t1547134823043300" t="eraserhd Hmm, this seems to say that we have retractions, right? (We shouldn’t.):"><y>#</y><d>2019-01-10</d><h>15:40</h><w>eraserhd</w>Hmm, this seems to say that we have retractions, right?  (We shouldn’t.):</z><z id="t1547135242043600" t="ethanc I think I have seen this behavior before, but i need to verify my suspicions before I could say for sure."><y>#</y><d>2019-01-10</d><h>15:47</h><r>ethanc</r>I think I have seen this behavior before, but i need to verify my suspicions before I could say for sure.</z><z id="t1547135332043800" t="eraserhd We are currently investigating. What should we look for?"><y>#</y><d>2019-01-10</d><h>15:48</h><r>eraserhd</r>We are currently investigating.  What should we look for?</z><z id="t1547135757044000" t="ethanc If it is what i&apos;m thinking, its a scenario where facts are inserted but have no corresponding nodes to activate. Thus meaning all work in prior rules was &quot;unnecessary&quot; and can be retracted. It sounds weird making this comment, but i think it relates to keeping the memory as low as possible... Again, i need to verify this and i am writing a simple set of rules to test it"><y>#</y><d>2019-01-10</d><h>15:55</h><r>ethanc</r>If it is what i&apos;m thinking, its a scenario where facts are inserted but have no corresponding nodes to activate. Thus meaning all work in prior rules was &quot;unnecessary&quot; and can be retracted.

It sounds weird making this comment, but i think it relates to keeping the memory as low as possible...

Again, i need to verify this and i am writing a simple set of rules to test it</z><z id="t1547135898044200" t="eraserhd Ahhh, interesting. We probably do have a lot of facts that aren&apos;t used by rules."><y>#</y><d>2019-01-10</d><h>15:58</h><r>eraserhd</r>Ahhh, interesting.  We probably do have a lot of facts that aren&apos;t used by rules.</z><z id="t1547136607044400" t="eraserhd we&apos;ve verified that we&apos;re not intentionally retracting any datoms in this batch."><y>#</y><d>2019-01-10</d><h>16:10</h><r>eraserhd</r>we&apos;ve verified that we&apos;re not intentionally retracting any datoms in this batch.</z><z id="t1547136687044600" t="eraserhd scratch that, no we&apos;re seeing something weird"><y>#</y><d>2019-01-10</d><h>16:11</h><r>eraserhd</r>scratch that, no we&apos;re seeing something weird</z><z id="t1547137313044800" t="mikerod alpha-retract happens from the truth maintenance as well."><y>#</y><d>2019-01-10</d><h>16:21</h><r>mikerod</r><code>alpha-retract</code> happens from the truth maintenance as well.</z><z id="t1547137346045000" t="mikerod so using logical insert (the default) can/will lead to them as the TMS keeps the working state’s “truth” consistent"><y>#</y><d>2019-01-10</d><h>16:22</h><r>mikerod</r>so using logical insert (the default) can/will lead to them as the TMS keeps the working state’s “truth” consistent</z><z id="t1547137412045200" t="mikerod Seeing your screenshot there though - relative to the other times I see - it looks like a lot of time is being spent in equality comparisons."><y>#</y><d>2019-01-10</d><h>16:23</h><r>mikerod</r>Seeing your screenshot there though - relative to the other times I see - it looks like a lot of time is being spent in equality comparisons.</z><z id="t1547137447045400" t="mikerod However, the memory updating functions comparing tokens and “remove first of each” do not seem to be as high."><y>#</y><d>2019-01-10</d><h>16:24</h><r>mikerod</r>However, the memory updating functions comparing tokens and “remove first of each” do not seem to be as high.</z><z id="t1547137473045600" t="mikerod I’d have to expand on the callstack trees of these a bit more perhaps to really know what’s going on there though"><y>#</y><d>2019-01-10</d><h>16:24</h><r>mikerod</r>I’d have to expand on the callstack trees of these a bit more perhaps to really know what’s going on there though</z><z id="t1547137513045800" t="eraserhd @U3KC48GHW we made a mistake in a parameter in the call we are timing. After fixing, we don&apos;t see a high alpha-retract time."><y>#</y><d>2019-01-10</d><h>16:25</h><r>eraserhd</r>@U3KC48GHW we made a mistake in a parameter in the call we are timing.  After fixing, we don&apos;t see a high alpha-retract time.</z><z id="t1547138021046400" t="mauricio.szabo @U0ECYL0ET what are you using to profile Clara? I&apos;ve tried to use VisualVM but my code hang even with small group of facts..."><y>#</y><d>2019-01-10</d><h>16:33</h><r>mauricio.szabo</r>@U0ECYL0ET what are you using to profile Clara? I&apos;ve tried to use VisualVM but my code hang even with small group of facts...</z><z id="t1547138056046600" t="eraserhd I&apos;m using the CPU sampler in VisualVM. I&apos;ve never successfully used the profiler."><y>#</y><d>2019-01-10</d><h>16:34</h><r>eraserhd</r>I&apos;m using the CPU sampler in VisualVM.  I&apos;ve never successfully used the profiler.</z><z id="t1547138085046800" t="eraserhd The profiler always hangs for me no matter what I try."><y>#</y><d>2019-01-10</d><h>16:34</h><r>eraserhd</r>The profiler always hangs for me no matter what I try.</z><z id="t1547138245047000" t="mikerod Yeah, VisualVM CPU sampler is typically pretty useful"><y>#</y><d>2019-01-10</d><h>16:37</h><r>mikerod</r>Yeah, VisualVM CPU sampler is typically pretty useful</z><z id="t1547138267047200" t="mikerod I don’t try to use the more invasive profiler there - I don’t even know that I’d call that “recommended”"><y>#</y><d>2019-01-10</d><h>16:37</h><r>mikerod</r>I don’t try to use the more invasive profiler there - I don’t even know that I’d call that “recommended”</z><z id="t1547138305047400" t="mikerod @U0ECYL0ET the example you showed did not look to have a high time spent in alpha-retract, so confused why you considered it a problem there"><y>#</y><d>2019-01-10</d><h>16:38</h><r>mikerod</r>@U0ECYL0ET the example you showed did not look to have a high time spent in alpha-retract, so confused why you considered it a problem there</z><z id="t1547138316047600" t="mikerod Or perhaps your screenshot was just not indicative of what you are looking at."><y>#</y><d>2019-01-10</d><h>16:38</h><r>mikerod</r>Or perhaps your screenshot was just not indicative of what you are looking at.</z><z id="t1547138378047900" t="mikerod or maybe I was reading this wrong. I tend to look at the callstack based view - so nvm I think"><y>#</y><d>2019-01-10</d><h>16:39</h><r>mikerod</r>or maybe I was reading this wrong. I tend to look at the callstack based view - so nvm I think</z><z id="t1547138408048100" t="ethanc yeah, @U0LK1552A thats seems to be a hotspot view"><y>#</y><d>2019-01-10</d><h>16:40</h><r>ethanc</r>yeah, @U0LK1552A thats seems to be a hotspot view</z><z id="t1547138472048500" t="mikerod yep, just noticed. Harder to read that to me. but Yeah, that means it is the “entry point” to a lot of the stuff taking the higher self-times below"><y>#</y><d>2019-01-10</d><h>16:41</h><r>mikerod</r>yep, just noticed. Harder to read that to me. but Yeah, that means it is the “entry point” to a lot of the stuff taking the higher self-times below</z><z id="t1547138487048700" t="eraserhd Let me post a corrected screenshot..."><y>#</y><d>2019-01-10</d><h>16:41</h><r>eraserhd</r>Let me post a corrected screenshot...</z><z id="t1547138489048900" t="mikerod I prefer the other view to see a direct hierarchical/callstack visual on it"><y>#</y><d>2019-01-10</d><h>16:41</h><r>mikerod</r>I prefer the other view to see a direct hierarchical/callstack visual on it</z><z id="t1547138539049100" t="mikerod just easier to pinpoint the more specific path to trace through"><y>#</y><d>2019-01-10</d><h>16:42</h><r>mikerod</r>just easier to pinpoint the more specific path to trace through</z><z id="t1547140135052600" t="ethanc To my original comment, the scenario i was remembering was something like: (defrule simple-rule [A (= ?f f)] [?bs &lt;- (acc/all) :from [B (= f ?f)]] =&gt; (insert! (-&gt;C))) This does cause an retract on the production node, but thats due to new facts being add. So not as i remembered."><y>#</y><d>2019-01-10</d><h>17:08</h><r>ethanc</r>To my original comment,

the scenario i was remembering was something like:
<pre>(defrule simple-rule
 [A (= ?f f)]
 [?bs &lt;- (acc/all) :from [B (= f ?f)]] 
 =&gt;
(insert! (-&gt;C)))
</pre>

This does cause an retract on the production node, but thats due to new facts being add. So not as i remembered.</z><z id="t1547139120049300" t="eraserhd"><y>#</y><d>2019-01-10</d><h>16:52</h><w>eraserhd</w></z><z id="t1547139309049600" t="mikerod @U0ECYL0ET It’s a bit cutoff and always a challenge to really know. From this, it seems to suggest that you have a rule with a negation - :not that is initially true due to no matches at some point in fire-rules. Later, it gets matches so becomes false. Due to order of rule firing, when it is becomes false, there was already staged activations of the rule from when it was true that need to be discarded now that that is no longer the case - via the truth maintenance"><y>#</y><d>2019-01-10</d><h>16:55</h><r>mikerod</r>@U0ECYL0ET It’s a bit cutoff and always a challenge to really know.

From this, it seems to suggest that you have a rule with a negation - <code>:not</code> that is initially true due to no matches at some point in fire-rules. Later, it gets matches so becomes false.
Due to order of rule firing, when it is becomes false, there was already staged activations of the rule from when it was true that need to be discarded now that that is no longer the case - via the truth maintenance</z><z id="t1547139336049800" t="mikerod The activations being discarded may have large tokens as one possibility - perhaps there is a large data gathered via an accumulator in this rule?"><y>#</y><d>2019-01-10</d><h>16:55</h><r>mikerod</r>The activations being discarded may have large tokens as one possibility - perhaps there is a large data gathered via an accumulator in this rule?</z><z id="t1547139374050000" t="mikerod Alternatively, I may have to see more stack to know (or can’t really know), the rule had a lot of combinations of matches resulting in many activations that now all have to be discarded"><y>#</y><d>2019-01-10</d><h>16:56</h><r>mikerod</r>Alternatively, I may have to see more stack to know (or can’t really know), the rule had a lot of combinations of matches resulting in many activations that now all have to be discarded</z><z id="t1547139461050200" t="eraserhd OK, my reading also. We&apos;re going to try to isolate which rule(s) cause it."><y>#</y><d>2019-01-10</d><h>16:57</h><r>eraserhd</r>OK, my reading also.  We&apos;re going to try to isolate which rule(s) cause it.</z><z id="t1547139522051200" t="mikerod Maybe you can find one of that structure. The negation May be your actual last condition of the role, although that isn’t strictly true in all cases I believe. "><y>#</y><d>2019-01-10</d><h>16:58</h><r>mikerod</r>Maybe you can find one of that structure. The negation May be your actual last condition of the role, although that isn’t strictly true in all cases I believe. </z><z id="t1547139565052400" t="mikerod May be able to do some listener tracing to find more details too. I’d have to play around to come up with a useful example of how to use it in this sort of case. "><y>#</y><d>2019-01-10</d><h>16:59</h><r>mikerod</r>May be able to do some listener tracing to find more details too. I’d have to play around to come up with a useful example of how to use it in this sort of case. </z><z id="t1547141989053400" t="wparker Regarding tracing - I wrote some helpers at one point for this that I really need to clean up some and push to master - but basically you get an entry in a list for every interaction in the rules engine, most of which have a node ID attached. You can then use that ID to look up the node in the session and see what rules/queries it corresponds to. So if you see an ID come up a lot those rules are doing a lot of work. Since it is ordered, you can investigate in more complex ways, but often a “lots of stuff is happening in this rule” can be enough to narrow things down enough"><y>#</y><d>2019-01-10</d><h>17:39</h><r>wparker</r>Regarding tracing - I wrote some helpers at one point for this that I really need to clean up some and push to master - but basically you get an entry in a list for every interaction in the rules engine, most of which have a node ID attached.  You can then use that ID to look up the node in the session and see what rules/queries it corresponds to.  So if you see an ID come up a lot those rules are doing a lot of work.  Since it is ordered, you can investigate in more complex ways, but often a “lots of stuff is happening in this rule” can be enough to narrow things down enough</z><z id="t1547142330053700" t="mikerod would be good to get some doc examples of this sort of thing"><y>#</y><d>2019-01-10</d><h>17:45</h><r>mikerod</r>would be good to get some doc examples of this sort of thing</z><z id="t1547385547061600" t="fricke Hi all, (in the google-group the title is Infinite Loop when using :not-guard in a rule) I tried to do something that is really easy to do in e.g. Datalog, like having given a node-&gt;parent relationship, I try to get hold of all the parents that are around (no duplicates). This snippet show the data-model with the rule: (defrecord Node2Parent [node parent]) (defrecord Node [node]) (r/defrule insert-all-parents [Node2Parent (= ?parent parent)] [:not [Node (= node ?parent)]] =&gt; (r/insert! (-&gt;Node ?parent)) ) The way I read this is that we add a new Node -fact for each occurring parent, that has not been added already. And here&apos;s how I call it: (defn s [] (-&gt; (r/mk-session &apos;engine.core) (r/insert (-&gt;Node2Parent :inner1 :root) (-&gt;Node2Parent :leaf1 :root) (-&gt;Node2Parent :leaf2 :inner1) (-&gt;Node2Parent :leaf3 :inner1)) (r/fire-rules))) (r/defquery all-nodes &quot;all nodes&quot; [] [Node (= ?node node)]) (r/query (s) all-nodes) It goes into a infinite loop and never comes back. Adding a print-statement to the rule tell you that it keeps adding :root nodes to the fact-base. I guess that I miss something the way the unification in the LHS-conditions play out. thanks and regards markus"><y>#</y><d>2019-01-13</d><h>13:19</h><w>fricke</w>Hi all,

(in the google-group the title is Infinite Loop when using :not-guard in a rule)

I tried to do something that is really easy to do in e.g. Datalog, like having given a node-&gt;parent relationship, I try to get hold of all the parents that are around (no duplicates). This snippet show the data-model with the rule:

<pre>(defrecord Node2Parent [node parent])
(defrecord Node [node])
(r/defrule insert-all-parents
  [Node2Parent (= ?parent parent)]
  [:not [Node (= node ?parent)]]
  =&gt;
  (r/insert! (-&gt;Node ?parent))
  )</pre>

The way I read this is that we add a new <code>Node</code>-fact for each occurring parent, that has not been added already.

And here&apos;s how I call it:
<pre>(defn s [] (-&gt; (r/mk-session &apos;engine.core) (r/insert (-&gt;Node2Parent :inner1 :root)
                                                     (-&gt;Node2Parent :leaf1 :root)
                                                 (-&gt;Node2Parent :leaf2 :inner1)
                                                 (-&gt;Node2Parent :leaf3 :inner1))
           (r/fire-rules)))

(r/defquery all-nodes &quot;all nodes&quot;
  []
  [Node (= ?node node)])
(r/query (s) all-nodes)</pre>

It goes into a infinite loop and never comes back. Adding a print-statement to the rule tell you that it keeps adding :root nodes to the fact-base.
I guess that I miss something the way the unification in the LHS-conditions play out.

thanks and regards
markus</z><z id="t1547395486063800" t="eraserhd @markus.frick the issue here is that Clara performs &quot;truth maintenance&quot;. The better way to interpret the Node2Parent rule is, &quot;Every Node which does not have a parent, should have a parent.&quot;"><y>#</y><d>2019-01-13</d><h>16:04</h><w>eraserhd</w>@markus.frick the issue here is that Clara performs &quot;truth maintenance&quot;.  The better way to interpret the Node2Parent rule is, &quot;Every Node which does not have a parent, should have a parent.&quot;</z><z id="t1547395551065100" t="eraserhd In this case, it confuses Clara. Clara sees a node with no parent and decides it should have one. Then it sees that the node has a parent, and therefore shouldn&apos;t have one, and therefore retracts it."><y>#</y><d>2019-01-13</d><h>16:05</h><w>eraserhd</w>In this case, it confuses Clara.  Clara sees a node with no parent and decides it should have one.  Then it sees that the node has a parent, and therefore shouldn&apos;t have one, and therefore retracts it.</z><z id="t1547395606065900" t="eraserhd If there&apos;s no other way for Node to be created, just remove the :not. If there is, you&apos;ll likely have to restructure it."><y>#</y><d>2019-01-13</d><h>16:06</h><w>eraserhd</w>If there&apos;s no other way for Node to be created, just remove the :not.  If there is, you&apos;ll likely have to restructure it.</z><z id="t1547396274069700" t="ethanc You could also use an unconditional insert, as this would remove the fact from truth maintenance."><y>#</y><d>2019-01-13</d><h>16:17</h><w>ethanc</w>You could also use an unconditional insert, as this would remove the fact from truth maintenance.</z><z id="t1547408239075000" t="fricke oh thanks a lot; I totally missed the &quot;truth maintenance&quot; aspect (coming from a Datalog world where rule-evaluation is monotonous). I guess it&apos;s just easier to understand and implement, if I add the Node -facts by hand and add them to the session before I execute the rules. More so, since I won&apos;t get rid of the duplicate facts anyway. With unconditional inserts I get ({:?node :root} {:?node :inner1} {:?node :inner1} {:?node :root}) I guess set semantics are just really difficult to have in a world where you just see the fixed number of facts from the LHS. thanks, markus"><y>#</y><d>2019-01-13</d><h>19:37</h><w>fricke</w>oh thanks a lot;  I totally missed the &quot;truth maintenance&quot; aspect (coming from a Datalog world where rule-evaluation is monotonous). I guess it&apos;s just easier to understand and implement, if I add the <code>Node</code>-facts by hand and add them to the session before I execute the rules. More so, since I won&apos;t get rid of the duplicate facts anyway.
With unconditional inserts I get
<pre>({:?node :root} {:?node :inner1} {:?node :inner1} {:?node :root})</pre>
I guess set semantics are just really difficult to have in a world where you just see the fixed number of facts from the LHS.

thanks, markus</z><z id="t1547587762075700" t="mikerod @markus.frick late to this answer, but you can eliminate duplicates via “intermediary facts” and accumulators"><y>#</y><d>2019-01-15</d><h>21:29</h><w>mikerod</w>@markus.frick late to this answer, but you can eliminate duplicates via “intermediary facts” and accumulators</z><z id="t1547587933075800" t="mikerod"><y>#</y><d>2019-01-15</d><h>21:32</h><w>mikerod</w></z><z id="t1548116054077400" t="eraserhd I feel like I need a CLI program like awk but using Rete / Datalog. It would be a souped-up join ."><y>#</y><d>2019-01-22</d><h>00:14</h><w>eraserhd</w>I feel like I need a CLI program like awk but using Rete / Datalog.  It would be a souped-up <code>join</code>.</z><z id="t1548116111078400" t="eraserhd It would take a rule description and an input file of facts, and the RHS can be only &quot;print&quot; or &quot;insert fact&quot;."><y>#</y><d>2019-01-22</d><h>00:15</h><w>eraserhd</w>It would take a rule description and an input file of facts, and the RHS can be only &quot;print&quot; or &quot;insert fact&quot;.</z><z id="t1548288534079300" t="kahunamoore Did you ever get a response here or elsewhere?"><y>#</y><d>2019-01-24</d><h>00:08</h><w>kahunamoore</w>Did you ever get a response here or elsewhere?</z><z id="t1548289550080500" t="jvtrigueros I would use that. Trying to figure out a rule system isn’t straightforward if you’re not used to it "><y>#</y><d>2019-01-24</d><h>00:25</h><w>jvtrigueros</w>I would use that. Trying to figure out a rule system isn’t straightforward if you’re not used to it </z><z id="t1548346745082300" t="eraserhd @kahunamoore no discussion elsewhere"><y>#</y><d>2019-01-24</d><h>16:19</h><w>eraserhd</w>@kahunamoore no discussion elsewhere</z><z id="t1548346772082900" t="eraserhd I suspect I&apos;ll eventually do it, but it&apos;s behind another personal project that&apos;s probably months away."><y>#</y><d>2019-01-24</d><h>16:19</h><w>eraserhd</w>I suspect I&apos;ll eventually do it, but it&apos;s behind another personal project that&apos;s probably months away.</z><z id="t1548347338083400" t="mikerod @eraserhd sorry for delay, wasn’t completely clear on what you were saying there"><y>#</y><d>2019-01-24</d><h>16:28</h><w>mikerod</w>@eraserhd sorry for delay, wasn’t completely clear on what you were saying there</z><z id="t1548347373083800" t="mikerod is a “rule description” a set of rules/queries? so a ruleset?"><y>#</y><d>2019-01-24</d><h>16:29</h><w>mikerod</w>is a “rule description” a set of rules/queries? so a ruleset?</z><z id="t1548347501084300" t="mikerod And this would be convenient because you could tie it in with scripts?"><y>#</y><d>2019-01-24</d><h>16:31</h><w>mikerod</w>And this would be convenient because you could tie it in with scripts?</z><z id="t1548355092085800" t="wparker I&apos;m also not clear on what&apos;s being discussed - is this a proposed tool for rule generation?"><y>#</y><d>2019-01-24</d><h>18:38</h><w>wparker</w>I&apos;m also not clear on what&apos;s being discussed - is this a proposed tool for rule generation?</z><z id="t1548359601087000" t="eraserhd Ahhh.... OK. So I&apos;m thinking of a tool like awk that can take a ruleset with -e the way awk takes a program, and reads facts from input, like an FS separated file."><y>#</y><d>2019-01-24</d><h>19:53</h><w>eraserhd</w>Ahhh.... OK.  So I&apos;m thinking of a tool like awk that can take a ruleset with -e the way awk takes a program, and reads facts from input, like an FS separated file.</z><z id="t1548359675088100" t="eraserhd The example I came up with was a script to iterate through my tmux panes and use their positions to find the upper-rightmost pane (because I need to configure the editor in that one)."><y>#</y><d>2019-01-24</d><h>19:54</h><w>eraserhd</w>The example I came up with was a script to iterate through my tmux panes and use their positions to find the upper-rightmost pane (because I need to configure the editor in that one).</z><z id="t1548359757089400" t="eraserhd So essentially I had two tables: &lt;top&gt; &lt;left&gt; &lt;pane-id&gt; and &lt;pane-id&gt; &lt;editor-id&gt;."><y>#</y><d>2019-01-24</d><h>19:55</h><w>eraserhd</w>So essentially I had two tables:  &lt;top&gt; &lt;left&gt; &lt;pane-id&gt; and &lt;pane-id&gt; &lt;editor-id&gt;.</z><z id="t1548359772089800" t="eraserhd And this is in shell, because my editor likes to be extended that way."><y>#</y><d>2019-01-24</d><h>19:56</h><w>eraserhd</w>And this is in shell, because my editor likes to be extended that way.</z><z id="t1548359824090300" t="eraserhd But it seemed natural to have a tool that can do datalog-like queries on files like this."><y>#</y><d>2019-01-24</d><h>19:57</h><w>eraserhd</w>But it seemed natural to have a tool that can do datalog-like queries on files like this.</z><z id="t1548963560094400" t="wparker Ok I think I see @eraserhd. I&apos;ve only used Clara personally as a component of larger JVM systems so I haven&apos;t needed a CLI tool but I can see the utility and it doesn&apos;t sound unduly difficult. I haven&apos;t heard of any existing such CLI tools though."><y>#</y><d>2019-01-31</d><h>19:39</h><w>wparker</w>Ok I think I see @eraserhd.  I&apos;ve only used Clara personally as a component of larger JVM systems so I haven&apos;t needed a CLI tool but I can see the utility and it doesn&apos;t sound unduly difficult.  I haven&apos;t heard of any existing such CLI tools though.</z><z id="t1549107107101800" t="david_clojurian Hello everyone, I have a problem with clara rules and I hope you can help me. To resolve components that are productive I create facts of dependencies and mark components that are used by productive components as productive as well. Right when I have a loop in the dependency chain, clara rules ends up in a endless loop while firing rules. Here is the code: (ns clara.error (:require [clara.rules :refer :all])) (defrecord DependsOn [element dep]) (defrecord Productive [element]) (defrule productive &quot;&quot; [DependsOn (= ?element1 element) (= ?element2 dep)] [Productive (= ?element1 element)] =&gt; (insert! (-&gt;Productive ?element2))) ; Works (as-&gt; (mk-session &apos;clara.error) $ (apply insert $ [(-&gt;Productive &quot;A&quot;)]) (apply insert $ [(-&gt;DependsOn &quot;A&quot; &quot;B&quot;) (-&gt;DependsOn &quot;B&quot; &quot;C&quot;) (-&gt;DependsOn &quot;C&quot; &quot;D&quot;)]) (fire-rules $)) ; ends in a loop (as-&gt; (mk-session &apos;clara.error) $ (apply insert $ [(-&gt;Productive &quot;A&quot;)]) (apply insert $ [(-&gt;DependsOn &quot;A&quot; &quot;B&quot;) (-&gt;DependsOn &quot;B&quot; &quot;C&quot;) (-&gt;DependsOn &quot;C&quot; &quot;A&quot;)]) (fire-rules $)) The approach of clara rules is awesome. That&apos;s why I hope we can find the problem so I can continue using clara rules. Thanks in advance."><y>#</y><d>2019-02-02</d><h>11:31</h><w>david_clojurian</w>Hello everyone,
I have a problem with clara rules and I hope you can help me.
To resolve components that are productive I create facts of dependencies and mark components that are used by productive components as productive as well.
Right when I have a loop in the dependency chain, clara rules ends up in a endless loop while firing rules.
Here is the code:
<pre>(ns clara.error
  (:require [clara.rules :refer :all]))

(defrecord DependsOn [element dep])
(defrecord Productive [element])

(defrule productive
  &quot;&quot;
  [DependsOn (= ?element1 element) (= ?element2 dep)]
  [Productive (= ?element1 element)]
  =&gt;
  (insert! (-&gt;Productive ?element2)))

; Works
(as-&gt; (mk-session &apos;clara.error) $
      (apply insert $ [(-&gt;Productive &quot;A&quot;)])
      (apply insert $ [(-&gt;DependsOn &quot;A&quot; &quot;B&quot;)
                       (-&gt;DependsOn &quot;B&quot; &quot;C&quot;)
                       (-&gt;DependsOn &quot;C&quot; &quot;D&quot;)])
      (fire-rules $))

; ends in a loop
(as-&gt; (mk-session &apos;clara.error) $
      (apply insert $ [(-&gt;Productive &quot;A&quot;)])
      (apply insert $ [(-&gt;DependsOn &quot;A&quot; &quot;B&quot;)
                       (-&gt;DependsOn &quot;B&quot; &quot;C&quot;)
                       (-&gt;DependsOn &quot;C&quot; &quot;A&quot;)])
      (fire-rules $))
</pre>
The approach of clara rules is awesome. That&apos;s why I hope we can find the problem so I can continue using clara rules.
Thanks in advance.</z><z id="t1549186847107200" t="ggaillard Hey David! I&apos;ve been using for some time so I hope I&apos;ll be able to help. Based on the graph you are building, if I understand correctly, it seems normal that Clara ends up looping. You have Productive -[DependsOn]-&gt; Productive . And you insert A -&gt; B -&gt; C -&gt; A , but A DependsOn B , so clara run again A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B … . You have a loop in your graph. It might be a problem with identity. You create a new Productive instance every time, but do clara knows that (-&gt;Productive &quot;A&quot;) is identical by value to (-&gt;Productive &quot;A&quot;) (new instance) ?"><y>#</y><d>2019-02-03</d><h>09:40</h><w>ggaillard</w>Hey David! I&apos;ve been using for some time so I hope I&apos;ll be able to help.
Based on the graph you are building, if I understand correctly, it seems normal that Clara ends up looping.
You have <code>Productive -[DependsOn]-&gt; Productive</code>.
And you insert <code>A -&gt; B -&gt; C -&gt; A</code>, but <code>A DependsOn B</code>, so clara run again <code>A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B …</code>. You have a loop in your graph.
It might be a problem with identity. You create a new <code>Productive</code> instance every time, but do clara knows that <code>(-&gt;Productive &quot;A&quot;)</code> is identical by value to <code>(-&gt;Productive &quot;A&quot;)</code> (new instance) ?</z><z id="t1549187010110600" t="david_clojurian Hello @ggaillard. I filed an issue on github and I get 2 answers. I&apos;m evaluating these answers now, but as far as I can see, it seems to resolve my issue. Here is the link: https://github.com/cerner/clara-rules/issues/418"><y>#</y><d>2019-02-03</d><h>09:43</h><w>david_clojurian</w>Hello @ggaillard. I filed an issue on github and I get 2 answers. I&apos;m evaluating these answers now, but as far as I can see, it seems to resolve my issue. Here is the link: <a href="https://github.com/cerner/clara-rules/issues/418" target="_blank">https://github.com/cerner/clara-rules/issues/418</a></z><z id="t1549187034110900" t="ggaillard Ah nice, will look into it!"><y>#</y><d>2019-02-03</d><h>09:43</h><r>ggaillard</r>Ah nice, will look into it!</z><z id="t1550613848003500" t="eraserhd Over the next week or so, we&apos;re going to be working on a library to translate pull expressions into Clara rules productions. Any thoughts on that now could shape how this works."><y>#</y><d>2019-02-19</d><h>22:04</h><w>eraserhd</w>Over the next week or so, we&apos;re going to be working on a library to translate pull expressions into Clara rules productions.  Any thoughts on that now could shape how this works.</z><z id="t1550615586005100" t="dominicm Why do you need this? I&apos;m missing something I think "><y>#</y><d>2019-02-19</d><h>22:33</h><r>dominicm</r>Why do you need this? I&apos;m missing something I think </z><z id="t1550617239005300" t="eraserhd The primary system I work on models tasks and data dependencies. Inputs and output for a task are described as pull expressions, and this allows us to compute task dependencies. We couldn&apos;t do this with raw Clara queries, since they model general computation so halting problem yada yada."><y>#</y><d>2019-02-19</d><h>23:00</h><r>eraserhd</r>The primary system I work on models tasks and data dependencies.  Inputs and output for a task are described as pull expressions, and this allows us to compute task dependencies.  We couldn&apos;t do this with raw Clara queries, since they model general computation so halting problem yada yada.</z><z id="t1550617274005500" t="eraserhd Pull expressions are a really nice, natural way to describe the shape of data wanted, IMHO."><y>#</y><d>2019-02-19</d><h>23:01</h><r>eraserhd</r>Pull expressions are a really nice, natural way to describe the shape of data wanted, IMHO.</z><z id="t1550617385005700" t="eraserhd We are moving to Clara handling more of the computation, because its truth maintenance property solves a lot of problem for us, and one of the new things we want to know is when a tasks inputs have changed, in order to retrigger our task."><y>#</y><d>2019-02-19</d><h>23:03</h><r>eraserhd</r>We are moving to Clara handling more of the computation, because its truth maintenance property solves a lot of problem for us, and one of the new things we want to know is when a tasks inputs have changed, in order to retrigger our task.</z><z id="t1550617465005900" t="eraserhd So we&apos;re building this library to have Clara compute the inputs for a task in real time and update them as new data arrives."><y>#</y><d>2019-02-19</d><h>23:04</h><r>eraserhd</r>So we&apos;re building this library to have Clara compute the inputs for a task in real time and update them as new data arrives.</z><z id="t1550634497009400" t="adamfeldman @U0ECYL0ET sounds like an interesting project. Do the task inputs and outputs change frequently, preventing the use of a simple dependency graph? Can you say more about the business domain? If you haven’t seen this, you may find it useful for working with pull expressions: https://github.com/edn-query-language/eql"><y>#</y><d>2019-02-20</d><h>03:48</h><r>adamfeldman</r>@U0ECYL0ET sounds like an interesting project. Do the task inputs and outputs change frequently, preventing the use of a simple dependency graph? Can you say more about the business domain?

If you haven’t seen this, you may find it useful for working with pull expressions: <a href="https://github.com/edn-query-language/eql" target="_blank">https://github.com/edn-query-language/eql</a></z><z id="t1550644489009700" t="dominicm This sounds quite similar to something I&apos;ve been working on in my spare time! "><y>#</y><d>2019-02-20</d><h>06:34</h><r>dominicm</r>This sounds quite similar to something I&apos;ve been working on in my spare time! </z><z id="t1550670919000100" t="eraserhd @UCHV4JZ7A the problem with a hand-coded dependency graph is that the tasks are sort of &quot;locally owned&quot; by different teams. This project coordinates tasks across the org."><y>#</y><d>2019-02-20</d><h>13:55</h><r>eraserhd</r>@UCHV4JZ7A the problem with a hand-coded dependency graph is that the tasks are sort of &quot;locally owned&quot; by different teams.  This project coordinates tasks across the org.</z><z id="t1550671039000300" t="eraserhd eql looks really neat, definitely something to investigate"><y>#</y><d>2019-02-20</d><h>13:57</h><r>eraserhd</r>eql looks really neat, definitely something to investigate</z><z id="t1550671205000500" t="dominicm @U0ECYL0ET are you familiar with terraform at all? would you say your tool is similar?"><y>#</y><d>2019-02-20</d><h>14:00</h><r>dominicm</r>@U0ECYL0ET are you familiar with terraform at all? would you say your tool is similar?</z><z id="t1550671488000700" t="eraserhd I am familiar, we use it. I have big rants on terraform. Our thing is much higher level."><y>#</y><d>2019-02-20</d><h>14:04</h><r>eraserhd</r>I am familiar, we use it.  I have big rants on terraform.  Our thing is much higher level.</z><z id="t1550671625000900" t="eraserhd Our thing&apos;s tasks are like, &quot;we need a marketing site&quot;. That integration might use terraform."><y>#</y><d>2019-02-20</d><h>14:07</h><r>eraserhd</r>Our thing&apos;s tasks are like, &quot;we need a marketing site&quot;.  That integration might use terraform.</z><z id="t1550671720002300" t="eraserhd There&apos;s some similarities, except that we really lean on forward-chaining rules. We need to have things built as early as possible, and we incrementally discover the information we need to do things."><y>#</y><d>2019-02-20</d><h>14:08</h><r>eraserhd</r>There&apos;s some similarities, except that we really lean on forward-chaining rules.  We need to have things built as early as possible, and we incrementally discover the information we need to do things.</z><z id="t1550671770002900" t="eraserhd A terraform-like thing using Clara would be nice!"><y>#</y><d>2019-02-20</d><h>14:09</h><r>eraserhd</r>A terraform-like thing using Clara would be nice!</z><z id="t1550672992006000" t="dominicm I want to write a terraform like thing in clojure. So I may look closer at what you&apos;re saying here."><y>#</y><d>2019-02-20</d><h>14:29</h><r>dominicm</r>I want to write a terraform like thing in clojure. So I may look closer at what you&apos;re saying here.</z><z id="t1550673196000400" t="adamfeldman @U09LZR36F Pulumi uses Terraform under the hood (and therefore takes advantage of the existing Terraform ecosystem), perhaps adapting Pulumi to Clojure would be a reasonable route to take https://github.com/pulumi/pulumi , https://github.com/pulumi/pulumi-terraform"><y>#</y><d>2019-02-20</d><h>14:33</h><r>adamfeldman</r>@U09LZR36F Pulumi uses Terraform under the hood (and therefore takes advantage of the existing Terraform ecosystem), perhaps adapting Pulumi to Clojure would be a reasonable route to take <a href="https://github.com/pulumi/pulumi" target="_blank">https://github.com/pulumi/pulumi</a>, <a href="https://github.com/pulumi/pulumi-terraform" target="_blank">https://github.com/pulumi/pulumi-terraform</a></z><z id="t1550673270001300" t="dominicm Interesting, will take a look"><y>#</y><d>2019-02-20</d><h>14:34</h><r>dominicm</r>Interesting, will take a look</z><z id="t1550673471001400" t="dominicm @U0ECYL0ET we probably share complaints about terraform, and also the level at which you are describing things sounds similar to a project I tried to tackle things."><y>#</y><d>2019-02-20</d><h>14:37</h><r>dominicm</r>@U0ECYL0ET we probably share complaints about terraform, and also the level at which you are describing things sounds similar to a project I tried to tackle things.</z><z id="t1550673610001500" t="eraserhd My main complaint is that it is trying to be declarative. I think that&apos;s a mistake in that domain. We frequently need one object per thing in some database, for example, and that leads to terrible duplication and weird text ETL procedures."><y>#</y><d>2019-02-20</d><h>14:40</h><r>eraserhd</r>My main complaint is that it is trying to be declarative.  I think that&apos;s a mistake in that domain.  We frequently need one object per thing in some database, for example, and that leads to terrible duplication and weird text ETL procedures.</z><z id="t1550673660001700" t="eraserhd Those ETL procedures defeat the idea of what terraform is for. So they&apos;ve added things like loops and getting external data, but it is kind of terrible and they don&apos;t want you to use it."><y>#</y><d>2019-02-20</d><h>14:41</h><r>eraserhd</r>Those ETL procedures defeat the idea of what terraform is for.  So they&apos;ve added things like loops and getting external data, but it is kind of terrible and they don&apos;t want you to use it.</z><z id="t1550673663001900" t="dominicm Oh I know. And the modules don&apos;t even help! Count doesn&apos;t even work for the &quot;loop construct&quot; in a number of cases, so you have to take explicit counts for everything"><y>#</y><d>2019-02-20</d><h>14:41</h><r>dominicm</r>Oh I know. And the modules don&apos;t even help! Count doesn&apos;t even work for the &quot;loop construct&quot; in a number of cases, so you have to take explicit counts for everything</z><z id="t1550673668002100" t="eraserhd In reality, it should be pure functional."><y>#</y><d>2019-02-20</d><h>14:41</h><r>eraserhd</r>In reality, it should be pure functional.</z><z id="t1550673699002400" t="eraserhd right?!"><y>#</y><d>2019-02-20</d><h>14:41</h><r>eraserhd</r>right?!</z><z id="t1550673716002700" t="dominicm The terraform language sucks, generally. I&apos;d love it if they had a minimal extensible core. "><y>#</y><d>2019-02-20</d><h>14:41</h><r>dominicm</r>The terraform language sucks, generally. I&apos;d love it if they had a minimal extensible core. </z><z id="t1550673736003400" t="dominicm I quite like the idea of figuring out some primitives for building your own tf :)"><y>#</y><d>2019-02-20</d><h>14:42</h><r>dominicm</r>I quite like the idea of figuring out some primitives for building your own tf :)</z><z id="t1550673843004100" t="eraserhd In Clojure, terraform really just becomes a data structure and a plan/apply procedure. The data structure can be generated by a function."><y>#</y><d>2019-02-20</d><h>14:44</h><r>eraserhd</r>In Clojure, terraform really just becomes a data structure and a plan/apply procedure.  The data structure can be generated by a function.</z><z id="t1550673872004700" t="eraserhd I mean, Clara is probably good here :D But not necessary."><y>#</y><d>2019-02-20</d><h>14:44</h><r>eraserhd</r>I mean, Clara is probably good here :D  But not necessary.</z><z id="t1550673962006700" t="eraserhd The data structure needs some kind of ?var to bind results of some operations to inputs of others. Unlike the go people, we know about proper unification :D"><y>#</y><d>2019-02-20</d><h>14:46</h><r>eraserhd</r>The data structure needs some kind of ?var to bind results of some operations to inputs of others.  Unlike the go people, we know about proper unification :D</z><z id="t1550674061007100" t="dominicm So, I&apos;m looking at clara to do the dependency graph of work semi-automatically. For example, when do you go fetch the list of GitHub users? Well, if something wants to query them (and then you cache it). If you&apos;ve diffed the list of users, and something inserts a new user, then you need to change your actions based on that. This is a pretty half-baked idea though 🙂"><y>#</y><d>2019-02-20</d><h>14:47</h><r>dominicm</r>So, I&apos;m looking at clara to do the dependency graph of work semi-automatically. For example, when do you go fetch the list of GitHub users? Well, if something wants to query them (and then you cache it). If you&apos;ve diffed the list of users, and something inserts a new user, then you need to change your actions based on that.

This is a pretty half-baked idea though <b>🙂</b></z><z id="t1550674242007300" t="eraserhd So, are you using it ahead-of-time to build a plan? Or are you using it during execution?"><y>#</y><d>2019-02-20</d><h>14:50</h><r>eraserhd</r>So, are you using it ahead-of-time to build a plan?  Or are you using it during execution?</z><z id="t1550674833007500" t="dominicm execution"><y>#</y><d>2019-02-20</d><h>15:00</h><r>dominicm</r>execution</z><z id="t1550674870007700" t="dominicm thinking about trade-offs, I decided that a plan is possible to do as an auxiliary based on a secondary set of rules which inform you of the &quot;optimistic write output&quot; of a task."><y>#</y><d>2019-02-20</d><h>15:01</h><r>dominicm</r>thinking about trade-offs, I decided that a plan is possible to do as an auxiliary based on a secondary set of rules which inform you of the &quot;optimistic write output&quot; of a task.</z><z id="t1550613955004700" t="eraserhd We&apos;re thinking about depending on clara_eav, since this will need a triplet type, and I&apos;m considering the EAV record in clara_eav the &quot;canonical triplet type&quot; for Clara."><y>#</y><d>2019-02-19</d><h>22:05</h><w>eraserhd</w>We&apos;re thinking about depending on clara_eav, since this will need a triplet type, and I&apos;m considering the EAV record in clara_eav the &quot;canonical triplet type&quot; for Clara.</z><z id="t1550613976005000" t="eraserhd It&apos;ll likely use nothing else from it, though."><y>#</y><d>2019-02-19</d><h>22:06</h><w>eraserhd</w>It&apos;ll likely use nothing else from it, though.</z><z id="t1550665590010300" t="dominicm http://www.clara-rules.org/docs/rules/ mentions &quot;props&quot;, but I can&apos;t see documentation for them on that page. Does anyone know what they are?"><y>#</y><d>2019-02-20</d><h>12:26</h><w>dominicm</w><a href="http://www.clara-rules.org/docs/rules/" target="_blank">http://www.clara-rules.org/docs/rules/</a> mentions &quot;props&quot;, but I can&apos;t see documentation for them on that page. Does anyone know what they are?</z><z id="t1550671872004100" t="ethanc @dominicm it is a simple map, currently the only thing supported would be salience, i think. http://www.clara-rules.org/docs/conflictsalience/"><y>#</y><d>2019-02-20</d><h>14:11</h><w>ethanc</w>@dominicm it is a simple map, currently the only thing supported would be salience, i think.

<a href="http://www.clara-rules.org/docs/conflictsalience/" target="_blank">http://www.clara-rules.org/docs/conflictsalience/</a></z><z id="t1550672398004600" t="mikerod @dominicm @ethanc there is also :no-loop"><y>#</y><d>2019-02-20</d><h>14:19</h><w>mikerod</w>@dominicm @ethanc there is also <code>:no-loop</code></z><z id="t1550672471004800" t="mikerod https://github.com/cerner/clara-rules/issues/23"><y>#</y><d>2019-02-20</d><h>14:21</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/issues/23" target="_blank">https://github.com/cerner/clara-rules/issues/23</a></z><z id="t1550672481005200" t="mikerod However, it’s typically not recommended to write rules in a way where you have to use that"><y>#</y><d>2019-02-20</d><h>14:21</h><w>mikerod</w>However, it’s typically not recommended to write rules in a way where you have to use that</z><z id="t1550672485005400" t="mikerod it can have confusing semantics I believe"><y>#</y><d>2019-02-20</d><h>14:21</h><w>mikerod</w>it can have confusing semantics I believe</z><z id="t1550672500005800" t="mikerod (probably why it hasn’t been documented much 😛 )"><y>#</y><d>2019-02-20</d><h>14:21</h><w>mikerod</w>(probably why it hasn’t been documented much <b>😛</b> )</z><z id="t1550673212001200" t="dominicm Is it possible to create rules with parameters? And be explicit about passing them in?"><y>#</y><d>2019-02-20</d><h>14:33</h><w>dominicm</w>Is it possible to create rules with parameters? And be explicit about passing them in?</z><z id="t1550673722003000" t="mikerod @dominicm It isn’t clear to me how that would work in general"><y>#</y><d>2019-02-20</d><h>14:42</h><w>mikerod</w>@dominicm It isn’t clear to me how that would work in general</z><z id="t1550673730003300" t="mikerod However, queries take parameters if that’s more what you’re looking for"><y>#</y><d>2019-02-20</d><h>14:42</h><w>mikerod</w>However, queries take parameters if that’s more what you’re looking for</z><z id="t1550673758004000" t="mikerod For rules, instead of taking a parameter, model the param as a fact inserted by a rule perhaps"><y>#</y><d>2019-02-20</d><h>14:42</h><w>mikerod</w>For rules, instead of taking a parameter, model the param as a fact inserted by a rule perhaps</z><z id="t1550673897005400" t="mikerod Instead of (defrule param-rule [A (= &lt;my-param-here&gt; x)] =&gt; &lt;do things&gt;) Do (defrule find-param [?i &lt;- InputFact] =&gt; (insert! (map-&gt;Param (extract-data ?i)))) (defrule param-rule [?p &lt;- Param] [A (= (:x ?p) x)] =&gt; &lt;do things&gt;) "><y>#</y><d>2019-02-20</d><h>14:44</h><w>mikerod</w>Instead of
<pre>(defrule param-rule
  [A (= &lt;my-param-here&gt; x)]
  =&gt;
  &lt;do things&gt;)
</pre>

Do
<pre>(defrule find-param
  [?i &lt;- InputFact]
  =&gt;
  (insert! (map-&gt;Param (extract-data ?i))))

(defrule param-rule
  [?p &lt;- Param]
  [A (= (:x ?p) x)]
  =&gt;
  &lt;do things&gt;)
</pre></z><z id="t1550673912005700" t="dominicm @mikerod hmm, maybe I haven&apos;t thought it through. But I want to write rules like &quot;for every X insert 5&quot;, where I might have multiple of these inserted."><y>#</y><d>2019-02-20</d><h>14:45</h><w>dominicm</w>@mikerod hmm, maybe I haven&apos;t thought it through. But I want to write rules like &quot;for every X insert 5&quot;, where I might have multiple of these inserted.</z><z id="t1550673915006000" t="dominicm Ah, right, of course."><y>#</y><d>2019-02-20</d><h>14:45</h><w>dominicm</w>Ah, right, of course.</z><z id="t1550673938006600" t="dominicm My rule just needs to find &quot;Candidate X&quot;, and then insertions can be made about X candidate. 🙂"><y>#</y><d>2019-02-20</d><h>14:45</h><w>dominicm</w>My rule just needs to find &quot;Candidate X&quot;, and then insertions can be made about X candidate. <b>🙂</b></z><z id="t1550674016007000" t="mikerod I think so"><y>#</y><d>2019-02-20</d><h>14:46</h><w>mikerod</w>I think so</z><z id="t1551195909008800" t="bmaddy Does anyone know if Clara supports recursion in queries? I couldn&apos;t find a mention of it on the website."><y>#</y><d>2019-02-26</d><h>15:45</h><w>bmaddy</w>Does anyone know if Clara supports recursion in queries? I couldn&apos;t find a mention of it on the website.</z><z id="t1551196901009400" t="ethanc @bmaddy could you elaborate on &quot;recursion in queries&quot;"><y>#</y><d>2019-02-26</d><h>16:01</h><w>ethanc</w>@bmaddy could you elaborate on &quot;recursion in queries&quot;</z><z id="t1551197225012900" t="bmaddy Sure, be advised that I&apos;m really new to Clara and rules engines in general. Basically, I have a tree of data (nested associatives). I want to convert that into facts to query over it. If you&apos;re familiar with Datomic, it would be like asserting an entity {:a 1 :b {:c {:d 5}}} into datoms. I then want to do a query that finds a result if :d is 5 and any ancestor has an :a with the value 1 . And because I said ancestor there, I think I&apos;ll need a recursive query."><y>#</y><d>2019-02-26</d><h>16:07</h><w>bmaddy</w>Sure, be advised that I&apos;m really new to Clara and rules engines in general. Basically, I have a tree of data (nested associatives). I want to convert that into facts to query over it. If you&apos;re familiar with Datomic, it would be like asserting an entity <code>{:a 1 :b {:c {:d 5}}}</code> into datoms. I then want to do a query that finds a result if <code>:d</code> is <code>5</code> and any ancestor has an <code>:a</code> with the value <code>1</code>. And because I said ancestor there, I think I&apos;ll need a recursive query.</z><z id="t1551202125015900" t="ethanc Sorry for the delay You could probably brute force it in a query(iterate over the nested maps), but i would think that the idiomatic way would be to deconstruct the parent and insert the children with reference to there parent or root. for example: (ns some.namespace (:require [clara.rules :as r])) (r/defrule expansion-rule [?e &lt;- :entity (some map? (vals this))] =&gt; (doseq [v (vals ?e) :when (map? v) [k v] v] (r/insert! (with-meta ;; wrapping ?e in a vector to prevent ;; v from having a child with that is a map ;; (infinite loop) {:key k :val v :root (or (:root ?e) [?e])} {:type :entity})))) (r/defquery get-root [:?val :?key] [:entity (= ?key (:key this)) (= ?val (:val this)) (= ?root (or (first (:root this)) this))]) (-&gt; (r/mk-session) (r/insert (with-meta {:a 1 :b {:c {:d 5}}} {:type :entity})) r/fire-rules (r/query get-root :?val 5 :?key :d)) "><y>#</y><d>2019-02-26</d><h>17:28</h><w>ethanc</w>Sorry for the delay
You could probably brute force it in a query(iterate over the nested maps), but i would think that the idiomatic way would be to deconstruct the parent and insert the children with reference to there parent or root.

for example:
<pre>(ns some.namespace
  (:require [clara.rules :as r]))

(r/defrule expansion-rule
  [?e &lt;- :entity (some map? (vals this))]
  =&gt;
  (doseq [v (vals ?e)
          :when (map? v)
          [k v] v]
    (r/insert! (with-meta
                 ;; wrapping ?e in a vector to prevent
                 ;; v from having a child with that is a map
                 ;; (infinite loop)
                {:key k :val v :root (or (:root ?e) [?e])}
                {:type :entity}))))

(r/defquery get-root
  [:?val :?key]
  [:entity
   (= ?key (:key this))
   (= ?val (:val this))
   (= ?root (or (first (:root this)) this))])


(-&gt; (r/mk-session)
     (r/insert (with-meta {:a 1 :b {:c {:d 5}}} {:type :entity}))
     r/fire-rules
     (r/query get-root :?val 5 :?key :d))
</pre></z><z id="t1551202293017800" t="ethanc Using clara&apos;s fact-type here as i was being lazy and didn&apos;t want to construct a wrapper fact. By default clara uses clojure.core/type to determine rules to activate, thus i made the maps of type :entity"><y>#</y><d>2019-02-26</d><h>17:31</h><w>ethanc</w>Using clara&apos;s fact-type here as i was being lazy and didn&apos;t want to construct a wrapper fact. By default clara uses <code>clojure.core/type</code> to determine rules to activate, thus i made the maps of type <code>:entity</code></z><z id="t1551203078018800" t="ethanc The when in the doseq would be wrong and could be removed"><y>#</y><d>2019-02-26</d><h>17:44</h><w>ethanc</w>The when in the doseq would be wrong and could be removed</z><z id="t1551203172019500" t="ethanc and would be replaced with logic to expand all the keys rather than just maps"><y>#</y><d>2019-02-26</d><h>17:46</h><w>ethanc</w>and would be replaced with logic to expand all the keys rather than just maps</z><z id="t1551204725022000" t="ethanc The ancestors questions would then have to be post query, either that or you could insert some sort of fact representing what you are trying to join logically. Queries are aimed more at field equivalence"><y>#</y><d>2019-02-26</d><h>18:12</h><w>ethanc</w>The ancestors questions would then have to be post query, either that or you could insert some sort of fact representing what you are trying to join logically. Queries are aimed more at field equivalence</z><z id="t1551208265023700" t="ethanc As an example of what i mean by inserting a fact to represent what you logically want to join, (ns some.namespace (:require [clara.rules :as r])) (r/defrule expansion-rule [?e &lt;- :entity (some map? (vals this))] =&gt; (doseq [v (vals ?e) :when (map? v)] (r/insert! (with-meta (assoc v :ancestors (conj (or (:ancestors ?e) []) (dissoc ?e :ancestors))) {:type :entity})))) (r/defrule query-rule [:query (= ?aq (:ancestor-question this)) (= ?eq (:entity-question this)) (= ?t (:query-id this))] [?e &lt;- :entity] [:test (and (?eq ?e) (some ?aq (:ancestors ?e)))] =&gt; (r/insert! (with-meta {:res ?e :query-id ?t} {:type :result}))) (r/defquery result-query [:?query-id] [:result (= ?query-id (:query-id this)) (= ?result (:res this))]) (-&gt; (r/mk-session) (r/insert (with-meta {:a 1 :b {:c {:d 5}}} {:type :entity})) (r/insert (with-meta {:query-id :d-5_a-1 :entity-question #(= (:d %) 5) :ancestor-question #(= (:a %) 1)} {:type :query})) r/fire-rules (r/query result-query :?query-id :d-5_a-1)) =&gt; ({:?query-id :d-5_a-1, :?result {:d 5, :ancestors [{:a 1, :b {:c {:d 5}}} {:c {:d 5}}]}}) "><y>#</y><d>2019-02-26</d><h>19:11</h><w>ethanc</w>As an example of what i mean by inserting a fact to represent what you logically want to join,
<pre>(ns some.namespace
  (:require [clara.rules :as r]))

(r/defrule expansion-rule
  [?e &lt;- :entity (some map? (vals this))]
  =&gt;
  (doseq [v (vals ?e)
          :when (map? v)]
    (r/insert! (with-meta
                 (assoc v :ancestors (conj (or (:ancestors ?e) []) (dissoc ?e :ancestors)))
                 {:type :entity}))))

(r/defrule query-rule
  [:query
   (= ?aq (:ancestor-question this))
   (= ?eq (:entity-question this))
   (= ?t (:query-id this))]
  [?e &lt;- :entity]
  [:test (and (?eq ?e)
              (some ?aq (:ancestors ?e)))]
  =&gt;
  (r/insert!
    (with-meta
      {:res ?e :query-id ?t}
      {:type :result})))

(r/defquery result-query
  [:?query-id]
  [:result
   (= ?query-id (:query-id this))
   (= ?result (:res this))])

(-&gt; (r/mk-session)
    (r/insert (with-meta {:a 1 :b {:c {:d 5}}} {:type :entity}))
    (r/insert (with-meta {:query-id :d-5_a-1
                          :entity-question #(= (:d %) 5)
                          :ancestor-question #(= (:a %) 1)}
                         {:type :query}))
    r/fire-rules
    (r/query result-query :?query-id :d-5_a-1))
=&gt;
({:?query-id :d-5_a-1, :?result {:d 5, :ancestors [{:a 1, :b {:c {:d 5}}} {:c {:d 5}}]}})
</pre></z><z id="t1551212503028500" t="bmaddy Wow, thanks for all the explanation. I must admit, I&apos;m rather stunned. I thought rules engines would let you do datalog-like queries across data to get notified as it changes, but now it seems like you need to build data up every step of the way in order to answer your question. I was thinking about using that to help with a ton of validations on nested data I have, but that sounds like I might be better off with something like datascript. So what&apos;s the killer app for rules engines? Right now my understanding of it makes me basically think it&apos;s like calling iterate on a set of data until it doesn&apos;t change anymore (applying rules) and then filtering it (the queries). (If you don&apos;t have the time to explain, I totally understand--you&apos;re generously volunteering your time after all! Thank you!)"><y>#</y><d>2019-02-26</d><h>20:21</h><w>bmaddy</w>Wow, thanks for all the explanation. I must admit, I&apos;m rather stunned. I thought rules engines would let you do datalog-like queries across data to get notified as it changes, but now it seems like you need to build data up every step of the way in order to answer your question. I was thinking about using that to help with a ton of validations on nested data I have, but that sounds like I might be better off with something like datascript.
So what&apos;s the killer app for rules engines? Right now my understanding of it makes me basically think it&apos;s like calling <code>iterate</code> on a set of data until it doesn&apos;t change anymore (applying rules) and then filtering it (the queries).
(If you don&apos;t have the time to explain, I totally understand--you&apos;re generously volunteering your time after all! Thank you!)</z><z id="t1551213950029000" t="mikerod @bmaddy I believe the distinction may be more around the forward-chaining vs backward-chaining strengths and weaknesses"><y>#</y><d>2019-02-26</d><h>20:45</h><w>mikerod</w>@bmaddy I believe the distinction may be more around the forward-chaining vs backward-chaining strengths and weaknesses</z><z id="t1551213978029300" t="mikerod Clara being oriented around the forward-chaining style rules"><y>#</y><d>2019-02-26</d><h>20:46</h><w>mikerod</w>Clara being oriented around the forward-chaining style rules</z><z id="t1551214024030000" t="mikerod and logic programming systems like prolog (core.logic too?; datascript too?) more around a backward-chaining design"><y>#</y><d>2019-02-26</d><h>20:47</h><w>mikerod</w>and logic programming systems like prolog (core.logic too?; datascript too?) more around a backward-chaining design</z><z id="t1551214892031300" t="bmaddy Yeah, I&apos;ve heard that. I could certainly stand to do some research to get a better grasp on that."><y>#</y><d>2019-02-26</d><h>21:01</h><w>bmaddy</w>Yeah, I&apos;ve heard that. I could certainly stand to do some research to get a better grasp on that.</z><z id="t1551217794034000" t="mikerod @bmaddy I think it’s difficult to explain well and there are probably good write-ups out there on the differences"><y>#</y><d>2019-02-26</d><h>21:49</h><w>mikerod</w>@bmaddy I think it’s difficult to explain well and there are probably good write-ups out there on the differences</z><z id="t1551217845035000" t="mikerod Clara’s forward-chaining approach is good for a type of problem where you have a set of known facts and you have a complex chain of logical inference that can be done based on those facts to arrive at some - typically pre-enumerated set of outcomes"><y>#</y><d>2019-02-26</d><h>21:50</h><w>mikerod</w>Clara’s forward-chaining approach is good for a type of problem where you have a set of known facts and you have a complex chain of logical inference that can be done based on those facts to arrive at some - typically pre-enumerated set of outcomes</z><z id="t1551217889035900" t="mikerod You can parameterize the queries in Clara to an extent that does allow you to look for different sorts of matches, but I don’t think the concept extends well to asking arbitrary questions about the state of the system"><y>#</y><d>2019-02-26</d><h>21:51</h><w>mikerod</w>You can parameterize the queries in Clara to an extent that does allow you to look for different sorts of matches, but I don’t think the concept extends well to asking arbitrary questions about the state of the system</z><z id="t1551217915036300" t="mikerod Like, I can say “Give me the outcomes that have an x value between 30-50”"><y>#</y><d>2019-02-26</d><h>21:51</h><w>mikerod</w>Like, I can say “Give me the outcomes that have an x value between 30-50”</z><z id="t1551217946037000" t="mikerod but it is harder to say, “Tell me what facts I’d need to get an outcome with x value between 30-50”"><y>#</y><d>2019-02-26</d><h>21:52</h><w>mikerod</w>but it is harder to say, “Tell me what facts I’d need to get an outcome with x value between 30-50”</z><z id="t1551217989037900" t="mikerod So Ethan had good examples above of how you can use forward-chaining to explicitly model relationships - so that you can query on those relationships-as-facts later"><y>#</y><d>2019-02-26</d><h>21:53</h><w>mikerod</w>So Ethan had good examples above of how you can use forward-chaining to explicitly model relationships - so that you can query on those relationships-as-facts later</z><z id="t1551218006038400" t="mikerod I think backwards-chaining may have more built-in approaches when that’s teh type of problem you are solving"><y>#</y><d>2019-02-26</d><h>21:53</h><w>mikerod</w>I think backwards-chaining may have more built-in approaches when that’s teh type of problem you are solving</z><z id="t1551218073039700" t="mikerod Forward-chaining is nice when you are doing waht I said above, and it comes with a good mechanism of chaining along a “path” that supports arriving at your various outcomes. I don’t think anyone tends to say which is better, forward/backwards, I think it’s just that each is better at a certain class of problem."><y>#</y><d>2019-02-26</d><h>21:54</h><w>mikerod</w>Forward-chaining is nice when you are doing waht I said above, and it comes with a good mechanism of chaining along a “path” that supports arriving at your various outcomes.
I don’t think anyone tends to say which is better, forward/backwards, I think it’s just that each is better at a certain class of problem.</z><z id="t1551218094040200" t="mikerod But not sure why I typed all that. Probably much better explanations available online. 😛"><y>#</y><d>2019-02-26</d><h>21:54</h><w>mikerod</w>But not sure why I typed all that. Probably much better explanations available online. <b>😛</b></z><z id="t1551221087052800" t="bmaddy Yeah, I&apos;m a little familiar with what you&apos;re describing. I certainly have an entity (nested associative structure) that regularly changes slightly (in one case this is part of a state for a UI) and I want to run the same set of validations on it after every little change. That&apos;s what makes me think a rules engine is the way to go (i.e. my queries don&apos;t change, my data does). I just thought the querying would have something like datalog rules. I think I&apos;ll just need to study Ethan&apos;s examples a little more. I think I get the general idea it&apos;s describing, but haven&apos;t fully wrapped my head around it yet. Thanks again everyone for your help!"><y>#</y><d>2019-02-26</d><h>22:44</h><w>bmaddy</w>Yeah, I&apos;m a little familiar with what you&apos;re describing. I certainly have an entity (nested associative structure) that regularly changes slightly (in one case this is part of a state for a UI) and I want to run the same set of validations on it after every little change. That&apos;s what makes me think a rules engine is the way to go (i.e. my queries don&apos;t change, my data does). I just thought the querying would have something like datalog rules. I think I&apos;ll just need to study Ethan&apos;s examples a little more. I think I get the general idea it&apos;s describing, but haven&apos;t fully wrapped my head around it yet.
Thanks again everyone for your help!</z><z id="t1551370396003900" t="wparker I don’t have much to add to the above - as the examples shows, Clara doesn’t try to query further into facts, it just treats them as top level entities to be joined, inserted, etc. Right now my understanding of it makes me basically think it&apos;s like calling `iterate` on a set of data until it doesn&apos;t change anymore (applying rules) and then filtering it (the queries). That sounds on target. One thing a rules engine such as Clara is good at is efficiently applying small changes onto a complex ruleset - the intermediate states of the rule engine internals are kept to facilitate this. The “truth maintenance” page on the webpage is a good one to read if you haven’t yet. @bmaddy"><y>#</y><d>2019-02-28</d><h>16:13</h><w>wparker</w>I  don’t  have much to add to  the above - as the examples shows, Clara doesn’t  try to query further  into facts,  it just treats them as top level entities  to be joined, inserted, etc.  <pre>Right now my understanding of it makes me basically think it&apos;s like calling `iterate` on a set of data until it doesn&apos;t change anymore (applying rules) and then filtering it (the queries). </pre> That sounds on target.  One thing a rules engine such as Clara is good at is efficiently applying small  changes  onto a complex ruleset - the intermediate states of the rule engine internals are kept to facilitate this.  The “truth  maintenance” page  on the webpage is a good one to read if you haven’t yet. @bmaddy</z><z id="t1551381681006500" t="bmaddy Thanks, it&apos;s nice to know my mental model is in the right ballpark. 🙂 Yeah, I&apos;ve read that page before--it&apos;s very clear and well written. I haven&apos;t been able to find much on joins though. I actually didn&apos;t even realize that was possible until I was looking at Precept."><y>#</y><d>2019-02-28</d><h>19:21</h><w>bmaddy</w>Thanks, it&apos;s nice to know my mental model is in the right ballpark. <b>🙂</b> Yeah, I&apos;ve read that page before--it&apos;s very clear and well written. I haven&apos;t been able to find much on joins though. I actually didn&apos;t even realize that was possible until I was looking at Precept.</z><z id="t1554316478000600" t="eraserhd can we cut a release? I think the :exists performance is blocking us right now (still running tests, tho)."><y>#</y><d>2019-04-03</d><h>18:34</h><w>eraserhd</w>can we cut a release?  I think the :exists performance is blocking us right now (still running tests, tho).</z><z id="t1554324790004700" t="defndaines I wanted to test the SNAPSHOT and realized I have to install an older JDK to compile the project. In particular, :javac-options [&quot;-target&quot; &quot;1.6&quot; &quot;-source&quot; &quot;1.6&quot;] is no longer supported. Does anyone know that best version to build with? (It isn’t enough to just change those to “1.8” … that brings up a ClassNotFoundException: javax.xml.bind.DatatypeConverter issue, which I think is JDK11 [LTS] and higher.)"><y>#</y><d>2019-04-03</d><h>20:53</h><w>defndaines</w>I wanted to test the SNAPSHOT and realized I have to install an older JDK to compile the project.  In particular, <code>:javac-options [&quot;-target&quot; &quot;1.6&quot; &quot;-source&quot; &quot;1.6&quot;]</code> is no longer supported. Does anyone know that best version to build with?
(It isn’t enough to just change those to “1.8” … that brings up a <code>ClassNotFoundException: javax.xml.bind.DatatypeConverter</code> issue, which I think is JDK11 [LTS] and higher.)</z><z id="t1554326324005500" t="eraserhd On mac, I do JAVA_HOME=$(/usr/libexec/java_home -v 1.8) lein install or what not."><y>#</y><d>2019-04-03</d><h>21:18</h><w>eraserhd</w>On mac, I do <code>JAVA_HOME=$(/usr/libexec/java_home -v 1.8) lein install</code> or what not.</z><z id="t1554326346005800" t="eraserhd That just worked for me today."><y>#</y><d>2019-04-03</d><h>21:19</h><w>eraserhd</w>That just worked for me today.</z><z id="t1554326375006200" t="eraserhd The target options are only about bytecode, iirc."><y>#</y><d>2019-04-03</d><h>21:19</h><w>eraserhd</w>The target options are only about bytecode, iirc.</z><z id="t1554327768006500" t="mikerod The xml thing is common in libs that haven’t upgrade some deps yet"><y>#</y><d>2019-04-03</d><h>21:42</h><w>mikerod</w>The xml thing is common in libs that haven’t upgrade some deps yet</z><z id="t1554327782006900" t="mikerod Clara has some lower version deps right now, it should be changed with some better profiles I think"><y>#</y><d>2019-04-03</d><h>21:43</h><w>mikerod</w>Clara has some lower version deps right now, it should be changed with some better profiles I think</z><z id="t1554327792007200" t="mikerod but you can work around the jdk11 things I think with just adding to the module path"><y>#</y><d>2019-04-03</d><h>21:43</h><w>mikerod</w>but you can work around the jdk11 things I think with just adding to the module path</z><z id="t1554327836007500" t="mikerod in :jvm-opts add &quot;--add-modules java.xml.bind&quot;"><y>#</y><d>2019-04-03</d><h>21:43</h><w>mikerod</w>in <code>:jvm-opts</code> add <code>&quot;--add-modules java.xml.bind&quot;</code></z><z id="t1554327851007900" t="mikerod can do that in your ~/.lein/profiles.clj or just alter Clara’s project"><y>#</y><d>2019-04-03</d><h>21:44</h><w>mikerod</w>can do that in your <code>~/.lein/profiles.clj</code> or just alter Clara’s project</z><z id="t1554327874008200" t="mikerod oh, there is already a profile for this in clara"><y>#</y><d>2019-04-03</d><h>21:44</h><w>mikerod</w>oh, there is already a profile for this in clara</z><z id="t1554327890008500" t="mikerod lein with-profile java9 install"><y>#</y><d>2019-04-03</d><h>21:44</h><w>mikerod</w><code>lein with-profile java9 install</code></z><z id="t1554327909008900" t="mikerod you can build with a bit higher cljs/clj too with a profile built-in"><y>#</y><d>2019-04-03</d><h>21:45</h><w>mikerod</w>you can build with a bit higher cljs/clj too with a profile built-in</z><z id="t1554327924009200" t="mikerod lein with-profile java9,recent-clj install"><y>#</y><d>2019-04-03</d><h>21:45</h><w>mikerod</w><code>lein with-profile java9,recent-clj install</code></z><z id="t1554327945009700" t="mikerod However, the java9 is slightly misleading, I think it should work with jdk11 too (pending any not testing jdk11 issues with clara or lib it uses)"><y>#</y><d>2019-04-03</d><h>21:45</h><w>mikerod</w>However, the <code>java9</code> is slightly misleading, I think it should work with jdk11 too (pending any not testing jdk11 issues with clara or lib it uses)</z><z id="t1554327960010000" t="mikerod I do not see this though :javac-options [&quot;-target&quot; &quot;1.6&quot; &quot;-source&quot; &quot;1.6&quot;] and that doesn’t seem ideal to me"><y>#</y><d>2019-04-03</d><h>21:46</h><w>mikerod</w>I do not see this though <code>:javac-options [&quot;-target&quot; &quot;1.6&quot; &quot;-source&quot; &quot;1.6&quot;]</code> and that doesn’t seem ideal to me</z><z id="t1554327978010300" t="mikerod I think Clara should remove that, maybe a good PR…"><y>#</y><d>2019-04-03</d><h>21:46</h><w>mikerod</w>I think Clara should remove that, maybe a good PR…</z><z id="t1554328075011300" t="mikerod maybe just do this: lein update-in : assoc :javac-opts &quot;^:replace []&quot; -- with-profile java9, recent-clj install - hah, quite rough"><y>#</y><d>2019-04-03</d><h>21:47</h><w>mikerod</w>maybe just do this: <code>lein update-in : assoc :javac-opts &quot;^:replace []&quot; -- with-profile java9, recent-clj install</code> - hah, quite rough</z><z id="t1554328204013100" t="wparker @eraserhd Regarding cutting a release in the near future, that seems reasonable to me - any objections anyone? Probably 0.19.1 looking at the changelog."><y>#</y><d>2019-04-03</d><h>21:50</h><w>wparker</w>@eraserhd Regarding cutting a release in the near future, that seems reasonable to me - any objections anyone?  Probably 0.19.1 looking at the changelog.</z><z id="t1554328208013300" t="mikerod We likely need to make a profile to build for more modern things and make that the default dev setup. Can have separate install/deploy configuration and testing"><y>#</y><d>2019-04-03</d><h>21:50</h><w>mikerod</w>We likely need to make a profile to build for more modern things and make that the default dev setup. Can have separate install/deploy configuration and testing</z><z id="t1554328298013800" t="mikerod @wparker release seems fine to me based on what I see"><y>#</y><d>2019-04-03</d><h>21:51</h><w>mikerod</w>@wparker release seems fine to me based on what I see</z><z id="t1554328302014000" t="mikerod and minor version seems acceptable - nothing in there should be breaking or considered a “feature add”"><y>#</y><d>2019-04-03</d><h>21:51</h><w>mikerod</w>and minor version seems acceptable - nothing in there should be breaking or considered a “feature add”</z><z id="t1554329509014500" t="ethanc Agreed"><y>#</y><d>2019-04-03</d><h>22:11</h><w>ethanc</w>Agreed</z><z id="t1554390152015000" t="defndaines I was able to smoke-test with the SNAPSHOT version and didn’t see any issues."><y>#</y><d>2019-04-04</d><h>15:02</h><w>defndaines</w>I was able to smoke-test with the SNAPSHOT version and didn’t see any issues.</z><z id="t1554390203016100" t="defndaines As a follow up to the questions yesterday (had to drop off, but thanks for all the suggestions): I could not build the project with either JDK 11 or 12. I was able to build the project with JDK 8."><y>#</y><d>2019-04-04</d><h>15:03</h><w>defndaines</w>As a follow up to the questions yesterday (had to drop off, but thanks for all the suggestions):
I could not build the project with either JDK 11 or 12.
I was able to build the project with JDK 8.</z><z id="t1554390983016600" t="mikerod @defndaines did you try my suggestion on running lein?"><y>#</y><d>2019-04-04</d><h>15:16</h><w>mikerod</w>@defndaines did you try my suggestion on running lein?</z><z id="t1554391006016900" t="mikerod Have to use a profile etc"><y>#</y><d>2019-04-04</d><h>15:16</h><w>mikerod</w>Have to use a profile etc</z><z id="t1554391608018300" t="defndaines Yeah, I tried all the suggestions above and none of them worked. Maybe it’s a set-up issue, but neither of the profiles work for me. I suspect that it’s because that XML fix for Java 9 only works in 9 and 10, and then was fully deprecated and removed in 11 so that it doesn’t cut it anymore."><y>#</y><d>2019-04-04</d><h>15:26</h><w>defndaines</w>Yeah, I tried all the suggestions above and none of them worked. Maybe it’s a set-up issue, but neither of the profiles work for me.
I suspect that it’s because that XML fix for Java 9 only works in 9 and 10, and then was fully deprecated and removed in 11 so that it doesn’t cut it anymore.</z><z id="t1554391959018600" t="mikerod @defndaines I didn’t think 11 went full on breaking for people"><y>#</y><d>2019-04-04</d><h>15:32</h><w>mikerod</w>@defndaines I didn’t think 11 went full on breaking for people</z><z id="t1554391961018800" t="mikerod but perhaps"><y>#</y><d>2019-04-04</d><h>15:32</h><w>mikerod</w>but perhaps</z><z id="t1554391975019200" t="mikerod we need to update dependencies in Clara, I may try to do this soon"><y>#</y><d>2019-04-04</d><h>15:32</h><w>mikerod</w>we need to update dependencies in Clara, I may try to do this soon</z><z id="t1554392034019500" t="mikerod It probably somewhat relates to https://github.com/cerner/clara-rules/issues/388 so I’ll probably use that one"><y>#</y><d>2019-04-04</d><h>15:33</h><w>mikerod</w>It probably somewhat relates to <a href="https://github.com/cerner/clara-rules/issues/388" target="_blank">https://github.com/cerner/clara-rules/issues/388</a> so I’ll probably use that one</z><z id="t1554392047019900" t="mikerod The offending deps are probably on the cljs side"><y>#</y><d>2019-04-04</d><h>15:34</h><w>mikerod</w>The offending deps are probably on the cljs side</z><z id="t1554392051020100" t="mikerod but will have to check"><y>#</y><d>2019-04-04</d><h>15:34</h><w>mikerod</w>but will have to check</z><z id="t1554392350020300" t="mikerod They removed it in jdk11 indeed: https://stackoverflow.com/a/52502208/924604"><y>#</y><d>2019-04-04</d><h>15:39</h><w>mikerod</w>They removed it in jdk11 indeed: <a href="https://stackoverflow.com/a/52502208/924604" target="_blank">https://stackoverflow.com/a/52502208/924604</a></z><z id="t1554392373020800" t="mikerod you have to add the jar now to the :dependencies is you need it - but we probably don’t need it, just using too old deps."><y>#</y><d>2019-04-04</d><h>15:39</h><w>mikerod</w>you have to add the jar now to the <code>:dependencies</code> is you need it - but we probably don’t need it, just using too old deps.</z><z id="t1554395566021900" t="defndaines Yeah, the error messages I was looking at yesterday when I ran things were all around the CLJS compilation. I tried some quick version updates myself, but it involved a lot more than changing the project.clj ."><y>#</y><d>2019-04-04</d><h>16:32</h><w>defndaines</w>Yeah, the error messages I was looking at yesterday when I ran things were all around the CLJS compilation. I tried some quick version updates myself, but it involved a lot more than changing the <code>project.clj</code>.</z><z id="t1554397031022300" t="mikerod @defndaines yeah, I’m working on the #388 issue a bit, hopefully not long before I can PR it"><y>#</y><d>2019-04-04</d><h>16:57</h><w>mikerod</w>@defndaines yeah, I’m working on the #388 issue a bit, hopefully not long before I can PR it</z><z id="t1554397048022800" t="mikerod I want to fix the cljs build in a few ways, but I do have it building now with jdk11 just using some newer clj+cljs deps"><y>#</y><d>2019-04-04</d><h>16:57</h><w>mikerod</w>I want to fix the cljs build in a few ways, but I do have it building now with jdk11 just using some newer clj+cljs deps</z><z id="t1554397060023200" t="mikerod I have all the details on that #388 issue if anyone is curious"><y>#</y><d>2019-04-04</d><h>16:57</h><w>mikerod</w>I have all the details on that #388 issue if anyone is curious</z><z id="t1554397093023700" t="mikerod It’s still a weird world to me to see the jdk not being backwards compatible. I think that’s basically unheard of until about jdk9 came along hah"><y>#</y><d>2019-04-04</d><h>16:58</h><w>mikerod</w>It’s still a weird world to me to see the jdk not being backwards compatible. I think that’s basically unheard of until about jdk9 came along hah</z><z id="t1554397128024100" t="mikerod it’s a new world, new release cadence, new “ownership of distros”"><y>#</y><d>2019-04-04</d><h>16:58</h><w>mikerod</w>it’s a new world, new release cadence, new “ownership of distros”</z><z id="t1554485038025700" t="eraserhd ha! I just found out that (-&gt; session inspect :insertions keys * :name) is not a fully qualified symbol, but a symbol with a slash in the name part."><y>#</y><d>2019-04-05</d><h>17:23</h><w>eraserhd</w>ha!  I just found out that <code>(-&gt; session inspect :insertions keys * :name)</code> is not a fully qualified symbol, but a symbol with a slash in the <code>name</code> part.</z><z id="t1554485252026100" t="mikerod I do not get it 😵"><y>#</y><d>2019-04-05</d><h>17:27</h><w>mikerod</w>I do not get it <b>😵</b></z><z id="t1554485262026300" t="mikerod doing crazy things with the symbol fn?"><y>#</y><d>2019-04-05</d><h>17:27</h><w>mikerod</w>doing crazy things with the <code>symbol</code> fn?</z><z id="t1554496390027200" t="devn What is * in there @eraserhd? When you say symbol do you mean keyword? I had the same thought as mikerod: (symbol &quot;not/valid&quot;)"><y>#</y><d>2019-04-05</d><h>20:33</h><w>devn</w>What is <code>*</code> in there @eraserhd? When you say symbol do you mean keyword? I had the same thought as mikerod: <code>(symbol &quot;not/valid&quot;)</code></z><z id="t1554496856028200" t="eraserhd * was pseudo-code for &quot;some integer&quot;. I guess first would actually work."><y>#</y><d>2019-04-05</d><h>20:40</h><w>eraserhd</w><code>*</code> was pseudo-code for &quot;some integer&quot;.  I guess <code>first</code> would actually work.</z><z id="t1554496891028800" t="eraserhd the value at :name on a rule map is a symbol"><y>#</y><d>2019-04-05</d><h>20:41</h><w>eraserhd</w>the value at <code>:name</code> on a rule map is a symbol</z><z id="t1554742059029100" t="wparker When I tried this I got a string: clara.other-ruleset=&gt; (-&gt; (mk-session) (insert (-&gt;ColdAndWindy 15 15)) fire-rules inspect/inspect :insertions keys first :name) &quot;clara.other-ruleset/is-lousy&quot; clara.other-ruleset=&gt; (-&gt; (mk-session) (insert (-&gt;ColdAndWindy 15 15)) fire-rules inspect/inspect :insertions keys first :name class) java.lang.String Do you have a reproducing case or maybe I’m misunderstanding something?"><y>#</y><d>2019-04-08</d><h>16:47</h><r>wparker</r>When I tried this I got a string:  <pre>clara.other-ruleset=&gt; (-&gt; (mk-session) (insert (-&gt;ColdAndWindy 15 15)) fire-rules inspect/inspect :insertions  keys first :name)
&quot;clara.other-ruleset/is-lousy&quot;
clara.other-ruleset=&gt; (-&gt; (mk-session) (insert (-&gt;ColdAndWindy 15 15)) fire-rules inspect/inspect :insertions  keys first :name class)
java.lang.String </pre> Do you have a reproducing case or maybe I’m misunderstanding something?</z><z id="t1554742086029300" t="wparker clara.other-ruleset is a test namespace in Clara"><y>#</y><d>2019-04-08</d><h>16:48</h><r>wparker</r>clara.other-ruleset is a test namespace in Clara</z><z id="t1554744154031800" t="eraserhd hmm"><y>#</y><d>2019-04-08</d><h>17:22</h><r>eraserhd</r>hmm</z><z id="t1554744418032100" t="eraserhd Here&apos;s the function: https://gist.github.com/eraserhd/b7276d42de798e04b3f1cda0fb8e76ab ... I don&apos;t see that I&apos;m doing anything weird there..."><y>#</y><d>2019-04-08</d><h>17:26</h><r>eraserhd</r>Here&apos;s the function: <a href="https://gist.github.com/eraserhd/b7276d42de798e04b3f1cda0fb8e76ab" target="_blank">https://gist.github.com/eraserhd/b7276d42de798e04b3f1cda0fb8e76ab</a>  ... I don&apos;t see that I&apos;m doing anything weird there...</z><z id="t1554744474032300" t="eraserhd However, a bunch of rules are generated by some macros. I&apos;m pretty sure they expand clara.rules/defrule with a normal, unqualified symbol. But maybe something in the macros is weird?"><y>#</y><d>2019-04-08</d><h>17:27</h><r>eraserhd</r>However, a bunch of rules are generated by some macros.  I&apos;m pretty sure they expand clara.rules/defrule with a normal, unqualified symbol.  But maybe something in the macros is weird?</z><z id="t1554744589032500" t="eraserhd (the code on line 22 in the gist was added to work around the observed problem)"><y>#</y><d>2019-04-08</d><h>17:29</h><r>eraserhd</r>(the code on line 22 in the gist was added to work around the observed problem)</z><z id="t1554744649032700" t="eraserhd https://github.com/eraserhd/clara-eql/blob/develop/src/net/eraserhead/clara_eql/core.clj &lt;-- the macro in question"><y>#</y><d>2019-04-08</d><h>17:30</h><r>eraserhd</r><a href="https://github.com/eraserhd/clara-eql/blob/develop/src/net/eraserhead/clara_eql/core.clj" target="_blank">https://github.com/eraserhd/clara-eql/blob/develop/src/net/eraserhead/clara_eql/core.clj</a> &lt;-- the macro in question</z><z id="t1554742545031500" t="wparker Clara-rules 0.19.1 has been released; this contains some performance optimizations for memory use with durability, :exists rule conditions, and new functionality for reporting potential performance problems to users. See the changelog for details: https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0191"><y>#</y><d>2019-04-08</d><h>16:55</h><w>wparker</w>Clara-rules 0.19.1 has been released; this contains some performance optimizations for memory use with durability, :exists rule conditions, and new functionality for reporting potential performance problems to users.   See the changelog for details:  <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0191" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0191</a></z><z id="t1554918731034900" t="eraserhd Oh, I missed this. \o/"><y>#</y><d>2019-04-10</d><h>17:52</h><w>eraserhd</w>Oh, I missed this.  \o/</z><z id="t1554918864036900" t="eraserhd On another note, we&apos;ve been troubleshooting some serious performance issues loading our database, and I&apos;ve just figured out it is memory. If I fire-rules with the facts of the worst kind in batches of 5 (that chain the most), it completes in about 25 minutes; otherwise, it takes about 4h10m."><y>#</y><d>2019-04-10</d><h>17:54</h><w>eraserhd</w>On another note, we&apos;ve been troubleshooting some serious performance issues loading our database, and I&apos;ve just figured out it is memory.  If I fire-rules with the facts of the worst kind in batches of 5 (that chain the most), it completes in about 25 minutes; otherwise, it takes about 4h10m.</z><z id="t1554918881037200" t="eraserhd I mean, that&apos;s what tells me it is memory. Tell me if I&apos;m wrong."><y>#</y><d>2019-04-10</d><h>17:54</h><w>eraserhd</w>I mean, that&apos;s what tells me it is memory.  Tell me if I&apos;m wrong.</z><z id="t1554919132038600" t="ethanc Do you have profiles of the heap when this occurs?"><y>#</y><d>2019-04-10</d><h>17:58</h><w>ethanc</w>Do you have profiles of the heap when this occurs?</z><z id="t1554919357039000" t="eraserhd No, but I&apos;ll happily make some."><y>#</y><d>2019-04-10</d><h>18:02</h><w>eraserhd</w>No, but I&apos;ll happily make some.</z><z id="t1554923178041800" t="mikerod @eraserhd both heap profile and CPU sampling snapshot info would be good - not sure what you use. visualvm is good"><y>#</y><d>2019-04-10</d><h>19:06</h><w>mikerod</w>@eraserhd both heap profile and CPU sampling snapshot info would be good - not sure what you use. visualvm is good</z><z id="t1554923212042800" t="mikerod Another shot in the dark suggestion - if you are making rules with long LHS sequence of conditions, perhaps you’d be better off breaking it into multiple rules that aren’t as “deep”"><y>#</y><d>2019-04-10</d><h>19:06</h><w>mikerod</w>Another shot in the dark suggestion - if you are making rules with long LHS sequence of conditions, perhaps you’d be better off breaking it into multiple rules that aren’t as “deep”</z><z id="t1554923226043200" t="mikerod using “intermediate facts” to represent the parts"><y>#</y><d>2019-04-10</d><h>19:07</h><w>mikerod</w>using “intermediate facts” to represent the parts</z><z id="t1554923282044200" t="mikerod this can often give better perf characteristics and I generally think it’s better modularization anyways. This may not be relevant to you at all though. I just noticed the “chain” part and wasn’t sure what it referred to."><y>#</y><d>2019-04-10</d><h>19:08</h><w>mikerod</w>this can often give better perf characteristics and I generally think it’s better modularization anyways. This may not be relevant to you at all though. I just noticed the “chain” part and wasn’t sure what it referred to.</z><z id="t1554923336045400" t="mikerod The clara inspection tracing/tools recently had an update by Will I believe where it can try to report “counts” of operations happening at points in the network. if your chaining is resulting in large “cartesian product” of facts joining together, these helpers may be useful to diagnose too"><y>#</y><d>2019-04-10</d><h>19:08</h><w>mikerod</w>The clara inspection tracing/tools recently had an update by Will I believe where it can try to report “counts” of operations happening at points in the network. if your chaining is resulting in large “cartesian product” of facts joining together, these helpers may be useful to diagnose too</z><z id="t1554923359045600" t="mikerod This is the relevant commit https://github.com/cerner/clara-rules/commit/dde409c446a731e364096440d02ea0f7e8442c04"><y>#</y><d>2019-04-10</d><h>19:09</h><w>mikerod</w>This is the relevant commit <a href="https://github.com/cerner/clara-rules/commit/dde409c446a731e364096440d02ea0f7e8442c04" target="_blank">https://github.com/cerner/clara-rules/commit/dde409c446a731e364096440d02ea0f7e8442c04</a></z><z id="t1554923393046100" t="mikerod which gives you a fn clara.tools.tracing/ranked-productions"><y>#</y><d>2019-04-10</d><h>19:09</h><w>mikerod</w>which gives you a fn <code>clara.tools.tracing/ranked-productions</code></z><z id="t1554926590046700" t="eraserhd by chain, I mean deep - rule A inserts a fact, then rule B fires and inserts a fact, etc..."><y>#</y><d>2019-04-10</d><h>20:03</h><w>eraserhd</w>by chain, I mean deep - rule A inserts a fact, then rule B fires and inserts a fact, etc...</z><z id="t1554926622047100" t="eraserhd That counts things seems really relevant. I&apos;ll try it."><y>#</y><d>2019-04-10</d><h>20:03</h><w>eraserhd</w>That counts things seems really relevant.  I&apos;ll try it.</z><z id="t1554928068049300" t="eraserhd oh wow. clojure.lang.Atom memory usage is climbing by 20M per second."><y>#</y><d>2019-04-10</d><h>20:27</h><w>eraserhd</w>oh wow.  clojure.lang.Atom memory usage is climbing by 20M per second.</z><z id="t1554928892049900" t="mikerod Are you making a lot of atoms? Clara shouldn’t be hah"><y>#</y><d>2019-04-10</d><h>20:41</h><w>mikerod</w>Are you making a lot of atoms? Clara shouldn’t be hah</z><z id="t1554930794057200" t="wparker @eraserhd Clara uses atoms in engine.cljc in some places to store pending operations, conceivably you could get there from data being put in those atoms. It would be fairly hard though. But then the performant version of your rules sessions taking 25 minutes is striking. 😱 Obviously it could be unavoidable if you’re just processing massive amounts of data, but I’d be curious to see any kind of reproducing example of inordinate resource use, smaller examples obviously being easier to diagnose. I suspect you’ve uncovered some kind of bad pattern in the way the rule network fires rather than this (poor) level of performance being inevitable. Most of Clara’s optimization to date has been done against Cerner’s use cases; having a broader sample of benchmarks would be useful."><y>#</y><d>2019-04-10</d><h>21:13</h><w>wparker</w>@eraserhd Clara uses atoms in engine.cljc in some places to store pending operations, conceivably you could get there from data being put in those atoms.  It would be fairly hard though.  But then the performant version of your rules sessions taking 25 minutes is striking. <b>😱</b> Obviously it could be unavoidable if you’re just processing massive amounts of data, but I’d be curious to see any kind of reproducing example of inordinate resource use, smaller examples obviously being easier to diagnose.  I suspect you’ve uncovered some kind of bad pattern in the way the rule network fires rather than this (poor) level of performance being inevitable.  Most of Clara’s optimization to date has been done against Cerner’s use cases; having a broader sample of benchmarks would be useful.</z><z id="t1554933881061200" t="ethanc AlphaNodes are also generated with an atom for the bindings that the node will propagate in the event that its satisfied, however they would be scoped to the function that determined the satisfaction of the node. The atom is probably unnecessary and could be probably be replaced with shadowing within the function… I doubt that this is the growth that you are seeing though. Might be a performance gain by not having to swap! that atom though…."><y>#</y><d>2019-04-10</d><h>22:04</h><r>ethanc</r>AlphaNodes are also generated with an <code>atom</code> for the bindings that the node will propagate in the event that its satisfied, however they would be scoped to the function that determined the satisfaction of the node. The atom is probably unnecessary and could be probably be replaced with shadowing within the function… I doubt that this is the growth that you are seeing though.

Might be a performance gain by not having to <code>swap!</code> that atom though….</z><z id="t1554935398061400" t="mikerod @U3KC48GHW interesting on the use of an atom there. I’ll have to check that out again. However, overall, I wouldn’t expect to see an “Atom” itself taking memory up. It’s a pointer to something that may be large, but it itself shouldn’t show up as taking that memory (that’s not what I expect in heap dumps at least I think?)"><y>#</y><d>2019-04-10</d><h>22:29</h><r>mikerod</r>@U3KC48GHW interesting on the use of an atom there. I’ll have to check that out again. However, overall, I wouldn’t expect to see an “Atom” itself taking memory up. It’s a pointer to something that may be large, but it itself shouldn’t show up as taking that memory (that’s not what I expect in heap dumps at least I think?)</z><z id="t1554935413061600" t="mikerod So a lot of memory taken by actual clojure.lang.Atom makes me think there’d be a lot of instances of the Atom class"><y>#</y><d>2019-04-10</d><h>22:30</h><r>mikerod</r>So a lot of memory taken by actual clojure.lang.Atom makes me think there’d be a lot of instances of the Atom class</z><z id="t1555640420001300" t="Joel somebody have a starter project for spring boot, but with clara support?"><y>#</y><d>2019-04-19</d><h>02:20</h><w>Joel</w>somebody have a starter project for spring boot, but with clara support?</z><z id="t1555643453002500" t="Joel also, what is attracting me to Clara is that I&apos;m expecting i could &quot;introspect&quot; the rules relatively easily, possibly even modify dynamically --- is that a reasonable assumption?"><y>#</y><d>2019-04-19</d><h>03:10</h><w>Joel</w>also, what is attracting me to Clara is that I&apos;m expecting i could &quot;introspect&quot; the rules relatively easily, possibly even modify dynamically --- is that a reasonable assumption?</z><z id="t1555655205002700" t="wparker What sorts of introspection did you have in mind? If you mean introspection on what the rules engine did and why, there&apos;s a good amount of that, you can take a look at the inspect namespace and if you wanted something lower level the tracing namespace. If you mean introspection on the rules network, possibly yes if you write things yourself, but since the rules can contain arbitrary code (that the user writes) you have the usual problems with inspecting arbitrary code."><y>#</y><d>2019-04-19</d><h>06:26</h><r>wparker</r>What sorts of introspection did you have in mind?  If you mean introspection on what the rules engine did and why, there&apos;s a good amount of that, you can take a look at the inspect namespace and if you wanted something lower level the tracing namespace.  If you mean introspection on the rules network, possibly yes if you write things yourself, but since the rules can contain arbitrary code (that the user writes) you have the usual problems with inspecting  arbitrary code.</z><z id="t1555655291002900" t="wparker Regarding dynamic modification, if you want to change the rules you have to build a new session and rerun the rules."><y>#</y><d>2019-04-19</d><h>06:28</h><r>wparker</r>Regarding dynamic modification, if you want to change the rules you have to build a new session and rerun the rules.</z><z id="t1555681742003100" t="Joel no, not in that respect. I&apos;m interested in reading the rules to see what data they are looking for, fetched, and put into working member before running. For DB/REST calls."><y>#</y><d>2019-04-19</d><h>13:49</h><r>Joel</r>no, not in that respect. I&apos;m interested in reading the rules to see what data they are looking for, fetched, and put into working member before running. For DB/REST calls.</z><z id="t1555681911003300" t="Joel Basically, its an optimization so multiple calls aren&apos;t made while rules run, can do them all up front with single calls."><y>#</y><d>2019-04-19</d><h>13:51</h><r>Joel</r>Basically, its an optimization so multiple calls aren&apos;t made while rules run, can do them all up front with single calls.</z><z id="t1555682347003500" t="Joel The second part, probably thinking about the wrong way, but for parts of the rules that have variables, I&apos;d kind of like to see the rules served up with the variables replaced with actual values, so that it&apos;s easier to understand for user (developer). Basically I&apos;ll be serving up the rules from a server, and the server will also know what some of the vars should be in the rules, if server could basically inject that info, my thinking it&apos;s easier than having to reason about than having to look-up the values by hand. These variables change infrequently. Maybe server could inject them not necessarily inline so at least easy to see in one place. Hope that makes sense."><y>#</y><d>2019-04-19</d><h>13:59</h><r>Joel</r>The second part, probably thinking about the wrong way, but for parts of the rules that have variables, I&apos;d kind of like to see the rules served up with the variables replaced with actual values, so that it&apos;s easier to understand for user (developer).

Basically I&apos;ll be serving up the rules from a server, and the server will also know what some of the vars should be in the rules, if server could basically inject that info, my thinking it&apos;s easier than having to reason about than having to look-up the values by hand. These variables change infrequently. Maybe server could inject them not necessarily inline so at least easy to see in one place. Hope that makes sense.</z><z id="t1555945136009500" t="mikerod @UH13Y2FSA The way to model what you are saying in the “second part” above, would be to make your variables expressed as facts instead."><y>#</y><d>2019-04-22</d><h>14:58</h><r>mikerod</r>@UH13Y2FSA The way to model what you are saying in the “second part” above, would be to make your variables expressed as facts instead.</z><z id="t1555945165009700" t="mikerod That’s the typical way it’d be done and the most straightforward with the way the forward-chaining data flow of the rules engine works."><y>#</y><d>2019-04-22</d><h>14:59</h><r>mikerod</r>That’s the typical way it’d be done and the most straightforward with the way the forward-chaining data flow of the rules engine works.</z><z id="t1555945183009900" t="mikerod &gt; if server could basically inject that info The “injection” would be to just insert these facts."><y>#</y><d>2019-04-22</d><h>14:59</h><r>mikerod</r>&gt;  if server could basically inject that info
The “injection” would be to just insert these facts.</z><z id="t1555945224010100" t="mikerod You base logic on them. If you need to derive things from them for other rules - derive “intermediate facts”, ie facts meant to just build up higher-level concepts to relay to other rules."><y>#</y><d>2019-04-22</d><h>15:00</h><r>mikerod</r>You base logic on them. If you need to derive things from them for other rules - derive “intermediate facts”, ie facts meant to just build up higher-level concepts to relay to other rules.</z><z id="t1555945299010300" t="mikerod Remember, the working memory “session” state is immutable. So if you don’t want to continually put in these infrequently changed facts, you could potentially create a session, insert these facts only, then use that as your base session for other later independent memory states with the more frequently changing facts."><y>#</y><d>2019-04-22</d><h>15:01</h><r>mikerod</r>Remember, the working memory “session” state is immutable. So if you don’t want to continually put in these infrequently changed facts, you could potentially create a session, insert these facts only, then use that as your base session for other later independent memory states with the more frequently changing facts.</z><z id="t1556095934034100" t="wparker This will work and is probably easiest, but if you really want to have the values be determined statically note that Clara can build sessions from rule data structures that you pass it; rules/queries don&apos;t have to be created with the defrule/defquery macros. So you can have arbitrary generation logic. You can look at the schemas namespace and the data under rule/query vars for examples. It might be best to become familiar with code generation e.g. macros in Clojure if you go down this route though."><y>#</y><d>2019-04-24</d><h>08:52</h><r>wparker</r>This will work and is probably easiest, but if you really want to have the values be determined statically note that Clara can build sessions from rule data structures that you pass it; rules/queries don&apos;t have to be created with the defrule/defquery macros.  So you can have arbitrary generation logic.  You can look at the schemas namespace and the data under rule/query vars for examples.  It might be best to become familiar with code generation e.g. macros in Clojure if you go down this route though.</z><z id="t1555904590005200" t="Joel (dir clararules.core) will give me a list of the rules in that ns, but how can i tell rules from other items in the namespace?"><y>#</y><d>2019-04-22</d><h>03:43</h><w>Joel</w>(dir clararules.core) will give me a list of the rules in that ns, but how can i tell rules from other items in the namespace?</z><z id="t1555910144005800" t="Joel how do i see which rules are/were fired? I don&apos;t see an example."><y>#</y><d>2019-04-22</d><h>05:15</h><w>Joel</w>how do i see which rules are/were fired? I don&apos;t see an example.</z><z id="t1555937205009000" t="ethanc @joel380, Im not sure if this is an implementation detail or not, but clara uses a protocol and metadata to determine productions in a given namespace. https://github.com/cerner/clara-rules/blob/0.19.1/src/main/clojure/clara/rules.cljc#L270-L305 To your second question, i believe the way you would determine if rules have or have not fired would be to use the tracing listener. http://www.clara-rules.org/docs/listeners/ Either that or the end state of the session could be used via queries and facts returned from those queries."><y>#</y><d>2019-04-22</d><h>12:46</h><w>ethanc</w>@joel380,
Im not sure if this is an implementation detail or not, but clara uses a protocol and metadata to determine productions in a given namespace.
<a href="https://github.com/cerner/clara-rules/blob/0.19.1/src/main/clojure/clara/rules.cljc#L270-L305" target="_blank">https://github.com/cerner/clara-rules/blob/0.19.1/src/main/clojure/clara/rules.cljc#L270-L305</a>

To your second question, i believe the way you would determine if rules have or have not fired would be to use the tracing listener.
<a href="http://www.clara-rules.org/docs/listeners/" target="_blank">http://www.clara-rules.org/docs/listeners/</a>
Either that or the end state of the session could be used via queries and facts returned from those queries.</z><z id="t1555994732011700" t="Joel thanks... that second question. I was able to look at the session and see a fired rule, so that seems workable. The link you sent looks good, it looks like it uses something called &quot;meta&quot; to determine (query or rule), but doesn&apos;t seem to work for me."><y>#</y><d>2019-04-23</d><h>04:45</h><w>Joel</w>thanks... that second question. I was able to look at the session and see a fired rule, so that seems workable.

The link you sent looks good, it looks like it uses something called &quot;meta&quot; to determine (query or rule), but doesn&apos;t seem to work for me.</z><z id="t1555995046012400" t="Joel actually no, this works: (meta (resolve &apos;has-email))"><y>#</y><d>2019-04-23</d><h>04:50</h><w>Joel</w>actually no, this works: (meta (resolve &apos;has-email))</z><z id="t1555997521014600" t="Joel @ethanc --- is there any examples around activation-group-fn. Maybe the documentation is good enough, but being a clojure newbie, I&apos;m really not understanding what that function should be receiving (a map that always represents rules only? or the metadata?) Also the it&apos;s sort sibling is fuzzy to me."><y>#</y><d>2019-04-23</d><h>05:32</h><w>Joel</w>@ethanc --- is there any examples around activation-group-fn. Maybe the documentation is good enough, but being a clojure newbie, I&apos;m really not understanding what that function should be receiving (a map that always represents rules only? or the metadata?) Also the it&apos;s sort sibling is fuzzy to me.</z><z id="t1556023805019400" t="ethanc @joel380, This is a test demonstrating the usage of the activation-group-fn : https://github.com/cerner/clara-rules/blob/0.19.1/src/test/clojurescript/clara/test_salience.cljs#L76-L99 Please note that the manipulation of salience is typically reserved for tuning poor preforming rules. By poor performing, I mean rule scenarios where a pattern can be established where the execution order of rules will drastically impact the time that subsequent rules will take to execute and maintain truth."><y>#</y><d>2019-04-23</d><h>12:50</h><w>ethanc</w>@joel380,
This is a test demonstrating the usage of the <code>activation-group-fn</code>:
<a href="https://github.com/cerner/clara-rules/blob/0.19.1/src/test/clojurescript/clara/test_salience.cljs#L76-L99" target="_blank">https://github.com/cerner/clara-rules/blob/0.19.1/src/test/clojurescript/clara/test_salience.cljs#L76-L99</a>

Please note that the manipulation of salience is typically reserved for tuning poor preforming rules. By poor performing, I mean rule scenarios where a pattern can be established where the execution order of rules will drastically impact the time that subsequent rules will take to execute and maintain truth.</z><z id="t1556071536019900" t="Joel another good link, that makes it understandable."><y>#</y><d>2019-04-24</d><h>02:05</h><w>Joel</w>another good link, that makes it understandable.</z><z id="t1556071753022100" t="Joel it looks like a &quot;one-to-one&quot; port of existing drools rules is problematic. Drools has a way for you to veto a rule firing, it also can allow us to skip rule groups. It looks like the equivalent involves just ensuring proper behavior by writing appropriate when clauses. I do like how using a defrecord to predicate on is simple."><y>#</y><d>2019-04-24</d><h>02:09</h><w>Joel</w>it looks like a &quot;one-to-one&quot; port of existing drools rules is problematic. Drools has a way for you to veto a rule firing, it also can allow us to skip rule groups. It looks like the equivalent involves just ensuring proper behavior by writing appropriate when clauses. I do like how using a defrecord to predicate on is simple.</z><z id="t1556073688023000" t="Joel i suppose the &quot;clara way&quot; to control groups would be to modify the productions --- add predicate(s)"><y>#</y><d>2019-04-24</d><h>02:41</h><w>Joel</w>i suppose the &quot;clara way&quot; to control groups would be to modify the productions --- add predicate(s)</z><z id="t1556080607024500" t="Joel i&apos;m getting infinite loops: (defrule has-email &quot;allow rule&quot; [User (= &quot;&lt;mailto: /cdn-cgi/l/email-protection | /cdn-cgi/l/email-protection &gt;&quot; email)] [:not [Decision (contains? #{:allow} type)]] =&gt; (insert! (-&gt;Decision :allow)) (println &quot;allowed&quot;)) (defrule has-email-deny &quot;deny if not allowed&quot; [:not [Decision (contains? #{:allow :deny} type)]] =&gt; (insert! (-&gt;Decision :deny)) (println &quot;denied&quot;)) trying to make &quot;allow&quot; take precedence over &quot;deny&quot; decisions, but either my &quot;contains&quot; or universal non-existence seems to not be working."><y>#</y><d>2019-04-24</d><h>04:36</h><w>Joel</w>i&apos;m getting infinite loops:

(defrule has-email
  &quot;allow rule&quot;
  [User  (= &quot;&lt;mailto:<a href="/cdn-cgi/l/email-protection" target="_blank">/cdn-cgi/l/email-protection</a>|<a href="/cdn-cgi/l/email-protection" target="_blank">/cdn-cgi/l/email-protection</a>&gt;&quot; email)]
  [:not [Decision (contains? #{:allow} type)]]
  =&gt;
  (insert! (-&gt;Decision :allow))
  (println &quot;allowed&quot;))

(defrule has-email-deny
  &quot;deny if not allowed&quot;
  [:not [Decision (contains? #{:allow :deny} type)]]
  =&gt;
  (insert! (-&gt;Decision :deny))
  (println &quot;denied&quot;))

trying to make &quot;allow&quot; take precedence over &quot;deny&quot; decisions, but either my &quot;contains&quot; or universal non-existence seems to not be working.</z><z id="t1556094824024600" t="wparker @UH13Y2FSA Does your Decision record have a &quot;type&quot; field? Perhaps you&apos;re running into https://github.com/cerner/clara-rules/issues/259"><y>#</y><d>2019-04-24</d><h>08:33</h><r>wparker</r>@UH13Y2FSA Does your Decision record have a &quot;type&quot; field?  Perhaps you&apos;re running into <a href="https://github.com/cerner/clara-rules/issues/259" target="_blank">https://github.com/cerner/clara-rules/issues/259</a></z><z id="t1556094885024900" t="wparker If that is the problem you can fix it by using an explicit field lookup e.g. (:type this)"><y>#</y><d>2019-04-24</d><h>08:34</h><r>wparker</r>If that is the problem you can fix it by using an explicit field lookup e.g. (:type this)</z><z id="t1556157083000300" t="Joel (defrecord Decision [type])"><y>#</y><d>2019-04-25</d><h>01:51</h><r>Joel</r>(defrecord Decision [type])</z><z id="t1556157488000500" t="Joel I tried this format, didn&apos;t help: [:not [Decision (contains? #{:allow} (:type this))]]"><y>#</y><d>2019-04-25</d><h>01:58</h><r>Joel</r>I tried this format, didn&apos;t help:   [:not [Decision (contains? #{:allow} (:type this))]]</z><z id="t1556157540000700" t="Joel kind of feel like i can&apos;t do &quot;non-existance&quot;"><y>#</y><d>2019-04-25</d><h>01:59</h><r>Joel</r>kind of feel like i can&apos;t do &quot;non-existance&quot;</z><z id="t1556164889000900" t="Joel i see examples of the same ... i don&apos;t get what I&apos;m doing wrong."><y>#</y><d>2019-04-25</d><h>04:01</h><r>Joel</r>i see examples of the same ... i don&apos;t get what I&apos;m doing wrong.</z><z id="t1556165393001100" t="Joel It actually works as expected if I add the fact when making the session."><y>#</y><d>2019-04-25</d><h>04:09</h><r>Joel</r>It actually works as expected if I add the fact when making the session.</z><z id="t1556167519001300" t="Joel changing salience fixes this!?"><y>#</y><d>2019-04-25</d><h>04:45</h><r>Joel</r>changing salience fixes this!?</z><z id="t1556095442034000" t="wparker Regarding looking at fired rules, the idiomatic way to get output from the session would usually be to have facts that represent that output and query on those facts. The tracing listener will tell you what rules fired, but it will also include rules that were later retracted. The API guarantees are generally around the final state of the session, not what rules are fired on the way there. It&apos;s possible to design rules in a way that constrains this, but this has to be done carefully and wouldn&apos;t be my first approach to solving a given problem. The tracing listener is primarily intended for debugging and performance problem diagnosis."><y>#</y><d>2019-04-24</d><h>08:44</h><w>wparker</w>Regarding looking at fired rules, the idiomatic way to get output from the session would usually be to have facts that represent that output and query on those facts.  The tracing listener will tell you what rules fired, but it will also include rules that were later retracted.  The API guarantees are generally around the final state of the session, not what rules are fired on the way there.  It&apos;s possible to design rules in a way that constrains this, but this has to be done carefully and wouldn&apos;t be my first approach to solving a given problem.   The tracing listener is primarily intended for debugging and performance problem diagnosis.</z><z id="t1556214527000800" t="Joel thanks @wparker. I opened clara ticket and that has been insightful as well."><y>#</y><d>2019-04-25</d><h>17:48</h><w>Joel</w>thanks @wparker. I opened clara ticket and that has been insightful as well.</z><z id="t1556252479001100" t="Joel is it possible to refer to the doc string on the RHS?"><y>#</y><d>2019-04-26</d><h>04:21</h><w>Joel</w>is it possible to refer to the doc string on the RHS?</z><z id="t1556283284002300" t="mikerod That seems odd. Maybe with a defrule style macro you could refer to its own self var and find the doc string on there somehow. "><y>#</y><d>2019-04-26</d><h>12:54</h><w>mikerod</w>That seems odd. Maybe with a defrule style macro you could refer to its own self var and find the doc string on there somehow. </z><z id="t1556283314002900" t="mikerod Would have to test that theory out though. Can’t at the moment. "><y>#</y><d>2019-04-26</d><h>12:55</h><w>mikerod</w>Would have to test that theory out though. Can’t at the moment. </z><z id="t1556283754004200" t="ethanc Since clara allows arbitrary clojure in the rhs, most things are possible. It just seems a bit weird to do them: (defrule a-rule &quot;hello&quot; [A (&gt; x 3)] =&gt; (println (:doc (meta #&apos;a-rule)))) (-&gt; (mk-session) (insert (-&gt;A 4)) fire-rules) hello "><y>#</y><d>2019-04-26</d><h>13:02</h><w>ethanc</w>Since clara allows arbitrary clojure in the rhs, most things are possible. It just seems a bit weird to do them:
<pre>(defrule a-rule
  &quot;hello&quot;
  [A (&gt; x 3)]
  =&gt;
  (println (:doc (meta #&apos;a-rule))))

(-&gt; (mk-session)
    (insert (-&gt;A 4))
    fire-rules)
hello
</pre></z><z id="t1556319726004500" t="Joel sweet."><y>#</y><d>2019-04-26</d><h>23:02</h><w>Joel</w>sweet.</z><z id="t1556319841005100" t="Joel well, i dunno like you say a bit weird, but at least possible."><y>#</y><d>2019-04-26</d><h>23:04</h><w>Joel</w>well, i dunno like you say a bit weird, but at least possible.</z><z id="t1556320523006200" t="Joel @ethanc --- commented on ticket #428 - curious if retract rules from :rule-matches reasonably possible."><y>#</y><d>2019-04-26</d><h>23:15</h><w>Joel</w>@ethanc --- commented on ticket #428 - curious if retract rules from :rule-matches reasonably possible.</z><z id="t1556337895008100" t="Joel I want to have multiple rule systems, each would have it&apos;s own namespace, but I&apos;d like to share not only records, but defquerys as well. However, I&apos;m not figuring out how to add the defquery from another namespace."><y>#</y><d>2019-04-27</d><h>04:04</h><w>Joel</w>I want to have multiple rule systems, each would have it&apos;s own namespace, but I&apos;d like to share not only records, but defquerys as well. However, I&apos;m not figuring out how to add the defquery from another namespace.</z><z id="t1556384906008200" t="mikerod @joel380 you can pass ns names, or a collection of rule/query structures to mk -session"><y>#</y><d>2019-04-27</d><h>17:08</h><w>mikerod</w>@joel380 you can pass ns names, or a collection of rule/query structures to mk -session</z><z id="t1556384910008300" t="mikerod So if you did defquery, you’d just do: (mk-session [my-query]) "><y>#</y><d>2019-04-27</d><h>17:08</h><w>mikerod</w>So if you did defquery, you’d just do:
<pre>(mk-session [my-query])
</pre></z><z id="t1556384914008400" t="mikerod There is more you can do too if you mark a var metadata with :production-seq that allows you to store sequences of rule/query structures under a single var when a ns is searched for rules/queries. "><y>#</y><d>2019-04-27</d><h>17:08</h><w>mikerod</w>There is more you can do too if you mark a var metadata with :production-seq  that allows you to store sequences of rule/query structures under a single var when a ns is searched for rules/queries. </z><z id="t1556406884009300" t="Joel thanks, i had tried (mk-session &apos;(my-query)) ... still getting up to speed on clojure"><y>#</y><d>2019-04-27</d><h>23:14</h><w>Joel</w>thanks, i had tried (mk-session &apos;(my-query)) ... still getting up to speed on clojure</z><z id="t1556407127009700" t="Joel hopefully that let&apos;s me use another ns as well. ill give it a go."><y>#</y><d>2019-04-27</d><h>23:18</h><w>Joel</w>hopefully that let&apos;s me use another ns as well. ill give it a go.</z><z id="t1556445220013000" t="wparker Yes, you can use an arbitrary mix of namespaces and sequences of explicitly included rules/queries when defining your session."><y>#</y><d>2019-04-28</d><h>09:53</h><r>wparker</r>Yes, you can use an arbitrary mix of namespaces and sequences of explicitly included rules/queries when defining your session.</z><z id="t1556410216010100" t="mikerod Use a vector and no quoting needed"><y>#</y><d>2019-04-28</d><h>00:10</h><w>mikerod</w>Use a vector and no quoting needed</z><z id="t1556423821011900" t="Joel How is anyone going about getting the reasons for the rule decisions? Or, as often done in other systems, use the rule name, in Clara case the :doc tag. The problem I see is when I do (inspect session) the :rule-matches matches rules that never fired."><y>#</y><d>2019-04-28</d><h>03:57</h><w>Joel</w>How is anyone going about getting the reasons for the rule decisions? Or, as often done in other systems, use the rule name, in Clara case the :doc tag.

The problem I see is when I do (inspect session) the :rule-matches matches rules that never fired.</z><z id="t1556425156012800" t="Joel Actually it looks like the rules have a () &quot;matches&quot; section, that I need to check... Unclear how I should be parsing that. Is there any convenience fn&apos;s?"><y>#</y><d>2019-04-28</d><h>04:19</h><w>Joel</w>Actually it looks like the rules have a () &quot;matches&quot; section, that I need to check... Unclear how I should be parsing that. Is there any convenience fn&apos;s?</z><z id="t1556445273013200" t="wparker I&apos;m not sure what you&apos;re trying to do, could you elaborate?"><y>#</y><d>2019-04-28</d><h>09:54</h><r>wparker</r>I&apos;m not sure what you&apos;re trying to do, could you elaborate?</z><z id="t1556472716013400" t="Joel I was trying to strip out the rule :docs that had matches. It wasn&apos;t clear to me that there were rules listed that weren&apos;t fired. This did the trick: (defn matched-rule-docs [session] (let [rule-match-map (:rule-matches (inspect session)) matched-rules (filter #(seq (get rule-match-map %)) (keys rule-match-map))] (map :doc matched-rules)))"><y>#</y><d>2019-04-28</d><h>17:31</h><r>Joel</r>I was trying to strip out the rule :docs that had matches. It wasn&apos;t clear to me that there were rules listed that weren&apos;t fired. This did the trick:

(defn matched-rule-docs [session]
  (let [rule-match-map (:rule-matches (inspect session))
        matched-rules (filter #(seq (get rule-match-map %)) (keys rule-match-map))]
    (map :doc matched-rules)))</z><z id="t1556477824014100" t="Joel Can this be done w/o using :test?: &apos;&apos;&apos; [?registry &lt;- ListRegistry] [:test (.isMember ?registry &quot;userguidwl&quot; &quot;whitelist&quot; &quot;userguid&quot;)] &apos;&apos;&apos;"><y>#</y><d>2019-04-28</d><h>18:57</h><w>Joel</w>Can this be done w/o using :test?:
&apos;&apos;&apos;
  [?registry &lt;- ListRegistry]
  [:test (.isMember ?registry &quot;userguidwl&quot; &quot;whitelist&quot; &quot;userguid&quot;)]
&apos;&apos;&apos;</z><z id="t1556477886014900" t="Joel (java class)"><y>#</y><d>2019-04-28</d><h>18:58</h><w>Joel</w>(java class)</z><z id="t1556477991016600" t="ethanc Use the this symbol in place of ?registry, If I read your question correctly"><y>#</y><d>2019-04-28</d><h>18:59</h><w>ethanc</w>Use the <code>this</code> symbol in place of ?registry, If I read your question correctly</z><z id="t1556478345016900" t="Joel you probably do read it correctly, ill try that."><y>#</y><d>2019-04-28</d><h>19:05</h><w>Joel</w>you probably do read it correctly, ill try that.</z><z id="t1556501246018900" t="mikerod [?registry &lt;- ListRegistry (.isMember this &lt;..etc..&gt;)] "><y>#</y><d>2019-04-29</d><h>01:27</h><w>mikerod</w><pre>[?registry &lt;- ListRegistry (.isMember this &lt;..etc..&gt;)]
</pre></z><z id="t1556583734021300" t="Joel How can I apply the working memory from one session to another? Or fire one group of rules, and then apply it&apos;s WM to another set of rules?"><y>#</y><d>2019-04-30</d><h>00:22</h><w>Joel</w>How can I apply the working memory from one session to another? Or fire one group of rules, and then apply it&apos;s WM to another set of rules?</z><z id="t1556588032022900" t="mikerod @joel380 if needing to go from one group or rules to another, you could just make query for the facts you want out of the first group, then insert those query results into the next group. "><y>#</y><d>2019-04-30</d><h>01:33</h><w>mikerod</w>@joel380 if needing to go from one group or rules to another, you could just make query for the facts you want out of the first group, then insert those query results into the next group. </z><z id="t1556588631024300" t="Joel i&apos;d want all of them, would rather avoid queries for each type."><y>#</y><d>2019-04-30</d><h>01:43</h><w>Joel</w>i&apos;d want all of them, would rather avoid queries for each type.</z><z id="t1556588697024600" t="Joel I didn&apos;t see them listed as part of the session."><y>#</y><d>2019-04-30</d><h>01:44</h><w>Joel</w>I didn&apos;t see them listed as part of the session.</z><z id="t1556630853026800" t="mikerod Yeah a query for all types is typically rough on performance. "><y>#</y><d>2019-04-30</d><h>13:27</h><w>mikerod</w>Yeah a query for all types is typically rough on performance. </z><z id="t1556630923028600" t="mikerod For all facts in working memory I don’t think there is a direct hook. I think maybe @ethanc would remember how we did “all facts” before. "><y>#</y><d>2019-04-30</d><h>13:28</h><w>mikerod</w>For all facts in working memory I don’t think there is a direct hook. I think maybe @ethanc would remember how we did “all facts” before. </z><z id="t1556630984030500" t="mikerod Also, keep in mind that the engine won’t hold onto facts that it knows will never match. So for example, if you insert a fact A but no rule will ever be able to match it, it doesn’t stay in working memory. So you wouldn’t get it back with some “all facts” request. "><y>#</y><d>2019-04-30</d><h>13:29</h><w>mikerod</w>Also, keep in mind that the engine won’t hold onto facts that it knows will never match. So for example, if you insert a fact A but no rule will ever be able to match it, it doesn’t stay in working memory. So you wouldn’t get it back with some “all facts” request. </z><z id="t1556632819033900" t="ethanc @joel380, Perhaps creating a marker protocol for the types of facts that you are interested in, and then leveraging a single query on that protocol. Something like: (require &apos;[clara.rules :refer :all]) (require &apos;[clara.rules.accumulators :as acc]) (defprotocol ImportantFacts) (defrecord A [x]) (defrecord B [y]) (defrecord C [z] ImportantFacts) (defrecord D [a] ImportantFacts) (defrecord E [b] ImportantFacts) (defrule a-rule [A (= ?x x)] =&gt; (insert! (-&gt;C (+ ?x 10)))) (defrule b-rule [B (= ?y y)] =&gt; (insert! (-&gt;D (+ ?y 50)))) (defrule ab-rule [A (= ?x x)] [B (= ?y y)] =&gt; (insert! (-&gt;E (+ ?y ?x)))) (defquery important-query [] [?all-important &lt;- (acc/all) :from [user.ImportantFacts]]) (-&gt; (mk-session) (insert (-&gt;A 12)) (insert (-&gt;B 1)) fire-rules (query important-query)) There is something goofy about the clara.rules.dsl namespace, with respect to how it resolves “types”, specifically protocols so i had to fully qualify the ImportantFacts symbol."><y>#</y><d>2019-04-30</d><h>14:00</h><w>ethanc</w>@joel380,
Perhaps creating a marker protocol for the types of facts that you are interested in, and then leveraging a single query on that protocol. Something like:
<pre>(require &apos;[clara.rules :refer :all])
(require &apos;[clara.rules.accumulators :as acc])

(defprotocol ImportantFacts)

(defrecord A [x])
(defrecord B [y])

(defrecord C [z]
  ImportantFacts)

(defrecord D [a]
  ImportantFacts)

(defrecord E [b]
  ImportantFacts)


(defrule a-rule 
  [A (= ?x x)]
  =&gt;
  (insert! (-&gt;C (+ ?x 10))))


(defrule b-rule
  [B (= ?y y)]
  =&gt;
  (insert! (-&gt;D (+ ?y 50))))

(defrule ab-rule
  [A (= ?x x)]
  [B (= ?y y)]
  =&gt;
  (insert! (-&gt;E (+ ?y ?x))))

(defquery important-query
  []
  [?all-important &lt;- (acc/all) :from [user.ImportantFacts]])


(-&gt; (mk-session)
    (insert (-&gt;A 12))
    (insert (-&gt;B 1))
    fire-rules
    (query important-query))
</pre>

There is something goofy about the <code>clara.rules.dsl</code> namespace, with respect to how it resolves “types”, specifically protocols so i had to fully qualify the ImportantFacts symbol.</z><z id="t1556633367034100" t="ethanc =&gt; ({:?all-important [#user.C{:z 22} #user.D{:a 51} #user.E{:b 13}]}) "><y>#</y><d>2019-04-30</d><h>14:09</h><w>ethanc</w><pre>=&gt; ({:?all-important [#user.C{:z 22} #user.D{:a 51} #user.E{:b 13}]})
</pre></z><z id="t1556636589036500" t="mikerod @joel380 @ethanc discussed on the side w/Ethan, but the defprotocol pattern for type hierarchies is sort of pedantically “wrong” I’d say. I think the host-type associated w/a defprotocol is meant to be more of an “impl details” (although it isn’t going to change), that is concerned with performance optimizations. So I’d probably go w/ definterface when all you want is the type marker. That said, Clara has supported defprotocol types being used in rules when the symbol is in reference to the the class type, not the protocol metadata var. Ethan is likely going to log a Clara issues concerning the 2nd case and how this can get weird."><y>#</y><d>2019-04-30</d><h>15:03</h><w>mikerod</w>@joel380 @ethanc discussed on the side w/Ethan, but the <code>defprotocol</code> pattern for type hierarchies is sort of pedantically “wrong” I’d say. I think the host-type associated w/a <code>defprotocol</code> is meant to be more of an “impl details” (although it isn’t going to change), that is concerned with performance optimizations. So I’d probably go w/ <code>definterface</code> when all you want is the type marker. That said, Clara has supported <code>defprotocol</code> types being used in rules when the symbol is in reference to the the class type, not the protocol metadata var. Ethan is likely going to log a Clara issues concerning the 2nd case and how this can get weird.</z><z id="t1556673208042200" t="Joel I appreciate all the help here so far! FWIW, I&apos;m looking into something that might work better than Drools for us. On that side we currently leverage rule-groups, and the order of groups is controlled. I think we can probably break away from that pattern, but just in case, the reason for my question is to see if that behavior could be had as a &quot;fallback&quot; in Clara. I think though if facts get &quot;kicked out&quot; of WM, then managing that could be kind of ugly. It sounds like the &quot;one true way&quot; in Clara is to put guards in as appropriate, and that&apos;s the approach I&apos;ll take for now rather than trying skip rule-groups or some such by segregating the rules."><y>#</y><d>2019-05-01</d><h>01:13</h><w>Joel</w>I appreciate all the help here so far! FWIW, I&apos;m looking into something that might work better than Drools for us. On that side we currently leverage rule-groups, and the order of groups is controlled. I think we can probably break away from that pattern, but just in case, the reason for my question is to see if that behavior could be had as a &quot;fallback&quot; in Clara. I think though if facts get &quot;kicked out&quot; of WM, then managing that could be kind of ugly.

It sounds like the &quot;one true way&quot; in Clara is to put guards in as appropriate, and that&apos;s the approach I&apos;ll take for now rather than trying skip rule-groups or some such by segregating the rules.</z><z id="t1556673287043200" t="Joel I&apos;m curious if anyone changes their rules dynamically in a production environment, and any issues that may come up as a result."><y>#</y><d>2019-05-01</d><h>01:14</h><w>Joel</w>I&apos;m curious if anyone changes their rules dynamically in a production environment, and any issues that may come up as a result.</z><z id="t1556721378044600" t="mikerod @joel380 Clara does have support for activation group like behavior. But it doesn’t completely disable rules. It prioritizes a firing order. It’s much like salience, but on a group of rule level. And salience works within a group. "><y>#</y><d>2019-05-01</d><h>14:36</h><w>mikerod</w>@joel380 Clara does have support for activation group like behavior. But it doesn’t completely disable rules. It prioritizes a firing order. It’s much like salience, but on a group of rule level. And salience works within a group. </z><z id="t1556721419046000" t="mikerod I just tend to think you can write more robust rules when you don’t write them in order dependent ways. Clara defaults to logical inserts that self-maintain the logical consistency to eliminate a large need for ordering. "><y>#</y><d>2019-05-01</d><h>14:36</h><w>mikerod</w>I just tend to think you can write more robust rules when you don’t write them in order dependent ways. Clara defaults to logical inserts that self-maintain the logical consistency to eliminate a large need for ordering. </z><z id="t1556721449047000" t="mikerod Drools provides a truth maintenance system too, but it isn’t the default in drools to insert “logical”, you have to call a separate fn for that in Drools. "><y>#</y><d>2019-05-01</d><h>14:37</h><w>mikerod</w>Drools provides a truth maintenance system too, but it isn’t the default in drools to insert “logical”, you have to call a separate fn for that in Drools. </z><z id="t1556721456047300" t="mikerod In Clara the reverse is true. "><y>#</y><d>2019-05-01</d><h>14:37</h><w>mikerod</w>In Clara the reverse is true. </z><z id="t1556721473047800" t="mikerod Part 2: what do you mean changing rules dynamically in production? "><y>#</y><d>2019-05-01</d><h>14:37</h><w>mikerod</w>Part 2: what do you mean changing rules dynamically in production? </z><z id="t1556721519049200" t="mikerod You’d have to create a new session+rulebase for new rules. Clara doesn’t support dynamic addition and removal of rules in an already constructed network. "><y>#</y><d>2019-05-01</d><h>14:38</h><w>mikerod</w>You’d have to create a new session+rulebase for new rules. Clara doesn’t support dynamic addition and removal of rules in an already constructed network. </z><z id="t1556721554050400" t="mikerod Drools does. And the semantics are to distribute working memory state to the new rules as they are added I believe. Clara has some mice optimization properties due to it not allowing this. "><y>#</y><d>2019-05-01</d><h>14:39</h><w>mikerod</w>Drools does. And the semantics are to distribute working memory state to the new rules as they are added I believe. Clara has some mice optimization properties due to it not allowing this. </z><z id="t1556721634052800" t="mikerod It’s possible it could be a future “mode” supported, but that’s require someone quite motivated to do it. I tend to think you can often just make a new session and re-run from scratch, or only put new rules in separate session and propagate facts from one to the next as needed. Cases vary though. "><y>#</y><d>2019-05-01</d><h>14:40</h><w>mikerod</w>It’s possible it could be a future “mode” supported, but that’s require someone quite motivated to do it. I tend to think you can often just make a new session and re-run from scratch, or only put new rules in separate session and propagate facts from one to the next as needed. Cases vary though. </z><z id="t1556766374053900" t="Joel dynamic loading --- i mean doing load-string on a clojure file containing the rules/defsession, at runtime as rules are occasionally dynamically updated."><y>#</y><d>2019-05-02</d><h>03:06</h><w>Joel</w>dynamic loading --- i mean doing load-string on a clojure file containing the rules/defsession, at runtime as rules are occasionally dynamically updated.</z><z id="t1556766610055500" t="Joel in drools we short-circuit to the last group if a previous group makes a decision basically. I think for Clara we just put guards in all the following rules."><y>#</y><d>2019-05-02</d><h>03:10</h><w>Joel</w>in drools we short-circuit to the last group if a previous group makes a decision basically. I think for Clara we just put guards in all the following rules.</z><z id="t1556893289056700" t="Joel Couple of questions 1) I see there is no &quot;update!&quot; --- is retract! followed by insert! considered non-idiomatic?"><y>#</y><d>2019-05-03</d><h>14:21</h><w>Joel</w>Couple of questions
1) I see there is no &quot;update!&quot; --- is retract! followed by insert! considered non-idiomatic?</z><z id="t1556894259066800" t="eraserhd In general, updating a fact would make truth maintenance really hard, if not impossible. If you find yourself retracting and inserting a fact on a right-hand-side, you are probably also going to run afoul of truth maintenance, likely by creating an infinite loop."><y>#</y><d>2019-05-03</d><h>14:37</h><w>eraserhd</w>In general, updating a fact would make truth maintenance really hard, if not impossible.  If you find yourself retracting and inserting a fact on a right-hand-side, you are probably also going to run afoul of truth maintenance, likely by creating an infinite loop.</z><z id="t1556894306067700" t="eraserhd Logically, if a fact is no longer true because of a new piece of data, you should have an additional condition on the left-hand-side of the original rule."><y>#</y><d>2019-05-03</d><h>14:38</h><w>eraserhd</w>Logically, if a fact is no longer true because of a new piece of data, you should have an additional condition on the left-hand-side of the original rule.</z><z id="t1556894331068300" t="eraserhd Which allows truth maintenance to clear it up."><y>#</y><d>2019-05-03</d><h>14:38</h><w>eraserhd</w>Which allows truth maintenance to clear it up.</z><z id="t1556894345068800" t="Joel 2) I have a case where I take measurements of events something like {&quot;eventX&quot; [ (:limit 5 :prior (5 hrs)) (:limit 10 :prior (1 day)) ]} also I need to +1 those measures if they just now happened based on rule. (I don&apos;t have a list of events over that time, just the prior totals) I&apos;m guessing the short answer is I need to &quot;normalize the list&quot; into individual facts and leverage insert-all! as well as use an accumulator (prior total + 1?), but then I need to accumulate and match against the limit, and how to do this with a flexible list is the part I&apos;m not currently seeing. Particularly totaling over each period to compare against limit."><y>#</y><d>2019-05-03</d><h>14:39</h><w>Joel</w>2) I have a case where I take measurements of events
    something like {&quot;eventX&quot; [ (:limit 5 :prior (5 hrs)) (:limit 10 :prior (1 day)) ]}
    also I need to +1 those measures if they just now happened based on rule. (I don&apos;t have a list of events over that time, just the prior totals)

I&apos;m guessing the short answer is I need to &quot;normalize the list&quot; into individual facts and leverage insert-all! as well as use an accumulator (prior total + 1?), but then I need to accumulate and match against the limit, and how to do this with a flexible list is the part I&apos;m not currently seeing. Particularly totaling over each period to compare against limit.</z><z id="t1556894613069400" t="eraserhd I would absolutely break down the measurements into independent facts."><y>#</y><d>2019-05-03</d><h>14:43</h><w>eraserhd</w>I would absolutely break down the measurements into independent facts.</z><z id="t1556894697071300" t="eraserhd I&apos;m not sure how you are saying :prior works. Do you want a rule to fire a rule if you get an event more than :limit in the last :prior?"><y>#</y><d>2019-05-03</d><h>14:44</h><w>eraserhd</w>I&apos;m not sure how you are saying :prior works.  Do you want a rule to fire a rule if you get an event more than :limit in the last :prior?</z><z id="t1556894751072500" t="Joel so there&apos;s the existing count (from DB) if that count + (just now happened) &gt; limit fire rule."><y>#</y><d>2019-05-03</d><h>14:45</h><w>Joel</w>so there&apos;s the existing count (from DB)
if that count + (just now happened) &gt; limit    fire rule.</z><z id="t1556894838073600" t="eraserhd You&apos;ve inserted multiple facts that has the database count of events of a particular type?"><y>#</y><d>2019-05-03</d><h>14:47</h><w>eraserhd</w>You&apos;ve inserted multiple facts that has the database count of events of a particular type?</z><z id="t1556894913074900" t="Joel i can do that... currently the logic is the LHS side fetches the info (uses cache)"><y>#</y><d>2019-05-03</d><h>14:48</h><w>Joel</w>i can do that... currently the logic is the LHS side fetches the info (uses cache)</z><z id="t1556894921075100" t="Joel (java call)"><y>#</y><d>2019-05-03</d><h>14:48</h><w>Joel</w>(java call)</z><z id="t1556894950075700" t="Joel the final piece is maybe something like [ EventCount (?name name)(?limit limit)(?period period) (&gt;= ?limit ( accumulate total for ?period ?name)) ; pseudocode"><y>#</y><d>2019-05-03</d><h>14:49</h><w>Joel</w>the final piece is maybe something like
[ EventCount (?name name)(?limit limit)(?period period) (&gt;= ?limit ( accumulate total for ?period ?name))    ; pseudocode</z><z id="t1556895008076600" t="Joel but then accumulating will be redundant."><y>#</y><d>2019-05-03</d><h>14:50</h><w>Joel</w>but then accumulating will be redundant.</z><z id="t1556895033077200" t="eraserhd Assuming you aren&apos;t using an immutable, global database, you will likely have trouble with consistency if you put database calls on the left-hand-side."><y>#</y><d>2019-05-03</d><h>14:50</h><w>eraserhd</w>Assuming you aren&apos;t using an immutable, global database, you will likely have trouble with consistency if you put database calls on the left-hand-side.</z><z id="t1556895101078500" t="Joel (the cache fixes that part, only refetches for another session)"><y>#</y><d>2019-05-03</d><h>14:51</h><w>Joel</w>(the cache fixes that part, only refetches for another session)</z><z id="t1556895136079200" t="Joel but that doesn&apos;t give me a flexible list of periods"><y>#</y><d>2019-05-03</d><h>14:52</h><w>Joel</w>but that doesn&apos;t give me a flexible list of periods</z><z id="t1556895148079500" t="eraserhd You have access to the session on the left-hand-side?"><y>#</y><d>2019-05-03</d><h>14:52</h><w>eraserhd</w>You have access to the session on the left-hand-side?</z><z id="t1556895156079700" t="eraserhd (in a rule at all, in fact?)"><y>#</y><d>2019-05-03</d><h>14:52</h><w>eraserhd</w>(in a rule at all, in fact?)</z><z id="t1556895168080000" t="Joel no... its a java bean inserted into WM"><y>#</y><d>2019-05-03</d><h>14:52</h><w>Joel</w>no... its a java bean inserted into WM</z><z id="t1556895189080400" t="eraserhd what&apos;s a WM?"><y>#</y><d>2019-05-03</d><h>14:53</h><w>eraserhd</w>what&apos;s a WM?</z><z id="t1556895204080800" t="Joel but a new one for each ... sorry firing. (working memory : clara currently drools 🙂 )"><y>#</y><d>2019-05-03</d><h>14:53</h><w>Joel</w>but a new one for each ... sorry firing. (working memory : clara currently drools <b>🙂</b>  )</z><z id="t1556895240081400" t="Joel basically the bean is inserted before fire rules."><y>#</y><d>2019-05-03</d><h>14:54</h><w>Joel</w>basically the bean is inserted before fire rules.</z><z id="t1556895247081600" t="eraserhd ah, right. But this will have the consistency issue I&apos;m talking about. If the count changes in the database, it will not refire a rule."><y>#</y><d>2019-05-03</d><h>14:54</h><w>eraserhd</w>ah, right.   But this will have the consistency issue I&apos;m talking about.  If the count changes in the database, it will not refire a rule.</z><z id="t1556895256081800" t="Joel not an issue."><y>#</y><d>2019-05-03</d><h>14:54</h><w>Joel</w>not an issue.</z><z id="t1556895270082400" t="Joel it caches the call and keeps it for rest of that firing."><y>#</y><d>2019-05-03</d><h>14:54</h><w>Joel</w>it caches the call and keeps it for rest of that firing.</z><z id="t1556895280082700" t="Joel and that&apos;s acceptable."><y>#</y><d>2019-05-03</d><h>14:54</h><w>Joel</w>and that&apos;s acceptable.</z><z id="t1556895285082900" t="eraserhd Ahhh, I see."><y>#</y><d>2019-05-03</d><h>14:54</h><w>eraserhd</w>Ahhh, I see.</z><z id="t1556895305083300" t="eraserhd It presents an immutable snapshot to the session. That&apos;s kind of neat."><y>#</y><d>2019-05-03</d><h>14:55</h><w>eraserhd</w>It presents an immutable snapshot to the session.  That&apos;s kind of neat.</z><z id="t1556895344084000" t="Joel but currently we write rules and add to them if we add more periods, that sort of thing... rather have the list of periods flexible and rules take care of."><y>#</y><d>2019-05-03</d><h>14:55</h><w>Joel</w>but currently we write rules and add to them if we add more periods, that sort of thing... rather have the list of periods flexible and rules take care of.</z><z id="t1556895391084900" t="Joel I think I need two defrecords one for name/period combo and another for keeping the count?"><y>#</y><d>2019-05-03</d><h>14:56</h><w>Joel</w>I think I need two defrecords one for name/period combo and another for keeping the count?</z><z id="t1556895468085900" t="Joel so match on all periods records and accumulate on the counting records (i think)."><y>#</y><d>2019-05-03</d><h>14:57</h><w>Joel</w>so match on all periods records and accumulate on the counting records (i think).</z><z id="t1556895499086900" t="Joel i think i was trying to keep this all kind of in one structure, and that&apos;s not do-able."><y>#</y><d>2019-05-03</d><h>14:58</h><w>Joel</w>i think i was trying to keep this all kind of in one structure, and that&apos;s not do-able.</z><z id="t1556895503087100" t="eraserhd I think doing arbitrary, data-driven periods will be hard without generating rules from data."><y>#</y><d>2019-05-03</d><h>14:58</h><w>eraserhd</w>I think doing arbitrary, data-driven periods will be hard without generating rules from data.</z><z id="t1556895559087500" t="eraserhd Well, maybe not the way you are doing it."><y>#</y><d>2019-05-03</d><h>14:59</h><w>eraserhd</w>Well, maybe not the way you are doing it.</z><z id="t1556895632088900" t="Joel yeah, i&apos;m going to see what that looks like if I can get it working refine from there... Thanks!"><y>#</y><d>2019-05-03</d><h>15:00</h><w>Joel</w>yeah, i&apos;m going to see what that looks like if I can get it working refine from there... Thanks!</z><z id="t1557137853091800" t="wparker @joel380 not sure if this will impact you, but note that facts should be immutable, including as regards their equals and hash methods. If, say, a hashcode changed while rules were firing you could get strange (undefined) behavior."><y>#</y><d>2019-05-06</d><h>10:17</h><w>wparker</w>@joel380 not sure if this will impact you, but note that facts should be immutable, including as regards their equals and hash methods.  If, say, a hashcode changed while rules were firing you could get strange (undefined) behavior.</z><z id="t1557372313107800" t="Joel I&apos;m thinking I may like to express a part of my system as a list (of maps) that gets turned into rules dynamically. However, I&apos;d still need to express part of the LHS conditions in this list. The examples I saw suggested that I should produce the data structure as if the macros had been run. Is this a bad use case for rule generation, as I&apos;d somehow need to transform these partial conditions and inject into final form?"><y>#</y><d>2019-05-09</d><h>03:25</h><w>Joel</w>I&apos;m thinking I may like to express a part of my system as a list (of maps) that gets turned into rules dynamically. However, I&apos;d still need to express part of the LHS conditions in this list. The examples I saw suggested that I should produce the data structure as if the macros had been run.  Is this a bad use case for rule generation, as I&apos;d somehow need to transform these partial conditions and inject into final form?</z><z id="t1557493510110700" t="wparker The API constraint is that mk-session needs to receive unevaluated code in the same format that the defrule and defmacro macros construct. I’ve worked on cases where the rules were generated from a DSL that had quite a bit of processing into Clara rule forms, so what you’re suggesting sounds plausible."><y>#</y><d>2019-05-10</d><h>13:05</h><r>wparker</r>The API constraint is that mk-session needs to receive unevaluated code in the same format that the defrule and defmacro macros construct.  I’ve worked on cases where the rules were generated from a DSL that had quite a bit of processing into Clara rule forms, so what you’re suggesting sounds plausible.</z><z id="t1557938089118900" t="drewverlee Apologies for asking wide sweeping and possible horrible inaccurate questions: 1. clara (and rules engines in general) has no story for how to persist data correct? 2. datatomic and clara would seem to overlap in that they both use declarative joins to query data. 3. clara has reactive in memory updates to rules, while nothing in the dataomic ecosystem offers this (that i know of, which isn&apos;t saying much). It seems like reactive datalog, would bridge many of these gaps (but at what costs!). However, i also assume maybe trying to bridge these differences at the library/database level has large implications for how your system has to be setup (databases, etc...). especially in order to be fast enough to be interesting."><y>#</y><d>2019-05-15</d><h>16:34</h><w>drewverlee</w>Apologies for asking wide sweeping and possible horrible inaccurate questions:

1. clara (and rules engines in general) has no story for how to persist data correct?
2. datatomic and clara would seem to overlap in that they both use declarative joins to query data.
3. clara has reactive in memory updates to rules, while nothing in the dataomic ecosystem offers this (that i know of, which isn&apos;t saying much).

It seems like reactive datalog, would bridge many of these gaps (but at what costs!). However, i also assume maybe trying to bridge these differences at the library/database level has large implications for how your system has to be setup (databases, etc...). especially in order to be fast enough to be interesting.</z><z id="t1557953028122700" t="mikerod @drewverlee &gt; 1. clara (and rules engines in general) has no story for how to persist data correct? Yeah, for the most part it doesn’t do that. There is some foundations for “durability” supported, but subject to change, but it’s nothing like datomic or something to that extent. &gt; 2. datatomic and clara would seem to overlap in that they both use declarative joins to query data. There is some overlap in how you query data out perhaps. However, it’s done much differently. Datomic assumes much more of an ecosystem around it. Clara is a lightweight lib you can drop in the middle of your app and it just is a way to express conditional logic that is perhaps hard to express well with your own if-then logic. It also gives you the ability to be more declarative in describing your logic by using a truth maintenance system and a modern variant of the classic rete algorithm for perf benefits. &gt; 3. clara has reactive in memory updates to rules, while nothing in the dataomic ecosystem offers this (that i know of, which isn’t saying much). I can’t say exactly that datomic is lacking this. I think you’d have to put a system over it indeed. You allude then to datalog, which is probably similar to Clara in nature, but I believe it is based on backwards-chaining logic, so then you have to consider forward vs backwards chaining for your application area. Hopefully this sheds some insight for you."><y>#</y><d>2019-05-15</d><h>20:43</h><w>mikerod</w>@drewverlee
&gt; 1. clara (and rules engines in general) has no story for how to persist data correct?

Yeah, for the most part it doesn’t do that. There is some foundations for “durability” supported, but subject to change, but it’s nothing like datomic or something to that extent.

&gt; 2. datatomic and clara would seem to overlap in that they both use declarative joins to query data.

There is some overlap in how you query data out perhaps. However, it’s done much differently. Datomic assumes much more of an ecosystem around it. Clara is a lightweight lib you can drop in the middle of your app and it just is a way to express conditional logic that is perhaps hard to express well with your own <code>if-then</code> logic. It also gives you the ability to be more declarative in describing your logic by using a truth maintenance system and a modern variant of the classic rete algorithm for perf benefits.

&gt; 3. clara has reactive in memory updates to rules, while nothing in the dataomic ecosystem offers this (that i know of, which isn’t saying much).

I can’t say exactly that datomic is lacking this. I think you’d have to put a system over it indeed.

You allude then to datalog, which is probably similar to Clara in nature, but I believe it is based on backwards-chaining logic, so then you have to consider forward vs backwards chaining for your application area.

Hopefully this sheds some insight for you.</z><z id="t1557953256123100" t="drewverlee This is hugely helpful, thank you. I was only recent aware of forwards chaining logic and to find out there is a (potentially) a relationship with datalog through a similar model, backwards chaining logic, is very interesting."><y>#</y><d>2019-05-15</d><h>20:47</h><r>drewverlee</r>This is hugely helpful, thank you. I was only recent aware of forwards chaining logic and to find out there is a (potentially) a relationship with datalog through a similar model, backwards chaining logic, is very interesting.</z><z id="t1557953391123300" t="mikerod No problem. Yeah, exploring forwards vs backwards chaining and when one may be better suited or not is always a topic of interest to me."><y>#</y><d>2019-05-15</d><h>20:49</h><r>mikerod</r>No problem. Yeah, exploring forwards vs backwards chaining and when one may be better suited or not is always a topic of interest to me.</z><z id="t1557953407123500" t="mikerod I think more or less, you can do similar things in both, but one may be more optimal for certain usages than the other"><y>#</y><d>2019-05-15</d><h>20:50</h><r>mikerod</r>I think more or less, you can do similar things in both, but one may be more optimal for certain usages than the other</z><z id="t1557953619123700" t="mikerod And in Clara’s case specifically, queries are expressed in a pre-defined way that is built directly into the rules network - via something such as defquery . So they are “pre-canned” and actually participate in the forward-chaining logic just like any other rule does. Something like datalog, I believe you just specify arbitrary queries on demand. These then form backwards chaining execution paths. More like a relational db query or something to that extent."><y>#</y><d>2019-05-15</d><h>20:53</h><r>mikerod</r>And in Clara’s case specifically, queries are expressed in a pre-defined way that is built directly into the rules network - via something such as <code>defquery</code>. So they are “pre-canned” and actually participate in the forward-chaining logic just like any other rule does.
Something like datalog, I believe you just specify arbitrary queries on demand. These then form backwards chaining execution paths. More like a relational db query or something to that extent.</z><z id="t1557955843123900" t="drewverlee I think your right mike, that very much gels with what i understand in principle about both. I think my next step is some papers and hammock time. Thanks a ton!"><y>#</y><d>2019-05-15</d><h>21:30</h><r>drewverlee</r>I think your right mike, that very much gels with what i understand in principle about both.

I think my next step is some papers and hammock time. Thanks a ton!</z><z id="t1558017133125400" t="eraserhd Just so you know, we use Datomic with Clara, and bolting them together has hit a sweet spot where we solved several problems at once."><y>#</y><d>2019-05-16</d><h>14:32</h><w>eraserhd</w>Just so you know, we use Datomic with Clara, and bolting them together has hit a sweet spot where we solved several problems at once.</z><z id="t1558017184126500" t="eraserhd Before, we had custom data validation code, and custom code to create &quot;synthetics&quot; - computed values that appear in our GraphQL queries that don&apos;t exist in the database."><y>#</y><d>2019-05-16</d><h>14:33</h><w>eraserhd</w>Before, we had custom data validation code, and custom code to create &quot;synthetics&quot; - computed values that appear in our GraphQL queries that don&apos;t exist in the database.</z><z id="t1558017244127400" t="eraserhd We are using less and less of datomic though, as it&apos;s now merely a data store, and we never query it directly except for debugging."><y>#</y><d>2019-05-16</d><h>14:34</h><w>eraserhd</w>We are using less and less of datomic though, as it&apos;s now merely a data store, and we never query it directly except for debugging.</z><z id="t1558054096129900" t="drewverlee How are you using datomic if your not querying it?"><y>#</y><d>2019-05-17</d><h>00:48</h><r>drewverlee</r>How are you using datomic if your not querying it?</z><z id="t1558019390128200" t="mikerod @eraserhd nice, hybrid situation of above"><y>#</y><d>2019-05-16</d><h>15:09</h><w>mikerod</w>@eraserhd nice, hybrid situation of above</z><z id="t1558019474128500" t="mikerod forgot to mention this project that came out a bit back and was discussed some here https://github.com/clyfe/clara-eav"><y>#</y><d>2019-05-16</d><h>15:11</h><w>mikerod</w>forgot to mention this project that came out a bit back and was discussed some here <a href="https://github.com/clyfe/clara-eav" target="_blank">https://github.com/clyfe/clara-eav</a></z><z id="t1558019549129800" t="mikerod I think the idea was to smoothly use EAV style tuples as facts. I haven’t used it or anything though. I just think it relates to datomic datoms."><y>#</y><d>2019-05-16</d><h>15:12</h><w>mikerod</w>I think the idea was to smoothly use EAV style tuples as facts. I haven’t used it or anything though. I just think it relates to datomic datoms.</z><z id="t1558231698131700" t="drewverlee Whats the difference from a query and a rule in rules engines in general. As i understand it. a rule is propositional logic &quot;if X then Y&quot; / X :- Y. But is query something else or is it just a rule where X is some direct match lookup?"><y>#</y><d>2019-05-19</d><h>02:08</h><w>drewverlee</w>Whats the difference from a query and a rule in rules engines in general.

As i understand it. a rule is propositional logic &quot;if X then Y&quot; / X :- Y. But is query something else or is it just a rule where X is some direct match lookup?</z><z id="t1558231724132000" t="drewverlee It seems in clara that rules can have arguments, is that right?"><y>#</y><d>2019-05-19</d><h>02:08</h><w>drewverlee</w>It seems in clara that rules can have arguments, is that right?</z><z id="t1558233368134000" t="mikerod @drewverlee queries gives you an external hook to pull data from the session. It has no RHS. When you “call” the query you get the matches as a result. The match’s have all the variable bindings of the rule bound by those keys for you to access. "><y>#</y><d>2019-05-19</d><h>02:36</h><w>mikerod</w>@drewverlee queries gives you an external hook to pull data from the session. It has no RHS. When you “call” the query you get the matches as a result. The match’s have all the variable bindings of the rule bound by those keys for you to access. </z><z id="t1558233399134800" t="mikerod You can parameterize a query. When you call it, you bind those parameters. "><y>#</y><d>2019-05-19</d><h>02:36</h><w>mikerod</w>You can parameterize a query. When you call it, you bind those parameters. </z><z id="t1558233424135700" t="mikerod Normal rules can’t be parameterized like this because you don’t “call” into rules directly. "><y>#</y><d>2019-05-19</d><h>02:37</h><w>mikerod</w>Normal rules can’t be parameterized like this because you don’t “call” into rules directly. </z><z id="t1561575655002300" t="misha why do rules have to have fact-type? e.g. Person here: [?person &lt;- Person (= first-name &quot;Alice&quot;) (= ?last-name last-name)] ;; or here [Person (= ?name1 name) (= ?age1 age)] "><y>#</y><d>2019-06-26</d><h>19:00</h><w>misha</w>why do rules have to have fact-type? e.g. <code>Person</code> here:
<pre>[?person &lt;- Person (= first-name &quot;Alice&quot;) (= ?last-name last-name)]
;; or here
[Person (= ?name1 name) (= ?age1 age)]
</pre></z><z id="t1561575932004100" t="misha how does engine implementation leverages that? it seems like having datomic-like datalog api would be somewhat more uniform or convenient, or ...?"><y>#</y><d>2019-06-26</d><h>19:05</h><w>misha</w>how does engine implementation leverages that?
it seems like having datomic-like datalog api would be somewhat more uniform or convenient, or ...?</z><z id="t1561579676007000" t="wparker @misha in essence Clara, given facts, finds the types that match that fact and looks up the rules with conditions on that type. Note that “matching the type” includes conditions matching on an ancestor of the fact’s type."><y>#</y><d>2019-06-26</d><h>20:07</h><w>wparker</w>@misha in essence Clara, given facts, finds the types that match that fact and looks up the rules with conditions on that type.  Note that “matching the type” includes conditions matching on an ancestor of the fact’s type.</z><z id="t1561579767008900" t="wparker This improves performance when there are lots of rules - a fact doesn’t have to be evaluated against rules that its’ type won’t allow it to match"><y>#</y><d>2019-06-26</d><h>20:09</h><w>wparker</w>This improves performance when there are lots of rules - a fact doesn’t have to be evaluated against rules that its’ type won’t allow it to match</z><z id="t1561579800009500" t="wparker There’s some tangentially related discussion of this at http://www.clara-rules.org/docs/fact_type_fn_perf/"><y>#</y><d>2019-06-26</d><h>20:10</h><w>wparker</w>There’s some tangentially related discussion of this at <a href="http://www.clara-rules.org/docs/fact_type_fn_perf/" target="_blank">http://www.clara-rules.org/docs/fact_type_fn_perf/</a></z><z id="t1561581364010500" t="mikerod @misha also, there are alternatives to how you could structure a DSL over this - Clara just has this one as the default. It isn’t necessarily trivial to extend things, but there are examples of at least datom-like datom support with https://github.com/clyfe/clara-eav"><y>#</y><d>2019-06-26</d><h>20:36</h><w>mikerod</w>@misha also, there are alternatives to how you could structure a DSL over this - Clara just has this one as the default. It isn’t necessarily trivial to extend things, but there are examples of at least datom-like datom support with <a href="https://github.com/clyfe/clara-eav" target="_blank">https://github.com/clyfe/clara-eav</a></z><z id="t1561636233018500" t="misha Thanks, Mike and W. Reading into both clara and eav sources now. However I still have strong feeling, something clever can be figured out on top of “vanilla” datalog (or very tightly coupled with). Eav seems to wrap clara, and only pretend to be datomic-like, in dsl layer. I’ll dig deeper into how attribute in conjunction with :aevt index can be used to pre-narrow down query space, as clara does with records-as-ruletypes"><y>#</y><d>2019-06-27</d><h>11:50</h><w>misha</w>Thanks, Mike and W.
Reading into both clara and eav sources now.
However I still have strong feeling, something clever can be figured out on top of “vanilla” datalog (or very tightly coupled with). Eav seems to wrap clara, and only pretend to be datomic-like, in dsl layer. I’ll dig deeper into how attribute in conjunction with :aevt index can be used to pre-narrow down query space, as clara does with records-as-ruletypes</z><z id="t1561645995020800" t="mikerod @misha Clara implements a forward-chaining, Rete based, engine. Datalog I believe is backward-chaining and maybe based on something like miniKanren or something? Either way, they aren’t the same. So that’s a correct observation. "><y>#</y><d>2019-06-27</d><h>14:33</h><w>mikerod</w>@misha Clara implements a forward-chaining, Rete based, engine. Datalog I believe is backward-chaining and maybe based on something like miniKanren or something? 
Either way, they aren’t the same. So that’s a correct observation. </z><z id="t1561646022021600" t="mikerod And typically on this path, you’ll have to consider the trade offs of the different styles of engine. "><y>#</y><d>2019-06-27</d><h>14:33</h><w>mikerod</w>And typically on this path, you’ll have to consider the trade offs of the different styles of engine. </z><z id="t1561646073023200" t="mikerod I wasn’t suggesting changing a DSL will change the fundamentals of the underlying engine for you there. It was just if you had EAV style data to represent as facts, and wanted to use them with a forward chaining engine. "><y>#</y><d>2019-06-27</d><h>14:34</h><w>mikerod</w>I wasn’t suggesting changing a DSL will change the fundamentals of the underlying engine for you there. It was just if you had EAV style data to represent as facts, and wanted to use them with a forward chaining engine. </z><z id="t1561646863025100" t="misha does forward-chaining give any speed, or other guarantees/properties, which clara relies on explicitly (comparing to backward-chaining)?"><y>#</y><d>2019-06-27</d><h>14:47</h><w>misha</w>does forward-chaining give any speed, or other guarantees/properties, which clara relies on explicitly (comparing to backward-chaining)?</z><z id="t1561650973028400" t="mikerod @misha I think that’s a more difficult question to answer succinctly. There are some papers out there that do discuss this exact topic (which I think we should work to link to in some Clara reference docs sometime soon). It looks like this paper https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf and (a paper the above references) http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf section on “3.2.1 Data-Driven and Goal-Driven Search” have some guidelines and more overview on the topic. I think there is a lot more out there than this though. The key concept being, • forward-chaining emphasizes the “data-driven” approach - use available facts to see what all possible “end states”/“goals” can be reached • backward-chaining emphasizes the “goal-driven” approach - see if there are available facts to support some desired “end state”/“goal”"><y>#</y><d>2019-06-27</d><h>15:56</h><w>mikerod</w>@misha I think that’s a more difficult question to answer succinctly. There are some papers out there that do discuss this exact topic (which I think we should work to link to in some Clara reference docs sometime soon).
It looks like this paper <a href="https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf" target="_blank">https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf</a>
and (a paper the above references) <a href="http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf" target="_blank">http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf</a> section on “3.2.1 Data-Driven and Goal-Driven Search” have some guidelines and more overview on the topic.
I think there is a lot more out there than this though.

The key concept being,
• forward-chaining emphasizes the “data-driven” approach - use available facts to see what all possible “end states”/“goals” can be reached
• backward-chaining emphasizes the “goal-driven” approach - see if there are available facts to support some desired “end state”/“goal”</z><z id="t1561651048029800" t="mikerod Since they emphasize a different desired solution finding paradigm, they tend to optimize better for that purpose"><y>#</y><d>2019-06-27</d><h>15:57</h><w>mikerod</w>Since they emphasize a different desired solution finding paradigm, they tend to optimize better for that purpose</z><z id="t1561651104030900" t="mikerod Meaning, * forward-chaining is likely more performant, and also more natural, when you want the “data-driven” approach. * backward-chaining is more performant, and also more natural, when you want the “goal-driven” approach."><y>#</y><d>2019-06-27</d><h>15:58</h><w>mikerod</w>Meaning,
* forward-chaining is likely more performant, and also more natural, when you want the “data-driven” approach.
* backward-chaining is more performant, and also more natural, when you want the “goal-driven” approach.</z><z id="t1561651253033600" t="mikerod There are engines that do a blend of each at times too. Clara doesn’t currently. An example of how where this could apply, is that a Clara style query (typically defined via defquery ) could be utilized in a way where you perhaps could say (query session :?x 5) and the engine could potentially use a backward-chaining approach to arrive at that goal. Perhaps to reduce the search space/work done. Nothing like this exists right now. I think that in the later version of Drools (popular, Java-centric (currently)) Rete-style, forward-chaining rules engine, there was actually limited support of a somewhat backward-chaining approach to deriving query results."><y>#</y><d>2019-06-27</d><h>16:00</h><w>mikerod</w>There are engines that do a blend of each at times too. Clara doesn’t currently. An example of how where this could apply, is that a Clara style query (typically defined via <code>defquery</code>) could be utilized in a way where you perhaps could say <code>(query session :?x 5)</code> and the engine could potentially use a backward-chaining approach to arrive at that goal. Perhaps to reduce the search space/work done. Nothing like this exists right now. I think that in the later version of Drools (popular, Java-centric (currently)) Rete-style, forward-chaining rules engine, there was actually limited support of a somewhat backward-chaining approach to deriving query results.</z><z id="t1561651295034300" t="mikerod however, if your main target is “goal-drive”, it’d likely still be best to use something centered around a full backward-chaining engine."><y>#</y><d>2019-06-27</d><h>16:01</h><w>mikerod</w>however, if your main target is “goal-drive”, it’d likely still be best to use something centered around a full backward-chaining engine.</z><z id="t1561708053034900" t="misha first paper link is $$$, thank you, Mike"><y>#</y><d>2019-06-28</d><h>07:47</h><w>misha</w>first paper link is $$$, thank you, Mike</z><z id="t1561708441037600" t="misha (2nd link is probably golden too, but, man, 800pages kappa )"><y>#</y><d>2019-06-28</d><h>07:54</h><w>misha</w>(2nd link is probably golden too, but, man, 800pages <b>kappa</b>)</z><z id="t1561713829046000" t="wparker Another point to consider is that since forward-chaining computes results upfront, applying diffs e.g. new facts can be quite fast once an initial &quot;batch&quot; has been completed."><y>#</y><d>2019-06-28</d><h>09:23</h><w>wparker</w>Another point to consider is that since forward-chaining computes results upfront, applying diffs e.g. new facts can be quite fast once an initial &quot;batch&quot; has been completed.</z><z id="t1561715419047500" t="misha I wonder if datomic&apos;s datalog is still implemented with backward chaining, given team recommends to put the most specific query clause first"><y>#</y><d>2019-06-28</d><h>09:50</h><w>misha</w>I wonder if datomic&apos;s datalog is still implemented with backward chaining, given team recommends to put the most specific query clause first</z><z id="t1561715577047900" t="misha https://docs.datomic.com/on-prem/best-practices.html#most-selective-clauses-first"><y>#</y><d>2019-06-28</d><h>09:52</h><w>misha</w><a href="https://docs.datomic.com/on-prem/best-practices.html#most-selective-clauses-first" target="_blank">https://docs.datomic.com/on-prem/best-practices.html#most-selective-clauses-first</a></z><z id="t1561716594055300" t="misha so what I am actually trying to achieve/figure out, – is how to sneak rule-based parasite system onto datomic/datascript, without any changes to user api, e.g.: there are d/q, d/transact, d/transact!, and I&apos;d like the defrule to be just a composition of those from user point of view (with some cleverness under the hood, like extra working memory or knowledge base). For example, clara-eav seems to have lots of internals leaking out into user api, making it less and less looking like datomic/datascript, which people already are used to &quot;dev-flow&quot;-wise. One seemingly minor, but I think very important from usability/adoption point ov view – is it is still dsl with custom tokens, which will be highlighted all over the ns as undefined in Cursive and probably some other IDE, on top of being yet another DSL you need to remember semantics of."><y>#</y><d>2019-06-28</d><h>10:09</h><w>misha</w>so what I am actually trying to achieve/figure out, – is how to sneak rule-based parasite system onto datomic/datascript, without any changes to user api, e.g.: there are d/q, d/transact, d/transact!, and I&apos;d like the <code>defrule</code> to be just a composition of those from user point of view (with some cleverness under the hood, like extra working memory or knowledge base).
For example, clara-eav seems to have lots of internals leaking out into user api, making it less and less looking like datomic/datascript, which people already are used to &quot;dev-flow&quot;-wise.
One seemingly minor, but I think very important from usability/adoption point ov view – is it is still dsl with custom tokens, which will be highlighted all over the ns as undefined in Cursive and probably some other IDE, on top of being yet another DSL you need to remember semantics of.</z><z id="t1561716673055900" t="misha re dsl, from https://github.com/clyfe/clara-eav#fact-dsl ;; Clara fact syntax [?eav &lt;- :todo/text (= (:e this) :new)] [?eav &lt;- (a/all) :from [:eav/all (= (:e this) :new)]] ;; ClaraEAV fact syntax [?eav &lt;- [:new :todo/text]] [?eav &lt;- (a/all) :from [[:new]]] "><y>#</y><d>2019-06-28</d><h>10:11</h><w>misha</w>re dsl, from <a href="https://github.com/clyfe/clara-eav#fact-dsl" target="_blank">https://github.com/clyfe/clara-eav#fact-dsl</a>
<pre>;; Clara fact syntax
[?eav &lt;- :todo/text (= (:e this) :new)]
[?eav &lt;- (a/all) :from [:eav/all (= (:e this) :new)]]

;; ClaraEAV fact syntax
[?eav &lt;- [:new :todo/text]]
[?eav &lt;- (a/all) :from [[:new]]]
</pre></z><z id="t1561716926057800" t="misha why this, if everyone is familiar with let -style bindings, and many libraries manage to represent domain-specific bindings with their custom let forms, eg: let for monads: https://github.com/funcool/cats/blob/master/src/cats/core.cljc#L233-L255 let for generators: https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1590-L1630"><y>#</y><d>2019-06-28</d><h>10:15</h><w>misha</w>why this, if everyone is familiar with <code>let</code>-style bindings, and many libraries manage to represent domain-specific bindings with their custom let forms, eg:
let for monads: <a href="https://github.com/funcool/cats/blob/master/src/cats/core.cljc#L233-L255" target="_blank">https://github.com/funcool/cats/blob/master/src/cats/core.cljc#L233-L255</a>
let for generators: <a href="https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1590-L1630" target="_blank">https://github.com/clojure/test.check/blob/master/src/main/clojure/clojure/test/check/generators.cljc#L1590-L1630</a></z><z id="t1561997584059000" t="mikerod https://clojurians.slack.com/archives/C08TC9JCS/p1561715419047500 I don’t know the specifics here at all. But probably could still be backwards chaining and have something like this apply. "><y>#</y><d>2019-07-01</d><h>16:13</h><w>mikerod</w><a href="https://clojurians.slack.com/archives/C08TC9JCS/p1561715419047500" target="_blank">https://clojurians.slack.com/archives/C08TC9JCS/p1561715419047500</a>

I don’t know the specifics here at all. But probably could still be backwards chaining and have something like this apply. </z><z id="t1561997773062300" t="mikerod https://clojurians.slack.com/archives/C08TC9JCS/p1561716926057800 The syntax can be altered if you want an alternative dsl. The rules have a well defined data model. It’s not “just let” syntax since that would be awkward to make semantically work for more complex rules. Rules are about unification bindings etc. datalog isn’t let-binding syntax either. Also Clara is aligning its default DSL syntax closer to the world of forward chaining rules engines that have existed for a long time. "><y>#</y><d>2019-07-01</d><h>16:16</h><w>mikerod</w><a href="https://clojurians.slack.com/archives/C08TC9JCS/p1561716926057800" target="_blank">https://clojurians.slack.com/archives/C08TC9JCS/p1561716926057800</a>

The syntax can be altered if you want an alternative dsl. The rules have a well defined data model. 

It’s not “just let” syntax since that would be awkward to make semantically work for more complex rules. Rules are about unification bindings etc. datalog isn’t let-binding syntax either. 

Also Clara is aligning its default DSL syntax closer to the world of forward chaining rules engines that have existed for a long time. </z><z id="t1561997834064100" t="mikerod But your problem seems interesting @misha I don’t have necessarily any easy answers there. First I would make sure the rules can express your problems that you try to solve. Then maybe worry more about blending it with a datalog syntax if that’s you’re goal. "><y>#</y><d>2019-07-01</d><h>16:17</h><w>mikerod</w>But your problem seems interesting @misha I don’t have necessarily any easy answers there. First I would make sure the rules can express your problems that you try to solve. Then maybe worry more about blending it with a datalog syntax if that’s you’re goal. </z><z id="t1563058111068900" t="drewverlee so rules engines model if then relationships and in the &quot;then&quot; part its easy to insert new facts or take abitrary actions on those facts. What i&apos;m not clear about, is how this model relates/overlaps with building a hierarchy of data, or if its orthogonal. Like, a common rules example is that my fathers brother is my uncle. But what about answering questions like, what are the names of all my friends, something that would be easy with datomic pull."><y>#</y><d>2019-07-13</d><h>22:48</h><w>drewverlee</w>so rules engines model if then relationships and in the &quot;then&quot; part its easy to insert new facts or take abitrary actions on those facts. What i&apos;m not clear about, is how this model relates/overlaps with building a hierarchy of data, or if its orthogonal. Like, a common rules example is that my fathers brother is my uncle. But what about answering questions like, what are the names of all my friends, something that would be easy with datomic pull.</z><z id="t1563117917070800" t="mikerod @drewverlee similar to recent posts in this channel, I think you may be running up against the pros/cons of forward chaining rules (clara) and backwards chaining “paradigm” in terms of what is best for what sort of situation. "><y>#</y><d>2019-07-14</d><h>15:25</h><w>mikerod</w>@drewverlee similar to recent posts in this channel, I think you may be running up against the pros/cons of forward chaining rules (clara) and backwards chaining “paradigm” in terms of what is best for what sort of situation. </z><z id="t1563117931071300" t="mikerod You could model that question as an explicit query in clara though. "><y>#</y><d>2019-07-14</d><h>15:25</h><w>mikerod</w>You could model that question as an explicit query in clara though. </z><z id="t1563117962072100" t="mikerod The query could be parameterized to some extent as well to give some flexibility. "><y>#</y><d>2019-07-14</d><h>15:26</h><w>mikerod</w>The query could be parameterized to some extent as well to give some flexibility. </z><z id="t1563117988072300" t="mikerod https://clojurians.slack.com/archives/C08TC9JCS/p1561651104030900"><y>#</y><d>2019-07-14</d><h>15:26</h><w>mikerod</w><a href="https://clojurians.slack.com/archives/C08TC9JCS/p1561651104030900" target="_blank">https://clojurians.slack.com/archives/C08TC9JCS/p1561651104030900</a></z><z id="t1563127364073700" t="drewverlee Thanks @mikerod, are their any resources that you recommend that compare these two different approaches? Or talk about using them together? Specifically i&apos;m thinking of using clara or precept with datomic."><y>#</y><d>2019-07-14</d><h>18:02</h><w>drewverlee</w>Thanks @mikerod, are their any resources that you recommend that compare these two different approaches? Or talk about using them together? Specifically i&apos;m thinking of using clara or precept with datomic.</z><z id="t1563164370074700" t="mikerod @drewverlee from above post I had a few https://clojurians.slack.com/archives/C08TC9JCS/p1561650973028400 that were overviews "><y>#</y><d>2019-07-15</d><h>04:19</h><w>mikerod</w>@drewverlee from above post I had a few <a href="https://clojurians.slack.com/archives/C08TC9JCS/p1561650973028400" target="_blank">https://clojurians.slack.com/archives/C08TC9JCS/p1561650973028400</a> that were overviews </z><z id="t1563191660075200" t="drewverlee Thanks again, I really appreciate it."><y>#</y><d>2019-07-15</d><h>11:54</h><w>drewverlee</w>Thanks again, I really appreciate it.</z><z id="t1564063940000800" t="drewverlee Can anyone highlight the key differences between Naga and Clara?"><y>#</y><d>2019-07-25</d><h>14:12</h><w>drewverlee</w>Can anyone highlight the key differences between Naga and Clara?</z><z id="t1564064103001600" t="drewverlee Is Naga more focused on interfacing with a database?"><y>#</y><d>2019-07-25</d><h>14:15</h><w>drewverlee</w>Is Naga more focused on interfacing with a database?</z><z id="t1564066739002000" t="mikerod @drewverlee yes, it was built on top of datomic I believe"><y>#</y><d>2019-07-25</d><h>14:58</h><w>mikerod</w>@drewverlee yes, it was built on top of datomic I believe</z><z id="t1564066752002400" t="mikerod so there is a db-specific integration point"><y>#</y><d>2019-07-25</d><h>14:59</h><w>mikerod</w>so there is a db-specific integration point</z><z id="t1564066765002800" t="mikerod but I’m no expert there - could be proven wrong."><y>#</y><d>2019-07-25</d><h>14:59</h><w>mikerod</w>but I’m no expert there - could be proven wrong.</z><z id="t1564066948005700" t="drewverlee Thanks Mike"><y>#</y><d>2019-07-25</d><h>15:02</h><w>drewverlee</w>Thanks Mike</z><z id="t1564930415008600" t="hadils Hi! I am new to Clara. I am very excited to be using it, but I am having difficulty with debugging a rule: (defrule processed-transactions-rule [?account &lt;- Account (= type :bank)] [TransactionSettings (= ?db db)] =&gt; (insert-all! (get-processed-txs ?db ?account))) The error I get is: CompilerException clojure.lang.ExceptionInfo: Failed compiling alpha node {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [this ?__fact__ ?__bindings__ (clojure.core/atom {})] (clojure.core/let [?db stackz.laws/db] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?db ?db) (clojure.core/deref ?__bindings__)))), :condition {:type stackz.laws.TransactionSettings, :constraints [(= ?db stackz.laws/db)]}, :env nil} {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [this ?__fact__ ?__bindings__ (clojure.core/atom {})] (clojure.core/let [?db stackz.laws/db] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?db ?db) (clojure.core/deref ?__bindings__)))), :condition {:type stackz.laws.TransactionSettings, :constraints [(= ?db stackz.laws/db)]}, :env nil}, compiling:(form-init5589377441026521223.clj:1:8) Can anyone point me in the right direction? Thanks!"><y>#</y><d>2019-08-04</d><h>14:53</h><w>hadils</w>Hi! I am new to Clara. I am very excited to be using it, but I am having difficulty with debugging a rule:
<pre>(defrule processed-transactions-rule
  [?account &lt;- Account (= type :bank)]
  [TransactionSettings (= ?db db)]
  =&gt;
  (insert-all! (get-processed-txs ?db ?account)))</pre>
The error I get is:
<pre>CompilerException clojure.lang.ExceptionInfo: Failed compiling alpha node
{:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [this ?__fact__ ?__bindings__ (clojure.core/atom {})] (clojure.core/let [?db stackz.laws/db] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?db ?db) (clojure.core/deref ?__bindings__)))), :condition {:type stackz.laws.TransactionSettings, :constraints [(= ?db stackz.laws/db)]}, :env nil}
 {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [this ?__fact__ ?__bindings__ (clojure.core/atom {})] (clojure.core/let [?db stackz.laws/db] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?db ?db) (clojure.core/deref ?__bindings__)))), :condition {:type stackz.laws.TransactionSettings, :constraints [(= ?db stackz.laws/db)]}, :env nil}, compiling:(form-init5589377441026521223.clj:1:8) 
</pre>
Can anyone point me in the right direction? Thanks!</z><z id="t1564942131009700" t="mikerod @hadilsabbagh18 is there any more stack trace to be seen? Perhaps *e in REPL after you see this or something?"><y>#</y><d>2019-08-04</d><h>18:08</h><w>mikerod</w>@hadilsabbagh18 is there any more stack trace to be seen? Perhaps <code>*e</code> in REPL after you see this or something?</z><z id="t1564942219011100" t="mikerod Oh. How is db defined? Is it a field on either a record/type/class named TransactionSettings ?"><y>#</y><d>2019-08-04</d><h>18:10</h><w>mikerod</w>Oh. How is <code>db</code> defined? Is it a field on either a record/type/class named <code>TransactionSettings</code>?</z><z id="t1564942331013500" t="mikerod Based on the form trying to be compiled there it looks like Clara cannot resolve what db is for that class so it is assuming it’s just a symbol resolving to something in the namespace stacks.laws.db/db "><y>#</y><d>2019-08-04</d><h>18:12</h><w>mikerod</w>Based on the form trying to be compiled there it looks like Clara cannot resolve what <code>db</code> is for that class so it is assuming it’s just a  symbol resolving to something in the namespace <code>stacks.laws.db/db</code> </z><z id="t1565186665015100" t="hadils Thanks @mikerod ! I am creating an empty session at this point. That seems to resolve these errors. "><y>#</y><d>2019-08-07</d><h>14:04</h><w>hadils</w>Thanks @mikerod !  I am creating an empty session at this point. That seems to resolve these errors. </z><z id="t1565187844015700" t="mikerod Hmm. Interesting. Well feel free to ask if you have more questions. "><y>#</y><d>2019-08-07</d><h>14:24</h><w>mikerod</w>Hmm. Interesting. Well feel free to ask if you have more questions. </z><z id="t1565209781017100" t="sparkofreason If the only thing that changes in the LHS of a rule is an accumulator value, is it correct that the rule won&apos;t fire if the collection of facts matching the accumulator condition change?"><y>#</y><d>2019-08-07</d><h>20:29</h><w>sparkofreason</w>If the only thing that changes in the LHS of a rule is an accumulator value, is it correct that the rule won&apos;t fire if the collection of facts matching the accumulator condition change?</z><z id="t1565210152019000" t="ethanc I would think that if an accumulator saw a new value, and the previously accumulated objects changed that there would be work that the rhs would have to do. Though I might be misunderstanding your question"><y>#</y><d>2019-08-07</d><h>20:35</h><w>ethanc</w>I would think that if an accumulator saw a new value, and the previously accumulated objects changed that there would be work that the rhs would have to do. Though I might be misunderstanding your question</z><z id="t1565210214019700" t="sparkofreason That&apos;s how I want it to behave, but I have a distant recollection that it doesn&apos;t actually work that way. Been awhile since I&apos;ve played with clara."><y>#</y><d>2019-08-07</d><h>20:36</h><w>sparkofreason</w>That&apos;s how I want it to behave, but I have a distant recollection that it doesn&apos;t actually work that way. Been awhile since I&apos;ve played with clara.</z><z id="t1565210549022200" t="ProbablyJody @dave.dixon, are you thinking of the retract-fn’s behavior?"><y>#</y><d>2019-08-07</d><h>20:42</h><w>ProbablyJody</w>@dave.dixon, are you thinking of the retract-fn’s behavior?</z><z id="t1565210567022400" t="sparkofreason Could be. Possible I&apos;m just writing my accumulation clause wrong or something, because sometimes it does seem to behave as you described."><y>#</y><d>2019-08-07</d><h>20:42</h><w>sparkofreason</w>Could be. Possible I&apos;m just writing my accumulation clause wrong or something, because sometimes it does seem to behave as you described.</z><z id="t1565211180023400" t="ProbablyJody Ah, I think this might help: https://github.com/cerner/clara-rules/blob/ce65c5071a271905786449db1190687ee40e4624/src/test/common/clara/test_accumulation.cljc#L1121"><y>#</y><d>2019-08-07</d><h>20:53</h><w>ProbablyJody</w>Ah, I think this might help: <a href="https://github.com/cerner/clara-rules/blob/ce65c5071a271905786449db1190687ee40e4624/src/test/common/clara/test_accumulation.cljc#L1121" target="_blank">https://github.com/cerner/clara-rules/blob/ce65c5071a271905786449db1190687ee40e4624/src/test/common/clara/test_accumulation.cljc#L1121</a></z><z id="t1565212977025200" t="mikerod @dave.dixon in current version of Clara (and several before) the rule will not continue to propagate if the accumulated value hasn’t changed according to = See lines like https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1200"><y>#</y><d>2019-08-07</d><h>21:22</h><w>mikerod</w>@dave.dixon in current version of Clara (and several before) the rule will not continue to propagate if the accumulated value hasn’t changed according to <code>=</code> 
See lines like <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1200" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1200</a></z><z id="t1565213074027700" t="mikerod So specifically if the accumulators result from the :convert-return-fn is = to what it was in the previous round of accumulating fact matches, propagation stops - which would imply no RHS action being triggered/activated"><y>#</y><d>2019-08-07</d><h>21:24</h><w>mikerod</w>So specifically if the accumulators result from the <code>:convert-return-fn</code> is <code>=</code> to what it was in the previous round of accumulating fact matches, propagation stops - which would imply no RHS action being triggered/activated</z><z id="t1565213158028600" t="mikerod The tests near what Jody pointed too could be enlightening on some more semantics though. I agree"><y>#</y><d>2019-08-07</d><h>21:25</h><w>mikerod</w>The tests near what Jody pointed too could be enlightening on some more semantics though. I agree</z><z id="t1565213181029400" t="mikerod There are quite detailed github issues out there that also discuss these semantics when we added the related changes. "><y>#</y><d>2019-08-07</d><h>21:26</h><w>mikerod</w>There are quite detailed github issues out there that also discuss these semantics when we added the related changes. </z><z id="t1565214500030700" t="sparkofreason @mikerod Thanks. Not exactly sure what I was thinking of. My actual problem was that I was hacking at something trying to make it update in place rather than letting truth maintenance do the lifting. Need to get back to &quot;thinking TMS&quot; 😉"><y>#</y><d>2019-08-07</d><h>21:48</h><w>sparkofreason</w>@mikerod Thanks. Not exactly sure what I was thinking of. My actual problem was that I was hacking at something trying to make it update in place rather than letting truth maintenance do the lifting. Need to get back to &quot;thinking TMS&quot; <b>😉</b></z><z id="t1565214726031200" t="mikerod Yes. No mutate in place. That’ll indeed cause issues. "><y>#</y><d>2019-08-07</d><h>21:52</h><w>mikerod</w>Yes. No mutate in place. That’ll indeed cause issues. </z><z id="t1565223990033700" t="sparkofreason Think I hit another issue trying to update in place. I thought I could get away with it for unconditional facts, but it appears that when I have multiple LHS bindings on a rule that does a retract! followed by an insert-unconditional! , the RHS fires for all bindings, so the retracts all occur before other rules fire that would potentially invalidate the LHS on the first rule after a subset of firings, based on those retractions."><y>#</y><d>2019-08-08</d><h>00:26</h><w>sparkofreason</w>Think I hit another issue trying to update in place. I thought I could get away with it for unconditional facts, but it appears that when I have multiple LHS bindings on a rule that does a <code>retract!</code> followed by an <code>insert-unconditional!</code>, the RHS fires for all bindings, so the retracts all occur before other rules fire that would potentially invalidate the LHS on the first rule after a subset of firings, based on those retractions.</z><z id="t1565229031035100" t="mikerod @dave.dixon if you get into the business of doing unconditional things, you’ll have to control rule order more. This can be done with salience and possibly “blocker” fact patterns. "><y>#</y><d>2019-08-08</d><h>01:50</h><w>mikerod</w>@dave.dixon if you get into the business of doing unconditional things, you’ll have to control rule order more. This can be done with salience and possibly “blocker” fact patterns. </z><z id="t1565277583039900" t="sparkofreason It seems like avoiding this sort of thing can be a guiding principle for data modeling. For example, the existence of an entity might be unconditional, but the facts describing that entity may have more detailed logical relationships. Trying to group those facts as attributes under a single entity fact map or record leads to the headaches I&apos;m encountering. But maybe if I separate them so that they can be separately inserted/retracted, things will be cleaner. Giving clara-eav a try for this purpose."><y>#</y><d>2019-08-08</d><h>15:19</h><w>sparkofreason</w>It seems like avoiding this sort of thing can be a guiding principle for data modeling. For example, the existence of an entity might be unconditional, but the facts describing that entity may have more detailed logical relationships. Trying to group those facts as attributes under a single entity fact map or record leads to the headaches I&apos;m encountering. But maybe if I separate them so that they can be separately inserted/retracted, things will be cleaner. Giving clara-eav a try for this purpose.</z><z id="t1566997827001600" t="grierson Should I run side effectful things (database/email) in the RHS of a rule. Or should I insert a new fact, query the session, and do side effectfs based on the query result?"><y>#</y><d>2019-08-28</d><h>13:10</h><w>grierson</w>Should I run side effectful things (database/email) in the RHS of a rule. Or should I insert a new fact, query the session, and do side effectfs based on the query result?</z><z id="t1566999928004600" t="ethanc The latter is recommended, Clara makes no promises on the number of times that the RHS will be executed before reaching steady state."><y>#</y><d>2019-08-28</d><h>13:45</h><w>ethanc</w>The latter is recommended, Clara makes no promises on the number of times that the RHS will be executed before reaching steady state.</z><z id="t1567000648005700" t="grierson Thank you @ethanc, I thought that might be the case but just wanted to clara-fy :rolling_on_the_floor_laughing: ."><y>#</y><d>2019-08-28</d><h>13:57</h><w>grierson</w>Thank you @ethanc, I thought that might be the case but just wanted to clara-fy <b>:rolling_on_the_floor_laughing:</b>.</z><z id="t1568124740009400" t="mbragg Hi. Im having a play around with Clara and seeing if it’ll fit our use case. One of which is to know which Rule(s) failed. I can see the inspect function gives loads of nice info for all the activations; what could I do if i wanted to know which Rules were not triggered and why?"><y>#</y><d>2019-09-10</d><h>14:12</h><w>mbragg</w>Hi. Im having a play around with Clara and seeing if it’ll fit our use case. One of which is to know which Rule(s) failed. I can see the inspect function gives loads of nice info for all the activations; what could I do if i wanted to know which Rules were not triggered and why?</z><z id="t1568125138009800" t="mikerod @mbragg I think that will be a bit of a challenge with a forward-chaining approach to rules"><y>#</y><d>2019-09-10</d><h>14:18</h><w>mikerod</w>@mbragg I think that will be a bit of a challenge with a forward-chaining approach to rules</z><z id="t1568125151010100" t="mikerod if you have more specific questions - you can model that as rules and queries"><y>#</y><d>2019-09-10</d><h>14:19</h><w>mikerod</w>if you have more specific questions - you can model that as rules and queries</z><z id="t1568125177010900" t="mikerod but just to find out something like “what was missing that you would have needed to reach certain goals/conclusions” is more of a backwards chaining strength (ie goal-driven) I’d say"><y>#</y><d>2019-09-10</d><h>14:19</h><w>mikerod</w>but just to find out something like “what was missing that you would have needed to reach certain goals/conclusions” is more of a backwards chaining strength (ie goal-driven) I’d say</z><z id="t1568125196011300" t="mikerod • clara is based around the rete algo which is a forward-chaining (ie data-driven) approach Good references for further reading: 1) https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf 2) http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf (section 8.2 Rule-Based Expert Systems)"><y>#</y><d>2019-09-10</d><h>14:19</h><w>mikerod</w>• clara is based around the rete algo which is a forward-chaining (ie data-driven) approach

Good references for further reading:
1) <a href="https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf" target="_blank">https://pdfs.semanticscholar.org/54af/b81b814acea73450430b4dabd0fc5c13732a.pdf</a>
2) <a href="http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf" target="_blank">http://iips.icci.edu.iq/images/exam/artificial-intelligence-structures-and-strategies-for--complex-problem-solving.pdf</a> (section 8.2 Rule-Based Expert Systems)</z><z id="t1568125236012100" t="mikerod you can make some progress of course with inspection - you can see what did happen, and subtract that from all the rules you know exists to find which were left out"><y>#</y><d>2019-09-10</d><h>14:20</h><w>mikerod</w>you can make some progress of course with inspection - you can see what did happen, and subtract that from all the rules you know exists to find which were left out</z><z id="t1568125265012600" t="mikerod you can also make more rules in some cases, perhaps even systematically (and programmatically) that try to capture the “negative” cases"><y>#</y><d>2019-09-10</d><h>14:21</h><w>mikerod</w>you can also make more rules in some cases, perhaps even systematically (and programmatically) that try to capture the “negative” cases</z><z id="t1568125301013300" t="mikerod eg. if I have a rule rule a =&gt; insert b , then also make a rule rule not(a) =&gt; insert z"><y>#</y><d>2019-09-10</d><h>14:21</h><w>mikerod</w>eg. if I have a rule <code>rule a =&gt; insert b</code>, then also make a rule <code>rule not(a) =&gt; insert z</code></z><z id="t1568125341014000" t="mikerod of course it can be more difficult than that with mult-condition joins, negation, and accumulators involved"><y>#</y><d>2019-09-10</d><h>14:22</h><w>mikerod</w>of course it can be more difficult than that with mult-condition joins, negation, and accumulators involved</z><z id="t1568126025017900" t="mbragg Many thanks @mikerod That all makes sense. diffing the activated vs non-activated rules &amp; using inspection does feel a little hacky, It seems like I should either re-think the problem and model it in a forward-chaining manner, or maybe not use clara and implement some sort of backward-chaining model. Thanks again!"><y>#</y><d>2019-09-10</d><h>14:33</h><w>mbragg</w>Many thanks @mikerod That all makes sense. diffing the activated vs non-activated rules &amp; using inspection does feel a little hacky, It seems like I should either re-think the problem and model it in a forward-chaining manner, or maybe not use clara and implement some sort of backward-chaining model. Thanks again!</z><z id="t1568140427019700" t="devn @mbragg at my previous gig, we found that doing what @mikerod mentioned was sufficient for our observability purposes. (Namely, we generated negative cases for certain types of rules, and created targeted queries to aid in observability.)"><y>#</y><d>2019-09-10</d><h>18:33</h><w>devn</w>@mbragg at my previous gig, we found that doing what @mikerod mentioned was sufficient for our observability purposes. (Namely, we generated negative cases for certain types of rules, and created targeted queries to aid in observability.)</z><z id="t1568140970021100" t="mbragg Thanks @devn yeah I’m having a think about that too"><y>#</y><d>2019-09-10</d><h>18:42</h><w>mbragg</w>Thanks @devn yeah I’m having a think about that too</z><z id="t1570220340002000" t="jjttjj Is the support for map types documented anywhere? I found this: https://github.com/cerner/clara-rules/issues/6 but it seems to use some outdated parts of the api (`mk-query` etc)"><y>#</y><d>2019-10-04</d><h>20:19</h><w>jjttjj</w>Is the support for map types documented anywhere? I found this: <a href="https://github.com/cerner/clara-rules/issues/6" target="_blank">https://github.com/cerner/clara-rules/issues/6</a> but it seems to use some outdated parts of the api (`mk-query` etc)</z><z id="t1570220651002300" t="hiredman https://github.com/cerner/clara-rules/wiki/Guide#fact-types"><y>#</y><d>2019-10-04</d><h>20:24</h><w>hiredman</w><a href="https://github.com/cerner/clara-rules/wiki/Guide#fact-types" target="_blank">https://github.com/cerner/clara-rules/wiki/Guide#fact-types</a></z><z id="t1570220726002500" t="jjttjj there it is, thanks!"><y>#</y><d>2019-10-04</d><h>20:25</h><w>jjttjj</w>there it is, thanks!</z><z id="t1570223407003000" t="mikerod @jjttjj you’ll see it used fairly often in test cases within clara as well, such as https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1129"><y>#</y><d>2019-10-04</d><h>21:10</h><w>mikerod</w>@jjttjj you’ll see it used fairly often in test cases within clara as well, such as <a href="https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1129" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_rules.clj#L1129</a></z><z id="t1570227460005300" t="Eduardo Mata How can I apply rules to my Records and modified them if needed then return all the Records that either change or did not change to the caller?"><y>#</y><d>2019-10-04</d><h>22:17</h><w>Eduardo Mata</w>How can I apply rules to my Records and modified them if needed then return all the Records that either change or did not change to the caller?</z><z id="t1570227468005600" t="Eduardo Mata I am using an atom but maybe that is wrong?"><y>#</y><d>2019-10-04</d><h>22:17</h><w>Eduardo Mata</w>I am using an atom but maybe that is wrong?</z><z id="t1570233864006500" t="mikerod @contact904 Ideally, you’d make a new type of fact for the “modified” record and/or “processed record” and just query for those types"><y>#</y><d>2019-10-05</d><h>00:04</h><w>mikerod</w>@contact904 Ideally, you’d make a new type of fact for the “modified” record and/or “processed record” and just query for those types</z><z id="t1570233878006900" t="mikerod they can still hold the original, real modified record, so you could still access it"><y>#</y><d>2019-10-05</d><h>00:04</h><w>mikerod</w>they can still hold the original, real modified record, so you could still access it</z><z id="t1570375905011700" t="jjttjj Are clara sessions intended as throwaway cheap things meant to replace an elaborate cond ? I have a long running process that receives events every few seconds, and needs to make decisions based mainly on that new data point, and to a lesser extent some previous, accumulating state, but not previous events in the stream. Which one is the default approach with clara: a new session for each new data point, adding in the needed extra state with insert ? Or should I be building up one session over time and retracting the old/unused data points"><y>#</y><d>2019-10-06</d><h>15:31</h><w>jjttjj</w>Are clara sessions intended as throwaway cheap things meant to replace an elaborate <code>cond</code>?  I have a long running process that receives events every few seconds, and needs to make decisions based mainly on that new data point, and to a lesser extent some previous, accumulating state, but not previous events in the stream. Which one is the default approach with clara: a new session for each new data point, adding in the needed extra state with <code>insert</code>? Or should I be building up one session over time and retracting the old/unused data points</z><z id="t1570376646013700" t="jjttjj Put slightly differently, the &quot;sensors&quot; example in the clara-examples repo seems similar to what i&apos;m trying to do, but I&apos;m not quite sure how the main function would translate to the &quot;real world&quot;: https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L87 Should the same session persist throughout the long-running process that provides the sensor data? Or is the run-examples function similar to something that would be called frequently in response to new data?"><y>#</y><d>2019-10-06</d><h>15:44</h><w>jjttjj</w>Put slightly differently, the &quot;sensors&quot; example in the clara-examples repo seems similar to what i&apos;m trying to do, but I&apos;m not quite sure how the main function would translate to the &quot;real world&quot;: <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L87" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj#L87</a> Should the same session persist throughout the long-running process that provides the sensor data? Or is the <code>run-examples</code> function similar to something that would be called frequently in response to new data?</z><z id="t1570379992014500" t="mikerod @jjttjj you could certainly create one “base session” and hold a reference to it"><y>#</y><d>2019-10-06</d><h>16:39</h><w>mikerod</w>@jjttjj you could certainly create one “base session” and hold a reference to it</z><z id="t1570380012015200" t="mikerod Then do insert+fire on independent “branches” from there. In isolation"><y>#</y><d>2019-10-06</d><h>16:40</h><w>mikerod</w>Then do insert+fire on independent “branches” from there. In isolation</z><z id="t1570380046016300" t="mikerod If old state doesn’t need to influence “new” you don’t need to try retracting the last cycle of facts etc. just start from scratch again from the base session"><y>#</y><d>2019-10-06</d><h>16:40</h><w>mikerod</w>If old state doesn’t need to influence “new” you don’t need to try retracting the last cycle of facts etc. just start from scratch again from the base session</z><z id="t1570380054016600" t="mikerod This will be cheap. "><y>#</y><d>2019-10-06</d><h>16:40</h><w>mikerod</w>This will be cheap. </z><z id="t1570380210016900" t="jjttjj great, thanks!"><y>#</y><d>2019-10-06</d><h>16:43</h><w>jjttjj</w>great, thanks!</z><z id="t1570551890018000" t="Eduardo Mata I have a multi-threaded parallel synchronous processor using Clara rules. How can I make sure that for every Rule session is clear out for the following session?"><y>#</y><d>2019-10-08</d><h>16:24</h><w>Eduardo Mata</w>I have a multi-threaded parallel synchronous processor using Clara rules. How can I make sure that for every Rule session is clear out for the following session?</z><z id="t1570552225020100" t="jjttjj @contact904 I&apos;m still really new to Clara, but sessions are immutable, so you should be able to make a session and then use that as the starting session from any number of parallel threads without worrying. Is the work each thread does independent of all others? Or does there need to be some coordination?"><y>#</y><d>2019-10-08</d><h>16:30</h><w>jjttjj</w>@contact904 I&apos;m still really new to Clara, but sessions are immutable, so you should be able to make a session and then use that as the starting session from any number of parallel threads without worrying. Is the work each thread does independent of all others? Or does there need to be some coordination?</z><z id="t1570552293021100" t="Eduardo Mata The threads are independent of each other, but some of them use the same rules.clj module"><y>#</y><d>2019-10-08</d><h>16:31</h><w>Eduardo Mata</w>The threads are independent of each other, but some of them use the same rules.clj module</z><z id="t1570552360022300" t="jjttjj Ok then yeah that&apos;s perfect, you should be able to bind mk-session somewhere, and then use it from any number of threads and the threads will only see the starting point. (Someone correct me if I&apos;m wrong :)"><y>#</y><d>2019-10-08</d><h>16:32</h><w>jjttjj</w>Ok then yeah that&apos;s perfect, you should be able to bind <code>mk-session</code> somewhere, and then use it from any number of threads and the threads will only see the starting point. (Someone correct me if I&apos;m wrong :)</z><z id="t1570552479024400" t="Eduardo Mata So if I have a set of N threads and the N thread are independent of each other running in parallel. All these N threads are using the same rules.clj module. I should not worry because the threads getting facts from other threads as they are only aware of the session the thread created at the time?"><y>#</y><d>2019-10-08</d><h>16:34</h><w>Eduardo Mata</w>So if I have a set of N threads and the N thread are independent of each other running in parallel. All these N threads are using the same rules.clj module. I should not worry because the threads getting facts from other threads as they are only aware of the session the thread created at the time?</z><z id="t1570552505024700" t="jjttjj Yes, that is my understanding"><y>#</y><d>2019-10-08</d><h>16:35</h><w>jjttjj</w>Yes, that is my understanding</z><z id="t1570552588026100" t="ethanc The rule definitions should be separate from the memory of the sessions that are created."><y>#</y><d>2019-10-08</d><h>16:36</h><w>ethanc</w>The rule definitions should be separate from the memory of the sessions that are created.</z><z id="t1570552622026500" t="jjttjj you can even share a &quot;root&quot; session because they are immutable, in the same way a bunch of threads can operate on the same root vector in clojure and only see their version of it"><y>#</y><d>2019-10-08</d><h>16:37</h><w>jjttjj</w>you can even share a &quot;root&quot; session because they are immutable, in the same way a bunch of threads can operate on the same root vector in clojure and only see their version of it</z><z id="t1570552669027100" t="ethanc jjttjj is correct, assuming that all threads were loading the same rules"><y>#</y><d>2019-10-08</d><h>16:37</h><w>ethanc</w>jjttjj is correct, assuming that all threads were loading the same rules</z><z id="t1570556178033600" t="Eduardo Mata Correct me if I am wrong. So I have multiple rules, I inserted a collection of events into the current session in progress. My main record is called Event. I will insert-all the Records in to the session and fire the rules. A little of back story, I used to have an atom, now I am inserting facts in to a new Record called NewEvents. Back to the current situation, The first rule will create a side effect (modify) on the Record and insert it in to NewEvents. The following rules will be fired with the Record Event, if it fits the rule, I want to look in to the past modified record in NewEvents and apply the changes to the corresponding NewEvent. I tried retract but it didn&apos;t seem to work. If I retract the fact from NewEvent, then apply changes, I insert it back but then it is not there anymore 😞 . Using insert-unconditional! just makes it eat my available heap space"><y>#</y><d>2019-10-08</d><h>17:36</h><w>Eduardo Mata</w>Correct me if I am wrong.
So I have multiple rules, I inserted a collection of events into the current session in progress. My main record is called Event. I will insert-all the Records in to the session and fire the rules. A little of back story, I used to have an atom, now I am inserting facts in to a new Record called NewEvents.
Back to the current situation,  The first rule will create a side effect (modify) on the Record and insert it in to NewEvents. The following rules will be fired with the Record Event, if it fits the rule, I want to look in to the past modified record in NewEvents and apply the changes to the corresponding NewEvent. I tried retract but it didn&apos;t seem to work.

If I retract the fact from NewEvent, then apply changes, I insert it back but then it is not there anymore <b>😞</b>. Using insert-unconditional! just makes it eat my available heap space</z><z id="t1570559881034900" t="Eduardo Mata basically, the question would be: How do I modify a NewEvent?"><y>#</y><d>2019-10-08</d><h>18:38</h><w>Eduardo Mata</w>basically, the question would be:
How do I modify a NewEvent?</z><z id="t1570637795000700" t="jjttjj @contact904 can you post some example code?"><y>#</y><d>2019-10-09</d><h>16:16</h><w>jjttjj</w>@contact904 can you post some example code?</z><z id="t1570638706000800" t="Eduardo Mata https://github.com/cerner/clara-rules/issues/437"><y>#</y><d>2019-10-09</d><h>16:31</h><r>Eduardo Mata</r><a href="https://github.com/cerner/clara-rules/issues/437" target="_blank">https://github.com/cerner/clara-rules/issues/437</a></z><z id="t1572214028007000" t="wparker Clara 0.20.0 is now released and available on Clojars. This contains a couple bugfixes and a new default optimization to reduce memory usage. Details on the changelog: https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0200"><y>#</y><d>2019-10-27</d><h>22:07</h><w>wparker</w>Clara 0.20.0 is now released and available on Clojars.  This contains a couple bugfixes and a new default optimization to reduce memory usage.  Details on the changelog:  <a href="https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0200" target="_blank">https://github.com/cerner/clara-rules/blob/master/CHANGELOG.md#0200</a></z><z id="t1572385820008500" t="bartuka hi people, I am very glad to have found this library"><y>#</y><d>2019-10-29</d><h>21:50</h><w>bartuka</w>hi people, I am very glad to have found this library</z><z id="t1572385846009100" t="bartuka there is only one thing though that I wish to fix... cider is not identing correctly all my conditions =("><y>#</y><d>2019-10-29</d><h>21:50</h><w>bartuka</w>there is only one thing though that I wish to fix... cider is not identing correctly all my conditions =(</z><z id="t1572385853009400" t="bartuka any suggestions on how to fix it? 🙂"><y>#</y><d>2019-10-29</d><h>21:50</h><w>bartuka</w>any suggestions on how to fix it? <b>🙂</b></z><z id="t1572398504010100" t="noprompt See put-clojure-indent"><y>#</y><d>2019-10-30</d><h>01:21</h><r>noprompt</r>See <code>put-clojure-indent</code></z><z id="t1572744920010900" t="mikerod Yeah it’d probably be cool if someone could share a cider config that helped indent some of the macros from Clara. "><y>#</y><d>2019-11-03</d><h>01:35</h><w>mikerod</w>Yeah it’d probably be cool if someone could share a cider config that helped indent some of the macros from Clara. </z><z id="t1572744949011600" t="mikerod I believe cursive IDE has some work in this area perhaps before if I recall. "><y>#</y><d>2019-11-03</d><h>01:35</h><w>mikerod</w>I believe cursive IDE has some work in this area perhaps before if I recall. </z><z id="t1572759535012300" t="dominicm The clara macros could add metadata to indicate to cider how to indent."><y>#</y><d>2019-11-03</d><h>05:38</h><w>dominicm</w>The clara macros could add metadata to indicate to cider how to indent.</z><z id="t1572943480016300" t="wparker Is this the indentation metadata you’re referring to @dominicm? https://docs.cider.mx/cider/indent_spec.html I’ve generally been satisfied with the default indentation in Cider when writing rules, are there examples of cases where the indentation is strange? My initial instinct if this sort of thing is desired would be to look for/create an extension mechanism for it so various development environments could be supported without everything needing to be in the main codebase (this is orthogonal to whether it would be in the main repo IMO and this could be separately considered)."><y>#</y><d>2019-11-05</d><h>08:44</h><w>wparker</w>Is this the indentation metadata you’re referring to @dominicm? <a href="https://docs.cider.mx/cider/indent_spec.html" target="_blank">https://docs.cider.mx/cider/indent_spec.html</a>  I’ve generally been satisfied with the default indentation in Cider when writing rules, are there examples of cases where the indentation is strange?  My initial instinct if this sort of thing is desired would be to look for/create an extension mechanism for it so various development environments could be supported without everything needing to be in the main codebase (this is orthogonal to whether it would be in the main repo IMO and this could be separately considered).</z><z id="t1572944167017400" t="dominicm Cursive looked at implementing the spec, I&apos;m not sure if it happened though. It hasn&apos;t seen much adoption in other editors."><y>#</y><d>2019-11-05</d><h>08:56</h><w>dominicm</w>Cursive looked at implementing the spec, I&apos;m not sure if it happened though.

It hasn&apos;t seen much adoption in other editors.</z><z id="t1572982483022700" t="sashton I’m trying out Clara right now. Is there a way to get all the current facts from a session? I’ve tried various inspection functions, and come up short. - inspect/explain-activations - fact-graph/session-&gt;fact-graph - inspect/inspect I can get most facts from the above functions. What I am missing is facts inserted directly into the session, which haven’t themselves fired any rules. This would be just for debugging the rules, not for production queries. I don’t want to write a query which includes all Fact types, I’m looking for a simple way to enumerate all current facts in the system. Any ideas?"><y>#</y><d>2019-11-05</d><h>19:34</h><w>sashton</w>I’m trying out Clara right now. Is there a way to get all the current facts from a session? I’ve tried various inspection functions, and come up short.
- <code>inspect/explain-activations</code>
- <code>fact-graph/session-&gt;fact-graph</code>
- <code>inspect/inspect</code>
I can get most facts from the above functions. What I am missing is facts inserted directly into the session, which haven’t themselves fired any rules. This would be just for debugging the rules, not for production queries.
I don’t want to write a query which includes all Fact types, I’m looking for a simple way to enumerate all current facts in the system.
Any ideas?</z><z id="t1572986257023300" t="mikerod @sashton easiest is a query on Object. "><y>#</y><d>2019-11-05</d><h>20:37</h><w>mikerod</w>@sashton easiest is a query on Object. </z><z id="t1572986263023600" t="mikerod It doesn’t necessary perform well though"><y>#</y><d>2019-11-05</d><h>20:37</h><w>mikerod</w>It doesn’t necessary perform well though</z><z id="t1572986277024300" t="mikerod Beyond that, it’s been done with hooking into the listeners Api"><y>#</y><d>2019-11-05</d><h>20:37</h><w>mikerod</w>Beyond that, it’s been done with hooking into the listeners Api</z><z id="t1572986289025100" t="mikerod I don’t think anything out of the box for it. I may be forgetting"><y>#</y><d>2019-11-05</d><h>20:38</h><w>mikerod</w>I don’t think anything out of the box for it. I may be forgetting</z><z id="t1572986306025700" t="sashton &gt; listeners api I was just exploring that path"><y>#</y><d>2019-11-05</d><h>20:38</h><w>sashton</w>&gt; listeners api
I was just exploring that path</z><z id="t1572986324026300" t="mikerod If you watch the alpha node activations. "><y>#</y><d>2019-11-05</d><h>20:38</h><w>mikerod</w>If you watch the alpha node activations. </z><z id="t1572986328026500" t="mikerod And retractions. "><y>#</y><d>2019-11-05</d><h>20:38</h><w>mikerod</w>And retractions. </z><z id="t1572986353027400" t="sashton I’ll try out the Object query, thanks for the pointer. This is only for debugging, so I’m not worried about performance"><y>#</y><d>2019-11-05</d><h>20:39</h><w>sashton</w>I’ll try out the Object query, thanks for the pointer. This is only for debugging, so I’m not worried about performance</z><z id="t1572986367027900" t="mikerod But there are some complexities involved depending how precise you need it"><y>#</y><d>2019-11-05</d><h>20:39</h><w>mikerod</w>But there are some complexities involved depending how precise you need it</z><z id="t1572986463028700" t="mikerod Object query is straightforward. It’s slow because it always is activated by all working memory changes"><y>#</y><d>2019-11-05</d><h>20:41</h><w>mikerod</w>Object query is straightforward. It’s slow because it always is activated by all working memory changes</z><z id="t1572986471029000" t="mikerod And remember to fire rules always before running query"><y>#</y><d>2019-11-05</d><h>20:41</h><w>mikerod</w>And remember to fire rules always before running query</z><z id="t1572986482029400" t="mikerod They (can) do some batching/lazy stuff they may delay until fire rules."><y>#</y><d>2019-11-05</d><h>20:41</h><w>mikerod</w>They (can) do some batching/lazy stuff they may delay until fire rules.</z><z id="t1572986596029700" t="sashton Thanks!"><y>#</y><d>2019-11-05</d><h>20:43</h><w>sashton</w>Thanks!</z><z id="t1572991456033900" t="wparker On the subject of the query performance, something that may be counterintuitive is that the cost comes from the presence of the query in the rules session, not the query call itself. In essence when fire-rules is called the query results are computed. Agreed that a query on Object is the simplest way to get all facts in the session if the perf hit doesn&apos;t matter e.g. in testing."><y>#</y><d>2019-11-05</d><h>22:04</h><w>wparker</w>On the subject of the query performance, something that may be counterintuitive is that the cost comes from the presence of the query in the rules session, not the query call itself.  In essence when fire-rules is called the query results are computed. Agreed that a query on Object is the simplest way to get all facts in the session if the perf hit doesn&apos;t matter e.g. in testing.</z><z id="t1572991504035300" t="wparker Assuming we&apos;re talking about JVM clojure, not sure offhand what the cljs equivalent would be."><y>#</y><d>2019-11-05</d><h>22:05</h><w>wparker</w>Assuming we&apos;re talking about JVM clojure, not sure offhand what the cljs equivalent would be.</z><z id="t1573653069038400" t="sashton I’m trying to figure out if there is a way to accumulate some joined data. I haven’t been able to come up with a single rule which will fire with my desired output. In the following example, I am trying to answer the question, what is the sum of quantities for each name : (defrecord A [id name]) (defrecord B [id quantity]) (defrule merge-things ??? =&gt; (println ?name ?total-quanity)) (-&gt; (mk-session) (insert (-&gt;A 1 &quot;car&quot;)) (insert (-&gt;A 2 &quot;truck&quot;)) (insert (-&gt;A 3 &quot;car&quot;)) (insert (-&gt;B 1 2)) (insert (-&gt;B 2 3)) (insert (-&gt;B 3 5)) (fire-rules)) I am trying to have that rule print out: car 7 truck 3 "><y>#</y><d>2019-11-13</d><h>13:51</h><w>sashton</w>I’m trying to figure out if there is a way to accumulate some joined data. I haven’t been able to come up with a single rule which will fire with my desired output.
In the following example, I am trying to answer the question, what is the sum of <code>quantities</code> for each <code>name</code>:
<pre>(defrecord A [id name])
(defrecord B [id quantity])

(defrule merge-things
  ???
  =&gt;
  (println ?name ?total-quanity))

(-&gt; (mk-session)
    (insert (-&gt;A 1 &quot;car&quot;))
    (insert (-&gt;A 2 &quot;truck&quot;))
    (insert (-&gt;A 3 &quot;car&quot;))
    (insert (-&gt;B 1 2))
    (insert (-&gt;B 2 3))
    (insert (-&gt;B 3 5))
    (fire-rules))
</pre>
I am trying to have that rule print out:
<pre>car 7
truck 3
</pre></z><z id="t1573653170039500" t="sashton I haven’t been able to come up with a ??? for that rule which works."><y>#</y><d>2019-11-13</d><h>13:52</h><w>sashton</w>I haven’t been able to come up with a <code>???</code> for that rule which works.</z><z id="t1573653621042900" t="sashton Well, duckie to the rescue. While typing this up, I found one way I hadn’t tried. So now my question is, are there any problems with the following rule definition? (memory,performance,other,…) It is different that other rules I’ve used. Not sure if using the accumulator and re-creating the set of ids — (set (map :id ?a)) — in the rule expression would cause any unexpected problems. (defrule merge-things [?a &lt;- (acc/all) :from [A (= ?name name)]] [?total-quantity &lt;- (acc/sum :quantity) :from [B (get (set (map :id ?a)) id)]] =&gt; (println ?name ?total-quantity)) "><y>#</y><d>2019-11-13</d><h>14:00</h><w>sashton</w>Well, <b>duckie</b>  to the rescue. While typing this up, I found one way I hadn’t tried. So now my question is, are there any problems with the following rule definition? (memory,performance,other,…)
It is different that other rules I’ve used. Not sure if using the accumulator and re-creating the set of ids — <code>(set (map :id ?a))</code> — in the rule expression would cause any unexpected problems.
<pre>(defrule merge-things
  [?a &lt;- (acc/all) :from [A (= ?name name)]]
  [?total-quantity &lt;- (acc/sum :quantity) :from [B (get (set (map :id ?a)) id)]]
  =&gt;
  (println ?name ?total-quantity))
</pre></z><z id="t1573756612054800" t="ethanc @sashton, Sorry for the delay. From my experience accumulators are relatively cheap with respect to memory/performance in scenarios where the state of the session that they are accumulating is relatively stable. Performance can degrade in the event that there are massive amounts of logical retractions due to truth maintenance, but it would be directly linked to the data in the session and other rules that may feed into this rule. To the second half, &gt; Not sure if using the accumulator and re-creating the set of ids — (set (map :id ?a)) — in the rule expression would cause any unexpected problems. I believe that would require each B in the session to generate the set again, perhaps using the distinct accumulator instead might be ‘better’. Any updates to A would also require this work to be redone. Something like: (defrule merge-things [?ids &lt;- (acc/distinct :id) :from [A (= ?name name)]] [?total-quantity &lt;- (acc/sum :quantity) :from [B (contains? ?ids id)]] =&gt; (println ?name ?total-quantity)) In theory this would only have to recalculate the set when a new A was seen and then only if that return value changed then re evaluation of the B logic would have to occur. Then again all of this needs to be taken with a grain of salt as data scenarios can change the behavior of performance while executing rules."><y>#</y><d>2019-11-14</d><h>18:36</h><w>ethanc</w>@sashton,
Sorry for the delay. From my experience accumulators are relatively cheap with respect to memory/performance in scenarios where the state of the session that they are accumulating is relatively stable.
Performance can degrade in the event that there are massive amounts of logical retractions due to truth maintenance, but it would be directly linked to the data in the session and other rules that may feed into this rule.

To the second half,
&gt; Not sure if using the accumulator and re-creating the set of ids — <code>(set (map :id ?a))</code> — in the rule expression would cause any unexpected problems.
I believe that would require each <code>B</code> in the session to generate the set again, perhaps using the <code>distinct</code> accumulator instead might be ‘better’. Any updates to <code>A</code> would also require this work to be redone.
Something like:
<pre>(defrule merge-things
  [?ids &lt;- (acc/distinct :id) :from [A (= ?name name)]]
  [?total-quantity &lt;- (acc/sum :quantity) :from [B (contains? ?ids id)]]
  =&gt;
  (println ?name ?total-quantity))
</pre>
In theory this would only have to recalculate the set when a new <code>A</code> was seen and then only if that return value changed then re evaluation of the <code>B</code> logic would have to occur.
Then again all of this needs to be taken with a grain of salt as data scenarios can  change the behavior of performance while executing rules.</z><z id="t1573757045055500" t="bartuka insteresting error, I am using a private function inside the namespace of the rules and clara gave me the follow stacktrace #error { :cause var: #&apos;secland.securities.contract-rules/now-in-inst is not public :via [{:type clojure.lang.ExceptionInfo :message Failed compiling alpha node... "><y>#</y><d>2019-11-14</d><h>18:44</h><w>bartuka</w>insteresting error, I am using a private function inside the namespace of the rules and clara gave me the follow stacktrace

<pre>#error {
 :cause var: #&apos;secland.securities.contract-rules/now-in-inst is not public
 :via
 [{:type clojure.lang.ExceptionInfo
   :message Failed compiling alpha node...
</pre></z><z id="t1573757063055800" t="bartuka I would like to understand more why"><y>#</y><d>2019-11-14</d><h>18:44</h><w>bartuka</w>I would like to understand more why</z><z id="t1573757312056700" t="ethanc @iagwanderson, Was the function was used inside the LHS of a rule?"><y>#</y><d>2019-11-14</d><h>18:48</h><w>ethanc</w>@iagwanderson, Was the function was used inside the LHS of a rule?</z><z id="t1573757410057800" t="ethanc nvm, i missed Failed compiling alpha node . So the answer to my question would be yes."><y>#</y><d>2019-11-14</d><h>18:50</h><w>ethanc</w>nvm, i missed <code>Failed compiling alpha node</code>. So the answer to my question would be yes.</z><z id="t1573757913064000" t="ethanc The reason that this would occur would be due to how clara evaluates LHS/RHS. The LHS is assumed to be namespace agnostic, as nodes that make up the LHS(AlphaNodes, JoinNodes, ect.) could be shared across namespaces and rules in those namespaces, whereas the RHS(ProductionNodes) can’t be shared and can be seen as Namespace bound. This means that Clara evaluates LHS nodes outside of the original namespace that they are defined within, and production nodes are evaluated within the namespace that they are defined. So, by having a private function within the LHS of a rule clara will cause an exception to be thrown due to illegal access. I’m not sure if that is documented anywhere, but it probably should be… I will see if i can find any."><y>#</y><d>2019-11-14</d><h>18:58</h><w>ethanc</w>The reason that this would occur would be due to how clara evaluates LHS/RHS. The LHS is assumed to be namespace agnostic, as nodes that make up the LHS(AlphaNodes, JoinNodes, ect.) could be shared across namespaces and rules in those namespaces, whereas the RHS(ProductionNodes) can’t be shared and can be seen as Namespace bound.

This means that Clara evaluates LHS nodes outside of the original namespace that they are defined within, and production nodes are evaluated within the namespace that they are defined. So, by having a private function within the LHS of a rule clara will cause an exception to be thrown due to illegal access. I’m not sure if that is documented anywhere, but it probably should be… I will see if i can find any.</z><z id="t1573759814064700" t="bartuka @ethanc thanks so much for the clear explanation, didn&apos;t find any explanation around it when I searched"><y>#</y><d>2019-11-14</d><h>19:30</h><w>bartuka</w>@ethanc thanks so much for the clear explanation, didn&apos;t find any explanation around it when I searched</z><z id="t1573759957065000" t="bartuka I have a more general question about code organization"><y>#</y><d>2019-11-14</d><h>19:32</h><w>bartuka</w>I have a more general question about code organization</z><z id="t1573759999065900" t="bartuka I have some rules that need to be run for specific clients and products, there is a recommended approach about how to organize the rules and the sessions for each situation?"><y>#</y><d>2019-11-14</d><h>19:33</h><w>bartuka</w>I have some rules that need to be run for specific clients and products, there is a recommended approach about how to organize the rules and the sessions for each situation?</z><z id="t1573760028066400" t="bartuka I would like to enable some users to enable/disable a rule, so probably having a reference to it in a database"><y>#</y><d>2019-11-14</d><h>19:33</h><w>bartuka</w>I would like to enable some users to enable/disable a rule, so probably having a reference to it in a database</z><z id="t1573770800072700" t="ethanc I guess it would depend on your use-case, i think the way i would handle them would be treating a namespace as a “feature package”. Then a given client could enable features(sets of rules) by namespace, of course through some abstraction(wouldn’t want consumers directly loading namespaces). That way when it comes to session creation you would only have to worry about loading a set of namespaces containing rules, ex (defn load-session [] (let [client-namespaces (get-namespaces-by-client)] &lt;require namespaces if not already done&gt; (com/mk-session client-namespaces))) per rule filtering would probably be more tricky."><y>#</y><d>2019-11-14</d><h>22:33</h><w>ethanc</w>I guess it would depend on your use-case, i think the way i would handle them would be treating a namespace as a “feature package”. Then a given client could enable features(sets of rules) by namespace, of course through some abstraction(wouldn’t want consumers directly loading namespaces). That way when it comes to session creation you would only have to worry about loading a set of namespaces containing rules, ex
<pre>(defn load-session 
  []
  (let [client-namespaces (get-namespaces-by-client)]
    &lt;require namespaces if not already done&gt;
    (com/mk-session client-namespaces)))
</pre>
per rule filtering would probably be more tricky.</z><z id="t1574799787073600" t="bartuka hi, @ethanc thanks for the answer"><y>#</y><d>2019-11-26</d><h>20:23</h><w>bartuka</w>hi, @ethanc thanks for the answer</z><z id="t1574799838074600" t="bartuka I was out of work these days. I just tried your approach, but the problem is to pass a list of symbols to mk-session , I am not able to use apply because this is a macro"><y>#</y><d>2019-11-26</d><h>20:23</h><w>bartuka</w>I was out of work these days. I just tried your approach, but the problem is to pass a list of symbols to <code>mk-session</code>, I am not able to use <code>apply</code> because this is a macro</z><z id="t1574799846074800" t="bartuka how are you handling this?"><y>#</y><d>2019-11-26</d><h>20:24</h><w>bartuka</w>how are you handling this?</z><z id="t1574800754075200" t="mikerod @iagwanderson clara.rules.compiler/mk-session can be used"><y>#</y><d>2019-11-26</d><h>20:39</h><w>mikerod</w>@iagwanderson <code>clara.rules.compiler/mk-session</code> can be used</z><z id="t1574800765075500" t="mikerod it’s the underlying fn - just have to deal with some boilerplate with quotes etc"><y>#</y><d>2019-11-26</d><h>20:39</h><w>mikerod</w>it’s the underlying fn - just have to deal with some boilerplate with quotes etc</z><z id="t1574800787075700" t="mikerod it’s signature is slightly different"><y>#</y><d>2019-11-26</d><h>20:39</h><w>mikerod</w>it’s signature is slightly different</z><z id="t1574800813076000" t="mikerod takes sequence of sources-and-options"><y>#</y><d>2019-11-26</d><h>20:40</h><w>mikerod</w>takes sequence of <code>sources-and-options</code></z><z id="t1574800818076200" t="mikerod sources expected to come first"><y>#</y><d>2019-11-26</d><h>20:40</h><w>mikerod</w>sources expected to come first</z><z id="t1574800834076500" t="mikerod then keyword options"><y>#</y><d>2019-11-26</d><h>20:40</h><w>mikerod</w>then keyword options</z><z id="t1574800848076800" t="mikerod example [&apos;my.ns.name :my-option :foo]"><y>#</y><d>2019-11-26</d><h>20:40</h><w>mikerod</w>example <code>[&apos;my.ns.name :my-option :foo]</code></z><z id="t1574800962077100" t="bartuka oh, cool. let me try out! thanks"><y>#</y><d>2019-11-26</d><h>20:42</h><w>bartuka</w>oh, cool. let me try out! thanks</z><z id="t1574801001077300" t="bartuka worked just fine o/"><y>#</y><d>2019-11-26</d><h>20:43</h><w>bartuka</w>worked just fine o/</z><z id="t1574801509077500" t="mikerod nice"><y>#</y><d>2019-11-26</d><h>20:51</h><w>mikerod</w>nice</z><z id="t1575983125081300" t="Konstantinos Tzanidakis Hi everyone, I was hoping to get some help on seriliazing the session in Clara Rules. I am fairly new to Clara and I am trying to start by implementing the example in the docs: &lt;http://www.clara-rules.org/docs/durability/&gt;, for my own facts (using maps along with fact-type-fn). However, during deserialization I am getting the following error: nth not supported on this type: Element . Any ideas/suggestions would be more than welcomed."><y>#</y><d>2019-12-10</d><h>13:05</h><w>Konstantinos Tzanidakis</w>Hi everyone, I was hoping to get some help on seriliazing the session in Clara Rules. I am fairly new to Clara and I am trying to start by implementing the example in the docs: &lt;http://www.clara-rules.org/docs/durability/&gt;, for my own facts (using maps along with fact-type-fn). However, during <code>deserialization</code> I am getting the following error: <code>nth not supported on this type: Element</code>. Any ideas/suggestions would be more than welcomed.</z><z id="t1575989640082500" t="mikerod @konstantinos562 (1) is it possible to share what you have? &amp; (2) can I see the full stack trace (or the Clara-part of it) coming with this exception?"><y>#</y><d>2019-12-10</d><h>14:54</h><w>mikerod</w>@konstantinos562 (1) is it possible to share what you have? &amp; (2) can I see the full stack trace (or the Clara-part of it) coming with this exception?</z><z id="t1575991231083500" t="Konstantinos Tzanidakis @mikerod thanks a lot, I have probably figured this out, I was using maps instead of records but when I was storing the session using the serializer I was not providing the :fact-type-fn options as well as I was setting with-rulebase? to false. Most probably, because I didn&apos;t include the fact-type-fn, the deserializer was mistakenly trying to destruct the facts as &quot;Element&quot;s (or something like this). Thank you very much for the prompt response 🙂"><y>#</y><d>2019-12-10</d><h>15:20</h><w>Konstantinos Tzanidakis</w>@mikerod thanks a lot, I have probably figured this out, I was using maps instead of records but when I was storing the session using the serializer I was not providing the :fact-type-fn options as well as I was setting with-rulebase? to false. Most probably, because I didn&apos;t include the fact-type-fn, the deserializer was mistakenly trying to destruct the facts as &quot;Element&quot;s (or something like this). Thank you very much for the prompt response <b>🙂</b></z><z id="t1575992008084600" t="mikerod @konstantinos562 that makes sense. Yes, the durability layer stuff can certainly be a bit complicated since you do have to do things quite specifically"><y>#</y><d>2019-12-10</d><h>15:33</h><w>mikerod</w>@konstantinos562 that makes sense. Yes, the durability layer stuff can certainly be a bit complicated since you do have to do things quite specifically</z><z id="t1576157382085700" t="bartuka I have being caught in infinite-loops some times while using clara and I would like to know if there is any way to handle this issue?"><y>#</y><d>2019-12-12</d><h>13:29</h><w>bartuka</w>I have being caught in infinite-loops some times while using clara and I would like to know if there is any way to handle this issue?</z><z id="t1576157429086700" t="bartuka Every time it happened was due to error in logic, but would be great to have an exception for that or something"><y>#</y><d>2019-12-12</d><h>13:30</h><w>bartuka</w>Every time it happened was due to error in logic, but would be great to have an exception for that or something</z><z id="t1576157463087200" t="bartuka it&apos;s possible to see how many times each rule was called during that session?"><y>#</y><d>2019-12-12</d><h>13:31</h><w>bartuka</w>it&apos;s possible to see how many times each rule was called during that session?</z><z id="t1576160771089700" t="ethanc &gt; it’s possible to see how many times each rule was called during that session? Im not sure that there is a way to see the number of executions of a rule, but i do believe that the inspect namespace: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.cljc has some tooling around explanations of rules firing. Additionally, I believe Will has been playing around with the idea of capturing scenarios that behave like infinite loops: https://github.com/cerner/clara-rules/pull/425"><y>#</y><d>2019-12-12</d><h>14:26</h><w>ethanc</w>&gt;  it’s possible to see how many times each rule was called during that session?
Im not sure that there is a way to see the number of executions of a rule, but i do believe that the inspect namespace:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/tools/inspect.cljc</a>
has some tooling around explanations of rules firing.

Additionally, I believe Will has been playing around with the idea of capturing scenarios that behave like infinite loops:
<a href="https://github.com/cerner/clara-rules/pull/425" target="_blank">https://github.com/cerner/clara-rules/pull/425</a></z><z id="t1576163155090400" t="bartuka @ethanc thanks for pointing the right directions o/"><y>#</y><d>2019-12-12</d><h>15:05</h><w>bartuka</w>@ethanc thanks for pointing the right directions o/</z><z id="t1576199852090900" t="geraldodev The 1st (= ?cd_paciente cd_paciente) is a binding (since there are no other on the local scope. The second (= ?cd_paciente cd_paciente) is a comparison because the binding is already established right ?"><y>#</y><d>2019-12-13</d><h>01:17</h><w>geraldodev</w>The 1st (= ?cd_paciente cd_paciente) is a binding (since there are no other on the local scope. The second (= ?cd_paciente cd_paciente) is a comparison because the binding is already established right ?</z><z id="t1576200006091600" t="ethanc That is correct"><y>#</y><d>2019-12-13</d><h>01:20</h><w>ethanc</w>That is correct</z><z id="t1576200106092900" t="geraldodev Its beautiful . (error prone too) if i remove a char of ?cd_paciente I got two bindings"><y>#</y><d>2019-12-13</d><h>01:21</h><w>geraldodev</w>Its beautiful . (error prone too) if i remove a char of ?cd_paciente I got two bindings</z><z id="t1576200278096300" t="ethanc Yeah, i&apos;ve wondered if the Clara compiler should warn on unused bindings..."><y>#</y><d>2019-12-13</d><h>01:24</h><w>ethanc</w>Yeah, i&apos;ve wondered if the Clara compiler should warn on unused bindings...</z><z id="t1576238289097000" t="bartuka this could be very handy"><y>#</y><d>2019-12-13</d><h>11:58</h><w>bartuka</w>this could be very handy</z><z id="t1576252188000600" t="mikerod @geraldodev yeah, because ?binding-name is just some arbitrary local name you want to give for the context"><y>#</y><d>2019-12-13</d><h>15:49</h><w>mikerod</w>@geraldodev yeah, because <code>?binding-name</code> is just some arbitrary local name you want to give for the context</z><z id="t1576252204000900" t="mikerod the warning isn’t a bad idea, @ethanc is a genius"><y>#</y><d>2019-12-13</d><h>15:50</h><w>mikerod</w>the warning isn’t a bad idea, @ethanc is a genius</z><z id="t1576252268001600" t="ethanc I will log an issue for enhancement, when i get a few free seconds @mikerod"><y>#</y><d>2019-12-13</d><h>15:51</h><w>ethanc</w>I will log an issue for enhancement, when i get a few free seconds @mikerod</z><z id="t1576258108004200" t="geraldodev @mikerod the warnings from clj-kondo have improved a lot my experience with clojure."><y>#</y><d>2019-12-13</d><h>17:28</h><w>geraldodev</w>@mikerod the warnings from clj-kondo have improved a lot my experience with clojure.</z><z id="t1576258609004700" t="mikerod @geraldodev I’ve started to play around with clj-kondo, but haven’t done so very seriously yet - it looks promising"><y>#</y><d>2019-12-13</d><h>17:36</h><w>mikerod</w>@geraldodev I’ve started to play around with clj-kondo, but haven’t done so very seriously yet - it looks promising</z><z id="t1576258631005300" t="mikerod for a Clara DSL thing though - not thinking it can help you much? like in the case of this variable binding thing?"><y>#</y><d>2019-12-13</d><h>17:37</h><w>mikerod</w>for a Clara DSL thing though - not thinking it can help you much? like in the case of this variable binding thing?</z><z id="t1576258646005700" t="mikerod I know it does have some pretty good extension points though - so can do some nice things"><y>#</y><d>2019-12-13</d><h>17:37</h><w>mikerod</w>I know it does have some pretty good extension points though - so can do some nice things</z><z id="t1576260674008900" t="geraldodev @mikerod I&apos;ve asked on #clj-kondo if it&apos;s possible to lint the unused binding case"><y>#</y><d>2019-12-13</d><h>18:11</h><w>geraldodev</w>@mikerod I&apos;ve asked on #clj-kondo if it&apos;s possible to lint the unused binding case</z><z id="t1576260883010800" t="geraldodev I think it&apos;s a work for a linter. But it&apos;s a very especific syntax. for macros that follows defn or def pattern you simply configure :lint-as on a config file like: {:lint-as {com.fulcrologic.fulcro.components/defsc clojure.core/defn }}"><y>#</y><d>2019-12-13</d><h>18:14</h><w>geraldodev</w>I think it&apos;s a work for a linter. But it&apos;s a very especific syntax. for macros that follows defn or def pattern you simply configure :lint-as on a config file like: {:lint-as
 {com.fulcrologic.fulcro.components/defsc clojure.core/defn
  }}</z><z id="t1576260945011400" t="mikerod @geraldodev yeah, I’ve seen how to do that pattern following like you have above"><y>#</y><d>2019-12-13</d><h>18:15</h><w>mikerod</w>@geraldodev yeah, I’ve seen how to do that pattern following like you have above</z><z id="t1576260948011600" t="mikerod I’ve used that one"><y>#</y><d>2019-12-13</d><h>18:15</h><w>mikerod</w>I’ve used that one</z><z id="t1576260958012000" t="mikerod but the clara DSL is of course more complicated"><y>#</y><d>2019-12-13</d><h>18:15</h><w>mikerod</w>but the clara DSL is of course more complicated</z><z id="t1576260994012500" t="mikerod of course for unused, it may be just not finding the symbol more than one time in the entire DSL form hah"><y>#</y><d>2019-12-13</d><h>18:16</h><w>mikerod</w>of course for unused, it may be just not finding the symbol more than one time in the entire DSL form hah</z><z id="t1576261005012900" t="mikerod Ethan did log a Clara issue it looks like now though"><y>#</y><d>2019-12-13</d><h>18:16</h><w>mikerod</w>Ethan did log a Clara issue it looks like now though</z><z id="t1576261054013900" t="mikerod His proposal targets more on the AST compilation side - which is better since the DSL layer is something that is “pluggable” in Clara (people could use their own and target same AST pre-compilation)"><y>#</y><d>2019-12-13</d><h>18:17</h><w>mikerod</w>His proposal targets more on the AST compilation side - which is better since the DSL layer is something that is “pluggable” in Clara (people could use their own and target same AST pre-compilation)</z><z id="t1576261197015000" t="geraldodev Yesterday was my 1st day with clara. I&apos;m enjoying."><y>#</y><d>2019-12-13</d><h>18:19</h><w>geraldodev</w>Yesterday was my 1st day with clara. I&apos;m enjoying.</z><z id="t1576262530015700" t="mikerod oh, nice"><y>#</y><d>2019-12-13</d><h>18:42</h><w>mikerod</w>oh, nice</z><z id="t1576269380016300" t="geraldodev About processing facts that comes from sql databases on long running sessions. Because of mutation, one has to query the session looking for the fact based on the primary key of the table, compare it with the current value and if it&apos;s different retract the old fact and insert again. Is that correct ?"><y>#</y><d>2019-12-13</d><h>20:36</h><w>geraldodev</w>About processing facts that comes from sql databases on long running sessions. Because of mutation, one has to query the session looking for the fact based on the primary key of the table, compare it with the current value and if it&apos;s different retract the old fact and insert again. Is that correct ?</z><z id="t1576278647016600" t="Eduardo Mata what does this even mean&quot; Java.lang.IllegalStateException: Attempting to call unbound fn: #&apos;"><y>#</y><d>2019-12-13</d><h>23:10</h><w>Eduardo Mata</w>what does this even mean&quot;
<pre>Java.lang.IllegalStateException: Attempting to call unbound fn: #&apos;</pre></z><z id="t1576278770017000" t="Eduardo Mata ups wrong place"><y>#</y><d>2019-12-13</d><h>23:12</h><w>Eduardo Mata</w>ups wrong place</z><z id="t1577131177002000" t="ethanc @geraldodev, sorry i missed your comment: &gt; About processing facts that comes from sql databases on long running sessions. Because of mutation, one has to query the session looking for the fact based on the primary key of the table, compare it with the current value and if it’s different retract the old fact and insert again. Is that correct ? I think that makes sense, for changes outside of the session, you would have to manually update the fact inside the session via an external retract followed by insertion of the fact."><y>#</y><d>2019-12-23</d><h>19:59</h><w>ethanc</w>@geraldodev, sorry i missed your comment:
&gt; About processing facts that comes from sql databases on long running sessions. Because of mutation, one has to query the session looking for the fact based on the primary key of the table, compare it with the current value and if it’s different retract the old fact and insert again. Is that correct ? 
I think that makes sense, for changes outside of the session, you would have to manually update the fact inside the session via an external retract followed by insertion of the fact.</z><z id="t1577490515003400" t="futuro Is it possible to compose left hand sides in rules?"><y>#</y><d>2019-12-27</d><h>23:48</h><w>futuro</w>Is it possible to compose left hand sides in rules?</z><z id="t1577491038006700" t="ethanc Could you elaborate on what you mean by composing?"><y>#</y><d>2019-12-27</d><h>23:57</h><w>ethanc</w>Could you elaborate on what you mean by composing?</z><z id="t1577494301008200" t="futuro I have three rules which have the same fact expressions in their LHS, and I’d like to extract them to aid in reuse. "><y>#</y><d>2019-12-28</d><h>00:51</h><w>futuro</w>I have three rules which have the same fact expressions in their LHS, and I’d like to extract them to aid in reuse. </z><z id="t1577494324009100" t="futuro I’m not at a computer, but I can write up a little snippet later if that’d make it clearer. "><y>#</y><d>2019-12-28</d><h>00:52</h><w>futuro</w>I’m not at a computer, but I can write up a little snippet later if that’d make it clearer. </z><z id="t1577494441012100" t="ethanc I would usually use an intermediate fact in that scenario, one rule that inserts the fact constrained by the common lhs and then downstream rules can rely on the presence of the intermediate fact"><y>#</y><d>2019-12-28</d><h>00:54</h><w>ethanc</w>I would usually use an intermediate fact in that scenario, one rule that inserts the fact constrained by the common lhs and then downstream rules can rely on the presence of the intermediate fact</z><z id="t1577494644014200" t="futuro Hmmm, yeah, that could work. I suppose you’d put any shared fields you needed into this shared fact, which would allow downstream rules to pull them back out, yeah?"><y>#</y><d>2019-12-28</d><h>00:57</h><w>futuro</w>Hmmm, yeah, that could work. I suppose you’d put any shared fields you needed into this shared fact, which would allow downstream rules to pull them back out, yeah?</z><z id="t1577495431017400" t="ethanc Yes, they would carry what&apos;s needed. In some cases simply wrapping the whole fact might make sense"><y>#</y><d>2019-12-28</d><h>01:10</h><w>ethanc</w>Yes, they would carry what&apos;s needed. In some cases simply wrapping the whole fact might make sense</z><z id="t1577498229018100" t="futuro Swanky, thank you @ethanc !"><y>#</y><d>2019-12-28</d><h>01:57</h><w>futuro</w>Swanky, thank you @ethanc !</z><z id="t1577816345020700" t="Matthew Pettis Does anyone know of any examples of clara-rules that solve logic problems? Or similarily, sudoku? I&apos;m looking for examples of rules, or good architecture, to make rules that enforce unique exclusions. Such as in logic problems found here: https://www.brainzilla.com/logic/logic-grid/apples-to-apples/"><y>#</y><d>2020-12-31</d><h>18:19</h><w>Matthew Pettis</w>Does anyone know of any examples of clara-rules that solve logic problems?  Or similarily, sudoku?  I&apos;m looking for examples of rules, or good architecture, to make rules that enforce unique exclusions.  Such as in logic problems found here: <a href="https://www.brainzilla.com/logic/logic-grid/apples-to-apples/" target="_blank">https://www.brainzilla.com/logic/logic-grid/apples-to-apples/</a></z><z id="t1577816446022400" t="Matthew Pettis I&quot;m looking to do this in an industrial setting (&quot;machine A can&apos;t be on if machine B is on&quot;, or &quot;machine B cannot turn on unless machine A is already on&quot;, etc.) Logic puzzles seem to be a template for what this concept is..."><y>#</y><d>2020-12-31</d><h>18:20</h><w>Matthew Pettis</w>I&quot;m looking to do this in an industrial setting (&quot;machine A can&apos;t be on if machine B is on&quot;, or &quot;machine B cannot turn on unless machine A is already on&quot;, etc.)  Logic puzzles seem to be a template for what this concept is...</z><z id="t1577820581023400" t="geraldodev https://gist.github.com/geraldodev/076ccb995db907644070f134656fb74b Hi can you comment on this gist. It looks like defsession with :fact-type-fn does not stick with the var"><y>#</y><d>2020-12-31</d><h>19:29</h><w>geraldodev</w><a href="https://gist.github.com/geraldodev/076ccb995db907644070f134656fb74b" target="_blank">https://gist.github.com/geraldodev/076ccb995db907644070f134656fb74b</a> Hi can you comment on this gist. It looks like defsession with :fact-type-fn does not stick with the var</z><z id="t1577822722023600" t="Matthew Pettis Thank you, I&apos;ll check out."><y>#</y><d>2020-12-31</d><h>20:05</h><r>Matthew Pettis</r>Thank you, I&apos;ll check out.</z><z id="t1577822949023900" t="Matthew Pettis Sorry, thought this was related to my question..."><y>#</y><d>2020-12-31</d><h>20:09</h><r>Matthew Pettis</r>Sorry, thought this was related to my question...</z><z id="t1577825699024100" t="ethanc @U0516053R, I don’t typically use the defsession macro, but it seems to me that it is building the call to mk-session differently. https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L368 (mk-session [:fact-type-fn :type]) vs (mk-session :fact-type-fn :type) so the session in this case is empty(no productions) due to defsession not appending the current namespace."><y>#</y><d>2020-12-31</d><h>20:54</h><r>ethanc</r>@U0516053R,
I don’t typically use the defsession macro, but it seems to me that it is building the call to mk-session differently.

<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L368" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L368</a>

<pre>(mk-session [:fact-type-fn :type])</pre>
vs
<pre>(mk-session :fact-type-fn :type)</pre>
so the <code>session</code> in this case is empty(no productions) due to <code>defsession</code> not appending the current namespace.</z><z id="t1577825850024500" t="ethanc To get this to work, (defsession session `app.mv.clara2 :fact-type-fn :type) the namespace would have to be provided"><y>#</y><d>2020-12-31</d><h>20:57</h><r>ethanc</r>To get this to work,
<pre>(defsession session `app.mv.clara2 :fact-type-fn :type)</pre>
the namespace would have to be provided</z><z id="t1577842716024700" t="geraldodev @U3KC48GHW Thank you!. I&apos;ve started with (def session (mk-session . Later I&apos;ve switched to defsession. Also I was trying to infer changes on the sql table based on the primary key. The plan was to baby sit the session like an atom. I&apos;ve stumbled across a issue that shows that clara ignores facts that are not touched by rules and queries. https://github.com/cerner/clara-rules/issues/48 . I was intending to use it wrong. It looks like reading the table, insert the facts and collect the results and let the session go way is a more correct approach.."><y>#</y><d>2020-01-01</d><h>01:38</h><r>geraldodev</r>@U3KC48GHW Thank you!. I&apos;ve started with (def session (mk-session . Later I&apos;ve switched to defsession. Also I was trying to infer changes on the sql table based on the primary key. The plan was to baby sit the session like an atom. I&apos;ve stumbled across a issue that shows that clara ignores facts that are not touched by rules and queries. <a href="https://github.com/cerner/clara-rules/issues/48" target="_blank">https://github.com/cerner/clara-rules/issues/48</a> . I was intending to use it wrong. It looks like reading the table, insert the facts and collect the results and let the session go way is a more correct approach..</z><z id="t1578340529034500" t="Eduardo Mata I am applying a basic rule saying (defrule missing-information [?event &lt;- Event (nil? flower-id) (= ?id _id)] =&gt; (insert! -&gt;AddError _id :error &quot;Missing Flower _id&quot;))"><y>#</y><d>2020-01-06</d><h>19:55</h><w>Eduardo Mata</w>I am applying a basic rule saying
<pre>(defrule missing-information
[?event &lt;- Event (nil? flower-id) (= ?id _id)]
=&gt;
(insert! -&gt;AddError _id  :error &quot;Missing Flower _id&quot;))</pre></z><z id="t1578340570035400" t="Eduardo Mata for some reason, I have a Record with flower-id and it clara still telling me the flower-id is missing"><y>#</y><d>2020-01-06</d><h>19:56</h><w>Eduardo Mata</w>for some reason, I have a Record with flower-id and it clara still telling me the flower-id is missing</z><z id="t1578341904038500" t="mikerod @contact904 do you have more than one Event? Are you saying an Event with a non-nil flower-id and a unique _id is being matched with the above rule which insets the AddError fact? Your -&gt;AddError syntax seems incorrect since it isn’t calling the fn to but guessing that this is maybe pseudo-code"><y>#</y><d>2020-01-06</d><h>20:18</h><w>mikerod</w>@contact904 do you have more than one Event? Are you saying an Event with a non-nil flower-id and a unique _id is being matched with the above rule which insets the AddError fact? Your -&gt;AddError syntax seems incorrect since it isn’t calling the fn to but guessing that this is maybe pseudo-code</z><z id="t1578342095039500" t="Eduardo Mata AddError is a new Record with fields _id, error, value it is close to a pseudo-code"><y>#</y><d>2020-01-06</d><h>20:21</h><w>Eduardo Mata</w>AddError is a new Record with fields <code>_id, error, value</code>  it is close to a pseudo-code</z><z id="t1578342124040000" t="Eduardo Mata I am confused because I have been usings this rule for a long time, this is the first time I get this error"><y>#</y><d>2020-01-06</d><h>20:22</h><w>Eduardo Mata</w>I am confused because I have been usings this rule for a long time, this is the first time I get this error</z><z id="t1578342356040400" t="Eduardo Mata I see what is my problem. I have similar _id;s"><y>#</y><d>2020-01-06</d><h>20:25</h><w>Eduardo Mata</w>I see what is my problem. I have similar _id;s</z><z id="t1578342899041000" t="mikerod @contact904 (insert! -&gt;AddError _id :error &quot;Missing Flower _id&quot;) is missing parens was my comment on syntax (insert! (-&gt;AddError _id :error &quot;Missing Flower _id&quot;))"><y>#</y><d>2020-01-06</d><h>20:34</h><w>mikerod</w>@contact904 <code>(insert! -&gt;AddError _id  :error &quot;Missing Flower _id&quot;)</code> is missing parens was my comment on syntax
<code>(insert! (-&gt;AddError _id  :error &quot;Missing Flower _id&quot;))</code></z><z id="t1578407521048300" t="Konstantinos Tzanidakis Hi all, I want to serialize/deserialize the working-memory separately so I started off by using a simple implementation for IWorkingMemorySerializer that serializes to an atom (as per Clara&apos;s docs) and deserializing from the atom by derefing it. That works perfectly fine, in that I am able to run queries and get the same results from both the original and deserialized session. However, if I add the extra step to write to fressian and read fressian to the ser/deserializer of the IWorkingMemorySerializer , all queries in the deserialized version of the session return with nil: eg. ({:?crn nil}) while the same query on the original is returning ({:?crn {:fact-type :client-representative-notification, :name &quot;Alice&quot;, :client &quot;Acme&quot;, :level :high}}) . I should note that I am fairly new to clara rules. Has anyone come across something like this before?"><y>#</y><d>2020-01-07</d><h>14:32</h><w>Konstantinos Tzanidakis</w>Hi all, I want to serialize/deserialize the working-memory separately so I started off by using a simple implementation for <code>IWorkingMemorySerializer</code> that serializes to an atom (as per Clara&apos;s docs) and deserializing from the atom by derefing it. That works perfectly fine, in that I am able to run queries and get the same results from both the original and deserialized session. However, if I add the extra step to write to fressian and read fressian to the ser/deserializer of the <code>IWorkingMemorySerializer</code> , all queries in the deserialized version of the session return with nil: eg. <code>({:?crn nil})</code> while the same query on the original is returning <code>({:?crn {:fact-type :client-representative-notification, :name &quot;Alice&quot;, :client &quot;Acme&quot;, :level :high}})</code> . I should note that I am fairly new to clara rules. Has anyone come across something like this before?</z><z id="t1578409791050100" t="ethanc @konstantinos562, Do you have a small snippet, it would help me reproduce it locally?"><y>#</y><d>2020-01-07</d><h>15:09</h><w>ethanc</w>@konstantinos562,
Do you have a small snippet, it would help me reproduce it locally?</z><z id="t1578409944050600" t="Konstantinos Tzanidakis Hi @ethanc do you need the rules as well?"><y>#</y><d>2020-01-07</d><h>15:12</h><w>Konstantinos Tzanidakis</w>Hi @ethanc do you need the rules as well?</z><z id="t1578409988050900" t="Konstantinos Tzanidakis (defrecord WorkingMemoryAtomSerializer [input output] d/IWorkingMemorySerializer (serialize-facts [_ facts] (reset! state (write-fressian facts))) (deserialize-facts [this] (-&gt; @state io/input-stream read-fressian)))"><y>#</y><d>2020-01-07</d><h>15:13</h><w>Konstantinos Tzanidakis</w><pre>(defrecord WorkingMemoryAtomSerializer [input output]
  d/IWorkingMemorySerializer
  (serialize-facts [_ facts]
    (reset! state (write-fressian facts)))
  (deserialize-facts [this]
    (-&gt; @state io/input-stream read-fressian)))</pre></z><z id="t1578410052051800" t="Konstantinos Tzanidakis with (def state (atom nil)) in the namespace"><y>#</y><d>2020-01-07</d><h>15:14</h><w>Konstantinos Tzanidakis</w>with <code>(def state (atom nil))</code> in the namespace</z><z id="t1578410076052100" t="Konstantinos Tzanidakis and the read and write fressian as follows"><y>#</y><d>2020-01-07</d><h>15:14</h><w>Konstantinos Tzanidakis</w>and the read and write fressian as follows</z><z id="t1578410080052500" t="Konstantinos Tzanidakis (defn write-fressian [obj] (let [baos (ByteArrayOutputStream.) wr (frz/create-writer baos)] (frz/write-object wr obj) (.toByteArray baos))) (defn read-fressian [b] (-&gt; b frz/create-reader frz/read-object))"><y>#</y><d>2020-01-07</d><h>15:14</h><w>Konstantinos Tzanidakis</w><pre>(defn write-fressian [obj]
  (let [baos (ByteArrayOutputStream.)
        wr   (frz/create-writer baos)]
    (frz/write-object wr obj)
    (.toByteArray baos)))

(defn read-fressian [b]
  (-&gt; b frz/create-reader frz/read-object))</pre></z><z id="t1578410087052800" t="Konstantinos Tzanidakis sorry for the long posting all"><y>#</y><d>2020-01-07</d><h>15:14</h><w>Konstantinos Tzanidakis</w>sorry for the long posting all</z><z id="t1578410150054000" t="Konstantinos Tzanidakis NB: I have replaced fressian with nippy/freeze and nippy/thaw and it works perfectly fine now. I am not sure what the issue was (most probably I am doing something wrong there)"><y>#</y><d>2020-01-07</d><h>15:15</h><w>Konstantinos Tzanidakis</w>NB: I have replaced fressian with nippy/freeze and nippy/thaw and it works perfectly fine now. I am not sure what the issue was (most probably I am doing something wrong there)</z><z id="t1578410171054300" t="mikerod @konstantinos562 not sure what frz ns is referring to"><y>#</y><d>2020-01-07</d><h>15:16</h><w>mikerod</w>@konstantinos562 not sure what <code>frz</code> ns is referring to</z><z id="t1578410183054700" t="mikerod You may just not have setup good read/write handlers for your facts"><y>#</y><d>2020-01-07</d><h>15:16</h><w>mikerod</w>You may just not have setup good read/write handlers for your facts</z><z id="t1578410195055200" t="mikerod Fressian’s defaults tend to be insufficient"><y>#</y><d>2020-01-07</d><h>15:16</h><w>mikerod</w>Fressian’s defaults tend to be insufficient</z><z id="t1578410196055400" t="Konstantinos Tzanidakis sorry it&apos;s the requirement: [clojure.data.fressian :as frz]"><y>#</y><d>2020-01-07</d><h>15:16</h><w>Konstantinos Tzanidakis</w>sorry it&apos;s the requirement: <code>[clojure.data.fressian :as frz]</code></z><z id="t1578410215055900" t="mikerod or they will cause many clj data structures to become Java structures - or not the same as before"><y>#</y><d>2020-01-07</d><h>15:16</h><w>mikerod</w>or they will cause many clj data structures to become Java structures - or not the same as before</z><z id="t1578410253057000" t="mikerod you can see Clara defines a more robust set of fressian handlers for clj to clj serialization https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability/fressian.clj#L231"><y>#</y><d>2020-01-07</d><h>15:17</h><w>mikerod</w>you can see Clara defines a more robust set of fressian handlers for clj to clj serialization <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability/fressian.clj#L231" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/durability/fressian.clj#L231</a></z><z id="t1578410267057600" t="mikerod however, there really is no compelling reason to not just use nippy if you have it set up"><y>#</y><d>2020-01-07</d><h>15:17</h><w>mikerod</w>however, there really is no compelling reason to not just use <code>nippy</code> if you have it set up</z><z id="t1578410283058200" t="mikerod I wouldn’t have used Fressian to impl Clara’s session serialization if I were to do it again today. it is difficult to work with in what it provides by default and I don’t think it is any better than something like nippy or perhaps a few others. It is also not documented super well and at the “primitive” level makes some unavoidable Java collections that are awkward to convert from (and also wasting perf time)"><y>#</y><d>2020-01-07</d><h>15:18</h><w>mikerod</w>I wouldn’t have used Fressian to impl Clara’s session serialization if I were to do it again today. it is difficult to work with in what it provides by default and I don’t think it is any better than something like <code>nippy</code> or perhaps a few others. It is also not documented super well and at the “primitive” level makes some unavoidable Java collections that are awkward to convert from (and also wasting perf time)</z><z id="t1578410291058600" t="Konstantinos Tzanidakis for this example, I have not set up any handlers but the facts are fairly simple [{:fact-type :client-representative :name &quot;Alice&quot; :client &quot;Acme&quot;} {:fact-type :support-request :client &quot;Acme&quot; :level :high}]"><y>#</y><d>2020-01-07</d><h>15:18</h><w>Konstantinos Tzanidakis</w>for this example, I have not set up any handlers but the facts are fairly simple
<pre>[{:fact-type :client-representative :name &quot;Alice&quot; :client &quot;Acme&quot;}
 {:fact-type :support-request :client &quot;Acme&quot; :level :high}]</pre></z><z id="t1578410299058800" t="mikerod (this is all pluggable and could be implemented with something else on Clara’s side just as well too)"><y>#</y><d>2020-01-07</d><h>15:18</h><w>mikerod</w>(this is all pluggable and could be implemented with something else on Clara’s side just as well too)</z><z id="t1578410327059200" t="mikerod try to Fressian write/read that and see that it returns you the facts in the same structure"><y>#</y><d>2020-01-07</d><h>15:18</h><w>mikerod</w>try to Fressian write/read that and see that it returns you the facts in the same structure</z><z id="t1578410334059400" t="mikerod leaving Clara session/rules out of the test"><y>#</y><d>2020-01-07</d><h>15:18</h><w>mikerod</w>leaving Clara session/rules out of the test</z><z id="t1578410351059600" t="mikerod that may give some insight"><y>#</y><d>2020-01-07</d><h>15:19</h><w>mikerod</w>that may give some insight</z><z id="t1578410413060400" t="Konstantinos Tzanidakis @mikerod simply using the fressian write/read does work correctly in REPL"><y>#</y><d>2020-01-07</d><h>15:20</h><w>Konstantinos Tzanidakis</w>@mikerod simply using the fressian write/read does work correctly in REPL</z><z id="t1578410446061100" t="Konstantinos Tzanidakis yes, I think I will use the nippy as it seems to be something in the fressian side that I cannot track at the moment"><y>#</y><d>2020-01-07</d><h>15:20</h><w>Konstantinos Tzanidakis</w>yes, I think I will use the nippy as it seems to be something in the <code>fressian</code> side that I cannot track at the moment</z><z id="t1578410477061700" t="mikerod &gt; simply using the fressian write/read does work correctly in REPL You’ve analyzed waht is returned? is it still a clj vector with 2 clj maps etc?"><y>#</y><d>2020-01-07</d><h>15:21</h><w>mikerod</w>&gt; simply using the fressian write/read does work correctly in REPL
You’ve analyzed waht is returned? is it still a clj vector with 2 clj maps etc?</z><z id="t1578410484062000" t="Konstantinos Tzanidakis thank you very much for the prompt responses and help!"><y>#</y><d>2020-01-07</d><h>15:21</h><w>Konstantinos Tzanidakis</w>thank you very much for the prompt responses and help!</z><z id="t1578410510062800" t="Konstantinos Tzanidakis @mikerod yes it returns exactly the same facts that are serialized; i.e. a vector of two clj maps"><y>#</y><d>2020-01-07</d><h>15:21</h><w>Konstantinos Tzanidakis</w>@mikerod yes it returns exactly the same facts that are serialized; i.e. a vector of two clj maps</z><z id="t1578410515062900" t="mikerod I’d have to experiment some to look close, can’t right now"><y>#</y><d>2020-01-07</d><h>15:21</h><w>mikerod</w>I’d have to experiment some to look close, can’t right now</z><z id="t1578410599063200" t="mikerod I have some examples in http://www.metasimple.org/2018/02/19/clj-fressian-ext.html"><y>#</y><d>2020-01-07</d><h>15:23</h><w>mikerod</w>I have some examples in <a href="http://www.metasimple.org/2018/02/19/clj-fressian-ext.html" target="_blank">http://www.metasimple.org/2018/02/19/clj-fressian-ext.html</a></z><z id="t1578410605063500" t="mikerod where things don’t work out-of-the-box with conversions and types"><y>#</y><d>2020-01-07</d><h>15:23</h><w>mikerod</w>where things don’t work out-of-the-box with conversions and types</z><z id="t1578410623063700" t="mikerod Under “Default handlers”"><y>#</y><d>2020-01-07</d><h>15:23</h><w>mikerod</w>Under “Default handlers”</z><z id="t1578410639064000" t="mikerod However, didn’t mention anything with vectors/maps there"><y>#</y><d>2020-01-07</d><h>15:23</h><w>mikerod</w>However, didn’t mention anything with vectors/maps there</z><z id="t1578410812064500" t="mikerod I immediately see that types at least aren’t preserved (let [r (serde-obj [{:fact-type :client-representative :name &quot;Alice&quot; :client &quot;Acme&quot;} {:fact-type :support-request :client &quot;Acme&quot; :level :high}])] (type r)) ;;= java.util.Arrays$ArrayList"><y>#</y><d>2020-01-07</d><h>15:26</h><w>mikerod</w>I immediately see that types at least aren’t preserved
<pre>(let [r (serde-obj [{:fact-type :client-representative :name &quot;Alice&quot; :client &quot;Acme&quot;}
                    {:fact-type :support-request :client &quot;Acme&quot; :level :high}])]

  (type r))
;;= java.util.Arrays$ArrayList</pre></z><z id="t1578410829065100" t="mikerod this isn’t immediately meaning Clara wouldn’t accept it - but it is already on shaky ground"><y>#</y><d>2020-01-07</d><h>15:27</h><w>mikerod</w>this isn’t immediately meaning Clara wouldn’t accept it - but it is already on shaky ground</z><z id="t1578410834065200" t="Konstantinos Tzanidakis oh I see"><y>#</y><d>2020-01-07</d><h>15:27</h><w>Konstantinos Tzanidakis</w>oh I see</z><z id="t1578410845065500" t="Konstantinos Tzanidakis @mikerod thank you very much on this!"><y>#</y><d>2020-01-07</d><h>15:27</h><w>Konstantinos Tzanidakis</w>@mikerod thank you very much on this!</z><z id="t1578410873066000" t="mikerod you could attempt to just add the handlers from clara.rules.durability.fressian"><y>#</y><d>2020-01-07</d><h>15:27</h><w>mikerod</w>you could attempt to just add the handlers from <code>clara.rules.durability.fressian</code></z><z id="t1578410895066500" t="mikerod only issue there being you may not want to deal with the “identity preserving” parts potentially"><y>#</y><d>2020-01-07</d><h>15:28</h><w>mikerod</w>only issue there being you may not want to deal with the “identity preserving” parts potentially</z><z id="t1578410934066800" t="mikerod you can see examples https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_fressian.clj#L16"><y>#</y><d>2020-01-07</d><h>15:28</h><w>mikerod</w>you can see examples <a href="https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_fressian.clj#L16" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/test/clojure/clara/test_fressian.clj#L16</a></z><z id="t1578410937067100" t="mikerod of how you’d do that"><y>#</y><d>2020-01-07</d><h>15:28</h><w>mikerod</w>of how you’d do that</z><z id="t1578410941067300" t="Konstantinos Tzanidakis that makes sense"><y>#</y><d>2020-01-07</d><h>15:29</h><w>Konstantinos Tzanidakis</w>that makes sense</z><z id="t1578410966067700" t="mikerod has 2 dynamically scoped bindings you add for it’s internal caching"><y>#</y><d>2020-01-07</d><h>15:29</h><w>mikerod</w>has 2 dynamically scoped bindings you add for it’s internal caching</z><z id="t1578410980068000" t="mikerod you can see it via pform/thread-local-binding"><y>#</y><d>2020-01-07</d><h>15:29</h><w>mikerod</w>you can see it via <code>pform/thread-local-binding</code></z><z id="t1578410993068300" t="mikerod d/node-id-&gt;node-cache doesn’t matter for working memory - so you can leave that off"><y>#</y><d>2020-01-07</d><h>15:29</h><w>mikerod</w><code>d/node-id-&gt;node-cache</code> doesn’t matter for working memory - so you can leave that off</z><z id="t1578411018068800" t="mikerod d/clj-struct-holder is required I’m fairly sure - it is used to preserve object identity during (de)serialization"><y>#</y><d>2020-01-07</d><h>15:30</h><w>mikerod</w><code>d/clj-struct-holder</code> is required I’m fairly sure - it is used to preserve object identity during (de)serialization</z><z id="t1578495530070000" t="bartuka is it possible to remove a rule from a session before firing it? I say that because I have a namespace with 10 rules and I want to run 9 of them. I would prefer to insert all the namespace and remove the single one"><y>#</y><d>2020-01-08</d><h>14:58</h><w>bartuka</w>is it possible to remove a rule from a session before firing it? I say that because I have a namespace with 10 rules and I want to run 9 of them. I would prefer to insert all the namespace and remove the single one</z><z id="t1578500250070800" t="ethanc @iagwanderson, Currently there is no way to add/remove rules from the rulebase after the session has been created"><y>#</y><d>2020-01-08</d><h>16:17</h><w>ethanc</w>@iagwanderson,
Currently there is no way to add/remove rules from the rulebase after the session has been created</z><z id="t1578501473071000" t="bartuka ok, thanks!"><y>#</y><d>2020-01-08</d><h>16:37</h><w>bartuka</w>ok, thanks!</z><z id="t1578501631072000" t="mikerod @iagwanderson as I think you already know you can pass a collection of rules to make a session too. "><y>#</y><d>2020-01-08</d><h>16:40</h><w>mikerod</w>@iagwanderson as I think you already know you can pass a collection of rules to make a session too. </z><z id="t1578501647072500" t="mikerod However it’s more of a “white list”. And you seem to want a “black list” "><y>#</y><d>2020-01-08</d><h>16:40</h><w>mikerod</w>However it’s more of a “white list”. And you seem to want a “black list” </z><z id="t1578501721072800" t="bartuka exactly, just to avoid typing too much"><y>#</y><d>2020-01-08</d><h>16:42</h><w>bartuka</w>exactly, just to avoid typing too much</z><z id="t1578502265075900" t="mikerod You can list rule names in a vector in a var as well with :production-seq metadata. But still doesn’t help you. You can do dynamic stuff to make session to if you use the clara.rules.compiler/mk-session* which is a fn instead of macro"><y>#</y><d>2020-01-08</d><h>16:51</h><w>mikerod</w>You can list rule names in a vector in a var as well with :production-seq metadata. But still doesn’t help you. You can do dynamic stuff to make session to if you use the clara.rules.compiler/mk-session* which is a fn instead of macro</z><z id="t1578502303076900" t="mikerod Doing that you could do some manual dynamic stuff with clj ns-publics where you removed the rules you didn’t want. "><y>#</y><d>2020-01-08</d><h>16:51</h><w>mikerod</w>Doing that you could do some manual dynamic stuff with clj ns-publics where you removed the rules you didn’t want. </z><z id="t1578502321077600" t="bartuka uhmmm... interesting..."><y>#</y><d>2020-01-08</d><h>16:52</h><w>bartuka</w>uhmmm... interesting...</z><z id="t1578502333078100" t="mikerod Or depending on what you’re doing. You could comment out your rule you don’t want and reload ensuring the ns has the old var removed. Hah. "><y>#</y><d>2020-01-08</d><h>16:52</h><w>mikerod</w>Or depending on what you’re doing. You could comment out your rule you don’t want and reload ensuring the ns has the old var removed. Hah. </z><z id="t1578502353078600" t="mikerod With ns-unmap I believe. "><y>#</y><d>2020-01-08</d><h>16:52</h><w>mikerod</w>With ns-unmap I believe. </z><z id="t1578502411079600" t="bartuka hah.. this option is not possible here 😕 but I will try the dynamic one later. This is more a convenience than a requirement right now"><y>#</y><d>2020-01-08</d><h>16:53</h><w>bartuka</w>hah.. this option is not possible here <b>😕</b> but I will try the dynamic one later. This is more a convenience than a requirement right now</z><z id="t1578502441080400" t="bartuka do you think this functionality would be welcome to clara.core? I can try to implement it as a side project here"><y>#</y><d>2020-01-08</d><h>16:54</h><w>bartuka</w>do you think this functionality would be welcome to clara.core? I can try to implement it as a side project here</z><z id="t1578502511081100" t="bartuka I&apos;m making a real investment in this library in my project, so I wish to learn the internals better some time 😃"><y>#</y><d>2020-01-08</d><h>16:55</h><w>bartuka</w>I&apos;m making a real investment in this library in my project, so I wish to learn the internals better some time <b>😃</b></z><z id="t1578504758082900" t="mikerod @iagwanderson it seems reasonable to think there could be support for ignoring certain rules. mk-session supports options so it could be added there perhaps. Or maybe rules could just be marked with metadata when wanting something like this. "><y>#</y><d>2020-01-08</d><h>17:32</h><w>mikerod</w>@iagwanderson it seems reasonable to think there could be support for ignoring certain rules. mk-session supports options so it could be added there perhaps. Or maybe rules could just be marked with metadata when wanting something like this. </z><z id="t1578655532095000" t="bartuka I was thinking in this API: (defrecord Values [id]) (defrule testing-&gt;include [?value &lt;- Values [v] (= ?id (:id v))] =&gt; (println &quot;INCLUDING!!! &quot; ?value)) (defrule testing-&gt;exclude [?value &lt;- Values [v] (= ?id (:id v))] =&gt; (println &quot;EXCLUDING!!! &quot; ?value)) (def session-without (rl/mk-session &apos;clara.rules.compiler/testing-&gt;include &apos;clara.rules.compiler/testing-&gt;exclude :blacklist [&apos;clara.rules.compiler/testing-&gt;exclude]))"><y>#</y><d>2020-01-10</d><h>11:25</h><r>bartuka</r>I was thinking in this  API:

<pre>(defrecord Values [id])

  (defrule testing-&gt;include
    [?value &lt;- Values [v] (= ?id (:id v))]
    =&gt;
    (println &quot;INCLUDING!!! &quot; ?value))

  (defrule testing-&gt;exclude
    [?value &lt;- Values [v] (= ?id (:id v))]
    =&gt;
    (println &quot;EXCLUDING!!! &quot; ?value))

  
  (def session-without (rl/mk-session &apos;clara.rules.compiler/testing-&gt;include
                                      &apos;clara.rules.compiler/testing-&gt;exclude
                                      :blacklist [&apos;clara.rules.compiler/testing-&gt;exclude]))</pre></z><z id="t1578656291095200" t="bartuka I already have a working solution to this problem. I am touching only the clara.rules.compiler/mk-session function. There are many tests namespaces in the project. I was thinking to add a new one with tests to this specific functionality, what you suggests?"><y>#</y><d>2020-01-10</d><h>11:38</h><r>bartuka</r>I already have a working solution to this problem. I am touching only the <code>clara.rules.compiler/mk-session</code> function. There are many tests namespaces in the project. I was thinking to add a new one with tests to this specific functionality, what you suggests?</z><z id="t1578661615095500" t="bartuka Weird, when I add a new test file to the common folder I get this error from lein test command. clojure.lang.ExceptionInfo: failed compiling file:src/test/common/clara/test_common.cljc {:file #object[.File 0x1085a882 &quot;src/test/common/clara/test_common.cljc&quot;]}"><y>#</y><d>2020-01-10</d><h>13:06</h><r>bartuka</r>Weird, when I add a new test file to the <code>common</code> folder I get this error from <code>lein test</code> command.

<pre>clojure.lang.ExceptionInfo: failed compiling file:src/test/common/clara/test_common.cljc {:file #object[.File 0x1085a882 &quot;src/test/common/clara/test_common.cljc&quot;]}</pre></z><z id="t1578648641093700" t="Konstantinos Tzanidakis Hi all, I&apos;m back 🙂 . Sorry for the several questions and thank you very much for all your prompt and very helpful responses; it&apos;s been very enjoyable working with Clara. I am progressing very well in building up the ruling system in Clara however I am getting some OOMs when I surpass a certain number of facts in my application. My application has around 15 rules, some of which are fired by others, and the facts may well range between 300k - 2m, but when I go closer to the upper end I get OOMs. So, I thought that it may be reasonable to run a few benchmark tests (and maybe start profiling?). I tried the clara-benchmark repository and experimented a bit with the AccumInsert test; in this I&apos;ve played with the number of Customers, setting it from 250k to 10m. I noticed that on my machine, Clara threw an OOM above 5m facts. I was wondering whether you have a direction to suggest on methods to cut down such costs? In my application the first try was to chop the initial facts only to the absolutely necessary fields required (I am using clojure maps as extracted from a DB) but without luck. Thank you all in advance!"><y>#</y><d>2020-01-10</d><h>09:30</h><w>Konstantinos Tzanidakis</w>Hi all, I&apos;m back <b>🙂</b> . Sorry for the several questions and thank you very much for all your prompt and very helpful responses; it&apos;s been very enjoyable working with Clara. I am progressing very well in building up the ruling system in Clara however I am getting some OOMs when I surpass a certain number of facts in my application. My application has around 15 rules, some of which are fired by others, and the facts may well range between 300k - 2m, but when I go closer to the upper end I get OOMs. So, I thought that it may be reasonable to run a few benchmark tests (and maybe start profiling?). I tried the <code>clara-benchmark</code> repository and experimented a bit with the <code>AccumInsert</code> test; in this I&apos;ve played with the number of Customers, setting it from 250k to 10m. I noticed that on my machine, Clara threw an OOM above 5m facts. I was wondering whether you have a direction to suggest on methods to cut down such costs? In my application the first try was to chop the initial facts only to the absolutely necessary fields required (I am using clojure maps as extracted from a DB) but without luck. Thank you all in advance!</z><z id="t1578664156096900" t="mikerod @konstantinos562 2m facts themself would be quite a memory burden in the jvm I think. If it’s just memory issues is the heap space you’re giving enough? "><y>#</y><d>2020-01-10</d><h>13:49</h><w>mikerod</w>@konstantinos562 2m facts themself would be quite a memory burden in the jvm I think. If it’s just memory issues is the heap space you’re giving enough? </z><z id="t1578664240099200" t="mikerod You can use a profiler to look more at the memory layout but Clara will certainly take more space than those 2m facts since it has working memory structure it uses on top of what they already take alone. And if you have rules inserting facts based on them. "><y>#</y><d>2020-01-10</d><h>13:50</h><w>mikerod</w>You can use a profiler to look more at the memory layout but Clara will certainly take more space than those 2m facts since it has working memory structure it uses on top of what they already take alone. And if you have rules inserting facts based on them. </z><z id="t1578664280100800" t="mikerod The benchmark stuff would be more aimed at execution time. Which isn’t too useful if you’re running out of memory. If it’s slow it’s probably due to GC thrashing before OOM"><y>#</y><d>2020-01-10</d><h>13:51</h><w>mikerod</w>The benchmark stuff would be more aimed at execution time. Which isn’t too useful if you’re running out of memory. If it’s slow it’s probably due to GC thrashing before OOM</z><z id="t1578664339102400" t="mikerod Or at least that’d hide any other perf issues. "><y>#</y><d>2020-01-10</d><h>13:52</h><w>mikerod</w>Or at least that’d hide any other perf issues. </z><z id="t1578664365102900" t="Konstantinos Tzanidakis Hi @mikerod, yes that&apos;s true, the heap space is set to 4G. I have tried to trim down the facts&apos; fields to the absolute necessary, and now I am considering of using a strategy to reduce the size of facts sent to Clara"><y>#</y><d>2020-01-10</d><h>13:52</h><w>Konstantinos Tzanidakis</w>Hi @mikerod, yes that&apos;s true, the heap space is set to 4G. I have tried to trim down the facts&apos; fields to the absolute necessary, and now I am considering of using a strategy to reduce the size of facts sent to Clara</z><z id="t1578664400103700" t="mikerod @konstantinos562 it’d be good to know how much of the 4G you are using before running the rules "><y>#</y><d>2020-01-10</d><h>13:53</h><w>mikerod</w>@konstantinos562 it’d be good to know how much of the 4G you are using before running the rules </z><z id="t1578664414104200" t="mikerod To gauge how much clara is adding relative to that. "><y>#</y><d>2020-01-10</d><h>13:53</h><w>mikerod</w>To gauge how much clara is adding relative to that. </z><z id="t1578664499106800" t="Konstantinos Tzanidakis Hmmm good question, I haven&apos;t noted this down, although I think it&apos;s relatively low as I start from a clean repl."><y>#</y><d>2020-01-10</d><h>13:54</h><w>Konstantinos Tzanidakis</w>Hmmm good question, I haven&apos;t noted this down, although I think it&apos;s relatively low as I start from a clean repl.</z><z id="t1578664535107900" t="mikerod But the diagnosing the issue will also come down to what you’re rules are doing. If they match too many facts in ways where they are producing factors like n^2 or more rule activations and new fact insertions - I think that already is putting you at quite a lot of objects in memory"><y>#</y><d>2020-01-10</d><h>13:55</h><w>mikerod</w>But the diagnosing the issue will also come down to what you’re rules are doing. If they match too many facts in ways where they are producing factors like n^2 or more rule activations and new fact insertions - I think that already is putting you at quite a lot of objects in memory</z><z id="t1578664536108000" t="Konstantinos Tzanidakis but will note this with VisualVM"><y>#</y><d>2020-01-10</d><h>13:55</h><w>Konstantinos Tzanidakis</w>but will note this with VisualVM</z><z id="t1578664557108600" t="mikerod Visualvm can be good to get some info for this. "><y>#</y><d>2020-01-10</d><h>13:55</h><w>mikerod</w>Visualvm can be good to get some info for this. </z><z id="t1578664582109500" t="Konstantinos Tzanidakis Yes, that is more close to what happening"><y>#</y><d>2020-01-10</d><h>13:56</h><w>Konstantinos Tzanidakis</w>Yes, that is more close to what happening</z><z id="t1578664596110400" t="mikerod Also you can try to just jump heap to like 6G then 8G to get a sense of how much memory it really needs. Of course this may not be acceptable in your production, but for testing "><y>#</y><d>2020-01-10</d><h>13:56</h><w>mikerod</w>Also you can try to just jump heap to like 6G then 8G to get a sense of how much memory it really needs. Of course this may not be acceptable in your production, but for testing </z><z id="t1578664633111600" t="mikerod Also Clara shouldn’t hold references to facts that can never match any rules. "><y>#</y><d>2020-01-10</d><h>13:57</h><w>mikerod</w>Also Clara shouldn’t hold references to facts that can never match any rules. </z><z id="t1578664636111800" t="Konstantinos Tzanidakis I think I will try another pass on the rules in an effort to downsize the domain"><y>#</y><d>2020-01-10</d><h>13:57</h><w>Konstantinos Tzanidakis</w>I think I will try another pass on the rules in an effort to downsize the domain</z><z id="t1578664690113800" t="mikerod So in some situations, if you actually can filter out a bunch of stuff early, you could do some sort of “stream of facts” in a sense. But your calling code would also have to not hold references past inserting them to Clara and firing rules. "><y>#</y><d>2020-01-10</d><h>13:58</h><w>mikerod</w>So in some situations, if you actually can filter out a bunch of stuff early, you could do some sort of “stream of facts” in a sense. But your calling code would also have to not hold references past inserting them to Clara and firing rules. </z><z id="t1578664757114000" t="Konstantinos Tzanidakis I see what you mean"><y>#</y><d>2020-01-10</d><h>13:59</h><w>Konstantinos Tzanidakis</w>I see what you mean</z><z id="t1578664855115700" t="Konstantinos Tzanidakis I am currently retrieving all facts from the DB, which maybe streaming this in Clara without holding a head would make a difference... thanks for the suggestion"><y>#</y><d>2020-01-10</d><h>14:00</h><w>Konstantinos Tzanidakis</w>I am currently retrieving all facts from the DB, which maybe streaming this in Clara without holding a head would make a difference... thanks for the suggestion</z><z id="t1578664915116200" t="mikerod Yeah to not have them all in memory at once I think you’d have to be a bit careful. "><y>#</y><d>2020-01-10</d><h>14:01</h><w>mikerod</w>Yeah to not have them all in memory at once I think you’d have to be a bit careful. </z><z id="t1578664956117700" t="mikerod Not sure something like insert-all would be careful enough within Clara. Would probably have to like near N number at a time, then fire rules. Then repeat the next batch"><y>#</y><d>2020-01-10</d><h>14:02</h><w>mikerod</w>Not sure something like insert-all would be careful enough within Clara. Would probably have to like near N number at a time, then fire rules. Then repeat the next batch</z><z id="t1578664981118600" t="mikerod But if they are mostly matching or even “partial matching” rules they will be held in memory. So it can be brittle "><y>#</y><d>2020-01-10</d><h>14:03</h><w>mikerod</w>But if they are mostly matching or even “partial matching” rules they will be held in memory. So it can be brittle </z><z id="t1578665027120200" t="mikerod A fact is held in memory if it can even “potentially” be used to satisfy a rule later. That’s the “partial match” "><y>#</y><d>2020-01-10</d><h>14:03</h><w>mikerod</w>A fact is held in memory if it can even “potentially” be used to satisfy a rule later. That’s the “partial match” </z><z id="t1578665034120400" t="Konstantinos Tzanidakis (I was just checking insert-all&apos;s source, as this is what I am using to insert facts - but will need to check a bit more carefully on the DB side too)"><y>#</y><d>2020-01-10</d><h>14:03</h><w>Konstantinos Tzanidakis</w>(I was just checking insert-all&apos;s source, as this is what I am using to insert facts - but will need to check a bit more carefully on the DB side too)</z><z id="t1578665052121000" t="mikerod Which intuitively makes sense. Since it may be needed later when new facts come. "><y>#</y><d>2020-01-10</d><h>14:04</h><w>mikerod</w>Which intuitively makes sense. Since it may be needed later when new facts come. </z><z id="t1578665075121700" t="Konstantinos Tzanidakis Makes sense yeah"><y>#</y><d>2020-01-10</d><h>14:04</h><w>Konstantinos Tzanidakis</w>Makes sense yeah</z><z id="t1578665080121800" t="mikerod But yeah my first thought would be the original stuff I said. Understand memory use a bit more. "><y>#</y><d>2020-01-10</d><h>14:04</h><w>mikerod</w>But yeah my first thought would be the original stuff I said. Understand memory use a bit more. </z><z id="t1578665264122200" t="Konstantinos Tzanidakis Thanks a bunch @mikerod"><y>#</y><d>2020-01-10</d><h>14:07</h><w>Konstantinos Tzanidakis</w>Thanks a bunch @mikerod</z><z id="t1578665437122900" t="bartuka hi @mikerod, I am trying to run the tests from clara repository and I keep receiving this error: clojure.lang.ExceptionInfo: failed compiling file:src/test/common/clara/test_common.cljc {:file #object[.File 0x1085a882 &quot;src/test/common/clara/test_common.cljc&quot;]}"><y>#</y><d>2020-01-10</d><h>14:10</h><w>bartuka</w>hi @mikerod, I am trying to run the tests from clara repository and I keep receiving this error:

<pre>clojure.lang.ExceptionInfo: failed compiling file:src/test/common/clara/test_common.cljc {:file #object[.File 0x1085a882 &quot;src/test/common/clara/test_common.cljc&quot;]}</pre></z><z id="t1578665475123700" t="bartuka there is any setup I need to do when adding a new test namespace?"><y>#</y><d>2020-01-10</d><h>14:11</h><w>bartuka</w>there is any setup I need to do when adding a new test namespace?</z><z id="t1578665487124000" t="bartuka Caused by: java.lang.RuntimeException: Unable to resolve symbol: test-rule in this context"><y>#</y><d>2020-01-10</d><h>14:11</h><w>bartuka</w><pre>Caused by: java.lang.RuntimeException: Unable to resolve symbol: test-rule in this context</pre></z><z id="t1578665566125300" t="mikerod @iagwanderson are you working with clj or cljs for this? And explain what you’re doing a bit more. You added new test ns? How are you trying to run them? "><y>#</y><d>2020-01-10</d><h>14:12</h><w>mikerod</w>@iagwanderson are you working with clj or cljs for this? And explain what you’re doing a bit more. You added new test ns? How are you trying to run them? </z><z id="t1578665635126500" t="bartuka I am working with clj, but as I see it should work with cljs as well. I created a file called test_blacklist.cljc inside the test/common/clara directory"><y>#</y><d>2020-01-10</d><h>14:13</h><w>bartuka</w>I am working with clj, but as I see it should work with cljs as well. I created a file called <code>test_blacklist.cljc</code> inside the <code>test/common/clara</code> directory</z><z id="t1578665654127000" t="bartuka and I tried to run using a simple lein test which runs fine if I remove my new namespace"><y>#</y><d>2020-01-10</d><h>14:14</h><w>bartuka</w>and I tried to run using a simple <code>lein test</code> which runs fine if I remove my new namespace</z><z id="t1578666041127600" t="bartuka I tried to run the lein test again only with this new empty namespace and I got this error msg already"><y>#</y><d>2020-01-10</d><h>14:20</h><w>bartuka</w>I tried to run the lein test again only with this new empty namespace and I got this error msg already</z><z id="t1578673815128000" t="mikerod @iagwanderson I’d have to see your changes I think at this point to help"><y>#</y><d>2020-01-10</d><h>16:30</h><w>mikerod</w>@iagwanderson I’d have to see your changes I think at this point to help</z><z id="t1578676633128700" t="bartuka This repository has the changes and the test file: https://github.com/wandersoncferreira/clara-rules"><y>#</y><d>2020-01-10</d><h>17:17</h><w>bartuka</w>This repository has the changes and the test file: <a href="https://github.com/wandersoncferreira/clara-rules" target="_blank">https://github.com/wandersoncferreira/clara-rules</a></z><z id="t1578676738129400" t="bartuka I changed the compiler.clj file"><y>#</y><d>2020-01-10</d><h>17:18</h><w>bartuka</w>I changed the <code>compiler.clj</code>  file</z><z id="t1578676849130100" t="bartuka https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/main/clojure/clara/rules/compiler.clj#L2040"><y>#</y><d>2020-01-10</d><h>17:20</h><w>bartuka</w><a href="https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/main/clojure/clara/rules/compiler.clj#L2040" target="_blank">https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/main/clojure/clara/rules/compiler.clj#L2040</a></z><z id="t1578676893130400" t="bartuka and my test file: https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/test/common/clara/test_blacklist.cljc"><y>#</y><d>2020-01-10</d><h>17:21</h><w>bartuka</w>and my test file:

<a href="https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/test/common/clara/test_blacklist.cljc" target="_blank">https://github.com/wandersoncferreira/clara-rules/blob/ede84e40a0f9671544ce4ab349e7e6735ab151e0/src/test/common/clara/test_blacklist.cljc</a></z><z id="t1578679011130900" t="mikerod Thanks. I’ll take a look in a few. "><y>#</y><d>2020-01-10</d><h>17:56</h><w>mikerod</w>Thanks. I’ll take a look in a few. </z><z id="t1578693109132400" t="bartuka Ok, thanks. There is no clear relationship between my implementation and the error messages"><y>#</y><d>2020-01-10</d><h>21:51</h><w>bartuka</w>Ok, thanks. There is no clear relationship between my implementation and the error messages</z><z id="t1578693788133100" t="mikerod @iagwanderson you need to use def-rules-test for cross platform “common” tests "><y>#</y><d>2020-01-10</d><h>22:03</h><w>mikerod</w>@iagwanderson you need to use def-rules-test for cross platform “common” tests </z><z id="t1578693816133400" t="mikerod That may be your issue"><y>#</y><d>2020-01-10</d><h>22:03</h><w>mikerod</w>That  may be your issue</z><z id="t1578693830133900" t="mikerod Look at another test ns in that dir to see it used. "><y>#</y><d>2020-01-10</d><h>22:03</h><w>mikerod</w>Look at another test ns in that dir to see it used. </z><z id="t1578693838134400" t="mikerod It’s used in all the rule sort of tests there. "><y>#</y><d>2020-01-10</d><h>22:03</h><w>mikerod</w>It’s used in all the rule sort of tests there. </z><z id="t1578693869135800" t="bartuka Uhmm... Ok. I will make this change."><y>#</y><d>2020-01-10</d><h>22:04</h><w>bartuka</w>Uhmm... Ok. I will make this change.</z><z id="t1578920898145800" t="wparker For some background, in Clojure Clara can create sessions on the fly using eval, while in ClojureScript sessions have to be defined at compilation time typically using a call to defsession at the top level. The dynamic session building in Clojure ultimately uses eval, which is why it doesn&apos;t work in ClojureScript. Defsession-test essentially makes the static session building in ClojureScript tests look more dynamic without needing to create tons of top-level defs etc."><y>#</y><d>2020-01-13</d><h>13:08</h><r>wparker</r>For some background, in Clojure Clara can create sessions on the fly using eval, while in ClojureScript sessions have to be defined at compilation time typically using a call to defsession at the top level.  The dynamic session building in Clojure ultimately uses eval, which is why it doesn&apos;t work in ClojureScript.  Defsession-test essentially makes the static session building in ClojureScript tests look more dynamic without needing to create tons of top-level defs etc.</z><z id="t1578958418147000" t="bartuka interesting!! I noticed during my tests that in these cases I should uses only the names of the rules that I was filtering inside the mk-session I was thinking that is was going to create the name with my current namespace in it"><y>#</y><d>2020-01-13</d><h>23:33</h><r>bartuka</r>interesting!! I noticed during my tests that in these cases I should uses only the names of the rules that I was filtering inside the <code>mk-session</code> I was thinking that is was going to create the name with my current namespace in it</z><z id="t1578693873136000" t="mikerod Can’t say it’s certainly the issue. But likely. I can’t remember without looking a bit more "><y>#</y><d>2020-01-10</d><h>22:04</h><w>mikerod</w>Can’t say it’s certainly the issue. But likely. I can’t remember without looking a bit more </z><z id="t1578693898136800" t="mikerod There are differences in how you would set this up in clj vs cljs. "><y>#</y><d>2020-01-10</d><h>22:04</h><w>mikerod</w>There are differences in how you would set this up in clj vs cljs. </z><z id="t1578693910137300" t="mikerod So the test helper makes that not an issue"><y>#</y><d>2020-01-10</d><h>22:05</h><w>mikerod</w>So the test helper makes that not an issue</z><z id="t1578693915137500" t="mikerod For portable test"><y>#</y><d>2020-01-10</d><h>22:05</h><w>mikerod</w>For portable test</z><z id="t1578693943138700" t="bartuka I never did cljc before, so I was betting on something related to that"><y>#</y><d>2020-01-10</d><h>22:05</h><w>bartuka</w>I never did cljc before, so I was betting on something related to that</z><z id="t1578694001139400" t="bartuka I will make the test work and open a PR for discussions around the implementation"><y>#</y><d>2020-01-10</d><h>22:06</h><w>bartuka</w>I will make the test work and open a PR for discussions around the implementation</z><z id="t1578695053141600" t="bartuka @mikerod looks like the Compiling [&quot;resources/public/js/simple.js&quot;] failed. because in the cljs_deps.js does not have definitions for my new file added"><y>#</y><d>2020-01-10</d><h>22:24</h><w>bartuka</w>@mikerod looks like the <code>Compiling [&quot;resources/public/js/simple.js&quot;] failed.</code> because in the <code>cljs_deps.js</code> does not have definitions for my new file added</z><z id="t1578695692142300" t="bartuka fixed, lein do clean, compile 😃"><y>#</y><d>2020-01-10</d><h>22:34</h><w>bartuka</w>fixed, <code>lein do clean, compile</code>  <b>😃</b></z><z id="t1578696689143300" t="mikerod Yeah. I have a long standing issue to improve the cljs setup and build stuff. But it is involved. So for now have to work with this stuff as it is. "><y>#</y><d>2020-01-10</d><h>22:51</h><w>mikerod</w>Yeah. I have a long standing issue to improve the cljs setup and build stuff. But it is involved. So for now have to work with this stuff as it is. </z><z id="t1578751784143800" t="bartuka Thanks for all the help @mikerod I opened a PR https://github.com/cerner/clara-rules/pull/445"><y>#</y><d>2020-01-11</d><h>14:09</h><w>bartuka</w>Thanks for all the help @mikerod I opened a PR <a href="https://github.com/cerner/clara-rules/pull/445" target="_blank">https://github.com/cerner/clara-rules/pull/445</a></z><z id="t1578754212144500" t="mikerod @iagwanderson nice. I’ll check it out "><y>#</y><d>2020-01-11</d><h>14:50</h><w>mikerod</w>@iagwanderson nice. I’ll check it out </z><z id="t1578915639145500" t="bartuka hi, you guys have customized cider to understand rules indentation correctly?"><y>#</y><d>2020-01-13</d><h>11:40</h><w>bartuka</w>hi, you guys have customized cider to understand rules indentation correctly?</z><z id="t1578922395146000" t="wparker I don’t, I think some others may have experimented with it as well as an attempt to format/highlight in Cursive. I’ve personally just used newlines for new conditions and Cider indents that well enough that it hasn’t bothered me."><y>#</y><d>2020-01-13</d><h>13:33</h><r>wparker</r>I don’t, I think some others may have experimented with it as well as an attempt to format/highlight in Cursive.  I’ve personally just used newlines for new conditions and Cider indents that well enough that it hasn’t bothered me.</z><z id="t1578922405146200" t="wparker Is there something in particular that looks strange to you?"><y>#</y><d>2020-01-13</d><h>13:33</h><r>wparker</r>Is there something in particular that looks strange to you?</z><z id="t1578954108146400" t="bartuka the default indentation looks like this:"><y>#</y><d>2020-01-13</d><h>22:21</h><r>bartuka</r>the default indentation looks like this:</z><z id="t1578954113146600" t="bartuka (defrule rule-&gt;legacy-contract? &quot;Add a Legacy fact into the session if the contract was sent with this status.&quot; [?contract &lt;- Contract [ct] (= ?principal-external-id (:contract/principal-external-id ct)) (= :legacy (:contract/status ct))] =&gt; (insert! (-&gt;Legacy ?principal-external-id)))"><y>#</y><d>2020-01-13</d><h>22:21</h><r>bartuka</r><pre>(defrule rule-&gt;legacy-contract?
  &quot;Add a Legacy fact into the session if the contract was sent with this status.&quot;
  [?contract &lt;- Contract [ct] (= ?principal-external-id (:contract/principal-external-id ct))
   (= :legacy (:contract/status ct))]
  =&gt;
  (insert! (-&gt;Legacy ?principal-external-id)))</pre></z><z id="t1578954145146800" t="bartuka and I have to manually change it to: (defrule rule-&gt;legacy-contract? &quot;Add a Legacy fact into the session if the contract was sent with this status.&quot; [?contract &lt;- Contract [ct] (= ?principal-external-id (:contract/principal-external-id ct)) (= :legacy (:contract/status ct))] =&gt; (insert! (-&gt;Legacy ?principal-external-id)))"><y>#</y><d>2020-01-13</d><h>22:22</h><r>bartuka</r>and I have to manually change it to:

<pre>(defrule rule-&gt;legacy-contract?
  &quot;Add a Legacy fact into the session if the contract was sent with this status.&quot;
  [?contract &lt;- Contract [ct] (= ?principal-external-id (:contract/principal-external-id ct))
                              (= :legacy (:contract/status ct))]
  =&gt;
  (insert! (-&gt;Legacy ?principal-external-id)))</pre></z><z id="t1578958471147200" t="bartuka sometimes I need to use M-x align-regexp (= to align the conditions"><y>#</y><d>2020-01-13</d><h>23:34</h><r>bartuka</r>sometimes I need to use <code>M-x align-regexp (=</code> to align the conditions</z><z id="t1579090983156000" t="mbragg Hi. Im evaluating potentially using Clara for one of our use cases. Can you imagine a sensible way to be able to determine the start-time and end-time of a given rule execution? Say I have a rule that has some expensive operation… I’d like to be able to record when it started and ended, ideally without adding the required code to the rule itself and adding the values to the emitted fact (as it would be great if all rules exposed this information implicitly). I’ve started looked into: • The inspect + trace tools dont seem to provide it • Creating a new Listener, but this may be a bad idea given it would no longer be immutable if its calling out for the current time? • Creating a macro and extend the parsing logic to wrap the rule execution somehow Any thoughts / suggestions appreciated. Many thanks"><y>#</y><d>2020-01-15</d><h>12:23</h><w>mbragg</w>Hi. Im evaluating potentially using Clara for one of our use cases. Can you imagine a sensible way to be able to determine the start-time and end-time of a given rule execution? Say I have a rule that has some expensive operation… I’d like to be able to record when it started and ended, ideally without adding the required code to the rule itself and adding the values to the emitted fact (as it would be great if all rules exposed this information implicitly). I’ve started looked into:
• The inspect + trace tools dont seem to provide it
• Creating a new Listener, but this may be a bad idea given it would no longer be immutable if its calling out for the current time?
• Creating a macro and extend the parsing logic to wrap the rule execution somehow
Any thoughts / suggestions appreciated. Many thanks</z><z id="t1579108201157000" t="mikerod @mbragg I don’t think it’s as straightforward as perhaps it seems. Rules aren’t the same as something like a fn body that you can time"><y>#</y><d>2020-01-15</d><h>17:10</h><w>mikerod</w>@mbragg I don’t think it’s as straightforward as perhaps it seems. Rules aren’t the same as something like a fn body that you can time</z><z id="t1579108234157800" t="mikerod The rules are structures that are used to create a rete based data flow tree (forest really)"><y>#</y><d>2020-01-15</d><h>17:10</h><w>mikerod</w>The rules are structures that are used to create a rete based data flow tree (forest really)</z><z id="t1579108360160800" t="mikerod Some examples of the complexity: (1) In some cases LHS conditions from separate rules may end up being shared as one common node in this tree. (2) rule conditions are nodes on the tree. They have varying degrees of eager vs lazy behavior. In most cases, the engine tries to batch facts up prior to evaluation of conditions "><y>#</y><d>2020-01-15</d><h>17:12</h><w>mikerod</w>Some examples of the complexity:

(1) In some cases LHS conditions from separate rules may end up being shared as one common node in this tree. 

(2) rule conditions are nodes on the tree. They have varying degrees of eager vs lazy behavior. In most cases, the engine tries to batch facts up prior to evaluation of conditions 

</z><z id="t1579108421162200" t="mikerod (3) before fire-rules happens a certain degree of evaluation takes place. Once fire-rules happens more work is done but always oriented towards batched fact propagation. "><y>#</y><d>2020-01-15</d><h>17:13</h><w>mikerod</w>(3) before fire-rules happens a certain degree of evaluation takes place. Once fire-rules happens more work is done but always oriented towards batched fact propagation. </z><z id="t1579108486163700" t="mikerod The inspection/trace stuff can be useful to get a sense of how many times a condition is being evaluated/matched. This tends to just give a relative “count” to compare and often find the outliers. "><y>#</y><d>2020-01-15</d><h>17:14</h><w>mikerod</w>The inspection/trace stuff can be useful to get a sense of how many times a condition is being evaluated/matched. This tends to just give a relative “count” to compare and often find the outliers. </z><z id="t1579108561165400" t="mikerod But overall. The rules are more like “sql query structures” where they are then compiled to a network, like the “db eval plan”"><y>#</y><d>2020-01-15</d><h>17:16</h><w>mikerod</w>But overall. The rules are more like “sql query structures” where they are then compiled to a network, like the “db eval plan”</z><z id="t1579108583166100" t="mikerod So the concerns tend to be things like how many times is this “join condition” being evaluated given some facts. "><y>#</y><d>2020-01-15</d><h>17:16</h><w>mikerod</w>So the concerns tend to be things like how many times is this “join condition” being evaluated given some facts. </z><z id="t1579108751169200" t="mikerod With profiling you can find actually hot spot functions which sometimes end up being a fn used in a condition that is being evaluated a large number of times: [MyFact (my-fn ...)] If that condition has a large number of matches you may profile and see my-fn is a hot spot and looking to be a perf issue."><y>#</y><d>2020-01-15</d><h>17:19</h><w>mikerod</w>With profiling you can find actually hot spot functions which sometimes end up being a fn used in a condition that is being evaluated a large number of times:
<pre>[MyFact (my-fn ...)]</pre>
If that condition has a large number of matches you may profile and see <code>my-fn</code> is a hot spot and looking to be a perf issue.</z><z id="t1579110385171900" t="mbragg Thanks @mikerod for the explanation, makes sense. I guess I was specifically meaning everything in the RHS do block for a given rule. But I can see it may not be that straight forward... especially if there’s batching involved. "><y>#</y><d>2020-01-15</d><h>17:46</h><w>mbragg</w>Thanks @mikerod for the explanation, makes sense. I guess I was specifically meaning everything in the RHS do block for a given rule. But I can see it may not be that straight forward... especially if there’s batching involved. </z><z id="t1579128177193000" t="wparker In case a concrete demonstration helps for clarity, the rule RHS calls like insert! add things to a cache that will be processed later (the details of that probably aren’t super important here), the default implementation of which is in this file: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/update_cache/core.cljc It’s certainly possible to have a poorly-performing function called in a rule, for which profiling with something like VisualVM can be useful, but a simple timer isn’t necessarily much help with diagnosing poorly performing rules networks as Mike has elaborated on."><y>#</y><d>2020-01-15</d><h>22:42</h><r>wparker</r>In case a concrete demonstration helps for clarity, the rule RHS calls like insert! add things to a cache that will be processed later (the details of that probably aren’t super important here), the default implementation of which is in this file: <a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/update_cache/core.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/update_cache/core.cljc</a> It’s certainly possible to have a poorly-performing function called in a rule, for which profiling with something like VisualVM can be useful, but a simple timer isn’t necessarily much help with diagnosing poorly performing rules networks as Mike has elaborated on.</z><z id="t1579190903201800" t="mbragg Thanks @U0KRSVDHR "><y>#</y><d>2020-01-16</d><h>16:08</h><r>mbragg</r>Thanks @U0KRSVDHR </z><z id="t1579110551172100" t="mikerod @mbragg the RHS is easier to time at least"><y>#</y><d>2020-01-15</d><h>17:49</h><w>mikerod</w>@mbragg the RHS is easier to time at least</z><z id="t1579110570172600" t="mikerod I mean you can wrap that fairly easily - but still the time it takes to do the insert! sort of functions is where the batching happens"><y>#</y><d>2020-01-15</d><h>17:49</h><w>mikerod</w>I mean you can wrap that fairly easily - but still the time it takes to do the <code>insert!</code> sort of functions is where the batching happens</z><z id="t1579110599173200" t="mikerod so you if you’re RHS is: (insert! (-&gt;Something ?x)) timing it won’t necessarily tell you much"><y>#</y><d>2020-01-15</d><h>17:49</h><w>mikerod</w>so you if you’re RHS is:
<pre>(insert! (-&gt;Something ?x))</pre>
timing it won’t necessarily tell you much</z><z id="t1579110631173800" t="mikerod that same RHS may end up being activated N times - so it evaluates N times, and you have N insert! calls all batched, so no fact is actually inserted right away until a later cycle"><y>#</y><d>2020-01-15</d><h>17:50</h><w>mikerod</w>that same RHS may end up being activated N times - so it evaluates N times, and you have N <code>insert!</code> calls all batched, so no fact is actually inserted right away until a later cycle</z><z id="t1579110665174400" t="mikerod the batching is very useful from a perf standpoint too - but does complicate timing things"><y>#</y><d>2020-01-15</d><h>17:51</h><w>mikerod</w>the batching is very useful from a perf standpoint too - but does complicate timing things</z><z id="t1579113762177800" t="mbragg @mikerod ok understood. It think I’m going to suggest that this “rule timing” requirement is something we drop if we go with Clara, as it sounds like it doesn’t really make sense... in the way they are imagining rules being executed anyway. Thanks for all your help "><y>#</y><d>2020-01-15</d><h>18:42</h><w>mbragg</w>@mikerod ok understood. It think I’m going to suggest that this “rule timing” requirement is something we drop if we go with Clara, as it sounds like it doesn’t really make sense... in the way they are imagining rules being executed anyway. Thanks for all your help </z><z id="t1579114074179000" t="Matthew Pettis In a defrule RHS, when making a record to insert, is there a way to access the rule name (the symbol associated with the rule that is firing) to store as a field in the inserted fact?"><y>#</y><d>2020-01-15</d><h>18:47</h><w>Matthew Pettis</w>In a defrule RHS, when making a record to insert, is there a way to access the rule name (the symbol associated with the rule that is firing) to store as a field in the inserted fact?</z><z id="t1579114346179800" t="mikerod @matthew.pettis I suppose you want this instead of being repetitive? (defrule my-rule =&gt; (insert! (-&gt;MyFact `my-rule))"><y>#</y><d>2020-01-15</d><h>18:52</h><w>mikerod</w>@matthew.pettis I suppose you want this instead of being repetitive?
<pre>(defrule my-rule
=&gt;
(insert! (-&gt;MyFact `my-rule))</pre></z><z id="t1579114500181700" t="Matthew Pettis Yeah, right now I&apos;m copying the name as the rule as a string in the creation of MyFact , so if there is a way to resolve the name of the rule in which the insert is operating that&apos;s what I&apos;m looking for (so, as you said, I&apos;m not repetitive in the sense of mis-copypasting the rule name into the string...)"><y>#</y><d>2020-01-15</d><h>18:55</h><w>Matthew Pettis</w>Yeah, right now I&apos;m copying the name as the rule as a string in the creation of <code>MyFact</code> , so if there is a way to resolve the name of the rule in which the insert is operating that&apos;s what I&apos;m looking for (so, as you said, I&apos;m not repetitive in the sense of mis-copypasting the rule name into the string...)</z><z id="t1579114621181800" t="Matthew Pettis Thinking of something like this, so I can use the same insert statement and not have to copy in the rulename somehow..."><y>#</y><d>2020-01-15</d><h>18:57</h><w>Matthew Pettis</w>Thinking of something like this, so I can use the same insert statement and not have to copy in the rulename somehow...</z><z id="t1579115146182400" t="mikerod @matthew.pettis have to look to think if anything is directly available"><y>#</y><d>2020-01-15</d><h>19:05</h><w>mikerod</w>@matthew.pettis have to look to think if anything is directly available</z><z id="t1579115152182700" t="mikerod however, you can always opt to make your own macro"><y>#</y><d>2020-01-15</d><h>19:05</h><w>mikerod</w>however, you can always opt to make your own macro</z><z id="t1579115195184200" t="mikerod defrule itself is just a macro and rules and queries in Clara are all modeled in a data-oriented data structure underneath that alternative DSL’s can be written to produce (via macros typically)"><y>#</y><d>2020-01-15</d><h>19:06</h><w>mikerod</w><code>defrule</code> itself is just a macro and rules and queries in Clara are all modeled in a data-oriented data structure underneath that alternative DSL’s can be written to produce (via macros typically)</z><z id="t1579115197184300" t="Matthew Pettis OK. A macro implementation might be in line for me too."><y>#</y><d>2020-01-15</d><h>19:06</h><w>Matthew Pettis</w>OK.  A macro implementation might be in line for me too.</z><z id="t1579115204184600" t="mikerod or you can have a macro that expands to defrule for your case"><y>#</y><d>2020-01-15</d><h>19:06</h><w>mikerod</w>or you can have a macro that expands to <code>defrule</code> for your case</z><z id="t1579115273186300" t="Matthew Pettis I think I may follow the custom macro expansion to defrule, thanks. Was just wondering if it was a common need and something was built in that I was missing..."><y>#</y><d>2020-01-15</d><h>19:07</h><w>Matthew Pettis</w>I think I may follow the custom macro expansion to defrule, thanks.  Was just wondering if it was a common need and something was built in that I was missing...</z><z id="t1579115290186700" t="mikerod an old (and probably no longer able to run examples) post, that did give a good overview of alterantive DSL’s http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/ just for reference if that concept is something you find further interest in - you don’t really need it for this small case"><y>#</y><d>2020-01-15</d><h>19:08</h><w>mikerod</w>an old (and probably no longer able to run examples) post, that did give a good overview of alterantive DSL’s <a href="http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/" target="_blank">http://www.toomuchcode.org/blog/2015/11/14/insta-declarative-dsls/</a> just for reference if that concept is something you find further interest in - you don’t really need it for this small case</z><z id="t1579115462187200" t="mikerod I don’t see anything built-in as of now"><y>#</y><d>2020-01-15</d><h>19:11</h><w>mikerod</w>I don’t see anything built-in as of now</z><z id="t1579115571187900" t="mikerod I have came across a similar use-case in the past. I think I just repeated the name basically - I believe I used keywordized version instead though"><y>#</y><d>2020-01-15</d><h>19:12</h><w>mikerod</w>I have came across a similar use-case in the past. I think I just repeated the name basically - I believe I used keywordized version instead though</z><z id="t1579115578188200" t="mikerod but can be error-prone indeed"><y>#</y><d>2020-01-15</d><h>19:12</h><w>mikerod</w>but can be error-prone indeed</z><z id="t1579115641189500" t="mikerod I’ve also done alternative DSLs that compile to underlying rule structures though in some cases where there was more to it"><y>#</y><d>2020-01-15</d><h>19:14</h><w>mikerod</w>I’ve also done alternative DSLs that compile to underlying rule structures though in some cases where there was more to it</z><z id="t1579115809192000" t="Matthew Pettis I like the macro wrapper for the cases where I want to insert a fact tracking what rule was fired. And, yeah, in my use case, I was thinking of using rule firing to track all of the rules that were fired on a given fact. This is like using rules as a way to track all of the ways a fact can violate rules without making a big conditional statement that checks all conditions and logs that observation."><y>#</y><d>2020-01-15</d><h>19:16</h><w>Matthew Pettis</w>I like the macro wrapper for the cases where I want to insert a fact tracking what rule was fired.  And, yeah, in my use case, I was thinking of using rule firing to track all of the rules that were fired on a given fact.  This is like using rules as a way to track all of the ways a fact can violate rules without making a big conditional statement that checks all conditions and logs that observation.</z><z id="t1579116287192200" t="mikerod Yeah that makes sense "><y>#</y><d>2020-01-15</d><h>19:24</h><w>mikerod</w>Yeah that makes sense </z><z id="t1579141745195900" t="Matthew Pettis I&apos;m having some trouble with understanding the mk-session function documentation ( http://www.clara-rules.org/apidocs/0.20.0/clojure/clara.rules.html#var-mk-session ). In particular, it references rule sources . Are those namespaces that the rules live in (if they aren&apos;t in the current namespace)? I&apos;m wondering what the alternative ways there are to giving rules to a session if you don&apos;t use defrule in the current namespace. Can you construct a vector of rules (that don&apos;t have names) that you&apos;d get from defrule and feed it to a session?"><y>#</y><d>2020-01-16</d><h>02:29</h><w>Matthew Pettis</w>I&apos;m having some trouble with understanding the <code>mk-session</code> function documentation (<a href="http://www.clara-rules.org/apidocs/0.20.0/clojure/clara.rules.html#var-mk-session" target="_blank">http://www.clara-rules.org/apidocs/0.20.0/clojure/clara.rules.html#var-mk-session</a>).  In particular, it references <code>rule sources</code>.  Are those namespaces that the rules live in (if they aren&apos;t in the current namespace)?  I&apos;m wondering what the alternative ways there are to giving rules to a session if you don&apos;t use <code>defrule</code> in the current namespace.  Can you construct a vector of rules (that don&apos;t have names) that you&apos;d get from <code>defrule</code> and feed it to a session?</z><z id="t1579149200197000" t="mikerod @matthew.pettis you can pass a collection of rules and queries"><y>#</y><d>2020-01-16</d><h>04:33</h><w>mikerod</w>@matthew.pettis you can pass a collection of rules and queries</z><z id="t1579149213197300" t="mikerod So a vector yes"><y>#</y><d>2020-01-16</d><h>04:33</h><w>mikerod</w>So a vector yes</z><z id="t1579149259198300" t="mikerod If you pass an ns name it’ll be automatically expanded to a collection of all rules sources within it"><y>#</y><d>2020-01-16</d><h>04:34</h><w>mikerod</w>If you pass an ns name it’ll be automatically expanded to a collection of all rules sources within it</z><z id="t1579149274198800" t="mikerod Rule sources are defined by a protocol "><y>#</y><d>2020-01-16</d><h>04:34</h><w>mikerod</w>Rule sources are defined by a protocol </z><z id="t1579149308199600" t="mikerod There are a few more built in impls but those are the main 2"><y>#</y><d>2020-01-16</d><h>04:35</h><w>mikerod</w>There are a few more built in impls but those are the main 2</z><z id="t1579149376201200" t="mikerod And “rule” is a bit overloaded here unfortunately since it includes queries. Clara typically calls them “productions” when referring generally to both. "><y>#</y><d>2020-01-16</d><h>04:36</h><w>mikerod</w>And “rule” is a bit overloaded here unfortunately since it includes queries. Clara typically calls them “productions” when referring generally to both. </z><z id="t1579576154002600" t="Matthew Pettis Are there any examples out there that show how to define a session in the namespace project.a , define facts in namespace project.b , rules in project.c , and how to import b and c into a to fire rules on them? I&apos;m struggling because I&quot;m sure I don&apos;t have namespace usage well..."><y>#</y><d>2020-01-21</d><h>03:09</h><w>Matthew Pettis</w>Are there any examples out there that show how to define a session in the namespace <code>project.a</code>, define facts in namespace <code>project.b</code> , rules in <code>project.c</code> , and how to import <code>b</code> and <code>c</code> into <code>a</code> to fire rules on them?  I&apos;m struggling because I&quot;m sure I don&apos;t have namespace usage well...</z><z id="t1579576266003500" t="Matthew Pettis My two files which fails (I&quot;m looking only at importing rules for this examples, not yet facts):"><y>#</y><d>2020-01-21</d><h>03:11</h><w>Matthew Pettis</w>My two files which fails (I&quot;m looking only at importing rules for this examples, not yet facts):</z><z id="t1579576300003600" t="Matthew Pettis The session namespace..."><y>#</y><d>2020-01-21</d><h>03:11</h><w>Matthew Pettis</w>The session namespace...</z><z id="t1579576333003900" t="Matthew Pettis The rule namespace I want to import from..."><y>#</y><d>2020-01-21</d><h>03:12</h><w>Matthew Pettis</w>The rule namespace I want to import from...</z><z id="t1579576887004500" t="Matthew Pettis The error I get:"><y>#</y><d>2020-01-21</d><h>03:21</h><w>Matthew Pettis</w>The error I get:</z><z id="t1579577381009500" t="ethanc @matthew.pettis I believe you would want to import the fact into the namespace where the rule is using it: (ns clara-lein.ex06rulesns (:require [clara.rules :refer :all] [clara-lein.ex06 :as ex06]) (:import [clara-lein.ex06 Myfact])) ;; Rules namespace for rules for ex06. ;; Define rules (defrule rule-1 &quot;Rule-1 in rulesns&quot; [Myfact (= ?size size)] [:test (&gt; 1 ?size)] =&gt; (insert! (ex06/-&gt;Rulefail &quot;rule-1&quot; ?size))) Though this might lead to issues with cyclical dependencies, with the session ns and rules ns. It might be practical to pull the fact definitions out into a separate ns so that they can be pulled by both ns without the possibility of a cycle."><y>#</y><d>2020-01-21</d><h>03:29</h><w>ethanc</w>@matthew.pettis
I believe you would want to import the fact into the namespace where the rule is using it:
<pre>(ns clara-lein.ex06rulesns
  (:require [clara.rules :refer :all] 
            [clara-lein.ex06 :as ex06])
  (:import [clara-lein.ex06 Myfact]))
;; Rules namespace for rules for ex06.
;; Define rules
(defrule rule-1
  &quot;Rule-1 in rulesns&quot;
  [Myfact (= ?size size)]
  [:test (&gt; 1 ?size)]
  =&gt;
  (insert! (ex06/-&gt;Rulefail &quot;rule-1&quot; ?size)))</pre>
Though this might lead to issues with cyclical dependencies, with the session ns and rules ns.

It might be practical to pull the fact definitions out into a separate ns so that they can be pulled by both ns without the possibility of a cycle.</z><z id="t1579577719011700" t="Matthew Pettis Thank you! If I copy and pasted this correctly, when i run (require &apos;clara-lein.ex06rulesns) in clara-lein.ex06 , I get an error that No namespace: clara-lein.ex06rulesns found . I&apos;ll keep poking, but that&apos;s my current error..."><y>#</y><d>2020-01-21</d><h>03:35</h><w>Matthew Pettis</w>Thank you!  If I copy and pasted this correctly, when i run <code>(require &apos;clara-lein.ex06rulesns)</code>  in <code>clara-lein.ex06</code> , I get an error that <code>No namespace: clara-lein.ex06rulesns found</code>.  I&apos;ll keep poking, but that&apos;s my current error...</z><z id="t1579577741012100" t="Matthew Pettis ... and that&apos;s when I run the final let that creates the session..."><y>#</y><d>2020-01-21</d><h>03:35</h><w>Matthew Pettis</w>... and that&apos;s when I run the final <code>let</code> that creates the session...</z><z id="t1579577841013100" t="Matthew Pettis oops, I take that back. When I run that require statement, I get a ClassNotFound exception for clara-lein.ex06.Myfact."><y>#</y><d>2020-01-21</d><h>03:37</h><w>Matthew Pettis</w>oops, I take that back.  When I run that require statement, I get a ClassNotFound exception for clara-lein.ex06.Myfact.</z><z id="t1579623624017800" t="Matthew Pettis So, I was able to make this work if I included all of the defrecords, rules, queries, and facts in a different namespace, referred that namespace, and then made a session with mk-session &apos;source.namespace) . However, I am struggling to modularize this, so that I can make a session where facts come from one namespace, rules from another namespace, and queries from yet another namespace. I&apos;m not sure if it is the namespace inclusion-ing that I am messing up, or that I don&apos;t know the proper syntax on mk-session or insert to build up a session that has facts, rules, and queries from these sources in it. An pointing to examples of rules that has that would be appreciated. I am doing this as an exercise to show that you can make a modular rules system and that clara-rules can support that modularity. Which is why I&apos;m making a toy example that is doing this... thanks in advance..."><y>#</y><d>2020-01-21</d><h>16:20</h><w>Matthew Pettis</w>So, I was able to make this work if I included all of the defrecords, rules, queries, and facts in a different namespace, referred that namespace, and then made a session with <code>mk-session &apos;source.namespace)</code> .  However, I am struggling to modularize this, so that I can make a session where facts come from one namespace, rules from another namespace, and queries from yet another namespace.  I&apos;m not sure if it is the namespace inclusion-ing that I am messing up, or that I don&apos;t know the proper syntax on <code>mk-session</code> or <code>insert</code> to build up a session that has facts, rules, and queries from these sources in it.  An pointing to examples of rules that has that would be appreciated.  I am doing this as an exercise to show that you can make a modular rules system and that clara-rules can support that modularity.  Which is why I&apos;m making a toy example that is doing this... thanks in advance...</z><z id="t1579625988019200" t="mikerod @matthew.pettis there are no special evaluation rules being done by Clara. You have to appropriately require all ns’s you depend on in the order they depend on each other via standard clj :require "><y>#</y><d>2020-01-21</d><h>16:59</h><w>mikerod</w>@matthew.pettis there are no special evaluation rules being done by Clara. You have to appropriately require all ns’s you depend on in the order they depend on each other via standard clj :require </z><z id="t1579626002019600" t="mikerod You can have things in as many ns’s as you want. "><y>#</y><d>2020-01-21</d><h>17:00</h><w>mikerod</w>You can have things in as many ns’s as you want. </z><z id="t1579626027020500" t="mikerod If you show your example I maybe can help. I’m confused what you are using to get into a situation you are describing at this point. "><y>#</y><d>2020-01-21</d><h>17:00</h><w>mikerod</w>If you show your example I maybe can help. I’m confused what you are using to get into a situation you are describing at this point. </z><z id="t1579627561022100" t="Matthew Pettis @mikerod Thanks for the help! I pushed a repo here of example code that doesn&apos;t quite work, but has the rules, facts, and queries in separate namespaces. The part is at the end of the core.clj file, where I assemble a session out of the facts, rules, and queries, to be able to query the session. https://github.com/mpettis/clara-ns-ex"><y>#</y><d>2020-01-21</d><h>17:26</h><w>Matthew Pettis</w>@mikerod Thanks for the help!  I pushed a repo here of example code that doesn&apos;t quite work, but has the rules, facts, and queries in separate namespaces.  The part is at the end of the core.clj file, where I assemble a session out of the facts, rules, and queries, to be able to query the session.  <a href="https://github.com/mpettis/clara-ns-ex" target="_blank">https://github.com/mpettis/clara-ns-ex</a></z><z id="t1579635732022300" t="mikerod First just style Notes: In clara-ns-ex.core , typically all :require are in one spec, but I guess what you have can work? I haven’t actually tested in recent clj: (ns clara-ns-ex.core (:require [clara.rules :refer :all] [clara-ns-ex.facts :refer :all] [clara-ns-ex.rules :refer :all] [clara-ns-ex.queries :refer :all])) Instead of fact-sess (apply insert query-sess facts) use insert-all fact-sess (insert-all query-sess facts) just since there is API to make you not need to use apply with varargs."><y>#</y><d>2020-01-21</d><h>19:42</h><r>mikerod</r>First just style Notes:

In <code>clara-ns-ex.core</code>, typically all <code>:require</code> are in one spec, but I guess what you have can work? I haven’t actually tested in recent clj:
<pre>(ns clara-ns-ex.core
  (:require [clara.rules :refer :all]
            [clara-ns-ex.facts :refer :all]
            [clara-ns-ex.rules :refer :all]
            [clara-ns-ex.queries :refer :all]))</pre>
Instead of
<pre>fact-sess (apply insert query-sess facts)</pre>
use <code>insert-all</code>
<pre>fact-sess (insert-all query-sess facts)</pre>
just since there is API to make you not need to use <code>apply</code> with varargs.</z><z id="t1579635789022500" t="mikerod Second (most important): You don’t insert rules and queries. These are needed upfront at mk-session time. Clara actually does not support dynamically adding or removing rules/queries at all right now. It may be a future potential to add, but there are perf benefits to not doing so. Even if it did allow that later though, you wouldn’t “insert rules”. insert is meant for facts, not rules."><y>#</y><d>2020-01-21</d><h>19:43</h><r>mikerod</r>Second (most important):
You don’t <code>insert</code> rules and queries. These are needed upfront at <code>mk-session</code> time. Clara actually does not support dynamically adding or removing rules/queries at all right now. It may be a future potential to add, but there are perf benefits to not doing so. Even if it did allow that later though, you wouldn’t “insert rules”.
<code>insert</code> is meant for facts, not rules.</z><z id="t1579635839022700" t="mikerod what you’d need to do for your example is: init-sess (mk-session &apos;clara-ns-ex.core &apos;clara-ns-ex.rules &apos;clara-ns-ex.queries) if you just wanted to automatically include all rules/queries defined in those namespaces."><y>#</y><d>2020-01-21</d><h>19:43</h><r>mikerod</r>what you’d need to do for your example is:
<pre>init-sess (mk-session &apos;clara-ns-ex.core &apos;clara-ns-ex.rules &apos;clara-ns-ex.queries)</pre>
if you just wanted to automatically include all rules/queries defined in those namespaces.</z><z id="t1579640457022900" t="Matthew Pettis OK, this is super-helpful, thank you so much! I will try these changes as soon as possible."><y>#</y><d>2020-01-21</d><h>21:00</h><r>Matthew Pettis</r>OK, this is super-helpful, thank you so much!  I will try these changes as soon as possible.</z><z id="t1579640679023100" t="Matthew Pettis I was not aware that rules and queries could not be dynamically added. It is nice to see an example of mk-session with multiple namepaces put in there. I wasn&apos;t sure if it was as a varargs or as a vector of namespaces, etc."><y>#</y><d>2020-01-21</d><h>21:04</h><r>Matthew Pettis</r>I was not aware that rules and queries could not be dynamically added.  It is nice to see an example of <code>mk-session</code> with multiple namepaces put in there.  I wasn&apos;t sure if it was as a varargs or as a vector of namespaces, etc.</z><z id="t1579641369023300" t="mikerod @matthew.pettis there is likely an issue or 2 in the github repo discussing dynamic rules. However, you may not need it as much as immediately it seems."><y>#</y><d>2020-01-21</d><h>21:16</h><r>mikerod</r>@matthew.pettis there is likely an issue or 2 in the github repo discussing dynamic rules. However, you may not need it as much as immediately it seems.</z><z id="t1579641382023500" t="mikerod Often there are solutions that don’t need that sort of feature at least."><y>#</y><d>2020-01-21</d><h>21:16</h><r>mikerod</r>Often there are solutions that don’t need that sort of feature at least.</z><z id="t1579657916023700" t="Matthew Pettis I agree; I don&apos;t need dynamic rules. I more needed a hint as to the fact that they are supplied and loaded upon mk-session ."><y>#</y><d>2020-01-22</d><h>01:51</h><r>Matthew Pettis</r>I agree; I don&apos;t need dynamic rules.  I more needed a hint as to the fact that they are supplied and loaded upon <code>mk-session</code>.</z><z id="t1579657994023900" t="Matthew Pettis To that end, I tried your advice, I think I did it faithfully, and wasn&apos;t able to make it work yet. My adjustments are at this commit: https://github.com/mpettis/clara-ns-ex/tree/0bdb72e98a8ef657de08579af6ee993c9008a738"><y>#</y><d>2020-01-22</d><h>01:53</h><r>Matthew Pettis</r>To that end, I tried your advice, I think I did it faithfully, and wasn&apos;t able to make it work yet.  My adjustments are at this commit: <a href="https://github.com/mpettis/clara-ns-ex/tree/0bdb72e98a8ef657de08579af6ee993c9008a738" target="_blank">https://github.com/mpettis/clara-ns-ex/tree/0bdb72e98a8ef657de08579af6ee993c9008a738</a></z><z id="t1579658069024100" t="Matthew Pettis When I run that, I still get that Myfact class cannot be found. I think I&apos;m probably missing something about using defrecord definitions from other namespaces."><y>#</y><d>2020-01-22</d><h>01:54</h><r>Matthew Pettis</r>When I run that, I still get that <code>Myfact</code> class cannot be found.  I think I&apos;m probably missing something about using <code>defrecord</code> definitions from other namespaces.</z><z id="t1579658644024500" t="Matthew Pettis Also, for a baseline, this is how I make it work when everything is in the same namespace... https://github.com/mpettis/clara-ns-ex/blob/nonamespace/src/clara_ns_ex/core.clj"><y>#</y><d>2020-01-22</d><h>02:04</h><r>Matthew Pettis</r>Also, for a baseline, this is how I make it work when everything is in the same namespace... <a href="https://github.com/mpettis/clara-ns-ex/blob/nonamespace/src/clara_ns_ex/core.clj" target="_blank">https://github.com/mpettis/clara-ns-ex/blob/nonamespace/src/clara_ns_ex/core.clj</a></z><z id="t1579660139025700" t="mikerod @matthew.pettis so you’re issue isn’t just referring to record symbols. Have to follow normal clojure symbol resolution rules. "><y>#</y><d>2020-01-22</d><h>02:28</h><r>mikerod</r>@matthew.pettis so you’re issue isn’t just referring to record symbols. Have to follow normal clojure symbol resolution rules. </z><z id="t1579660152026300" t="mikerod So you require the ns that defines the records - to ensure it is compiled. "><y>#</y><d>2020-01-22</d><h>02:29</h><r>mikerod</r>So you require the ns that defines the records - to ensure it is compiled. </z><z id="t1579660186027400" t="mikerod Then you typically would use :import in clj (not cljs) to refer to the record class name as the shortened version"><y>#</y><d>2020-01-22</d><h>02:29</h><r>mikerod</r>Then you typically would use :import in clj (not cljs) to refer to the record class name as the shortened version</z><z id="t1579660216028300" t="mikerod Otherwise you’d have to fully qualify it each reference clara_ns_ex.facts.Myfact"><y>#</y><d>2020-01-22</d><h>02:30</h><r>mikerod</r>Otherwise you’d have to fully qualify it each reference clara_ns_ex.facts.Myfact</z><z id="t1579660822028600" t="Matthew Pettis Thanks. I thought about that a bit more after I posted, I&apos;ll think a bit more carefully about resolution rules, and think I may get it... Thanks for the help; learning Clojure as I learn Clara here..."><y>#</y><d>2020-01-22</d><h>02:40</h><r>Matthew Pettis</r>Thanks.  I thought about that a bit more after I posted, I&apos;ll think a bit more carefully about resolution rules, and think I may get it... Thanks for the help; learning Clojure as I learn Clara here...</z><z id="t1579663255029100" t="mikerod No problem. Let me know if more questions"><y>#</y><d>2020-01-22</d><h>03:20</h><r>mikerod</r>No problem. Let me know if more questions</z><z id="t1579663272029800" t="mikerod I’d give better examples but typing on mobile is hard hah"><y>#</y><d>2020-01-22</d><h>03:21</h><r>mikerod</r>I’d give better examples but typing on mobile is hard hah</z><z id="t1579664854030100" t="Matthew Pettis I really appreciate the help."><y>#</y><d>2020-01-22</d><h>03:47</h><r>Matthew Pettis</r>I really appreciate the help.</z><z id="t1579666774030300" t="Matthew Pettis fyi, i think i&apos;m closer, but I can&apos;t decipher the location of where the error of can&apos;t find Class for Myfact, as it won&apos;t tell me at what line it is failing. This is the state that I have it: https://github.com/mpettis/clara-ns-ex/tree/f3d6f67346eacb61294205f6da0e1f3073e7428a"><y>#</y><d>2020-01-22</d><h>04:19</h><r>Matthew Pettis</r>fyi, i think i&apos;m closer, but I can&apos;t decipher the location of where the error of can&apos;t find Class for Myfact, as it won&apos;t tell me at what line it is failing.  This is the state that I have it: <a href="https://github.com/mpettis/clara-ns-ex/tree/f3d6f67346eacb61294205f6da0e1f3073e7428a" target="_blank">https://github.com/mpettis/clara-ns-ex/tree/f3d6f67346eacb61294205f6da0e1f3073e7428a</a></z><z id="t1579666889030500" t="Matthew Pettis I have the import statements, I tested that it worked. I referenced these pages that went with the hint that @mikerod gave me on using import: https://danielcompton.net/2016/05/04/requiring-records-clojure-clojurescript and https://stackoverflow.com/a/23420084/1022967"><y>#</y><d>2020-01-22</d><h>04:21</h><r>Matthew Pettis</r>I have the import statements, I tested that it worked.  I referenced these pages that went with the hint that @mikerod gave me on using import: <a href="https://danielcompton.net/2016/05/04/requiring-records-clojure-clojurescript" target="_blank">https://danielcompton.net/2016/05/04/requiring-records-clojure-clojurescript</a> and <a href="https://stackoverflow.com/a/23420084/1022967" target="_blank">https://stackoverflow.com/a/23420084/1022967</a></z><z id="t1579667992030800" t="Matthew Pettis OK, I got it to work by playing with what did and did not need namespace qualified names, and where. I don&apos;t fully understand the rules of when I should and should not yet, but I have a working example to go off of, so thanks for all of your help! Here is the commit that has a working example: https://github.com/mpettis/clara-ns-ex/tree/d077c141d305ef217043bcf44a328c6921311847"><y>#</y><d>2020-01-22</d><h>04:39</h><r>Matthew Pettis</r>OK, I got it to work by playing with what did and did not need namespace qualified names, and where.  I don&apos;t fully understand the rules of when I should and should not yet, but I have a working example to go off of, so thanks for all of your help!  Here is the commit that has a working example: <a href="https://github.com/mpettis/clara-ns-ex/tree/d077c141d305ef217043bcf44a328c6921311847" target="_blank">https://github.com/mpettis/clara-ns-ex/tree/d077c141d305ef217043bcf44a328c6921311847</a></z><z id="t1579686087031000" t="wparker Looks like you&apos;ve got it figured out mostly. :). You don&apos;t need the fact class imports in your core namespace, but rather just in the rule/query namespaces that use them. Clara rule and query defs use the same evaluation semantics as normal Clojure code, that is something used, be it a function, class, etc. needs to be resolvable in the namespace where the rule/query is being defined. Also it&apos;s somewhat a matter of personal preference, but I find it more clear where things are coming from when I use :as aliases rather than :refer :all, that might help reduce confusion."><y>#</y><d>2020-01-22</d><h>09:41</h><r>wparker</r>Looks like you&apos;ve got it figured out mostly.  :). You don&apos;t need the fact class imports in your core namespace, but rather just in the rule/query namespaces that use them.  Clara rule and query defs use the same evaluation semantics as normal Clojure code, that is something used, be it a function, class, etc. needs to be resolvable in the namespace where the rule/query is being defined.  Also it&apos;s somewhat a matter of personal preference, but I find it more clear where things are coming from when I use :as aliases rather than :refer :all, that might help reduce confusion.</z><z id="t1579686211031200" t="wparker Admittedly there&apos;s a fair amount of code in Clara dealing with that evaluation, but the end result is to have the same user-facing semantics."><y>#</y><d>2020-01-22</d><h>09:43</h><r>wparker</r>Admittedly there&apos;s a fair amount of code in Clara dealing with that evaluation, but the end result is to have the same user-facing semantics.</z><z id="t1579697664031400" t="Matthew Pettis Awesome! I&apos;ll take out the require and import statements in core and use :as aliases in the rest and push a cleaner example. Thanks for the help."><y>#</y><d>2020-01-22</d><h>12:54</h><r>Matthew Pettis</r>Awesome!  I&apos;ll take out the require and import statements in core and use :as aliases in the rest and push a cleaner example.  Thanks for the help.</z><z id="t1579700902033600" t="mikerod I also advocate for :as aliases too. It helps to make it clear where symbols are coming from. ClojureScript doesn’t even have :refer :all support! Hah"><y>#</y><d>2020-01-22</d><h>13:48</h><r>mikerod</r>I also advocate for :as aliases too. It helps to make it clear where symbols are coming from. ClojureScript doesn’t even have :refer :all support! Hah</z><z id="t1579701962034100" t="Matthew Pettis I just discovered &apos;how to ns&apos; by Sierra, reading that to guide me on that: https://stuartsierra.com/2016/clojure-how-to-ns.html"><y>#</y><d>2020-01-22</d><h>14:06</h><r>Matthew Pettis</r>I just discovered &apos;how to ns&apos; by Sierra, reading that to guide me on that: <a href="https://stuartsierra.com/2016/clojure-how-to-ns.html" target="_blank">https://stuartsierra.com/2016/clojure-how-to-ns.html</a></z><z id="t1579702255037300" t="mikerod I thought it had some good points. I can’t remember if I fully agreed with it, but analyzing require forms can become a debate of “taste” at a certain point. Hah. He does at least mention its opinionated. 😎"><y>#</y><d>2020-01-22</d><h>14:10</h><r>mikerod</r>I thought it had some good points. I can’t remember if I fully agreed with it, but analyzing require forms can become a debate of “taste” at a certain point. Hah. He does at least mention its opinionated. <b>😎</b></z><z id="t1579703573037700" t="Matthew Pettis OK, just for completeness and posterity... For this question, which was how to use namespaced rules, queries, and facts in making a session, I cleaned up the namespace declaration, using Sierra&apos;s &quot;how to ns&quot; style recommendations, and removed most :require :refer :all statements to be more precise (except for clara-rules ). Here is the commit that is cleaned up per this comment: https://github.com/mpettis/clara-ns-ex/tree/8b78de1442fd8484341cc68d6ac63b7d78cf85e4"><y>#</y><d>2020-01-22</d><h>14:32</h><r>Matthew Pettis</r>OK, just for completeness and posterity... For this question, which was how to use namespaced rules, queries, and facts in making a session, I cleaned up the namespace declaration, using Sierra&apos;s &quot;how to ns&quot; style recommendations, and removed most :require :refer :all statements to be more precise (except for <code>clara-rules</code>).  Here is the commit that is cleaned up per this comment: <a href="https://github.com/mpettis/clara-ns-ex/tree/8b78de1442fd8484341cc68d6ac63b7d78cf85e4" target="_blank">https://github.com/mpettis/clara-ns-ex/tree/8b78de1442fd8484341cc68d6ac63b7d78cf85e4</a></z><z id="t1579703642037900" t="Matthew Pettis"><y>#</y><d>2020-01-22</d><h>14:34</h><w>Matthew Pettis</w></z><z id="t1579711388038400" t="mikerod @matthew.pettis nice, glad to see you sorted it out - looks better too"><y>#</y><d>2020-01-22</d><h>16:43</h><w>mikerod</w>@matthew.pettis nice, glad to see you sorted it out - looks better too</z><z id="t1579725863039800" t="Matthew Pettis Thanks again for the help. I think it is helpful to have an example for clara-rules that leverages namespaces. I think I&apos;ll see if cerner/clara-examples would consider adding it as an example. Or somewhere. Nice to have a battery of examples for some of this..."><y>#</y><d>2020-01-22</d><h>20:44</h><w>Matthew Pettis</w>Thanks again for the help.  I think it is helpful to have an example for clara-rules that leverages namespaces.  I think I&apos;ll see if cerner/clara-examples would consider adding it as an example.  Or somewhere.  Nice to have a battery of examples for some of this...</z><z id="t1579726253041100" t="mikerod @matthew.pettis yeah more examples could be good. Not sure when the last time that repo was updated. But perhaps it is the right place. There are also docs that maybe could explain some things more "><y>#</y><d>2020-01-22</d><h>20:50</h><w>mikerod</w>@matthew.pettis yeah more examples could be good. Not sure when the last time that repo was updated. But perhaps it is the right place. There are also docs that maybe could explain some things more </z><z id="t1579726277041300" t="mikerod http://www.clara-rules.org"><y>#</y><d>2020-01-22</d><h>20:51</h><w>mikerod</w><a href="http://www.clara-rules.org" target="_blank">http://www.clara-rules.org</a></z><z id="t1579726638044800" t="Matthew Pettis @mikerod Yep, started there, read the documentation, some of it was vague to me, and not sure if is lack of experience on my part or it just doesn&apos;t have attention anymore to curate. Also, fwiw, I am making a different repo of collected small steps for myself for self-training. In this link, I use clara-rules to solve a logic puzzle, much like could be done with core.logic. However, I did it in clara-rules not because it was more efficient (oh, my example is real slow and memory hoggy), but because it mimicked a different scenario I think I want to apply clara-rules to. Here is that particular example... https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj"><y>#</y><d>2020-01-22</d><h>20:57</h><w>Matthew Pettis</w>@mikerod Yep, started there, read the documentation, some of it was vague to me, and not sure if is lack of experience on my part or it just doesn&apos;t have attention anymore to curate.  Also, fwiw, I am making a different repo of collected small steps for myself for self-training.  In this link, I use clara-rules to solve a logic puzzle, much like could be done with core.logic.  However, I did it in clara-rules not because it was more efficient (oh, my example is real slow and memory hoggy), but because it mimicked a different scenario I think I want to apply clara-rules to.  Here is that particular example... <a href="https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj" target="_blank">https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj</a></z><z id="t1579728516045300" t="mikerod that’s interesting, could be something nice to add to docs or examples"><y>#</y><d>2020-01-22</d><h>21:28</h><w>mikerod</w>that’s interesting, could be something nice to add to docs or examples</z><z id="t1580270298000500" t="bartuka would be great at the examples!"><y>#</y><d>2020-01-29</d><h>03:58</h><w>bartuka</w>would be great at the examples!</z><z id="t1580270326001200" t="bartuka I am currently teaching the basics of this library to some teammates and this will be a nice exercise to challenge them latter"><y>#</y><d>2020-01-29</d><h>03:58</h><w>bartuka</w>I am currently teaching the basics of this library to some teammates and this will be a nice exercise to challenge them latter</z><z id="t1580514974001600" t="Matthew Pettis My slack history is limited... Do you have a link to the GitHub where I put this?"><y>#</y><d>2020-01-31</d><h>23:56</h><r>Matthew Pettis</r>My slack history is limited... Do you have a link to the GitHub where I put this?</z><z id="t1580526291001800" t="bartuka https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj"><y>#</y><d>2020-02-01</d><h>03:04</h><r>bartuka</r><a href="https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj" target="_blank">https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex05.clj</a></z><z id="t1580526321002100" t="bartuka this one?"><y>#</y><d>2020-02-01</d><h>03:05</h><r>bartuka</r>this one?</z><z id="t1580528268002300" t="Matthew Pettis Yeah. That repo is where I am putting probably all my examples..."><y>#</y><d>2020-02-01</d><h>03:37</h><r>Matthew Pettis</r>Yeah.  That repo is where I am putting probably all my examples...</z><z id="t1580548918002500" t="bartuka great! thanks"><y>#</y><d>2020-02-01</d><h>09:21</h><r>bartuka</r>great! thanks</z><z id="t1581110083010200" t="Matthew Pettis Because it occurs to me that rules like this are just like basic syllogisms (which I&apos;m sure others have observed long before me here) I put together a dead-simple example of making the rules engine do modus ponens from basic propositional logic. https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj"><y>#</y><d>2020-02-07</d><h>21:14</h><w>Matthew Pettis</w>Because it occurs to me that rules like this are just like basic syllogisms (which I&apos;m sure others have observed long before me here) I put together a dead-simple example of making the rules engine do modus ponens from basic propositional logic.  <a href="https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj" target="_blank">https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj</a></z><z id="t1581111369011500" t="ethanc I don’t believe that the rhs should be wrapped in a vector, https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj#L28"><y>#</y><d>2020-02-07</d><h>21:36</h><r>ethanc</r>I don’t believe that the rhs should be wrapped in a vector,
<a href="https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj#L28" target="_blank">https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex07.clj#L28</a></z><z id="t1581111781011800" t="ethanc my reasoning with this nit is, that the clara wraps the rhs inside a fn and executes it when the lhs is satisfied. basically something like: (fn [bindings] &lt;original form&gt;) The inserts! would be considered stateful as the operate on the active session, thus the example still works its just the vector is superfluous. I am just being nit picky though"><y>#</y><d>2020-02-07</d><h>21:43</h><r>ethanc</r>my reasoning with this nit is, that the clara wraps the rhs inside a fn and executes it when the lhs is satisfied.

basically something like:
<pre>(fn [bindings] 
  &lt;original form&gt;)</pre>
The inserts! would be considered stateful as the operate on the active session, thus the example still works its just the vector is superfluous.

I am just being nit picky though</z><z id="t1581111853012000" t="Matthew Pettis this is good... i was getting some wierd nested results when I ran (but still had right answers). I&apos;ll remove and see if that does what&apos;s expected; i didn&apos;t notice I had wrapped that..."><y>#</y><d>2020-02-07</d><h>21:44</h><r>Matthew Pettis</r>this is good... i was getting some wierd nested results when I ran (but still had right answers).  I&apos;ll remove and see if that does what&apos;s expected; i didn&apos;t notice I had wrapped that...</z><z id="t1581115188012200" t="Matthew Pettis ... guess i&apos;m a little surprised it worked in the original, now that I see it..."><y>#</y><d>2020-02-07</d><h>22:39</h><r>Matthew Pettis</r>... guess i&apos;m a little surprised it worked in the original, now that I see it...</z><z id="t1581117682012400" t="ethanc I should add that clara also wraps the RHS form in a do when you use defrule . (fn [bindings] (do &lt;form&gt;)) Since clara doesn’t use the returned value from this function, it doesn’t really make a difference, clojure will gladly return a vector with whatever insert! returns. Which is promptly ignored by clara 🙂"><y>#</y><d>2020-02-07</d><h>23:21</h><r>ethanc</r>I should add that clara also wraps the RHS form in a <code>do</code> when you use <code>defrule</code>.

<pre>(fn [bindings] 
  (do 
     &lt;form&gt;))</pre>
Since clara doesn’t use the returned value from this function, it doesn’t really make a difference, clojure will gladly return a vector with whatever <code>insert!</code> returns.
Which is promptly ignored by clara <b>🙂</b></z><z id="t1581186376012800" t="Matthew Pettis fixed and pushed."><y>#</y><d>2020-02-08</d><h>18:26</h><r>Matthew Pettis</r>fixed and pushed.</z><z id="t1581110158011300" t="Matthew Pettis And a slightly more complicated example here too. I&apos;m just experimenting, not saying this is the optimal way to do this, but it is just fleshing out some thoughts and analogies that might be useful for others teaching rules-engines concepts. criticisms welcome. https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex08.clj"><y>#</y><d>2020-02-07</d><h>21:15</h><w>Matthew Pettis</w>And a slightly more complicated example here too.  I&apos;m just experimenting, not saying this is the optimal way to do this, but it is just fleshing out some thoughts and analogies that might be useful for others teaching rules-engines concepts.  criticisms welcome.  <a href="https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex08.clj" target="_blank">https://github.com/mpettis/clara-lien/blob/master/src/clara_lein/ex08.clj</a></z><z id="t1581293917014100" t="Matthew Pettis Documentation question: from this page ( http://www.clara-rules.org/docs/rules/ ), in the defrule structure flow has an optional props token. I can&apos;t find anywhere in the documentation that talks about what that actually is. Can anyone point me to what that is?"><y>#</y><d>2020-02-10</d><h>00:18</h><w>Matthew Pettis</w>Documentation question: from this page (<a href="http://www.clara-rules.org/docs/rules/" target="_blank">http://www.clara-rules.org/docs/rules/</a>), in the <code>defrule</code> structure flow has an optional <code>props</code> token.  I can&apos;t find anywhere in the documentation that talks about what that actually is.  Can anyone point me to what that is?</z><z id="t1581351370014300" t="wparker The primary property used currently is salience, which allows users to control the order in which rules fire. Usually it shouldn’t be necessary, but sometimes is useful either for performance optimization or when rules opt out of truth maintenance (by using unconditional insertions and/or RHS retractions). The latter tends to make things more complicated in my experience, but sometimes can be useful/necessary"><y>#</y><d>2020-02-10</d><h>16:16</h><r>wparker</r>The primary property used currently is salience, which allows users to control the order in which rules fire.  Usually it shouldn’t be necessary, but sometimes is useful either for performance optimization or when rules opt out of truth maintenance (by using unconditional insertions and/or RHS retractions).  The latter tends to make things more complicated in my experience, but sometimes can be useful/necessary</z><z id="t1581352884014500" t="Matthew Pettis OK, thank you, this is nice to know."><y>#</y><d>2020-02-10</d><h>16:41</h><r>Matthew Pettis</r>OK, thank you, this is nice to know.</z><z id="t1581355341015200" t="mikerod They are undocumented to discourage use perhaps. Hah"><y>#</y><d>2020-02-10</d><h>17:22</h><r>mikerod</r>They are undocumented to discourage use perhaps. Hah</z><z id="t1581355356015800" t="mikerod I thought salience may be documented somewhere though. Would have to look"><y>#</y><d>2020-02-10</d><h>17:22</h><r>mikerod</r>I thought salience may be documented somewhere though. Would have to look</z><z id="t1581363251016000" t="Matthew Pettis yep, salience is documented here: http://www.clara-rules.org/docs/conflictsalience/"><y>#</y><d>2020-02-10</d><h>19:34</h><r>Matthew Pettis</r>yep, salience is documented here: <a href="http://www.clara-rules.org/docs/conflictsalience/" target="_blank">http://www.clara-rules.org/docs/conflictsalience/</a></z><z id="t1581363311016300" t="Matthew Pettis I just didn&apos;t connect what I read there with what I read in the documentation..."><y>#</y><d>2020-02-10</d><h>19:35</h><r>Matthew Pettis</r>I just didn&apos;t connect what I read there with what I read in the documentation...</z><z id="t1584390451001100" t="eraserhd Hey, remember when I said I wanted a command-line Clara rules-like thing? It exists: https://www.w3.org/2000/10/swap/doc/cwm.html"><y>#</y><d>2020-03-16</d><h>20:27</h><w>eraserhd</w>Hey, remember when I said I wanted a command-line Clara rules-like thing?  It exists: <a href="https://www.w3.org/2000/10/swap/doc/cwm.html" target="_blank">https://www.w3.org/2000/10/swap/doc/cwm.html</a></z><z id="t1584405805001600" t="staypufd Cool"><y>#</y><d>2020-03-17</d><h>00:43</h><w>staypufd</w>Cool</z><z id="t1585740774001000" t="narkisr Hey Clara team I&apos;m trying to require clara and I&apos;m getting an error namespace &apos;clara.rules.schema&apos; not found Any idea what I&apos;m missing? (I am able to require &apos; http://calra.ru"><y>#</y><d>2020-04-01</d><h>11:32</h><w>narkisr</w>Hey Clara team I&apos;m trying to require clara and I&apos;m getting an error

<pre>namespace &apos;clara.rules.schema&apos; not found</pre>
Any idea what I&apos;m missing? (I am able to require &apos;<a href="http://calra.ru" target="_blank">http://calra.ru</a></z><z id="t1585741536001500" t="narkisr Ok seems like I had a conflicting [prismatic/schema &quot;1.1.6&quot;] version in my classpath all good 🙂"><y>#</y><d>2020-04-01</d><h>11:45</h><w>narkisr</w>Ok seems like I had a conflicting [prismatic/schema &quot;1.1.6&quot;] version in my classpath all good <b>🙂</b></z><z id="t1585750541003700" t="ethanc I wonder if it would make sense to rip that dependency out of clara. I know it adds a bit of clarity to the underlying structure of the Sessions and whatnot, but it is another dependency we are forcing on consumers. @mikerod do you have any thoughts here?"><y>#</y><d>2020-04-01</d><h>14:15</h><w>ethanc</w>I wonder if it would make sense to rip that dependency out of clara. I know it adds a bit of clarity to the underlying structure of the Sessions and whatnot, but it is another dependency we are forcing on consumers. @mikerod do you have any thoughts here?</z><z id="t1585751602004000" t="mikerod @ethanc replace with spec or just nothing?"><y>#</y><d>2020-04-01</d><h>14:33</h><w>mikerod</w>@ethanc replace with spec or just nothing?</z><z id="t1585751618004700" t="mikerod We maybe could get the schema ns usage to be optional (and use it in tests too)"><y>#</y><d>2020-04-01</d><h>14:33</h><w>mikerod</w>We maybe could get the schema ns usage to be optional (and use it in tests too)</z><z id="t1585751658005500" t="ethanc Spec would probably be the ideal, but i’m not sure what all is going to have to change to uplift clojure/clojurescript versios"><y>#</y><d>2020-04-01</d><h>14:34</h><w>ethanc</w>Spec would probably be the ideal, but i’m not sure what all is going to have to change to uplift clojure/clojurescript versios</z><z id="t1585752376006000" t="mikerod spec could probably be added without much difficulty on the versioning front, but actually making the spec would be more time consuming"><y>#</y><d>2020-04-01</d><h>14:46</h><w>mikerod</w>spec could probably be added without much difficulty on the versioning front, but actually making the spec would be more time consuming</z><z id="t1585752390006400" t="mikerod Perhaps we can just get the schema to be an option dependency we only check/bring in during the :dev profile?"><y>#</y><d>2020-04-01</d><h>14:46</h><w>mikerod</w>Perhaps we can just get the schema to be an option dependency we only check/bring in during the <code>:dev</code> profile?</z><z id="t1585752581007000" t="ethanc I’m not completely sure how we could do that."><y>#</y><d>2020-04-01</d><h>14:49</h><w>ethanc</w>I’m not completely sure how we could do that.</z><z id="t1585754685007600" t="mikerod probably would have to shim some schema fn’s/macros"><y>#</y><d>2020-04-01</d><h>15:24</h><w>mikerod</w>probably would have to shim some schema fn’s/macros</z><z id="t1585754694007900" t="mikerod and have them at compile time decide if the dep is there or not - if not fall back"><y>#</y><d>2020-04-01</d><h>15:24</h><w>mikerod</w>and have them at compile time decide if the dep is there or not - if not fall back</z><z id="t1585754714008300" t="mikerod probably isn’t easy if using harder macro features like schema’s defn or defrecord"><y>#</y><d>2020-04-01</d><h>15:25</h><w>mikerod</w>probably isn’t easy if using harder macro features like schema’s <code>defn</code> or <code>defrecord</code></z><z id="t1585755780008800" t="ethanc which clara does, at least for the defrecord."><y>#</y><d>2020-04-01</d><h>15:43</h><w>ethanc</w>which clara does, at least for the defrecord.</z><z id="t1585757293009100" t="mikerod yeah, so it’s likely difficult 😛"><y>#</y><d>2020-04-01</d><h>16:08</h><w>mikerod</w>yeah, so it’s likely difficult <b>😛</b></z><z id="t1585760751010100" t="ethanc I really wouldn’t want to be in the business of trying to parse schema’s forms and convert them back into clojure’s forms"><y>#</y><d>2020-04-01</d><h>17:05</h><w>ethanc</w>I really wouldn’t want to be in the business of trying to parse schema’s forms and convert them back into clojure’s forms</z><z id="t1585762087010500" t="mikerod No. I wouldn’t want that either"><y>#</y><d>2020-04-01</d><h>17:28</h><w>mikerod</w>No. I wouldn’t want that either</z><z id="t1585827604011900" t="narkisr BTW I think that I have a very interesting use case for Clara rules, once done ill share it but I&apos;m very excited about it"><y>#</y><d>2020-04-02</d><h>11:40</h><w>narkisr</w>BTW I think that I have a very interesting use case for Clara rules, once done ill share it but I&apos;m very excited about it</z><z id="t1585837191014700" t="narkisr Hi Clara team, is there an option to run a query that matches any fact? for example: (defquery get-failures [] (?f &lt;- [_ true])) Assuming that the first value in the vector is not important we only care for the second true value"><y>#</y><d>2020-04-02</d><h>14:19</h><w>narkisr</w>Hi Clara team, is there an option to run a query that matches any fact? for example:

<pre>(defquery get-failures [] 
    (?f &lt;- [_ true]))</pre>
Assuming that the first value in the vector is not important we only care for the second true value</z><z id="t1585837251015500" t="narkisr Or alternatively: (defquery get-failures [] (?f &lt;- _ (= ?failure true)))"><y>#</y><d>2020-04-02</d><h>14:20</h><w>narkisr</w>Or alternatively:

<pre>(defquery get-failures [] 
    (?f &lt;- _ (= ?failure true)))</pre></z><z id="t1585837334015900" t="narkisr (looks like ancestors-fn might be useful in such a case?)"><y>#</y><d>2020-04-02</d><h>14:22</h><w>narkisr</w>(looks like ancestors-fn might be useful in such a case?)</z><z id="t1585837569017500" t="ethanc A rule/query that has a fact type of Object would find all facts"><y>#</y><d>2020-04-02</d><h>14:26</h><w>ethanc</w>A rule/query that has a fact type of Object would find all facts</z><z id="t1585838190019700" t="narkisr In my case I&apos;m using a keyword as the fact type, if I understand this correctly (ancestors :foo) is nil so Object dosent capture this?"><y>#</y><d>2020-04-02</d><h>14:36</h><w>narkisr</w>In my case I&apos;m using a keyword as the fact type, if I understand this correctly (ancestors :foo) is nil so Object dosent capture this?</z><z id="t1585838206020000" t="narkisr (defquery get-failures [] (?f &lt;- Object (= ?failure true)))"><y>#</y><d>2020-04-02</d><h>14:36</h><w>narkisr</w><pre>(defquery get-failures [] 
    (?f &lt;- Object (= ?failure true)))</pre></z><z id="t1585838229020400" t="narkisr Sounds like I need to use an actual clojure keys hierarchy?"><y>#</y><d>2020-04-02</d><h>14:37</h><w>narkisr</w>Sounds like I need to use an actual clojure keys hierarchy?</z><z id="t1585838804022300" t="ethanc ah when using a custom fact-type-fn i think the only reliable way to achieve this would be to also provide a matching custom ancestors-fn"><y>#</y><d>2020-04-02</d><h>14:46</h><w>ethanc</w>ah when using a custom fact-type-fn i think the only reliable way to achieve this would be to also provide a matching custom ancestors-fn</z><z id="t1585838858022600" t="narkisr Makes sense, ill continue to fiddle with it"><y>#</y><d>2020-04-02</d><h>14:47</h><w>narkisr</w>Makes sense, ill continue to fiddle with it</z><z id="t1585838860022800" t="narkisr Thanks"><y>#</y><d>2020-04-02</d><h>14:47</h><w>narkisr</w>Thanks</z><z id="t1586043911028800" t="rainbow_bamboo Hi :) I&apos;ve been working on a website to cite data about the pandemic, http://coronavirus-charts.org . Underneath it uses clara rules to generate HTML charts... (A full writeup on the project https://devpost.com/software/coronavirus-charts-org and the source code https://github.com/rainbow-bamboo/coronavirus-charts/ ) any help, advice or feedback is welcome :)"><y>#</y><d>2020-04-04</d><h>23:45</h><w>rainbow_bamboo</w>Hi :) I&apos;ve been working on a website to cite data about the pandemic, <a href="http://coronavirus-charts.org" target="_blank">http://coronavirus-charts.org</a> .

Underneath it uses clara rules to generate HTML charts... (A full writeup on the project <a href="https://devpost.com/software/coronavirus-charts-org" target="_blank">https://devpost.com/software/coronavirus-charts-org</a> and the source code <a href="https://github.com/rainbow-bamboo/coronavirus-charts/" target="_blank">https://github.com/rainbow-bamboo/coronavirus-charts/</a> ) any help, advice or feedback is welcome :)</z><z id="t1586126382030000" t="mikerod @ada this looks interesting! Cool to see clara being used some underneath this. "><y>#</y><d>2020-04-05</d><h>22:39</h><w>mikerod</w>@ada this looks interesting! Cool to see clara being used some underneath this. </z><z id="t1587051759034700" t="narkisr Hi Clara team just wanted to share my use which is using Clara rules for provisioning https://github.com/re-ops/re-core/blob/re-flow/src/re_flow/core.clj , the ability to combine different flows easily while getting the computation graph for free is amazing, trying to implement this with procedural if/else or state machines would have resulted with much less composeable and brittle code. To be able to just query and see why a flow has failed is just the icing on the cake ;) Thank you for the hard work!"><y>#</y><d>2020-04-16</d><h>15:42</h><w>narkisr</w>Hi Clara team just wanted to share my use which is using Clara rules for provisioning <a href="https://github.com/re-ops/re-core/blob/re-flow/src/re_flow/core.clj" target="_blank">https://github.com/re-ops/re-core/blob/re-flow/src/re_flow/core.clj</a>, the ability to combine different flows easily while getting the computation graph for free is amazing, trying to implement this with procedural if/else or state machines would have resulted with much less composeable and brittle code.

To be able to just query and see why a flow has failed is just the icing on the cake ;)

Thank you for the hard work!</z><z id="t1587054243036000" t="ethanc Thats pretty cool, its great to see people using clara in new inventive ways"><y>#</y><d>2020-04-16</d><h>16:24</h><w>ethanc</w>Thats pretty cool, its great to see people using clara in new inventive ways</z><z id="t1587057304036300" t="noprompt Workflows are where its at 🙂"><y>#</y><d>2020-04-16</d><h>17:15</h><w>noprompt</w>Workflows are where its at <b>🙂</b></z><z id="t1587057432037200" t="noprompt Its awesome to hear/see this idea catching on."><y>#</y><d>2020-04-16</d><h>17:17</h><w>noprompt</w>Its awesome to hear/see this idea catching on.</z><z id="t1587060629037700" t="mikerod @narkisr looks like an interesting use-case. Nice to see."><y>#</y><d>2020-04-16</d><h>18:10</h><w>mikerod</w>@narkisr looks like an interesting use-case. Nice to see.</z><z id="t1588072442050900" t="narkisr Hi Clara team this is a cross post from the #announcements channel (I hope its ok) just wanted to share my post on how I used Clara and why I think its cool for process automation http://narkisr.com/posts/27-04-2020-clara-flow/ I hope to see more projects make use of this awesome project"><y>#</y><d>2020-04-28</d><h>11:14</h><w>narkisr</w>Hi Clara team this is a cross post from the #announcements channel (I hope its ok) just wanted to share my post on how I used Clara and why I think its cool for process automation <a href="http://narkisr.com/posts/27-04-2020-clara-flow/" target="_blank">http://narkisr.com/posts/27-04-2020-clara-flow/</a>

I hope to see more projects make use of this awesome project</z><z id="t1588079250051500" t="mikerod @narkisr this is cool to see. Thanks for writing the blog explaining and sharing. Exciting to see clara being useful here. "><y>#</y><d>2020-04-28</d><h>13:07</h><w>mikerod</w>@narkisr this is cool to see. Thanks for writing the blog explaining and sharing. Exciting to see clara being useful here. </z><z id="t1588457497053500" t="oskarkv I&apos;m new to Clara Rules. I have been trying to write a rule for a board game, but I haven&apos;t been able to do it. The rule in English is: During a player&apos;s turn, at the stage of the turn called :into-city, the player will move into the city if either there are no other players in the city, or if there is just one player in the city and the total number of players is more than four. I have these fact types: (defrecord Player [id name health score energy]) (defrecord Turn [id stage]) (defrecord InCity [id]) InCity just means that a player is in the city. Turn keeps track of whose turn it is and at what stage the player is in his turn. Player just represents a player. I tried this: (cr/defrule into-city [?turn &lt;- Turn (= ?id id) (= :into-city stage)] [?players &lt;- (acc/count) :from [Player]] [?in-city &lt;- (acc/count) :from [InCity]] ;; (or (zero? ?in-city ;; (and (= 1 ?in-city) ;; (&gt; ?players 4)))) =&gt; (cr/retract! ?turn) (cr/insert! (-&gt;Turn ?id (next-stage :into-city))) (cr/insert! (-&gt;InCity ?id))) But of course that part of the condition with &quot;if either there are no other players in the city, or if there is just one player in the city and the total number of players is more than 4&quot; is missing. I have commented out an expression that I tried to put in there somehow. But I&apos;m not sure where to put that. As far as I have seen, conditions apply to individual facts, and I&apos;m not sure if I can put in another condition line with just boolean logic. Can I? Also, since, as you can see, I&apos;m retracting the Turn fact that led to the new facts being inserted, because now the stage of the turn is the next stage, and so the inserted facts will be instantly retracted, right? So how should I think about it? I&apos;m finding it harder than I anticipated to write a program with rules."><y>#</y><d>2020-05-02</d><h>22:11</h><w>oskarkv</w>I&apos;m new to Clara Rules. I have been trying to write a rule
for a board game, but I haven&apos;t been able to do it. The rule
in English is:

During a player&apos;s turn, at the stage of the turn called
:into-city, the player will move into the city if either
there are no other players in the city, or if there is just
one player in the city and the total number of players is
more than four.

I have these fact types:

<pre>(defrecord Player [id name health score energy])
(defrecord Turn [id stage])
(defrecord InCity [id])</pre>
InCity just means that a player is in the city. Turn keeps
track of whose turn it is and at what stage the player is in
his turn. Player just represents a player.

I tried this:

<pre>(cr/defrule into-city
  [?turn &lt;- Turn (= ?id id) (= :into-city stage)]
  [?players &lt;- (acc/count) :from [Player]]
  [?in-city &lt;- (acc/count) :from [InCity]]
  ;; (or (zero? ?in-city
  ;;            (and (= 1 ?in-city)
  ;;                 (&gt; ?players 4))))
  =&gt;
  (cr/retract! ?turn)
  (cr/insert! (-&gt;Turn ?id (next-stage :into-city)))
  (cr/insert! (-&gt;InCity ?id)))</pre>
But of course that part of the condition with &quot;if either
there are no other players in the city, or if there is just
one player in the city and the total number of players is
more than 4&quot; is missing. I have commented out an expression
that I tried to put in there somehow. But I&apos;m not sure where
to put that. As far as I have seen, conditions apply to
individual facts, and I&apos;m not sure if I can put in another
condition line with just boolean logic. Can I?

Also, since, as you can see, I&apos;m retracting the Turn fact
that led to the new facts being inserted, because now the
stage of the turn is the next stage, and so the inserted
facts will be instantly retracted, right? So how should I
think about it? I&apos;m finding it harder than I anticipated to
write a program with rules.</z><z id="t1588526338059000" t="ethanc To: &gt; As far as I have seen, conditions apply to &gt; individual facts, and I&apos;m not sure if I can put in another &gt; condition line with just boolean logic. Can I? yes, clara represents this as an underlying join of the two facts. You could also do this in a &quot;test&quot; condition: http://www.clara-rules.org/docs/expressions/ For: &gt; Also, since, as you can see, I&apos;m retracting the Turn fact &gt; that led to the new facts being inserted, because now the &gt; stage of the turn is the next stage, and so the inserted &gt; facts will be instantly retracted, right? So how should I &gt; think about it? As you alluded to, truth maintenance( http://www.clara-rules.org/docs/truthmaint/ ) would kick in when retracting the fact, meaning that this rule would likely cause a loop to occur. I&apos;ve never really thought about modeling game state management in clara, but i would wonder if the retract is necessary."><y>#</y><d>2020-05-03</d><h>17:18</h><w>ethanc</w>To:
&gt; As far as I have seen, conditions apply to
&gt; individual facts, and I&apos;m not sure if I can put in another
&gt; condition line with just boolean logic. Can I?
yes, clara represents this as an underlying join of the two facts. You could also do this in a &quot;test&quot; condition:
<a href="http://www.clara-rules.org/docs/expressions/" target="_blank">http://www.clara-rules.org/docs/expressions/</a>

For:
&gt; Also, since, as you can see, I&apos;m retracting the Turn fact
&gt; that led to the new facts being inserted, because now the
&gt; stage of the turn is the next stage, and so the inserted
&gt; facts will be instantly retracted, right? So how should I
&gt; think about it?
As you alluded to, truth maintenance(<a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a>) would kick in when retracting the fact, meaning that this rule would likely cause a loop to occur. I&apos;ve never really thought about modeling game state management in clara, but i would wonder if the retract is necessary.</z><z id="t1588535784059900" t="oskarkv I discovered that there is insert-unconditional too, maybe I can use that"><y>#</y><d>2020-05-03</d><h>19:56</h><w>oskarkv</w>I discovered that there is <code>insert-unconditional</code> too, maybe I can use that</z><z id="t1588535785060100" t="oskarkv Thanks"><y>#</y><d>2020-05-03</d><h>19:56</h><w>oskarkv</w>Thanks</z><z id="t1588555077060400" t="mikerod @oskarkv maybe related http://www.metasimple.org/2017/12/23/clara-updating-facts.html"><y>#</y><d>2020-05-04</d><h>01:17</h><w>mikerod</w>@oskarkv maybe related <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a></z><z id="t1588869538060800" t="oskarkv Thanks!"><y>#</y><d>2020-05-07</d><h>16:38</h><w>oskarkv</w>Thanks!</z><z id="t1588869986064100" t="oskarkv (cr/defquery my-query [:?x :?y] [?p &lt;- (acc/all) :from [Player]]) (defn oktest [] (-&gt; (cr/mk-session) (cr/insert (-&gt;Player 0 0 0)) (cr/insert (-&gt;Player 1 2 3)) cr/fire-rules (cr/query my-query :?x 0 :?y 0))) This does not produce any results. But if I use ?x and ?y in the query, e.g. (= ?x x) and same for y then it does produce results. This is kind of surprising since in normal functions one doesn&apos;t have to use the args. Is there any particular reason for this? Same if I remove the arguments :?x and :?y from the query but keep them in the call to cr/query , then the query doesn&apos;t produce any results. Also a bit confusing."><y>#</y><d>2020-05-07</d><h>16:46</h><w>oskarkv</w><pre>(cr/defquery my-query
  [:?x :?y]
  [?p &lt;- (acc/all) :from [Player]])

(defn oktest []
  (-&gt; (cr/mk-session)
    (cr/insert (-&gt;Player 0 0 0))
    (cr/insert (-&gt;Player 1 2 3))
    cr/fire-rules
    (cr/query my-query :?x 0 :?y 0)))</pre>
This does not produce any results. But if I use <code>?x</code> and <code>?y</code> in the query, e.g. <code>(= ?x x)</code> and same for y then it does produce results. This is kind of surprising since in normal functions one doesn&apos;t have to use the args. Is there any particular reason for this? Same if I remove the arguments <code>:?x</code> and <code>:?y</code> from the query but keep them in the call to <code>cr/query</code>, then the query doesn&apos;t produce any results. Also a bit confusing.</z><z id="t1588870623064700" t="oskarkv And apparently this doesn&apos;t work. I&apos;m confused about queries. (cr/defquery my-query [:?x :?y] [?p &lt;- (acc/all) :from [Player (&gt; x ?x) (&gt; y ?y)]]) (defn oktest [] (-&gt; (cr/mk-session) (cr/insert (-&gt;Player 1 1 1)) (cr/insert (-&gt;Player 2 2 2)) cr/fire-rules (cr/query my-query :?x 0 :?y 0)))"><y>#</y><d>2020-05-07</d><h>16:57</h><w>oskarkv</w>And apparently this doesn&apos;t work. I&apos;m confused about queries.
<pre>(cr/defquery my-query
  [:?x :?y]
  [?p &lt;- (acc/all) :from [Player (&gt; x ?x) (&gt; y ?y)]])

(defn oktest []
  (-&gt; (cr/mk-session)
    (cr/insert (-&gt;Player 1 1 1))
    (cr/insert (-&gt;Player 2 2 2))
    cr/fire-rules
    (cr/query my-query :?x 0 :?y 0)))</pre></z><z id="t1588870791065500" t="oskarkv What can and should the arguments be used for? Only for testing equality? I don&apos;t get it."><y>#</y><d>2020-05-07</d><h>16:59</h><w>oskarkv</w>What can and should the arguments be used for? Only for testing equality? I don&apos;t get it.</z><z id="t1588871750065900" t="mikerod @oskarkv perhaps try it all again with (cr/mk-session :cache false) just to make sure"><y>#</y><d>2020-05-07</d><h>17:15</h><w>mikerod</w>@oskarkv perhaps try it all again with <code>(cr/mk-session :cache false)</code> just to make sure</z><z id="t1588871777066500" t="mikerod It sounds like you are describing 3 variations you have tested"><y>#</y><d>2020-05-07</d><h>17:16</h><w>mikerod</w>It sounds like you are describing 3 variations you have tested</z><z id="t1588871834066700" t="mikerod &gt; What can and should the arguments be used for? Only for testing equality? I don’t get it. this should not be the case"><y>#</y><d>2020-05-07</d><h>17:17</h><w>mikerod</w>&gt; What can and should the arguments be used for? Only for testing equality? I don’t get it.
this should not be the case</z><z id="t1588872194067000" t="oskarkv In the last case I get this error http://dpaste.com/1QSB24C"><y>#</y><d>2020-05-07</d><h>17:23</h><w>oskarkv</w>In the last case I get this error <a href="http://dpaste.com/1QSB24C" target="_blank">http://dpaste.com/1QSB24C</a></z><z id="t1588872276067500" t="oskarkv That&apos;s the one with (&gt; x ?x) as constraints"><y>#</y><d>2020-05-07</d><h>17:24</h><w>oskarkv</w>That&apos;s the one with <code>(&gt; x ?x)</code> as constraints</z><z id="t1588872434068100" t="oskarkv I restarted Clojure and added :cache false but nothing was different"><y>#</y><d>2020-05-07</d><h>17:27</h><w>oskarkv</w>I restarted Clojure and added <code>:cache false</code> but nothing was different</z><z id="t1588872687071100" t="oskarkv So with (= x ?x) I get results if I pass in the correct arguments. With (&gt; x ?x) I get an error. Not using ?x at all in the query body produce no results although I think it should. Having an empty args vector in the query but passing args in when calling produce no results either. And finally using no args in the query or when calling I get results again. I am very confused."><y>#</y><d>2020-05-07</d><h>17:31</h><w>oskarkv</w>So with <code>(= x ?x)</code> I get results if I pass in the correct arguments. With <code>(&gt; x ?x)</code> I get an error. Not using <code>?x</code> at all in the query body produce no results although I think it should. Having an empty args vector in the query but passing args in when calling produce no results either. And finally using no args in the query or when calling I get results again. I am very confused.</z><z id="t1588873974071300" t="oskarkv clarax.queriestest&gt; (q1test) with (= ?x x) ({:?x 1, :?y 1, :?p [{:x 1, :y 1, :z 1}]}) clarax.queriestest&gt; (q2test) with no ?x or ?y in body () clarax.queriestest&gt; (q3test) with no argsvector () clarax.queriestest&gt; (q4test) argsvector but no args passed in ({:?p [{:x 1, :y 1, :z 1} {:x 2, :y 2, :z 2}]}) clarax.queriestest&gt; (q5test) no args whatsoever ({:?p [{:x 1, :y 1, :z 1} {:x 2, :y 2, :z 2}]}) clarax.queriestest&gt; (q6test) with (&gt; x ?x) Execution error (ExceptionInfo) at clara.rules.compiler/eval18474$sort-conditions$fn (compiler.clj:847). I used this source https://gist.github.com/oskarkv/74cf41ab8937326beabc695711c19618 I&apos;m using Clara 0.20.0 I would have expected at least q2 with no args in the body to return something, and also the last one with (&gt; x ?x) to work."><y>#</y><d>2020-05-07</d><h>17:52</h><w>oskarkv</w><pre>clarax.queriestest&gt; (q1test)
with (= ?x x)
({:?x 1, :?y 1, :?p [{:x 1, :y 1, :z 1}]})
clarax.queriestest&gt; (q2test)
with no ?x or ?y in body
()
clarax.queriestest&gt; (q3test)
with no argsvector
()
clarax.queriestest&gt; (q4test)
argsvector but no args passed in
({:?p [{:x 1, :y 1, :z 1} {:x 2, :y 2, :z 2}]})
clarax.queriestest&gt; (q5test)
no args whatsoever
({:?p [{:x 1, :y 1, :z 1} {:x 2, :y 2, :z 2}]})
clarax.queriestest&gt; (q6test)
with (&gt; x ?x)
Execution error (ExceptionInfo) at clara.rules.compiler/eval18474$sort-conditions$fn (compiler.clj:847).</pre>
I used this source <a href="https://gist.github.com/oskarkv/74cf41ab8937326beabc695711c19618" target="_blank">https://gist.github.com/oskarkv/74cf41ab8937326beabc695711c19618</a>

I&apos;m using Clara 0.20.0

I would have expected at least q2 with no args in the body to return something, and also the last one with <code>(&gt; x ?x)</code> to work.</z><z id="t1588881239074300" t="ethanc @oskarkv I will take a look at this in a bit. My gut reaction as to why this isn’t acting as expected is due to the implementation of how queries are executed directly on clara’s internal memory."><y>#</y><d>2020-05-07</d><h>19:53</h><w>ethanc</w>@oskarkv
I will take a look at this in a bit. My gut reaction as to why this isn’t acting as expected is due to the implementation of how queries are executed directly on clara’s internal memory.</z><z id="t1588889087074700" t="mikerod It’d be interesting if it’s not working for non =. "><y>#</y><d>2020-05-07</d><h>22:04</h><w>mikerod</w>It’d be interesting if it’s not working for non =. </z><z id="t1588889102075000" t="mikerod Perhaps that was its original intent though "><y>#</y><d>2020-05-07</d><h>22:05</h><w>mikerod</w>Perhaps that was its original intent though </z><z id="t1588891426077400" t="ethanc I was under the assumption that queries never support heavier logic than equality, as its the job of the rules to do more complex filtering and joining logic… Might be a poor assumption on my part but it sure seems like bound variables are the contract"><y>#</y><d>2020-05-07</d><h>22:43</h><w>ethanc</w>I was under the assumption that queries never support heavier logic than equality, as its the job of the rules to do more complex filtering and joining logic…
Might be a poor assumption on my part but it sure seems like bound variables are the contract</z><z id="t1588891450077800" t="ethanc at least in its current implementation"><y>#</y><d>2020-05-07</d><h>22:44</h><w>ethanc</w>at least in its current implementation</z><z id="t1588897035081500" t="mikerod That’s probably accurate "><y>#</y><d>2020-05-08</d><h>00:17</h><w>mikerod</w>That’s probably accurate </z><z id="t1588897447084400" t="ethanc Ok looking at this, I would say that clara.rules/query( https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L47-L57 ) could use a bit of validation on the args. As the user provides both the query and key/values to query already it should be pretty straight forward to determine if the map of arguments match that of the params on the query itself. similar to how we validate that the query is in rulebase today: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1976 a disjunction between the keys of the params provided and params on the node itself( https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L432 ) in the event that the user provided more/less the query behaves quite differently as demonstrated in the examples provided. This simply comes down to the implementation of query itself: https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1978"><y>#</y><d>2020-05-08</d><h>00:24</h><w>ethanc</w>Ok looking at this,
I would say that clara.rules/query(<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L47-L57" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules.cljc#L47-L57</a>) could use a bit of validation on the args.
As the user provides both the query and key/values to query already it should be pretty straight forward to determine if the map of arguments match that of the params on the query itself.

similar to how we validate that the query is in rulebase today:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1976" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1976</a>

a disjunction between the keys of the params provided and params on the node itself(<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L432" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L432</a>)
in the event that the user provided more/less the query behaves quite differently as demonstrated in the examples provided.

This simply comes down to the implementation of query itself:
<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1978" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/engine.cljc#L1978</a></z><z id="t1588897526084900" t="ethanc as it uses bindings to retrieve the tokens from memory"><y>#</y><d>2020-05-08</d><h>00:25</h><w>ethanc</w>as it uses bindings to retrieve the tokens from memory</z><z id="t1588897583086000" t="ethanc so the assumption i mentioned above is technically true, and has to be true as it would be inforced by the behavior of the memory"><y>#</y><d>2020-05-08</d><h>00:26</h><w>ethanc</w>so the assumption i mentioned above is technically true, and has to be true as it would be inforced by the behavior of the memory</z><z id="t1588953032087900" t="ethanc I have logged: https://github.com/cerner/clara-rules/issues/454 for the conversation above. Please feel free to add Comments/Concerns, it seems pretty straight forward and if i get time this weekend i might knock it out"><y>#</y><d>2020-05-08</d><h>15:50</h><w>ethanc</w>I have logged:
<a href="https://github.com/cerner/clara-rules/issues/454" target="_blank">https://github.com/cerner/clara-rules/issues/454</a>
for the conversation above.

Please feel free to add Comments/Concerns, it seems pretty straight forward and if i get time this weekend i might knock it out</z><z id="t1588957782089000" t="oskarkv I&apos;m not completely sure I understand everything you said. Can I only use = in query constraints?"><y>#</y><d>2020-05-08</d><h>17:09</h><w>oskarkv</w>I&apos;m not completely sure I understand everything you said. Can I only use <code>=</code> in query constraints?</z><z id="t1588966628089200" t="ethanc yes"><y>#</y><d>2020-05-08</d><h>19:37</h><w>ethanc</w>yes</z><z id="t1588966953094000" t="ethanc in the context of the query (= ?x x) is defining a binding of :?x , when querying the memory of a session the bindings of the query denoted by the query parameters are used. meaning a defquery like: (defquery some-query [:?x] [?a &lt;- SomeFact (= ?x x) (= ?y y)]) would use: {:?x &lt;val&gt;} to retrieve the values of the query from the session."><y>#</y><d>2020-05-08</d><h>19:42</h><w>ethanc</w>in the context of the query
<pre>(= ?x x)</pre>
is defining a binding of <code>:?x</code>, when querying the memory of a session the bindings of the query denoted by the query parameters are used.

meaning a defquery like:
<pre>(defquery some-query
  [:?x]
  [?a &lt;- SomeFact (= ?x x) (= ?y y)])</pre>
would use:
<pre>{:?x &lt;val&gt;}</pre>
to retrieve the values of the query from the session.</z><z id="t1588967037095200" t="ethanc where value is provided from the clara.rule/query function like: (r/query session some-query :?x 42)"><y>#</y><d>2020-05-08</d><h>19:43</h><w>ethanc</w>where value is provided from the clara.rule/query function like:
<pre>(r/query session some-query :?x 42)</pre></z><z id="t1588967310097900" t="ethanc however today clara allows arbitrary values to be provided to the query, like: (r/query session some-query :?x 42 :?v 1 :?w 2) this causes the retrieval from memory to miss tokens as it simply assumes that all values passed are valid bindings."><y>#</y><d>2020-05-08</d><h>19:48</h><w>ethanc</w>however today clara allows arbitrary values to be provided to the query, like:
<pre>(r/query session some-query :?x 42 :?v 1 :?w 2)</pre>
this causes the retrieval from memory to miss tokens as it simply assumes that all values passed are valid bindings.</z><z id="t1589367016098400" t="oskarkv When using :exists , adding a binding variable changes the behaviour of the rule, making it trigger more times. For example (only difference being ?i &lt;- in more ): (cr/defrule more [?p &lt;- Player (= id ?id)] [:exists [?i &lt;- Item (= id ?id)]] =&gt; (println &quot;more&quot; ?p)) (cr/defrule less [?p &lt;- Player (= id ?id)] [:exists [Item (= id ?id)]] =&gt; (println &quot;less&quot; ?p)) prints: more #claraz.rules.Player{:id 2, :y 2} more #claraz.rules.Player{:id 1, :y 1} more #claraz.rules.Player{:id 2, :y 2} more #claraz.rules.Player{:id 1, :y 1} more #claraz.rules.Player{:id 1, :y 1} less #claraz.rules.Player{:id 2, :y 2} less #claraz.rules.Player{:id 1, :y 1} I find that a bit unintuitive. Is it supposed to be this way?"><y>#</y><d>2020-05-13</d><h>10:50</h><w>oskarkv</w>When using <code>:exists</code>, adding a binding variable changes the behaviour of the rule, making it trigger more times. For example (only difference being <code>?i &lt;-</code> in <code>more</code>):
<pre>(cr/defrule more
  [?p &lt;- Player (= id ?id)]
  [:exists [?i &lt;- Item (= id ?id)]]
  =&gt;
  (println &quot;more&quot; ?p))

(cr/defrule less
  [?p &lt;- Player (= id ?id)]
  [:exists [Item (= id ?id)]]
  =&gt;
  (println &quot;less&quot; ?p))</pre>
prints:
<pre>more #claraz.rules.Player{:id 2, :y 2}
more #claraz.rules.Player{:id 1, :y 1}
more #claraz.rules.Player{:id 2, :y 2}
more #claraz.rules.Player{:id 1, :y 1}
more #claraz.rules.Player{:id 1, :y 1}
less #claraz.rules.Player{:id 2, :y 2}
less #claraz.rules.Player{:id 1, :y 1}</pre>
I find that a bit unintuitive. Is it supposed to be this way?</z><z id="t1589375946098900" t="mikerod @oskarkv I think it’s invalid to do a “fact binding” on an :exists"><y>#</y><d>2020-05-13</d><h>13:19</h><w>mikerod</w>@oskarkv I think it’s invalid to do a “fact binding” on an <code>:exists</code></z><z id="t1589375956099200" t="mikerod Now that I see that syntax, makes me wonder why it works"><y>#</y><d>2020-05-13</d><h>13:19</h><w>mikerod</w>Now that I see that syntax, makes me wonder why it works</z><z id="t1589376300099500" t="mikerod So basically, I think more is invalid - but I guess it isn’t being checked well"><y>#</y><d>2020-05-13</d><h>13:25</h><w>mikerod</w>So basically, I think <code>more</code> is invalid - but I guess it isn’t being checked well</z><z id="t1589376315099900" t="mikerod I don’t understand how it could have any semantically meaningful compilation result"><y>#</y><d>2020-05-13</d><h>13:25</h><w>mikerod</w>I don’t understand how it could have any semantically meaningful compilation result</z><z id="t1589376327100200" t="mikerod :exists in general does not allow you to access the fact that “exists”"><y>#</y><d>2020-05-13</d><h>13:25</h><w>mikerod</w><code>:exists</code> in general does not allow you to access the fact that “exists”</z><z id="t1589376341100600" t="mikerod because it isn’t meaningful directly - there could be more than one"><y>#</y><d>2020-05-13</d><h>13:25</h><w>mikerod</w>because it isn’t meaningful directly - there could be more than one</z><z id="t1589376369101200" t="mikerod if you need to have an actual fact - and I suppose any fact will do for you - you should use an accumulator"><y>#</y><d>2020-05-13</d><h>13:26</h><w>mikerod</w>if you need to have an actual fact - and I suppose any fact will do for you - you should use an accumulator</z><z id="t1589376428102300" t="mikerod [?items &lt;- (acc/all) :from [Item ...]] =&gt; ;; choose one here ... (first ?items) ..."><y>#</y><d>2020-05-13</d><h>13:27</h><w>mikerod</w><pre>[?items &lt;- (acc/all) :from [Item ...]]
=&gt;
;; choose one here
... (first ?items) ...</pre></z><z id="t1589376507103000" t="mikerod In your case, you may be thinking that in your domain there is exactly 1 match or no matches. However, the rules do not know this"><y>#</y><d>2020-05-13</d><h>13:28</h><w>mikerod</w>In your case, you may be thinking that in your domain there is exactly 1 match or no matches. However, the rules do not know this</z><z id="t1589376546103600" t="mikerod I do find the situation where the syntax is allowing this fact binding to be put inside the :exists condition to be something to be addressed though"><y>#</y><d>2020-05-13</d><h>13:29</h><w>mikerod</w>I do find the situation where the syntax is allowing this fact binding to be put inside the <code>:exists</code> condition to be something to be addressed though</z><z id="t1590858996107600" t="narkisr Hi Clara team, iv been trying to use Clara rules within a graalvm native image and iv managed to compile it however its failing during runtime on the use of eval, is there an option iv missed to not use eval? (compile the rules ahead of time) https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L223 [{:type clojure.lang.ExceptionInfo :message Failed compiling alpha node {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [{:keys [?wildcard]} ?__fact__ ?__bindings__ (clojure.core/atom {:?e ?__fact__})] (clojure.core/let [?wildcard true] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?wildcard ?wildcard) (clojure.core/deref ?__bindings__)))), :condition {:type :grant.rules/user-spec, :constraints [(= ?wildcard true)], :args [{:keys [?wildcard]}], :fact-binding :?e}, :env nil} :data {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [{:keys [?wildcard]} ?__fact__ ?__bindings__ (clojure.core/atom {:?e ?__fact__})] (clojure.core/let [?wildcard true] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?wildcard ?wildcard) (clojure.core/deref ?__bindings__)))), :condition {:type :grant.rules/user-spec, :constraints [(= ?wildcard true)], :args [{:keys [?wildcard]}], :fact-binding :?e}, :env nil} :at [clara.rules.compiler$try_eval invokeStatic compiler.clj 238]} {:type clojure.lang.Compiler$CompilerException :message Syntax error compiling at (grant/rules.clj:15:0). :data {:clojure.error/phase :compile-syntax-check, :clojure.error/line 15, :clojure.error/column 0, :clojure.error/source grant/rules.clj} :at [clojure.lang.Compiler analyzeSeq Compiler.java 7115]} {:type java.lang.ClassNotFoundException :message clojure.lang.PersistentHashMap :at [com.oracle.svm.core.hub.ClassForNameSupport forName ClassForNameSupport.java 60]}] :trace [[com.oracle.svm.core.hub.ClassForNameSupport forName ClassForNameSupport.java 60] [java.lang.Class forName DynamicHub.java 1207] [clojure.lang.RT classForName RT.java 2211] [clojure.lang.RT classForNameNonLoading RT.java 2224] [clojure.lang.Compiler$HostExpr maybeClass Compiler.java 1041] [clojure.lang.Compiler macroexpand1 Compiler.java 7045] [clojure.lang.Compiler analyzeSeq Compiler.java 7093] "><y>#</y><d>2020-05-30</d><h>17:16</h><w>narkisr</w>Hi Clara team, iv been trying to use Clara rules within a graalvm native image and iv managed to compile it however its failing during runtime on the use of eval, is there an option iv missed to not use eval? (compile the rules ahead of time)

<a href="https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L223" target="_blank">https://github.com/cerner/clara-rules/blob/master/src/main/clojure/clara/rules/compiler.clj#L223</a>

<pre>[{:type clojure.lang.ExceptionInfo
   :message Failed compiling alpha node
{:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [{:keys [?wildcard]} ?__fact__ ?__bindings__ (clojure.core/atom {:?e ?__fact__})] (clojure.core/let [?wildcard true] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?wildcard ?wildcard) (clojure.core/deref ?__bindings__)))), :condition {:type :grant.rules/user-spec, :constraints [(= ?wildcard true)], :args [{:keys [?wildcard]}], :fact-binding :?e}, :env nil}

   :data {:expr (clojure.core/fn [?__fact__ ?__env__] (clojure.core/let [{:keys [?wildcard]} ?__fact__ ?__bindings__ (clojure.core/atom {:?e ?__fact__})] (clojure.core/let [?wildcard true] (clojure.core/swap! ?__bindings__ clojure.core/assoc :?wildcard ?wildcard) (clojure.core/deref ?__bindings__)))), :condition {:type :grant.rules/user-spec, :constraints [(= ?wildcard true)], :args [{:keys [?wildcard]}], :fact-binding :?e}, :env nil}
   :at [clara.rules.compiler$try_eval invokeStatic compiler.clj 238]}
  {:type clojure.lang.Compiler$CompilerException
   :message Syntax error compiling at (grant/rules.clj:15:0).
   :data {:clojure.error/phase :compile-syntax-check, :clojure.error/line 15, :clojure.error/column 0, :clojure.error/source grant/rules.clj}
   :at [clojure.lang.Compiler analyzeSeq Compiler.java 7115]}
  {:type java.lang.ClassNotFoundException
   :message clojure.lang.PersistentHashMap
   :at [com.oracle.svm.core.hub.ClassForNameSupport forName ClassForNameSupport.java 60]}]
 :trace
 [[com.oracle.svm.core.hub.ClassForNameSupport forName ClassForNameSupport.java 60]
  [java.lang.Class forName DynamicHub.java 1207]
  [clojure.lang.RT classForName RT.java 2211]
  [clojure.lang.RT classForNameNonLoading RT.java 2224]
  [clojure.lang.Compiler$HostExpr maybeClass Compiler.java 1041]
  [clojure.lang.Compiler macroexpand1 Compiler.java 7045]
  [clojure.lang.Compiler analyzeSeq Compiler.java 7093]</pre>
</z><z id="t1590861954113600" t="ethanc @narkisr Currently there is no such flag to disable eval, that mainly comes down to the fact that we have to evaluate user provided functions(RHS) and generated functions from the LHS of rules on the fly. Otherwise the forms produced by larger sessions would likely exceed some of the constraints of generated code sizes set by java. I am curious as to the use-case, are you AOT compiling the sessions themselves or are you trying to generate the sessions during runtime? I know @mikerod has been trying to untangle eval from rule compilation, but i believe that has been focused on Cljs as clara has been doing that wrong."><y>#</y><d>2020-05-30</d><h>18:05</h><w>ethanc</w>@narkisr
Currently there is no such flag to disable eval, that mainly comes down to the fact that we have to evaluate user provided functions(RHS) and generated functions from the LHS of rules on the fly. Otherwise the forms produced by larger sessions would likely exceed some of the constraints of generated code sizes set by java.

I am curious as to the use-case, are you AOT compiling the sessions themselves or are you trying to generate the sessions during runtime?

I know @mikerod has been trying to untangle eval from rule compilation, but i believe that has been focused on Cljs as clara has been doing that wrong.</z><z id="t1590862505115400" t="mikerod Cljs is closer to meeting that sort of requirement. The clj impl would not be easy to make happen. Unless it also went through a macro expansion type cljs like flow. Then again. I don’t even know exactly the constraints we’d have to use graal for this"><y>#</y><d>2020-05-30</d><h>18:15</h><w>mikerod</w>Cljs is closer to meeting that sort of requirement. The clj impl would not be easy to make happen. Unless it also went through a macro expansion type cljs like flow. Then again. I don’t even know exactly the constraints we’d have to use graal for this</z><z id="t1590862555116700" t="mikerod I’m guessing if macros could expand to code that avoided any eval and all fn instantiations were done via the compiler directly from the expanded code it’d work. Which is basically what cljs has to do"><y>#</y><d>2020-05-30</d><h>18:15</h><w>mikerod</w>I’m guessing if macros could expand to code that avoided any eval and all fn instantiations were done via the compiler directly from the expanded code it’d work. Which is basically what cljs has to do</z><z id="t1590862575117200" t="mikerod But only my current side branch of cljs at the moment. And it’s not functional yet. "><y>#</y><d>2020-05-30</d><h>18:16</h><w>mikerod</w>But only my current side branch of cljs at the moment. And it’s not functional yet. </z><z id="t1590892658119100" t="narkisr Graal&apos;s native-image doesn&apos;t support eval at the moment, I&apos;m not sure if there are any workarounds for this at the moment ill try to research that"><y>#</y><d>2020-05-31</d><h>02:37</h><w>narkisr</w>Graal&apos;s native-image doesn&apos;t support eval at the moment, I&apos;m not sure if there are any workarounds for this at the moment ill try to research that</z><z id="t1590932916122600" t="mikerod I wouldn’t expect it’d support eval since that’s just arbitrary bytecode being emitted at runtime. "><y>#</y><d>2020-05-31</d><h>13:48</h><w>mikerod</w>I wouldn’t expect it’d support eval since that’s just arbitrary bytecode being emitted at runtime. </z><z id="t1591186562124300" t="narkisr Yes I agree, still I think that having Clara in native image would have been really cool 🙂"><y>#</y><d>2020-06-03</d><h>12:16</h><w>narkisr</w>Yes I agree, still I think that having Clara in native image would have been really cool <b>🙂</b></z><z id="t1591188179125500" t="mikerod I agree but think cljs clara is most likely to come closer to supporting it than clj. At least as of now. I’m still working through issues there though. :exploding_head:"><y>#</y><d>2020-06-03</d><h>12:42</h><w>mikerod</w>I agree but think cljs clara is most likely to come closer to supporting it than clj. At least as of now. I’m still working through issues there though. <b>:exploding_head:</b></z><z id="t1591623202126600" t="Pieter Slabbert Hi, We are are going to be using clara rules at work, the example at http://www.clara-rules.org/docs/fact_type_fn_perf/ looks like it will be very useful for part of our system. There are many facts that we will use records for, but there is one kind of fact in particular which we have many different instances of the same fact but each with a different status (there can be quite a few of these statuses) Ideally we don&apos;t want to create a new type for each of these statuses. So I would like to be able to create a tuple as shown in the link, but I would also need to be able to write other conditions on it. There is a hint of how to do it on the page right at the bottom, but I can&apos;t seem to figure it out. Would anyone be able to provide a fleshed out example with extra conditions?"><y>#</y><d>2020-06-08</d><h>13:33</h><w>Pieter Slabbert</w>Hi, We are are going to be using clara rules at work, the example at <a href="http://www.clara-rules.org/docs/fact_type_fn_perf/" target="_blank">http://www.clara-rules.org/docs/fact_type_fn_perf/</a> looks like it will be very useful for part of our system.

There are many facts that we will use records for, but there is one kind of fact in particular which we have many different instances of the same fact but each with a different status (there can be quite a few of these statuses)  Ideally we don&apos;t want to create a new type for each of these statuses. So I would like to be able to create a tuple as shown in the link, but I would also need to be able to write other conditions on it.  There is a hint of how to do it on the page right at the bottom, but I can&apos;t seem to figure it out.  Would anyone be able to provide a fleshed out example with extra conditions?</z><z id="t1591625266129800" t="Felix Holmgren Hi everyone! 👋 I just (finally) published a podcast interview I did with @ryanbrush two years ago, about Clara. I would think most of it is still as relevant, but if Clara has changed in ways that make what&apos;s said in the interview misleading I&apos;d be happy to include pointers in the show notes. In any case, I would of course welcome any feedback/criticism from this community! https://thesearch.space/episodes/2-ryan-brush-on-retaking-rules-for-developers"><y>#</y><d>2020-06-08</d><h>14:07</h><w>Felix Holmgren</w>Hi everyone! <b>👋</b>   I just (finally) published a podcast interview I did with @ryanbrush two years ago, about Clara.
I would think most of it is still as relevant, but if Clara has changed in ways that make what&apos;s said in the interview misleading I&apos;d be happy to include pointers in the show notes. In any case, I would of course welcome any feedback/criticism from this community!
<a href="https://thesearch.space/episodes/2-ryan-brush-on-retaking-rules-for-developers" target="_blank">https://thesearch.space/episodes/2-ryan-brush-on-retaking-rules-for-developers</a></z><z id="t1591634816133800" t="mikerod @blob626 you’ve seen this one too http://www.clara-rules.org/docs/fact_type_customization/ ?"><y>#</y><d>2020-06-08</d><h>16:46</h><w>mikerod</w>@blob626 you’ve seen this one too <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a> ?</z><z id="t1591634823134200" t="mikerod the one you linked was more about performance than the feature use itself"><y>#</y><d>2020-06-08</d><h>16:47</h><w>mikerod</w>the one you linked was more about performance than the feature use itself</z><z id="t1591640891135100" t="ethanc @blob626, If I remember correctly you should be able to apply constraints to a condition even when using a custom fact type. However, the syntactic sugar that clara provides for field accessors would no longer be available. Meaning that you would have to provide custom destructuring for the fact or have the constraints access the fact via this and drill in that way. For example: (ns test.rules (:require [clara.rules :as r])) (defrecord SomeFact [id status another-identifier]) (defrecord IncompleteFact [id]) (r/defrule a-rule [[SomeFact &quot;id-1&quot;] [{:keys [another-identifier status]}] (= ?another-identifier another-identifier) (= status &quot;INCOMPLETE&quot;)] =&gt; (r/insert! (-&gt;IncompleteFact ?another-identifier))) (r/defquery get-incomplete-facts [] [?f &lt;- IncompleteFact]) (defn fact-type-fn [fact] (if (instance? SomeFact fact) [`SomeFact (:id fact)] (type fact))) (defn run-test [] (-&gt; (r/mk-session [a-rule get-incomplete-facts] :fact-type-fn fact-type-fn) (r/insert (-&gt;SomeFact &quot;id-1&quot; &quot;INCOMPLETE&quot; &quot;external-id&quot;)) (r/fire-rules) (r/query get-incomplete-facts))) Specifically, [{:keys [another-identifier status]}] "><y>#</y><d>2020-06-08</d><h>18:28</h><w>ethanc</w>@blob626,
If I remember correctly you should be able to apply constraints to a condition even when using a custom fact type. However, the syntactic sugar that clara provides for field accessors would no longer be available. Meaning that you would have to provide custom destructuring for the fact or have the constraints access the fact via <code>this</code> and drill in that way. For example:

<pre>(ns test.rules
  (:require [clara.rules :as r]))


(defrecord SomeFact [id status another-identifier])

(defrecord IncompleteFact [id])

(r/defrule a-rule
  [[SomeFact &quot;id-1&quot;] [{:keys [another-identifier status]}]
    (= ?another-identifier another-identifier)
    (= status &quot;INCOMPLETE&quot;)]
  =&gt;
  (r/insert! (-&gt;IncompleteFact ?another-identifier)))

(r/defquery get-incomplete-facts
  []
  [?f &lt;- IncompleteFact])

(defn fact-type-fn
  [fact]
  (if (instance? SomeFact fact)
    [`SomeFact (:id fact)]
    (type fact))) 

(defn run-test
  []
  (-&gt; (r/mk-session [a-rule get-incomplete-facts]
                    :fact-type-fn fact-type-fn)
      (r/insert (-&gt;SomeFact &quot;id-1&quot; &quot;INCOMPLETE&quot; &quot;external-id&quot;))
      (r/fire-rules)
      (r/query get-incomplete-facts)))</pre>
Specifically,
<pre>[{:keys [another-identifier status]}]</pre>
</z><z id="t1591646160136300" t="apbleonard Clara Rules has a mention in Rich Hickey&apos;s HOPL IV &quot;A History of Clojure&quot; paper! 🙂 https://clojure.org/about/history"><y>#</y><d>2020-06-08</d><h>19:56</h><w>apbleonard</w>Clara Rules has a mention in Rich Hickey&apos;s HOPL IV &quot;A History of Clojure&quot; paper! <b>🙂</b> <a href="https://clojure.org/about/history" target="_blank">https://clojure.org/about/history</a></z><z id="t1591647715136500" t="ethanc 😮"><y>#</y><d>2020-06-08</d><h>20:21</h><w>ethanc</w><b>😮</b></z><z id="t1591655345137000" t="mikerod thanks for making the example @ethanc"><y>#</y><d>2020-06-08</d><h>22:29</h><w>mikerod</w>thanks for making the example @ethanc</z><z id="t1591655349137200" t="mikerod perhaps our docs are too weak on this"><y>#</y><d>2020-06-08</d><h>22:29</h><w>mikerod</w>perhaps our docs are too weak on this</z><z id="t1591655355137400" t="mikerod I need to re-read through"><y>#</y><d>2020-06-08</d><h>22:29</h><w>mikerod</w>I need to re-read through</z><z id="t1591655376137900" t="mikerod and clara is in the history paper? wow, I’ve been meaning to read it. Clara’s officially famous 😜 \"><y>#</y><d>2020-06-08</d><h>22:29</h><w>mikerod</w>and clara is in the history paper? wow, I’ve been meaning to read it. Clara’s officially famous <b>😜</b>\</z><z id="t1591686227140000" t="Pieter Slabbert @mikerod I saw that link but I couldn&apos;t quite see how to make it work for what I needed. (probably just me missing something) @ethanc Thanks, that was exactly what I needed"><y>#</y><d>2020-06-09</d><h>07:03</h><w>Pieter Slabbert</w>@mikerod I saw that link but I couldn&apos;t quite see how to make it work for what I needed. (probably just me missing something)

@ethanc Thanks, that was exactly what I needed</z><z id="t1591714554140600" t="ethanc side note to the previous post, http://www.clara-rules.org/docs/fact_type_fn_perf/ im not 100% sure that demo works"><y>#</y><d>2020-06-09</d><h>14:55</h><w>ethanc</w>side note to the previous post,
<a href="http://www.clara-rules.org/docs/fact_type_fn_perf/" target="_blank">http://www.clara-rules.org/docs/fact_type_fn_perf/</a>
im not 100% sure that demo works</z><z id="t1592576476147000" t="kvlt Hey all, is there a way to insert multiple records inside of a rule, one for each item in a list. Sorry, I think I&apos;m not sure how to properly ask this but I think my example should describe this pretty well: (defrule somerule [SomeRecord (= ?list-of-ids list-of-ids)] =&gt; (for [id ?list-of-ids] (insert! (-&gt;Addition id :some-key &quot;icecream&quot;))))"><y>#</y><d>2020-06-19</d><h>14:21</h><w>kvlt</w>Hey all, is there a way to <code>insert</code> multiple records inside of a rule, one for each item in a list. Sorry, I think I&apos;m not sure how to properly ask this but I think my example should describe this pretty well:

<pre>(defrule somerule
  [SomeRecord  (= ?list-of-ids list-of-ids)]
  =&gt;
  (for [id ?list-of-ids]
    (insert! (-&gt;Addition id :some-key &quot;icecream&quot;))))</pre></z><z id="t1592576647148200" t="mbragg There is insert-all! that accepts a sequence of facts which may be useful to you https://cljdoc.org/d/com.cerner/clara-rules/0.20.0/api/clara.rules#insert-all !"><y>#</y><d>2020-06-19</d><h>14:24</h><w>mbragg</w>There is <code>insert-all!</code>that accepts a sequence of facts which may be useful to you <a href="https://cljdoc.org/d/com.cerner/clara-rules/0.20.0/api/clara.rules#insert-all" target="_blank">https://cljdoc.org/d/com.cerner/clara-rules/0.20.0/api/clara.rules#insert-all</a>!</z><z id="t1592576694149000" t="kvlt @mbragg yes! but how do I generate that sequence of facts? It does not allow me to iterate over ?list-of-ids"><y>#</y><d>2020-06-19</d><h>14:24</h><w>kvlt</w>@mbragg yes! but how do I generate that sequence of facts? It does not allow me to iterate over <code>?list-of-ids</code></z><z id="t1592576992149500" t="kvlt Oh, I was wrong, I was really tired last night. Thank you @mbragg"><y>#</y><d>2020-06-19</d><h>14:29</h><w>kvlt</w>Oh, I was wrong, I was really tired last night. Thank you @mbragg</z><z id="t1592755226153400" t="nick Hey all I was wondering if there is a simpler way to rewrite this? (defrule calc-total-sum [?total1 &lt;- (acc/reduce-to-accum (fn [previous value] (+ previous (get-amount value))) 0 ) :from [Record1]] [?total2 &lt;- (acc/reduce-to-accum (fn [previous value] (+ previous (get-amount value))) 0 ) :from [Record2]] =&gt; (insert! (-&gt;TotalAmount (+ ?total1 ?total2)))) I have lots of record types like RecordN(in this simplified example) defrecord-s and all of them implement the same protocol(`get-amount` func) I&apos;m trying to get the total amount for all those record types. Ideally this would be just a single reduce-to-accum with :from [Record1 Record2 ...] or :from [[Record1] [Record2] [...]] but it doesn&apos;t seem to work."><y>#</y><d>2020-06-21</d><h>16:00</h><w>nick</w>Hey all

I was wondering if there is a simpler way to rewrite this?
<pre>(defrule calc-total-sum
  [?total1 &lt;- (acc/reduce-to-accum (fn [previous value]
                                     (+ previous (get-amount value)))
                                   0
                                   ) :from [Record1]]
  [?total2 &lt;- (acc/reduce-to-accum (fn [previous value]
                                     (+ previous (get-amount value)))
                                   0
                                   ) :from [Record2]]
  =&gt;
  (insert! (-&gt;TotalAmount (+ ?total1 ?total2))))</pre>
I have lots of record types like RecordN(in this simplified example) defrecord-s and all of them implement the same protocol(`get-amount` func)

I&apos;m trying to get the total amount for all those record types.
Ideally this would be just a single reduce-to-accum with <code>:from [Record1 Record2 ...]</code> or <code>:from [[Record1] [Record2] [...]]</code> but it doesn&apos;t seem to work.</z><z id="t1592831153154700" t="mbragg Have you seen http://www.clara-rules.org/docs/fact_type_customization/ ? This would allow you to match on the ancestor type and just have the single accumulator."><y>#</y><d>2020-06-22</d><h>13:05</h><w>mbragg</w>Have you seen <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a>? This would allow you to match on the ancestor type and just have the single accumulator.</z><z id="t1592832078156400" t="ethanc Another option would be to leverage interfaces and allow the default ancestors function to handle it. Something like: (ns test.interfaces (:require [clara.rules :as r] [clara.rules.accumulators :as acc])) (definterface Summable (^long amount [])) (defrecord RecordOne [x] Summable (amount [_] x)) (defrecord RecordTwo [y] Summable (amount [_] y)) (defrecord Sum [z]) (r/defrule sum-rule [?s &lt;- (acc/sum #(.amount ^Summable %)) :from [Summable]] =&gt; (r/insert! (-&gt;Sum ?s))) (r/defquery sum-query [] [?s &lt;- Sum]) (defn run-test [] (-&gt; (r/mk-session) (r/insert (-&gt;RecordOne 1) (-&gt;RecordOne 2) (-&gt;RecordTwo 3) (-&gt;RecordTwo 4)) (r/fire-rules) (r/query sum-query))) ;; (run-test) ;; =&gt; ({:?s #test.interfaces.Sum{:z 10}})"><y>#</y><d>2020-06-22</d><h>13:21</h><w>ethanc</w>Another option would be to leverage interfaces and allow the default ancestors function to handle it.
Something like:
<pre>(ns test.interfaces
  (:require [clara.rules :as r]
            [clara.rules.accumulators :as acc]))

(definterface Summable
  (^long amount []))


(defrecord RecordOne [x]
  Summable
  (amount [_] x))

(defrecord RecordTwo [y]
  Summable
  (amount [_] y))


(defrecord Sum [z])


(r/defrule sum-rule
  [?s &lt;- (acc/sum #(.amount ^Summable %)) :from [Summable]]
  =&gt;
  (r/insert! (-&gt;Sum ?s)))

(r/defquery sum-query
  []
  [?s &lt;- Sum])

(defn run-test
  []
  (-&gt; (r/mk-session)
      (r/insert (-&gt;RecordOne 1)
                (-&gt;RecordOne 2)
                (-&gt;RecordTwo 3)
                (-&gt;RecordTwo 4))
      (r/fire-rules)
      (r/query sum-query)))

;; (run-test)
;; =&gt; ({:?s #test.interfaces.Sum{:z 10}})</pre></z><z id="t1592832157157600" t="ethanc this assumes you own the definition of the records in the session. Otherwise, @mbragg solution would likely be easier"><y>#</y><d>2020-06-22</d><h>13:22</h><w>ethanc</w>this assumes you own the definition of the records in the session. Otherwise, @mbragg solution would likely be easier</z><z id="t1592834034158000" t="ethanc cc. @nfedyashev"><y>#</y><d>2020-06-22</d><h>13:53</h><w>ethanc</w>cc. @nfedyashev</z><z id="t1592834215158500" t="nick @mbragg @ethanc Perfect! Thank you so much"><y>#</y><d>2020-06-22</d><h>13:56</h><w>nick</w>@mbragg @ethanc Perfect! Thank you so much</z><z id="t1592934868160200" t="kvlt How does one distribute rules over multiple ns&apos;s? mk-session seems to imply that I can pass in multiple ns&apos;s (mk-session [&apos;my.core &apos;my.somethingelse] :cache false) But it appears this is not the case"><y>#</y><d>2020-06-23</d><h>17:54</h><w>kvlt</w>How does one distribute rules over multiple ns&apos;s?
<code>mk-session</code> seems to imply that I can pass in multiple ns&apos;s

<pre>(mk-session [&apos;my.core &apos;my.somethingelse] :cache false) </pre>
But it appears this is not the case</z><z id="t1592935201161700" t="mbragg You can just pass the namespaces as args I.e (mk-session &apos;my.core &apos;my.somethingelse :cache false) "><y>#</y><d>2020-06-23</d><h>18:00</h><w>mbragg</w>You can just pass the namespaces as args I.e
<pre>(mk-session &apos;my.core &apos;my.somethingelse :cache false) </pre></z><z id="t1592935225162300" t="kvlt Oh, sorry, it&apos;s &amp; args"><y>#</y><d>2020-06-23</d><h>18:00</h><w>kvlt</w>Oh, sorry, it&apos;s <code>&amp;</code> args</z><z id="t1592935231162500" t="kvlt You&apos;re right, sorry for the stupid question"><y>#</y><d>2020-06-23</d><h>18:00</h><w>kvlt</w>You&apos;re right, sorry for the stupid question</z><z id="t1592935272163100" t="mbragg No worries 😀"><y>#</y><d>2020-06-23</d><h>18:01</h><w>mbragg</w>No worries <b>😀</b></z><z id="t1593441853164900" t="Matthew Pettis Is there a way to just dump or inspect all of the facts that exist in a session? I am thinking about looking at taking a session (which has to be defined with a static set of rules, if I understand correctly), dumping the facts, and creating a new session with a different set of rules to apply to the facts from the previous session."><y>#</y><d>2020-06-29</d><h>14:44</h><w>Matthew Pettis</w>Is there a way to just dump or inspect all of the facts that exist in a session?  I am thinking about looking at taking a session (which has to be defined with a static set of rules, if I understand correctly), dumping the facts, and creating a new session with a different set of rules to apply to the facts from the previous session.</z><z id="t1593444485166100" t="Matthew Pettis Also, I&apos;ve seen in youtube talks some (at the time, just alpha-level) tools that will diagram out a set of rules or fact-firings on the given state of the working memory. Does anyone have any links to tools like this to play with?"><y>#</y><d>2020-06-29</d><h>15:28</h><w>Matthew Pettis</w>Also, I&apos;ve seen in youtube talks some (at the time, just alpha-level) tools that will diagram out a set of rules or fact-firings on the given state of the working memory.  Does anyone have any links to tools like this to play with?</z><z id="t1593456897167300" t="mbragg @matthew.pettis You can inspect a session to return a number of different rule/fact data structures http://www.clara-rules.org/apidocs/0.9.0/clojure/clara.tools.inspect.html"><y>#</y><d>2020-06-29</d><h>18:54</h><w>mbragg</w>@matthew.pettis You can inspect a session to return a number of different rule/fact data structures <a href="http://www.clara-rules.org/apidocs/0.9.0/clojure/clara.tools.inspect.html" target="_blank">http://www.clara-rules.org/apidocs/0.9.0/clojure/clara.tools.inspect.html</a></z><z id="t1593456991167900" t="mbragg That should enable you to retrieve all the facts inserted"><y>#</y><d>2020-06-29</d><h>18:56</h><w>mbragg</w>That should enable you to retrieve all the facts inserted</z><z id="t1593457141168600" t="mbragg https://github.com/rbrush/clara-tools might of been what you saw in that YouTube talk"><y>#</y><d>2020-06-29</d><h>18:59</h><w>mbragg</w><a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a> might of been what you saw in that YouTube talk</z><z id="t1593459284169800" t="mikerod @matthew.pettis in general I’d say it’s best to make targeted queries that you use to extract the facts you want to use in the next set of rules. "><y>#</y><d>2020-06-29</d><h>19:34</h><w>mikerod</w>@matthew.pettis in general I’d say it’s best to make targeted queries that you use to extract the facts you want to use in the next set of rules. </z><z id="t1593459318170300" t="mikerod That’s your smoothest path forward. "><y>#</y><d>2020-06-29</d><h>19:35</h><w>mikerod</w>That’s your smoothest path forward.  </z><z id="t1593459420171400" t="mikerod There are some inspect namespaces and stuff in clara you can look at too. But typically more for inspection at a different sort of level"><y>#</y><d>2020-06-29</d><h>19:37</h><w>mikerod</w>There are some inspect namespaces and stuff in clara you can look at too. But typically more for inspection at a different sort of level</z><z id="t1593459433171900" t="mikerod I’m just on mobile so can’t pull up much currently"><y>#</y><d>2020-06-29</d><h>19:37</h><w>mikerod</w>I’m just on mobile so can’t pull up much currently</z><z id="t1593459501173600" t="mikerod Clara-tools maybe relevant. I think the codebase is likely outdated though. But perhaps gives extra insight. Clara has inspection and tracing things built in to an extent too. And then there is a listener api you can hook into if you require more specific things. "><y>#</y><d>2020-06-29</d><h>19:38</h><w>mikerod</w>Clara-tools maybe relevant. I think the codebase is likely outdated though. But perhaps gives extra insight. Clara has inspection and tracing things built in to an extent too. And then there is a listener api you can hook into if you require more specific things. </z><z id="t1593460740174300" t="Matthew Pettis Thanks @mbragg and @mikerod -- I&apos;ll take a look at these things."><y>#</y><d>2020-06-29</d><h>19:59</h><w>Matthew Pettis</w>Thanks @mbragg and @mikerod -- I&apos;ll take a look at these things.</z><z id="t1593465810178400" t="wparker Agreed that if you need to pull out facts, targeted queries are probably the way to go. You could write a query that would match all facts e.g. against Object on the JVM, but the performance impact of that could be significant. You might consider whether you actually need multiple sessions though - what is the motivation there as opposed to having the facts you’re extracting trigger those rules in the same session? You could use a design pattern where you have subsets of your system that have “private” facts that by convention are only used in say a particular namespace, and “glue” facts that connect different parts. It is highly domain-dependent but that’s a pattern I’ve used before. @matthew.pettis"><y>#</y><d>2020-06-29</d><h>21:23</h><w>wparker</w>Agreed that if you need to pull out facts, targeted queries are probably the way to go.  You could write a query that would match all facts e.g. against Object on the JVM, but the performance impact of that could be significant.  You might consider whether you actually need multiple sessions though - what is the motivation there as opposed to having the facts you’re extracting trigger those rules in the same session?  You could use a design pattern where you have subsets of your system that have “private” facts that by convention are only used in say a particular namespace, and “glue” facts that connect different parts.   It is highly domain-dependent but that’s a pattern I’ve used before. @matthew.pettis</z><z id="t1593522784183700" t="Matthew Pettis @wparker Thanks for this. At this point, I am honestly just exploring, and thinking more about the ability to see the complete state of a session after starting with an initial fact set and seeing what all gets generated by firing the rules. I&apos;m thinking more about a diagnostic to just dump a session and being able to talk through with someone &quot;If you start with these rules and this initial fact set, this is the final set of facts that end up in the session.&quot; Starting with that fact set and triggering another set of rules was just a thought experiment, but looking at a given state thoroughly was the main driver. The session use cases I can think of probably won&apos;t be all that large in terms of facts, or at least initial facts, but might get a lot of derived facts with the rule set I put into the session. I like the &quot;private&quot; and &quot;glue&quot; facts approach... I was thinking along the lines of &quot;initial&quot; and &quot;derived&quot; facts from rules, and comparing those two sets."><y>#</y><d>2020-06-30</d><h>13:13</h><w>Matthew Pettis</w>@wparker Thanks for this.  At this point, I am honestly just exploring, and thinking more about the ability to see the complete state of a session after starting with an initial fact set and seeing what all gets generated by firing the rules.  I&apos;m thinking more about a diagnostic to just dump a session and being able to talk through with someone &quot;If you start with these rules and this initial fact set, this is the final set of facts that end up in the session.&quot;  Starting with that fact set and triggering another set of rules was just a thought experiment, but looking at a given state thoroughly was the main driver.  The session use cases I can think of probably won&apos;t be all that large in terms of facts, or at least initial facts, but might get a lot of derived facts with the rule set I put into the session.  I like the &quot;private&quot; and &quot;glue&quot; facts approach... I was thinking along the lines of &quot;initial&quot; and &quot;derived&quot; facts from rules, and comparing those two sets.</z><z id="t1593581259189600" t="mac Is there an idiomatic way to do hierarchical rules in clara? I have a set of rules that all calculate the same property from a fact but I would like the calculation only to be made by the most specific of the rules that match. I have tried inserting a guard fact when a rule (e.g. [:not [:guard (= (:active this) true] and (insert! {:type guard :active true} ) matches and using salience to control firing order, but this results in an endless loop for reasons I cannot figure out."><y>#</y><d>2020-07-01</d><h>05:27</h><w>mac</w>Is there an idiomatic way to do hierarchical rules in clara? I have a set of rules that all calculate the same property from a fact but I would like the calculation only to be made by the most specific of the rules that match. I have tried inserting a guard fact when a rule (e.g. <code>[:not [:guard (= (:active this) true] and (insert! {:type guard :active true}</code> ) matches and using salience to control firing order, but this results in an endless loop for reasons I cannot figure out.</z><z id="t1593597604190600" t="mac As an example I don&apos;t understand why the code below goes into an endless loop. (defrule test-rule &quot;test guard&quot; [:not [:guard (= (:active this) true)]] =&gt; (do (println &quot;Inserting guard!&quot;) (insert! {:type :guard :active true}))) (-&gt; (mk-session [test-rule] :fact-type-fn :type) (fire-rules))"><y>#</y><d>2020-07-01</d><h>10:00</h><w>mac</w>As an example I don&apos;t understand why the code below goes into an endless loop.
<pre>(defrule test-rule
    &quot;test guard&quot;
    [:not [:guard (= (:active this) true)]]
    =&gt;
    (do
      (println &quot;Inserting guard!&quot;)
      (insert! {:type :guard :active true})))
  (-&gt; (mk-session [test-rule]
                  :fact-type-fn :type)
      (fire-rules))</pre></z><z id="t1593601563191100" t="mikerod @mac use a different guard type for each tier"><y>#</y><d>2020-07-01</d><h>11:06</h><w>mikerod</w>@mac use a different guard type for each tier</z><z id="t1593601573191400" t="mikerod Where the rule never inserts it’s own type"><y>#</y><d>2020-07-01</d><h>11:06</h><w>mikerod</w>Where the rule never inserts it’s own type</z><z id="t1593601928192400" t="mikerod @mac https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac this actually has a somewhat similar model as well. For a slightly different goal but notice the guarding not conditions "><y>#</y><d>2020-07-01</d><h>11:12</h><w>mikerod</w>@mac <a href="https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac" target="_blank">https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac</a> this actually has a somewhat similar model as well. For a slightly different goal but notice the guarding not conditions </z><z id="t1593602368193200" t="mac @mikerod Thanks, the gist looks very useful. Do you know why my example would loop?"><y>#</y><d>2020-07-01</d><h>11:19</h><w>mac</w>@mikerod Thanks, the gist looks very useful. Do you know why my example would loop?</z><z id="t1593603038194100" t="mikerod @mac the rules attempt to find a logical consistency balance"><y>#</y><d>2020-07-01</d><h>11:30</h><w>mikerod</w>@mac the rules attempt to find a logical consistency balance</z><z id="t1593603054194600" t="mikerod Your rule Left side condition is invalidated when the right side inserts. "><y>#</y><d>2020-07-01</d><h>11:30</h><w>mikerod</w>Your rule Left side condition is invalidated when the right side inserts. </z><z id="t1593603069195200" t="mikerod The engine then retracts that’s fact because it is no longer logically supported. "><y>#</y><d>2020-07-01</d><h>11:31</h><w>mikerod</w>The engine then retracts that’s fact because it is no longer logically supported. </z><z id="t1593603088195500" t="mikerod It’s called the truth maintenance system"><y>#</y><d>2020-07-01</d><h>11:31</h><w>mikerod</w>It’s called the truth maintenance system</z><z id="t1593603119196400" t="mikerod Then it can activate again and re insert. And again it invalidates itself. So it’s logical looping"><y>#</y><d>2020-07-01</d><h>11:31</h><w>mikerod</w>Then it can activate again and re insert. And again it invalidates itself. So it’s logical looping</z><z id="t1593603323198000" t="mac @mikerod OK, so the guard gets removed because the LHS match that caused it to be inserted no longer matches?"><y>#</y><d>2020-07-01</d><h>11:35</h><w>mac</w>@mikerod OK, so the guard gets removed because the LHS match that caused it to be inserted no longer matches?</z><z id="t1593607149198200" t="mikerod Yes"><y>#</y><d>2020-07-01</d><h>12:39</h><w>mikerod</w>Yes</z><z id="t1593607173199000" t="mikerod Think of rules not like in order. But instead that the rhs facts inserted are supported by the lhs "><y>#</y><d>2020-07-01</d><h>12:39</h><w>mikerod</w>Think of rules not like in order. But instead that the rhs facts inserted are supported by the lhs </z><z id="t1593612448200000" t="mac @mikerod Got it, this is much closer to logic programming than I thought, but it makes sense when framed like that."><y>#</y><d>2020-07-01</d><h>14:07</h><w>mac</w>@mikerod Got it, this is much closer to logic programming than I thought, but it makes sense when framed like that.</z><z id="t1594244858200900" t="Matthew Pettis Regarding fact-type customization, from here: https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj"><y>#</y><d>2020-07-08</d><h>21:47</h><w>Matthew Pettis</w>Regarding fact-type customization, from here: <a href="https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj" target="_blank">https://github.com/cerner/clara-examples/blob/master/src/main/clojure/clara/examples/fact_type_options.clj</a></z><z id="t1594244960201400" t="Matthew Pettis Can someone explain how this works to find ancestors?"><y>#</y><d>2020-07-08</d><h>21:49</h><w>Matthew Pettis</w>Can someone explain how this works to find ancestors?</z><z id="t1594244975201600" t="Matthew Pettis (def custom-ancestors-fn {:precise-temperature-reading #{:temperature-reading}})"><y>#</y><d>2020-07-08</d><h>21:49</h><w>Matthew Pettis</w><code>(def custom-ancestors-fn {:precise-temperature-reading #{:temperature-reading}})</code></z><z id="t1594245057202700" t="Matthew Pettis I get that a map can work in the function position, and will look up the value for a key given as argument, but I am struggling to see how this def works as a function to look up ancestors."><y>#</y><d>2020-07-08</d><h>21:50</h><w>Matthew Pettis</w>I get that a map can work in the function position, and will look up the value for a key given as argument, but I am struggling to see how this def works as a function to look up ancestors.</z><z id="t1594303968204100" t="ethanc The def itself isn’t special, its just handed off to the mk-session call. Unless I am miss interpreting your question"><y>#</y><d>2020-07-09</d><h>14:12</h><w>ethanc</w>The def itself isn’t special, its just handed off to the <code>mk-session</code> call. Unless I am miss interpreting your question</z><z id="t1594304166204700" t="mikerod @matthew.pettis I think I don’t know exactly what you are asking either, but perhaps you are just trying to understand what the ancestors fn does?"><y>#</y><d>2020-07-09</d><h>14:16</h><w>mikerod</w>@matthew.pettis I think I don’t know exactly what you are asking either, but perhaps you are just trying to understand what the ancestors fn does?</z><z id="t1594304178205000" t="mikerod it takes a type, and returns a set of ancestors"><y>#</y><d>2020-07-09</d><h>14:16</h><w>mikerod</w>it takes a type, and returns a set of ancestors</z><z id="t1594304215205700" t="mikerod And in rules, a type T matches any rule type that is the same type T or any ancestor in the set of ancestors of T - as returned from ancestors fn"><y>#</y><d>2020-07-09</d><h>14:16</h><w>mikerod</w>And in rules, a type T matches any rule type that is the same type T or any ancestor in the set of ancestors of T - as returned from ancestors fn</z><z id="t1594304256206100" t="mikerod the docs http://www.clara-rules.org/docs/fact_type_customization/ here seem to explain this with an example though - so not sure this is where you the confusion is"><y>#</y><d>2020-07-09</d><h>14:17</h><w>mikerod</w>the docs <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a> here seem to explain this with an example though - so not sure this is where you the confusion is</z><z id="t1594304318207300" t="mikerod &gt; I get that a map can work in the function position, and will look up the value for a key given as argument, but I am struggling to see how this def works as a function to look up ancestors. A map is a fn of 1 argument. It looks no different from the callers perspective. So the clara-rules engine has a fact with type T, it looks up ancestors like: (ancestors-fn T) which returns the ancestor types"><y>#</y><d>2020-07-09</d><h>14:18</h><w>mikerod</w>&gt; I get that a map can work in the function position, and will look up the value for a key given as argument, but I am struggling to see how this def works as a function to look up ancestors.
A map is a fn of 1 argument. It looks no different from the callers perspective.
So the clara-rules engine has a fact with type T, it looks up ancestors like:
<code>(ancestors-fn T)</code> which returns the ancestor types</z><z id="t1594304381208000" t="mikerod in pure clj with the above example: (let [ancestors-fn {:precise-temperature-reading #{:temperature-reading}}] (ancestors-fn :precise-temperature-reading)) ;;= #{:temperature-reading}}"><y>#</y><d>2020-07-09</d><h>14:19</h><w>mikerod</w>in pure clj with the above example:
<pre>(let [ancestors-fn {:precise-temperature-reading #{:temperature-reading}}]
  (ancestors-fn :precise-temperature-reading))
;;= #{:temperature-reading}}</pre></z><z id="t1594306314212800" t="Matthew Pettis @mikerod Thanks, I think that what you said is enough for me. The missing thing for me, which I understand from your code snipped, is that it interacts with the fact-type-function. That is, it seems that first the fact-type-function is used to get a value, and then that value (like :precise-temperature-reading), and then that is the argument to the ancestor-fn, which returns a set of ancestors that the argument belongs to, and then rules that use any of those ancestors are considered. I was trying to figure out how that ancestor-fn could be applied directly to the the fact, instead of the result of the fact-type-function applied to the fact."><y>#</y><d>2020-07-09</d><h>14:51</h><w>Matthew Pettis</w>@mikerod Thanks, I think that what you said is enough for me.  The missing thing for me, which I understand from your code snipped, is that it interacts with the fact-type-function.  That is, it seems that first the fact-type-function is used to get a value, and then that value (like :precise-temperature-reading), and then that is the argument to the ancestor-fn, which returns a set of ancestors that the argument belongs to, and then rules that use any of those ancestors are considered.  I was trying to figure out how that ancestor-fn could be applied directly to the the fact, instead of the result of the fact-type-function applied to the fact.</z><z id="t1594306363213700" t="Matthew Pettis So, in short, I was missing that ancestor-fn operated on the result of fact-type-fn, not on the original fact itself, which I couldn&apos;t see how that would work."><y>#</y><d>2020-07-09</d><h>14:52</h><w>Matthew Pettis</w>So, in short, I was missing that ancestor-fn operated on the result of fact-type-fn, not on the original fact itself, which I couldn&apos;t see how that would work.</z><z id="t1594307114213900" t="mikerod yes exactly!"><y>#</y><d>2020-07-09</d><h>15:05</h><w>mikerod</w>yes exactly!</z><z id="t1594934200217200" t="sekao is there any way, either with the public API or with private stuff, that i can determine which fact(s) caused a rule to fire? something that i could check in the right hand side of a rule. i tried looking in clara.rules.engine/**rule-context** but the :token inside it seems to contain all matching facts, not just the ones that triggered the rule."><y>#</y><d>2020-07-16</d><h>21:16</h><w>sekao</w>is there any way, either with the public API or with private stuff, that i can determine which fact(s) caused a rule to fire? something that i could check in the right hand side of a rule. i tried looking in <code>clara.rules.engine/**rule-context**</code> but the <code>:token</code> inside it seems to contain all matching facts, not just the ones that triggered the rule.</z><z id="t1594941196217900" t="mikerod @sekao if you use a fact level binding you have the fact available as a binding on rhs "><y>#</y><d>2020-07-16</d><h>23:13</h><w>mikerod</w>@sekao if you use a fact level binding you have the fact available as a binding on rhs </z><z id="t1594941242218800" t="mikerod [?fact &lt;- Something] =&gt; "><y>#</y><d>2020-07-16</d><h>23:14</h><w>mikerod</w>[?fact &lt;- Something] =&gt; </z><z id="t1594943065221600" t="sekao yes but what i&apos;m hoping to figure out is which of the bound facts actually caused the rule to fire. so if i have three facts bound on the lhs, in the rhs i want to know which of the three caused the current execution. i&apos;m guessing this info is not available anywhere?"><y>#</y><d>2020-07-16</d><h>23:44</h><w>sekao</w>yes but what i&apos;m hoping to figure out is which of the bound facts actually caused the rule to fire. so if i have three facts bound on the lhs, in the rhs i want to know which of the three caused the current execution. i&apos;m guessing this info is not available anywhere?</z><z id="t1594943180223400" t="sekao during the first execution the answer will be &quot;all three caused it to fire&quot;, but if i insert a new fact that matches the first binding, for example, the rule will execute a second time, and i want to know that the first binding was what caused that second execution."><y>#</y><d>2020-07-16</d><h>23:46</h><w>sekao</w>during the first execution the answer will be &quot;all three caused it to fire&quot;, but if i insert a new fact that matches the first binding, for example, the rule will execute a second time, and i want to know that the first binding was what caused that second execution.</z><z id="t1594987976224600" t="mikerod @sekao each time there is a match it’s a new rule firing. The cause is whatever the combination of facts it was to cause the rule to fire. "><y>#</y><d>2020-07-17</d><h>12:12</h><w>mikerod</w>@sekao each time there is a match it’s a new rule firing. The cause is whatever the combination of facts it was to cause the rule to fire. </z><z id="t1594987990225100" t="mikerod Seems an odd thing you are trying to distinguish. "><y>#</y><d>2020-07-17</d><h>12:13</h><w>mikerod</w>Seems an odd thing you are trying to distinguish. </z><z id="t1595000907227200" t="sekao fair enough. the reason i&apos;m interested in this is that it would potentially be a way to make updating facts within rules more ergonomic (avoiding the infinite loop problem). but it may not fit how clara works underneath."><y>#</y><d>2020-07-17</d><h>15:48</h><w>sekao</w>fair enough. the reason i&apos;m interested in this is that it would potentially be a way to make updating facts within rules more ergonomic (avoiding the infinite loop problem). but it may not fit how clara works underneath.</z><z id="t1595005930227600" t="mikerod @sekao I’d encourage you read http://www.metasimple.org/2017/12/23/clara-updating-facts.html"><y>#</y><d>2020-07-17</d><h>17:12</h><w>mikerod</w>@sekao I’d encourage you read <a href="http://www.metasimple.org/2017/12/23/clara-updating-facts.html" target="_blank">http://www.metasimple.org/2017/12/23/clara-updating-facts.html</a></z><z id="t1595005979229100" t="mikerod I wrote it a while ago but it was an attempt to basically dump as much info I could on the updating facts concept and how it interacts with clara and in general the automatic truth maintenance system model (which is what allows rules to be order independently expressed etc)"><y>#</y><d>2020-07-17</d><h>17:12</h><w>mikerod</w>I wrote it a while ago but it was an attempt to basically dump as much info I could on the updating facts concept and how it interacts with clara and in general the automatic truth maintenance system model (which is what allows rules to be order independently expressed etc)</z><z id="t1595022041229900" t="MatthewLisp Hello clojurists users of Clara "><y>#</y><d>2020-07-17</d><h>21:40</h><w>MatthewLisp</w>Hello clojurists users of Clara </z><z id="t1595022063230500" t="MatthewLisp I’m currently using Clara on a project and I’m kinda lost really "><y>#</y><d>2020-07-17</d><h>21:41</h><w>MatthewLisp</w>I’m currently using Clara on a project and I’m kinda lost really </z><z id="t1595022085231200" t="MatthewLisp Lost in the designing of the rules and the facts "><y>#</y><d>2020-07-17</d><h>21:41</h><w>MatthewLisp</w>Lost in the designing of the rules and the facts </z><z id="t1595022105231800" t="MatthewLisp I wanted to know how you define what is a Fact? "><y>#</y><d>2020-07-17</d><h>21:41</h><w>MatthewLisp</w>I wanted to know how you define what is a Fact? </z><z id="t1595022125232400" t="MatthewLisp What should be a fact in your system "><y>#</y><d>2020-07-17</d><h>21:42</h><w>MatthewLisp</w>What should be a fact in your system </z><z id="t1595022156233300" t="MatthewLisp Because this directly influence what you insert on right hand side of rules also "><y>#</y><d>2020-07-17</d><h>21:42</h><w>MatthewLisp</w>Because this directly influence what you insert on right hand side of rules also </z><z id="t1595022326237000" t="MatthewLisp Currently my rules are operating on a state map that represents a requisition from outside. I have multiple records but every record has the same data inside. The rules are pretty much looking whether I have key X or not on the map. It feels wrong, it feels that i don’t know how to design the facts "><y>#</y><d>2020-07-17</d><h>21:45</h><w>MatthewLisp</w>Currently my rules are operating on a state map that represents a requisition from outside. I have multiple records but every record has the same data inside. The rules are pretty much looking whether I have key X or not on the map. It feels wrong, it feels that i don’t know how to design the facts </z><z id="t1595096993245200" t="ethanc @matthewlisp, Clara is pretty flexible with the terminology of fact, clara provides extension points(fact-type-fn &amp; ancestors-fn) to allow users to define their own “facts” or whatever that means to their system. I’m having trouble visualizing the sort of system that you described with the state map above, perhaps you could provide a small example?"><y>#</y><d>2020-07-18</d><h>18:29</h><w>ethanc</w>@matthewlisp,
Clara is pretty flexible with the terminology of fact, clara provides extension points(fact-type-fn &amp; ancestors-fn) to allow users to define their own “facts” or whatever that means to their system.

I’m having trouble visualizing the sort of system that you described with the state map above, perhaps you could provide a small example?</z><z id="t1595983065249300" t="Matthew Pettis Are there examples of using things like multiple insert! calls, or insert! inside of an if-let on the RHS of a rule? Or reasons why that isn&apos;t allowed? I&apos;ll try once back at a computer, but I wanted to ask in case there was something obvious I should know."><y>#</y><d>2020-07-29</d><h>00:37</h><w>Matthew Pettis</w>Are there examples of using things like multiple insert! calls, or insert! inside of an if-let on the RHS of a rule?  Or reasons why that isn&apos;t allowed?  I&apos;ll try once back at a computer, but I wanted to ask in case there was something obvious I should know.</z><z id="t1596030180254000" t="ethanc The rhs of a rule is inside an implicit let block, so it should allow for multiple inserts: (defrule rule-name &lt;lhs&gt; =&gt; (insert! &lt;fact1&gt;) (insert! &lt;fact2&gt;)) https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/compiler.clj#L454-L456 The RHS can be arbitrary clojure code, so if-lets would be fine. Though as a word of warning, don’t do stateful things in the RHS of a rule as it can lead to weird side effects."><y>#</y><d>2020-07-29</d><h>13:43</h><w>ethanc</w>The rhs of a rule is inside an implicit let block, so it should allow for multiple inserts:
<pre>(defrule rule-name
  &lt;lhs&gt;
  =&gt;
  (insert! &lt;fact1&gt;)
  (insert! &lt;fact2&gt;))</pre>
<a href="https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/compiler.clj#L454-L456" target="_blank">https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/compiler.clj#L454-L456</a>

The RHS can be arbitrary clojure code, so if-lets would be fine. Though as a word of warning, don’t do stateful things in the RHS of a rule as it can lead to weird side effects.</z><z id="t1596030655255100" t="Matthew Pettis Thanks! Warning taken. I&apos;m trying to put together a framework like the &apos;sensors&apos; example in the https://github.com/cerner/clara-examples repo. I haven&apos;t worked out how I want it structured yet, but I know I want to trigger using a function to compute something based on the presence of facts, and then conditionally insert another fact based on what that function returns. Something like, &quot;if these two facts exist, do this computation on them. If that computation yields a certain result (like a constraint violation) insert a fact that records the constraint violation. Otherwise, don&apos;t insert a fact.&quot; I&apos;m not sure if good practice is to that computation on the LHS of the rules as a precondition, and then the RHS will trigger if result passes a test, or to do that check totally on the RHS."><y>#</y><d>2020-07-29</d><h>13:50</h><r>Matthew Pettis</r>Thanks!  Warning taken.  I&apos;m trying to put together a framework like the &apos;sensors&apos; example in the <a href="https://github.com/cerner/clara-examples" target="_blank">https://github.com/cerner/clara-examples</a> repo.  I haven&apos;t worked out how I want it structured yet, but I know I want to trigger using a function to compute something based on the presence of facts, and then conditionally insert another fact based on what that function returns.  Something like, &quot;if these two facts exist, do this computation on them.  If that computation yields a certain result (like a constraint violation) insert a fact that records the constraint violation.  Otherwise, don&apos;t insert a fact.&quot;  I&apos;m not sure if good practice is to that computation on the LHS of the rules as a precondition, and then the RHS will trigger if result passes a test, or to do that check totally on the RHS.</z><z id="t1596045559268600" t="ethanc As mike has mentioned(outside of this thread) LHS is probably the ideal place for this sort of logic. We can continue that conversation there. :)"><y>#</y><d>2020-07-29</d><h>17:59</h><r>ethanc</r>As mike has mentioned(outside of this thread) LHS is probably the ideal place for this sort of logic.

We can continue that conversation there. :)</z><z id="t1596047089270700" t="Matthew Pettis Thanks! Yep, Or, for my first pass, with my logic, I&apos;m going to not do conditional inserts within rules -- I&apos;m going to try to just do do inserts with a record of a natural structure that allows me to pull out what I want on a query, and put logic in the query, or even post-process query outputs. Thanks for the help!"><y>#</y><d>2020-07-29</d><h>18:24</h><r>Matthew Pettis</r>Thanks!  Yep,   Or, for my first pass, with my logic, I&apos;m going to not do conditional inserts within rules -- I&apos;m going to try to just do do inserts with a record of a natural structure that allows me to pull out what I want on a query, and put logic in the query, or even post-process query outputs.  Thanks for the help!</z><z id="t1596031146256000" t="Matthew Pettis Here&apos;s some pseudocode of what I am trying to decide between, not sure if both are even feasible or, as noted here, advisable:"><y>#</y><d>2020-07-29</d><h>13:59</h><w>Matthew Pettis</w>Here&apos;s some pseudocode of what I am trying to decide between, not sure if both are even feasible or, as noted here, advisable:</z><z id="t1596031151256200" t="Matthew Pettis ;; pseudocode for a lhs computation. I&apos;m not sure how to compute ?c here syntactically, if possible at all. (defrule lhs-pseudocode [?a &lt;- ConditionA] [?b &lt;- ConditionB] ;; [?c &lt;- compute a function return value (check-function ?a ?b)] ;; [:test ?c is truthy] =&gt; (insert! (-&gt;ExceptionFact ?c))) ;; pseudocode for a rhs check (defrule rhs-pseudocode [?a &lt;- ConditionA] [?b &lt;- ConditionB] =&gt; (let [c (check-function ?a ?b)] (when (truthy c) (insert! (-&gt;ExceptionFact c)))))"><y>#</y><d>2020-07-29</d><h>13:59</h><w>Matthew Pettis</w><pre>;; pseudocode for a lhs computation.  I&apos;m not sure how to compute ?c here syntactically, if possible at all.
(defrule lhs-pseudocode
 [?a &lt;- ConditionA]
 [?b &lt;- ConditionB]
 ;; [?c &lt;- compute a function return value (check-function ?a ?b)]
 ;; [:test ?c is truthy]
 =&gt;
 (insert! (-&gt;ExceptionFact ?c)))


;; pseudocode for a rhs check
(defrule rhs-pseudocode
 [?a &lt;- ConditionA]
 [?b &lt;- ConditionB]
 =&gt;
 (let [c (check-function ?a ?b)]
  (when (truthy c)
   (insert! (-&gt;ExceptionFact c)))))</pre></z><z id="t1596031526257200" t="mikerod I’d add it’s generally not good to do conditional things in RHS. The rules themselves are meant to capture the conditional flows"><y>#</y><d>2020-07-29</d><h>14:05</h><w>mikerod</w>I’d add it’s generally not good to do conditional things in RHS. The rules themselves are meant to capture the conditional flows</z><z id="t1596031543257700" t="mikerod I generally find it an anti pattern for the RHS to “maybe do some insert”"><y>#</y><d>2020-07-29</d><h>14:05</h><w>mikerod</w>I generally find it an anti pattern for the RHS to “maybe do some insert”</z><z id="t1596031547257900" t="mikerod There are exceptions"><y>#</y><d>2020-07-29</d><h>14:05</h><w>mikerod</w>There are exceptions</z><z id="t1596031561258300" t="mikerod But above , you’d be better off using a :test node on LHS "><y>#</y><d>2020-07-29</d><h>14:06</h><w>mikerod</w>But above , you’d be better off using a :test node on LHS </z><z id="t1596032067260300" t="Matthew Pettis Thanks, makes sense. My question then is: If I do a test, and in that test, I use a function to compute a value which is to be checked, and I want to pass that value on to the RHS as part of the fact insert, what would that look like? In the first pseudocode above, I want to pass the output value of (check-function) to be inserted as a field in a record on the RHS..."><y>#</y><d>2020-07-29</d><h>14:14</h><w>Matthew Pettis</w>Thanks, makes sense.  My question then is: If I do a test, and in that test, I use a function to compute a value which is to be checked, and I want to pass that value on to the RHS as part of the fact insert, what would that look like?  In the first pseudocode above, I want to pass the output value of (check-function) to be inserted as a field in a record on the RHS...</z><z id="t1596032349262400" t="Matthew Pettis The one way I thought to get around that was to not check conditions at all in the rules, but always insert a fact with the results of the computation I want to do, and that record has the result. And then, during a query, I can filter out those new records based on some flag/indicator field of the result. That seems like I potentially put more facts into the session than are necessary."><y>#</y><d>2020-07-29</d><h>14:19</h><w>Matthew Pettis</w>The one way I thought to get around that was to not check conditions at all in the rules, but always insert a fact with the results of the computation I want to do, and that record has the result.  And then, during a query, I can filter out those new records based on some flag/indicator field of the result.  That seems like I potentially put more facts into the session than are necessary.</z><z id="t1596032440264000" t="Matthew Pettis Another thought I was to follow up what I did above, but then add another rule that prunes facts that don&apos;t have a certain value in an indicator field -- like a cleanup rule. Then there is no conditional inserts in the LHS or RHS of a rule, but another rule takes care of the conditional inserts by removing things that I would not have originally inserted."><y>#</y><d>2020-07-29</d><h>14:20</h><w>Matthew Pettis</w>Another thought I was to follow up what I did above, but then add another rule that prunes facts that don&apos;t have a certain value in an indicator field -- like a cleanup rule.  Then there is no conditional inserts in the LHS or RHS of a rule, but another rule takes care of the conditional inserts by removing things that I would not have originally inserted.</z><z id="t1596032485264800" t="Matthew Pettis Again, new to this, so I am trying to map the ideas of how I want my conditional domain logic I want to the best practices and discipline of a rules system..."><y>#</y><d>2020-07-29</d><h>14:21</h><w>Matthew Pettis</w>Again, new to this, so I am trying to map the ideas of how I want my conditional domain logic I want to the best practices and discipline of a rules system...</z><z id="t1596043132265600" t="mikerod @matthew.pettis I’d recommend a rule that always inserts facts modeling result values you want like that. You sort of already said this above"><y>#</y><d>2020-07-29</d><h>17:18</h><w>mikerod</w>@matthew.pettis I’d recommend a rule that always inserts facts modeling result values you want like that. You sort of already said this above</z><z id="t1596043154266300" t="mikerod So the answer is just more rules. More “intermediate facts” representing knowledge of the system"><y>#</y><d>2020-07-29</d><h>17:19</h><w>mikerod</w>So the answer is just more rules. More “intermediate facts” representing knowledge of the system</z><z id="t1596043253266900" t="mikerod I can’t write up too many useful details at the moment though. So I may not be that useful to you "><y>#</y><d>2020-07-29</d><h>17:20</h><w>mikerod</w>I can’t write up too many useful details at the moment though. So I may not be that useful to you </z><z id="t1596043281267600" t="mikerod If you make queries more specific. You don’t have to worry as much about adding more intermediate level facts though"><y>#</y><d>2020-07-29</d><h>17:21</h><w>mikerod</w>If you make queries more specific. You don’t have to worry as much about adding more intermediate level facts though</z><z id="t1596043309268500" t="mikerod And don’t typically need cleanup. Unless you have some memory concern or something. That can be somewhat trickier to retract things in a way that plays well with truth maintenance "><y>#</y><d>2020-07-29</d><h>17:21</h><w>mikerod</w>And don’t typically need cleanup. Unless you have some memory concern or something. That can be somewhat trickier to retract things in a way that plays well with truth maintenance </z><z id="t1596045903270500" t="Matthew Pettis @mikerod Thanks! The more I thought about my proposed alternatives, the more it seemed to be in line with the rules philosophy. I&apos;ll be trying that. I appreciate the thought of writing something up too. I think I have enough to go on to code to this philosophy to start with, and I&apos;ll probably have other questions later. Thanks again!"><y>#</y><d>2020-07-29</d><h>18:05</h><w>Matthew Pettis</w>@mikerod Thanks!  The more I thought about my proposed alternatives, the more it seemed to be in line with the rules philosophy.  I&apos;ll be trying that.  I appreciate the thought of writing something up too.  I think I have enough to go on to code to this philosophy to start with, and I&apos;ll probably have other questions later.  Thanks again!</z><z id="t1596055683272200" t="Matthew Pettis Also, from a thread way-back... I&apos;d like to try clara.tools, I see the repo here: https://github.com/rbrush/clara-tools ... what I don&apos;t see is the :dependencies version string to put into my project.clj file... and advice on how to install from this repo?"><y>#</y><d>2020-07-29</d><h>20:48</h><w>Matthew Pettis</w>Also, from a thread way-back... I&apos;d like to try clara.tools, I see the repo here: <a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a> ... what I don&apos;t see is the :dependencies version string to put into my project.clj file... and advice on how to install from this repo?</z><z id="t1596126074273200" t="ethanc based on the only issue: https://github.com/rbrush/clara-tools/issues/12 I have a feeling that clara-tools is not really being supported anymore."><y>#</y><d>2020-07-30</d><h>16:21</h><w>ethanc</w>based on the only issue:
<a href="https://github.com/rbrush/clara-tools/issues/12" target="_blank">https://github.com/rbrush/clara-tools/issues/12</a>

I have a feeling that clara-tools is not really being supported anymore.</z><z id="t1596727689276000" t="Brian Abbott Hi, I am having a problem with resolving a defrecord call that resides in a seperate namespace from the rule defininitions. I was wondering if someone might be able to help me out. I have the code I made for a small prototype that repros the issue here: https://github.com/briancabbott/clara-rules-test"><y>#</y><d>2020-08-06</d><h>15:28</h><w>Brian Abbott</w>Hi, I am having a problem with resolving a defrecord call that resides in a seperate namespace from the rule defininitions. I was wondering if someone might be able to help me out. I have the code I made for a small prototype that repros the issue here: <a href="https://github.com/briancabbott/clara-rules-test" target="_blank">https://github.com/briancabbott/clara-rules-test</a></z><z id="t1596728325277200" t="mikerod @briancabbott in CLJ to refer to a defrecord created type you have to use the java interop :import "><y>#</y><d>2020-08-06</d><h>15:38</h><w>mikerod</w>@briancabbott in CLJ to refer to a defrecord created type you have to use the java interop :import </z><z id="t1596728348277900" t="mikerod So it’s not represented as a var. so :require + :refer won’t work. "><y>#</y><d>2020-08-06</d><h>15:39</h><w>mikerod</w>So it’s not represented as a var. so :require + :refer won’t work. </z><z id="t1596728380278600" t="mikerod It’s somewhat unfortunate. In CLJS you actually can refer to them as non-interop style symbols. "><y>#</y><d>2020-08-06</d><h>15:39</h><w>mikerod</w>It’s somewhat unfortunate. In CLJS you actually can refer to them as non-interop style symbols. </z><z id="t1596728469280600" t="mikerod So something like. : `(:import [ clara_rules_test.parent_rules_split_ns.rule_records MyFirstRecordOne MyFirstRecordTwo])` "><y>#</y><d>2020-08-06</d><h>15:41</h><w>mikerod</w>So something like. :

`(:import [ clara_rules_test.parent_rules_split_ns.rule_records
MyFirstRecordOne
MyFirstRecordTwo])`
</z><z id="t1596728514282000" t="mikerod Not also the need for underscores instead of hyphens. Again. That’s the java interop part. Cannot have hyphens in class names on JVM so clj converts them (called “munching”) to underscores. "><y>#</y><d>2020-08-06</d><h>15:41</h><w>mikerod</w>Not also the need for underscores instead of hyphens. Again. That’s the java interop part. Cannot have hyphens in class names on JVM so clj converts them (called “munching”)  to underscores. </z><z id="t1596730999282600" t="Brian Abbott BAM!!! HELL YES! 🙂 Thank you my friend --- you are my Savior!"><y>#</y><d>2020-08-06</d><h>16:23</h><w>Brian Abbott</w>BAM!!! HELL YES! <b>🙂</b> Thank you my friend --- you are my Savior!</z><z id="t1596731012282900" t="Brian Abbott @mikerod"><y>#</y><d>2020-08-06</d><h>16:23</h><w>Brian Abbott</w>@mikerod</z><z id="t1596732094283200" t="mikerod 🙌"><y>#</y><d>2020-08-06</d><h>16:41</h><w>mikerod</w><b>🙌</b></z><z id="t1596746670285800" t="eraserhd It&apos;s been a while... are there any issues with [:not [:exists ...]] ? I have a rule that is firing, even though the LHS has [:exists A] [:not [:exists A]] ."><y>#</y><d>2020-08-06</d><h>20:44</h><w>eraserhd</w>It&apos;s been a while... are there any issues with <code>[:not [:exists ...]]</code>?  I have a rule that is firing, even though the LHS has <code>[:exists A] [:not [:exists A]]</code>.</z><z id="t1596809272286900" t="ethanc Thats an interesting scenario, i will have to look into whats going on there"><y>#</y><d>2020-08-07</d><h>14:07</h><r>ethanc</r>Thats an interesting scenario, i will have to look into whats going on there</z><z id="t1596746980286500" t="eraserhd oh, while that is not correct, it is actually silly to say [:not [:exists A]] instead of [:not A], huh"><y>#</y><d>2020-08-06</d><h>20:49</h><w>eraserhd</w>oh, while that is not correct, it is actually silly to say [:not [:exists A]] instead of [:not A], huh</z><z id="t1596810548289100" t="mikerod @eraserhd yes, :not is already “not exist”"><y>#</y><d>2020-08-07</d><h>14:29</h><w>mikerod</w>@eraserhd yes, <code>:not</code> is already “not exist”</z><z id="t1596810555289300" t="mikerod I don’t think you can nest these thing either"><y>#</y><d>2020-08-07</d><h>14:29</h><w>mikerod</w>I don’t think you can nest these thing either</z><z id="t1596810561289600" t="mikerod even though the syntax may not check against it"><y>#</y><d>2020-08-07</d><h>14:29</h><w>mikerod</w>even though the syntax may not check against it</z><z id="t1596810564289800" t="wparker It is a known issue: https://github.com/cerner/clara-rules/issues/329 As you say though, while [:not [:exists A]] makes logical sense and IMO would ideally work the problem is easily avoided as you wrote."><y>#</y><d>2020-08-07</d><h>14:29</h><w>wparker</w>It is a known issue: <a href="https://github.com/cerner/clara-rules/issues/329" target="_blank">https://github.com/cerner/clara-rules/issues/329</a> As you say though, while [:not [:exists A]] makes logical sense and IMO would ideally work the problem is easily avoided as you wrote.</z><z id="t1597096658292000" t="panda hi, this is a noob question but do people typically keep one clara session running for the app and then constantly insert facts and fire rules? or the session more of a localized thing (i.e. once you get a collection of facts, then apply rules on that collection)?"><y>#</y><d>2020-08-10</d><h>21:57</h><w>panda</w>hi, this is a noob question but do people typically keep one clara session running for the app and then constantly insert facts and fire rules? or the session more of a localized thing (i.e. once you get a collection of facts, then apply rules on that collection)?</z><z id="t1597097120293700" t="panda on that note — are there any more complex github/project examples than the ones listed https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples ?"><y>#</y><d>2020-08-10</d><h>22:05</h><w>panda</w>on that note — are there any more complex github/project examples than the ones listed <a href="https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples" target="_blank">https://github.com/cerner/clara-examples/tree/master/src/main/clojure/clara/examples</a> ?</z><z id="t1597156086294500" t="defndaines We use one session per request, but that may be specific to our scenario, where each request represented a wholly unique patient."><y>#</y><d>2020-08-11</d><h>14:28</h><w>defndaines</w>We use one session per request, but that may be specific to our scenario, where each request represented a wholly unique patient.</z><z id="t1597159797296700" t="panda @defndaines thanks! any chance you’ve used the explain activations function in the tooling? i’m curious what the best way is to use that if each session is spun up and down for a request"><y>#</y><d>2020-08-11</d><h>15:29</h><w>panda</w>@defndaines  thanks! any chance you’ve used the explain activations function in the tooling? i’m curious what the best way is to use that if each session is spun up and down for a request</z><z id="t1597162914298200" t="defndaines We have a hook to turn on explain-activations , but we rarely use it. We accumulate data in each of our facts that helps with all of our debugging. We also capture all of the input to the sessions, so we can reproduce a session for debugging in order to analyze."><y>#</y><d>2020-08-11</d><h>16:21</h><w>defndaines</w>We have a hook to turn on <code>explain-activations</code>, but we rarely use it. We accumulate data in each of our facts that helps with all of our debugging. We also capture all of the input to the sessions, so we can reproduce a session for debugging in order to analyze.</z><z id="t1597162964298600" t="panda thank you! that’s super helpful"><y>#</y><d>2020-08-11</d><h>16:22</h><w>panda</w>thank you! that’s super helpful</z><z id="t1597173863298900" t="mikerod So a session is immutable. "><y>#</y><d>2020-08-11</d><h>19:24</h><w>mikerod</w>So a session is immutable. </z><z id="t1597173889299700" t="mikerod I would necessarily recommend making a new session when speed is important or it is slower due to many rules"><y>#</y><d>2020-08-11</d><h>19:24</h><w>mikerod</w>I would necessarily recommend making a new session when speed is important or it is slower due to many rules</z><z id="t1597173894299900" t="mikerod With smaller rule sets maybe ok"><y>#</y><d>2020-08-11</d><h>19:24</h><w>mikerod</w>With smaller rule sets maybe ok</z><z id="t1597174001301800" t="mikerod But typically, I’d store the initial session made via mk-session and then just do new isolated insert+fire callls on it “per unrelated invocation” "><y>#</y><d>2020-08-11</d><h>19:26</h><w>mikerod</w>But typically, I’d store the initial session made via mk-session and then just do new isolated insert+fire callls on it “per unrelated invocation” </z><z id="t1597174045302200" t="mikerod This is also assuming the rule set is unchanged per use. "><y>#</y><d>2020-08-11</d><h>19:27</h><w>mikerod</w>This is also assuming the rule set is unchanged per use. </z><z id="t1597175056302600" t="panda thank you! much appreciated."><y>#</y><d>2020-08-11</d><h>19:44</h><w>panda</w>thank you! much appreciated.</z><z id="t1597245131304100" t="eraserhd Does Clara do better with [Object (= n ?n) (odd? n)] than [Object (= n ?n)] [:test (odd? n)] ? (In other words, does it filter before working memory in the previous case?)"><y>#</y><d>2020-08-12</d><h>15:12</h><w>eraserhd</w>Does Clara do better with <code>[Object (= n ?n) (odd? n)]</code> than <code>[Object (= n ?n)] [:test (odd? n)]</code>?  (In other words, does it filter before working memory in the previous case?)</z><z id="t1597257058307800" t="ethanc I believe that the first example would compile the odd? constraint into the alpha node, where as the second would have test node after the AlphaNode. I don’t believe that either of these nodes add anything to working memory, following nodes might though."><y>#</y><d>2020-08-12</d><h>18:30</h><w>ethanc</w>I believe that the first example would compile the <code>odd?</code> constraint into the alpha node, where as the second would have test node after the AlphaNode.

I don’t believe that either of these nodes add anything to working memory, following nodes might though.</z><z id="t1597257256308300" t="eraserhd Hmm, I omitted that I expect there to be another hash-join field on Object."><y>#</y><d>2020-08-12</d><h>18:34</h><w>eraserhd</w>Hmm, I omitted that I expect there to be another hash-join field on Object.</z><z id="t1597260030311600" t="ethanc with the hashJoin between the alpha and the test, then i would expect moving the odd? constraint to the alpha node to likely reduce some of the objects being placed into working memory. How much savings it would produce I cannot say."><y>#</y><d>2020-08-12</d><h>19:20</h><w>ethanc</w>with the hashJoin between the alpha and the test, then i would expect moving the <code>odd?</code> constraint to the alpha node to likely reduce some of the objects being placed into working memory. How much savings it would produce I cannot say.</z><z id="t1598882050004000" t="Pieter Slabbert I have sample code that I&apos;m trying to figure out the best way to fix. (defrecord ThingA [id data]) (defrecord ThingB [k]) (defrule broken [ThingB (= ?k k)] [ThingA (= ?id id) (= ?data data) (= ?entry (-&gt; data :items (get ?k))) (some? ?entry)] =&gt; (println &quot;entry&quot; ?entry)) (-&gt; (rules/mk-session) (rules/insert (-&gt;ThingA 1 {:items {:entry {:a 1 :b 2}}})) (rules/insert (-&gt;ThingB :entry)) (rules/fire-rules)) When I run this I get Execution error at clara.rules.compiler/try-eval (compiler.clj:233). Unable to resolve symbol: ?entry in this context If I hard code the value of ?k it works, but it when I try get it from another fact I get the error. What would be the proper way to extract a field from one fact and use it to look something up in another fact"><y>#</y><d>2020-08-31</d><h>13:54</h><w>Pieter Slabbert</w>I have sample code that I&apos;m trying to figure out the best way to fix.
<pre>(defrecord ThingA [id data])
(defrecord ThingB [k])

(defrule broken
  [ThingB
   (= ?k k)]
  [ThingA
   (= ?id id)
   (= ?data data)
   (= ?entry (-&gt; data :items (get ?k)))
   (some? ?entry)]
  =&gt;
  (println &quot;entry&quot; ?entry))

(-&gt; (rules/mk-session)
    (rules/insert (-&gt;ThingA 1 {:items {:entry {:a 1 :b 2}}}))
    (rules/insert (-&gt;ThingB :entry))
    (rules/fire-rules))</pre>
When I run this I get
<pre>Execution error at clara.rules.compiler/try-eval (compiler.clj:233).
Unable to resolve symbol: ?entry in this context</pre>
If I hard code the value of ?k it works, but it when I try get it from another fact I get the error.

What would be the proper way to extract a field from one fact and use it to look something up in another fact</z><z id="t1598962772004400" t="mikerod @blob626 it looks like the above should work. "><y>#</y><d>2020-09-01</d><h>12:19</h><w>mikerod</w>@blob626 it looks like the above should work. </z><z id="t1598962796005200" t="mikerod If the ?k is causing problems I’m surprised. Maybe this needs to be an issue logged. "><y>#</y><d>2020-09-01</d><h>12:19</h><w>mikerod</w>If the ?k is causing problems I’m surprised. Maybe this needs to be an issue logged. </z><z id="t1598962807005600" t="mikerod I need to experiment with it in a bit to see. "><y>#</y><d>2020-09-01</d><h>12:20</h><w>mikerod</w>I need to experiment with it in a bit to see. </z><z id="t1598971088006000" t="ethanc @mikerod, Looks similar to https://github.com/cerner/clara-rules/issues/426"><y>#</y><d>2020-09-01</d><h>14:38</h><w>ethanc</w>@mikerod,
Looks similar to <a href="https://github.com/cerner/clara-rules/issues/426" target="_blank">https://github.com/cerner/clara-rules/issues/426</a></z><z id="t1598971110006400" t="ethanc cc. @blob626"><y>#</y><d>2020-09-01</d><h>14:38</h><w>ethanc</w>cc. @blob626</z><z id="t1598977426006700" t="mikerod @ethanc good find. does look the same"><y>#</y><d>2020-09-01</d><h>16:23</h><w>mikerod</w>@ethanc good find. does look the same</z><z id="t1599031158008300" t="Pieter Slabbert @ethanc thank you, that looks like the problem. At the moment I&apos;m resorting to an intermediary &quot;Getter&quot; fact to get around this, its not pretty, but it works"><y>#</y><d>2020-09-02</d><h>07:19</h><w>Pieter Slabbert</w>@ethanc thank you, that looks like the problem.  At the moment I&apos;m resorting to an intermediary  &quot;Getter&quot; fact to get around this, its not pretty, but it works</z><z id="t1599060080009200" t="ethanc @mikerod @blob626, I haven’t looked at that issue in a while, but i will see if i can find time to give it another pass/look"><y>#</y><d>2020-09-02</d><h>15:21</h><w>ethanc</w>@mikerod @blob626,
I haven’t looked at that issue in a while, but i will see if i can find time to give it another pass/look</z><z id="t1599486164010500" t="sparkofreason What would be the most efficient way to get notified when results of a specific query have changed?"><y>#</y><d>2020-09-07</d><h>13:42</h><w>sparkofreason</w>What would be the most efficient way to get notified when results of a specific query have changed?</z><z id="t1599812568012100" t="wparker Clara computes query results upfront; when you call (query session ….) you’re basically just doing map lookups. https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/engine.cljc#L1998 So I don’t think different ways of doing this would have much difference in terms of performance; you’d probably want something that stores the previous state, calls query on the session, and then compares them."><y>#</y><d>2020-09-11</d><h>08:22</h><r>wparker</r>Clara computes query results upfront; when you call (query session ….) you’re basically just doing map lookups. <a href="https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/engine.cljc#L1998" target="_blank">https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/rules/engine.cljc#L1998</a> So I don’t think different ways of doing this would have much difference in terms of performance; you’d probably want something that stores the previous state, calls query on the session, and then compares them.</z><z id="t1599865178014400" t="sparkofreason I was thinking more in terms of getting notified per query only when the results changed. I&apos;ll look at doing it with a listener."><y>#</y><d>2020-09-11</d><h>22:59</h><r>sparkofreason</r>I was thinking more in terms of getting notified per query only when the results changed. I&apos;ll look at doing it with a listener.</z><z id="t1599812927013900" t="wparker Clara-rules version 0.21.0 has been released and is available on Clojars. This release primarily has improvements to error reporting and inspectability along with a minor bugfix where exceptions could be thrown on certain Java object fact types. Further details at https://github.com/cerner/clara-rules/blob/main/CHANGELOG.md#0210"><y>#</y><d>2020-09-11</d><h>08:28</h><w>wparker</w>Clara-rules version 0.21.0 has been released and is available on Clojars.  This release primarily has improvements to error reporting and inspectability along with a minor bugfix where exceptions could be thrown on certain Java object fact types. Further details at <a href="https://github.com/cerner/clara-rules/blob/main/CHANGELOG.md#0210" target="_blank">https://github.com/cerner/clara-rules/blob/main/CHANGELOG.md#0210</a></z><z id="t1600310390016900" t="Matthew Pettis Is there a way to import defrec definitions from another namespace to use in a rules session? I want to modularize my rules, queries, and record definitions into different namespaces, and am having troubles getting the definitons/objects recognized in a rules session. Below is a the most stripped-down example I could make that I cannot figure out..."><y>#</y><d>2020-09-17</d><h>02:39</h><w>Matthew Pettis</w>Is there a way to import <code>defrec</code> definitions from another namespace to use in a rules session?  I want to modularize my rules, queries, and record definitions into different namespaces, and am having troubles getting the definitons/objects recognized in a rules session.  Below is a the most stripped-down example I could make that I cannot figure out...</z><z id="t1600310398017100" t="Matthew Pettis user=&gt; (ns a #_=&gt; &quot;Has the record definitions&quot;) nil a=&gt; (defrecord MyRec [nm]) a.MyRec a=&gt; (ns b #_=&gt; &quot;Has the logic to run the clara rules session&quot; #_=&gt; (:require #_=&gt; [clara.rules :as r] #_=&gt; [a :as nsa]) #_=&gt; (:import (a MyRec)) #_=&gt; ) nil b=&gt; (r/defrule therec #_=&gt; &quot;Has a MyRec record&quot; #_=&gt; [?r &lt;- nsa/MyRec] #_=&gt; =&gt; #_=&gt; (r/insert! (nsa/-&gt;MyRec :output))) #&apos;b/therec b=&gt; (r/defquery qrec #_=&gt; [] #_=&gt; [?e &lt;- nsa/MyRec]) #&apos;b/qrec b=&gt; (def sess (r/mk-session)) Syntax error (ClassNotFoundException) compiling at (form-init1616251358278573848.clj:1:11). MyRec"><y>#</y><d>2020-09-17</d><h>02:39</h><w>Matthew Pettis</w><pre>user=&gt; (ns a
  #_=&gt;   &quot;Has the record definitions&quot;)
nil
a=&gt; (defrecord MyRec [nm])
a.MyRec


a=&gt; (ns b
#_=&gt;     &quot;Has the logic to run the clara rules session&quot;
#_=&gt;     (:require
#_=&gt;         [clara.rules :as r]
#_=&gt;         [a :as nsa])
#_=&gt;     (:import (a MyRec))
#_=&gt; )
nil


b=&gt; (r/defrule therec
#_=&gt;   &quot;Has a MyRec record&quot;
#_=&gt;   [?r &lt;- nsa/MyRec]
#_=&gt;   =&gt;
#_=&gt;   (r/insert! (nsa/-&gt;MyRec :output)))
#&apos;b/therec


b=&gt; (r/defquery qrec
#_=&gt;   []
#_=&gt;   [?e &lt;- nsa/MyRec])
#&apos;b/qrec


b=&gt; (def sess (r/mk-session))
Syntax error (ClassNotFoundException) compiling at (form-init1616251358278573848.clj:1:11).
MyRec</pre></z><z id="t1600310852018600" t="ethanc @matthew.pettis, i believe that you would want to remove the alias qualifier from the conditions of the query and the rule. nsa/MyRec would instead be MyRec"><y>#</y><d>2020-09-17</d><h>02:47</h><w>ethanc</w>@matthew.pettis, i believe that you would want to remove the alias qualifier from the conditions of the query and the rule.
<code>nsa/MyRec</code> would instead be <code>MyRec</code></z><z id="t1600310987018800" t="Matthew Pettis user=&gt; (ns a #_=&gt; &quot;Has the record definitions&quot;) nil a=&gt; (defrecord MyRec [nm]) a.MyRec a=&gt; (ns b #_=&gt; &quot;Has the logic to run the clara rules session&quot; #_=&gt; (:require #_=&gt; [clara.rules :as r] #_=&gt; [a :as nsa]) #_=&gt; (:import (a MyRec)) #_=&gt; ) nil b=&gt; (r/defrule therec #_=&gt; &quot;Has a MyRec record&quot; #_=&gt; [?r &lt;- MyRec] #_=&gt; =&gt; #_=&gt; (r/insert! (-&gt;MyRec :output))) #&apos;b/therec b=&gt; (r/defquery qrec #_=&gt; [] #_=&gt; [?e &lt;- MyRec]) #&apos;b/qrec b=&gt; (def sess (r/mk-session)) Syntax error compiling at (form-init2860030196736207126.clj:1:11). Unable to resolve symbol: -&gt;MyRec in this context"><y>#</y><d>2020-09-17</d><h>02:49</h><w>Matthew Pettis</w><pre>user=&gt; (ns a
  #_=&gt;   &quot;Has the record definitions&quot;)
nil
a=&gt; (defrecord MyRec [nm])
a.MyRec


a=&gt; (ns b
#_=&gt;     &quot;Has the logic to run the clara rules session&quot;
#_=&gt;     (:require
#_=&gt;         [clara.rules :as r]
#_=&gt;         [a :as nsa])
#_=&gt;     (:import (a MyRec))
#_=&gt; )
nil


b=&gt; (r/defrule therec
#_=&gt;   &quot;Has a MyRec record&quot;
#_=&gt;   [?r &lt;- MyRec]
#_=&gt;   =&gt;
#_=&gt;   (r/insert! (-&gt;MyRec :output)))
#&apos;b/therec


b=&gt; (r/defquery qrec
#_=&gt;   []
#_=&gt;   [?e &lt;- MyRec])
#&apos;b/qrec


b=&gt; (def sess (r/mk-session))
Syntax error compiling at (form-init2860030196736207126.clj:1:11).
Unable to resolve symbol: -&gt;MyRec in this context</pre></z><z id="t1600311048019800" t="Matthew Pettis Different error message though... I keep trying permutations and am having a hard time tracking what each means..."><y>#</y><d>2020-09-17</d><h>02:50</h><w>Matthew Pettis</w>Different error message though... I keep trying permutations and am having a hard time tracking what each means...</z><z id="t1600311103020700" t="ethanc you would still want to qualify the position based constructor function in the RHS of the rule"><y>#</y><d>2020-09-17</d><h>02:51</h><w>ethanc</w>you would still want to qualify the position based constructor function in the RHS of the rule</z><z id="t1600311289021700" t="Matthew Pettis ah, right, the difference makes sense. That fixed the error messages, thanks! But I&apos;m getting an empty query result, but I expect to find two facts with the query... any advice there?"><y>#</y><d>2020-09-17</d><h>02:54</h><w>Matthew Pettis</w>ah, right, the difference makes sense.  That fixed the error messages, thanks!  But I&apos;m getting an empty query result, but I expect to find two facts with the query... any advice there?</z><z id="t1600311293021900" t="Matthew Pettis b=&gt; (ns a #_=&gt; &quot;Has the record definitions&quot;) nil a=&gt; (defrecord MyRec [nm]) a.MyRec a=&gt; (ns b #_=&gt; &quot;Has the logic to run the clara rules session&quot; #_=&gt; (:require #_=&gt; [clara.rules :as r] #_=&gt; [a :as nsa]) #_=&gt; (:import (a MyRec)) #_=&gt; ) nil b=&gt; (r/defrule therec #_=&gt; &quot;Has a MyRec record&quot; #_=&gt; [?r &lt;- MyRec] #_=&gt; =&gt; #_=&gt; (r/insert! (nsa/-&gt;MyRec :output))) #&apos;b/therec b=&gt; (r/defquery qrec #_=&gt; [] #_=&gt; [?e &lt;- MyRec]) #&apos;b/qrec b=&gt; (def sess (r/mk-session)) #&apos;b/sess b=&gt; (let [qsess (-&gt; sess #_=&gt; (r/insert-all (nsa/-&gt;MyRec :init)) #_=&gt; r/fire-rules #_=&gt; (r/query qrec))] #_=&gt; qsess) ()"><y>#</y><d>2020-09-17</d><h>02:54</h><w>Matthew Pettis</w><pre>b=&gt; (ns a
#_=&gt;   &quot;Has the record definitions&quot;)
nil
a=&gt; (defrecord MyRec [nm])
a.MyRec


a=&gt; (ns b
#_=&gt;     &quot;Has the logic to run the clara rules session&quot;
#_=&gt;     (:require
#_=&gt;         [clara.rules :as r]
#_=&gt;         [a :as nsa])
#_=&gt;     (:import (a MyRec))
#_=&gt; )
nil


b=&gt; (r/defrule therec
#_=&gt;   &quot;Has a MyRec record&quot;
#_=&gt;   [?r &lt;- MyRec]
#_=&gt;   =&gt;
#_=&gt;   (r/insert! (nsa/-&gt;MyRec :output)))
#&apos;b/therec


b=&gt; (r/defquery qrec
#_=&gt;   []
#_=&gt;   [?e &lt;- MyRec])
#&apos;b/qrec


b=&gt; (def sess (r/mk-session))
#&apos;b/sess


b=&gt; (let [qsess (-&gt; sess
#_=&gt;                (r/insert-all (nsa/-&gt;MyRec :init))
#_=&gt;                r/fire-rules
#_=&gt;                (r/query qrec))]
#_=&gt;   qsess)
()</pre></z><z id="t1600311514023100" t="Matthew Pettis (But I see that that is not related to my namespace issue... I&apos;m doing something wrong with just basic rules, I think...)"><y>#</y><d>2020-09-17</d><h>02:58</h><w>Matthew Pettis</w>(But I see that that is not related to my namespace issue... I&apos;m doing something wrong with just basic rules, I think...)</z><z id="t1600311524023400" t="ethanc insert-all in this case is assuming that you passed a list and is probably breaking the record down into a list of keyvalue pairs"><y>#</y><d>2020-09-17</d><h>02:58</h><w>ethanc</w><code>insert-all</code> in this case is assuming that you passed a list and is probably breaking the record down into a list of keyvalue pairs</z><z id="t1600311545023600" t="ethanc (r/insert-all [(nsa/-&gt;MyRec :init)])"><y>#</y><d>2020-09-17</d><h>02:59</h><w>ethanc</w><code>(r/insert-all [(nsa/-&gt;MyRec :init)])</code></z><z id="t1600311590024600" t="ethanc however this will cause an infinite loop do to therec inserting a fact that then triggers itself"><y>#</y><d>2020-09-17</d><h>02:59</h><w>ethanc</w>however this will cause an infinite loop do to <code>therec</code> inserting a fact that then triggers itself</z><z id="t1600311596024900" t="ethanc *due"><y>#</y><d>2020-09-17</d><h>02:59</h><w>ethanc</w>*due</z><z id="t1600311608025200" t="Matthew Pettis ach, yeah, i copied that over from a place where I was inserting a list, thanks for the catch!"><y>#</y><d>2020-09-17</d><h>03:00</h><w>Matthew Pettis</w>ach, yeah, i copied that over from a place where I was inserting a list, thanks for the catch!</z><z id="t1600312121025800" t="Matthew Pettis For posterity, here is a working example where I&apos;m importing the defrec from another namespace... And thank you @ethanc for the great help!"><y>#</y><d>2020-09-17</d><h>03:08</h><w>Matthew Pettis</w>For posterity, here is a working example where I&apos;m importing the <code>defrec</code> from another namespace... And thank you @ethanc for the great help!</z><z id="t1600312126026000" t="Matthew Pettis user=&gt; (ns a #_=&gt; &quot;Has the record definitions&quot;) nil a=&gt; (defrecord MyRec [nm]) a.MyRec a=&gt; (ns b #_=&gt; &quot;Has the logic to run the clara rules session&quot; #_=&gt; (:require #_=&gt; [clara.rules :as r] #_=&gt; [a :as nsa]) #_=&gt; (:import (a MyRec)) #_=&gt; ) nil b=&gt; (r/defrule therec #_=&gt; &quot;Has a MyRec record&quot; #_=&gt; [?r &lt;- MyRec (= :nm :init)] #_=&gt; =&gt; #_=&gt; (r/insert! (nsa/-&gt;MyRec :output))) #&apos;b/therec b=&gt; (r/defquery qrec #_=&gt; [] #_=&gt; [?e &lt;- MyRec]) #&apos;b/qrec b=&gt; (def sess (r/mk-session)) #&apos;b/sess b=&gt; (let [qsess (-&gt; sess #_=&gt; (r/insert-all [(nsa/-&gt;MyRec :init)]) #_=&gt; r/fire-rules #_=&gt; (r/query qrec))] #_=&gt; qsess) ({:?e #a.MyRec{:nm :init}})"><y>#</y><d>2020-09-17</d><h>03:08</h><w>Matthew Pettis</w><pre>user=&gt; (ns a
  #_=&gt;   &quot;Has the record definitions&quot;)
nil
a=&gt; (defrecord MyRec [nm])
a.MyRec


a=&gt; (ns b
#_=&gt;     &quot;Has the logic to run the clara rules session&quot;
#_=&gt;     (:require
#_=&gt;         [clara.rules :as r]
#_=&gt;         [a :as nsa])
#_=&gt;     (:import (a MyRec))
#_=&gt; )
nil


b=&gt; (r/defrule therec
#_=&gt;   &quot;Has a MyRec record&quot;
#_=&gt;   [?r &lt;- MyRec (= :nm :init)]
#_=&gt;   =&gt;
#_=&gt;   (r/insert! (nsa/-&gt;MyRec :output)))
#&apos;b/therec


b=&gt; (r/defquery qrec
#_=&gt;   []
#_=&gt;   [?e &lt;- MyRec])
#&apos;b/qrec


b=&gt; (def sess (r/mk-session))
#&apos;b/sess


b=&gt; (let [qsess (-&gt; sess
#_=&gt;                (r/insert-all [(nsa/-&gt;MyRec :init)])
#_=&gt;                r/fire-rules
#_=&gt;                (r/query qrec))]
#_=&gt;   qsess)
({:?e #a.MyRec{:nm :init}})</pre></z><z id="t1600313093028400" t="Matthew Pettis Ok, so I tried splitting defrec, rules, and queries up into their own namespace, and run a session in a namespace separate from those three. With the help above, I was able to not get errors. But in the final query, I expect to see a single Outp record, but the query gives me () . It should be a simple step from what I did above, but I&apos;m not seeing where I went wrong... UPDATE: Below, my rules LHS tried to match the record field as a symbol, not as a symbol. Fixing below, see update further down."><y>#</y><d>2020-09-17</d><h>03:24</h><w>Matthew Pettis</w>Ok, so I tried splitting defrec, rules, and queries up into their own namespace, and run a session in a namespace separate from those three.  With the help above, I was able to not get errors.  But in the final query, I expect to see a single <code>Outp</code> record, but the query gives me <code>()</code>.  It should be a simple step from what I did above, but I&apos;m not seeing where I went wrong...

UPDATE: Below, my rules LHS tried to match the record field as a symbol, not as a symbol.  Fixing below, see update further down.</z><z id="t1600313098028600" t="Matthew Pettis rules-engine.core=&gt; (ns rules-engine.rec-defs #_=&gt; &quot;Records to use in rules&quot;) nil rules-engine.rec-defs=&gt; (defrecord Inp [nm]) rules_engine.rec_defs.Inp rules-engine.rec-defs=&gt; (defrecord Outp [nm]) rules_engine.rec_defs.Outp rules-engine.rec-defs=&gt; (ns rules-engine.rules #_=&gt; &quot;Rules to import&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Inp Outp)) #_=&gt; ) nil rules-engine.rules=&gt; (r/defrule has-inp #_=&gt; &quot;Has a Inp record&quot; #_=&gt; [?r &lt;- Inp (= :nm :init)] #_=&gt; =&gt; #_=&gt; (r/insert! (rd/-&gt;Outp :output))) #&apos;rules-engine.rules/has-inp rules-engine.rules=&gt; (ns rules-engine.queries #_=&gt; &quot;Queries&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Inp Outp))) nil rules-engine.queries=&gt; (r/defquery all-outp #_=&gt; [] #_=&gt; [?e &lt;- Outp]) #&apos;rules-engine.queries/all-outp rules-engine.queries=&gt; (ns rules-engine.run-it #_=&gt; &quot;Main script to run a rules set&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd] #_=&gt; [rules-engine.rules :as rl] #_=&gt; [rules-engine.queries :as q] #_=&gt; ) #_=&gt; (:import (rules_engine.rec_defs Inp Outp)) #_=&gt; ) nil rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries)) #&apos;rules-engine.run-it/sess rules-engine.run-it=&gt; (let [qsess (-&gt; sess #_=&gt; (r/insert-all [(rd/-&gt;Inp :init)]) #_=&gt; r/fire-rules #_=&gt; (r/query q/all-outp))] #_=&gt; qsess) ()"><y>#</y><d>2020-09-17</d><h>03:24</h><w>Matthew Pettis</w><pre>rules-engine.core=&gt; (ns rules-engine.rec-defs
               #_=&gt;   &quot;Records to use in rules&quot;)
nil

rules-engine.rec-defs=&gt; (defrecord Inp [nm])
rules_engine.rec_defs.Inp
rules-engine.rec-defs=&gt; (defrecord Outp [nm])
rules_engine.rec_defs.Outp



rules-engine.rec-defs=&gt; (ns rules-engine.rules
                   #_=&gt;   &quot;Rules to import&quot;
                   #_=&gt;   (:require [clara.rules :as r]
                   #_=&gt;             [rules-engine.rec-defs :as rd])
                   #_=&gt;   (:import (rules_engine.rec_defs Inp Outp))
                   #_=&gt;   )
nil


rules-engine.rules=&gt; (r/defrule has-inp
                #_=&gt;   &quot;Has a Inp record&quot;
                #_=&gt;   [?r &lt;- Inp (= :nm :init)]
                #_=&gt;   =&gt;
                #_=&gt;   (r/insert! (rd/-&gt;Outp :output)))
#&apos;rules-engine.rules/has-inp



rules-engine.rules=&gt; (ns rules-engine.queries
                #_=&gt;   &quot;Queries&quot;
                #_=&gt;   (:require [clara.rules :as r]
                #_=&gt;             [rules-engine.rec-defs :as rd])
                #_=&gt;   (:import (rules_engine.rec_defs Inp Outp)))
nil

rules-engine.queries=&gt; (r/defquery all-outp
                  #_=&gt;   []
                  #_=&gt;   [?e &lt;- Outp])
#&apos;rules-engine.queries/all-outp



rules-engine.queries=&gt; (ns rules-engine.run-it
                  #_=&gt;   &quot;Main script to run a rules set&quot;
                  #_=&gt;   (:require [clara.rules :as r]
                  #_=&gt;             [rules-engine.rec-defs :as rd]
                  #_=&gt;             [rules-engine.rules :as rl]
                  #_=&gt;             [rules-engine.queries :as q]
                  #_=&gt;             )
                  #_=&gt;   (:import (rules_engine.rec_defs Inp Outp))
                  #_=&gt;   )
nil


rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries))
#&apos;rules-engine.run-it/sess

rules-engine.run-it=&gt; (let [qsess (-&gt; sess
                 #_=&gt;                (r/insert-all [(rd/-&gt;Inp :init)])
                 #_=&gt;                r/fire-rules
                 #_=&gt;                (r/query q/all-outp))]
                 #_=&gt;   qsess)
()</pre></z><z id="t1600314197029300" t="Matthew Pettis Well, I know it is my logic, not the namespace stuff... this version works, I&apos;ll work on the one above..."><y>#</y><d>2020-09-17</d><h>03:43</h><w>Matthew Pettis</w>Well, I know it is my logic, not the namespace stuff... this version works, I&apos;ll work on the one above...</z><z id="t1600314202029500" t="Matthew Pettis rules-engine.run-it=&gt; (ns rules-engine.rec-defs #_=&gt; &quot;Records to use in rules&quot;) nil rules-engine.rec-defs=&gt; rules-engine.rec-defs=&gt; (defrecord Myrec [nm]) rules_engine.rec_defs.Myrec rules-engine.rec-defs=&gt; (ns rules-engine.rules #_=&gt; &quot;Rules to import&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Myrec))) nil rules-engine.rules=&gt; (r/defrule has-inp #_=&gt; &quot;Has a Inp record&quot; #_=&gt; [?r &lt;- Myrec (= :nm :init)] #_=&gt; =&gt; #_=&gt; (r/insert! (rd/-&gt;Myrec :output))) #&apos;rules-engine.rules/has-inp rules-engine.rules=&gt; (ns rules-engine.queries #_=&gt; &quot;Queries&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Myrec))) nil rules-engine.queries=&gt; (r/defquery all-outp #_=&gt; [] #_=&gt; [?e &lt;- Myrec]) #&apos;rules-engine.queries/all-outp rules-engine.queries=&gt; (ns rules-engine.run-it #_=&gt; &quot;Main script to run a rules set&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd] #_=&gt; [rules-engine.rules :as rl] #_=&gt; [rules-engine.queries :as q] #_=&gt; ) #_=&gt; (:import (rules_engine.rec_defs Myrec))) nil rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries)) #&apos;rules-engine.run-it/sess rules-engine.run-it=&gt; (let [qsess (-&gt; sess #_=&gt; (r/insert-all [(rd/-&gt;Myrec :init)]) #_=&gt; r/fire-rules #_=&gt; (r/query q/all-outp))] #_=&gt; qsess) ({:?e #rules_engine.rec_defs.Myrec{:nm :init}})"><y>#</y><d>2020-09-17</d><h>03:43</h><w>Matthew Pettis</w><pre>rules-engine.run-it=&gt; (ns rules-engine.rec-defs
                 #_=&gt;   &quot;Records to use in rules&quot;)
nil
rules-engine.rec-defs=&gt;

rules-engine.rec-defs=&gt; (defrecord Myrec [nm])
rules_engine.rec_defs.Myrec



rules-engine.rec-defs=&gt; (ns rules-engine.rules
                   #_=&gt;   &quot;Rules to import&quot;
                   #_=&gt;   (:require [clara.rules :as r]
                   #_=&gt;             [rules-engine.rec-defs :as rd])
                   #_=&gt;   (:import (rules_engine.rec_defs Myrec)))
nil

rules-engine.rules=&gt; (r/defrule has-inp
                #_=&gt;   &quot;Has a Inp record&quot;
                #_=&gt;   [?r &lt;- Myrec (= :nm :init)]
                #_=&gt;   =&gt;
                #_=&gt;   (r/insert! (rd/-&gt;Myrec :output)))
#&apos;rules-engine.rules/has-inp



rules-engine.rules=&gt; (ns rules-engine.queries
                #_=&gt;   &quot;Queries&quot;
                #_=&gt;   (:require [clara.rules :as r]
                #_=&gt;             [rules-engine.rec-defs :as rd])
                #_=&gt;   (:import (rules_engine.rec_defs Myrec)))
nil

rules-engine.queries=&gt; (r/defquery all-outp
                  #_=&gt;   []
                  #_=&gt;   [?e &lt;- Myrec])
#&apos;rules-engine.queries/all-outp

rules-engine.queries=&gt; (ns rules-engine.run-it
                  #_=&gt;   &quot;Main script to run a rules set&quot;
                  #_=&gt;   (:require [clara.rules :as r]
                  #_=&gt;             [rules-engine.rec-defs :as rd]
                  #_=&gt;             [rules-engine.rules :as rl]
                  #_=&gt;             [rules-engine.queries :as q]
                  #_=&gt;             )
                  #_=&gt;   (:import (rules_engine.rec_defs Myrec)))
nil

rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries))
#&apos;rules-engine.run-it/sess

rules-engine.run-it=&gt; (let [qsess (-&gt; sess
                 #_=&gt;                (r/insert-all [(rd/-&gt;Myrec :init)])
                 #_=&gt;                r/fire-rules
                 #_=&gt;                (r/query q/all-outp))]
                 #_=&gt;   qsess)
({:?e #rules_engine.rec_defs.Myrec{:nm :init}})</pre></z><z id="t1600314971029900" t="Matthew Pettis Fixed session from above:"><y>#</y><d>2020-09-17</d><h>03:56</h><w>Matthew Pettis</w>Fixed session from above:</z><z id="t1600314976030100" t="Matthew Pettis rules-engine.run-it=&gt; (ns rules-engine.rec-defs #_=&gt; &quot;Records to use in rules&quot;) nil rules-engine.rec-defs=&gt; (defrecord Inp [nm]) rules_engine.rec_defs.Inp rules-engine.rec-defs=&gt; (defrecord Outp [nm]) rules_engine.rec_defs.Outp rules-engine.rec-defs=&gt; rules-engine.rec-defs=&gt; (ns rules-engine.rules #_=&gt; &quot;Rules to import&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Inp Outp)) #_=&gt; ) nil rules-engine.rules=&gt; (r/defrule has-inp #_=&gt; &quot;Has a Inp record&quot; #_=&gt; [?r &lt;- Inp (= nm :init)] #_=&gt; =&gt; #_=&gt; (r/insert! (rd/-&gt;Outp :output))) #&apos;rules-engine.rules/has-inp rules-engine.rules=&gt; (ns rules-engine.queries #_=&gt; &quot;Queries&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd]) #_=&gt; (:import (rules_engine.rec_defs Inp Outp))) nil rules-engine.queries=&gt; (r/defquery all-outp #_=&gt; [] #_=&gt; [?e &lt;- Outp]) #&apos;rules-engine.queries/all-outp rules-engine.queries=&gt; (r/defquery all-inp #_=&gt; [] #_=&gt; [?e &lt;- Inp]) #&apos;rules-engine.queries/all-inp rules-engine.queries=&gt; (ns rules-engine.run-it #_=&gt; &quot;Main script to run a rules set&quot; #_=&gt; (:require [clara.rules :as r] #_=&gt; [rules-engine.rec-defs :as rd] #_=&gt; [rules-engine.rules :as rl] #_=&gt; [rules-engine.queries :as q] #_=&gt; ) #_=&gt; (:import (rules_engine.rec_defs Inp Outp))) nil rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries)) #&apos;rules-engine.run-it/sess rules-engine.run-it=&gt; (let [qsess (-&gt; sess #_=&gt; (r/insert-all [(rd/-&gt;Inp :init)]) #_=&gt; r/fire-rules #_=&gt; (r/query q/all-outp))] #_=&gt; qsess) ({:?e #rules_engine.rec_defs.Outp{:nm :output}})"><y>#</y><d>2020-09-17</d><h>03:56</h><w>Matthew Pettis</w><pre>rules-engine.run-it=&gt; (ns rules-engine.rec-defs
                 #_=&gt;   &quot;Records to use in rules&quot;)
nil

rules-engine.rec-defs=&gt; (defrecord Inp [nm])
rules_engine.rec_defs.Inp
rules-engine.rec-defs=&gt; (defrecord Outp [nm])
rules_engine.rec_defs.Outp
rules-engine.rec-defs=&gt;



rules-engine.rec-defs=&gt; (ns rules-engine.rules
                   #_=&gt;   &quot;Rules to import&quot;
                   #_=&gt;   (:require [clara.rules :as r]
                   #_=&gt;             [rules-engine.rec-defs :as rd])
                   #_=&gt;   (:import (rules_engine.rec_defs Inp Outp))
                   #_=&gt;   )
nil

rules-engine.rules=&gt; (r/defrule has-inp
                #_=&gt;   &quot;Has a Inp record&quot;
                #_=&gt;   [?r &lt;- Inp (= nm :init)]
                #_=&gt;   =&gt;
                #_=&gt;   (r/insert! (rd/-&gt;Outp :output)))
#&apos;rules-engine.rules/has-inp



rules-engine.rules=&gt; (ns rules-engine.queries
                #_=&gt;   &quot;Queries&quot;
                #_=&gt;   (:require [clara.rules :as r]
                #_=&gt;             [rules-engine.rec-defs :as rd])
                #_=&gt;   (:import (rules_engine.rec_defs Inp Outp)))
nil

rules-engine.queries=&gt; (r/defquery all-outp
                  #_=&gt;   []
                  #_=&gt;   [?e &lt;- Outp])
#&apos;rules-engine.queries/all-outp

rules-engine.queries=&gt; (r/defquery all-inp
                  #_=&gt;   []
                  #_=&gt;   [?e &lt;- Inp])
#&apos;rules-engine.queries/all-inp



rules-engine.queries=&gt; (ns rules-engine.run-it
                  #_=&gt;   &quot;Main script to run a rules set&quot;
                  #_=&gt;   (:require [clara.rules :as r]
                  #_=&gt;             [rules-engine.rec-defs :as rd]
                  #_=&gt;             [rules-engine.rules :as rl]
                  #_=&gt;             [rules-engine.queries :as q]
                  #_=&gt;             )
                  #_=&gt;   (:import (rules_engine.rec_defs Inp Outp)))
nil

rules-engine.run-it=&gt; (def sess (r/mk-session &apos;rules-engine.rules &apos;rules-engine.queries))
#&apos;rules-engine.run-it/sess

rules-engine.run-it=&gt; (let [qsess (-&gt; sess
                 #_=&gt;                (r/insert-all [(rd/-&gt;Inp :init)])
                 #_=&gt;                r/fire-rules
                 #_=&gt;                (r/query q/all-outp))]
                 #_=&gt;   qsess)
({:?e #rules_engine.rec_defs.Outp{:nm :output}})</pre></z><z id="t1600364288030600" t="mikerod @matthew.pettis it’s just clj rules here for how you refer to record types"><y>#</y><d>2020-09-17</d><h>17:38</h><w>mikerod</w>@matthew.pettis it’s just clj rules here for how you refer to record types</z><z id="t1600364304031100" t="mikerod in cljs you use ns’s and aliases like your stuff above"><y>#</y><d>2020-09-17</d><h>17:38</h><w>mikerod</w>in cljs you use ns’s and aliases like your stuff above</z><z id="t1600364311031400" t="mikerod in clj (unfortunately), you have to use interop"><y>#</y><d>2020-09-17</d><h>17:38</h><w>mikerod</w>in clj (unfortunately), you have to use interop</z><z id="t1600364342032100" t="mikerod so the actual :import class symbols"><y>#</y><d>2020-09-17</d><h>17:39</h><w>mikerod</w>so the actual <code>:import</code> class symbols</z><z id="t1600364346032300" t="mikerod nothing from a :require + :as etc"><y>#</y><d>2020-09-17</d><h>17:39</h><w>mikerod</w>nothing from a <code>:require</code> + <code>:as</code> etc</z><z id="t1600364512034700" t="Matthew Pettis @mikerod Thanks. Yep, I hit this problem once before (I think I posted it here too)... The way I am currently thinking about it is: for rules that do matching on the LHS, I need to import the classes with :import . When I want to construct a record I need to insert on the RHS, with -&gt;Myrecord , I need to require the namespace from which I have my defrecord declaration so I have that constructor. Does that seem right?"><y>#</y><d>2020-09-17</d><h>17:41</h><w>Matthew Pettis</w>@mikerod Thanks.  Yep, I hit this problem once before (I think I posted it here too)... The way I am currently thinking about it is: for rules that do matching on the LHS, I need to import the classes with <code>:import</code>.  When I want to construct a record I need to insert on the RHS, with <code>-&gt;Myrecord</code>, I need to require the namespace from which I have my <code>defrecord</code> declaration so I have that constructor.  Does that seem right?</z><z id="t1600365149035200" t="mikerod @matthew.pettis I do not like it. I think when writing non-interop clj, things like :import should not be necessary at all"><y>#</y><d>2020-09-17</d><h>17:52</h><w>mikerod</w>@matthew.pettis I do not like it. I think when writing non-interop clj, things like <code>:import</code> should not be necessary at all</z><z id="t1600365161035700" t="mikerod I don’t like that Clara basically enforces this needing to be done for records"><y>#</y><d>2020-09-17</d><h>17:52</h><w>mikerod</w>I don’t like that Clara basically enforces this needing to be done for records</z><z id="t1600365182036200" t="mikerod Clj does offer some “factory functions” it auto-creates with defrecord - which allows you to not have to use interop forms to create records"><y>#</y><d>2020-09-17</d><h>17:53</h><w>mikerod</w>Clj does offer some “factory functions” it auto-creates with <code>defrecord</code> - which allows you to not have to use interop forms to create records</z><z id="t1600365200036700" t="mikerod What clj does not offer, is how to refer to records in a way without interop (eg. :import )"><y>#</y><d>2020-09-17</d><h>17:53</h><w>mikerod</w>What clj does not offer, is how to refer to records in a way without interop (eg. <code>:import</code>)</z><z id="t1600365214037100" t="mikerod More frustrating to me, is CLJS does allow you to refer to record types via :require + :as"><y>#</y><d>2020-09-17</d><h>17:53</h><w>mikerod</w>More frustrating to me, is CLJS does allow you to refer to record types via <code>:require</code> + <code>:as</code></z><z id="t1600365245037800" t="mikerod so this causes lots of additional problems with say , making cljc files where you want to use :as aliases, but then records need to be specified different ways for :clj vs :cljs"><y>#</y><d>2020-09-17</d><h>17:54</h><w>mikerod</w>so this causes lots of additional problems with say , making cljc files where you want to use <code>:as</code> aliases, but then records need to be specified different ways for <code>:clj</code> vs  <code>:cljs</code></z><z id="t1600365293038600" t="mikerod so that’s some background. I don’t know what exactly Clara should/could do here to help. However, Clara’s compilation has control over symbol resolution so it’s likely something could be done to allow for no :import to be needed"><y>#</y><d>2020-09-17</d><h>17:54</h><w>mikerod</w>so that’s some background. I don’t know what exactly Clara should/could do here to help. However, Clara’s compilation has control over symbol resolution so it’s likely something could be done to allow for no <code>:import</code> to be needed</z><z id="t1600365314039000" t="mikerod I think probably, Clara could attempt to support the cljs style record syntax"><y>#</y><d>2020-09-17</d><h>17:55</h><w>mikerod</w>I think probably, Clara could attempt to support the cljs style record syntax</z><z id="t1600365323039400" t="mikerod like a/MyRec"><y>#</y><d>2020-09-17</d><h>17:55</h><w>mikerod</w>like <code>a/MyRec</code></z><z id="t1600365352040200" t="mikerod and just implicitly know to resolve it in clj following some rules like: 1) first see if a/MyRec exists 2) if not, try a.MyRec1"><y>#</y><d>2020-09-17</d><h>17:55</h><w>mikerod</w>and just implicitly know to resolve it in clj following some rules like:
1) first see if <code>a/MyRec</code> exists
2) if not, try <code>a.MyRec1</code></z><z id="t1600365400041300" t="mikerod this could be convenient for Clara’s perspective. it would deviate from the perspective of what clj actually allows"><y>#</y><d>2020-09-17</d><h>17:56</h><w>mikerod</w>this could be convenient for Clara’s perspective. it would deviate from the perspective of what clj actually allows</z><z id="t1600365404041500" t="mikerod so there’s a pro vs con"><y>#</y><d>2020-09-17</d><h>17:56</h><w>mikerod</w>so there’s a pro vs con</z><z id="t1600365794045500" t="Matthew Pettis That would be nice to not have the interop require vs. import split, as it seems a typical rules pattern is to have record class referenced in the LHS, and needs to construct and insert a record on the RHS, which needs the constructor via require. It took me a while to suss out the difference, and a post by Alex Miller (which I can&apos;t find today) helped me understand it a bit more. I considered going down to the plain maps workflow and not using records, which would take care of this issue, and I assume people who don&apos;t use records make code that should mostly run in either CLJ or CLJS."><y>#</y><d>2020-09-17</d><h>18:03</h><w>Matthew Pettis</w>That would be nice to not have the interop require vs. import split, as it seems a typical rules pattern is to have record class referenced in the LHS, and needs to construct and insert a record on the RHS, which needs the constructor via require.  It took me a while to suss out the difference, and a post by Alex Miller (which I can&apos;t find today) helped me understand it a bit more.  I considered going down to the plain maps workflow and not using records, which would take care of this issue, and I assume people who don&apos;t use records make code that should mostly run in either CLJ or CLJS.</z><z id="t1600365973048400" t="Matthew Pettis But I&apos;ll say that Clara still seems to have better semantics and usability than other solutions I&apos;ve tried. durable_rules from jruizgit at github works, but not for my use case, where I like the concept of queries that can return me the facts in the session, which durable_rules does not in theory (jruiz made a function to do so after a an issue I filed, but it appears to still have some bugs)."><y>#</y><d>2020-09-17</d><h>18:06</h><w>Matthew Pettis</w>But I&apos;ll say that Clara still seems to have better semantics and usability than other solutions I&apos;ve tried.  <code>durable_rules</code> from jruizgit at github works, but not for my use case, where I like the concept of queries that can return me the facts in the session, which <code>durable_rules</code> does not in theory (jruiz made a function to do so after a an issue I filed, but it appears to still have some bugs).</z><z id="t1600366000048700" t="mikerod Nice that Clara has worked better for you!"><y>#</y><d>2020-09-17</d><h>18:06</h><w>mikerod</w>Nice that Clara has worked better for you!</z><z id="t1600366013049000" t="mikerod and I really wish clj would have supported non-interop ways to refer to records"><y>#</y><d>2020-09-17</d><h>18:06</h><w>mikerod</w>and I really wish clj would have supported non-interop ways to refer to records</z><z id="t1600366016049200" t="mikerod it’s much nicer in cljs"><y>#</y><d>2020-09-17</d><h>18:06</h><w>mikerod</w>it’s much nicer in cljs</z><z id="t1600366047049900" t="mikerod you will see in clara-rules test ns’s we have a lot of cljc stuff. And you’ll see a lot of read-conditionals around the difference between having to use :require in cljs for records, vs :import for clj"><y>#</y><d>2020-09-17</d><h>18:07</h><w>mikerod</w>you will see in clara-rules test ns’s we have a lot of cljc stuff. And you’ll see a lot of read-conditionals around the difference between having to use <code>:require</code> in cljs for records, vs <code>:import</code> for clj</z><z id="t1600366074050400" t="mikerod but yeah, feel free to log a clara-rules github issue if you want to propose allowing the syntactic forms perhaps"><y>#</y><d>2020-09-17</d><h>18:07</h><w>mikerod</w>but yeah, feel free to log a clara-rules github issue if you want to propose allowing the syntactic forms perhaps</z><z id="t1600366085050900" t="mikerod the only thing I don’t like as much as it differs from how clj resolves symbols"><y>#</y><d>2020-09-17</d><h>18:08</h><w>mikerod</w>the only thing I don’t like as much as it differs from how clj resolves symbols</z><z id="t1600366098051500" t="mikerod but we do that in other ways throughout forms as well - so maybe not that big of a deal"><y>#</y><d>2020-09-17</d><h>18:08</h><w>mikerod</w>but we do that in other ways throughout forms as well - so maybe not that big of a deal</z><z id="t1600366113052000" t="mikerod and records can be quite convenient over maps (although both are supported)"><y>#</y><d>2020-09-17</d><h>18:08</h><w>mikerod</w>and records can be quite convenient over maps (although both are supported)</z><z id="t1600366130052800" t="mikerod records have another benefit in that clara compiler will “understand field references”"><y>#</y><d>2020-09-17</d><h>18:08</h><w>mikerod</w>records have another benefit in that clara compiler will “understand field references”</z><z id="t1600366143053400" t="mikerod so you can do like [MyRec (= ?x x)] where x is a field on MyRec"><y>#</y><d>2020-09-17</d><h>18:09</h><w>mikerod</w>so you can do like <code>[MyRec (= ?x x)]</code> where <code>x</code> is a field on <code>MyRec</code></z><z id="t1600366187054800" t="mikerod if you used a map, you’d have to do [:my-rec (= ?x (;x this))] (assuming your map used the clara default type impl to produce that :my-rec type)"><y>#</y><d>2020-09-17</d><h>18:09</h><w>mikerod</w>if you used a map, you’d have to do <code>[:my-rec (= ?x (;x this))]</code> (assuming your map used the clara default <code>type</code> impl to produce that <code>:my-rec</code> type)</z><z id="t1600366225055800" t="Matthew Pettis in disclosure, I am not so much a programmer as a data scientist with some ability to code, and I have a some applications I can really see rules engine bridging for me, so I am learning Clojure and Clara mostly at the same time. I say that so when you see crazy recommendations from me, you&apos;ll take it with a grain of salt."><y>#</y><d>2020-09-17</d><h>18:10</h><w>Matthew Pettis</w>in disclosure, I am not so much a programmer as a data scientist with some ability to code, and I have a some applications I can really see rules engine bridging for me, so I am learning Clojure and Clara mostly at the same time.  I say that so when you see crazy recommendations from me, you&apos;ll take it with a grain of salt.</z><z id="t1600366227055900" t="mikerod and lastly, records can have some efficiency gains where some cases that may matter"><y>#</y><d>2020-09-17</d><h>18:10</h><w>mikerod</w>and lastly, records can have some efficiency gains where some cases that may matter</z><z id="t1600366360057800" t="Matthew Pettis yeah, that&apos;s why I like the records approach -- it seemed like a much more comprehensible syntax to make rules with. I haven&apos;t had to address performance yet, as my rulesets are not that large, and probably won&apos;t be for what I am envisioning."><y>#</y><d>2020-09-17</d><h>18:12</h><w>Matthew Pettis</w>yeah, that&apos;s why I like the records approach -- it seemed like a much more comprehensible syntax to make rules with.  I haven&apos;t had to address performance yet, as my rulesets are not that large, and probably won&apos;t be for what I am envisioning.</z><z id="t1600793108001500" t="yenda Is there a way to have async code in the LHS of a rule? It looks like because a go block returns immediately, if one tries to insert! a fact in the go block on the LHS of a rule, the insert throws an error because the context is gone"><y>#</y><d>2020-09-22</d><h>16:45</h><w>yenda</w>Is there a way to have async code in the LHS of a rule? It looks like because a go block returns immediately, if one tries to insert! a fact in the go block on the LHS of a rule, the insert throws an error because the context is gone</z><z id="t1600800739002200" t="sparkofreason Pretty sure the answer is &quot;no&quot;. Why do you want a go-block in the LHS? Maybe there&apos;s another way to accomplish what you need."><y>#</y><d>2020-09-22</d><h>18:52</h><w>sparkofreason</w>Pretty sure the answer is &quot;no&quot;. Why do you want a go-block in the LHS? Maybe there&apos;s another way to accomplish what you need.</z><z id="t1600808786002500" t="yenda I need to do some async calls to get some info from an api"><y>#</y><d>2020-09-22</d><h>21:06</h><w>yenda</w>I need to do some async calls to get some info from an api</z><z id="t1600808861004900" t="ethanc Doing stateful things within the rules themselves can lead to bizzare behaviors"><y>#</y><d>2020-09-22</d><h>21:07</h><w>ethanc</w>Doing stateful things within the rules themselves can lead to bizzare behaviors</z><z id="t1600808893005700" t="yenda if I can&apos;t do it I suppose the way around that is to insert a fact that will describe the api call that needs to be done, query for that fact, insert more fact based on that result then fire rules again?"><y>#</y><d>2020-09-22</d><h>21:08</h><w>yenda</w>if I can&apos;t do it I suppose the way around that is to insert a fact that will describe the api call that needs to be done, query for that fact, insert more fact based on that result then fire rules again?</z><z id="t1600809039007700" t="ethanc that would likely be the recommended approach, clara works on the presence or absence of non mutating facts and assertions. When stuff starts changing beneath it, truth maintenance starts to break down"><y>#</y><d>2020-09-22</d><h>21:10</h><w>ethanc</w>that would likely be the recommended approach, clara works on the presence or absence of non mutating facts and assertions. When stuff starts changing beneath it, truth maintenance starts to break down</z><z id="t1601412549001600" t="kvlt Is it possible to have rule run, if it does not find a match, it calls another rule? Or will all rules be run and it&apos;s up to me to clean that out?"><y>#</y><d>2020-09-29</d><h>20:49</h><w>kvlt</w>Is it possible to have rule run, if it does not find a match, it calls another rule? Or will all rules be run and it&apos;s up to me to clean that out?</z><z id="t1601412651001800" t="kvlt I guess rule chaining"><y>#</y><d>2020-09-29</d><h>20:50</h><w>kvlt</w>I guess rule chaining</z><z id="t1601424531003300" t="futuro You probably want two rules, one for when there’s a match and one for when there isn’t (using the :not predicate)"><y>#</y><d>2020-09-30</d><h>00:08</h><w>futuro</w>You probably want two rules, one for when there’s a match and one for when there isn’t (using the :not predicate)</z><z id="t1601479040004400" t="kvlt @futuro it&apos;s possible for it to match multiple rules, but there is a preference as to which one we want to use. Right now I&apos;m assigning a priority to the matches and then using an accumulator to select the best. Is this a valid approach?"><y>#</y><d>2020-09-30</d><h>15:17</h><w>kvlt</w>@futuro it&apos;s possible for it to match multiple rules, but there is a preference as to which one we want to use. Right now I&apos;m assigning a priority to the matches and then using an accumulator to select the best. Is this a valid approach?</z><z id="t1601494249011700" t="mikerod Yes. Priority sort of logic comes up often in my past usages"><y>#</y><d>2020-09-30</d><h>19:30</h><w>mikerod</w>Yes. Priority sort of logic comes up often in my past usages</z><z id="t1601494289012100" t="kvlt Thanks @defndaines @mikerod"><y>#</y><d>2020-09-30</d><h>19:31</h><w>kvlt</w>Thanks @defndaines @mikerod</z><z id="t1601494430012300" t="mikerod https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac"><y>#</y><d>2020-09-30</d><h>19:33</h><w>mikerod</w><a href="https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac" target="_blank">https://gist.github.com/mrrodriguez/6a6f8373b25d69826b3efe154c928fac</a></z><z id="t1601494445012800" t="mikerod This this was a related gist I did about it long ago. Not sure if it’s exactly the same situation though. "><y>#</y><d>2020-09-30</d><h>19:34</h><w>mikerod</w>This this was a related gist I did about it long ago. Not sure if it’s exactly the same situation though. </z><z id="t1601494666013200" t="kvlt @mikerod that&apos;s very useful. It does look like you&apos;re using clojure maps over records?"><y>#</y><d>2020-09-30</d><h>19:37</h><w>kvlt</w>@mikerod that&apos;s very useful. It does look like you&apos;re using clojure maps over records?</z><z id="t1601495207013800" t="mikerod @petr just for the sake of example. Either would work for the concept"><y>#</y><d>2020-09-30</d><h>19:46</h><w>mikerod</w>@petr just for the sake of example. Either would work for the concept</z><z id="t1601495254014600" t="kvlt Of course. I think I would prefer to use maps over records in my code-base. I was excited to see an example. I didn’t know it was possible"><y>#</y><d>2020-09-30</d><h>19:47</h><w>kvlt</w>Of course. I think I would prefer to use maps over records in my code-base. I was excited to see an example. I didn’t know it was possible</z><z id="t1601564533015800" t="mikerod @petr I guess it isn’t really documented that well - but this relates http://www.clara-rules.org/docs/fact_type_customization/"><y>#</y><d>2020-10-01</d><h>15:02</h><w>mikerod</w>@petr I guess it isn’t really documented that well - but this relates <a href="http://www.clara-rules.org/docs/fact_type_customization/" target="_blank">http://www.clara-rules.org/docs/fact_type_customization/</a></z><z id="t1601564543016200" t="mikerod but is more specific than the general case you probably care about."><y>#</y><d>2020-10-01</d><h>15:02</h><w>mikerod</w>but is more specific than the general case you probably care about.</z><z id="t1601564565016600" t="mikerod In general though, the type matching dispatch for rules is done via clojure.core/type"><y>#</y><d>2020-10-01</d><h>15:02</h><w>mikerod</w>In general though, the type matching dispatch for rules is done via <code>clojure.core/type</code></z><z id="t1601564594017100" t="mikerod but you can customize that dispatch via :fact-type-fn and :ancestors-fn if you have “hierarchical relationship”"><y>#</y><d>2020-10-01</d><h>15:03</h><w>mikerod</w>but you can customize that dispatch via <code>:fact-type-fn</code> and <code>:ancestors-fn</code> if you have “hierarchical relationship”</z><z id="t1601564611017300" t="mikerod my gist I shared mentions this stuff briefly and references the source doc"><y>#</y><d>2020-10-01</d><h>15:03</h><w>mikerod</w>my gist I shared mentions this stuff briefly and references the source doc</z><z id="t1601567461022600" t="bmaddy I&apos;m potentially going to be using clara for a situation where end users will be writing their own rules. I&apos;m concerned that the rules will get really complex with non-developers writing them. Are there any techniques to automatically find candidates for new rules that would simplify multiple other rules (like abstracting common clauses out)? One idea I had when I noticed clara converts expressions to disjunctive normal form was to use that along with karnaugh maps to simplify expressions. Has anyone heard of something like that being done before? Is this a crazy idea?"><y>#</y><d>2020-10-01</d><h>15:51</h><w>bmaddy</w>I&apos;m potentially going to be using clara for a situation where end users will be writing their own rules. I&apos;m concerned that the rules will get really complex with non-developers writing them. Are there any techniques to automatically find candidates for new rules that would simplify multiple other rules (like abstracting common clauses out)?
One idea I had when I noticed clara converts expressions to disjunctive normal form was to use that along with karnaugh maps to simplify expressions. Has anyone heard of something like that being done before? Is this a crazy idea?</z><z id="t1601647007024200" t="ethanc @mikerod can probably correct me here, but i believe that clara’s compiler already tries to share common constraints within the same session."><y>#</y><d>2020-10-02</d><h>13:56</h><w>ethanc</w>@mikerod can probably correct me here, but i believe that clara’s compiler already tries to share common constraints within the same session.</z><z id="t1601647901024700" t="mikerod Yeah, I believe that common constraints are checked for and can end up being shared nodes on the rulebase network"><y>#</y><d>2020-10-02</d><h>14:11</h><w>mikerod</w>Yeah, I believe that common constraints are checked for and can end up being shared nodes on the rulebase network</z><z id="t1601647977026100" t="mikerod So typically, I guess the idea is you don’t need to be overly concerned with “redundancy” in that respect - however, there are clearly times when you want to extract rules to help eliminate large numbers of facts coming into multi-way joins"><y>#</y><d>2020-10-02</d><h>14:12</h><w>mikerod</w>So typically, I guess the idea is you don’t need to be overly concerned with “redundancy” in that respect - however, there are clearly times when you want to extract rules to help eliminate large numbers of facts coming into multi-way joins</z><z id="t1601649556028200" t="bmaddy Oh, yeah, I didn&apos;t mean for performance--I didn&apos;t make that clear above. I&apos;m really thinking more in terms of readability for humans (i.e. automatically find a common abstraction to make it easier to understand all your rules). It&apos;s nice to know constraints become shared nodes though!"><y>#</y><d>2020-10-02</d><h>14:39</h><w>bmaddy</w>Oh, yeah, I didn&apos;t mean for performance--I didn&apos;t make that clear above. I&apos;m really thinking more in terms of readability for humans (i.e. automatically find a common abstraction to make it easier to understand all your rules). It&apos;s nice to know constraints become shared nodes though!</z><z id="t1601654379030300" t="ethanc i haven’t really thought about static analysis of the rules written in the DSL, its an interesting thought. In general it would be nice to have analysis tools that would guide rule developers in the right direction with regards to patterns."><y>#</y><d>2020-10-02</d><h>15:59</h><w>ethanc</w>i haven’t really thought about static analysis of the rules written in the DSL, its an interesting thought.
In general it would be nice to have analysis tools that would guide rule developers in the right direction with regards to patterns.</z><z id="t1601664756030600" t="mikerod we did write some extra higher-level DSLs in some cases"><y>#</y><d>2020-10-02</d><h>18:52</h><w>mikerod</w>we did write some extra higher-level DSLs in some cases</z><z id="t1601664762030900" t="mikerod to abstract away common rule patterns"><y>#</y><d>2020-10-02</d><h>18:52</h><w>mikerod</w>to abstract away common rule patterns</z><z id="t1601664769031100" t="mikerod so that’s something to consider sometimes"><y>#</y><d>2020-10-02</d><h>18:52</h><w>mikerod</w>so that’s something to consider sometimes</z><z id="t1601927160032200" t="bmaddy Thanks for the thoughts. It will be a while before I get to the position of maybe trying it. If I do end up trying it, I&apos;ll certainly post results back here."><y>#</y><d>2020-10-05</d><h>19:46</h><w>bmaddy</w>Thanks for the thoughts. It will be a while before I get to the position of maybe trying it. If I do end up trying it, I&apos;ll certainly post results back here.</z><z id="t1601997116035500" t="futuro A second idea @bmaddy , if it fits your project, would be to create a UI for building rules, perhaps presenting a searchable list of Fact records to users, along with their available fields, and allow them to pick the facts and fields they want to match on, plus the Boolean expression combinations. "><y>#</y><d>2020-10-06</d><h>15:11</h><w>futuro</w>A second idea @bmaddy , if it fits your project, would be to create a UI for building rules, perhaps presenting a searchable list of Fact records to users, along with their available fields, and allow them to pick the facts and fields they want to match on, plus the Boolean expression combinations. </z><z id="t1601997163036900" t="futuro That’s definitely not a small project, but might greatly raise the accessibility for non-developers to write facts with, while providing guardrails to help them. "><y>#</y><d>2020-10-06</d><h>15:12</h><w>futuro</w>That’s definitely not a small project, but might greatly raise the accessibility for non-developers to write facts with, while providing guardrails to help them. </z><z id="t1601998565038500" t="bmaddy @futuro Yeah, a UI would be nice, but that&apos;s way off in the future. At the moment, we&apos;re not entirely sure we&apos;ll have users writing actual rules yet. We&apos;ll see what happens. Good ideas though!"><y>#</y><d>2020-10-06</d><h>15:36</h><w>bmaddy</w>@futuro Yeah, a UI would be nice, but that&apos;s way off in the future. At the moment, we&apos;re not entirely sure we&apos;ll have users writing actual rules yet. We&apos;ll see what happens. Good ideas though!</z><z id="t1602015405041500" t="Matthew Pettis I think I&apos;ve asked this before, but I cannot retrieve the history too far back of this channel... What is the best way to capture the chain of facts and rules that caused a fact to be produced in a session? I don&apos;t need a full-blown GUI, and honestly would just be able to get a data structure I can manipulate myself..."><y>#</y><d>2020-10-06</d><h>20:16</h><w>Matthew Pettis</w>I think I&apos;ve asked this before, but I cannot retrieve the history too far back of this channel... What is the best way to capture the chain of facts and rules that caused a fact to be produced in a session?  I don&apos;t need a full-blown GUI, and honestly would just be able to get a data structure I can manipulate myself...</z><z id="t1602015500043400" t="Matthew Pettis So, for instance, if I have a session with a rule that has something like &quot;P =&gt; Q&quot; and I insert a fact P into the session, and query for the fact Q, which should be present, I&apos;d like to be able to take Q and inspect the session and see the presence of fact P and the rule &quot;P =&gt; Q&quot;. But, you know, with more complex rules and such. Is this readily available?"><y>#</y><d>2020-10-06</d><h>20:18</h><w>Matthew Pettis</w>So, for instance, if I have a session with a rule that has something like &quot;P =&gt; Q&quot; and I insert a fact P into the session, and query for the fact Q, which should be present, I&apos;d like to be able to take Q and inspect the session and see the presence of fact P and the rule &quot;P =&gt; Q&quot;.  But, you know, with more complex rules and such.  Is this readily available?</z><z id="t1602015579044900" t="Matthew Pettis I&apos;ve looked at https://github.com/rbrush/clara-tools , but I can&apos;t get the shopping.clj example to work -- launches a web page, but with no session and nothing to look at, as far as I can tell. But again, I really don&apos;t want the gui, I just want to be able to inspect a session for the chain of facts and rules that lead to other facts being present in the system..."><y>#</y><d>2020-10-06</d><h>20:19</h><w>Matthew Pettis</w>I&apos;ve looked at <a href="https://github.com/rbrush/clara-tools" target="_blank">https://github.com/rbrush/clara-tools</a> , but I can&apos;t get the shopping.clj example to work -- launches a web page, but with no session and nothing to look at, as far as I can tell.  But again, I really don&apos;t want the gui, I just want to be able to inspect a session for the chain of facts and rules that lead to other facts being present in the system...</z><z id="t1602015639046200" t="Matthew Pettis It should also make sense in simple cases. As in the prior case, if P is an inserted fact, and I want to see how I got P, I should just see &quot;P&quot; with no rules, as it was inserted a priori..."><y>#</y><d>2020-10-06</d><h>20:20</h><w>Matthew Pettis</w>It should also make sense in simple cases.  As in the prior case, if P is an inserted fact, and I want to see how I got P, I should just see &quot;P&quot; with no rules, as it was inserted a priori...</z><z id="t1602097420047600" t="wparker As far as I know the clara-tools project isn’t really maintained anymore. From what you describe though I think you can probably accomplish what you’re looking for in a non-GUI environment with session inspection, particularly the :fact-&gt;explanations key. http://www.clara-rules.org/docs/inspection/"><y>#</y><d>2020-10-07</d><h>19:03</h><r>wparker</r>As far as I know the clara-tools project isn’t really maintained anymore.  From what you describe though I think you can probably accomplish what you’re looking for in a non-GUI environment with session inspection, particularly the :fact-&gt;explanations key. <a href="http://www.clara-rules.org/docs/inspection/" target="_blank">http://www.clara-rules.org/docs/inspection/</a></z><z id="t1602097483047900" t="wparker The fact-graph functionality might also be of use, though note that this is basically just another view over the information returned by session inspection. https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/tools/fact_graph.cljc"><y>#</y><d>2020-10-07</d><h>19:04</h><r>wparker</r>The fact-graph functionality might also be of use, though note that this is basically just another view over the information returned by session inspection. <a href="https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/tools/fact_graph.cljc" target="_blank">https://github.com/cerner/clara-rules/blob/main/src/main/clojure/clara/tools/fact_graph.cljc</a></z><z id="t1602099369051500" t="Matthew Pettis Thanks! I think session-inspection is exactly what I need at this point of what I think are my simple needs."><y>#</y><d>2020-10-07</d><h>19:36</h><r>Matthew Pettis</r>Thanks!  I think session-inspection is exactly what I need at this point of what I think are my simple needs.</z><z id="t1602071226046800" t="dharrigan Can clara be used to enforce a type of &quot;state&quot;, i.e., something starts with a state, then moves to another state, but cannot move to a previous state?"><y>#</y><d>2020-10-07</d><h>11:47</h><w>dharrigan</w>Can clara be used to enforce a type of &quot;state&quot;, i.e., something starts with a state, then moves to another state, but cannot move to a previous state?</z><z id="t1602076136047100" t="mikerod @dharrigan I’d think you can model this via forward-chaining"><y>#</y><d>2020-10-07</d><h>13:08</h><w>mikerod</w>@dharrigan I’d think you can model this via forward-chaining</z><z id="t1602079134047500" t="dharrigan Okay, thank you. I&apos;ll have a play 🙂"><y>#</y><d>2020-10-07</d><h>13:58</h><w>dharrigan</w>Okay, thank you. I&apos;ll have a play <b>🙂</b></z><z id="t1602097706050700" t="wparker Like a state machine basically? It certainly could be done in Clara, although maybe something more specifically aimed at representing state machines would be simpler. Depends on the use case probably and whether it is part of your rules or the whole thing; I haven’t tried encoding any state machines “for real” before."><y>#</y><d>2020-10-07</d><h>19:08</h><w>wparker</w>Like a state machine basically?  It certainly could be done in Clara, although maybe something more specifically aimed at representing state machines would be simpler.  Depends on the use case probably and whether it is part of your rules or the whole thing; I haven’t tried encoding any state machines “for real” before.</z><z id="t1602098022051000" t="dharrigan Yes, a very very simple state machine, just a few states."><y>#</y><d>2020-10-07</d><h>19:13</h><w>dharrigan</w>Yes, a very very simple state machine, just a few states.</z><z id="t1602098037051300" t="dharrigan Perhaps I may just end up doing a cond 🙂"><y>#</y><d>2020-10-07</d><h>19:13</h><w>dharrigan</w>Perhaps I may just end up doing a cond <b>🙂</b></z><z id="t1602115977052300" t="sparkofreason Is there a technical reason why tests are not included in boolean expressions?"><y>#</y><d>2020-10-08</d><h>00:12</h><w>sparkofreason</w>Is there a technical reason why tests are not included in boolean expressions?</z><z id="t1602116103052700" t="sparkofreason Maybe because the variables have to be bound before executing the test?"><y>#</y><d>2020-10-08</d><h>00:15</h><w>sparkofreason</w>Maybe because the variables have to be bound before executing the test?</z><z id="t1602116604056400" t="ethanc As you mentioned, test conditions allow a fact-binding to be bound before evaluation. My go-to example would be checking the result of an accumulator"><y>#</y><d>2020-10-08</d><h>00:23</h><w>ethanc</w>As you mentioned, test conditions allow a fact-binding to be bound before evaluation. My go-to example would be checking the result of an accumulator</z><z id="t1602128923058400" t="Matthew Pettis Looking at output of clara.rules.inspect ... just wondering, when using inspect on a session, what is the difference in the contents of the :condition-matches vs the :insertions . They seem to have pretty much the same information, but granted, I am just using a single rule and single insertion and trying to inspect the output to figure out what inspect can tell me, and how, at the moment..."><y>#</y><d>2020-10-08</d><h>03:48</h><w>Matthew Pettis</w>Looking at output of <code>clara.rules.inspect</code>... just wondering, when using <code>inspect</code> on a session, what is the difference in the contents of the <code>:condition-matches</code> vs the <code>:insertions</code>.  They seem to have pretty much the same information, but granted, I am just using a single rule and single insertion and trying to inspect the output to figure out what <code>inspect</code> can tell me, and how, at the moment...</z><z id="t1602163966060200" t="ethanc I believe that the :condition-matches is meant to capture/explain join nodes, where :insertions should contain what facts were inserted and why they were inserted i believe"><y>#</y><d>2020-10-08</d><h>13:32</h><w>ethanc</w>I believe that the <code>:condition-matches</code> is meant to capture/explain join nodes, where <code>:insertions</code> should contain what facts were inserted and why they were inserted i believe</z><z id="t1602170821062100" t="Matthew Pettis It looks like :condition-matches will also show the unconditional inserts (like the initial facts loaded to a session)... does that seem right?"><y>#</y><d>2020-10-08</d><h>15:27</h><w>Matthew Pettis</w>It looks like <code>:condition-matches</code> will also show the unconditional inserts (like the initial facts loaded to a session)... does that seem right?</z><z id="t1602859202065600" t="kvlt Is there a way to create rules without the defrule macro? I am currently pulling constraints out of a database and would like to make a bunch of rules based off of those. I noticed that the macro appears to just create a var? (def do-it {:ns-name &apos;woof, :lhs &apos;[{:type woof.Person, :constraints [(= name &quot;me&quot;)]}], :rhs &apos;(do (prn &quot;99999&quot;)), :name &quot;woof/do-it&quot;}) However creating that var does not seem to create the rule."><y>#</y><d>2020-10-16</d><h>14:40</h><w>kvlt</w>Is there a way to create rules without the <code>defrule</code> macro? I am currently pulling constraints out of a database and would like to make a bunch of rules based off of those. I noticed that the macro appears to just create a var?

<pre>(def
 do-it
 {:ns-name &apos;woof,
  :lhs &apos;[{:type woof.Person, :constraints [(= name &quot;me&quot;)]}],
  :rhs &apos;(do (prn &quot;99999&quot;)),
  :name &quot;woof/do-it&quot;})</pre>
However creating that var does not seem to create the rule.</z><z id="t1602859429067300" t="kvlt My guess is that this is not adding that var to the clara-session?"><y>#</y><d>2020-10-16</d><h>14:43</h><w>kvlt</w>My guess is that this is not adding that var to the clara-session?</z><z id="t1602859646067700" t="mikerod @petr it is supported and you don’t even need vars"><y>#</y><d>2020-10-16</d><h>14:47</h><w>mikerod</w>@petr it is supported and you don’t even need vars</z><z id="t1602859650067900" t="mikerod but you can use vars if that is convenient for you"><y>#</y><d>2020-10-16</d><h>14:47</h><w>mikerod</w>but you can use vars if that is convenient for you</z><z id="t1602859671068300" t="mikerod if you do use vars, the question then becomes how is it “auto detected” via Clara’s default namespace scanning impl"><y>#</y><d>2020-10-16</d><h>14:47</h><w>mikerod</w>if you do use vars, the question then becomes how is it “auto detected” via Clara’s default namespace scanning impl</z><z id="t1602859676068500" t="mikerod and that is done via metadata"><y>#</y><d>2020-10-16</d><h>14:47</h><w>mikerod</w>and that is done via metadata</z><z id="t1602859776068800" t="mikerod https://github.com/cerner/clara-rules/blob/0.21.0/src/main/clojure/clara/rules.cljc#L271-L305"><y>#</y><d>2020-10-16</d><h>14:49</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/blob/0.21.0/src/main/clojure/clara/rules.cljc#L271-L305" target="_blank">https://github.com/cerner/clara-rules/blob/0.21.0/src/main/clojure/clara/rules.cljc#L271-L305</a></z><z id="t1602859835070500" t="kvlt @mikerod I would use vars or not. It just feels better than using a macro to generate defrules"><y>#</y><d>2020-10-16</d><h>14:50</h><w>kvlt</w>@mikerod I would use vars or not. It just feels better than using a macro to generate <code>defrules</code></z><z id="t1602859852071200" t="mikerod this is what it does to scan built-in"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>this is what it does to scan built-in</z><z id="t1602859853071400" t="mikerod so specifically for vars"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>so specifically for vars</z><z id="t1602859853071600" t="mikerod if you have meta : :rule , :query , or :production-seq"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>if you have <code>meta</code> :
<code>:rule</code>, <code>:query</code>, or <code>:production-seq</code></z><z id="t1602859853071800" t="mikerod it is treated as a rule container of some sort"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>it is treated as a rule container of some sort</z><z id="t1602859854072000" t="mikerod :rule and :query are a single rule/query"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w><code>:rule</code> and <code>:query</code> are a single rule/query</z><z id="t1602859854072100" t="mikerod :production-seq is a collection of rules/queries - aka “productions”"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w><code>:production-seq</code> is a collection of rules/queries - aka “productions”</z><z id="t1602859854072300" t="mikerod you don’t need macros"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>you don’t need macros</z><z id="t1602859855072500" t="mikerod and you don’t need vars"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>and you don’t need vars</z><z id="t1602859856072700" t="mikerod if you have a more data-oriented case"><y>#</y><d>2020-10-16</d><h>14:50</h><w>mikerod</w>if you have a more data-oriented case</z><z id="t1602859868073000" t="mikerod mk-session takes collections of rule/query (aka production) structures"><y>#</y><d>2020-10-16</d><h>14:51</h><w>mikerod</w><code>mk-session</code> takes collections of rule/query (aka production) structures</z><z id="t1602859873073200" t="kvlt I&apos;m open to really any approach here"><y>#</y><d>2020-10-16</d><h>14:51</h><w>kvlt</w>I&apos;m open to really any approach here</z><z id="t1602859899073700" t="mikerod well, you just have to choose what is best suited"><y>#</y><d>2020-10-16</d><h>14:51</h><w>mikerod</w>well, you just have to choose what is best suited</z><z id="t1602859907074100" t="kvlt Oh cool. so I could actually pass those &quot;rule&quot; maps to the mk-session ?"><y>#</y><d>2020-10-16</d><h>14:51</h><w>kvlt</w>Oh cool. so I could actually pass those &quot;rule&quot; maps to the <code>mk-session</code>?</z><z id="t1602859909074200" t="mikerod vars are awkward to create if you’re doing it like at runtime"><y>#</y><d>2020-10-16</d><h>14:51</h><w>mikerod</w>vars are awkward to create if you’re doing it like at runtime</z><z id="t1602859951074400" t="kvlt I agree"><y>#</y><d>2020-10-16</d><h>14:52</h><w>kvlt</w>I agree</z><z id="t1602859969074900" t="mikerod if you look at tests"><y>#</y><d>2020-10-16</d><h>14:52</h><w>mikerod</w>if you look at tests</z><z id="t1602860030076700" t="mikerod https://github.com/cerner/clara-rules/blob/0.21.0/src/test/clojure/clara/test_rules.clj#L144"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w><a href="https://github.com/cerner/clara-rules/blob/0.21.0/src/test/clojure/clara/test_rules.clj#L144" target="_blank">https://github.com/cerner/clara-rules/blob/0.21.0/src/test/clojure/clara/test_rules.clj#L144</a></z><z id="t1602860030076800" t="mikerod as example"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w>as example</z><z id="t1602860031076900" t="mikerod you see they are almost all just based on passing rule/query maps in a collection to mk-session"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w>you see they are almost all just based on passing rule/query maps in a collection to <code>mk-session</code></z><z id="t1602860031077000" t="mikerod so this is probably all you are really looking for"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w>so this is probably all you are really looking for</z><z id="t1602860031077100" t="mikerod vars with metadata are basically just a convenience"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w>vars with metadata are basically just a convenience</z><z id="t1602860031077200" t="mikerod for automatic rule/query detection in namespaces"><y>#</y><d>2020-10-16</d><h>14:53</h><w>mikerod</w>for automatic rule/query detection in namespaces</z><z id="t1602860047077600" t="mikerod which works better for cases where you are more statically writing rules via macros/DSL"><y>#</y><d>2020-10-16</d><h>14:54</h><w>mikerod</w>which works better for cases where you are more statically writing rules via macros/DSL</z><z id="t1602860155077900" t="kvlt Ohhh that looks useful, thank you for showing me that"><y>#</y><d>2020-10-16</d><h>14:55</h><w>kvlt</w>Ohhh that looks useful, thank you for showing me that</z><z id="t1602862983078100" t="mikerod no problem"><y>#</y><d>2020-10-16</d><h>15:43</h><w>mikerod</w>no problem</z><z id="t1602862996078700" t="mikerod I looked briefly on http://clara-rules.org and do not see any actual good documentation around “rule sources”"><y>#</y><d>2020-10-16</d><h>15:43</h><w>mikerod</w>I looked briefly on <a href="http://clara-rules.org" target="_blank">http://clara-rules.org</a> and do not see any actual good documentation around “rule sources”</z><z id="t1602863002078900" t="mikerod which I think could be improved"><y>#</y><d>2020-10-16</d><h>15:43</h><w>mikerod</w>which I think could be improved</z><z id="t1602863017079600" t="kvlt @mikerod thank you so much for that. This has made my day a lot easier"><y>#</y><d>2020-10-16</d><h>15:43</h><w>kvlt</w>@mikerod thank you so much for that. This has made my day a lot easier</z><z id="t1602863020079700" t="mikerod I think it’s lacking if we don’t include other major variants of how to load rules"><y>#</y><d>2020-10-16</d><h>15:43</h><w>mikerod</w>I think it’s lacking if we don’t include other major variants of how to load rules</z><z id="t1602863032080100" t="mikerod We’ve taken special care in a lot of the clara stuff to make it where the DSL is optional"><y>#</y><d>2020-10-16</d><h>15:43</h><w>mikerod</w>We’ve taken special care in a lot of the clara stuff to make it where the DSL is optional</z><z id="t1602863051080700" t="mikerod and to have the API accept other data-oriented options"><y>#</y><d>2020-10-16</d><h>15:44</h><w>mikerod</w>and to have the API accept other data-oriented options</z><z id="t1602863062081300" t="kvlt Yeah, this is clearly very well thought out"><y>#</y><d>2020-10-16</d><h>15:44</h><w>kvlt</w>Yeah, this is clearly very well thought out</z><z id="t1602863070081600" t="mikerod just DSL + var/ns scan-loading is built-in for convenience and the typical, most easy examples"><y>#</y><d>2020-10-16</d><h>15:44</h><w>mikerod</w>just DSL + var/ns scan-loading is built-in for convenience and the typical, most easy examples</z><z id="t1603031295082000" t="schmee are rule clauses order sensitive?"><y>#</y><d>2020-10-18</d><h>14:28</h><w>schmee</w>are rule clauses order sensitive?</z><z id="t1603031826082700" t="schmee i.e if I have (defrule foo [HighCardinality (= foo ?foo)] [LowCardinality (= foo ?foo)] =&gt; (insert! (-&gt;Foo ?name))) does it matter for performance that HighCardinality is before LowCardinality ?"><y>#</y><d>2020-10-18</d><h>14:37</h><w>schmee</w>i.e if I have
<pre>(defrule foo
  [HighCardinality (= foo ?foo)]
  [LowCardinality (= foo ?foo)]
  =&gt;
  (insert! (-&gt;Foo ?name)))</pre>
does it matter for performance that <code>HighCardinality</code> is before <code>LowCardinality</code>?</z><z id="t1603042919087200" t="ethanc I don&apos;t believe it would impact performance. The cartesian product would be the same size I believe"><y>#</y><d>2020-10-18</d><h>17:41</h><w>ethanc</w>I don&apos;t believe it would impact performance. The cartesian product would be the same size I believe</z><z id="t1603047849087600" t="schmee okay, this one has me completely stumped: (defrecord Reachable [nodeType name]) (defrecord Node [nodeType area name]) (defrule area-reachability [Reachable (= nodeType :area) (= name ?area)] [Node (= area ?area) (= nodeType ?nodeType) (= name ?name)] ; [:not [Reachable (= nodeType ?nodeType) (= name ?name)]] =&gt; (insert! (-&gt;Reachable ?nodeType ?name))) (comment (-&gt; (mk-session [area-reachability]) (insert (-&gt;Reachable :area &quot;World&quot;)) (insert (-&gt;Node :room &quot;World&quot; &quot;Foo&quot;)) fire-rules))"><y>#</y><d>2020-10-18</d><h>19:04</h><w>schmee</w>okay, this one has me completely stumped:
<pre>(defrecord Reachable [nodeType name])
(defrecord Node [nodeType area name])

(defrule area-reachability
  [Reachable (= nodeType :area) (= name ?area)]
  [Node (= area ?area) (= nodeType ?nodeType) (= name ?name)]
  ; [:not [Reachable (= nodeType ?nodeType) (= name ?name)]]
  =&gt;
  (insert! (-&gt;Reachable ?nodeType ?name)))

(comment
  (-&gt; (mk-session [area-reachability])
      (insert (-&gt;Reachable :area &quot;World&quot;))
      (insert (-&gt;Node :room &quot;World&quot; &quot;Foo&quot;))
      fire-rules))</pre></z><z id="t1603047873088200" t="schmee as written it finishes instantly, if you uncomment the [:not ...] it goes into an infinite loop"><y>#</y><d>2020-10-18</d><h>19:04</h><w>schmee</w>as written it finishes instantly, if you uncomment the <code>[:not ...]</code> it goes into an infinite loop</z><z id="t1603048286088800" t="schmee the intent is to not insert the Reachable fact if it’s already in the session"><y>#</y><d>2020-10-18</d><h>19:11</h><w>schmee</w>the intent is to not insert the <code>Reachable</code> fact if it’s already in the session</z><z id="t1603049252090400" t="mikerod It’s a commmon issue @schmee and you have to rethink the LHS to be in terms of what’s true about the entire state of the system"><y>#</y><d>2020-10-18</d><h>19:27</h><w>mikerod</w>It’s a commmon issue @schmee and you have to rethink the LHS to be in terms of what’s true about the entire state of the system</z><z id="t1603049265090900" t="mikerod So with the :not above you are expressing a logical contradiction. "><y>#</y><d>2020-10-18</d><h>19:27</h><w>mikerod</w>So with the :not above you are expressing a logical contradiction. </z><z id="t1603049913091700" t="schmee I see, could you elaborate a bit?"><y>#</y><d>2020-10-18</d><h>19:38</h><w>schmee</w>I see, could you elaborate a bit?</z><z id="t1603049947092500" t="schmee my mental model is that since the inserted node is not of nodeType :area , it will fail to match the first clause and hence the rule as a whole will not fire"><y>#</y><d>2020-10-18</d><h>19:39</h><w>schmee</w>my mental model is that since the inserted node is not of <code>nodeType</code> <code>:area</code>, it will fail to match the first clause and hence the rule as a whole will not fire</z><z id="t1603049957092900" t="schmee but that can’t be the case?"><y>#</y><d>2020-10-18</d><h>19:39</h><w>schmee</w>but that can’t be the case?</z><z id="t1603054764102000" t="ethanc What Mkie is alluding to is clara&apos;s truth maintenance: http://www.clara-rules.org/docs/truthmaint/ With the not un-commented, the rule itself becomes a logical contradiction of itself. The rule will only execute and be considered true if the fact in question is not within the session. However, if the rule inserts a fact that itself asserts to be absent, then a loop would be formed. A base state would be a session without the fact in question, ergo the rule must insert the Fact. Then clara must assert that all truth has been maintained, and finds that the Fact is now present. Meaning that the Rule is no no longer true, thus a logical retraction occurs removing the Fact from the session. Then clara must asser that all truth has been maintained, again. However we are back to the base state meaning that there is no Fact within the session and the Rule is true again, thus the cycle repeats and continues forever. The wiki mentions ways to circumvent this mechanic using unconditional inserts, however these can lead to non-logical conclusions if assumptions are made."><y>#</y><d>2020-10-18</d><h>20:59</h><w>ethanc</w>What Mkie is alluding to is clara&apos;s truth maintenance:
 <a href="http://www.clara-rules.org/docs/truthmaint/" target="_blank">http://www.clara-rules.org/docs/truthmaint/</a>

With the <code>not</code> un-commented, the rule itself becomes a logical contradiction of itself. The rule will only execute and  be considered true if the fact in question is not within the session. However, if the rule inserts a fact that itself asserts to be absent, then a loop would be formed.

A base state would be a session without the fact in question, ergo the rule must insert the Fact. Then clara must assert that all truth has been maintained, and finds that the Fact is now present. Meaning that the Rule is no no longer true, thus a logical retraction occurs removing the Fact from the session. Then clara must asser that all truth has been maintained, again. However we are back to the base state meaning that there is no Fact within the session and the Rule is true again, thus the cycle repeats and continues forever.

The wiki mentions ways to circumvent this mechanic using unconditional inserts, however these can lead to non-logical conclusions if assumptions are made.</z><z id="t1603055350103100" t="schmee thanks @ethanc, that clears things up quite a bit! I’ll take some time to ponder that and see if I can write the rule differently"><y>#</y><d>2020-10-18</d><h>21:09</h><w>schmee</w>thanks @ethanc, that clears things up quite a bit! I’ll take some time to ponder that and see if I can write the rule differently</z><z id="t1603055461104000" t="schmee I’m coming into Clara with a Datomic mindset, which will surely trip me up a few times before I understand the “rule engine way”"><y>#</y><d>2020-10-18</d><h>21:11</h><w>schmee</w>I’m coming into Clara with a Datomic mindset, which will surely trip me up a few times before I understand the “rule engine way”</z><z id="t1603060383106100" t="sparkofreason insert-uncondtional! is your friend here, if you want to have effects in the LHS of your rules. I find it easier to always use insert! , so that my rules are pure logic statements. When I want an effect, instead I insert a request fact, which is executed by some external component. That effect often invalidates the rule, thus causing the request to then be retracted by truth maintenance."><y>#</y><d>2020-10-18</d><h>22:33</h><w>sparkofreason</w><code>insert-uncondtional!</code> is your friend here, if you want to have effects in the LHS of your rules. I find it easier to always use <code>insert!</code>, so that my rules are pure logic statements. When I want an effect, instead I insert a <code>request</code> fact, which is executed by some external component. That effect often invalidates the rule, thus causing the request to then be retracted by truth maintenance.</z><z id="t1603060996106500" t="mikerod Yeah. I avoid unconditional in most cases. "><y>#</y><d>2020-10-18</d><h>22:43</h><w>mikerod</w>Yeah. I avoid unconditional in most cases. </z><z id="t1603061041107900" t="mikerod You typically can phrase the problem in a way that works with TMS. Often intermediate facts and accumulators in an aggregate rule can solve common situations. "><y>#</y><d>2020-10-18</d><h>22:44</h><w>mikerod</w>You typically can phrase the problem in a way that works with TMS. Often intermediate facts and accumulators in an aggregate rule can solve common situations. </z><z id="t1603201758108600" t="schmee what a good approach to ensure that a fact is only inserted once, kind of like a primary key in a DB?"><y>#</y><d>2020-10-20</d><h>13:49</h><w>schmee</w>what a good approach to ensure that a fact is only inserted once, kind of like a primary key in a DB?</z><z id="t1603201789109300" t="schmee I could have a rule where the RHS literally checks in a DB to see if the key is there, but it seems better to keep as much state as possible in the session?"><y>#</y><d>2020-10-20</d><h>13:49</h><w>schmee</w>I could have a rule where the RHS literally checks in a DB to see if the key is there, but it seems better to keep as much state as possible in the session?</z><z id="t1603387539119100" t="kvlt It seems kind of dangerous have side-effects inside of a rule."><y>#</y><d>2020-10-22</d><h>17:25</h><r>kvlt</r>It seems kind of dangerous have side-effects inside of a rule.</z><z id="t1603207750110300" t="nikola What would be the best practice to implement a decision table like that?"><y>#</y><d>2020-10-20</d><h>15:29</h><w>nikola</w>What would be the best practice to implement a decision table like that?</z><z id="t1603207905112100" t="nikola At my team a couple of product specialists use Excel for logic like that and I was wondering if I can somehow turn them into Clara rules and use it to make decisions. Has anyone have done something similar in the past?"><y>#</y><d>2020-10-20</d><h>15:31</h><w>nikola</w>At my team a couple of product specialists use Excel for logic like that and I was wondering if I can somehow turn them into Clara rules and use it to make decisions. Has anyone have done something similar in the past?</z><z id="t1603210805112600" t="mikerod @schmee Use an accumulator for the fact you actually want 1 of"><y>#</y><d>2020-10-20</d><h>16:20</h><w>mikerod</w>@schmee Use an accumulator for the fact you actually want 1 of</z><z id="t1603210810112800" t="mikerod if you have rules that may produce multiples"><y>#</y><d>2020-10-20</d><h>16:20</h><w>mikerod</w>if you have rules that may produce multiples</z><z id="t1603210817113100" t="mikerod make an intermediate fact type to represent the multiple"><y>#</y><d>2020-10-20</d><h>16:20</h><w>mikerod</w>make an intermediate fact type to represent the multiple</z><z id="t1603210826113400" t="mikerod then a single acumulator to aggregate it “down to 1”"><y>#</y><d>2020-10-20</d><h>16:20</h><w>mikerod</w>then a single acumulator to aggregate it “down to 1”</z><z id="t1603210846113900" t="mikerod this aggregation rule is you explicitly choosing how you want to represent or handle multiple supporting matches"><y>#</y><d>2020-10-20</d><h>16:20</h><w>mikerod</w>this aggregation rule is you explicitly choosing how you want to represent or handle multiple supporting matches</z><z id="t1603210874114400" t="mikerod it’s not always obvious actually - if they happen to have different data associated with them them or something"><y>#</y><d>2020-10-20</d><h>16:21</h><w>mikerod</w>it’s not always obvious actually - if they happen to have different data associated with them them or something</z><z id="t1603210911114700" t="schmee gotcha, thanks for the tip!"><y>#</y><d>2020-10-20</d><h>16:21</h><w>schmee</w>gotcha, thanks for the tip!</z><z id="t1603210931115600" t="mikerod @nikola.kasev I haven’t attempted anything first-class with tables like that - but you could start by just trying to make rule to represent it and see what patterns may emerge"><y>#</y><d>2020-10-20</d><h>16:22</h><w>mikerod</w>@nikola.kasev I haven’t attempted anything first-class with tables like that - but you could start by just trying to make rule to represent it and see what patterns may emerge</z><z id="t1603210971116600" t="mikerod I know some traditional rete-based engines - like Drools on the JVM - had some spreadsheet-like decision table functionality built on top to capture the pattern - but underneath was stilll just plain rules"><y>#</y><d>2020-10-20</d><h>16:22</h><w>mikerod</w>I know some traditional rete-based engines - like Drools on the JVM - had some spreadsheet-like decision table functionality built on top to capture the pattern - but underneath was stilll just plain rules</z><z id="t1603725455123500" t="eraserhd @nikola.kasev I use tables a lot, and I&apos;m not sure of a general way to make them into rules (I would definitely be curious about such a thing!), but I have at least one example I can think of: https://gist.github.com/eraserhd/a60250281e9d47743e9021ccd1337bcaa"><y>#</y><d>2020-10-26</d><h>15:17</h><w>eraserhd</w>@nikola.kasev I use tables a lot, and I&apos;m not sure of a general way to make them into rules (I would definitely be curious about such a thing!), but I have at least one example I can think of: <a href="https://gist.github.com/eraserhd/a60250281e9d47743e9021ccd1337bcaa" target="_blank">https://gist.github.com/eraserhd/a60250281e9d47743e9021ccd1337bcaa</a></z><z id="t1604574283130000" t="nikola @U0ECYL0ET, can you check the link?"><y>#</y><d>2020-11-05</d><h>11:04</h><r>nikola</r>@U0ECYL0ET, can you check the link?</z><z id="t1603725517123900" t="eraserhd I&apos;ve also used macros to make different shapes of data into Clara rules."><y>#</y><d>2020-10-26</d><h>15:18</h><w>eraserhd</w>I&apos;ve also used macros to make different shapes of data into Clara rules.</z><z id="t1603731605124400" t="mikerod https://github.com/cerner/clara-site/issues/34 @wparker did log an issue to document better the rules-as-data model"><y>#</y><d>2020-10-26</d><h>17:00</h><w>mikerod</w><a href="https://github.com/cerner/clara-site/issues/34" target="_blank">https://github.com/cerner/clara-site/issues/34</a> @wparker did log an issue to document better the rules-as-data model</z><z id="t1604275991126000" t="panda hi, i get this issue on compiling a rules namespace. could anyone help me understand what’s wrong with my bindings? Malformed variable binding for #{?contract-provider ?claim-provider}. No associated value. (defrule associated-contracts [:contract (= ?contract this)] [:contract (= ?contract-provider (:subject ?contract))] [:claim (= ?claim this)] [:claim (= ?claim-provider (-&gt; ?claim :billing-provider :identifier :value))] [:associated? (= ?claim-provider ?contract-provider)] =&gt; (insert! {:resource-type :associated-contract :claim ?claim :contract ?contract})) "><y>#</y><d>2020-11-02</d><h>00:13</h><w>panda</w>hi, i get this issue on compiling a rules namespace. could anyone help me understand what’s wrong with my bindings?
<pre>Malformed variable binding for #{?contract-provider ?claim-provider}. No associated value.
(defrule associated-contracts
  [:contract (= ?contract this)]
  [:contract (= ?contract-provider (:subject ?contract))]
  [:claim (= ?claim this)]
  [:claim (= ?claim-provider (-&gt; ?claim
                                  :billing-provider
                                  :identifier
                                  :value))]
  [:associated? (= ?claim-provider ?contract-provider)]
  =&gt;
  (insert! {:resource-type :associated-contract
            :claim ?claim
            :contract ?contract}))</pre>
</z><z id="t1604276068126100" t="panda i’m using fact-type functions instead of clojure records but i’m having trouble figuring out what are the right patterns"><y>#</y><d>2020-11-02</d><h>00:14</h><r>panda</r>i’m using fact-type functions instead of clojure records but i’m having trouble figuring out what are the right patterns</z><z id="t1604276083126300" t="panda in this case i want to bind the entire object to either ?claim or ?contract"><y>#</y><d>2020-11-02</d><h>00:14</h><r>panda</r>in this case i want to bind the entire object to either ?claim or ?contract</z><z id="t1604276104126500" t="panda and i also want to bind nested variables in that map"><y>#</y><d>2020-11-02</d><h>00:15</h><r>panda</r>and i also want to bind nested variables in that map</z><z id="t1604276400126700" t="ethanc I don&apos;t have repl open currently, but it looks like this might be because of the multiple conditions with similar fact types. rather than 2 conditions to bind contract and claim, i would assume that you might actually want a single condition for each. Something like: (defrule associated-contracts [:contract (= ?contract this) (= ?contract-provider (:subject this))] [:claim (= ?claim this) (= ?claim-provider (-&gt; this :billing-provider :identifier :value))] [:associated? (= ?claim-provider ?contract-provider)] =&gt; (insert! {:resource-type :associated-contract :claim ?claim :contract ?contract}))"><y>#</y><d>2020-11-02</d><h>00:20</h><r>ethanc</r>I don&apos;t have repl open currently, but it looks like this might be because of the multiple conditions with similar fact types.

rather than 2 conditions to bind contract and claim, i would assume that you might actually want a single condition for each. Something like:

<pre>(defrule associated-contracts
  [:contract 
(= ?contract this)
(= ?contract-provider (:subject this))]
  [:claim 
 (= ?claim this)
(= ?claim-provider (-&gt; this
                                  :billing-provider
                                  :identifier
                                  :value))]
  [:associated? (= ?claim-provider ?contract-provider)]
  =&gt;
  (insert! {:resource-type :associated-contract
            :claim ?claim
            :contract ?contract}))</pre></z><z id="t1604276648127000" t="panda oh i see — that’s definitely a lot cleaner 🙂 it’s still giving me that error though"><y>#</y><d>2020-11-02</d><h>00:24</h><r>panda</r>oh i see — that’s definitely a lot cleaner <b>🙂</b> it’s still giving me that error though</z><z id="t1604277061127200" t="ethanc hmmm, seems clara is incorrectly moving the joined conditional up in front of the binding itself. Specifially, [:associated? (= ?claim-provider ?contract-provider)]"><y>#</y><d>2020-11-02</d><h>00:31</h><r>ethanc</r>hmmm, seems clara is incorrectly moving the joined conditional up in front of the binding itself.

Specifially,
<pre>[:associated? (= ?claim-provider ?contract-provider)]</pre></z><z id="t1604277114127400" t="ethanc however this condition seems odd to me, you are looking to a fact in the session but not asserting anything based on this fact"><y>#</y><d>2020-11-02</d><h>00:31</h><r>ethanc</r>however this condition seems odd to me, you are looking to a fact in the session but not asserting anything based on this fact</z><z id="t1604277175127600" t="ethanc it almost seems as if that should be a test node: [:test (= ?claim-provider ?contract-provider)]"><y>#</y><d>2020-11-02</d><h>00:32</h><r>ethanc</r>it almost seems as if that should be a test node:
<pre>[:test (= ?claim-provider ?contract-provider)]</pre></z><z id="t1604277215127800" t="ethanc or potentially rolled up into the :claim condition itself"><y>#</y><d>2020-11-02</d><h>00:33</h><r>ethanc</r>or potentially rolled up into the <code>:claim</code> condition itself</z><z id="t1604277285128000" t="ethanc something like: (r/defrule associated-contracts [:contract (= ?contract this) (= ?contract-provider (:subject this))] [:claim (= ?claim this) (= (-&gt; this :billing-provider :identifier :value) ?contract-provider)] =&gt; (r/insert! {:resource-type :associated-contract :claim ?claim :contract ?contract}))"><y>#</y><d>2020-11-02</d><h>00:34</h><r>ethanc</r>something like:
<pre>(r/defrule associated-contracts
  [:contract
   (= ?contract this)
   (= ?contract-provider (:subject this))]
  [:claim
   (= ?claim this)
   (= (-&gt; this
          :billing-provider
          :identifier
          :value)
      ?contract-provider)]
  =&gt;
  (r/insert! {:resource-type :associated-contract
              :claim ?claim
              :contract ?contract}))</pre></z><z id="t1604277424128300" t="panda oh that’s totally it — i’m trying to set it up to have the simple predicate comparing facts and i didn’t realize that you had to name it :test in order for that to work…"><y>#</y><d>2020-11-02</d><h>00:37</h><r>panda</r>oh that’s totally it — i’m trying to set it up to have the simple predicate comparing facts and i didn’t realize that you had to name it <code>:test</code> in order for that to work…</z><z id="t1604277464128500" t="panda would the above example give you ones that matched or all combinations of facts?"><y>#</y><d>2020-11-02</d><h>00:37</h><r>panda</r>would the above example give you ones that matched or all combinations of facts?</z><z id="t1604277537128700" t="panda also how does querying for the fact-type-fn work? i tried the following: (defquery get-associated-contracts [] [?associated-contract &lt;- :associated-contract])"><y>#</y><d>2020-11-02</d><h>00:38</h><r>panda</r>also how does querying for the fact-type-fn work? i tried the following:
<pre>(defquery get-associated-contracts
  []
  [?associated-contract &lt;- :associated-contract])</pre></z><z id="t1604277551128900" t="ethanc in the example above, the RHS should execute and insert a fact for each combination of a Claim and Contract that share the same provider"><y>#</y><d>2020-11-02</d><h>00:39</h><r>ethanc</r>in the example above, the RHS should execute and insert a fact for each combination of a Claim and Contract that share the same provider</z><z id="t1604277828129100" t="panda oh i see"><y>#</y><d>2020-11-02</d><h>00:43</h><r>panda</r>oh i see</z><z id="t1604277835129300" t="panda that’s perfect! thank you so much!!"><y>#</y><d>2020-11-02</d><h>00:43</h><r>panda</r>that’s perfect! thank you so much!!</z><z id="t1604277841129500" t="ethanc Queries should work the same way while using/not using an overridden fact-type-fn. For example: (defn test-session [] (-&gt; (r/mk-session :fact-type-fn :resource-type) (r/insert {:resource-type :contract :subject :Thomas}) (r/insert {:resource-type :claim :billing-provider {:identifier {:value :Thomas}}}) (r/fire-rules) (r/query get-associated-contracts))) should net: ({:?associated-contract {:resource-type :associated-contract, :claim {:resource-type :claim, :billing-provider {:identifier {:value :Thomas}}}, :contract {:resource-type :contract, :subject :Thomas}}})"><y>#</y><d>2020-11-02</d><h>00:44</h><r>ethanc</r>Queries should work the same way while using/not using an overridden fact-type-fn. For example:

<pre>(defn test-session
  []
  (-&gt; (r/mk-session :fact-type-fn :resource-type)
      (r/insert {:resource-type :contract :subject :Thomas})
      (r/insert {:resource-type :claim :billing-provider {:identifier {:value :Thomas}}})
      (r/fire-rules)
      (r/query get-associated-contracts)))</pre>
should net:
<pre>({:?associated-contract {:resource-type :associated-contract,
                         :claim {:resource-type :claim, :billing-provider {:identifier {:value :Thomas}}},
                         :contract {:resource-type :contract, :subject :Thomas}}})</pre></z><z id="t1604277987129700" t="panda ooh i see — thank you! that makes sense"><y>#</y><d>2020-11-02</d><h>00:46</h><r>panda</r>ooh i see — thank you! that makes sense</z><z id="t1605009109131600" t="narkisr Hi Clara team, I&apos;m looking for a way to add/remove rules from a LocalSession, I&apos;m not seeing any matching function in http://www.clara-rules.org/apidocs/0.21.0/clojure/index.html any idea if this is possible? Thanks!"><y>#</y><d>2020-11-10</d><h>11:51</h><w>narkisr</w>Hi Clara team, I&apos;m looking for a way to add/remove rules from a LocalSession, I&apos;m not seeing any matching function in <a href="http://www.clara-rules.org/apidocs/0.21.0/clojure/index.html" target="_blank">http://www.clara-rules.org/apidocs/0.21.0/clojure/index.html</a> any idea if this is possible? Thanks!</z><z id="t1605009918133000" t="narkisr (BTW I don&apos;t expect to keep any facts within the session prior to manipulating it, I just want to be able to manipulate the rules prior to usage in some tests)"><y>#</y><d>2020-11-10</d><h>12:05</h><w>narkisr</w>(BTW I don&apos;t expect to keep any facts within the session prior to manipulating it, I just want to be able to manipulate the rules prior to usage in some tests)</z><z id="t1605021457135000" t="ethanc @narkisr, Clara does not currently support adding or removing productions from a compiled session. I believe that currently the only way to have a session with fewer rules would be to remake the session without providing the rules in question."><y>#</y><d>2020-11-10</d><h>15:17</h><w>ethanc</w>@narkisr, Clara does not currently support adding or removing productions from a compiled session. I believe that currently the only way to have a session with fewer rules would be to remake the session without providing the rules in question.</z><z id="t1605102658135600" t="narkisr Yeap thats the route iv went with (the session is stored in atom which makes it possible) thanks for help"><y>#</y><d>2020-11-11</d><h>13:50</h><w>narkisr</w>Yeap thats the route iv went with (the session is stored in atom which makes it possible) thanks for help</z><z id="t1605630974137100" t="kvlt I&apos;m looking at the rules-dsl and came across parse-query . The first argument is params . I was wondering what that construct is for?"><y>#</y><d>2020-11-17</d><h>16:36</h><w>kvlt</w>I&apos;m looking at the rules-dsl and came across <code>parse-query</code>. The first argument is <code>params</code> . I was wondering what that construct is for?</z><z id="t1605653050137600" t="mikerod @petr I believe the doc for query mentions how params work"><y>#</y><d>2020-11-17</d><h>22:44</h><w>mikerod</w>@petr I believe the doc for query mentions how params work</z><z id="t1605653053137800" t="mikerod Can’t look now"><y>#</y><d>2020-11-17</d><h>22:44</h><w>mikerod</w>Can’t look now</z></div></body>