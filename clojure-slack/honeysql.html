<!DOCTYPE html>
<head><title>honeysql</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 216px;} r {min-width: 248px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#honeysql</h2><pre><i>generated UTC: 2023-11-22 19:44</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/honeysql/2023-11-15">https://clojurians-log.clojureverse.org/honeysql/2023-11-15</a></i><i>
messages: 3134</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter2(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}
function textFilter(text) {
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (s){
            var sid = s.getAttribute("id");
            text.split(' ').forEach(function (t) {
                if (t !== '') {
                    filterTextStyle.innerHTML += "\ng#" + sid + " > z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
                }
            });
        })
    }
}
function textFilter3(text) {
    console.time("text search");
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        const re = new RegExp( text, "i");
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (w){
            var zs = w.getElementsByTagName ("z");
            var zsArr = Array.prototype.slice.call(zs);
            var ids = zsArr
                .filter(function (el) {
                    return !re.test(el.innerText);
                })
                .map(function (el){
                    return el.getAttribute("id");
                });
            if (ids) {
                filterTextStyle.innerHTML += "\n#" + ids.join(",#") + " {display: none; opacity: 0.6}";
            }
        })
    }
    console.timeEnd("text search");
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><g id="s0"><z id="t1591739719" t="avi 👋 hi all, hopefully quick question, about HoneySQL support for create table statements. My impression is that it’s currently either impossible; difficult+tricky+unsupported; and/or undocumented. Can anyone confirm which of those is the case, if any? Thanks!"><y>#</y><d>2020-06-09</d><h>21:55</h><w>avi</w><b>👋</b> hi all, hopefully quick question, about HoneySQL support for <code>create table</code> statements. My impression is that it’s currently either impossible; difficult+tricky+unsupported; and/or undocumented. Can anyone confirm which of those is the case, if any? Thanks!</z><z id="t1591740177" t="seancorfield [:attrs {:href &quot;/_/_/users/U69US348Z&quot;}] create table syntax varies wildly from database to database -- HoneySQL&apos;s goal is to support SQL-92 / portable SQL so it doesn&apos;t attempt to do any DDL stuff."><y>#</y><d>2020-06-09</d><h>22:02</h><w>seancorfield</w><a>@aviflax</a> <code>create table</code> syntax varies wildly from database to database -- HoneySQL&apos;s goal is to support SQL-92 / portable SQL so it doesn&apos;t attempt to do any DDL stuff.</z><z id="t1591740280" t="seancorfield FWIW, clojure.java.jdbc has some very basic support for creating the DDL for that, but I omitted it from next.jdbc because it really wasn&apos;t any better than just bashing strings together..."><y>#</y><d>2020-06-09</d><h>22:04</h><w>seancorfield</w>FWIW, <code>clojure.java.jdbc</code> has some very basic support for creating the DDL for that, but I omitted it from <code>next.jdbc</code> because it really wasn&apos;t any better than just bashing strings together...</z><z id="t1591740297" t="seancorfield https://clojure.github.io/java.jdbc/#clojure.java.jdbc/create-table-ddl"><y>#</y><d>2020-06-09</d><h>22:04</h><w>seancorfield</w><a href="https://clojure.github.io/java.jdbc/#clojure.java.jdbc/create-table-ddl" target="_blank">https://clojure.github.io/java.jdbc/#clojure.java.jdbc/create-table-ddl</a></z><z id="t1591740424" t="seancorfield So many column declarations require strings due to spaces or punctuation -- and all it does really is (clojure.string/join &quot; &quot; (map name col-spec)) on each column spec and then (clojure.string/join &quot;, &quot; cols) across the sequence of column descriptions..."><y>#</y><d>2020-06-09</d><h>22:07</h><w>seancorfield</w>So many column declarations require strings due to spaces or punctuation -- and all it does really is <code>(clojure.string/join &quot; &quot; (map name col-spec))</code> on each column spec and then <code>(clojure.string/join &quot;, &quot; cols)</code> across the sequence of column descriptions...</z><z id="t1591744061" t="Chris O’Donnell [:attrs {:href &quot;/_/_/users/U69US348Z&quot;}] if you&apos;re using postgres, https://github.com/nilenso/honeysql-postgres has them."><y>#</y><d>2020-06-09</d><h>23:07</h><w>Chris O’Donnell</w><a>@aviflax</a> if you&apos;re using postgres, <a href="https://github.com/nilenso/honeysql-postgres" target="_blank">https://github.com/nilenso/honeysql-postgres</a> has them.</z><z id="t1591744259" t="avi Thanks! I’m using SQLite tho."><y>#</y><d>2020-06-09</d><h>23:10</h><w>avi</w>Thanks! I’m using SQLite tho.</z><z id="t1591749347" t="Chris O’Donnell Ah well. If you&apos;re set on using honeysql for ddl, you could probably adapt the definitions from postgres."><y>#</y><d>2020-06-10</d><h>00:35</h><w>Chris O’Donnell</w>Ah well. If you&apos;re set on using honeysql for ddl, you could probably adapt the definitions from postgres.</z><z id="t1591749375" t="avi I’ll take a look. Thank you!"><y>#</y><d>2020-06-10</d><h>00:36</h><w>avi</w>I’ll take a look. Thank you!</z><z id="t1591749967" t="seancorfield [:attrs {:href &quot;/_/_/users/U69US348Z&quot;}] Outside of the tests in clojure.java.jdbc , I&apos;ve never used the DDL helpers -- they just don&apos;t add enough."><y>#</y><d>2020-06-10</d><h>00:46</h><w>seancorfield</w><a>@aviflax</a> Outside of the tests in <code>clojure.java.jdbc</code>, I&apos;ve never used the DDL helpers -- they just don&apos;t add enough.</z><z id="t1591752083" t="Chris O’Donnell I don&apos;t use them, either. I tend to put ddl in raw sql migration files."><y>#</y><d>2020-06-10</d><h>01:21</h><w>Chris O’Donnell</w>I don&apos;t use them, either. I tend to put ddl in raw sql migration files.</z><z id="t1591752387" t="seancorfield [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] Yeah, that&apos;s the route we&apos;ve gone at work, so it&apos;s easier to roll a database up for testing to a specific &quot;version&quot;."><y>#</y><d>2020-06-10</d><h>01:26</h><w>seancorfield</w><a>@codonnell</a> Yeah, that&apos;s the route we&apos;ve gone at work, so it&apos;s easier to roll a database up for testing to a specific &quot;version&quot;.</z><z id="t1591753393" t="avi That makes sense. Thanks! FWIW, I was just hoping to find some kind of “standardized” way to represent a create table statement as a data structure rather than as a string, because I am working on a function that will eventually return something that has generated create table statement in its metadata, and I want to be able to write equality checks in my tests without worrying about string formatting. I whipped this up on the fly, thinking this might work: [:create-table &quot;technologies&quot; &quot;name varchar(255) not null primary key&quot; &quot;links-main text&quot;] But my SQL is so rusty I don’t have much confidence in something so simple being actually viable. 😅"><y>#</y><d>2020-06-10</d><h>01:43</h><w>avi</w>That makes sense. Thanks!

FWIW, I was just hoping to find some kind of “standardized” way to represent a <code>create table</code> statement as a data structure rather than as a string, because I am working on a function that will eventually return something that has generated <code>create table</code> statement in its metadata, and I want to be able to write equality checks in my tests without worrying about string formatting.

I whipped this up on the fly, thinking this might work:

<pre>[:create-table
 &quot;technologies&quot;
 &quot;name varchar(255) not null primary key&quot;
 &quot;links-main text&quot;]</pre>
But my SQL is so rusty I don’t have much confidence in something so simple being actually viable. <b>😅</b></z><z id="t1591753536" t="seancorfield I would probably use a hash map: {:create-table :technologies :columns [&quot;name varchar(255) not null primary key&quot;, &quot;links_main text&quot;]}"><y>#</y><d>2020-06-10</d><h>01:45</h><w>seancorfield</w>I would probably use a hash map: <code>{:create-table :technologies :columns [&quot;name varchar(255) not null primary key&quot;, &quot;links_main text&quot;]}</code></z><z id="t1591753597" t="seancorfield then you can (clojure.string/join &quot;, &quot; ...) on the columns and then it&apos;s just (str &quot;CREATE TABLE&quot; (:create-table data) &quot;(&quot; column-string &quot;)&quot;)"><y>#</y><d>2020-06-10</d><h>01:46</h><w>seancorfield</w>then you can <code>(clojure.string/join &quot;, &quot; ...)</code> on the columns and then it&apos;s just <code>(str &quot;CREATE TABLE&quot; (:create-table data) &quot;(&quot; column-string &quot;)&quot;)</code></z><z id="t1591753649" t="avi I like that. More forwards-compatible. Thanks!"><y>#</y><d>2020-06-10</d><h>01:47</h><w>avi</w>I like that. More forwards-compatible. Thanks!</z><z id="t1591798465" t="kwrooijen Hello. I&apos;m trying to create a new row, and return the generated primary key (or complete row). (-&gt; (insert-into :person) (values [{:name &quot;foo&quot;}]) (sql/format) (-&gt;&gt; (jdbc/execute! *database*))) This inserts the row as expected, but returns (1) instead of the new row. Is there any way I can get the primary key? I also saw that there was a jdbc/insert! , but this takes a map instead of an SQL string. Meaning I can&apos;t use honeysql with this. Any tips?"><y>#</y><d>2020-06-10</d><h>14:14</h><w>kwrooijen</w>Hello. I&apos;m trying to create a new row, and return the generated primary key (or complete row).
<pre>(-&gt; (insert-into :person)
    (values [{:name &quot;foo&quot;}])
    (sql/format)
    (-&gt;&gt; (jdbc/execute! *database*)))</pre>
This inserts the row as expected, but returns <code>(1)</code>  instead of the new row. Is there any way I can get the primary key? I also saw that there was a <code>jdbc/insert!</code> , but this takes a map instead of an SQL string. Meaning I can&apos;t use honeysql with this. Any tips?</z><z id="t1591804223" t="gon you can use &apos;returning id&apos; clause at the end of the insert if your db implements it"><y>#</y><d>2020-06-10</d><h>15:50</h><w>gon</w>you can use &apos;returning id&apos; clause at the end of the insert if your db implements it</z><z id="t1591806465" t="kwrooijen Ah ok, I also need to use jdbc/query instead of jdbc/execute! if I want it to return data"><y>#</y><d>2020-06-10</d><h>16:27</h><w>kwrooijen</w>Ah ok, I also need to use <code>jdbc/query</code> instead of <code>jdbc/execute!</code> if I want it to return data</z><z id="t1591809495" t="seancorfield Use :return-keys true"><y>#</y><d>2020-06-10</d><h>17:18</h><w>seancorfield</w>Use <code>:return-keys true</code></z><z id="t1591809518" t="seancorfield (As an option passed to execute!"><y>#</y><d>2020-06-10</d><h>17:18</h><w>seancorfield</w>(As an option passed to <code>execute!</code></z><z id="t1591892780" t="kwrooijen Thanks! I tried next-jdbc and that seems to work."><y>#</y><d>2020-06-11</d><h>16:26</h><w>kwrooijen</w>Thanks! I tried next-jdbc and that seems to work.</z><z id="t1591895067" t="seancorfield Ah, you were using clojure.java.jdbc ? Yeah, that&apos;s a bit fussy about which functions you use since they nearly all invoke different JDBC methods under the hood. next.jdbc deliberately simplifies that, so everything goes through .execute() under the hood, which means execute! is much more broadly useful (and next.jdbc.sql/query is just an alias for next.jdbc/execute! really)."><y>#</y><d>2020-06-11</d><h>17:04</h><w>seancorfield</w>Ah, you were using <code>clojure.java.jdbc</code>? Yeah, that&apos;s a bit fussy about which functions you use since they nearly all invoke different JDBC methods under the hood. <code>next.jdbc</code> deliberately simplifies that, so everything goes through <code>.execute()</code> under the hood, which means <code>execute!</code> is much more broadly useful (and <code>next.jdbc.sql/query</code> is just an alias for <code>next.jdbc/execute!</code> really).</z><z id="t1591899215" t="kwrooijen Yeah I&apos;m exploring my options with SQL (and other Clojure libs). At work we use raw jdbc and HugSQL, but I&apos;d like to use something other than that for my personal project. I&apos;m really impressed with HoneySQL though 🙂"><y>#</y><d>2020-06-11</d><h>18:13</h><w>kwrooijen</w>Yeah I&apos;m exploring my options with SQL (and other Clojure libs). At work we use raw jdbc and HugSQL, but I&apos;d like to use something other than that for my personal project. I&apos;m really impressed with HoneySQL though <b>🙂</b></z><z id="t1591899248" t="kwrooijen next.jdbc sounds like a good option to use from now on"><y>#</y><d>2020-06-11</d><h>18:14</h><w>kwrooijen</w>next.jdbc sounds like a good option to use from now on</z><z id="t1591901407" t="seancorfield HugSQL has built-in support for next.jdbc via an adapter. next.jdbc &apos;s docs also have a Quick Start guide for using it with HugSQL."><y>#</y><d>2020-06-11</d><h>18:50</h><w>seancorfield</w>HugSQL has built-in support for <code>next.jdbc</code> via an adapter. <code>next.jdbc</code>&apos;s docs also have a Quick Start guide for using it with HugSQL.</z><z id="t1592059961" t="wombawomba How can I build a INSERT INTO foo SELECT ... FROM ... statement with HoneySQL?"><y>#</y><d>2020-06-13</d><h>14:52</h><w>wombawomba</w>How can I build a <code>INSERT INTO foo SELECT ... FROM ...</code> statement with HoneySQL?</z><z id="t1592061286" t="dharrigan (-&gt; (insert-into [:foo (-&gt; (select :*) (from :bar))]) sql/format) [&quot;INSERT INTO foo SELECT * FROM bar&quot;]"><y>#</y><d>2020-06-13</d><h>15:14</h><w>dharrigan</w><pre>(-&gt; (insert-into [:foo (-&gt; (select :*) (from :bar))]) sql/format)
[&quot;INSERT INTO foo SELECT * FROM bar&quot;]</pre></z><z id="t1592061408" t="wombawomba [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] thx!"><y>#</y><d>2020-06-13</d><h>15:16</h><w>wombawomba</w><a>@dharrigan</a> thx!</z><z id="t1592077365" t="seancorfield Cross-posting from #sql for anyone who is here but not there..."><y>#</y><d>2020-06-13</d><h>19:42</h><w>seancorfield</w>Cross-posting from #sql for anyone who is here but not there...</z><z id="t1592078629" t="kwrooijen Cool!"><y>#</y><d>2020-06-13</d><h>20:03</h><w>kwrooijen</w>Cool!</z><z id="t1592132067" t="borkdude Now released as 0.1.2"><y>#</y><d>2020-06-14</d><h>10:54</h><w>borkdude</w>Now released as 0.1.2</z><z id="t1596916392" t="viesti Hmm, is there a way to use CTE and UNION together, so that I could refer to the CTEs from the UNION clauses?"><y>#</y><d>2020-08-08</d><h>19:53</h><w>viesti</w>Hmm, is there a way to use CTE and UNION together, so that I could refer to the CTEs from the UNION clauses?</z><z id="t1596916626" t="viesti something like this in sql: WITH cte AS ( SELECT * FROM shared ) SELECT cte.id, f.x FROM cte LEFT JOIN foo f ON f.id = c.id UNION SELECT cte.id, b.x FROM cte LEFT JOIN bar b ON b.id = c.id;"><y>#</y><d>2020-08-08</d><h>19:57</h><w>viesti</w>something like this in sql:
<pre>WITH cte AS (
  SELECT
    *
  FROM
    shared
)
SELECT
  cte.id,
  f.x
FROM
  cte
  LEFT JOIN foo f ON f.id = c.id
UNION
SELECT
  cte.id,
  b.x
FROM
  cte
  LEFT JOIN bar b ON b.id = c.id;</pre></z><z id="t1596917240" t="viesti ah, hmm, just using a map {:with ... :union [...]} and referring to the cte&apos;s in the :union by name seems to work"><y>#</y><d>2020-08-08</d><h>20:07</h><w>viesti</w>ah, hmm, just using a map <code>{:with ... :union [...]}</code> and referring to the cte&apos;s in the <code>:union</code> by name seems to work</z><z id="t1596917262" t="viesti the dsl tripped me off a bit"><y>#</y><d>2020-08-08</d><h>20:07</h><w>viesti</w>the dsl tripped me off a bit</z><z id="t1611160753" t="dharrigan Can honeysql do multiple or&apos;s if a vector is passed in, [&quot;A&quot; &quot;B&quot;] -&gt; select foo from bar where baz = &quot;A&quot; or baz = &quot;b&quot; ?"><y>#</y><d>2021-01-20</d><h>16:39</h><w>dharrigan</w>Can honeysql do multiple or&apos;s if a vector is passed in, <code>[&quot;A&quot; &quot;B&quot;]</code> -&gt; <code>select foo from bar where baz = &quot;A&quot; or baz = &quot;b&quot;</code>?</z><z id="t1611165609" t="seancorfield Why not [:in :baz [&quot;A&quot; &quot;B&quot;]]"><y>#</y><d>2021-01-20</d><h>18:00</h><w>seancorfield</w>Why not <code>[:in :baz [&quot;A&quot; &quot;B&quot;]]</code></z><z id="t1611169237" t="dharrigan good idea!"><y>#</y><d>2021-01-20</d><h>19:00</h><w>dharrigan</w>good idea!</z><z id="t1611199524" t="Nassin What would be the structure for from weather w, cities c .... ?"><y>#</y><d>2021-01-21</d><h>03:25</h><w>Nassin</w>What would be the structure for <code>from weather w, cities c ....</code>?</z><z id="t1611200066" t="seancorfield [:attrs {:href &quot;/_/_/users/U011VD1RDQT&quot;}] are you using the helper functions or just the raw data structure?"><y>#</y><d>2021-01-21</d><h>03:34</h><w>seancorfield</w><a>@kaxaw75836</a> are you using the helper functions or just the raw data structure?</z><z id="t1611200151" t="Nassin raw"><y>#</y><d>2021-01-21</d><h>03:35</h><w>Nassin</w>raw</z><z id="t1611200214" t="seancorfield In general with HoneySQL, if :foo is a SQL entity then [:foo :bar] is a SQL entity with an alias."><y>#</y><d>2021-01-21</d><h>03:36</h><w>seancorfield</w>In general with HoneySQL, if <code>:foo</code> is a SQL entity then <code>[:foo :bar]</code> is a SQL entity with an alias.</z><z id="t1611200374" t="Nassin :from [:foo :bar :baz :bat] produces from foo, bar, baz, bat"><y>#</y><d>2021-01-21</d><h>03:39</h><w>Nassin</w><code>:from [:foo :bar :baz :bat]</code> produces <code>from foo, bar, baz, bat</code></z><z id="t1611200455" t="Nassin ah"><y>#</y><d>2021-01-21</d><h>03:40</h><w>Nassin</w>ah</z><z id="t1611200519" t="Nassin I see what you mean [[:foo :bar] [:baz :bat]] thx!"><y>#</y><d>2021-01-21</d><h>03:41</h><w>Nassin</w>I see what you mean <code>[[:foo :bar] [:baz :bat]]</code>  thx!</z><z id="t1611200666" t="Nassin missed it cause I was ignoring the &quot;vanilla helpers&quot; in the docs"><y>#</y><d>2021-01-21</d><h>03:44</h><w>Nassin</w>missed it cause I was ignoring the &quot;vanilla helpers&quot; in the docs</z><z id="t1611201084" t="seancorfield I prefer the helpers. I wish more people used them."><y>#</y><d>2021-01-21</d><h>03:51</h><w>seancorfield</w>I prefer the helpers. I wish more people used them.</z><z id="t1611201109" t="seancorfield It&apos;s really hard to get the raw data structures right. The helpers... well... help."><y>#</y><d>2021-01-21</d><h>03:51</h><w>seancorfield</w>It&apos;s really hard to get the raw data structures right. The helpers... well... help.</z><z id="t1611202855" t="Nassin noted, you use it for all your queries or just dynamic ones?"><y>#</y><d>2021-01-21</d><h>04:20</h><w>Nassin</w>noted, you use it for all your queries or just dynamic ones?</z><z id="t1611203162" t="seancorfield Just dynamic ones. We don&apos;t use HoneySQL for static queries. And we only use the helpers, not the raw data structure. And we&apos;re heavy users of HoneySQL -- one of my colleagues did a Clojure/West talk about it in 2015 (I think)."><y>#</y><d>2021-01-21</d><h>04:26</h><w>seancorfield</w>Just dynamic ones. We don&apos;t use HoneySQL for static queries. And we only use the helpers, not the raw data structure. And we&apos;re heavy users of HoneySQL -- one of my colleagues did a Clojure/West talk about it in 2015 (I think).</z><z id="t1611204676" t="markaddleman fwiw, I code honey using the data structures directly. the only real problem is that, when i get something wrong, the resulting error message isn&apos;t terribly helpful but i can generally visually spot the problem in a minute or two of examining the data structure. i&apos;m looking forward to honey 2.0 and spec. not only do i expect the error messages to get better, i think spec will make it easier to programmaticly manipulate queries."><y>#</y><d>2021-01-21</d><h>04:51</h><w>markaddleman</w>fwiw, I code honey using the data structures directly.  the only real problem is that, when i get something wrong, the resulting error message isn&apos;t terribly helpful but i can generally visually spot the problem in a minute or two of examining the data structure.  i&apos;m looking forward to honey 2.0 and spec.  not only do i expect the error messages to get better, i think spec will make it easier to programmaticly manipulate queries.</z><z id="t1611672442" t="jimi hendrix Is there any support for postgres&apos;s CTE?"><y>#</y><d>2021-01-26</d><h>14:47</h><w>jimi hendrix</w>Is there any support for postgres&apos;s CTE?</z><z id="t1611681771" t="markaddleman fwiw, I have extended honeysql to support BigQuery CTEs (which are similar to Postgres CTEs). It was pretty easy"><y>#</y><d>2021-01-26</d><h>17:22</h><r>markaddleman</r>fwiw, I have extended honeysql to support BigQuery CTEs (which are similar to Postgres CTEs).  It was pretty easy</z><z id="t1611681778" t="markaddleman (defmethod fmt/format-clause ::with [[_ ctes] _] (str &quot;WITH &quot; (fmt/comma-join (map (fn [[cte alias]] (try (str (fmt/to-sql alias) &quot; AS &quot; (fmt/to-sql cte)) (catch Exception e (throw (ex-info &quot;Unable to format&quot; {:alias alias :cte cte} e))))) ctes))))"><y>#</y><d>2021-01-26</d><h>17:22</h><r>markaddleman</r><pre>(defmethod fmt/format-clause ::with [[_ ctes] _]
  (str &quot;WITH &quot; (fmt/comma-join (map (fn [[cte alias]]
                                      (try (str (fmt/to-sql alias) &quot; AS &quot; (fmt/to-sql cte))
                                           (catch Exception e
                                             (throw (ex-info &quot;Unable to format&quot;
                                                             {:alias alias :cte cte}
                                                             e)))))
                                    ctes))))</pre></z><z id="t1611685027" t="seancorfield FYI with will be built-in with v2."><y>#</y><d>2021-01-26</d><h>18:17</h><r>seancorfield</r>FYI <code>with</code> will be built-in with v2.</z><z id="t1611674417" t="orestis Yes, via “with”"><y>#</y><d>2021-01-26</d><h>15:20</h><w>orestis</w>Yes, via “with”</z><z id="t1611674454" t="orestis Iirc the merge helper is missing "><y>#</y><d>2021-01-26</d><h>15:20</h><w>orestis</w>Iirc the merge helper is missing </z><z id="t1611674468" t="orestis AFK right now so can’t help with sample code"><y>#</y><d>2021-01-26</d><h>15:21</h><w>orestis</w>AFK right now so can’t help with sample code</z><z id="t1611682549" t="athomasoriginal [:attrs {:href &quot;/_/_/users/U01L96YC03T&quot;}] :with and :with-recurive are supported by HSQL. You can see usage https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/test/honeysql/format_test.cljc#L62"><y>#</y><d>2021-01-26</d><h>17:35</h><w>athomasoriginal</w><a>@nasikebuli156</a> <code>:with</code> and <code>:with-recurive</code> are supported by HSQL.  You can see usage <a href="https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/test/honeysql/format_test.cljc#L62" target="_blank">https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/test/honeysql/format_test.cljc#L62</a></z><z id="t1611682650" t="athomasoriginal And then I usually take a look at https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/src/honeysql/format.cljc#L222 when I need to remind myself of some of the options. I also build the HSQL manually and without helpers…a habit I would like to break because I imagine that they are actually “helpful”"><y>#</y><d>2021-01-26</d><h>17:37</h><w>athomasoriginal</w>And then I usually take a look at <a href="https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/src/honeysql/format.cljc#L222" target="_blank">https://github.com/seancorfield/honeysql/blob/5e087617159fa61a15363bf76ad3d6598dd7d30f/src/honeysql/format.cljc#L222</a> when I need to remind myself of some of the options.  I also build the HSQL manually and without helpers…a habit I would like to break because I imagine that they are actually “helpful”</z><z id="t1611682884" t="Janne Sauvala HoneySql 2 looks promising. What is the state of it? Is it too early to start using it?"><y>#</y><d>2021-01-26</d><h>17:41</h><w>Janne Sauvala</w>HoneySql 2 looks promising. What is the state of it? Is it too early to start using it?</z><z id="t1611683050" t="athomasoriginal [:attrs {:href &quot;/_/_/users/UJZ6S8YR2&quot;}] agreed. I’m not speaking for Sean, but TMK it’s still in an “evolving” state."><y>#</y><d>2021-01-26</d><h>17:44</h><w>athomasoriginal</w><a>@janne.sauvala</a> agreed.  I’m not speaking for Sean, but TMK it’s still in an “evolving” state.</z><z id="t1611684812" t="seancorfield [:attrs {:href &quot;/_/_/users/UJZ6S8YR2&quot;}] v2 is very much in &quot;hammock mode&quot; right now. The v2 branch mostly works but there are some features from v1 not implemented yet -- still figuring out the best approach. Several features will behave differently but v2 uses different namespaces (and will have a different Maven coordinate: seancorfield/honeysql ) so you can load both v1 and v2 into your project and migrate piecemeal."><y>#</y><d>2021-01-26</d><h>18:13</h><w>seancorfield</w><a>@janne.sauvala</a> v2 is very much in &quot;hammock mode&quot; right now. The v2 branch mostly works but there are some features from v1 not implemented yet -- still figuring out the best approach. Several features will behave differently but v2 uses different namespaces (and will have a different Maven coordinate: <code>seancorfield/honeysql</code>) so you can load both v1 and v2 into your project and migrate piecemeal.</z><z id="t1611744089" t="Janne Sauvala Good to know I can use them at the same time - I might go that route if I feel that v2 seems to be more superior 🙂"><y>#</y><d>2021-01-27</d><h>10:41</h><r>Janne Sauvala</r>Good to know I can use them at the same time - I might go that route if I feel that v2 seems to be more superior <b>🙂</b></z><z id="t1611770576" t="seancorfield I&apos;m hoping to have something &quot;usable&quot; next week. I&apos;m taking four days off to work on OSS (Thu-Tue) and I plan to deal with the parameterization issue which is the current blocker as far as I&apos;m concerned. If I can get that working this weekend and get all the tests to pass, then I&apos;ll probably ask folks to test it -- if I can also get enough documentation in place."><y>#</y><d>2021-01-27</d><h>18:02</h><r>seancorfield</r>I&apos;m hoping to have something &quot;usable&quot; next week. I&apos;m taking four days off to work on OSS (Thu-Tue) and I plan to deal with the parameterization issue which is the current blocker as far as I&apos;m concerned. If I can get that working this weekend and get all the tests to pass, then I&apos;ll probably ask folks to test it -- if I can also get enough documentation in place.</z><z id="t1611684872" t="seancorfield I don&apos;t consider it even &quot;alpha&quot; yet and I&apos;m not yet trying to use it at work 🙂"><y>#</y><d>2021-01-26</d><h>18:14</h><w>seancorfield</w>I don&apos;t consider it even &quot;alpha&quot; yet and I&apos;m not yet trying to use it at work <b>🙂</b></z><z id="t1611744272" t="Janne Sauvala I think Clojure has spoiled me with the definition of “alpha” in our community. Usually alpha versions of any Clojure lib works fine but in any other language those alpha versions barely even compiles 😄"><y>#</y><d>2021-01-27</d><h>10:44</h><r>Janne Sauvala</r>I think Clojure has spoiled me with the definition of “alpha” in our community. Usually alpha versions of any Clojure lib works fine but in any other language those alpha versions barely even compiles <b>😄</b></z><z id="t1611684976" t="seancorfield I&apos;m taking a few days off at the end of this week (Thursday through Tuesday) and plan to spend quite a bit of time on OSS projects -- which is possible because of GitHub sponsorship! I&apos;ll probably tackle stuff in the order: next.jdbc , depstar , clj-new , and then HoneySQL v2 (but those first three projects only need a few hours of time on them)."><y>#</y><d>2021-01-26</d><h>18:16</h><w>seancorfield</w>I&apos;m taking a few days off at the end of this week (Thursday through Tuesday) and plan to spend quite a bit of time on OSS projects -- which is possible because of GitHub sponsorship! I&apos;ll probably tackle stuff in the order: <code>next.jdbc</code>, <code>depstar</code>, <code>clj-new</code>, and then HoneySQL v2 (but those first three projects only need a few hours of time on them).</z><z id="t1611685027" t="seancorfield FYI with will be built-in with v2."><y>#</y><d>2021-01-26</d><h>18:17</h><w>seancorfield</w>FYI <code>with</code> will be built-in with v2.</z><z id="t1611705841" t="jimi hendrix Thanks guys!"><y>#</y><d>2021-01-27</d><h>00:04</h><w>jimi hendrix</w>Thanks guys!</z><z id="t1611705853" t="jimi hendrix I feel like clojure&apos;s community is very helpful even for the beginner"><y>#</y><d>2021-01-27</d><h>00:04</h><w>jimi hendrix</w>I feel like clojure&apos;s community is very helpful even for the beginner</z><z id="t1611726710" t="kitallis [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Have you considered taking a: everything is a relation approach for a future honeysql version? rather than generating SQL queries, build them as composable relational algebra… or is that something out of scope for this project?"><y>#</y><d>2021-01-27</d><h>05:51</h><w>kitallis</w><a>@seancorfield</a> Have you considered taking a: everything is a relation approach for a future honeysql version? rather than generating SQL queries, build them as composable relational algebra… or is that something out of scope for this project?</z><z id="t1611770707" t="seancorfield [:attrs {:href &quot;/_/_/users/U055GPYR1&quot;}] Could you give an example of what you mean? HoneySQL already allows you to compose partial queries -- and we rely on that at work (one of my former colleagues gave a talk about it at Clojure/West one year)."><y>#</y><d>2021-01-27</d><h>18:05</h><w>seancorfield</w><a>@kitallis</a> Could you give an example of what you mean? HoneySQL already allows you to compose partial queries -- and we rely on that at work (one of my former colleagues gave a talk about it at Clojure/West one year).</z><z id="t1611837677" t="Yang Xu HI, I want to know whether exists a library of Java that similar to HoneySQL?"><y>#</y><d>2021-01-28</d><h>12:41</h><w>Yang Xu</w>HI, I want to know whether exists a library of Java that similar to HoneySQL?</z><z id="t1611839670" t="dharrigan Perhaps you may want to consider JOOQ"><y>#</y><d>2021-01-28</d><h>13:14</h><w>dharrigan</w>Perhaps you may want to consider JOOQ</z><z id="t1611839691" t="dharrigan I use JOOQ in Kotlin and Java, works really well. It&apos;s not quite like HoneySQL, but I would use JOOQ over JPA anyday."><y>#</y><d>2021-01-28</d><h>13:14</h><w>dharrigan</w>I use JOOQ in Kotlin and Java, works really well. It&apos;s not quite like HoneySQL, but I would use JOOQ over JPA anyday.</z><z id="t1611841205" t="Yang Xu Thank you, let me look."><y>#</y><d>2021-01-28</d><h>13:40</h><w>Yang Xu</w>Thank you, let me look.</z><z id="t1612139055" t="seancorfield Major milestone: HoneySQL v2 repo now passes all the tests (for the first time!). The next two days will be about documentation!"><y>#</y><d>2021-02-01</d><h>00:24</h><w>seancorfield</w>Major milestone: HoneySQL v2 repo now passes all the tests (for the first time!). The next two days will be about documentation!</z><z id="t1612139092" t="seancorfield I plan to incorporate a bunch of new tests from a recent v1 PR into the v2 test base as well."><y>#</y><d>2021-02-01</d><h>00:24</h><w>seancorfield</w>I plan to incorporate a bunch of new tests from a recent v1 PR into the v2 test base as well.</z><z id="t1612139120" t="seancorfield I hope to cut a v2 alpha by the end of Tuesday."><y>#</y><d>2021-02-01</d><h>00:25</h><w>seancorfield</w>I hope to cut a v2 alpha by the end of Tuesday.</z><z id="t1612139628" t="seancorfield (I also need to substantially clean up the code 🙂 but that will be an ongoing process now that I have a passing test suite)"><y>#</y><d>2021-02-01</d><h>00:33</h><w>seancorfield</w>(I also need to substantially clean up the code <b>🙂</b> but that will be an ongoing process now that I have a passing test suite)</z><z id="t1612197826" t="Chris O’Donnell Hey [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] , just ran into surprising behavior with the way honeysql formats :values clauses. We were inserting a collection of maps that didn&apos;t all have the same keys and discovered after a period of confusion that honeysql picks the columns based off the first map in the :values vector. Would you be amenable to changing this so that honeysql picks the columns to be the union of all keys present in :values maps? Happy to provide a PR."><y>#</y><d>2021-02-01</d><h>16:43</h><w>Chris O’Donnell</w>Hey <a>@seancorfield</a>, just ran into surprising behavior with the way honeysql formats <code>:values</code> clauses. We were inserting a collection of maps that didn&apos;t all have the same keys and discovered after a period of confusion that honeysql picks the columns based off the first map in the <code>:values</code> vector. Would you be amenable to changing this so that honeysql picks the columns to be the union of all keys present in <code>:values</code> maps? Happy to provide a PR.</z><z id="t1612198727" t="seancorfield [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] I&apos;ll fix that for v2 but not for v1 at this point. It&apos;s the same behavior as clojure.pprint/print-table BTW."><y>#</y><d>2021-02-01</d><h>16:58</h><w>seancorfield</w><a>@codonnell</a> I&apos;ll fix that for v2 but not for v1 at this point. It&apos;s the same behavior as <code>clojure.pprint/print-table</code> BTW.</z><z id="t1612198798" t="seancorfield (I don&apos;t think it&apos;s a bug but I agree it could be a bit surprising -- feel free to open an issue on GH so I don&apos;t forget)"><y>#</y><d>2021-02-01</d><h>16:59</h><w>seancorfield</w>(I don&apos;t think it&apos;s a bug but I agree it could be a bit surprising -- feel free to open an issue on GH so I don&apos;t forget)</z><z id="t1612199025" t="Chris O’Donnell Will do, thanks."><y>#</y><d>2021-02-01</d><h>17:03</h><w>Chris O’Donnell</w>Will do, thanks.</z><z id="t1612199218" t="Chris O’Donnell https://github.com/seancorfield/honeysql/issues/291"><y>#</y><d>2021-02-01</d><h>17:06</h><w>Chris O’Donnell</w><a href="https://github.com/seancorfield/honeysql/issues/291" target="_blank">https://github.com/seancorfield/honeysql/issues/291</a></z><z id="t1612201454" t="seancorfield Thanks! I&apos;ll probably work on that for v2 later today."><y>#</y><d>2021-02-01</d><h>17:44</h><w>seancorfield</w>Thanks! I&apos;ll probably work on that for v2 later today.</z><z id="t1612201524" t="dharrigan Just a shout out for a big thanks for [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] for doing the work for honeysql v2. Looking forward to it! 🙂"><y>#</y><d>2021-02-01</d><h>17:45</h><w>dharrigan</w>Just a shout out for a big thanks for <a>@seancorfield</a> for doing the work for honeysql v2. Looking forward to it! <b>🙂</b></z><z id="t1612205180" t="seancorfield [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] That is fixed on the v2 branch."><y>#</y><d>2021-02-01</d><h>18:46</h><w>seancorfield</w><a>@codonnell</a> That is fixed on the v2 branch.</z><z id="t1612205352" t="Chris O’Donnell Thanks a bunch!"><y>#</y><d>2021-02-01</d><h>18:49</h><w>Chris O’Donnell</w>Thanks a bunch!</z><z id="t1612214984" t="seancorfield [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] BTW, the 1.x readme says &quot;the first map defines the columns to insert, and the remaining maps must have the same set of keys and values&quot; (but this restriction is gone in 2.x)."><y>#</y><d>2021-02-01</d><h>21:29</h><w>seancorfield</w><a>@codonnell</a> BTW, the 1.x readme says &quot;the first map defines the columns to insert, and the remaining maps must have the same set of keys and values&quot; (but this restriction is gone in 2.x).</z><z id="t1612223062" t="Chris O’Donnell Sorry, I totally missed that! Maybe it&apos;s just me, but I don&apos;t often consult the Readme anymore except to glance at an example when I don&apos;t remember syntax. I&apos;m sure I read the prose some time ago, but didn&apos;t remember that detail. Definitely appreciate that is documented."><y>#</y><d>2021-02-01</d><h>23:44</h><r>Chris O’Donnell</r>Sorry, I totally missed that! Maybe it&apos;s just me, but I don&apos;t often consult the Readme anymore except to glance at an example when I don&apos;t remember syntax. I&apos;m sure I read the prose some time ago, but didn&apos;t remember that detail. Definitely appreciate that is documented.</z><z id="t1612220261" t="seancorfield Today I have mostly worked on docstrings for the public API and updating the README to ensure it&apos;s all up-to-date and has examples of several new pieces of syntax, as well as ensuring all the tests pass on Clojure 1.9/1.10/1.11 (master) and ClojureScript and that the README example code also all passes (as tests). Code-wise, I&apos;m pretty much at a 2.0.0 Alpha 1 state now for anyone who feels adventurous enough to try it out 🙂"><y>#</y><d>2021-02-01</d><h>22:57</h><w>seancorfield</w>Today I have mostly worked on docstrings for the public API and updating the README to ensure it&apos;s all up-to-date and has examples of several new pieces of syntax, as well as ensuring all the tests pass on Clojure 1.9/1.10/1.11 (master) and ClojureScript and that the README example code also all passes (as tests). Code-wise, I&apos;m pretty much at a 2.0.0 Alpha 1 state now for anyone who feels adventurous enough to try it out <b>🙂</b></z><z id="t1612220289" t="seancorfield seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;4cbeb170ddf4ba0d7238c43b092ffb0a33062474&quot;} updated to latest SHA"><y>#</y><d>2021-02-01</d><h>22:58</h><w>seancorfield</w><code>seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;4cbeb170ddf4ba0d7238c43b092ffb0a33062474&quot;}</code> updated to latest SHA</z><z id="t1612220322" t="seancorfield And follow the README here https://github.com/seancorfield/honeysql/tree/v2 (not the develop branch)"><y>#</y><d>2021-02-01</d><h>22:58</h><w>seancorfield</w>And follow the README here <a href="https://github.com/seancorfield/honeysql/tree/v2" target="_blank">https://github.com/seancorfield/honeysql/tree/v2</a> (not the develop branch)</z><z id="t1612220471" t="seancorfield I&apos;m about to start fleshing out the &quot;differences between v1 and v2&quot; document and then I&apos;ll move on to full-blown documentation of v2 later today and most of tomorrow and at some point when I think there&apos;s at least enough documentation to support more widespread testing, I&apos;ll cut a 2.0.0-alpha1 release on Clojars for folks to use with Leiningen."><y>#</y><d>2021-02-01</d><h>23:01</h><w>seancorfield</w>I&apos;m about to start fleshing out the &quot;differences between v1 and v2&quot; document and then I&apos;ll move on to full-blown documentation of v2 later today and most of tomorrow and at some point when I think there&apos;s at least enough documentation to support more widespread testing, I&apos;ll cut a 2.0.0-alpha1 release on Clojars for folks to use with Leiningen.</z><z id="t1612220625" t="seancorfield There&apos;s still a lot of work to do but at this point I believe v2 has reached general feature parity with v1 -- although I have deliberately not implemented several of the v1 formatting options (so I&apos;m looking forward to some discussions about what folks rely on from v1 that I would prefer not to implement in v2 🙂 )."><y>#</y><d>2021-02-01</d><h>23:03</h><w>seancorfield</w>There&apos;s still a lot of work to do but at this point I believe v2 has reached general feature parity with v1 -- although I have deliberately not implemented several of the v1 formatting options (so I&apos;m looking forward to some discussions about what folks rely on from v1 that I would prefer not to implement in v2 <b>🙂</b> ).</z><z id="t1612313970" t="seancorfield (writing documentation is taking me longer than I&apos;d hoped so I&apos;m not going to cut an alpha release to http://clojars.org just yet -- but folks are still welcome to try it out via {:git/url &quot;&quot; :sha &quot;4cbeb170ddf4ba0d7238c43b092ffb0a33062474&quot;} 🙂 )"><y>#</y><d>2021-02-03</d><h>00:59</h><w>seancorfield</w>(writing documentation is taking me longer than I&apos;d hoped so I&apos;m not going to cut an alpha release to <a href="http://clojars.org" target="_blank">http://clojars.org</a> just yet -- but folks are still welcome to try it out via <code>{:git/url &quot;&quot; :sha &quot;4cbeb170ddf4ba0d7238c43b092ffb0a33062474&quot;}</code> <b>🙂</b> )</z><z id="t1612314041" t="seancorfield Special syntax docs https://github.com/seancorfield/honeysql/blob/v2/doc/special-syntax.md"><y>#</y><d>2021-02-03</d><h>01:00</h><w>seancorfield</w>Special syntax docs <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/special-syntax.md" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/special-syntax.md</a></z><z id="t1612381761" t="seancorfield If anyone does take v2 for a spin, please provide feedback -- good or bad."><y>#</y><d>2021-02-03</d><h>19:49</h><w>seancorfield</w>If anyone does take v2 for a spin, please provide feedback -- good or bad.</z><z id="t1612382355" t="dharrigan Hi Sean. I plan to do a bit of playing around in the next few days with it. Slightly busy at work atm."><y>#</y><d>2021-02-03</d><h>19:59</h><w>dharrigan</w>Hi Sean. I plan to do a bit of playing around in the next few days with it. Slightly busy at work atm.</z><z id="t1612382383" t="dharrigan Hopefully I&apos;ll have positive feedback 🙂"><y>#</y><d>2021-02-03</d><h>19:59</h><w>dharrigan</w>Hopefully I&apos;ll have positive feedback <b>🙂</b></z><z id="t1612389120" t="markaddleman [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Where did you land regarding spec and v2? Personally, I&apos;d love to have a honeysql spec. I do a lot of programmatic SQL generation and transformation. I believe that having a spec will help create a honeysql AST that will make transformations easier."><y>#</y><d>2021-02-03</d><h>21:52</h><w>markaddleman</w><a>@seancorfield</a> Where did you land regarding spec and v2?  Personally, I&apos;d love to have a honeysql spec.  I do a lot of programmatic SQL generation and transformation.  I believe that having a spec will help create a honeysql AST that will make transformations easier.</z><z id="t1612389668" t="seancorfield [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Still on the roadmap but it&apos;s much harder than I initially thought -- since it&apos;s basically the Spec equivalent of SQL&apos;s entire syntax 🙂"><y>#</y><d>2021-02-03</d><h>22:01</h><w>seancorfield</w><a>@markaddleman</a> Still on the roadmap but it&apos;s much harder than I initially thought -- since it&apos;s basically the Spec equivalent of SQL&apos;s entire syntax <b>🙂</b></z><z id="t1612389699" t="markaddleman ha. Yeah, that was the conclusion I came to. I was hoping you had some magic up your sleeve"><y>#</y><d>2021-02-03</d><h>22:01</h><r>markaddleman</r>ha.  Yeah, that was the conclusion I came to.  I was hoping you had some magic up your sleeve</z><z id="t1612389777" t="seancorfield Writing a Spec that just says &quot;this data structure is acceptable to HoneySQL&quot; is fairly tractable but that&apos;s very lax -- HoneySQL can format all sorts of otherwise rather dubious &quot;SQL&quot; 🙂 No guarantee the SQL itself is valid, however..."><y>#</y><d>2021-02-03</d><h>22:02</h><r>seancorfield</r>Writing a Spec that just says &quot;this data structure is acceptable to HoneySQL&quot; is fairly tractable but that&apos;s very lax -- HoneySQL can format all sorts of otherwise rather dubious &quot;SQL&quot; <b>🙂</b> No guarantee the SQL itself is valid, however...</z><z id="t1612389963" t="seancorfield Since I want v2 to accept as much of the existing data structure DSLs out there which are used by v1, there are some inconsistencies I don&apos;t want to fix. At the same time, I&apos;ve made v2 a bit more lenient in some cases where there&apos;s no ambiguity."><y>#</y><d>2021-02-03</d><h>22:06</h><r>seancorfield</r>Since I want v2 to accept as much of the existing data structure DSLs out there which are used by v1, there are some inconsistencies I don&apos;t want to fix. At the same time, I&apos;ve made v2 a bit more lenient in some cases where there&apos;s no ambiguity.</z><z id="t1612390183" t="seancorfield For example, (format {:select :id :from :table :where [:= :x 42]}) works in v2 because it makes sense -- folks expect that. But if you want aliases, you can&apos;t just do (format {:select [:id :a] :from [:table :t]:where [:= :x 42]}) because both :select and :from really expect sequences of identifiers and aliases need to be nested inside that sequence, as (format {:select [[:id :a]] :from [[:table :t]]:where [:= :x 42]})"><y>#</y><d>2021-02-03</d><h>22:09</h><r>seancorfield</r>For example, <code>(format {:select :id :from :table :where [:= :x 42]})</code> works in v2 because it makes sense -- folks expect that. But if you want aliases, you can&apos;t just do <code>(format {:select [:id :a] :from [:table :t]:where [:= :x 42]})</code> because both <code>:select</code> and <code>:from</code> really expect sequences of identifiers and aliases need to be nested inside that sequence, as <code>(format {:select [[:id :a]] :from [[:table :t]]:where [:= :x 42]})</code></z><z id="t1612390218" t="seancorfield There&apos;s no good way to consistently make the &quot;mistake&quot; genuinely illegal without also prohibiting strange-but-legal stuff..."><y>#</y><d>2021-02-03</d><h>22:10</h><r>seancorfield</r>There&apos;s no good way to consistently make the &quot;mistake&quot; genuinely illegal without also prohibiting strange-but-legal stuff...</z><z id="t1612390290" t="seancorfield I certainly could make v2 stricter (and disallow &apos;{select id from table where (= x 42)} ) but it would also make it more complex and probably less easy to use 😐"><y>#</y><d>2021-02-03</d><h>22:11</h><r>seancorfield</r>I certainly could make v2 stricter (and disallow <code>&apos;{select id from table where (= x 42)}</code>) but it would also make it more complex and probably less easy to use <b>😐</b></z><z id="t1612390323" t="seancorfield (and v2 deliberately accepts symbols and lists where v1 only accepted keywords and vectors -- because folks want the quoted datalog-style query format)"><y>#</y><d>2021-02-03</d><h>22:12</h><r>seancorfield</r>(and v2 deliberately accepts symbols and lists where v1 only accepted keywords and vectors -- because folks want the quoted datalog-style query format)</z><z id="t1612390607" t="markaddleman Understood. I encountered similar issues. I author queries by hand using using honeysql&apos;s syntax but the very first thing my transformation system does is &quot;normalize&quot; it (eg, all column projections have aliases, all tables have aliases, where clause expressions are converted to SqlCall records, etc)."><y>#</y><d>2021-02-03</d><h>22:16</h><r>markaddleman</r>Understood.  I encountered similar issues.  I author queries by hand using using honeysql&apos;s  syntax but the very first thing my transformation system does is &quot;normalize&quot; it (eg, all column projections have aliases, all tables have aliases, where clause expressions are converted to SqlCall records, etc).</z><z id="t1612390669" t="markaddleman I despair of writing a spec for the unnormalized structure but the normalized data wouldn&apos;t be too bad"><y>#</y><d>2021-02-03</d><h>22:17</h><r>markaddleman</r>I despair of writing a spec for the unnormalized structure but the normalized data wouldn&apos;t be too bad</z><z id="t1612390183" t="seancorfield For example, (format {:select :id :from :table :where [:= :x 42]}) works in v2 because it makes sense -- folks expect that. But if you want aliases, you can&apos;t just do (format {:select [:id :a] :from [:table :t]:where [:= :x 42]}) because both :select and :from really expect sequences of identifiers and aliases need to be nested inside that sequence, as (format {:select [[:id :a]] :from [[:table :t]]:where [:= :x 42]})"><y>#</y><d>2021-02-03</d><h>22:09</h><w>seancorfield</w>For example, <code>(format {:select :id :from :table :where [:= :x 42]})</code> works in v2 because it makes sense -- folks expect that. But if you want aliases, you can&apos;t just do <code>(format {:select [:id :a] :from [:table :t]:where [:= :x 42]})</code> because both <code>:select</code> and <code>:from</code> really expect sequences of identifiers and aliases need to be nested inside that sequence, as <code>(format {:select [[:id :a]] :from [[:table :t]]:where [:= :x 42]})</code></z><z id="t1612475485" t="wombawomba I&apos;m looking for, but can&apos;t find any examples of how to build CTE queries in HoneySQL. Any pointers?"><y>#</y><d>2021-02-04</d><h>21:51</h><w>wombawomba</w>I&apos;m looking for, but can&apos;t find any examples of how to build CTE queries in HoneySQL. Any pointers?</z><z id="t1612478700" t="seancorfield [:attrs {:href &quot;/_/_/users/U15RYEQPJ&quot;}] Do you mean like this https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/format_test.cljc#L62-L76 ?"><y>#</y><d>2021-02-04</d><h>22:45</h><w>seancorfield</w><a>@wombawomba</a> Do you mean like this <a href="https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/format_test.cljc#L62-L76" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/format_test.cljc#L62-L76</a> ?</z><z id="t1612478981" t="wombawomba yup, thanks!"><y>#</y><d>2021-02-04</d><h>22:49</h><w>wombawomba</w>yup, thanks!</z><z id="t1612479154" t="seancorfield On the bright side, the v2 docs will list all the supported clauses https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md (when I get time to work on the docs some more)."><y>#</y><d>2021-02-04</d><h>22:52</h><w>seancorfield</w>On the bright side, the v2 docs will list all the supported clauses <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md</a> (when I get time to work on the docs some more).</z><z id="t1612735229" t="seancorfield As I&apos;ve been continuing with https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md I&apos;ve also been fixing a few bugs I&apos;ve run across and also adjusting a few things to make usage easier (e.g., :with for CTE no longer requires the extra wrapping as a sequence since there can only ever be one WITH clause in an expression as far as I can tell from the SQL Server docs, although it still accepts the old 1.x format; :order-by now allows the direction to be omitted when you order by an expression although it still needs to be wrapped to disambiguate it)."><y>#</y><d>2021-02-07</d><h>22:00</h><w>seancorfield</w>As I&apos;ve been continuing with <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md</a> I&apos;ve also been fixing a few bugs I&apos;ve run across and also adjusting a few things to make usage easier (e.g., <code>:with</code> for CTE no longer requires the extra wrapping as a sequence since there can only ever be one <code>WITH</code> clause in an expression as far as I can tell from the SQL Server docs, although it still accepts the old 1.x format; <code>:order-by</code> now allows the direction to be omitted when you order by an expression although it still needs to be wrapped to disambiguate it).</z><z id="t1612804177" t="enn [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I think you’re right that you can only have one WITH clause, but it can define multiple tables … is that supported by the new syntax? e.g. the first example here: https://www.postgresql.org/docs/9.1/queries-with.html"><y>#</y><d>2021-02-08</d><h>17:09</h><w>enn</w><a>@seancorfield</a> I think you’re right that you can only have one WITH clause, but it can define multiple tables … is that supported by the new syntax? e.g. the first example here: <a href="https://www.postgresql.org/docs/9.1/queries-with.html" target="_blank">https://www.postgresql.org/docs/9.1/queries-with.html</a></z><z id="t1612807367" t="seancorfield [:attrs {:href &quot;/_/_/users/U060QM7AA&quot;}] Ah, thanks for that link -- I had only been looking at SQL Server and the docs seemed to indicate only one CTE can be defined but that PostgreSQL example makes it clear you can define multiple ones. I&apos;ll create and issue to reverse that optimization and make sure that example can be done with HoneySQL 2.0!"><y>#</y><d>2021-02-08</d><h>18:02</h><w>seancorfield</w><a>@enn</a> Ah, thanks for that link -- I had only been looking at SQL Server and the docs seemed to indicate only one CTE can be defined but that PostgreSQL example makes it clear you can define multiple ones. I&apos;ll create and issue to reverse that optimization and make sure that example can be done with HoneySQL 2.0!</z><z id="t1612807491" t="seancorfield (issue 298)"><y>#</y><d>2021-02-08</d><h>18:04</h><w>seancorfield</w>(issue 298)</z><z id="t1612808023" t="enn thank you!"><y>#</y><d>2021-02-08</d><h>18:13</h><w>enn</w>thank you!</z><z id="t1613003801" t="seancorfield Progress report! WITH is back to supporting multiple CTEs (and there&apos;s even a test for it); I have &quot;finished&quot; the clause reference mentioned above; I have incorporated all of the SQL portions from the nilenso/honeysql-postgres library (although some of the syntax has ended up a little different (HoneySQL v2&apos;s :insert-into supports an alias out of the box so insert-into-as is not needed, and do-update-set! is not needed because HoneySQL v2&apos;s :do-update-set clause supports both the simple excluded case and the full SET -like version). See https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L281-L332 for the HoneySQL v2 tests of helpers like the nilenso functions."><y>#</y><d>2021-02-11</d><h>00:36</h><w>seancorfield</w>Progress report! <code>WITH</code> is back to supporting multiple CTEs (and there&apos;s even a test for it); I have &quot;finished&quot; the clause reference mentioned above; I have incorporated all of the SQL portions from the nilenso/honeysql-postgres library (although some of the syntax has ended up a little different (HoneySQL v2&apos;s <code>:insert-into</code> supports an alias out of the box so <code>insert-into-as</code> is not needed, and <code>do-update-set!</code> is not needed because HoneySQL v2&apos;s <code>:do-update-set</code> clause supports both the simple <code>excluded</code> case and the full <code>SET</code>-like version). See <a href="https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L281-L332" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L281-L332</a> for the HoneySQL v2 tests of helpers like the nilenso functions.</z><z id="t1613003873" t="seancorfield Next up: add the DDL from nilenso/honeysql-postgres (and document those clauses) and comb through the source and tests in that library to see if there&apos;s anything that isn&apos;t documented in the README."><y>#</y><d>2021-02-11</d><h>00:37</h><w>seancorfield</w>Next up: add the DDL from nilenso/honeysql-postgres (and document those clauses) and comb through the source and tests in that library to see if there&apos;s anything that isn&apos;t documented in the README.</z><z id="t1613003974" t="seancorfield Then I&apos;ll continue on through the open issues for v2 and documentation and figure out at what point it will be worth cutting an alpha release to clojars. The latest SHA for anyone playing with the :git/url version is e157aec976769e4cfad0e63f0bad665ba5068e01 ."><y>#</y><d>2021-02-11</d><h>00:39</h><w>seancorfield</w>Then I&apos;ll continue on through the open issues for v2 and documentation and figure out at what point it will be worth cutting an alpha release to clojars. The latest SHA for anyone playing with the <code>:git/url</code> version is <code>e157aec976769e4cfad0e63f0bad665ba5068e01</code>.</z><z id="t1613077347" t="dharrigan So, just getting round to &quot;port&quot; my existing application to honeysql v2. Am I right in thinking that this style is no longer in use (or rather no longer encouraged)..."><y>#</y><d>2021-02-11</d><h>21:02</h><w>dharrigan</w>So, just getting round to &quot;port&quot; my existing application to honeysql v2. Am I right in thinking that this style is no longer in use (or rather no longer encouraged)...</z><z id="t1613077374" t="dharrigan (-&gt; (select :device-id) (helpers/from :trip) (where [:= :vrn vrn] [:= :tenant-id tenant-id] [:&gt;= :start-datetime (db/datetime-&gt;sql from)] [:&lt;= :end-datetime (db/datetime-&gt;sql to)]) (limit 1) sql/format)))"><y>#</y><d>2021-02-11</d><h>21:02</h><w>dharrigan</w><pre>(-&gt; (select :device-id)
        (helpers/from :trip)
        (where [:= :vrn vrn]
               [:= :tenant-id tenant-id]
               [:&gt;= :start-datetime (db/datetime-&gt;sql from)]
               [:&lt;= :end-datetime (db/datetime-&gt;sql to)])
        (limit 1)
        sql/format)))</pre></z><z id="t1613077381" t="dharrigan and should be replaced with {} maps?"><y>#</y><d>2021-02-11</d><h>21:03</h><w>dharrigan</w>and should be replaced with <code>{}</code> maps?</z><z id="t1613077945" t="dharrigan i.e.,"><y>#</y><d>2021-02-11</d><h>21:12</h><w>dharrigan</w>i.e.,</z><z id="t1613077948" t="dharrigan (sql/format {:select [:device-id] :from [:trip] :where [:and [:= :vrn &quot;asd&quot;] [:= :tenant-id &quot;tenant-id&quot;] [:&gt;= :start-datetime &quot;from&quot;] [:&lt;= :end-datetime &quot;to&quot;]] :limit 1}) ;; [&quot;SELECT device_id FROM trip WHERE (vrn = ?) AND (tenant_id = ?) AND (start_datetime &gt;= ?) AND (end_datetime &lt;= ?) LIMIT ?&quot; ;; &quot;asd&quot; ;; &quot;tenant-id&quot; ;; &quot;from&quot; ;; &quot;to&quot; ;; 1]"><y>#</y><d>2021-02-11</d><h>21:12</h><w>dharrigan</w><pre>(sql/format
  {:select [:device-id]
   :from [:trip]
   :where [:and [:= :vrn &quot;asd&quot;]
                [:= :tenant-id &quot;tenant-id&quot;]
                [:&gt;= :start-datetime &quot;from&quot;]
                [:&lt;= :end-datetime &quot;to&quot;]]
   :limit 1})
;; [&quot;SELECT device_id FROM trip WHERE (vrn = ?) AND (tenant_id = ?) AND (start_datetime &gt;= ?) AND (end_datetime &lt;= ?) LIMIT ?&quot;
;;  &quot;asd&quot;
;;  &quot;tenant-id&quot;
;;  &quot;from&quot;
;;  &quot;to&quot;
;;  1]</pre></z><z id="t1613079608" t="seancorfield honey.sql.helpers has all the helpers you are used to."><y>#</y><d>2021-02-11</d><h>21:40</h><w>seancorfield</w><code>honey.sql.helpers</code> has all the helpers you are used to.</z><z id="t1613079844" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] user=&gt; (-&gt; (select :device-id) #_=&gt; (helpers/from :trip) #_=&gt; (where [:= :vrn vrn] #_=&gt; [:= :tenant-id tenant-id] #_=&gt; [:&gt;= :start-datetime (db/datetime-&gt;sql from)] #_=&gt; [:&lt;= :end-datetime (db/datetime-&gt;sql to)]) #_=&gt; (limit 1) #_=&gt; sql/format) [&quot;SELECT device_id FROM trip WHERE (vrn = ?) AND (tenant_id = ?) AND (start_datetime &gt;= ?) AND (end_datetime &lt;= ?) LIMIT ?&quot; &quot;vrn&quot; 42 #inst &quot;2021-02-11T21:43:31.289-00:00&quot; #inst &quot;2021-02-11T21:43:31.289-00:00&quot; 1] 🎉"><y>#</y><d>2021-02-11</d><h>21:44</h><w>seancorfield</w><a>@dharrigan</a>
<pre>user=&gt; (-&gt; (select :device-id)
  #_=&gt;         (helpers/from :trip)
  #_=&gt;         (where [:= :vrn vrn]
  #_=&gt;                [:= :tenant-id tenant-id]
  #_=&gt;                [:&gt;= :start-datetime (db/datetime-&gt;sql from)]
  #_=&gt;                [:&lt;= :end-datetime (db/datetime-&gt;sql to)])
  #_=&gt;         (limit 1)
  #_=&gt;         sql/format)
[&quot;SELECT device_id FROM trip WHERE (vrn = ?) AND (tenant_id = ?) AND (start_datetime &gt;= ?) AND (end_datetime &lt;= ?) LIMIT ?&quot; &quot;vrn&quot; 42 #inst &quot;2021-02-11T21:43:31.289-00:00&quot; #inst &quot;2021-02-11T21:43:31.289-00:00&quot; 1]</pre>
<b>🎉</b></z><z id="t1613114979" t="dharrigan 🙂"><y>#</y><d>2021-02-12</d><h>07:29</h><w>dharrigan</w><b>🙂</b></z><z id="t1613148715" t="dharrigan Converted my application to honeysql v2"><y>#</y><d>2021-02-12</d><h>16:51</h><w>dharrigan</w>Converted my application to honeysql v2</z><z id="t1613148721" t="dharrigan slowly working through it to find any breakage"><y>#</y><d>2021-02-12</d><h>16:52</h><w>dharrigan</w>slowly working through it to find any breakage</z><z id="t1613148809" t="dharrigan I notice now that function calls are uppercased, i.e., in honey v1, [:ST_SetSRID....] now becomes ST_SETSRID(... when formatted in honey v2"><y>#</y><d>2021-02-12</d><h>16:53</h><w>dharrigan</w>I notice now that function calls are uppercased, i.e.,  in honey v1, <code>[:ST_SetSRID....]</code> now becomes <code>ST_SETSRID(...</code> when formatted in honey v2</z><z id="t1613148844" t="dharrigan (just an observation, natch it&apos;s fine as sql is case insensitive unless quoted)"><y>#</y><d>2021-02-12</d><h>16:54</h><w>dharrigan</w>(just an observation, natch it&apos;s fine as sql is case insensitive unless quoted)</z><z id="t1613148918" t="dharrigan Modified about 15 files that used honeysql calls, so let&apos;s see what happens 🙂"><y>#</y><d>2021-02-12</d><h>16:55</h><w>dharrigan</w>Modified about 15 files that used honeysql calls, so let&apos;s see what happens <b>🙂</b></z><z id="t1613149059" t="dharrigan I am liking the natural use of [:foo being a function call"><y>#</y><d>2021-02-12</d><h>16:57</h><w>dharrigan</w>I am liking the natural use of <code>[:foo</code> being a function call</z><z id="t1613149112" t="seancorfield Re: uppercase -- yeah, v1 was a bit inconsistent about that, depending on how it treated the context so you&apos;d get lowercase for some things that were clearly built-in and &quot;should&quot; be uppercase, you&apos;d get mixed case in some situations, and then you&apos;d get uppercase for other things 😐 So I just took the position that your own &quot;vars&quot; (tables and column names) should be left as is (modulo the - -&gt; _ thing) and pretty much everything else should be uppercase."><y>#</y><d>2021-02-12</d><h>16:58</h><w>seancorfield</w>Re: uppercase -- yeah, v1 was a bit inconsistent about that, depending on how it treated the context so you&apos;d get lowercase for some things that were clearly built-in and &quot;should&quot; be uppercase, you&apos;d get mixed case in some situations, and then you&apos;d get uppercase for other things <b>😐</b> So I just took the position that your own &quot;vars&quot; (tables and column names) should be left as is (modulo the <code>-</code> -&gt; <code>_</code> thing) and pretty much everything else should be uppercase.</z><z id="t1613149143" t="dharrigan consistency is key! 🙂"><y>#</y><d>2021-02-12</d><h>16:59</h><w>dharrigan</w>consistency is key! <b>🙂</b></z><z id="t1613149234" t="seancorfield Having to wrap things in (sql/call ..) in v1 was probably the most common thing I got support questions and GitHub issues about: because [:foo 1 2 3] worked in &quot;most&quot; situations but there were lots of edge cases where it didn&apos;t quite work and you needed to &quot;help&quot; HoneySQL figure it out. And that&apos;s why I went with all the other &quot;special syntax&quot; as plain &quot;function&quot; calls too: raw, inline, param, etc."><y>#</y><d>2021-02-12</d><h>17:00</h><w>seancorfield</w>Having to wrap things in <code>(sql/call ..)</code> in v1 was probably the most common thing I got support questions and GitHub issues about: because <code>[:foo 1 2 3]</code> worked in &quot;most&quot; situations but there were lots of edge cases where it didn&apos;t quite work and you needed to &quot;help&quot; HoneySQL figure it out. And that&apos;s why I went with all the other &quot;special syntax&quot; as plain &quot;function&quot; calls too: raw, inline, param, etc.</z><z id="t1613149288" t="seancorfield (I&apos;m going to make coffee and feed cats but will be back to answer any Qs in 10 mins)"><y>#</y><d>2021-02-12</d><h>17:01</h><w>seancorfield</w>(I&apos;m going to make coffee and feed cats but will be back to answer any Qs in 10 mins)</z><z id="t1613150458" t="seancorfield (back)"><y>#</y><d>2021-02-12</d><h>17:20</h><w>seancorfield</w>(back)</z><z id="t1613151969" t="dharrigan I think it&apos;s looking good, question."><y>#</y><d>2021-02-12</d><h>17:46</h><w>dharrigan</w>I think it&apos;s looking good, question.</z><z id="t1613151998" t="dharrigan how does the on-conflict , do-nothing work (previously I was using a defhelper to default a clause)"><y>#</y><d>2021-02-12</d><h>17:46</h><w>dharrigan</w>how does the <code>on-conflict</code>, <code>do-nothing</code> work (previously I was using a defhelper to default a clause)</z><z id="t1613152047" t="dharrigan Figured it out"><y>#</y><d>2021-02-12</d><h>17:47</h><w>dharrigan</w>Figured it out</z><z id="t1613152061" t="dharrigan Man, working with the repl, rich comment blocks is fantastic, such quick feedabck"><y>#</y><d>2021-02-12</d><h>17:47</h><w>dharrigan</w>Man, working with the repl, rich comment blocks is fantastic, such quick feedabck</z><z id="t1613152067" t="dharrigan (on-conflict (do-nothing))"><y>#</y><d>2021-02-12</d><h>17:47</h><w>dharrigan</w><code>(on-conflict (do-nothing))</code></z><z id="t1613152087" t="dharrigan (insert-sql {:id 1}) ;; [&quot;INSERT INTO investigation (id) VALUES (?) ON CONFLICT DO NOTHING&quot; 1]"><y>#</y><d>2021-02-12</d><h>17:48</h><w>dharrigan</w><code>(insert-sql {:id 1}) ;; [&quot;INSERT INTO investigation (id) VALUES (?) ON CONFLICT DO NOTHING&quot; 1]</code></z><z id="t1613152142" t="dharrigan (as an aside, conjure on vim recently gained the ability to put the evaluation into a comment beside the form - that&apos;s what you&apos;re seeing there - makes capturing the result of a RCF fantastic and easy to look back upon)"><y>#</y><d>2021-02-12</d><h>17:49</h><w>dharrigan</w>(as an aside, conjure on vim recently gained the ability to put the evaluation into a comment beside the form - that&apos;s what you&apos;re seeing there - makes capturing the result of a RCF fantastic and easy to look back upon)</z><z id="t1613152599" t="dharrigan Well, so far so good, the happy path of my application works with honey v2"><y>#</y><d>2021-02-12</d><h>17:56</h><w>dharrigan</w>Well, so far so good, the happy path of my application works with honey v2</z><z id="t1613152609" t="dharrigan will check over the data in due course"><y>#</y><d>2021-02-12</d><h>17:56</h><w>dharrigan</w>will check over the data in due course</z><z id="t1613154546" t="seancorfield Nice. Yeah, I haven&apos;t documented the helpers yet -- even tho&apos; I prefer those over working with raw data -- but, as you&apos;re finding out, they&apos;re a lot more comprehensive than in v1 (there is literally a helper now for every single clause -- and a couple of helpers for special syntax forms as well)."><y>#</y><d>2021-02-12</d><h>18:29</h><w>seancorfield</w>Nice. Yeah, I haven&apos;t documented the helpers yet -- even tho&apos; I prefer those over working with raw data -- but, as you&apos;re finding out, they&apos;re a lot more comprehensive than in v1 (there is literally a helper now for every single clause -- and a couple of helpers for special syntax forms as well).</z><z id="t1613157259" t="seancorfield Once I&apos;ve finished implementing all the parts of nilenso/honeysql-postgres I&apos;ll add a specific section to the docs that talks about the differences between HoneySQL v2 and that lib -- there are a few things that just made sense to do a bit differently [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}]"><y>#</y><d>2021-02-12</d><h>19:14</h><w>seancorfield</w>Once I&apos;ve finished implementing all the parts of nilenso/honeysql-postgres I&apos;ll add a specific section to the docs that talks about the differences between HoneySQL v2 and that lib -- there are a few things that just made sense to do a bit differently <a>@dharrigan</a></z><z id="t1613158493" t="dharrigan np, looking forward to it. So far, the upgrade has been relatively straightforward. The main thing for me was replacing &quot;sql/call&quot; and &quot;sql/raw&quot; statements"><y>#</y><d>2021-02-12</d><h>19:34</h><w>dharrigan</w>np, looking forward to it. So far, the upgrade has been relatively straightforward. The main thing for me was replacing &quot;sql/call&quot; and &quot;sql/raw&quot; statements</z><z id="t1613158541" t="dharrigan will do some testing over the weekend, apart from some temporal differences, the data produced v1 vs v2 should be the same"><y>#</y><d>2021-02-12</d><h>19:35</h><w>dharrigan</w>will do some testing over the weekend, apart from some temporal differences, the data produced v1 vs v2 should be the same</z><z id="t1613159568" t="seancorfield Much appreciated! I will continue working on the docs over the weekend, after completing the PG DDL stuff."><y>#</y><d>2021-02-12</d><h>19:52</h><w>seancorfield</w>Much appreciated! I will continue working on the docs over the weekend, after completing the PG DDL stuff.</z><z id="t1613162870" t="dharrigan so far, data produced is identical, apart from a datetime stamp (of creation)"><y>#</y><d>2021-02-12</d><h>20:47</h><w>dharrigan</w>so far, data produced is identical, apart from a datetime stamp (of creation)</z><z id="t1613162890" t="dharrigan encouraging! 🙂"><y>#</y><d>2021-02-12</d><h>20:48</h><w>dharrigan</w>encouraging! <b>🙂</b></z><z id="t1613163015" t="dharrigan the two results are about +135,000 lines long, comprised of various sql reports, so only 2 lines differ, and that&apos;s the date of when the request to generate the reports was done 🙂"><y>#</y><d>2021-02-12</d><h>20:50</h><w>dharrigan</w>the two results are about +135,000 lines long, comprised of various sql reports, so only 2 lines differ, and that&apos;s the date of when the request to generate the reports was done <b>🙂</b></z><z id="t1613163485" t="seancorfield Sounds like some serious testing -- thank you!"><y>#</y><d>2021-02-12</d><h>20:58</h><w>seancorfield</w>Sounds like some serious testing -- thank you!</z><z id="t1613163510" t="dharrigan more testing adhoc over the weekend on the CD of CRUD actions 🙂"><y>#</y><d>2021-02-12</d><h>20:58</h><w>dharrigan</w>more testing adhoc over the weekend on the CD of CRUD actions <b>🙂</b></z><z id="t1613163519" t="dharrigan oh and U too 🙂"><y>#</y><d>2021-02-12</d><h>20:58</h><w>dharrigan</w>oh and U too <b>🙂</b></z><z id="t1613163587" t="seancorfield It should now support stuff like delete from multiple tables, delete using, insert into as, and various other stuff that v1 omitted (or had only partially added)."><y>#</y><d>2021-02-12</d><h>20:59</h><w>seancorfield</w>It should now support stuff like delete from multiple tables, delete using, insert into as, and various other stuff that v1 omitted (or had only partially added).</z><z id="t1613163606" t="seancorfield It also has all the OVER / PARTITION BY / WINDOW stuff built in now."><y>#</y><d>2021-02-12</d><h>21:00</h><w>seancorfield</w>It also has all the OVER / PARTITION BY / WINDOW stuff built in now.</z><z id="t1613163614" t="dharrigan my inserts do various joins over several tables"><y>#</y><d>2021-02-12</d><h>21:00</h><w>dharrigan</w>my inserts do various joins over several tables</z><z id="t1613163631" t="dharrigan and my reports do use OVER window functions too, so that appears to be tickity-boo for me atm"><y>#</y><d>2021-02-12</d><h>21:00</h><w>dharrigan</w>and my reports do use OVER window functions too, so that appears to be tickity-boo for me atm</z><z id="t1613163686" t="dharrigan I&apos;ve replaced all the honeysql-postgres extensions from nilenso too"><y>#</y><d>2021-02-12</d><h>21:01</h><w>dharrigan</w>I&apos;ve replaced all the honeysql-postgres extensions from nilenso too</z><z id="t1613163756" t="dharrigan right, ttfn! off to re-re-re-read LOTR!"><y>#</y><d>2021-02-12</d><h>21:02</h><w>dharrigan</w>right, ttfn! off to re-re-re-read LOTR!</z><z id="t1613175890" t="seancorfield Q for folks using nilenso/honeysql-postgres: how many of you actually use alter-table (and the undocumented rename-table )? It looks like it doesn&apos;t currently let you have multiple altering clauses (e.g., alter table foo add column id int, drop column ident; type stuff). Would a syntax allowing multiple clauses be appreciated?"><y>#</y><d>2021-02-13</d><h>00:24</h><w>seancorfield</w>Q for folks using nilenso/honeysql-postgres: how many of you actually use <code>alter-table</code> (and the undocumented <code>rename-table</code>)? It looks like it doesn&apos;t currently let you have multiple altering clauses (e.g., <code>alter table foo add column id int, drop column ident;</code> type stuff). Would a syntax allowing multiple clauses be appreciated?</z><z id="t1613176137" t="seancorfield I&apos;m thinking of something like: {:alter-table :foo :add-column [:id :int]} ; single clause case (-&gt; (alter-table :foo) (add-column :id :int)) ; single clause helper version ;; proposed: {:alter-table [:foo {:add-column [:id :int]} {:drop-column :ident}]} ; multi-clause case (alter-table :foo (add-column :id :int) (:drop-column :ident)) ; multi-clause helper version"><y>#</y><d>2021-02-13</d><h>00:28</h><w>seancorfield</w>I&apos;m thinking of something like:
<pre>{:alter-table :foo :add-column [:id :int]} ; single clause case
(-&gt; (alter-table :foo) (add-column :id :int)) ; single clause helper version
;; proposed:
{:alter-table [:foo {:add-column [:id :int]} {:drop-column :ident}]} ; multi-clause case
(alter-table :foo (add-column :id :int) (:drop-column :ident)) ; multi-clause helper version</pre></z><z id="t1613251755" t="kwrooijen Yes it would be nice to have!"><y>#</y><d>2021-02-13</d><h>21:29</h><r>kwrooijen</r>Yes it would be nice to have!</z><z id="t1613251838" t="kwrooijen I actually had to write my own to get it to work in Gungnir 😅 https://github.com/kwrooijen/gungnir/blob/ef0c9a25bb00792e27a6d07871bb82feb8aaf50d/src/clj/gungnir/extension/honeysql_postgres.clj#L46-L60"><y>#</y><d>2021-02-13</d><h>21:30</h><r>kwrooijen</r>I actually had to write my own to get it to work in Gungnir <b>😅</b>  <a href="https://github.com/kwrooijen/gungnir/blob/ef0c9a25bb00792e27a6d07871bb82feb8aaf50d/src/clj/gungnir/extension/honeysql_postgres.clj#L46-L60" target="_blank">https://github.com/kwrooijen/gungnir/blob/ef0c9a25bb00792e27a6d07871bb82feb8aaf50d/src/clj/gungnir/extension/honeysql_postgres.clj#L46-L60</a></z><z id="t1613251863" t="kwrooijen If Honeysql would get first class support for creating / altering tables etc. It would simplify it for my library and I&apos;d get rid of an extra dependency 🙂"><y>#</y><d>2021-02-13</d><h>21:31</h><r>kwrooijen</r>If Honeysql would get first class support for creating / altering tables etc. It would simplify it for my library and I&apos;d get rid of an extra dependency <b>🙂</b></z><z id="t1613251965" t="kwrooijen (I currently use this to implement my migration system)"><y>#</y><d>2021-02-13</d><h>21:32</h><r>kwrooijen</r>(I currently use this to implement my migration system)</z><z id="t1613254233" t="seancorfield [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] Thanks for the feedback -- I&apos;m most of the way through integrating and testing the last few parts of the nilenso library this afternoon (`do update set` is giving me fits! 👀 ) but by Monday this should all be sorted out and documented (integrating all these clauses in a consistent manner has led to some divergence -- so I plan to write a full &quot;differences&quot; page in the documentation)."><y>#</y><d>2021-02-13</d><h>22:10</h><r>seancorfield</r><a>@UG9U7TPDZ</a> Thanks for the feedback -- I&apos;m most of the way through integrating and testing the last few parts of the nilenso library this afternoon (`do update set` is giving me fits! <b>👀</b> ) but by Monday this should all be sorted out and documented (integrating all these clauses in a consistent manner has led to some divergence -- so I plan to write a full &quot;differences&quot; page in the documentation).</z><z id="t1613194709" t="seancorfield And another PG Q about that library: is anyone actually using create-extension and/or drop-extension ? What on earth do those even mean?"><y>#</y><d>2021-02-13</d><h>05:38</h><w>seancorfield</w>And another PG Q about that library: is anyone actually using <code>create-extension</code> and/or <code>drop-extension</code>? What on earth do those even mean?</z><z id="t1613197588" t="Chris O’Donnell I don&apos;t use honeysql for ddl, but create and drop extension are for enabling and disabling postgres extensions ( https://www.postgresql.org/docs/current/external-extensions.html ), which are basically plug-ins adding functionality to postgres. For example, PostGIS is a popular extension adding spatial and geographic data types."><y>#</y><d>2021-02-13</d><h>06:26</h><r>Chris O’Donnell</r>I don&apos;t use honeysql for ddl, but create and drop extension are for enabling and disabling postgres extensions (<a href="https://www.postgresql.org/docs/current/external-extensions.html" target="_blank">https://www.postgresql.org/docs/current/external-extensions.html</a>), which are basically plug-ins adding functionality to postgres. For example, PostGIS is a popular extension adding spatial and geographic data types.</z><z id="t1613249456" t="kwrooijen I use it to enable uuids"><y>#</y><d>2021-02-13</d><h>20:50</h><r>kwrooijen</r>I use it to enable uuids</z><z id="t1613202438" t="dharrigan Morning - whilst I don&apos;t use alter table/rename table clauses, perhaps in the name of completeness they should be included (if minimal work involved!)"><y>#</y><d>2021-02-13</d><h>07:47</h><w>dharrigan</w>Morning - whilst I don&apos;t use alter table/rename table clauses, perhaps in the name of completeness they should be included (if minimal work involved!)</z><z id="t1613202455" t="dharrigan Yeah, create and drop extensions are for installing extensions within schemas"><y>#</y><d>2021-02-13</d><h>07:47</h><w>dharrigan</w>Yeah, create and drop extensions are for installing extensions within schemas</z><z id="t1613202468" t="dharrigan for example &quot;create extension postgis schema foo&quot;"><y>#</y><d>2021-02-13</d><h>07:47</h><w>dharrigan</w>for example &quot;create extension postgis schema foo&quot;</z><z id="t1613202476" t="dharrigan would install the postgis extension into schema foo"><y>#</y><d>2021-02-13</d><h>07:47</h><w>dharrigan</w>would install the postgis extension into schema foo</z><z id="t1613202489" t="dharrigan there are lots of extensions"><y>#</y><d>2021-02-13</d><h>07:48</h><w>dharrigan</w>there are lots of extensions</z><z id="t1613202831" t="dharrigan The problem, perhaps, with alter table (including it&apos;s rename variant) is there are tonnes of options on how to alter/create the table. "><y>#</y><d>2021-02-13</d><h>07:53</h><w>dharrigan</w>The problem, perhaps, with alter table (including it&apos;s rename variant) is there are tonnes of options on how to alter/create the table. <code></code></z><z id="t1613202855" t="dharrigan Would it be too much effort?"><y>#</y><d>2021-02-13</d><h>07:54</h><w>dharrigan</w>Would it be too much effort?</z><z id="t1613202933" t="dharrigan The way I use those clauses (create schema, alter table etc...) is only in my migration scripts (I use flywaydb). Since i would expect these to run on application start."><y>#</y><d>2021-02-13</d><h>07:55</h><w>dharrigan</w>The way I use those clauses (create schema, alter table etc...) is only in my migration scripts (I use flywaydb). Since i would expect these to run on application start.</z><z id="t1613236142" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] Thanks for that feedback. I ended up implementing add/drop/modify/rename column and add/drop index. I may implement more if folks request it. I&apos;ll go ahead and implement create/drop extension then since nilenso does have it."><y>#</y><d>2021-02-13</d><h>17:09</h><w>seancorfield</w><a>@dharrigan</a> Thanks for that feedback. I ended up implementing add/drop/modify/rename column and add/drop index. I may implement more if folks request it. I&apos;ll go ahead and implement create/drop extension then since nilenso does have it.</z><z id="t1613236192" t="seancorfield I also added rename table (that&apos;s in the nilenso library but not documented -- seems there are quite a few things implemented and not documented there, so at least they&apos;ll all get documented now in HoneySQL v2!)"><y>#</y><d>2021-02-13</d><h>17:09</h><w>seancorfield</w>I also added rename table (that&apos;s in the nilenso library but not documented -- seems there are quite a few things implemented and not documented there, so at least they&apos;ll all get documented now in HoneySQL v2!)</z><z id="t1613236412" t="dharrigan I&apos;ve finished off testing my application, works perfectly with minimal changes to support honeysql v2"><y>#</y><d>2021-02-13</d><h>17:13</h><w>dharrigan</w>I&apos;ve finished off testing my application, works perfectly with minimal changes to support honeysql v2</z><z id="t1613236540" t="seancorfield Brilliant! Thank you!"><y>#</y><d>2021-02-13</d><h>17:15</h><w>seancorfield</w>Brilliant! Thank you!</z><z id="t1613236591" t="seancorfield Today I&apos;m going to post over the nilenso test suite and adjust it to work with v2 to check I have everything implemented."><y>#</y><d>2021-02-13</d><h>17:16</h><w>seancorfield</w>Today I&apos;m going to post over the nilenso test suite and adjust it to work with v2 to check I have everything implemented.</z><z id="t1613236789" t="dharrigan you&apos;re most welcome 🙂"><y>#</y><d>2021-02-13</d><h>17:19</h><w>dharrigan</w>you&apos;re most welcome <b>🙂</b></z><z id="t1613283538" t="seancorfield OK, seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha1&quot;} is available for early testing... or [seancorfield/honeysql &quot;2.0.0-alpha1&quot;] ... unfortunately http://cljdoc.org doesn&apos;t like this release so you can find the docs at https://github.com/seancorfield/honeysql/blob/v2/doc/getting-started.md (I&apos;m working on fixing broken links etc so please let me know if you hit any problems)."><y>#</y><d>2021-02-14</d><h>06:18</h><w>seancorfield</w>OK, <code>seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha1&quot;}</code> is available for early testing... or <code>[seancorfield/honeysql &quot;2.0.0-alpha1&quot;]</code>... unfortunately <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a> doesn&apos;t like this release so you can find the docs at <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/getting-started.md" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/getting-started.md</a> (I&apos;m working on fixing broken links etc so please let me know if you hit any problems).</z><z id="t1613294222" t="kwrooijen Reading the docs now. I&apos;m really happy with some of these changes (written in differences-fromt-1-x.md ) 😍"><y>#</y><d>2021-02-14</d><h>09:17</h><w>kwrooijen</w>Reading the docs now. I&apos;m really happy with some of these changes (written in <code>differences-fromt-1-x.md</code> ) <b>😍</b></z><z id="t1613294290" t="kwrooijen The removal of the reader literals is especially great"><y>#</y><d>2021-02-14</d><h>09:18</h><w>kwrooijen</w>The removal of the reader literals is especially great</z><z id="t1613294366" t="kwrooijen The new :cast keyword is actually going to fix a nasty bug for me"><y>#</y><d>2021-02-14</d><h>09:19</h><w>kwrooijen</w>The new <code>:cast</code> keyword is actually going to fix a nasty bug for me</z><z id="t1613294504" t="kwrooijen If you try to insert an empty array in Postgres without casting the type it&apos;ll actually fail. (Not sure why Postgres needs to know the type of the data if it&apos;s empty but ok). Now that I don&apos;t need to use sql/call this might actually be easier for me"><y>#</y><d>2021-02-14</d><h>09:21</h><w>kwrooijen</w>If you try to insert an empty array in Postgres without casting the type it&apos;ll actually fail. (Not sure why Postgres needs to know the type of the data if it&apos;s empty but ok). Now that I don&apos;t need to use <code>sql/call</code> this might actually be easier for me</z><z id="t1613295177" t="kwrooijen It&apos;s going to be some work to upgrade to 2.0. Mainly because of this https://github.com/seancorfield/honeysql/issues/276 [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] any chance you thought about this? Of if you&apos;d want to implement something like this at all?"><y>#</y><d>2021-02-14</d><h>09:32</h><w>kwrooijen</w>It&apos;s going to be some work to upgrade to 2.0. Mainly because of this <a href="https://github.com/seancorfield/honeysql/issues/276" target="_blank">https://github.com/seancorfield/honeysql/issues/276</a>
<a>@seancorfield</a> any chance you thought about this? Of if you&apos;d want to implement something like this at all?</z><z id="t1613326002" t="seancorfield [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] I&apos;m open to suggestions while it&apos;s still in alpha."><y>#</y><d>2021-02-14</d><h>18:06</h><w>seancorfield</w><a>@kevin.van.rooijen</a> I&apos;m open to suggestions while it&apos;s still in alpha.</z><z id="t1613326136" t="seancorfield My initial reading of Gungnir&apos;s purpose is that it feels like something that should applied to SQL execution rather than SQL generation."><y>#</y><d>2021-02-14</d><h>18:08</h><w>seancorfield</w>My initial reading of Gungnir&apos;s purpose is that it feels like something that should applied to SQL execution rather than SQL generation.</z><z id="t1613391016" t="kwrooijen What do you mean by execution? Simple Gungnir usecase: Query: {:select :* :from :user :where [:= :user/email &quot; Transformation: string/lower-case :user/email Result: {:select :* :from :user :where [:= :user/email &quot;"><y>#</y><d>2021-02-15</d><h>12:10</h><r>kwrooijen</r>What do you mean by execution?
Simple Gungnir usecase:

Query:

<pre>{:select :* :from :user :where [:= :user/email &quot;</pre>
Transformation:
<pre>string/lower-case :user/email</pre>
Result:

<pre>{:select :* :from :user :where [:= :user/email &quot;</pre></z><z id="t1613410977" t="seancorfield [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] I mean that the transformation &quot;doesn&apos;t matter&quot; until the value is about to be stored into the DB or has just been retrieved from the DB. You&apos;ve attached Gungnir to SQL generation but a similar transformation could be done against next.jdbc around the setting of parameters and the reading of SQL values back from the DB."><y>#</y><d>2021-02-15</d><h>17:42</h><r>seancorfield</r><a>@kevin.van.rooijen</a> I mean that the transformation &quot;doesn&apos;t matter&quot; until the value is about to be stored into the DB or has just been retrieved from the DB. You&apos;ve attached Gungnir to SQL generation but a similar transformation could be done against <code>next.jdbc</code> around the setting of parameters and the reading of SQL values back from the DB.</z><z id="t1613411846" t="seancorfield I&apos;ll take a deeper look at Gungnir over the next week or two and discuss my thoughts in more detail after that -- but my gut reaction is that attaching this to the set parameter / read result set functionality in next.jdbc would be &quot;better&quot; because then it would operate on things like update! and insert! from next.jdbc.sql ."><y>#</y><d>2021-02-15</d><h>17:57</h><r>seancorfield</r>I&apos;ll take a deeper look at Gungnir over the next week or two and discuss my thoughts in more detail after that -- but my gut reaction is that attaching this to the set parameter / read result set functionality in <code>next.jdbc</code> would be &quot;better&quot; because then it would operate on things like <code>update!</code> and <code>insert!</code> from <code>next.jdbc.sql</code>.</z><z id="t1613416475" t="kwrooijen I mean that the transformation &quot;doesn&apos;t matter&quot; until the value is about to be stored into the DB or has just been retrieved from the DB. I don&apos;t think this is correct. Because I&apos;m lower-casing the email in my query, not the resulting values. This is so that I don&apos;t have any case matching issues"><y>#</y><d>2021-02-15</d><h>19:14</h><r>kwrooijen</r><code>I mean that the transformation &quot;doesn&apos;t matter&quot; until the value is about to be stored into the DB or has just been retrieved from the DB.</code>
I don&apos;t think this is correct. Because I&apos;m lower-casing the email in my query, not the resulting values. This is so that I don&apos;t have any case matching issues</z><z id="t1613416643" t="kwrooijen But maybe this can be solved in next.jdbc as you said"><y>#</y><d>2021-02-15</d><h>19:17</h><r>kwrooijen</r>But maybe this can be solved in next.jdbc as you said</z><z id="t1613417647" t="seancorfield You misunderstand: You need the parameter lowercased before you store it into the parameter, as part of the prepared statement setup, for your query. Which could happen in next.jdbc &apos;s set-parameter -- and which would then apply to all of the ways you could run queries, not just those that go through HoneySQL."><y>#</y><d>2021-02-15</d><h>19:34</h><r>seancorfield</r>You misunderstand: You need the parameter lowercased before you store it into the parameter, as part of the prepared statement setup, for your query. Which could happen in <code>next.jdbc</code>&apos;s <code>set-parameter</code> -- and which would then apply to all of the ways you could run queries, not just those that go through HoneySQL.</z><z id="t1613417747" t="seancorfield And if this was wrapped around next.jdbc , Gungnir could also transform values coming back from the DB if needed -- although that is orthogonal."><y>#</y><d>2021-02-15</d><h>19:35</h><r>seancorfield</r>And if this was wrapped around <code>next.jdbc</code>, Gungnir could also transform values coming back from the DB if needed -- although that is orthogonal.</z><z id="t1613417985" t="seancorfield To illustrate my point: if you do (jdbc/execute! ds (-&gt; (select :*) (from :user) (where [:= :user/email &quot; Gungnir would intercept that but if you did (sql/find-by-keys ds :user {:user/email &quot; it wouldn&apos;t -- with Gungnir based on HoneySQL; but Gungnir could intercept the second version as well if it was based on next.jdbc . Does that make more sense?"><y>#</y><d>2021-02-15</d><h>19:39</h><r>seancorfield</r>To illustrate my point: if you do <code>(jdbc/execute! ds (-&gt; (select :*) (from :user) (where [:= :user/email &quot;</code> Gungnir would intercept that but if you did <code>(sql/find-by-keys ds :user {:user/email &quot;</code> it wouldn&apos;t -- with Gungnir based on HoneySQL; but Gungnir could intercept the second version as well if it was based on <code>next.jdbc</code>. Does that make more sense?</z><z id="t1613421442" t="kwrooijen Right, so basically what I&apos;m doing now could be handled with set-params . I&apos;ll take a look at that this week then, sounds like a much better solution"><y>#</y><d>2021-02-15</d><h>20:37</h><r>kwrooijen</r>Right, so basically what I&apos;m doing now could be handled with <code>set-params</code>. I&apos;ll take a look at that this week then, sounds like a much better solution</z><z id="t1613421885" t="seancorfield Feel free to ping me if you have Qs -- the qualified name is not present by the time set-parameter is called but the metadata, available through the PreparedStatement , may provide enough information."><y>#</y><d>2021-02-15</d><h>20:44</h><r>seancorfield</r>Feel free to ping me if you have Qs -- the qualified name is not present by the time <code>set-parameter</code> is called but the metadata, available through the <code>PreparedStatement</code>, may provide enough information.</z><z id="t1613421952" t="seancorfield And although clojure.java.jdbc has a different protocol, the machinery should be the same, so you could have one ns for next.jdbc and a separate ns for c.j.j if you wanted to support both libraries."><y>#</y><d>2021-02-15</d><h>20:45</h><r>seancorfield</r>And although <code>clojure.java.jdbc</code> has a different protocol, the machinery should be the same, so you could have one ns for <code>next.jdbc</code> and a separate ns for c.j.j if you wanted to support both libraries.</z><z id="t1613422165" t="kwrooijen I&apos;m already using some features from next.jdbc so it&apos;s already required 🙂"><y>#</y><d>2021-02-15</d><h>20:49</h><r>kwrooijen</r>I&apos;m already using some features from <code>next.jdbc</code> so it&apos;s already required <b>🙂</b></z><z id="t1613422169" t="kwrooijen Thanks for the tip"><y>#</y><d>2021-02-15</d><h>20:49</h><r>kwrooijen</r>Thanks for the tip</z><z id="t1613422499" t="seancorfield I just took another look at it and I don&apos;t think there&apos;s enough metadata to figure it out: the parameter metadata only has type information and no concept of naming; and the result set metadata is about what comes back not what goes in."><y>#</y><d>2021-02-15</d><h>20:54</h><r>seancorfield</r>I just took another look at it and I don&apos;t think there&apos;s enough metadata to figure it out: the parameter metadata only has type information and no concept of naming; and the result set metadata is about what comes back not what goes in.</z><z id="t1613422563" t="seancorfield Which means the level you need access to is above the SQL statement / parameters, unfortunately. 😞"><y>#</y><d>2021-02-15</d><h>20:56</h><r>seancorfield</r>Which means the level you need access to is above the SQL statement / parameters, unfortunately. <b>😞</b></z><z id="t1613423145" t="kwrooijen Hmm that&apos;s unfortunate"><y>#</y><d>2021-02-15</d><h>21:05</h><r>kwrooijen</r>Hmm that&apos;s unfortunate</z><z id="t1613423244" t="kwrooijen Is it possible to patch this to add the extra metadata?"><y>#</y><d>2021-02-15</d><h>21:07</h><r>kwrooijen</r>Is it possible to patch this to add the extra metadata?</z><z id="t1613423257" t="kwrooijen Would be a good excuse for me to dive into next.jdbc"><y>#</y><d>2021-02-15</d><h>21:07</h><r>kwrooijen</r>Would be a good excuse for me to dive into next.jdbc</z><z id="t1613424293" t="seancorfield Yes, you could extend the protocol via metadata on a value-by-value basis -- the trick I&apos;ve been using is to wrap the value in a function (`constantly`) so the protocol implementation can easily retrieve the original value."><y>#</y><d>2021-02-15</d><h>21:24</h><r>seancorfield</r>Yes, you could extend the protocol via metadata on a value-by-value basis -- the trick I&apos;ve been using is to wrap the value in a function (`constantly`) so the protocol implementation can easily retrieve the original value.</z><z id="t1613424310" t="seancorfield That&apos;s how the next.jdbc.types type adapters work."><y>#</y><d>2021-02-15</d><h>21:25</h><r>seancorfield</r>That&apos;s how the <code>next.jdbc.types</code> type adapters work.</z><z id="t1613424381" t="seancorfield I&apos;ve just been looking at the Gungnir source code: it looks like it overrides a specific set of operators within HoneySQL to provide the before-read transform of the values associated with certain (qualified) keywords -- is that accurate?"><y>#</y><d>2021-02-15</d><h>21:26</h><r>seancorfield</r>I&apos;ve just been looking at the Gungnir source code: it looks like it overrides a specific set of operators within HoneySQL to provide the <code>before-read</code> transform of the values associated with certain (qualified) keywords -- is that accurate?</z><z id="t1613424501" t="seancorfield (and it also wraps some of next.jdbc to achieve the same thing directly with insert! and update! ?)"><y>#</y><d>2021-02-15</d><h>21:28</h><r>seancorfield</r>(and it also wraps some of <code>next.jdbc</code> to achieve the same thing directly with <code>insert!</code> and <code>update!</code>?)</z><z id="t1613426595" t="kwrooijen Right, with Gungnir you can transform specific qualified-keywords defined in the model https://kwrooijen.github.io/gungnir/model.html It supports three things: :before-save - Done within gungnir, separate from HSQL / NJ :before-read - Patched version of HSQL (linked in the issue of HSQL) :after-read - custom result-set builder with NJ https://github.com/kwrooijen/gungnir/blob/master/src/clj/gungnir/database/builder.clj"><y>#</y><d>2021-02-15</d><h>22:03</h><r>kwrooijen</r>Right, with Gungnir you can transform specific qualified-keywords defined in the model <a href="https://kwrooijen.github.io/gungnir/model.html" target="_blank">https://kwrooijen.github.io/gungnir/model.html</a>
It supports three things:
<code>:before-save</code> - Done within gungnir, separate from HSQL / NJ
<code>:before-read</code> - Patched version of HSQL (linked in the issue of HSQL)
<code>:after-read</code> - custom result-set builder with NJ <a href="https://github.com/kwrooijen/gungnir/blob/master/src/clj/gungnir/database/builder.clj" target="_blank">https://github.com/kwrooijen/gungnir/blob/master/src/clj/gungnir/database/builder.clj</a></z><z id="t1613426648" t="kwrooijen You can read me model document for the use cases / how they are implemented by the end-user. It&apos;s all based on qualified keywords"><y>#</y><d>2021-02-15</d><h>22:04</h><r>kwrooijen</r>You can read me model document for the use cases / how they are implemented by the end-user. It&apos;s all based on qualified keywords</z><z id="t1613426782" t="seancorfield Given HoneySQL v2&apos;s recursive descent formatting -- which is independent of the actual operators/function calls being used -- it&apos;s certainly a lot harder to implement a hook like that. I&apos;ll continue to give it some thought."><y>#</y><d>2021-02-15</d><h>22:06</h><r>seancorfield</r>Given HoneySQL v2&apos;s recursive descent formatting -- which is independent of the actual operators/function calls being used -- it&apos;s certainly a lot harder to implement a hook like that. I&apos;ll continue to give it some thought.</z><z id="t1613427014" t="kwrooijen All right. I&apos;m a bit in between projects right now so Gungnir doesn&apos;t have my highest priority at the moment. Worst case I&apos;d have to walk the HSQL datastructure but hopefully we can prevent that"><y>#</y><d>2021-02-15</d><h>22:10</h><r>kwrooijen</r>All right. I&apos;m a bit in between projects right now so Gungnir doesn&apos;t have my highest priority at the moment. Worst case I&apos;d have to walk the HSQL datastructure but hopefully we can prevent that</z><z id="t1613428445" t="seancorfield What would you do with an expression like this in Gungnir? (where [:= :user/email [:|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;]])"><y>#</y><d>2021-02-15</d><h>22:34</h><r>seancorfield</r>What would you do with an expression like this in Gungnir? <code>(where [:= :user/email [:|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;]])</code></z><z id="t1613428532" t="seancorfield (it would produce [&quot;... WHERE email = CONCAT(?, ?, ?)&quot; &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;] )"><y>#</y><d>2021-02-15</d><h>22:35</h><r>seancorfield</r>(it would produce <code>[&quot;... WHERE email = CONCAT(?, ?, ?)&quot; &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;]</code>)</z><z id="t1613459500" t="kwrooijen the [;|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;] part would be in the user defined part. So you&apos;d for example have this (end-user defined) (defmethod gungnir.model/before-read :string/lower-case [_k v] (clojure.string/lower-case v)) And v woul be [;|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;] . So the end-user can decide what to do with it"><y>#</y><d>2021-02-16</d><h>07:11</h><r>kwrooijen</r>the <code>[;|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;]</code> part would be in the user defined part. So you&apos;d for example have this (end-user defined)
<pre>(defmethod gungnir.model/before-read :string/lower-case [_k v]
  (clojure.string/lower-case v))</pre>
And <code>v</code> woul be <code>[;|| &quot;KEVIN&quot; &quot;@&quot; &quot;&quot;]</code> . So the end-user can decide what to do with it</z><z id="t1613459540" t="kwrooijen (In this example it would fail because we&apos;re using string/lower-case on a vector, but the user could change that)"><y>#</y><d>2021-02-16</d><h>07:12</h><r>kwrooijen</r>(In this example it would fail because we&apos;re using <code>string/lower-case</code> on a vector, but the user could change that)</z><z id="t1613494696" t="seancorfield [:attrs {:href &quot;/_/_/users/UG9U7TPDZ&quot;}] Ah, good to know. OK, that gives me some ideas then..."><y>#</y><d>2021-02-16</d><h>16:58</h><r>seancorfield</r><a>@kevin.van.rooijen</a> Ah, good to know. OK, that gives me some ideas then...</z><z id="t1613494733" t="kwrooijen Let me know if you need any more info (sorry for the occasional late replies, timezones 😄 )"><y>#</y><d>2021-02-16</d><h>16:58</h><r>kwrooijen</r>Let me know if you need any more info (sorry for the occasional late replies, timezones <b>😄</b> )</z><z id="t1613494824" t="seancorfield To be expected when I&apos;m on Pacific time and you&apos;re on Dutch(?) time 🙂"><y>#</y><d>2021-02-16</d><h>17:00</h><r>seancorfield</r>To be expected when I&apos;m on Pacific time and you&apos;re on Dutch(?) time <b>🙂</b></z><z id="t1613495099" t="kwrooijen Yep"><y>#</y><d>2021-02-16</d><h>17:04</h><r>kwrooijen</r>Yep</z><z id="t1613328161" t="seancorfield I have fixed the docs on http://cljdoc.org now: https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme"><y>#</y><d>2021-02-14</d><h>18:42</h><w>seancorfield</w>I have fixed the docs on <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a> now: <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme</a></z><z id="t1613339274" t="athomasoriginal Just upgraded my side project to V2 (10k loc all clojure)! Everything is working well and the upgrade went smoothly. Thanks for everything Sean and let me know if there is anything I can test!"><y>#</y><d>2021-02-14</d><h>21:47</h><w>athomasoriginal</w>Just upgraded my side project to V2 (10k loc all clojure)!  Everything is working well and the upgrade went smoothly.  Thanks for everything Sean and let me know if there is anything I can test!</z><z id="t1613339345" t="seancorfield Oh, nice! Thank you!"><y>#</y><d>2021-02-14</d><h>21:49</h><w>seancorfield</w>Oh, nice! Thank you!</z><z id="t1613339371" t="seancorfield What database are you using [:attrs {:href &quot;/_/_/users/U6GNVEWQG&quot;}] ?"><y>#</y><d>2021-02-14</d><h>21:49</h><w>seancorfield</w>What database are you using <a>@tkjone</a>?</z><z id="t1613339382" t="athomasoriginal Postgres 😉"><y>#</y><d>2021-02-14</d><h>21:49</h><w>athomasoriginal</w>Postgres <b>😉</b></z><z id="t1613339391" t="athomasoriginal Because of the upgrade I was able to • simplify helper functions built around sql/call , • remove nilenso • gain clarity on my queries using postgres specific functions"><y>#</y><d>2021-02-14</d><h>21:49</h><w>athomasoriginal</w>Because of the upgrade I was able to

• simplify helper functions built around <code>sql/call</code>, 
• remove nilenso
• gain clarity on my queries using postgres specific functions</z><z id="t1613339397" t="seancorfield Do you use the nilenso lib?"><y>#</y><d>2021-02-14</d><h>21:49</h><w>seancorfield</w>Do you use the nilenso lib?</z><z id="t1613339474" t="athomasoriginal haha well, not anymore 🙂"><y>#</y><d>2021-02-14</d><h>21:51</h><w>athomasoriginal</w>haha well, not anymore <b>🙂</b></z><z id="t1613339627" t="athomasoriginal The areas I can see future upgraders maybe having challenges is if, as you mentioned, there is use of nilenso but one forgot which keywords were nilenso specific. Not a big deal, I just totally forgot I was using exists [UPDATE]: The above issue is unrelated to the nilenso library. It was undocumented behaviour from HoneySQL V1. See the convo in the thread below"><y>#</y><d>2021-02-14</d><h>21:53</h><w>athomasoriginal</w>The areas I can see future upgraders maybe having challenges is if, as you mentioned, there is use of <code>nilenso</code> but one forgot which keywords were <code>nilenso</code> specific.  Not a big deal, I just totally forgot I was using <code>exists</code>

[UPDATE]: The above issue is unrelated to the <code>nilenso</code> library.  It was undocumented behaviour from HoneySQL V1.  See the convo in the thread below</z><z id="t1613339768" t="athomasoriginal Only other points of momentary confusion: • The switch from hsql/call to :function-name - but you have that well documented, I for some reason spaced when reading it • Switch from format/value to :lift - again, well documented, but I was looking for it in the V1 to V2 transition guide. Again, my assumption getting the best of me haha"><y>#</y><d>2021-02-14</d><h>21:56</h><w>athomasoriginal</w>Only other points of momentary confusion:

• The switch from <code>hsql/call</code> to <code>:function-name</code> - but you have that well documented, I for some reason spaced when reading it
• Switch from <code>format/value</code> to <code>:lift</code> - again, well documented, but I was looking for it in the V1 to V2 transition guide.  Again, my assumption getting the best of me haha</z><z id="t1613339780" t="seancorfield The only references to exists I see in the nilenso lib are as part of the if-exists / if-not-exists around create/drop table/extension?"><y>#</y><d>2021-02-14</d><h>21:56</h><w>seancorfield</w>The only references to <code>exists</code> I see in the nilenso lib are as part of the if-exists / if-not-exists around create/drop table/extension?</z><z id="t1613339848" t="athomasoriginal hmm. One sec. Let me look at the sql that was failing one more time."><y>#</y><d>2021-02-14</d><h>21:57</h><r>athomasoriginal</r>hmm.  One sec.  Let me look at the sql that was failing one more time.</z><z id="t1613340452" t="athomasoriginal This is the line I was successfully using with nilenso (-&gt;&gt; {:exists {:select [:datname] :from [:pg_catalog.pg_database] :where [:= :datname dbname]}} (hsql/format))) and when I run the above with hsql 2 I get this exception: &quot;Unknown SQL clauses: :exists&quot;"><y>#</y><d>2021-02-14</d><h>22:07</h><r>athomasoriginal</r>This is the line I was successfully using with <code>nilenso</code>

<pre>(-&gt;&gt; {:exists
        {:select [:datname]
         :from   [:pg_catalog.pg_database]
         :where  [:= :datname dbname]}}
       (hsql/format)))</pre>
and when I run the above with hsql 2 I get this exception:

<pre>&quot;Unknown SQL clauses: :exists&quot;</pre></z><z id="t1613340515" t="athomasoriginal To get it to work I updated it to {:select [[[:exists {:select ...}]]]}"><y>#</y><d>2021-02-14</d><h>22:08</h><r>athomasoriginal</r>To get it to work I updated it to

<pre>{:select [[[:exists {:select ...}]]]}</pre></z><z id="t1613340658" t="seancorfield Hmm, interesting. I can&apos;t find any mention of that in nilenso&apos;s code."><y>#</y><d>2021-02-14</d><h>22:10</h><r>seancorfield</r>Hmm, interesting. I can&apos;t find any mention of that in nilenso&apos;s code.</z><z id="t1613340692" t="seancorfield Ah, it&apos;s an undocumented part of HoneySQL 1.x!"><y>#</y><d>2021-02-14</d><h>22:11</h><r>seancorfield</r>Ah, it&apos;s an undocumented part of HoneySQL 1.x!</z><z id="t1613340751" t="athomasoriginal Shoot! My bad!! but that makes sense! After a while, I would have to read H1 source more and more to figure out how to do something."><y>#</y><d>2021-02-14</d><h>22:12</h><r>athomasoriginal</r>Shoot!  My bad!! but that makes sense!   After a while, I would have to read H1 source more and more to figure out how to do something.</z><z id="t1613340760" t="seancorfield But I did migrate it -- it just needs to be added to the migration doc and probably elsewhere: ;; EXISTS should never have been implemented as SQL syntax: it&apos;s an operator! #_(is (= (format {:exists {:select [:a] :from [:foo]}}) [&quot;EXISTS (SELECT a FROM foo)&quot;])) ;; select function call with an alias: (is (= (format {:select [[[:exists {:select [:a] :from [:foo]}] :x]]}) [&quot;SELECT EXISTS (SELECT a FROM foo) AS x&quot;]))"><y>#</y><d>2021-02-14</d><h>22:12</h><r>seancorfield</r>But I did migrate it -- it just needs to be added to the migration doc and probably elsewhere:
<pre>;; EXISTS should never have been implemented as SQL syntax: it&apos;s an operator!
  #_(is (= (format {:exists {:select [:a] :from [:foo]}})
           [&quot;EXISTS (SELECT a FROM foo)&quot;]))
  ;; select function call with an alias:
  (is (= (format {:select [[[:exists {:select [:a] :from [:foo]}] :x]]})
         [&quot;SELECT EXISTS (SELECT a FROM foo) AS x&quot;]))</pre></z><z id="t1613340782" t="seancorfield (that&apos;s from the v2 tests)"><y>#</y><d>2021-02-14</d><h>22:13</h><r>seancorfield</r>(that&apos;s from the v2 tests)</z><z id="t1613340880" t="athomasoriginal Nice, so it won’t be allowed to be used as SQL syntax, correct?"><y>#</y><d>2021-02-14</d><h>22:14</h><r>athomasoriginal</r>Nice, so it won’t be allowed to be used as SQL syntax, correct?</z><z id="t1613341078" t="seancorfield It never should have been allowed -- that was a bug in how it was added 😞"><y>#</y><d>2021-02-14</d><h>22:17</h><r>seancorfield</r>It never should have been allowed -- that was a bug in how it was added <b>😞</b></z><z id="t1613341112" t="seancorfield It was added way back in 0.5.3"><y>#</y><d>2021-02-14</d><h>22:18</h><r>seancorfield</r>It was added way back in 0.5.3</z><z id="t1613341147" t="athomasoriginal 🙈"><y>#</y><d>2021-02-14</d><h>22:19</h><r>athomasoriginal</r><b>🙈</b></z><z id="t1613341149" t="seancorfield I added it to the differences doc: https://github.com/seancorfield/honeysql/commit/2af7d0b6902b149c442f43d1ecf23473108fb585"><y>#</y><d>2021-02-14</d><h>22:19</h><r>seancorfield</r>I added it to the differences doc: <a href="https://github.com/seancorfield/honeysql/commit/2af7d0b6902b149c442f43d1ecf23473108fb585" target="_blank">https://github.com/seancorfield/honeysql/commit/2af7d0b6902b149c442f43d1ecf23473108fb585</a></z><z id="t1613341203" t="athomasoriginal Very nice!!!"><y>#</y><d>2021-02-14</d><h>22:20</h><r>athomasoriginal</r>Very nice!!!</z><z id="t1613339923" t="seancorfield Ah, I totally missed format/value -- I&apos;ll add that to the migration doc and the :lift special syntax. Thanks."><y>#</y><d>2021-02-14</d><h>21:58</h><w>seancorfield</w>Ah, I totally missed <code>format/value</code> -- I&apos;ll add that to the migration doc and the <code>:lift</code> special syntax. Thanks.</z><z id="t1613340038" t="seancorfield (docs updated)"><y>#</y><d>2021-02-14</d><h>22:00</h><w>seancorfield</w>(docs updated)</z><z id="t1613475736" t="zackteo Hello! I was looking for a query builder for PostGIS and was directed to HoneySQL. I understand that there is no PostGIS support but might something like this work through JDBC? (def postgis-map {:select [:city/name :state/name :city/geom] :from [:city] :join [:state (sql/raw [&quot;ST_Intersects(&quot; :city/geom &quot;, &quot; :state/geom &quot;)&quot;])]}) (sql/format postgis-map :namespace-as-table? true) ;; =&gt; [&quot;SELECT city.name, state.name, city.geom FROM city INNER JOIN state ON ST_Intersects(city.geom, state.geom)&quot;] Am trying to see if I can compose PostGIS queries by simply using sql/raw and sql/forma which seems to work 🙂 Any advice on how I might want to improve my approach to this? And just wondering if there is anything I should be aware of when linking up to JDBC to PostgreSQL + PostGIS (extension)"><y>#</y><d>2021-02-16</d><h>11:42</h><w>zackteo</w>Hello! I was looking for a query builder for PostGIS and was directed to HoneySQL. I understand that there is no PostGIS support but might something like this work through JDBC?
<pre>(def postgis-map {:select [:city/name :state/name :city/geom]
                  :from   [:city]
                  :join   [:state (sql/raw [&quot;ST_Intersects(&quot; :city/geom &quot;, &quot; :state/geom &quot;)&quot;])]})

(sql/format postgis-map :namespace-as-table? true)
;; =&gt; [&quot;SELECT city.name, state.name, city.geom FROM city INNER JOIN state ON ST_Intersects(city.geom, state.geom)&quot;]</pre>
Am trying to see if I can compose PostGIS queries by simply using <code>sql/raw</code> and <code>sql/forma</code> which seems to work <b>🙂</b>

Any advice on how I might want to improve my approach to this? And just wondering if there is anything I should be aware of when linking up to JDBC to PostgreSQL + PostGIS (extension)</z><z id="t1613475772" t="dharrigan That&apos;s the approach I take"><y>#</y><d>2021-02-16</d><h>11:42</h><w>dharrigan</w>That&apos;s the approach I take</z><z id="t1613475776" t="dharrigan It works fine"><y>#</y><d>2021-02-16</d><h>11:42</h><w>dharrigan</w>It works fine</z><z id="t1613475790" t="dharrigan With honeysql v2, out in due course, it becomes a lot easier"><y>#</y><d>2021-02-16</d><h>11:43</h><w>dharrigan</w>With honeysql v2, out in due course, it becomes a lot easier</z><z id="t1613475849" t="dharrigan i.e.,"><y>#</y><d>2021-02-16</d><h>11:44</h><w>dharrigan</w>i.e.,</z><z id="t1613475851" t="dharrigan (defn location-&gt;st-point [{:keys [lat lng] :as location}] [[:ST_SetSRID [:ST_MakePoint (round6 lng) (round6 lat)] [:cast 4326 :integer]]])"><y>#</y><d>2021-02-16</d><h>11:44</h><w>dharrigan</w><pre>(defn location-&gt;st-point
  [{:keys [lat lng] :as location}]
  [[:ST_SetSRID [:ST_MakePoint (round6 lng) (round6 lat)] [:cast 4326 :integer]]])</pre></z><z id="t1613475871" t="dharrigan anything starting with a : is interpreted as a function call"><y>#</y><d>2021-02-16</d><h>11:44</h><w>dharrigan</w>anything starting with a <code>:</code> is interpreted as a function call</z><z id="t1613475901" t="dharrigan (that is in honeysql v2 syntax)"><y>#</y><d>2021-02-16</d><h>11:45</h><w>dharrigan</w>(that is in honeysql v2 syntax)</z><z id="t1613481294" t="zackteo Cool, excited to get this working! 🙂"><y>#</y><d>2021-02-16</d><h>13:14</h><w>zackteo</w>Cool, excited to get this working! <b>🙂</b></z><z id="t1613481309" t="zackteo On a sidenote, is there a place I can look at the unstable(?) implementation of honeysql v2?"><y>#</y><d>2021-02-16</d><h>13:15</h><w>zackteo</w>On a sidenote, is there a place I can look at the unstable(?) implementation of honeysql v2?</z><z id="t1613481836" t="dharrigan yes"><y>#</y><d>2021-02-16</d><h>13:23</h><w>dharrigan</w>yes</z><z id="t1613481861" t="dharrigan seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha1&quot;}"><y>#</y><d>2021-02-16</d><h>13:24</h><w>dharrigan</w><code>seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha1&quot;}</code></z><z id="t1613481877" t="dharrigan and https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme"><y>#</y><d>2021-02-16</d><h>13:24</h><w>dharrigan</w>and <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha1/doc/readme</a></z><z id="t1613494763" t="seancorfield [:attrs {:href &quot;/_/_/users/UUSQHP535&quot;}] Even 1.x supports PostGIS expressions -- there&apos;s a section in the README about it: https://github.com/seancorfield/honeysql/#postgis /cc [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}]"><y>#</y><d>2021-02-16</d><h>16:59</h><w>seancorfield</w><a>@zackteo</a> Even 1.x supports PostGIS expressions -- there&apos;s a section in the README about it: <a href="https://github.com/seancorfield/honeysql/#postgis" target="_blank">https://github.com/seancorfield/honeysql/#postgis</a> /cc <a>@dharrigan</a></z><z id="t1613494775" t="seancorfield (and, yes, 2.x makes this even easier)"><y>#</y><d>2021-02-16</d><h>16:59</h><w>seancorfield</w>(and, yes, 2.x makes this even easier)</z><z id="t1613534385" t="seancorfield seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha2&quot;} is available for testing. It&apos;s mostly an overhaul and expansion of the documentation around v2 but also includes a number of small bug fixes and improvements, mostly around the insert/upsert syntax for PostgreSQL. Everything in nilenso/honeysql-postgres is built-in for this release and mostly documented (there are some small differences) -- see: https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support and nearly all of the helper functions have docstrings now -- see: https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers"><y>#</y><d>2021-02-17</d><h>03:59</h><w>seancorfield</w><code>seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha2&quot;}</code> is available for testing. It&apos;s mostly an overhaul and expansion of the documentation around v2 but also includes a number of small bug fixes and improvements, mostly around the insert/upsert syntax for PostgreSQL. Everything in nilenso/honeysql-postgres is built-in for this release and mostly documented (there are some small differences) -- see: <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support</a> and nearly all of the helper functions have docstrings now -- see: <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers</a></z><z id="t1613534585" t="seancorfield At this point, the core API feels pretty stable to me and the overall shape and scope of the library also feels fairly well &quot;baked&quot; so I think it&apos;s mostly a matter of documentation to reach a &quot;gold&quot; 2.0 release, although I&apos;m still ploughing though the open issues from the 2.0 milestone: https://github.com/seancorfield/honeysql/milestone/7"><y>#</y><d>2021-02-17</d><h>04:03</h><w>seancorfield</w>At this point, the core API feels pretty stable to me and the overall shape and scope of the library also feels fairly well &quot;baked&quot; so I think it&apos;s mostly a matter of documentation to reach a &quot;gold&quot; 2.0 release, although I&apos;m still ploughing though the open issues from the 2.0 milestone: <a href="https://github.com/seancorfield/honeysql/milestone/7" target="_blank">https://github.com/seancorfield/honeysql/milestone/7</a></z><z id="t1613542996" t="zackteo Whoops. I think I might have glanced past that - and I think I might have been trying out how other forms of PostGIS queries might work. Looks like I can use sql/call for the most part then 🙂 and tap into sql/raw and sql/format for finer manipulation"><y>#</y><d>2021-02-17</d><h>06:23</h><w>zackteo</w>Whoops. I think I might have glanced past that - and I think I might have been trying out how other forms of PostGIS queries might work. Looks like I can use <code>sql/call</code> for the most part then <b>🙂</b> and tap into <code>sql/raw</code> and <code>sql/format</code> for finer manipulation</z><z id="t1613583722" t="seancorfield [:attrs {:href &quot;/_/_/users/UUSQHP535&quot;}] Yup, in 2.0 it&apos;s easier because you never need sql/call and sql/raw has just become a :raw &quot;function&quot; (and :inline is more powerful now too)."><y>#</y><d>2021-02-17</d><h>17:42</h><w>seancorfield</w><a>@zackteo</a> Yup, in 2.0 it&apos;s easier because you never need <code>sql/call</code> and <code>sql/raw</code> has just become a <code>:raw</code> &quot;function&quot; (and <code>:inline</code> is more powerful now too).</z><z id="t1613598174" t="borkdude Is there an option in honeysql to convert a sqlvec string (with question marks) and values into one string with the values embedded? This might be an anti-pattern but for shelling out I want to use this (just for a demo)"><y>#</y><d>2021-02-17</d><h>21:42</h><w>borkdude</w>Is there an option in honeysql to convert a sqlvec string (with question marks) and values into one string with the values embedded? This might be an anti-pattern but for shelling out I want to use this (just for a demo)</z><z id="t1613599297" t="borkdude :parameterizer does what I want, I think :)"><y>#</y><d>2021-02-17</d><h>22:01</h><w>borkdude</w><pre>:parameterizer</pre>
does what I want, I think :)</z><z id="t1613599688" t="seancorfield In 1.x, yes, :parameterizer but in 2.x, you can just pass :inline true to sql/format and it attempts to inline all parameters."><y>#</y><d>2021-02-17</d><h>22:08</h><w>seancorfield</w>In 1.x, yes, <code>:parameterizer</code> but in 2.x, you can just pass <code>:inline true</code> to <code>sql/format</code> and it attempts to inline all parameters.</z><z id="t1613599854" t="borkdude wow... I&apos;ll try!"><y>#</y><d>2021-02-17</d><h>22:10</h><w>borkdude</w>wow... I&apos;ll try!</z><z id="t1613600176" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] That worked. With babashka! I&apos;m writing a small demo for a presention. 1) First I show how shitty it is to write manual sql using string functions and send that through java.shell to sqlite. 2) Then I show that you can use honeysql to take care of the sql. (defn insert-sql [animals] (sql/format (-&gt; (h/insert-into :animals) (h/columns :name :scientific_name) (h/values (map (juxt :name :scientific-name) animals))) {:inline true})) (defn insert-rows! [animals] (let [sql (insert-sql animals) {:keys [:exit :err]} (query (first sql))] (when (not (zero? exit)) (println &quot;Error inserting var!&quot; err) (System/exit exit)))) (insert-rows! [{:name &quot;Bison&quot; :scientific-name &quot;Bos gaurus&quot;} {:name &quot;Duck&quot; :scientific-name &quot;Anas Platyrhynchos&quot;}]) 3) And then I show how to use the pod-babashka-sqlite3 pod so you don&apos;t need the :inline true option but can interact with sqlite as if it&apos;s a local library."><y>#</y><d>2021-02-17</d><h>22:16</h><w>borkdude</w><a>@seancorfield</a> That worked. With babashka! I&apos;m writing a small demo for a presention.
1) First I show how shitty it is to write manual sql using string functions and send that through java.shell to sqlite.
2) Then I show that you can use honeysql to take care of the sql.
<pre>(defn insert-sql [animals]
  (sql/format (-&gt; (h/insert-into :animals)
                  (h/columns :name :scientific_name)
                  (h/values (map (juxt :name :scientific-name)
                                 animals)))
              {:inline true}))

(defn insert-rows! [animals]
  (let [sql (insert-sql animals)
        {:keys [:exit :err]}
        (query (first sql))]
    (when (not (zero? exit))
      (println &quot;Error inserting var!&quot; err)
      (System/exit exit))))

(insert-rows! [{:name &quot;Bison&quot; :scientific-name &quot;Bos gaurus&quot;}
               {:name &quot;Duck&quot;  :scientific-name &quot;Anas Platyrhynchos&quot;}])</pre>
3) And then I show how to use the pod-babashka-sqlite3 pod so you don&apos;t need the <code>:inline true</code> option but can interact with sqlite as if it&apos;s a local library.</z><z id="t1613600243" t="seancorfield LMK if you run into anything in 2.0.0 that causes problems or you&apos;d like to see enhanced."><y>#</y><d>2021-02-17</d><h>22:17</h><w>seancorfield</w>LMK if you run into anything in 2.0.0 that causes problems or you&apos;d like to see enhanced.</z><z id="t1613600251" t="borkdude will do, so far so good"><y>#</y><d>2021-02-17</d><h>22:17</h><w>borkdude</w>will do, so far so good</z><z id="t1613600386" t="borkdude I was looking for something around create , I guess most people just do that as a raw string and not using data structures?"><y>#</y><d>2021-02-17</d><h>22:19</h><w>borkdude</w>I was looking for something around <code>create</code>, I guess most people just do that as a raw string and not using data structures?</z><z id="t1613600421" t="borkdude I don&apos;t really need it, I just wondered if there was something"><y>#</y><d>2021-02-17</d><h>22:20</h><w>borkdude</w>I don&apos;t really need it, I just wondered if there was something</z><z id="t1613600659" t="seancorfield As in create table ?"><y>#</y><d>2021-02-17</d><h>22:24</h><w>seancorfield</w>As in <code>create table</code>?</z><z id="t1613600732" t="seancorfield https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started#ddl-statements which leads you to https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support (because the DDL stuff all used to be in the nilenso library, but now it is supported in core)."><y>#</y><d>2021-02-17</d><h>22:25</h><w>seancorfield</w><a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started#ddl-statements" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started#ddl-statements</a> which leads you to <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/postgresql-support</a> (because the DDL stuff all used to be in the nilenso library, but now it is supported in core).</z><z id="t1613600783" t="seancorfield DDL documentation is the first section here: https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference and the helpers are all listed here https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers"><y>#</y><d>2021-02-17</d><h>22:26</h><w>seancorfield</w>DDL documentation is the first section here: <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference</a> and the helpers are all listed here <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/api/honey.sql.helpers</a></z><z id="t1613600806" t="borkdude ooh, thanks"><y>#</y><d>2021-02-17</d><h>22:26</h><w>borkdude</w>ooh, thanks</z><z id="t1613600850" t="seancorfield You can&apos;t -- currently -- add clauses to a create table statement after the column definitions, but that is coming maybe in the next alpha (since I need it for MySQL)."><y>#</y><d>2021-02-17</d><h>22:27</h><w>seancorfield</w>You can&apos;t -- currently -- add clauses to a <code>create table</code> statement after the column definitions, but that is coming maybe in the next alpha (since I need it for MySQL).</z><z id="t1613601028" t="borkdude Worked. (defn create-db! [] (when (not (.exists (io/file db))) (query (first (sql/format (-&gt; (h/create-table :animals) (h/with-columns [[:name :text] [:scientific-name :text]]))))))) "><y>#</y><d>2021-02-17</d><h>22:30</h><w>borkdude</w>Worked.
<pre>(defn create-db! []
  (when (not (.exists (io/file db)))
    (query (first
            (sql/format
             (-&gt; (h/create-table :animals)
                 (h/with-columns [[:name :text]
                                  [:scientific-name :text]])))))))</pre>
</z><z id="t1613601094" t="borkdude So for values in v1 I needed to do: (h/values (map (juxt :name :scientific-name) animals)) Does v2 maybe accept maps?"><y>#</y><d>2021-02-17</d><h>22:31</h><w>borkdude</w>So for values in v1 I needed to do:
<pre>(h/values (map (juxt :name :scientific-name)
                                 animals))</pre>
Does v2 maybe accept maps?</z></g><g id="s1"><z id="t1613601157" t="borkdude eh, I guess it does, reading this in the README now"><y>#</y><d>2021-02-17</d><h>22:32</h><w>borkdude</w>eh, I guess it does, reading this in the README now</z><z id="t1613601271" t="borkdude oh yes, it only works when you leave out the h/columns clause, is this expected?"><y>#</y><d>2021-02-17</d><h>22:34</h><w>borkdude</w>oh yes, it only works when you leave out the <code>h/columns</code> clause, is this expected?</z><z id="t1613601292" t="seancorfield Yes -- because the column names come from the (union of) the hash maps instea."><y>#</y><d>2021-02-17</d><h>22:34</h><w>seancorfield</w>Yes -- because the column names come from the (union of) the hash maps instea.</z><z id="t1613601310" t="borkdude I guess h/columns could act as select-keys maybe?"><y>#</y><d>2021-02-17</d><h>22:35</h><w>borkdude</w>I guess <code>h/columns</code> could act as <code>select-keys</code> maybe?</z><z id="t1613601344" t="seancorfield Maybe? Or maybe throw an exception if the h/columns are not in the hash map keys?"><y>#</y><d>2021-02-17</d><h>22:35</h><w>seancorfield</w>Maybe? Or maybe throw an exception if the <code>h/columns</code> are not in the hash map keys?</z><z id="t1613601350" t="seancorfield I can see arguments for both."><y>#</y><d>2021-02-17</d><h>22:35</h><w>seancorfield</w>I can see arguments for both.</z><z id="t1613601406" t="borkdude yeah, maybe the user should just map a select-keys over the maps first"><y>#</y><d>2021-02-17</d><h>22:36</h><w>borkdude</w>yeah, maybe the user should just map a select-keys over the maps first</z><z id="t1613601416" t="borkdude so the current behavior could stay as it is"><y>#</y><d>2021-02-17</d><h>22:36</h><w>borkdude</w>so the current behavior could stay as it is</z><z id="t1613601419" t="borkdude not sure"><y>#</y><d>2021-02-17</d><h>22:36</h><w>borkdude</w>not sure</z><z id="t1613601535" t="borkdude but right now it yields invalid sql when you combine columns + maps"><y>#</y><d>2021-02-17</d><h>22:38</h><w>borkdude</w>but right now it yields invalid sql when you combine columns + maps</z><z id="t1613601590" t="borkdude maybe throw in that case with a message like: you should explicitly format the maps yourself with the desired columns"><y>#</y><d>2021-02-17</d><h>22:39</h><w>borkdude</w>maybe throw in that case with a message like: you should explicitly format the maps yourself with the desired columns</z><z id="t1613601780" t="borkdude Afk now. Thanks for the improvements so far!"><y>#</y><d>2021-02-17</d><h>22:43</h><w>borkdude</w>Afk now. Thanks for the improvements so far!</z><z id="t1613729291" t="agile_geek Morning, I am looking for an example of how to add an as alias to a subquery?"><y>#</y><d>2021-02-19</d><h>10:08</h><w>agile_geek</w>Morning, I am looking for an example of how to add an <code>as</code> alias to a subquery?</z><z id="t1613730027" t="dharrigan Like this?"><y>#</y><d>2021-02-19</d><h>10:20</h><w>dharrigan</w>Like this?</z><z id="t1613730029" t="dharrigan user=&gt; (sql/format {:with [[:query {:select [:foo] :from [:bar]}]]}) [&quot;WITH query AS (SELECT foo FROM bar)&quot;]"><y>#</y><d>2021-02-19</d><h>10:20</h><w>dharrigan</w><pre>user=&gt; (sql/format {:with [[:query {:select [:foo] :from [:bar]}]]})
[&quot;WITH query AS (SELECT foo FROM bar)&quot;]</pre></z><z id="t1613730042" t="dharrigan "><y>#</y><d>2021-02-19</d><h>10:20</h><w>dharrigan</w><code></code></z><z id="t1613730078" t="dharrigan If not, maybe some of the tests might give a clue?"><y>#</y><d>2021-02-19</d><h>10:21</h><w>dharrigan</w>If not, maybe some of the tests might give a clue?</z><z id="t1613731159" t="borkdude"><y>#</y><d>2021-02-19</d><h>10:39</h><w>borkdude</w></z><z id="t1613732064" t="agile_geek Thx [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] . I think that {:with …} example might work but thru trial and error I found this worked: {:select [:sub.id] :from [[{:select [:id :name1 :name2]] :from [:table1] :modifiers [:distinct-on :name1 :name2] :order-by [:name1 :name2]} :sub]]} Suitably anonymised table names and columns plus sub query is simplified."><y>#</y><d>2021-02-19</d><h>10:54</h><w>agile_geek</w>Thx <a>@dharrigan</a> <a>@borkdude</a>. I think that <code>{:with …}</code>example might work but thru trial and error I found this worked:
<pre>{:select [:sub.id]
                 :from
                 [[{:select [:id :name1 :name2]]
                    :from [:table1]
                    :modifiers [:distinct-on :name1 :name2]
                    :order-by [:name1 :name2]} :sub]]}</pre>
Suitably anonymised table names and columns plus sub query is simplified.</z><z id="t1613732568" t="borkdude Sorry, the video wasn&apos;t related to your question, I just posted it here because it was about honeysql"><y>#</y><d>2021-02-19</d><h>11:02</h><r>borkdude</r>Sorry, the video wasn&apos;t related to your question, I just posted it here because it was about honeysql</z><z id="t1613732618" t="agile_geek Information is good, more information is better!"><y>#</y><d>2021-02-19</d><h>11:03</h><r>agile_geek</r>Information is good, more information is better!</z><z id="t1613732670" t="agile_geek I need to look at babashka as I think it may solve a bunch of issues with observability and debugging in my current client."><y>#</y><d>2021-02-19</d><h>11:04</h><r>agile_geek</r>I need to look at babashka as I think it may solve a bunch of issues with observability and debugging in my current client.</z><z id="t1613732439" t="dharrigan fantastic! 🙂"><y>#</y><d>2021-02-19</d><h>11:00</h><w>dharrigan</w>fantastic! <b>🙂</b></z><z id="t1613745272" t="aratare Hi there. Quick question about using HoneySQL/next.jdbc: Is there a nice or recommended way to handle conversion between dashes and underscores in keywords? There&apos;s :allow-dashed-names true but that&apos;s just allowing HoneySQL to include dashes in the formatted string. Thanks in advance."><y>#</y><d>2021-02-19</d><h>14:34</h><w>aratare</w>Hi there. Quick question about using HoneySQL/next.jdbc: Is there a nice or recommended way to handle conversion between dashes and underscores in keywords? There&apos;s :allow-dashed-names true but that&apos;s just allowing HoneySQL to include dashes in the formatted string. Thanks in advance.</z><z id="t1613745343" t="dharrigan In my code, I use dashes for keywords, i.e., tenant-id , that will automatically convert to tenant_id on the rendered SQL that goes out to the db."><y>#</y><d>2021-02-19</d><h>14:35</h><w>dharrigan</w>In my code, I use dashes for keywords, i.e., <code>tenant-id</code>, that will automatically convert to <code>tenant_id</code> on the rendered SQL that goes out to the db.</z><z id="t1613745346" t="dharrigan Not had an issue."><y>#</y><d>2021-02-19</d><h>14:35</h><w>dharrigan</w>Not had an issue.</z><z id="t1613745428" t="borkdude I actually showed that in the video earlier today and wondered where this was done. Later I saw this is in the format.clj namespace"><y>#</y><d>2021-02-19</d><h>14:37</h><w>borkdude</w>I actually showed that in the video earlier today and wondered where this was done. Later I saw this is in the format.clj namespace</z><z id="t1613745456" t="aratare Ah so it&apos;s automatic with no configuration I assume?"><y>#</y><d>2021-02-19</d><h>14:37</h><w>aratare</w>Ah so it&apos;s automatic with no configuration I assume?</z><z id="t1613745463" t="dharrigan not had to configure anything 🙂"><y>#</y><d>2021-02-19</d><h>14:37</h><w>dharrigan</w>not had to configure anything <b>🙂</b></z><z id="t1613745485" t="aratare Splendid! Thanks a lot 🙂"><y>#</y><d>2021-02-19</d><h>14:38</h><w>aratare</w>Splendid! Thanks a lot <b>🙂</b></z><z id="t1613745522" t="dharrigan you&apos;re most welcome"><y>#</y><d>2021-02-19</d><h>14:38</h><w>dharrigan</w>you&apos;re most welcome</z><z id="t1613745589" t="borkdude I recommend using v2 (the alpha one): it has cool new features, like passing in maps as values"><y>#</y><d>2021-02-19</d><h>14:39</h><w>borkdude</w>I recommend using v2 (the alpha one): it has cool new features, like passing in maps as values</z><z id="t1613745653" t="dharrigan Yes, I agree. If you&apos;re starting off on something new 🙂 I don&apos;t think it&apos;ll be that long before 2.0.0 Alpha2 becomes a beta, then a final 🙂"><y>#</y><d>2021-02-19</d><h>14:40</h><w>dharrigan</w>Yes, I agree. If you&apos;re starting off on something new <b>🙂</b> I don&apos;t think it&apos;ll be that long before 2.0.0 Alpha2 becomes a beta, then a final <b>🙂</b></z><z id="t1613745674" t="dharrigan I&apos;ve converted my applications to use honeysql v2 (on branches atm) works wonderfully well."><y>#</y><d>2021-02-19</d><h>14:41</h><w>dharrigan</w>I&apos;ve converted my applications to use honeysql v2 (on branches atm) works wonderfully well.</z><z id="t1613745676" t="dharrigan and easier too!"><y>#</y><d>2021-02-19</d><h>14:41</h><w>dharrigan</w>and easier too!</z><z id="t1613745898" t="aratare &gt; passing in maps as values How do you mean sorry?"><y>#</y><d>2021-02-19</d><h>14:44</h><w>aratare</w>&gt; passing in maps as values
How do you mean sorry?</z><z id="t1613745990" t="borkdude (helpers/values [{:a 1 :b 2}])"><y>#</y><d>2021-02-19</d><h>14:46</h><w>borkdude</w><code>(helpers/values [{:a 1 :b 2}])</code></z><z id="t1613746024" t="borkdude you must omit the column names if you are using that though"><y>#</y><d>2021-02-19</d><h>14:47</h><w>borkdude</w>you must omit the column names if you are using that though</z><z id="t1613746030" t="borkdude because they will be inferred from the maps"><y>#</y><d>2021-02-19</d><h>14:47</h><w>borkdude</w>because they will be inferred from the maps</z><z id="t1613746065" t="borkdude check the video above if you want to know how this works :)"><y>#</y><d>2021-02-19</d><h>14:47</h><w>borkdude</w>check the video above if you want to know how this works :)</z><z id="t1613746073" t="aratare I think that&apos;s already available in the current version? At least that&apos;s what the doc is telling me: (-&gt; (insert-into :properties) (values [{:name &quot;John&quot; :surname &quot;Smith&quot; :age 34} {:name &quot;Andrew&quot; :surname &quot;Cooper&quot; :age 12} {:name &quot;Jane&quot; :surname &quot;Daniels&quot; :age 56}]) sql/format)"><y>#</y><d>2021-02-19</d><h>14:47</h><w>aratare</w>I think that&apos;s already available in the current version? At least that&apos;s what the doc is telling me:
<pre>(-&gt; (insert-into :properties)
    (values [{:name &quot;John&quot; :surname &quot;Smith&quot; :age 34}
             {:name &quot;Andrew&quot; :surname &quot;Cooper&quot; :age 12}
             {:name &quot;Jane&quot; :surname &quot;Daniels&quot; :age 56}])
    sql/format)</pre></z><z id="t1613746096" t="borkdude oh really? I thought that was new, sorry"><y>#</y><d>2021-02-19</d><h>14:48</h><w>borkdude</w>oh really? I thought that was new, sorry</z><z id="t1613746110" t="aratare but totally agree that it is awesome to use 😄"><y>#</y><d>2021-02-19</d><h>14:48</h><w>aratare</w>but totally agree that it is awesome to use <b>😄</b></z><z id="t1613746158" t="dharrigan [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] would it be possible for honeysqlv2 support create/edit/drop materialized view ? which is the same as create view for postgresql?"><y>#</y><d>2021-02-19</d><h>14:49</h><w>dharrigan</w><a>@seancorfield</a> would it be possible for honeysqlv2 support <code>create/edit/drop materialized view</code>? which is the same as <code>create view</code> for postgresql?</z><z id="t1613746164" t="dharrigan would be supar handy"><y>#</y><d>2021-02-19</d><h>14:49</h><w>dharrigan</w>would be supar handy</z><z id="t1613746194" t="dharrigan I would replace this (-&gt; (sql/raw (str &quot;refresh materialized view &quot; view &quot; with data&quot;))"><y>#</y><d>2021-02-19</d><h>14:49</h><w>dharrigan</w>I would replace this <code>(-&gt; (sql/raw (str &quot;refresh materialized view &quot; view &quot; with data&quot;))</code></z><z id="t1613746207" t="dharrigan and (-&gt; (sql/raw (str &quot;create materialized view &quot; view &quot; with data&quot;))"><y>#</y><d>2021-02-19</d><h>14:50</h><w>dharrigan</w>and <code>(-&gt; (sql/raw (str &quot;create materialized view &quot; view &quot; with data&quot;))</code></z><z id="t1613746247" t="dharrigan I can raise a jira if you are willing, no issues if not 🙂"><y>#</y><d>2021-02-19</d><h>14:50</h><w>dharrigan</w>I can raise a jira if you are willing, no issues if not <b>🙂</b></z><z id="t1613746251" t="dharrigan jira!?"><y>#</y><d>2021-02-19</d><h>14:50</h><w>dharrigan</w>jira!?</z><z id="t1613746253" t="dharrigan wtf"><y>#</y><d>2021-02-19</d><h>14:50</h><w>dharrigan</w>wtf</z><z id="t1613746261" t="dharrigan I&apos;m too &quot;enterprisey&quot;"><y>#</y><d>2021-02-19</d><h>14:51</h><w>dharrigan</w>I&apos;m too &quot;enterprisey&quot;</z><z id="t1613749421" t="seancorfield Sure, create a GH issue so I don&apos;t forget."><y>#</y><d>2021-02-19</d><h>15:43</h><w>seancorfield</w>Sure, create a GH issue so I don&apos;t forget.</z><z id="t1613749429" t="dharrigan w00t"><y>#</y><d>2021-02-19</d><h>15:43</h><w>dharrigan</w>w00t</z><z id="t1613749882" t="dharrigan done. thank you."><y>#</y><d>2021-02-19</d><h>15:51</h><w>dharrigan</w>done. thank you.</z><z id="t1613753210" t="seancorfield Quick Q [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] Is create view different from create materialized view ?"><y>#</y><d>2021-02-19</d><h>16:46</h><w>seancorfield</w>Quick Q <a>@dharrigan</a> Is <code>create view</code> different from <code>create materialized view</code>?</z><z id="t1613753354" t="seancorfield Ah, yes, different syntax. So many options."><y>#</y><d>2021-02-19</d><h>16:49</h><w>seancorfield</w>Ah, yes, different syntax. So many options.</z><z id="t1613753503" t="dharrigan :thumbsup:"><y>#</y><d>2021-02-19</d><h>16:51</h><w>dharrigan</w><b>:thumbsup:</b></z><z id="t1613753554" t="dharrigan Not suggesting perhaps to support all the options, maybe even refresh materialized view &lt;blah&gt; with [no] data would be great 🙂"><y>#</y><d>2021-02-19</d><h>16:52</h><w>dharrigan</w>Not suggesting perhaps to support all the options, maybe even <code>refresh materialized view &lt;blah&gt; with [no] data</code> would be great <b>🙂</b></z><z id="t1614021729" t="seancorfield In case anyone missed this in #announcements"><y>#</y><d>2021-02-22</d><h>19:22</h><w>seancorfield</w>In case anyone missed this in #announcements</z><z id="t1614034112" t="devn I am using honeysql to generate a suffix which I then pass into sql.builder/for-insert-multi as an option. The trouble is that the suffix has a param named group , which needs to be quoted, otherwise PG is unhappy. Roughly it goes something like this: (let [suffix (first (hsql/format {:upsert {:on-conflict [:id] :do-update-set [:a :group :b]}})) insert-multi (sql.builder/for-insert-multi table cols rows {:suffix suffix :column-fn (fn [col] (format &quot;\&quot;%s\&quot;&quot; col))})] (jdbc/execute! ...))"><y>#</y><d>2021-02-22</d><h>22:48</h><w>devn</w>I am using honeysql to generate a suffix which I then pass into <code>sql.builder/for-insert-multi</code> as an option.

The trouble is that the suffix has a param named <code>group</code> , which needs to be quoted, otherwise PG is unhappy.

Roughly it goes something like this:

<pre>(let [suffix (first (hsql/format {:upsert {:on-conflict [:id] :do-update-set [:a :group :b]}}))
      insert-multi (sql.builder/for-insert-multi table cols rows {:suffix suffix :column-fn (fn [col] (format &quot;\&quot;%s\&quot;&quot; col))})]
  (jdbc/execute! ...))</pre></z><z id="t1614034149" t="devn i may just rename the column, but im curious if anyone has any bright ideas"><y>#</y><d>2021-02-22</d><h>22:49</h><w>devn</w>i may just rename the column, but im curious if anyone has any bright ideas</z><z id="t1614035287" t="seancorfield HoneySQL can do quoting for different databases: it&apos;s an option to hsql/format"><y>#</y><d>2021-02-22</d><h>23:08</h><w>seancorfield</w>HoneySQL can do quoting for different databases: it&apos;s an option to <code>hsql/format</code></z><z id="t1614035355" t="seancorfield If you&apos;re still using HoneySQL 1.0 or earlier: (hsql/format .. :quoting :ansi) If you&apos;re already using HoneySQL 2.0: (hsql/format .. {:quoted true}) (the ANSI dialect is the default)."><y>#</y><d>2021-02-22</d><h>23:09</h><w>seancorfield</w>If you&apos;re still using HoneySQL 1.0 or earlier: <code>(hsql/format .. :quoting :ansi)</code> If you&apos;re already using HoneySQL 2.0: <code>(hsql/format .. {:quoted true})</code> (the ANSI dialect is the default).</z><z id="t1614035368" t="seancorfield ^ [:attrs {:href &quot;/_/_/users/U06DQC6MA&quot;}] does that solve your problem?"><y>#</y><d>2021-02-22</d><h>23:09</h><w>seancorfield</w>^ <a>@devn</a> does that solve your problem?</z><z id="t1614036068" t="devn unfortunately, no. I tried that."><y>#</y><d>2021-02-22</d><h>23:21</h><w>devn</w>unfortunately, no. I tried that.</z><z id="t1614036087" t="devn it’s alright, I went ahead and renamed the column"><y>#</y><d>2021-02-22</d><h>23:21</h><w>devn</w>it’s alright, I went ahead and renamed the column</z><z id="t1614036108" t="seancorfield Which version of HoneySQL are you using?"><y>#</y><d>2021-02-22</d><h>23:21</h><w>seancorfield</w>Which version of HoneySQL are you using?</z><z id="t1614036144" t="devn actually, you know what, let me try one more time because i see you have :quoting :ansi bare there (with no wrapping {})"><y>#</y><d>2021-02-22</d><h>23:22</h><w>devn</w>actually, you know what, let me try one more time because i see you have :quoting :ansi bare there (with no wrapping {})</z><z id="t1614036233" t="devn ah yes, that’ll do it — however it still is a bit of a mess to also add in the column-fn transformation. if we run into another instance of this i’ll consider switching it up"><y>#</y><d>2021-02-22</d><h>23:23</h><w>devn</w>ah yes, that’ll do it — however it still is a bit of a mess to also add in the column-fn transformation. if we run into another instance of this i’ll consider switching it up</z><z id="t1614036279" t="seancorfield I realized you must be using 1.0 and the honeysql-postgres extension lib -- :upsert 🙂"><y>#</y><d>2021-02-22</d><h>23:24</h><w>seancorfield</w>I realized you must be using 1.0 and the honeysql-postgres extension lib -- <code>:upsert</code> <b>🙂</b></z><z id="t1614036307" t="seancorfield In 2.0, you don&apos;t need the extension lib and it&apos;s just user=&gt; (sql/format #_=&gt; {:on-conflict [:id] :do-update-set [:a :group :b]} {:quoted true}) [&quot;ON CONFLICT (\&quot;id\&quot;) DO UPDATE SET \&quot;a\&quot; = EXCLUDED.\&quot;a\&quot;, \&quot;group\&quot; = EXCLUDED.\&quot;group\&quot;, \&quot;b\&quot; = EXCLUDED.\&quot;b\&quot;&quot;] user=&gt; "><y>#</y><d>2021-02-22</d><h>23:25</h><w>seancorfield</w>In 2.0, you don&apos;t need the extension lib and it&apos;s just
<pre>user=&gt; (sql/format 
  #_=&gt;  {:on-conflict [:id] :do-update-set [:a :group :b]} {:quoted true})
[&quot;ON CONFLICT (\&quot;id\&quot;) DO UPDATE SET \&quot;a\&quot; = EXCLUDED.\&quot;a\&quot;, \&quot;group\&quot; = EXCLUDED.\&quot;group\&quot;, \&quot;b\&quot; = EXCLUDED.\&quot;b\&quot;&quot;]
user=&gt; </pre></z><z id="t1614036329" t="devn [honeysql &quot;1.0.444&quot;] [nilenso/honeysql-postgres &quot;0.2.6&quot;]"><y>#</y><d>2021-02-22</d><h>23:25</h><w>devn</w><pre>[honeysql &quot;1.0.444&quot;]
                 [nilenso/honeysql-postgres &quot;0.2.6&quot;]</pre></z><z id="t1614036338" t="devn ah, nice!"><y>#</y><d>2021-02-22</d><h>23:25</h><w>devn</w>ah, nice!</z><z id="t1614036356" t="devn then /that/ is what i’ll do to finish out my day 🙂"><y>#</y><d>2021-02-22</d><h>23:25</h><w>devn</w>then /that/ is what i’ll do to finish out my day <b>🙂</b></z><z id="t1614036357" t="devn thanks"><y>#</y><d>2021-02-22</d><h>23:25</h><w>devn</w>thanks</z><z id="t1614036359" t="seancorfield Also, since you&apos;re on 1.0, make sure you update to 1.0.461 for the important bug fix."><y>#</y><d>2021-02-22</d><h>23:25</h><w>seancorfield</w>Also, since you&apos;re on 1.0, make sure you update to 1.0.461 for the important bug fix.</z><z id="t1614036369" t="devn yep, saw that"><y>#</y><d>2021-02-22</d><h>23:26</h><w>devn</w>yep, saw that</z><z id="t1614036421" t="seancorfield You can use 1.0 and 2.0 side-by-side and migrate piecemeal: different maven coords and different namespaces 🙂"><y>#</y><d>2021-02-22</d><h>23:27</h><w>seancorfield</w>You can use 1.0 and 2.0 side-by-side and migrate piecemeal: different maven coords and different namespaces <b>🙂</b></z><z id="t1614036495" t="devn :male-cook: 💋 🤌"><y>#</y><d>2021-02-22</d><h>23:28</h><w>devn</w><b>:male-cook:</b> <b>💋</b> <b>🤌</b></z><z id="t1614036520" t="seancorfield https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/differences-from-1-x"><y>#</y><d>2021-02-22</d><h>23:28</h><w>seancorfield</w><a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/differences-from-1-x" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/differences-from-1-x</a></z><z id="t1614193131" t="Jeff Evans how can I create an insert-into query where one of the column names has a dot in it? running into this when upgrading from 0.9.4 to ~the latest~ 1.0.461. ex: (-&gt; (apply h/columns [:name_first (keyword &quot;name.last&quot;) :col2]) (h/insert-into :properties) (h/values (lazy-seq [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]])) (honeysql.format/format)) =&gt; [&quot;INSERT INTO properties (name_first, name.last, col2) VALUES (?, ?, 34), (?, ?, 12), (?, ?, 56)&quot; &quot;Jon&quot; &quot;Smith&quot; &quot;Andrew&quot; &quot;Cooper&quot; &quot;Jane&quot; &quot;Daniels&quot;]"><y>#</y><d>2021-02-24</d><h>18:58</h><w>Jeff Evans</w>how can I create an <code>insert-into</code> query where one of the column names has a dot in it?  running into this when upgrading from 0.9.4 to ~the latest~ 1.0.461.  ex:

<pre>(-&gt; (apply h/columns [:name_first (keyword &quot;name.last&quot;) :col2])
    (h/insert-into :properties)
    (h/values
      (lazy-seq [[&quot;Jon&quot; &quot;Smith&quot; 34]
                 [&quot;Andrew&quot; &quot;Cooper&quot; 12]
                 [&quot;Jane&quot; &quot;Daniels&quot; 56]]))
    (honeysql.format/format))
=&gt;
[&quot;INSERT INTO properties (name_first, name.last, col2) VALUES (?, ?, 34), (?, ?, 12), (?, ?, 56)&quot;
 &quot;Jon&quot;
 &quot;Smith&quot;
 &quot;Andrew&quot;
 &quot;Cooper&quot;
 &quot;Jane&quot;
 &quot;Daniels&quot;]</pre></z><z id="t1614193154" t="Jeff Evans I want the SQL to be INSERT INTO properties (name_first, &quot;name.last&quot;, col2) VALUES (?, ?, 34), (?, ?, 12), (?, ?, 56)"><y>#</y><d>2021-02-24</d><h>18:59</h><w>Jeff Evans</w>I want the SQL to be <code>INSERT INTO properties (name_first, &quot;name.last&quot;, col2) VALUES (?, ?, 34), (?, ?, 12), (?, ?, 56)</code></z><z id="t1614193319" t="Jeff Evans well, really, all of the column names could be quoted, that would be nice"><y>#</y><d>2021-02-24</d><h>19:01</h><w>Jeff Evans</w>well, really, all of the column names could be quoted, that would be nice</z><z id="t1614193420" t="seancorfield [:attrs {:href &quot;/_/_/users/U0183EZCD0D&quot;}] Which &quot;latest&quot;? 1.0 or 2.0?"><y>#</y><d>2021-02-24</d><h>19:03</h><w>seancorfield</w><a>@jeffrey.wayne.evans</a> Which &quot;latest&quot;? 1.0 or 2.0?</z><z id="t1614193445" t="Jeff Evans sorry. 1.0.461"><y>#</y><d>2021-02-24</d><h>19:04</h><w>Jeff Evans</w>sorry.  1.0.461</z><z id="t1614194280" t="seancorfield Looking over the 1.0 code, I don&apos;t think there&apos;s any way to prevent the dot-splitting -- it seems to be guarded by quoting being OFF so it looks like you definitely cannot have quoting ON and avoid the splitting."><y>#</y><d>2021-02-24</d><h>19:18</h><w>seancorfield</w>Looking over the 1.0 code, I don&apos;t think there&apos;s any way to prevent the dot-splitting -- it seems to be guarded by quoting being OFF so it looks like you definitely cannot have quoting ON and avoid the splitting.</z><z id="t1614194567" t="seancorfield You can&apos;t avoid it in 2.0 either since insert column names are a context where the namespace portion of a name is ignored -- and you can only avoid dot-splitting if you have a namespace-qualified name, e.g., properties/name.last in your case."><y>#</y><d>2021-02-24</d><h>19:22</h><w>seancorfield</w>You can&apos;t avoid it in 2.0 either since insert column names are a context where the namespace portion of a name is ignored -- and you can only avoid dot-splitting if you have a namespace-qualified name, e.g., <code>properties/name.last</code> in your case.</z><z id="t1614194593" t="seancorfield It&apos;s pretty deeply baked into HoneySQL, in both versions, that foo.bar means &quot;table foo, column bar&quot;."><y>#</y><d>2021-02-24</d><h>19:23</h><w>seancorfield</w>It&apos;s pretty deeply baked into HoneySQL, in both versions, that <code>foo.bar</code> means &quot;table foo, column bar&quot;.</z><z id="t1614194662" t="Jeff Evans hmm, interesting. thanks for checking. I need to do a bit more homework to understand how it was doing what we wanted before"><y>#</y><d>2021-02-24</d><h>19:24</h><w>Jeff Evans</w>hmm, interesting.  thanks for checking.  I need to do a bit more homework to understand how it was doing what we wanted before</z><z id="t1614194939" t="seancorfield There were certainly some big changes in how names were handled in the 0.9.x series of releases -- some changes had to be reverted, some spawned extra options and/or dynamic vars."><y>#</y><d>2021-02-24</d><h>19:28</h><w>seancorfield</w>There were certainly some big changes in how names were handled in the 0.9.x series of releases -- some changes had to be reverted, some spawned extra options and/or dynamic vars.</z><z id="t1614194999" t="seancorfield I don&apos;t think I&apos;ve ever seen a DB schema where column names contain dots tho&apos;..."><y>#</y><d>2021-02-24</d><h>19:29</h><w>seancorfield</w>I don&apos;t think I&apos;ve ever seen a DB schema where column names contain dots tho&apos;...</z><z id="t1614200504" t="Jeff Evans oh, I’ve seen every godawful thing like that. and I’m guessing some of my coworkers have too, since there is a test written for it"><y>#</y><d>2021-02-24</d><h>21:01</h><w>Jeff Evans</w>oh, I’ve seen every godawful thing like that.  and I’m guessing some of my coworkers have too, since there is a test written for it</z><z id="t1614203078" t="Chris O’Donnell Could you do (sql/raw &quot;\&quot;name.last\&quot;&quot;) as a workaround?"><y>#</y><d>2021-02-24</d><h>21:44</h><w>Chris O’Donnell</w>Could you do <code>(sql/raw &quot;\&quot;name.last\&quot;&quot;)</code> as a workaround?</z><z id="t1614203338" t="seancorfield [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] Not in the middle of a column name list, no. But you could, possibly, pass a string into columns maybe? (I haven&apos;t tried -- that just occurred to me)"><y>#</y><d>2021-02-24</d><h>21:48</h><w>seancorfield</w><a>@codonnell</a> Not in the middle of a column name list, no. But you could, possibly, pass a string into <code>columns</code> maybe? (I haven&apos;t tried -- that just occurred to me)</z><z id="t1614203480" t="seancorfield Nope, that won&apos;t work."><y>#</y><d>2021-02-24</d><h>21:51</h><w>seancorfield</w>Nope, that won&apos;t work.</z><z id="t1614203522" t="seancorfield Oh, yeah -- [:attrs {:href &quot;/_/_/users/U0DUNNKT2&quot;}] wins the prize after all! user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;name.last&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format)) [&quot;INSERT INTO properties (name_first, name.last, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56] user=&gt; "><y>#</y><d>2021-02-24</d><h>21:52</h><w>seancorfield</w>Oh, yeah -- <a>@codonnell</a> wins the prize after all!
<pre>user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;name.last&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format))
[&quot;INSERT INTO properties (name_first, name.last, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56]
user=&gt; </pre></z><z id="t1614203564" t="seancorfield Although it will not quote it: user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;name.last&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format :quoting :ansi)) [&quot;INSERT INTO \&quot;properties\&quot; (\&quot;name_first\&quot;, name.last, \&quot;col2\&quot;) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56] user=&gt; "><y>#</y><d>2021-02-24</d><h>21:52</h><w>seancorfield</w>Although it will not quote it:
<pre>user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;name.last&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format :quoting :ansi))
[&quot;INSERT INTO \&quot;properties\&quot; (\&quot;name_first\&quot;, name.last, \&quot;col2\&quot;) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56]
user=&gt; </pre></z><z id="t1614203601" t="seancorfield So you&apos;d need to do that manually: user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;\&quot;name.last\&quot;&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format)) [&quot;INSERT INTO properties (name_first, \&quot;name.last\&quot;, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56] user=&gt; "><y>#</y><d>2021-02-24</d><h>21:53</h><w>seancorfield</w>So you&apos;d need to do that manually:
<pre>user=&gt; (-&gt; (insert-into :properties) (columns :name_first (sql/raw &quot;\&quot;name.last\&quot;&quot;) :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format))
[&quot;INSERT INTO properties (name_first, \&quot;name.last\&quot;, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56]
user=&gt; </pre></z><z id="t1614203622" t="Jeff Evans aha, thanks to both of you! should work"><y>#</y><d>2021-02-24</d><h>21:53</h><w>Jeff Evans</w>aha, thanks to both of you!  should work</z><z id="t1614203656" t="Chris O’Donnell Whew! 😅"><y>#</y><d>2021-02-24</d><h>21:54</h><w>Chris O’Donnell</w>Whew! <b>😅</b></z><z id="t1614203697" t="Jeff Evans granted, we are actually passing in things that reify ToSql already, so it will take me a bit of time to figure out how to adjust things. but that’s my problem"><y>#</y><d>2021-02-24</d><h>21:54</h><w>Jeff Evans</w>granted, we are actually passing in things that <code>reify ToSql</code> already, so it will take me a bit of time to figure out how to adjust things.  but that’s my problem</z><z id="t1614203698" t="seancorfield And in v2: user=&gt; (-&gt; (insert-into :properties) (columns :name_first [:raw &quot;\&quot;name.last\&quot;&quot;] :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format)) [&quot;INSERT INTO properties (name_first, \&quot;name.last\&quot;, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56]"><y>#</y><d>2021-02-24</d><h>21:54</h><w>seancorfield</w>And in v2:
<pre>user=&gt; (-&gt; (insert-into :properties) (columns :name_first [:raw &quot;\&quot;name.last\&quot;&quot;] :col2) (values [[&quot;Jon&quot; &quot;Smith&quot; 34] [&quot;Andrew&quot; &quot;Cooper&quot; 12] [&quot;Jane&quot; &quot;Daniels&quot; 56]]) (sql/format))
[&quot;INSERT INTO properties (name_first, \&quot;name.last\&quot;, col2) VALUES (?, ?, ?), (?, ?, ?), (?, ?, ?)&quot; &quot;Jon&quot; &quot;Smith&quot; 34 &quot;Andrew&quot; &quot;Cooper&quot; 12 &quot;Jane&quot; &quot;Daniels&quot; 56]</pre></z><z id="t1614203904" t="seancorfield [:attrs {:href &quot;/_/_/users/U0183EZCD0D&quot;}] I&apos;m curious what things you have reifying ToSql ? That whole system goes away in v2 (and as you can see, sql/raw becomes just a regular &quot;function call&quot; expression -- a.k.a &quot;special syntax&quot; -- in v2)."><y>#</y><d>2021-02-24</d><h>21:58</h><w>seancorfield</w><a>@jeffrey.wayne.evans</a> I&apos;m curious what things you have reifying <code>ToSql</code>? That whole system goes away in v2 (and as you can see, <code>sql/raw</code> becomes just a regular &quot;function call&quot; expression -- a.k.a &quot;special syntax&quot; -- in v2).</z><z id="t1614204224" t="Jeff Evans well, I’m still quite new to this codebase, so I definitely can’t answer any type of historical/“why” questions, but the relevant sections are https://github.com/metabase/metabase/blob/master/test/metabase/test/data/sql/ddl.clj#L85-L89 and https://github.com/metabase/metabase/blob/master/src/metabase/util/honeysql_extensions.clj"><y>#</y><d>2021-02-24</d><h>22:03</h><w>Jeff Evans</w>well, I’m still quite new to this codebase, so I definitely can’t answer any type of historical/“why” questions, but the relevant sections are

<a href="https://github.com/metabase/metabase/blob/master/test/metabase/test/data/sql/ddl.clj#L85-L89" target="_blank">https://github.com/metabase/metabase/blob/master/test/metabase/test/data/sql/ddl.clj#L85-L89</a>

and

<a href="https://github.com/metabase/metabase/blob/master/src/metabase/util/honeysql_extensions.clj" target="_blank">https://github.com/metabase/metabase/blob/master/src/metabase/util/honeysql_extensions.clj</a></z><z id="t1614204361" t="Jeff Evans er, sorry, this particular one (the Identifier ) is a defrecord , not a reify"><y>#</y><d>2021-02-24</d><h>22:06</h><w>Jeff Evans</w>er, sorry, this particular one (the <code>Identifier</code> ) is a <code>defrecord</code>, not a <code>reify</code></z><z id="t1614288564" t="Jeff Evans well, this is curious… (honeysql.helpers/columns (honeysql.core/raw &quot;col1&quot;) (honeysql.core/raw &quot;\&quot;col.2\&quot;&quot;) (honeysql.core/raw &quot;col.3&quot;)) =&gt; #sql/raw&quot;col1&quot; (honeysql.helpers/columns (keyword &quot;col1&quot;) (honeysql.core/raw &quot;\&quot;col.2\&quot;&quot;) (honeysql.core/raw &quot;col.3&quot;)) =&gt; {:columns (:col1 #sql/raw&quot;\&quot;col.2\&quot;&quot; #sql/raw&quot;col.3&quot;)}"><y>#</y><d>2021-02-25</d><h>21:29</h><w>Jeff Evans</w>well, this is curious…

<pre>(honeysql.helpers/columns (honeysql.core/raw &quot;col1&quot;) (honeysql.core/raw &quot;\&quot;col.2\&quot;&quot;) (honeysql.core/raw &quot;col.3&quot;))
=&gt; #sql/raw&quot;col1&quot;
(honeysql.helpers/columns (keyword &quot;col1&quot;) (honeysql.core/raw &quot;\&quot;col.2\&quot;&quot;) (honeysql.core/raw &quot;col.3&quot;))
=&gt; {:columns (:col1 #sql/raw&quot;\&quot;col.2\&quot;&quot; #sql/raw&quot;col.3&quot;)}</pre></z><z id="t1614288804" t="seancorfield Yeah, I suspect there&apos;s an edge case with merging data on that first column. Put {} before the first column name."><y>#</y><d>2021-02-25</d><h>21:33</h><w>seancorfield</w>Yeah, I suspect there&apos;s an edge case with merging data on that first column. Put <code>{}</code> before the first column name.</z><z id="t1614288840" t="Jeff Evans aha, yep, that did it"><y>#</y><d>2021-02-25</d><h>21:34</h><w>Jeff Evans</w>aha, yep, that did it</z><z id="t1614288853" t="Jeff Evans better than what I was planning"><y>#</y><d>2021-02-25</d><h>21:34</h><w>Jeff Evans</w>better than what I was planning</z><z id="t1614288865" t="seancorfield user=&gt; (columns (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;)) #sql/raw &quot;col1&quot; user=&gt; (columns {} (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;)) {:columns (#sql/raw &quot;col1&quot; #sql/raw &quot;col.two&quot; #sql/raw &quot;col:three&quot;)}"><y>#</y><d>2021-02-25</d><h>21:34</h><w>seancorfield</w><pre>user=&gt; (columns (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;))
#sql/raw &quot;col1&quot;
user=&gt; (columns {} (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;))
{:columns (#sql/raw &quot;col1&quot; #sql/raw &quot;col.two&quot; #sql/raw &quot;col:three&quot;)}</pre></z><z id="t1614288878" t="seancorfield Normally you&apos;d thread a hash map into the helper call."><y>#</y><d>2021-02-25</d><h>21:34</h><w>seancorfield</w>Normally you&apos;d thread a hash map into the helper call.</z><z id="t1614288921" t="seancorfield user=&gt; (-&gt; {} (columns (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;))) {:columns (#sql/raw &quot;col1&quot; #sql/raw &quot;col.two&quot; #sql/raw &quot;col:three&quot;)}"><y>#</y><d>2021-02-25</d><h>21:35</h><w>seancorfield</w><pre>user=&gt; (-&gt; {} (columns (sql/raw &quot;col1&quot;) (sql/raw &quot;col.two&quot;) (sql/raw &quot;col:three&quot;)))
{:columns (#sql/raw &quot;col1&quot; #sql/raw &quot;col.two&quot; #sql/raw &quot;col:three&quot;)}</pre></z><z id="t1614288942" t="seancorfield Nearly all the helpers expect to be used in that context."><y>#</y><d>2021-02-25</d><h>21:35</h><w>seancorfield</w>Nearly all the helpers expect to be used in that context.</z><z id="t1614288954" t="Jeff Evans ah, right. hence the insert-into example from the README"><y>#</y><d>2021-02-25</d><h>21:35</h><w>Jeff Evans</w>ah, right.  hence the <code>insert-into</code> example from the README</z><z id="t1614289006" t="seancorfield HoneySQL v2 gets it right: user=&gt; (columns [:raw &quot;col1&quot;] [:raw &quot;col.two&quot;] [:raw &quot;col:three&quot;]) {:columns [[:raw &quot;col1&quot;] [:raw &quot;col.two&quot;] [:raw &quot;col:three&quot;]]}"><y>#</y><d>2021-02-25</d><h>21:36</h><w>seancorfield</w>HoneySQL v2 gets it right:
<pre>user=&gt; (columns [:raw &quot;col1&quot;] [:raw &quot;col.two&quot;] [:raw &quot;col:three&quot;])
{:columns [[:raw &quot;col1&quot;] [:raw &quot;col.two&quot;] [:raw &quot;col:three&quot;]]}</pre></z><z id="t1614291997" t="Jeff Evans thanks a lot, Sean! this is extremely helpful. I will definitely be looking for us to upgrade to v2 once it’s released 🙂"><y>#</y><d>2021-02-25</d><h>22:26</h><w>Jeff Evans</w>thanks a lot, Sean!  this is extremely helpful.  I will definitely be looking for us to upgrade to v2 once it’s released <b>🙂</b></z><z id="t1614292086" t="Jeff Evans in the meantime, I can finally explain the hiccup we ran into in the 0.9.4-&gt;1.0.461 upgrade in 0.9.4: (honeysql.helpers/columns {} (honeysql.core/raw &quot;col1&quot;)) =&gt; {:columns (#sql/raw&quot;col1&quot;)} (honeysql.helpers/columns (honeysql.core/raw &quot;col1&quot;)) =&gt; {:columns (#sql/raw&quot;col1&quot;)} in 1.0.461: (honeysql.helpers/columns (honeysql.core/raw &quot;a.b&quot;)) =&gt; #sql/raw&quot;a.b&quot; (honeysql.helpers/columns {} (honeysql.core/raw &quot;a.b&quot;)) Execution error (IllegalArgumentException) at honeysql.helpers/check-varargs (helpers.cljc:264). columns takes varargs, not a single collection"><y>#</y><d>2021-02-25</d><h>22:28</h><w>Jeff Evans</w>in the meantime, I can finally explain the hiccup we ran into in the 0.9.4-&gt;1.0.461 upgrade

in 0.9.4:
<pre>(honeysql.helpers/columns {} (honeysql.core/raw &quot;col1&quot;))
=&gt; {:columns (#sql/raw&quot;col1&quot;)}
(honeysql.helpers/columns (honeysql.core/raw &quot;col1&quot;))
=&gt; {:columns (#sql/raw&quot;col1&quot;)}</pre>
in 1.0.461:
<pre>(honeysql.helpers/columns (honeysql.core/raw &quot;a.b&quot;))
=&gt; #sql/raw&quot;a.b&quot;
(honeysql.helpers/columns {} (honeysql.core/raw &quot;a.b&quot;))
Execution error (IllegalArgumentException) at honeysql.helpers/check-varargs (helpers.cljc:264).
columns takes varargs, not a single collection</pre></z><z id="t1614292095" t="Jeff Evans i.e. this patch: https://github.com/seancorfield/honeysql/commit/4ca74f2b0d0f87827ce34d9baf8dcc8d086ce18e"><y>#</y><d>2021-02-25</d><h>22:28</h><w>Jeff Evans</w>i.e. this patch: <a href="https://github.com/seancorfield/honeysql/commit/4ca74f2b0d0f87827ce34d9baf8dcc8d086ce18e" target="_blank">https://github.com/seancorfield/honeysql/commit/4ca74f2b0d0f87827ce34d9baf8dcc8d086ce18e</a></z><z id="t1614292111" t="Jeff Evans so now that I clearly understand it, I can work around"><y>#</y><d>2021-02-25</d><h>22:28</h><w>Jeff Evans</w>so now that I clearly understand it, I can work around</z><z id="t1614296337" t="seancorfield Ah, back in 0.9.7... yeah, with hindsight there was a lot more churn in the 0.9.x releases than there should have been and definitely not enough test coverage 😞"><y>#</y><d>2021-02-25</d><h>23:38</h><w>seancorfield</w>Ah, back in 0.9.7... yeah, with hindsight there was a lot more churn in the 0.9.x releases than there should have been and definitely not enough test coverage <b>😞</b></z><z id="t1614296429" t="seancorfield FYI, re: 2.0 -- the main thing blocking a &quot;gold&quot; release is actually documentation, to be honest. At this point the functionality isn&apos;t going to change (beyond supporting more ANSI SQL and probably more PostgreSQL syntax)."><y>#</y><d>2021-02-25</d><h>23:40</h><w>seancorfield</w>FYI, re: 2.0 -- the main thing blocking a &quot;gold&quot; release is actually documentation, to be honest. At this point the functionality isn&apos;t going to change (beyond supporting more ANSI SQL and probably more PostgreSQL syntax).</z><z id="t1614296451" t="seancorfield (but I understand some folks are reluctant to use an alpha in production)"><y>#</y><d>2021-02-25</d><h>23:40</h><w>seancorfield</w>(but I understand some folks are reluctant to use an alpha in production)</z><z id="t1614681204" t="borkdude As a bit of user feedback: It&apos;s been several times now that I&apos;ve been reading the README and I have trouble resolving mentally where some vars are coming from due to the use of :refer :all . E.g. right now I&apos;m searching where insert-into is coming from (again). Can the README maybe use an alias, or an explicit :refer [...] ? Or can all of these functions maybe be part of the honey.sql namespace?"><y>#</y><d>2021-03-02</d><h>10:33</h><w>borkdude</w>As a bit of user feedback:

It&apos;s been several times now that I&apos;ve been reading the README and I have trouble resolving mentally where some vars are coming from due to the use of <code>:refer :all</code>. E.g. right now I&apos;m searching where <code>insert-into</code> is coming from (again). Can the README maybe use an alias, or an explicit <code>:refer [...]</code>?

Or can all of these functions maybe be part of the <code>honey.sql</code> namespace?</z><z id="t1614706350" t="seancorfield The helpers have always traditionally been in a separate ns and that folks can either :refer specific ones or use an alias as they prefer. I think the DSL reads much more clearly with referred symbols than with using an alias. In v2 there are only two namespaces: honey.sql for working with the data structure and format &apos;ing it, honey.sql.helpers with all the helper functions. In v2, honey.sql has one primary API: the format function, and you only care about the other public functions if you&apos;re extending HoneySQL."><y>#</y><d>2021-03-02</d><h>17:32</h><w>seancorfield</w>The helpers have always traditionally been in a separate ns and that folks can either <code>:refer</code> specific ones or use an alias as they prefer. I think the DSL reads much more clearly with referred symbols than with using an alias. In v2 there are only two namespaces: <code>honey.sql</code> for working with the data structure and <code>format</code>&apos;ing it, <code>honey.sql.helpers</code> with all the helper functions. In v2, <code>honey.sql</code> has one primary API: the <code>format</code> function, and you only care about the other public functions if you&apos;re extending HoneySQL.</z><z id="t1614706823" t="seancorfield I get the impression that only a minority of HoneySQL users rely on the helpers at all -- most folks seem to prefer to work with the data structures and just sql/format . I&apos;m still working on the docs (the major piece of work blocking a &quot;gold&quot; release) and I&apos;ll definitely make a couple more passes over the readme. The readme already has [honey.sql.helpers :refer :all :as h] (v1 had :as helpers instead of :as h and used that alias in precisely one place, to disambiguate update )."><y>#</y><d>2021-03-02</d><h>17:40</h><w>seancorfield</w>I get the impression that only a minority of HoneySQL users rely on the helpers at all -- most folks seem to prefer to work with the data structures and just <code>sql/format</code>. I&apos;m still working on the docs (the major piece of work blocking a &quot;gold&quot; release) and I&apos;ll definitely make a couple more passes over the readme. The readme already has <code>[honey.sql.helpers :refer :all :as h]</code> (v1 had <code>:as helpers</code> instead of <code>:as h</code> and used that alias in precisely one place, to disambiguate <code>update</code>).</z><z id="t1614872741" t="iarenaza One data point: we use the data structures, unless we need to resort to using sql/raw for certain Postgresql-specific constructs not supported in HoneySQL 1.x. Sometimes we need to dig into the code a bit to find the exact shape of the data structures because the README mainly uses helpers (e.g., to do a multi-JOIN) but the code is extremely clear and helpful (thanks a lot for that!)"><y>#</y><d>2021-03-04</d><h>15:45</h><r>iarenaza</r>One data point: we use the data structures, unless we need to resort to using <code>sql/raw</code> for certain Postgresql-specific constructs not supported in HoneySQL 1.x.

Sometimes we need to dig into the code a bit to find the exact shape of the data structures because the README mainly uses helpers (e.g., to do a multi-JOIN) but the code is extremely clear and helpful (thanks a lot for that!)</z><z id="t1614872809" t="iarenaza Looking forward to migrating to v2, as some rough edges of 1.x have been polished quite a bit!"><y>#</y><d>2021-03-04</d><h>15:46</h><r>iarenaza</r>Looking forward to migrating to v2, as some rough edges of 1.x have been polished quite a bit!</z><z id="t1614878433" t="seancorfield Thanks, I hope the new SQL Clause Reference docs in v2 solve the &quot;exact shape of the data structures&quot; issue?"><y>#</y><d>2021-03-04</d><h>17:20</h><r>seancorfield</r>Thanks, I hope the new SQL Clause Reference docs in v2 solve the &quot;exact shape of the data structures&quot; issue?</z><z id="t1614706980" t="seancorfield (as for moving the helpers into honey.sql -- definitely not, at this point)"><y>#</y><d>2021-03-02</d><h>17:43</h><w>seancorfield</w>(as for moving the helpers into <code>honey.sql</code> -- definitely not, at this point)</z><z id="t1614708875" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I was using insert-into since I didn&apos;t know how to do this using data structures"><y>#</y><d>2021-03-02</d><h>18:14</h><w>borkdude</w><a>@seancorfield</a> I was using <code>insert-into</code> since I didn&apos;t know how to do this using data structures</z><z id="t1614708890" t="borkdude There were no examples I could find on this"><y>#</y><d>2021-03-02</d><h>18:14</h><w>borkdude</w>There were no examples I could find on this</z><z id="t1614708965" t="seancorfield https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference#insert-into"><y>#</y><d>2021-03-02</d><h>18:16</h><w>seancorfield</w><a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference#insert-into" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-clause-reference#insert-into</a></z><z id="t1614709193" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I&apos;m referring to the main README where I ctrl-f-ed on insert which only comes up with examples with insert-into (from the namespace I had to guess)"><y>#</y><d>2021-03-02</d><h>18:19</h><w>borkdude</w><a>@seancorfield</a> I&apos;m referring to the main README where I ctrl-f-ed on <code>insert</code> which only comes up with examples with <code>insert-into</code> (from the namespace I had to guess)</z><z id="t1614709217" t="borkdude if :insert-into is preferred, maybe the main README should suggest this instead?"><y>#</y><d>2021-03-02</d><h>18:20</h><w>borkdude</w>if <code>:insert-into</code> is preferred, maybe the main README should suggest this instead?</z><z id="t1614709224" t="borkdude I had no idea it existed"><y>#</y><d>2021-03-02</d><h>18:20</h><w>borkdude</w>I had no idea it existed</z><z id="t1614709285" t="seancorfield Everything has always been available as data structures. The helpers in v1 don&apos;t even cover all of the clauses. When I overhaul the README I will link more heavily to the reference doc sections."><y>#</y><d>2021-03-02</d><h>18:21</h><w>seancorfield</w>Everything has always been available as data structures. The helpers in v1 don&apos;t even cover all of the clauses. When I overhaul the README I will link more heavily to the reference doc sections.</z><z id="t1614709347" t="seancorfield I will also make the whole data structure vs helper DSL thing clearer (the v2 readme is still modeled after the v1 readme, for the most part)."><y>#</y><d>2021-03-02</d><h>18:22</h><w>seancorfield</w>I will also make the whole data structure vs helper DSL thing clearer (the v2 readme is still modeled after the v1 readme, for the most part).</z><z id="t1614709367" t="borkdude Thanks!"><y>#</y><d>2021-03-02</d><h>18:22</h><w>borkdude</w>Thanks!</z><z id="t1614709528" t="seancorfield (this is good feedback esp. since you&apos;re a new-to-HoneySQL user, right?)"><y>#</y><d>2021-03-02</d><h>18:25</h><w>seancorfield</w>(this is good feedback esp. since you&apos;re a new-to-HoneySQL user, right?)</z><z id="t1614709603" t="borkdude yeah"><y>#</y><d>2021-03-02</d><h>18:26</h><w>borkdude</w>yeah</z><z id="t1614709647" t="borkdude I&apos;m using it now from babashka mainly to poke at our work database, since this is faster than pgadmin which is annoyingly slow right now when connecting to a database in the US region (from Europe)"><y>#</y><d>2021-03-02</d><h>18:27</h><w>borkdude</w>I&apos;m using it now from babashka mainly to poke at our work database, since this is faster than pgadmin which is annoyingly slow right now when connecting to a database in the US region (from Europe)</z><z id="t1614709689" t="seancorfield Feel free to add any and all readme/doc thoughts to https://github.com/seancorfield/honeysql/issues/307 so I don&apos;t lose track of any suggestions."><y>#</y><d>2021-03-02</d><h>18:28</h><w>seancorfield</w>Feel free to add any and all readme/doc thoughts to <a href="https://github.com/seancorfield/honeysql/issues/307" target="_blank">https://github.com/seancorfield/honeysql/issues/307</a> so I don&apos;t lose track of any suggestions.</z><z id="t1614746927" t="Chris O’Donnell I tend to use the query data structure directly, personally. When the readme just shows how a helper is used, I usually evaluate it at the repl to see the structure of the map it returns."><y>#</y><d>2021-03-03</d><h>04:48</h><w>Chris O’Donnell</w>I tend to use the query data structure directly, personally. When the readme just shows how a helper is used, I usually evaluate it at the repl to see the structure of the map it returns.</z><z id="t1614774364" t="borkdude Does / should honeysql support inlining arrays? (def sql (sql/format (-&gt; (h/insert-into :users) ;; (sql/columns :foo) (h/values [{:foo (into-array [1 2 3])}])) {:inline true})) [&quot;INSERT INTO users (foo) VALUES ([Ljava.lang.Long;@34b3d918)&quot;]"><y>#</y><d>2021-03-03</d><h>12:26</h><w>borkdude</w>Does / should honeysql support inlining arrays?
<pre>(def sql (sql/format (-&gt; (h/insert-into :users)
                         ;; (sql/columns :foo)
                         (h/values [{:foo (into-array [1 2 3])}]))
                     {:inline true}))</pre>
<pre>[&quot;INSERT INTO users (foo) VALUES ([Ljava.lang.Long;@34b3d918)&quot;]</pre></z><z id="t1614792157" t="seancorfield Does it work in v1 and just not in v2?"><y>#</y><d>2021-03-03</d><h>17:22</h><w>seancorfield</w>Does it work in v1 and just not in v2?</z><z id="t1614806254" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Just tried with v1, same thing"><y>#</y><d>2021-03-03</d><h>21:17</h><w>borkdude</w><a>@seancorfield</a> Just tried with v1, same thing</z><z id="t1614807053" t="seancorfield There are some situations where HoneySQL expands collections and others where it assumes the JDBC library will handle the value."><y>#</y><d>2021-03-03</d><h>21:30</h><w>seancorfield</w>There are some situations where HoneySQL expands collections and others where it assumes the JDBC library will handle the value.</z><z id="t1614807157" t="seancorfield Oh, is this just about inlining? What should an array inline into? And is it portable across other databases?"><y>#</y><d>2021-03-03</d><h>21:32</h><w>seancorfield</w>Oh, is this just about inlining? What should an array inline into? And is it portable across other databases?</z><z id="t1614807176" t="seancorfield (I&apos;m pretty sure the answer to 3) is &quot;no&quot;)"><y>#</y><d>2021-03-03</d><h>21:32</h><w>seancorfield</w>(I&apos;m pretty sure the answer to 3) is &quot;no&quot;)</z><z id="t1614807652" t="borkdude There is an ANSI array standard now. I tried this: (def array-sql2 (sql/format {:insert-into :foo :values [{:foo [:raw (format &quot;array [%s]&quot; (str/join &quot;,&quot; [1 2 3]))]}]})) and that worked, but I haven&apos;t tested with e.g. postgres"><y>#</y><d>2021-03-03</d><h>21:40</h><w>borkdude</w>There is an ANSI array standard now. I tried this:
<pre>(def array-sql2
  (sql/format {:insert-into :foo
               :values [{:foo [:raw (format &quot;array [%s]&quot; (str/join &quot;,&quot; [1 2 3]))]}]}))</pre>
and that worked, but I haven&apos;t tested with e.g. postgres</z><z id="t1614807964" t="borkdude can I do something like this? :select [:raw &quot;ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;]&quot;] This comes back with: column :raw does not exist"><y>#</y><d>2021-03-03</d><h>21:46</h><w>borkdude</w>can I do something like this?
<pre>:select [:raw &quot;ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;]&quot;]</pre>
This comes back with: <code>column :raw does not exist</code></z><z id="t1614808250" t="rwstauner i think there&apos;s a (sql/raw &quot;...&quot;)"><y>#</y><d>2021-03-03</d><h>21:50</h><w>rwstauner</w>i think there&apos;s a <code>(sql/raw &quot;...&quot;)</code></z><z id="t1614808293" t="borkdude Anyway, this seemed to work: (pg/execute! db [&quot;select ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;] from users limit 1&quot;]) so I think the standard (ANSI) sql notation for arrays is ARRAY[1,2,3] . Maybe :inline could do that. More research needed probably."><y>#</y><d>2021-03-03</d><h>21:51</h><w>borkdude</w>Anyway, this seemed to work:
<pre>(pg/execute! db [&quot;select ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;] from users limit 1&quot;])</pre>
so I think the standard (ANSI) sql notation for arrays is <code>ARRAY[1,2,3]</code>. Maybe <code>:inline</code> could do that. More research needed probably.</z><z id="t1614809262" t="seancorfield {:select [[[:raw ...]]]} because SELECT takes a sequence of things, and those things can be aliases (which are wrapped in a sequence) and the thing you would alias is a function call [:raw ...]"><y>#</y><d>2021-03-03</d><h>22:07</h><w>seancorfield</w><code>{:select [[[:raw ...]]]}</code> because SELECT takes a sequence of things, and those things can be aliases (which are wrapped in a sequence) and the thing you would alias is a function call <code>[:raw ...]</code></z><z id="t1614809283" t="seancorfield That looks slightly less weird with the select helper but still a bit odd."><y>#</y><d>2021-03-03</d><h>22:08</h><w>seancorfield</w>That looks slightly less weird with the <code>select</code> helper but still a bit odd.</z><z id="t1614809296" t="seancorfield and in v2 there&apos;s :array"><y>#</y><d>2021-03-03</d><h>22:08</h><w>seancorfield</w>and in v2 there&apos;s <code>:array</code></z><z id="t1614809325" t="seancorfield https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-special-syntax-#array"><y>#</y><d>2021-03-03</d><h>22:08</h><w>seancorfield</w><a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-special-syntax-#array" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-alpha2/doc/getting-started/sql-special-syntax-#array</a></z><z id="t1614809845" t="borkdude confirming that :select [[[:raw &quot;ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;]&quot;]]] works. also :select [[[:array [1 2 3]]]] works and also [:array (into-array [1 2 3])] works. TIL!"><y>#</y><d>2021-03-03</d><h>22:17</h><w>borkdude</w>confirming that <code>:select [[[:raw &quot;ARRAY[&apos;hello&apos;,&apos;bob&apos;,&apos;and&apos;,&apos;sally&apos;]&quot;]]]</code> works.
also <code>:select [[[:array [1 2 3]]]]</code> works
and also <code>[:array (into-array [1 2 3])]</code> works. TIL!</z><z id="t1614809942" t="borkdude I&apos;m not sure how this would compose with :inline still, e.g. when you insert values. Can you do {:values [{:foo [:array [1 2 3]]}]} ?"><y>#</y><d>2021-03-03</d><h>22:19</h><w>borkdude</w>I&apos;m not sure how this would compose with <code>:inline</code> still, e.g. when you insert values. Can you do <code>{:values [{:foo [:array [1 2 3]]}]}</code>?</z><z id="t1614810010" t="borkdude it worked!"><y>#</y><d>2021-03-03</d><h>22:20</h><w>borkdude</w>it worked!</z><z id="t1614810029" t="borkdude (def sql (sql/format {:insert-into :foo :values [{:foo [:array [1 2 3]]}]} {:inline true})) [&quot;INSERT INTO foo (foo) VALUES (ARRAY[1, 2, 3])&quot;]"><y>#</y><d>2021-03-03</d><h>22:20</h><w>borkdude</w><pre>(def sql (sql/format {:insert-into :foo
                      :values [{:foo [:array [1 2 3]]}]}
                     {:inline true}))</pre>
<pre>[&quot;INSERT INTO foo (foo) VALUES (ARRAY[1, 2, 3])&quot;]</pre></z><z id="t1614810055" t="borkdude This lib is truly amazing ;)"><y>#</y><d>2021-03-03</d><h>22:20</h><w>borkdude</w>This lib is truly amazing ;)</z><z id="t1614810344" t="seancorfield Yeah, :inline knows how to inline basic stuff: strings, numbers, booleans, but not much else."><y>#</y><d>2021-03-03</d><h>22:25</h><w>seancorfield</w>Yeah, <code>:inline</code> knows how to inline basic stuff: strings, numbers, booleans, but not much else.</z><z id="t1614810392" t="seancorfield https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L149-L155"><y>#</y><d>2021-03-03</d><h>22:26</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L149-L155" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L149-L155</a></z><z id="t1614810462" t="seancorfield Since [:array [1 2 3]] itself expands to ARRAY[?, ?, ?] and params, then :inline can handle it (by just inlining those numbers back into the SQL)."><y>#</y><d>2021-03-03</d><h>22:27</h><w>seancorfield</w>Since <code>[:array [1 2 3]]</code> itself expands to <code>ARRAY[?, ?, ?]</code> and params, then <code>:inline</code> can handle it (by just inlining those numbers back into the SQL).</z><z id="t1614892529" t="Scott Starkey Hi all - I have set up a postgresql server with my web host provider (Bluehost) and I’m trying to figure out the steps to basic database access. Is there a “Hello world!” guide to how to get set up with HoneySQL (or any other SQL)? I’ve set up a database and a user, but I’m a little lost on how to connect to it."><y>#</y><d>2021-03-04</d><h>21:15</h><w>Scott Starkey</w>Hi all - I have set up a postgresql server with my web host provider (Bluehost) and I’m trying to figure out the steps to basic database access. Is there a “Hello world!” guide to how to get set up with HoneySQL (or any other SQL)? I’ve set up a database and a user, but I’m a little lost on how to connect to it.</z><z id="t1614892987" t="seancorfield HoneySQL just turns Clojure data into SQL. It doesn&apos;t have anything to do with actually connecting to a database."><y>#</y><d>2021-03-04</d><h>21:23</h><w>seancorfield</w>HoneySQL just turns Clojure data into SQL. It doesn&apos;t have anything to do with actually connecting to a database.</z><z id="t1614893019" t="seancorfield You need to use next.jdbc to actually run any SQL against a database."><y>#</y><d>2021-03-04</d><h>21:23</h><w>seancorfield</w>You need to use <code>next.jdbc</code> to actually run any SQL against a database.</z><z id="t1614893084" t="seancorfield You would generally define a hash map that describes your database setup: {:dbtype &quot;postgres&quot; :dbname &quot;whatever&quot; :user &quot;dbauser&quot; :password &quot;secret&quot; :host &quot;ip-or-hostname&quot;}"><y>#</y><d>2021-03-04</d><h>21:24</h><w>seancorfield</w>You would generally define a hash map that describes your database setup: <code>{:dbtype &quot;postgres&quot; :dbname &quot;whatever&quot; :user &quot;dbauser&quot; :password &quot;secret&quot; :host &quot;ip-or-hostname&quot;}</code></z><z id="t1614893135" t="seancorfield Then you can run SQL against the DB via (next.jdbc/execute! db-spec (sql/format {:your :honeysql :data :here}))"><y>#</y><d>2021-03-04</d><h>21:25</h><w>seancorfield</w>Then you can run SQL against the DB via <code>(next.jdbc/execute! db-spec (sql/format {:your :honeysql :data :here}))</code></z><z id="t1614893164" t="seancorfield https://cljdoc.org/d/seancorfield/next.jdbc/1.1.613/doc/getting-started [:attrs {:href &quot;/_/_/users/UH0FTE610&quot;}]"><y>#</y><d>2021-03-04</d><h>21:26</h><w>seancorfield</w><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.1.613/doc/getting-started" target="_blank">https://cljdoc.org/d/seancorfield/next.jdbc/1.1.613/doc/getting-started</a> <a>@scotto</a></z><z id="t1615238356" t="Scott Starkey Hi Sean and others. I’m starting to take a hack at this, and I appreciate any help you could provide. I’ve done the basics at the link above, and got the following error message: db-hello-world.core&gt; (def ds (jdbc/get-datasource testmap)) ;; =&gt; #&apos;db-hello-world.core/ds db-hello-world.core&gt; (jdbc/execute! ds [&quot; create table address ( id int auto_increment primary key, name varchar(32), email varchar(255) )&quot;]) Execution error (SQLException) at java.sql.DriverManager/getConnection (DriverManager.java:689). No suitable driver found for ***My IP Address***:***My port number***/***My db name*** I’m not sure whether this is an error with my host provider giving me the wrong IP/port info, or if this is a problem with something else. “No suitable driver” makes it sound like I’m missing a driver! Can you help?"><y>#</y><d>2021-03-08</d><h>21:19</h><r>Scott Starkey</r>Hi Sean and others. I’m starting to take a hack at this, and I appreciate any help you could provide.

I’ve done the basics at the link above, and got the following error message:
<pre>db-hello-world.core&gt; (def ds (jdbc/get-datasource testmap))
;; =&gt; #&apos;db-hello-world.core/ds
db-hello-world.core&gt; (jdbc/execute! ds [&quot;
create table address (
  id int auto_increment primary key,
  name varchar(32),
  email varchar(255)
)&quot;])

Execution error (SQLException) at java.sql.DriverManager/getConnection (DriverManager.java:689).
No suitable driver found for ***My IP Address***:***My port number***/***My db  name***</pre>
I’m not sure whether this is an error with my host provider giving me the wrong IP/port info, or if this is a problem with something else.

“No suitable driver” makes it sound like I’m missing a driver! Can you help?</z><z id="t1615238567" t="seancorfield What is your testmap ?"><y>#</y><d>2021-03-08</d><h>21:22</h><r>seancorfield</r>What is your <code>testmap</code>?</z><z id="t1615238607" t="seancorfield That error generally means you have not specified a valid :dbtype"><y>#</y><d>2021-03-08</d><h>21:23</h><r>seancorfield</r>That error generally means you have not specified a valid <code>:dbtype</code></z><z id="t1615238783" t="seancorfield [:attrs {:href &quot;/_/_/users/UH0FTE610&quot;}] You&apos;re using PostgreSQL? Hosted somewhere non-local?"><y>#</y><d>2021-03-08</d><h>21:26</h><r>seancorfield</r><a>@scotto</a> You&apos;re using PostgreSQL? Hosted somewhere non-local?</z><z id="t1615238868" t="Scott Starkey Yeah, I want to host it at my hosting provider (bluehost). Eventually I would like it to be a web app."><y>#</y><d>2021-03-08</d><h>21:27</h><r>Scott Starkey</r>Yeah, I want to host it at my hosting provider (bluehost). Eventually I would like it to be a web app.</z><z id="t1615238967" t="seancorfield So I would expect something like this in your testmap : {:dbtype &quot;postgres&quot; :dbname &quot;...&quot; :user &quot;...&quot; :password &quot;...&quot; :host &quot;...&quot;} (assuming a default port for PostgreSQL which is 5432)"><y>#</y><d>2021-03-08</d><h>21:29</h><r>seancorfield</r>So I would expect something like this in your <code>testmap</code>: <code>{:dbtype &quot;postgres&quot; :dbname &quot;...&quot; :user &quot;...&quot; :password &quot;...&quot; :host &quot;...&quot;}</code> (assuming a default port for PostgreSQL which is 5432)</z><z id="t1615238996" t="Scott Starkey My testmap is {:dbtype &quot;postgres&quot;, :dbname &quot;&quot;, ; redacted :user &quot;&quot;, ; redacted :password &quot;&quot;, ; redacted :host &quot;162.241.216.221&quot;, ; The ip number that Bluehost told me. :port 3306} ; The port number that Bluehost told me."><y>#</y><d>2021-03-08</d><h>21:29</h><r>Scott Starkey</r>My testmap is
<pre>{:dbtype &quot;postgres&quot;,
 :dbname &quot;&quot;, ; redacted
 :user &quot;&quot;, ; redacted
 :password &quot;&quot;, ; redacted 
 :host &quot;162.241.216.221&quot;, ; The ip number that Bluehost told me.
 :port 3306} ; The port number that Bluehost told me.</pre></z><z id="t1615239017" t="seancorfield 3306 is normally MySQL, not PostgreSQL."><y>#</y><d>2021-03-08</d><h>21:30</h><r>seancorfield</r>3306 is normally MySQL, not PostgreSQL.</z><z id="t1615239025" t="Scott Starkey Ahhh…"><y>#</y><d>2021-03-08</d><h>21:30</h><r>Scott Starkey</r>Ahhh…</z><z id="t1615239035" t="Scott Starkey They might have given me wrong info."><y>#</y><d>2021-03-08</d><h>21:30</h><r>Scott Starkey</r>They might have given me wrong info.</z><z id="t1615239043" t="seancorfield In your project setup, do you have the appropriate database driver added as a dependency?"><y>#</y><d>2021-03-08</d><h>21:30</h><r>seancorfield</r>In your project setup, do you have the appropriate database driver added as a dependency?</z><z id="t1615239071" t="seancorfield Per the Getting Started docs: &quot;In addition, you will need to add dependencies for the JDBC drivers you wish to use for whatever databases you are using.&quot;"><y>#</y><d>2021-03-08</d><h>21:31</h><r>seancorfield</r>Per the Getting Started docs: &quot;In addition, you will need to add dependencies for the JDBC drivers you wish to use for whatever databases you are using.&quot;</z><z id="t1615239097" t="Scott Starkey :dependencies [[org.clojure/clojure &quot;1.10.3&quot;] [seancorfield/next.jdbc &quot;1.1.613&quot;]] I think so… ^"><y>#</y><d>2021-03-08</d><h>21:31</h><r>Scott Starkey</r><pre>:dependencies [[org.clojure/clojure &quot;1.10.3&quot;]
                 [seancorfield/next.jdbc &quot;1.1.613&quot;]]</pre>
I think so… ^</z><z id="t1615239111" t="seancorfield No, you have no JDBC drivers there."><y>#</y><d>2021-03-08</d><h>21:31</h><r>seancorfield</r>No, you have no JDBC drivers there.</z><z id="t1615239153" t="seancorfield The docs link to this part of the next.jdbc project https://github.com/seancorfield/next-jdbc/blob/develop/deps.edn#L10-L27 which shows a list of JDBC driver dependencies."><y>#</y><d>2021-03-08</d><h>21:32</h><r>seancorfield</r>The docs link to this part of the <code>next.jdbc</code> project <a href="https://github.com/seancorfield/next-jdbc/blob/develop/deps.edn#L10-L27" target="_blank">https://github.com/seancorfield/next-jdbc/blob/develop/deps.edn#L10-L27</a> which shows a list of JDBC driver dependencies.</z><z id="t1615239156" t="Scott Starkey Oh… sorry. Newbie…"><y>#</y><d>2021-03-08</d><h>21:32</h><r>Scott Starkey</r>Oh… sorry. Newbie…</z><z id="t1615239205" t="seancorfield As you said “No suitable driver” makes it sound like I’m missing a driver! Can you help? -- so you were correct that you are missing a driver."><y>#</y><d>2021-03-08</d><h>21:33</h><r>seancorfield</r>As you said <code>“No suitable driver” makes it sound like I’m missing a driver! Can you help?</code> -- so you were correct that you are missing a driver.</z><z id="t1615239213" t="Scott Starkey When this is fixed, I will buy you the beverage of your choice. 🙂 :thumbsup:"><y>#</y><d>2021-03-08</d><h>21:33</h><r>Scott Starkey</r>When this is fixed, I will buy you the beverage of your choice. <b>🙂</b> <b>:thumbsup:</b></z><z id="t1615239228" t="seancorfield PostgreSQL: org.postgresql/postgresql {:mvn/version &quot;42.2.10&quot;}"><y>#</y><d>2021-03-08</d><h>21:33</h><r>seancorfield</r>PostgreSQL: <code>org.postgresql/postgresql {:mvn/version &quot;42.2.10&quot;}</code></z><z id="t1615239239" t="seancorfield MySQL: mysql/mysql-connector-java {:mvn/version &quot;8.0.19&quot;}"><y>#</y><d>2021-03-08</d><h>21:33</h><r>seancorfield</r>MySQL: <code>mysql/mysql-connector-java {:mvn/version &quot;8.0.19&quot;}</code></z><z id="t1615239266" t="seancorfield Those aren&apos;t quite the latest versions but they should be recent enough for you."><y>#</y><d>2021-03-08</d><h>21:34</h><r>seancorfield</r>Those aren&apos;t quite the latest versions but they should be recent enough for you.</z><z id="t1615239327" t="seancorfield If Bluehost is really offering you MySQL instead of PostgreSQL, you want :dbtype &quot;mysql&quot; instead of :dbtype &quot;postgres&quot; (and you can omit :port 3306 since that is the default)"><y>#</y><d>2021-03-08</d><h>21:35</h><r>seancorfield</r>If Bluehost is really offering you MySQL instead of PostgreSQL, you want <code>:dbtype &quot;mysql&quot;</code> instead of <code>:dbtype &quot;postgres&quot;</code> (and you can omit <code>:port 3306</code> since that is the default)</z><z id="t1615239332" t="Scott Starkey I’m using Leiningen, so I assume I need: [org.postgresql/postgresql &quot;42.2.18.jre7&quot;]"><y>#</y><d>2021-03-08</d><h>21:35</h><r>Scott Starkey</r>I’m using Leiningen, so I assume I need: <code>[org.postgresql/postgresql &quot;42.2.18.jre7&quot;]</code></z><z id="t1615239370" t="seancorfield Are you using Java 7 or a more recent JVM?"><y>#</y><d>2021-03-08</d><h>21:36</h><r>seancorfield</r>Are you using Java 7 or a more recent JVM?</z><z id="t1615239419" t="Scott Starkey java version &quot;1.8.0_201&quot;"><y>#</y><d>2021-03-08</d><h>21:36</h><r>Scott Starkey</r><code>java version &quot;1.8.0_201&quot;</code></z><z id="t1615239426" t="seancorfield Looks like this is the most recent for Java 8 and above: https://search.maven.org/artifact/org.postgresql/postgresql/42.2.19/jar"><y>#</y><d>2021-03-08</d><h>21:37</h><r>seancorfield</r>Looks like this is the most recent for Java 8 and above: <a href="https://search.maven.org/artifact/org.postgresql/postgresql/42.2.19/jar" target="_blank">https://search.maven.org/artifact/org.postgresql/postgresql/42.2.19/jar</a></z><z id="t1615239452" t="seancorfield Scroll down and you&apos;ll see the Leiningen dep on the right hand side: [org.postgresql/postgresql &quot;42.2.19&quot;]"><y>#</y><d>2021-03-08</d><h>21:37</h><r>seancorfield</r>Scroll down and you&apos;ll see the Leiningen dep on the right hand side: <code>[org.postgresql/postgresql &quot;42.2.19&quot;]</code></z><z id="t1615239469" t="Scott Starkey Again. Thank you so much!"><y>#</y><d>2021-03-08</d><h>21:37</h><r>Scott Starkey</r>Again. Thank you so much!</z><z id="t1615239470" t="seancorfield The .jre7 and .jre6 versions are for older JVMs."><y>#</y><d>2021-03-08</d><h>21:37</h><r>seancorfield</r>The <code>.jre7</code> and <code>.jre6</code> versions are for older JVMs.</z><z id="t1615239621" t="seancorfield If you actually are connecting to MySQL, this is the latest version I recommend: https://search.maven.org/artifact/mysql/mysql-connector-java/8.0.22/jar (there&apos;s an 8.0.23 but it has a number of changes that can be a bit problematic, depending on your setup so I&apos;d say stick to 8.0.22 for now)."><y>#</y><d>2021-03-08</d><h>21:40</h><r>seancorfield</r>If you actually are connecting to MySQL, this is the latest version I recommend: <a href="https://search.maven.org/artifact/mysql/mysql-connector-java/8.0.22/jar" target="_blank">https://search.maven.org/artifact/mysql/mysql-connector-java/8.0.22/jar</a> (there&apos;s an 8.0.23 but it has a number of changes that can be a bit problematic, depending on your setup so I&apos;d say stick to 8.0.22 for now).</z><z id="t1614893658" t="Scott Starkey Thank you, kindly!"><y>#</y><d>2021-03-04</d><h>21:34</h><w>Scott Starkey</w>Thank you, kindly!</z><z id="t1615139928" t="seancorfield I plan to cut 2.0.0 Alpha 3 &quot;soon&quot;, now that I&apos;ve incorporated [:attrs {:href &quot;/_/_/users/U42REFCKA&quot;}] ’s &quot;smarter&quot; where/having and merge variants into the 2.x branch (and got all of his additional tests working -- although I still need to update the where/having docs to reflect that). Are there particular things in this list of open issues https://github.com/seancorfield/honeysql/issues that folks would like to see in Alpha 3 (vs a later milestone)? My goal is to hit Beta 1 in late March/early April which would be the signal that the API will no longer change in any breaking ways (and all subsequent changes would be purely accretive/fixative). Beta 1 will also signal that the documentation is &quot;complete&quot; insofar as every feature is documented and all public functions have docstrings. I anticipate the documentation continuing to improve well beyond the point of &quot;completion&quot;. Feel free to add comments to issues you care strongly about so I can get a sense of what my priorities should be for Alpha 3. Oh, and Alpha 3 will be published as com.github.seancorfield/honeysql but not as seancorfield/honeysql ."><y>#</y><d>2021-03-07</d><h>17:58</h><w>seancorfield</w>I plan to cut 2.0.0 Alpha 3 &quot;soon&quot;, now that I&apos;ve incorporated <a>@camsaul</a>’s &quot;smarter&quot; where/having and merge variants into the 2.x branch (and got all of his additional tests working -- although I still need to update the where/having docs to reflect that). Are there particular things in this list of open issues <a href="https://github.com/seancorfield/honeysql/issues" target="_blank">https://github.com/seancorfield/honeysql/issues</a> that folks would like to see in Alpha 3 (vs a later milestone)? My goal is to hit Beta 1 in late March/early April which would be the signal that the API will no longer change in any breaking ways (and all subsequent changes would be purely accretive/fixative). Beta 1 will also signal that the documentation is &quot;complete&quot; insofar as every feature is documented and all public functions have docstrings. I anticipate the documentation continuing to improve well beyond the point of &quot;completion&quot;. Feel free to add comments to issues you care strongly about so I can get a sense of what my priorities should be for Alpha 3. Oh, and Alpha 3 will be published as <code>com.github.seancorfield/honeysql</code> but not as <code>seancorfield/honeysql</code>.</z><z id="t1615147150" t="dharrigan Thre&apos;s a lot of good things in that issues list"><y>#</y><d>2021-03-07</d><h>19:59</h><w>dharrigan</w>Thre&apos;s a lot of good things in that issues list</z><z id="t1615147153" t="dharrigan hard to choose 😉"><y>#</y><d>2021-03-07</d><h>19:59</h><w>dharrigan</w>hard to choose <b>😉</b></z><z id="t1615147755" t="dharrigan If I was to order them from a functional POV (rather than documentation or project POV), I suppose: #292, #284, #301, #297, #277, #306, #280, #303, #278."><y>#</y><d>2021-03-07</d><h>20:09</h><w>dharrigan</w>If I was to order them from a functional POV (rather than documentation or project POV), I suppose: #292, #284, #301, #297, #277, #306, #280, #303, #278.</z><z id="t1615147763" t="dharrigan (slight postgresql bias there 😉 )"><y>#</y><d>2021-03-07</d><h>20:09</h><w>dharrigan</w>(slight postgresql bias there <b>😉</b> )</z><z id="t1615148459" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] Can you add comments to those indicating your priorities, so I have them on record?"><y>#</y><d>2021-03-07</d><h>20:20</h><w>seancorfield</w><a>@dharrigan</a> Can you add comments to those indicating your priorities, so I have them on record?</z><z id="t1615148482" t="dharrigan comments?"><y>#</y><d>2021-03-07</d><h>20:21</h><w>dharrigan</w>comments?</z><z id="t1615148486" t="seancorfield Or at least do a &quot;thumbs up&quot; on them."><y>#</y><d>2021-03-07</d><h>20:21</h><w>seancorfield</w>Or at least do a &quot;thumbs up&quot; on them.</z><z id="t1615148492" t="dharrigan ah, on github"><y>#</y><d>2021-03-07</d><h>20:21</h><w>dharrigan</w>ah, on github</z><z id="t1615148509" t="seancorfield Then I&apos;ll tackle issues that seem to have the most &quot;votes&quot; etc."><y>#</y><d>2021-03-07</d><h>20:21</h><w>seancorfield</w>Then I&apos;ll tackle issues that seem to have the most &quot;votes&quot; etc.</z><z id="t1615148516" t="dharrigan kk nae problemo!"><y>#</y><d>2021-03-07</d><h>20:21</h><w>dharrigan</w>kk nae problemo!</z><z id="t1615148742" t="dharrigan and done"><y>#</y><d>2021-03-07</d><h>20:25</h><w>dharrigan</w>and done</z><z id="t1615402002" t="bartuka Hi, I need an extra help with insert-into. I have a data like: (def my-data [{:value1 &quot;1&quot;, :mymap {:map2 &quot;42&quot;}}]) this can potentially be several maps and I want to insert-many. (jdbc/execute! datasource (-&gt; {:insert-into :Table :values my-data} (sql/format))) but I got an error Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2553). ERROR: syntax error at or near &quot;)&quot; The sql query generate will be (-&gt; {:insert-into :Table :values [{:value1 &quot;1&quot; :mymap {:map2 &quot;42&quot;}}]} (sql/format)) ;; =&gt; [&quot;INSERT INTO Table (value1, mymap) VALUES (?, ())&quot; &quot;1&quot;] "><y>#</y><d>2021-03-10</d><h>18:46</h><w>bartuka</w>Hi, I need an extra help with insert-into. I have a data like:

<pre>(def my-data [{:value1 &quot;1&quot;, :mymap {:map2 &quot;42&quot;}}])</pre>
this can potentially be several maps and I want to insert-many.

<pre>(jdbc/execute! datasource (-&gt; {:insert-into :Table :values my-data} (sql/format)))</pre>
but I got an error

<pre>Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2553).
ERROR: syntax error at or near &quot;)&quot;</pre>
The sql query generate will be
<pre>(-&gt; {:insert-into :Table
     :values [{:value1 &quot;1&quot; :mymap {:map2 &quot;42&quot;}}]}
     (sql/format))
;; =&gt; [&quot;INSERT INTO Table (value1, mymap) VALUES (?, ())&quot; &quot;1&quot;]</pre>
</z><z id="t1615402033" t="bartuka I feel I am missing something here. Not sure if I need to add something specific into sql/format"><y>#</y><d>2021-03-10</d><h>18:47</h><w>bartuka</w>I feel I am missing something here. Not sure if I need to add something specific into <code>sql/format</code></z><z id="t1615403745" t="seancorfield [:attrs {:href &quot;/_/_/users/UBSREKQ5Q&quot;}] Which version of HoneySQL are you using? And what does it mean to have a column whose value is a hash map?"><y>#</y><d>2021-03-10</d><h>19:15</h><w>seancorfield</w><a>@iagwanderson</a> Which version of HoneySQL are you using? And what does it mean to have a column whose value is a hash map?</z><z id="t1615403779" t="bartuka version &quot;1.0.461&quot;, the hashmap is coerced to jsonb fields"><y>#</y><d>2021-03-10</d><h>19:16</h><w>bartuka</w>version &quot;1.0.461&quot;, the hashmap is coerced to jsonb fields</z><z id="t1615403879" t="seancorfield With 2.0, you can do this: user=&gt; (-&gt; {:insert-into :Table #_=&gt; :values [{:value1 &quot;1&quot; :mymap [:lift {:map2 &quot;42&quot;}]}]} #_=&gt; (sql/format)) [&quot;INSERT INTO Table (value1, mymap) VALUES (?, ?)&quot; &quot;1&quot; {:map2 &quot;42&quot;}] I&apos;m not sure what the solution is in 1.0, probably wrapping it in (sql/param ..) ?"><y>#</y><d>2021-03-10</d><h>19:17</h><w>seancorfield</w>With 2.0, you can do this:
<pre>user=&gt; (-&gt; {:insert-into :Table
  #_=&gt;      :values [{:value1 &quot;1&quot; :mymap [:lift {:map2 &quot;42&quot;}]}]}
  #_=&gt;      (sql/format))
[&quot;INSERT INTO Table (value1, mymap) VALUES (?, ?)&quot; &quot;1&quot; {:map2 &quot;42&quot;}]</pre>
I&apos;m not sure what the solution is in 1.0, probably wrapping it in <code>(sql/param ..)</code>?</z><z id="t1615403976" t="seancorfield Nope, not sql/param"><y>#</y><d>2021-03-10</d><h>19:19</h><w>seancorfield</w>Nope, not <code>sql/param</code></z><z id="t1615403989" t="bartuka I tried, sql/param too."><y>#</y><d>2021-03-10</d><h>19:19</h><w>bartuka</w>I tried, sql/param too.</z><z id="t1615404013" t="seancorfield I&apos;m not sure if it&apos;s possible with 1.0."><y>#</y><d>2021-03-10</d><h>19:20</h><w>seancorfield</w>I&apos;m not sure if it&apos;s possible with 1.0.</z><z id="t1615404047" t="seancorfield (well, I&apos;m sure it is possible but I don&apos;t know how, off the top of my head)"><y>#</y><d>2021-03-10</d><h>19:20</h><w>seancorfield</w>(well, I&apos;m sure it is possible but I don&apos;t know how, off the top of my head)</z><z id="t1615404148" t="bartuka I will investigate this further later on and fix my situation now using next.jdbc directly. Would be good idea to create an issue as enhancement to support this? At least for tracking and generate docs if current facilities allow"><y>#</y><d>2021-03-10</d><h>19:22</h><w>bartuka</w>I will investigate this further later on and fix my situation now using next.jdbc directly. Would be good idea to create an issue as enhancement to support this? At least for tracking and generate docs if current facilities allow</z><z id="t1615404231" t="seancorfield It works in 2.0 as shown above. If it isn&apos;t possible in 1.0, it won&apos;t get fixed at this point."><y>#</y><d>2021-03-10</d><h>19:23</h><w>seancorfield</w>It works in 2.0 as shown above. If it isn&apos;t possible in 1.0, it won&apos;t get fixed at this point.</z><z id="t1615404356" t="seancorfield If you figure out how to do it in 1.0, I&apos;d accept a PR for the docs for 1.0, but I&apos;d encourage you you start upgrading to 2.0 at this point: you can depend on both versions at the same time -- different group IDs and different namespaces -- so you could use 2.0 for just that one insert if you wanted, and stay with 1.0 for everything else."><y>#</y><d>2021-03-10</d><h>19:25</h><w>seancorfield</w>If you figure out how to do it in 1.0, I&apos;d accept a PR for the docs for 1.0, but I&apos;d encourage you you start upgrading to 2.0 at this point: you can depend on both versions at the same time -- different group IDs and different namespaces -- so you could use 2.0 for just that one insert if you wanted, and stay with 1.0 for everything else.</z><z id="t1615404436" t="bartuka &gt; If you figure out how to do it in 1.0, I&apos;d accept a PR for the docs for 1.0, but I&apos;d encourage you you start upgrading to 2.0 at this point: you can depend on both versions at the same time -- different group IDs and different namespaces -- so you could use 2.0 for just that one insert if you wanted, and stay with 1.0 for everything else. nice, it makes sense. thank you!"><y>#</y><d>2021-03-10</d><h>19:27</h><w>bartuka</w>&gt; If you figure out how to do it in 1.0, I&apos;d accept a PR for the docs for 1.0, but I&apos;d encourage you you start upgrading to 2.0 at this point: you can depend on both versions at the same time -- different group IDs and different namespaces -- so you could use 2.0 for just that one insert if you wanted, and stay with 1.0 for everything else.
nice, it makes sense. thank you!</z><z id="t1615474164" t="murtaza 👋 We’ve released a new version of honeysql-postgres with support for more PG clauses, minor improvements, and a revamped readme. • https://github.com/nilenso/honeysql-postgres/releases/tag/0.3.104 • https://github.com/nilenso/honeysql-postgres/releases/tag/0.4.112 • https://github.com/nilenso/honeysql-postgres/blob/master/CHANGELOG.md "><y>#</y><d>2021-03-11</d><h>14:49</h><w>murtaza</w><b>👋</b>

 We’ve released a new version of honeysql-postgres with support for more PG clauses, minor improvements, and a revamped readme.

• <a href="https://github.com/nilenso/honeysql-postgres/releases/tag/0.3.104" target="_blank">https://github.com/nilenso/honeysql-postgres/releases/tag/0.3.104</a>
• <a href="https://github.com/nilenso/honeysql-postgres/releases/tag/0.4.112" target="_blank">https://github.com/nilenso/honeysql-postgres/releases/tag/0.4.112</a>
• <a href="https://github.com/nilenso/honeysql-postgres/blob/master/CHANGELOG.md" target="_blank">https://github.com/nilenso/honeysql-postgres/blob/master/CHANGELOG.md</a>
</z><z id="t1615475189" t="murtaza We&apos;ve also added a note about the progress being made in Honeysql 2.0 for people who may be looking for pg support"><y>#</y><d>2021-03-11</d><h>15:06</h><w>murtaza</w>We&apos;ve also added a note about the progress being made in Honeysql 2.0 for people who may be looking for pg support</z><z id="t1615483038" t="seancorfield https://github.com/seancorfield/honeysql/issues/310 🙂"><y>#</y><d>2021-03-11</d><h>17:17</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/310" target="_blank">https://github.com/seancorfield/honeysql/issues/310</a> <b>🙂</b></z><z id="t1615483126" t="borkdude how do I write this? (sql/format {:update :foo :set {:dismiss &quot;dissmis + 1&quot;}})"><y>#</y><d>2021-03-11</d><h>17:18</h><w>borkdude</w>how do I write this?
<pre>(sql/format {:update :foo :set {:dismiss &quot;dissmis + 1&quot;}})</pre></z><z id="t1615483206" t="borkdude I tend to just go with hugsql for queries like this"><y>#</y><d>2021-03-11</d><h>17:20</h><w>borkdude</w>I tend to just go with hugsql for queries like this</z><z id="t1615483217" t="borkdude but there might be a good way to do it in honeysql?"><y>#</y><d>2021-03-11</d><h>17:20</h><w>borkdude</w>but there might be a good way to do it in honeysql?</z><z id="t1615483300" t="seancorfield [:+ dissmis 1] is the expression"><y>#</y><d>2021-03-11</d><h>17:21</h><w>seancorfield</w><code>[:+ dissmis 1]</code> is the expression</z><z id="t1615483332" t="seancorfield user=&gt; (sql/format {:update :foo :set {:dismiss [:+ :dissmis 1]}}) [&quot;UPDATE foo SET dismiss = dissmis + ?&quot; 1]"><y>#</y><d>2021-03-11</d><h>17:22</h><w>seancorfield</w><pre>user=&gt; (sql/format {:update :foo :set {:dismiss [:+ :dissmis 1]}})
[&quot;UPDATE foo SET dismiss = dissmis + ?&quot; 1]</pre></z><z id="t1615483389" t="seancorfield [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] There&apos;s an example of that in the README: (-&gt; (h/update :films) (set {:kind &quot;dramatic&quot; :watched [:+ :watched 1]}) (where [:= :kind &quot;drama&quot;]) (sql/format {:pretty true})) =&gt; [&quot; UPDATE films SET kind = ?, watched = watched + ? WHERE kind = ? &quot; &quot;dramatic&quot; 1 &quot;drama&quot;] ;; or as pure data DSL: (-&gt; {:update :films, :set {:kind &quot;dramatic&quot;, :watched [:+ :watched 1]}, :where [:= :kind &quot;drama&quot;]} (sql/format {:pretty true})) =&gt; [&quot; UPDATE films SET kind = ?, watched = watched + ? WHERE kind = ? &quot; &quot;dramatic&quot; 1 &quot;drama&quot;]"><y>#</y><d>2021-03-11</d><h>17:23</h><w>seancorfield</w><a>@borkdude</a> There&apos;s an example of that in the README:
<pre>(-&gt; (h/update :films)
    (set {:kind &quot;dramatic&quot;
           :watched [:+ :watched 1]})
    (where [:= :kind &quot;drama&quot;])
    (sql/format {:pretty true}))
=&gt; [&quot;
UPDATE films
SET kind = ?, watched = watched + ?
WHERE kind = ?
&quot;
&quot;dramatic&quot;
1
&quot;drama&quot;]
;; or as pure data DSL:
(-&gt; {:update :films,
     :set {:kind &quot;dramatic&quot;, :watched [:+ :watched 1]},
     :where [:= :kind &quot;drama&quot;]}
    (sql/format {:pretty true}))
=&gt; [&quot;
UPDATE films
SET kind = ?, watched = watched + ?
WHERE kind = ?
&quot;
&quot;dramatic&quot;
1
&quot;drama&quot;]</pre></z><z id="t1615483411" t="seancorfield See https://github.com/seancorfield/honeysql/tree/v2#updates"><y>#</y><d>2021-03-11</d><h>17:23</h><w>seancorfield</w>See <a href="https://github.com/seancorfield/honeysql/tree/v2#updates" target="_blank">https://github.com/seancorfield/honeysql/tree/v2#updates</a></z><z id="t1615483421" t="borkdude I am using v1 still at work."><y>#</y><d>2021-03-11</d><h>17:23</h><w>borkdude</w>I am using v1 still at work.</z><z id="t1615483432" t="seancorfield There&apos;s an example in the v1 readme too!"><y>#</y><d>2021-03-11</d><h>17:23</h><w>seancorfield</w>There&apos;s an example in the v1 readme too!</z><z id="t1615483460" t="borkdude my bad then, but thanks for answering :)"><y>#</y><d>2021-03-11</d><h>17:24</h><w>borkdude</w>my bad then, but thanks for answering :)</z><z id="t1615483465" t="seancorfield You have to use (sql/call :+ :watched 1) in V1 https://github.com/seancorfield/honeysql#updates"><y>#</y><d>2021-03-11</d><h>17:24</h><w>seancorfield</w>You have to use <code>(sql/call :+ :watched 1)</code> in V1 <a href="https://github.com/seancorfield/honeysql#updates" target="_blank">https://github.com/seancorfield/honeysql#updates</a></z><z id="t1615483490" t="borkdude I see yeah, hm. I did scan the unit tests for this"><y>#</y><d>2021-03-11</d><h>17:24</h><w>borkdude</w>I see yeah, hm. I did scan the unit tests for this</z><z id="t1615483535" t="seancorfield (I know the V1 readme only uses helpers -- you can always run the helper version in the REPL without sql/format to see what the equivalent data structure would be)"><y>#</y><d>2021-03-11</d><h>17:25</h><w>seancorfield</w>(I know the V1 readme only uses helpers -- you can always run the helper version in the REPL without <code>sql/format</code> to see what the equivalent data structure would be)</z><z id="t1615483585" t="borkdude thanks a lot, this helps"><y>#</y><d>2021-03-11</d><h>17:26</h><w>borkdude</w>thanks a lot, this helps</z><z id="t1615483602" t="borkdude I still think the helpers are somewhat magic, but I guess not"><y>#</y><d>2021-03-11</d><h>17:26</h><w>borkdude</w>I still think the helpers are somewhat magic, but I guess not</z><z id="t1615483641" t="seancorfield They&apos;re a lot less &quot;magic&quot; in V2 since they&apos;re nearly all implemented with the same generic function 🙂"><y>#</y><d>2021-03-11</d><h>17:27</h><w>seancorfield</w>They&apos;re a lot less &quot;magic&quot; in V2 since they&apos;re nearly all implemented with the same generic function <b>🙂</b></z><z id="t1615509289" t="maxp [:attrs {:href &quot;/_/_/users/UBSREKQ5Q&quot;}] You can use named parameter in insert-into and after that pass param-map to sql/format."><y>#</y><d>2021-03-12</d><h>00:34</h><w>maxp</w><a>@iagwanderson</a> You can use named parameter in insert-into and after that pass param-map to sql/format.</z><z id="t1615509429" t="maxp something like (-&gt; (insert-into :table) (values [{:map_field :?my-map}]) (sql/format {:my-map {:a :b}})) "><y>#</y><d>2021-03-12</d><h>00:37</h><w>maxp</w>something like
<pre>(-&gt; 
  (insert-into :table) 
  (values [{:map_field :?my-map}])
  (sql/format {:my-map {:a :b}}))</pre>
</z><z id="t1615510316" t="seancorfield Thanks [:attrs {:href &quot;/_/_/users/U0666UM3J&quot;}] — I tend to forget about named parameters because I never use them."><y>#</y><d>2021-03-12</d><h>00:51</h><w>seancorfield</w>Thanks <a>@maxp</a> — I tend to forget about named parameters because I never use them.</z><z id="t1615578371" t="seancorfield Just committed extended support for create /`drop` for tables, views, materialized views. Also refresh support for the latter. Docs to come but hopefully the tests explain enough of it for now."><y>#</y><d>2021-03-12</d><h>19:46</h><w>seancorfield</w>Just committed extended support for <code>create</code>/`drop` for tables, views, materialized views. Also <code>refresh</code> support for the latter. Docs to come but hopefully the tests explain enough of it for now.</z><z id="t1615578377" t="seancorfield ^ [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] 🙂"><y>#</y><d>2021-03-12</d><h>19:46</h><w>seancorfield</w>^ <a>@dharrigan</a> <b>🙂</b></z><z id="t1615621606" t="dharrigan thank you! looks great!"><y>#</y><d>2021-03-13</d><h>07:46</h><w>dharrigan</w>thank you! looks great!</z><z id="t1615679981" t="seancorfield com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha3&quot;} is available on Clojars for testing — lots of new stuff in this Alpha release: * Change coordinates to com.github.seancorfield/honeysql (although new versions will continue to be deployed to seancorfield/honeysql for a while -- see the [Clojars Verified Group Names policy]( https://github.com/clojars/clojars-web/wiki/Verified-Group-Names) ). * Support much richer range of syntax on CREATE /`DROP` statements in general, including columns, TABLESPACE , CASCADE , WITH [NO] DATA , etc. * Fix #306 by supporting CREATE TABLE .. AS .. . * Fix #305 by supporting more complex join clauses. * Fix #303 by supporting MySQL’s ON DUPLICATE KEY UPDATE . * Fix #301 by adding support for CREATE /`DROP`/`REFRESH` on MATERIALIZED VIEW . * Add tests to confirm #299 does not affect v2. * Fix #297 by adding both SELECT .. INTO .. and SELECT .. BULK COLLECT INTO .. . * Fix #295 by adding docstrings to all helper functions (and adding an assert to ensure it stays that way as more are added in future). * Confirm the whole of the [nilenso/honeysql-postgres]( https://github.com/nilenso/honeysql-postgres ) is implemented out-of-the-box (#293, but see #310 for recent additions not yet incorporated). * Fix #292 by adding support for SELECT TOP and OFFSET /`FETCH`. * Fix #284 by adding support for LATERAL (as special syntax, with a helper). * Reconcile where behavior with recent 1.0 changes (porting #283 to v2). * Fix #280 by adding :escape as special syntax for regular expression patterns. * Fix #277 by adding :join-by /`join-by` so that you can have multiple JOIN ’s in a specific order."><y>#</y><d>2021-03-13</d><h>23:59</h><w>seancorfield</w><code>com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-alpha3&quot;}</code> is available on Clojars for testing — lots of new stuff in this Alpha release:
  * Change coordinates to <code>com.github.seancorfield/honeysql</code> (although new versions will continue to be deployed to <code>seancorfield/honeysql</code> for a while -- see the [Clojars Verified Group Names policy](<a href="https://github.com/clojars/clojars-web/wiki/Verified-Group-Names)" target="_blank">https://github.com/clojars/clojars-web/wiki/Verified-Group-Names)</a>).
  * Support much richer range of syntax on <code>CREATE</code>/`DROP` statements in general, including columns, <code>TABLESPACE</code>, <code>CASCADE</code>, <code>WITH [NO] DATA</code>, etc.
  * Fix #306 by supporting <code>CREATE TABLE .. AS ..</code>.
  * Fix #305 by supporting more complex join clauses.
  * Fix #303 by supporting MySQL’s <code>ON DUPLICATE KEY UPDATE</code>.
  * Fix #301 by adding support for <code>CREATE</code>/`DROP`/`REFRESH` on <code>MATERIALIZED VIEW</code>.
  * Add tests to confirm #299 does not affect v2.
  * Fix #297 by adding both <code>SELECT .. INTO ..</code> and <code>SELECT .. BULK COLLECT INTO ..</code>.
  * Fix #295 by adding docstrings to all helper functions (and adding an assert to ensure it stays that way as more are added in future).
  * Confirm the whole of the [nilenso/honeysql-postgres](<a href="https://github.com/nilenso/honeysql-postgres" target="_blank">https://github.com/nilenso/honeysql-postgres</a>) is implemented out-of-the-box (#293, but see #310 for recent additions not yet incorporated).
  * Fix #292 by adding support for <code>SELECT TOP</code> and <code>OFFSET</code>/`FETCH`.
  * Fix #284 by adding support for <code>LATERAL</code> (as special syntax, with a helper).
  * Reconcile <code>where</code> behavior with recent 1.0 changes (porting #283 to v2).
  * Fix #280 by adding <code>:escape</code> as special syntax for regular expression patterns.
  * Fix #277 by adding <code>:join-by</code>/`join-by` so that you can have multiple <code>JOIN</code>’s in a specific order.</z><z id="t1615680246" t="seancorfield (ugh, I cut the tag on the wrong branch… let me fix that — the JAR on Clojars is correct!)"><y>#</y><d>2021-03-14</d><h>00:04</h><w>seancorfield</w>(ugh, I cut the tag on the wrong branch… let me fix that — the JAR on Clojars is correct!)</z><z id="t1615680588" t="seancorfield Fixed! Updated docs https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/readme"><y>#</y><d>2021-03-14</d><h>00:09</h><w>seancorfield</w>Fixed! Updated docs <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/readme" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/readme</a></z><z id="t1615835861" t="dcj I am attempting to migrate to honeysql 2 from 1. Many things are working, but I&apos;m having trouble with one very complex CTE: The docs for with state: The argument to :with (or :with-recursive) is a sequences of pairs, each of a result set name (or description) and a basic SQL statement I&apos;m having trouble parsing this, and the examples given use a different style than I am used to.... Previously I did something like: (with [:A &quot;some sql thing&quot;] [:B &quot;another sql thing&quot;] ...) Is that still valid?"><y>#</y><d>2021-03-15</d><h>19:17</h><w>dcj</w>I am attempting to migrate to honeysql 2 from 1.
Many things are working, but I&apos;m having trouble with one very complex CTE:
The docs for <code>with</code> state:
<pre>The argument to :with (or :with-recursive) is a sequences of pairs, each of a result set name (or description) and a basic SQL statement</pre>
I&apos;m having trouble parsing this, and the examples given use a different style than I am used to....
Previously I did something like:
<pre>(with [:A &quot;some sql thing&quot;]
      [:B &quot;another sql thing&quot;]
      ...)</pre>
Is that still valid?</z><z id="t1615837187" t="seancorfield I don’t think that, as written, has ever been valid with strings."><y>#</y><d>2021-03-15</d><h>19:39</h><w>seancorfield</w>I don’t think that, as written, has ever been valid with strings.</z><z id="t1615837229" t="seancorfield (with [:A [&quot;some sql thing&quot; its params]] [:B [&quot;another sql thing&quot; more params]]) is more like it."><y>#</y><d>2021-03-15</d><h>19:40</h><w>seancorfield</w><code>(with [:A [&quot;some sql thing&quot; its params]] [:B [&quot;another sql thing&quot; more params]])</code> is more like it.</z><z id="t1615837332" t="seancorfield Can you share exactly what you had with v1 that worked (that no longer works the same in v2)?"><y>#</y><d>2021-03-15</d><h>19:42</h><w>seancorfield</w>Can you share exactly what you had with v1 that worked (that no longer works the same in v2)?</z><z id="t1615837405" t="seancorfield The syntax should not have changed between v1 and v2 as far as I’m aware [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}]"><y>#</y><d>2021-03-15</d><h>19:43</h><w>seancorfield</w>The syntax should not have changed between v1 and v2 as far as I’m aware <a>@dcj</a></z><z id="t1615837509" t="seancorfield There are two CTEs in the V1 tests: https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/core_test.cljc#L16-L62 and here’s the same tests for v2 https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L22-L62"><y>#</y><d>2021-03-15</d><h>19:45</h><w>seancorfield</w>There are two CTEs in the V1 tests: <a href="https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/core_test.cljc#L16-L62" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/test/honeysql/core_test.cljc#L16-L62</a> and here’s the same tests for v2 <a href="https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L22-L62" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/test/honey/sql/helpers_test.cljc#L22-L62</a></z><z id="t1615837596" t="seancorfield The difference there is that modifiers no longer exists in v2 (`:select-distinct` replaces :select and :modifiers as separate things)."><y>#</y><d>2021-03-15</d><h>19:46</h><w>seancorfield</w>The difference there is that <code>modifiers</code> no longer exists in v2 (`:select-distinct` replaces <code>:select</code> and <code>:modifiers</code> as separate things).</z><z id="t1615839030" t="dcj Sorry, I over simplified my example with and confused things. I don&apos;t use strings, your re-write is basically indeed what I did both before and now"><y>#</y><d>2021-03-15</d><h>20:10</h><w>dcj</w>Sorry, I over simplified my example <code>with</code> and confused things.  I don&apos;t  use strings, your re-write is basically indeed what I did both before and now</z><z id="t1615839173" t="seancorfield Sounds like you’ll need to share more of what code you actually have then and compare the V1 and V2 data structures produced and what the formatter does with each. That’s why V2 has different namespaces so you can try them side-by-side."><y>#</y><d>2021-03-15</d><h>20:12</h><w>seancorfield</w>Sounds like you’ll need to share more of what code you actually have then and compare the V1 and V2 data structures produced and what the formatter does with each. That’s why V2 has different namespaces so you can try them side-by-side.</z><z id="t1615840231" t="bartuka hi!! is it possible to perform select from values in honeysql? =&gt; SELECT * FROM (VALUES (1, &apos;one&apos;), (2, &apos;two&apos;), (3, &apos;three&apos;)) AS t (num,letter); ? I am still getting the hang of it."><y>#</y><d>2021-03-15</d><h>20:30</h><w>bartuka</w>hi!! is it possible to perform select from values in honeysql? <code>=&gt; SELECT * FROM (VALUES (1, &apos;one&apos;), (2, &apos;two&apos;), (3, &apos;three&apos;)) AS t (num,letter);</code> ? I am still getting the hang of it.</z><z id="t1615843730" t="seancorfield In V2: user=&gt; (-&gt; (select :*) (from [(values [[1, &quot;one&quot;] [2, &quot;two&quot;] [3, &quot;three&quot;]]) :t]) (sql/format)) [&quot;SELECT * FROM (VALUES (?, ?), (?, ?), (?, ?)) AS t&quot; 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;]"><y>#</y><d>2021-03-15</d><h>21:28</h><w>seancorfield</w>In V2:
<pre>user=&gt; (-&gt; (select :*) (from [(values [[1, &quot;one&quot;] [2, &quot;two&quot;] [3, &quot;three&quot;]]) :t]) (sql/format))
[&quot;SELECT * FROM (VALUES (?, ?), (?, ?), (?, ?)) AS t&quot; 1 &quot;one&quot; 2 &quot;two&quot; 3 &quot;three&quot;]</pre></z><z id="t1615843782" t="seancorfield Not sure about the (num,letter) piece at the end… I don’t even understand that SQL syntax…"><y>#</y><d>2021-03-15</d><h>21:29</h><w>seancorfield</w>Not sure about the <code>(num,letter)</code> piece at the end… I don’t even understand that SQL syntax…</z><z id="t1615850794" t="dcj Here is the raw SQL string I am attempting to model in honey2: (SELECT fid, pca_raw, dca, X.path[1] AS id, X.geom AS g, ST_M(geom) AS m FROM flts_close CROSS JOIN ST_DumpPoints(t_trajectory) AS X) So: (println (sql/format (-&gt; (select :fid :pca_raw :dca [[:raw &quot;X.path[1]&quot;] :id] [:X.geom :g] [[:ST_M :geom] :m]) (from :flts_close) (sql.helpers/cross-join [[:ST_DumpPoints :t_trajectory] :X])))) [SELECT fid, pca_raw, dca, X.path[1] AS id, X.geom AS g, ST_M(geom) AS m FROM flts_close CROSS JOIN ST_DUMPPOINTS(t_trajectory) X] Is the part after the CROSS JOIN the same as AS X above?"><y>#</y><d>2021-03-15</d><h>23:26</h><w>dcj</w>Here is the raw SQL string I am attempting to model in honey2:
<pre>(SELECT fid, pca_raw, dca, X.path[1] AS id, X.geom AS g, ST_M(geom) AS m FROM flts_close CROSS JOIN ST_DumpPoints(t_trajectory) AS X)</pre>
So:
<pre>(println (sql/format (-&gt; (select :fid :pca_raw :dca [[:raw &quot;X.path[1]&quot;] :id] [:X.geom :g] [[:ST_M :geom] :m])
                                (from :flts_close)
                                (sql.helpers/cross-join [[:ST_DumpPoints :t_trajectory] :X]))))

[SELECT fid, pca_raw, dca, X.path[1] AS id, X.geom AS g, ST_M(geom) AS m FROM flts_close CROSS JOIN ST_DUMPPOINTS(t_trajectory) X]</pre>
Is the part after the CROSS JOIN the same as <code>AS X</code> above?</z><z id="t1615851442" t="dcj Apparently yes!"><y>#</y><d>2021-03-15</d><h>23:37</h><w>dcj</w>Apparently yes!</z><z id="t1615851713" t="seancorfield In cross join x as y , the x as y part is just an aliased pair (like other joins). I’ll have a think about that array indexing syntax but I don’t realistically think there’s anything I can do that would make it easier/neater in HoneySQL than wrapping [:raw ..] around the expressions."><y>#</y><d>2021-03-15</d><h>23:41</h><w>seancorfield</w>In <code>cross join x as y</code>, the <code>x as y</code> part is just an aliased pair (like other joins). I’ll have a think about that array indexing syntax but I don’t realistically think there’s anything I can do that would make it easier/neater in HoneySQL than wrapping <code>[:raw ..]</code> around the expressions.</z><z id="t1615857686" t="dcj Here is the latest v2 &quot;puzzle&quot;: The SQL I&apos;m trying to generate is: LEAD(g) OVER (PARTITION BY fid ORDER BY m) I&apos;ve tried this: (sql.helpers/over [[:lead :g] (-&gt; (sql.helpers/partition-by :fid) (order-by :m))]) which generates: [[:over [[:lead :g] {:partition-by [:fid], :order-by [:m]}]]] which sql/format chokes on"><y>#</y><d>2021-03-16</d><h>01:21</h><w>dcj</w>Here is the latest v2 &quot;puzzle&quot;:
The SQL I&apos;m trying to generate is:
<pre>LEAD(g) OVER (PARTITION BY fid ORDER BY m)</pre>
I&apos;ve tried this:
<pre>(sql.helpers/over [[:lead :g]
                   (-&gt; (sql.helpers/partition-by :fid) (order-by :m))])</pre>
which generates:
<pre>[[:over [[:lead :g] {:partition-by [:fid], :order-by [:m]}]]]</pre>
which <code>sql/format</code> chokes on</z><z id="t1615858960" t="seancorfield Can you provide a bit more context? This works: user=&gt; (sql/format (-&gt; (select (over [[:lead :g] (-&gt; (h/partition-by :fid) (order-by :m))])))) [&quot;SELECT LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC)&quot;]"><y>#</y><d>2021-03-16</d><h>01:42</h><w>seancorfield</w>Can you provide a bit more context? This works:
<pre>user=&gt; (sql/format (-&gt; (select (over [[:lead :g] (-&gt; (h/partition-by :fid) (order-by :m))]))))
[&quot;SELECT LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC)&quot;]</pre></z><z id="t1615859103" t="seancorfield Here’s a more complex example from the docs: user=&gt; (sql/format (-&gt; (select :id #_=&gt; (over [[:avg :salary] (-&gt; (h/partition-by :department) (order-by :designation)) :Average] #_=&gt; [[:max :salary] :w :MaxSalary])) #_=&gt; (from :employee) #_=&gt; (window :w (h/partition-by :department)))) [&quot;SELECT id, AVG(salary) OVER (PARTITION BY department ORDER BY designation ASC) AS Average, MAX(salary) OVER w AS MaxSalary FROM employee WINDOW w AS (PARTITION BY department)&quot;]"><y>#</y><d>2021-03-16</d><h>01:45</h><w>seancorfield</w>Here’s a more complex example from the docs:
<pre>user=&gt; (sql/format (-&gt; (select :id
  #_=&gt;                                (over [[:avg :salary] (-&gt; (h/partition-by :department) (order-by :designation)) :Average]
  #_=&gt;                                      [[:max :salary] :w :MaxSalary]))
  #_=&gt;                        (from :employee)
  #_=&gt;                        (window :w (h/partition-by :department))))
[&quot;SELECT id, AVG(salary) OVER (PARTITION BY department ORDER BY designation ASC) AS Average, MAX(salary) OVER w AS MaxSalary FROM employee WINDOW w AS (PARTITION BY department)&quot;]</pre></z><z id="t1615861670" t="dcj I definitely looked at the docs that I could find in https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md The broader context is that the snipped above is part of a with CTE, here is the raw version of it (that works): [:E [:raw &quot;(SELECT DISTINCT ON (fid) fid, id AS a, id + 1 AS b, ST_3DDistance(ST_MakeLine(g, LEAD(g) OVER (PARTITION BY fid ORDER BY m)), pca_raw) AS dist FROM D ORDER BY fid, 4)&quot;]]"><y>#</y><d>2021-03-16</d><h>02:27</h><w>dcj</w>I definitely looked at the docs that I could find in <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/clause-reference.md</a>

The broader context is that the snipped above is part of a <code>with</code> CTE, here is the <code>raw</code> version of it (that works):
<pre>[:E [:raw &quot;(SELECT DISTINCT ON (fid) fid, id AS a, id + 1 AS b, ST_3DDistance(ST_MakeLine(g, LEAD(g) OVER (PARTITION BY fid ORDER BY m)), pca_raw) AS dist FROM D ORDER BY fid, 4)&quot;]]</pre></z><z id="t1615861936" t="dcj Here is what I tried: [:E (-&gt; (sql.helpers/select-distinct-on :fid :fid [:id :a] [[:raw &quot;id + 1&quot;] :b] [[:ST_3DDistance [:ST_MakeLine :g (sql.helpers/over [[:lead :g] (-&gt; (sql.helpers/partition-by :fid) (order-by :m))])] :pca_raw] :dist]) (from :D) (order-by [:fid 4]))] "><y>#</y><d>2021-03-16</d><h>02:32</h><w>dcj</w>Here is what I tried:
<pre>[:E (-&gt; (sql.helpers/select-distinct-on :fid
                                        :fid
                                        [:id :a]
                                        [[:raw &quot;id + 1&quot;] :b]
                                        [[:ST_3DDistance [:ST_MakeLine :g
                                                                        (sql.helpers/over [[:lead :g]
                                                                                          (-&gt; (sql.helpers/partition-by :fid)
                                                                                              (order-by :m))])] :pca_raw] :dist])
        (from :D)
        (order-by [:fid 4]))]</pre>
</z><z id="t1615864958" t="seancorfield [I was wrong: HoneySQL treats "><y>#</y><d>2021-03-16</d><h>03:22</h><w>seancorfield</w>[I was wrong: HoneySQL treats </z><z id="t1615865363" t="seancorfield Oh, I see the issue [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] :select-distinct-on expects the first argument to be a sequence of column names per the docs: &quot;Similar to :select-distinct above but the first element in the sequence should be a sequence of columns for the DISTINCT ON clause&quot;"><y>#</y><d>2021-03-16</d><h>03:29</h><w>seancorfield</w>Oh, I see the issue <a>@dcj</a> <code>:select-distinct-on</code> expects the first argument to be a sequence of column names per the docs: &quot;Similar to :select-distinct above but the first element in the sequence should be a sequence of columns for the DISTINCT ON clause&quot;</z><z id="t1615865563" t="seancorfield Also, the order-by should have a direction (`:asc` or :desc ) instead of 4 -- can you explain what you&apos;re trying to do there?"><y>#</y><d>2021-03-16</d><h>03:32</h><w>seancorfield</w>Also, the <code>order-by</code> should have a direction (`:asc`  or <code>:desc</code>) instead of <code>4</code> -- can you explain what you&apos;re trying to do there?</z><z id="t1615865658" t="seancorfield Maybe this is what you&apos;re aiming for: dev=&gt; (sql/format (-&gt; (h/select-distinct-on [:fid] #_=&gt; #_=&gt; :fid #_=&gt; #_=&gt; [:id :a] #_=&gt; #_=&gt; [[:+ :id 1] :b] #_=&gt; #_=&gt; [[:ST_3DDistance [:ST_MakeLine :g #_=&gt; #_=&gt; (h/over [[:lead :g] #_=&gt; #_=&gt; (-&gt; (h/partition-by :fid) #_=&gt; #_=&gt; (h/order-by :m))])] :pca_raw] :dist]) #_=&gt; #_=&gt; (h/from :D) (h/order-by :fid [[:inline 4]]))) [&quot;SELECT DISTINCT ON(fid) fid, id AS a, id + ? AS b, ST_3DDISTANCE(ST_MAKELINE(g, (LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC))), pca_raw) AS dist FROM D ORDER BY fid ASC, 4 ASC&quot; 1] Not sure whether the id + 1 is better for you as an expression rather than raw like that?"><y>#</y><d>2021-03-16</d><h>03:34</h><w>seancorfield</w>Maybe this is what you&apos;re aiming for:
<pre>dev=&gt; (sql/format (-&gt; (h/select-distinct-on [:fid]
 #_=&gt;  #_=&gt;                                         :fid
 #_=&gt;  #_=&gt;                                         [:id :a]
 #_=&gt;  #_=&gt;                                         [[:+ :id 1] :b]
 #_=&gt;  #_=&gt;                                         [[:ST_3DDistance [:ST_MakeLine :g
 #_=&gt;  #_=&gt;                                                                         (h/over [[:lead :g]
 #_=&gt;  #_=&gt;                                                                                  (-&gt; (h/partition-by :fid)
 #_=&gt;  #_=&gt;                                                                                      (h/order-by :m))])] :pca_raw] :dist])
 #_=&gt;  #_=&gt;                 (h/from :D) (h/order-by :fid [[:inline 4]])))
[&quot;SELECT DISTINCT ON(fid) fid, id AS a, id + ? AS b, ST_3DDISTANCE(ST_MAKELINE(g, (LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC))), pca_raw) AS dist FROM D ORDER BY fid ASC, 4 ASC&quot; 1]</pre>
Not sure whether the <code>id + 1</code> is better for you as an expression rather than raw like that?</z><z id="t1615911383" t="dcj 1. Thank you for the syntax fix! 2. Clearly I need to read the docs more carefully 3. Is there some way I can run my proposed query DSL through Spec, to veriify it is correct? 4. Thank you for [[:+ :id 1] :b] that is way better "><y>#</y><d>2021-03-16</d><h>16:16</h><w>dcj</w>1. Thank you for the syntax fix!  
2. Clearly I need to read the docs more carefully
3. Is there some way I can run my proposed query DSL through Spec, to veriify it is correct?  
4. Thank you for <code>[[:+ :id 1] :b]</code> that is way better
</z><z id="t1615911838" t="dcj Also, the order-by should have a direction (:asc  or :desc) instead of 4 -- can you explain what you&apos;re trying to do there? The short answer is that I can&apos;t explain this, the query I am working on was created by an extremely experienced PostGIS developer, and I don&apos;t understand how it works 😞 That being said, I checked the Postgres docs on order-by: https://www.postgresql.org/docs/9.5/queries-order.html Note this: A sort_expression can also be the column label or number of an output column, as in: SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1; So, at this point, here is what I have: (pprint tqe) {:select-distinct-on [[:fid] :fid [:id :a] [[:raw &quot;id + 1&quot;] :b] [[:ST_3DDistance [:ST_MakeLine :g [[:over [[:lead :g] {:partition-by [:fid], :order-by [:m]}]]]] :pca_raw] :dist]], :from [:D], :order-by [[[:raw &quot;fid, 4&quot;]]]} (println (sql/format tqe {:pretty true})) [ SELECT DISTINCT ON(fid) fid, id AS a, id + 1 AS b, ST_3DDISTANCE(ST_MAKELINE(g, (LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC))), pca_raw) AS dist FROM D ORDER BY fid, 4 ASC ] I haven&apos;t tested this yet, need to head to a meeting, back in a couple hours"><y>#</y><d>2021-03-16</d><h>16:23</h><w>dcj</w><pre>Also, the order-by should have a direction (:asc  or :desc) instead of 4 -- can you explain what you&apos;re trying to do there?</pre>
The short answer is that I can&apos;t explain this, the query I am working on was created by an extremely experienced PostGIS developer, and I don&apos;t understand how it works <b>😞</b>
That being said, I checked the Postgres docs on order-by: <a href="https://www.postgresql.org/docs/9.5/queries-order.html" target="_blank">https://www.postgresql.org/docs/9.5/queries-order.html</a>
Note this:
<pre>A sort_expression can also be the column label or number of an output column, as in:

    SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;</pre>
So, at this point, here is what I have:
<pre>(pprint tqe)

{:select-distinct-on
 [[:fid]
  :fid
  [:id :a]
  [[:raw &quot;id + 1&quot;] :b]
  [[:ST_3DDistance
    [:ST_MakeLine
     :g
     [[:over [[:lead :g] {:partition-by [:fid], :order-by [:m]}]]]]
    :pca_raw]
   :dist]],
 :from [:D],
 :order-by [[[:raw &quot;fid, 4&quot;]]]}

(println (sql/format tqe {:pretty true}))

[
SELECT DISTINCT ON(fid) fid, id AS a, id + 1 AS b, ST_3DDISTANCE(ST_MAKELINE(g, (LEAD(g) OVER (PARTITION BY fid ORDER BY m ASC))), pca_raw) AS dist
FROM D
ORDER BY fid, 4 ASC
]</pre>
I haven&apos;t tested this yet, need to head to a meeting, back in a couple hours</z><z id="t1615914219" t="seancorfield I showed an order-by that would work for :fid, 4 : (h/order-by :fid [[:inline 4]]) — you don’t need :raw here."><y>#</y><d>2021-03-16</d><h>17:03</h><w>seancorfield</w>I showed an <code>order-by</code> that would work for <code>:fid, 4</code>: <code>(h/order-by :fid [[:inline 4]])</code> — you don’t need <code>:raw</code> here.</z><z id="t1615923577" t="dcj Yes, this is working, thank you! Now, pne last giant blob of :raw to convert...."><y>#</y><d>2021-03-16</d><h>19:39</h><r>dcj</r>Yes, this is working, thank you!
Now, pne last giant blob of <code>:raw</code> to convert....</z><z id="t1615914313" t="seancorfield Re: #3 — there’s an issue on GitHub for a Spec for the DSL but I’m not sure how tractable that really is since it would need to pretty much match the entire recursive descent “formatter”: SQL is extremely complex as a language and Spec isn’t really suited to describing language grammars."><y>#</y><d>2021-03-16</d><h>17:05</h><w>seancorfield</w>Re: #3 — there’s an issue on GitHub for a Spec for the DSL but I’m not sure how tractable that really is since it would need to pretty much match the entire recursive descent “formatter”: SQL is extremely complex as a language and Spec isn’t really suited to describing language grammars.</z><z id="t1615923695" t="dcj Could each helper fn check its args? Not saying this would enable checking everything.... I will try and give this some thought"><y>#</y><d>2021-03-16</d><h>19:41</h><r>dcj</r>Could each helper fn check its args?  Not saying this would enable checking everything....  I will try and give this some thought</z><z id="t1615926119" t="seancorfield Not really: the helpers are nearly all generic — they mostly just assoc/merge arguments into the underlying data structure (they’re nearly all just calls to generic under the hood)."><y>#</y><d>2021-03-16</d><h>20:21</h><r>seancorfield</r>Not really: the helpers are nearly all generic — they mostly just assoc/merge arguments into the underlying data structure (they’re nearly all just calls to <code>generic</code> under the hood).</z><z id="t1615926161" t="seancorfield And the problem is that the syntax of SQL is recursive: SELECT expressions can contain SELECT expressions in all sorts of complex ways."><y>#</y><d>2021-03-16</d><h>20:22</h><r>seancorfield</r>And the problem is that the syntax of SQL is recursive: SELECT expressions can contain SELECT expressions in all sorts of complex ways.</z><z id="t1615926183" t="seancorfield Any Spec that I end up writing is only going to catch the most egregious mistakes."><y>#</y><d>2021-03-16</d><h>20:23</h><r>seancorfield</r>Any Spec that I end up writing is only going to catch the most egregious mistakes.</z><z id="t1615926266" t="seancorfield There are a few clauses where the structure required is unique enough that Spec could catch some errors (`:select-distinct-on` is a particular case where it expects a sequence where the first element must be a sequence — but you already got an error from that… just not a very informative one)."><y>#</y><d>2021-03-16</d><h>20:24</h><r>seancorfield</r>There are a few clauses where the structure required is unique enough that Spec could catch some errors (`:select-distinct-on` is a particular case where it expects a sequence where the first element must be a sequence — but you already got an error from that… just not a very informative one).</z><z id="t1615926322" t="seancorfield I can try to add more “specific error checking” in cases where, if you pass in bad data today you get a generic error (either an NPE or a CCE), but many of those would be hard to predict…"><y>#</y><d>2021-03-16</d><h>20:25</h><r>seancorfield</r>I can try to add more “specific error checking” in cases where, if you pass in bad data today you get a generic error (either an NPE or a CCE), but many of those would be hard to predict…</z><z id="t1615926453" t="seancorfield There are also two distinct classes of “user error” here: one that blows up the formatter and one that formats successfully but produces bogus SQL. The former I can probably do something about, at least in terms of narrowing down where the error occurred, but the latter is pretty much impossible to detect."><y>#</y><d>2021-03-16</d><h>20:27</h><r>seancorfield</r>There are also two distinct classes of “user error” here: one that blows up the formatter and one that formats successfully but produces bogus SQL. The former I can probably do something about, at least in terms of narrowing down where the error occurred, but the latter is pretty much impossible to detect.</z><z id="t1615926453" t="seancorfield There are also two distinct classes of “user error” here: one that blows up the formatter and one that formats successfully but produces bogus SQL. The former I can probably do something about, at least in terms of narrowing down where the error occurred, but the latter is pretty much impossible to detect."><y>#</y><d>2021-03-16</d><h>20:27</h><w>seancorfield</w>There are also two distinct classes of “user error” here: one that blows up the formatter and one that formats successfully but produces bogus SQL. The former I can probably do something about, at least in terms of narrowing down where the error occurred, but the latter is pretty much impossible to detect.</z><z id="t1615926918" t="dcj Understood! I&apos;m thinking more about the &quot;user error&quot; case...."><y>#</y><d>2021-03-16</d><h>20:35</h><w>dcj</w>Understood!  I&apos;m thinking more about the &quot;user error&quot; case....</z><z id="t1615928029" t="dcj Today&apos;s v2 puzzle, trying to convert this from :raw FROM (SELECT fid, pca, dca FROM P) P INNER JOIN (SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, a FROM E)) A ON P.fid = A.fid INNER JOIN (SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) B ON P.fid = B.fid My approach to these tasks is to try and build &quot;up&quot; from an innermost. So in this case, I started trying to write: (SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) B The part I can&apos;t figure out is WHERE (fid, id) IN (SELECT fid, b FROM E) , specifically the IN part..."><y>#</y><d>2021-03-16</d><h>20:53</h><w>dcj</w>Today&apos;s v2 puzzle, trying to convert this from <code>:raw</code>
<pre>FROM
    (SELECT fid, pca, dca FROM P) P
    INNER JOIN
    (SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, a FROM E)) A ON P.fid = A.fid
    INNER JOIN
    (SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) B ON P.fid = B.fid</pre>
My approach to these tasks is to try and build &quot;up&quot; from an innermost.
So in this case, I started trying to write:
<pre>(SELECT fid, m, ST_3DDistance(g,pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) B</pre>
The part I can&apos;t figure out is <code>WHERE (fid, id) IN (SELECT fid, b FROM E)</code>, specifically the <code>IN</code> part...</z><z id="t1615928323" t="seancorfield user=&gt; (sql/format {:where [:in [:composite :fid :id] {:select [:fid :b] :from :e}]}) [&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]"><y>#</y><d>2021-03-16</d><h>20:58</h><w>seancorfield</w><pre>user=&gt; (sql/format {:where [:in [:composite :fid :id] {:select [:fid :b] :from :e}]})
[&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]</pre></z><z id="t1615928354" t="seancorfield (assuming you want the data structure version, not the helper version)"><y>#</y><d>2021-03-16</d><h>20:59</h><w>seancorfield</w>(assuming you want the data structure version, not the helper version)</z><z id="t1615928397" t="seancorfield user=&gt; (sql/format (where [:in (composite :fid :id) (-&gt; (select :fid :b) (from :e))])) [&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]"><y>#</y><d>2021-03-16</d><h>20:59</h><w>seancorfield</w><pre>user=&gt; (sql/format (where [:in (composite :fid :id) (-&gt; (select :fid :b) (from :e))]))
[&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]</pre></z><z id="t1615928414" t="dcj Nice! Thank you again!"><y>#</y><d>2021-03-16</d><h>21:00</h><w>dcj</w>Nice!  Thank you again!</z><z id="t1615928479" t="seancorfield It’s probably worth pointing out that this is one of those places where the V2 support for symbols instead of keywords makes for a more readable piece of code user=&gt; (sql/format &apos;{where [in [composite fid id] {select [fid b] from e}]}) [&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]"><y>#</y><d>2021-03-16</d><h>21:01</h><w>seancorfield</w>It’s probably worth pointing out that this is one of those places where the V2 support for symbols instead of keywords makes for a more readable piece of code
<pre>user=&gt; (sql/format &apos;{where [in [composite fid id] {select [fid b] from e}]})
[&quot;WHERE (fid, id) IN (SELECT fid, b FROM e)&quot;]</pre></z><z id="t1615928511" t="seancorfield (that was not possible in V1 although symbols were accepted in a few places)"><y>#</y><d>2021-03-16</d><h>21:01</h><w>seancorfield</w>(that was not possible in V1 although symbols were accepted in a few places)</z></g><g id="s2"><z id="t1615928537" t="seancorfield Obviously you can’t use a quoted structure if you have Clojure variables in the structure but…"><y>#</y><d>2021-03-16</d><h>21:02</h><w>seancorfield</w>Obviously you can’t use a quoted structure if you have Clojure variables in the structure but…</z><z id="t1615928620" t="seancorfield (although you could use named parameters for that)"><y>#</y><d>2021-03-16</d><h>21:03</h><w>seancorfield</w>(although you could use named parameters for that)</z><z id="t1615928678" t="enn perfect use case for quasi-quote"><y>#</y><d>2021-03-16</d><h>21:04</h><w>enn</w>perfect use case for quasi-quote</z><z id="t1615934817" t="dcj Recall my &quot;today&apos;s V2 puzzle&quot; above... Here is what I&apos;ve got now: (-&gt; (select :fid :pca :dca) (from :P) (inner-join [(-&gt; (select :fid :m [[:ST_3DDistance :g :pca] :dist]) (from :D) (where [:in (composite :fid :id) (-&gt; (select :fid :a) (from :E))])) :A] [:= :P.fid :A.fid]) (inner-join [(-&gt; (select :fid :m [[:ST_3DDistance :g :pca] :dist]) (from :D) (where [:in (composite :fid :id) (-&gt; (select :fid :b) (from :E))])) :B] [:= :P.fid :B.fid])) Which results in this: [ SELECT fid, pca, dca FROM P INNER JOIN (SELECT fid, m, ST_3DDISTANCE(g, pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, a FROM E)) AS A ON P.fid = A.fid INNER JOIN (SELECT fid, m, ST_3DDISTANCE(g, pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) AS B ON P.fid = B.fid ] This seems really close, but I can&apos;t figure out how to get the first SELECT to end with AS P It is supposed to be: (SELECT fid, pca, dca FROM P) P "><y>#</y><d>2021-03-16</d><h>22:46</h><w>dcj</w>Recall my &quot;today&apos;s V2 puzzle&quot; above...
Here is what I&apos;ve got now:
<pre>(-&gt; (select :fid :pca :dca)
    (from :P)
    (inner-join [(-&gt; (select :fid :m [[:ST_3DDistance :g :pca] :dist])
                     (from :D)
                     (where [:in (composite :fid :id) (-&gt; (select :fid :a) (from :E))]))
                 :A]
                [:= :P.fid :A.fid])
    (inner-join [(-&gt; (select :fid :m [[:ST_3DDistance :g :pca] :dist])
                     (from :D)
                     (where [:in (composite :fid :id) (-&gt; (select :fid :b) (from :E))]))
                 :B]
                [:= :P.fid :B.fid]))</pre>
Which results in this:
<pre>[
SELECT fid, pca, dca
FROM P
INNER JOIN (SELECT fid, m, ST_3DDISTANCE(g, pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, a FROM E)) AS A ON P.fid = A.fid INNER JOIN (SELECT fid, m, ST_3DDISTANCE(g, pca) AS dist FROM D WHERE (fid, id) IN (SELECT fid, b FROM E)) AS B ON P.fid = B.fid
]</pre>
This seems really close, but I can&apos;t figure out how to get the first <code>SELECT</code> to end with <code>AS P</code>
It is supposed to be:
<pre>(SELECT fid, pca, dca FROM P) P</pre>
</z><z id="t1615935839" t="seancorfield You don’t need it to be aliased tho’ since the table name is already P , right?"><y>#</y><d>2021-03-16</d><h>23:03</h><w>seancorfield</w>You don’t need it to be aliased tho’ since the table name is already <code>P</code>, right?</z><z id="t1615935999" t="seancorfield I’m not even sure how to get an alias on that without nesting it in a SELECT … SELECT * FROM (SELECT fid, pca, dca FROM P) AS P which would be (-&gt; (select :*) (from [(-&gt; (select :fid :pca :dca) (from :p)) :p]) ...) I think [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] ?"><y>#</y><d>2021-03-16</d><h>23:06</h><w>seancorfield</w>I’m not even sure how to get an alias on that without nesting it in a <code>SELECT</code> … <code>SELECT * FROM (SELECT fid, pca, dca FROM P) AS P</code> which would be <code>(-&gt; (select :*) (from [(-&gt; (select :fid :pca :dca) (from :p)) :p]) ...)</code> I think <a>@dcj</a>?</z><z id="t1615936047" t="seancorfield user=&gt; (sql/format (-&gt; (select :*) (from [(-&gt; (select :fid :pca :dca) (from :p)) :p]))) [&quot;SELECT * FROM (SELECT fid, pca, dca FROM p) AS p&quot;]"><y>#</y><d>2021-03-16</d><h>23:07</h><w>seancorfield</w><pre>user=&gt; (sql/format (-&gt; (select :*) (from [(-&gt; (select :fid :pca :dca) (from :p)) :p])))
[&quot;SELECT * FROM (SELECT fid, pca, dca FROM p) AS p&quot;]</pre></z><z id="t1615936180" t="seancorfield (SELECT .. FROM ..) AS alias INNER JOIN .. is certainly not legal SQL as far as MySQL is concerned."><y>#</y><d>2021-03-16</d><h>23:09</h><w>seancorfield</w><code>(SELECT .. FROM ..) AS alias INNER JOIN ..</code> is certainly not legal SQL as far as MySQL is concerned.</z><z id="t1615936341" t="dcj AFAICT, it is supposed to be: (SELECT some-stuff FROM OTHER_P) P INNER JOIN ... INNER JOIN ... AFAIK this is legal Postgres, my raw query above works fine"><y>#</y><d>2021-03-16</d><h>23:12</h><w>dcj</w>AFAICT, it is supposed to be:
<pre>(SELECT some-stuff FROM OTHER_P) P
INNER JOIN ...
INNER JOIN ...</pre>
AFAIK this is legal Postgres, my raw query above works fine</z><z id="t1615936548" t="dcj Had to edit the above 3 times to get it right"><y>#</y><d>2021-03-16</d><h>23:15</h><w>dcj</w>Had to edit the above 3 times to get it right</z><z id="t1615936763" t="seancorfield There’s no way to generate that with HoneySQL — the closest you’ll get is the nested select I showed above."><y>#</y><d>2021-03-16</d><h>23:19</h><w>seancorfield</w>There’s no way to generate that with HoneySQL — the closest you’ll get is the nested select I showed above.</z><z id="t1615936786" t="seancorfield I can’t even think how to write that syntax in the DSL."><y>#</y><d>2021-03-16</d><h>23:19</h><w>seancorfield</w>I can’t even think how to write that syntax in the DSL.</z><z id="t1615936809" t="seancorfield SELECT some-stuff FROM OTHER_P AS P would be “equivalent” though, wouldn’t it?"><y>#</y><d>2021-03-16</d><h>23:20</h><w>seancorfield</w><code>SELECT some-stuff FROM OTHER_P AS P</code> would be “equivalent” though, wouldn’t it?</z><z id="t1615936821" t="seancorfield (and that is expressible in the DSL)"><y>#</y><d>2021-03-16</d><h>23:20</h><w>seancorfield</w>(and that is expressible in the DSL)</z><z id="t1615936841" t="dcj That makes me feel better since I spent the last couple hours trying and failing"><y>#</y><d>2021-03-16</d><h>23:20</h><w>dcj</w>That makes me feel better since I spent the last couple hours trying and failing</z><z id="t1615936954" t="dcj I also think your point that &quot;you already have P, so why alias it again&quot; bears some thought, seems like I ought to be able to make my query work without that"><y>#</y><d>2021-03-16</d><h>23:22</h><w>dcj</w>I also think your point that &quot;you already have P, so why alias it again&quot; bears some thought, seems like I ought to be able to make my query work without that</z><z id="t1615937225" t="seancorfield I can’t see how it’s legal based on the Postgres docs either but, hey, maybe PG accepts syntax that isn’t documented?"><y>#</y><d>2021-03-16</d><h>23:27</h><w>seancorfield</w>I can’t see how it’s legal based on the Postgres docs either but, hey, maybe PG accepts syntax that isn’t documented?</z><z id="t1615937329" t="dcj Don;t know if it matters, but all this ends up in a from"><y>#</y><d>2021-03-16</d><h>23:28</h><w>dcj</w>Don;t know if it matters, but all this ends up in a <code>from</code></z><z id="t1615937509" t="seancorfield The FROM can alias the result — but it would be the entire result, not just that select /`from` part."><y>#</y><d>2021-03-16</d><h>23:31</h><w>seancorfield</w>The <code>FROM</code> can alias the result — but it would be the entire result, not just that <code>select</code>/`from` part.</z><z id="t1615937726" t="seancorfield Oh, I see what you mean. So it is (-&gt; .. (from [ (-&gt; (select :fid :pca :dca) (from :other_p)) :p ]) (inner-join .. ) )"><y>#</y><d>2021-03-16</d><h>23:35</h><w>seancorfield</w>Oh, I see what you mean. So it is <code>(-&gt; .. (from [ (-&gt; (select :fid :pca :dca) (from :other_p)) :p ]) (inner-join .. ) )</code></z><z id="t1615937820" t="seancorfield because overall your query is select stuff from (select fid, pca, dca from p) as p ... right?"><y>#</y><d>2021-03-16</d><h>23:37</h><w>seancorfield</w>because overall your query is <code>select stuff from (select fid, pca, dca from p) as p ...</code> right?</z><z id="t1615937926" t="dcj yes the original P was part of a with/CTE above"><y>#</y><d>2021-03-16</d><h>23:38</h><w>dcj</w>yes the original P was part of a with/CTE above</z><z id="t1615938199" t="dcj but the inner joins apply to the select/from within the larger from"><y>#</y><d>2021-03-16</d><h>23:43</h><w>dcj</w>but the inner joins apply to the select/from within the larger from</z><z id="t1615939113" t="seancorfield I’d have to see the whole raw query to be able to help further at this point."><y>#</y><d>2021-03-16</d><h>23:58</h><w>seancorfield</w>I’d have to see the whole raw query to be able to help further at this point.</z><z id="t1615940952" t="dcj Interesting, I finally tried to run the entire query with that last bit, and now I get this: ERROR: subquery in FROM must have an alias Hint: For example, FROM (SELECT ...) [AS] foo. Position: 1092 "><y>#</y><d>2021-03-17</d><h>00:29</h><w>dcj</w>Interesting, I finally tried to run the entire query with that last bit, and now I get this:
<pre>ERROR: subquery in FROM must have an alias
  Hint: For example, FROM (SELECT ...) [AS] foo.
  Position: 1092</pre>
</z><z id="t1615941388" t="dcj So I need to figure out how to generate that alias for the select...."><y>#</y><d>2021-03-17</d><h>00:36</h><w>dcj</w>So I need to figure out how to generate that alias for the select....</z><z id="t1615941605" t="seancorfield I told you how to do that just above."><y>#</y><d>2021-03-17</d><h>00:40</h><w>seancorfield</w>I told you how to do that just above.</z><z id="t1615941641" t="seancorfield ^ [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] did you not see my suggestion?"><y>#</y><d>2021-03-17</d><h>00:40</h><w>seancorfield</w>^ <a>@dcj</a> did you not see my suggestion?</z><z id="t1615941682" t="dcj yes, wrapping the entire thing in an outer select :*"><y>#</y><d>2021-03-17</d><h>00:41</h><w>dcj</w>yes, wrapping the entire thing in an outer <code>select :*</code></z><z id="t1615941685" t="dcj ?"><y>#</y><d>2021-03-17</d><h>00:41</h><w>dcj</w>?</z><z id="t1615941901" t="seancorfield No, the alias in the from clause."><y>#</y><d>2021-03-17</d><h>00:45</h><w>seancorfield</w>No, the alias in the <code>from</code> clause.</z><z id="t1615941914" t="dcj trying that now,"><y>#</y><d>2021-03-17</d><h>00:45</h><w>dcj</w>trying that now,</z><z id="t1615941943" t="seancorfield (from [ (some subquery) :alias ]) =&gt; FROM (some subquery) AS alias"><y>#</y><d>2021-03-17</d><h>00:45</h><w>seancorfield</w><code>(from [ (some subquery) :alias ])</code> =&gt; <code>FROM (some subquery) AS alias</code></z><z id="t1615941972" t="seancorfield So it’s just a matter of how much of your query needs to go into that (some subquery) piece."><y>#</y><d>2021-03-17</d><h>00:46</h><w>seancorfield</w>So it’s just a matter of how much of your query needs to go into that <code>(some subquery)</code> piece.</z><z id="t1615941981" t="dcj Seem to recall issue with subsequent inner joins not being inside the enveloping FROM"><y>#</y><d>2021-03-17</d><h>00:46</h><w>dcj</w>Seem to recall issue with subsequent inner joins not being inside the enveloping FROM</z><z id="t1616220879" t="Vincent Cantin [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I have a small suggestion about honeysql 2.0.0-alpha3, it is to rename the namespaces to remove the ending s . • honey.sql.helpers -&gt; honey.sql.helper • honey.specs -&gt; honey.spec"><y>#</y><d>2021-03-20</d><h>06:14</h><w>Vincent Cantin</w><a>@seancorfield</a> I have a small suggestion about honeysql 2.0.0-alpha3, it is to rename the namespaces to remove the ending <code>s</code> .
• <code>honey.sql.helpers -&gt; honey.sql.helper</code> 
• <code>honey.specs -&gt; honey.spec</code></z><z id="t1616252369" t="Vincent Cantin it is a very subjective suggestion, ignore it at will 🙂"><y>#</y><d>2021-03-20</d><h>14:59</h><r>Vincent Cantin</r>it is a very subjective suggestion, ignore it at will <b>🙂</b></z><z id="t1616287506" t="seancorfield [:attrs {:href &quot;/_/_/users/U8MJBRSR5&quot;}] Clojure has core.specs (`.alpha`) and I think a lot of libraries have followed that plural lead -- I did with next.jdbc and it seemed natural to do so for HoneySQL as well. As for helpers -- people are used to that from V1 so it&apos;s been plural for years."><y>#</y><d>2021-03-21</d><h>00:45</h><r>seancorfield</r><a>@U8MJBRSR5</a> Clojure has <code>core.specs</code> (`.alpha`) and I think a lot of libraries have followed that plural lead -- I did with <code>next.jdbc</code> and it seemed natural to do so for HoneySQL as well. As for <code>helpers</code> -- people are used to that from V1 so it&apos;s been plural for years.</z><z id="t1616766239" t="maxp is there an example how to use on-conflict do-update-set in HoneySQL 2.0 ?"><y>#</y><d>2021-03-26</d><h>13:43</h><w>maxp</w>is there an example how to use on-conflict do-update-set in HoneySQL 2.0 ?</z><z id="t1616766535" t="dharrigan https://github.com/seancorfield/honeysql/blob/24b87ebd69e756d910d38bece954f3e1d2de864d/test/honey/sql/postgres_test.cljc#L34"><y>#</y><d>2021-03-26</d><h>13:48</h><w>dharrigan</w><a href="https://github.com/seancorfield/honeysql/blob/24b87ebd69e756d910d38bece954f3e1d2de864d/test/honey/sql/postgres_test.cljc#L34" target="_blank">https://github.com/seancorfield/honeysql/blob/24b87ebd69e756d910d38bece954f3e1d2de864d/test/honey/sql/postgres_test.cljc#L34</a></z><z id="t1616774232" t="seancorfield [:attrs {:href &quot;/_/_/users/U0666UM3J&quot;}] https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/postgresql-support covers the HoneySQL equivalents from honeysql-postgres. They are also covered in the SQL Clause Reference https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set"><y>#</y><d>2021-03-26</d><h>15:57</h><w>seancorfield</w><a>@maxp</a> <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/postgresql-support" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/postgresql-support</a> covers the HoneySQL equivalents from honeysql-postgres. They are also covered in the SQL Clause Reference <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-alpha3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set</a></z><z id="t1616864238" t="dcj If you want to format the query as a string with no parameters (e.g. to use the SQL statement in a SQL console), pass :inline true as an option to sql/format: THANK YOU [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] !!!"><y>#</y><d>2021-03-27</d><h>16:57</h><w>dcj</w><pre>If you want to format the query as a string with no parameters (e.g. to use the SQL statement in a SQL console), pass :inline true as an option to sql/format:</pre>
THANK YOU <a>@seancorfield</a>!!!</z><z id="t1616865522" t="seancorfield There&apos;s also :pretty true simple_smile"><y>#</y><d>2021-03-27</d><h>17:18</h><w>seancorfield</w>There&apos;s also <code>:pretty true</code> <b>simple_smile</b></z><z id="t1616866562" t="dcj Already knew about :pretty but not about :inline which I needed, and was about to go manually inline a lot of cruft, and then while taking a shower this morning, it occured to me &quot;wouldn&apos;t be awesome if sql/format did that&quot;, read the docs, and there it was!"><y>#</y><d>2021-03-27</d><h>17:36</h><r>dcj</r>Already knew about <code>:pretty</code> but not about <code>:inline</code> which I needed, and was about to go manually inline a lot of cruft, and then while taking a shower this morning, it occured to me &quot;wouldn&apos;t be awesome if <code>sql/format</code> did that&quot;, read the docs, and there it was!</z><z id="t1616871193" t="orestis That’s a pretty nice feature! Is that honey sql 2 only? Very good reason to switch ASAP :)"><y>#</y><d>2021-03-27</d><h>18:53</h><w>orestis</w>That’s a pretty nice feature! Is that honey sql 2 only? Very good reason to switch ASAP :)</z><z id="t1616871499" t="seancorfield [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] V2 only 🙂 Well, in theory the :parameterizer :none option in V1 did the same thing, except it didn’t work properly as I recall."><y>#</y><d>2021-03-27</d><h>18:58</h><w>seancorfield</w><a>@orestis</a> V2 only <b>🙂</b> Well, in theory the <code>:parameterizer :none</code> option in V1 did the same thing, except it didn’t work properly as I recall.</z><z id="t1616933206" t="aratare Hi there. I’m trying to delete a row in a POSTGRESQL table with (-&gt; (helpers/delete-from :current-user) (helpers/where [:= :user/id id] [:= :user/token token]) (sql/format :quoting :ansi)) but it seems that the default behaviour when used with next.jdbc/execute-one! is to return {:update count 1} . Is there a way for me to return the deleted row instead?"><y>#</y><d>2021-03-28</d><h>12:06</h><w>aratare</w>Hi there. I’m trying to delete a row in a POSTGRESQL table with
<pre>(-&gt; (helpers/delete-from :current-user)
                            (helpers/where [:= :user/id id] [:= :user/token token])
                            (sql/format :quoting :ansi))</pre>
but it seems that the default behaviour when used with <code>next.jdbc/execute-one!</code> is to return <code>{:update count 1}</code>. Is there a way for me to return the deleted row instead?</z><z id="t1616940495" t="dharrigan Seek and ye shall find "><y>#</y><d>2021-03-28</d><h>14:08</h><w>dharrigan</w>Seek and ye shall find <code></code></z><z id="t1616940606" t="dharrigan (mind you, that is v2 of honeysql)"><y>#</y><d>2021-03-28</d><h>14:10</h><w>dharrigan</w>(mind you, that is v2 of honeysql)</z><z id="t1616941325" t="aratare Thanks. I may upgrade to v2 if it’s stable enough."><y>#</y><d>2021-03-28</d><h>14:22</h><w>aratare</w>Thanks. I may upgrade to v2 if it’s stable enough.</z><z id="t1616944583" t="dharrigan I&apos;ve been using it for a while (in admittingly non-production, but near to production) code. Works just like v1 🙂"><y>#</y><d>2021-03-28</d><h>15:16</h><w>dharrigan</w>I&apos;ve been using it for a while (in admittingly non-production, but near to production) code. Works just like v1 <b>🙂</b></z><z id="t1617259608" t="aratare Hi there. I’m having a problem with Postgresql not being very happy with /cdn-cgi/l/email-protection converting :foo/bar to &quot;foo&quot;.&quot;bar&quot; when set -ing a new value. For example: (-&gt; (helpers/update :user) (helpers/set {:foo/bar 1}) (helpers/where [:= :user/id id]) (helpers/returning :*) (sql/format {:dialect :ansi})) will not work because PSQL requires that columns do not contain the table name. Is there a way to disable this behaviour? I can just convert those keywords to simple keywords but that’s a bit ugly. Thanks in advance."><y>#</y><d>2021-04-01</d><h>06:46</h><w>aratare</w>Hi there. I’m having a problem with Postgresql not being very happy with <a href="/cdn-cgi/l/email-protection" target="_blank">/cdn-cgi/l/email-protection</a> converting <code>:foo/bar</code> to <code>&quot;foo&quot;.&quot;bar&quot;</code> when <code>set</code>-ing a new value. For example:
<pre>(-&gt; (helpers/update :user)
      (helpers/set {:foo/bar 1})
      (helpers/where [:= :user/id id])
      (helpers/returning :*)
      (sql/format {:dialect :ansi}))</pre>
will not work because PSQL requires that columns do not contain the table name. Is there a way to disable this behaviour? I can just convert those keywords to simple keywords but that’s a bit ugly. Thanks in advance.</z><z id="t1617259762" t="seancorfield Open an issue on github and I&apos;ll fix it tomorrow. It&apos;s a bug."><y>#</y><d>2021-04-01</d><h>06:49</h><w>seancorfield</w>Open an issue on github and I&apos;ll fix it tomorrow. It&apos;s a bug.</z><z id="t1617259774" t="aratare Will do. Thanks 🙂"><y>#</y><d>2021-04-01</d><h>06:49</h><w>aratare</w>Will do. Thanks <b>🙂</b></z><z id="t1617283846" t="aratare Hi there. Where should I be looking into if I want to configure automatic conversion between kebab-case and snake_case for both table names and column names? Thanks in advance."><y>#</y><d>2021-04-01</d><h>13:30</h><w>aratare</w>Hi there. Where should I be looking into if I want to configure automatic conversion between <code>kebab-case</code> and <code>snake_case</code> for both table names and column names? Thanks in advance.</z><z id="t1617284007" t="dharrigan it does that already"><y>#</y><d>2021-04-01</d><h>13:33</h><w>dharrigan</w>it does that already</z><z id="t1617284112" t="aratare It doesn’t for me for some reason…"><y>#</y><d>2021-04-01</d><h>13:35</h><w>aratare</w>It doesn’t for me for some reason…</z><z id="t1617284165" t="aratare I’m using Hikari for pooling, and every time I use honeysql it always yell at me for not having the proper relation"><y>#</y><d>2021-04-01</d><h>13:36</h><w>aratare</w>I’m using Hikari for pooling, and every time I use honeysql it always yell at me for not having the proper relation</z><z id="t1617284166" t="dharrigan are you using next jdbc?"><y>#</y><d>2021-04-01</d><h>13:36</h><w>dharrigan</w>are you using next jdbc?</z><z id="t1617284170" t="aratare yep"><y>#</y><d>2021-04-01</d><h>13:36</h><w>aratare</w>yep</z><z id="t1617284176" t="dharrigan do you have csk on your classpath?"><y>#</y><d>2021-04-01</d><h>13:36</h><w>dharrigan</w>do you have csk on your classpath?</z><z id="t1617284191" t="aratare I dont know what that is sorry"><y>#</y><d>2021-04-01</d><h>13:36</h><w>aratare</w>I dont know what that is sorry</z><z id="t1617284199" t="dharrigan camel snake kebab"><y>#</y><d>2021-04-01</d><h>13:36</h><w>dharrigan</w>camel snake kebab</z><z id="t1617284203" t="aratare oh yeah I do"><y>#</y><d>2021-04-01</d><h>13:36</h><w>aratare</w>oh yeah I do</z><z id="t1617284209" t="aratare I have it in lein"><y>#</y><d>2021-04-01</d><h>13:36</h><w>aratare</w>I have it in lein</z><z id="t1617284226" t="aratare do I need to also require it like next.jdbc.datetime ?"><y>#</y><d>2021-04-01</d><h>13:37</h><w>aratare</w>do I need to also <code>require</code> it like <code>next.jdbc.datetime</code>?</z><z id="t1617284319" t="aratare so here’s what I have atm: ;; conn (connection/-&gt;pool HikariDataSource (select-keys env [:jdbcUrl])) (s/defn read-user-tab :- [TabDB] [{:user/keys [id]} :- {:user/id s/Uuid}] (log/info &quot;Reading tabs for user id&quot; id) (nj/with-transaction [tx db] (nj/execute! tx (-&gt; (helpers/select :*) (helpers/from :tab) (helpers/where [:= :tab/user-id id]) (sql/format {:dialect :ansi})))))"><y>#</y><d>2021-04-01</d><h>13:38</h><w>aratare</w>so here’s what I have atm:
<pre>;; conn
(connection/-&gt;pool HikariDataSource (select-keys env [:jdbcUrl]))

(s/defn read-user-tab :- [TabDB]
  [{:user/keys [id]} :- {:user/id s/Uuid}]
  (log/info &quot;Reading tabs for user id&quot; id)
  (nj/with-transaction [tx db]
    (nj/execute! tx (-&gt; (helpers/select :*)
                        (helpers/from :tab)
                        (helpers/where [:= :tab/user-id id])
                        (sql/format {:dialect :ansi})))))</pre></z><z id="t1617284359" t="aratare I’m getting yelled at that user-id relation doesn’t exist"><y>#</y><d>2021-04-01</d><h>13:39</h><w>aratare</w>I’m getting yelled at that <code>user-id</code> relation doesn’t exist</z><z id="t1617284369" t="aratare it’s called user_id in the db"><y>#</y><d>2021-04-01</d><h>13:39</h><w>aratare</w>it’s called <code>user_id</code> in the db</z><z id="t1617284371" t="dharrigan you don&apos;t need the :tab/user-id"><y>#</y><d>2021-04-01</d><h>13:39</h><w>dharrigan</w>you don&apos;t need the <code>:tab/user-id</code></z><z id="t1617284381" t="dharrigan just [:= :user-id id]"><y>#</y><d>2021-04-01</d><h>13:39</h><w>dharrigan</w>just <code>[:= :user-id id]</code></z><z id="t1617284423" t="aratare let me test real quick"><y>#</y><d>2021-04-01</d><h>13:40</h><w>aratare</w>let me test real quick</z><z id="t1617284966" t="aratare [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] No luck. It’s still giving me ERROR: column &quot;user-id&quot; of relation &quot;tab&quot; does not exist"><y>#</y><d>2021-04-01</d><h>13:49</h><w>aratare</w><a>@dharrigan</a> No luck. It’s still giving me <code>ERROR: column &quot;user-id&quot; of relation &quot;tab&quot; does not exist</code></z><z id="t1617285029" t="aratare with or without the tab namespace"><y>#</y><d>2021-04-01</d><h>13:50</h><w>aratare</w>with or without the <code>tab</code> namespace</z><z id="t1617285039" t="aratare changing it to user_id works as expected"><y>#</y><d>2021-04-01</d><h>13:50</h><w>aratare</w>changing it to <code>user_id</code> works as expected</z><z id="t1617285055" t="dharrigan question why dialect ansi?"><y>#</y><d>2021-04-01</d><h>13:50</h><w>dharrigan</w>question why dialect ansi?</z><z id="t1617285074" t="aratare because I want quoting"><y>#</y><d>2021-04-01</d><h>13:51</h><w>aratare</w>because I want quoting</z><z id="t1617285086" t="dharrigan the quoting may disable the undasherizing"><y>#</y><d>2021-04-01</d><h>13:51</h><w>dharrigan</w>the quoting may disable the undasherizing</z><z id="t1617285089" t="dharrigan https://github.com/seancorfield/honeysql/blob/8ffca0deae44c6a1d546669cbcaa5c8bdb8baa32/src/honeysql/format.cljc#L75"><y>#</y><d>2021-04-01</d><h>13:51</h><w>dharrigan</w><a href="https://github.com/seancorfield/honeysql/blob/8ffca0deae44c6a1d546669cbcaa5c8bdb8baa32/src/honeysql/format.cljc#L75" target="_blank">https://github.com/seancorfield/honeysql/blob/8ffca0deae44c6a1d546669cbcaa5c8bdb8baa32/src/honeysql/format.cljc#L75</a></z><z id="t1617285092" t="aratare @ /cdn-cgi/l/email-protection"><y>#</y><d>2021-04-01</d><h>13:51</h><w>aratare</w>@<a href="/cdn-cgi/l/email-protection" target="_blank">/cdn-cgi/l/email-protection</a></z><z id="t1617285141" t="aratare holy heck"><y>#</y><d>2021-04-01</d><h>13:52</h><w>aratare</w>holy heck</z><z id="t1617285143" t="aratare you’re right"><y>#</y><d>2021-04-01</d><h>13:52</h><w>aratare</w>you’re right</z><z id="t1617285149" t="aratare I just removed it and it works"><y>#</y><d>2021-04-01</d><h>13:52</h><w>aratare</w>I just removed it and it works</z><z id="t1617285156" t="dharrigan party-corgi"><y>#</y><d>2021-04-01</d><h>13:52</h><w>dharrigan</w><b>party-corgi</b></z><z id="t1617285169" t="aratare haha is that even intended?"><y>#</y><d>2021-04-01</d><h>13:52</h><w>aratare</w>haha is that even intended?</z><z id="t1617285187" t="dharrigan probably. Sean wouldn&apos;t do anything without a reason 🙂"><y>#</y><d>2021-04-01</d><h>13:53</h><w>dharrigan</w>probably. Sean wouldn&apos;t do anything without a reason <b>🙂</b></z><z id="t1617285207" t="dharrigan it&apos;s probably because as you&apos;re using ansi, it won&apos;t make any assumptions about the identifiers"><y>#</y><d>2021-04-01</d><h>13:53</h><w>dharrigan</w>it&apos;s probably because as you&apos;re using ansi, it won&apos;t make any assumptions about the identifiers</z><z id="t1617285213" t="dharrigan it&apos;ll treat them &quot;literally&quot;"><y>#</y><d>2021-04-01</d><h>13:53</h><w>dharrigan</w>it&apos;ll treat them &quot;literally&quot;</z><z id="t1617285223" t="dharrigan rather than trying to undasherize them"><y>#</y><d>2021-04-01</d><h>13:53</h><w>dharrigan</w>rather than trying to undasherize them</z><z id="t1617285246" t="aratare I mean I can rename the table, but it’s hard trying to find anything more suitable than user"><y>#</y><d>2021-04-01</d><h>13:54</h><w>aratare</w>I mean I can rename the table, but it’s hard trying to find anything more suitable than <code>user</code></z><z id="t1617285397" t="aratare I have another problem it seems. The returned map still keeps it as user_id …"><y>#</y><d>2021-04-01</d><h>13:56</h><w>aratare</w>I have another problem it seems. The returned map still keeps it as <code>user_id</code>…</z><z id="t1617285518" t="aratare Well that’s tomorrow’s problem. Time for me to do something else 😅"><y>#</y><d>2021-04-01</d><h>13:58</h><w>aratare</w>Well that’s tomorrow’s problem. Time for me to do something else <b>😅</b></z><z id="t1617285726" t="dharrigan User is the only convention I break (keeping tables singular) and I call it users"><y>#</y><d>2021-04-01</d><h>14:02</h><w>dharrigan</w><code>User</code> is the only convention I break (keeping tables singular) and I call it <code>users</code></z><z id="t1617285736" t="dharrigan makes life simple 🙂"><y>#</y><d>2021-04-01</d><h>14:02</h><w>dharrigan</w>makes life simple <b>🙂</b></z><z id="t1617294846" t="seancorfield [:attrs {:href &quot;/_/_/users/U013F1Q1R7G&quot;}] To clarify some stuff about the camel snake kebab stuff: that only affects next.jdbc and it only affects 1) names in ResultSet ’s that the library converts to Clojure and 2) names in Clojure data structures that the library converts to SQL — it does not (cannot) affect anything in the SQL string itself."><y>#</y><d>2021-04-01</d><h>16:34</h><w>seancorfield</w><a>@rextruong</a> To clarify some stuff about the camel snake kebab stuff: that only affects <code>next.jdbc</code> and it only affects 1) names in <code>ResultSet</code>’s that the library converts to Clojure and 2) names in Clojure data structures that the library converts to SQL — it does not (cannot) affect anything in the SQL string itself.</z><z id="t1617294974" t="seancorfield HoneySQL V2 defaults to :ansi dialect so you don’t need to provide it as an option (it’s relatively harmless to do so). If you specify a dialect, you get quoting. You can also ask for :quoted true to get quoted with the current/default dialect."><y>#</y><d>2021-04-01</d><h>16:36</h><w>seancorfield</w>HoneySQL V2 defaults to <code>:ansi</code> dialect so you don’t need to provide it as an option (it’s relatively harmless to do so). If you specify a dialect, you get quoting. You can also ask for <code>:quoted true</code> to get quoted with the current/default dialect.</z><z id="t1617295069" t="seancorfield If you ask HoneySQL to quote names, it does so without dealing with - /`_` — in both V1 (which is the code [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] linked to) and V2 here: https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L150-L169"><y>#</y><d>2021-04-01</d><h>16:37</h><w>seancorfield</w>If you ask HoneySQL to quote names, it does so without dealing with <code>-</code>/`_` — in both V1 (which is the code <a>@dharrigan</a> linked to) and V2 here: <a href="https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L150-L169" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L150-L169</a></z><z id="t1617295160" t="seancorfield user=&gt; (-&gt; {:select :* :from :tab :where [:= :tab/user-id 42]} (sql/format)) [&quot;SELECT * FROM tab WHERE tab.user_id = ?&quot; 42] user=&gt; (-&gt; {:select :* :from :tab :where [:= :tab/user-id 42]} (sql/format {:quoted true})) [&quot;SELECT * FROM \&quot;tab\&quot; WHERE \&quot;tab\&quot;.\&quot;user-id\&quot; = ?&quot; 42]"><y>#</y><d>2021-04-01</d><h>16:39</h><w>seancorfield</w><pre>user=&gt; (-&gt; {:select :* :from :tab :where [:= :tab/user-id 42]} (sql/format))
[&quot;SELECT * FROM tab WHERE tab.user_id = ?&quot; 42]
user=&gt; (-&gt; {:select :* :from :tab :where [:= :tab/user-id 42]} (sql/format {:quoted true}))
[&quot;SELECT * FROM \&quot;tab\&quot; WHERE \&quot;tab\&quot;.\&quot;user-id\&quot; = ?&quot; 42]</pre></z><z id="t1617295245" t="seancorfield See some of the important differences around V1/V2 handling of names here https://github.com/seancorfield/honeysql/blob/v2/doc/differences-from-1-x.md#option-changes"><y>#</y><d>2021-04-01</d><h>16:40</h><w>seancorfield</w>See some of the important differences around V1/V2 handling of names here <a href="https://github.com/seancorfield/honeysql/blob/v2/doc/differences-from-1-x.md#option-changes" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/doc/differences-from-1-x.md#option-changes</a></z><z id="t1617327181" t="aratare Thanks for the explanation and the fix [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] . I have one more question if that’s okay. I’m currently getting user-id returned as snake case from execute-one! with the following code: (let [tab {:id (java.util.UUID/fromString &quot;a768c90a-e1f2-4b66-bfd6-a9d8773dffd8&quot;), :name &quot;foo&quot;, :password &quot;.Xp8&quot;, :user-id (java.util.UUID/fromString &quot;740cb441-ce5e-4f8f-b328-009dc44ebda6&quot;)}] (nj/with-transaction [tx db] (nj/execute-one! tx (-&gt; (helpers/insert-into :tab) (helpers/values [tab]) (helpers/returning :*) (sql/format))))) =&gt; #:tab{:id #uuid&quot;a768c90a-e1f2-4b66-bfd6-a9d8773dffd8&quot;, :name &quot;&quot;, :password &quot;.Xp8&quot;, :created #object[java.time.OffsetDateTime 0x227987af &quot;2021-04-02T01:30:20.962643Z&quot;], :updated #object[java.time.OffsetDateTime 0x46632f55 &quot;2021-04-02T01:30:20.962643Z&quot;], :user_id #uuid&quot;740cb441-ce5e-4f8f-b328-009dc44ebda6&quot;} Am I doing something wrong here? Thanks in advance."><y>#</y><d>2021-04-02</d><h>01:33</h><w>aratare</w>Thanks for the explanation and the fix <a>@seancorfield</a>. I have one more question if that’s okay. I’m currently getting <code>user-id</code> returned as snake case from <code>execute-one!</code> with the following code:
<pre>(let [tab {:id       (java.util.UUID/fromString &quot;a768c90a-e1f2-4b66-bfd6-a9d8773dffd8&quot;),
             :name     &quot;foo&quot;,
             :password &quot;.Xp8&quot;,
             :user-id  (java.util.UUID/fromString &quot;740cb441-ce5e-4f8f-b328-009dc44ebda6&quot;)}]
    (nj/with-transaction [tx db]
                         (nj/execute-one! tx (-&gt; (helpers/insert-into :tab)
                                                 (helpers/values [tab])
                                                 (helpers/returning :*)
                                                 (sql/format)))))

=&gt; #:tab{:id #uuid&quot;a768c90a-e1f2-4b66-bfd6-a9d8773dffd8&quot;,
      :name &quot;&quot;,
      :password &quot;.Xp8&quot;,
      :created #object[java.time.OffsetDateTime 0x227987af &quot;2021-04-02T01:30:20.962643Z&quot;],
      :updated #object[java.time.OffsetDateTime 0x46632f55 &quot;2021-04-02T01:30:20.962643Z&quot;],
      :user_id #uuid&quot;740cb441-ce5e-4f8f-b328-009dc44ebda6&quot;}</pre>
Am I doing something wrong here? Thanks in advance.</z><z id="t1617327354" t="seancorfield What is the column actually called in the DB [:attrs {:href &quot;/_/_/users/U013F1Q1R7G&quot;}] ?"><y>#</y><d>2021-04-02</d><h>01:35</h><w>seancorfield</w>What is the column actually called in the DB <a>@rextruong</a>?</z><z id="t1617327393" t="aratare user_id , hence the reason why I was asking about how HoneySQL handles conversion between the two cases."><y>#</y><d>2021-04-02</d><h>01:36</h><w>aratare</w><code>user_id</code>, hence the reason why I was asking about how HoneySQL handles conversion between the two cases.</z><z id="t1617327421" t="aratare You mentioned “it only affects 1) names in ResultSet’s that the library converts to Clojure” so that’s why I’m expecting user-id instead"><y>#</y><d>2021-04-02</d><h>01:37</h><w>aratare</w>You mentioned “it only affects 1) names in ResultSet’s that the library converts to Clojure” so that’s why I’m expecting <code>user-id</code> instead</z><z id="t1617327442" t="seancorfield Since you are using the default result set builder, you get &lt;table&gt;/&lt;column&gt; ."><y>#</y><d>2021-04-02</d><h>01:37</h><w>seancorfield</w>Since you are using the default result set builder, you get <code>&lt;table&gt;/&lt;column&gt;</code>.</z><z id="t1617327472" t="seancorfield If you have Camel Snake Kebab on your classpath, that enables a couple of new result set builders that you can choose to use."><y>#</y><d>2021-04-02</d><h>01:37</h><w>seancorfield</w>If you have Camel Snake Kebab on your classpath, that enables a couple of new result set builders that you can choose to use.</z><z id="t1617327483" t="seancorfield It doesn’t change the default behavior."><y>#</y><d>2021-04-02</d><h>01:38</h><w>seancorfield</w>It doesn’t change the default behavior.</z><z id="t1617327498" t="aratare Ah that makes sense"><y>#</y><d>2021-04-02</d><h>01:38</h><w>aratare</w>Ah that makes sense</z><z id="t1617327559" t="seancorfield next.jdbc ’s default is to leave names alone going in both directions (with the caveat that you get qualified names out)."><y>#</y><d>2021-04-02</d><h>01:39</h><w>seancorfield</w><code>next.jdbc</code>’s default is to leave names alone going in both directions (with the caveat that you get qualified names out).</z><z id="t1617327598" t="aratare I see. So I’d need to change the builder when I’m setting next.jdbc up."><y>#</y><d>2021-04-02</d><h>01:39</h><w>aratare</w>I see. So I’d need to change the builder when I’m setting <code>next.jdbc</code> up.</z><z id="t1617327625" t="aratare Will have a go at it now. Thanks a lot 🙂"><y>#</y><d>2021-04-02</d><h>01:40</h><w>aratare</w>Will have a go at it now. Thanks a lot <b>🙂</b></z><z id="t1617327690" t="seancorfield You can specify :table-fn and :column-fn to affect how the “friendly” SQL functions deal with (Clojure data structure) input and you can specify :builder-fn to affect how almost all functions deal with (`ResultSet` to Clojure data structure) output."><y>#</y><d>2021-04-02</d><h>01:41</h><w>seancorfield</w>You can specify <code>:table-fn</code> and <code>:column-fn</code> to affect how the “friendly” SQL functions deal with (Clojure data structure) input and you can specify <code>:builder-fn</code> to affect how almost all functions deal with (`ResultSet` to Clojure data structure) output.</z><z id="t1617327780" t="seancorfield If you want a particular set of behaviors to be your “default” (for most calls), take a look at next.jdbc/with-options but also be aware of the caveats around that near the end of https://cljdoc.org/d/seancorfield/next.jdbc/1.1.646/doc/getting-started#options--result-set-builders"><y>#</y><d>2021-04-02</d><h>01:43</h><w>seancorfield</w>If you want a particular set of behaviors to be your “default” (for most calls), take a look at <code>next.jdbc/with-options</code> but also be aware of the caveats around that near the end of <a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.1.646/doc/getting-started#options--result-set-builders" target="_blank">https://cljdoc.org/d/seancorfield/next.jdbc/1.1.646/doc/getting-started#options--result-set-builders</a></z><z id="t1617327834" t="seancorfield HoneySQL operates completely “independently” of next.jdbc insofar as all it does is turn Clojure data into SQL (plus parameters) so any translation of names there only corresponds to next.jdbc ’s “input” via the “friendly” SQL functions."><y>#</y><d>2021-04-02</d><h>01:43</h><w>seancorfield</w>HoneySQL operates completely “independently” of <code>next.jdbc</code> insofar as all it does is turn Clojure data into SQL (plus parameters) so any translation of names there only corresponds to <code>next.jdbc</code>’s “input” via the “friendly” SQL functions.</z><z id="t1617327882" t="seancorfield (I definitely need to clarify that in HoneySQL’s docs!)"><y>#</y><d>2021-04-02</d><h>01:44</h><w>seancorfield</w>(I definitely need to clarify that in HoneySQL’s docs!)</z><z id="t1617327945" t="aratare So I was reading that link and I noticed that the examples are mostly just jdbc/get-datasource . I assume with-options also works with connection/-&gt;pool ?"><y>#</y><d>2021-04-02</d><h>01:45</h><w>aratare</w>So I was reading that link and I noticed that the examples are mostly just <code>jdbc/get-datasource</code>. I assume <code>with-options</code> also works with <code>connection/-&gt;pool</code>?</z><z id="t1617327974" t="seancorfield Yes, because it “is-a” DataSource ."><y>#</y><d>2021-04-02</d><h>01:46</h><w>seancorfield</w>Yes, because it “is-a” <code>DataSource</code>.</z><z id="t1617327988" t="aratare Lovely. Thanks."><y>#</y><d>2021-04-02</d><h>01:46</h><w>aratare</w>Lovely. Thanks.</z><z id="t1617328042" t="seancorfield with-options : “Given a connectable/transactable object and a set of (default) options that should be used on all operations on that object, return a new wrapper object that can be used in its place.” — a connectable is anything you can get a Connection from."><y>#</y><d>2021-04-02</d><h>01:47</h><w>seancorfield</w><code>with-options</code>: “Given a connectable/transactable object and a set of (default) options that should be used on all operations on that object, return a new wrapper object that can be used in its place.” — a connectable is anything you can get a <code>Connection</code> from.</z><z id="t1617328077" t="seancorfield (you just have to be careful that if you get a Connection from it, that’s a bare Java object with no “options” attached)"><y>#</y><d>2021-04-02</d><h>01:47</h><w>seancorfield</w>(you just have to be careful that if you get a <code>Connection</code> from it, that’s a bare Java object with no “options” attached)</z><z id="t1617963747" t="Joe Hello, first time HoneySQL user here. I&apos;m doing an insert statement on a PostGres DB, and having trouble with the SQL HoneySQL is spitting out..."><y>#</y><d>2021-04-09</d><h>10:22</h><w>Joe</w>Hello, first time HoneySQL user here.
I&apos;m doing an insert statement on a PostGres DB, and having trouble with the SQL HoneySQL is spitting out...</z><z id="t1617963771" t="Joe This is the clojure code: (-&gt; (insert-into :records) (values sample-records) (sql/format))"><y>#</y><d>2021-04-09</d><h>10:22</h><r>Joe</r>This is the clojure code:
<pre>(-&gt; (insert-into :records)
    (values sample-records)
    (sql/format))</pre></z><z id="t1617963873" t="Joe which produces this (slightly sanitized) [&quot;INSERT INTO records (date, balance, account_number, amount, memo, payee, category) VALUES (?, ?, ?, ?, ?, ?, food), (?, ?, ?, ?, ?, ?, food)&quot; &quot;01/02/2021&quot; 123.45 &quot;acc&quot; 123.45 &quot;memo&quot; &quot;Deliveroo&quot; &quot;01/02/2021&quot; 123.45 &quot;acc&quot; 123.45 &quot;memo&quot; &quot;Tesco&quot;] When I try to execute this I get ; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2553). ; ERROR: column &quot;food&quot; does not exist"><y>#</y><d>2021-04-09</d><h>10:24</h><r>Joe</r>which produces this (slightly sanitized)
<pre>[&quot;INSERT INTO records (date, balance, account_number, amount, memo, payee, category) VALUES (?, ?, ?, ?, ?, ?, food), (?, ?, ?, ?, ?, ?, food)&quot;
 &quot;01/02/2021&quot;
 123.45
 &quot;acc&quot;
 123.45
 &quot;memo&quot;
 &quot;Deliveroo&quot;
 &quot;01/02/2021&quot;
 123.45
 &quot;acc&quot;
 123.45
 &quot;memo&quot;
 &quot;Tesco&quot;]</pre>
When I try to execute this I get
<pre>; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2553).
; ERROR: column &quot;food&quot; does not exist</pre></z><z id="t1617963946" t="dharrigan can you show what your sample-records looks like"><y>#</y><d>2021-04-09</d><h>10:25</h><r>dharrigan</r>can you show what your <code>sample-records</code> looks like</z><z id="t1617963955" t="Joe I&apos;m not super clear on why food is being considered a column, when it&apos;s clearly specified as a value. But when I manually reformat to [&quot;INSERT INTO records (date, balance, account_number, amount, memo, payee, category) VALUES (?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?)&quot; &quot;01/02/2021&quot; 123.45 &quot;acc&quot; 123.45 &quot;memo&quot; &quot;Deliveroo&quot; &quot;food&quot; &quot;01/02/2021&quot; 123.45 &quot;acc&quot; 123.45 &quot;memo&quot; &quot;Tesco&quot; &quot;food&quot;] it seems to work OK."><y>#</y><d>2021-04-09</d><h>10:25</h><r>Joe</r>I&apos;m not super clear on why <code>food</code> is being considered a column, when it&apos;s clearly specified as a value. But when I manually reformat to
<pre>[&quot;INSERT INTO records (date, balance, account_number, amount, memo, payee, category) VALUES (?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?)&quot;
 &quot;01/02/2021&quot;
 123.45
 &quot;acc&quot;
 123.45
 &quot;memo&quot;
 &quot;Deliveroo&quot;
 &quot;food&quot;
 &quot;01/02/2021&quot;
 123.45
 &quot;acc&quot;
 123.45
 &quot;memo&quot;
 &quot;Tesco&quot;
 &quot;food&quot;]</pre>
it seems to work OK.</z><z id="t1617964073" t="Joe &gt; can you show what your sample-records looks like Sure, it&apos;s {:date &quot;01/02/2021&quot; :balance 123.45 :account-number &quot;acc&quot; :amount 123.45 :memo &quot;memo&quot; :payee &quot;Deliveroo&quot; :category :food} Now I look at it, it seem like it must be something to do with the keyword. Maybe I need stringify that before I pass it in"><y>#</y><d>2021-04-09</d><h>10:27</h><r>Joe</r>&gt; can you show what your <code>sample-records</code> looks like
Sure, it&apos;s
<pre>{:date &quot;01/02/2021&quot;
   :balance 123.45
   :account-number &quot;acc&quot;
   :amount 123.45
   :memo &quot;memo&quot;
   :payee &quot;Deliveroo&quot;
   :category :food}</pre>
Now I look at it, it seem like it must be something to do with the keyword. Maybe I need stringify that before I pass it in</z><z id="t1617964101" t="Joe So the SQL comes out (?, ?, ?, ?, ?, ?, &apos;food&apos;) or something"><y>#</y><d>2021-04-09</d><h>10:28</h><r>Joe</r>So the SQL comes out <code>(?, ?, ?, ?, ?, ?, &apos;food&apos;)</code> or something</z><z id="t1617964150" t="Joe Yup, that did it, thanks for the prompt!"><y>#</y><d>2021-04-09</d><h>10:29</h><r>Joe</r>Yup, that did it, thanks for the prompt!</z><z id="t1617964303" t="dharrigan you&apos;re welcome 🙂"><y>#</y><d>2021-04-09</d><h>10:31</h><r>dharrigan</r>you&apos;re welcome <b>🙂</b></z><z id="t1617984849" t="seancorfield [:attrs {:href &quot;/_/_/users/U0105JJK1L3&quot;}] Keywords (and symbols) are treated as column names, universally, in HoneySQL — and you would need to convert :food to a string even if you weren’t using HoneySQL because you can’t write a Clojure keyword into a SQL database."><y>#</y><d>2021-04-09</d><h>16:14</h><r>seancorfield</r><a>@U0105JJK1L3</a> Keywords (and symbols) are treated as column names, universally, in HoneySQL — and you would need to convert <code>:food</code> to a string even if you weren’t using HoneySQL because you can’t write a Clojure keyword into a SQL database.</z><z id="t1617986292" t="Joe That make sense, thanks Sean"><y>#</y><d>2021-04-09</d><h>16:38</h><r>Joe</r>That make sense, thanks Sean</z><z id="t1618038061" t="seancorfield com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-beta1&quot;} — HoneySQL V2 moves out of Alpha! At this point I consider the documentation “complete” (it will continue to grow but I believe it now covers all V2 functionality) and the APIs are all stable. Only accretive/fixative changes will be made from this point on. See https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-beta1 for details of this release. I consider this stable for production usage (we’re already using Alpha 3 at work)."><y>#</y><d>2021-04-10</d><h>07:01</h><w>seancorfield</w><code>com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-beta1&quot;}</code> — HoneySQL V2 moves out of Alpha! At this point I consider the documentation “complete” (it will continue to grow but I believe it now covers all V2 functionality) and the APIs are all stable. Only accretive/fixative changes will be made from this point on. See <a href="https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-beta1" target="_blank">https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-beta1</a> for details of this release. I consider this stable for production usage (we’re already using Alpha 3 at work).</z><z id="t1618038113" t="dharrigan w00t!"><y>#</y><d>2021-04-10</d><h>07:01</h><w>dharrigan</w>w00t!</z><z id="t1618038141" t="dharrigan Will you let it bed in for a couple of weeks before promoting to release?"><y>#</y><d>2021-04-10</d><h>07:02</h><w>dharrigan</w>Will you let it bed in for a couple of weeks before promoting to release?</z><z id="t1618039089" t="seancorfield At least a couple of weeks, yes."><y>#</y><d>2021-04-10</d><h>07:18</h><w>seancorfield</w>At least a couple of weeks, yes.</z><z id="t1618039125" t="seancorfield I’m hoping for wider usage/testing now it’s “stable” (out of alpha) and therefore more feedback on the docs and some of the specific functionality."><y>#</y><d>2021-04-10</d><h>07:18</h><w>seancorfield</w>I’m hoping for wider usage/testing now it’s “stable” (out of alpha) and therefore more feedback on the docs and some of the specific functionality.</z><z id="t1618039212" t="seancorfield (I’ve already found and pushed a bunch of small doc fixes since Beta 1 hit http://cljdoc.org !)"><y>#</y><d>2021-04-10</d><h>07:20</h><w>seancorfield</w>(I’ve already found and pushed a bunch of small doc fixes since Beta 1 hit <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a>!)</z><z id="t1618039368" t="dharrigan I&apos;m writing a new backend service, using v2, nothing fancy, nothing pushing the boundaries, but will keep an eye on it 🙂"><y>#</y><d>2021-04-10</d><h>07:22</h><w>dharrigan</w>I&apos;m writing a new backend service, using v2, nothing fancy, nothing pushing the boundaries, but will keep an eye on it <b>🙂</b></z><z id="t1618039400" t="seancorfield Of the open issues, I definitely want to get #308 and #310 done for an RC, maybe #315 as well. I still need to figure out what to do about #146 (Spec) and I need to come up with a suitable extension hook for Gungnir #276."><y>#</y><d>2021-04-10</d><h>07:23</h><w>seancorfield</w>Of the open issues, I definitely want to get #308 and #310 done for an RC, maybe #315 as well. I still need to figure out what to do about #146 (Spec) and I need to come up with a suitable extension hook for Gungnir #276.</z><z id="t1618039462" t="seancorfield But those are all accretive at this point. The rest will slip to 2.1 or later."><y>#</y><d>2021-04-10</d><h>07:24</h><w>seancorfield</w>But those are all accretive at this point. The rest will slip to 2.1 or later.</z><z id="t1618039508" t="dharrigan All excellent news. It&apos;s a great library"><y>#</y><d>2021-04-10</d><h>07:25</h><w>dharrigan</w>All excellent news. It&apos;s a great library</z><z id="t1618044260" t="Ben Sless Hi, something I&apos;ve been wondering about regarding honeysql for a while is if there&apos;s any way to render a string in advance and pass it parameters as symbols. From what I&apos;ve seen there&apos;s no way to avoid calling format every time, but I could have missed it. What I had in mind can best be illustrated by this little macro I wrote: (defn parametrize-form [form params] (clojure.walk/postwalk (fn [e] (if (and (symbol? e) (contains? params e)) `(sql/param ~(keyword e)) e)) form)) (defn format [args query] (let [form (parametrize-form query (set args))] (sql/format (eval form) (zipmap (map keyword args) args)))) (defmacro defsql [name args query] `(defn ~name [ I wouldn&apos;t feel half as bad about it if it didn&apos;t use eval thoughts?"><y>#</y><d>2021-04-10</d><h>08:44</h><w>Ben Sless</w>Hi, something I&apos;ve been wondering about regarding honeysql for a while is if there&apos;s any way to render a string in advance and pass it parameters as symbols. From what I&apos;ve seen there&apos;s no way to avoid calling <code>format</code> every time, but I could have missed it.
What I had in mind can best be illustrated by this little macro I wrote:
<pre>(defn parametrize-form
  [form params]
  (clojure.walk/postwalk
   (fn [e]
     (if (and (symbol? e)
              (contains? params e))
       `(sql/param ~(keyword e))
       e))
   form))

(defn format
  [args query]
  (let [form (parametrize-form query (set args))]
    (sql/format (eval form) (zipmap (map keyword args) args))))

(defmacro defsql
  [name args query]
  `(defn ~name [</pre>
I wouldn&apos;t feel half as bad about it if it didn&apos;t use <code>eval</code>
thoughts?</z><z id="t1618071010" t="seancorfield [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] yeah, this is something I&apos;ve thought about often but haven&apos;t yet come up with a good way to handle in the context of HoneySQL. It&apos;s definitely still on my radar."><y>#</y><d>2021-04-10</d><h>16:10</h><w>seancorfield</w><a>@ben.sless</a> yeah, this is something I&apos;ve thought about often but haven&apos;t yet come up with a good way to handle in the context of HoneySQL. It&apos;s definitely still on my radar.</z><z id="t1618072298" t="seancorfield I’ll create a GH issue for tracking. It definitely feels like something worth doing. It’s not easy though: there are some constructs that don’t lend themselves to it in all cases — the two that spring to mind immediately are [:in :col some-vals] where the generated string depends on the number of elements in some-vals and even something as simple as [:= :col foo] because the generated string is different for foo being nil , vs foo being non-`nil`: col IS NULL vs col = ? ."><y>#</y><d>2021-04-10</d><h>16:31</h><w>seancorfield</w>I’ll create a GH issue for tracking. It definitely feels like something worth doing. It’s not easy though: there are some constructs that don’t lend themselves to it in all cases — the two that spring to mind immediately are <code>[:in :col some-vals]</code> where the generated string depends on the number of elements in <code>some-vals</code> and even something as simple as <code>[:= :col foo]</code> because the generated string is different for <code>foo</code> being <code>nil</code>, vs <code>foo</code> being non-`nil`: <code>col IS NULL</code> vs <code>col = ?</code>.</z><z id="t1618077384" t="Ben Sless Figured it wasn&apos;t going to be this easy 🙂"><y>#</y><d>2021-04-10</d><h>17:56</h><r>Ben Sless</r>Figured it wasn&apos;t going to be this easy <b>🙂</b></z><z id="t1618078069" t="Ben Sless &gt; produce strings with special placeholders so that only those pieces of the overall string needed to be generated for a final format Wonder if it&apos;s possible to return a closure and delay the building Emit something like: (fn [foo] (let [rendered-foo (if (nil? foo) &quot; IS NULL&quot; &quot; = ?&quot;)] (let [sb (StringBuilder.)] (.append sb &quot;SELECT * WHERE col&quot;) (.append sb rendered-foo)))) "><y>#</y><d>2021-04-10</d><h>18:07</h><r>Ben Sless</r>&gt; produce strings with special placeholders so that only those pieces of the overall string needed to be generated for a final format
Wonder if it&apos;s possible to return a closure and delay the building
Emit something like:
<pre>(fn [foo]
  (let [rendered-foo (if (nil? foo) &quot; IS NULL&quot; &quot; = ?&quot;)]
    (let [sb (StringBuilder.)]
      (.append sb &quot;SELECT * WHERE col&quot;)
      (.append sb rendered-foo))))</pre>
</z><z id="t1618078933" t="seancorfield Right now, the entire formatting system expects to use str to bash pieces together under the hood. I suspect I’d need to change every piece of code that does that to allow for a sequence of strings-or-thunks and then have just the top-level format actually bash everything together — but that would break the public API functions format-expr and format-dsl , as well as making it much harder for anyone to extend HoneySQL for their own syntax."><y>#</y><d>2021-04-10</d><h>18:22</h><r>seancorfield</r>Right now, the entire formatting system expects to use <code>str</code> to bash pieces together under the hood. I suspect I’d need to change every piece of code that does that to allow for a sequence of strings-or-thunks and then have just the top-level <code>format</code> actually bash everything together — but that would break the public API functions <code>format-expr</code> and <code>format-dsl</code>, as well as making it much harder for anyone to extend HoneySQL for their own syntax.</z><z id="t1618079004" t="seancorfield One “easy” workaround is to build the sql+params once with dummy values and just reuse that sql string with different sets of values — but that doesn’t account for IN or the NULL stuff."><y>#</y><d>2021-04-10</d><h>18:23</h><r>seancorfield</r>One “easy” workaround is to build the sql+params once with dummy values and just reuse that sql string with different sets of values — but that doesn’t account for <code>IN</code> or the <code>NULL</code> stuff.</z><z id="t1618079168" t="seancorfield Another option is to produce a Selmer-style template that could just be formatted with the final set of parameters — but that’s still going to potentially do a bunch of string-bashing each time anyway."><y>#</y><d>2021-04-10</d><h>18:26</h><r>seancorfield</r>Another option is to produce a Selmer-style template that could just be formatted with the final set of parameters — but that’s still going to potentially do a bunch of string-bashing each time anyway.</z><z id="t1618079297" t="seancorfield As an example of the complexity of logic needed to “do the right thing”, look at how much conditional logic is in format-in to take into account empty collections and nil values: https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L923-L951"><y>#</y><d>2021-04-10</d><h>18:28</h><r>seancorfield</r>As an example of the complexity of logic needed to “do the right thing”, look at how much conditional logic is in <code>format-in</code> to take into account empty collections and <code>nil</code> values: <a href="https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L923-L951" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L923-L951</a></z><z id="t1618080861" t="Ben Sless That&apos;s pretty complicated"><y>#</y><d>2021-04-10</d><h>18:54</h><r>Ben Sless</r>That&apos;s pretty complicated</z><z id="t1618081356" t="seancorfield SQL is complicated, man 🙂"><y>#</y><d>2021-04-10</d><h>19:02</h><r>seancorfield</r>SQL is complicated, man <b>🙂</b></z><z id="t1618081800" t="Ben Sless I think it was Rich in one of his talks who commented on how silly SQL was, instead of being a protocol/specification first it was a natural language first and doomed us forever to string-manipulation-purgatory"><y>#</y><d>2021-04-10</d><h>19:10</h><r>Ben Sless</r>I think it was Rich in one of his talks who commented on how silly SQL was, instead of being a protocol/specification first it was a natural language first and doomed us forever to string-manipulation-purgatory</z><z id="t1618082059" t="seancorfield Yeah, it’s been eye-opening trying to implement a much large subset of SQL for V2 than V1 supported — and the vendor-specific extensions are often completely arbitrary as far as syntax goes (in my opinion)."><y>#</y><d>2021-04-10</d><h>19:14</h><r>seancorfield</r>Yeah, it’s been eye-opening trying to implement a much large subset of SQL for V2 than V1 supported — and the vendor-specific extensions are often completely arbitrary as far as syntax goes (in my opinion).</z><z id="t1618082101" t="seancorfield Every year I continue to work with relational databases is a year that I get ever closer to wanting something more like Datalog instead 🙂"><y>#</y><d>2021-04-10</d><h>19:15</h><r>seancorfield</r>Every year I continue to work with relational databases is a year that I get ever closer to wanting something more like Datalog instead <b>🙂</b></z><z id="t1618082159" t="seancorfield That said, HoneySQL has definitely made our lives easier at World Singles Networks, where we programmatically compose some very gnarly reporting queries full of conditionals…"><y>#</y><d>2021-04-10</d><h>19:15</h><r>seancorfield</r>That said, HoneySQL has definitely made our lives easier at World Singles Networks, where we programmatically compose some very gnarly reporting queries full of conditionals…</z><z id="t1618082504" t="Ben Sless Working with data is certainly better than working with strings, don&apos;t get me wrong, but at the bottom of the stack stands some poor soul who has to write a compiler for that mess"><y>#</y><d>2021-04-10</d><h>19:21</h><r>Ben Sless</r>Working with data is certainly better than working with strings, don&apos;t get me wrong, but at the bottom of the stack stands some poor soul who has to write a compiler for that mess</z><z id="t1618082563" t="seancorfield As someone who started their career in IT writing compilers, yes, I feel that pain 🙂"><y>#</y><d>2021-04-10</d><h>19:22</h><r>seancorfield</r>As someone who started their career in IT writing compilers, yes, I feel that pain <b>🙂</b></z><z id="t1618082684" t="Ben Sless And speaking of bashing strings, I don&apos;t know if you&apos;ll find this useful, but I wrote a templating engine which bashes strings relatively fast because I needed one. Was somewhat inspired by Metosin&apos;s approach https://github.com/bsless/contextual"><y>#</y><d>2021-04-10</d><h>19:24</h><r>Ben Sless</r>And speaking of bashing strings, I don&apos;t know if you&apos;ll find this useful, but I wrote a templating engine which bashes strings relatively fast because I needed one. Was somewhat inspired by Metosin&apos;s approach
<a href="https://github.com/bsless/contextual" target="_blank">https://github.com/bsless/contextual</a></z><z id="t1618082978" t="seancorfield Interesting."><y>#</y><d>2021-04-10</d><h>19:29</h><r>seancorfield</r>Interesting.</z><z id="t1618083225" t="Ben Sless Returning types which implement the desired behavior at run/compile/render time can speed you up significantly over runtime interpretation. Another thing I did because I was already used to that technique was unroll loops where possible, which is why I have ugly macros emitting defrecord s with 20 arities"><y>#</y><d>2021-04-10</d><h>19:33</h><r>Ben Sless</r>Returning types which implement the desired behavior at run/compile/render time can speed you up significantly over runtime interpretation.
Another thing I did because I was already used to that technique was unroll loops where possible, which is why I have ugly macros emitting <code>defrecord</code> s with 20 arities</z><z id="t1618073054" t="seancorfield https://github.com/seancorfield/honeysql/issues/320"><y>#</y><d>2021-04-10</d><h>16:44</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/320" target="_blank">https://github.com/seancorfield/honeysql/issues/320</a></z><z id="t1618077359" t="Ben Sless Can you please tag my GH user, @bsless ?"><y>#</y><d>2021-04-10</d><h>17:55</h><r>Ben Sless</r>Can you please tag my GH user, <code>@bsless</code> ?</z><z id="t1618077488" t="seancorfield Tagged!"><y>#</y><d>2021-04-10</d><h>17:58</h><r>seancorfield</r>Tagged!</z><z id="t1618077492" t="Ben Sless thank you 🙂"><y>#</y><d>2021-04-10</d><h>17:58</h><r>Ben Sless</r>thank you <b>🙂</b></z><z id="t1618077588" t="seancorfield I have a tentative solution for https://github.com/seancorfield/honeysql/issues/315 but I’d like some input: if you effectively say {:where [:in :id []]} what would you expect to get? Also {:where [:in :id [nil]]} ?"><y>#</y><d>2021-04-10</d><h>17:59</h><w>seancorfield</w>I have a tentative solution for <a href="https://github.com/seancorfield/honeysql/issues/315" target="_blank">https://github.com/seancorfield/honeysql/issues/315</a> but I’d like some input: if you effectively say <code>{:where [:in :id []]}</code> what would you expect to get? Also <code>{:where [:in :id [nil]]}</code>?</z><z id="t1618077677" t="seancorfield Since id IN () is not legal SQL and no IDs are in an empty set, I would lean toward producing WHERE FALSE for that case and WHERE id IS NULL for the second case."><y>#</y><d>2021-04-10</d><h>18:01</h><w>seancorfield</w>Since <code>id IN ()</code> is not legal SQL and no IDs are in an empty set, I would lean toward producing <code>WHERE FALSE</code> for that case and <code>WHERE id IS NULL</code> for the second case.</z><z id="t1618077720" t="seancorfield And, just as a sanity check, do folks think adding an explicit OR id IS NULL is the correct way to handle this in the first place?"><y>#</y><d>2021-04-10</d><h>18:02</h><w>seancorfield</w>And, just as a sanity check, do folks think adding an explicit <code>OR id IS NULL</code> is the correct way to handle this in the first place?</z><z id="t1618099242" t="seancorfield (if folks want to actually experiment with #315, it has been pushed to the v2 branch, post Beta 1)"><y>#</y><d>2021-04-11</d><h>00:00</h><w>seancorfield</w>(if folks want to actually experiment with #315, it has been pushed to the v2 branch, post Beta 1)</z><z id="t1618182121" t="seancorfield For folks who do a lot of PostgreSQL work -- and especially folks who are using nilenso/honeysql-postgres with HoneySQL 1.x -- I just added the new features from 0.4.112 (of the nilenso library) to HoneySQL 2.x as special syntax, as well as support for ORDER BY in expressions which I saw in the PG docs while researching FILTER and WITHIN GROUP . It&apos;ll be in the next 2.0.0 Beta but you can try it out via :git/url &quot;&quot; :sha &quot;d734767877b718244d366a7680069eb99ab723b3&quot; if you want."><y>#</y><d>2021-04-11</d><h>23:02</h><w>seancorfield</w>For folks who do a lot of PostgreSQL work -- and especially folks who are using nilenso/honeysql-postgres with HoneySQL 1.x -- I just added the new features from 0.4.112 (of the nilenso library) to HoneySQL 2.x as special syntax, as well as support for <code>ORDER BY</code> in expressions which I saw in the PG docs while researching <code>FILTER</code> and <code>WITHIN GROUP</code>. It&apos;ll be in the next 2.0.0 Beta but you can try it out via <code>:git/url &quot;&quot; :sha &quot;d734767877b718244d366a7680069eb99ab723b3&quot;</code> if you want.</z><z id="t1618182152" t="seancorfield I&apos;d also be interested to hear about any PG features that you use but are not yet implemented by either the nilenso library or by HoneySQL."><y>#</y><d>2021-04-11</d><h>23:02</h><w>seancorfield</w>I&apos;d also be interested to hear about any PG features that you use but are not yet implemented by either the nilenso library or by HoneySQL.</z><z id="t1618254784" t="seancorfield There’s some additional discussion on https://github.com/seancorfield/honeysql/issues/315 that I’d like more input on. I’m inclined to roll that change back out at this point…?"><y>#</y><d>2021-04-12</d><h>19:13</h><w>seancorfield</w>There’s some additional discussion on <a href="https://github.com/seancorfield/honeysql/issues/315" target="_blank">https://github.com/seancorfield/honeysql/issues/315</a> that I’d like more input on. I’m inclined to roll that change back out at this point…?</z><z id="t1618256813" t="sandqvist Assuming a function such as (defn find-foos [ids] (-&gt; (select :*) (from :foo) (where [:in :id ids]))) I would expect to pass either a subselect or a seq of primary keys as ids . Values such as nil , [nil] and [1 2 nil] would all be programming errors in my code and I&apos;m happy to catch them early. Especially the last one (when actually desired) I would always write explicitly as two clauses so that the next person to see the code can see how NULL is handled."><y>#</y><d>2021-04-12</d><h>19:46</h><w>sandqvist</w>Assuming a function such as
<pre>(defn find-foos [ids]
  (-&gt; (select :*)
      (from :foo)
      (where [:in :id ids])))</pre>
I would expect to pass either a subselect or a seq of primary keys as <code>ids</code>. Values such as <code>nil</code>, <code>[nil]</code> and <code>[1 2 nil]</code> would all be programming errors in my code and I&apos;m happy to catch them early. Especially the last one (when actually desired) I would always write explicitly as two clauses so that the next person to see the code can see how NULL is handled.</z><z id="t1618256917" t="seancorfield Thanks, [:attrs {:href &quot;/_/_/users/U1BJTVDLG&quot;}] ! Good feedback. “avoid magic, make programmer errors visible”"><y>#</y><d>2021-04-12</d><h>19:48</h><w>seancorfield</w>Thanks, <a>@sandqvist</a> ! Good feedback. “avoid magic, make programmer errors visible”</z><z id="t1618257093" t="seancorfield So I guess then a question would be: should HoneySQL throw an exception if the IN collection is empty and/or contains nil ? The former seems reasonable since WHERE col IN () is going to blow up in JDBC-land anyway, but the latter is probably a grey area since it “works” in JDBC-land, it just doesn’t necessarily do what the developer might want/expect…?"><y>#</y><d>2021-04-12</d><h>19:51</h><w>seancorfield</w>So I guess then a question would be: should HoneySQL throw an exception if the <code>IN</code> collection is empty and/or contains <code>nil</code>? The former seems reasonable since <code>WHERE col IN ()</code> is going to blow up in JDBC-land anyway, but the latter is probably a grey area since it “works” in JDBC-land, it just doesn’t necessarily do what the developer might want/expect…?</z><z id="t1618258575" t="sandqvist This is a tricky one. For the [] and nil cases an exception would be useful if it makes complex statements easier to debug and fix than looking at the database logs and reading the SQL statement which is what I currently do as I&apos;m still on v1. An exception without a good HoneySQL data structure context might be tricky to figure out. What I mean is unless the IN clause has a helper fn, you can only throw in format , right?"><y>#</y><d>2021-04-12</d><h>20:16</h><w>sandqvist</w>This is a tricky one. For the <code>[]</code> and <code>nil</code> cases an exception would be useful if it makes complex statements easier to debug and fix than looking at the database logs and reading the SQL statement which is what I currently do as I&apos;m still on v1. An exception without a good HoneySQL data structure context might be tricky to figure out. What I mean is unless the <code>IN</code> clause has a helper fn, you can only throw in <code>format</code>, right?</z><z id="t1618258793" t="seancorfield Correct. But the error message could include the SQL fragment that would fail, e.g., col IN () so you would at least see the col (or expression)."><y>#</y><d>2021-04-12</d><h>20:19</h><w>seancorfield</w>Correct. But the error message could include the SQL fragment that would fail, e.g., <code>col IN ()</code> so you would at least see the <code>col</code> (or expression).</z><z id="t1618259111" t="sandqvist I compose HoneySQL queries quite a bit. What I&apos;m afraid of is an error like [:in :id nil] is not allowed when I&apos;ve composed three or four subqueries for tables that all have a surrogate primary key column called id . In that case, just looking at the database log is simpler."><y>#</y><d>2021-04-12</d><h>20:25</h><w>sandqvist</w>I compose HoneySQL queries quite a bit. What I&apos;m afraid of is an error like <code>[:in :id nil] is not allowed</code> when I&apos;ve composed three or four subqueries for tables that all have a surrogate primary key column called <code>id</code>. In that case, just looking at the database log is simpler.</z><z id="t1618259235" t="sandqvist But just a debugging option to ignore the check and let the DB complain would also be fine."><y>#</y><d>2021-04-12</d><h>20:27</h><w>sandqvist</w>But just a debugging option to ignore the check and let the DB complain would also be fine.</z><z id="t1618259298" t="seancorfield Or perhaps leave the default behavior “as-is” and add a :checking true opt-in feature that performs this check (and potential other checks in the future)?"><y>#</y><d>2021-04-12</d><h>20:28</h><w>seancorfield</w>Or perhaps leave the default behavior “as-is” and add a <code>:checking true</code> opt-in feature that performs this check (and potential other checks in the future)?</z><z id="t1618259675" t="sandqvist I would prefer that, with the possibility of later adding helper fns for IN and other clauses. The stacktrace from those would be very helpful. Of course, anyone can make those."><y>#</y><d>2021-04-12</d><h>20:34</h><w>sandqvist</w>I would prefer that, with the possibility of later adding helper fns for <code>IN</code> and other clauses. The stacktrace from those would be very helpful. Of course, anyone can make those.</z><z id="t1618306493" t="orestis Glad to see that honeysql v2 supports DDL statements."><y>#</y><d>2021-04-13</d><h>09:34</h><w>orestis</w>Glad to see that honeysql v2 supports DDL statements.</z><z id="t1618331179" t="seancorfield Thanks! [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] It supports a pretty wide range of things now. I started with what the honeysql-postgres library supported, then added a bunch of additional syntax I found in the PostgreSQL docs (and SQL Server and MySQL docs too) while trying to figure out the correct syntax for the nilenso stuff (instead of trying to read their implementation), then added quite a bit of stuff suggested by folks here, including (and especially) [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}]"><y>#</y><d>2021-04-13</d><h>16:26</h><w>seancorfield</w>Thanks! <a>@orestis</a> It supports a pretty wide range of things now. I started with what the honeysql-postgres library supported, then added a bunch of additional syntax I found in the PostgreSQL docs (and SQL Server and MySQL docs too) while trying to figure out the correct syntax for the nilenso stuff (instead of trying to read their implementation), then added quite a bit of stuff suggested by folks here, including (and especially) <a>@dharrigan</a></z><z id="t1618331232" t="dharrigan You&apos;re most welcome! And thank you for your library! I migrated another service to v2 beta1 today, and only had one gotcha"><y>#</y><d>2021-04-13</d><h>16:27</h><w>dharrigan</w>You&apos;re most welcome! And thank you for your library! I migrated another service to v2 beta1 today, and only had one gotcha</z><z id="t1618331243" t="dharrigan which thankfully a test caught, otherwise it would have had dire consequences"><y>#</y><d>2021-04-13</d><h>16:27</h><w>dharrigan</w>which thankfully a test caught, otherwise it would have had dire consequences</z><z id="t1618331284" t="dharrigan Perhaps it was a bug in v1 or something in v2, but it caused a AND condition to become an OR condition"><y>#</y><d>2021-04-13</d><h>16:28</h><w>dharrigan</w>Perhaps it was a bug in v1 or something in v2, but it caused a <code>AND</code> condition to become an <code>OR</code> condition</z><z id="t1618331288" t="dharrigan which would have blasted out my database."><y>#</y><d>2021-04-13</d><h>16:28</h><w>dharrigan</w>which would have blasted out my database.</z><z id="t1618331319" t="seancorfield Oh? Please open an issue on GH if you can."><y>#</y><d>2021-04-13</d><h>16:28</h><w>seancorfield</w>Oh? Please open an issue on GH if you can.</z><z id="t1618331333" t="dharrigan Would you like to know here first, perhaps it was just my mistake?"><y>#</y><d>2021-04-13</d><h>16:28</h><w>dharrigan</w>Would you like to know here first, perhaps it was just my mistake?</z><z id="t1618331338" t="dharrigan I can DM you it"><y>#</y><d>2021-04-13</d><h>16:28</h><w>dharrigan</w>I can DM you it</z><z id="t1618331340" t="dharrigan if you perfer 🙂"><y>#</y><d>2021-04-13</d><h>16:29</h><w>dharrigan</w>if you perfer <b>🙂</b></z><z id="t1618331458" t="seancorfield Whatever works for you…"><y>#</y><d>2021-04-13</d><h>16:30</h><w>seancorfield</w>Whatever works for you…</z><z id="t1618344285" t="seancorfield com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-beta2&quot;} — includes an important bug fix uncovered by [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] — thank you!"><y>#</y><d>2021-04-13</d><h>20:04</h><w>seancorfield</w><code>com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-beta2&quot;}</code> — includes an important bug fix uncovered by <a>@dharrigan</a> — thank you!</z><z id="t1618400324" t="yenda Is anyone using postgres enums with honeySQL? So far the only way I found to make it work was to use either [:inline &quot;enumValue&quot;] or (types/as-other &quot;enumValue&quot;) , in both cases the downside is that it involves modifying the query arguments, and keywords can&apos;t be used without an extra step to turn them into strings"><y>#</y><d>2021-04-14</d><h>11:38</h><w>yenda</w>Is anyone using postgres enums with honeySQL? So far the only way I found to make it work was to use either <code>[:inline &quot;enumValue&quot;]</code> or <code>(types/as-other &quot;enumValue&quot;)</code>, in both cases the downside is that it involves modifying the query arguments, and keywords can&apos;t be used without an extra step to turn them into strings</z><z id="t1618429424" t="dcj Could you write your own helper to handle the keyword conversion for you? e.g. (defn clj-pg-enum [kw] [:inline (name kw)]) "><y>#</y><d>2021-04-14</d><h>19:43</h><r>dcj</r>Could you write your own helper to handle the keyword conversion for you? e.g.
<pre>(defn clj-pg-enum
  [kw]
  [:inline (name kw)])</pre>
</z><z id="t1618476015" t="yenda yes that is what I have (defn enum [k] (types/as-other (name k))) I wouldn&apos;t recommend the inline solution it&apos;s not the same, with as-other it&apos;s a ? in your prepared statement, with inline it&apos;s part of it"><y>#</y><d>2021-04-15</d><h>08:40</h><r>yenda</r>yes that is what I have
<pre>(defn enum [k]
  (types/as-other (name k)))</pre>
I wouldn&apos;t recommend the inline solution it&apos;s not the same, with as-other it&apos;s a <code>?</code> in your prepared statement, with <code>inline</code> it&apos;s part of it</z><z id="t1618404976" t="orestis I&apos;ve added casts in the enum definition: DO $$ BEGIN CREATE TYPE idea_state AS ENUM (&apos;draft&apos;, &apos;publish&apos;); CREATE CAST (varchar AS idea_state) WITH INOUT AS ASSIGNMENT; EXCEPTION WHEN duplicate_object THEN null; END $$; "><y>#</y><d>2021-04-14</d><h>12:56</h><w>orestis</w>I&apos;ve added casts in the enum definition:
<pre>DO $$ BEGIN
  CREATE TYPE idea_state AS ENUM (&apos;draft&apos;, &apos;publish&apos;);
  CREATE CAST (varchar AS idea_state) WITH INOUT AS ASSIGNMENT;
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;</pre>
</z><z id="t1618405014" t="orestis But I was recently told that postgres enums are dangerous because you cannot add new values without dropping the enum, which is difficult to do when you already have data that point to the enum."><y>#</y><d>2021-04-14</d><h>12:56</h><w>orestis</w>But I was recently told that postgres enums are dangerous because you cannot add new values without dropping the enum, which is difficult to do when you already have data that point to the enum.</z><z id="t1618422516" t="yenda https://blog.yo1.dog/updating-enum-values-in-postgresql-the-safe-and-easy-way/ what you were told is not correct, adding is easy, updating is only since 9.6 and removing involves renaming / creating a new one / migrating"><y>#</y><d>2021-04-14</d><h>17:48</h><r>yenda</r><a href="https://blog.yo1.dog/updating-enum-values-in-postgresql-the-safe-and-easy-way/" target="_blank">https://blog.yo1.dog/updating-enum-values-in-postgresql-the-safe-and-easy-way/</a>
what you were told is not correct, adding is easy, updating is only since 9.6 and removing involves renaming / creating a new one / migrating</z><z id="t1619155016" t="seancorfield FYI, progress on v2: * 2.0.next in progress * Fix #323 by supporting more than one SQL entity in `:on-conflict`. * Fix #321 by adding `:checking` mode. Currently only detects potential problems with `IN` clauses. What will determine whether I go to Beta 3 or RC 1 is whether the maintainer of Gungnir gets back to me &quot;soon&quot; and what we decide to do about that potential integration."><y>#</y><d>2021-04-23</d><h>05:16</h><w>seancorfield</w>FYI, progress on v2:
<pre>* 2.0.next in progress
  * Fix #323 by supporting more than one SQL entity in `:on-conflict`.
  * Fix #321 by adding `:checking` mode. Currently only detects potential problems with `IN` clauses.</pre>
What will determine whether I go to Beta 3 or RC 1 is whether the maintainer of Gungnir gets back to me &quot;soon&quot; and what we decide to do about that potential integration.</z><z id="t1619155128" t="dharrigan :thumbsup:"><y>#</y><d>2021-04-23</d><h>05:18</h><w>dharrigan</w><b>:thumbsup:</b></z><z id="t1619479121" t="piyer Is there a way to install honeysql v2 beta from clojars to test?"><y>#</y><d>2021-04-26</d><h>23:18</h><w>piyer</w>Is there a way to install honeysql v2 beta from clojars to test?</z><z id="t1619479763" t="piyer nvm, found it."><y>#</y><d>2021-04-26</d><h>23:29</h><w>piyer</w>nvm, found it.</z><z id="t1619563838" t="az Hi all, is there a way convert raw sql to honeysql compliant data? I have a bunch of sql I would like to convert."><y>#</y><d>2021-04-27</d><h>22:50</h><w>az</w>Hi all, is there a way convert raw sql to honeysql compliant data? I have a bunch of sql I would like to convert.</z><z id="t1619566519" t="Noah Bogart Depending on how much effort you want to put in, you could convert the sql to AST nodes and then convert that to honeysql style nodes"><y>#</y><d>2021-04-27</d><h>23:35</h><w>Noah Bogart</w>Depending on how much effort you want to put in, you could convert the sql to AST nodes and then convert that to honeysql style nodes</z><z id="t1619566675" t="seancorfield The grammar for SQL is extremely complicated and is also different for each database so this is a very hard problem to solve."><y>#</y><d>2021-04-27</d><h>23:37</h><w>seancorfield</w>The grammar for SQL is extremely complicated and is also different for each database so this is a very hard problem to solve.</z><z id="t1619566726" t="seancorfield If you have “simple” SQL, you might be able to do at least some of it via regex-style parsing but it’s still going to be a lot of work [:attrs {:href &quot;/_/_/users/U0AJQJCQ1&quot;}]"><y>#</y><d>2021-04-27</d><h>23:38</h><w>seancorfield</w>If you have “simple” SQL, you might be able to do at least some of it via regex-style parsing but it’s still going to be a lot of work <a>@limix</a></z><z id="t1619566754" t="az Thank you, makes sense"><y>#</y><d>2021-04-27</d><h>23:39</h><w>az</w>Thank you, makes sense</z><z id="t1619566760" t="seancorfield (it’s been requested a couple of times against HoneySQL and I’ve rejected it each time as being effectively intractable)"><y>#</y><d>2021-04-27</d><h>23:39</h><w>seancorfield</w>(it’s been requested a couple of times against HoneySQL and I’ve rejected it each time as being effectively intractable)</z><z id="t1619573244" t="Noah Bogart Does honeysql have anything like a spec or BNF? "><y>#</y><d>2021-04-28</d><h>01:27</h><w>Noah Bogart</w>Does honeysql have anything like a spec or BNF? </z><z id="t1619574980" t="seancorfield [:attrs {:href &quot;/_/_/users/UEENNMX0T&quot;}] No. See https://github.com/seancorfield/honeysql/issues/146"><y>#</y><d>2021-04-28</d><h>01:56</h><w>seancorfield</w><a>@nbtheduke</a> No. See <a href="https://github.com/seancorfield/honeysql/issues/146" target="_blank">https://github.com/seancorfield/honeysql/issues/146</a></z><z id="t1619575046" t="seancorfield Or if you want the TL;DR jump straight to the end https://github.com/seancorfield/honeysql/issues/146#issuecomment-817217955"><y>#</y><d>2021-04-28</d><h>01:57</h><w>seancorfield</w>Or if you want the TL;DR jump straight to the end <a href="https://github.com/seancorfield/honeysql/issues/146#issuecomment-817217955" target="_blank">https://github.com/seancorfield/honeysql/issues/146#issuecomment-817217955</a></z><z id="t1619576910" t="Noah Bogart Thanks for that link! I’ll take a look"><y>#</y><d>2021-04-28</d><h>02:28</h><w>Noah Bogart</w>Thanks for that link! I’ll take a look</z><z id="t1619597317" t="tianshu Hi, does honeysql v2 has the support for array types?"><y>#</y><d>2021-04-28</d><h>08:08</h><w>tianshu</w>Hi, does honeysql v2 has the support for array types?</z><z id="t1619626255" t="seancorfield [:attrs {:href &quot;/_/_/users/U0NBGRGD6&quot;}] Do you mean for PostgreSQL? Read the PostgresSQL section of the Tips &amp;amp; Tricks page in the docs — it has example code and explains how to work with arrays."><y>#</y><d>2021-04-28</d><h>16:10</h><w>seancorfield</w><a>@doglooksgood</a> Do you mean for PostgreSQL? Read the PostgresSQL section of the Tips &amp;amp; Tricks page in the docs — it has example code and explains how to work with arrays.</z><z id="t1619660358" t="tianshu [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] thanks! I didn&apos;t notice there&apos;s a docs folder in project."><y>#</y><d>2021-04-29</d><h>01:39</h><w>tianshu</w><a>@seancorfield</a> thanks! I didn&apos;t notice there&apos;s a docs folder in project.</z><z id="t1619661755" t="seancorfield It’s a lot easier to read here: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-beta2/doc/readme"><y>#</y><d>2021-04-29</d><h>02:02</h><w>seancorfield</w>It’s a lot easier to read here: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-beta2/doc/readme" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-beta2/doc/readme</a></z><z id="t1619661787" t="seancorfield (which is linked from the README BTW)"><y>#</y><d>2021-04-29</d><h>02:03</h><w>seancorfield</w>(which is linked from the README BTW)</z><z id="t1619661863" t="seancorfield Oh, I just realized I thought you were asking about arrays at the JDBC level which is not those docs."><y>#</y><d>2021-04-29</d><h>02:04</h><w>seancorfield</w>Oh, I just realized I thought you were asking about arrays at the JDBC level which is not those docs.</z><z id="t1619661903" t="seancorfield This is probably what you want: https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.1.646/doc/getting-started/tips-tricks"><y>#</y><d>2021-04-29</d><h>02:05</h><w>seancorfield</w>This is probably what you want: <a href="https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.1.646/doc/getting-started/tips-tricks" target="_blank">https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.1.646/doc/getting-started/tips-tricks</a></z><z id="t1619661955" t="seancorfield HoneySQL doesn’t interact with JDBC at all, so “arrays” are irrelevant for HoneySQL. When you interact with the database, the handling of arrays will matter and that’s something you control via next.jdbc stuff."><y>#</y><d>2021-04-29</d><h>02:05</h><w>seancorfield</w>HoneySQL doesn’t interact with JDBC at all, so “arrays” are irrelevant for HoneySQL. When you interact with the database, the handling of arrays will matter and that’s something you control via <code>next.jdbc</code> stuff.</z><z id="t1619661979" t="seancorfield [:attrs {:href &quot;/_/_/users/U0NBGRGD6&quot;}] Perhaps you can elaborate on what you mean by “support for array types”?"><y>#</y><d>2021-04-29</d><h>02:06</h><w>seancorfield</w><a>@doglooksgood</a> Perhaps you can elaborate on what you mean by “support for array types”?</z><z id="t1619889432" t="snorremd Hi! I&apos;m struggling to combine the with and insert-into functions to build a query. Any help is appreciated. EDIT: Found the answer using the pure clojure map specification: {:with [[:workday {:insert-into :workdays :values [{:work-date (t/today) :work-interval (t/new-duration 7 :hours) :account-id #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;}] :on-conflict [:work-date :account-id] :do-update-set [:work-interval] :returning [:id]}]] :insert-into [[:work-intervals [:workday-id :interval-start]] {:select [:workday.id (t/now)] :from :workday}]} Where I want to end up: WITH workday_insert AS (INSERT INTO workdays (work_date, work_interval, account_id) VALUES (?, ?, ?) ON CONFLICT (work_date, account_id) DO UPDATE SET work_interval = EXCLUDED.work_interval RETURNING id) INSERT INTO work_intervals (workday_id, interval_start) INSERT INTO work_intervals (workday_id, interval_start) SELECT id, ? FROM workday_insert What I have so far: (-&gt; (hsqlh/with [:workday-insert (-&gt; (hsqlh/insert-into :workdays) (hsqlh/values [{:work-date (t/today) :work-interval (t/new-duration 7 :hours) :account-id #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;}]) (hsqlh/on-conflict :work-date :account-id) (hsqlh/do-update-set :work-interval) (hsqlh/returning :id))]) (hsqlh/insert-into :work-intervals [:workday-id :interval-start] (-&gt; (hsqlh/select :id (t/now)) (hsqlh/from :workday-insert)))) Producing: [&quot;WITH workday_insert AS (INSERT INTO workdays (work_date, work_interval, account_id) VALUES (?, ?, ?) ON CONFLICT (work_date, account_id) DO UPDATE SET work_interval = EXCLUDED.work_interval RETURNING id) INSERT INTO work_intervals (workday_id, interval_start)&quot; #time/date &quot;2021-05-01&quot; #time/duration &quot;PT7H&quot; #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;] It seems the select and from portion of the insert-into is simply dropped from the query. Not sure why. When running the insert-into function on its own and formatting I get: INSERT INTO work_intervals (workday_id, interval_start) SELECT id, ? FROM workday_insert For reference I&apos;m using the latest code of the v2-branch. com.github.seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;20cba15da22946d60f53dd6913caba990f7cddb7&quot;"><y>#</y><d>2021-05-01</d><h>17:17</h><w>snorremd</w>Hi! I&apos;m struggling to combine the <code>with</code> and <code>insert-into</code>  functions to build a query. Any help is appreciated.

EDIT: Found the answer using the pure clojure map specification:

<pre>{:with [[:workday {:insert-into :workdays
                   :values [{:work-date (t/today)
                             :work-interval (t/new-duration 7 :hours)
                             :account-id #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;}]
                   :on-conflict [:work-date :account-id]
                   :do-update-set [:work-interval]
                   :returning [:id]}]]
 :insert-into [[:work-intervals [:workday-id :interval-start]]
               {:select [:workday.id (t/now)]
                :from :workday}]}</pre>

Where I want to end up:

<pre>WITH workday_insert AS (INSERT INTO workdays (work_date, work_interval, account_id) VALUES (?, ?, ?) ON CONFLICT (work_date, account_id) DO UPDATE SET work_interval = EXCLUDED.work_interval RETURNING id)
INSERT INTO work_intervals (workday_id, interval_start) INSERT INTO work_intervals (workday_id, interval_start) SELECT id, ? FROM workday_insert</pre>
What I have so far:
<pre>(-&gt; (hsqlh/with [:workday-insert (-&gt; (hsqlh/insert-into :workdays)
                                     (hsqlh/values [{:work-date (t/today)
                                                     :work-interval (t/new-duration 7 :hours)
                                                     :account-id #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;}])
                                     (hsqlh/on-conflict :work-date :account-id)
                                     (hsqlh/do-update-set :work-interval)
                                     (hsqlh/returning :id))])
    (hsqlh/insert-into :work-intervals
                       [:workday-id :interval-start]
                       (-&gt; (hsqlh/select :id (t/now))
                           (hsqlh/from :workday-insert))))</pre>
Producing:

<pre>[&quot;WITH workday_insert AS (INSERT INTO workdays (work_date, work_interval, account_id) VALUES (?, ?, ?) ON CONFLICT (work_date, account_id) DO UPDATE SET work_interval = EXCLUDED.work_interval RETURNING id) INSERT INTO work_intervals (workday_id, interval_start)&quot;
 #time/date &quot;2021-05-01&quot;
 #time/duration &quot;PT7H&quot;
 #uuid &quot;5d90856c-5a48-46ae-8f6e-a06295ea0dfb&quot;]</pre>
It seems the select and from portion of the insert-into is simply dropped from the query. Not sure why. When running the insert-into function on its own and formatting I get:

<pre>INSERT INTO work_intervals (workday_id, interval_start) SELECT id, ? FROM workday_insert</pre>
For reference I&apos;m using the latest code of the v2-branch.

<pre>com.github.seancorfield/honeysql {:git/url &quot;&quot;
                                  :sha &quot;20cba15da22946d60f53dd6913caba990f7cddb7&quot;</pre></z><z id="t1619893614" t="seancorfield [:attrs {:href &quot;/_/_/users/U3T0CQGQH&quot;}] Can you open an issue on GitHub and I&apos;ll take a look at this next week when I&apos;m back at work?"><y>#</y><d>2021-05-01</d><h>18:26</h><w>seancorfield</w><a>@snorremd</a> Can you open an issue on GitHub and I&apos;ll take a look at this next week when I&apos;m back at work?</z><z id="t1619893679" t="seancorfield In the meantime, have a look in the v2 tests for insert-into / :insert-into -- pretty sure there&apos;s an INSERT INTO .. SELECT .. example there somewhere."><y>#</y><d>2021-05-01</d><h>18:27</h><w>seancorfield</w>In the meantime, have a look in the v2 tests for <code>insert-into</code> / <code>:insert-into</code> -- pretty sure there&apos;s an <code>INSERT INTO .. SELECT ..</code> example there somewhere.</z><z id="t1619894444" t="snorremd I&apos;ll try to make a smallest possible reproduction of the working and non-working code in a repo and file an issue as soon as possible. This should make it easier for you to verify/test the issue. The INSERT INTO .. SELECT .. standalone case works well both with utility functions and the clojure map syntax, so there might be something with the utility functions and combining the insert-into and with statements. Many thanks for the quick reply. 👍"><y>#</y><d>2021-05-01</d><h>18:40</h><w>snorremd</w>I&apos;ll try to make a smallest possible reproduction of the working and non-working code in a repo and file an issue as soon as possible. This should make it easier for you to verify/test the issue.
The <code>INSERT INTO .. SELECT ..</code> standalone case works well both with utility functions and the clojure map syntax, so there might be something with the utility functions and combining the insert-into and with statements.
Many thanks for the quick reply. <b>👍</b></z><z id="t1619897322" t="seancorfield [:attrs {:href &quot;/_/_/users/U3T0CQGQH&quot;}] It&apos;s a bug in the insert-into helper."><y>#</y><d>2021-05-01</d><h>19:28</h><w>seancorfield</w><a>@snorremd</a> It&apos;s a bug in the <code>insert-into</code> helper.</z><z id="t1619897412" t="seancorfield It doesn&apos;t expect to have a statement to already merge into."><y>#</y><d>2021-05-01</d><h>19:30</h><w>seancorfield</w>It doesn&apos;t expect to have a statement to already merge into.</z><z id="t1619898556" t="seancorfield https://github.com/seancorfield/honeysql/issues/324"><y>#</y><d>2021-05-01</d><h>19:49</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/324" target="_blank">https://github.com/seancorfield/honeysql/issues/324</a></z><z id="t1619899035" t="snorremd Ah, I see. Thanks for looking into that."><y>#</y><d>2021-05-01</d><h>19:57</h><w>snorremd</w>Ah, I see. Thanks for looking into that.</z><z id="t1619899035" t="seancorfield [:attrs {:href &quot;/_/_/users/U3T0CQGQH&quot;}] The fix is on the v2 branch if you want to test it?"><y>#</y><d>2021-05-01</d><h>19:57</h><w>seancorfield</w><a>@snorremd</a> The fix is on the v2 branch if you want to test it?</z><z id="t1619899048" t="snorremd Yeah, definitely."><y>#</y><d>2021-05-01</d><h>19:57</h><w>snorremd</w>Yeah, definitely.</z><z id="t1619899078" t="seancorfield New sha 46b3c1773b57ad17efda63f5ceee4f24c221ad0a"><y>#</y><d>2021-05-01</d><h>19:57</h><w>seancorfield</w>New sha 46b3c1773b57ad17efda63f5ceee4f24c221ad0a</z><z id="t1619899198" t="snorremd I can verify that it now works as expected."><y>#</y><d>2021-05-01</d><h>19:59</h><w>snorremd</w>I can verify that it now works as expected.</z><z id="t1619899221" t="seancorfield Thanks for finding that bug! This is why we have Beta releases 🙂"><y>#</y><d>2021-05-01</d><h>20:00</h><w>seancorfield</w>Thanks for finding that bug! This is why we have Beta releases <b>🙂</b></z><z id="t1619899311" t="snorremd Yeah, no problem! In the future, would you prefer if I just open issues for problems like these? I was not 100% sure if it was a bug in honeysql or some problem with my code, so I used the slack channel."><y>#</y><d>2021-05-01</d><h>20:01</h><w>snorremd</w>Yeah, no problem! In the future, would you prefer if I just open issues for problems like these? I was not 100% sure if it was a bug in honeysql or some problem with my code, so I used the slack channel.</z><z id="t1619899397" t="seancorfield Posting the example here is good. Others may see it and have input, in case there are workarounds or it isn&apos;t a bug."><y>#</y><d>2021-05-01</d><h>20:03</h><w>seancorfield</w>Posting the example here is good. Others may see it and have input, in case there are workarounds or it isn&apos;t a bug.</z><z id="t1619899495" t="seancorfield And my exposure to more &quot;exotic&quot; SQL is somewhat limited so I&apos;m not always sure whether a given syntax is legal, especially for PostgreSQL 🙂"><y>#</y><d>2021-05-01</d><h>20:04</h><w>seancorfield</w>And my exposure to more &quot;exotic&quot; SQL is somewhat limited so I&apos;m not always sure whether a given syntax is legal, especially for PostgreSQL <b>🙂</b></z><z id="t1620104303" t="Akiz Hi! I am using honeysql together with Babashka and I would like to produce a raw sql queries compatible with psql. Is this possible right now?"><y>#</y><d>2021-05-04</d><h>04:58</h><w>Akiz</w>Hi! I am using honeysql together with Babashka and I would like to produce a raw sql queries compatible with psql. Is this possible right now?</z><z id="t1620105826" t="seancorfield If you&apos;re using V2, there is an inline option that tries to put the values inline in the string instead of using ? And putting the parameters in a vector"><y>#</y><d>2021-05-04</d><h>05:23</h><w>seancorfield</w>If you&apos;re using V2, there is an inline option that tries to put the values inline in the string instead of using ? And putting the parameters in a vector</z><z id="t1620119450" t="Akiz Thank you, this is exactly what I needed."><y>#</y><d>2021-05-04</d><h>09:10</h><r>Akiz</r>Thank you, this is exactly what I needed.</z><z id="t1620119648" t="Akiz Hi, version 1 has build fn, i use it for removing keys with missing values to build a valid sql map. Is there something simiĺlar in v2? "><y>#</y><d>2021-05-04</d><h>09:14</h><w>Akiz</w>Hi, version 1 has build fn, i use it for removing keys with missing values to build a valid sql map. Is there something simiĺlar in v2? 
</z><z id="t1620144602" t="seancorfield [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] No, V2 does not have that function. Can you explain what you mean by “removing keys with missing values”?"><y>#</y><d>2021-05-04</d><h>16:10</h><w>seancorfield</w><a>@zikajk</a> No, V2 does not have that function. Can you explain what you mean by “removing keys with missing values”?</z><z id="t1620145215" t="Akiz [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] In HoneySQL v1 I had got a function like this: (defn build-select [table-name where limit] (hsql/format (hsql/build :select :* :from table-name :where where :limit limit))) All this was valid thanks to the build fn: (build-select :public.table) (build-select :public.table [:= :table.field &quot;string&quot;]) (build-select :public.table [:= :table.field &quot;string&quot;] 10) Now I changed the logic in HoneySQL v2 to this - so I can supply map with/out :where or :limit as before. (defn build-select [table-opts] (hsql/format (merge {:select [:*] :from [(:table-name table-opts)]} (select-keys table-opts [:where :limit])))) The input got a little different of course: (build-select {:table-name :public.table}) (I am building custom sql queries from EDN files. I used to read list of [table-name where limit] now it is (:table-name string :where vector :limit int}"><y>#</y><d>2021-05-04</d><h>16:20</h><r>Akiz</r><a>@U04V70XH6</a>
In HoneySQL v1 I had got a function like this:
<code>(defn build-select [table-name where limit]</code>
  <code>(hsql/format</code> 
    <code>(hsql/build :select :*</code>
                <code>:from table-name</code>
                <code>:where where</code>
                <code>:limit limit)))</code>

All this was valid thanks to the build fn:
<code>(build-select :public.table)</code>
<code>(build-select :public.table [:= :table.field &quot;string&quot;])</code>
<code>(build-select :public.table [:= :table.field &quot;string&quot;] 10)</code>

Now I changed the logic in HoneySQL v2 to this - so I can supply map with/out :where or :limit as before.
<code>(defn build-select [table-opts]</code>
  <code>(hsql/format (merge {:select [:*] :from [(:table-name table-opts)]}</code>
                      <code>(select-keys table-opts [:where :limit]))))</code>

The input got a little different of course:
<code>(build-select {:table-name :public.table})</code>

(I am building custom sql queries from EDN files. I used to read list of [table-name where limit] now it is (:table-name string :where vector :limit int}</z><z id="t1620145424" t="seancorfield Well, it’s “just data” so you can use cond-&gt; and assoc to conditionally add things, or use the helper functions to make sure you get the right structure."><y>#</y><d>2021-05-04</d><h>16:23</h><r>seancorfield</r>Well, it’s “just data” so you can use <code>cond-&gt;</code> and <code>assoc</code> to conditionally add things, or use the helper functions to make sure you get the right structure.</z><z id="t1620193536" t="seancorfield [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] BTW, if you’re reading a vector of [table-name where limit] you can always turn that into a map programmatically with (zipmap [table-name where limit] [:table-name :where :limit]) or your build-select could take [[table-name where limit]] as before and do (hsql/format (cond-&gt; {:select [:*] :from [table-name]} where (assoc :where where) limit (assoc :limit limit)))"><y>#</y><d>2021-05-05</d><h>05:45</h><r>seancorfield</r><a>@zikajk</a> BTW, if you’re reading a vector of <code>[table-name where limit]</code> you can always turn that into a map programmatically with <code>(zipmap [table-name where limit] [:table-name :where :limit])</code> or your <code>build-select</code> could take <code>[[table-name where limit]]</code> as before and do <code>(hsql/format (cond-&gt; {:select [:*] :from [table-name]} where (assoc :where where) limit (assoc :limit limit)))</code></z><z id="t1620193550" t="seancorfield (in case you wanted to preserve the calling format)"><y>#</y><d>2021-05-05</d><h>05:45</h><r>seancorfield</r>(in case you wanted to preserve the calling format)</z><z id="t1620195476" t="Akiz [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Thank you. I already changed my code to use maps, no problem here. It is just that build fn is one of the first thing mentioned in HoneySQL v1 tutorial so I have been looking for it (as I migrated to version2 because of {:inline true} which is a great option btw.)"><y>#</y><d>2021-05-05</d><h>06:17</h><r>Akiz</r><a>@U04V70XH6</a> Thank you. I already changed my code to use maps, no problem here. It is just that build fn is one of the first thing mentioned in HoneySQL v1 tutorial so I have been looking for it (as I migrated to version2 because of {:inline true} which is a great option btw.)</z><z id="t1620668768" t="thumbnail I&apos;m new to honey and so far loving it!. V2 has been really solid! I&apos;m composing a sub query and noticed the params are not filled in correctly :thinking_face: . (sql/format {:left-join [[{:select [:c] :from :a :where [:= :id 123]}] :x] :where [:= :a/id 123]}) =&gt; [&quot;LEFT JOIN (SELECT c FROM a WHERE id = ?) ON x WHERE a.id = ?&quot; 123] I can work around it by using :where [:= :id [:inline 123]] but it I might be doing something wrong"><y>#</y><d>2021-05-10</d><h>17:46</h><w>thumbnail</w>I&apos;m new to honey and so far loving it!. V2 has been really solid!

I&apos;m composing a sub query and noticed the params are not filled in correctly <b>:thinking_face:</b> .

<pre>(sql/format
  {:left-join [[{:select [:c]
                 :from   :a
                 :where  [:= :id 123]}]
               :x]
   :where     [:= :a/id 123]})
=&gt; [&quot;LEFT JOIN (SELECT c FROM a WHERE id = ?) ON x WHERE a.id = ?&quot; 123]</pre>
I can work around it by using <code>:where [:= :id [:inline 123]]</code> but it I might be doing something wrong</z><z id="t1620671607" t="seancorfield [:attrs {:href &quot;/_/_/users/UHJH8MG6S&quot;}] Hmm, that may be a form of JOIN that just isn’t supported yet."><y>#</y><d>2021-05-10</d><h>18:33</h><w>seancorfield</w><a>@jeroen.dejong</a> Hmm, that may be a form of JOIN that just isn’t supported yet.</z><z id="t1620671614" t="seancorfield What DB are you using?"><y>#</y><d>2021-05-10</d><h>18:33</h><w>seancorfield</w>What DB are you using?</z><z id="t1620671674" t="thumbnail postgres"><y>#</y><d>2021-05-10</d><h>18:34</h><r>thumbnail</r>postgres</z><z id="t1620671787" t="seancorfield Of course 🙂 OK, I’ll open an issue to review it and see if I can find PG’s docs about that syntax — I know your posted example is simplified but it doesn’t make sense to me as written, so I’ll need to see what the full syntax can be from the docs…"><y>#</y><d>2021-05-10</d><h>18:36</h><r>seancorfield</r>Of course <b>🙂</b> OK, I’ll open an issue to review it and see if I can find PG’s docs about that syntax — I know your posted example is simplified but it doesn’t make sense to me as written, so I’ll need to see what the full syntax can be from the docs…</z><z id="t1620672028" t="seancorfield https://github.com/seancorfield/honeysql/issues/326"><y>#</y><d>2021-05-10</d><h>18:40</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/326" target="_blank">https://github.com/seancorfield/honeysql/issues/326</a></z><z id="t1620672055" t="thumbnail haha sure thing. I converted this from a snippet I found in another projects codebase 😅 ; so the exact wizardry is lost on me too to be honest. Thanks !"><y>#</y><d>2021-05-10</d><h>18:40</h><r>thumbnail</r>haha sure thing. I converted this from a snippet I found in another projects codebase <b>😅</b>; so the exact wizardry is lost on me too to be honest. Thanks !</z><z id="t1620673024" t="seancorfield I can see where the parameter(s) are getting dropped. There’s an assumption in the formatter for JOIN that parameters will only “appear” for a JOIN .. USING .. statement, not a JOIN .. ON .. statement. That’s an easy bug to fix… OK, v2 has an update that “fixes” your example case, if you want to test via :git/url ?"><y>#</y><d>2021-05-10</d><h>18:57</h><r>seancorfield</r>I can see where the parameter(s) are getting dropped. There’s an assumption in the formatter for JOIN that parameters will only “appear” for a JOIN .. USING .. statement, not a JOIN .. ON .. statement. That’s an easy bug to fix… OK, <code>v2</code> has an update that “fixes” your example case, if you want to test via <code>:git/url</code>?</z><z id="t1620673080" t="seancorfield I’m going to leave that open until I have tests in place and a better understanding of the implication of making that change…"><y>#</y><d>2021-05-10</d><h>18:58</h><r>seancorfield</r>I’m going to leave that open until I have tests in place and a better understanding of the implication of making that change…</z><z id="t1620673290" t="thumbnail That&apos;s epic! I&apos;ll try it out soon and let you know"><y>#</y><d>2021-05-10</d><h>19:01</h><r>thumbnail</r>That&apos;s epic! I&apos;ll try it out soon and let you know</z><z id="t1620716133" t="thumbnail Just tried out 2.0.0-rc2; and it indeed fixes my issue. Epic 🙂 Thanks again"><y>#</y><d>2021-05-11</d><h>06:55</h><r>thumbnail</r>Just tried out 2.0.0-rc2; and it indeed fixes my issue. Epic <b>🙂</b> Thanks again</z><z id="t1620672941" t="Noah Bogart full syntax for postgres select is here: https://www.postgresql.org/docs/current/sql-select.html"><y>#</y><d>2021-05-10</d><h>18:55</h><w>Noah Bogart</w>full syntax for postgres select is here: <a href="https://www.postgresql.org/docs/current/sql-select.html" target="_blank">https://www.postgresql.org/docs/current/sql-select.html</a></z><z id="t1620672975" t="Noah Bogart from clause, select: &gt; A sub-SELECT can appear in the FROM clause. This acts as though its output were created as a temporary table for the duration of this single SELECT command. Note that the sub-SELECT must be surrounded by parentheses, and an alias must be provided for it."><y>#</y><d>2021-05-10</d><h>18:56</h><w>Noah Bogart</w>from clause, select:
&gt; A sub-SELECT can appear in the FROM clause. This acts as though its output were created as a temporary table for the duration of this single SELECT command. Note that the sub-SELECT must be surrounded by parentheses, and an alias must be provided for it.</z><z id="t1620673029" t="Noah Bogart from clause, join type: &gt; A JOIN clause combines two FROM items, which for convenience we will refer to as “tables”, though in reality they can be any type of FROM item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, JOINs nest left-to-right. In any case JOIN binds more tightly than the commas separating FROM-list items."><y>#</y><d>2021-05-10</d><h>18:57</h><w>Noah Bogart</w>from clause, join type:
&gt; A JOIN clause combines two FROM items, which for convenience we will refer to as “tables”, though in reality they can be any type of FROM item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, JOINs nest left-to-right. In any case JOIN binds more tightly than the commas separating FROM-list items.</z><z id="t1620673155" t="Noah Bogart the requirement to alias the sub-select might be something worth noting, [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] , from the current output it looks like that&apos;s not being generated"><y>#</y><d>2021-05-10</d><h>18:59</h><w>Noah Bogart</w>the requirement to alias the sub-select might be something worth noting, <a>@seancorfield</a>, from the current output it looks like that&apos;s not being generated</z><z id="t1620673227" t="seancorfield The code snippet above does not have the alias in the correct place."><y>#</y><d>2021-05-10</d><h>19:00</h><w>seancorfield</w>The code snippet above does not have the alias in the correct place.</z><z id="t1620673255" t="Noah Bogart cool"><y>#</y><d>2021-05-10</d><h>19:00</h><w>Noah Bogart</w>cool</z><z id="t1620673303" t="seancorfield But that highlights a second bug in the join formatting, which is that ON is optional, which the current formatter does not support 😐"><y>#</y><d>2021-05-10</d><h>19:01</h><w>seancorfield</w>But that highlights a second bug in the join formatting, which is that ON is optional, which the current formatter does not support <b>😐</b></z><z id="t1620673415" t="Noah Bogart oops, but also glad i could help"><y>#</y><d>2021-05-10</d><h>19:03</h><w>Noah Bogart</w>oops, but also glad i could help</z><z id="t1620673538" t="seancorfield OK, fix for that pushed to v2 as well. Now: user=&gt; (sql/format #_=&gt; {:left-join [[{:select [:c] #_=&gt; :from :a #_=&gt; :where [:= :id 123]} #_=&gt; :x]] #_=&gt; :where [:= :a/id 124]}) [&quot;LEFT JOIN (SELECT c FROM a WHERE id = ?) AS x WHERE a.id = ?&quot; 123 124]"><y>#</y><d>2021-05-10</d><h>19:05</h><w>seancorfield</w>OK, fix for that pushed to v2 as well. Now:
<pre>user=&gt; (sql/format
  #_=&gt;   {:left-join [[{:select [:c]
  #_=&gt;                  :from   :a
  #_=&gt;                  :where  [:= :id 123]}
  #_=&gt;                :x]]
  #_=&gt;    :where     [:= :a/id 124]})
[&quot;LEFT JOIN (SELECT c FROM a WHERE id = ?) AS x WHERE a.id = ?&quot; 123 124]</pre></z><z id="t1620673553" t="seancorfield Note the nesting on the alias [:attrs {:href &quot;/_/_/users/UHJH8MG6S&quot;}]"><y>#</y><d>2021-05-10</d><h>19:05</h><w>seancorfield</w>Note the nesting on the alias <a>@jeroen.dejong</a></z><z id="t1620673574" t="seancorfield (that bug was due to using partition instead of partition-by )"><y>#</y><d>2021-05-10</d><h>19:06</h><w>seancorfield</w>(that bug was due to using <code>partition</code> instead of <code>partition-by</code>)</z><z id="t1620673765" t="thumbnail Awesome! Big thanks for quick response 🙂"><y>#</y><d>2021-05-10</d><h>19:09</h><w>thumbnail</w>Awesome! Big thanks for quick response <b>🙂</b></z><z id="t1620676175" t="seancorfield Thanks for finding bugs! 🙂"><y>#</y><d>2021-05-10</d><h>19:49</h><w>seancorfield</w>Thanks for finding bugs! <b>🙂</b></z><z id="t1620712591" t="seancorfield com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-rc2&quot;} — https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc2 — bug fixes for JOIN, % function syntax (thanks to [:attrs {:href &quot;/_/_/users/U45DURWEN&quot;}] ), more control over quoted entity rendering."><y>#</y><d>2021-05-11</d><h>05:56</h><w>seancorfield</w><code>com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-rc2&quot;}</code> — <a href="https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc2" target="_blank">https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc2</a> — bug fixes for JOIN, <code>%</code> function syntax (thanks to <a>@zugnush</a>), more control over quoted entity rendering.</z><z id="t1620716613" t="thumbnail Another question, I noticed :%coalesce.a/id.b/id.c/id will format correctly in 2.0.0-rc2; But because it&apos;s not a valid keyword, Cursive prevents me from sending the form to the repl. Is there an alternative without resorting to :raw :thinking_face: ?"><y>#</y><d>2021-05-11</d><h>07:03</h><w>thumbnail</w>Another question, I noticed <code>:%coalesce.a/id.b/id.c/id</code> will format correctly in 2.0.0-rc2; But because it&apos;s not a valid keyword, Cursive prevents me from sending the form to the repl.

Is there an alternative without resorting to <code>:raw</code> <b>:thinking_face:</b>?</z><z id="t1620750268" t="seancorfield You can either a) (keyword &quot;%coalesce.a/id.b/id.c/id&quot;) or b) &apos;%coalesce.a/id.b/id.c/id -- since symbols work as well as keywords (but the latter may be illegal for Cursive too?)."><y>#</y><d>2021-05-11</d><h>16:24</h><w>seancorfield</w>You can either a) <code>(keyword &quot;%coalesce.a/id.b/id.c/id&quot;)</code> or b) <code>&apos;%coalesce.a/id.b/id.c/id</code> -- since symbols work as well as keywords (but the latter may be illegal for Cursive too?).</z><z id="t1620751939" t="thumbnail That works, Thanks. Cursive indeed triggers the same &quot;syntax error&quot; on the symbol."><y>#</y><d>2021-05-11</d><h>16:52</h><r>thumbnail</r>That works, Thanks. Cursive indeed triggers the same &quot;syntax error&quot; on the symbol.</z><z id="t1620751626" t="seancorfield FWIW, that keyword is just plain old illegal in ClojureScript, so even in the test suite I have to construct it programmatically by calling keyword ."><y>#</y><d>2021-05-11</d><h>16:47</h><w>seancorfield</w>FWIW, that keyword is just plain old illegal in ClojureScript, so even in the test suite I have to construct it programmatically by calling <code>keyword</code>.</z><z id="t1620811154" t="snorremd Hello. What&apos;s the story around using your own Records/types with honeysql V2 . In version 1 there seems to be a honeysql.format/ToSQL protocol to tell honeysql how to deal with Record parameters. In v2 this seems to be gone? When I pass in a record type as a parameter to honeysql v2&apos;s format function it incorrectly parses the record fields as sql clauses: :message &quot;Unknown SQL clauses: :beginning, :end&quot; Any thoughts on how to solve this in v2 is much appreciated. The use case would be to pass the record as a parameter value that can then be handled by next.jdbc&apos;s settable parameter protocol which would dispatch on the Record type. Edit: Since breaking changes can be introduced with V2, perhaps this would be a good time to just not treat Records as SQL clauses maps? Edit 2: The expression in question where interval in the select statement is the record in question. {:with [[:workday (workday-upsert m)]] :insert-into [[:work-intervals [:workday-id :interval]] {:select [:workday.id interval] :from :workday}] :returning :*}"><y>#</y><d>2021-05-12</d><h>09:19</h><w>snorremd</w>Hello. What&apos;s the story around using your own Records/types with honeysql V2 . In version 1 there seems to be a <code>honeysql.format/ToSQL</code> protocol to tell honeysql how to deal with Record parameters. In v2 this seems to be gone?

When I pass in a record type as a parameter to honeysql v2&apos;s format function it incorrectly parses the record fields as sql clauses:

<pre>:message &quot;Unknown SQL clauses: :beginning, :end&quot;</pre>
Any thoughts on how to solve this in v2 is much appreciated. The use case would be to pass the record as a parameter value that can then be handled by next.jdbc&apos;s settable parameter protocol which would dispatch on the Record type.

Edit: Since breaking changes can be introduced with V2, perhaps this would be a good time to just not treat Records as SQL clauses maps?

Edit 2: The expression in question where <code>interval</code> in the select statement is the record in question.

<pre>{:with [[:workday (workday-upsert m)]]
 :insert-into [[:work-intervals [:workday-id :interval]]
               {:select [:workday.id interval]
                :from :workday}]
 :returning :*}</pre></z><z id="t1620828008" t="snorremd So I think the problem is related to how the format-selectable-dsl function checks if something is a map, which records are. https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L257 It seems the code should check that something is both a map and not a record, but I&apos;m not sure if this is then something that would have to be done a lot of places. Edit: I&apos;ve not had the chance to test this in practice, but could test this after work today if you&apos;d be interested in a pull-request for this."><y>#</y><d>2021-05-12</d><h>14:00</h><w>snorremd</w>So I think the problem is related to how the <code>format-selectable-dsl</code> function checks if something is a map, which records are.
<a href="https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L257" target="_blank">https://github.com/seancorfield/honeysql/blob/v2/src/honey/sql.cljc#L257</a>
It seems the code should check that something is both a map and not a record, but I&apos;m not sure if this is then something that would have to be done a lot of places.

Edit: I&apos;ve not had the chance to test this in practice, but could test this after work today if you&apos;d be interested in a pull-request for this.</z><z id="t1620836230" t="seancorfield [:attrs {:href &quot;/_/_/users/U3T0CQGQH&quot;}] I think you can wrap such things with [:lift ..]"><y>#</y><d>2021-05-12</d><h>16:17</h><w>seancorfield</w><a>@snorremd</a> I think you can wrap such things with <code>[:lift ..]</code></z><z id="t1620836290" t="seancorfield That’s the “escape” mechanism for passing sequential and map-like types through as parameter values, if I’m understanding what you’re trying to do…"><y>#</y><d>2021-05-12</d><h>16:18</h><w>seancorfield</w>That’s the “escape” mechanism for passing sequential and map-like types through as parameter values, if I’m understanding what you’re trying to do…</z><z id="t1620837968" t="snorremd So something like this? (-&gt; {:insert-into [[:foo [:interval]] {:select [[:lift (-&gt;Interval nil nil)]] :from :test}]} hsql/format) Produced an error: ; Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:891). ; Unknown SQL clauses: :beginning, :end"><y>#</y><d>2021-05-12</d><h>16:46</h><r>snorremd</r>So something like this?
<pre>(-&gt; {:insert-into [[:foo [:interval]]
                   {:select [[:lift (-&gt;Interval nil nil)]]
                    :from :test}]}
    hsql/format)</pre>
Produced an error:
<pre>; Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:891).
; Unknown SQL clauses: :beginning, :end</pre></z><z id="t1620838647" t="seancorfield :select expects a sequence of expressions, but those can be aliased, so a function call without an alias still needs to be written as if it did have one — the docs have examples and talk about this."><y>#</y><d>2021-05-12</d><h>16:57</h><r>seancorfield</r><code>:select</code> expects a sequence of expressions, but those can be aliased, so a function call without an alias still needs to be written as if it did have one — the docs have examples and talk about this.</z><z id="t1620838666" t="seancorfield {:select [[[:lift (-&gt;Interval nil nil)]]] .. should do it."><y>#</y><d>2021-05-12</d><h>16:57</h><r>seancorfield</r><code>{:select [[[:lift (-&gt;Interval nil nil)]]] ..</code> should do it.</z><z id="t1620838693" t="snorremd Ah, thanks. That worked. 🙂"><y>#</y><d>2021-05-12</d><h>16:58</h><r>snorremd</r>Ah, thanks. That worked. <b>🙂</b></z><z id="t1620838738" t="seancorfield :select [:a [:b :c] [[:fun 42] :d]] =&gt; SELECT a, b AS c, FUN(42) AS d"><y>#</y><d>2021-05-12</d><h>16:58</h><r>seancorfield</r><code>:select [:a [:b :c] [[:fun 42] :d]]</code> =&gt; <code>SELECT a, b AS c, FUN(42) AS d</code></z><z id="t1620837167" t="Michaël Salihi Hi everybody! I begin to playing with honeysql and I wonder how I can do SELECT (first_name, last_name) as name"><y>#</y><d>2021-05-12</d><h>16:32</h><w>Michaël Salihi</w>Hi everybody!
I begin to playing with honeysql and I wonder how I can do <code>SELECT (first_name, last_name) as name</code></z><z id="t1620837271" t="seancorfield user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]}) [&quot;SELECT (first_name, last_name) AS name&quot;]"><y>#</y><d>2021-05-12</d><h>16:34</h><w>seancorfield</w><pre>user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]})
[&quot;SELECT (first_name, last_name) AS name&quot;]</pre></z><z id="t1620838973" t="Michaël Salihi I tried and it gives me this error: Assert failed: Alias should have two parts[:composite :first_name :last_name] (= 2 (count x))"><y>#</y><d>2021-05-12</d><h>17:02</h><r>Michaël Salihi</r>I tried and it gives me this error:
<pre>Assert failed: Alias should have two parts[:composite :first_name :last_name]
(= 2 (count x))</pre></z><z id="t1620839379" t="Michaël Salihi It works with the helpers function call: (h/format {:select [[(composite :first_name :last_name) :name]]})"><y>#</y><d>2021-05-12</d><h>17:09</h><r>Michaël Salihi</r>It works with the helpers function call:
<pre>(h/format {:select [[(composite :first_name :last_name) :name]]})</pre></z><z id="t1620839401" t="Michaël Salihi I prefer the first syntax. Any idea?"><y>#</y><d>2021-05-12</d><h>17:10</h><r>Michaël Salihi</r>I prefer the first syntax. Any idea?</z><z id="t1620842033" t="seancorfield You have missed a level of nesting. Funnily enough I was just explaining this to someone else…"><y>#</y><d>2021-05-12</d><h>17:53</h><r>seancorfield</r>You have missed a level of nesting. Funnily enough I was just explaining this to someone else…</z><z id="t1620842045" t="seancorfield :select [:a :b :c] =&gt; SELECT a, b, c"><y>#</y><d>2021-05-12</d><h>17:54</h><r>seancorfield</r><code>:select [:a :b :c]</code> =&gt; <code>SELECT a, b, c</code></z><z id="t1620842063" t="seancorfield :select [:a [:b :c]] =&gt; SELECT a, b AS c"><y>#</y><d>2021-05-12</d><h>17:54</h><r>seancorfield</r><code>:select [:a [:b :c]]</code> =&gt; <code>SELECT a, b AS c</code></z><z id="t1620842092" t="seancorfield :select [:a [[:foo :bar] :c]] =&gt; SELECT a, FOO(bar) AS c"><y>#</y><d>2021-05-12</d><h>17:54</h><r>seancorfield</r><code>:select [:a [[:foo :bar] :c]]</code> =&gt; <code>SELECT a, FOO(bar) AS c</code></z><z id="t1620842123" t="seancorfield And as I showed above: user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]}) [&quot;SELECT (first_name, last_name) AS name&quot;] Note the nesting level."><y>#</y><d>2021-05-12</d><h>17:55</h><r>seancorfield</r>And as I showed above:
<pre>user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]})
[&quot;SELECT (first_name, last_name) AS name&quot;]</pre>
Note the nesting level.</z><z id="t1620842172" t="seancorfield If I add spaces it might be easier to see: user=&gt; (sql/format {:select [ [ [:composite :first_name :last_name] :name ] ]}) [&quot;SELECT (first_name, last_name) AS name&quot;]"><y>#</y><d>2021-05-12</d><h>17:56</h><r>seancorfield</r>If I add spaces it might be easier to see:
<pre>user=&gt; (sql/format {:select [    [  [:composite :first_name :last_name] :name  ]    ]})
[&quot;SELECT (first_name, last_name) AS name&quot;]</pre></z><z id="t1620845784" t="Michaël Salihi No success, always same error with a simple copy paste: user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]}) Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385). Assert failed: Alias should have two parts[:composite :first_name :last_name] (= 2 (count x))"><y>#</y><d>2021-05-12</d><h>18:56</h><r>Michaël Salihi</r>No success, always same error with a simple copy paste:
<pre>user=&gt; (sql/format {:select [[[:composite :first_name :last_name] :name]]})
Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385).
Assert failed: Alias should have two parts[:composite :first_name :last_name]
(= 2 (count x))</pre></z><z id="t1620846081" t="seancorfield You’re using HoneySQL V2?"><y>#</y><d>2021-05-12</d><h>19:01</h><r>seancorfield</r>You’re using HoneySQL V2?</z><z id="t1620846215" t="Michaël Salihi No &quot;1.0.461&quot;"><y>#</y><d>2021-05-12</d><h>19:03</h><r>Michaël Salihi</r>No &quot;1.0.461&quot;</z><z id="t1620846259" t="Michaël Salihi OK I move to v2, thx"><y>#</y><d>2021-05-12</d><h>19:04</h><r>Michaël Salihi</r>OK I move to v2, thx</z></g><g id="s3"><z id="t1620847674" t="seancorfield Sorry, yeah, what I suggested is for V2. On V1, you’d have to use the helper I think or sql/call ."><y>#</y><d>2021-05-12</d><h>19:27</h><r>seancorfield</r>Sorry, yeah, what I suggested is for V2. On V1, you’d have to use the helper I think or <code>sql/call</code>.</z><z id="t1620850467" t="Michaël Salihi I supposed sqlite is not well supported. With particulary syntax like: SELECT first_name || &quot; &quot; || last_name as name FROM users;"><y>#</y><d>2021-05-12</d><h>20:14</h><r>Michaël Salihi</r>I supposed sqlite is not well supported. With particulary syntax like:
<pre>SELECT first_name || &quot; &quot; || last_name as name FROM users;</pre></z><z id="t1620851172" t="seancorfield [:|| :first_name &quot; &quot; :last_name] should work."><y>#</y><d>2021-05-12</d><h>20:26</h><r>seancorfield</r><code>[:|| :first_name &quot; &quot; :last_name]</code> should work.</z><z id="t1620851193" t="seancorfield :select [ [ [:|| ...] :name ] ]"><y>#</y><d>2021-05-12</d><h>20:26</h><r>seancorfield</r><code>:select [ [ [:|| ...] :name ] ]</code></z><z id="t1620851261" t="seancorfield user=&gt; (sql/format {:select [ [ [:|| :first_name &quot; &quot; :last_name] :name ] ]}) [&quot;SELECT first_name || ? || last_name AS name&quot; &quot; &quot;] Several DBs have || as a string concatenation operator."><y>#</y><d>2021-05-12</d><h>20:27</h><r>seancorfield</r><pre>user=&gt; (sql/format {:select [ [ [:|| :first_name &quot; &quot; :last_name] :name ] ]})
[&quot;SELECT first_name || ? || last_name AS name&quot; &quot; &quot;]</pre>
Several DBs have <code>||</code> as a string concatenation operator.</z><z id="t1620851316" t="seancorfield See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-operator-reference"><y>#</y><d>2021-05-12</d><h>20:28</h><r>seancorfield</r>See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-operator-reference" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-operator-reference</a></z><z id="t1620851922" t="Michaël Salihi Great, very relevant. Thanks a lot."><y>#</y><d>2021-05-12</d><h>20:38</h><r>Michaël Salihi</r>Great, very relevant.
Thanks a lot.</z><z id="t1620837304" t="seancorfield [:composite :first_name :last_name] is a function call/operator syntax"><y>#</y><d>2021-05-12</d><h>16:35</h><w>seancorfield</w><code>[:composite :first_name :last_name]</code> is a function call/operator syntax</z><z id="t1620837319" t="seancorfield [[:composite :first_name :last_name] :name] is an aliased expression"><y>#</y><d>2021-05-12</d><h>16:35</h><w>seancorfield</w><code>[[:composite :first_name :last_name] :name]</code> is an aliased expression</z><z id="t1620837329" t="seancorfield and :select takes a sequence of expressions"><y>#</y><d>2021-05-12</d><h>16:35</h><w>seancorfield</w>and <code>:select</code> takes a sequence of expressions</z><z id="t1620837408" t="Michaël Salihi Oh I had missed :composite"><y>#</y><d>2021-05-12</d><h>16:36</h><w>Michaël Salihi</w>Oh I had missed <code>:composite</code></z><z id="t1620837415" t="Michaël Salihi Perfect, thanks!"><y>#</y><d>2021-05-12</d><h>16:36</h><w>Michaël Salihi</w>Perfect, thanks!</z><z id="t1620837510" t="seancorfield https://github.com/seancorfield/honeysql/tree/v2#composite-types (README) — although the usage shown is with insert rather than select"><y>#</y><d>2021-05-12</d><h>16:38</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/tree/v2#composite-types" target="_blank">https://github.com/seancorfield/honeysql/tree/v2#composite-types</a> (README) — although the usage shown is with <code>insert</code> rather than <code>select</code></z><z id="t1620837697" t="Michaël Salihi Last thing, is there an equivalent of &quot;%pattern%&quot; for a where clause?"><y>#</y><d>2021-05-12</d><h>16:41</h><w>Michaël Salihi</w>Last thing, is there an equivalent of <code>&quot;%pattern%&quot;</code> for a where clause?</z><z id="t1620837785" t="seancorfield Not sure what you mean."><y>#</y><d>2021-05-12</d><h>16:43</h><w>seancorfield</w>Not sure what you mean.</z><z id="t1620837814" t="seancorfield [:like :first_name &quot;%foo%&quot;] ?"><y>#</y><d>2021-05-12</d><h>16:43</h><w>seancorfield</w><code>[:like :first_name &quot;%foo%&quot;]</code> ?</z><z id="t1620837830" t="Michaël Salihi Yes"><y>#</y><d>2021-05-12</d><h>16:43</h><w>Michaël Salihi</w>Yes</z><z id="t1620837850" t="seancorfield BTW, it can be really inefficient to query with a leading % in a regex — it will do a full table scan in all cases."><y>#</y><d>2021-05-12</d><h>16:44</h><w>seancorfield</w>BTW, it can be really inefficient to query with a leading <code>%</code> in a regex — it will do a full table scan in all cases.</z><z id="t1620837898" t="seancorfield Trailing % is OK, because SQL can use the stem value (the portion before the % ) to narrow down the index range, assuming you have an index on the column 🙂"><y>#</y><d>2021-05-12</d><h>16:44</h><w>seancorfield</w>Trailing <code>%</code> is OK, because SQL can use the stem value (the portion before the <code>%</code>) to narrow down the index range, assuming you have an index on the column <b>🙂</b></z><z id="t1620838029" t="Michaël Salihi Oh thanks, very useful information."><y>#</y><d>2021-05-12</d><h>16:47</h><w>Michaël Salihi</w>Oh thanks, very useful information.</z><z id="t1620838256" t="Michaël Salihi So with your snippet, if I want pass a var so I&apos;ll do [:like :first_name (str &quot;%&quot; foo &quot;%&quot;)]"><y>#</y><d>2021-05-12</d><h>16:50</h><w>Michaël Salihi</w>So with your snippet, if I want pass a var so I&apos;ll do <code>[:like :first_name (str &quot;%&quot; foo &quot;%&quot;)]</code></z><z id="t1620838343" t="Michaël Salihi or is a cleaner way to do it?"><y>#</y><d>2021-05-12</d><h>16:52</h><w>Michaël Salihi</w>or is a cleaner way to do it?</z><z id="t1620838524" t="seancorfield If you have just a string and you want it to be a SQL regex and match anywhere in the column value, you have to add the % yourself."><y>#</y><d>2021-05-12</d><h>16:55</h><w>seancorfield</w>If you have just a string and you want it to be a SQL regex and match anywhere in the column value, you have to add the <code>%</code> yourself.</z><z id="t1620838569" t="seancorfield I think :like will be case sensitive in most cases (depends on the DB and how it is setup) so there’s also :ilike for a case-insensitive comparison"><y>#</y><d>2021-05-12</d><h>16:56</h><w>seancorfield</w>I think <code>:like</code> will be case sensitive in most cases (depends on the DB and how it is setup) so there’s also <code>:ilike</code> for a case-insensitive comparison</z><z id="t1620838611" t="Michaël Salihi Great, thanks. 👍"><y>#</y><d>2021-05-12</d><h>16:56</h><w>Michaël Salihi</w>Great, thanks. <b>👍</b></z><z id="t1620985527" t="Lennart Buit Can you express nested functions in honeysql, say sum(coalesce(a, b)) ?"><y>#</y><d>2021-05-14</d><h>09:45</h><w>Lennart Buit</w>Can you express nested functions in honeysql, say <code>sum(coalesce(a, b))</code>?</z><z id="t1621007257" t="dcj Would [:sum [:coalesce a b]] work?"><y>#</y><d>2021-05-14</d><h>15:47</h><w>dcj</w>Would <code>[:sum [:coalesce a b]]</code> work?</z><z id="t1621009431" t="seancorfield dev=&gt; (sql/format-expr [:sum [:coalesce :a :b]]) [&quot;SUM(COALESCE(a, b))&quot;] dev=&gt; (sql/format {:select [ [[:sum [:coalesce :a :b]] :c] ]}) [&quot;SELECT SUM(COALESCE(a, b)) AS c&quot;] dev=&gt; "><y>#</y><d>2021-05-14</d><h>16:23</h><w>seancorfield</w><pre>dev=&gt; (sql/format-expr [:sum [:coalesce :a :b]])
[&quot;SUM(COALESCE(a, b))&quot;]
dev=&gt; (sql/format {:select [ [[:sum [:coalesce :a :b]] :c] ]})
[&quot;SELECT SUM(COALESCE(a, b)) AS c&quot;]
dev=&gt; </pre></z><z id="t1621269360" t="borkdude Any tips on how to express: SELECT ARRAY[1,2] &amp;&amp; foo; in honeysql (still on v1 in our production app)? The left array is from values from input, the other array foo is from a table"><y>#</y><d>2021-05-17</d><h>16:36</h><w>borkdude</w>Any tips on how to express:
<pre>SELECT ARRAY[1,2] &amp;&amp; foo;</pre>
in honeysql (still on v1 in our production app)? The left array is from values from input, the other array <code>foo</code> is from a table</z><z id="t1621269520" t="borkdude I guess I can use (h/format (honeysql.types/array [1 2 3]))"><y>#</y><d>2021-05-17</d><h>16:38</h><w>borkdude</w>I guess I can use <code>(h/format (honeysql.types/array [1 2 3]))</code></z><z id="t1621269709" t="borkdude and now the [:&amp;&amp; included-uuids :tzdb.tag_uuids] part: can I generate the &amp;&amp; as an operator instead of a function?"><y>#</y><d>2021-05-17</d><h>16:41</h><w>borkdude</w>and now the <code>[:&amp;&amp; included-uuids :tzdb.tag_uuids]</code> part: can I generate the <code>&amp;&amp;</code> as an operator instead of a function?</z><z id="t1621269747" t="borkdude (sorry, this is probblay in the docs somewhere, but I have trouble finding it 😒 )"><y>#</y><d>2021-05-17</d><h>16:42</h><w>borkdude</w>(sorry, this is probblay in the docs somewhere, but I have trouble finding it <b>😒</b> )</z><z id="t1621270169" t="borkdude Is there some hook to register a thing as an infix thing?"><y>#</y><d>2021-05-17</d><h>16:49</h><w>borkdude</w>Is there some hook to register a thing as an infix thing?</z><z id="t1621270378" t="borkdude I did this: (defmethod hf/fn-handler &quot;&amp;&amp;&quot; [op &amp; args] (let [args (map hf/to-sql args)] (hf/paren-wrap (str/join (str &quot; &quot; op &quot; &quot;) args))))"><y>#</y><d>2021-05-17</d><h>16:52</h><w>borkdude</w>I did this:
<pre>(defmethod hf/fn-handler &quot;&amp;&amp;&quot; [op &amp; args]
  (let [args (map hf/to-sql args)]
    (hf/paren-wrap (str/join (str &quot; &quot; op &quot; &quot;) args))))</pre></z><z id="t1621271049" t="seancorfield Sounds like you’ve solved the problem? Which DB is that for? || is a variadic infix operator in V2 for string concatenation so I’m a bit surprised to see &amp;&amp; — what does it mean?"><y>#</y><d>2021-05-17</d><h>17:04</h><w>seancorfield</w>Sounds like you’ve solved the problem? Which DB is that for? <code>||</code> is a variadic infix operator in V2 for string concatenation so I’m a bit surprised to see <code>&amp;&amp;</code> — what does it mean?</z><z id="t1621272691" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] this is an array operator in postgresql."><y>#</y><d>2021-05-17</d><h>17:31</h><w>borkdude</w><a>@seancorfield</a> this is an array operator in postgresql.</z><z id="t1621272717" t="borkdude array[1,2,3] &amp;&amp; array[1,2,3,4] means all the left elements must occur in the right elements"><y>#</y><d>2021-05-17</d><h>17:31</h><w>borkdude</w><pre>array[1,2,3] &amp;&amp; array[1,2,3,4]</pre>
means all the left elements must occur in the right elements</z><z id="t1621272746" t="borkdude perhaps allowing people to say: &quot;this is an infix operator&quot; would be easier"><y>#</y><d>2021-05-17</d><h>17:32</h><w>borkdude</w>perhaps allowing people to say: &quot;this is an infix operator&quot; would be easier</z><z id="t1621272976" t="seancorfield That’s easy in HoneySQL v2 but I think fn-handler is the right approach in v1."><y>#</y><d>2021-05-17</d><h>17:36</h><w>seancorfield</w>That’s easy in HoneySQL v2 but I think <code>fn-handler</code> is the right approach in v1.</z><z id="t1621273092" t="seancorfield In v2 it’s (sql/register-op! :&amp;&amp; :variadic true) and you’re off to the races. But I’ll go ahead and add &amp;&amp; as a built-in for the next v2 version anyway."><y>#</y><d>2021-05-17</d><h>17:38</h><w>seancorfield</w>In v2 it’s <code>(sql/register-op! :&amp;&amp; :variadic true)</code> and you’re off to the races. But I’ll go ahead and add <code>&amp;&amp;</code> as a built-in for the next v2 version anyway.</z><z id="t1621273410" t="borkdude Excellent! I&apos;ll try to migrate this one namespace to v2 now"><y>#</y><d>2021-05-17</d><h>17:43</h><w>borkdude</w>Excellent! I&apos;ll try to migrate this one namespace to v2 now</z><z id="t1621273422" t="borkdude We can use them side by side anyway"><y>#</y><d>2021-05-17</d><h>17:43</h><w>borkdude</w>We can use them side by side anyway</z><z id="t1621273452" t="seancorfield Yup. develop has that change. It’ll be in RC 3 or “gold”, whichever comes next."><y>#</y><d>2021-05-17</d><h>17:44</h><w>seancorfield</w>Yup. develop has that change. It’ll be in RC 3 or “gold”, whichever comes next.</z><z id="t1621277179" t="borkdude if I have an array like ARRAY[&quot;...&quot;] but I want to generate ARRAY[&quot;...&quot;]::uuid[] , what&apos;s the best option?"><y>#</y><d>2021-05-17</d><h>18:46</h><w>borkdude</w>if I have an array like <code>ARRAY[&quot;...&quot;]</code> but I want to generate <code>ARRAY[&quot;...&quot;]::uuid[]</code>, what&apos;s the best option?</z><z id="t1621277343" t="borkdude [:cast included-uuids :uuid[]] doesn&apos;t work obviously :)"><y>#</y><d>2021-05-17</d><h>18:49</h><w>borkdude</w><pre>[:cast included-uuids :uuid[]]</pre>
doesn&apos;t work obviously :)</z><z id="t1621277611" t="borkdude hacky and ugly, but it works: [:&amp;&amp; [:cast included-uuids [:lift (symbol &quot;uuid[]&quot;)]] :tzdb.tag_uuids] open to improvements :)"><y>#</y><d>2021-05-17</d><h>18:53</h><w>borkdude</w>hacky and ugly, but it works:
<pre>[:&amp;&amp; [:cast included-uuids [:lift (symbol &quot;uuid[]&quot;)]]  :tzdb.tag_uuids]</pre>
open to improvements :)</z><z id="t1621277729" t="borkdude this seems to work: [:&amp;&amp; [:cast included-uuids [:raw &quot;uuid[]&quot;]] :tzdb.tag_uuids]"><y>#</y><d>2021-05-17</d><h>18:55</h><w>borkdude</w>this seems to work: <code>[:&amp;&amp; [:cast included-uuids [:raw &quot;uuid[]&quot;]]  :tzdb.tag_uuids]</code></z><z id="t1621277968" t="borkdude The :inline feature is great for debugging"><y>#</y><d>2021-05-17</d><h>18:59</h><w>borkdude</w>The <code>:inline</code> feature is great for debugging</z><z id="t1621281267" t="seancorfield I’d probably go with :cast / :raw for a situation like that. Open to suggestions on making that easier — but we’re sort of at the mercy of Clojure’s reader for that one."><y>#</y><d>2021-05-17</d><h>19:54</h><w>seancorfield</w>I’d probably go with <code>:cast</code> / <code>:raw</code> for a situation like that. Open to suggestions on making that easier — but we’re sort of at the mercy of Clojure’s reader for that one.</z><z id="t1621282421" t="borkdude cast / raw works for me, it just wasn&apos;t what I usually write with hugsql"><y>#</y><d>2021-05-17</d><h>20:13</h><w>borkdude</w>cast / raw works for me, it just wasn&apos;t what I usually write with hugsql</z><z id="t1621339940" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] any idea about this one? (sql/format {:select [:tzdb.source :tzdb.uri [:cast :tzdb.tag_uuids [:raw &quot;text[]&quot;]]]}) ;;=&gt; [&quot;SELECT tzdb.source, tzdb.uri, cast AS tzdb.tag_uuids&quot;] I want something like cast(tzdb.tag_uuids as text[])"><y>#</y><d>2021-05-18</d><h>12:12</h><w>borkdude</w><a>@seancorfield</a> any idea about this one?
<pre>(sql/format {:select [:tzdb.source :tzdb.uri [:cast :tzdb.tag_uuids [:raw &quot;text[]&quot;]]]})
;;=&gt;
[&quot;SELECT tzdb.source, tzdb.uri, cast AS tzdb.tag_uuids&quot;]</pre>
I want something like <code>cast(tzdb.tag_uuids as text[])</code></z><z id="t1621340165" t="borkdude This also doesn&apos;t work for me: (sql/format {:select [:tzdb.source :tzdb.uri [:raw &quot;tzdb.tag_uuids::text[]&quot;]]})"><y>#</y><d>2021-05-18</d><h>12:16</h><w>borkdude</w>This also doesn&apos;t work for me: <code>(sql/format {:select [:tzdb.source :tzdb.uri [:raw &quot;tzdb.tag_uuids::text[]&quot;]]})</code></z><z id="t1621340531" t="borkdude Again, this works: (sql/format {:select [&apos;foo &apos;bar (symbol &quot;tzdb.tag_uuids::text[]&quot;)]}) but it&apos;s pretty ugly :)"><y>#</y><d>2021-05-18</d><h>12:22</h><w>borkdude</w>Again, this works: <code>(sql/format {:select [&apos;foo &apos;bar (symbol &quot;tzdb.tag_uuids::text[]&quot;)]})</code> but it&apos;s pretty ugly :)</z><z id="t1621340623" t="borkdude perhaps instead of (symbol &quot;tzdb.tag_uuids::text[]&quot;) honeysql could support a raw function, since [:raw ...] doesn&apos;t seem to work everywhere."><y>#</y><d>2021-05-18</d><h>12:23</h><w>borkdude</w>perhaps instead of <code>(symbol &quot;tzdb.tag_uuids::text[]&quot;)</code> honeysql could support a <code>raw</code> function, since <code>[:raw ...]</code> doesn&apos;t seem to work everywhere.</z><z id="t1621351640" t="seancorfield For functions in a select you need an extra level of brackets - otherwise it&apos;s an aliased column. The docs explain that but could clearly do a better job:grin:"><y>#</y><d>2021-05-18</d><h>15:27</h><w>seancorfield</w>For functions in a select you need an extra level of brackets - otherwise it&apos;s an aliased column. The docs explain that but could clearly do a better job:grin:</z><z id="t1621358925" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] 🙏 :select [:tzdb.source :tzdb.uri [[:raw &quot;tzdb.tag_uuids::text[]&quot;]]] there&apos;s nothing that can&apos;t be fixed using an extra pair of brackets"><y>#</y><d>2021-05-18</d><h>17:28</h><w>borkdude</w><a>@seancorfield</a> <b>🙏</b>
<pre>:select [:tzdb.source :tzdb.uri [[:raw &quot;tzdb.tag_uuids::text[]&quot;]]]</pre>
there&apos;s nothing that can&apos;t be fixed using an extra pair of brackets</z><z id="t1621360505" t="seancorfield Well, :select [[:a :b]] means SELECT a AS b so :select [[[:foo :a] :b]] means SELECT FOO(a) AS b"><y>#</y><d>2021-05-18</d><h>17:55</h><w>seancorfield</w>Well, <code>:select [[:a :b]]</code> means <code>SELECT a AS b</code> so <code>:select [[[:foo :a] :b]]</code> means <code>SELECT FOO(a) AS b</code></z><z id="t1621368690" t="borkdude of course, once you see it you can&apos;t unsee it"><y>#</y><d>2021-05-18</d><h>20:11</h><w>borkdude</w>of course, once you see it you can&apos;t unsee it</z><z id="t1621472266" t="seancorfield FYI: in preparation for 2.0 “gold” hopefully dropping fairly soon, I have created a v1 branch from develop (in case I need to cut security fixes) and I have merged the v2 branch down onto develop . I will probably delete the v2 branch once I cut a “gold” release from develop . I will also most likely drop double-publishing to Clojars at that point (so 2.0 “gold” will not appear under the old seancorfield group ID)."><y>#</y><d>2021-05-20</d><h>00:57</h><w>seancorfield</w>FYI: in preparation for 2.0 “gold” hopefully dropping fairly soon, I have created a <code>v1</code> branch from <code>develop</code> (in case I need to cut security fixes) and I have merged the <code>v2</code> branch down onto <code>develop</code>. I will probably delete the <code>v2</code> branch once I cut a “gold” release from <code>develop</code>. I will also most likely drop double-publishing to Clojars at that point (so 2.0 “gold” will not appear under the old <code>seancorfield</code> group ID).</z><z id="t1621473285" t="seancorfield I’ve expanded the SQL Expressions section in Getting Started to better explain how to SELECT function expressions https://github.com/seancorfield/honeysql/blob/develop/doc/getting-started.md#sql-expressions /cc [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] and everyone else who has run into that and asked questions here and on Zulip 🙂"><y>#</y><d>2021-05-20</d><h>01:14</h><w>seancorfield</w>I’ve expanded the SQL Expressions section in Getting Started to better explain how to <code>SELECT</code> function expressions <a href="https://github.com/seancorfield/honeysql/blob/develop/doc/getting-started.md#sql-expressions" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/getting-started.md#sql-expressions</a> /cc <a>@borkdude</a> and everyone else who has run into that and asked questions here and on Zulip <b>🙂</b></z><z id="t1622640163" t="Teemu Kaukoranta How do you cast strings to enums with honeysql? Found some discussion from the slack archive, but I can&apos;t figure out what is the types/as-other that is being referenced. https://clojurians-log.clojureverse.org/honeysql/2021-04-14"><y>#</y><d>2021-06-02</d><h>13:22</h><w>Teemu Kaukoranta</w>How do you cast strings to enums with honeysql? Found some discussion from the slack archive, but I can&apos;t figure out what is the <code>types/as-other</code> that is being referenced.

<a href="https://clojurians-log.clojureverse.org/honeysql/2021-04-14" target="_blank">https://clojurians-log.clojureverse.org/honeysql/2021-04-14</a></z><z id="t1622640999" t="Teemu Kaukoranta Well, I guess I can just add the casting stuff to the string myself"><y>#</y><d>2021-06-02</d><h>13:36</h><r>Teemu Kaukoranta</r>Well, I guess I can just add the casting stuff to the string myself</z><z id="t1622641266" t="Teemu Kaukoranta https://github.com/seancorfield/honeysql/blob/fb601138588cf32be07ff2362e8ef8300fec255b/doc/special-syntax.md#cast"><y>#</y><d>2021-06-02</d><h>13:41</h><r>Teemu Kaukoranta</r><a href="https://github.com/seancorfield/honeysql/blob/fb601138588cf32be07ff2362e8ef8300fec255b/doc/special-syntax.md#cast" target="_blank">https://github.com/seancorfield/honeysql/blob/fb601138588cf32be07ff2362e8ef8300fec255b/doc/special-syntax.md#cast</a></z><z id="t1622646025" t="seancorfield types/as-other is next.jdbc not honeysql"><y>#</y><d>2021-06-02</d><h>15:00</h><r>seancorfield</r><code>types/as-other</code> is <code>next.jdbc</code> not <code>honeysql</code></z><z id="t1622647146" t="Teemu Kaukoranta ah, that explains it"><y>#</y><d>2021-06-02</d><h>15:19</h><r>Teemu Kaukoranta</r>ah, that explains it</z><z id="t1622647236" t="Teemu Kaukoranta I had to do this a bit differently than I at first thought anyway. In case someone finds this message later, here&apos;s the approach I used https://www.bevuta.com/en/blog/using-postgresql-enums-in-clojure/"><y>#</y><d>2021-06-02</d><h>15:20</h><r>Teemu Kaukoranta</r>I had to do this a bit differently than I at first thought anyway. In case someone finds this message later, here&apos;s the approach I used

<a href="https://www.bevuta.com/en/blog/using-postgresql-enums-in-clojure/" target="_blank">https://www.bevuta.com/en/blog/using-postgresql-enums-in-clojure/</a></z><z id="t1622649047" t="seancorfield Yeah, if you’re using clojure.java.jdbc , you need to extend ISQLValue . That’s one of the nice things about next.jdbc : you can use any of the built-in JDBC types as “hints”, via the next.jdbc.types namespace: https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.659/api/next.jdbc.types"><y>#</y><d>2021-06-02</d><h>15:50</h><r>seancorfield</r>Yeah, if you’re using <code>clojure.java.jdbc</code>, you need to extend <code>ISQLValue</code>. That’s one of the nice things about <code>next.jdbc</code>: you can use any of the built-in JDBC types as “hints”, via the <code>next.jdbc.types</code> namespace: <a href="https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.659/api/next.jdbc.types" target="_blank">https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.659/api/next.jdbc.types</a></z><z id="t1623150463" t="orestis I&apos;ve finally taken honeysql2 out for a spin. What an improvement [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] , many thanks for taking the time. Funnily enough, it&apos;s the helpers documentation and clause reference that it&apos;s most useful so far. Very much appreciated."><y>#</y><d>2021-06-08</d><h>11:07</h><w>orestis</w>I&apos;ve finally taken honeysql2 out for a spin. What an improvement <a>@seancorfield</a>, many thanks for taking the time. Funnily enough, it&apos;s the helpers documentation and clause reference that it&apos;s most useful so far. Very much appreciated.</z><z id="t1623150524" t="orestis I&apos;ve opened a couple of minor issues as I find small things, but I&apos;d like to let you know here that everything so far works as expected. I like the new call convention, when reading examples I was worried about too many square brackets (obviously could use quoted parentheses there if I want to, right?)"><y>#</y><d>2021-06-08</d><h>11:08</h><w>orestis</w>I&apos;ve opened a couple of minor issues as I find small things, but I&apos;d like to let you know here that everything so far works as expected. I like the new call convention, when reading examples I was worried about too many square brackets (obviously could use quoted parentheses there if I want to, right?)</z><z id="t1623165944" t="seancorfield Thank you, and I’m glad the new documentation is helping — as I was rebuilding HoneySQL, I began to realize just how many features were not documented at all or only appeared in an example with no explanation! And, yes, the “quoted list” format and being able to use symbols in place of keywords can make complex forms a lot more readable — thanks to whoever it was that asked for “quoted forms, like datalog etc” 🙂"><y>#</y><d>2021-06-08</d><h>15:25</h><w>seancorfield</w>Thank you, and I’m glad the new documentation is helping — as I was rebuilding HoneySQL, I began to realize just how many features were not documented at all or only appeared in an example with no explanation! And, yes, the “quoted list” format and being able to use symbols in place of keywords can make complex forms a lot more readable — thanks to whoever it was that asked for “quoted forms, like datalog etc” <b>🙂</b></z><z id="t1623165991" t="seancorfield Thanks for the issues. Will take a look during my next “OSS window” this week."><y>#</y><d>2021-06-08</d><h>15:26</h><w>seancorfield</w>Thanks for the issues. Will take a look during my next “OSS window” this week.</z><z id="t1623225849" t="orestis One suggestion that perhaps merit some discussion is re-introducing the call helper? It would help our migration quite a bit and the implementation could just be (defn call [f &amp; args] (apply vector f args))"><y>#</y><d>2021-06-09</d><h>08:04</h><w>orestis</w>One suggestion that perhaps merit some discussion is re-introducing the <code>call</code> helper? It would help our migration quite a bit and the implementation could just be
<pre>(defn call [f &amp; args]
  (apply vector f args))</pre></z><z id="t1623240799" t="seancorfield Open a Github issue and I&apos;ll think about it."><y>#</y><d>2021-06-09</d><h>12:13</h><r>seancorfield</r>Open a Github issue and I&apos;ll think about it.</z><z id="t1623731801" t="pinealan Are there examples out there for writing CTE in honeysql? I’m basically trying to write insert queries with https://dba.stackexchange.com/questions/46410/how-do-i-insert-a-row-which-contains-a-foreign-key so it involves quite a few types of clauses in one go where the interactions are not described in the docs"><y>#</y><d>2021-06-15</d><h>04:36</h><w>pinealan</w>Are there examples out there for writing CTE in honeysql? I’m basically trying to write insert queries with <a href="https://dba.stackexchange.com/questions/46410/how-do-i-insert-a-row-which-contains-a-foreign-key" target="_blank">https://dba.stackexchange.com/questions/46410/how-do-i-insert-a-row-which-contains-a-foreign-key</a> so it involves quite a few types of clauses in one go where the interactions are not described in the docs</z><z id="t1623733107" t="seancorfield [:attrs {:href &quot;/_/_/users/U0112ACBNRM&quot;}] You mean like this? https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference#with-with-recursive"><y>#</y><d>2021-06-15</d><h>04:58</h><w>seancorfield</w><a>@achan961117</a> You mean like this? <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference#with-with-recursive" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference#with-with-recursive</a></z><z id="t1623733219" t="seancorfield And if you&apos;re still using 1.x, the first test here has an example: https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L16"><y>#</y><d>2021-06-15</d><h>05:00</h><w>seancorfield</w>And if you&apos;re still using 1.x, the first test here has an example: <a href="https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L16" target="_blank">https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L16</a></z><z id="t1623733856" t="pinealan thanks for the pointer!"><y>#</y><d>2021-06-15</d><h>05:10</h><r>pinealan</r>thanks for the pointer!</z><z id="t1623733940" t="pinealan ya I’m still on 1.x, I’ve only just read the 1.x -&gt; 2 differences doc and still digesting the changes"><y>#</y><d>2021-06-15</d><h>05:12</h><r>pinealan</r>ya I’m still on 1.x, I’ve only just read the 1.x -&gt; 2 differences doc and still digesting the changes</z><z id="t1623835841" t="orestis Is there a way to order by NULLS FIRST/LAST in honeysql 2?"><y>#</y><d>2021-06-16</d><h>09:30</h><w>orestis</w>Is there a way to order by NULLS FIRST/LAST in honeysql 2?</z><z id="t1623835992" t="orestis Oh I see, just pass in a keyword: :desc-nulls-last which sql-kw would convert to DESC NULLS LAST"><y>#</y><d>2021-06-16</d><h>09:33</h><w>orestis</w>Oh I see, just pass in a keyword: <code>:desc-nulls-last</code> which <code>sql-kw</code> would convert to <code>DESC NULLS LAST</code></z><z id="t1623847457" t="orestis I see that honeysql v1 qualify was removed. It was quite handy for us, I&apos;ve come up with a quick replacement: (defn- qualify &quot;Replace honeysql v1 qualify function, that takes a table and column and joins them together.&quot; [table column] (keyword (hsql/format-entity (keyword (name table) (name column))))) I was just wondering if there was something wrong with the original? I could copy that code."><y>#</y><d>2021-06-16</d><h>12:44</h><w>orestis</w>I see that honeysql v1 <code>qualify</code> was removed. It was quite handy for us, I&apos;ve come up with a quick replacement:
<pre>(defn- qualify
  &quot;Replace honeysql v1 qualify function, that takes a table and column
  and joins them together.&quot;
  [table column]
  (keyword (hsql/format-entity (keyword (name table) (name column)))))</pre>
I was just wondering if there was something wrong with the original? I could copy that code.</z><z id="t1623852459" t="jaihindhreddy Encouraging pervasive use of namespaced keywords is the reason perhaps?"><y>#</y><d>2021-06-16</d><h>14:07</h><r>jaihindhreddy</r>Encouraging pervasive use of namespaced keywords is the reason perhaps?</z><z id="t1623854988" t="seancorfield What purpose do qualified names serve in SQL?"><y>#</y><d>2021-06-16</d><h>14:49</h><r>seancorfield</r>What purpose do qualified names serve in SQL?</z><z id="t1623864196" t="orestis So we use a lot of WITH statements that we later join to. Sometimes more than once with different table names. So the table name is dynamic. If you want to refer to a specific column you need to write it as table.column which is what the qualify function would give us "><y>#</y><d>2021-06-16</d><h>17:23</h><r>orestis</r>So we use a lot of WITH statements that we later join to. Sometimes more than once with different table names. So the table name is dynamic. If you want to refer to a specific column you need to write it as table.column which is what the qualify function would give us </z><z id="t1623864236" t="orestis Perhaps there’s a more direct way to do this?"><y>#</y><d>2021-06-16</d><h>17:23</h><r>orestis</r>Perhaps there’s a more direct way to do this?</z><z id="t1623865657" t="seancorfield So you’re round-tripping through qualified keywords for that? I guess I’m having a hard time imagining what the code looks like for this to be needed… Can you show a (simplified) example?"><y>#</y><d>2021-06-16</d><h>17:47</h><r>seancorfield</r>So you’re round-tripping through qualified keywords for that? I guess I’m having a hard time imagining what the code looks like for this to be needed… Can you show a (simplified) example?</z><z id="t1623869315" t="orestis I’m on the phone but imagine that I have a base query map that I keep adding where clauses to (users adding filters etc) Some of the where clauses need additional with and left-join clauses. The with, left-join and where clauses must share the same table name. The table name is dynamic as a filter might be repeated. So all the column references need to be qualified at runtime with the dynamic table name. "><y>#</y><d>2021-06-16</d><h>18:48</h><r>orestis</r>I’m on the phone but imagine that I have a base query map that I keep adding where clauses to (users adding filters etc) Some of the where clauses need additional with and left-join clauses. The with, left-join and where clauses must share the same table name. The table name is dynamic as a filter might be repeated. So all the column references need to be qualified at runtime with the dynamic table name. </z><z id="t1623869446" t="orestis Note, I don’t care about namespaced Clojure keywords at all. All I want is a honeysql function that given a table and a column will construct the correct keyword (to be later escaped properly) for an “absolute” column reference. "><y>#</y><d>2021-06-16</d><h>18:50</h><r>orestis</r>Note, I don’t care about namespaced Clojure keywords at all. All I want is a honeysql function that given a table and a column will construct the correct keyword (to be later escaped properly) for an “absolute” column reference. </z><z id="t1623869491" t="orestis My sample code took advantage that format-entity uses namespaced keywords to generate the escaped column reference. "><y>#</y><d>2021-06-16</d><h>18:51</h><r>orestis</r>My sample code took advantage that format-entity uses namespaced keywords to generate the escaped column reference. </z><z id="t1623871156" t="seancorfield :some_alias.some_col when you have [:table :some_alias] to alias table to some_alias ?"><y>#</y><d>2021-06-16</d><h>19:19</h><r>seancorfield</r><code>:some_alias.some_col</code> when you have <code>[:table :some_alias]</code> to alias <code>table</code> to <code>some_alias</code>?</z><z id="t1623871177" t="seancorfield And :some_alias is the dynamic part here (not really the table name)?"><y>#</y><d>2021-06-16</d><h>19:19</h><r>seancorfield</r>And <code>:some_alias</code> is the dynamic part here (not really the table name)?</z><z id="t1623871289" t="seancorfield So I think you just want (keyword (name the-alias) (name column)) and then HoneySQL will take care of formatting that? (you don’t need to call format-entity and convert back to a keyword) What am I missing?"><y>#</y><d>2021-06-16</d><h>19:21</h><r>seancorfield</r>So I think you just want <code>(keyword (name the-alias) (name column))</code> and then HoneySQL will take care of formatting that? (you don’t need to call <code>format-entity</code> and convert back to a keyword) What am I missing?</z><z id="t1623914173" t="orestis Right, so there is a convention that I’m missing. In all of our hand written columns we use dot as a separator - alias.some_column - but you’re saying that namespaced keywords also would be equivalent; alias/some_column as far as honeysql is concerned? "><y>#</y><d>2021-06-17</d><h>07:16</h><r>orestis</r>Right, so there is a convention that I’m missing. In all of our hand written columns we use dot as a separator - alias.some_column - but you’re saying that namespaced keywords also would be equivalent; alias/some_column as far as honeysql is concerned? </z><z id="t1623946732" t="seancorfield In v1, you needed to specify :namespace-as-table? true as an option — that has become the default in v2: dev=&gt; (sql/format {:select [:foo/bar] :from [:foo] :where [[:= :foo/id 42]]}) [&quot;SELECT foo.bar FROM foo WHERE (foo.id = ?)&quot; 42] dev=&gt; "><y>#</y><d>2021-06-17</d><h>16:18</h><r>seancorfield</r>In v1, you needed to specify <code>:namespace-as-table? true</code> as an option — that has become the default in v2:
<pre>dev=&gt; (sql/format {:select [:foo/bar] :from [:foo] :where [[:= :foo/id 42]]})
[&quot;SELECT foo.bar FROM foo WHERE (foo.id = ?)&quot; 42]
dev=&gt; </pre></z><z id="t1623906005" t="pinealan Is it possible to create VALUES in FROM for postgresql in honeysql 1.x (or 2)?"><y>#</y><d>2021-06-17</d><h>05:00</h><w>pinealan</w>Is it possible to create VALUES in FROM for postgresql in honeysql 1.x (or 2)?</z><z id="t1623906248" t="pinealan ah nevermind scratch that, I realised it’s an issue with values in from requiring an alias, got what I wanted with (sql/format {:select [[:column1 :num]] :from [[{:values [[1] [2] [3]]} :vraw]]}) "><y>#</y><d>2021-06-17</d><h>05:04</h><r>pinealan</r>ah nevermind scratch that, I realised it’s an issue with values in from requiring an alias, got what I wanted with
<pre>(sql/format {:select [[:column1 :num]]
             :from [[{:values [[1] [2] [3]]} :vraw]]})</pre>
</z><z id="t1623942511" t="orestis Migrating our codebase to honeysql v2. An easy transition but I’m glad that we have end-to-end tests. If we had a bigger codebase I’d investigate an automated approach with rewrite-clj"><y>#</y><d>2021-06-17</d><h>15:08</h><w>orestis</w>Migrating our codebase to honeysql v2. An easy transition but I’m glad that we have end-to-end tests. If we had a bigger codebase I’d investigate an automated approach with rewrite-clj</z><z id="t1623942561" t="orestis Thank you [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] for taking the time to do this work. I particularly like some error messages that I saw!"><y>#</y><d>2021-06-17</d><h>15:09</h><w>orestis</w>Thank you <a>@seancorfield</a> for taking the time to do this work. I particularly like some error messages that I saw!</z><z id="t1623947057" t="seancorfield We’re migrating one query at a time at work — since we can have both v1 and v2 required into the same namespace."><y>#</y><d>2021-06-17</d><h>16:24</h><w>seancorfield</w>We’re migrating one query at a time at work — since we can have both v1 and v2 required into the same namespace.</z><z id="t1623948412" t="borkdude I using both (versions of honeysql) at the moment. I just rewrote a query using honeysql which was previously in hugsql... it&apos;s way more fun (and easier to debug)."><y>#</y><d>2021-06-17</d><h>16:46</h><w>borkdude</w>I using both (versions of honeysql) at the moment. I just rewrote a query using honeysql which was previously in hugsql... it&apos;s way more fun (and easier to debug).</z><z id="t1623950205" t="orestis A lot of our queries are interconnected so they have to be changed as a unit. But otherwise we have hugsql, honeysql 1 and honeysql 2 :) We have committed to standardize on honeysql 2 though. "><y>#</y><d>2021-06-17</d><h>17:16</h><w>orestis</w>A lot of our queries are interconnected so they have to be changed as a unit. But otherwise we have hugsql,  honeysql 1 and honeysql 2 :) We have committed to standardize on honeysql 2 though. </z><z id="t1623952129" t="borkdude Where can I get a t-shirt"><y>#</y><d>2021-06-17</d><h>17:48</h><w>borkdude</w>Where can I get a t-shirt</z><z id="t1623952179" t="seancorfield If only HoneySQL had a project logo…"><y>#</y><d>2021-06-17</d><h>17:49</h><w>seancorfield</w>If only HoneySQL had a project logo…</z><z id="t1623952257" t="borkdude If you like Calva&apos;s and clojure-lsp&apos;s logo, you could ask [:attrs {:href &quot;/_/_/users/U8WFYMFRU&quot;}]"><y>#</y><d>2021-06-17</d><h>17:50</h><w>borkdude</w>If you like Calva&apos;s and clojure-lsp&apos;s logo, you could ask <a>@jayzawrotny</a></z><z id="t1623952356" t="borkdude Nikitonsky designed clj-kondo and babashka&apos;s logo, but he&apos;s quite busy I think"><y>#</y><d>2021-06-17</d><h>17:52</h><w>borkdude</w>Nikitonsky designed clj-kondo and babashka&apos;s logo, but he&apos;s quite busy I think</z><z id="t1623952393" t="borkdude [:attrs {:href &quot;/_/_/users/UE21H2HHD&quot;}] also made a few logo&apos;s (jet and sci). So there, a few ideas"><y>#</y><d>2021-06-17</d><h>17:53</h><w>borkdude</w><a>@lee</a> also made a few logo&apos;s (jet and sci). So there, a few ideas</z><z id="t1623953714" t="lread I also did rewrite-clj&apos;s current logo. It was not terribly imaginative, but I also came up with the clj-kondo icon clj-kondo . Borkdude and I had some fun working out https://github.com/borkdude/sci/issues/129 and https://github.com/borkdude/jet/issues/50 logos. The lil hammock person is from me too: hammock . I would consider myself an amateur, but if you seriously want a logo, and none more talented makes an offer, I could take a stab at it sometime."><y>#</y><d>2021-06-17</d><h>18:15</h><w>lread</w>I also did rewrite-clj&apos;s current logo. It was not terribly imaginative, but I also came up with the clj-kondo icon <b>clj-kondo</b>. Borkdude and I had some fun working out <a href="https://github.com/borkdude/sci/issues/129" target="_blank">https://github.com/borkdude/sci/issues/129</a> and <a href="https://github.com/borkdude/jet/issues/50" target="_blank">https://github.com/borkdude/jet/issues/50</a> logos.  The lil hammock person is from me too: <b>hammock</b> . I would consider myself an amateur, but if you seriously want a logo, and none more talented makes an offer, I could take a stab at it sometime.</z><z id="t1623953839" t="borkdude The icon is iconic, thanks again [:attrs {:href &quot;/_/_/users/UE21H2HHD&quot;}]"><y>#</y><d>2021-06-17</d><h>18:17</h><w>borkdude</w>The icon is iconic, thanks again <a>@lee</a></z><z id="t1623953947" t="lread For you? Anytime!"><y>#</y><d>2021-06-17</d><h>18:19</h><w>lread</w>For you? Anytime!</z><z id="t1624023552" t="orestis Should there be support for CROSS JOIN LATERAL? I tried the [:lateral ...] wrapper but didn&apos;t get what I expected..."><y>#</y><d>2021-06-18</d><h>13:39</h><w>orestis</w>Should there be support for CROSS JOIN LATERAL? I tried the <code>[:lateral ...]</code> wrapper but didn&apos;t get what I expected...</z><z id="t1624023878" t="orestis {:select [:foo.id [ :x.id :x_id] :x.value ] :cross-join [[[:jsonb_to_recordset :foo.json_value] [[:raw &quot;x(id text, value jsonb)&quot;]]]] :from [:foo]} vs {:select [:foo.id [ :x.id :x_id] :x.value ] :cross-join [:lateral [[[:jsonb_to_recordset :foo.json_value] [[:raw &quot;x(id text, value jsonb)&quot;]]]]] :from [:foo]} The latter returns: SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN lateral, (JSONB_TO_RECORDSET(foo.json_value), (x(id text, value jsonb))) instead of SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)"><y>#</y><d>2021-06-18</d><h>13:44</h><w>orestis</w><pre>{:select [:foo.id [ :x.id :x_id] :x.value ]
 :cross-join [[[:jsonb_to_recordset :foo.json_value]
                 [[:raw &quot;x(id text, value jsonb)&quot;]]]]
   :from [:foo]}</pre>
vs
<pre>{:select [:foo.id [ :x.id :x_id] :x.value ]
   :cross-join [:lateral
                [[[:jsonb_to_recordset :foo.json_value]
                  [[:raw &quot;x(id text, value jsonb)&quot;]]]]]
   :from [:foo]}</pre>
The latter returns:
<pre>SELECT foo.id, x.id AS x_id, x.value
FROM foo
CROSS JOIN lateral, (JSONB_TO_RECORDSET(foo.json_value), (x(id text, value jsonb)))</pre>
instead of
<pre>SELECT foo.id, x.id AS x_id, x.value
FROM foo
CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)</pre></z><z id="t1624023948" t="orestis Perhaps there should be a :cross-join-lateral keyword? Can I add this on my own?"><y>#</y><d>2021-06-18</d><h>13:45</h><w>orestis</w>Perhaps there should be a <code>:cross-join-lateral</code> keyword? Can I add this on my own?</z><z id="t1624036394" t="seancorfield [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] Is this what you’re after? dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ] #_=&gt; :cross-join [[[:lateral #_=&gt; [[:jsonb_to_recordset :foo.json_value] #_=&gt; [:raw &quot;x(id text, value jsonb)&quot;]]]]] #_=&gt; :from [:foo]}) [&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL (JSONB_TO_RECORDSET(foo.json_value), x(id text, value jsonb))&quot;] :cross-join takes a sequence of SQL entities; each can be a simple name or a pair of expression/alias — like :select — so when you want a “function call” there, you need :cross-join [ [ [:fn-call :arg1 :arg2] ] ] just like in a SELECT ."><y>#</y><d>2021-06-18</d><h>17:13</h><w>seancorfield</w><a>@orestis</a> Is this what you’re after?
<pre>dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ]
 #_=&gt;    :cross-join [[[:lateral
 #_=&gt;                 [[:jsonb_to_recordset :foo.json_value]
 #_=&gt;                   [:raw &quot;x(id text, value jsonb)&quot;]]]]]
 #_=&gt;    :from [:foo]})
[&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL (JSONB_TO_RECORDSET(foo.json_value), x(id text, value jsonb))&quot;]</pre>
<code>:cross-join</code> takes a sequence of SQL entities; each can be a simple name or a pair of expression/alias — like <code>:select</code> — so when you want a “function call” there, you need <code>:cross-join [ [ [:fn-call :arg1 :arg2] ] ]</code> just like in a <code>SELECT</code>.</z><z id="t1624036512" t="seancorfield Looking at your desired result more carefully, I think you want this: dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ] #_=&gt; :cross-join [[[:lateral #_=&gt; [:jsonb_to_recordset :foo.json_value]]] #_=&gt; [[:raw &quot;x(id text, value jsonb)&quot;]]] #_=&gt; :from [:foo]}) [&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value), x(id text, value jsonb)&quot;] Again, the :raw part needs to be treated as a function call in the sequence of CROSS JOIN expressions."><y>#</y><d>2021-06-18</d><h>17:15</h><w>seancorfield</w>Looking at your desired result more carefully, I think you want this:
<pre>dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ]
 #_=&gt;    :cross-join [[[:lateral
 #_=&gt;                   [:jsonb_to_recordset :foo.json_value]]]
 #_=&gt;                 [[:raw &quot;x(id text, value jsonb)&quot;]]]
 #_=&gt;    :from [:foo]})
[&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value), x(id text, value jsonb)&quot;]</pre>
Again, the <code>:raw</code> part needs to be treated as a function call in the sequence of <code>CROSS JOIN</code> expressions.</z><z id="t1624036629" t="seancorfield So we have [:lateral [:jsonb..]] as one function call, wrapped as an alias (with the actual alias omitted): [ [:lateral [:jsonb..]] ] and then the same for [ [:raw ..] ]"><y>#</y><d>2021-06-18</d><h>17:17</h><w>seancorfield</w>So we have <code>[:lateral [:jsonb..]]</code> as one function call, wrapped as an alias (with the actual alias omitted): <code>[ [:lateral [:jsonb..]] ]</code> and then the same for <code>[ [:raw ..] ]</code></z><z id="t1624036791" t="seancorfield I notice you don’t have a , in your desired expression: CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb) — is that intentional? I’m not quite sure what to make of that syntax…"><y>#</y><d>2021-06-18</d><h>17:19</h><w>seancorfield</w>I notice you don’t have a <code>,</code> in your desired expression: <code>CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)</code> — is that intentional? I’m not quite sure what to make of that syntax…</z><z id="t1624037104" t="orestis Thanks for answering [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] - first of all, putting the lateral as in your example works. I was putting it surrounding the entire expression but I was confused 🙂"><y>#</y><d>2021-06-18</d><h>17:25</h><w>orestis</w>Thanks for answering <a>@seancorfield</a> - first of all, putting the lateral as in your example works. I was putting it surrounding the entire expression but I was confused <b>🙂</b></z><z id="t1624037201" t="orestis Regarding the raw placement: my example is actually what I&apos;m after. In this case, the x(id text, value jsonb) is a cast expression. jsonb_to_recordset takes a postgres jsonb array and creates a &quot;set&quot; (or table, or relation) out of it. But since SQL is statically typed you need to provide the columns and their types as a cast expression."><y>#</y><d>2021-06-18</d><h>17:26</h><w>orestis</w>Regarding the raw placement: my example is actually what I&apos;m after. In this case, the <code>x(id text, value jsonb)</code> is a cast expression. <code>jsonb_to_recordset</code> takes a postgres jsonb array and creates a &quot;set&quot; (or table, or relation) out of it. But since SQL is statically typed you need to provide the columns and their types as a cast expression.</z><z id="t1624037238" t="orestis I discovered that technically for postgres the LATERAL is not needed in a table-returning-function (it can refer to other tables already in the FROM clause)."><y>#</y><d>2021-06-18</d><h>17:27</h><w>orestis</w>I discovered that technically for postgres the LATERAL is not needed in a table-returning-function (it can refer to other tables already in the FROM clause).</z><z id="t1624037319" t="seancorfield So you’re aiming for JSONB_TO_RECORDSET(foo.json_value) AS x(id text, value jsonb) essentially?"><y>#</y><d>2021-06-18</d><h>17:28</h><w>seancorfield</w>So you’re aiming for <code>JSONB_TO_RECORDSET(foo.json_value) AS x(id text, value jsonb)</code> essentially?</z><z id="t1624037344" t="seancorfield (i.e., x is the name you are trying to give to the record set?)"><y>#</y><d>2021-06-18</d><h>17:29</h><w>seancorfield</w>(i.e., <code>x</code> is the name you are trying to give to the record set?)</z><z id="t1624037358" t="orestis If you&apos;re interested, given a column containing this JSONB data (using EDN for type laziness): [{:id &quot;foo&quot; :value &quot;bar&quot;}, [{:id &quot;qoo&quot; :value &quot;cux&quot;}] it would return 2 rows with the columns id, value."><y>#</y><d>2021-06-18</d><h>17:29</h><w>orestis</w>If you&apos;re interested, given a column containing this JSONB data (using EDN for type laziness): <code>[{:id &quot;foo&quot; :value &quot;bar&quot;}, [{:id &quot;qoo&quot; :value &quot;cux&quot;}]</code>it would return 2 rows with the columns id, value.</z><z id="t1624037373" t="orestis Yes, x is the name of the recordset that you can use in the SELECT clause."><y>#</y><d>2021-06-18</d><h>17:29</h><w>orestis</w>Yes, <code>x</code> is the name of the recordset that you can use in the SELECT clause.</z><z id="t1624037412" t="orestis AS is optional as in many other places. SQL is soooo weird 🙂"><y>#</y><d>2021-06-18</d><h>17:30</h><w>orestis</w>AS is optional as in many other places. SQL is soooo weird <b>🙂</b></z><z id="t1624037458" t="orestis So, no worries from my end: honeysql provides what I want, and turns out I didn&apos;t need it anyway 🙂 Thanks for taking the time."><y>#</y><d>2021-06-18</d><h>17:30</h><w>orestis</w>So, no worries from my end: honeysql provides what I want, and turns out I didn&apos;t need it anyway <b>🙂</b> Thanks for taking the time.</z><z id="t1624037496" t="orestis Between honeysql queries-as-data and PostgreSQL&apos;s power I can create pivot tables quite easily. Dynamically generate column definitions etc 🙂"><y>#</y><d>2021-06-18</d><h>17:31</h><w>orestis</w>Between honeysql queries-as-data and PostgreSQL&apos;s power I can create pivot tables quite easily. Dynamically generate column definitions etc <b>🙂</b></z><z id="t1624037513" t="seancorfield OK, here it is: dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ] #_=&gt; :cross-join [[[:lateral #_=&gt; [:jsonb_to_recordset :foo.json_value]] #_=&gt; [[:raw &quot;x(id text, value jsonb)&quot;]]]] #_=&gt; :from [:foo]}) [&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)&quot;]"><y>#</y><d>2021-06-18</d><h>17:31</h><w>seancorfield</w>OK, here it is:
<pre>dev=&gt; (sql/format {:select [:foo.id [ :x.id :x_id] :x.value ]
 #_=&gt;    :cross-join [[[:lateral
 #_=&gt;                   [:jsonb_to_recordset :foo.json_value]]
 #_=&gt;                   [[:raw &quot;x(id text, value jsonb)&quot;]]]]
 #_=&gt;    :from [:foo]})
[&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)&quot;]</pre></z><z id="t1624037620" t="seancorfield :cross-join now has a single expression: an alias pair. The first part of that alias pair is [:lateral ..] and the second part is the nested “function call” of [[:raw ..]] ."><y>#</y><d>2021-06-18</d><h>17:33</h><w>seancorfield</w><code>:cross-join</code> now has a single expression: an alias pair. The first part of that alias pair is <code>[:lateral ..]</code> and the second part is the nested “function call” of <code>[[:raw ..]]</code>.</z><z id="t1624037664" t="seancorfield :cross-join [ [expr [AS] alias] ] where [AS] is just intended to show how the aliased expression gets created."><y>#</y><d>2021-06-18</d><h>17:34</h><w>seancorfield</w><code>:cross-join [ [expr [AS] alias] ]</code> where <code>[AS]</code> is just intended to show how the aliased expression gets created.</z><z id="t1624037702" t="orestis Gotcha, I ended up with the same result. I was looking for &quot;lateral&quot; in the docs and found a couple of hits but I I was tired 🙂"><y>#</y><d>2021-06-18</d><h>17:35</h><w>orestis</w>Gotcha, I ended up with the same result. I was looking for &quot;lateral&quot; in the docs and found a couple of hits but I I was tired <b>🙂</b></z><z id="t1624037734" t="orestis BTW, honeysql is CLJC, right? Would be a nice project to put together a webpage that takes a honeysql query on the left and gives you SQL on the right."><y>#</y><d>2021-06-18</d><h>17:35</h><w>orestis</w>BTW, honeysql is CLJC, right? Would be a nice project to put together a webpage that takes a honeysql query on the left and gives you SQL on the right.</z><z id="t1624037774" t="orestis I think malli has something similar with also some persistence that makes it for a nice playground and easier for creating issues and so on..."><y>#</y><d>2021-06-18</d><h>17:36</h><w>orestis</w>I think malli has something similar with also some persistence that makes it for a nice playground and easier for creating issues and so on...</z><z id="t1624037786" t="seancorfield The “problem” is that pretty much any combination of expressions with [ ..`]` is “valid” as far as the DSL is concerned and most of them produce valid SQL with various meanings, but not all of the possible SQL outputs are going to be valid 🙂"><y>#</y><d>2021-06-18</d><h>17:36</h><w>seancorfield</w>The “problem” is that pretty much any combination of expressions with <code>[</code>..`]` is “valid” as far as the DSL is concerned and most of them produce valid SQL with various meanings, but not all of the possible SQL outputs are going to be valid <b>🙂</b></z><z id="t1624037806" t="orestis (hoping someone likes the idea and takes it up, I don&apos;t have time myself 😄 )"><y>#</y><d>2021-06-18</d><h>17:36</h><w>orestis</w>(hoping someone likes the idea and takes it up, I don&apos;t have time myself <b>😄</b>)</z><z id="t1624037826" t="seancorfield I don’t do cljs/frontend at all so it won’t be me either!"><y>#</y><d>2021-06-18</d><h>17:37</h><w>seancorfield</w>I don’t do cljs/frontend at all so it won’t be me either!</z><z id="t1624037866" t="orestis I think that&apos;s a valid tradeoff. SQL is infinitely complicated and getting a DSL able to express all of it correctly while still being data will be impossible."><y>#</y><d>2021-06-18</d><h>17:37</h><w>orestis</w>I think that&apos;s a valid tradeoff. SQL is infinitely complicated and getting a DSL able to express all of it correctly while still being data will be impossible.</z><z id="t1624037922" t="orestis You do end up using the REPL quite a lot during query development, and for the more complex stuff you do have to run the query against a live DB anyway -- but that&apos;s what we do in Clojure anyway 🙂"><y>#</y><d>2021-06-18</d><h>17:38</h><w>orestis</w>You do end up using the REPL quite a lot during query development, and for the more complex stuff you do have to run the query against a live DB anyway -- but that&apos;s what we do in Clojure anyway <b>🙂</b></z><z id="t1624038055" t="seancorfield Yeah, I tend to build my more complex queries up in RCFs with dummy data values, to ensure I’m getting what I want. But I also use MySQL so life is a lot simpler 🙂"><y>#</y><d>2021-06-18</d><h>17:40</h><w>seancorfield</w>Yeah, I tend to build my more complex queries up in RCFs with dummy data values, to ensure I’m getting what I want. But I also use MySQL so life is a lot simpler <b>🙂</b></z><z id="t1624038222" t="orestis RCF?"><y>#</y><d>2021-06-18</d><h>17:43</h><w>orestis</w>RCF?</z><z id="t1624038252" t="seancorfield Rich Comment Form."><y>#</y><d>2021-06-18</d><h>17:44</h><w>seancorfield</w>Rich Comment Form.</z><z id="t1624038276" t="orestis Hehe most of our queries are pretty simple too. But we&apos;re migrating a MongoDB database with an actual valid use case of using schema-less in some areas. And these areas we have to dig into Postgres JSON support which is great but also weird 🙂"><y>#</y><d>2021-06-18</d><h>17:44</h><w>orestis</w>Hehe most of our queries are pretty simple too. But we&apos;re migrating a MongoDB database with an actual valid use case of using schema-less in some areas. And these areas we have to dig into Postgres JSON support which is great but also weird <b>🙂</b></z><z id="t1624038285" t="orestis Ah yes. Same here 🙂"><y>#</y><d>2021-06-18</d><h>17:44</h><w>orestis</w>Ah yes. Same here <b>🙂</b></z><z id="t1624038306" t="seancorfield A name coined by Stu Halloway for (comment ..) forms used while developing/exploring problem solutions — because Rich Hickey does it that way (you can see some such forms at the bottom of some namespaces in Clojure)."><y>#</y><d>2021-06-18</d><h>17:45</h><w>seancorfield</w>A name coined by Stu Halloway for <code>(comment ..)</code> forms used while developing/exploring problem solutions — because Rich Hickey does it that way (you can see some such forms at the bottom of some namespaces in Clojure).</z><z id="t1624038333" t="seancorfield https://github.com/seancorfield/honeysql/issues/332"><y>#</y><d>2021-06-18</d><h>17:45</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/332" target="_blank">https://github.com/seancorfield/honeysql/issues/332</a></z><z id="t1624038750" t="orestis I knew the term but not the acronym 🙂"><y>#</y><d>2021-06-18</d><h>17:52</h><w>orestis</w>I knew the term but not the acronym <b>🙂</b></z><z id="t1624069947" t="john-shaffer [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] https://www.john-shaffer.com/honeysql/"><y>#</y><d>2021-06-19</d><h>02:32</h><w>john-shaffer</w><a>@orestis</a> <a href="https://www.john-shaffer.com/honeysql/" target="_blank">https://www.john-shaffer.com/honeysql/</a></z><z id="t1624069983" t="john-shaffer Very primitive, but works &amp; maybe I&apos;ll have time later to spruce it up"><y>#</y><d>2021-06-19</d><h>02:33</h><w>john-shaffer</w>Very primitive, but works &amp; maybe I&apos;ll have time later to spruce it up</z><z id="t1624070232" t="john-shaffer Know any good syntax/highlighting libs for sql/edn?"><y>#</y><d>2021-06-19</d><h>02:37</h><w>john-shaffer</w>Know any good syntax/highlighting libs for sql/edn?</z><z id="t1624073299" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] That is awesome! 🙂"><y>#</y><d>2021-06-19</d><h>03:28</h><w>seancorfield</w><a>@jshaffer2112</a> That is awesome! <b>🙂</b></z><z id="t1624095587" t="borkdude [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] you could try to integrate nextjournal/clojure-mode: https://nextjournal.github.io/clojure-mode/ also sci for clojure(script) evaluation if you need it."><y>#</y><d>2021-06-19</d><h>09:39</h><w>borkdude</w><a>@jshaffer2112</a> you could try to integrate nextjournal/clojure-mode:
<a href="https://nextjournal.github.io/clojure-mode/" target="_blank">https://nextjournal.github.io/clojure-mode/</a>
also sci for clojure(script) evaluation if you need it.</z><z id="t1624095656" t="borkdude for only highlighting, perhaps highlight.js has sql support"><y>#</y><d>2021-06-19</d><h>09:40</h><w>borkdude</w>for only highlighting, perhaps highlight.js has sql support</z><z id="t1624288626" t="john-shaffer Thanks, those look great. I&apos;m getting married Saturday, but I&apos;ll try those out once things settle down"><y>#</y><d>2021-06-21</d><h>15:17</h><r>john-shaffer</r>Thanks, those look great. I&apos;m getting married Saturday, but I&apos;ll try those out once things settle down</z><z id="t1624288712" t="borkdude Congrats!"><y>#</y><d>2021-06-21</d><h>15:18</h><r>borkdude</r>Congrats!</z><z id="t1624284039" t="borkdude How do I express x is not null in honeysql?"><y>#</y><d>2021-06-21</d><h>14:00</h><w>borkdude</w>How do I express <code>x is not null</code> in honeysql?</z><z id="t1624284070" t="borkdude [:raw &quot;username is not null&quot;] :)"><y>#</y><d>2021-06-21</d><h>14:01</h><w>borkdude</w><pre>[:raw &quot;username is not null&quot;]</pre>
 :)</z><z id="t1624285101" t="john-shaffer [:not= nil :username]"><y>#</y><d>2021-06-21</d><h>14:18</h><w>john-shaffer</w><pre>[:not= nil :username]</pre></z><z id="t1624285729" t="seancorfield dev=&gt; (sql/format {:where [:is-not nil :x]}) [&quot;WHERE x IS NOT NULL&quot;] dev=&gt; (sql/format {:where [:&lt;&gt; nil :x]}) [&quot;WHERE x IS NOT NULL&quot;] dev=&gt; (sql/format {:where [:not= nil :x]}) [&quot;WHERE x IS NOT NULL&quot;]"><y>#</y><d>2021-06-21</d><h>14:28</h><w>seancorfield</w><pre>dev=&gt; (sql/format {:where [:is-not nil :x]})
[&quot;WHERE x IS NOT NULL&quot;]
dev=&gt; (sql/format {:where [:&lt;&gt; nil :x]})
[&quot;WHERE x IS NOT NULL&quot;]
dev=&gt; (sql/format {:where [:not= nil :x]})
[&quot;WHERE x IS NOT NULL&quot;]</pre></z><z id="t1624292857" t="borkdude the possibilities are endless!"><y>#</y><d>2021-06-21</d><h>16:27</h><w>borkdude</w>the possibilities are endless!</z><z id="t1624393896" t="Eric Casteleijn Is there a way to express array_agg(distinct table.field) in honeysql, specifically the distinct there, or do I have to fall back to raw in that case?"><y>#</y><d>2021-06-22</d><h>20:31</h><w>Eric Casteleijn</w>Is there a way to express <code>array_agg(distinct table.field)</code> in honeysql, specifically the <code>distinct</code> there, or do I have to fall back to raw in that case?</z><z id="t1624394374" t="seancorfield [:attrs {:href &quot;/_/_/users/U017RJGHE95&quot;}] If you’re using 2.0.0 RC 3, you can do it like this: dev=&gt; (sql/format-expr [:array_agg [:distinct :table/field]]) [&quot;ARRAY_AGG(DISTINCT table.field)&quot;]"><y>#</y><d>2021-06-22</d><h>20:39</h><w>seancorfield</w><a>@thisfred</a> If you’re using 2.0.0 RC 3, you can do it like this:
<pre>dev=&gt; (sql/format-expr [:array_agg [:distinct :table/field]])
[&quot;ARRAY_AGG(DISTINCT table.field)&quot;]</pre></z><z id="t1624394392" t="Eric Casteleijn Thank you so much!"><y>#</y><d>2021-06-22</d><h>20:39</h><w>Eric Casteleijn</w>Thank you so much!</z><z id="t1624394424" t="seancorfield Or like this in a select: dev=&gt; (sql/format {:select [ [ [:array_agg [:distinct :table/field]] :agg ] ] :from :table}) [&quot;SELECT ARRAY_AGG(DISTINCT table.field) AS agg FROM table&quot;]"><y>#</y><d>2021-06-22</d><h>20:40</h><w>seancorfield</w>Or like this in a select:
<pre>dev=&gt; (sql/format {:select [ [ [:array_agg [:distinct :table/field]] :agg ] ] :from :table})
[&quot;SELECT ARRAY_AGG(DISTINCT table.field) AS agg FROM table&quot;]</pre></z><z id="t1624394427" t="Eric Casteleijn I don’t think we’re on that yet, but I’ll make a note to replace the raw with that as soon as we upgrade"><y>#</y><d>2021-06-22</d><h>20:40</h><w>Eric Casteleijn</w>I don’t think we’re on that yet, but I’ll make a note to replace the raw with that as soon as we upgrade</z><z id="t1624433330" t="orestis Here&apos;s a touch one: Can we use operators that are not valid clojure keywords? Postgresql has some array operators that contain @ , particularly @&gt; and &lt;@"><y>#</y><d>2021-06-23</d><h>07:28</h><w>orestis</w>Here&apos;s a touch one: Can we use operators that are not valid clojure keywords? Postgresql has some array operators that contain <code>@</code> , particularly <code>@&gt;</code> and <code>&lt;@</code></z><z id="t1624450323" t="thumbnail You could use (keyword &quot;&lt;@&quot;) at the very least"><y>#</y><d>2021-06-23</d><h>12:12</h><r>thumbnail</r>You could use <code>(keyword &quot;&lt;@&quot;)</code> at the very least</z><z id="t1624462925" t="seancorfield dev=&gt; (def at&gt; (keyword &quot;@&gt;&quot;)) #&apos;dev/at&gt; dev=&gt; (def &lt;at (keyword &quot;&lt;@&quot;)) #&apos;dev/&lt;at dev=&gt; (sql/register-op! at&gt;) nil dev=&gt; (sql/register-op! &lt;at) nil dev=&gt; (sql/format {:select :* :from :foo :where [:and [at&gt; :a :b] [&lt;at :c :d]]}) [&quot;SELECT * FROM foo WHERE (a @&gt; b) AND (c &lt;@ d)&quot;]"><y>#</y><d>2021-06-23</d><h>15:42</h><r>seancorfield</r><pre>dev=&gt; (def at&gt; (keyword &quot;@&gt;&quot;))
#&apos;dev/at&gt;
dev=&gt; (def &lt;at (keyword &quot;&lt;@&quot;))
#&apos;dev/&lt;at
dev=&gt; (sql/register-op! at&gt;)
nil
dev=&gt; (sql/register-op! &lt;at)
nil
dev=&gt; (sql/format {:select :* :from :foo :where [:and [at&gt; :a :b] [&lt;at :c :d]]})
[&quot;SELECT * FROM foo WHERE (a @&gt; b) AND (c &lt;@ d)&quot;]</pre></z><z id="t1624469140" t="orestis Ah nice. I forgot that you can make keywords which are valid but &quot;unreadable&quot;."><y>#</y><d>2021-06-23</d><h>17:25</h><r>orestis</r>Ah nice. I forgot that you can make keywords which are valid but &quot;unreadable&quot;.</z><z id="t1624469500" t="john-shaffer I do exactly this, but are the warnings on https://clojuredocs.org/clojure.core/keyword still valid? ;; keyword does not validate input strings for ns and name, and may ;; return improper keywords with undefined behavior for non-conformant ;; ns and name. ;; Warning - the following generated keywords are non-conformant and may wreak ;; serious havoc in the near/far future when least expected... iirc undefined === &quot;behavior can change at any time&quot;"><y>#</y><d>2021-06-23</d><h>17:31</h><r>john-shaffer</r>I do exactly this, but are the warnings on <a href="https://clojuredocs.org/clojure.core/keyword" target="_blank">https://clojuredocs.org/clojure.core/keyword</a> still valid?
<pre>;; keyword does not validate input strings for ns and name, and may
;; return improper keywords with undefined behavior for non-conformant
;; ns and name.</pre>
<pre>;; Warning - the following generated keywords are non-conformant and may wreak
;; serious havoc in the near/far future when least expected...</pre>
iirc undefined === &quot;behavior can change at any time&quot;</z><z id="t1624469609" t="john-shaffer I don&apos;t think it&apos;s a big deal here, but I see a lot of places where people e.g. take arbitrary JSON as input and decode with keyword keys, and it seems pretty scary if the result is undefined"><y>#</y><d>2021-06-23</d><h>17:33</h><r>john-shaffer</r>I don&apos;t think it&apos;s a big deal here, but I see a lot of places where people e.g. take arbitrary JSON as input and decode with keyword keys, and it seems pretty scary if the result is undefined</z><z id="t1624469704" t="john-shaffer Should I be a stickler about using string keys, or are keywords actually fine?"><y>#</y><d>2021-06-23</d><h>17:35</h><r>john-shaffer</r>Should I be a stickler about using string keys, or are keywords actually fine?</z><z id="t1624470326" t="seancorfield The core team did at one point try to tighten up what keywords the reader accepted but it broke quite a bit of code out there — so they reverted that change. I think at this point you are “safe” creating unreadable keywords via keyword as long as you don’t actually try to ."><y>#</y><d>2021-06-23</d><h>17:45</h><r>seancorfield</r>The core team did at one point try to tighten up what keywords the reader accepted but it broke quite a bit of code out there — so they reverted that change. I think at this point you are “safe” creating unreadable keywords via <code>keyword</code> as long as you don’t actually try to .</z><z id="t1624470371" t="seancorfield (and, in particular, http://clojuredocs.org is not official documentation so examples and commentary are what random community members think 🙂 )"><y>#</y><d>2021-06-23</d><h>17:46</h><r>seancorfield</r>(and, in particular, <a href="http://clojuredocs.org" target="_blank">http://clojuredocs.org</a> is not official documentation so examples and commentary are what random community members think <b>🙂</b> )</z><z id="t1624641640" t="rlander Hey folks! How do I call a PG stored procedure in HoneySQL v1.0?"><y>#</y><d>2021-06-25</d><h>17:20</h><w>rlander</w>Hey folks! How do I call a PG stored procedure in HoneySQL v1.0?</z><z id="t1624641743" t="rlander In plain SQL it´d be CALL stored_procedure_name(argument_list)"><y>#</y><d>2021-06-25</d><h>17:22</h><w>rlander</w>In plain SQL it´d be <code>CALL stored_procedure_name(argument_list)</code></z><z id="t1624730650" t="seancorfield At the suggestion of [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I have enabled Discussions on GitHub https://github.com/seancorfield/honeysql/discussions (and I now plan to do this for most of my projects)."><y>#</y><d>2021-06-26</d><h>18:04</h><w>seancorfield</w>At the suggestion of <a>@borkdude</a> I have enabled Discussions on GitHub <a href="https://github.com/seancorfield/honeysql/discussions" target="_blank">https://github.com/seancorfield/honeysql/discussions</a> (and I now plan to do this for most of my projects).</z><z id="t1624780013" t="Ilan Uzan I am trying to use :param inside :raw because I have an unsupported SQL clause postgres: (sql/format {:select [:*] :from [:blah] :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]]}) I don&apos;t get where to place the param value - this throws: missing parameter value for :x and what worked in honeysql-1: (sql/format {:select [:*] :from [:blah] :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]] :params {:x 3}}) Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:904). These SQL clauses are unknown or have nil values: :params does not work in honeysql-2..."><y>#</y><d>2021-06-27</d><h>07:46</h><w>Ilan Uzan</w>I am trying to use :param inside :raw because I have an unsupported SQL clause postgres:
<pre>(sql/format {:select [:*]
             :from [:blah]
             :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]]})</pre>
I don&apos;t get where to place the param value - this throws:
<pre>missing parameter value for :x</pre>
and what worked in honeysql-1:
<pre>(sql/format {:select [:*]
             :from [:blah]
             :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]] :params {:x 3}})
Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:904).
These SQL clauses are unknown or have nil values: :params</pre>
does not work in honeysql-2...</z><z id="t1624810390" t="Ilan Uzan nevermind, it works - my code wasn&apos;t doing what I thought it was doing."><y>#</y><d>2021-06-27</d><h>16:13</h><r>Ilan Uzan</r>nevermind, it works - my code wasn&apos;t doing what I thought it was doing.</z><z id="t1624815889" t="seancorfield Just to follow-up on [:attrs {:href &quot;/_/_/users/U01K63EDZ4K&quot;}] ’s post -- this works: dev=&gt; (sql/format {:select [:*] #_=&gt; :from [:blah] #_=&gt; :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]]} #_=&gt; {:params {:x 3}}) [&quot;SELECT * FROM blah WHERE x &gt;&gt;= ?&quot; 3] but it&apos;s easy enough to just register &gt;&gt;= as a new binary operator and use it directly: dev=&gt; (sql/register-op! &apos;&gt;&gt;=) nil dev=&gt; (sql/format {:select [:*] #_=&gt; :from [:blah] #_=&gt; :where [:&gt;&gt;= :x [:param :x]]} #_=&gt; {:params {:x 3}}) [&quot;SELECT * FROM blah WHERE x &gt;&gt;= ?&quot; 3]"><y>#</y><d>2021-06-27</d><h>17:44</h><w>seancorfield</w>Just to follow-up on <a>@ilan800</a>’s post -- this works:
<pre>dev=&gt; (sql/format {:select [:*]
 #_=&gt;              :from [:blah]
 #_=&gt;              :where [:raw [&quot;x &gt;&gt;= &quot; [:param :x]]]}
 #_=&gt;             {:params {:x 3}})
[&quot;SELECT * FROM blah WHERE x &gt;&gt;= ?&quot; 3]</pre>
but it&apos;s easy enough to just register <code>&gt;&gt;=</code> as a new binary operator and use it directly:
<pre>dev=&gt; (sql/register-op! &apos;&gt;&gt;=)
nil
dev=&gt; (sql/format {:select [:*]
 #_=&gt;              :from [:blah]
 #_=&gt;              :where [:&gt;&gt;= :x [:param :x]]}
 #_=&gt;             {:params {:x 3}})
[&quot;SELECT * FROM blah WHERE x &gt;&gt;= ?&quot; 3]</pre></z><z id="t1624865317" t="Ilan Uzan even better! thanks:)"><y>#</y><d>2021-06-28</d><h>07:28</h><r>Ilan Uzan</r>even better! thanks:)</z><z id="t1624945608" t="Krishan V Hey everyone, I am trying to insert 3 new records into two tables at the same time. The first record that goes into Table A looks somewhat like {:id &quot;&quot; :name &quot;&quot;} while the second and third record that goes into Table B looks like {:a_id &quot;&quot; :country_id &quot;&quot;} where a_id is a foreign key constraint. How do I go about creating records through association with honeysql? Is there a reading or somewhere in the docs where I can try to self-serve from?"><y>#</y><d>2021-06-29</d><h>05:46</h><w>Krishan V</w>Hey everyone, I am trying to insert 3 new records into two tables at the same time. The first record that goes into Table A looks somewhat like <code>{:id &quot;&quot; :name &quot;&quot;}</code>  while the second and third record that goes into Table B looks like <code>{:a_id &quot;&quot; :country_id &quot;&quot;}</code> where <code>a_id</code>  is a foreign key constraint.

How do I go about creating records through association with honeysql? Is there a reading or somewhere in the docs where I can try to self-serve from?</z><z id="t1624946539" t="seancorfield [:attrs {:href &quot;/_/_/users/U01V7GEU89J&quot;}] I&apos;m afraid I don&apos;t understand what you&apos;re trying to do... HoneySQL is just a DSL to create SQL from Clojure data structures so if you don&apos;t know what the SQL should be, we&apos;re not going to be able to help you figure out what the DSL should be."><y>#</y><d>2021-06-29</d><h>06:02</h><w>seancorfield</w><a>@krishanvj</a> I&apos;m afraid I don&apos;t understand what you&apos;re trying to do... HoneySQL is just a DSL to create SQL from Clojure data structures so if you don&apos;t know what the SQL should be, we&apos;re not going to be able to help you figure out what the DSL should be.</z><z id="t1624956570" t="Krishan V I see, I&apos;ll have to shake off my ORM habits. I&apos;ve decided to go with separate insert statements and have resolved this issue. Thanks anyways!"><y>#</y><d>2021-06-29</d><h>08:49</h><r>Krishan V</r>I see, I&apos;ll have to shake off my ORM habits. I&apos;ve decided to go with separate insert statements and have resolved this issue. Thanks anyways!</z><z id="t1624993701" t="seancorfield https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/ 🙂"><y>#</y><d>2021-06-29</d><h>19:08</h><r>seancorfield</r><a href="https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/" target="_blank">https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/</a> <b>🙂</b></z><z id="t1625218027" t="Krishan V What would the DSL look like if my raw SQL were to look like this? INSERT INTO profiles_to_countries (profile_id, country_id) SELECT &apos;04d6b414-2163-476d-8d20-91f918f63045&apos;, c.id FROM countries c WHERE c.region = &apos;Africa&apos; My select statement returns a list of values which are them inserted in a join table. My incomplete statement is somewhat like this. I am unsure how the c.id bit would translate to the DSL (-&gt; (sqlh/insert-into :profiles_to_countries) (sqlh/select [(:profiles_id m) ()]) (sql/format))"><y>#</y><d>2021-07-02</d><h>09:27</h><w>Krishan V</w>What would the DSL look like if my raw SQL were to look like this?

<pre>INSERT INTO profiles_to_countries (profile_id, country_id)
SELECT &apos;04d6b414-2163-476d-8d20-91f918f63045&apos;, c.id 
FROM countries c 
WHERE c.region = &apos;Africa&apos;</pre>
My select statement returns a list of values which are them inserted in a join table. My incomplete statement is somewhat like this. I am unsure how the <code>c.id</code> bit would translate to the DSL
<pre>(-&gt;
  (sqlh/insert-into :profiles_to_countries)
  (sqlh/select [(:profiles_id m) ()])
  (sql/format))</pre></z><z id="t1625239589" t="seancorfield [:attrs {:href &quot;/_/_/users/U01V7GEU89J&quot;}] There are examples of this in the docs https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#insert-into"><y>#</y><d>2021-07-02</d><h>15:26</h><w>seancorfield</w><a>@krishanvj</a> There are examples of this in the docs <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#insert-into" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#insert-into</a></z><z id="t1625458333" t="Krishan V Thanks! [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] . Is it possible to interpolate variables directly into the SQL statement rather than using bindings with HoneySQL? e.g: INSERT INTO profile (name, age) VALUES (&quot;John Doe&quot;, &quot;30&quot;) instead of INSERT INTO profile (name, age) VALUES (?, ?) My intention is to generate an SQL file which I can use for an up.sql migration script."><y>#</y><d>2021-07-05</d><h>04:12</h><r>Krishan V</r>Thanks! <a>@U04V70XH6</a>. Is it possible to interpolate variables directly into the SQL statement rather than using bindings with HoneySQL? e.g:

<code>INSERT INTO profile (name, age) VALUES (&quot;John Doe&quot;, &quot;30&quot;)</code>
instead of
<code>INSERT INTO profile (name, age) VALUES (?, ?)</code>

My intention is to generate an SQL file which I can use for an <code>up.sql</code> migration script.</z><z id="t1625458785" t="Krishan V Nevermind, I just found out about the :inline true option in format Loving this library, thank you so much for making this possible! [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2021-07-05</d><h>04:19</h><r>Krishan V</r>Nevermind, I just found out about the <code>:inline true</code> option in <code>format</code> Loving this library, thank you so much for making this possible! <a>@U04V70XH6</a></z><z id="t1625774009" t="mjosefs Hi there! I’m wondering if there’s any way to access a composite type (as in https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-ACCESSING ) with honeysql? Re the linked example: as I’m not able to use :(item).name , is there any alternative way to express (item).name ? (I could only find how to compose a composite type in the docs; any way to decompose it would be useful.)"><y>#</y><d>2021-07-08</d><h>19:53</h><w>mjosefs</w>Hi there! I’m wondering if there’s any way to access a composite type (as in <a href="https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-ACCESSING" target="_blank">https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-ACCESSING</a> ) with honeysql? Re the linked example: as I’m not able to use <code>:(item).name</code>, is there any alternative way to express <code>(item).name</code>? (I could only find how to compose a composite type in the docs; any way to decompose it would be useful.)</z><z id="t1625781297" t="seancorfield I suspect (keyword &quot;(item)&quot; &quot;name&quot;) would work (but that&apos;s pretty ugly). I&apos;d probably define :. as special syntax: dev=&gt; (sql/register-fn! :. (fn [_ [x y]] [(str &quot;(&quot; (sql/format-entity x) &quot;).&quot; (sql/format-entity y))])) ... dev=&gt; (sql/format-expr [:. :item :name]) [&quot;(item).name&quot;] Maybe (sql/format-expr x) if that can be an expression -- but that returns [sql &amp; params] so you&apos;d need a more complex formatted..."><y>#</y><d>2021-07-08</d><h>21:54</h><w>seancorfield</w>I suspect <code>(keyword &quot;(item)&quot; &quot;name&quot;)</code> would work (but that&apos;s pretty ugly). I&apos;d probably define <code>:.</code> as special syntax:
<pre>dev=&gt; (sql/register-fn! :. (fn [_ [x y]] [(str &quot;(&quot; (sql/format-entity x) &quot;).&quot; (sql/format-entity y))]))
...
dev=&gt; (sql/format-expr [:. :item :name])
[&quot;(item).name&quot;]</pre>
Maybe <code>(sql/format-expr x)</code> if that can be an expression -- but that returns <code>[sql &amp; params]</code> so you&apos;d need a more complex formatted...</z><z id="t1625781307" t="seancorfield [:attrs {:href &quot;/_/_/users/U0177ARBSJZ&quot;}] ☝️ :skin-tone-2: Does that help?"><y>#</y><d>2021-07-08</d><h>21:55</h><w>seancorfield</w><a>@marcus.josefsson</a> <b>☝️</b><b>:skin-tone-2:</b> Does that help?</z><z id="t1625822052" t="mjosefs It does - many thanks for the help!"><y>#</y><d>2021-07-09</d><h>09:14</h><r>mjosefs</r>It does - many thanks for the help!</z><z id="t1625797454" t="pinealan I’m trying to use honeysql to format an insert Prepared Statement with next.jdbc/execute-batch! , how that seems not possible since honey.sql needs all the values up front to format the sql string appropriately, and I’m stuck using next.jdbc/execute! . Are there idioms that I’m missing which would make things easier? Should I even be concerned with using execute-batch! ?"><y>#</y><d>2021-07-09</d><h>02:24</h><w>pinealan</w>I’m trying to use honeysql to format an insert Prepared Statement with <code>next.jdbc/execute-batch!</code>, how that seems not possible since honey.sql needs all the values up front to format the sql string appropriately, and I’m stuck using <code>next.jdbc/execute!</code>. Are there idioms that I’m missing which would make things easier? Should I even be concerned with using <code>execute-batch!</code>?</z><z id="t1625798597" t="seancorfield execute-batch! exists for a very specific purpose, namely &quot;repeating&quot; the same statement -- typically an insert -- with lots (and often LOTS) of groups of parameters."><y>#</y><d>2021-07-09</d><h>02:43</h><w>seancorfield</w><code>execute-batch!</code> exists for a very specific purpose, namely &quot;repeating&quot; the same statement -- typically an insert -- with lots (and often LOTS) of groups of parameters.</z><z id="t1625798640" t="seancorfield HoneySQL is designed to help you programmatically create single SQL statements with a (single) group of parameters."><y>#</y><d>2021-07-09</d><h>02:44</h><w>seancorfield</w>HoneySQL is designed to help you programmatically create single SQL statements with a (single) group of parameters.</z><z id="t1625798704" t="seancorfield [:attrs {:href &quot;/_/_/users/U0112ACBNRM&quot;}] Does that help?"><y>#</y><d>2021-07-09</d><h>02:45</h><w>seancorfield</w><a>@achan961117</a> Does that help?</z><z id="t1625810703" t="pinealan thanks ya I think I can stick with honeysql and use partition with doseq and achieve a similar factor of optimisation"><y>#</y><d>2021-07-09</d><h>06:05</h><r>pinealan</r>thanks ya I think I can stick with honeysql and use <code>partition</code> with <code>doseq</code> and achieve a similar factor of optimisation</z><z id="t1626094828" t="zackteo Hello, may I know if there is a good way to changed the namespaced keywords (based on the table) to normal keywords in honeysql? Am thinking it is removing the namespace part is better when I pass the resulting sql result to my frontend. I know I can do something like ... (zipmap (map (comp keyword name) (keys sql-result)) (vals sql-result)) do i just do that?"><y>#</y><d>2021-07-12</d><h>13:00</h><w>zackteo</w>Hello, may I know if there is a good way to changed the namespaced keywords (based on the table) to normal keywords in honeysql? Am thinking it is removing the namespace part is better when I pass the resulting sql result to my frontend.
I know I can do something like ...
<pre>(zipmap (map (comp keyword name)
               (keys sql-result)) (vals sql-result))</pre>
do i just do that?</z><z id="t1626103784" t="thumbnail There might be a better way; but aliases don’t get a namespace. So if you {:select [[[:user/id] :my_id]]} ; it returns :user/id as :my_id"><y>#</y><d>2021-07-12</d><h>15:29</h><r>thumbnail</r>There might be a better way; but aliases don’t get a namespace. So if you <code>{:select [[[:user/id] :my_id]]}</code>; it returns :user/id as :my_id</z><z id="t1626114405" t="seancorfield [:attrs {:href &quot;/_/_/users/UUSQHP535&quot;}] I don&apos;t understand the context of this question. What perceived problem are you trying to solve? I&apos;ve never needed to do anything like this."><y>#</y><d>2021-07-12</d><h>18:26</h><r>seancorfield</r><a>@UUSQHP535</a> I don&apos;t understand the context of this question. What perceived problem are you trying to solve? I&apos;ve never needed to do anything like this.</z><z id="t1626231657" t="zackteo [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I was thinking of renaming/removing the namespace from the keywords. So that my frontend doesn&apos;t need to know in which database table the column of data comes from"><y>#</y><d>2021-07-14</d><h>03:00</h><r>zackteo</r><a>@U04V70XH6</a> I was thinking of renaming/removing the namespace from the keywords. So that my frontend doesn&apos;t need to know in which database table the column of data comes from</z><z id="t1626231811" t="seancorfield I&apos;m not sure what that has to do with HoneySQL? You use HoneySQL to generate SQL that you then pass to a JDBC library (by which point namespaced keywords have been processed/removed)."><y>#</y><d>2021-07-14</d><h>03:03</h><r>seancorfield</r>I&apos;m not sure what that has to do with HoneySQL? You use HoneySQL to generate SQL that you then pass to a JDBC library (by which point namespaced keywords have been processed/removed).</z><z id="t1626231833" t="seancorfield The JDBC library might give you back namespace-qualified keywords but that has nothing to do with HoneySQL."><y>#</y><d>2021-07-14</d><h>03:03</h><r>seancorfield</r>The JDBC library might give you back namespace-qualified keywords but that has nothing to do with HoneySQL.</z><z id="t1626231956" t="seancorfield You can tell the JDBC library to not qualify column names -- but my recommendation would be to allow that and to have a transformation at the boundary where you pass data back to the frontend: I would argue that in general the over-the-wire data you send from the backend to the frontend should be a specific API (that suits the client) and should not just be an exact copy of the data model used inside your backend."><y>#</y><d>2021-07-14</d><h>03:05</h><r>seancorfield</r>You can tell the JDBC library to not qualify column names -- but my recommendation would be to allow that and to have a transformation at the boundary where you pass data back to the frontend: I would argue that in general the over-the-wire data you send from the backend to the frontend should be a specific API (that suits the client) and should not just be an exact copy of the data model used inside your backend.</z><z id="t1626232110" t="seancorfield In my handler function, which returns data to the API, I would probably either destructure the data to extract just the fields the API needs (and give them appropriate &quot;API&quot; names) or use a combination of select-keys and clojure.set/rename-keys to produce an appropriately named data structure for the client."><y>#</y><d>2021-07-14</d><h>03:08</h><r>seancorfield</r>In my handler function, which returns data to the API, I would probably either destructure the data to extract just the fields the API needs (and give them appropriate &quot;API&quot; names) or use a combination of <code>select-keys</code> and <code>clojure.set/rename-keys</code> to produce an appropriately named data structure for the client.</z><z id="t1626232156" t="seancorfield This isolates your frontend code from any changes in your data model -- and also allows for your frontend/API to change independently of your data model."><y>#</y><d>2021-07-14</d><h>03:09</h><r>seancorfield</r>This isolates your frontend code from any changes in your data model -- and also allows for your frontend/API to change independently of your data model.</z><z id="t1626232219" t="seancorfield The data structures going back and forth between your API and your client are a good candidate for validation with Spec (using :req-un /`:opt-un` keys)."><y>#</y><d>2021-07-14</d><h>03:10</h><r>seancorfield</r>The data structures going back and forth between your API and your client are a good candidate for validation with Spec (using <code>:req-un</code>/`:opt-un` keys).</z><z id="t1626238253" t="zackteo oops, yeah you are right, this is a next.JDBC. Was getting things mixed up because was concurrently thinking if i should be renaming it with :as in sql"><y>#</y><d>2021-07-14</d><h>04:50</h><r>zackteo</r>oops, yeah you are right, this is a next.JDBC. Was getting things mixed up because was concurrently thinking if i should be renaming it with <code>:as</code> in sql</z><z id="t1626238310" t="zackteo Thanks for your advice! Let me try to implement what you explained"><y>#</y><d>2021-07-14</d><h>04:51</h><r>zackteo</r>Thanks for your advice! Let me try to implement what you explained</z><z id="t1626113492" t="borkdude does honeysql support this syntax in do-update-set? ;; do update set (docdata_user_id, docdata_client_id, profile, last_login, _updated, login_count) = ;; (:docdata_user_id, :docdata_client_id, excluded.profile, now()::timestamp, now()::timestamp, users.login_count + 1) "><y>#</y><d>2021-07-12</d><h>18:11</h><w>borkdude</w>does honeysql support this syntax in do-update-set?
<pre>;; do update set (docdata_user_id, docdata_client_id, profile, last_login, _updated, login_count) =
;; (:docdata_user_id, :docdata_client_id, excluded.profile, now()::timestamp, now()::timestamp, users.login_count + 1)</pre>
</z><z id="t1626113503" t="borkdude so set (x,y,z) = (foo,bar,baz)?"><y>#</y><d>2021-07-12</d><h>18:11</h><w>borkdude</w>so set (x,y,z) = (foo,bar,baz)?</z><z id="t1626113513" t="borkdude I&apos;m trying to convert a hugsql query"><y>#</y><d>2021-07-12</d><h>18:11</h><w>borkdude</w>I&apos;m trying to convert a hugsql query</z><z id="t1626114741" t="seancorfield [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I don&apos;t think you can do a composite set like that, but you can specify a hash map of columns/values that it will set: :do-update-set {:docdata_user_id :docdata_user_id, :docdata_client_id :docdata_client_id, :profile :excluded.profile, :last_login ..., :_updated ..., :login_count [:+ :users.login_count 1]}"><y>#</y><d>2021-07-12</d><h>18:32</h><w>seancorfield</w><a>@borkdude</a> I don&apos;t think you can do a composite <code>set</code> like that, but you can specify a hash map of columns/values that it will set: <code>:do-update-set {:docdata_user_id :docdata_user_id, :docdata_client_id :docdata_client_id, :profile :excluded.profile, :last_login ..., :_updated ..., :login_count [:+ :users.login_count 1]}</code></z><z id="t1626114770" t="borkdude oh that&apos;s equally good"><y>#</y><d>2021-07-12</d><h>18:32</h><w>borkdude</w>oh that&apos;s equally good</z><z id="t1626114789" t="seancorfield (I&apos;m not quite sure what the best way to write the cast syntax is [:cast [:now] :timestamp] would probably work)"><y>#</y><d>2021-07-12</d><h>18:33</h><w>seancorfield</w>(I&apos;m not quite sure what the best way to write the cast syntax is <code>[:cast [:now] :timestamp]</code> would probably work)</z><z id="t1626114797" t="borkdude I don&apos;t care about the SQL it generates, as long as it&apos;s the thing that&apos;s semantically the same"><y>#</y><d>2021-07-12</d><h>18:33</h><w>borkdude</w>I don&apos;t care about the SQL it generates, as long as it&apos;s the thing that&apos;s semantically the same</z><z id="t1626114814" t="borkdude yeah, I can always do a :raw for that as well"><y>#</y><d>2021-07-12</d><h>18:33</h><w>borkdude</w>yeah, I can always do a <code>:raw</code> for that as well</z><z id="t1626114821" t="borkdude thanks!"><y>#</y><d>2021-07-12</d><h>18:33</h><w>borkdude</w>thanks!</z><z id="t1626114968" t="seancorfield The docs have an example of :do-update-set with a hash map BTW"><y>#</y><d>2021-07-12</d><h>18:36</h><w>seancorfield</w>The docs have an example of <code>:do-update-set</code> with a hash map BTW</z><z id="t1626114984" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set"><y>#</y><d>2021-07-12</d><h>18:36</h><w>seancorfield</w><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc3/doc/getting-started/sql-clause-reference#on-conflict-on-constraint-do-nothing-do-update-set</a></z><z id="t1626550421" t="Daniel Hugh 👋 Hi, I am using honeysql version 2.0.0-rc3 and seem to have encountered a couple bugs with the :fetch clause. 1. clj꞉user꞉&gt;  (require &apos;[honey.sql :as sql]) nil clj꞉user꞉&gt;  (sql/format {:select [:id :name] :from [:table] :offset 20 :fetch 10}) [&quot;SELECT id, name FROM table OFFSET ? FETCH ?&quot; 20 10] According to the second example in https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch we are missing the ONLY term ;; expected return [&quot;SELECT id, name FROM table OFFSET ? FETCH ? ONLY&quot; 20 10] 2. clj꞉user꞉&gt;  (require &apos;[honey.sql.helpers :as h]) nil clj꞉user꞉&gt;  (h/fetch 10) {:offset 10} clj꞉user꞉&gt;  Should the map returned contain the :fetch key instead of the :offset key?"><y>#</y><d>2021-07-17</d><h>19:33</h><w>Daniel Hugh</w><b>👋</b> Hi, I am using honeysql version 2.0.0-rc3 and seem to have encountered a couple bugs with the <code>:fetch</code> clause.

1.
<pre>clj꞉user꞉&gt; 
(require &apos;[honey.sql :as sql])
nil
clj꞉user꞉&gt; 
(sql/format {:select [:id :name]
             :from [:table]
             :offset 20 :fetch 10})
[&quot;SELECT id, name FROM table OFFSET ? FETCH ?&quot; 20 10]</pre>
According to the second example in <a href="https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch</a> we are missing the <code>ONLY</code> term

<pre>;; expected return
[&quot;SELECT id, name FROM table OFFSET ? FETCH ? ONLY&quot; 20 10]</pre>
2.
<pre>clj꞉user꞉&gt; 
(require &apos;[honey.sql.helpers :as h])
nil
clj꞉user꞉&gt; 
(h/fetch 10)
{:offset 10}
clj꞉user꞉&gt; </pre>
Should the map returned contain the <code>:fetch</code> key instead of the <code>:offset</code> key?</z><z id="t1626551317" t="seancorfield [:attrs {:href &quot;/_/_/users/U018NSFJZSL&quot;}] Is it actually syntactically illegal for the JDBC driver you&apos;re using?"><y>#</y><d>2021-07-17</d><h>19:48</h><w>seancorfield</w><a>@daniel_hugh</a> Is it actually syntactically illegal for the JDBC driver you&apos;re using?</z><z id="t1626559173" t="Daniel Hugh Yes it appears to be illegal. I am using a JDBC driver for Microsoft SQL Server and it looks like it requires the ONLY term according to the syntax docs https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql?view=sql-server-ver15 EDIT: Actually in my case, FETCH ? ONLY isn&apos;t enough 😞 I would need something like FETCH NEXT 20 ROWS ONLY with terms like NEXT and ROWS like described in this old issue https://github.com/seancorfield/honeysql/issues/58 So it looks like I will need to create a custom clause."><y>#</y><d>2021-07-17</d><h>21:59</h><r>Daniel Hugh</r>Yes it appears to be illegal. I am using a JDBC driver for Microsoft SQL Server and it looks like it requires the <code>ONLY</code> term according to the syntax docs <a href="https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql?view=sql-server-ver15" target="_blank">https://docs.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql?view=sql-server-ver15</a>

EDIT: Actually in my case, <code>FETCH ? ONLY</code> isn&apos;t enough <b>😞</b> I would need something like <code>FETCH NEXT 20 ROWS ONLY</code> with terms like <code>NEXT</code> and <code>ROWS</code> like described in this old issue <a href="https://github.com/seancorfield/honeysql/issues/58" target="_blank">https://github.com/seancorfield/honeysql/issues/58</a>

So it looks like I will need to create a custom clause.</z><z id="t1626566372" t="seancorfield Darn, I thought bits were optional. Sigh. I suspect OFFSET also needs ROW or ROWS for SQL Server? I&apos;ll have to do that based on dialect because MySQL can&apos;t have ROWS there. PostgreSQL can have OFFSET n or OFFSET n ROWS (of course it can!). And it can either have LIMIT n (like MySQL) or FETCH FIRST n ROWS ONLY (FIRST/NEXT are synonyms, ROW/ROWS are synonyms)."><y>#</y><d>2021-07-17</d><h>23:59</h><r>seancorfield</r>Darn, I thought bits were optional. Sigh. I suspect <code>OFFSET</code> also needs <code>ROW</code> or <code>ROWS</code> for SQL Server? I&apos;ll have to do that based on dialect because MySQL can&apos;t have <code>ROWS</code> there. PostgreSQL can have <code>OFFSET n</code> or <code>OFFSET n ROWS</code> (of course it can!). And it can either have <code>LIMIT n</code> (like MySQL) or <code>FETCH FIRST n ROWS ONLY</code> (FIRST/NEXT are synonyms, ROW/ROWS are synonyms).</z><z id="t1626566675" t="Daniel Hugh Yep seems like that is the case for OFFSET in SQL Server. What an interesting standard we have for SQL haha"><y>#</y><d>2021-07-18</d><h>00:04</h><r>Daniel Hugh</r>Yep seems like that is the case for OFFSET in SQL Server. What an interesting standard we have for SQL haha</z><z id="t1626569633" t="seancorfield Are you specifying :sqlserver as your dialect, BTW?"><y>#</y><d>2021-07-18</d><h>00:53</h><r>seancorfield</r>Are you specifying <code>:sqlserver</code> as your dialect, BTW?</z><z id="t1626569739" t="seancorfield I&apos;m going to set it up so if there&apos;s :offset and :fetch it will use this verbose style, if there&apos;s :offset and :limit it will use the abbreviated style, and if there&apos;s :offset on its own, it will only use the verbose style for the :sqlserver dialect -- which I think is the only way to not introduce breaking behavior."><y>#</y><d>2021-07-18</d><h>00:55</h><r>seancorfield</r>I&apos;m going to set it up so if there&apos;s <code>:offset</code> and <code>:fetch</code> it will use this verbose style, if there&apos;s <code>:offset</code> and <code>:limit</code> it will use the abbreviated style, and if there&apos;s <code>:offset</code> on its own, it will only use the verbose style for the <code>:sqlserver</code> dialect -- which I think is the only way to not introduce breaking behavior.</z><z id="t1626569778" t="Daniel Hugh No i am not currently using the dialect option"><y>#</y><d>2021-07-18</d><h>00:56</h><r>Daniel Hugh</r>No i am not currently using the dialect option</z><z id="t1626570021" t="Daniel Hugh I think that will work for my use case. The query I have uses both :offset and :fetch"><y>#</y><d>2021-07-18</d><h>01:00</h><r>Daniel Hugh</r>I think that will work for my use case. The query I have uses both :offset and :fetch</z><z id="t1626570239" t="seancorfield [:attrs {:href &quot;/_/_/users/U018NSFJZSL&quot;}] OK, 2.0.0-rc5 is available on Clojars. Can you try it out and let me know if it works for you?"><y>#</y><d>2021-07-18</d><h>01:03</h><r>seancorfield</r><a>@daniel_hugh</a> OK, 2.0.0-rc5 is available on Clojars. Can you try it out and let me know if it works for you?</z><z id="t1626570255" t="seancorfield Once I get the all-clear from you, I&apos;ll go ahead and actually announce that RC 🙂"><y>#</y><d>2021-07-18</d><h>01:04</h><r>seancorfield</r>Once I get the all-clear from you, I&apos;ll go ahead and actually announce that RC <b>🙂</b></z><z id="t1626570365" t="Daniel Hugh Sure thing. Let me get on a computer"><y>#</y><d>2021-07-18</d><h>01:06</h><r>Daniel Hugh</r>Sure thing. Let me get on a computer</z><z id="t1626571024" t="Daniel Hugh Great! That works for me 🙂 Thanks for implementing this so quickly 😄"><y>#</y><d>2021-07-18</d><h>01:17</h><r>Daniel Hugh</r>Great! That works for me <b>🙂</b> Thanks for implementing this so quickly <b>😄</b></z><z id="t1626571294" t="seancorfield Thank you for catching this before I got to &quot;gold&quot;!"><y>#</y><d>2021-07-18</d><h>01:21</h><r>seancorfield</r>Thank you for catching this before I got to &quot;gold&quot;!</z><z id="t1626572111" t="Daniel Hugh Oh yeah, I suppose the original example that started this all would need to be updated as well with the verbose style. https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch (sql/format {:select [:id :name] :from [:table] :offset 20 :fetch 10}) [&quot;SELECT id, name FROM table OFFSET ? ROWS FETCH NEXT ? ROWS ONLY&quot; 20 10]"><y>#</y><d>2021-07-18</d><h>01:35</h><r>Daniel Hugh</r>Oh yeah, I suppose the original example that started this all would need to be updated as well with the verbose style.

<a href="https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#limit-offset-fetch</a>

<pre>(sql/format {:select [:id :name]
             :from [:table]
             :offset 20 :fetch 10})

[&quot;SELECT id, name FROM table OFFSET ? ROWS FETCH NEXT ? ROWS ONLY&quot; 20 10]</pre></z><z id="t1626572368" t="seancorfield Yeah, I&apos;ll be polishing the docs a lot over the next two weeks. I&apos;ll get that updated this evening (although it won&apos;t make the cljdoc version until the &quot;gold&quot; release)."><y>#</y><d>2021-07-18</d><h>01:39</h><r>seancorfield</r>Yeah, I&apos;ll be polishing the docs a lot over the next two weeks. I&apos;ll get that updated this evening (although it won&apos;t make the cljdoc version until the &quot;gold&quot; release).</z><z id="t1626572997" t="seancorfield OK, that section is updated. Please take a look and let me know if there are any improvements you can think of..."><y>#</y><d>2021-07-18</d><h>01:49</h><r>seancorfield</r>OK, that section is updated. Please take a look and let me know if there are any improvements you can think of...</z><z id="t1626573637" t="Daniel Hugh Looks good. I don&apos;t have any suggestions at the moment, but will let you know if anything comes up 🙂"><y>#</y><d>2021-07-18</d><h>02:00</h><r>Daniel Hugh</r>Looks good. I don&apos;t have any suggestions at the moment, but will let you know if anything comes up <b>🙂</b></z><z id="t1626551504" t="seancorfield It&apos;s definitely a bug. I don&apos;t have a test for it, apparently 😞"><y>#</y><d>2021-07-17</d><h>19:51</h><w>seancorfield</w>It&apos;s definitely a bug. I don&apos;t have a test for it, apparently <b>😞</b></z><z id="t1626554090" t="seancorfield https://github.com/seancorfield/honeysql/issues/338 -- it&apos;s fixed on develop now [:attrs {:href &quot;/_/_/users/U018NSFJZSL&quot;}]"><y>#</y><d>2021-07-17</d><h>20:34</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/338" target="_blank">https://github.com/seancorfield/honeysql/issues/338</a> -- it&apos;s fixed on develop now <a>@daniel_hugh</a></z><z id="t1626559211" t="Daniel Hugh thanks! 🙂"><y>#</y><d>2021-07-17</d><h>22:00</h><r>Daniel Hugh</r>thanks! <b>🙂</b></z><z id="t1626559627" t="Daniel Hugh By the way, I am not not sure if you caught the second issue in my original post about the fetch helper. clj꞉user꞉&gt;  (require &apos;[honey.sql.helpers :as h]) nil clj꞉user꞉&gt;  (h/fetch 10) {:offset 10} clj꞉user꞉&gt;  Should the map returned contain the `:fetch` key instead of the `:offset` key?"><y>#</y><d>2021-07-17</d><h>22:07</h><r>Daniel Hugh</r>By the way, I am not not sure if you caught the second issue in my original post about the <code>fetch</code> helper.

<pre>clj꞉user꞉&gt; 
(require &apos;[honey.sql.helpers :as h])
nil
clj꞉user꞉&gt; 
(h/fetch 10)
{:offset 10}
clj꞉user꞉&gt; </pre>
Should the map returned contain the `:fetch` key instead of the `:offset` key?</z><z id="t1626565829" t="seancorfield I did not see that, no, sorry."><y>#</y><d>2021-07-17</d><h>23:50</h><r>seancorfield</r>I did not see that, no, sorry.</z><z id="t1626565941" t="seancorfield OK, that&apos;s fixed on develop."><y>#</y><d>2021-07-17</d><h>23:52</h><r>seancorfield</r>OK, that&apos;s fixed on develop.</z><z id="t1626572156" t="seancorfield OK, com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-rc5&quot;} -- https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc5 -- fixes :fetch /`:offset` for SQL Server (and ANSI/PostgreSQL too), fixes the fetch helper and the with-columns helper, improve error reporting when an entity is required but something else if provided, improves the :cross-join documentation. This should be the last RC and 2.0.&lt;commits&gt; will be the &quot;gold&quot; version arriving at the end of the month!"><y>#</y><d>2021-07-18</d><h>01:35</h><w>seancorfield</w>OK, <code>com.github.seancorfield/honeysql {:mvn/version &quot;2.0.0-rc5&quot;}</code> -- <a href="https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc5" target="_blank">https://github.com/seancorfield/honeysql/releases/tag/v2.0.0-rc5</a> -- fixes <code>:fetch</code>/`:offset` for SQL Server (and ANSI/PostgreSQL too), fixes the <code>fetch</code> helper and the <code>with-columns</code> helper, improve error reporting when an entity is required but something else if provided, improves the <code>:cross-join</code> documentation. This should be the last RC and 2.0.&lt;commits&gt; will be the &quot;gold&quot; version arriving at the end of the month!</z><z id="t1626707118" t="john-shaffer Why 2.0.&lt;commits&gt;?"><y>#</y><d>2021-07-19</d><h>15:05</h><w>john-shaffer</w>Why 2.0.&lt;commits&gt;?</z><z id="t1626708581" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] All my projects follow MAJOR.MINOR.COMMITS these days -- same as many of the Clojure tools. I think it&apos;s a better model than SemVer."><y>#</y><d>2021-07-19</d><h>15:29</h><w>seancorfield</w><a>@jshaffer2112</a> All my projects follow MAJOR.MINOR.COMMITS these days -- same as many of the Clojure tools. I think it&apos;s a better model than SemVer.</z><z id="t1626708630" t="seancorfield Per the HoneySQL README: &gt; Once the prerelease testing is complete, this project will follow the version scheme MAJOR.MINOR.COMMITS where MAJOR and MINOR provide some relative indication of the size of the change, but do not follow semantic versioning. In general, all changes endeavor to be non-breaking (by moving to new names rather than by breaking existing names). COMMITS is an ever-increasing counter of commits since the beginning of this repository."><y>#</y><d>2021-07-19</d><h>15:30</h><w>seancorfield</w>Per the HoneySQL README:

&gt; Once the prerelease testing is complete, this project will follow the version scheme MAJOR.MINOR.COMMITS where MAJOR and MINOR provide some relative indication of the size of the change, but do not follow semantic versioning. In general, all changes endeavor to be non-breaking (by moving to new names rather than by breaking existing names). COMMITS is an ever-increasing counter of commits since the beginning of this repository.</z><z id="t1626709364" t="john-shaffer Why the commits counter though, as opposed to incrementing by one? It seems like a very considered choice, but I haven&apos;t found any explanation of the reasoning behind it"><y>#</y><d>2021-07-19</d><h>15:42</h><w>john-shaffer</w>Why the commits counter though, as opposed to incrementing by one? It seems like a very considered choice, but I haven&apos;t found any explanation of the reasoning behind it</z><z id="t1626713921" t="seancorfield The commit counter is easy to base a version on programmatically -- tools.build has a built-in function for that -- and it gives a sense of how much change has occurred between two releases. It also makes it clear you&apos;re not using SemVer (which just incrementing the patch slot would look like)."><y>#</y><d>2021-07-19</d><h>16:58</h><w>seancorfield</w>The commit counter is easy to base a version on programmatically -- <code>tools.build</code> has a built-in function for that -- and it gives a sense of how much change has occurred between two releases. It also makes it clear you&apos;re not using SemVer (which just incrementing the patch slot would look like).</z><z id="t1626713991" t="seancorfield The Clojure CLI, tools.deps.alpha , and several other libraries have all adopted this so I think it&apos;s a good model to follow."><y>#</y><d>2021-07-19</d><h>16:59</h><w>seancorfield</w>The Clojure CLI, <code>tools.deps.alpha</code>, and several other libraries have all adopted this so I think it&apos;s a good model to follow.</z><z id="t1626717095" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] Alex told me &quot;commits is a meaningful, monotonically-increasing, quantitative description of version over time. major.minor is a subjective, human oriented description of version. Combined, you get both.&quot;"><y>#</y><d>2021-07-19</d><h>17:51</h><w>seancorfield</w><a>@jshaffer2112</a> Alex told me &quot;commits is a meaningful, monotonically-increasing, quantitative description of version over time. major.minor is a subjective, human oriented description of version. Combined, you get both.&quot;</z><z id="t1626717108" t="seancorfield (and I agree 🙂 )"><y>#</y><d>2021-07-19</d><h>17:51</h><w>seancorfield</w>(and I agree <b>🙂</b> )</z><z id="t1626717411" t="john-shaffer Thanks! That makes sense"><y>#</y><d>2021-07-19</d><h>17:56</h><w>john-shaffer</w>Thanks! That makes sense</z><z id="t1626806898" t="orestis TIL about the commits rationale. Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2021-07-20</d><h>18:48</h><w>orestis</w>TIL about the commits rationale. Thanks <a>@seancorfield</a></z><z id="t1627325175" t="v3ga What would be a good way to go about deleting a record by ID with honeysqł? Newb question, just tinkering around. https://gist.github.com/v3gal0g/0944bae4b784cd96ad53de71c35bb793"><y>#</y><d>2021-07-26</d><h>18:46</h><w>v3ga</w>What would be a good way to go about deleting a record by ID with honeysqł?  Newb question, just tinkering around. <a href="https://gist.github.com/v3gal0g/0944bae4b784cd96ad53de71c35bb793" target="_blank">https://gist.github.com/v3gal0g/0944bae4b784cd96ad53de71c35bb793</a></z><z id="t1627325275" t="seancorfield [:attrs {:href &quot;/_/_/users/U06FM9QN9&quot;}] There are a couple of examples in the README https://github.com/seancorfield/honeysql#deletes"><y>#</y><d>2021-07-26</d><h>18:47</h><w>seancorfield</w><a>@decim</a> There are a couple of examples in the README <a href="https://github.com/seancorfield/honeysql#deletes" target="_blank">https://github.com/seancorfield/honeysql#deletes</a></z><z id="t1627325355" t="seancorfield Hard to tell from that Gist what result you are getting that is different from what you are expecting?"><y>#</y><d>2021-07-26</d><h>18:49</h><w>seancorfield</w>Hard to tell from that Gist what result you are getting that is different from what you are expecting?</z><z id="t1627325981" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] the jdbc “sql/delete” gives me what I want but thats without honeysql. The other two attempts aren’t doing anything as of yet."><y>#</y><d>2021-07-26</d><h>18:59</h><w>v3ga</w><a>@seancorfield</a> the jdbc “sql/delete” gives me what I want but thats without honeysql. The other two attempts aren’t doing anything as of yet.</z><z id="t1627326120" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ok I believe i’ve got it working now."><y>#</y><d>2021-07-26</d><h>19:02</h><w>v3ga</w><a>@seancorfield</a> ok I believe i’ve got it working now.</z><z id="t1627326220" t="seancorfield [:attrs {:href &quot;/_/_/users/U06FM9QN9&quot;}] What did you need to change?"><y>#</y><d>2021-07-26</d><h>19:03</h><w>seancorfield</w><a>@decim</a> What did you need to change?</z><z id="t1627326878" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] well I thought this would work, Apparently not but that SHOULD be correct…. (-&gt; {:delete-from :books :where [:= :books.id 2]} (honeysql/format))"><y>#</y><d>2021-07-26</d><h>19:14</h><w>v3ga</w><a>@seancorfield</a> well I thought this would work,  Apparently not but that SHOULD be correct….

<code>(-&gt; {:delete-from :books</code>
     <code>:where [:= :books.id 2]}</code>
    <code>(honeysql/format))</code></z><z id="t1627326944" t="v3ga I’m looking at your tests now in the library…"><y>#</y><d>2021-07-26</d><h>19:15</h><w>v3ga</w>I’m looking at your tests now in the library…</z><z id="t1627327303" t="seancorfield dev=&gt; (-&gt; {:delete-from :books #_=&gt; :where [:= :books.id 2]} #_=&gt; (sql/format)) [&quot;DELETE FROM books WHERE books.id = ?&quot; 2] What is that db-query-one function you are calling?"><y>#</y><d>2021-07-26</d><h>19:21</h><w>seancorfield</w><pre>dev=&gt; (-&gt; {:delete-from :books
 #_=&gt;      :where [:= :books.id 2]}
 #_=&gt;     (sql/format))
[&quot;DELETE FROM books WHERE books.id = ?&quot; 2]</pre>
What is that <code>db-query-one</code> function you are calling?</z><z id="t1627327391" t="v3ga (defn db-query-one [sql] (db/execute-one! data-source sql {:return-keys true :builder-fn rs/as-unqualified-maps}))"><y>#</y><d>2021-07-26</d><h>19:23</h><w>v3ga</w><code>(defn db-query-one [sql]</code>
  <code>(db/execute-one! data-source sql</code>
                   <code>{:return-keys true</code>
                    <code>:builder-fn rs/as-unqualified-maps}))</code></z><z id="t1627327550" t="v3ga I’m no longer using that, I removed it for the delete. I get the same as what you posted when I evaluate it… oh. That’s one thing I was wondering. My ‘store-book!’ function does store data to the database but the delete isn’t picking up on the data source is my guess."><y>#</y><d>2021-07-26</d><h>19:25</h><w>v3ga</w>I’m no longer using that, I removed it for the delete.  I get the same as what you posted when I evaluate it… oh.  That’s one thing I was wondering. My ‘store-book!’ function does store data to the database but the delete isn’t picking up on the data source is my guess.</z><z id="t1627327861" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ooops, you were giving me a hint there. Now it does in fact work. I was running around like a chicken with his head cut off… =( (-&gt; (hh/delete-from :books) (hh/where := :books.id 2) (honeysql/format) db-query-one)"><y>#</y><d>2021-07-26</d><h>19:31</h><w>v3ga</w><a>@seancorfield</a> ooops, you were giving me a hint there. Now it does in fact work.  I was running around like a chicken with his head cut off… =(

<code>(-&gt; (hh/delete-from :books)</code>
    <code>(hh/where := :books.id 2)</code>
    <code>(honeysql/format)</code>
    <code>db-query-one)</code></z><z id="t1627327893" t="v3ga I even answered it my damn self without knowing, lol. Thank you."><y>#</y><d>2021-07-26</d><h>19:31</h><w>v3ga</w>I even answered it my damn self without knowing, lol. Thank you.</z><z id="t1627332571" t="seancorfield I&apos;m not sure what you even changed 🙂"><y>#</y><d>2021-07-26</d><h>20:49</h><w>seancorfield</w>I&apos;m not sure what you even changed <b>🙂</b></z><z id="t1627334279" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] it was a round of craziness… I confused myself and executed it without db-query-one, then added it back before making a gist. I’m looking over next.jdbc documentation as well now. I actually learned the very little that i’m using from a tutorial online so I’m tinkering to figure out what all is necessary for the basics."><y>#</y><d>2021-07-26</d><h>21:17</h><w>v3ga</w><a>@seancorfield</a> it was a round of craziness… I confused myself and executed it without db-query-one, then added it back before making a gist.  I’m looking over next.jdbc documentation as well now. I actually learned the very little that i’m using from a tutorial online so I’m tinkering to figure out what all is necessary for the basics.</z><z id="t1627334487" t="seancorfield Cool. Feel free to ask Qs here and in #sql whenever you get stuck or need clarification on something in the docs."><y>#</y><d>2021-07-26</d><h>21:21</h><w>seancorfield</w>Cool. Feel free to ask Qs here and in #sql whenever you get stuck or need clarification on something in the docs.</z><z id="t1627334598" t="v3ga Will do…"><y>#</y><d>2021-07-26</d><h>21:23</h><w>v3ga</w>Will do…</z><z id="t1627538776" t="seancorfield The HoneySQL README has a standard link to cljdocs, just like next.jdbc ."><y>#</y><d>2021-07-29</d><h>06:06</h><w>seancorfield</w>The HoneySQL README has a standard link to cljdocs, just like <code>next.jdbc</code>.</z><z id="t1627538873" t="seancorfield"><y>#</y><d>2021-07-29</d><h>06:07</h><w>seancorfield</w></z><z id="t1627538885" t="seancorfield Right at the top of the readme?"><y>#</y><d>2021-07-29</d><h>06:08</h><w>seancorfield</w>Right at the top of the readme?</z><z id="t1627538914" t="seancorfield (I&apos;m curious because I&apos;ve just followed what most other repos seemed to be doing)"><y>#</y><d>2021-07-29</d><h>06:08</h><w>seancorfield</w>(I&apos;m curious because I&apos;ve just followed what most other repos seemed to be doing)</z><z id="t1627538930" t="seancorfield Both honeysql and next.jdbc do the exact same thing..."><y>#</y><d>2021-07-29</d><h>06:08</h><w>seancorfield</w>Both honeysql and next.jdbc do the exact same thing...</z><z id="t1627538945" t="seancorfield (depstar too)"><y>#</y><d>2021-07-29</d><h>06:09</h><w>seancorfield</w>(depstar too)</z><z id="t1627538958" t="seancorfield Hey, that&apos;s a perfectly valid point! If that isn&apos;t obvious, I can def. make it clearer."><y>#</y><d>2021-07-29</d><h>06:09</h><w>seancorfield</w>Hey, that&apos;s a perfectly valid point! If that isn&apos;t obvious, I can def. make it clearer.</z><z id="t1627539016" t="seancorfield I don&apos;t like that you can&apos;t copy&apos;n&apos;paste the versions from those badges but they seem ... &quot;standard&quot; ... even if they&apos;re not obvious?"><y>#</y><d>2021-07-29</d><h>06:10</h><w>seancorfield</w>I don&apos;t like that you can&apos;t copy&apos;n&apos;paste the versions from those badges but they seem ... &quot;standard&quot; ... even if they&apos;re not obvious?</z><z id="t1627539070" t="seancorfield oh... um... 😁"><y>#</y><d>2021-07-29</d><h>06:11</h><w>seancorfield</w>oh... um... <b>😁</b></z><z id="t1627539105" t="seancorfield I guess they&apos;re not very accessible... 😐"><y>#</y><d>2021-07-29</d><h>06:11</h><w>seancorfield</w>I guess they&apos;re not very accessible... <b>😐</b></z><z id="t1627539200" t="seancorfield Oh!! Yes, right! That would be better. Thank you!"><y>#</y><d>2021-07-29</d><h>06:13</h><w>seancorfield</w>Oh!! Yes, right! That would be better. Thank you!</z><z id="t1627539284" t="seancorfield Brilliant! I&apos;ve updated honeysql and depstar like that."><y>#</y><d>2021-07-29</d><h>06:14</h><w>seancorfield</w>Brilliant! I&apos;ve updated honeysql and depstar like that.</z><z id="t1627539336" t="seancorfield (and expectations.clojure.test!)"><y>#</y><d>2021-07-29</d><h>06:15</h><w>seancorfield</w>(and expectations.clojure.test!)</z><z id="t1627539440" t="seancorfield I hope you will also continue to provide feedback like this -- it is super helpful (even if I seem dense about understanding the feedback sometimes!)"><y>#</y><d>2021-07-29</d><h>06:17</h><w>seancorfield</w>I hope you will also continue to provide feedback like this -- it is super helpful (even if I seem dense about understanding the feedback sometimes!)</z><z id="t1627730815" t="Adie Hey all, I am using https://github.com/nilenso/honeysql-postgres#upsert for upserting this data in my postgres database. The table has this schema: CREATE TABLE my_table ( key varchar(150) NOT NULL, value jsonb, PRIMARY KEY (key) ); My clojure code looks like this: (defn upsert! [table record constraint-name where-clause] (-&gt; (insert-into table) (values [record]) (where* where-clause) (psqlh/upsert (-&gt; (psqlh/on-conflict-constraint constraint-name) (psqlh/do-update-set :key :value) )) sql/format) But I am getting this error on calling the upsert function on the same key twice : 2021-07-30 19:42:30.656 UTC [2376] ERROR: duplicate key value violates unique constraint &quot;my_table_pkey&quot; 2021-07-30 19:42:30.656 UTC [2376] DETAIL: Key (key)=(8343847329) already exists. 2021-07-30 19:42:30.656 UTC [2376] STATEMENT: INSERT INTO my_table (driver_id, tags) VALUES ($1, $2) As per the doc the query in postgres should look like below : [&quot;INSERT INTO distributors (did, dname) VALUES (?, ?), (?, ?) ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname RETURNING *&quot; 5 &quot;Gizmo Transglobal&quot; 6 &quot;Associated Computing, Inc&quot;]"><y>#</y><d>2021-07-31</d><h>11:26</h><w>Adie</w>Hey all, I am using <a href="https://github.com/nilenso/honeysql-postgres#upsert" target="_blank">https://github.com/nilenso/honeysql-postgres#upsert</a> for upserting this data in my postgres database.

The table has this schema:

<pre>CREATE TABLE my_table (
                      key varchar(150) NOT NULL,
                      value jsonb,
                      PRIMARY KEY (key)
);</pre>
My clojure code looks like this:

<pre>(defn upsert!
  [table record constraint-name where-clause]
  (-&gt; (insert-into table)
      (values [record])
      (where* where-clause)
      (psqlh/upsert (-&gt; (psqlh/on-conflict-constraint constraint-name)
                        (psqlh/do-update-set :key
                                             :value)
                        ))
      sql/format)</pre>

But I am getting this error on calling the upsert function on the same key twice :


<pre>2021-07-30 19:42:30.656 UTC [2376] ERROR:  duplicate key value violates unique constraint &quot;my_table_pkey&quot;
2021-07-30 19:42:30.656 UTC [2376] DETAIL:  Key (key)=(8343847329) already exists.
2021-07-30 19:42:30.656 UTC [2376] STATEMENT:  INSERT INTO my_table (driver_id, tags) VALUES ($1, $2)  </pre>
As per the doc the query in postgres should look like below :

<pre>[&quot;INSERT INTO distributors (did, dname) VALUES (?, ?), (?, ?) ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname RETURNING *&quot;
    5 &quot;Gizmo Transglobal&quot; 6 &quot;Associated Computing, Inc&quot;]</pre></z><z id="t1627731109" t="Adie The following query works fine when executed directly in the psql shell. INSERT INTO my_table (key, value) VALUES (&apos;8343847329&apos;, &apos;{&quot;val-a&quot;: &quot;hello&quot;, &quot;val-b&quot;: [&quot;ABC&quot; &quot;XYZ&quot; &quot;PQR&quot;], &quot;val-c&quot;: &quot;MNO&quot;, &quot;val-d&quot;: [&quot;RST&quot;]}&apos;) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value RETURNING *; I feel my clojure code is unable to create the appropriate DML for the expected psql query."><y>#</y><d>2021-07-31</d><h>11:31</h><r>Adie</r>The following query works fine when executed directly in the psql shell.


<pre>INSERT INTO my_table (key, value) VALUES (&apos;8343847329&apos;, &apos;{&quot;val-a&quot;: &quot;hello&quot;, &quot;val-b&quot;: [&quot;ABC&quot; &quot;XYZ&quot; &quot;PQR&quot;], &quot;val-c&quot;: &quot;MNO&quot;, &quot;val-d&quot;: [&quot;RST&quot;]}&apos;) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value RETURNING *;</pre>

I feel my clojure code is unable to create the appropriate DML for the expected psql query.</z><z id="t1627736029" t="indy You can start debugging by comparing the output of the upsert query returned by your function with the one you intend to run. What is the output of the upsert query that you generated using honesql-postgres?"><y>#</y><d>2021-07-31</d><h>12:53</h><w>indy</w>You can start debugging by comparing the output of the upsert query returned by your function with the one you intend to run. What is the output of the upsert query that you generated using honesql-postgres?</z><z id="t1627736083" t="indy From the log that you posted, doesn&apos;t seem like the on conflict bit has been included"><y>#</y><d>2021-07-31</d><h>12:54</h><w>indy</w>From the log that you posted, doesn&apos;t seem like the on conflict bit has been included</z><z id="t1627736968" t="Adie can you please share some doc how to log querys generated from honeysql"><y>#</y><d>2021-07-31</d><h>13:09</h><r>Adie</r>can you please share some doc how to log querys generated from honeysql</z><z id="t1627737103" t="indy You just have to call the function that generates the query from the REPL, in your case the upsert! function. It&apos;ll give you the output. sql/format will return something like [&quot;SELECT * FROM some_table&quot;] ."><y>#</y><d>2021-07-31</d><h>13:11</h><r>indy</r>You just have to call the function that generates the query from the REPL, in your case the <code>upsert!</code> function. It&apos;ll give you the output. <code>sql/format</code> will return something like <code>[&quot;SELECT * FROM some_table&quot;]</code>.</z><z id="t1627737920" t="indy From your past messages in other channels, it seems you&apos;ve misunderstood honeysql. To clarify things, honeysql and it&apos;s postgres fork by nilenso are only query builders, they will only help you build queries using Clojure&apos;s datastructures and don&apos;t interact with the database at all. It is the JDBC driver that will interact with the DB, this is done using next.jdbc and the postgres driver in your case. So the flow is something like this, 1. You build SQL queries using honeysql that take clojure data structures as input. 2. You pass this query to next.jdbc &apos;s functions like next.jdbc/execute , next.jdbc.sql/query and others. 3. next.jdbc will interact with the DB using the chosen driver, postgres in your case and return you the results if any."><y>#</y><d>2021-07-31</d><h>13:25</h><r>indy</r>From your past messages in other channels, it seems you&apos;ve misunderstood honeysql. To clarify things, <code>honeysql</code> and it&apos;s postgres fork by nilenso are only query builders, they will only help you build queries using Clojure&apos;s datastructures and don&apos;t interact with the database at all. It is the JDBC driver that will interact with the DB, this is done using <code>next.jdbc</code> and the postgres driver in your case.

So the flow is something like this,
1. You build SQL queries using honeysql that take clojure data structures as input.
2. You pass this query to <code>next.jdbc</code>&apos;s functions like <code>next.jdbc/execute</code> , <code>next.jdbc.sql/query</code> and others.
3. <code>next.jdbc</code> will interact with the DB using the chosen driver, <code>postgres</code> in your case and return you the results if any.</z><z id="t1627742507" t="Adie Those are old messages when I had barely used honeysql"><y>#</y><d>2021-07-31</d><h>14:41</h><r>Adie</r>Those are old messages when I had barely used honeysql</z><z id="t1627744649" t="Adie I ran the exact same example on my repl as shown here https://github.com/nilenso/honeysql-postgres#upsert but my query is coming as different"><y>#</y><d>2021-07-31</d><h>15:17</h><r>Adie</r>I ran the exact same example on my repl as shown here <a href="https://github.com/nilenso/honeysql-postgres#upsert" target="_blank">https://github.com/nilenso/honeysql-postgres#upsert</a> but my query is coming as different</z><z id="t1627744699" t="Adie The exact same is happening for my table as well."><y>#</y><d>2021-07-31</d><h>15:18</h><r>Adie</r>The exact same is happening for my table as well.</z><z id="t1627745170" t="indy Are you using honeysql 2? It seems honeysql 2 doesn&apos;t work with honeysql-postgres https://github.com/nilenso/honeysql-postgres/issues/62"><y>#</y><d>2021-07-31</d><h>15:26</h><r>indy</r>Are you using honeysql 2? It seems honeysql 2 doesn&apos;t work with honeysql-postgres <a href="https://github.com/nilenso/honeysql-postgres/issues/62" target="_blank">https://github.com/nilenso/honeysql-postgres/issues/62</a></z><z id="t1627745315" t="indy Not sure if the situation has changed since the comments are dated"><y>#</y><d>2021-07-31</d><h>15:28</h><r>indy</r>Not sure if the situation has changed since the comments are dated</z><z id="t1627745436" t="indy But honeysql 2 has direct support for upsert https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc5/doc/getting-started/postgresql-support"><y>#</y><d>2021-07-31</d><h>15:30</h><r>indy</r>But honeysql 2 has direct support for upsert <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc5/doc/getting-started/postgresql-support" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.0-rc5/doc/getting-started/postgresql-support</a></z><z id="t1627834310" t="p-himik Is there a common approach towards approaching aliases/CTE names generation in reusable subquery-generating functions? I have a lot of functions that generate small clauses, some of which require aliases due to nesting or names for some CTEs. Hard-coding them can&apos;t work because the same function can be used multiple times for the same query. Passing them can&apos;t work because the overall internal API is rather generic - the caller just cares about the changes it should make to the sqlmap, it doesn&apos;t care about which tiny function requires which aliases/names. I&apos;m about to implement a mechanism similar to (gensym) with just a plain atom and ID increment + rollover (paranoid, I know). But maybe there&apos;s a known solution, maybe even a function somewhere for that, that I just can&apos;t find?"><y>#</y><d>2021-08-01</d><h>16:11</h><w>p-himik</w>Is there a common approach towards approaching aliases/CTE names generation in reusable subquery-generating functions?
I have a lot of functions that generate small clauses, some of which require aliases due to nesting or names for some CTEs.
Hard-coding them can&apos;t work because the same function can be used multiple times for the same query. Passing them can&apos;t work because the overall internal API is rather generic - the caller just cares about the changes it should make to the sqlmap, it doesn&apos;t care about which tiny function requires which aliases/names.

I&apos;m about to implement a mechanism similar to <code>(gensym)</code> with just a plain atom and ID increment + rollover (paranoid, I know).
But maybe there&apos;s a known solution, maybe even a function somewhere for that, that I just can&apos;t find?</z><z id="t1627835625" t="deleted I was reading that and thinking &quot;wow, sounds like gensym&quot; and sure enough 😂"><y>#</y><d>2021-08-01</d><h>16:33</h><w>deleted</w>I was reading that and thinking &quot;wow, sounds like gensym&quot; and sure enough <b>😂</b></z></g><g id="s4"><z id="t1627835733" t="p-himik gensym can&apos;t alleviate my paranoia - it doesn&apos;t have roll-over. :)"><y>#</y><d>2021-08-01</d><h>16:35</h><r>p-himik</r><code>gensym</code> can&apos;t alleviate my paranoia - it doesn&apos;t have roll-over. :)</z><z id="t1627836266" t="p-himik A single swap! with if should be simpler though. I should&apos;ve been more clear - the crux of the issue is not getting a unique identifier itself but rather having it work automagically. I&apos;ve glanced at the source and there doesn&apos;t seem to be such a thing, but I could be blind."><y>#</y><d>2021-08-01</d><h>16:44</h><r>p-himik</r>A single <code>swap!</code> with <code>if</code> should be simpler though.
I should&apos;ve been more clear - the crux of the issue is not getting a unique identifier itself but rather having it work automagically. I&apos;ve glanced at the source and there doesn&apos;t seem to be such a thing, but I could be blind.</z><z id="t1627836509" t="p-himik But why can&apos;t I just use the counter itself? Just like gensym does. So an alias would be something like :G_234975 ."><y>#</y><d>2021-08-01</d><h>16:48</h><r>p-himik</r>But why can&apos;t I just use the counter itself? Just like <code>gensym</code> does. So an alias would be something like <code>:G_234975</code> .</z><z id="t1627836684" t="p-himik Nah, given my overflow paranoia it makes sense. Although that would have to be one large query to fit repeating IDs."><y>#</y><d>2021-08-01</d><h>16:51</h><r>p-himik</r>Nah, given my overflow paranoia it makes sense. Although that would have to be one large query to fit repeating IDs.</z><z id="t1627837058" t="p-himik Java doesn&apos;t have built-in unsigned number types though. And overflowing a long leads to an exception. And better be explicit about it anyway: (def -last-id (atom 1)) (defn get-alias ([] (get-alias :alias)) ([k] (keyword (str (name k) &quot;_&quot; (swap! -last-id (fn [id] (if (= Long/MAX_VALUE) 1 (inc id))))))))"><y>#</y><d>2021-08-01</d><h>16:57</h><r>p-himik</r>Java doesn&apos;t have built-in unsigned number types though. And overflowing a long leads to an exception.
And better be explicit about it anyway:
<pre>(def -last-id (atom 1))

(defn get-alias
  ([]
   (get-alias :alias))
  ([k]
   (keyword (str (name k) &quot;_&quot; (swap! -last-id (fn [id]
                                                (if (= Long/MAX_VALUE)
                                                  1
                                                  (inc id))))))))</pre></z><z id="t1627837841" t="p-himik Makes sense! Especially given that it shouldn&apos;t happen at all in a realistic scenario."><y>#</y><d>2021-08-01</d><h>17:10</h><r>p-himik</r>Makes sense! Especially given that it shouldn&apos;t happen at all in a realistic scenario.</z><z id="t1628189788" t="greglook I feel like I’m missing something obvious; how would I format an = clause inside of a function call? The approach I expected to work doesn’t do the right thing: =&gt; (sql/format (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)) [&quot;nullif((=, id, ?), FALSE)&quot; &quot;dsr-000&quot;]"><y>#</y><d>2021-08-05</d><h>18:56</h><w>greglook</w>I feel like I’m missing something obvious; how would I format an <code>=</code> clause inside of a function call? The approach I expected to work doesn’t do the right thing:
<pre>=&gt; (sql/format (sql/call :nullif [:= :id &quot;dsr-000&quot;] false))
[&quot;nullif((=, id, ?), FALSE)&quot; &quot;dsr-000&quot;]</pre></z><z id="t1628189876" t="seancorfield [:attrs {:href &quot;/_/_/users/U8XJ15DTK&quot;}] HoneySQL v1 or v2?"><y>#</y><d>2021-08-05</d><h>18:57</h><w>seancorfield</w><a>@greg316</a> HoneySQL v1 or v2?</z><z id="t1628189901" t="greglook good question, looks like [honeysql &quot;1.0.461&quot;]"><y>#</y><d>2021-08-05</d><h>18:58</h><w>greglook</w>good question, looks like <code>[honeysql &quot;1.0.461&quot;]</code></z><z id="t1628189926" t="seancorfield On v2: dev=&gt; (sql/format-expr (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)) [&quot;NULLIF(id = ?, FALSE)&quot; &quot;dsr-000&quot;] (sorry, didn&apos;t paste the right thing)"><y>#</y><d>2021-08-05</d><h>18:58</h><w>seancorfield</w>On v2:
<pre>dev=&gt; (sql/format-expr (sql/call :nullif [:= :id &quot;dsr-000&quot;] false))
[&quot;NULLIF(id = ?, FALSE)&quot; &quot;dsr-000&quot;]</pre>
(sorry, didn&apos;t paste the right thing)</z><z id="t1628189976" t="seancorfield (I&apos;m not sure if you can format expressions in v1 -- you can&apos;t in v2, you must use format-expr -- but if you format a statement that includes your expression you should do better)"><y>#</y><d>2021-08-05</d><h>18:59</h><w>seancorfield</w>(I&apos;m not sure if you can <code>format</code> expressions in v1 -- you can&apos;t in v2, you must use <code>format-expr</code> -- but if you <code>format</code> a statement that includes your expression you should do better)</z><z id="t1628190019" t="greglook has the same effect in a full expression: =&gt; (sql/format (sql/build :update :foos :set {:is_default (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)})) [&quot;UPDATE foos SET is_default = nullif((=, id, ?), FALSE)&quot; &quot;dsr-000&quot;]"><y>#</y><d>2021-08-05</d><h>19:00</h><w>greglook</w>has the same effect in a full expression:
<pre>=&gt; (sql/format (sql/build :update :foos :set {:is_default (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)}))
[&quot;UPDATE foos SET is_default = nullif((=, id, ?), FALSE)&quot; &quot;dsr-000&quot;]</pre></z><z id="t1628190068" t="seancorfield v1 had some strange behavior in some places with embedded expressions..."><y>#</y><d>2021-08-05</d><h>19:01</h><w>seancorfield</w>v1 had some strange behavior in some places with embedded expressions...</z><z id="t1628190076" t="greglook hoping I don’t have to fall back to making it a raw string 😅"><y>#</y><d>2021-08-05</d><h>19:01</h><w>greglook</w>hoping I don’t have to fall back to making it a raw string <b>😅</b></z><z id="t1628190128" t="seancorfield v2: (there&apos;s no build function because it really didn&apos;t do much) dev=&gt; (sql/format {:update :foos :set {:is_default (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)}}) [&quot;UPDATE foos SET is_default = NULLIF(id = ?, FALSE)&quot; &quot;dsr-000&quot;]"><y>#</y><d>2021-08-05</d><h>19:02</h><w>seancorfield</w>v2: (there&apos;s no <code>build</code> function because it really didn&apos;t do much)
<pre>dev=&gt; (sql/format {:update :foos :set {:is_default (sql/call :nullif [:= :id &quot;dsr-000&quot;] false)}})
[&quot;UPDATE foos SET is_default = NULLIF(id = ?, FALSE)&quot; &quot;dsr-000&quot;]</pre></z><z id="t1628190193" t="greglook unfortunately I don’t think upgrading the whole app to v2 is tractable right now, but I’ll put it on our backlog - does look like a nicer API"><y>#</y><d>2021-08-05</d><h>19:03</h><w>greglook</w>unfortunately I don’t think upgrading the whole app to v2 is tractable right now, but I’ll put it on our backlog - does look like a nicer API</z><z id="t1628190305" t="seancorfield You can run v1 and v2 side-by-side and migrate on a query-by-query basis."><y>#</y><d>2021-08-05</d><h>19:05</h><w>seancorfield</w>You can run v1 and v2 side-by-side and migrate on a query-by-query basis.</z><z id="t1628190314" t="seancorfield Different library names and different namespaces."><y>#</y><d>2021-08-05</d><h>19:05</h><w>seancorfield</w>Different library names and different namespaces.</z><z id="t1628190328" t="seancorfield We&apos;re running both at work and slowly migrating from v1 to v2."><y>#</y><d>2021-08-05</d><h>19:05</h><w>seancorfield</w>We&apos;re running both at work and slowly migrating from v1 to v2.</z><z id="t1628216548" t="john-shaffer Added clojure-mode, syntax highlighting, and permalinks to https://www.john-shaffer.com/honeysql/"><y>#</y><d>2021-08-06</d><h>02:22</h><w>john-shaffer</w>Added clojure-mode, syntax highlighting, and permalinks to <a href="https://www.john-shaffer.com/honeysql/" target="_blank">https://www.john-shaffer.com/honeysql/</a></z><z id="t1628216825" t="john-shaffer e.g., https://www.john-shaffer.com/honeysql/?q=%7B%3Aupdate%20%3Afoos%0A%20%3Aset%20%7B%3Ais-default%20%5B%3Anullif%20%5B%3A%3D%20%3Aid%20%22dsr-000%22%5D%20false%5D%7D%7D&amp;amp;opt=%7B%3Apretty%20true%7D"><y>#</y><d>2021-08-06</d><h>02:27</h><w>john-shaffer</w>e.g., <a href="https://www.john-shaffer.com/honeysql/?q=%7B%3Aupdate%20%3Afoos%0A%20%3Aset%20%7B%3Ais-default%20%5B%3Anullif%20%5B%3A%3D%20%3Aid%20%22dsr-000%22%5D%20false%5D%7D%7D&amp;amp;opt=%7B%3Apretty%20true%7D" target="_blank">https://www.john-shaffer.com/honeysql/?q=%7B%3Aupdate%20%3Afoos%0A%20%3Aset%20%7B%3Ais-default%20%5B%3Anullif%20%5B%3A%3D%20%3Aid%20%22dsr-000%22%5D%20false%5D%7D%7D&amp;amp;opt=%7B%3Apretty%20true%7D</a></z><z id="t1628217052" t="john-shaffer I&apos;d like to add multiple versions in a dropdown (once it&apos;s relevant), so the permalinks will stay perma"><y>#</y><d>2021-08-06</d><h>02:30</h><w>john-shaffer</w>I&apos;d like to add multiple versions in a dropdown (once it&apos;s relevant), so the permalinks will stay perma</z><z id="t1628222371" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] Is this something you&apos;re planning to keep online and maintain now? Just wondering whether to add it to the docs since I think it&apos;s a great resource!"><y>#</y><d>2021-08-06</d><h>03:59</h><w>seancorfield</w><a>@jshaffer2112</a> Is this something you&apos;re planning to keep online and maintain now? Just wondering whether to add it to the docs since I think it&apos;s a great resource!</z><z id="t1628223422" t="john-shaffer Yes, I&apos;ll keep it maintained. It&apos;d be nice to have it in the docs"><y>#</y><d>2021-08-06</d><h>04:17</h><w>john-shaffer</w>Yes, I&apos;ll keep it maintained. It&apos;d be nice to have it in the docs</z><z id="t1628275016" t="seancorfield I&apos;ve added links to the README and the Getting Started section so it&apos;ll be part of the next release&apos;s documentation (2.0 &quot;gold&quot;). Thank again for this [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] !"><y>#</y><d>2021-08-06</d><h>18:36</h><r>seancorfield</r>I&apos;ve added links to the README and the Getting Started section so it&apos;ll be part of the next release&apos;s documentation (2.0 &quot;gold&quot;). Thank again for this <a>@jshaffer2112</a>!</z><z id="t1628223503" t="john-shaffer I use it all the time"><y>#</y><d>2021-08-06</d><h>04:18</h><w>john-shaffer</w>I use it all the time</z><z id="t1628226992" t="seancorfield Cool. I&apos;ve made a note to remind me to add it to the docs. Thank you!"><y>#</y><d>2021-08-06</d><h>05:16</h><w>seancorfield</w>Cool. I&apos;ve made a note to remind me to add it to the docs. Thank you!</z><z id="t1628234005" t="Adie [honeysql-postgres.helpers :as psqlh] (defn upsert! [table record constraint-name where-clause] (-&gt; (insert-into table) (values [record]) (where* where-clause) (psqlh/upsert (-&gt; (psqlh/on-conflict-constraint constraint-name) (psqlh/do-update-set :id :tag) )) sql/format) ) Can somebody suggest how I can make this function generic and remove the coupling with :id and :tag . I need to fetch the keys from record. Record looks like this :"><y>#</y><d>2021-08-06</d><h>07:13</h><w>Adie</w><pre>[honeysql-postgres.helpers :as psqlh]</pre>
<pre>(defn upsert!
  [table record constraint-name where-clause]
  (-&gt; (insert-into table)
      (values [record])
      (where* where-clause)
      (psqlh/upsert (-&gt; (psqlh/on-conflict-constraint constraint-name)
                        (psqlh/do-update-set :id
                                             :tag)
                        ))
      sql/format)
  )</pre>

Can somebody suggest how I can make this function generic and remove the coupling with :id and :tag . I need to fetch the keys from record.
Record looks like this :</z><z id="t1628234062" t="Adie {:id &quot;abcdef&quot;, :tag {:ab &quot;hello&quot; :bc &quot;world&quot;}}"><y>#</y><d>2021-08-06</d><h>07:14</h><w>Adie</w>{:id &quot;abcdef&quot;, :tag {:ab &quot;hello&quot; :bc &quot;world&quot;}}</z><z id="t1628234112" t="Adie I tried replacing :id :tag with (keys record)"><y>#</y><d>2021-08-06</d><h>07:15</h><w>Adie</w>I tried replacing :id :tag with (keys record)</z><z id="t1628234116" t="Adie but it didnt help"><y>#</y><d>2021-08-06</d><h>07:15</h><w>Adie</w>but it didnt help</z><z id="t1628234162" t="Adie This is the input format for psqlh/do-update-set (defhelper do-update-set [m args] (assoc m :do-update-set (sqlh/collify args))) "><y>#</y><d>2021-08-06</d><h>07:16</h><w>Adie</w>This is the input format for psqlh/do-update-set
<pre>(defhelper do-update-set [m args]
  (assoc m :do-update-set (sqlh/collify args)))</pre>
</z><z id="t1628235160" t="Adie (keys record) =&gt; (:id :tag)"><y>#</y><d>2021-08-06</d><h>07:32</h><w>Adie</w>(keys record)
=&gt; (:id :tag)</z><z id="t1628272062" t="seancorfield [:attrs {:href &quot;/_/_/users/U01P6LWQD1S&quot;}] That&apos;s for the nilenso library?"><y>#</y><d>2021-08-06</d><h>17:47</h><w>seancorfield</w><a>@aditi.mishra</a> That&apos;s for the nilenso library?</z><z id="t1628272155" t="seancorfield I suspect you could do something like (assoc :do-update-set (into [] (keys record))) depending on exactly what that do-update-set helper uses as the underlying key..."><y>#</y><d>2021-08-06</d><h>17:49</h><w>seancorfield</w>I suspect you could do something like <code>(assoc :do-update-set (into [] (keys record)))</code> depending on exactly what that <code>do-update-set</code> helper uses as the underlying key...</z><z id="t1628348215" t="snorremd Hi. I&apos;m trying to figure out a way to get the containment operator from Postgres registered with honeysql in a good way. The @&gt; operator does not easily represent as a keyword in clojure because of the @ character."><y>#</y><d>2021-08-07</d><h>14:56</h><w>snorremd</w>Hi. I&apos;m trying to figure out a way to get the containment operator from Postgres registered with honeysql in a good way.
The <code>@&gt;</code>  operator does not easily represent as a keyword in clojure because of the @ character.</z><z id="t1628348327" t="snorremd So while I could do (honey.sql/register-op! (keyword &quot;@&gt;&quot;)) , I would then have to refer to the operator via (keyword &quot;@&gt;&quot;) everywhere I want to use it. 😕"><y>#</y><d>2021-08-07</d><h>14:58</h><w>snorremd</w>So while I could do <code>(honey.sql/register-op! (keyword &quot;@&gt;&quot;))</code>, I would then have to refer to the operator via <code>(keyword &quot;@&gt;&quot;)</code>  everywhere I want to use it. <b>😕</b></z><z id="t1628350421" t="seancorfield [:attrs {:href &quot;/_/_/users/U3T0CQGQH&quot;}] I would just define a global somewhere with an mnemonic name for it: (def at&gt; (keyword &quot;@&gt;&quot;)) ... (sql/register-op! at&gt;) ... (sql/format ... at&gt; ...)"><y>#</y><d>2021-08-07</d><h>15:33</h><w>seancorfield</w><a>@snorremd</a> I would just define a global somewhere with an mnemonic name for it:
<pre>(def at&gt; (keyword &quot;@&gt;&quot;))
...
(sql/register-op! at&gt;)
...
(sql/format ... at&gt; ...)</pre></z><z id="t1628350487" t="seancorfield (given Clojure&apos;s restrictions on using @ there&apos;s really not much else you can do -- this applies to a number of PostgreSQL &quot;enhancements&quot; that use weird characters)"><y>#</y><d>2021-08-07</d><h>15:34</h><w>seancorfield</w>(given Clojure&apos;s restrictions on using <code>@</code> there&apos;s really not much else you can do -- this applies to a number of PostgreSQL &quot;enhancements&quot; that use weird characters)</z><z id="t1628351303" t="snorremd Thanks! Did not think about just defining a global. I made a function instead with infix notation: (defn- contains-formatter [_f args] (let [[sql &amp; params] (hsql/format-expr-list args)] (into [(str (first sql) &quot; @&gt; &quot; (second sql))] (flatten params)))) (hsql/register-fn! :at&gt; contains-formatter) This seems to work reasonably well, but yours is simpler. 🙂"><y>#</y><d>2021-08-07</d><h>15:48</h><w>snorremd</w>Thanks! Did not think about just defining a global. I made a function instead with infix notation:

<pre>(defn- contains-formatter [_f args]
  (let [[sql &amp; params] (hsql/format-expr-list args)]
    (into [(str (first sql) &quot; @&gt; &quot; (second sql))]
          (flatten params))))

(hsql/register-fn! :at&gt; contains-formatter)</pre>
This seems to work reasonably well, but yours is simpler. <b>🙂</b></z><z id="t1628818568" t="seancorfield I have a three-day weekend ahead of me (taking tomorrow, Friday, off) so I plan to work on OSS projects quite a bit. In particular, I plan to release HoneySQL 2.0 &quot;gold&quot; this weekend so now is your last chance to test RC 5 and find bugs/ask for enhancements before the formal release!"><y>#</y><d>2021-08-13</d><h>01:36</h><w>seancorfield</w>I have a three-day weekend ahead of me (taking tomorrow, Friday, off) so I plan to work on OSS projects quite a bit. In particular, I plan to release HoneySQL 2.0 &quot;gold&quot; this weekend so now is your last chance to test RC 5 and find bugs/ask for enhancements before the formal release!</z><z id="t1628818707" t="seancorfield LOL!"><y>#</y><d>2021-08-13</d><h>01:38</h><w>seancorfield</w>LOL!</z><z id="t1628818724" t="seancorfield Cool."><y>#</y><d>2021-08-13</d><h>01:38</h><w>seancorfield</w>Cool.</z><z id="t1628818770" t="seancorfield PostgreSQL support is the bane of my life 🙂 But I&apos;m glad it serves the needs of PG users..."><y>#</y><d>2021-08-13</d><h>01:39</h><w>seancorfield</w>PostgreSQL support is the bane of my life <b>🙂</b> But I&apos;m glad it serves the needs of PG users...</z><z id="t1629052814" t="seancorfield For anyone who has been cautious about using the prerelease version in production..."><y>#</y><d>2021-08-15</d><h>18:40</h><w>seancorfield</w>For anyone who has been cautious about using the prerelease version in production...</z><z id="t1629053123" t="dharrigan party-corgi"><y>#</y><d>2021-08-15</d><h>18:45</h><w>dharrigan</w><b>party-corgi</b></z><z id="t1629053139" t="dharrigan amazing! Well done Sean! Looking forward to using that in the near future! 🙂"><y>#</y><d>2021-08-15</d><h>18:45</h><w>dharrigan</w>amazing! Well done Sean! Looking forward to using that in the near future! <b>🙂</b></z><z id="t1629130697" t="snorremd Thanks for all your hard work on this library Sean! Will definitely upgrade from the pre-release to the gold release. 🎉"><y>#</y><d>2021-08-16</d><h>16:18</h><w>snorremd</w>Thanks for all your hard work on this library Sean! Will definitely upgrade from the pre-release to the gold release. <b>🎉</b></z><z id="t1629641563" t="bartuka hello, I am extending honeysql 2.x by adding a new function however I could not easily find a way to support bindable params in my new function. (sql/format {:select [:user] :from [:t] :where [:my-function :?path]} {:params {:path [:meta &quot;title&quot;]}}) the my-function body only receives the keyword :?path how can I get access to the params provided in sql/format?"><y>#</y><d>2021-08-22</d><h>14:12</h><w>bartuka</w>hello, I am extending honeysql 2.x by adding a new function however I could not easily find a way to support bindable params in my new function.

<pre>(sql/format
 {:select [:user]
  :from [:t]
  :where [:my-function :?path]}
 {:params {:path [:meta &quot;title&quot;]}})</pre>
the <code>my-function</code> body only receives the keyword <code>:?path</code> how can I get access to the <code>params</code> provided in sql/format?</z><z id="t1629661536" t="seancorfield [:attrs {:href &quot;/_/_/users/UBSREKQ5Q&quot;}] The :params are only applied right at the end. The expectation is that your new function would call format-expr etc on its argument, or whatever semantics it wants to have."><y>#</y><d>2021-08-22</d><h>19:45</h><w>seancorfield</w><a>@iagwanderson</a> The <code>:params</code> are only applied right at the end. The expectation is that your new function would call <code>format-expr</code> etc on its argument, or whatever semantics it wants to have.</z><z id="t1629661645" t="seancorfield When you call format-expr on :?path , you get [&quot;?&quot; &lt;param function&gt;] and that (opaque) &lt;param function&gt; is turned into an actual value as the last step of format (the mapv unwrap code there)."><y>#</y><d>2021-08-22</d><h>19:47</h><w>seancorfield</w>When you call <code>format-expr</code> on <code>:?path</code>, you get <code>[&quot;?&quot; &lt;param function&gt;]</code> and that (opaque) <code>&lt;param function&gt;</code> is turned into an actual value as the last step of <code>format</code> (the <code>mapv</code> <code>unwrap</code> code there).</z><z id="t1629661711" t="seancorfield Perhaps you can explain what problem you&apos;re trying to solve? Maybe you&apos;re misunderstanding why you would register a new formatting function?"><y>#</y><d>2021-08-22</d><h>19:48</h><w>seancorfield</w>Perhaps you can explain what problem you&apos;re trying to solve? Maybe you&apos;re misunderstanding why you would register a new formatting function?</z><z id="t1629670040" t="bartuka I am writing a to_tsvector function e.g: (sql/format {:select [[[:to-tsvector &quot;test&quot;]]]}) ;; =&gt; [&quot;SELECT to_tsvector(&apos;simple&apos;, &apos;test&apos;)&quot;] "><y>#</y><d>2021-08-22</d><h>22:07</h><r>bartuka</r>I am writing a <code>to_tsvector</code> function e.g:

<pre>(sql/format {:select [[[:to-tsvector &quot;test&quot;]]]})
;; =&gt; [&quot;SELECT to_tsvector(&apos;simple&apos;, &apos;test&apos;)&quot;]</pre>
</z><z id="t1629670092" t="bartuka the syntax above is already good enough, I was curious about how to support bindable params"><y>#</y><d>2021-08-22</d><h>22:08</h><r>bartuka</r>the syntax above is already good enough, I was curious about how to support bindable params</z><z id="t1629670222" t="seancorfield In the same way you wouldn&apos;t want macros to generally to introduce fixed names, you generally wouldn&apos;t want to introduce fixed names for bindable params."><y>#</y><d>2021-08-22</d><h>22:10</h><r>seancorfield</r>In the same way you wouldn&apos;t want macros to generally to introduce fixed names, you generally wouldn&apos;t want to introduce fixed names for bindable params.</z><z id="t1629670262" t="seancorfield But the answer is that (sql/format-expr :?some-name) is going to put ? in your SQL and will bind to :some-name in the :params passed to sql/format ."><y>#</y><d>2021-08-22</d><h>22:11</h><r>seancorfield</r>But the answer is that <code>(sql/format-expr :?some-name)</code> is going to put <code>?</code> in your SQL and will bind to <code>:some-name</code> in the <code>:params</code> passed to <code>sql/format</code>.</z><z id="t1629670320" t="seancorfield But if someone called your new function as [:to-tsvector :?val] , then they&apos;d provide :params {:val &quot;test&quot;} in the call to sql/format ."><y>#</y><d>2021-08-22</d><h>22:12</h><r>seancorfield</r>But if someone called your new function as <code>[:to-tsvector :?val]</code>, then they&apos;d provide <code>:params {:val &quot;test&quot;}</code> in the call to <code>sql/format</code>.</z><z id="t1629670369" t="seancorfield Your function should call sql/format-expr on its argument to get [sql &amp; params] from it, and merge that into the function&apos;s overall SQL (and any other params)."><y>#</y><d>2021-08-22</d><h>22:12</h><r>seancorfield</r>Your function should call <code>sql/format-expr</code> on its argument to get <code>[sql &amp; params]</code> from it, and merge that into the function&apos;s overall SQL (and any other params).</z><z id="t1629670375" t="seancorfield Does that make sense [:attrs {:href &quot;/_/_/users/UBSREKQ5Q&quot;}] ?"><y>#</y><d>2021-08-22</d><h>22:12</h><r>seancorfield</r>Does that make sense <a>@iagwanderson</a>?</z><z id="t1629670483" t="bartuka yes, I will play with format-expr a bit more. Do you mind expanding more on your first comment about fixed names?"><y>#</y><d>2021-08-22</d><h>22:14</h><r>bartuka</r>yes, I will play with <code>format-expr</code> a bit more. Do you mind expanding more on your first comment about fixed names?</z><z id="t1629670985" t="bartuka oh, I think I got it. The case above should return (sql/format {:select [[[:to-tsvector &quot;test&quot;]]]}) ;; =&gt; [&quot;SELECT to_tsvector(&apos;simple&apos;, ?)&quot; &quot;teste&quot;]"><y>#</y><d>2021-08-22</d><h>22:23</h><r>bartuka</r>oh, I think I got it. The case above should return

<pre>(sql/format {:select [[[:to-tsvector &quot;test&quot;]]]})
;; =&gt; [&quot;SELECT to_tsvector(&apos;simple&apos;, ?)&quot; &quot;teste&quot;]</pre></z><z id="t1629671631" t="seancorfield Right."><y>#</y><d>2021-08-22</d><h>22:33</h><r>seancorfield</r>Right.</z><z id="t1629671670" t="seancorfield I was cautioning against your function injecting new named parameters (since you couldn&apos;t use your function twice in a single query and expect it to get different arguments)."><y>#</y><d>2021-08-22</d><h>22:34</h><r>seancorfield</r>I was cautioning against your function injecting new named parameters (since you couldn&apos;t use your function twice in a single query and expect it to get different arguments).</z><z id="t1629721308" t="bartuka thanks for the help [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I have another variation of this problem. If :?path is a vector and I want to unpack the vector inside my formatter e.g. ;; better syntax for path: (sql/format {:select [:*] :from [:honey] :where [:-&gt; :data :?path]} {:params {:path [&quot;key1&quot; &quot;key2&quot;]}}) ;; =&gt; [&quot;SELECT * FROM honey WHERE DATA-&gt;?&quot; [&quot;key1&quot; &quot;key2&quot;]] &lt;&lt;&lt;-- wrong ;; desired ;; =&gt; [&quot;SELECT * FROM honey WHERE DATA-&gt;?-&gt;?&quot; &quot;key1&quot; &quot;key2&quot;] &lt;&lt;&lt;-- desired I have the code for this here https://github.com/wandersoncferreira/honey-ext/blob/07257daffad1b56fb6923b1d420385f1108c3ce7/src/honey_ext/json.clj#L40 does this make sense or I would need necessary to pass the vector elements separated as params? [:-&gt; :data ?:key1 :?key2] (as this is a path, I thought sending a vector would be better imo)"><y>#</y><d>2021-08-23</d><h>12:21</h><w>bartuka</w>thanks for the help <a>@seancorfield</a> I have another variation of this problem. If <code>:?path</code> is a vector and I want to unpack the vector inside my formatter e.g.
<pre>;; better syntax for path:
(sql/format {:select [:*]
             :from [:honey]
             :where [:-&gt; :data :?path]}
            {:params {:path [&quot;key1&quot; &quot;key2&quot;]}})
;; =&gt; [&quot;SELECT * FROM honey WHERE DATA-&gt;?&quot; [&quot;key1&quot; &quot;key2&quot;]]  &lt;&lt;&lt;-- wrong
;; desired
;; =&gt; [&quot;SELECT * FROM honey WHERE DATA-&gt;?-&gt;?&quot; &quot;key1&quot; &quot;key2&quot;]  &lt;&lt;&lt;-- desired</pre>
I have the code for this here <a href="https://github.com/wandersoncferreira/honey-ext/blob/07257daffad1b56fb6923b1d420385f1108c3ce7/src/honey_ext/json.clj#L40" target="_blank">https://github.com/wandersoncferreira/honey-ext/blob/07257daffad1b56fb6923b1d420385f1108c3ce7/src/honey_ext/json.clj#L40</a>

does this make sense or I would need necessary to pass the vector elements separated as params? <code>[:-&gt; :data ?:key1 :?key2]</code>  (as this is a path, I thought sending a vector would be better imo)</z><z id="t1629738945" t="seancorfield [:attrs {:href &quot;/_/_/users/UBSREKQ5Q&quot;}] Bear in mind that, in general, the argument to a formatter can be a completely arbitrary DSL expression and could render to just SQL or to some SQL and an arbitrary number of parameters (because the expression could be arbitrarily complex). I don&apos;t think your mental model of how formatters work lines up with reality at the moment 🙂"><y>#</y><d>2021-08-23</d><h>17:15</h><w>seancorfield</w><a>@iagwanderson</a> Bear in mind that, in general, the argument to a formatter can be a completely arbitrary DSL expression and could render to just SQL or to some SQL and an arbitrary number of parameters (because the expression could be arbitrarily complex). I don&apos;t think your mental model of how formatters work lines up with reality at the moment <b>🙂</b></z><z id="t1629740159" t="bartuka In the second example here https://github.com/seancorfield/honeysql#extensibility the :a value could be an arbitrary SQL expression and the only thing that :betwixt operator guarantees is the &quot;order&quot; that these arbitrary SQL will be placed related to the other 2 parameter values."><y>#</y><d>2021-08-23</d><h>17:35</h><r>bartuka</r>In the second example here <a href="https://github.com/seancorfield/honeysql#extensibility" target="_blank">https://github.com/seancorfield/honeysql#extensibility</a> the <code>:a</code> value could be an arbitrary SQL expression  and the only thing that <code>:betwixt</code> operator guarantees is the &quot;order&quot; that these arbitrary SQL will be placed related to the other 2 parameter values.</z><z id="t1629740204" t="bartuka this is how I should read this example?"><y>#</y><d>2021-08-23</d><h>17:36</h><r>bartuka</r>this is how I should read this example?</z><z id="t1629741714" t="seancorfield Yes, that&apos;s why there are three format-expr calls and then the SQL and the params are assembled into the result: (let [[sql-a &amp; params-a] (sql/format-expr a) [sql-b &amp; params-b] (sql/format-expr b) [sql-c &amp; params-c] (sql/format-expr c)]"><y>#</y><d>2021-08-23</d><h>18:01</h><r>seancorfield</r>Yes, that&apos;s why there are three <code>format-expr</code> calls and then the SQL and the params are assembled into the result:
<pre>(let [[sql-a &amp; params-a] (sql/format-expr a)
                          [sql-b &amp; params-b] (sql/format-expr b)
                          [sql-c &amp; params-c] (sql/format-expr c)]</pre></z><z id="t1629744360" t="bartuka got it! leaving the named parameters aside, I am thinking if the approach of the :-&gt; operator is useful or not. I am working a lot with jsonb columns and was exploring some ways to make it more honeyql-like 😃 instead of using raw calls"><y>#</y><d>2021-08-23</d><h>18:46</h><r>bartuka</r>got it! leaving the named parameters aside, I am thinking if the approach of the <code>:-&gt;</code> operator is useful or not. I am working a lot with jsonb columns and was exploring some ways to make it more honeyql-like <b>😃</b> instead of using <code>raw</code> calls</z><z id="t1629744839" t="seancorfield I&apos;m not familiar with that operator but it doesn&apos;t seem like you need anything custom for it: dev=&gt; (sql/register-op! :-&gt; :variadic true) nil dev=&gt; (sql/format-expr [:-&gt; :data :a :b :c]) [&quot;data -&gt; a -&gt; b -&gt; c&quot;]"><y>#</y><d>2021-08-23</d><h>18:53</h><r>seancorfield</r>I&apos;m not familiar with that operator but it doesn&apos;t seem like you need anything custom for it:
<pre>dev=&gt; (sql/register-op! :-&gt; :variadic true)
nil
dev=&gt; (sql/format-expr [:-&gt; :data :a :b :c])
[&quot;data -&gt; a -&gt; b -&gt; c&quot;]</pre></z><z id="t1629744886" t="seancorfield Is that what you&apos;re trying to produce?"><y>#</y><d>2021-08-23</d><h>18:54</h><r>seancorfield</r>Is that what you&apos;re trying to produce?</z><z id="t1629739090" t="seancorfield Formatters do not have access to named parameters. By design. And that&apos;s because any expression in the DSL can expand to SQL with zero or more parameters -- and the parameters vector is only fully known once the entire DSL &quot;statement&quot; has been processed, and the top-level formatter then processes the :params hash map (to unwrap the placeholders that are put into the parameter slots by the formatters)."><y>#</y><d>2021-08-23</d><h>17:18</h><w>seancorfield</w>Formatters do not have access to named parameters. By design. And that&apos;s because any expression in the DSL can expand to SQL with zero or more parameters -- and the parameters vector is only fully known once the entire DSL &quot;statement&quot; has been processed, and the top-level formatter then processes the <code>:params</code> hash map (to unwrap the placeholders that are put into the parameter slots by the formatters).</z><z id="t1630023991" t="v3ga I’m just curious, I was doing some refactoring and “create-architect2” throws a HStore extension not installed. I did some initial digging and it appears to be json related which means ‘[:lift …]’ is throwing it off. My first ‘create-architect’ function works fine, but I’d like to know what’s so different in the background here?"><y>#</y><d>2021-08-27</d><h>00:26</h><w>v3ga</w>I’m just curious, I was doing some refactoring and “create-architect2” throws a HStore extension not installed.  I did some initial digging and it appears to be json related which means ‘[:lift …]’ is throwing it off.  My first ‘create-architect’ function works fine, but I’d like to know what’s so different in the background here?</z><z id="t1630024951" t="seancorfield [:attrs {:href &quot;/_/_/users/U06FM9QN9&quot;}] were you passing the lifted value into the working version?"><y>#</y><d>2021-08-27</d><h>00:42</h><w>seancorfield</w><a>@decim</a> were you passing the lifted value into the working version?</z><z id="t1630025024" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] yup, same exact way, I literally just copied the function call over and changed the name and wrapped it in (query! …)"><y>#</y><d>2021-08-27</d><h>00:43</h><w>v3ga</w><a>@seancorfield</a> yup, same exact way, I literally just copied the function call over and changed the name and wrapped it in (query! …)</z><z id="t1630025091" t="seancorfield I&apos;m not at my computer so I can&apos;t try anything but I don&apos;t see anything obvious on my phone"><y>#</y><d>2021-08-27</d><h>00:44</h><w>seancorfield</w>I&apos;m not at my computer so I can&apos;t try anything but I don&apos;t see anything obvious on my phone</z><z id="t1630025146" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] hmm, ok. It’s a bit odd. The initial function works but clearly something is thrown off. I’ll continue to toy with it a little later tonight."><y>#</y><d>2021-08-27</d><h>00:45</h><w>v3ga</w><a>@seancorfield</a> hmm, ok. It’s a bit odd. The initial function works but clearly something is thrown off.  I’ll continue to toy with it a little later tonight.</z><z id="t1630042885" t="seancorfield [:attrs {:href &quot;/_/_/users/U06FM9QN9&quot;}] I ran both of these and they produce identical results -- in terms of what is handed off to next.jdbc so I don&apos;t think this is a HoneySQL issue (nor a bug in your code). Something else must be at play here."><y>#</y><d>2021-08-27</d><h>05:41</h><w>seancorfield</w><a>@decim</a> I ran both of these and they produce identical results -- in terms of what is handed off to <code>next.jdbc</code> so I don&apos;t think this is a HoneySQL issue (nor a bug in your code). Something else must be at play here.</z><z id="t1630206107" t="v3ga [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ok. I’ve left it over for now but I’ve tagged a note to that bit of code. My curiosity will bring my back to it in time. I’m sure it’s something small/odd. "><y>#</y><d>2021-08-29</d><h>03:01</h><w>v3ga</w><a>@seancorfield</a> ok. I’ve left it over for now but I’ve tagged a note to that bit of code. My curiosity will bring my back to it in time. I’m sure it’s something small/odd.  </z><z id="t1630308798" t="quan hi, how can we create add primary key ddl in honeysql? look like there is no add-primary-key helper fn? ALTER TABLE table_name ADD PRIMARY KEY (id);"><y>#</y><d>2021-08-30</d><h>07:33</h><w>quan</w>hi, how can we create add primary key ddl in honeysql? look like there is no <code>add-primary-key</code> helper fn?
<pre>ALTER TABLE table_name ADD PRIMARY KEY (id);</pre></z><z id="t1630336921" t="seancorfield [:attrs {:href &quot;/_/_/users/U050PGQ9J&quot;}] Use :add-index : dev=&gt; (-&gt; (h/alter-table :foo) #_=&gt; (h/add-index :primary-key :id) #_=&gt; (sql/format)) [&quot;ALTER TABLE foo ADD PRIMARY KEY(id)&quot;] dev=&gt; "><y>#</y><d>2021-08-30</d><h>15:22</h><w>seancorfield</w><a>@quan</a> Use <code>:add-index</code>:
<pre>dev=&gt; (-&gt; (h/alter-table :foo)
 #_=&gt;     (h/add-index :primary-key :id)
 #_=&gt;     (sql/format))
[&quot;ALTER TABLE foo ADD PRIMARY KEY(id)&quot;]
dev=&gt; </pre></z><z id="t1630337082" t="seancorfield It&apos;s a combination of https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#add-index-drop-index and https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-special-syntax-#foreign-key-primary-key -- I&apos;ll create an issue to add an example and cross-link these."><y>#</y><d>2021-08-30</d><h>15:24</h><w>seancorfield</w>It&apos;s a combination of <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#add-index-drop-index" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#add-index-drop-index</a> and <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-special-syntax-#foreign-key-primary-key" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-special-syntax-#foreign-key-primary-key</a> -- I&apos;ll create an issue to add an example and cross-link these.</z><z id="t1630337159" t="seancorfield https://github.com/seancorfield/honeysql/issues/347"><y>#</y><d>2021-08-30</d><h>15:25</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/347" target="_blank">https://github.com/seancorfield/honeysql/issues/347</a></z><z id="t1630378320" t="quan ah great, thank [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2021-08-31</d><h>02:52</h><w>quan</w>ah great, thank <a>@seancorfield</a></z><z id="t1630379817" t="quan another question, do we have create index command https://www.postgresql.org/docs/current/sql-createindex.html , it seem different with add-index above? CREATE INDEX ON foo (title);"><y>#</y><d>2021-08-31</d><h>03:16</h><w>quan</w>another question, do we have create index command <a href="https://www.postgresql.org/docs/current/sql-createindex.html" target="_blank">https://www.postgresql.org/docs/current/sql-createindex.html</a>, it seem different with <code>add-index</code> above?
<pre>CREATE INDEX ON foo (title);</pre></z><z id="t1630385803" t="quan yeah, I just want to quick check if honeysql already support that."><y>#</y><d>2021-08-31</d><h>04:56</h><w>quan</w>yeah, I just want to quick check if honeysql already support that.</z><z id="t1630387059" t="seancorfield [:attrs {:href &quot;/_/_/users/U050PGQ9J&quot;}] Is there a reason to use CREATE INDEX ON &lt;table&gt; ... rather than ALTER TABLE &lt;table&gt; ADD &lt;index&gt; ... ?"><y>#</y><d>2021-08-31</d><h>05:17</h><w>seancorfield</w><a>@quan</a> Is there a reason to use <code>CREATE INDEX ON &lt;table&gt; ...</code> rather than <code>ALTER TABLE &lt;table&gt; ADD &lt;index&gt; ...</code> ?</z><z id="t1630387088" t="seancorfield SQL/DDL is insanely variable so it&apos;s really kind of hard to support everything... 🙂"><y>#</y><d>2021-08-31</d><h>05:18</h><w>seancorfield</w>SQL/DDL is insanely variable so it&apos;s really kind of hard to support everything... <b>🙂</b></z><z id="t1630387261" t="seancorfield Ugh! Because PG doesn&apos;t let you alter table and add an index concurrently..."><y>#</y><d>2021-08-31</d><h>05:21</h><w>seancorfield</w>Ugh! Because PG doesn&apos;t let you alter table and add an index concurrently...</z><z id="t1630387289" t="seancorfield Fine (gods, I hate PostgreSQL!) go create an issue on GH and I&apos;ll look at adding it..."><y>#</y><d>2021-08-31</d><h>05:21</h><w>seancorfield</w>Fine (gods, I hate PostgreSQL!) go create an issue on GH and I&apos;ll look at adding it...</z><z id="t1630387312" t="seancorfield PG is far and away the most work of any database I ever have to support, both for HoneySQL and for next.jdbc 😞"><y>#</y><d>2021-08-31</d><h>05:21</h><w>seancorfield</w>PG is far and away the most work of any database I ever have to support, both for HoneySQL and for <code>next.jdbc</code> <b>😞</b></z><z id="t1630387801" t="quan thanks! I&apos;m fine just using jdbc query for now."><y>#</y><d>2021-08-31</d><h>05:30</h><w>quan</w>thanks! I&apos;m fine just using jdbc query for now.</z><z id="t1630388074" t="quan for delete-from helper, how can I add alias for delete table. I try with this but it&apos;s not expected (-&gt; (delete-from [:foo :a]) (using [:bar :b]) (where [:= :a.id :b.id]) sql/format) =&gt; [&quot;DELETE FROM FOO(a) USING bar b WHERE a.id = b.id&quot;]"><y>#</y><d>2021-08-31</d><h>05:34</h><w>quan</w>for <code>delete-from</code> helper, how can I add alias for delete table. I try with this but it&apos;s not expected
<pre>(-&gt; (delete-from [:foo :a])
    (using [:bar :b])
    (where [:= :a.id :b.id])
    sql/format)
=&gt; [&quot;DELETE FROM FOO(a) USING bar b WHERE a.id = b.id&quot;]</pre></z><z id="t1630389099" t="seancorfield It&apos;s late. I&apos;m in bed. I&apos;ll look at that tomorrow"><y>#</y><d>2021-08-31</d><h>05:51</h><w>seancorfield</w>It&apos;s late. I&apos;m in bed. I&apos;ll look at that tomorrow</z><z id="t1630427998" t="seancorfield [:attrs {:href &quot;/_/_/users/U050PGQ9J&quot;}] Is this what you&apos;re looking for in that delete-from ? dev=&gt; (-&gt; (h/delete-from :foo :a) #_=&gt; (h/using [:bar :b]) #_=&gt; (h/where [:= :a.id :b.id]) #_=&gt; (sql/format)) [&quot;DELETE FROM foo a USING bar b WHERE a.id = b.id&quot;]"><y>#</y><d>2021-08-31</d><h>16:39</h><w>seancorfield</w><a>@quan</a> Is this what you&apos;re looking for in that <code>delete-from</code>?
<pre>dev=&gt; (-&gt; (h/delete-from :foo :a)
 #_=&gt;     (h/using [:bar :b])
 #_=&gt;     (h/where [:= :a.id :b.id])
 #_=&gt;     (sql/format))
[&quot;DELETE FROM foo a USING bar b WHERE a.id = b.id&quot;]</pre></z><z id="t1630492721" t="quan ah yeah, thank [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] . For me look like behavior of delete-from is inconsistent with another function, e.g using bellow. It seem not clear to have (h/delete-from :foo :a) based on the doc 🙂"><y>#</y><d>2021-09-01</d><h>10:38</h><r>quan</r>ah yeah, thank <a>@seancorfield</a>. For me look like behavior of <code>delete-from</code> is inconsistent with another function, e.g <code>using</code> bellow. It seem not clear to have <code>(h/delete-from :foo :a)</code> based on the doc <b>🙂</b></z><z id="t1630512200" t="seancorfield It wasn&apos;t a syntax I expected. I&apos;ll need to look at the docs for the various databases, and also in more detail at that specific formatter."><y>#</y><d>2021-09-01</d><h>16:03</h><r>seancorfield</r>It wasn&apos;t a syntax I expected. I&apos;ll need to look at the docs for the various databases, and also in more detail at that specific formatter.</z><z id="t1630516421" t="seancorfield [:attrs {:href &quot;/_/_/users/U050PGQ9J&quot;}] I double-checked and delete-from is formatted like a select except that it expects a single form, however it doesn&apos;t add AS which probably makes more sense so I&apos;ll update the as filter so delete-from is formatted that way. I still need to double-check a few databases&apos; docs to verify that is safe."><y>#</y><d>2021-09-01</d><h>17:13</h><r>seancorfield</r><a>@quan</a> I double-checked and <code>delete-from</code> is formatted like a <code>select</code> except that it expects a single form, however it doesn&apos;t add <code>AS</code> which probably makes more sense so I&apos;ll update the <code>as</code> filter so <code>delete-from</code> is formatted that way. I still need to double-check a few databases&apos; docs to verify that is safe.</z><z id="t1630516696" t="seancorfield Looks like that might be PG only, but I think alias support is harmless -- delete from foo a ... will work on PG and won&apos;t work on other DBs, so it would be clearer to support delete from foo as a ... I think."><y>#</y><d>2021-09-01</d><h>17:18</h><r>seancorfield</r>Looks like that might be PG only, but I think alias support is harmless -- <code>delete from foo a ...</code> will work on PG and won&apos;t work on other DBs, so it would be clearer to support <code>delete from foo as a ...</code> I think.</z><z id="t1630516825" t="seancorfield (that&apos;ll be in the next release -- but you have a working solution now)"><y>#</y><d>2021-09-01</d><h>17:20</h><r>seancorfield</r>(that&apos;ll be in the next release -- but you have a working solution now)</z><z id="t1630428347" t="seancorfield Here&apos;s the issue for create index https://github.com/seancorfield/honeysql/issues/348 -- it&apos;s hard because that&apos;s completely vendor-specific syntax (and not compatible between PG and MS SQL -- I haven&apos;t even looked at Oracle or MySQL there. DDL is all over the map across different DBs."><y>#</y><d>2021-08-31</d><h>16:45</h><w>seancorfield</w>Here&apos;s the issue for <code>create index</code> <a href="https://github.com/seancorfield/honeysql/issues/348" target="_blank">https://github.com/seancorfield/honeysql/issues/348</a> -- it&apos;s hard because that&apos;s completely vendor-specific syntax (and not compatible between PG and MS SQL -- I haven&apos;t even looked at Oracle or MySQL there. DDL is all over the map across different DBs.</z><z id="t1630492773" t="quan yeah, I&apos;m not work much with MySQL recently, so not aware these different.."><y>#</y><d>2021-09-01</d><h>10:39</h><r>quan</r>yeah, I&apos;m not work much with MySQL recently, so not aware these different..</z><z id="t1630428453" t="seancorfield For comparison, here&apos;s MySQL which is different again https://dev.mysql.com/doc/refman/5.7/en/create-index.html"><y>#</y><d>2021-08-31</d><h>16:47</h><w>seancorfield</w>For comparison, here&apos;s MySQL which is different again <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank">https://dev.mysql.com/doc/refman/5.7/en/create-index.html</a></z><z id="t1631159094" t="pinealan Hi chat, how would you add a frame clause on window definitions using honey? i.e. SELECT ... sum(amount) over (PARTITION BY fruit ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM fruit_sale"><y>#</y><d>2021-09-09</d><h>03:44</h><w>pinealan</w>Hi chat, how would you add a <code>frame clause</code> on window definitions using honey? i.e.
<pre>SELECT ...
  sum(amount) over (PARTITION BY fruit ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM fruit_sale</pre></z><z id="t1631160024" t="seancorfield [:attrs {:href &quot;/_/_/users/U0112ACBNRM&quot;}] That&apos;s more specific than the :partition-by syntax that HoneySQL supports right now. What DB is that for?"><y>#</y><d>2021-09-09</d><h>04:00</h><w>seancorfield</w><a>@achan961117</a> That&apos;s more specific than the <code>:partition-by</code> syntax that HoneySQL supports right now. What DB is that for?</z><z id="t1631160064" t="seancorfield Could you open an issue on GitHub with details and a link to the DB&apos;s docs for PARTITION BY and I&apos;ll see what I can do next time I&apos;m working on OSS (in a week or two, I expect)."><y>#</y><d>2021-09-09</d><h>04:01</h><w>seancorfield</w>Could you open an issue on GitHub with details and a link to the DB&apos;s docs for <code>PARTITION BY</code> and I&apos;ll see what I can do next time I&apos;m working on OSS (in a week or two, I expect).</z><z id="t1631160146" t="pinealan it’s for postgres, I realised it’s pretty specific usecases so I’m reading up the docs on register-clause! now"><y>#</y><d>2021-09-09</d><h>04:02</h><w>pinealan</w>it’s for postgres, I realised it’s pretty specific usecases so I’m reading up the docs on <code>register-clause!</code> now</z><z id="t1631160157" t="pinealan here’s the postgres docs for reference https://www.postgresql.org/docs/11/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS"><y>#</y><d>2021-09-09</d><h>04:02</h><w>pinealan</w>here’s the postgres docs for reference
<a href="https://www.postgresql.org/docs/11/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" target="_blank">https://www.postgresql.org/docs/11/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS</a></z><z id="t1631160166" t="seancorfield Put it in an issue 🙂"><y>#</y><d>2021-09-09</d><h>04:02</h><w>seancorfield</w>Put it in an issue <b>🙂</b></z><z id="t1631160178" t="pinealan sure will do 👌"><y>#</y><d>2021-09-09</d><h>04:02</h><w>pinealan</w>sure will do <b>👌</b></z><z id="t1631160190" t="seancorfield And, yeah, I f&apos;ing h8t PostgreSQL 🙂"><y>#</y><d>2021-09-09</d><h>04:03</h><w>seancorfield</w>And, yeah, I f&apos;ing h8t PostgreSQL <b>🙂</b></z><z id="t1631160406" t="seancorfield It&apos;s like the absolute opposite of Clojure in a database 😛"><y>#</y><d>2021-09-09</d><h>04:06</h><w>seancorfield</w>It&apos;s like the absolute opposite of Clojure in a database <b>😛</b></z><z id="t1631188647" t="cyppan Is there a way to deactivate the transform of “-” into “_” in table names? BigQuery uses dashes in project names, and the table name is in the form projectName.datasetName.tableName (sql/format (sql-h/create-table :test-dash)) =&gt; [&quot;CREATE TABLE test_dash&quot;]"><y>#</y><d>2021-09-09</d><h>11:57</h><w>cyppan</w>Is there a way to deactivate the transform of “-” into “_” in table names? BigQuery uses dashes in project names, and the table name is in the form <code>projectName.datasetName.tableName</code>
<pre>(sql/format (sql-h/create-table :test-dash))
=&gt; [&quot;CREATE TABLE test_dash&quot;]</pre></z><z id="t1631189264" t="V (sql/format (sql-h/create-table :test-dash) {:quoted true}) =&gt; [&quot;CREATE TABLE \&quot;test-dash\&quot;&quot;]"><y>#</y><d>2021-09-09</d><h>12:07</h><w>V</w><pre>(sql/format (sql-h/create-table :test-dash) {:quoted true})
=&gt; [&quot;CREATE TABLE \&quot;test-dash\&quot;&quot;]</pre></z><z id="t1631189706" t="cyppan Thank you I’ve tried that but there is another problem, I need two dots in my table name, like project-dashed.dataset.table I’ve tried (sql/format (sql-h/create-table :project-dashed.dataset/table) {:quoted true}) =&gt; [&quot;CREATE TABLE \&quot;project_dashed.dataset\&quot;.\&quot;table\&quot;&quot;] (sql/format (sql-h/create-table :project-dashed.dataset.table) {:quoted true}) =&gt; [&quot;CREATE TABLE \&quot;project-dashed\&quot;.\&quot;dataset\&quot;&quot;] ;; it works but the table name disapeared (sql/format (sql-h/create-table &quot;project-dashed.dataset.table&quot;) {:quoted true}) Execution error (NullPointerException) at honey.sql/namespace (sql.cljc:154). null "><y>#</y><d>2021-09-09</d><h>12:15</h><r>cyppan</r>Thank you I’ve tried that but there is another problem, I need two dots in my table name, like <code>project-dashed.dataset.table</code>
I’ve tried
<pre>(sql/format (sql-h/create-table :project-dashed.dataset/table) {:quoted true})
=&gt; [&quot;CREATE TABLE \&quot;project_dashed.dataset\&quot;.\&quot;table\&quot;&quot;]

(sql/format (sql-h/create-table :project-dashed.dataset.table) {:quoted true})
=&gt; [&quot;CREATE TABLE \&quot;project-dashed\&quot;.\&quot;dataset\&quot;&quot;]
;; it works but the table name disapeared

(sql/format (sql-h/create-table &quot;project-dashed.dataset.table&quot;) {:quoted true})
Execution error (NullPointerException) at honey.sql/namespace (sql.cljc:154).
null</pre>
</z><z id="t1631208797" t="seancorfield [:attrs {:href &quot;/_/_/users/U0CL38MU1&quot;}] Looks like it is actually two bugs compounded here. After I extended :create-table &apos;s syntax, it no longer processes strings correctly for the table name, which was supposed to be the way to handle this, but there&apos;s also a bug in format-entity that doesn&apos;t handle multi-segment names in string properly. https://github.com/seancorfield/honeysql/issues/353"><y>#</y><d>2021-09-09</d><h>17:33</h><r>seancorfield</r><a>@U0CL38MU1</a> Looks like it is actually two bugs compounded here. After I extended <code>:create-table</code>&apos;s syntax, it no longer processes strings correctly for the table name, which was supposed to be the way to handle this, but there&apos;s also a bug in <code>format-entity</code> that doesn&apos;t handle multi-segment names in string properly. <a href="https://github.com/seancorfield/honeysql/issues/353" target="_blank">https://github.com/seancorfield/honeysql/issues/353</a></z><z id="t1631209315" t="seancorfield That&apos;s fixed on develop now if you want to try it out via git deps but I need to do a pass over the documentation to make sure the behavior is accurately reflected there (and probably to add notes about using strings for complex, qualified entity names)."><y>#</y><d>2021-09-09</d><h>17:41</h><r>seancorfield</r>That&apos;s fixed on develop now if you want to try it out via git deps but I need to do a pass over the documentation to make sure the behavior is accurately reflected there (and probably to add notes about using strings for complex, qualified entity names).</z><z id="t1631212830" t="cyppan awesome thank you [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I’ll try that"><y>#</y><d>2021-09-09</d><h>18:40</h><r>cyppan</r>awesome thank you <a>@U04V70XH6</a> I’ll try that</z><z id="t1631212850" t="cyppan I was indeed surprised the string version didn’t work"><y>#</y><d>2021-09-09</d><h>18:40</h><r>cyppan</r>I was indeed surprised the string version didn’t work</z><z id="t1631189278" t="V Might solve your issue"><y>#</y><d>2021-09-09</d><h>12:07</h><w>V</w>Might solve your issue</z><z id="t1631741937" t="sansarip Sorry if I’m missing something obvious, but how would you write a honeysql map that contains a join , left-join , and join - in that order? Something equivalent to this SQL query for example: select * from foo join bar on foo.id = bar.id left join baz on foo.id = baz.id join qux on foo.id = qux.id"><y>#</y><d>2021-09-15</d><h>21:38</h><w>sansarip</w>Sorry if I’m missing something obvious, but how would you write a honeysql map that contains a <code>join</code>, <code>left-join</code>, and <code>join</code> - in that order?

Something equivalent to this SQL query for example:

<pre>select *
from foo
join bar on foo.id = bar.id
left join baz on foo.id = baz.id
join qux on foo.id = qux.id</pre></z><z id="t1631742225" t="seancorfield [:attrs {:href &quot;/_/_/users/U022T96EFV3&quot;}] https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#join-by"><y>#</y><d>2021-09-15</d><h>21:43</h><w>seancorfield</w><a>@pehrans</a> <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#join-by" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.0.783/doc/getting-started/sql-clause-reference#join-by</a></z><z id="t1631742266" t="sansarip I knew I was missing something obvious, doh! :face_palm: Thanks!"><y>#</y><d>2021-09-15</d><h>21:44</h><r>sansarip</r>I knew I was missing something obvious, doh! <b>:face_palm:</b>  Thanks!</z><z id="t1631847849" t="armed Yes it’s a great feature. Made me upgrade to version 2"><y>#</y><d>2021-09-17</d><h>03:04</h><r>armed</r>Yes it’s a great feature. Made me upgrade to version 2</z><z id="t1631838638" t="john-shaffer What do you think about allowing a set as the value of a :select? Would that cause any problems?"><y>#</y><d>2021-09-17</d><h>00:30</h><w>john-shaffer</w>What do you think about allowing a set as the value of a :select? Would that cause any problems?</z><z id="t1631838807" t="seancorfield Can you elaborate? I&apos;m not entirely sure what you&apos;re asking..."><y>#</y><d>2021-09-17</d><h>00:33</h><r>seancorfield</r>Can you elaborate? I&apos;m not entirely sure what you&apos;re asking...</z><z id="t1631838834" t="john-shaffer Like {:select #{:id} :from :table}"><y>#</y><d>2021-09-17</d><h>00:33</h><r>john-shaffer</r>Like <code>{:select #{:id} :from :table}</code></z><z id="t1631838848" t="john-shaffer Right now it throws"><y>#</y><d>2021-09-17</d><h>00:34</h><r>john-shaffer</r>Right now it throws</z><z id="t1631839068" t="seancorfield Well, the logic that formats a :select also formats several other statements in the DSL so I&apos;d have to take a close look at those. Worst case I&apos;d have to special case :select and preprocess the argument to make it compatible I guess. Feel free to open an issue."><y>#</y><d>2021-09-17</d><h>00:37</h><r>seancorfield</r>Well, the logic that formats a <code>:select</code> also formats several other statements in the DSL so I&apos;d have to take a close look at those. Worst case I&apos;d have to special case <code>:select</code> and preprocess the argument to make it compatible I guess. Feel free to open an issue.</z><z id="t1631839211" t="john-shaffer Okay, thanks"><y>#</y><d>2021-09-17</d><h>00:40</h><r>john-shaffer</r>Okay, thanks</z><z id="t1632618383" t="seancorfield HoneySQL 2.0.813 is available. In addition, I&apos;ve updated the CI pipeline to push a 2.0.999-SNAPSHOT to Clojars for every push on the develop branch so if you&apos;re not able to use git deps, you can still test out the very latest enhancements via lein ."><y>#</y><d>2021-09-26</d><h>01:06</h><w>seancorfield</w>HoneySQL 2.0.813 is available. In addition, I&apos;ve updated the CI pipeline to push a 2.0.999-SNAPSHOT to Clojars for every push on the develop branch so if you&apos;re not able to use git deps, you can still test out the very latest enhancements via <code>lein</code>.</z><z id="t1632638515" t="vlaaad What do you think about creating specs for honeysql data structure format?"><y>#</y><d>2021-09-26</d><h>06:41</h><w>vlaaad</w>What do you think about creating specs for honeysql data structure format?</z><z id="t1632682099" t="seancorfield https://github.com/seancorfield/honeysql/issues/146"><y>#</y><d>2021-09-26</d><h>18:48</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/146" target="_blank">https://github.com/seancorfield/honeysql/issues/146</a></z><z id="t1632682169" t="seancorfield TL;DR: the DSL is so big and complex and SQL allows so many variations that it really isn&apos;t tractable."><y>#</y><d>2021-09-26</d><h>18:49</h><w>seancorfield</w>TL;DR: the DSL is so big and complex and SQL allows so many variations that it really isn&apos;t tractable.</z><z id="t1632691403" t="vlaaad Interesting, thanks for the link. I agree it&apos;s too much to expect spec to validate DSL so it produces only valid SQL statements, but more primitive specification might still be useful.."><y>#</y><d>2021-09-26</d><h>21:23</h><w>vlaaad</w>Interesting, thanks for the link. I agree it&apos;s too much to expect spec to validate DSL so it produces only valid SQL statements, but more primitive specification might still be useful..</z><z id="t1632691507" t="vlaaad I&apos;ll think some more about it.."><y>#</y><d>2021-09-26</d><h>21:25</h><w>vlaaad</w>I&apos;ll think some more about it..</z><z id="t1632692537" t="seancorfield I&apos;ve spent quite a bit of time on it over the past three years since I waded into that issue. I really wanted it at the beginning. But I came to realize it just isn&apos;t really tractable in any useful way. Just want to set the expectations that I will not accept a PR for it, after the time I&apos;ve spent thinking about it."><y>#</y><d>2021-09-26</d><h>21:42</h><r>seancorfield</r>I&apos;ve spent quite a bit of time on it over the past three years since I waded into that issue. I really wanted it at the beginning. But I came to realize it just isn&apos;t really tractable in any useful way. Just want to set the expectations that I will not accept a PR for it, after the time I&apos;ve spent thinking about it.</z><z id="t1632721021" t="vlaaad Ah, okay. Good that you said it, since your last comment on that issue says you are open to PRs :)"><y>#</y><d>2021-09-27</d><h>05:37</h><r>vlaaad</r>Ah, okay. Good that you said it, since your last comment on that issue says you are open to PRs :)</z><z id="t1632762217" t="seancorfield Yeah, I mean if someone really wants to send a PR, even after hearing all of that background on the subject, I&apos;ll consider it. But I wanted you to have all the background before you invested any time in it."><y>#</y><d>2021-09-27</d><h>17:03</h><r>seancorfield</r>Yeah, I mean if someone really wants to send a PR, even after hearing all of that background on the subject, I&apos;ll consider it. But I wanted you to have all the background before you invested any time in it.</z><z id="t1632773017" t="Michael Gardner FWIW, some time ago I wanted to walk a HoneySQL (1.0) query to transform table names. I initially tried to identify all the &quot;places&quot; that could contain table names, but quickly found it intractable for the same reasons spec-ing the thing is hard. Instead I ended up using namespaced :table/foo keywords everywhere, so I could just postwalk and automatically know what&apos;s a table"><y>#</y><d>2021-09-27</d><h>20:03</h><w>Michael Gardner</w>FWIW, some time ago I wanted to walk a HoneySQL (1.0) query to transform table names. I initially tried to identify all the &quot;places&quot; that could contain table names, but quickly found it intractable for the same reasons spec-ing the thing is hard.

Instead I ended up using namespaced <code>:table/foo</code> keywords everywhere, so I could just <code>postwalk</code> and automatically know what&apos;s a table</z><z id="t1632773108" t="Michael Gardner of course that only worked because I controlled all the queries. If you&apos;re trying to operate on HoneySQL from another source, you don&apos;t have that option"><y>#</y><d>2021-09-27</d><h>20:05</h><w>Michael Gardner</w>of course that only worked because I controlled all the queries. If you&apos;re trying to operate on HoneySQL from another source, you don&apos;t have that option</z><z id="t1633276274" t="alpox Hi everyone! Short question: Is it possible to make insert-into set DEFAULT instead of NULL on missing keys? Usecase: I want to use the on-conflict and do-update-set of postgres with uuid primary keys. If I now had a list of mixed fields where some already have an id and some not, honeysql inserts a NULL for the primary key where its missing and will therefore not be able to insert the entry due to a missing primary key."><y>#</y><d>2021-10-03</d><h>15:51</h><w>alpox</w>Hi everyone! Short question: Is it possible to make <code>insert-into</code> set <code>DEFAULT</code> instead of <code>NULL</code> on missing keys?
Usecase: I want to use the <code>on-conflict</code> and <code>do-update-set</code> of postgres with uuid primary keys.

If I now had a list of mixed fields where some already have an id and some not, honeysql inserts a <code>NULL</code> for the primary key where its missing and will therefore not be able to insert the entry due to a missing primary key.</z><z id="t1633277153" t="alpox I believe I can get around it by assigning uuids generated by java.util.UUID/randomUUID for entries that don&apos;t hold an id already but I&apos;d think it would be cleaner to let the database handle that"><y>#</y><d>2021-10-03</d><h>16:05</h><w>alpox</w>I believe I can get around it by assigning uuids generated by <code>java.util.UUID/randomUUID</code> for entries that don&apos;t hold an id already but I&apos;d think it would be cleaner to let the database handle that</z><z id="t1633280436" t="seancorfield [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] not sure I understand your question : honeysql just generates sql, it doesn&apos;t interact with the database at all - it doesn&apos;t actually insert anything."><y>#</y><d>2021-10-03</d><h>17:00</h><w>seancorfield</w><a>@alpox</a> not sure I understand your question : honeysql just generates sql, it doesn&apos;t interact with the database at all - it doesn&apos;t actually insert anything.</z><z id="t1633280487" t="seancorfield Honeysql knows nothing about databases, nothing about columns or defaults."><y>#</y><d>2021-10-03</d><h>17:01</h><w>seancorfield</w>Honeysql knows nothing about databases, nothing about columns or defaults.</z><z id="t1633281840" t="alpox [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Yes, my issue was with the sql generated by honeysql. If I take the data: (def fields [{:id #uuid &quot;e352239e-5ccc-4de4-8fcb-d9745a4c7739&quot; :name &quot;foo&quot; :position 1 :type &quot;foobar&quot; :table-field-name &quot;foo&quot; :entity-id (:entity/id new-entity)} {:name &quot;bar&quot; :position 2 :type &quot;bar&quot; :table-field-name &quot;bar&quot; :entity-id (:entity/id new-entity)}]) Where the first field has an id (already exists in the database) and the second one has no id (yet to be created) I give those fields to honeysql through: (-&gt; (hh/insert-into :field) (hh/values fields) ; fields here (hh/on-conflict :id) (hh/do-update-set :position :type :name :table_field_name) (hh/returning :id) (hsql/format)) The generated insert statement creates INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (NULL, ?, ?, ?, ?, ?) Where the NULL leads to an error due to a missing value for the primary key. If it was instead DEFAULT the id would instead be created by the database. This does not happen if I have only new fields (fields without ids) because the id field is omitted and the default will be used"><y>#</y><d>2021-10-03</d><h>17:24</h><w>alpox</w><a>@seancorfield</a> Yes, my issue was with the sql generated by honeysql. If I take the data:
<pre>(def fields [{:id #uuid &quot;e352239e-5ccc-4de4-8fcb-d9745a4c7739&quot;
                :name &quot;foo&quot;
                :position 1
                :type &quot;foobar&quot;
                :table-field-name &quot;foo&quot;
                :entity-id (:entity/id new-entity)}

               {:name &quot;bar&quot;
                :position 2
                :type &quot;bar&quot;
                :table-field-name &quot;bar&quot;
                :entity-id (:entity/id new-entity)}])
</pre>
Where the first field has an id (already exists in the database) and the second one has no id (yet to be created) I give those fields to honeysql through:
<pre>(-&gt; (hh/insert-into :field)
                     (hh/values fields) ; fields here
                     (hh/on-conflict :id)
                     (hh/do-update-set
                      :position
                      :type
                      :name
                      :table_field_name)
                     (hh/returning :id)
                     (hsql/format))
</pre>
The generated insert statement creates <code>INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (NULL, ?, ?, ?, ?, ?)</code>
Where the <code>NULL</code> leads to an error due to a missing value for the primary key. If it was instead <code>DEFAULT</code> the id would instead be created by the database.

This does not happen if I have only new fields (fields without ids) because the id field is omitted and the default will be used</z><z id="t1633282938" t="dharrigan A very simple, quick way of moving on from this, is simply to do a string replacement (as what comes out of (hsql/format) is a string"><y>#</y><d>2021-10-03</d><h>17:42</h><w>dharrigan</w>A very simple, quick way of moving on from this, is simply to do a string replacement (as what comes out of <code>(hsql/format)</code> is a string</z><z id="t1633282953" t="dharrigan (def sql &quot;INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (NULL, ?, ?, ?, ?, ?)&quot;)"><y>#</y><d>2021-10-03</d><h>17:42</h><w>dharrigan</w><code>(def sql &quot;INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (NULL, ?, ?, ?, ?, ?)&quot;)</code></z><z id="t1633282966" t="dharrigan (clojure.string/replace sql #&quot;\(NULL&quot; &quot;(DEFAULT&quot;)"><y>#</y><d>2021-10-03</d><h>17:42</h><w>dharrigan</w><code>(clojure.string/replace sql #&quot;\(NULL&quot; &quot;(DEFAULT&quot;)</code></z><z id="t1633282971" t="dharrigan &quot;INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (DEFAULT, ?, ?, ?, ?, ?)&quot;"><y>#</y><d>2021-10-03</d><h>17:42</h><w>dharrigan</w><code>&quot;INSERT INTO field (id, name, position, type, table_field_name, entity_id) VALUES (?, ?, ?, ?, ?, ?), (DEFAULT, ?, ?, ?, ?, ?)&quot;</code></z><z id="t1633283059" t="alpox Hmm yes thats a possible approach. But im not sure if this could not lead to followup errors in some cases where NULL is wanted still (e.g. explicitely specified nil)"><y>#</y><d>2021-10-03</d><h>17:44</h><w>alpox</w>Hmm yes thats a possible approach. But im not sure if this could not lead to followup errors in some cases where NULL is wanted still (e.g. explicitely specified nil)</z><z id="t1633283082" t="alpox I guess I have to apply it with caution"><y>#</y><d>2021-10-03</d><h>17:44</h><w>alpox</w>I guess I have to apply it with caution</z><z id="t1633283084" t="dharrigan one thing at a time 🙂 Tackle that bridge if you come to it."><y>#</y><d>2021-10-03</d><h>17:44</h><w>dharrigan</w>one thing at a time <b>🙂</b> Tackle that bridge if you come to it.</z><z id="t1633283471" t="alpox Thanks for the feedback :) ill go down that road for now as I dont think Ill run into trouble with this"><y>#</y><d>2021-10-03</d><h>17:51</h><w>alpox</w>Thanks for the feedback :) ill go down that road for now as I dont think Ill run into trouble with this</z><z id="t1633291368" t="seancorfield In a lot of situations, you really do want NULL inserted in a column so the choice to use DEFAULT instead is extremely context-sensitive. I&apos;m not sure what HoneySQL could actually do here to help."><y>#</y><d>2021-10-03</d><h>20:02</h><w>seancorfield</w>In a lot of situations, you really do want <code>NULL</code> inserted in a column so the choice to use <code>DEFAULT</code> instead is extremely context-sensitive. I&apos;m not sure what HoneySQL could actually do here to help.</z><z id="t1633291942" t="seancorfield You might even have a situation where you want NULL inserted for some nil columns (or missing columns), and DEFAULT for other columns in the same so how would HoneySQL know? There would have to be some way for you to tell it which columns should map to DEFAULT is nil /missing. That might be the best approach, on a per-call (to format ) basis, as some sort of option with a set of column names?"><y>#</y><d>2021-10-03</d><h>20:12</h><w>seancorfield</w>You might even have a situation where you want <code>NULL</code> inserted for some <code>nil</code> columns (or missing columns), and <code>DEFAULT</code> for other columns in the same  so how would HoneySQL know? There would have to be some way for you to tell it which columns should map to <code>DEFAULT</code> is <code>nil</code>/missing. That might be the best approach, on a per-call (to <code>format</code>) basis, as some sort of option with a set of column names?</z><z id="t1633292173" t="seancorfield https://github.com/seancorfield/honeysql/issues/366"><y>#</y><d>2021-10-03</d><h>20:16</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/366" target="_blank">https://github.com/seancorfield/honeysql/issues/366</a></z><z id="t1633293439" t="alpox &gt; That might be the best approach, on a per-call (to `format`) basis, as some sort of option with a set of column names? Maybe something like: (hsql/format sql {:insert-key-fallback {:id [:raw &quot;DEFAULT&quot;]}}) then? I would have liked to put it together with :values but there is no space for options at that point (which is probably for the best)."><y>#</y><d>2021-10-03</d><h>20:37</h><w>alpox</w>&gt; That might be the best approach, on a per-call (to `format`) basis, as some sort of option with a set of column names?
Maybe something like:
<pre>(hsql/format sql {:insert-key-fallback {:id [:raw &quot;DEFAULT&quot;]}})</pre>
then?

I would have liked to put it together with <code>:values</code> but there is no space for options at that point (which is probably for the best).</z><z id="t1633299030" t="seancorfield I&apos;ll have to give it sort thought, in terms of naming, and in terms of whether it should consider missing columns differently than nil values (in general HoneySQL doesn&apos;t -- and idiomatically Clojure generally doesn&apos;t). Not sure whether it needs to be a hash map from column to expression or just a set of columns that should turn into [:default] -- you don&apos;t need :raw here."><y>#</y><d>2021-10-03</d><h>22:10</h><w>seancorfield</w>I&apos;ll have to give it sort thought, in terms of naming, and in terms of whether it should consider missing columns differently than <code>nil</code> values (in general HoneySQL doesn&apos;t -- and idiomatically Clojure generally doesn&apos;t). Not sure whether it needs to be a hash map from column to expression or just a set of columns that should turn into <code>[:default]</code> -- you don&apos;t need <code>:raw</code> here.</z><z id="t1633299280" t="seancorfield See https://www.john-shaffer.com/honeysql/?q=%7B%3Ainsert-into%20%3Atable%0A%20%3Avalues%20%5B%7B%3Aid%201%2C%3Aname%20%22Sean%22%7D%0A%20%20%20%20%20%20%20%20%20%20%7B%3Aid%20%5B%3Adefault%5D%2C%20%3Aname%20%22Alpox%22%7D%5D%7D&amp;amp;opt=%7B%3Apretty%20true%7D"><y>#</y><d>2021-10-03</d><h>22:14</h><w>seancorfield</w>See <a href="https://www.john-shaffer.com/honeysql/?q=%7B%3Ainsert-into%20%3Atable%0A%20%3Avalues%20%5B%7B%3Aid%201%2C%3Aname%20%22Sean%22%7D%0A%20%20%20%20%20%20%20%20%20%20%7B%3Aid%20%5B%3Adefault%5D%2C%20%3Aname%20%22Alpox%22%7D%5D%7D&amp;amp;opt=%7B%3Apretty%20true%7D" target="_blank">https://www.john-shaffer.com/honeysql/?q=%7B%3Ainsert-into%20%3Atable%0A%20%3Avalues%20%5B%7B%3Aid%201%2C%3Aname%20%22Sean%22%7D%0A%20%20%20%20%20%20%20%20%20%20%7B%3Aid%20%5B%3Adefault%5D%2C%20%3Aname%20%22Alpox%22%7D%5D%7D&amp;amp;opt=%7B%3Apretty%20true%7D</a></z><z id="t1633299537" t="seancorfield [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] ☝️ :skin-tone-2: (you can&apos;t swap the value in your map for :id , just pointing out the syntax)"><y>#</y><d>2021-10-03</d><h>22:18</h><w>seancorfield</w><a>@alpox</a> <b>☝️</b><b>:skin-tone-2:</b> (you can&apos;t swap the value in your map for <code>:id</code>, just pointing out the syntax)</z><z id="t1633325651" t="seancorfield [:attrs {:href &quot;/_/_/users/U6JS7B99S&quot;}] I&apos;ve implemented the first cut of this. If you try 2.0.999-SNAPSHOT (or a git dep based on the head of develop), you can try an options hash map of {:values-default-columns #{:id}} in the hsql/format call and it should substitute DEFAULT for the :id column if it is missing from a hash map."><y>#</y><d>2021-10-04</d><h>05:34</h><w>seancorfield</w><a>@alpox</a> I&apos;ve implemented the first cut of this. If you try 2.0.999-SNAPSHOT (or a git dep based on the head of develop), you can try an options hash map of <code>{:values-default-columns #{:id}}</code> in the <code>hsql/format</code> call and it should substitute <code>DEFAULT</code> for the <code>:id</code> column if it is missing from a hash map.</z><z id="t1633325669" t="seancorfield See the important caveats in issue 366 for limitations."><y>#</y><d>2021-10-04</d><h>05:34</h><w>seancorfield</w>See the important caveats in issue 366 for limitations.</z><z id="t1633328473" t="dharrigan That&apos;s pretty awesome 🙂"><y>#</y><d>2021-10-04</d><h>06:21</h><w>dharrigan</w>That&apos;s pretty awesome <b>🙂</b></z><z id="t1633370179" t="alpox [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I have just seen and tried this. Wow that was crazy fast and works perfectly :thumbsup: thanks!"><y>#</y><d>2021-10-04</d><h>17:56</h><w>alpox</w><a>@seancorfield</a> I have just seen and tried this. Wow that was crazy fast and works perfectly <b>:thumbsup:</b> thanks!</z><z id="t1633380102" t="seancorfield Excellent. Thanks for testing it. I&apos;ll probably cut a new releases of both HoneySQL and next.jdbc this afternoon."><y>#</y><d>2021-10-04</d><h>20:41</h><w>seancorfield</w>Excellent. Thanks for testing it. I&apos;ll probably cut a new releases of both HoneySQL and <code>next.jdbc</code> this afternoon.</z><z id="t1633389291" t="seancorfield"><y>#</y><d>2021-10-04</d><h>23:14</h><w>seancorfield</w></z><z id="t1634568099" t="mauricio.szabo Hi there! Is it possible to somehow keep the aliases on HoneySQL as qualified keywords? I&apos;m querying a SQL database and I want to make aliases like SUM(&quot;person.age&quot;) as &quot;people/age&quot; . Is it possible for HoneySQL to keep aliases as qualified keywords? Something like {:select [[[:sum :person.age] :people/age]]} , but keeping the alias as-is (currently it is converting to &quot;people&quot;.&quot;age&quot; )"><y>#</y><d>2021-10-18</d><h>14:41</h><w>mauricio.szabo</w>Hi there! Is it possible to somehow keep the aliases on HoneySQL as qualified keywords?

I&apos;m querying a SQL database and I want to make aliases like <code>SUM(&quot;person.age&quot;) as &quot;people/age&quot;</code>. Is it possible for HoneySQL to keep aliases as qualified keywords? Something like <code>{:select [[[:sum :person.age] :people/age]]}</code>, but keeping the alias as-is (currently it is converting to <code>&quot;people&quot;.&quot;age&quot;</code>)</z><z id="t1634577066" t="seancorfield [:attrs {:href &quot;/_/_/users/U3Y18N0UC&quot;}] Which version of HoneySQL? I think this differs between 1.x and 2.x?"><y>#</y><d>2021-10-18</d><h>17:11</h><w>seancorfield</w><a>@mauricio.szabo</a> Which version of HoneySQL? I think this differs between 1.x and 2.x?</z><z id="t1634577365" t="mauricio.szabo I&apos;m using the latest version (2.1.818). I remember that I was able to make it work with 1.x a long time ago, but it was even a different Clojure version so I&apos;m not sure what changed (or even if something changed). I somehow was able to fix by monkey-patching honey/format-entity , but I don&apos;t think that&apos;s a great solution 😄"><y>#</y><d>2021-10-18</d><h>17:16</h><w>mauricio.szabo</w>I&apos;m using the latest version (2.1.818).

I remember that I was able to make it work with 1.x a long time ago, but it was even a different Clojure version so I&apos;m not sure what changed (or even if something changed). I somehow was able to fix by monkey-patching <code>honey/format-entity</code>, but I don&apos;t think that&apos;s a great solution <b>😄</b></z><z id="t1634577541" t="seancorfield Could you create an issue on GH with a small repro case of what you need? There may be a way to make it work but I&apos;ll need to spend some time experimenting."><y>#</y><d>2021-10-18</d><h>17:19</h><w>seancorfield</w>Could you create an issue on GH with a small repro case of what you need? There may be a way to make it work but I&apos;ll need to spend some time experimenting.</z><z id="t1634577673" t="seancorfield dev=&gt; (sql/format {:select [[[:sum :person.age] &quot;people/age&quot;]]}) [&quot;SELECT SUM(person.age) AS \&quot;people/age\&quot;&quot;] In general, using strings for aliases leaves them as-is. Not sure if that helps you?"><y>#</y><d>2021-10-18</d><h>17:21</h><w>seancorfield</w><pre>dev=&gt; (sql/format {:select [[[:sum :person.age] &quot;people/age&quot;]]})
[&quot;SELECT SUM(person.age) AS \&quot;people/age\&quot;&quot;]</pre>
In general, using strings for aliases leaves them as-is. Not sure if that helps you?</z><z id="t1634589147" t="mauricio.szabo Oh, and it already quotes! Ok, that works for me 🙂"><y>#</y><d>2021-10-18</d><h>20:32</h><w>mauricio.szabo</w>Oh, and it already quotes! Ok, that works for me <b>🙂</b></z><z id="t1634589842" t="seancorfield It is mentioned in the docs but it&apos;s probably not very obvious, since it&apos;s in a big paragraph about naming and quoting strategies..."><y>#</y><d>2021-10-18</d><h>20:44</h><w>seancorfield</w>It is mentioned in the docs but it&apos;s probably not very obvious, since it&apos;s in a big paragraph about naming and quoting strategies...</z><z id="t1634632295" t="thumbnail We&apos;ve been implementing honeysql for a while now at work, and I can&apos;t believe I missed that 😅 . That&apos;s one of the few difficulties we had so far (other than complex queries being complex 😛 )"><y>#</y><d>2021-10-19</d><h>08:31</h><w>thumbnail</w>We&apos;ve been implementing honeysql for a while now at work, and I can&apos;t believe I missed that <b>😅</b>. That&apos;s one of the few difficulties we had so far (other than complex queries being complex <b>😛</b> )</z><z id="t1636037757" t="valerauko From the README I get the impression that :nest should unquestioningly just wrap parens around its children but that doesn&apos;t seem to be the case? Am i missing something? user=&gt; (honey.sql/format {:select :* :from :table :where [:nest [:not [:or [:= :a 1] [:= :b 2]]]]}) [&quot;SELECT * FROM table WHERE NOT (a = ?) OR (b = ?)&quot; 1 2] If this behavior is intended, is there a way to force-wrap parens around a part of the query?"><y>#</y><d>2021-11-04</d><h>14:55</h><w>valerauko</w>From the README I get the impression that :nest should unquestioningly just wrap parens around its children but that doesn&apos;t seem to be the case? Am i missing something?
<pre>user=&gt; (honey.sql/format
 {:select :*
  :from :table
  :where 
  [:nest [:not [:or [:= :a 1] [:= :b 2]]]]})
[&quot;SELECT * FROM table WHERE NOT (a = ?) OR (b = ?)&quot; 1 2]</pre>
If this behavior is intended, is there a way to force-wrap parens around a part of the query?</z><z id="t1636037927" t="valerauko I&apos;m running into behavior that i suspect is due to operator precedence and without the parens it&apos;s really hard to test (through honeysql)"><y>#</y><d>2021-11-04</d><h>14:58</h><r>valerauko</r>I&apos;m running into behavior that i suspect is due to operator precedence and without the parens it&apos;s really hard to test (through honeysql)</z><z id="t1636038432" t="valerauko I quickly confirmed by using pr-str that it&apos;s a problem of operator precedence. Query, current result and expected result below (it&apos;s a quick-and-dirty mysql export so ignore the fact that the query is disgusting): {:select :* :from :vblog_posts :where [:and [:between :post_id 23 2105] [:not [:and [:or [:like :post_main &quot;%[img%&quot;] [:like :post_long &quot;%[img%&quot;]] [:&lt; :post_date 1239462000]]] [:not [:or [:like :post_main &quot;%[devfav%&quot;] [:like :post_long &quot;%[devfav%&quot;]]] [:= :post_id 415]] :limit 1} Result (2.1.818) [&quot;SELECT * FROM vblog_posts WHERE post_id BETWEEN ? AND ? AND NOT ((post_main LIKE ?) OR (post_long LIKE ?)) AND (post_date &lt; ?) AND NOT (post_main LIKE ?) OR (post_long LIKE ?) AND (post_id = ?) LIMIT ?&quot; 23 2105 &quot;%[img%&quot; &quot;%[img%&quot; 1239462000 &quot;%[devfav%&quot; &quot;%[devfav%&quot; 415 1] This doesn&apos;t work as intended. I don&apos;t know which bit of the precedence between AND OR and NOT causes the problem but there is a problem. Expected (works as intended): [&quot;SELECT * FROM vblog_posts WHERE (post_id BETWEEN ? AND ?) AND (NOT ((post_main LIKE ?) OR (post_long LIKE ?)) AND (post_date &lt; ?)) AND (NOT (post_main LIKE ?) OR (post_long LIKE ?)) AND (post_id = ?) LIMIT ?&quot; 23 2105 &quot;%[img%&quot; &quot;%[img%&quot; 1239462000 &quot;%[devfav%&quot; &quot;%[devfav%&quot; 415 1] It might be safe (and maybe simple?) to wrap everything in parens without thinking?"><y>#</y><d>2021-11-04</d><h>15:07</h><r>valerauko</r>I quickly confirmed by using pr-str that it&apos;s a problem of operator precedence.

Query, current result and expected result below (it&apos;s a quick-and-dirty mysql export so ignore the fact that the query is disgusting):
<pre>{:select :*
 :from :vblog_posts
 :where [:and
         [:between :post_id 23 2105]
         [:not [:and
                [:or
                 [:like :post_main &quot;%[img%&quot;]
                 [:like :post_long &quot;%[img%&quot;]]
                [:&lt; :post_date 1239462000]]]
         [:not [:or
                [:like :post_main &quot;%[devfav%&quot;]
                [:like :post_long &quot;%[devfav%&quot;]]]
         [:= :post_id 415]]
 :limit 1}</pre>
Result (2.1.818)
<pre>[&quot;SELECT * FROM vblog_posts WHERE post_id BETWEEN ? AND ? AND NOT ((post_main LIKE ?) OR (post_long LIKE ?)) AND (post_date &lt; ?) AND NOT (post_main LIKE ?) OR (post_long LIKE ?) AND (post_id = ?) LIMIT ?&quot; 23 2105 &quot;%[img%&quot; &quot;%[img%&quot; 1239462000 &quot;%[devfav%&quot; &quot;%[devfav%&quot; 415 1]</pre>
This doesn&apos;t work as intended. I don&apos;t know which bit of the precedence between AND OR and NOT causes the problem but there is a problem.

Expected (works as intended):
<pre>[&quot;SELECT * FROM vblog_posts WHERE (post_id BETWEEN ? AND ?) AND (NOT ((post_main LIKE ?) OR (post_long LIKE ?)) AND (post_date &lt; ?)) AND (NOT (post_main LIKE ?) OR (post_long LIKE ?)) AND (post_id = ?) LIMIT ?&quot; 23 2105 &quot;%[img%&quot; &quot;%[img%&quot; 1239462000 &quot;%[devfav%&quot; &quot;%[devfav%&quot; 415 1]</pre>
It might be safe (and maybe simple?) to wrap everything in parens without thinking?</z><z id="t1636038727" t="valerauko Wrapping [:nest ,,,] around the problematic bits does nothing"><y>#</y><d>2021-11-04</d><h>15:12</h><r>valerauko</r>Wrapping <code>[:nest ,,,]</code> around the problematic bits does nothing</z><z id="t1636045095" t="seancorfield :where takes a sequence of expressions where :and is implicit at the beginning. The following works: dev=&gt; (honey.sql/format #_=&gt; {:select :* #_=&gt; :from :table #_=&gt; :where #_=&gt; [[:nest [:not [:or [:= :a 1] [:= :b 2]]]]]}) [&quot;SELECT * FROM table WHERE (NOT (a = ?) OR (b = ?))&quot; 1 2]"><y>#</y><d>2021-11-04</d><h>16:58</h><r>seancorfield</r><code>:where</code> takes a sequence of expressions where <code>:and</code> is implicit at the beginning. The following works:
<pre>dev=&gt; (honey.sql/format
 #_=&gt;  {:select :*
 #_=&gt;   :from :table
 #_=&gt;   :where 
 #_=&gt;   [[:nest [:not [:or [:= :a 1] [:= :b 2]]]]]})
[&quot;SELECT * FROM table WHERE (NOT (a = ?) OR (b = ?))&quot; 1 2]</pre></z><z id="t1636045198" t="seancorfield I think you just need the ( .. ) around the :between expansion to solve this so {:select :* :from :vblog_posts :where [:and [:nest [:between :post_id 23 2105]] [:not [:and [:or [:like :post_main &quot;%[img%&quot;] [:like :post_long &quot;%[img%&quot;]] [:&lt; :post_date 1239462000]]] [:not [:or [:like :post_main &quot;%[devfav%&quot;] [:like :post_long &quot;%[devfav%&quot;]]] [:= :post_id 415]] :limit 1} (because :between expands to something containing AND )"><y>#</y><d>2021-11-04</d><h>16:59</h><r>seancorfield</r>I think you just need the <code>(</code> .. <code>)</code> around the <code>:between</code> expansion to solve this so
<pre>{:select :*
 :from :vblog_posts
 :where [:and
         [:nest [:between :post_id 23 2105]]
         [:not [:and
                [:or
                 [:like :post_main &quot;%[img%&quot;]
                 [:like :post_long &quot;%[img%&quot;]]
                [:&lt; :post_date 1239462000]]]
         [:not [:or
                [:like :post_main &quot;%[devfav%&quot;]
                [:like :post_long &quot;%[devfav%&quot;]]]
         [:= :post_id 415]]
 :limit 1}</pre>
(because <code>:between</code> expands to something containing <code>AND</code>)</z><z id="t1636048024" t="valerauko Good learning about the implicit :and! But :nest still has no effect and doesn&apos;t add parens As for the priorities, I think NOT and AND don&apos;t mix well either..."><y>#</y><d>2021-11-04</d><h>17:47</h><r>valerauko</r>Good learning about the implicit :and!

But :nest still has no effect and doesn&apos;t add parens

As for the priorities, I think NOT and AND don&apos;t mix well either...</z><z id="t1636056318" t="seancorfield Yeah, looks like a bug that :not isn&apos;t wrapping its argument and also a bug that :nest isn&apos;t working in that context. I&apos;m kind of in and out of my office today so if you could, please create issues for both of those on GH for me so I don&apos;t forget when I am back at my desk for more than a few minutes."><y>#</y><d>2021-11-04</d><h>20:05</h><r>seancorfield</r>Yeah, looks like a bug that <code>:not</code> isn&apos;t wrapping its argument and also a bug that <code>:nest</code> isn&apos;t working in that context. I&apos;m kind of in and out of my office today so if you could, please create issues for both of those on GH for me so I don&apos;t forget when I am back at my desk for more than a few minutes.</z><z id="t1636093200" t="valerauko Alright will do!"><y>#</y><d>2021-11-05</d><h>06:20</h><r>valerauko</r>Alright will do!</z><z id="t1636384662" t="Aviv Kotek hi, i&apos;m trying to generate dynamic &quot;batch&quot; query via honey-sql + clojure.java.jdbc (let [q [&quot;INSERT INTO fruit2 ( name, appearance, cost, grade ) VALUES ( ?, ?, ?, ? )&quot; [&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], v2......vN]] (sql/db-do-prepared db q {:multi? true})) where vec2...vecN are some row data dynamically given I have tried something like that: (-&gt; (insert-into :fruit2) (columns :name :appeareance :cost :grade) (values [:?values]) (sql/format {:params {:values sequences}}) but this is not supported by values API, how can I built the query with dynamic given params? thx!"><y>#</y><d>2021-11-08</d><h>15:17</h><w>Aviv Kotek</w>hi, i&apos;m trying to generate dynamic &quot;batch&quot; query via honey-sql + clojure.java.jdbc
<pre>(let [q [&quot;INSERT INTO fruit2 ( name, appearance, cost, grade ) VALUES ( ?, ?, ?, ? )&quot;
         [&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], v2......vN]]
  (sql/db-do-prepared db q {:multi? true}))</pre>
where vec2...vecN are some row data dynamically given
I have tried something like that:
<pre>(-&gt; (insert-into :fruit2)
    (columns :name :appeareance :cost :grade)
    (values [:?values])
    (sql/format {:params {:values sequences}})</pre>
but this is not supported by values API, how can I built  the query with dynamic given params? thx!</z><z id="t1636528043" t="beders hey, there, quite new to honeysql (but not SQL). Here’s two examples that are supposedly doing the same thing, however, only the second one seems to create the right SQL: (let [data &apos;({:installer-id &quot;bubu&quot; :states (sql-types/array [&quot;CA&quot; &quot;DC&quot;]) :improvement-type-id #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot; })] (-&gt; (hsql/insert-into :installer-improvement-types) (hsql/values data) (sql/format :pretty true))) =&gt; [&quot;INSERT INTO installer_improvement_types (installer_id, states, improvement_type_id) VALUES (?, array ? DC, ?)&quot; &quot;bubu&quot; &quot;CA&quot; #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;] "><y>#</y><d>2021-11-10</d><h>07:07</h><w>beders</w>hey, there, quite new to honeysql (but not SQL).
Here’s two examples that are supposedly doing the same thing, however, only the second one seems to create the right SQL:
<pre>(let [data &apos;({:installer-id        &quot;bubu&quot;
              :states              (sql-types/array [&quot;CA&quot; &quot;DC&quot;])
              :improvement-type-id #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;
              })] 
  (-&gt; (hsql/insert-into :installer-improvement-types)
      (hsql/values data)
      (sql/format :pretty true)))
=&gt;
[&quot;INSERT INTO installer_improvement_types (installer_id, states, improvement_type_id) VALUES (?, array ? DC, ?)&quot;
 &quot;bubu&quot;
 &quot;CA&quot;
 #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;]</pre>
</z><z id="t1636528080" t="beders (-&gt; (hsql/insert-into :installer-improvement-types) (hsql/columns :installer-id :states :improvement-type-id) (hsql/values [[&quot;bubu&quot; (sql-types/array [&quot;CA&quot; &quot;DC&quot;]) #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;]]) (sql/format :pretty true)) =&gt; [&quot;INSERT INTO installer_improvement_types (installer_id, states, improvement_type_id) VALUES (?, ARRAY[?, ?], ?)&quot; &quot;bubu&quot; &quot;CA&quot; &quot;DC&quot; #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;] "><y>#</y><d>2021-11-10</d><h>07:08</h><w>beders</w><pre>(-&gt; (hsql/insert-into :installer-improvement-types)
      (hsql/columns :installer-id :states :improvement-type-id)
      (hsql/values [[&quot;bubu&quot; (sql-types/array [&quot;CA&quot; &quot;DC&quot;]) #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;]])
      (sql/format :pretty true))
=&gt;
[&quot;INSERT INTO installer_improvement_types (installer_id, states, improvement_type_id) VALUES (?, ARRAY[?, ?], ?)&quot;
 &quot;bubu&quot;
 &quot;CA&quot;
 &quot;DC&quot;
 #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;]</pre>
</z><z id="t1636528136" t="beders what am I doing wrong when using the map format for values? Thanks in advance"><y>#</y><d>2021-11-10</d><h>07:08</h><w>beders</w>what am I doing wrong when using the map format for values? Thanks in advance</z><z id="t1636561635" t="seancorfield In the first form you&apos;ve quoted the whole expression so sql-types is not evaluated."><y>#</y><d>2021-11-10</d><h>16:27</h><w>seancorfield</w>In the first form you&apos;ve quoted the whole expression so <code>sql-types</code> is not evaluated.</z><z id="t1636561687" t="seancorfield (let [data [{:installer-id &quot;bubu&quot; :states (sql-types/array [&quot;CA&quot; &quot;DC&quot;]) :improvement-type-id #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot; }]] (-&gt; (hsql/insert-into :installer-improvement-types) (hsql/values data) (sql/format :pretty true))) That should do what you want [:attrs {:href &quot;/_/_/users/U628K7XGQ&quot;}]"><y>#</y><d>2021-11-10</d><h>16:28</h><w>seancorfield</w><pre>(let [data [{:installer-id        &quot;bubu&quot;
             :states              (sql-types/array [&quot;CA&quot; &quot;DC&quot;])
             :improvement-type-id #uuid&quot;7efc8a9e-a317-424f-a775-ba4bf6a5bf94&quot;
             }]] 
  (-&gt; (hsql/insert-into :installer-improvement-types)
      (hsql/values data)
      (sql/format :pretty true)))</pre>
That should do what you want <a>@beders</a></z><z id="t1636561697" t="seancorfield (no quote, use a vector instead of a list)"><y>#</y><d>2021-11-10</d><h>16:28</h><w>seancorfield</w>(no quote, use a vector instead of a list)</z><z id="t1636602738" t="beders Thank you very much !"><y>#</y><d>2021-11-11</d><h>03:52</h><w>beders</w>Thank you very much !</z><z id="t1638058373" t="seancorfield Thank you for the bug reports ( [:attrs {:href &quot;/_/_/users/UAEH11THP&quot;}] ) and enhancement requests (various!) that went into this release!"><y>#</y><d>2021-11-28</d><h>00:12</h><w>seancorfield</w>Thank you for the bug reports (<a>@vale</a>) and enhancement requests (various!) that went into this release!</z><z id="t1638562663" t="AJ Jaro I’m on a super old version of honeysql (1.0.444) and we have a bunch of places in the code that developers put in to protect ourselves before running a query with an empty collection. For a simple example, select (); obviously returns an error (at least in postgres), so we’ve written a number of (when (seq data) (select data)) Is there something built-in to a newer version that prevents that query from being run since it’s invalid? If not, I’m pretty sure we could write some internal tooling to prevent that instead"><y>#</y><d>2021-12-03</d><h>20:17</h><w>AJ Jaro</w>I’m on a super old version of honeysql (1.0.444) and we have a bunch of places in the code that developers put in to protect ourselves before running a query with an empty collection. For a simple example, <code>select ();</code> obviously returns an error (at least in postgres), so we’ve written a number of <code>(when (seq data) (select data))</code>

Is there something built-in to a newer version that prevents that query from being run since it’s invalid? If not, I’m pretty sure we could write some internal tooling to prevent that instead</z><z id="t1638564263" t="seancorfield [:attrs {:href &quot;/_/_/users/UGMAVSMUM&quot;}] There&apos;s nothing specifically, right now, but there is now the concept of a &quot;checking&quot; mode (`:checking :none|:basic|:strict`) which enables certain checks and assertions in the formatted so adding logic to throw an exception if :select has an empty? collection argument would be pretty easy. It was originally added to check IN () clauses but I could extend it to SELECT clauses to -- and anything else folks want."><y>#</y><d>2021-12-03</d><h>20:44</h><w>seancorfield</w><a>@ajarosinski</a> There&apos;s nothing specifically, right now, but there is now the concept of a &quot;checking&quot; mode (`:checking :none|:basic|:strict`) which enables certain checks and assertions in the formatted so adding logic to throw an exception if <code>:select</code> has an <code>empty?</code> collection argument would be pretty easy. It was originally added to check <code>IN ()</code> clauses but I could extend it to <code>SELECT</code> clauses to -- and anything else folks want.</z><z id="t1638564358" t="AJ Jaro Hmm, that sounds kind of interesting. I was actually thinking for the in clause. Do you mean that you already have it for that form!?"><y>#</y><d>2021-12-03</d><h>20:45</h><r>AJ Jaro</r>Hmm, that sounds kind of interesting. I was actually thinking for the <code>in</code> clause. Do you mean that you already have it for that form!?</z><z id="t1638565446" t="seancorfield Yes, if you say {:checking :basic} or {:checking :strict} in the options to sql/format (new version) then it throws if IN would have an empty set of values."><y>#</y><d>2021-12-03</d><h>21:04</h><r>seancorfield</r>Yes, if you say <code>{:checking :basic}</code> or <code>{:checking :strict}</code> in the options to <code>sql/format</code> (new version) then it throws if <code>IN</code> would have an empty set of values.</z><z id="t1638565472" t="seancorfield I&apos;m just adding a similar check for SELECT and similar constructs."><y>#</y><d>2021-12-03</d><h>21:04</h><r>seancorfield</r>I&apos;m just adding a similar check for <code>SELECT</code> and similar constructs.</z><z id="t1638565682" t="seancorfield Just pushed that to develop. I&apos;ll cut a new release soon, I expect."><y>#</y><d>2021-12-03</d><h>21:08</h><r>seancorfield</r>Just pushed that to develop. I&apos;ll cut a new release soon, I expect.</z><z id="t1638567277" t="seancorfield 2.1.833 is available."><y>#</y><d>2021-12-03</d><h>21:34</h><r>seancorfield</r>2.1.833 is available.</z><z id="t1638564292" t="seancorfield If you create an issue on the honeysql repo, I&apos;ll add that -- and any other &quot;lint&quot;-like checks folks can think of."><y>#</y><d>2021-12-03</d><h>20:44</h><w>seancorfield</w>If you create an issue on the <code>honeysql</code> repo, I&apos;ll add that -- and any other &quot;lint&quot;-like checks folks can think of.</z><z id="t1638567266" t="seancorfield https://github.com/seancorfield/honeysql/releases/tag/v2.1.833 -- includes a bug fix for merging select-distinct-on and expands the &quot;lint&quot;-like checks to SELECT and a bunch of other clauses that expect a non-empty list of columns (when :checking is :basic or :strict -- by default, checking is :none )."><y>#</y><d>2021-12-03</d><h>21:34</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/releases/tag/v2.1.833" target="_blank">https://github.com/seancorfield/honeysql/releases/tag/v2.1.833</a> -- includes a bug fix for merging <code>select-distinct-on</code> and expands the &quot;lint&quot;-like checks to <code>SELECT</code> and a bunch of other clauses that expect a non-empty list of columns (when <code>:checking</code> is <code>:basic</code> or <code>:strict</code> -- by default, checking is <code>:none</code>).</z><z id="t1638660565" t="john-shaffer Web app updates: • Moved site to https://john.shaffe.rs • Added :checking :strict to default options • Added previous versions of HoneySQL for easy comparison of changes Example of all 3: https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%5B%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D"><y>#</y><d>2021-12-04</d><h>23:29</h><w>john-shaffer</w>Web app updates:
• Moved site to <a href="https://john.shaffe.rs" target="_blank">https://john.shaffe.rs</a>
• Added :checking :strict to default options
• Added previous versions of HoneySQL for easy comparison of changes
Example of all 3: <a href="https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%5B%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D" target="_blank">https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%5B%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D</a></z><z id="t1638661047" t="seancorfield I updated the link in the HoneySQL README -- thanks for having a redirect in place!"><y>#</y><d>2021-12-04</d><h>23:37</h><r>seancorfield</r>I updated the link in the HoneySQL README -- thanks for having a redirect in place!</z><z id="t1638661085" t="seancorfield And thanks again for the great web app!"><y>#</y><d>2021-12-04</d><h>23:38</h><r>seancorfield</r>And thanks again for the great web app!</z><z id="t1638663465" t="john-shaffer Thank you for all your libraries and blog posts 🙂"><y>#</y><d>2021-12-05</d><h>00:17</h><r>john-shaffer</r>Thank you for all your libraries and blog posts <b>🙂</b></z><z id="t1639405502" t="enn Is there a way to create an expression that I can pass to honeysql.sql/format that will just spit out a specific SQL string? for working around gaps in HoneySQL&apos;s functionality (no create index support), in an environment where I am collecting a bunch of HoneySQL expressions and then calling format on all of them at the end."><y>#</y><d>2021-12-13</d><h>14:25</h><w>enn</w>Is there a way to create an expression that I can pass to <code>honeysql.sql/format</code> that will just spit out a specific SQL string? for working around gaps in HoneySQL&apos;s functionality (no create index support), in an environment where I am collecting a bunch of HoneySQL expressions and then calling <code>format</code> on all of them at the end.</z><z id="t1639405891" t="Lennart Buit Do you mean the raw syntax? [:raw …]"><y>#</y><d>2021-12-13</d><h>14:31</h><w>Lennart Buit</w>Do you mean the raw syntax? <code>[:raw …]</code></z><z id="t1639493151" t="enn yes, that works. thank you!"><y>#</y><d>2021-12-14</d><h>14:45</h><w>enn</w>yes, that works. thank you!</z><z id="t1639548472" t="dekel Hi, I believe there is a bug around boolean equality comparisons for nullable columns but I just wanted to make sure this is unintended before I opened an issue. I believe the query it generates should use IS NOT instead of &lt;&gt; . Example: Say I have the following table and data: create table testing( id INT PRIMARY KEY, yesno BOOLEAN ); INSERT INTO testing (id, yesno) values(1, TRUE), (2, FALSE), (3, NULL); Say I want to filter based on the yesno column: (-&gt; (hsql/format {:select [:*] :from [:testing] :where [:is-not :yesno true]}) (first)) =&gt; &quot;SELECT * FROM testing WHERE yesno &lt;&gt; TRUE&quot; The problem is that SELECT * FROM testing WHERE yesno &lt;&gt; TRUE would only return the row with ID = 2, whereas I would expect that query to return 2 and 3. In contrast, select * from testing where yesno is not true does return both 2 and 3. The query returns the same result (i.e. only id=2) if I used [:not [:is :yesno true]] . I’m using honeysql 2.1.833 and Postgres 13.2."><y>#</y><d>2021-12-15</d><h>06:07</h><w>dekel</w>Hi, I believe there is a bug around boolean equality comparisons for nullable columns but I just wanted to make sure this is unintended before I opened an issue. I believe the query it generates should use <code>IS NOT</code> instead of  <code>&lt;&gt;</code> . Example:

Say I have the following table and data:
<pre>create table testing(
    id INT PRIMARY KEY,
    yesno BOOLEAN
);

INSERT INTO testing (id, yesno)
		values(1, TRUE), (2, FALSE), (3, NULL);</pre>
Say I want to filter based on the <code>yesno</code> column:
<pre>(-&gt; (hsql/format {:select [:*]
                  :from [:testing]
                  :where [:is-not :yesno true]})
    (first))
=&gt; &quot;SELECT * FROM testing WHERE yesno &lt;&gt; TRUE&quot;</pre>
The problem is that <code>SELECT * FROM testing WHERE yesno &lt;&gt; TRUE</code> would only return the row with ID = 2, whereas I would expect that query to return 2 and 3. In contrast, <code>select * from testing where yesno is not true</code> does return both 2 and 3. The query returns the same result (i.e. only id=2) if I used <code>[:not [:is :yesno true]]</code>.

I’m using honeysql 2.1.833 and Postgres 13.2.</z><z id="t1639548956" t="seancorfield [:attrs {:href &quot;/_/_/users/U02634NQ5MK&quot;}] Interesting. I&apos;d have to check how that work on other databases. My experience is that WHERE col &lt;&gt; someValue doesn&apos;t return NULL matches... Can you open an issue on GitHub so I don&apos;t forget to look at this?"><y>#</y><d>2021-12-15</d><h>06:15</h><w>seancorfield</w><a>@dekelpilli</a> Interesting. I&apos;d have to check how that work on other databases. My experience is that <code>WHERE col &lt;&gt; someValue</code> doesn&apos;t return NULL matches... Can you open an issue on GitHub so I don&apos;t forget to look at this?</z><z id="t1639549272" t="dekel Created https://github.com/seancorfield/honeysql/issues/374"><y>#</y><d>2021-12-15</d><h>06:21</h><r>dekel</r>Created <a href="https://github.com/seancorfield/honeysql/issues/374" target="_blank">https://github.com/seancorfield/honeysql/issues/374</a></z><z id="t1639549516" t="seancorfield Given all the log4j craziness, which is still ongoing, it might be a few days before I get to this. Just setting expectations."><y>#</y><d>2021-12-15</d><h>06:25</h><r>seancorfield</r>Given all the log4j craziness, which is still ongoing, it might be a few days before I get to this. Just setting expectations.</z><z id="t1639577079" t="athomasoriginal In peoples experience, what kind of rule of thumb do you apply when extending honeysql V2. For example, I have a scenario (postgres) where I have the following hsql query: [[[:json_agg [:jsonb_build_object &quot;alias&quot; :column ...]] &quot;alias_name&quot;]] The above gets a bit verbose after a while and easy to make mistakes. Two options I am exploring ;; option 1 - a function (defn as-josn-object [m] [:json_agg [:json_agg :jsonb_build_object &quot;alias&quot; :column ...]]) [(as-json-array-of-object [&quot;alias&quot; &quot;name&quot;]) &quot;alias_name&quot;]] ;; option 2 - extending honeysql (defn register-fn :json-array-of-objects (fn [m] ....)) [[:json-array-of-objects [&quot;alias&quot; &quot;name&quot;]] &quot;alias_name&quot;] I am curious which people prefer? (sorry if there are syntax errors, I was going quick)"><y>#</y><d>2021-12-15</d><h>14:04</h><w>athomasoriginal</w>In peoples experience, what kind of rule of thumb do you apply when extending honeysql V2.  For example, I have a scenario (postgres) where I have the following hsql query:

<pre>[[[:json_agg [:jsonb_build_object &quot;alias&quot; :column ...]] &quot;alias_name&quot;]] </pre>
The above gets a bit verbose after a while and easy to make mistakes.  Two options I am exploring

<pre>;; option 1 - a function
(defn as-josn-object [m] [:json_agg [:json_agg :jsonb_build_object &quot;alias&quot; :column ...]])

[(as-json-array-of-object [&quot;alias&quot; &quot;name&quot;]) &quot;alias_name&quot;]] 

;; option 2 - extending honeysql
(defn register-fn :json-array-of-objects (fn [m] ....))

[[:json-array-of-objects [&quot;alias&quot; &quot;name&quot;]] &quot;alias_name&quot;]</pre>
I am curious which people prefer? (sorry if there are syntax errors, I was going quick)</z><z id="t1639686186" t="orestis I prefer the functions "><y>#</y><d>2021-12-16</d><h>20:23</h><r>orestis</r>I prefer the functions </z><z id="t1639686226" t="orestis They can be much more clever and descriptive with proper args, docstrings etc "><y>#</y><d>2021-12-16</d><h>20:23</h><r>orestis</r>They can be much more clever and descriptive with proper args, docstrings etc </z><z id="t1640285897" t="seancorfield Folks, I&apos;m looking at https://github.com/seancorfield/honeysql/issues/374 and trying to figure out the best path forward here. The TL;DR is that HoneySQL has always treated :is as a synonym for := and :is-not as a synonym for :&lt;&gt; which is not quite correct. In addition, equality and inequality when one operand or the other is nil is special-cased and always produces IS NULL or IS NOT NULL as appropriate -- which means that [:= a :col] when a evaluates to nil produces col IS NULL but when a evaluates to, say, 42 produces 42 = col (well, ? = col and a parameter of 42)."><y>#</y><d>2021-12-23</d><h>18:58</h><w>seancorfield</w>Folks, I&apos;m looking at <a href="https://github.com/seancorfield/honeysql/issues/374" target="_blank">https://github.com/seancorfield/honeysql/issues/374</a> and trying to figure out the best path forward here. The TL;DR is that HoneySQL has always treated <code>:is</code> as a synonym for <code>:=</code> and <code>:is-not</code> as a synonym for <code>:&lt;&gt;</code> which is not quite correct. In addition, equality and inequality when one operand or the other is <code>nil</code> is special-cased and always produces <code>IS NULL</code> or <code>IS NOT NULL</code> as appropriate -- which means that <code>[:= a :col]</code> when <code>a</code> evaluates to <code>nil</code> produces <code>col IS NULL</code> but when <code>a</code> evaluates to, say, 42 produces <code>42 = col</code> (well, <code>? = col</code> and a parameter of 42).</z><z id="t1640286001" t="seancorfield At issue here is that IS /`IS NOT` are not synonyms for = /`&lt;&gt;` for Boolean operands or situations where the second operand is nil (`NULL`). I verified this on MySQL (in addition to what&apos;s in that issue)."><y>#</y><d>2021-12-23</d><h>19:00</h><w>seancorfield</w>At issue here is that <code>IS</code>/`IS NOT` are not synonyms for <code>=</code>/`&lt;&gt;` for Boolean operands or situations where the second operand is <code>nil</code> (`NULL`). I verified this on MySQL (in addition to what&apos;s in that issue).</z><z id="t1640286045" t="seancorfield So this is definitely a bug but I&apos;m concerned that fixing it is going to silently change the behavior of existing code."><y>#</y><d>2021-12-23</d><h>19:00</h><w>seancorfield</w>So this is definitely a bug but I&apos;m concerned that fixing it is going to silently change the behavior of existing code.</z><z id="t1640286211" t="seancorfield The existing behavior with = /`&lt;&gt;` and one operand being nil is intended to be a convenience, so you can just write [:= :col foo] and get either col = ? (and the parameter value of foo ) or col IS NULL depending on the value of foo . Checking col = NULL here would always be an empty result."><y>#</y><d>2021-12-23</d><h>19:03</h><w>seancorfield</w>The existing behavior with <code>=</code>/`&lt;&gt;` and one operand being <code>nil</code> is intended to be a convenience, so you can just write <code>[:= :col foo]</code> and get either <code>col = ?</code> (and the parameter value of <code>foo</code>) or <code>col IS NULL</code> depending on the value of <code>foo</code>. Checking <code>col = NULL</code> here would always be an empty result.</z><z id="t1640286276" t="seancorfield I think that behavior should be retained because, well, it&apos;s convenient and I suspect quite a bit of code out there relies on that happening."><y>#</y><d>2021-12-23</d><h>19:04</h><w>seancorfield</w>I think that behavior should be retained because, well, it&apos;s convenient and I suspect quite a bit of code out there relies on that happening.</z><z id="t1640286342" t="seancorfield But that aliasing behavior is not correct for Boolean columns (`BIT(1)` in MySQL) when testing for TRUE or FALSE (or UNKNOWN but that is not yet supported by HoneySQL) -- because col IS NOT TRUE and col &lt;&gt; TRUE behave differently if col can be NULL ."><y>#</y><d>2021-12-23</d><h>19:05</h><w>seancorfield</w>But that aliasing behavior is not correct for Boolean columns (`BIT(1)` in MySQL) when testing for <code>TRUE</code> or <code>FALSE</code> (or <code>UNKNOWN</code> but that is not yet supported by HoneySQL) -- because <code>col IS NOT TRUE</code> and <code>col &lt;&gt; TRUE</code> behave differently if <code>col</code> can be <code>NULL</code>.</z><z id="t1640286433" t="seancorfield (and right now there&apos;s no way to get the correct IS / IS NOT behavior for Boolean columns because HoneySQL turns those into = and &lt;&gt; respectively)"><y>#</y><d>2021-12-23</d><h>19:07</h><w>seancorfield</w>(and right now there&apos;s no way to get the correct <code>IS</code> / <code>IS NOT</code> behavior for Boolean columns because HoneySQL turns those into <code>=</code> and <code>&lt;&gt;</code> respectively)</z><z id="t1640286741" t="seancorfield If I just remove the aliasing (which would be &quot;correct&quot;), any existing code using :is or :is-not is potentially going to change behavior in a subtle way (which is worse than just &quot;breaking&quot;)."><y>#</y><d>2021-12-23</d><h>19:12</h><w>seancorfield</w>If I just remove the aliasing (which would be &quot;correct&quot;), any existing code using <code>:is</code> or <code>:is-not</code> is potentially going to change behavior in a subtle way (which is worse than just &quot;breaking&quot;).</z><z id="t1640286900" t="seancorfield (note that [:= a :col] or [:is a :col] transforms to col IS NULL if a happens to be nil but NULL = col produces no matches and NULL IS col is a syntax error so that is a special case that is also problematic)"><y>#</y><d>2021-12-23</d><h>19:15</h><w>seancorfield</w>(note that <code>[:= a :col]</code> or <code>[:is a :col]</code> transforms to <code>col IS NULL</code> if <code>a</code> happens to be <code>nil</code> but <code>NULL = col</code> produces no matches and <code>NULL IS col</code> is a syntax error so that is a special case that is also problematic)</z><z id="t1640287407" t="seancorfield I think, clearly, whatever I do has to have at the very least a dynamic var that folks can set to select the behavior. We certainly have code at work that explicitly relies on being able to do [:= :col nil] / [:&lt;&gt; :col nil] and get col IS NULL / col IS NOT NULL so I&apos;m loathed to change that behavior."><y>#</y><d>2021-12-23</d><h>19:23</h><w>seancorfield</w>I think, clearly, whatever I do has to have at the very least a dynamic var that folks can set to select the behavior. We certainly have code at work that explicitly relies on being able to do <code>[:= :col nil]</code> / <code>[:&lt;&gt; :col nil]</code> and get <code>col IS NULL</code> / <code>col IS NOT NULL</code> so I&apos;m loathed to change that behavior.</z><z id="t1640290726" t="orestis The first time I used honeysql I had to triple check about this. In the end, I came to like the := behavior because I thought it was just a nice way when dealing with explicit nils. Especially when passing in a literal nil. "><y>#</y><d>2021-12-23</d><h>20:18</h><w>orestis</w>The first time I used honeysql I had to triple check about this. In the end, I came to like the := behavior because I thought it was just a nice way when dealing with explicit nils. Especially when passing in a literal nil. </z><z id="t1640290767" t="orestis I think that is/is-not should be left as is though. Clearly the caller knows what they&apos;re doing. "><y>#</y><d>2021-12-23</d><h>20:19</h><w>orestis</w>I think that is/is-not should be left as is though. Clearly the caller knows what they&apos;re doing. </z><z id="t1640290984" t="orestis [:is a :col] should probably produce correct sql, ordering wise and/or throw if a is not nil. "><y>#</y><d>2021-12-23</d><h>20:23</h><w>orestis</w>[:is a :col] should probably produce correct sql, ordering wise and/or throw if a is not nil. </z><z id="t1640292724" t="seancorfield Thanks [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] That&apos;s useful feedback. I think I am beginning to lean toward just removing the aliasing for :is /`:is-not` and warning folks in the change log about this (and updating the docs in several places to show examples of this behavior and the subtle differences)."><y>#</y><d>2021-12-23</d><h>20:52</h><w>seancorfield</w>Thanks <a>@orestis</a> That&apos;s useful feedback. I think I am beginning to lean toward just removing the aliasing for <code>:is</code>/`:is-not` and warning folks in the change log about this (and updating the docs in several places to show examples of this behavior and the subtle differences).</z><z id="t1640296058" t="seancorfield Check your code for :is-not uses!"><y>#</y><d>2021-12-23</d><h>21:47</h><w>seancorfield</w>Check your code for <code>:is-not</code> uses!</z><z id="t1640296087" t="seancorfield We&apos;ll see whether it actually breaks any real code..."><y>#</y><d>2021-12-23</d><h>21:48</h><w>seancorfield</w>We&apos;ll see whether it actually breaks any real code...</z><z id="t1640389573" t="valerauko I think this is a reasonable change that fixes ~incorrect~ unexpected (and inconsistent with sql) behavior. Absolutely agreed."><y>#</y><d>2021-12-24</d><h>23:46</h><w>valerauko</w>I think this is a reasonable change that fixes ~incorrect~ unexpected (and inconsistent with sql) behavior. Absolutely agreed.</z><z id="t1641509053" t="wombawomba How can I do a CASE statement in a SELECT column? I.e, how would I write something like SELECT CASE WHEN 1 &gt; 2 THEN 1 ELSE 2 END foo FROM bar ?"><y>#</y><d>2022-01-06</d><h>22:44</h><w>wombawomba</w>How can I do a <code>CASE</code> statement in a <code>SELECT</code> column? I.e, how would I write something like <code>SELECT CASE WHEN 1 &gt; 2 THEN 1 ELSE 2 END foo FROM bar</code>?</z><z id="t1641510914" t="seancorfield [:attrs {:href &quot;/_/_/users/U15RYEQPJ&quot;}] https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.840/doc/getting-started/sql-special-syntax-#case"><y>#</y><d>2022-01-06</d><h>23:15</h><w>seancorfield</w><a>@wombawomba</a> <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.840/doc/getting-started/sql-special-syntax-#case" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.840/doc/getting-started/sql-special-syntax-#case</a></z><z id="t1641510974" t="seancorfield Just remember that expressions (function call-like stuff) has to have an extra [ .. ] around it in :select to avoid confusion with aliased columns."><y>#</y><d>2022-01-06</d><h>23:16</h><w>seancorfield</w>Just remember that expressions (function call-like stuff) has to have an extra <code>[</code> .. <code>]</code> around it in <code>:select</code> to avoid confusion with aliased columns.</z><z id="t1641511082" t="seancorfield dev=&gt; (sql/format {:select [ [ [:case [:&gt; 1 2] 1 :else 2] :foo ] ] :from :bar}) [&quot;SELECT CASE WHEN ? &gt; ? THEN ? ELSE ? END AS foo FROM bar&quot; 1 2 1 2]"><y>#</y><d>2022-01-06</d><h>23:18</h><w>seancorfield</w><pre>dev=&gt; (sql/format {:select [ [ [:case [:&gt; 1 2] 1 :else 2] :foo ] ] :from :bar})
[&quot;SELECT CASE WHEN ? &gt; ? THEN ? ELSE ? END AS foo FROM bar&quot; 1 2 1 2]</pre></z><z id="t1641555432" t="wombawomba [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]  copy/pasting that code causes an exception on my end: java.lang.AssertionError: Assert failed: Alias should have two parts[:case [:&gt; 1 2] 1 :else 2] (= 2 (count x)) I&apos;m on 1.0.461 FWIW"><y>#</y><d>2022-01-07</d><h>11:37</h><r>wombawomba</r><a>@seancorfield</a> copy/pasting that code causes an exception on my end:
<pre>java.lang.AssertionError: Assert failed: Alias should have two parts[:case [:&gt; 1 2] 1 :else 2]
                          (= 2 (count x))</pre>
I&apos;m on <code>1.0.461</code> FWIW</z><z id="t1641558749" t="wombawomba It does work in Honeysql 2.x, but the actual code I&apos;m formatting contains a bunch of #honeysql.types.SqlCall , and I don&apos;t have the time to translate all of the associated code to 2.x at the moment."><y>#</y><d>2022-01-07</d><h>12:32</h><r>wombawomba</r>It does work in Honeysql 2.x, but the actual code I&apos;m formatting contains a bunch of <code>#honeysql.types.SqlCall</code>, and I don&apos;t have the time to translate all of the associated code to 2.x at the moment.</z><z id="t1641575640" t="seancorfield [:attrs {:href &quot;/_/_/users/U15RYEQPJ&quot;}] Ah, I don&apos;t remember how you do it with 1.x, sorry, and I don&apos;t think it was documented."><y>#</y><d>2022-01-07</d><h>17:14</h><r>seancorfield</r><a>@wombawomba</a> Ah, I don&apos;t remember how you do it with 1.x, sorry, and I don&apos;t think it was documented.</z><z id="t1641575717" t="wombawomba Alright. [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] can you think of any &apos;wrong&apos; way to do it?"><y>#</y><d>2022-01-07</d><h>17:15</h><r>wombawomba</r>Alright. <a>@seancorfield</a> can you think of any &apos;wrong&apos; way to do it?</z><z id="t1641575727" t="wombawomba I kind of need to get it working and I&apos;m out of ideas"><y>#</y><d>2022-01-07</d><h>17:15</h><r>wombawomba</r>I kind of need to get it working and I&apos;m out of ideas</z><z id="t1641575768" t="wombawomba if there&apos;s a hacky way to do it I can go with that and then just make sure to do it properly when I migrate to 2.x"><y>#</y><d>2022-01-07</d><h>17:16</h><r>wombawomba</r>if there&apos;s a hacky way to do it I can go with that and then just make sure to do it properly when I migrate to 2.x</z><z id="t1641575817" t="seancorfield It&apos;s been so long since I&apos;ve used 1.x -- you know you can use both side-by-side and could change the code on a per-query basis?"><y>#</y><d>2022-01-07</d><h>17:16</h><r>seancorfield</r>It&apos;s been so long since I&apos;ve used 1.x -- you know you can use both side-by-side and could change the code on a per-query basis?</z><z id="t1641575827" t="wombawomba yeah"><y>#</y><d>2022-01-07</d><h>17:17</h><r>wombawomba</r>yeah</z><z id="t1641575852" t="wombawomba the problem here though is that other parts of the query contain a bunch of #honeysql.types.SqlCall"><y>#</y><d>2022-01-07</d><h>17:17</h><r>wombawomba</r>the problem here though is that other parts of the query contain a bunch of <code>#honeysql.types.SqlCall</code></z><z id="t1641575870" t="wombawomba and those give me an error when I give them to honey.sql/format"><y>#</y><d>2022-01-07</d><h>17:17</h><r>wombawomba</r>and those give me an error when I give them to <code>honey.sql/format</code></z><z id="t1641575903" t="wombawomba perhaps there&apos;s some easyish way to translate those other parts of the query to the equivalent hsql2?"><y>#</y><d>2022-01-07</d><h>17:18</h><r>wombawomba</r>perhaps there&apos;s some easyish way to translate those other parts of the query to the equivalent hsql2?</z><z id="t1641576540" t="seancorfield You don&apos;t need that SqlCall stuff in 2.x -- calls are just syntax [:func arg1 arg2] etc."><y>#</y><d>2022-01-07</d><h>17:29</h><r>seancorfield</r>You don&apos;t need that <code>SqlCall</code> stuff in 2.x -- calls are just syntax <code>[:func arg1 arg2]</code> etc.</z><z id="t1641576660" t="seancorfield [:attrs {:href &quot;/_/_/users/U15RYEQPJ&quot;}] The 1.x tests have examples of case/when: https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L150"><y>#</y><d>2022-01-07</d><h>17:31</h><r>seancorfield</r><a>@wombawomba</a> The 1.x tests have examples of case/when: <a href="https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L150" target="_blank">https://github.com/seancorfield/honeysql/blob/v1/test/honeysql/core_test.cljc#L150</a></z><z id="t1641578454" t="wombawomba [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] thanks! (h/format {:select [[(h/call :case [:&gt; 1 2] 1 :else 2) :foo]] :from [:bar]}) did the trick 🙂"><y>#</y><d>2022-01-07</d><h>18:00</h><r>wombawomba</r><a>@seancorfield</a> thanks! <code>(h/format {:select [[(h/call :case [:&gt; 1 2] 1 :else 2) :foo]] :from [:bar]})</code> did the trick <b>🙂</b></z><z id="t1641578618" t="seancorfield The tests are pretty much the best &quot;documentation&quot; for 1.x. I&apos;m trying hard to make that not the case for 2.x which has &quot;proper&quot; documentation on http://cljdoc.org 🙂"><y>#</y><d>2022-01-07</d><h>18:03</h><r>seancorfield</r>The tests are pretty much the best &quot;documentation&quot; for 1.x. I&apos;m trying hard to make that not the case for 2.x which has &quot;proper&quot; documentation on <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a> <b>🙂</b></z><z id="t1641555432" t="wombawomba [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]  copy/pasting that code causes an exception on my end: java.lang.AssertionError: Assert failed: Alias should have two parts[:case [:&gt; 1 2] 1 :else 2] (= 2 (count x)) I&apos;m on 1.0.461 FWIW"><y>#</y><d>2022-01-07</d><h>11:37</h><w>wombawomba</w><a>@seancorfield</a> copy/pasting that code causes an exception on my end:
<pre>java.lang.AssertionError: Assert failed: Alias should have two parts[:case [:&gt; 1 2] 1 :else 2]
                          (= 2 (count x))</pre>
I&apos;m on <code>1.0.461</code> FWIW</z><z id="t1641558749" t="wombawomba It does work in Honeysql 2.x, but the actual code I&apos;m formatting contains a bunch of #honeysql.types.SqlCall , and I don&apos;t have the time to translate all of the associated code to 2.x at the moment."><y>#</y><d>2022-01-07</d><h>12:32</h><w>wombawomba</w>It does work in Honeysql 2.x, but the actual code I&apos;m formatting contains a bunch of <code>#honeysql.types.SqlCall</code>, and I don&apos;t have the time to translate all of the associated code to 2.x at the moment.</z><z id="t1641539336" t="seancorfield Attention Google BigQuery users! Please take a look at https://github.com/seancorfield/honeysql/pull/376 and provide feedback!"><y>#</y><d>2022-01-07</d><h>07:08</h><w>seancorfield</w>Attention Google BigQuery users! Please take a look at <a href="https://github.com/seancorfield/honeysql/pull/376" target="_blank">https://github.com/seancorfield/honeysql/pull/376</a> and provide feedback!</z><z id="t1641631403" t="littleli Hi. I&apos;m a bit late to the party as I was sick but it really looks great. Thanks for adding this."><y>#</y><d>2022-01-08</d><h>08:43</h><r>littleli</r>Hi. I&apos;m a bit late to the party as I was sick but it really looks great. Thanks for adding this.</z><z id="t1641631581" t="seancorfield Hope you&apos;re better now [:attrs {:href &quot;/_/_/users/UBLU3FQRZ&quot;}] ?"><y>#</y><d>2022-01-08</d><h>08:46</h><r>seancorfield</r>Hope you&apos;re better now <a>@UBLU3FQRZ</a>?</z><z id="t1641631858" t="littleli Yes. I&apos;m ok now I think., It was &quot;just&quot; an excessive reaction to a booster 😞"><y>#</y><d>2022-01-08</d><h>08:50</h><r>littleli</r>Yes. I&apos;m ok now I think., It was &quot;just&quot; an excessive reaction to a booster <b>😞</b></z><z id="t1641631925" t="seancorfield I had my booster on December 7th and was pretty miserable for a while, starting 24 hours after the shot. Better than getting the virus tho&apos;!"><y>#</y><d>2022-01-08</d><h>08:52</h><r>seancorfield</r>I had my booster on December 7th and was pretty miserable for a while, starting 24 hours after the shot. Better than getting the virus tho&apos;!</z><z id="t1641632091" t="littleli Yeah, just avoiding the worst cases is a good strategy in general."><y>#</y><d>2022-01-08</d><h>08:54</h><r>littleli</r>Yeah, just avoiding the worst cases is a good strategy in general.</z><z id="t1641631830" t="seancorfield I&apos;ve added the first cut of cached query generation in https://github.com/seancorfield/honeysql/pull/378 -- if you use embedded values, they are all cached as-is (and so you get a different cached version for each different set of parameters); if you use named parameters, you get a single cached version (I think! I need to verify this!). Small queries only see a small speedup (2-3x) but large, complex queries can see speedups of up to 20x so this definitely seems worthwhile (if you&apos;re using named parameters!). Please take it for a spin and provide feedback. The tests use a basic cache factory (so every single unique query is cached forever) but you could use any type of cache factory from clojure.core.cache.wrapped ."><y>#</y><d>2022-01-08</d><h>08:50</h><w>seancorfield</w>I&apos;ve added the first cut of cached query generation in <a href="https://github.com/seancorfield/honeysql/pull/378" target="_blank">https://github.com/seancorfield/honeysql/pull/378</a> -- if you use embedded values, they are all cached as-is (and so you get a different cached version for each different set of parameters); if you use named parameters, you get a single cached version (I think! I need to verify this!). Small queries only see a small speedup (2-3x) but large, complex queries can see speedups of up to 20x so this definitely seems worthwhile (if you&apos;re using named parameters!). Please take it for a spin and provide feedback. The tests use a basic cache factory (so every single unique query is cached forever) but you could use any type of cache factory from <code>clojure.core.cache.wrapped</code>.</z><z id="t1641639744" t="orestis Nice! Can you also cite absolute numbers? It would be interesting to see those too. "><y>#</y><d>2022-01-08</d><h>11:02</h><r>orestis</r>Nice! Can you also cite absolute numbers? It would be interesting to see those too. </z><z id="t1641667936" t="seancorfield It varies dramatically depending on the actual query. There are a couple of timing test cases in that PR if you want to try it yourself locally."><y>#</y><d>2022-01-08</d><h>18:52</h><r>seancorfield</r>It varies dramatically depending on the actual query. There are a couple of timing test cases in that PR if you want to try it yourself locally.</z><z id="t1641757920" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Are you open to some improvements with regards to GraalVM? A small tweak would help reduce the binary size."><y>#</y><d>2022-01-09</d><h>19:52</h><r>borkdude</r><a>@U04V70XH6</a> Are you open to some improvements with regards to GraalVM? A small tweak would help reduce the binary size.</z><z id="t1641758244" t="borkdude The tweak would be to pull this: &gt; ;; prefer requiring-resolve but that&apos;s 1.10+ only: &gt; (let [_ (require &apos;clojure.core.cache.wrapped) &gt; through (resolve &apos;clojure.core.cache.wrapped/lookup-or-miss)] to the top level and wrap it in a try/catch. So if core.cached is on the classpath and it loads correctly, then you will use it, else you will ignore it. This helps in following ways for GraalVM: 1. GraalVM sees the dependency at compile time so it includes it in the image. 2. Dynamic requires tend to bloat the native image, doing this at the top level prevents this. In general: Preventing calls to require &quot;at runtime&quot; would maybe save some runtime overhead. Here is some more info on that: https://github.com/borkdude/dynaload"><y>#</y><d>2022-01-09</d><h>19:57</h><r>borkdude</r>The tweak would be to pull this:
&gt;   ;; prefer requiring-resolve but that&apos;s 1.10+ only:
&gt;             (let [_ (require &apos;clojure.core.cache.wrapped)
&gt;                   through (resolve &apos;clojure.core.cache.wrapped/lookup-or-miss)]
to the top level and wrap it in a try/catch. So if core.cached is on the classpath and it loads correctly, then you will use it, else you will ignore it.

This helps in following ways for GraalVM:
1. GraalVM sees the dependency at compile time so it includes it in the image. 
2. Dynamic requires tend to bloat the native image, doing this at the top level prevents this.
In general:

Preventing calls to require &quot;at runtime&quot; would maybe save some runtime overhead.

Here is some more info on that: <a href="https://github.com/borkdude/dynaload" target="_blank">https://github.com/borkdude/dynaload</a></z><z id="t1641758528" t="Ben Sless This reminds me some time ago I floated an idea of splitting the rendering and parsing parts of honeysql queries where you said there are too many ad-hoc cases for it. I can give it a try if you&apos;d like"><y>#</y><d>2022-01-09</d><h>20:02</h><r>Ben Sless</r>This reminds me some time ago I floated an idea of splitting the rendering and parsing parts of honeysql queries where you said there are too many ad-hoc cases for it. I can give it a try if you&apos;d like</z><z id="t1641766061" t="seancorfield [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Sure, that&apos;s only in a PR so I can modify it any old way while it&apos;s still in progress. Could you add a comment on the PR explaining exactly what needs to be done there, so that it works correctly in Clojure/Script?"><y>#</y><d>2022-01-09</d><h>22:07</h><r>seancorfield</r><a>@U04V15CAJ</a> Sure, that&apos;s only in a PR so I can modify it any old way while it&apos;s still in progress. Could you add a comment on the PR explaining exactly what needs to be done there, so that it works correctly in Clojure/Script?</z><z id="t1641766098" t="seancorfield [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I&apos;ve no idea what you mean about &quot;parsing&quot; -- HoneySQL does no parsing?"><y>#</y><d>2022-01-09</d><h>22:08</h><r>seancorfield</r><a>@UK0810AQ2</a> I&apos;ve no idea what you mean about &quot;parsing&quot; -- HoneySQL does no parsing?</z><z id="t1641766123" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] will do tomorrow"><y>#</y><d>2022-01-09</d><h>22:08</h><r>borkdude</r><a>@U04V70XH6</a> will do tomorrow</z><z id="t1641809145" t="Ben Sless [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] honey SQL parses and renders the SQL string in a single pass, but it should be possible to front load most of the parsing and emit a single function that when taking the parameters will emit the rendered query in an optimized manner"><y>#</y><d>2022-01-10</d><h>10:05</h><r>Ben Sless</r><a>@U04V70XH6</a> honey SQL parses and renders the SQL string in a single pass, but it should be possible to front load most of the parsing and emit a single function that when taking the parameters will emit the rendered query in an optimized manner</z><z id="t1641818493" t="seancorfield [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] that&apos;s what this pull request provides, essentially - does it not address that for you?"><y>#</y><d>2022-01-10</d><h>12:41</h><r>seancorfield</r><a>@UK0810AQ2</a> that&apos;s what this pull request provides, essentially - does it not address that for you?</z><z id="t1641818963" t="borkdude [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I have a PR coming up to your PR. Old situation: Testing honey.cache-test Uncached, simple, embedded &quot;Elapsed time: 2611.85342 msecs&quot; Cached, simple, embedded &quot;Elapsed time: 946.489007 msecs&quot; Uncached, complex, mixed &quot;Elapsed time: 2058.002488 msecs&quot; Cached, complex, mixed &quot;Elapsed time: 90.428769 msecs&quot;"><y>#</y><d>2022-01-10</d><h>12:49</h><r>borkdude</r><a>@U04V70XH6</a> I have a PR coming up to your PR. Old situation:
<pre>Testing honey.cache-test
Uncached, simple, embedded
&quot;Elapsed time: 2611.85342 msecs&quot;
Cached, simple, embedded
&quot;Elapsed time: 946.489007 msecs&quot;
Uncached, complex, mixed
&quot;Elapsed time: 2058.002488 msecs&quot;
Cached, complex, mixed
&quot;Elapsed time: 90.428769 msecs&quot;</pre></z><z id="t1641818975" t="borkdude New situation: Testing honey.cache-test Uncached, simple, embedded &quot;Elapsed time: 2451.831827 msecs&quot; Cached, simple, embedded &quot;Elapsed time: 527.828611 msecs&quot; Uncached, complex, mixed &quot;Elapsed time: 2098.901274 msecs&quot; Cached, complex, mixed &quot;Elapsed time: 58.642879 msecs&quot;"><y>#</y><d>2022-01-10</d><h>12:49</h><r>borkdude</r>New situation:
<pre>Testing honey.cache-test
Uncached, simple, embedded
&quot;Elapsed time: 2451.831827 msecs&quot;
Cached, simple, embedded
&quot;Elapsed time: 527.828611 msecs&quot;
Uncached, complex, mixed
&quot;Elapsed time: 2098.901274 msecs&quot;
Cached, complex, mixed
&quot;Elapsed time: 58.642879 msecs&quot;</pre></z><z id="t1641819155" t="borkdude https://github.com/seancorfield/honeysql/pull/379"><y>#</y><d>2022-01-10</d><h>12:52</h><r>borkdude</r><a href="https://github.com/seancorfield/honeysql/pull/379" target="_blank">https://github.com/seancorfield/honeysql/pull/379</a></z><z id="t1641819396" t="Ben Sless [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] haven&apos;t looked too deep into it, but if borkdude&apos;s numbers are any indication there&apos;s at least another order of magnitude of rather easy* speedups."><y>#</y><d>2022-01-10</d><h>12:56</h><r>Ben Sless</r><a>@U04V70XH6</a> haven&apos;t looked too deep into it, but if borkdude&apos;s numbers are any indication there&apos;s at least another order of magnitude of rather easy* speedups.</z><z id="t1641819542" t="borkdude such as?"><y>#</y><d>2022-01-10</d><h>12:59</h><r>borkdude</r>such as?</z><z id="t1641819637" t="Ben Sless I&apos;ll need to give it a detailed look, but on JVM carrying a single strong builder instead if calling str multiple times has a significant effect"><y>#</y><d>2022-01-10</d><h>13:00</h><r>Ben Sless</r>I&apos;ll need to give it a detailed look, but on JVM carrying a single strong builder instead if calling str multiple times has a significant effect</z><z id="t1641819666" t="borkdude for the JVM but in babashka it will be slower :/"><y>#</y><d>2022-01-10</d><h>13:01</h><r>borkdude</r>for the JVM but in babashka it will be slower :/</z><z id="t1641819729" t="borkdude but yeah that would work"><y>#</y><d>2022-01-10</d><h>13:02</h><r>borkdude</r>but yeah that would work</z><z id="t1641819783" t="Ben Sless Let&apos;s take it in the babashka channel I&apos;m curious"><y>#</y><d>2022-01-10</d><h>13:03</h><r>Ben Sless</r>Let&apos;s take it in the babashka channel I&apos;m curious</z><z id="t1641844925" t="seancorfield What is cached is the generated vector of SQL string + embedded parameter values. If you use named parameters, placeholders are putting into that vector (instead of the lifted values), and the only work done after the cached vector is retrieved is a single pass over the vector, calling each placeholder with the :params hash map. There&apos;s no string manipulation performed in that case. String vs StringBuilder would indeed make the uncached version a lot faster but would substantially complicate the code and make writing extensions much harder as well."><y>#</y><d>2022-01-10</d><h>20:02</h><r>seancorfield</r>What is cached is the generated vector of SQL string + embedded parameter values. If you use named parameters, placeholders are putting into that vector (instead of the lifted values), and the only work done after the cached vector is retrieved is a single pass over the vector, calling each placeholder with the <code>:params</code> hash map. There&apos;s no string manipulation performed in that case. String vs StringBuilder would indeed make the uncached version a lot faster but would substantially complicate the code and make writing extensions much harder as well.</z><z id="t1641845065" t="borkdude There&apos;s always a trade-off when it comes to performance optimizations"><y>#</y><d>2022-01-10</d><h>20:04</h><r>borkdude</r>There&apos;s always a trade-off when it comes to performance optimizations</z><z id="t1641881935" t="Ben Sless Anyway, I&apos;ll start with profiling, may be some easy optimizations"><y>#</y><d>2022-01-11</d><h>06:18</h><r>Ben Sless</r>Anyway, I&apos;ll start with profiling, may be some easy optimizations</z><z id="t1642370572" t="seancorfield [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Did you get a chance to do any of that profiling? Just curious."><y>#</y><d>2022-01-16</d><h>22:02</h><r>seancorfield</r><a>@UK0810AQ2</a> Did you get a chance to do any of that profiling? Just curious.</z><z id="t1642370678" t="seancorfield I&apos;m taking a few days off work at the end of this week so I&apos;ll be writing up the documentation for this PR and merging it in and making a release. If anyone has feedback and -- especially -- if you can do some testing of the PR in your environment, the next few days would be a good time to get that in... Thanks!"><y>#</y><d>2022-01-16</d><h>22:04</h><r>seancorfield</r>I&apos;m taking a few days off work at the end of this week so I&apos;ll be writing up the documentation for this PR and merging it in and making a release. If anyone has feedback and -- especially -- if you can do some testing of the PR in your environment, the next few days would be a good time to get that in... Thanks!</z><z id="t1642395582" t="Ben Sless [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] was a bit swamped with work and life but should get to it today (Monday morning here already)."><y>#</y><d>2022-01-17</d><h>04:59</h><r>Ben Sless</r><a>@U04V70XH6</a> was a bit swamped with work and life but should get to it today (Monday morning here already).</z><z id="t1642399909" t="Ben Sless Profiling results are in, bit hard to read because of laziness"><y>#</y><d>2022-01-17</d><h>06:11</h><r>Ben Sless</r>Profiling results are in, bit hard to read because of laziness</z><z id="t1642399946" t="Ben Sless Unsurprisingly, most work is iteration and format-expr"><y>#</y><d>2022-01-17</d><h>06:12</h><r>Ben Sless</r>Unsurprisingly, most work is iteration and <code>format-expr</code></z><z id="t1642443952" t="seancorfield Yeah, I&apos;d definitely expect some possible optimizations in walking the data and bashing the strings together (but don&apos;t want to switch to StringBuilder per above). I&apos;d be surprised if there&apos;s much optimization available in the &quot;fill-in-the-blanks&quot; post-cache processing?"><y>#</y><d>2022-01-17</d><h>18:25</h><r>seancorfield</r>Yeah, I&apos;d definitely expect some possible optimizations in walking the data and bashing the strings together (but don&apos;t want to switch to StringBuilder per above). I&apos;d be surprised if there&apos;s much optimization available in the &quot;fill-in-the-blanks&quot; post-cache processing?</z><z id="t1642444596" t="Ben Sless I&apos;ll give it a look, too"><y>#</y><d>2022-01-17</d><h>18:36</h><r>Ben Sless</r>I&apos;ll give it a look, too</z><z id="t1642444666" t="Ben Sless Constantly calling into is also pretty wasteful, and usually destructured right after"><y>#</y><d>2022-01-17</d><h>18:37</h><r>Ben Sless</r>Constantly calling into is also pretty wasteful, and usually destructured right after</z><z id="t1642444727" t="Ben Sless Re string bashing, you can use a portable string builder function, then ideally return a single eduction which would walk the data once and collect into a string"><y>#</y><d>2022-01-17</d><h>18:38</h><r>Ben Sless</r>Re string bashing, you can use a portable string builder function, then ideally return a single eduction which would walk the data once and collect into a string</z><z id="t1642444767" t="Ben Sless Did some experiments this morning, should be possible"><y>#</y><d>2022-01-17</d><h>18:39</h><r>Ben Sless</r>Did some experiments this morning, should be possible</z><z id="t1642444822" t="Ben Sless But requires care"><y>#</y><d>2022-01-17</d><h>18:40</h><r>Ben Sless</r>But requires care</z><z id="t1642714262" t="seancorfield Feel free to open issues with the results of any of your analysis/optimizations [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}]"><y>#</y><d>2022-01-20</d><h>21:31</h><r>seancorfield</r>Feel free to open issues with the results of any of your analysis/optimizations <a>@UK0810AQ2</a></z><z id="t1642370678" t="seancorfield I&apos;m taking a few days off work at the end of this week so I&apos;ll be writing up the documentation for this PR and merging it in and making a release. If anyone has feedback and -- especially -- if you can do some testing of the PR in your environment, the next few days would be a good time to get that in... Thanks!"><y>#</y><d>2022-01-16</d><h>22:04</h><w>seancorfield</w>I&apos;m taking a few days off work at the end of this week so I&apos;ll be writing up the documentation for this PR and merging it in and making a release. If anyone has feedback and -- especially -- if you can do some testing of the PR in your environment, the next few days would be a good time to get that in... Thanks!</z><z id="t1642175093" t="paulbutcher I suspect that this is me being dense, but I am struggling to find a way to pass arguments to functions with Honey SQL. The SQL I’m trying to generate is: [&quot;SELECT name, SQRT(POW(lat - ?, 2) + POW(long - ?, 2)) AS distance FROM circuits&quot; x y] and I’m damned if I can work out how to persuade Honey SQL to generate it. I’d be very grateful for a nudge in the right direction? Thanks!"><y>#</y><d>2022-01-14</d><h>15:44</h><w>paulbutcher</w>I suspect that this is me being dense, but I am struggling to find a way to pass arguments to functions with Honey SQL. The SQL I’m trying to generate is:
<pre>[&quot;SELECT name, SQRT(POW(lat - ?, 2) + POW(long - ?, 2)) AS distance FROM circuits&quot; x y]</pre>
and I’m damned if I can work out how to persuade Honey SQL to generate it. I’d be very grateful for a nudge in the right direction?

Thanks!</z><z id="t1642177080" t="aav (let [x 1 y 2] (honey/format {:select [:name [[:sqrt [[:+ [[:pow [[:- :lat x]] [:inline 2]]] [[:pow [[:- :long y]] [:inline 2]]]]]] :distance]] :from [:circuits]}))"><y>#</y><d>2022-01-14</d><h>16:18</h><r>aav</r><pre>(let [x 1 y 2]
  (honey/format
    {:select
     [:name
      [[:sqrt
        [[:+
          [[:pow [[:- :lat x]] [:inline 2]]]
          [[:pow [[:- :long y]] [:inline 2]]]]]] :distance]]
     :from [:circuits]}))</pre></z><z id="t1642178250" t="paulbutcher Thank you!"><y>#</y><d>2022-01-14</d><h>16:37</h><r>paulbutcher</r>Thank you!</z><z id="t1642178336" t="paulbutcher Is this mentioned in the documentation anywhere? The only mention of calling a function I could find was the % notation?"><y>#</y><d>2022-01-14</d><h>16:38</h><r>paulbutcher</r>Is this mentioned in the documentation anywhere? The only mention of calling a function I could find was the <code>%</code> notation?</z></g><g id="s5"><z id="t1642178659" t="aav &quot;Since regular function calls are indicated with vectors and so are aliased pairs, this shorthand can be more convenient due to the extra wrapping needed for the regular function calls in a select:&quot; (-&gt; (select [[:count :*]]) (from :foo) sql/format) =&gt; [&quot;SELECT COUNT(*) FROM foo&quot;]"><y>#</y><d>2022-01-14</d><h>16:44</h><r>aav</r>&quot;Since regular function calls are indicated with vectors and so are aliased pairs, this shorthand can be more convenient due to the extra wrapping needed for the regular function calls in a select:&quot;

<pre>(-&gt; (select [[:count :*]]) (from :foo) sql/format)
=&gt; [&quot;SELECT COUNT(*) FROM foo&quot;]</pre></z><z id="t1642178690" t="aav https://github.com/seancorfield/honeysql"><y>#</y><d>2022-01-14</d><h>16:44</h><r>aav</r><a href="https://github.com/seancorfield/honeysql" target="_blank">https://github.com/seancorfield/honeysql</a></z><z id="t1642178841" t="paulbutcher Thanks. I guess I (mis-) interpreted that as only applying to operators. Got it now, thanks."><y>#</y><d>2022-01-14</d><h>16:47</h><r>paulbutcher</r>Thanks. I guess I (mis-) interpreted that as only applying to operators. Got it now, thanks.</z><z id="t1642181006" t="seancorfield [:attrs {:href &quot;/_/_/users/U5KAD4W2E&quot;}] If you have a suggestion for where in the docs that should be called out more clearly, feel free to create issues on the repo! I guess both the readme and the getting started pages should have function call examples in them somewhere?"><y>#</y><d>2022-01-14</d><h>17:23</h><r>seancorfield</r><a>@U5KAD4W2E</a> If you have a suggestion for where in the docs that should be called out more clearly, feel free to create issues on the repo! I guess both the readme and the getting started pages should have function call examples in them somewhere?</z><z id="t1642181047" t="paulbutcher Yes, I think that that would have helped me work things out. Give me a moment and I’ll see if I can come up with something 👍"><y>#</y><d>2022-01-14</d><h>17:24</h><r>paulbutcher</r>Yes, I think that that would have helped me work things out. Give me a moment and I’ll see if I can come up with something <b>👍</b></z><z id="t1642238545" t="pinkfrog Hi. I am using sql"><y>#</y><d>2022-01-15</d><h>09:22</h><w>pinkfrog</w>Hi. I am using sql</z><z id="t1642238600" t="pinkfrog How to compose the following with honey helpers? (str &quot;SET statement_timeout = 300000;\n&quot; &quot;SET idle_in_transaction_session_timeout = 300000;&quot;)) "><y>#</y><d>2022-01-15</d><h>09:23</h><w>pinkfrog</w>How to compose the following with honey helpers?
<pre>(str &quot;SET statement_timeout = 300000;\n&quot;
       &quot;SET idle_in_transaction_session_timeout = 300000;&quot;))</pre>
</z><z id="t1642283362" t="seancorfield [:attrs {:href &quot;/_/_/users/UGC0NEP4Y&quot;}] Since those are neither SQL nor DDL (they are database-specific settings), there is no support in HoneySQL for that."><y>#</y><d>2022-01-15</d><h>21:49</h><w>seancorfield</w><a>@i</a> Since those are neither SQL nor DDL (they are database-specific settings), there is no support in HoneySQL for that.</z><z id="t1642341677" t="pinkfrog Can’t I go with something like raw ?"><y>#</y><d>2022-01-16</d><h>14:01</h><r>pinkfrog</r>Can’t I go with something like <code>raw</code> ?</z><z id="t1642357812" t="seancorfield You might as well just use [&quot;SQL string&quot;] directly with next.jdbc at that point -- why use HoneySQL for something that is entirely raw SQL strings?"><y>#</y><d>2022-01-16</d><h>18:30</h><r>seancorfield</r>You might as well just use <code>[&quot;SQL string&quot;]</code> directly with <code>next.jdbc</code> at that point -- why use HoneySQL for something that is entirely raw SQL strings?</z><z id="t1642714216" t="seancorfield Caching, BigQuery support, a convenience for WHERE clause comparisons."><y>#</y><d>2022-01-20</d><h>21:30</h><w>seancorfield</w>Caching, BigQuery support, a convenience for <code>WHERE</code> clause comparisons.</z><z id="t1642771385" t="thumbnail Cool to see the caching feature being released! We use honeysql extensively, but most of the queries use https://www.postgresql.org/docs/8.3/queries-values.html ; resulting in a dynamic amount of parameters most queries (even though most of the query is the same). Would we be able to leverage the new caching mechanic?"><y>#</y><d>2022-01-21</d><h>13:23</h><w>thumbnail</w>Cool to see the caching feature being released!

We use honeysql extensively, but most of the queries use <a href="https://www.postgresql.org/docs/8.3/queries-values.html" target="_blank">https://www.postgresql.org/docs/8.3/queries-values.html</a>; resulting in a dynamic amount of parameters most queries (even though most of the query is the same).

Would we be able to leverage the new caching mechanic?</z><z id="t1642790331" t="seancorfield [:attrs {:href &quot;/_/_/users/UHJH8MG6S&quot;}] I&apos;d have to see how you&apos;re generating those in HoneySQL to offer an opinion, but I suspect if the number of parameters is varying, the best you&apos;ll get is cached generation for each multiple of parameters (since it&apos;s the data structure that is used as a cache key and I think that&apos;s going to vary based on the number of parameters, right?)."><y>#</y><d>2022-01-21</d><h>18:38</h><w>seancorfield</w><a>@jeroen.dejong</a> I&apos;d have to see how you&apos;re generating those in HoneySQL to offer an opinion, but I suspect if the number of parameters is varying, the best you&apos;ll get is cached generation for each multiple of parameters (since it&apos;s the data structure that is used as a cache key and I think that&apos;s going to vary based on the number of parameters, right?).</z><z id="t1642791842" t="thumbnail Yeah the amount of parameters can differ quite a lot, but we may be able to pass entire arrays through as 1 parameter; but I&apos;m not sure about the safety in that case 😅 It would help us with keeping track of the same queries, but that&apos;s another story altogether:sweat_smile:"><y>#</y><d>2022-01-21</d><h>19:04</h><r>thumbnail</r>Yeah the amount of parameters can differ quite a lot, but we may be able to pass entire arrays through as 1 parameter; but I&apos;m not sure about the safety in that case <b>😅</b>


It would help us with keeping track of the same queries, but that&apos;s another story altogether:sweat_smile:</z><z id="t1643292638" t="Jakub Holý (HolyJak) Hi! Is there a way to force (values [{:id 1, :valid true}]) to generate &quot;... values(?,?)&quot; instead of &quot;... values(?,TRUE)&quot; ? I have been reading the docs and code but could not figure it out 🙏"><y>#</y><d>2022-01-27</d><h>14:10</h><w>Jakub Holý (HolyJak)</w>Hi! Is there a way to force <code>(values [{:id 1, :valid true}])</code> to generate <code>&quot;... values(?,?)&quot;</code> instead of <code>&quot;... values(?,TRUE)&quot;</code> ? I have been reading the docs and code but could not figure it out <b>🙏</b></z><z id="t1643310886" t="seancorfield That&apos;s what :lift is for: dev=&gt; (sql/format (h/values [{:id 1 :value true}])) [&quot;(id, value) VALUES (?, TRUE)&quot; 1] dev=&gt; (sql/format (h/values [{:id 1 :value [:lift true]}])) [&quot;(id, value) VALUES (?, ?)&quot; 1 true] dev=&gt; https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.858/doc/getting-started/sql-special-syntax-#lift"><y>#</y><d>2022-01-27</d><h>19:14</h><w>seancorfield</w>That&apos;s what <code>:lift</code> is for:
<pre>dev=&gt; (sql/format (h/values [{:id 1 :value true}]))
[&quot;(id, value) VALUES (?, TRUE)&quot; 1]
dev=&gt; (sql/format (h/values [{:id 1 :value [:lift true]}]))
[&quot;(id, value) VALUES (?, ?)&quot; 1 true]
dev=&gt; </pre>
<a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.858/doc/getting-started/sql-special-syntax-#lift" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.858/doc/getting-started/sql-special-syntax-#lift</a></z><z id="t1643313370" t="Jakub Holý (HolyJak) Thanks a lot! I believed I saw something like that in the docs when I first read them but when I was searching them I obviously failed to find the right search terms / look at the right place 😔"><y>#</y><d>2022-01-27</d><h>19:56</h><w>Jakub Holý (HolyJak)</w>Thanks a lot! I believed I saw something like that in the docs when I first read them but when I was searching them I obviously failed to find the right search terms / look at the right place <b>😔</b></z><z id="t1643316728" t="rafaeldelboni Hey hello, does anybody knows if is possible to reproduce this in honeysql? ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);"><y>#</y><d>2022-01-27</d><h>20:52</h><w>rafaeldelboni</w>Hey hello, does anybody knows if is possible to reproduce this in honeysql?
<pre>ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);</pre></z><z id="t1643316753" t="rafaeldelboni https://www.postgresql.org/docs/current/sql-altertable.html"><y>#</y><d>2022-01-27</d><h>20:52</h><r>rafaeldelboni</r><a href="https://www.postgresql.org/docs/current/sql-altertable.html" target="_blank">https://www.postgresql.org/docs/current/sql-altertable.html</a></z><z id="t1643320930" t="seancorfield DDL is often very database-specific and hard to design a DSL for that works predictably so I&apos;m open to adding support where there is ANSI-standard syntax but for a lot of DDL, it&apos;s just not worth going through HoneySQL, IMO."><y>#</y><d>2022-01-27</d><h>22:02</h><r>seancorfield</r>DDL is often very database-specific and hard to design a DSL for that works predictably so I&apos;m open to adding support where there is ANSI-standard syntax but for a lot of DDL, it&apos;s just not worth going through HoneySQL, IMO.</z><z id="t1643367603" t="rafaeldelboni Makes sense, thanks"><y>#</y><d>2022-01-28</d><h>11:00</h><r>rafaeldelboni</r>Makes sense, thanks</z><z id="t1643322899" t="Max ~I’m having a little trouble getting sql functions working with honeysql. Taking this example directly out of the readme:~ (-&gt; {:select [[[:max :id]]], :from [:foo]} sql/format) ~I’m supposed to get ~ Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385). Assert failed: Alias should have two parts[[:max :id]] ~Are the docs out of date; is there a newer way to call functions?~ EDIT: facepalm I’m using an older version of honeysql from before that syntax was introduced. Ignore me!"><y>#</y><d>2022-01-27</d><h>22:34</h><w>Max</w>~I’m having a little trouble getting sql functions working with honeysql. Taking this example directly out of the readme:~
<pre>(-&gt; {:select [[[:max :id]]], :from [:foo]} sql/format)</pre>
~I’m supposed to get ~
<pre>Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385).
Assert failed: Alias should have two parts[[:max :id]]</pre>
~Are the docs out of date; is there a newer way to call functions?~

EDIT: <b>facepalm</b> I’m using an older version of honeysql from before that syntax was introduced. Ignore me!</z><z id="t1643654162" t="seancorfield More BigQuery support; easier extension to new clauses."><y>#</y><d>2022-01-31</d><h>18:36</h><w>seancorfield</w>More BigQuery support; easier extension to new clauses.</z><z id="t1644336364" t="wcalderipe Hey, I wonder if is there a better way to write a query using CASE WHEN within the SUM ? For example, getting rid of the :raw somehow. {:select [[[:raw &quot;SUM(CASE WHEN direction = &apos;in&apos; THEN amount ELSE 0 END) as in&quot;]] [[:raw &quot;SUM(CASE WHEN direction = &apos;out&apos; THEN amount ELSE 0 END) as out&quot;]]] :from [:foo]}"><y>#</y><d>2022-02-08</d><h>16:06</h><w>wcalderipe</w>Hey, I wonder if is there a better way to write a query using <code>CASE WHEN</code> within the <code>SUM</code>? For example, getting rid of the <code>:raw</code> somehow.

<pre>{:select [[[:raw &quot;SUM(CASE WHEN direction = &apos;in&apos; THEN amount ELSE 0 END) as in&quot;]]
          [[:raw &quot;SUM(CASE WHEN direction = &apos;out&apos; THEN amount ELSE 0 END) as out&quot;]]]
 :from   [:foo]}</pre></z><z id="t1644339147" t="seancorfield [:attrs {:href &quot;/_/_/users/UHD67JRL4&quot;}] Why would you need :raw there? dev=&gt; (sql/format {:select [[[:sum [:case [:= :direction &quot;in&quot;] :amount :else 0]] :in] #_=&gt; [[:sum [:case [:= :direction &quot;out&quot;] :amount :else 0]] :out]] #_=&gt; :from :foo}) [&quot;SELECT SUM(CASE WHEN direction = ? THEN amount ELSE ? END) AS in, SUM(CASE WHEN direction = ? THEN amount ELSE ? END) AS out FROM foo&quot; &quot;in&quot; 0 &quot;out&quot; 0]"><y>#</y><d>2022-02-08</d><h>16:52</h><w>seancorfield</w><a>@wcalderipe</a> Why would you need <code>:raw</code> there?
<pre>dev=&gt; (sql/format {:select [[[:sum [:case [:= :direction &quot;in&quot;] :amount :else 0]] :in]
 #_=&gt;                       [[:sum [:case [:= :direction &quot;out&quot;] :amount :else 0]] :out]]
 #_=&gt;              :from :foo})
[&quot;SELECT SUM(CASE WHEN direction = ? THEN amount ELSE ? END) AS in, SUM(CASE WHEN direction = ? THEN amount ELSE ? END) AS out FROM foo&quot; &quot;in&quot; 0 &quot;out&quot; 0]</pre></z><z id="t1644350876" t="wcalderipe I wasn&apos;t sure if I need it; hence the question here. It&apos;s my first time using HoneySQL so I&apos;m still learning how to work with it. Thanks for the answer 😄"><y>#</y><d>2022-02-08</d><h>20:07</h><r>wcalderipe</r>I wasn&apos;t sure if I need it; hence the question here.

It&apos;s my first time using HoneySQL so I&apos;m still learning how to work with it.

Thanks for the answer <b>😄</b></z><z id="t1644352954" t="seancorfield Use of :raw should be extremely rare -- and only needed for really unusual corner case syntax."><y>#</y><d>2022-02-08</d><h>20:42</h><r>seancorfield</r>Use of <code>:raw</code> should be extremely rare -- and only needed for really unusual corner case syntax.</z><z id="t1644601413" t="markbastian How might I express SELECT COUNT(*) &gt; 0 in honeysql? I’ve got :select [:%count.*] so far for the count. Just trying to get that &gt; 0 in there. Thanks!"><y>#</y><d>2022-02-11</d><h>17:43</h><w>markbastian</w>How might I express <code>SELECT COUNT(*) &gt; 0</code> in honeysql? I’ve got
<pre>:select [:%count.*]</pre>
so far for the count. Just trying to get that &gt; 0 in there. Thanks!</z><z id="t1644602787" t="john-shaffer https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%0A%20%3Apretty%20true%7D https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D {:select [[[:&gt; [:count :*] 0]]]}"><y>#</y><d>2022-02-11</d><h>18:06</h><r>john-shaffer</r><a href="https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%0A%20%3Apretty%20true%7D" target="_blank">https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%0A%20%3Apretty%20true%7D</a><a href="https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D" target="_blank">https://john.shaffe.rs/honeysql/?q=%7B%3Aselect%20%5B%5B%5B%3A%3E%20%5B%3Acount%20%3A*%5D%200%5D%5D%5D%7D&amp;amp;opt=%7B%3Achecking%20%3Astrict%7D</a> <code>{:select [[[:&gt; [:count :*] 0]]]}</code></z><z id="t1644605258" t="markbastian yeah, like that, but when I use that I get: Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385). Assert failed: Alias should have two parts[[:&gt; [:count :*] 0]] (= 2 (count x)) "><y>#</y><d>2022-02-11</d><h>18:47</h><r>markbastian</r>yeah, like that, but when I use that I get:
<pre>Execution error (AssertionError) at honeysql.format/seq-&gt;sql (format.cljc:385).
Assert failed: Alias should have two parts[[:&gt; [:count :*] 0]]
(= 2 (count x))</pre>
</z><z id="t1644605406" t="john-shaffer Oh, sorry, that&apos;s version 2. I don&apos;t know how to do it in v1"><y>#</y><d>2022-02-11</d><h>18:50</h><r>john-shaffer</r>Oh, sorry, that&apos;s version 2. I don&apos;t know how to do it in v1</z><z id="t1644870058" t="hanDerPeder so I have this guy st_makeline(point order by ts)::geography line , best I can come up with is [[[:cast [:st_makeline [:order-by :point :ts]] :geography]] :line] seems like a case where raw is clearer"><y>#</y><d>2022-02-14</d><h>20:20</h><w>hanDerPeder</w>so I have this guy <code>st_makeline(point order by ts)::geography line</code>,
best I can come up with is <code>[[[:cast [:st_makeline [:order-by :point :ts]] :geography]] :line]</code>
seems like a case where <code>raw</code> is clearer</z><z id="t1644870382" t="seancorfield [:attrs {:href &quot;/_/_/users/U013U475882&quot;}] Yes, sometimes raw will be clearer. A general DSL is not always going to be shorter or easier to read than the language it represents."><y>#</y><d>2022-02-14</d><h>20:26</h><w>seancorfield</w><a>@peder.refsnes</a> Yes, sometimes <code>raw</code> will be clearer. A general DSL is not always going to be shorter or easier to read than the language it represents.</z><z id="t1644870469" t="hanDerPeder thanks sean. just wondered if I had missed something. love the lib by the way. composing query snippets is amazing!"><y>#</y><d>2022-02-14</d><h>20:27</h><w>hanDerPeder</w>thanks sean. just wondered if I had missed something. love the lib by the way. composing query snippets is amazing!</z><z id="t1644934722" t="Stas Makarov i’m trying to write this query: SELECT c.id, c.name, JSONB_AGG(JSONB_BUILD_OBJECT(&apos;id&apos;, ce.expertise_id, &apos;years&apos;, ce.experience_years)) AS &quot;expertises&quot; FROM candidates AS C LEFT JOIN candidate_expertises AS ce ON c.id = ce.candidate_id GROUP BY c.id as .. (:require [honey.sql :as sql2] [honey.sql.helpers :as sqlh2]).. (-&gt; (sqlh2/select :c.id :c.name [[:jsonb_agg [:jsonb_build_object &quot;id&quot; :ce.expertise_id &quot;experience_years&quot; :ce.experience_years]] &quot;expertises&quot;] ) (sqlh2/from [:candidates :c]) (sqlh2/left-join [:candidate-expertises :ce] [:= :c.id :ce.candidate-id]) (sqlh2/group-by :c.id)) sql/format returns [&quot;SELECT c.id, c.name, JSONB_AGG(JSONB_BUILD_OBJECT(?, ce.expertise_id, ?, ce.experience_years)) AS \&quot;expertises\&quot; FROM candidates AS c LEFT JOIN candidate_expertises AS ce ON c.id = ce.candidate_id GROUP BY c.id&quot; &quot;id&quot; &quot;experience_years&quot;] and execute throws this error: Assert failed: Alias should have two parts[:jsonb_build_object &quot;id&quot; :ce.expertise_id &quot;experience_years&quot; :ce.experience_years] (= 2 (count x)) and i’m lost :)"><y>#</y><d>2022-02-15</d><h>14:18</h><w>Stas Makarov</w>i’m trying to write this query:
<pre>SELECT c.id, c.name,
       JSONB_AGG(JSONB_BUILD_OBJECT(&apos;id&apos;, ce.expertise_id,
                                    &apos;years&apos;, ce.experience_years)) AS &quot;expertises&quot;
  FROM candidates AS C
       LEFT JOIN candidate_expertises AS ce ON c.id = ce.candidate_id
 GROUP BY c.id</pre>
as
<pre>.. (:require    [honey.sql :as sql2]
                     [honey.sql.helpers :as sqlh2])..

(-&gt; (sqlh2/select
        :c.id
        :c.name
        [[:jsonb_agg [:jsonb_build_object
                      &quot;id&quot; :ce.expertise_id
                      &quot;experience_years&quot; :ce.experience_years]] &quot;expertises&quot;]
        )
      (sqlh2/from [:candidates :c])
      (sqlh2/left-join [:candidate-expertises :ce] [:= :c.id :ce.candidate-id])
      (sqlh2/group-by :c.id))</pre>
<code>sql/format</code> returns
<pre>[&quot;SELECT c.id, c.name, 
JSONB_AGG(JSONB_BUILD_OBJECT(?, ce.expertise_id, ?, ce.experience_years)) AS \&quot;expertises\&quot; 
FROM candidates AS c 
LEFT JOIN candidate_expertises AS ce ON c.id = ce.candidate_id 
GROUP BY c.id&quot;
 &quot;id&quot;
 &quot;experience_years&quot;]</pre>
and <code>execute</code> throws this error:
<pre>Assert failed: Alias should have two parts[:jsonb_build_object &quot;id&quot;
   :ce.expertise_id &quot;experience_years&quot; :ce.experience_years] (= 2 (count x))</pre>
and i’m lost :)</z><z id="t1644936899" t="Stas Makarov solved it: i used our helper for execute , which called format from honey v1 🙃"><y>#</y><d>2022-02-15</d><h>14:54</h><w>Stas Makarov</w>solved it: i used our helper for <code>execute</code>, which called <code>format</code> from honey v1 <b>🙃</b></z><z id="t1644938909" t="Stas Makarov but i still want to figure out if it’s possible to solve this with honey v1.0.461 : .. (:require [honeysql.core :as sql] [honeysql.helpers :as sqlh]) .. (-&gt; (sqlh/select :c.id :c.name [[:jsonb_agg [:jsonb_build_object &quot;id&quot; :ce.expertise_id &quot;experience_years&quot; :ce.experience_years]] &quot;expertises&quot;] ) (sqlh/from [:candidates :c]) (sqlh/left-join [:candidate-expertises :ce] [:= :c.id :ce.candidate-id]) (sqlh/group :c.id) (sql/format)) throws the same exception as above"><y>#</y><d>2022-02-15</d><h>15:28</h><w>Stas Makarov</w>but i still want to figure out if it’s possible to solve this with <code>honey v1.0.461</code> :
<pre>.. (:require    [honeysql.core :as sql]   [honeysql.helpers :as sqlh]) .. 

(-&gt; (sqlh/select
          :c.id
          :c.name
          [[:jsonb_agg [:jsonb_build_object
                        &quot;id&quot; :ce.expertise_id
                        &quot;experience_years&quot; :ce.experience_years]] &quot;expertises&quot;]
          )
        (sqlh/from [:candidates :c])
        (sqlh/left-join [:candidate-expertises :ce] [:= :c.id :ce.candidate-id])
        (sqlh/group :c.id)
        (sql/format))</pre>
throws the same exception as above</z><z id="t1644939603" t="seancorfield In v1, you almost certainly need sql/call to identify the function calls in the select."><y>#</y><d>2022-02-15</d><h>15:40</h><w>seancorfield</w>In v1, you almost certainly need sql/call to identify the function calls in the select.</z><z id="t1644940562" t="Stas Makarov thanks a lot, Sean! it seems to be working with: .. [(sql/call &quot;jsonb_agg&quot; (sql/call &quot;jsonb_build_object&quot; &quot;id&quot; :ce.expertise_id &quot;years&quot; :ce.experience_years)) &quot;expertises&quot;] .. "><y>#</y><d>2022-02-15</d><h>15:56</h><w>Stas Makarov</w>thanks a lot, Sean! it seems to be working with:
<pre>..
[(sql/call
            &quot;jsonb_agg&quot;
            (sql/call &quot;jsonb_build_object&quot;
                      &quot;id&quot; :ce.expertise_id
                      &quot;years&quot; :ce.experience_years)) &quot;expertises&quot;] .. </pre></z><z id="t1645361567" t="Ben Sless the dehyphen docstring mentions There&apos;s probably a faster solution. I don&apos;t know if javascript supports lookahead matches, but this regex is ~2x faster (str/replace s #&quot;(?!\w)-(?=\w)&quot; &quot; &quot;)"><y>#</y><d>2022-02-20</d><h>12:52</h><w>Ben Sless</w>the <code>dehyphen</code> docstring mentions There&apos;s probably a faster solution. I don&apos;t know if javascript supports lookahead matches, but this regex is ~2x faster <code>(str/replace s #&quot;(?!\w)-(?=\w)&quot; &quot; &quot;)</code></z><z id="t1645389400" t="seancorfield [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] can you open a ticket about that so I don&apos;t forget?"><y>#</y><d>2022-02-20</d><h>20:36</h><r>seancorfield</r><a>@UK0810AQ2</a> can you open a ticket about that so I don&apos;t forget?</z><z id="t1645389532" t="Ben Sless Gladly. Was hoping exactly for a reply directing me towards the best place to leave it I can PR it, too, if you&apos;d like"><y>#</y><d>2022-02-20</d><h>20:38</h><r>Ben Sless</r>Gladly. Was hoping exactly for a reply directing me towards the best place to leave it
I can PR it, too, if you&apos;d like</z><z id="t1645389872" t="Ben Sless BTW, I think I figured out out to separate the string bashing from parsing the expression"><y>#</y><d>2022-02-20</d><h>20:44</h><r>Ben Sless</r>BTW, I think I figured out out to separate the string bashing from parsing the expression</z><z id="t1645392563" t="seancorfield Sure, PR is fine. Make sure you run the ci tests so the docs and cljs are all tested -- and perhaps make sure there&apos;s at least one test that verifies multi-part-names still work."><y>#</y><d>2022-02-20</d><h>21:29</h><r>seancorfield</r>Sure, PR is fine. Make sure you run the <code>ci</code> tests so the docs and cljs are all tested -- and perhaps make sure there&apos;s at least one test that verifies multi-part-names still work.</z><z id="t1645392583" t="seancorfield But if you don&apos;t want to go to that effort, just an issue is fine too."><y>#</y><d>2022-02-20</d><h>21:29</h><r>seancorfield</r>But if you don&apos;t want to go to that effort, just an issue is fine too.</z><z id="t1645429119" t="Ben Sless done 🙂 https://github.com/seancorfield/honeysql/issues/387"><y>#</y><d>2022-02-21</d><h>07:38</h><r>Ben Sless</r>done <b>🙂</b>
<a href="https://github.com/seancorfield/honeysql/issues/387" target="_blank">https://github.com/seancorfield/honeysql/issues/387</a></z><z id="t1645469677" t="seancorfield Thanks [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] -- I&apos;ll check the cljs stuff as well."><y>#</y><d>2022-02-21</d><h>18:54</h><r>seancorfield</r>Thanks <a>@UK0810AQ2</a> -- I&apos;ll check the cljs stuff as well.</z><z id="t1645489002" t="pinkfrog Hi. How to convert this query into next-jdbc. update task set scheduled_at = clock_timestamp() + ?::interval I don’t how to make the ? :: interval part."><y>#</y><d>2022-02-22</d><h>00:16</h><w>pinkfrog</w>Hi. How to convert this query into next-jdbc.
<pre>update task
set scheduled_at = clock_timestamp() + ?::interval</pre>
I don’t how to make the ?<b>::</b>interval part.</z><z id="t1645495318" t="seancorfield [:attrs {:href &quot;/_/_/users/UGC0NEP4Y&quot;}] I saw you asked this in #sql as well and got an answer there."><y>#</y><d>2022-02-22</d><h>02:01</h><w>seancorfield</w><a>@i</a> I saw you asked this in #sql as well and got an answer there.</z><z id="t1645495544" t="seancorfield The ::type cast syntax is not supported, only the CAST( foo AS bar ) syntax -- and it&apos;s explained in the docs."><y>#</y><d>2022-02-22</d><h>02:05</h><w>seancorfield</w>The <code>::type</code> cast syntax is not supported, only the <code>CAST( foo AS bar )</code> syntax -- and it&apos;s explained in the docs.</z><z id="t1645495631" t="seancorfield If that syntax works for you, it would be: dev=&gt; (sql/format {:update :task :set {:scheduled_at [:+ [:clock_timestamp] [:cast &quot;3 minutes&quot; :interval]]}}) [&quot;UPDATE task SET scheduled_at = CLOCK_TIMESTAMP() + CAST(? AS interval)&quot; &quot;3 minutes&quot;]"><y>#</y><d>2022-02-22</d><h>02:07</h><w>seancorfield</w>If that syntax works for you, it would be:
<pre>dev=&gt; (sql/format {:update :task :set {:scheduled_at [:+ [:clock_timestamp] [:cast &quot;3 minutes&quot; :interval]]}})
[&quot;UPDATE task SET scheduled_at = CLOCK_TIMESTAMP() + CAST(? AS interval)&quot; &quot;3 minutes&quot;]</pre></z><z id="t1645506010" t="seancorfield"><y>#</y><d>2022-02-22</d><h>05:00</h><w>seancorfield</w></z><z id="t1645513655" t="dharrigan :thumbsup:"><y>#</y><d>2022-02-22</d><h>07:07</h><w>dharrigan</w><b>:thumbsup:</b></z><z id="t1645713970" t="rafaeldelboni Hey we are using postgresql&apos;s https://www.postgresql.org/docs/14/ddl-inherit.html and I would like to extend honey to add the keywork ONLY to make selects like SELECT * FROM ONLY table_name What is the best approach? This is what I did; (def format-selects-common #&apos;sql/format-selects-common) (defn- format-selects [k xs] (format-selects-common (sql/sql-kw k) &apos;from xs)) (sql/register-clause! :from-only format-selects :where) (sql/format {:select [:*], :from-only [[:table :t]]})"><y>#</y><d>2022-02-24</d><h>14:46</h><w>rafaeldelboni</w>Hey we are using postgresql&apos;s <a href="https://www.postgresql.org/docs/14/ddl-inherit.html" target="_blank">https://www.postgresql.org/docs/14/ddl-inherit.html</a> and I would like to extend honey to add the keywork <code>ONLY</code> to make selects like <code>SELECT * FROM ONLY table_name</code>
What is the best approach? This is what I did;
<pre>(def format-selects-common #&apos;sql/format-selects-common)

(defn- format-selects [k xs]
  (format-selects-common
   (sql/sql-kw k)
   &apos;from
   xs))

(sql/register-clause! :from-only format-selects :where)

(sql/format {:select [:*], :from-only [[:table :t]]})</pre></z><z id="t1645715223" t="seancorfield [:attrs {:href &quot;/_/_/users/UMMMKKADU&quot;}] Happy to add core support for that -- can you a) create an issue on GitHub with this example and b) include a link to the relevant PostgreSQL docs so I can read more about the syntax (and any subtleties of it). Thanks"><y>#</y><d>2022-02-24</d><h>15:07</h><w>seancorfield</w><a>@rafaeldelboni</a> Happy to add core support for that -- can you a) create an issue on GitHub with this example and b) include a link to the relevant PostgreSQL docs so I can read more about the syntax (and any subtleties of it). Thanks</z><z id="t1645715861" t="rafaeldelboni Sure thing!"><y>#</y><d>2022-02-24</d><h>15:17</h><r>rafaeldelboni</r>Sure thing!</z><z id="t1645717109" t="seancorfield Just got the GH email -- thank you!"><y>#</y><d>2022-02-24</d><h>15:38</h><r>seancorfield</r>Just got the GH email -- thank you!</z><z id="t1646226754" t="crankyadmin Hi, I’m working on a project and have a bit of difficulty getting the desired output, here’s what I have: (h/where :and [:&gt;= :total_units 1] [:raw &quot;week_beginning &gt;= date &apos;2019-01-01&apos;&quot;] (when skus [:in :sku skus]) ;; Good (when brands [:in :brand brands]) ;; Good (when cat-ids [:regex_like :cat cat-ids]) ;; Bad ) regexp_like(cat-ids, &apos;^Thing\|Foo\\|Bar&apos;) &lt;--- this is what I’m trying to replicate in Honey. I suspect I need to extend Honey but I’m failing all over the place, could anyone provide any pointers?"><y>#</y><d>2022-03-02</d><h>13:12</h><w>crankyadmin</w>Hi, I’m working on a project and have a bit of difficulty getting the desired output, here’s what I have:
<pre>(h/where :and
            [:&gt;= :total_units 1]
            [:raw &quot;week_beginning &gt;= date &apos;2019-01-01&apos;&quot;]
            (when skus [:in :sku skus]) ;; Good
            (when brands [:in :brand brands]) ;; Good
            (when cat-ids [:regex_like :cat cat-ids]) ;; Bad
            )</pre>
<code>regexp_like(cat-ids, &apos;^Thing\|Foo\\|Bar&apos;)</code>  &lt;--- this is what I’m trying to replicate in Honey. I suspect I need to extend Honey but I’m failing all over the place, could anyone provide any pointers?</z><z id="t1646226799" t="crankyadmin skus, brands and cat-ids are all lists."><y>#</y><d>2022-03-02</d><h>13:13</h><w>crankyadmin</w>skus, brands and cat-ids are all lists.</z><z id="t1646230625" t="crankyadmin I ended up just using :raw and built the string up."><y>#</y><d>2022-03-02</d><h>14:17</h><w>crankyadmin</w>I ended up just using <code>:raw</code> and built the string up.</z><z id="t1646236970" t="seancorfield [:attrs {:href &quot;/_/_/users/U0AN7M0HG&quot;}] cat-ids is a list of strings? You&apos;d need str/join to turn it into the single string argument that regexp_like expects."><y>#</y><d>2022-03-02</d><h>16:02</h><w>seancorfield</w><a>@crankyadmin</a> <code>cat-ids</code> is a list of strings? You&apos;d need <code>str/join</code> to turn it into the single string argument that <code>regexp_like</code> expects.</z><z id="t1646837295" t="Adrian Smith I’m using honeysql 0.9.4 is there a way to generate this? INSERT INTO x &lt;sub query&gt; I’ve tried using :from but INSERT INTO x FROM &lt;sub query&gt; is invalid SQL"><y>#</y><d>2022-03-09</d><h>14:48</h><w>Adrian Smith</w>I’m using honeysql 0.9.4 is there a way to generate this?
<pre>INSERT INTO x 
&lt;sub query&gt;</pre>
I’ve tried using :from but <code>INSERT INTO x FROM &lt;sub query&gt;</code> is invalid SQL</z><z id="t1646837374" t="Adrian Smith The map at the moment looks something like {:insert-into x :from sub-query}"><y>#</y><d>2022-03-09</d><h>14:49</h><w>Adrian Smith</w>The map at the moment looks something like
<pre>{:insert-into x
 :from sub-query}</pre></z><z id="t1646837491" t="Adrian Smith Ah I think I see it here: https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#insert-into"><y>#</y><d>2022-03-09</d><h>14:51</h><w>Adrian Smith</w>Ah I think I see it here: <a href="https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#insert-into" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/clause-reference.md#insert-into</a></z><z id="t1646844603" t="seancorfield Those are the docs for HoneySQL 2.x -- not sure how much of it will work on earlier versions."><y>#</y><d>2022-03-09</d><h>16:50</h><r>seancorfield</r>Those are the docs for HoneySQL 2.x -- not sure how much of it will work on earlier versions.</z><z id="t1646840068" t="AJ Jaro Are there utilities for JSONB field selectors like this? select response-&gt;&gt;&apos;step&apos; from table_with_json_field; "><y>#</y><d>2022-03-09</d><h>15:34</h><w>AJ Jaro</w>Are there utilities for JSONB field selectors like this?

<pre>select response-&gt;&gt;&apos;step&apos; from table_with_json_field; </pre></z><z id="t1646906976" t="thumbnail Not by default; but you can register your own ops with sql/register-op!"><y>#</y><d>2022-03-10</d><h>10:09</h><r>thumbnail</r>Not by default; but you can register your own ops with <code>sql/register-op!</code></z><z id="t1646907000" t="thumbnail we use (sql/register-op! (keyword &quot;&lt;@&quot;)) for example"><y>#</y><d>2022-03-10</d><h>10:10</h><r>thumbnail</r>we use <code>(sql/register-op! (keyword &quot;&lt;@&quot;))</code> for example</z><z id="t1646907542" t="flowthing This surprised me: (honey.sql/format {:select #{:foo :bar} :from :baz}) ;;=&gt; [&quot;SELECT ? FROM baz&quot; #{:bar :foo}] (honey.sql/format {:select [:foo :bar] :from :baz}) ;;=&gt; [&quot;SELECT foo, bar FROM baz&quot;] Is this intentional?"><y>#</y><d>2022-03-10</d><h>10:19</h><w>flowthing</w>This surprised me:

<pre>(honey.sql/format {:select #{:foo :bar} :from :baz})
;;=&gt; [&quot;SELECT ? FROM baz&quot; #{:bar :foo}]
(honey.sql/format {:select [:foo :bar] :from :baz})
;;=&gt; [&quot;SELECT foo, bar FROM baz&quot;]</pre>
Is this intentional?</z><z id="t1646936185" t="seancorfield Sequential forms are part of the DSL. Other data structures are treated as your data."><y>#</y><d>2022-03-10</d><h>18:16</h><w>seancorfield</w>Sequential forms are part of the DSL. Other data structures are treated as your data.</z><z id="t1646936223" t="seancorfield (I&apos;m on vacation for a couple of weeks so responses will be rare)"><y>#</y><d>2022-03-10</d><h>18:17</h><w>seancorfield</w>(I&apos;m on vacation for a couple of weeks so responses will be rare)</z><z id="t1646937501" t="flowthing OK, makes sense, thanks! (And have a relaxing vacation!)"><y>#</y><d>2022-03-10</d><h>18:38</h><w>flowthing</w>OK, makes sense, thanks! (And have a relaxing vacation!)</z><z id="t1647640298" t="dharrigan Hi! I think there may be a slight typo, here: , namely the example of (returning [:did :dname]) . I believe in the documentation , it&apos;s (returning &amp; cols) , so should it be (returning :did :dname) ?"><y>#</y><d>2022-03-18</d><h>21:51</h><w>dharrigan</w>Hi! I think there may be a slight typo, here: <code></code>, namely the example of <code>(returning [:did :dname])</code>. I believe in the documentation <code></code>, it&apos;s <code>(returning &amp; cols)</code>, so should it be <code>(returning :did :dname)</code>?</z><z id="t1647640321" t="dharrigan (at least, the later works for me, not the former 🙂 )"><y>#</y><d>2022-03-18</d><h>21:52</h><w>dharrigan</w>(at least, the later works for me, not the former <b>🙂</b> )</z><z id="t1647641383" t="seancorfield Create a Github issue about it so I don&apos;t forget"><y>#</y><d>2022-03-18</d><h>22:09</h><w>seancorfield</w>Create a Github issue about it so I don&apos;t forget</z><z id="t1647680869" t="dharrigan no worries"><y>#</y><d>2022-03-19</d><h>09:07</h><w>dharrigan</w>no worries</z><z id="t1647765252" t="aratare Hi there. I have a question regarding keyword-&gt;column conversion in honeysql. I have a Tab table that has a column called is_protected? . Naturally, when using honeysql Clojure&apos;s keywords are converted into snake case upon formatting, but in this case that won&apos;t work because is_protected? needs to be quoted properly (i.e. &quot;is_protected?&quot; ) otherwise the database will get upset. I&apos;ve tried :quoted true but that will ignore conversion all together, which is not what I want. Is there any nice way to be able to quote after conversion has been done? Thanks in advance."><y>#</y><d>2022-03-20</d><h>08:34</h><w>aratare</w>Hi there. I have a question regarding keyword-&gt;column conversion in honeysql. I have a <code>Tab</code> table that has a column called <code>is_protected?</code>. Naturally, when using honeysql Clojure&apos;s keywords are converted into snake case upon formatting, but in this case that won&apos;t work because <code>is_protected?</code> needs to be quoted properly (i.e. <code>&quot;is_protected?&quot;</code>) otherwise the database will get upset. I&apos;ve tried <code>:quoted true</code> but that will ignore conversion all together, which is not what I want. Is there any nice way to be able to quote after conversion has been done? Thanks in advance.</z><z id="t1647770847" t="dharrigan Not sure, but you could use raw for the time being?"><y>#</y><d>2022-03-20</d><h>10:07</h><w>dharrigan</w>Not sure, but you could use <code>raw</code> for the time being?</z><z id="t1647770850" t="dharrigan user=&gt; (-&gt; (select :foo) (from :bar) (where [[:raw &quot;is_protected? = true&quot;]]) sql/format) [&quot;SELECT foo FROM bar WHERE (is_protected? = true)&quot;]"><y>#</y><d>2022-03-20</d><h>10:07</h><w>dharrigan</w><pre>user=&gt; (-&gt; (select :foo) (from :bar) (where [[:raw &quot;is_protected? = true&quot;]]) sql/format)
[&quot;SELECT foo FROM bar WHERE (is_protected? = true)&quot;]</pre></z><z id="t1647770854" t="dharrigan would that help?"><y>#</y><d>2022-03-20</d><h>10:07</h><w>dharrigan</w>would that help?</z><z id="t1647770878" t="dharrigan sorry, this:"><y>#</y><d>2022-03-20</d><h>10:07</h><w>dharrigan</w>sorry, this:</z><z id="t1647770880" t="dharrigan user=&gt; (-&gt; (select :foo) (from :bar) (where [[:raw &quot;&apos;is_protected?&apos; = true&quot;]]) sql/format) [&quot;SELECT foo FROM bar WHERE (&apos;is_protected?&apos; = true)&quot;]"><y>#</y><d>2022-03-20</d><h>10:08</h><w>dharrigan</w><pre>user=&gt; (-&gt; (select :foo) (from :bar) (where [[:raw &quot;&apos;is_protected?&apos; = true&quot;]]) sql/format)
[&quot;SELECT foo FROM bar WHERE (&apos;is_protected?&apos; = true)&quot;]</pre></z><z id="t1647770885" t="dharrigan forgot about quoting."><y>#</y><d>2022-03-20</d><h>10:08</h><w>dharrigan</w>forgot about quoting.</z><z id="t1647771372" t="aratare [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] Ah I see. Would that also work with insertion?"><y>#</y><d>2022-03-20</d><h>10:16</h><w>aratare</w><a>@dharrigan</a> Ah I see. Would that also work with insertion?</z><z id="t1647771407" t="aratare I&apos;ve decided to just change the column name in my PostgreSQL db for the time being"><y>#</y><d>2022-03-20</d><h>10:16</h><w>aratare</w>I&apos;ve decided to just change the column name in my PostgreSQL db for the time being</z><z id="t1647771434" t="dharrigan yes, also for insertion."><y>#</y><d>2022-03-20</d><h>10:17</h><w>dharrigan</w>yes, also for insertion.</z><z id="t1647771454" t="dharrigan (that&apos;s a better approach, having ? in column names is a bit weird)"><y>#</y><d>2022-03-20</d><h>10:17</h><w>dharrigan</w>(that&apos;s a better approach, having <code>?</code> in column names is a bit weird)</z><z id="t1647771493" t="aratare Yeah it&apos;s not a common way to name your column, I just decided to make it for seamless transition between the db and Clojure land"><y>#</y><d>2022-03-20</d><h>10:18</h><w>aratare</w>Yeah it&apos;s not a common way to name your column, I just decided to make it for seamless transition between the db and Clojure land</z><z id="t1647771500" t="dharrigan 🙂"><y>#</y><d>2022-03-20</d><h>10:18</h><w>dharrigan</w><b>🙂</b></z><z id="t1647771565" t="dharrigan Maybe, I don&apos;t know, but maybe, Sean might consider something - a switch perhaps? that if the user so-chooses to enable, that on the column translation on the way in/out, if the data type is boolean to convert the clojure to/from ?"><y>#</y><d>2022-03-20</d><h>10:19</h><w>dharrigan</w>Maybe, I don&apos;t know, but maybe, Sean might consider something - a switch perhaps? that if the user so-chooses to enable, that on the column translation on the way in/out, if the data type is boolean to convert the clojure to/from <code>?</code></z><z id="t1647771594" t="dharrigan i.e,. if a column name is enabled and type boolean , then on the data map on the way out, it might be :table_name/enabled? as the key."><y>#</y><d>2022-03-20</d><h>10:19</h><w>dharrigan</w>i.e,. if a column name is <code>enabled</code> and type <code>boolean</code>, then on the data map on the way out, it might be <code>:table_name/enabled?</code> as the key.</z><z id="t1647771636" t="dharrigan &lt;shrug&gt; perhaps asking and gauging his thoughts on that one 🙂"><y>#</y><d>2022-03-20</d><h>10:20</h><w>dharrigan</w>&lt;shrug&gt; perhaps asking and gauging his thoughts on that one <b>🙂</b></z><z id="t1647771728" t="aratare I think a more general approach would be to have some sort of conversion layer where you can provide a map of from/to keys?"><y>#</y><d>2022-03-20</d><h>10:22</h><w>aratare</w>I think a more general approach would be to have some sort of conversion layer where you can provide a map of from/to keys?</z><z id="t1647771781" t="aratare So if you feed it is-protected? it can be converted into is_protected and vice versa."><y>#</y><d>2022-03-20</d><h>10:23</h><w>aratare</w>So if you feed it <code>is-protected?</code> it can be converted into <code>is_protected</code> and vice versa.</z><z id="t1647771788" t="aratare May be there&apos;s already something like this which I haven&apos;t got to yet 😅"><y>#</y><d>2022-03-20</d><h>10:23</h><w>aratare</w>May be there&apos;s already something like this which I haven&apos;t got to yet <b>😅</b></z><z id="t1647771807" t="dharrigan I think you&apos;re looking at a more low level solution here, for example, I use next.jdbc which is the one that actually does the querying etc., of the db"><y>#</y><d>2022-03-20</d><h>10:23</h><w>dharrigan</w>I think you&apos;re looking at a more low level solution here, for example, I use next.jdbc which is the one that actually does the querying etc., of the db</z><z id="t1647771827" t="dharrigan in there, you can define your own protocols to decide on how column names etc. are handled."><y>#</y><d>2022-03-20</d><h>10:23</h><w>dharrigan</w>in there, you can define your own protocols to decide on how column names etc. are handled.</z><z id="t1647771870" t="aratare Ah I see"><y>#</y><d>2022-03-20</d><h>10:24</h><w>aratare</w>Ah I see</z><z id="t1647771873" t="dharrigan Reading around here might help"><y>#</y><d>2022-03-20</d><h>10:24</h><w>dharrigan</w>Reading around here <code></code> might help</z><z id="t1647771913" t="aratare 👍"><y>#</y><d>2022-03-20</d><h>10:25</h><w>aratare</w><b>👍</b></z><z id="t1647771941" t="aratare my brain is a bit fried at the moment but I&apos;ll have a look"><y>#</y><d>2022-03-20</d><h>10:25</h><w>aratare</w>my brain is a bit fried at the moment but I&apos;ll have a look</z><z id="t1647771947" t="dharrigan np 🙂"><y>#</y><d>2022-03-20</d><h>10:25</h><w>dharrigan</w>np <b>🙂</b></z><z id="t1647771947" t="aratare Thanks a lot for the help 🙂"><y>#</y><d>2022-03-20</d><h>10:25</h><w>aratare</w>Thanks a lot for the help <b>🙂</b></z><z id="t1647771951" t="dharrigan you&apos;re most welcome."><y>#</y><d>2022-03-20</d><h>10:25</h><w>dharrigan</w>you&apos;re most welcome.</z><z id="t1647902883" t="Nick Stares Hello, I&apos;m trying to generate the following (postgres)SQL with honeysql: CREATE TEMPORARY TABLE temp_table AS TABLE display_impressions_reach_by_line_test WITH NO DATA; I&apos;ve been playing around with argument orderings to create-table-as but no luck (-&gt; {:create-table-as [:temporary :table :temp_table :display_impressions_reach_by_line_test]} sql/format) ;; =&gt; [&quot;CREATE TEMPORARY TABLE TEMP_TABLE TABLE display_impressions_reach_by_line_test AS&quot;] I can&apos;t figure out how I&apos;m supposed to order the symbols in the argument vector"><y>#</y><d>2022-03-21</d><h>22:48</h><w>Nick Stares</w>Hello, I&apos;m trying to generate the following (postgres)SQL with honeysql:
<pre>CREATE TEMPORARY TABLE temp_table AS
            TABLE display_impressions_reach_by_line_test
            WITH NO DATA;</pre>
I&apos;ve been playing around with argument orderings to <code>create-table-as</code> but no luck
<pre>(-&gt; {:create-table-as [:temporary :table :temp_table :display_impressions_reach_by_line_test]}
    sql/format)
;; =&gt; [&quot;CREATE TEMPORARY TABLE TEMP_TABLE TABLE display_impressions_reach_by_line_test AS&quot;]</pre>
I can&apos;t figure out how I&apos;m supposed to order the symbols in the argument vector</z><z id="t1648226544" t="seancorfield Can you open a Github issue with details so I can take a look at the exact syntax and what needs to be done? I&apos;m not sure right now whether what you&apos;re asking for can be done directly in HoneySQL or whether some enhancements are required. Thanks, [:attrs {:href &quot;/_/_/users/U8STBJZU0&quot;}]"><y>#</y><d>2022-03-25</d><h>16:42</h><r>seancorfield</r>Can you open a Github issue with details so I can take a look at the exact syntax and what needs to be done? I&apos;m not sure right now whether what you&apos;re asking for can be done directly in HoneySQL or whether some enhancements are required. Thanks, <a>@U8STBJZU0</a></z><z id="t1648328568" t="dharrigan Should I add this as a ticket? It hasn&apos;t been added yet, so happy to just do that 🙂"><y>#</y><d>2022-03-26</d><h>21:02</h><r>dharrigan</r>Should I add this as a ticket? It hasn&apos;t been added yet, so happy to just do that <b>🙂</b></z><z id="t1648330177" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] Thanks! Yes, please. Thanks for the returning doc ticket, BTW."><y>#</y><d>2022-03-26</d><h>21:29</h><r>seancorfield</r><a>@U11EL3P9U</a> Thanks! Yes, please. Thanks for the <code>returning</code> doc ticket, BTW.</z><z id="t1648330309" t="dharrigan you&apos;re most welcome. I&apos;ll just copy pasta above into a ticket."><y>#</y><d>2022-03-26</d><h>21:31</h><r>dharrigan</r>you&apos;re most welcome. I&apos;ll just copy pasta above into a ticket.</z><z id="t1648334505" t="seancorfield It took me a while to figure out what that SQL syntax was meant to be -- and then I discovered that PostgreSQL has a TABLE command that is equivalent to SELECT * FROM and then it made more sense: dev=&gt; (println (sql/format {:create-table-as [:temporary :temp_table] :select :* :from :display_impressions_reach_by_line_test :with-data false} {:pretty true})) [ CREATE TEMPORARY TABLE temp_table AS SELECT * FROM display_impressions_reach_by_line_test WITH NO DATA ]"><y>#</y><d>2022-03-26</d><h>22:41</h><r>seancorfield</r>It took me a while to figure out what that SQL syntax was meant to be -- and then I discovered that PostgreSQL has a <code>TABLE</code> command that is equivalent to <code>SELECT * FROM</code> and then it made more sense:
<pre>dev=&gt; (println (sql/format {:create-table-as [:temporary :temp_table] :select :* :from :display_impressions_reach_by_line_test :with-data false} {:pretty true}))
[
CREATE TEMPORARY TABLE temp_table AS
SELECT *
FROM display_impressions_reach_by_line_test
WITH NO DATA
]</pre></z><z id="t1648334563" t="seancorfield HoneySQL doesn&apos;t support a :table clause right now so that select/from is the best you can do."><y>#</y><d>2022-03-26</d><h>22:42</h><r>seancorfield</r>HoneySQL doesn&apos;t support a <code>:table</code> clause right now so that select/from is the best you can do.</z><z id="t1648480595" t="seancorfield I&apos;ve added :table as a clause (on develop) for the next release - see that issue."><y>#</y><d>2022-03-28</d><h>15:16</h><r>seancorfield</r>I&apos;ve added <code>:table</code> as a clause (on develop) for the next release - see that issue.</z><z id="t1648480766" t="seancorfield https://github.com/seancorfield/honeysql/issues/400"><y>#</y><d>2022-03-28</d><h>15:19</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/400" target="_blank">https://github.com/seancorfield/honeysql/issues/400</a></z><z id="t1648480965" t="dharrigan 👍"><y>#</y><d>2022-03-28</d><h>15:22</h><r>dharrigan</r><b>👍</b></z><z id="t1648015147" t="orestis So this week I&apos;m playing around post-processing a honeysql query (removing terms from select, specifically). So far I rely on some invariants that are only true in our codebase: clauses and columns are always keywords and lowercase, so you can just use an equality check. But I realized two things: 1. Clauses can also be symbols (eg :select and &apos;select) 2. Same with column names 3. Column names can also be mixed case and depending on the quoting strategy may normalize to the same column name. 4. Perhaps I&apos;m also missing something else altogether :) So I want to ask, is there any thought for some protocol that given a honey sql map, can ask questions and do manipulations?"><y>#</y><d>2022-03-23</d><h>05:59</h><w>orestis</w>So this week I&apos;m playing around post-processing a honeysql query (removing terms from select, specifically). So far I rely on some invariants that are only true in our codebase: clauses and columns are always keywords and lowercase, so you can just use an equality check. But I realized two things: 
1. Clauses can also be symbols (eg :select and &apos;select) 
2. Same with column names 
3. Column names can also be mixed case and depending on the quoting strategy may normalize to the same column name. 
4. Perhaps I&apos;m also missing something else altogether :)
So I want to ask, is there any thought for some protocol that given a honey sql map, can ask questions and do manipulations?</z><z id="t1648061323" t="seancorfield Nope. It is &quot;just&quot; Clojure data."><y>#</y><d>2022-03-23</d><h>18:48</h><w>seancorfield</w>Nope. It is &quot;just&quot; Clojure data.</z><z id="t1648099327" t="orestis Ok. I just discovered simple-ident? which should at least cover the symbol/keyword split. And looking at the code it seems that clauses must be lowercase."><y>#</y><d>2022-03-24</d><h>05:22</h><w>orestis</w>Ok. I just discovered simple-ident? which should at least cover the symbol/keyword split. And looking at the code it seems that clauses must be lowercase.</z><z id="t1648134759" t="pinkfrog How to use the -&gt; and -&gt;&gt; json operator? They will be converted to underscore, e.g., &amp;gt; and &gt;&gt; if I do not use the :raw syntax. e.g., (defn- sql:get-wallets-by-address [address] (-&gt; (s/select :*) (s/from :wallet) (s/where [:= [:raw &quot;(data-&gt;&gt;&apos;address&apos;)&quot;] address]) sql/format))"><y>#</y><d>2022-03-24</d><h>15:12</h><w>pinkfrog</w>How to use the -&gt; and -&gt;&gt; json operator? They will be converted to underscore, e.g., &amp;gt; and &gt;&gt; if I do not use the :raw syntax. e.g.,
<pre>(defn- sql:get-wallets-by-address
  [address]
  (-&gt; (s/select :*)
      (s/from :wallet)
      (s/where [:= [:raw &quot;(data-&gt;&gt;&apos;address&apos;)&quot;] address])
      sql/format))</pre></z><z id="t1648139665" t="dharrigan you can use {:quoted true} so that the _ is not coverted"><y>#</y><d>2022-03-24</d><h>16:34</h><w>dharrigan</w>you can use {:quoted true} so that the _ is not coverted</z><z id="t1648215729" t="pinkfrog {:quoted} is a good option but it is on the sql/format level so it will affect all identifiers."><y>#</y><d>2022-03-25</d><h>13:42</h><w>pinkfrog</w>{:quoted} is a good option but it is on the sql/format level so it will affect all identifiers.</z><z id="t1648218967" t="seancorfield Why not declare the JSON operators to Honeysql and then just use them as &quot;functions&quot;? Maybe I should add them all by default..."><y>#</y><d>2022-03-25</d><h>14:36</h><w>seancorfield</w>Why not declare the JSON operators to Honeysql and then just use them as &quot;functions&quot;? Maybe I should add them all by default...</z><z id="t1648225626" t="Pradeep B I am trying to perform some join using HoneySQL and when putting some condition and merging sql-query map it is failing due to dependency on the other table in query. Is there a way to force the order of the joins in the map? Details below in thread."><y>#</y><d>2022-03-25</d><h>16:27</h><w>Pradeep B</w>I am trying to perform some join using HoneySQL and when putting some condition and merging sql-query map it is failing due to dependency on the other table in query. Is there a way to force the order of the joins in the map? Details below in thread.</z><z id="t1648225646" t="Pradeep B (defn join-account-id [base-query account-id] (if account-id (merge base-query {:join [[:account :a] [:and [:= :pl.location_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;location_id&apos;&quot;] :bigint]] [:= :pg.group_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;group_id&apos;&quot;] :bigint]]]]}) base-query)) (defn raw-query-gen [i-key db-function-to-use] (sql/format {:raw (str db-function-to-use &quot;(&apos;&quot; i-key &quot;&apos;, now() - interval &apos;24 hours&apos;)&quot;)})) (defn fetch-roster-query [i-key account-id db-function-to-use] (-&gt; {:select [:p.*] :from [[:person :p]] :where [:= :p.instance i-key] :left-join [[:person_location :pl] [:= :p.location_id :pl.location_id] [:person_department :pd] [:= :p.department_id :pd.department_id] [:person_group :pg] [:= :p.group_id :pg.group_id] [[:raw (raw-query-gen i-key db-function-to-use)] :person_result] [:= :p.person_id :person_result.person_id] [:result :r] [:and [:= :person_result.result_id :r.result_id] [:= :r.is_excluded [:raw &quot;&apos;FALSE&apos;&quot;]]]] :group-by [:p.person_id :pl.name :pd.name :pg.name]} (join-account-id account-id) (sql/format :quoting :ansi))) (defn fetch-roster [i-key account-id db-function-to-use] (jdbc/execute-one! @db/data-source (fetch-roster-query i-key account-id db-function-to-use) {:builder-fn result-set/as-unqualified-maps :return-keys true})) (comment (fetch-roster &quot;TEST&quot; true &quot;results_for_instance_v2&quot;) ;; =&gt; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2510). ;; ERROR: missing FROM-clause entry for table &quot;pl&quot; ;; Position: 57 (fetch-roster &quot;TEST&quot; false &quot;results_for_instance_v2&quot;) ;; =&gt; {:identity {:first-name &quot;first1&quot;, :last-name &quot;last1&quot;, :employee-id 1}, :instance &quot;TEST&quot;, :location_id 1, :person_id 1, :group_id 1, :custom_data {:surname &quot;Wow&quot;, :test &quot;Name&quot;}, :last_daily_screening_reminder nil, :old_id nil, :department_id 1, :created_at #time/instant &quot;2022-02-16T14:40:25.314411Z&quot;} (fetch-roster-query &quot;TEST&quot; true &quot;results_for_instance_v2&quot;) ;; =&gt; [&quot;SELECT p.* FROM person AS p INNER JOIN account AS a ON (pl.location_id = CAST(a.con-&gt;&gt;&apos;location_id&apos; AS bigint)) AND (pg.group_id = CAST(a.con-&gt;&gt;&apos;group_id&apos; AS bigint)) LEFT JOIN person_location AS pl ON p.location_id = pl.location_id LEFT JOIN person_department AS pd ON p.department_id = pd.department_id LEFT JOIN person_group AS pg ON p.group_id = pg.group_id LEFT JOIN results_for_instance_v2(&apos;TEST&apos;, now() - interval &apos;24 hours&apos;) AS person_result ON p.person_id = person_result.person_id LEFT JOIN result AS r ON (person_result.result_id = r.result_id) AND (r.is_excluded = &apos;FALSE&apos;) WHERE p.instance = ? GROUP BY p.person_id, pl.name, pd.name, pg.name&quot; &quot;TEST&quot;] )"><y>#</y><d>2022-03-25</d><h>16:27</h><r>Pradeep B</r><pre>(defn join-account-id [base-query account-id]
  (if account-id
    (merge base-query
           {:join [[:account :a] [:and
                                  [:= :pl.location_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;location_id&apos;&quot;] :bigint]]
                                  [:= :pg.group_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;group_id&apos;&quot;] :bigint]]]]})
    base-query))

(defn raw-query-gen [i-key db-function-to-use]
  (sql/format {:raw (str db-function-to-use &quot;(&apos;&quot; i-key &quot;&apos;, now() - interval &apos;24 hours&apos;)&quot;)}))

(defn fetch-roster-query [i-key account-id db-function-to-use]
  (-&gt; {:select [:p.*]
       :from [[:person :p]]
       :where [:= :p.instance i-key]
       :left-join [[:person_location :pl] [:= :p.location_id :pl.location_id]
                   [:person_department :pd] [:= :p.department_id :pd.department_id]
                   [:person_group :pg] [:= :p.group_id :pg.group_id]
                   [[:raw (raw-query-gen i-key db-function-to-use)]  :person_result]
                   [:= :p.person_id :person_result.person_id]
                   [:result :r] [:and [:= :person_result.result_id :r.result_id]
                                 [:= :r.is_excluded [:raw &quot;&apos;FALSE&apos;&quot;]]]]
       :group-by [:p.person_id :pl.name :pd.name :pg.name]}
      (join-account-id account-id)
      (sql/format :quoting :ansi)))

(defn fetch-roster [i-key account-id db-function-to-use]
  (jdbc/execute-one! @db/data-source
                     (fetch-roster-query i-key account-id db-function-to-use)
                     {:builder-fn result-set/as-unqualified-maps
                      :return-keys true}))

(comment

 (fetch-roster &quot;TEST&quot; true &quot;results_for_instance_v2&quot;)
  ;; =&gt; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2510).
  ;;    ERROR: missing FROM-clause entry for table &quot;pl&quot;
  ;;      Position: 57


  (fetch-roster &quot;TEST&quot; false &quot;results_for_instance_v2&quot;)
  ;; =&gt; {:identity {:first-name &quot;first1&quot;, :last-name &quot;last1&quot;, :employee-id 1}, :instance &quot;TEST&quot;, :location_id 1, :person_id 1, :group_id 1, :custom_data {:surname &quot;Wow&quot;, :test &quot;Name&quot;}, :last_daily_screening_reminder nil, :old_id nil, :department_id 1, :created_at #time/instant &quot;2022-02-16T14:40:25.314411Z&quot;}



 (fetch-roster-query &quot;TEST&quot; true &quot;results_for_instance_v2&quot;)
 ;; =&gt; [&quot;SELECT p.* FROM person AS p INNER JOIN account AS a ON (pl.location_id = CAST(a.con-&gt;&gt;&apos;location_id&apos; AS bigint)) AND (pg.group_id = CAST(a.con-&gt;&gt;&apos;group_id&apos; AS bigint)) LEFT JOIN person_location AS pl ON p.location_id = pl.location_id LEFT JOIN person_department AS pd ON p.department_id = pd.department_id LEFT JOIN person_group AS pg ON p.group_id = pg.group_id LEFT JOIN results_for_instance_v2(&apos;TEST&apos;, now() - interval &apos;24 hours&apos;) AS person_result ON p.person_id = person_result.person_id LEFT JOIN result AS r ON (person_result.result_id = r.result_id) AND (r.is_excluded = &apos;FALSE&apos;) WHERE p.instance = ? GROUP BY p.person_id, pl.name, pd.name, pg.name&quot; &quot;TEST&quot;]

)</pre></z><z id="t1648225734" t="Pradeep B whenever i execute the query with account_id = true, it fails with below error ;; =&gt; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2510). ;; ERROR: missing FROM-clause entry for table &quot;pl&quot; ;; Position: 57 and with account_id = false it works fine (when the other query is not joined). Please suggest how to move forward - can share additional details if not clear."><y>#</y><d>2022-03-25</d><h>16:28</h><r>Pradeep B</r>whenever i execute the query with account_id = true, it fails with below error
<pre>;; =&gt; Execution error (PSQLException) at org.postgresql.core.v3.QueryExecutorImpl/receiveErrorResponse (QueryExecutorImpl.java:2510).
  ;;    ERROR: missing FROM-clause entry for table &quot;pl&quot;
  ;;      Position: 57</pre>
and with account_id = false it works fine (when the other query is not joined).

Please suggest how to move forward - can share additional details if not clear.</z><z id="t1648226394" t="seancorfield See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.868/doc/getting-started/sql-clause-reference#join-by"><y>#</y><d>2022-03-25</d><h>16:39</h><r>seancorfield</r>See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.868/doc/getting-started/sql-clause-reference#join-by" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.868/doc/getting-started/sql-clause-reference#join-by</a></z><z id="t1648226438" t="seancorfield (as always, I highly recommend reading the docs from cover-to-cover -- nearly every question asked about HoneySQL these days is answered in the docs)"><y>#</y><d>2022-03-25</d><h>16:40</h><r>seancorfield</r>(as always, I highly recommend reading the docs from cover-to-cover -- nearly every question asked about HoneySQL these days is answered in the docs)</z><z id="t1648226660" t="Pradeep B sure, checking it again."><y>#</y><d>2022-03-25</d><h>16:44</h><r>Pradeep B</r>sure, checking it again.</z><z id="t1648227438" t="Pradeep B thank you [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] i did missed reading those. Have to make some more changes for it to work on my query."><y>#</y><d>2022-03-25</d><h>16:57</h><r>Pradeep B</r>thank you <a>@U04V70XH6</a> i did missed reading those. Have to make some more changes for it to work on my query.</z><z id="t1648227553" t="Pradeep B (defn join-account-id [base-query account-id] (if account-id (update-in base-query [:join-by] conj [:join [[:account :a] [:and [:= :pl.location_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;location_id&apos;&quot;] :bigint]] [:= :pg.group_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;group_id&apos;&quot;] :bigint]]]]]) base-query)) (defn raw-query-gen [i-key db-function-to-use] (sql/format {:raw (str db-function-to-use &quot;(&apos;&quot; i-key &quot;&apos;, now() - interval &apos;24 hours&apos;)&quot;)})) (defn fetch-roster-query [i-key account-id db-function-to-use] (-&gt; {:select [:p.*] :from [[:person :p]] :where [:= :p.instance i-key] :join-by [:left [[:person_location :pl] [:= :p.location_id :pl.location_id] [:person_department :pd] [:= :p.department_id :pd.department_id] [:person_group :pg] [:= :p.group_id :pg.group_id] [[:raw (raw-query-gen i-key db-function-to-use)] :person_result] [:= :p.person_id :person_result.person_id] [:result :r] [:and [:= :person_result.result_id :r.result_id] [:= :r.is_excluded [:raw &quot;&apos;FALSE&apos;&quot;]]]]] :group-by [:p.person_id :pl.name :pd.name :pg.name]} (join-account-id account-id) (sql/format :quoting :ansi))) used update-in and join-by"><y>#</y><d>2022-03-25</d><h>16:59</h><r>Pradeep B</r><pre>(defn join-account-id [base-query account-id]
  (if account-id
    (update-in base-query [:join-by] conj
           [:join [[:account :a] [:and
                                  [:= :pl.location_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;location_id&apos;&quot;] :bigint]]
                                  [:= :pg.group_id [:cast [:raw &quot;a.con-&gt;&gt;&apos;group_id&apos;&quot;] :bigint]]]]])
    base-query))

(defn raw-query-gen [i-key db-function-to-use]
  (sql/format {:raw (str db-function-to-use &quot;(&apos;&quot; i-key &quot;&apos;, now() - interval &apos;24 hours&apos;)&quot;)}))

(defn fetch-roster-query [i-key account-id db-function-to-use]
  (-&gt; {:select [:p.*]
       :from [[:person :p]]
       :where [:= :p.instance i-key]
       :join-by [:left [[:person_location :pl] [:= :p.location_id :pl.location_id]
                          [:person_department :pd] [:= :p.department_id :pd.department_id]
                          [:person_group :pg] [:= :p.group_id :pg.group_id]
                          [[:raw (raw-query-gen i-key db-function-to-use)]  :person_result]
                          [:= :p.person_id :person_result.person_id]
                          [:result :r] [:and [:= :person_result.result_id :r.result_id]
                                        [:= :r.is_excluded [:raw &quot;&apos;FALSE&apos;&quot;]]]]]
       :group-by [:p.person_id :pl.name :pd.name :pg.name]}
      (join-account-id account-id)
      (sql/format :quoting :ansi)))</pre>

used <code>update-in</code>  and <code>join-by</code></z><z id="t1648226355" t="seancorfield https://github.com/seancorfield/honeysql/issues/398 -- If PostgreSQL users could add links to relevant docs and/or examples of operators they use a lot, that would be helpful."><y>#</y><d>2022-03-25</d><h>16:39</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/398" target="_blank">https://github.com/seancorfield/honeysql/issues/398</a> -- If PostgreSQL users could add links to relevant docs and/or examples of operators they use a lot, that would be helpful.</z><z id="t1648257327" t="pinkfrog I added a link to the https://www.postgresqltutorial.com/postgresql-json/ in the issue"><y>#</y><d>2022-03-26</d><h>01:15</h><r>pinkfrog</r>I added a link to the <a href="https://www.postgresqltutorial.com/postgresql-json/" target="_blank">https://www.postgresqltutorial.com/postgresql-json/</a> in the issue</z><z id="t1648290554" t="orestis FWIW recent Postgres versions also have functions to substitute most of these operators. "><y>#</y><d>2022-03-26</d><h>10:29</h><r>orestis</r>FWIW recent Postgres versions also have functions to substitute most of these operators. </z><z id="t1648292885" t="pinkfrog [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] Do you know what’s the equivalent function of -&gt; ?"><y>#</y><d>2022-03-26</d><h>11:08</h><r>pinkfrog</r><a>@U7PBP4UVA</a> Do you know what’s the equivalent function of -&gt; ?</z><z id="t1648292946" t="orestis I would say jsonb_extract_path ?"><y>#</y><d>2022-03-26</d><h>11:09</h><r>orestis</r>I would say jsonb_extract_path ?</z><z id="t1648293037" t="orestis I&apos;ve used extensively the jsonpath support recently. "><y>#</y><d>2022-03-26</d><h>11:10</h><r>orestis</r>I&apos;ve used extensively the jsonpath support recently. </z><z id="t1648270727" t="seancorfield I&apos;m working on addressing https://github.com/seancorfield/honeysql/issues/398 by adding honey.sql.pg-json as a new namespace that, when required, will register the PostgreSQL JSON/JSONB operators and also provide symbolic names for the four &quot;unwritable&quot; operators that include @ (`@&gt;` - at&gt; , &lt;@ - &lt;at , @? - at? , and @@ - atat ). Question: would it be more intuitive for all JSON/JSONB operators to have a symbolic name (even for those that can be written as a literal Clojure keyword or symbol) and, if so, what should those names be? The same as the underlying op keyword perhaps (does that make sense for -&gt; , -&gt;&gt; , || , and - which are all part of clojure.core already)?"><y>#</y><d>2022-03-26</d><h>04:58</h><w>seancorfield</w>I&apos;m working on addressing <a href="https://github.com/seancorfield/honeysql/issues/398" target="_blank">https://github.com/seancorfield/honeysql/issues/398</a> by adding <code>honey.sql.pg-json</code> as a new namespace that, when required, will register the PostgreSQL JSON/JSONB operators and also provide symbolic names for the four &quot;unwritable&quot; operators that include <code>@</code> (`@&gt;` - <code>at&gt;</code>, <code>&lt;@</code> - <code>&lt;at</code>, <code>@?</code> - <code>at?</code>, and <code>@@</code> - <code>atat</code>).

Question: would it be more intuitive for all JSON/JSONB operators to have a symbolic name (even for those that can be written as a literal Clojure keyword or symbol) and, if so, what should those names be? The same as the underlying op keyword perhaps (does that make sense for <code>-&gt;</code>, <code>-&gt;&gt;</code>, <code>||</code>, and <code>-</code> which are all part of <code>clojure.core</code> already)?</z><z id="t1648270830" t="seancorfield As a reminder, those operators are: -&gt; , -&gt;&gt; , #&gt; , #&gt;&gt; , @&gt; , &lt;@ , ? , ?| , ?&amp; , || , - , #- , @? , and @@ ."><y>#</y><d>2022-03-26</d><h>05:00</h><w>seancorfield</w>As a reminder, those operators are: <code>-&gt;</code>, <code>-&gt;&gt;</code>, <code>#&gt;</code>, <code>#&gt;&gt;</code>, <code>@&gt;</code>, <code>&lt;@</code>, <code>?</code>, <code>?|</code>, <code>?&amp;</code>, <code>||</code>, <code>-</code>, <code>#-</code>, <code>@?</code>, and <code>@@</code>.</z><z id="t1648270881" t="seancorfield (note that || and - are already built-in operators for HoneySQL)"><y>#</y><d>2022-03-26</d><h>05:01</h><w>seancorfield</w>(note that <code>||</code> and <code>-</code> are already built-in operators for HoneySQL)</z><z id="t1648289732" t="dharrigan Personally, I think having symbolic names for only those operators that are unwriteable and then having things like pg_json/-&gt; for those that are writeable is fine. I know I would only use (or favour really) writing pg_json/-&gt; over a symbolic name each time. Having documentation to show just the cases were a symbolic name is necessary would cover having the mix of both."><y>#</y><d>2022-03-26</d><h>10:15</h><w>dharrigan</w>Personally, I think having symbolic names for only those operators that are unwriteable and then having things like <code>pg_json/-&gt;</code> for those that are writeable is fine. I know I would only use (or favour really) writing <code>pg_json/-&gt;</code> over a symbolic name each time. Having documentation to show just the cases were a symbolic name is necessary would cover having the mix of both.</z><z id="t1648298565" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] that would be a symbolic name - since I&apos;d have to define -&gt; in the pg-json namespace for that to work."><y>#</y><d>2022-03-26</d><h>12:42</h><w>seancorfield</w><a>@dharrigan</a> that would be a symbolic name - since I&apos;d have to define <code>-&gt;</code> in the pg-json namespace for that to work.</z><z id="t1648298602" t="seancorfield You&apos;d say :-&gt; directly if there was no symbolic name."><y>#</y><d>2022-03-26</d><h>12:43</h><w>seancorfield</w>You&apos;d say <code>:-&gt;</code> directly if there was no symbolic name.</z><z id="t1648298684" t="seancorfield The unwritable operators have to have symbolic names (since you can&apos;t write them directly)."><y>#</y><d>2022-03-26</d><h>12:44</h><w>seancorfield</w>The unwritable operators have to have symbolic names (since you can&apos;t write them directly).</z><z id="t1648316735" t="dharrigan Ah I see, well, I do see merit then in the symbolic name, on the other hand, learning to use :-&gt; is fine also"><y>#</y><d>2022-03-26</d><h>17:45</h><w>dharrigan</w>Ah I see, well, I do see merit then in the symbolic name, on the other hand, learning to use <code>:-&gt;</code> is fine also</z><z id="t1648321068" t="seancorfield Yeah, maybe it&apos;s just better to be consistent and provide vars for all of them, even though only the four at ops really need a name..."><y>#</y><d>2022-03-26</d><h>18:57</h><w>seancorfield</w>Yeah, maybe it&apos;s just better to be consistent and provide vars for all of them, even though only the four <code>at</code> ops really need a name...</z><z id="t1648330350" t="seancorfield #&gt; , #&gt;&gt; , and #- also need names -- they can be written just fine as keywords but not as symbols -- so hash instead of # 🙂"><y>#</y><d>2022-03-26</d><h>21:32</h><w>seancorfield</w><code>#&gt;</code>, <code>#&gt;&gt;</code>, and <code>#-</code> also need names -- they can be written just fine as keywords but not as symbols -- so <code>hash</code> instead of <code>#</code> <b>🙂</b></z><z id="t1648330546" t="dharrigan glad you&apos;re using hash, not pound 😄"><y>#</y><d>2022-03-26</d><h>21:35</h><w>dharrigan</w>glad you&apos;re using hash, not pound <b>😄</b></z><z id="t1648330576" t="seancorfield (and this makes me realize that these operators can&apos;t be used in the datalog-style DSL for HoneySQL, i.e., as quoted symbolic forms: &apos;(#&gt; a b) is not valid: dev=&gt; (sql/format &apos;{select ( ( (#&gt; a b) c ) )}) Syntax error reading source at (REPL:1:31). No reader function for tag &gt; ;; you can fallback to a keyword: dev=&gt; (sql/format &apos;{select ( ( (:#&gt; a b) c ) )}) [&quot;SELECT a #&gt; b AS c&quot;]"><y>#</y><d>2022-03-26</d><h>21:36</h><w>seancorfield</w>(and this makes me realize that these operators can&apos;t be used in the datalog-style DSL for HoneySQL, i.e., as quoted symbolic forms: <code>&apos;(#&gt; a b)</code> is not valid:
<pre>dev=&gt; (sql/format &apos;{select ( ( (#&gt; a b) c ) )})
Syntax error reading source at (REPL:1:31).
No reader function for tag &gt;
;; you can fallback to a keyword:
dev=&gt; (sql/format &apos;{select ( ( (:#&gt; a b) c ) )})
[&quot;SELECT a #&gt; b AS c&quot;]</pre></z><z id="t1648330629" t="dharrigan Ah yes, the reader symbol"><y>#</y><d>2022-03-26</d><h>21:37</h><w>dharrigan</w>Ah yes, the reader symbol</z><z id="t1648330788" t="seancorfield (you cannot do the same thing with @ since that is turned into a (deref ..) call by the Clojure reader -- so there are a lot of weird corner cases here)"><y>#</y><d>2022-03-26</d><h>21:39</h><w>seancorfield</w>(you cannot do the same thing with <code>@</code> since that is turned into a <code>(deref ..)</code> call by the Clojure reader -- so there are a lot of weird corner cases here)</z><z id="t1648330834" t="dharrigan btw, I was playing around with over yesterday and I have an example of how to use it when the select columns are dynamic (coming in from a search, i.e., only return such and such columns), does this look about right? If so, then perhaps an inclusion into the docs (as the examples only show how to use over when the columsn are known in advance):"><y>#</y><d>2022-03-26</d><h>21:40</h><w>dharrigan</w>btw, I was playing around with over yesterday and I have an example of how to use it when the select columns are dynamic (coming in from a search, i.e., only return such and such columns), does this look about right? If so, then perhaps an inclusion into the docs (as the examples only show how to use over when the columsn are known in advance):</z><z id="t1648330838" t="dharrigan (defn search [query-parameters] (let [{:keys [field1 field2 field3 fields sort-field sort-direction page limit] :or {page 0 limit 100 sort-field :field1 sort-direction :desc}} query-parameters] (-&gt; {:select (merge (mapv #(-&gt;kebab-case (keyword %)) (or fields [:*])) [[:over [[:count :*] {} :total-rows]]])} (from :service) (where (when field1 [:= :field1 field1]) (when field2 [:= :field2 field2]) (when field3 [:= :field3 field3])) (order-by [sort-field sort-direction]) (offset (* limit page)) (helpers/limit limit) sql/format)))"><y>#</y><d>2022-03-26</d><h>21:40</h><w>dharrigan</w><pre>(defn search
  [query-parameters]
  (let [{:keys [field1 field2 field3 fields sort-field sort-direction page limit] :or {page 0 limit 100 sort-field :field1 sort-direction :desc}} query-parameters]
    (-&gt; {:select (merge (mapv #(-&gt;kebab-case (keyword %)) (or fields [:*]))
                        [[:over [[:count :*] {} :total-rows]]])}
        (from :service)
        (where
         (when field1 [:= :field1 field1])
         (when field2 [:= :field2 field2])
         (when field3 [:= :field3 field3]))
        (order-by [sort-field sort-direction])
        (offset (* limit page))
        (helpers/limit limit)
        sql/format)))</pre></z><z id="t1648330854" t="dharrigan natch, -&gt;kebab-case is from csk."><y>#</y><d>2022-03-26</d><h>21:40</h><w>dharrigan</w>natch, <code>-&gt;kebab-case</code> is from csk.</z><z id="t1648330998" t="seancorfield I guess that merge is honey.sql.helpers/merge -- kind of weird to see merge on vectors 🙂"><y>#</y><d>2022-03-26</d><h>21:43</h><w>seancorfield</w>I guess that <code>merge</code> is <code>honey.sql.helpers/merge</code> -- kind of weird to see <code>merge</code> on vectors <b>🙂</b></z><z id="t1648331011" t="dharrigan it&apos;s the standard clojure merge"><y>#</y><d>2022-03-26</d><h>21:43</h><w>dharrigan</w>it&apos;s the standard clojure merge</z><z id="t1648331122" t="seancorfield That&apos;s... an odd usage then..."><y>#</y><d>2022-03-26</d><h>21:45</h><w>seancorfield</w>That&apos;s... an odd usage then...</z><z id="t1648331125" t="dharrigan I tried firstly to use the honeysql helpers, i.e, (select) , but that just caused it to do something like select field1 as field2 and so on, since the mapv returns a vector, i.e., [:field1 :field2 :field3]`. So had to try using the {} variant"><y>#</y><d>2022-03-26</d><h>21:45</h><w>dharrigan</w>I tried firstly to use the honeysql helpers, i.e, <code>(select)</code>, but that just caused it to do something like <code>select field1 as field2</code> and so on, since the <code>mapv</code>  returns a vector, i.e., [:field1 :field2 :field3]`. So had to try using the <code>{}</code> variant</z><z id="t1648331166" t="dharrigan Happy to understand if there is a better way if the fields are unknown coming in"><y>#</y><d>2022-03-26</d><h>21:46</h><w>dharrigan</w>Happy to understand if there is a better way if the fields are unknown coming in</z><z id="t1648331193" t="dharrigan (obs, it does work, as the sql it spits out is valid)"><y>#</y><d>2022-03-26</d><h>21:46</h><w>dharrigan</w>(obs, it does work, as the sql it spits out is valid)</z><z id="t1648331258" t="seancorfield This doesn&apos;t seem right: dev=&gt; (let [fields [:a :b :c] -&gt;kebab-case identity] #_=&gt; {:select (merge (mapv #(-&gt;kebab-case (keyword %)) (or fields [:*])) #_=&gt; [[:over [[:count :*] {} :total-rows]]])}) {:select [:a :b :c [[:over [[:count :*] {} :total-rows]]]]} "><y>#</y><d>2022-03-26</d><h>21:47</h><w>seancorfield</w>This doesn&apos;t seem right:
<pre>dev=&gt; (let [fields [:a :b :c] -&gt;kebab-case identity]
 #_=&gt;   {:select (merge (mapv #(-&gt;kebab-case (keyword %)) (or fields [:*]))
 #_=&gt;                         [[:over [[:count :*] {} :total-rows]]])})
{:select [:a :b :c [[:over [[:count :*] {} :total-rows]]]]}</pre>
</z><z id="t1648331285" t="seancorfield Maybe I&apos;m just misunderstanding what you&apos;re trying to do?"><y>#</y><d>2022-03-26</d><h>21:48</h><w>seancorfield</w>Maybe I&apos;m just misunderstanding what you&apos;re trying to do?</z><z id="t1648331324" t="seancorfield merge is meant for hash maps -- that it works on vectors is an accident of its implementation using conj"><y>#</y><d>2022-03-26</d><h>21:48</h><w>seancorfield</w><code>merge</code> is meant for hash maps -- that it works on vectors is an accident of its implementation using <code>conj</code></z><z id="t1648331338" t="dharrigan It&apos;s a way of returning the total number of rows in a table, whilst also only being interested in a subset of the rows in the actualy query"><y>#</y><d>2022-03-26</d><h>21:48</h><w>dharrigan</w>It&apos;s a way of returning the total number of rows in a table, whilst also only being interested in a subset of the rows in the actualy query</z><z id="t1648331359" t="seancorfield Forget the SQL -- I&apos;m talking about the Clojure data structure."><y>#</y><d>2022-03-26</d><h>21:49</h><w>seancorfield</w>Forget the SQL -- I&apos;m talking about the Clojure data structure.</z><z id="t1648331364" t="dharrigan oh sorry 😄"><y>#</y><d>2022-03-26</d><h>21:49</h><w>dharrigan</w>oh sorry <b>😄</b></z><z id="t1648331415" t="dharrigan It looks quite like the example in the docs"><y>#</y><d>2022-03-26</d><h>21:50</h><w>dharrigan</w>It looks quite like the example in the docs</z><z id="t1648331426" t="dharrigan (sql/format {:select [:id [[:over [[:avg :salary] {} :Average] [[:max :salary] nil :MaxSalary]]]] :from [:employee]})"><y>#</y><d>2022-03-26</d><h>21:50</h><w>dharrigan</w><pre>(sql/format {:select [:id
                             [[:over
                               [[:avg :salary]
                                {}
                                :Average]
                               [[:max :salary]
                                nil
                                :MaxSalary]]]]
                    :from [:employee]})</pre></z><z id="t1648331473" t="seancorfield Not relevant to variable column names though... dev=&gt; (let [fields [:a :b :c]] #_=&gt; (sql/format (apply select fields))) [&quot;SELECT a, b, c&quot;] dev=&gt; (let [fields [:a :b :c]] #_=&gt; (sql/format {:select fields})) [&quot;SELECT a, b, c&quot;]"><y>#</y><d>2022-03-26</d><h>21:51</h><w>seancorfield</w>Not relevant to variable column names though...
<pre>dev=&gt; (let [fields [:a :b :c]]
 #_=&gt;   (sql/format (apply select fields)))
[&quot;SELECT a, b, c&quot;]
dev=&gt; (let [fields [:a :b :c]]
 #_=&gt;   (sql/format {:select fields}))
[&quot;SELECT a, b, c&quot;]</pre></z><z id="t1648331586" t="seancorfield I&apos;m confused about what you&apos;re trying to do -- the DSL is &quot;just&quot; a data structure so you can construct it however you want with literals, honey.sql.helpers calls, Clojure functions to manipulate data..."><y>#</y><d>2022-03-26</d><h>21:53</h><w>seancorfield</w>I&apos;m confused about what you&apos;re trying to do -- the DSL is &quot;just&quot; a data structure so you can construct it however you want with literals, <code>honey.sql.helpers</code> calls, Clojure functions to manipulate data...</z><z id="t1648331804" t="dharrigan Well, from the outside world coming in, someone may be doing ?fields=field_foo1,field_bar2 which ends up as {,,,,, :fields [&quot;field_foo1&quot;, &quot;field_bar2&quot;]} , (just realised that having the kebab-case is unecessary), but anywhoo, I have to take those fields, could be N, and cconstruct the SQL from that but also end up with a select that included the {:over} clause as well, what I could get to work was {:select ...} above."><y>#</y><d>2022-03-26</d><h>21:56</h><w>dharrigan</w>Well, from the outside world coming in, someone may be doing <code>?fields=field_foo1,field_bar2</code> which ends up as <code>{,,,,, :fields [&quot;field_foo1&quot;, &quot;field_bar2&quot;]}</code>, (just realised that having the kebab-case is unecessary), but anywhoo, I have to take those fields, could be N, and cconstruct the SQL from that but also end up with a select that included the <code>{:over}</code> clause as well, what I could get to work was <code>{:select ...}</code> above.</z><z id="t1648331955" t="dharrigan So, I get this:"><y>#</y><d>2022-03-26</d><h>21:59</h><w>dharrigan</w>So, I get this:</z><z id="t1648331959" t="dharrigan (search {:fields [&quot;name&quot; &quot;address&quot;]}) ;; [&quot;SELECT name, address, COUNT(*) OVER () AS total_rows FROM service ORDER BY field1 DESC LIMIT ? OFFSET ?&quot; ;; 100 ;; 0]"><y>#</y><d>2022-03-26</d><h>21:59</h><w>dharrigan</w><pre>(search {:fields [&quot;name&quot; &quot;address&quot;]})
;; [&quot;SELECT name, address, COUNT(*) OVER () AS total_rows FROM service ORDER BY field1 DESC LIMIT ? OFFSET ?&quot;
;;  100
;;  0]</pre></z><z id="t1648331967" t="dharrigan as an exmple"><y>#</y><d>2022-03-26</d><h>21:59</h><w>dharrigan</w>as an exmple</z><z id="t1648332068" t="dharrigan Hmm, could use concat"><y>#</y><d>2022-03-26</d><h>22:01</h><w>dharrigan</w>Hmm, could use concat</z><z id="t1648332077" t="dharrigan (-&gt; {:select (concat (mapv keyword (or fields [:*])) [[:over [[:count :*] {} :total-rows]]])}"><y>#</y><d>2022-03-26</d><h>22:01</h><w>dharrigan</w><code>(-&gt; {:select (concat (mapv keyword (or fields [:*])) [[:over [[:count :*] {} :total-rows]]])}</code></z><z id="t1648332201" t="seancorfield Ah, OK, so this is all about taking a collection of strings and wanting to treat them as column names (keywords or symbols)?"><y>#</y><d>2022-03-26</d><h>22:03</h><w>seancorfield</w>Ah, OK, so this is all about taking a collection of strings and wanting to treat them as column names (keywords or symbols)?</z><z id="t1648332215" t="dharrigan yes, that is right"><y>#</y><d>2022-03-26</d><h>22:03</h><w>dharrigan</w>yes, that is right</z><z id="t1648332259" t="dharrigan So, this looks better"><y>#</y><d>2022-03-26</d><h>22:04</h><w>dharrigan</w>So, this looks better</z><z id="t1648332261" t="dharrigan (defn search2 [query-parameters] (let [{:keys [field1 field2 field3 fields sort-field sort-direction page limit] :or {page 0 limit 100 sort-field :field1 sort-direction :desc}} query-parameters] (-&gt; {:select (concat (mapv keyword (or fields [:*])) [[:over [[:count :*] {} :total-rows]]])} (from :service) (where (when field1 [:= :field1 field1]) (when field2 [:= :field2 field2]) (when field3 [:= :field3 field3])) (order-by [sort-field sort-direction]) (offset (* limit page)) (helpers/limit limit) sql/format)))"><y>#</y><d>2022-03-26</d><h>22:04</h><w>dharrigan</w><pre>(defn search2
  [query-parameters]
  (let [{:keys [field1 field2 field3 fields sort-field sort-direction page limit] :or {page 0 limit 100 sort-field :field1 sort-direction :desc}} query-parameters]
    (-&gt; {:select (concat (mapv keyword (or fields [:*])) [[:over [[:count :*] {} :total-rows]]])}
        (from :service)
        (where
         (when field1 [:= :field1 field1])
         (when field2 [:= :field2 field2])
         (when field3 [:= :field3 field3]))
        (order-by [sort-field sort-direction])
        (offset (* limit page))
        (helpers/limit limit)
        sql/format)))</pre></z><z id="t1648332338" t="dharrigan (search2 {:field1 &quot;rocking&quot; :fields [&quot;field1&quot; &quot;field2&quot;]}) ;; [&quot;SELECT field1, field2, over AS COUNT(*) total_rows FROM service WHERE field1 = ? ORDER BY field1 DESC LIMIT ? OFFSET ?&quot; ;; &quot;rocking&quot; ;; 100 ;; 0]"><y>#</y><d>2022-03-26</d><h>22:05</h><w>dharrigan</w><pre>(search2 {:field1 &quot;rocking&quot; :fields [&quot;field1&quot; &quot;field2&quot;]})
;; [&quot;SELECT field1, field2, over AS COUNT(*)  total_rows FROM service WHERE field1 = ? ORDER BY field1 DESC LIMIT ? OFFSET ?&quot;
;;  &quot;rocking&quot;
;;  100
;;  0]</pre></z><z id="t1648332383" t="dharrigan Actually that&apos;s wrong now, the concat doesn&apos;t construct the vector to create the over correctly"><y>#</y><d>2022-03-26</d><h>22:06</h><w>dharrigan</w>Actually that&apos;s wrong now, the concat doesn&apos;t construct the vector to create the over correctly</z><z id="t1648332397" t="seancorfield So now all I need to do is invoke your app with ?fields=some,SQL,injection,here and your database is toast 🙂"><y>#</y><d>2022-03-26</d><h>22:06</h><w>seancorfield</w>So now all I need to do is invoke your app with <code>?fields=some,SQL,injection,here</code> and your database is toast <b>🙂</b></z><z id="t1648332427" t="dharrigan oops"><y>#</y><d>2022-03-26</d><h>22:07</h><w>dharrigan</w>oops</z><z id="t1648332445" t="dharrigan I&apos;m going to try that, looks fun!"><y>#</y><d>2022-03-26</d><h>22:07</h><w>dharrigan</w>I&apos;m going to try that, looks fun!</z><z id="t1648332473" t="seancorfield The simple and obvious injection is detected and blocked: dev=&gt; (let [fields [&quot;foo; drop user&quot;]] #_=&gt; (sql/format {:select (mapv keyword fields)})) Execution error (ExceptionInfo) at honey.sql/format-entity (sql.cljc:206). suspicious character found in entity: foo; drop user but more sophisticated ones can be constructed fairly easily."><y>#</y><d>2022-03-26</d><h>22:07</h><w>seancorfield</w>The simple and obvious injection is detected and blocked:
<pre>dev=&gt; (let [fields [&quot;foo; drop user&quot;]]
 #_=&gt;   (sql/format {:select (mapv keyword fields)}))
Execution error (ExceptionInfo) at honey.sql/format-entity (sql.cljc:206).
suspicious character found in entity: foo; drop user</pre>
but more sophisticated ones can be constructed fairly easily.</z><z id="t1648332574" t="dharrigan Perhaps it&apos;s easier then to return all fields, i.e., select *, then filter after that?"><y>#</y><d>2022-03-26</d><h>22:09</h><w>dharrigan</w>Perhaps it&apos;s easier then to return all fields, i.e., select *, then filter after that?</z><z id="t1648332593" t="dharrigan not sure, since it would be helpful for the db to only return fields that you&apos;re interested in, after all, it&apos;s good at that 🙂"><y>#</y><d>2022-03-26</d><h>22:09</h><w>dharrigan</w>not sure, since it would be helpful for the db to only return fields that you&apos;re interested in, after all, it&apos;s good at that <b>🙂</b></z><z id="t1648332622" t="dharrigan and if you don&apos;t know in advance which fields the client will want returned, interesting!"><y>#</y><d>2022-03-26</d><h>22:10</h><w>dharrigan</w>and if you don&apos;t know in advance which fields the client will want returned, interesting!</z><z id="t1648332638" t="dharrigan cough*graphql*cough"><y>#</y><d>2022-03-26</d><h>22:10</h><w>dharrigan</w>cough*graphql*cough</z><z id="t1648332671" t="seancorfield Outside the scope of HoneySQL but sanitizing requested field names into column names is important and would be the correct approach here."><y>#</y><d>2022-03-26</d><h>22:11</h><w>seancorfield</w>Outside the scope of HoneySQL but sanitizing requested field names into column names is important and would be the correct approach here.</z><z id="t1648332724" t="dharrigan True, no need to discuss it here."><y>#</y><d>2022-03-26</d><h>22:12</h><w>dharrigan</w>True, no need to discuss it here.</z><z id="t1648332781" t="seancorfield (now I see what you&apos;re really asking -- it&apos;s something we do in code at work but we validate input against a known list of valid fields that can be exposed... after all, we don&apos;t want passwords and credit card info returned in a query where users can specify arbitrary columns to return)"><y>#</y><d>2022-03-26</d><h>22:13</h><w>seancorfield</w>(now I see what you&apos;re really asking -- it&apos;s something we do in code at work but we validate input against a known list of valid fields that can be exposed... after all, we don&apos;t want passwords and credit card info returned in a query where users can specify arbitrary columns to return)</z><z id="t1648332846" t="dharrigan Yes, I was starting to ponder that too. I can accept an input of fields from the outside world, and strip away any fields that I don&apos;t allow and are not part of the table schema."><y>#</y><d>2022-03-26</d><h>22:14</h><w>dharrigan</w>Yes, I was starting to ponder that too. I can accept an input of fields from the outside world, and strip away any fields that I don&apos;t allow and are not part of the table schema.</z><z id="t1648332877" t="dharrigan A nice little problem to ponder on over the next few days. This is for a personal project of mine, so nothing work related 🙂"><y>#</y><d>2022-03-26</d><h>22:14</h><w>dharrigan</w>A nice little problem to ponder on over the next few days. This is for a personal project of mine, so nothing work related <b>🙂</b></z><z id="t1648332911" t="dharrigan Thanks Sean! I&apos;m offski to bed now."><y>#</y><d>2022-03-26</d><h>22:15</h><w>dharrigan</w>Thanks Sean! I&apos;m offski to bed now.</z><z id="t1648332988" t="seancorfield dev=&gt; (let [fields [&quot;password from user union select 1 as password&quot;]] #_=&gt; (sql/format {:select (mapv keyword fields) :from :table})) [&quot;SELECT password from user union select 1 as password FROM table&quot;] 🙂"><y>#</y><d>2022-03-26</d><h>22:16</h><w>seancorfield</w><pre>dev=&gt; (let [fields [&quot;password from user union select 1 as password&quot;]]
 #_=&gt;   (sql/format {:select (mapv keyword fields) :from :table}))
[&quot;SELECT password from user union select 1 as password FROM table&quot;]</pre>
<b>🙂</b></z><z id="t1648333033" t="seancorfield There&apos;s a ticket about detecting/blocking this sort of thing: #394"><y>#</y><d>2022-03-26</d><h>22:17</h><w>seancorfield</w>There&apos;s a ticket about detecting/blocking this sort of thing: #394</z><z id="t1648354982" t="orestis [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] two things on your approach: 1. I&apos;ve found that window functions (over) performed much worse than doing a completely separate query for the count. Not sure if something changed since I last tried. 2. I would construct the full select statically and then remove fields not present in the request. Much safer!"><y>#</y><d>2022-03-27</d><h>04:23</h><w>orestis</w><a>@dharrigan</a> two things on your approach:
1. I&apos;ve found that window functions (over) performed much worse than doing a completely separate query for the count. Not sure if something changed since I last tried. 
2. I would construct the full select statically and then remove fields not present in the request. Much safer!</z><z id="t1648355071" t="orestis Re: 2, I&apos;m working on some code to do it. Can&apos;t promise it works on every kind of query but we&apos;ve covered the common use case of renamed columns. Quite easy to do. "><y>#</y><d>2022-03-27</d><h>04:24</h><w>orestis</w>Re: 2, I&apos;m working on some code to do it. Can&apos;t promise it works on every kind of query but we&apos;ve covered the common use case of renamed columns. Quite easy to do. </z><z id="t1648363169" t="dharrigan Thanks! 🙂 Useful to know! 🙂"><y>#</y><d>2022-03-27</d><h>06:39</h><w>dharrigan</w>Thanks! <b>🙂</b> Useful to know! <b>🙂</b></z><z id="t1648367962" t="orestis The Postgres planner seemingly does a good job in ignoring unused stuff so even if your query uses joins etc, if you don&apos;t select something from joined tables they will be ignored. "><y>#</y><d>2022-03-27</d><h>07:59</h><w>orestis</w>The Postgres planner seemingly does a good job in ignoring unused stuff so even if your query uses joins etc, if you don&apos;t select something from joined tables they will be ignored. </z><z id="t1648758169" t="Cam Saul In HoneySQL 2.x is there a way to use custom functions inside :select or :from without using an alias? I have something like this in HoneySQL 1.x (simplified example) (defrecord Identifier [components] honeysql.format/ToSql (to-sql [_this] (str/join \. components))) (honeysql.core/format {:select [(Identifier. [&quot;x&quot; &quot;y&quot;])]}) ;; =&gt; [&quot;SELECT x.y&quot;] When I try to convert it to HoneySQL 2.x I can only use it if I provide an alias, otherwise it doesn&apos;t work: (honey.sql/register-fn! ::identifier (fn [_ [components]] [(str/join \. components)])) ;; with alias (honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]] :z]]}) ;; =&gt; [&quot;SELECT x.y AS z&quot;] ;; without alias (honey.sql/format {:select [[::identifier [&quot;x&quot; &quot;y&quot;]]]}) ;; =&gt; [&quot;SELECT my.namespace.identifier AS ? ?&quot; &quot;x&quot; &quot;y&quot;] There&apos;s no equivalent of ToSql in HoneySQL 2, right? Is something like this impossible?"><y>#</y><d>2022-03-31</d><h>20:22</h><w>Cam Saul</w>In HoneySQL 2.x is there a way to use custom functions inside <code>:select</code> or <code>:from</code> without using an alias?

I have something like this in HoneySQL 1.x (simplified example)

<pre>(defrecord Identifier [components]
  honeysql.format/ToSql
  (to-sql [_this]
    (str/join \. components)))

(honeysql.core/format {:select [(Identifier. [&quot;x&quot; &quot;y&quot;])]})
;; =&gt; [&quot;SELECT x.y&quot;]</pre>
When I try to convert it to HoneySQL 2.x I can only use it if I provide an alias, otherwise it doesn&apos;t work:

<pre>(honey.sql/register-fn!
 ::identifier
 (fn [_ [components]]
   [(str/join \. components)]))

;; with alias
(honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]] :z]]})
;; =&gt; [&quot;SELECT x.y AS z&quot;]

;; without alias
(honey.sql/format {:select [[::identifier [&quot;x&quot; &quot;y&quot;]]]})
;; =&gt; [&quot;SELECT my.namespace.identifier AS ? ?&quot; &quot;x&quot; &quot;y&quot;]</pre>
There&apos;s no equivalent of <code>ToSql</code> in HoneySQL 2, right? Is something like this impossible?</z><z id="t1648758233" t="Cam Saul It&apos;s the same thing for :from FWIW, things that used to work in HoneySQL 1 without an alias now don&apos;t work unless you pass in a [form alias] pair in their place"><y>#</y><d>2022-03-31</d><h>20:23</h><w>Cam Saul</w>It&apos;s the same thing for <code>:from</code> FWIW, things that used to work in HoneySQL 1 without an alias now don&apos;t work unless you pass in a <code>[form alias]</code> pair in their place</z><z id="t1648759546" t="seancorfield You can omit the alias but you need the brackets. That is specifically documented as a difference. It&apos;s a way to ensure consistent function syntax."><y>#</y><d>2022-03-31</d><h>20:45</h><w>seancorfield</w>You can omit the alias but you need the brackets. That is specifically documented as a difference. It&apos;s a way to ensure consistent function syntax.</z><z id="t1648759633" t="seancorfield dev=&gt; (honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]] :z]]}) [&quot;SELECT x.y AS z&quot;] dev=&gt; (honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]]]]}) [&quot;SELECT x.y&quot;] ☝️ :skin-tone-2: [:attrs {:href &quot;/_/_/users/U42REFCKA&quot;}]"><y>#</y><d>2022-03-31</d><h>20:47</h><w>seancorfield</w><pre>dev=&gt; (honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]] :z]]})
[&quot;SELECT x.y AS z&quot;]
dev=&gt; (honey.sql/format {:select [[[::identifier [&quot;x&quot; &quot;y&quot;]]]]})
[&quot;SELECT x.y&quot;]</pre>
<b>☝️</b><b>:skin-tone-2:</b> <a>@camsaul</a></z><z id="t1648759665" t="Cam Saul Oh that makes sense. Thank you!"><y>#</y><d>2022-03-31</d><h>20:47</h><w>Cam Saul</w>Oh that makes sense. Thank you!</z><z id="t1648765639" t="Cam Saul Is it possible to use something custom in the alias part of a [source-identifier alias] pair? e.g. (ns x (:require [honey.sql :as sql] [clojure.string :as str])) (defn- format-identifier [_ components] [(str/join \. (for [component components] ;; by passing `:aliased true` it won&apos;t split on any dots in the keyword/string (sql/format-entity component {:aliased true})))]) (sql/register-fn! ::identifier format-identifier) (sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;]]]}) ;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot;&quot;] (sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] &quot;my_alias&quot;]]}) ;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot; AS \&quot;my_alias\&quot;&quot;] (sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] [::identifier &quot;my_alias&quot;]]]}) ;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot; AS x.identifier ?&quot; &quot;my_alias&quot;]"><y>#</y><d>2022-03-31</d><h>22:27</h><w>Cam Saul</w>Is it possible to use something custom in the <code>alias</code> part of a <code>[source-identifier alias]</code> pair? e.g.

<pre>(ns x
  (:require [honey.sql :as sql]
            [clojure.string :as str]))

(defn- format-identifier [_ components]
  [(str/join
    \.
    (for [component components]
      ;; by passing `:aliased true` it won&apos;t split on any dots in the keyword/string
      (sql/format-entity component {:aliased true})))])

(sql/register-fn! ::identifier format-identifier)

(sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;]]]})
;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot;&quot;]

(sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] &quot;my_alias&quot;]]})
;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot; AS \&quot;my_alias\&quot;&quot;]

(sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] [::identifier &quot;my_alias&quot;]]]})
;; =&gt; [&quot;SELECT \&quot;my_table\&quot;.\&quot;my_field\&quot; AS x.identifier ?&quot; &quot;my_alias&quot;]</pre></z><z id="t1648766471" t="seancorfield [:attrs {:href &quot;/_/_/users/U42REFCKA&quot;}] I don&apos;t understand the question, sorry. What problem are you trying to solve?"><y>#</y><d>2022-03-31</d><h>22:41</h><w>seancorfield</w><a>@camsaul</a> I don&apos;t understand the question, sorry. What problem are you trying to solve?</z><z id="t1648766823" t="Cam Saul In Metabase we have a special record type called Identifier that we use for different identifiers -- we use it to record some extra info beyond what a normal string or keyword might identifier might have, such as the type of identifier (table/field/field alias/etc.) and database type (important for databases like BigQuery where you have to use different functions for a DATE vs a DATETIME vs a TIMESTAMP ). It implements HoneySQL 1.x ToSql Our code uses that everywhere we need identifiers -- on both sides of the [identifier alias] pair in :select , :from , joins, etc. I&apos;m looking at upgrading to HoneySQL 2 but this is a sticking point because (sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] [::identifier &quot;my_alias&quot;]]]}) doesn&apos;t work"><y>#</y><d>2022-03-31</d><h>22:47</h><w>Cam Saul</w>In Metabase we have a special record type called <code>Identifier</code> that we use for different identifiers -- we use it to record some extra info beyond what a normal string or keyword might identifier might have, such as the type of identifier (table/field/field alias/etc.) and database type (important for databases like BigQuery where you have to use different functions for a <code>DATE</code> vs a <code>DATETIME</code> vs a <code>TIMESTAMP</code> ). It implements HoneySQL 1.x <code>ToSql</code>

Our code uses that everywhere we need identifiers -- on both sides of the <code>[identifier alias]</code> pair in <code>:select</code> , <code>:from</code> , joins, etc. I&apos;m looking at upgrading to HoneySQL 2 but this is a sticking point because

<pre>(sql/format {:select [[[::identifier &quot;my_table&quot; &quot;my_field&quot;] [::identifier &quot;my_alias&quot;]]]})</pre>
doesn&apos;t work</z><z id="t1648766902" t="seancorfield I&apos;m still not understanding. What SQL are you trying to generate here?"><y>#</y><d>2022-03-31</d><h>22:48</h><w>seancorfield</w>I&apos;m still not understanding. What SQL are you trying to generate here?</z><z id="t1648766924" t="seancorfield What&apos;s the problem, not what&apos;s the implementation/solution 🙂"><y>#</y><d>2022-03-31</d><h>22:48</h><w>seancorfield</w>What&apos;s the problem, not what&apos;s the implementation/solution <b>🙂</b></z><z id="t1648766937" t="Cam Saul SELECT &quot;my_table&quot;.&quot;my_field&quot; AS &quot;my_alias&quot; (assuming ANSI quoting)"><y>#</y><d>2022-03-31</d><h>22:48</h><w>Cam Saul</w><pre>SELECT &quot;my_table&quot;.&quot;my_field&quot; AS &quot;my_alias&quot;</pre>
(assuming ANSI quoting)</z><z id="t1648766967" t="seancorfield So what&apos;s wrong with just :my_alias here?"><y>#</y><d>2022-03-31</d><h>22:49</h><w>seancorfield</w>So what&apos;s wrong with just <code>:my_alias</code> here?</z><z id="t1648767200" t="Cam Saul Right, I know that would work. The main problem is we&apos;re currently generating Identifier (or [::identifier ...] if I can make the migration to HoneySQL 2 work) all over the place (since we need to pass around the extra type info) so while we could manually unwrap that stuff where appropriate, it&apos;s going to break any third party usage that isn&apos;t updated to do the manual unwrapping stuff as well. I&apos;m cool with rewriting a bunch of code in Metabase itself but it would break stuff in a bunch of our third party drivers"><y>#</y><d>2022-03-31</d><h>22:53</h><w>Cam Saul</w>Right, I know that would work. The main problem is we&apos;re currently generating <code>Identifier</code> (or <code>[::identifier ...]</code> if I can make the migration to HoneySQL 2 work) all over the place (since we need to pass around the extra type info) so while we could manually unwrap that stuff where appropriate, it&apos;s going to break any third party usage that isn&apos;t updated to do the manual unwrapping stuff as well.

I&apos;m cool with rewriting a bunch of code in Metabase itself but it would break stuff in a bunch of our third party drivers</z><z id="t1648767347" t="seancorfield I would have expected the type information etc to be on the expression part and the alias to be just a plain old alias..."><y>#</y><d>2022-03-31</d><h>22:55</h><w>seancorfield</w>I would have expected the type information etc to be on the expression part and the alias to be just a plain old alias...</z><z id="t1648767401" t="seancorfield ...as for the difference you&apos;re running into, there&apos;s currently a baked-in assumption that aliases are just aliases and therefore should be simple identifiers."><y>#</y><d>2022-03-31</d><h>22:56</h><w>seancorfield</w>...as for the difference you&apos;re running into, there&apos;s currently a baked-in assumption that aliases are just aliases and therefore should be simple identifiers.</z><z id="t1648767482" t="seancorfield Feel free to create a GH issue about this but I&apos;m not very inclined to add this right now. You can try to be more persuasive in the ticket 🙂"><y>#</y><d>2022-03-31</d><h>22:58</h><w>seancorfield</w>Feel free to create a GH issue about this but I&apos;m not very inclined to add this right now. You can try to be more persuasive in the ticket <b>🙂</b></z><z id="t1648767672" t="Cam Saul We had a bunch of other reasons for doing it, such as https://github.com/seancorfield/honeysql/issues/216 (we started using HoneySQL before that was fixed). It doesn&apos;t really need to be done that way now, but I never changed it so as to not bust a bunch of other people&apos;s working code I was just asking if there was a way you could do that or not. I&apos;ll figure something out. I might just have to ask people to rework their drivers"><y>#</y><d>2022-03-31</d><h>23:01</h><w>Cam Saul</w>We had a bunch of other reasons for doing it, such as <a href="https://github.com/seancorfield/honeysql/issues/216" target="_blank">https://github.com/seancorfield/honeysql/issues/216</a> (we started using HoneySQL before that was fixed). It doesn&apos;t really need to be done that way now, but I never changed it so as to not bust a bunch of other people&apos;s working code

I was just asking if there was a way you could do that or not. I&apos;ll figure something out. I might just have to ask people to rework their drivers</z><z id="t1648767941" t="seancorfield Please report back with what you ultimately figure out. If it&apos;s really going to cause a lot of people a lot of work, that is persuasive, but I don&apos;t really want to open up the possibility of supporting arbitrary expressions as aliases... Maybe &quot;just&quot; a simple function expression would be OK."><y>#</y><d>2022-03-31</d><h>23:05</h><w>seancorfield</w>Please report back with what you ultimately figure out. If it&apos;s really going to cause a lot of people a lot of work, that is persuasive, but I don&apos;t really want to open up the possibility of supporting arbitrary expressions as aliases... Maybe &quot;just&quot; a simple function expression would be OK.</z><z id="t1648768534" t="Cam Saul This isn&apos;t such a big deal to be honest. I have ran a handful of other gotchas around not having the general ToSql protocol anymore tho. For example we had an impl for clojure.lang.Ratio and some other stuff. That&apos;s really the only thing making the transition tricky. We have a lot of custom stuff"><y>#</y><d>2022-03-31</d><h>23:15</h><w>Cam Saul</w>This isn&apos;t such a big deal to be honest. I have ran a handful of other gotchas around not having the general <code>ToSql</code> protocol anymore tho. For example we had an impl for <code>clojure.lang.Ratio</code> and some other stuff. That&apos;s really the only thing making the transition tricky. We have a lot of custom stuff</z><z id="t1648771819" t="Cam Saul Sorry for all the dumb questions but is it by design that HoneySQL 2 doesn&apos;t attempt to escape quote characters inside quoted identifiers? ;; HoneySQL 1 (println (first (honeysql.core/format {:select [[:field &quot;A\&quot;B&quot;]]} :quoting :ansi))) ;; =&gt; SELECT &quot;field&quot; AS &quot;A&quot;&quot;B&quot; ;; HoneySQL 2 (println (first (honey.sql/format {:select [[:field &quot;A\&quot;B&quot;]]} {:dialect :ansi}))) ;; =&gt; SELECT &quot;field&quot; AS &quot;A&quot;B&quot; If we are expected to quote these things ourselves I offer this up a real-world case where supporting custom functions inside the alias part of a pair would make sense. I&apos;d just do something like [::escape-quotes &quot;A\&quot;B&quot;] and then wait until actual compilation to do the escaping"><y>#</y><d>2022-04-01</d><h>00:10</h><w>Cam Saul</w>Sorry for all the dumb questions but is it by design that HoneySQL 2 doesn&apos;t attempt to escape quote characters inside quoted identifiers?

<pre>;; HoneySQL 1
(println (first (honeysql.core/format {:select [[:field &quot;A\&quot;B&quot;]]} :quoting :ansi)))
;; =&gt; SELECT &quot;field&quot; AS &quot;A&quot;&quot;B&quot;

;; HoneySQL 2
(println (first (honey.sql/format {:select [[:field &quot;A\&quot;B&quot;]]} {:dialect :ansi})))
;; =&gt; SELECT &quot;field&quot; AS &quot;A&quot;B&quot;</pre>
If we are expected to quote these things ourselves I offer this up a real-world case where supporting custom functions inside the alias part of a pair would make sense. I&apos;d just do something like <code>[::escape-quotes &quot;A\&quot;B&quot;]</code> and then wait until actual compilation to do the escaping</z><z id="t1648772421" t="seancorfield https://github.com/seancorfield/honeysql/issues/394"><y>#</y><d>2022-04-01</d><h>00:20</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/394" target="_blank">https://github.com/seancorfield/honeysql/issues/394</a></z><z id="t1648772462" t="seancorfield &quot;A&quot;&quot;B&quot; would be valid for that, yes? Quoted A&quot;B ?"><y>#</y><d>2022-04-01</d><h>00:21</h><w>seancorfield</w><code>&quot;A&quot;&quot;B&quot;</code> would be valid for that, yes? Quoted <code>A&quot;B</code>?</z><z id="t1648772497" t="Cam Saul Yeah for ANSI at least that&apos;s the correct way to do that"><y>#</y><d>2022-04-01</d><h>00:21</h><w>Cam Saul</w>Yeah for ANSI at least that&apos;s the correct way to do that</z><z id="t1648772543" t="seancorfield I was a bit surprised that HoneySQL 1.x handled that automatically but it hadn&apos;t come up with HoneySQL 2.x until about a week ago 🙂"><y>#</y><d>2022-04-01</d><h>00:22</h><w>seancorfield</w>I was a bit surprised that HoneySQL 1.x handled that automatically but it hadn&apos;t come up with HoneySQL 2.x until about a week ago <b>🙂</b></z><z id="t1648772589" t="seancorfield I&apos;ve been a bit slammed this week but I&apos;m hoping to get a new release out next week and it&apos;ll have #394 in it."><y>#</y><d>2022-04-01</d><h>00:23</h><w>seancorfield</w>I&apos;ve been a bit slammed this week but I&apos;m hoping to get a new release out next week and it&apos;ll have #394 in it.</z><z id="t1648772682" t="seancorfield Ah, HoneySQL 1.x: (def ^:private quote-fns {:ansi #(str \&quot; (string/replace % &quot;\&quot;&quot; &quot;\&quot;\&quot;&quot;) \&quot;) :mysql #(str \` (string/replace % &quot;`&quot; &quot;``&quot;) \`) :sqlserver #(str \[ (string/replace % &quot;]&quot; &quot;]]&quot;) \]) :oracle #(str \&quot; (string/replace % &quot;\&quot;&quot; &quot;\&quot;\&quot;&quot;) \&quot;)})"><y>#</y><d>2022-04-01</d><h>00:24</h><w>seancorfield</w>Ah, HoneySQL 1.x:
<pre>(def ^:private quote-fns
  {:ansi #(str \&quot; (string/replace % &quot;\&quot;&quot; &quot;\&quot;\&quot;&quot;) \&quot;)
   :mysql #(str \` (string/replace % &quot;`&quot; &quot;``&quot;) \`)
   :sqlserver #(str \[ (string/replace % &quot;]&quot; &quot;]]&quot;) \])
   :oracle #(str \&quot; (string/replace % &quot;\&quot;&quot; &quot;\&quot;\&quot;&quot;) \&quot;)})</pre></z><z id="t1648773315" t="seancorfield OK, that&apos;s committed to develop now if you want to try it via a git dep?"><y>#</y><d>2022-04-01</d><h>00:35</h><w>seancorfield</w>OK, that&apos;s committed to develop now if you want to try it via a git dep?</z><z id="t1648773327" t="seancorfield (and it&apos;ll be a SNAPSHOT on Clojars in about ten minutes)"><y>#</y><d>2022-04-01</d><h>00:35</h><w>seancorfield</w>(and it&apos;ll be a SNAPSHOT on Clojars in about ten minutes)</z><z id="t1648773338" t="Cam Saul Awesome! I&apos;ll try in just a second"><y>#</y><d>2022-04-01</d><h>00:35</h><w>Cam Saul</w>Awesome! I&apos;ll try in just a second</z><z id="t1648773459" t="Cam Saul One last question (hopefully). Would you be open to a PR adding support for defining custom dialects? Something like a register-dialect! function? We need to do some weird stuff. Examples: • H2 uppercases unquoted identifiers by default and for historic reasons Metabase H2 application DBs use all uppercase identifiers. We have a custom quote fn that upper-cases and quotes identifiers for this case • We have an ::application-db quote function that calls either the :ansi or :mysql or our custom H2 impl depending on the current application DB type; it would be nice to be able to use it as the default dialect with set-dialect! In HoneySQL 1.x I just hacked it in with alter-var-root and while I could do that with HoneySQL 2.x as well it seems like it would be nicer if I could register! it like I can do with everything else"><y>#</y><d>2022-04-01</d><h>00:37</h><w>Cam Saul</w>One last question (hopefully). Would you be open to a PR adding support for defining custom dialects? Something like a <code>register-dialect!</code> function? We need to do some weird stuff.

Examples:
• H2 uppercases unquoted identifiers by default and for historic reasons Metabase H2 application DBs use all uppercase identifiers. We have a custom quote fn that upper-cases and quotes identifiers for this case
• We have an <code>::application-db</code> quote function that calls either the <code>:ansi</code> or <code>:mysql</code> or our custom H2 impl depending on the current application DB type; it would be nice to be able to use it as the default dialect with <code>set-dialect!</code> 
In HoneySQL 1.x I just hacked it in with <code>alter-var-root</code> and while I could do that with HoneySQL 2.x as well it seems like it would be nicer if I could <code>register!</code> it like I can do with everything else</z><z id="t1648773880" t="seancorfield Can you open an issue first, outlining what you&apos;re looking for?"><y>#</y><d>2022-04-01</d><h>00:44</h><r>seancorfield</r>Can you open an issue first, outlining what you&apos;re looking for?</z><z id="t1648773949" t="seancorfield Looking at the code, I think changing dialects to an atom and adding register-dialect! taking a dialect keyword and a hash map with at least a :quote function would be the minimum. But such a change needs tests and documentation as well."><y>#</y><d>2022-04-01</d><h>00:45</h><r>seancorfield</r>Looking at the code, I think changing <code>dialects</code> to an <code>atom</code> and adding <code>register-dialect!</code> taking a dialect keyword and a hash map with at least a <code>:quote</code> function would be the minimum. But such a change needs tests and documentation as well.</z><z id="t1648774477" t="Cam Saul Ok I opened https://github.com/seancorfield/honeysql/issues/401"><y>#</y><d>2022-04-01</d><h>00:54</h><r>Cam Saul</r>Ok I opened <a href="https://github.com/seancorfield/honeysql/issues/401" target="_blank">https://github.com/seancorfield/honeysql/issues/401</a></z><z id="t1648774629" t="seancorfield Appreciated!"><y>#</y><d>2022-04-01</d><h>00:57</h><r>seancorfield</r>Appreciated!</z><z id="t1648773682" t="Cam Saul Just tried the latest commit it&apos;s working for me BTW. Thanks!"><y>#</y><d>2022-04-01</d><h>00:41</h><w>Cam Saul</w>Just tried the latest commit it&apos;s working for me BTW. Thanks!</z><z id="t1648813970" t="Eugen hi, is there an inline version of (sql/format-expr [:array (range 5)]) ? or another way to generate an inline SQL for update my_table set tags = ARRAY[&apos;tag1,&apos;tag2&apos;] where .... ? Context: I&apos;m trying to generate an SQL file for lots of data that I can then bulk import as a transaction. the file should update a column that is of type PostgreSQL text array (let [tags [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;] id 5] (sql/format {:update [:my_table] :set {:tags :?tags} :where [:= :id :?id] :returning :*} {:inline true :params {:id id :tags tags}})) give me [&quot;UPDATE my_table SET tags = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;] WHERE id = 5 RETURNING *&quot;] which is not the good syntax. I tried several forms with format-expr and :array without success. I did manage to execute a query with array via next.jdbc but I want to generate the SQL file, not execute it."><y>#</y><d>2022-04-01</d><h>11:52</h><w>Eugen</w>hi, is there an inline version of <code>(sql/format-expr [:array (range 5)])</code>  ?
or another way to generate an inline SQL for <code>update my_table set tags = ARRAY[&apos;tag1,&apos;tag2&apos;] where ....</code>  ?
Context:
I&apos;m trying to generate an SQL file for lots of data that I can then bulk import as a transaction.
the file should update a column that is of type PostgreSQL text array

<pre>(let [tags [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;]
        id 5]
    (sql/format {:update [:my_table]
                 :set {:tags :?tags}
                 :where [:= :id :?id]
                 :returning :*}
                {:inline true
                 :params {:id id :tags tags}}))</pre>
give me
<pre>[&quot;UPDATE my_table SET tags = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;] WHERE id = 5 RETURNING *&quot;]</pre>
which is not the good syntax.
I tried several forms with format-expr and <code>:array</code> without success.
I did manage to execute a query with array via next.jdbc but I want to generate the SQL file, not execute it.</z><z id="t1648815622" t="Eugen so it seems this works, but it&apos;s not very obvious or documented. (binding [sql/*inline* true] (sql/format-expr [:array [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;]])) =&gt; [&quot;ARRAY[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;]&quot;] [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] : should I improve the docs, the code, both ?!"><y>#</y><d>2022-04-01</d><h>12:20</h><r>Eugen</r>so it seems this works, but it&apos;s not very obvious or documented.
<pre>(binding [sql/*inline* true]
    (sql/format-expr [:array [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;]]))</pre>
=&gt;
<pre>[&quot;ARRAY[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;]&quot;]</pre>
<a>@U04V70XH6</a>: should I improve the docs, the code, both ?!</z><z id="t1648815640" t="Eugen wdyt it&apos;s the best solution ?"><y>#</y><d>2022-04-01</d><h>12:20</h><r>Eugen</r>wdyt it&apos;s the best solution ?</z><z id="t1648825192" t="seancorfield Create a GH issue with the examples above and the SQL you&apos;re trying to generate and I&apos;ll look at it when I&apos;m back from vacation."><y>#</y><d>2022-04-01</d><h>14:59</h><r>seancorfield</r>Create a GH issue with the examples above and the SQL you&apos;re trying to generate and I&apos;ll look at it when I&apos;m back from vacation.</z><z id="t1648825213" t="Eugen will do that, enjoy your vacation !"><y>#</y><d>2022-04-01</d><h>15:00</h><r>Eugen</r>will do that, enjoy your vacation !</z><z id="t1648826034" t="Eugen done here https://github.com/seancorfield/honeysql/issues/403"><y>#</y><d>2022-04-01</d><h>15:13</h><r>Eugen</r>done here <a href="https://github.com/seancorfield/honeysql/issues/403" target="_blank">https://github.com/seancorfield/honeysql/issues/403</a></z><z id="t1648826361" t="seancorfield Looks like a bug with parameter substitution since this works: dev=&gt; (let [tags [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;] #_=&gt; id 5] #_=&gt; (sql/format {:update [:my_table] #_=&gt; :set {:tags [:array tags]} #_=&gt; :where [:= :id :?id] #_=&gt; :returning :*} #_=&gt; {:inline true #_=&gt; :params {:id id}})) [&quot;UPDATE my_table SET tags = ARRAY[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;] WHERE id = 5 RETURNING *&quot;]"><y>#</y><d>2022-04-01</d><h>15:19</h><r>seancorfield</r>Looks like a bug with parameter substitution since this works:
<pre>dev=&gt; (let [tags [&quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;99&quot;]
 #_=&gt;         id 5]
 #_=&gt;     (sql/format {:update [:my_table]
 #_=&gt;                  :set {:tags [:array tags]}
 #_=&gt;                  :where [:= :id :?id]
 #_=&gt;                  :returning :*}
 #_=&gt;                 {:inline true
 #_=&gt;                  :params {:id id}}))
[&quot;UPDATE my_table SET tags = ARRAY[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;99&apos;] WHERE id = 5 RETURNING *&quot;]</pre></z><z id="t1648826410" t="seancorfield Or it might be a bug with the :array function maybe..."><y>#</y><d>2022-04-01</d><h>15:20</h><r>seancorfield</r>Or it might be a bug with the <code>:array</code> function maybe...</z><z id="t1648826418" t="seancorfield Anyways, will look at it next week."><y>#</y><d>2022-04-01</d><h>15:20</h><r>seancorfield</r>Anyways, will look at it next week.</z><z id="t1648986132" t="jabhi207 How to use is distinct from in honeysql query?"><y>#</y><d>2022-04-03</d><h>11:42</h><w>jabhi207</w>How to use <code>is distinct from</code> in honeysql query?</z><z id="t1649102896" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ2KW482V&quot;}] I don&apos;t even know what SQL that is... can you link to docs for it? Is it DB-specific? If it is a binary operator, you can register it yourself and use it: dev=&gt; (sql/register-op! :is-distinct-from) nil dev=&gt; (sql/format {:where [:is-distinct-from :a :b]}) [&quot;WHERE a IS DISTINCT FROM b&quot;] If it is ANSI SQL, I can add it to the core."><y>#</y><d>2022-04-04</d><h>20:08</h><w>seancorfield</w><a>@jabhi207</a> I don&apos;t even know what SQL that is... can you link to docs for it? Is it DB-specific? If it is a binary operator, you can register it yourself and use it:
<pre>dev=&gt; (sql/register-op! :is-distinct-from)
nil
dev=&gt; (sql/format {:where [:is-distinct-from :a :b]})
[&quot;WHERE a IS DISTINCT FROM b&quot;]</pre>
If it is ANSI SQL, I can add it to the core.</z><z id="t1649131042" t="jabhi207 Yes it is binary operator. The solution works. Didn’t knew about sql/register-op! . Thanks"><y>#</y><d>2022-04-05</d><h>03:57</h><r>jabhi207</r>Yes it is binary operator. The solution works. Didn’t knew about <code>sql/register-op!</code> . Thanks</z><z id="t1649103619" t="dharrigan Could be this: "><y>#</y><d>2022-04-04</d><h>20:20</h><w>dharrigan</w>Could be this: <code></code></z><z id="t1649103858" t="dharrigan Looks like it&apos;s part of the standard too"><y>#</y><d>2022-04-04</d><h>20:24</h><w>dharrigan</w>Looks like it&apos;s part of the standard too</z><z id="t1649103918" t="dharrigan also in mysql "><y>#</y><d>2022-04-04</d><h>20:25</h><w>dharrigan</w>also in mysql <code></code></z><z id="t1649192559" t="Proctor I was doing an upgrade of HoneySQL from 0.9.3 to 2.2.868 to get support for CTEs and RowNumber function and figured I would attempt a bump to latest. I found that the “alternate” version of parameterized queries as outputs are gone (e.g. $1 ) and everything is now ? which our postgres instance doesn’t seem to like (PostgreSQL 10.18) ERROR: syntax error at or near &quot;,&quot; LINE 2: ..._guid, update_type, update_data, status) VALUES (?, ?, ?, ?,... ^ any suggestions on things to look at? Should I rewrite most of the queries to take the params map?"><y>#</y><d>2022-04-05</d><h>21:02</h><w>Proctor</w>I was doing an upgrade of HoneySQL from <code>0.9.3</code> to <code>2.2.868</code> to get support for CTEs and RowNumber function and figured I would attempt a bump to latest.

I found that the “alternate” version of parameterized queries as outputs are gone (e.g. <code>$1</code> ) and everything is now <code>?</code> which our postgres instance doesn’t seem to like (PostgreSQL 10.18)

<pre>ERROR:  syntax error at or near &quot;,&quot;
LINE 2: ..._guid, update_type, update_data, status) VALUES (?, ?, ?, ?,...
                                                             ^</pre>
any suggestions on things to look at?   Should I rewrite most of the queries to take the <code>params</code> map?</z><z id="t1649193188" t="seancorfield No idea why PG would barf on that -- it&apos;s legal SQL syntax and works in the tests for PG. But, yes, the positional $N style parameters are no longer supported -- only ? placeholders (standard SQL) and named parameters (like :?foo and then {:params {:foo 123}} passed in options)."><y>#</y><d>2022-04-05</d><h>21:13</h><w>seancorfield</w>No idea why PG would barf on that -- it&apos;s legal SQL syntax and works in the tests for PG. But, yes, the positional <code>$N</code> style parameters are no longer supported -- only <code>?</code> placeholders (standard SQL) and named parameters (like <code>:?foo</code> and then <code>{:params {:foo 123}}</code> passed in options).</z><z id="t1649193257" t="seancorfield [:attrs {:href &quot;/_/_/users/US03ZP2F5&quot;}] I&apos;d have to see your format call and possibly how you&apos;re using the result of that (`clojure.java.jdbc` or next.jdbc call)."><y>#</y><d>2022-04-05</d><h>21:14</h><w>seancorfield</w><a>@steven.proctor</a> I&apos;d have to see your <code>format</code> call and possibly how you&apos;re using the result of that (`clojure.java.jdbc` or <code>next.jdbc</code> call).</z><z id="t1649204547" t="Proctor (defn insert-transaction ([record] (insert-transaction record &quot;running&quot;)) ([record status] (-&gt; (insert-into :write_transactions) (values [(cond-&gt; record (not (:status record)) (assoc :status status))]) (sql/format)))) that is our basic honey-sql sql generator"><y>#</y><d>2022-04-06</d><h>00:22</h><r>Proctor</r><pre>(defn insert-transaction
  ([record]
   (insert-transaction record &quot;running&quot;))
  ([record status]
   (-&gt; (insert-into :write_transactions)
       (values [(cond-&gt; record
                  (not (:status record))
                  (assoc :status status))])
       (sql/format))))</pre>
that is our basic honey-sql sql generator</z><z id="t1649204638" t="Proctor and we destructure and send to pg in ClojureScript on Node (let [[sql &amp; params] (insert-transaction record)] (.query client sql (apply array params))) "><y>#</y><d>2022-04-06</d><h>00:23</h><r>Proctor</r>and we destructure and send to <code>pg</code> in ClojureScript on Node
<pre>(let [[sql &amp; params] (insert-transaction record)]
        (.query client sql (apply array params)))</pre>
</z><z id="t1649204737" t="Proctor sql &quot;INSERT INTO write_transactions (id, session_id, on_behalf_of, loan_guid, update_type, update_data, status) VALUES (?, ?, ?, ?, ?, ?, ?)&quot; params #js [&quot;b953ca66-a030-4f1c-9e6e-50ea239574a3&quot; &quot;&lt;session-id&gt;&quot; &quot;testing-sap&quot; &quot;2e8de942-e954-4b08-88a4-84d38261e33&quot; &quot;update-async&quot; #js {:commands #js [#js [&quot;patch-loan&quot; #js {}]]} &quot;running&quot;]"><y>#</y><d>2022-04-06</d><h>00:25</h><r>Proctor</r><pre>sql &quot;INSERT INTO write_transactions (id, session_id, on_behalf_of, loan_guid, update_type, update_data, status) VALUES (?, ?, ?, ?, ?, ?, ?)&quot;


params #js [&quot;b953ca66-a030-4f1c-9e6e-50ea239574a3&quot; &quot;&lt;session-id&gt;&quot; &quot;testing-sap&quot; &quot;2e8de942-e954-4b08-88a4-84d38261e33&quot; &quot;update-async&quot; #js {:commands #js [#js [&quot;patch-loan&quot; #js {}]]} &quot;running&quot;]</pre></z><z id="t1649204835" t="Proctor and taking that sql straight in to postgres barfs too for some reason: PREPARE fooprep (uuid, varchar, varchar, uuid, varchar, json, varchar) as INSERT INTO write_transactions (id, session_id, on_behalf_of, loan_guid, update_type, update_data, status) VALUES (?, ?, ?, ?, ?, ?, ?) "><y>#</y><d>2022-04-06</d><h>00:27</h><r>Proctor</r>and taking that sql straight in to postgres barfs too for some reason:
<pre>PREPARE fooprep (uuid, varchar, varchar, uuid, varchar, json, varchar) as
  INSERT INTO write_transactions (id, session_id, on_behalf_of, loan_guid, update_type, update_data, status) VALUES (?, ?, ?, ?, ?, ?, ?)</pre>
</z><z id="t1649204898" t="Proctor mainly just making sure it is nothing with the honey-sql directly, as it seemed like the ? would work… but wanted to check on the honey-sql side because all the prepared statements docs on postgres docs and such show the $1 style params"><y>#</y><d>2022-04-06</d><h>00:28</h><r>Proctor</r>mainly just making sure it is nothing with the honey-sql directly, as it seemed like the <code>?</code> would work… but wanted to check on the honey-sql side because all the prepared statements docs on postgres docs and such show the <code>$1</code> style params</z><z id="t1649205511" t="Proctor also wondering if the ? is handled specially by the JDBC stuff"><y>#</y><d>2022-04-06</d><h>00:38</h><r>Proctor</r>also wondering if the <code>?</code> is handled specially by the JDBC stuff</z><z id="t1649205848" t="seancorfield If you&apos;re using Node on the server, you&apos;re not using JDBC... right? So what DB connector are you using on the server?"><y>#</y><d>2022-04-06</d><h>00:44</h><r>seancorfield</r>If you&apos;re using Node on the server, you&apos;re not using JDBC... right? So what DB connector are you using on the server?</z><z id="t1649205884" t="seancorfield Maybe it doesn&apos;t support ? placeholders? (that seems... incredible... to me since this is the basic default for JDBC)"><y>#</y><d>2022-04-06</d><h>00:44</h><r>seancorfield</r>Maybe it doesn&apos;t support <code>?</code> placeholders? (that seems... incredible... to me since this is the basic default for JDBC)</z><z id="t1649205988" t="seancorfield Are you using this https://node-postgres.com/features/queries ?"><y>#</y><d>2022-04-06</d><h>00:46</h><r>seancorfield</r>Are you using this <a href="https://node-postgres.com/features/queries" target="_blank">https://node-postgres.com/features/queries</a> ?</z><z id="t1649206018" t="Proctor yeah, that is the pg node library"><y>#</y><d>2022-04-06</d><h>00:46</h><r>Proctor</r>yeah, that is the <code>pg</code> node library</z><z id="t1649206159" t="Proctor I also just took a peek to see at next.jdbc on the far off-hand chance that the Heart of Gold had marked those code files as cljc …. 😉"><y>#</y><d>2022-04-06</d><h>00:49</h><r>Proctor</r>I also just took a peek to see at next.jdbc on the far off-hand chance that the Heart of Gold  had marked those code files  as <code>cljc</code>…. <b>😉</b></z><z id="t1649206334" t="seancorfield next.jdbc is a thin wrapper around JDBC -- very JVM-specific."><y>#</y><d>2022-04-06</d><h>00:52</h><r>seancorfield</r><code>next.jdbc</code> is a thin wrapper around JDBC -- very JVM-specific.</z><z id="t1649206406" t="seancorfield https://github.com/seancorfield/honeysql/issues/405"><y>#</y><d>2022-04-06</d><h>00:53</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/405" target="_blank">https://github.com/seancorfield/honeysql/issues/405</a></z><z id="t1649206410" t="Proctor yeah, I was expecting that… figured I would check anyway, because it would be nicer to move to something off the node ecosystem to something more properly clojure ;)"><y>#</y><d>2022-04-06</d><h>00:53</h><r>Proctor</r>yeah, I was expecting that… figured I would check anyway, because it would be nicer to move to something off the node ecosystem to something more properly clojure ;)</z><z id="t1649206461" t="seancorfield I avoid node at all costs -- and js in general. You&apos;re the first person to ask about the numbered parameters since the 2.x release 🙂"><y>#</y><d>2022-04-06</d><h>00:54</h><r>seancorfield</r>I avoid node at all costs -- and js in general. You&apos;re the first person to ask about the numbered parameters since the 2.x release <b>🙂</b></z><z id="t1649206521" t="Proctor I would too, but we have AWS Lambdas… and the decision was made because of the JVM startup time… (even though a number of them are driven by SQS queues and are async anyway… ¯\(ツ)/¯ )"><y>#</y><d>2022-04-06</d><h>00:55</h><r>Proctor</r>I would too, but we have AWS Lambdas… and the decision was made because of the JVM startup time… (even though a number of them are driven by SQS queues and are async anyway… ¯\(ツ)/¯ )</z><z id="t1649206557" t="Proctor if there is something I can do to help with it, feel free to point me in the right direction on the ticket"><y>#</y><d>2022-04-06</d><h>00:55</h><r>Proctor</r>if there is something I can do to help with it, feel free to point me in the right direction on the ticket</z><z id="t1649206848" t="seancorfield Part of the problem -- and why I dropped support for it -- is because the parsing/formatting is no longer left-to-right linear so it&apos;s very hard to figure out the ordering for parameters in the SQL string now. I&apos;d have to go through every formatter in the whole codebase and ensure that it produces parameters in a strictly linear, left-to-right order which is potentially a lot of work... so don&apos;t expect this to get added any time soon..."><y>#</y><d>2022-04-06</d><h>01:00</h><r>seancorfield</r>Part of the problem -- and why I dropped support for it -- is because the parsing/formatting is no longer left-to-right linear so it&apos;s very hard to figure out the ordering for parameters in the SQL string now. I&apos;d have to go through every formatter in the whole codebase and ensure that it produces parameters in a strictly linear, left-to-right order which is potentially a lot of work... so don&apos;t expect this to get added any time soon...</z><z id="t1649206981" t="Proctor that part is good to know at least… 😉"><y>#</y><d>2022-04-06</d><h>01:03</h><r>Proctor</r>that part is good to know at least… <b>😉</b></z><z id="t1649207185" t="seancorfield Just looking over the code, there are some places where the ? handling is pretty hardcoded in and there&apos;s at least one place where the code depends on &quot;?&quot; being a possible whole SQL string... I&apos;ll continue to give it some thought but..."><y>#</y><d>2022-04-06</d><h>01:06</h><r>seancorfield</r>Just looking over the code, there are some places where the <code>?</code> handling is pretty hardcoded in and there&apos;s at least one place where the code depends on <code>&quot;?&quot;</code> being a possible whole SQL string... I&apos;ll continue to give it some thought but...</z><z id="t1649193346" t="seancorfield Note that, to aid migration, you can use both HoneySQL 1.x (and earlier) alongside 2.x -- they have different group/artifact coordinates and different namespaces so you can use them together and even require both into the same ns (under different aliases) so you can migrate one query at a time if you want."><y>#</y><d>2022-04-05</d><h>21:15</h><w>seancorfield</w>Note that, to aid migration, you can use both HoneySQL 1.x (and earlier) alongside 2.x -- they have different group/artifact coordinates and different namespaces so you can use them together and even require both into the same ns (under different aliases) so you can migrate one query at a time if you want.</z><z id="t1649198958" t="john-shaffer Is there any syntax for ARRAY() (as opposed to ARRAY[] )? {:select [[[(keyword &quot;array &quot;) {:select :* ,,,}] :alias]]} is the best I&apos;ve found"><y>#</y><d>2022-04-05</d><h>22:49</h><w>john-shaffer</w>Is there any syntax for <code>ARRAY()</code> (as opposed to <code>ARRAY[]</code>)? <code>{:select [[[(keyword &quot;array &quot;) {:select :* ,,,}] :alias]]}</code> is the best I&apos;ve found</z><z id="t1649199556" t="seancorfield [:attrs {:href &quot;/_/_/users/UQ5EVP2LW&quot;}] Which database are you working with?"><y>#</y><d>2022-04-05</d><h>22:59</h><w>seancorfield</w><a>@jshaffer2112</a> Which database are you working with?</z><z id="t1649200114" t="seancorfield Not sure if this is better or worse? dev=&gt; (sql/format {:select [[[:&apos;ARRAY {:select :* :from :foo}] :bar]]}) [&quot;SELECT ARRAY (SELECT * FROM foo) AS bar&quot;] The quoted in the keyword means &quot;render as-is&quot; so it circumvents the built-in :array behavior."><y>#</y><d>2022-04-05</d><h>23:08</h><w>seancorfield</w>Not sure if this is better or worse?
<pre>dev=&gt; (sql/format {:select [[[:&apos;ARRAY {:select :* :from :foo}] :bar]]})
[&quot;SELECT ARRAY (SELECT * FROM foo) AS bar&quot;]</pre>
The quoted in the keyword means &quot;render as-is&quot; so it circumvents the built-in <code>:array</code> behavior.</z><z id="t1649200932" t="john-shaffer postgres That is better, thanks"><y>#</y><d>2022-04-05</d><h>23:22</h><w>john-shaffer</w>postgres
That is better, thanks</z><z id="t1649203161" t="seancorfield Given that [:array ...] is already special syntax to support PG&apos;s ARRAY[..] , there&apos;s no obvious way to signify an ARRAY() function -- and I suspect the ARRAY[..] syntax is a lot more common? I looked online and couldn&apos;t find PG docs for SELECT ARRAY( SELECT .. ) .. -- do you have a link?"><y>#</y><d>2022-04-05</d><h>23:59</h><w>seancorfield</w>Given that <code>[:array ...]</code> is already special syntax to support PG&apos;s <code>ARRAY[..]</code>, there&apos;s no obvious way to signify an <code>ARRAY()</code> function -- and I suspect the <code>ARRAY[..]</code> syntax is a lot more common? I looked online and couldn&apos;t find PG docs for <code>SELECT ARRAY( SELECT .. ) ..</code> -- do you have a link?</z><z id="t1649203257" t="seancorfield NM, finally found it on this page: https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS"><y>#</y><d>2022-04-06</d><h>00:00</h><w>seancorfield</w>NM, finally found it on this page: <a href="https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS" target="_blank">https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS</a></z><z id="t1649203280" t="seancorfield It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word ARRAY followed by a parenthesized (not bracketed) subquery. For example: SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE &apos;bytea%&apos;);"><y>#</y><d>2022-04-06</d><h>00:01</h><w>seancorfield</w>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word ARRAY followed by a parenthesized (not bracketed) subquery. For example:
<pre>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE &apos;bytea%&apos;);</pre></z><z id="t1649203410" t="seancorfield https://github.com/seancorfield/honeysql/issues/404"><y>#</y><d>2022-04-06</d><h>00:03</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/404" target="_blank">https://github.com/seancorfield/honeysql/issues/404</a></z><z id="t1649693841" t="dev-hartmann hey folks"><y>#</y><d>2022-04-11</d><h>16:17</h><w>dev-hartmann</w>hey folks</z><z id="t1649693870" t="dev-hartmann I have an issue with a query of mine returning a org.postgresql.util.PGobject"><y>#</y><d>2022-04-11</d><h>16:17</h><w>dev-hartmann</w>I have an issue with a query of mine returning a <code>org.postgresql.util.PGobject</code></z><z id="t1649693887" t="dev-hartmann i have a one to many relation"><y>#</y><d>2022-04-11</d><h>16:18</h><w>dev-hartmann</w>i have a one to many relation</z><z id="t1649693890" t="dev-hartmann like this"><y>#</y><d>2022-04-11</d><h>16:18</h><w>dev-hartmann</w>like this</z><z id="t1649693903" t="dev-hartmann customer &lt;- order"><y>#</y><d>2022-04-11</d><h>16:18</h><w>dev-hartmann</w>customer &lt;- order</z><z id="t1649693913" t="dev-hartmann my honeysql query looks like this"><y>#</y><d>2022-04-11</d><h>16:18</h><w>dev-hartmann</w>my honeysql query looks like this</z><z id="t1649693988" t="dev-hartmann (-&gt; (hh/select-distinct :customer :order) (hh/from :customer) (hh/left-join [:order] [:= :customer.id :order.customer_id]) (hh/where [:= :customer.id :?id]) (sql/format {:params {:id id}}))"><y>#</y><d>2022-04-11</d><h>16:19</h><w>dev-hartmann</w><pre>(-&gt; (hh/select-distinct :customer :order)
    (hh/from :customer)
    (hh/left-join [:order] [:= :customer.id :order.customer_id])
    (hh/where [:= :customer.id :?id])
    (sql/format {:params {:id id}}))</pre></z><z id="t1649693998" t="dev-hartmann the resulting sql query:"><y>#</y><d>2022-04-11</d><h>16:19</h><w>dev-hartmann</w>the resulting sql query:</z><z id="t1649694053" t="dev-hartmann &quot;SELECT DISTINCT customer, order FROM customer LEFT JOIN order ON customer.id = order.customer_id WHERE customer.id = ?&quot;"><y>#</y><d>2022-04-11</d><h>16:20</h><w>dev-hartmann</w><pre>&quot;SELECT DISTINCT customer, order FROM customer LEFT JOIN order ON customer.id = order.customer_id WHERE customer.id = ?&quot;</pre></z><z id="t1649694229" t="dev-hartmann this being the result when evaluated in the REPL"><y>#</y><d>2022-04-11</d><h>16:23</h><w>dev-hartmann</w>this being the result when evaluated in the REPL</z><z id="t1649694233" t="dev-hartmann [{:customer #object[org.postgresql.util.PGobject 0x15feceb3 &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;], :order #object[org.postgresql.util.PGobject 0x680eec30 &quot;(1,1,\&quot;test order 1\&quot;)&quot;]} {:customer #object[org.postgresql.util.PGobject 0x701081a7 &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;], :order #object[org.postgresql.util.PGobject 0x13f2d1a6 &quot;(2,1,\&quot;test order 2\&quot;)&quot;]} {:customer #object[org.postgresql.util.PGobject 0x65c70b0b &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;], :order #object[org.postgresql.util.PGobject 0x51f2659f &quot;(4,1,\&quot;test order 4\)&quot;]}]"><y>#</y><d>2022-04-11</d><h>16:23</h><w>dev-hartmann</w><pre>[{:customer #object[org.postgresql.util.PGobject 0x15feceb3 &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;],
  :order #object[org.postgresql.util.PGobject 0x680eec30 &quot;(1,1,\&quot;test order 1\&quot;)&quot;]}
 {:customer #object[org.postgresql.util.PGobject 0x701081a7 &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;],
  :order #object[org.postgresql.util.PGobject 0x13f2d1a6 &quot;(2,1,\&quot;test order 2\&quot;)&quot;]}
 {:customer #object[org.postgresql.util.PGobject 0x65c70b0b &quot;(1,\&quot;test customer\&quot;,\&quot;jerry)&quot;],
  :order #object[org.postgresql.util.PGobject 0x51f2659f &quot;(4,1,\&quot;test order 4\)&quot;]}]</pre></z><z id="t1649694320" t="dev-hartmann what I obiously want to do is create a map from that like {:id 1 :desc &quot;test customer&quot; :name &quot;jerry :tasks [{....} {....]}"><y>#</y><d>2022-04-11</d><h>16:25</h><w>dev-hartmann</w>what I obiously want to do is create a map from that like <code>{:id 1 :desc &quot;test customer&quot; :name &quot;jerry :tasks [{....} {....]}</code></z><z id="t1649694327" t="dev-hartmann but I have no clue how to do that"><y>#</y><d>2022-04-11</d><h>16:25</h><w>dev-hartmann</w>but I have no clue how to do that</z><z id="t1649694333" t="dev-hartmann anyone able to help?"><y>#</y><d>2022-04-11</d><h>16:25</h><w>dev-hartmann</w>anyone able to help?</z><z id="t1649694383" t="dev-hartmann especially how to deal with the pgobject"><y>#</y><d>2022-04-11</d><h>16:26</h><w>dev-hartmann</w>especially how to deal with the pgobject</z><z id="t1649701808" t="dev-hartmann Nevermind folks, found the answer with changing my query‘ select section "><y>#</y><d>2022-04-11</d><h>18:30</h><w>dev-hartmann</w>Nevermind folks, found the answer with changing my query‘ select section </z><z id="t1650617673" t="Serafeim Papastefanos hey friends! i&apos;m reading the readme of the project and see this example code (def sqlmap {:select [:a :b :c] :from [:foo] :where [:= :f.a &quot;baz&quot;]}) I can&apos;t understand what&apos;s :f in the where clause. is this a typo ?"><y>#</y><d>2022-04-22</d><h>08:54</h><w>Serafeim Papastefanos</w>hey friends! i&apos;m reading the readme of the project and see this example code
<pre>(def sqlmap {:select [:a :b :c]
             :from   [:foo]
             :where  [:= :f.a &quot;baz&quot;]})</pre>
I can&apos;t understand what&apos;s <code>:f</code> in the where clause. is this a typo ?</z><z id="t1650618095" t="pavlosmelissinos It translates to [&quot;SELECT a, b, c FROM foo WHERE f.a = ?&quot; &quot;baz&quot;] f could be an alias of foo but the purpose of the example is to showcase the syntax. Does it really matter whether the query itself is correct or not?"><y>#</y><d>2022-04-22</d><h>09:01</h><r>pavlosmelissinos</r>It translates to <code>[&quot;SELECT a, b, c FROM foo WHERE f.a = ?&quot; &quot;baz&quot;]</code>

<code>f</code> could be an alias of <code>foo</code> but the purpose of the example is to showcase the syntax. Does it really matter whether the query itself is correct or not?</z></g><g id="s6"><z id="t1650618178" t="Serafeim Papastefanos Yes it matters because it confuses people not familiar with the tool. It confused me"><y>#</y><d>2022-04-22</d><h>09:02</h><r>Serafeim Papastefanos</r>Yes it matters because it confuses people not familiar with the tool. It confused me</z><z id="t1650618260" t="Serafeim Papastefanos I guess the correct query would be :from [:foo :f] ?"><y>#</y><d>2022-04-22</d><h>09:04</h><r>Serafeim Papastefanos</r>I guess the correct query would be :from [:foo :f] ?</z><z id="t1650618290" t="pavlosmelissinos yes"><y>#</y><d>2022-04-22</d><h>09:04</h><r>pavlosmelissinos</r>yes</z><z id="t1650618297" t="Serafeim Papastefanos Cool thank you"><y>#</y><d>2022-04-22</d><h>09:04</h><r>Serafeim Papastefanos</r>Cool thank you</z><z id="t1650618535" t="pavlosmelissinos &quot;correct&quot; as in standalone f could be the name/alias of another table that is defined in an earlier part of the query (in which case the original query isn&apos;t necessarily incorrect)"><y>#</y><d>2022-04-22</d><h>09:08</h><r>pavlosmelissinos</r>&quot;correct&quot; as in standalone

<code>f</code> could be the name/alias of another table that is defined in an earlier part of the query (in which case the original query isn&apos;t necessarily incorrect)</z><z id="t1650639928" t="seancorfield Mostly that stuff came from tests originally where the SQL didn&apos;t have to be valid but I can clean up the examples. Feel free to create a GitHub issue to remind me."><y>#</y><d>2022-04-22</d><h>15:05</h><r>seancorfield</r>Mostly that stuff came from tests originally where the SQL didn&apos;t have to be valid but I can clean up the examples. Feel free to create a GitHub issue to remind me.</z><z id="t1650756306" t="seancorfield I&apos;ve updated the README to use foo.a instead of f.a to avoid that confusion. That will get into cljdoc in the next release (I updated the README after making the 2.2.891 release, sorry)."><y>#</y><d>2022-04-23</d><h>23:25</h><r>seancorfield</r>I&apos;ve updated the README to use <code>foo.a</code> instead of <code>f.a</code> to avoid that confusion. That will get into cljdoc in the next release (I updated the README after making the 2.2.891 release, sorry).</z><z id="t1650756046" t="seancorfield TL;DR: improved PostgreSQL support, bug fixes, documentation improvements!"><y>#</y><d>2022-04-23</d><h>23:20</h><w>seancorfield</w>TL;DR: improved PostgreSQL support, bug fixes, documentation improvements!</z><z id="t1651004144" t="jdf hi. is there a reason why a query like this [{:select [[:stp.site_trial_id :site_trial_id] [#sql/call [:max :stp.created_at] :latest_activity_at]], :from [[:SiteTrialPatientView :stp]], :join [[:SiteTrialRead :st] [:= :st.id :stp.site_trial_id]], :where [:and [:in :stp.site_trial_id #sql/param :site-trial-ids] [:&lt;&gt; :st.sponsor_trial_id nil] [:in :stp.stage [#object[org.postgresql.util.PGobject 0x3634ec9f &quot;potential-candidate&quot;] #object[org.postgresql.util.PGobject 0x73918461 &quot;completed&quot;] #object[org.postgresql.util.PGobject 0xb808f9e &quot;enrolled&quot;] #object[org.postgresql.util.PGobject 0x3ca4bc49 &quot;pre-screen-failure&quot;] #object[org.postgresql.util.PGobject 0x2de5ef56 &quot;screen-failure&quot;] #object[org.postgresql.util.PGobject 0x5228c407 &quot;first-visit-scheduled&quot;] #object[org.postgresql.util.PGobject 0x5d5b5da3 &quot;in-screening&quot;] #object[org.postgresql.util.PGobject 0x4484e4b5 &quot;discontinued&quot;] #object[org.postgresql.util.PGobject 0x46993c2c &quot;pre-screening&quot;]]]]}] is returning the following error java.lang.AssertionError: Assert failed: Alias should have two parts . which alias is it referring to? the one in the select?"><y>#</y><d>2022-04-26</d><h>20:15</h><w>jdf</w>hi. is there a reason why a query like this
<pre>[{:select [[:stp.site_trial_id :site_trial_id] [#sql/call [:max :stp.created_at] :latest_activity_at]],
:from [[:SiteTrialPatientView :stp]],
:join [[:SiteTrialRead :st] [:= :st.id :stp.site_trial_id]],
:where [:and [:in :stp.site_trial_id #sql/param :site-trial-ids] [:&lt;&gt; :st.sponsor_trial_id nil] [:in :stp.stage [#object[org.postgresql.util.PGobject 0x3634ec9f &quot;potential-candidate&quot;] #object[org.postgresql.util.PGobject 0x73918461 &quot;completed&quot;] #object[org.postgresql.util.PGobject 0xb808f9e &quot;enrolled&quot;] #object[org.postgresql.util.PGobject 0x3ca4bc49 &quot;pre-screen-failure&quot;] #object[org.postgresql.util.PGobject 0x2de5ef56 &quot;screen-failure&quot;] #object[org.postgresql.util.PGobject 0x5228c407 &quot;first-visit-scheduled&quot;] #object[org.postgresql.util.PGobject 0x5d5b5da3 &quot;in-screening&quot;] #object[org.postgresql.util.PGobject 0x4484e4b5 &quot;discontinued&quot;] #object[org.postgresql.util.PGobject 0x46993c2c &quot;pre-screening&quot;]]]]}]</pre>
is returning the following error <code>java.lang.AssertionError: Assert failed: Alias should have two parts</code> . which alias is it referring to? the one in the select?</z><z id="t1651004911" t="seancorfield That&apos;s HoneySQL 1.x?"><y>#</y><d>2022-04-26</d><h>20:28</h><r>seancorfield</r>That&apos;s HoneySQL 1.x?</z><z id="t1651005016" t="seancorfield Is that the whole query (data structure)? There seems to be a [ ..`]` around the {:select ..} -- is that intentional?"><y>#</y><d>2022-04-26</d><h>20:30</h><r>seancorfield</r>Is that the whole query (data structure)? There seems to be a <code>[</code>..`]` around the <code>{:select ..}</code> -- is that intentional?</z><z id="t1651006088" t="jorda0mega Yeah that&apos;s the data structure returned from sql/format"><y>#</y><d>2022-04-26</d><h>20:48</h><r>jorda0mega</r>Yeah that&apos;s the data structure returned from <code>sql/format</code></z><z id="t1651006153" t="jorda0mega Let me paste the original query "><y>#</y><d>2022-04-26</d><h>20:49</h><r>jorda0mega</r>Let me paste the original query </z><z id="t1651011315" t="seancorfield sql/format should return a vector with a SQL string followed by the various parameters which that isn&apos;t... the hash map looks like what I&apos;d expect you to pass in to sql/format but the vector around it seems odd."><y>#</y><d>2022-04-26</d><h>22:15</h><r>seancorfield</r><code>sql/format</code> should return a vector with a SQL string followed by the various parameters which that isn&apos;t... the hash map looks like what I&apos;d expect you to pass in to <code>sql/format</code> but the vector around it seems odd.</z><z id="t1651256480" t="jdf I ended up figuring out what it was (in case someone else runs into the same issue). I was defining a sql/param as such :where [:in (sql/param :site-trials)] where instead I just needed to pass the clojure seq :where [:in site-trials]"><y>#</y><d>2022-04-29</d><h>18:21</h><r>jdf</r>I ended up figuring out what it was (in case someone else runs into the same issue). I was defining a <code>sql/param</code> as such  <code>:where [:in (sql/param :site-trials)]</code> where instead I just needed to pass the clojure seq <code>:where [:in site-trials]</code></z><z id="t1651497093" t="andersmurphy Just published a blog post on adding support for alter column and add constraint . Seems like postgresql doesn’t support modify column unless I’m missing something. Anyway, just wanted to check I wasn’t missing any obvious existing support for these to clauses. Cheers. https://andersmurphy.com/2022/05/02/clojure-extend-honeysql-to-support-postgres-alter-column-and-add-constraint.html"><y>#</y><d>2022-05-02</d><h>13:11</h><w>andersmurphy</w>Just published a blog post on adding support for <code>alter column</code>  and <code>add constraint</code> . Seems like postgresql doesn’t support <code>modify column</code>  unless I’m missing something. Anyway, just wanted to check I wasn’t missing any obvious existing support for these to clauses. Cheers.

<a href="https://andersmurphy.com/2022/05/02/clojure-extend-honeysql-to-support-postgres-alter-column-and-add-constraint.html" target="_blank">https://andersmurphy.com/2022/05/02/clojure-extend-honeysql-to-support-postgres-alter-column-and-add-constraint.html</a></z><z id="t1651497228" t="andersmurphy I appreciate these clauses are only uses when when writing migrations (so not that common), but we write our migrations in honeysql. 😃"><y>#</y><d>2022-05-02</d><h>13:13</h><w>andersmurphy</w>I appreciate these clauses are only uses when when writing migrations (so not that common), but we write our migrations in honeysql.  <b>😃</b></z><z id="t1651505353" t="seancorfield Ah, it seems modify column is actually MySQL only and alter column is the ANSI/other version. I&apos;ll create a GH issue and fix that."><y>#</y><d>2022-05-02</d><h>15:29</h><w>seancorfield</w>Ah, it seems <code>modify column</code> is actually MySQL only and <code>alter column</code> is the ANSI/other version. I&apos;ll create a GH issue and fix that.</z><z id="t1651505479" t="seancorfield [:attrs {:href &quot;/_/_/users/U0JEEGD4N&quot;}] https://github.com/seancorfield/honeysql/issues/406"><y>#</y><d>2022-05-02</d><h>15:31</h><w>seancorfield</w><a>@andersmurphy</a> <a href="https://github.com/seancorfield/honeysql/issues/406" target="_blank">https://github.com/seancorfield/honeysql/issues/406</a></z><z id="t1651511360" t="andersmurphy [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Thanks! That makes sense. I assumed it was postgres being different to ANSI. But you are right it’s MySQL that’s different in this case. I’ll update the blog post to reference the ticket (not that I get much traffic it’s mainly personal reference material for when I forget how to do things). Thanks for sharing the issue. I’ve been diving into the internals of honeysql so I’m curious to see what this sort of change would involve. One thing I did notice is that modify column supports changing constraints where as alter column does not, you need to use drop constraint / add constraint as far as I can tell."><y>#</y><d>2022-05-02</d><h>17:09</h><w>andersmurphy</w><a>@seancorfield</a> Thanks! That makes sense. I assumed it was postgres being different to ANSI. But you are right it’s MySQL that’s different in this case. I’ll update the blog post to reference the ticket (not that I get much traffic it’s mainly personal reference material for when I forget how to do things).

Thanks for sharing the issue. I’ve been diving into the internals of honeysql so I’m curious to see what this sort of change would involve. One thing I did notice is that <code>modify column</code> supports changing constraints where as <code>alter column</code> does not, you need to use <code>drop constraint</code> / <code>add constraint</code> as far as I can tell.</z><z id="t1651511577" t="seancorfield There&apos;s a ticket for standalone add index I believe but not yet constraint and not within the ... column stuff. DDL is a bit of a &quot;wild west&quot; so adding support for it is a giant PITA quite often."><y>#</y><d>2022-05-02</d><h>17:12</h><w>seancorfield</w>There&apos;s a ticket for standalone <code>add index</code> I believe but not yet <code>constraint</code> and not within the <code>... column</code> stuff. DDL is a bit of a &quot;wild west&quot; so adding support for it is a giant PITA quite often.</z><z id="t1651511600" t="seancorfield Please create GH issues as needed around DDL support!"><y>#</y><d>2022-05-02</d><h>17:13</h><w>seancorfield</w>Please create GH issues as needed around DDL support!</z><z id="t1651609577" t="snoe Hi, is it possible to alias a clause with named columns? My closest attempt is this: (hsql/format {:select [:nums.tens :nums.ones] :from [[{:values [[1,10] [2,20]]} [:nums [:ones :tens]]]]}) =actual&gt; &quot;SELECT nums.tens, nums.ones FROM (VALUES (1, 10), (2, 20)) nums ones tens&quot; =desire&gt; &quot;SELECT nums.tens, nums.ones FROM (VALUES (1, 10), (2, 20)) nums(ones, tens)&quot;"><y>#</y><d>2022-05-03</d><h>20:26</h><w>snoe</w>Hi, is it possible to alias a clause with named columns? My closest attempt is this:
<pre>(hsql/format {:select [:nums.tens :nums.ones]
              :from [[{:values [[1,10] [2,20]]} [:nums [:ones :tens]]]]})
=actual&gt; &quot;SELECT nums.tens, nums.ones FROM (VALUES (1, 10), (2, 20)) nums ones tens&quot;
=desire&gt; &quot;SELECT nums.tens, nums.ones FROM (VALUES (1, 10), (2, 20)) nums(ones, tens)&quot;</pre></z><z id="t1651614180" t="seancorfield Is this what you&apos;re trying to achieve? dev=&gt; (hsql/format {:select [:nums.tens :nums.ones] #_=&gt; :from [[{:values [[1,10] [2,20]]} [:nums [:composite :ones :tens]]]]}) [&quot;SELECT nums.tens, nums.ones FROM (VALUES (?, ?), (?, ?)) AS nums (ones, tens)&quot; 1 10 2 20]"><y>#</y><d>2022-05-03</d><h>21:43</h><r>seancorfield</r>Is this what you&apos;re trying to achieve?
<pre>dev=&gt; (hsql/format {:select [:nums.tens :nums.ones]
 #_=&gt;               :from [[{:values [[1,10] [2,20]]} [:nums [:composite :ones :tens]]]]})
[&quot;SELECT nums.tens, nums.ones FROM (VALUES (?, ?), (?, ?)) AS nums (ones, tens)&quot; 1 10 2 20]</pre></z><z id="t1651614232" t="seancorfield (HoneySQL 2.x -- :composite does not exist in 1.x I don&apos;t think)"><y>#</y><d>2022-05-03</d><h>21:43</h><r>seancorfield</r>(HoneySQL 2.x -- <code>:composite</code> does not exist in 1.x I don&apos;t think)</z><z id="t1651614246" t="snoe ah, perfect, thank you"><y>#</y><d>2022-05-03</d><h>21:44</h><r>snoe</r>ah, perfect, thank you</z><z id="t1651614279" t="snoe we&apos;re still on 1.x but maybe i can backport in our code"><y>#</y><d>2022-05-03</d><h>21:44</h><r>snoe</r>we&apos;re still on 1.x but maybe i can backport in our code</z><z id="t1651614605" t="seancorfield You can use 2.x and 1.x side-by-side, even in the same namespace, so you could add 2.x and use it just for this one query 🙂"><y>#</y><d>2022-05-03</d><h>21:50</h><r>seancorfield</r>You can use 2.x and 1.x side-by-side, even in the same namespace, so you could add 2.x and use it just for this one query <b>🙂</b></z><z id="t1651614635" t="seancorfield We are using a mix of 1.x and 2.x at work so we can migrate one query at a time if we need to."><y>#</y><d>2022-05-03</d><h>21:50</h><r>seancorfield</r>We are using a mix of 1.x and 2.x at work so we can migrate one query at a time if we need to.</z><z id="t1651688305" t="jdf hi. I have a function that constructs a query as follows {:select [[:st.id :site_trial_id] [(sql/call :max :pce.created_at) :last_activity_at]] :from [[:SiteTrialView :st]] :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id] [:change_event.SiteTrialPatientAttributeChangeEvent :pace] [:= :pace.site_trial_patient_id :stp.id] [:change_event.PatientChangeEvent :pce] [:= :pace.change_event_id :pce.id]] :where [:in :st.id (sql/param :site-trial-ids)] :group-by [:st.id]} {:site-trial-ids (remove nil? site-trial-ids)} and I’m passing it a list of uuids. The function appears to be called multiple times and during one of those calls it is inserting a nil which breaks the query. Is there a way to remove nils from this collection at the time of query evaluation? When I look at the query that’s being evaluated I see this list of parameters (notice the nil) &quot;6ff7d3d3-fefe-5e58-8733-d235593c96dd&quot; #uuid &quot;25ffa790-6175-5988-842c-ccf42d6f2562&quot; #uuid &quot;240d1ac7-d382-54e4-a3fe-f62ee8f3d5f1&quot; nil #uuid &quot;488f3fb6-00ec-528f-9de6-373549ff4edf&quot; "><y>#</y><d>2022-05-04</d><h>18:18</h><w>jdf</w>hi. I have a function that constructs a query as follows
<pre>{:select [[:st.id :site_trial_id] [(sql/call :max :pce.created_at) :last_activity_at]]
                      :from [[:SiteTrialView :st]]
                      :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id]
                             [:change_event.SiteTrialPatientAttributeChangeEvent :pace] [:= :pace.site_trial_patient_id :stp.id]
                             [:change_event.PatientChangeEvent :pce] [:= :pace.change_event_id :pce.id]]
                      :where [:in :st.id (sql/param :site-trial-ids)]
                      :group-by [:st.id]}
   {:site-trial-ids (remove nil? site-trial-ids)}</pre>
and I’m passing it a list of uuids. The function appears to be called multiple times and during one of those calls it is inserting a <code>nil</code> which breaks the query. Is there a way to remove nils from this collection at the time of query evaluation? When I look at the query that’s being evaluated I see this list of parameters (notice the nil)
<pre>&quot;6ff7d3d3-fefe-5e58-8733-d235593c96dd&quot; #uuid &quot;25ffa790-6175-5988-842c-ccf42d6f2562&quot; #uuid &quot;240d1ac7-d382-54e4-a3fe-f62ee8f3d5f1&quot; nil #uuid &quot;488f3fb6-00ec-528f-9de6-373549ff4edf&quot; </pre></z><z id="t1651690673" t="seancorfield Given that you&apos;re removing the nil s from site-trial-ids , how is nil getting into the query?"><y>#</y><d>2022-05-04</d><h>18:57</h><r>seancorfield</r>Given that you&apos;re removing the <code>nil</code>s from <code>site-trial-ids</code>, how is <code>nil</code> getting into the query?</z><z id="t1651690852" t="jdf no idea honestly. the (remove nil... seems to have no effect on the collection being passed in"><y>#</y><d>2022-05-04</d><h>19:00</h><r>jdf</r>no idea honestly. the <code>(remove nil...</code> seems to have no effect on the collection being passed in</z><z id="t1651690881" t="seancorfield (HoneySQL 2.x has a :checking :strict mode that would throw an exception here which at least prevent the incorrect query from running)"><y>#</y><d>2022-05-04</d><h>19:01</h><r>seancorfield</r>(HoneySQL 2.x has a <code>:checking :strict</code> mode that would throw an exception here which at least prevent the incorrect query from running)</z><z id="t1651690967" t="jdf do you know where I can find an example of that?"><y>#</y><d>2022-05-04</d><h>19:02</h><r>jdf</r>do you know where I can find an example of that?</z><z id="t1651691022" t="seancorfield HoneySQL 2.x: dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids [1 2 3 nil 4 5]}}) [&quot;WHERE id IN (?, ?, ?, ?, ?, ?)&quot; 1 2 3 nil 4 5] dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids [1 2 3 nil 4 5]} :checking :strict}) Execution error (ExceptionInfo) at honey.sql/format-in (sql.cljc:1122). IN (NULL) does not match dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids (remove nil? [1 2 3 nil 4 5])} :checking :strict}) [&quot;WHERE id IN (?, ?, ?, ?, ?)&quot; 1 2 3 4 5] If you can create a repro case for HoneySQL 1.x, with that remove nil? in place, I can take a look but I&apos;m a bit skeptical... 🙂"><y>#</y><d>2022-05-04</d><h>19:03</h><r>seancorfield</r>HoneySQL 2.x:
<pre>dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids [1 2 3 nil 4 5]}})
[&quot;WHERE id IN (?, ?, ?, ?, ?, ?)&quot; 1 2 3 nil 4 5]
dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids [1 2 3 nil 4 5]} :checking :strict})
Execution error (ExceptionInfo) at honey.sql/format-in (sql.cljc:1122).
IN (NULL) does not match
dev=&gt; (hsql/format {:where [:in :id :?ids]} {:params {:ids (remove nil? [1 2 3 nil 4 5])} :checking :strict})
[&quot;WHERE id IN (?, ?, ?, ?, ?)&quot; 1 2 3 4 5]</pre>
If you can create a repro case for HoneySQL 1.x, with that <code>remove nil?</code> in place, I can take a look but I&apos;m a bit skeptical... <b>🙂</b></z><z id="t1651691073" t="jdf what’s weird is that I’m tapping the collection and there are no nils in it so there has to be something else going on"><y>#</y><d>2022-05-04</d><h>19:04</h><r>jdf</r>what’s weird is that I’m tapping the collection and there are no nils in it so there has to be something else going on</z><z id="t1651691111" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started#format-options explains :checking"><y>#</y><d>2022-05-04</d><h>19:05</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started#format-options" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started#format-options</a> explains <code>:checking</code></z><z id="t1651694085" t="jdf so I think I found the issue and it has to do with the format function. when calling (sql/format q :quoting :ansi :allow-dashed-names? true :allow-namespaced-names? true :params (or params {})) I’m getting duplicate params passed in. The params object looks as follows and yet the formatted query has duplicates and a nil"><y>#</y><d>2022-05-04</d><h>19:54</h><r>jdf</r>so I think I found the issue and it has to do with the format function. when calling <code>(sql/format q :quoting :ansi :allow-dashed-names? true :allow-namespaced-names? true :params (or params {}))</code> I’m getting duplicate params passed in. The params object looks as follows and yet the formatted query has duplicates and a nil</z><z id="t1651694236" t="seancorfield If you can create a small, self-contained repro, feel free to open an issue on GH -- but my recommendation would be to migrate at least that query to use HoneySQL 2.x at this point (you can add both 1.x and 2.x as dependencies since they have different coordinates and you can use both 1.x and 2.x in the same ns because they have different namespaces -- no conflicts)."><y>#</y><d>2022-05-04</d><h>19:57</h><r>seancorfield</r>If you can create a small, self-contained repro, feel free to open an issue on GH -- but my recommendation would be to migrate at least that query to use HoneySQL 2.x at this point (you can add both 1.x and 2.x as dependencies since they have different coordinates and you can use both 1.x and 2.x in the same <code>ns</code> because they have different namespaces -- no conflicts).</z><z id="t1651694306" t="jdf ah ok. let me see if I get the approval from the team (some of the data is sensitive so I have to double check). thank you for the quick replies"><y>#</y><d>2022-05-04</d><h>19:58</h><r>jdf</r>ah ok. let me see if I get the approval from the team (some of the data is sensitive so I have to double check). thank you for the quick replies</z><z id="t1651695963" t="seancorfield At this point, HoneySQL 1.x is &quot;legacy&quot; and is only likely to get important security fixes (or, perhaps, occasionally a fix for a genuine showstopping bug). All work has been focused on 2.x for a long time now. It removes a lot of the warts in 1.x and provides much better PostgreSQL support -- and I&apos;m continually enhancing it. It also has much better documentation (and better test coverage)."><y>#</y><d>2022-05-04</d><h>20:26</h><r>seancorfield</r>At this point, HoneySQL 1.x is &quot;legacy&quot; and is only likely to get important security fixes (or, perhaps, occasionally a fix for a genuine showstopping bug). All work has been focused on 2.x for a long time now. It removes a lot of the warts in 1.x and provides much better PostgreSQL support -- and I&apos;m continually enhancing it. It also has much better documentation (and better test coverage).</z><z id="t1651699076" t="jdf looks like they’ll be a discussion to see if we adopt v2. In the meantime, is there a way to indicate that a parameter refers to a specific item in the map of params? I have a union of selects like so {:select [[:st.id :site_trial_id] [(sql/call :max :stp.acknowledged_at) :last_activity_at]] :from [[:SiteTrialView :st]] :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id]] :where [:in :st.id (sql/param site-trial-ids)] :group-by [:st.id]} {:select [[:st.id :site_trial_id] [(sql/call :max :pce.created_at) :last_activity_at]] :from [[:SiteTrialView :st]] :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id] [:change_event.SiteTrialPatientAttributeChangeEvent :pace] [:= :pace.site_trial_patient_id :stp.id] [:change_event.PatientChangeEvent :pce] [:= :pace.change_event_id :pce.id]] :where [:in :st.id (sql/param :site-trial-ids)] but the param should be the same one in each where clause. I think what’s happening is that sql/format repeats the sequence site-trial-ids so it can reference params by position. And in doing so it introduces a nil somewhere. The formatted query has multiple ? s and each one of those refers to an item in site-trial-ids"><y>#</y><d>2022-05-04</d><h>21:17</h><r>jdf</r>looks like they’ll be a discussion to see if we adopt v2. In the meantime, is there a way to indicate that a parameter refers to a specific item in the map of params? I have a union of selects like so
<pre>{:select [[:st.id :site_trial_id] [(sql/call :max :stp.acknowledged_at) :last_activity_at]]
                                 :from [[:SiteTrialView :st]]
                                 :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id]]
                                 :where [:in :st.id (sql/param site-trial-ids)]
                                 :group-by [:st.id]}
                                {:select [[:st.id :site_trial_id] [(sql/call :max :pce.created_at) :last_activity_at]]
                                 :from [[:SiteTrialView :st]]
                                 :join [[:SiteTrialPatientView :stp] [:= :st.id :stp.site_trial_id]
                                        [:change_event.SiteTrialPatientAttributeChangeEvent :pace] [:= :pace.site_trial_patient_id :stp.id]
                                        [:change_event.PatientChangeEvent :pce] [:= :pace.change_event_id :pce.id]]
                                 :where [:in :st.id (sql/param :site-trial-ids)]</pre>
but the param should be the same one in each where clause. I think what’s happening is that sql/format repeats the sequence <code>site-trial-ids</code> so it can reference params by position. And in doing so it introduces a nil somewhere. The formatted query has multiple <code>?</code>s and each one of those refers to an item in <code>site-trial-ids</code></z><z id="t1651699306" t="seancorfield In 1.x, there is a parameterizer that uses numbered placeholders instead of ? which might do what you want but I suspect it will also repeat the sequence. I&apos;m thinking about how to add that to 2.x because the Node.js PostgreSQL library doesn&apos;t support ? (which seems dumb to me!) and I might look at some option to coalesce named parameters in that case."><y>#</y><d>2022-05-04</d><h>21:21</h><r>seancorfield</r>In 1.x, there is a parameterizer that uses numbered placeholders instead of <code>?</code> which might do what you want but I suspect it will also repeat the sequence. I&apos;m thinking about how to add that to 2.x because the Node.js PostgreSQL library doesn&apos;t support <code>?</code> (which seems dumb to me!) and I might look at some option to coalesce named parameters in that case.</z><z id="t1651959006" t="vlad_poh I’d avoided honeysql and korma for years but playing with datalog rules prompted me to take another look. It&apos;s amazing! 2 questions how do I do subqueries and how do i call a function on an aliased column? Neither :% http://max.c.id nor :%max: http://c.id works"><y>#</y><d>2022-05-07</d><h>21:30</h><w>vlad_poh</w>I’d avoided honeysql and korma for years but playing with datalog rules prompted me to take another look. It&apos;s amazing! 2 questions how do I do subqueries and how do i call a function on an aliased column? Neither :%<a href="http://max.c.id" target="_blank">http://max.c.id</a> nor :%max:<a href="http://c.id" target="_blank">http://c.id</a> works</z><z id="t1651959529" t="seancorfield You can&apos;t use the shorthand function call syntax on compound names. Do this instead: [:max :c.id]"><y>#</y><d>2022-05-07</d><h>21:38</h><w>seancorfield</w>You can&apos;t use the shorthand function call syntax on compound names. Do this instead: <code>[:max :c.id]</code></z><z id="t1651959666" t="seancorfield As for your other question, are you referring to something like this in the README? https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#nested-subqueries"><y>#</y><d>2022-05-07</d><h>21:41</h><w>seancorfield</w>As for your other question, are you referring to something like this in the README? <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#nested-subqueries" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#nested-subqueries</a></z><z id="t1651959724" t="seancorfield This section of the README should answer your other question about function calls: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#functions"><y>#</y><d>2022-05-07</d><h>21:42</h><w>seancorfield</w>This section of the README should answer your other question about function calls: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#functions" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#functions</a></z><z id="t1651959730" t="seancorfield [:attrs {:href &quot;/_/_/users/U06GMV0B0&quot;}] Does that help?"><y>#</y><d>2022-05-07</d><h>21:42</h><w>seancorfield</w><a>@kbosompem</a> Does that help?</z><z id="t1651961788" t="vlad_poh [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] perfect! Thanks "><y>#</y><d>2022-05-07</d><h>22:16</h><w>vlad_poh</w><a>@seancorfield</a> perfect! Thanks </z><z id="t1651977502" t="quan xing Dynamic generate columns and values for insert sql: (def data {:id &quot;123&quot; :parentid &quot;456&quot; :datacode &quot;HS-V100&quot;}) (keys data) ;; =&gt; (:id :parentid :datacode) (vals data) ;; =&gt; (&quot;123&quot; &quot;456&quot; &quot;HS-V100&quot;) (sql/format {:insert-into :corp_credit_dictdata :columns (keys data) :values [(vals data)]}) ;; =&gt; [&quot;INSERT INTO corp_credit_dictdata (id, parentid, datacode) VALUES (?, ?, ?)&quot; &quot;123&quot; &quot;456&quot; &quot;HS-V100&quot;] (keys data) return seq. the :columns needs vec. but I saw the output put sql is right am I doing the right thing? do I need covert seq to vec?"><y>#</y><d>2022-05-08</d><h>02:38</h><w>quan xing</w>Dynamic generate columns and values for insert sql:
<pre>(def data {:id &quot;123&quot; :parentid &quot;456&quot; :datacode &quot;HS-V100&quot;})
  (keys data) ;; =&gt; (:id :parentid :datacode)
  (vals data)  ;; =&gt; (&quot;123&quot; &quot;456&quot; &quot;HS-V100&quot;)
  (sql/format {:insert-into :corp_credit_dictdata
                        :columns (keys data)
                        :values [(vals data)]})
  ;; =&gt; [&quot;INSERT INTO corp_credit_dictdata (id, parentid, datacode) VALUES (?, ?, ?)&quot; &quot;123&quot; &quot;456&quot; &quot;HS-V100&quot;]</pre>
   (keys data) return seq.  the :columns needs vec.  but I saw the output put sql is right  am I doing the right thing?  do I need covert seq to vec?</z><z id="t1651980824" t="seancorfield Mostly, no, [:attrs {:href &quot;/_/_/users/U025AG2H55F&quot;}] -- HoneySQL is generally happy with anything sequential?"><y>#</y><d>2022-05-08</d><h>03:33</h><w>seancorfield</w>Mostly, no, <a>@imxingquan</a> -- HoneySQL is generally happy with anything <code>sequential?</code></z><z id="t1651981621" t="quan xing ok. It&apos;s very easy understand"><y>#</y><d>2022-05-08</d><h>03:47</h><w>quan xing</w>ok. It&apos;s very easy understand</z><z id="t1652212648" t="dcj For an upsert (using Postgres) :on-conflict I want to update every column/value specified in :values , and I do not understand what I should specify for :do-upset-set , can/should I just provide the same hashmap of column names and values that I used for :values ? Yes I (tried to) read https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference?q=do-update#on-conflict-on-constraint-do-nothing-do-update-set and https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert"><y>#</y><d>2022-05-10</d><h>19:57</h><w>dcj</w>For an upsert (using Postgres) <code>:on-conflict</code> I want to update every column/value specified in <code>:values</code> , and I do not understand what I should specify for <code>:do-upset-set</code>, can/should I just provide the same hashmap of column names and values that I used for <code>:values</code> ?  Yes I (tried to) read <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference?q=do-update#on-conflict-on-constraint-do-nothing-do-update-set" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/sql-clause-reference?q=do-update#on-conflict-on-constraint-do-nothing-do-update-set</a> and <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert</a></z><z id="t1652213509" t="seancorfield I don&apos;t use PostgreSQL but it sounds like the answer would be &quot;yes&quot; to that question?"><y>#</y><d>2022-05-10</d><h>20:11</h><w>seancorfield</w>I don&apos;t use PostgreSQL but it sounds like the answer would be &quot;yes&quot; to that question?</z><z id="t1652213531" t="seancorfield Unless there&apos;s some shorthand PostgreSQL uses for that?"><y>#</y><d>2022-05-10</d><h>20:12</h><w>seancorfield</w>Unless there&apos;s some shorthand PostgreSQL uses for that?</z><z id="t1652213632" t="seancorfield Maybe you just need the keys of that hash map? Based on this example in those docs: :do-update-set {:fields [:phone :name] :where [:= :user.active false]}"><y>#</y><d>2022-05-10</d><h>20:13</h><w>seancorfield</w>Maybe you just need the <code>keys</code> of that hash map? Based on this example in those docs:
<pre>:do-update-set {:fields [:phone :name]
                          :where  [:= :user.active false]}</pre></z><z id="t1652213675" t="seancorfield So :values [my-value-hash-map] ... :do-update-set {:fields (keys my-value-hash map)} ... Something like that?"><y>#</y><d>2022-05-10</d><h>20:14</h><w>seancorfield</w>So <code>:values [my-value-hash-map] ... :do-update-set {:fields (keys my-value-hash map)} ...</code> Something like that?</z><z id="t1652214225" t="dcj This seems like a good way to go, when I first read the docs I was like &quot;I don&apos;t want to list out all the :fields , but DUH, (keys my-value-hash-map) is obviously the easy way to do that! thanks3"><y>#</y><d>2022-05-10</d><h>20:23</h><r>dcj</r>This seems like a good way to go, when I first read the docs I was like &quot;I don&apos;t want to list out all the <code>:fields</code>, but DUH, <code>(keys my-value-hash-map)</code> is obviously the easy way to do that!  <b>thanks3</b></z><z id="t1652216231" t="seancorfield LMK if it actually works 🙂"><y>#</y><d>2022-05-10</d><h>20:57</h><r>seancorfield</r>LMK if it actually works <b>🙂</b></z><z id="t1652213722" t="seancorfield [:attrs {:href &quot;/_/_/users/U07TTE6RH&quot;}] Let me know what you figure out works in the end..."><y>#</y><d>2022-05-10</d><h>20:15</h><w>seancorfield</w><a>@dcj</a> Let me know what you figure out works in the end...</z><z id="t1652284581" t="vlad_poh Is it possible to convert the following mariadb query to honeysql select * from zone for system_time all y "><y>#</y><d>2022-05-11</d><h>15:56</h><w>vlad_poh</w>Is it possible to convert the following mariadb query to honeysql

<pre>select * from zone for system_time all y</pre>
</z><z id="t1652285448" t="seancorfield Well, yes, you could use :raw 🙂 Can you link to the docs for that syntax so I can understand what parts of the grammar it represents [:attrs {:href &quot;/_/_/users/U06GMV0B0&quot;}] ?"><y>#</y><d>2022-05-11</d><h>16:10</h><w>seancorfield</w>Well, yes, you could use <code>:raw</code> <b>🙂</b> Can you link to the docs for that syntax so I can understand what parts of the grammar it represents <a>@kbosompem</a>?</z><z id="t1652285825" t="vlad_poh https://mariadb.com/kb/en/system-versioned-tables/#:~:text=SELECT%20*%20FROM%20t%20FOR%20SYSTEM_TIME%20ALL%3B"><y>#</y><d>2022-05-11</d><h>16:17</h><w>vlad_poh</w><a href="https://mariadb.com/kb/en/system-versioned-tables/#:~:text=SELECT%20*%20FROM%20t%20FOR%20SYSTEM_TIME%20ALL%3B" target="_blank">https://mariadb.com/kb/en/system-versioned-tables/#:~:text=SELECT%20*%20FROM%20t%20FOR%20SYSTEM_TIME%20ALL%3B</a></z><z id="t1652286072" t="seancorfield Thanks. https://github.com/seancorfield/honeysql/issues/407 It&apos;s an interesting piece of syntax. I&apos;ll have to think about how best to support it."><y>#</y><d>2022-05-11</d><h>16:21</h><w>seancorfield</w>Thanks. <a href="https://github.com/seancorfield/honeysql/issues/407" target="_blank">https://github.com/seancorfield/honeysql/issues/407</a> It&apos;s an interesting piece of syntax. I&apos;ll have to think about how best to support it.</z><z id="t1652286323" t="seancorfield https://www.sqlshack.com/how-to-query-data-in-a-system-versioned-temporal-tables-in-sql-server/"><y>#</y><d>2022-05-11</d><h>16:25</h><w>seancorfield</w><a href="https://www.sqlshack.com/how-to-query-data-in-a-system-versioned-temporal-tables-in-sql-server/" target="_blank">https://www.sqlshack.com/how-to-query-data-in-a-system-versioned-temporal-tables-in-sql-server/</a></z><z id="t1652600294" t="Ho0man Hi everyone, is there a way in honey and psqlh that I could do these two queries in a single statement - assuming these are my tables user (id, login, password, name) and dealer (id, user_id) : WITH rows AS ( INSERT INTO &quot;user&quot; (login, password, name) VALUES (&apos;dealer1&apos;, &apos;jygbjybk&apos;, &apos;Dealer 1&apos;) RETURNING id ) INSERT INTO dealer (user_id) SELECT id FROM rows; SELECT currval(&apos;dealer_id_seq&apos;); I want to insert in the user table and use the returning id from that to insert the dealer in one statement. Were using honeysql from versions prior to 2. Thanks"><y>#</y><d>2022-05-15</d><h>07:38</h><w>Ho0man</w>Hi everyone, is there a way in <code>honey</code> and <code>psqlh</code> that I could do these two queries in a single statement - assuming these are my tables <code>user (id, login, password, name)</code> and <code>dealer (id, user_id)</code> :
<pre>WITH rows AS (
    INSERT INTO &quot;user&quot;
        (login, password, name)
    VALUES
        (&apos;dealer1&apos;, &apos;jygbjybk&apos;, &apos;Dealer 1&apos;)
    RETURNING id
)
INSERT INTO dealer (user_id)
    SELECT id
    FROM rows;
SELECT currval(&apos;dealer_id_seq&apos;);</pre>
I want to insert in the user table and use the returning id from that to insert the dealer in one statement.
Were using honeysql from versions prior to 2.
Thanks</z><z id="t1652793299" t="vlad_poh How do i force &quot;set&quot; to show up after the join? (hsql/format {:update [:customer :c] :join [[{:select [[[:min :c.row_start] :crs] :c.customerid] :from [[[:raw &quot; customer for system_time all c&quot;]]] :group-by [:customerid]} :x] [:= :c.customerid :x.customerid]] :set {:c.created :x.crs}} generates the following. Query would work if the set clause appeared after the inner join UPDATE customer c SET c.created = x.crs INNER JOIN ( SELECT MIN(c.row_start) AS crs , c.customerid FROM customer for system_time all c GROUP BY customerid) AS x ON c.customerid = x.customerid"><y>#</y><d>2022-05-17</d><h>13:14</h><w>vlad_poh</w>How do i force &quot;set&quot; to show up after the join?

<pre>(hsql/format 
{:update [:customer :c]
    :join [[{:select [[[:min :c.row_start] :crs] :c.customerid]
             :from [[[:raw &quot; customer for system_time all c&quot;]]]
             :group-by [:customerid]} :x]
           [:= :c.customerid :x.customerid]]
    :set {:c.created :x.crs}}</pre>
generates the following. Query would work if the set clause appeared after the inner join
<pre>UPDATE customer c 
       SET c.created = x.crs 
INNER JOIN (  SELECT MIN(c.row_start) AS crs
                   , c.customerid 
                FROM  customer for system_time all c 
            GROUP BY customerid) AS x 
         ON c.customerid = x.customerid</pre></z><z id="t1652801925" t="seancorfield [:attrs {:href &quot;/_/_/users/U06GMV0B0&quot;}] what version of HoneySQL? What database is this for?"><y>#</y><d>2022-05-17</d><h>15:38</h><r>seancorfield</r><a>@U06GMV0B0</a> what version of HoneySQL? What database is this for?</z><z id="t1652803478" t="vlad_poh [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Maria DB : 10.6.7-MariaDB via Babashka (deps/add-deps &apos;{:deps {com.github.seancorfield/honeysql {:mvn/version &quot;2.2.861&quot;}}})"><y>#</y><d>2022-05-17</d><h>16:04</h><r>vlad_poh</r><a>@U04V70XH6</a>  Maria DB : 10.6.7-MariaDB
via Babashka (deps/add-deps &apos;{:deps {com.github.seancorfield/honeysql {:mvn/version &quot;2.2.861&quot;}}})</z><z id="t1652803721" t="seancorfield Ah, so it&apos;s a MySQL dialect -- you need to specify that, per the docs."><y>#</y><d>2022-05-17</d><h>16:08</h><r>seancorfield</r>Ah, so it&apos;s a MySQL dialect -- you need to specify that, per the docs.</z><z id="t1652803778" t="seancorfield MySQL (and MariaDB) has a different precedence for SET -- it&apos;s annoying (and it only shows up in complex UPDATE statements."><y>#</y><d>2022-05-17</d><h>16:09</h><r>seancorfield</r>MySQL (and MariaDB) has a different precedence for <code>SET</code> -- it&apos;s annoying (and it only shows up in complex <code>UPDATE</code> statements.</z><z id="t1652803781" t="vlad_poh :man-facepalming: just saw it in the readme"><y>#</y><d>2022-05-17</d><h>16:09</h><r>vlad_poh</r><b>:man-facepalming:</b> just saw it in the readme</z><z id="t1652803825" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#updates 🙂"><y>#</y><d>2022-05-17</d><h>16:10</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#updates" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/readme#updates</a> <b>🙂</b></z><z id="t1652803845" t="seancorfield As I often say, there&apos;s a lot of good stuff in the docs :rolling_on_the_floor_laughing:"><y>#</y><d>2022-05-17</d><h>16:10</h><r>seancorfield</r>As I often say, there&apos;s a lot of good stuff in the docs <b>:rolling_on_the_floor_laughing:</b></z><z id="t1653061441" t="rschmukler Does honeysql support anything for generating a batch values insert statement as expected by jdbc-next? ie. rather than generating INSERT INTO table (id, col) VALUES (?, ?), (?, ?), (?, ?) when doing (sql/format {:insert-into :table :values [{:id 1, :col &quot;a&quot;}, {:id 2, :col &quot;b&quot;}, {:id 3, :col &quot;c&quot;}) it does INSERT INTO table (id, col) VALUES (?, ?)"><y>#</y><d>2022-05-20</d><h>15:44</h><w>rschmukler</w>Does honeysql support anything for generating a batch values insert statement as expected by jdbc-next? ie. rather than generating <code>INSERT INTO table (id, col) VALUES (?, ?), (?, ?), (?, ?)</code> when doing <code>(sql/format {:insert-into :table :values [{:id 1, :col &quot;a&quot;}, {:id 2, :col &quot;b&quot;}, {:id 3, :col &quot;c&quot;})</code> it does <code>INSERT INTO table (id, col) VALUES (?, ?)</code></z><z id="t1653062537" t="seancorfield I assume you mean jdbc/execute-batch! there? Feel free to open an issue and I&apos;ll give it some thought. The machinery that does that formatting is deep inside the formatter and it would affect a lot of how parameters are handled -- because anything could be an expression and have parameters lifted out of it."><y>#</y><d>2022-05-20</d><h>16:02</h><r>seancorfield</r>I assume you mean <code>jdbc/execute-batch!</code> there? Feel free to open an issue and I&apos;ll give it some thought. The machinery that does that formatting is deep inside the formatter and it would affect a lot of how parameters are handled -- because anything could be an expression and have parameters lifted out of it.</z><z id="t1653062639" t="seancorfield An easier &quot;win&quot; would be to enhance https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.780/api/next.jdbc.sql#insert-multi ! so it could accept a sequence of hash maps and validate/split them into cols and rows."><y>#</y><d>2022-05-20</d><h>16:03</h><r>seancorfield</r>An easier &quot;win&quot; would be to enhance <a href="https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.780/api/next.jdbc.sql#insert-multi" target="_blank">https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.2.780/api/next.jdbc.sql#insert-multi</a>! so it could accept a sequence of hash maps and validate/split them into cols and rows.</z><z id="t1653064000" t="rschmukler If I&apos;m understanding the docs correctly insert-multi! will still not use batch statements (which makes sense as default). I&apos;m specifically trying to get to batch statements (because my JDBC driver warns me when I don&apos;t use them 😛 )"><y>#</y><d>2022-05-20</d><h>16:26</h><r>rschmukler</r>If I&apos;m understanding the docs correctly <code>insert-multi!</code> will still not use batch statements (which makes sense as default). I&apos;m specifically trying to get to batch statements (because my JDBC driver warns me when I don&apos;t use them <b>😛</b>)</z><z id="t1653064325" t="seancorfield [:attrs {:href &quot;/_/_/users/UEC8W94AE&quot;}] It&apos;s a tricky area, since both PG and MySQL need (different) JDBC URL parameters to perform the statement rewriting necessary to actually batch things properly..."><y>#</y><d>2022-05-20</d><h>16:32</h><r>seancorfield</r><a>@UEC8W94AE</a> It&apos;s a tricky area, since both PG and MySQL need (different) JDBC URL parameters to perform the statement rewriting necessary to actually batch things properly...</z><z id="t1653064514" t="seancorfield ...but changing insert-multi! to conditionally use execute-batch! would be &quot;relatively straightforward&quot; and would be my preference, rather than trying to conditionally change HoneySQL&apos;s :insert-into behavior (since it is actually :values that would be affected -- and there&apos;s an interaction with :columns as well)."><y>#</y><d>2022-05-20</d><h>16:35</h><r>seancorfield</r>...but changing <code>insert-multi!</code> to conditionally use <code>execute-batch!</code> would be &quot;relatively straightforward&quot; and would be my preference, rather than trying to conditionally change HoneySQL&apos;s <code>:insert-into</code> behavior (since it is actually <code>:values</code> that would be affected -- and there&apos;s an interaction with <code>:columns</code> as well).</z><z id="t1653064965" t="rschmukler That all makes sense [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] - I&apos;ll look at extending insert-multi! to support the hash maps + add an optional :batch option that converts it to using execute-batch! instead of execute! - thanks for the help!"><y>#</y><d>2022-05-20</d><h>16:42</h><r>rschmukler</r>That all makes sense <a>@U04V70XH6</a> - I&apos;ll look at extending <code>insert-multi!</code> to support the hash maps + add an optional <code>:batch</code> option that converts it to using <code>execute-batch!</code> instead of <code>execute!</code>  - thanks for the help!</z><z id="t1653065026" t="seancorfield Thanks! That&apos;s definitely something I&apos;d consider a PR for -- with multi-database tests and documentation, please -- or just create an issue as a placeholder and provide your thoughts."><y>#</y><d>2022-05-20</d><h>16:43</h><r>seancorfield</r>Thanks! That&apos;s definitely something I&apos;d consider a PR for -- with multi-database tests and documentation, please -- or just create an issue as a placeholder and provide your thoughts.</z><z id="t1653065038" t="rschmukler Let me know if you want me to just close https://github.com/seancorfield/honeysql/issues/408 with some of your thoughts (in case somebody else goes looking on GH)"><y>#</y><d>2022-05-20</d><h>16:43</h><r>rschmukler</r>Let me know if you want me to just close <a href="https://github.com/seancorfield/honeysql/issues/408" target="_blank">https://github.com/seancorfield/honeysql/issues/408</a> with some of your thoughts (in case somebody else goes looking on GH)</z><z id="t1653065110" t="seancorfield That code would fail if inserting composite values since it doesn&apos;t account for nested parens in the generated SQL."><y>#</y><d>2022-05-20</d><h>16:45</h><r>seancorfield</r>That code would fail if inserting composite values since it doesn&apos;t account for nested parens in the generated SQL.</z><z id="t1653065169" t="seancorfield (feel free to close it -- the actual changes needed are almost certainly much more complex than they might appear)"><y>#</y><d>2022-05-20</d><h>16:46</h><r>seancorfield</r>(feel free to close it -- the actual changes needed are almost certainly much more complex than they might appear)</z><z id="t1653065562" t="rschmukler Closed! Thanks again for the input"><y>#</y><d>2022-05-20</d><h>16:52</h><r>rschmukler</r>Closed! Thanks again for the input</z><z id="t1653069495" t="rschmukler https://github.com/seancorfield/next-jdbc/pull/206"><y>#</y><d>2022-05-20</d><h>17:58</h><r>rschmukler</r><a href="https://github.com/seancorfield/next-jdbc/pull/206" target="_blank">https://github.com/seancorfield/next-jdbc/pull/206</a></z><z id="t1653073214" t="seancorfield Available to test via git deps or https://clojars.org/com.github.seancorfield/next.jdbc/versions/1.2.999-SNAPSHOT -- thank you!"><y>#</y><d>2022-05-20</d><h>19:00</h><r>seancorfield</r>Available to test via git deps or <a href="https://clojars.org/com.github.seancorfield/next.jdbc/versions/1.2.999-SNAPSHOT" target="_blank">https://clojars.org/com.github.seancorfield/next.jdbc/versions/1.2.999-SNAPSHOT</a> -- thank you!</z><z id="t1653073252" t="rschmukler Thanks for the quick publish! "><y>#</y><d>2022-05-20</d><h>19:00</h><r>rschmukler</r>Thanks for the quick publish! </z><z id="t1653074267" t="seancorfield Thanks for the high quality contribution!"><y>#</y><d>2022-05-20</d><h>19:17</h><r>seancorfield</r>Thanks for the high quality contribution!</z><z id="t1653083007" t="rschmukler Confirmed that it&apos;s working for me chef_kiss"><y>#</y><d>2022-05-20</d><h>21:43</h><r>rschmukler</r>Confirmed that it&apos;s working for me <b>chef_kiss</b></z><z id="t1653061450" t="rschmukler If not, would you be open to a PR?"><y>#</y><d>2022-05-20</d><h>15:44</h><w>rschmukler</w>If not, would you be open to a PR?</z><z id="t1653061527" t="rschmukler Something like: (let [[sql &amp; groups] (sql/format {:insert-into :table :values val-seq} {:batch true})] (jdbc/insert-batch! connectable sql groups)) "><y>#</y><d>2022-05-20</d><h>15:45</h><w>rschmukler</w>Something like:

<pre>(let [[sql &amp; groups] (sql/format {:insert-into :table :values val-seq} {:batch true})]
  (jdbc/insert-batch! connectable sql groups))
      </pre></z><z id="t1653062444" t="rschmukler What I currently have (and works fine - but just wondering if this is something honeysql would like): (defn- -format-batch-insert &quot;Convert a multi-parameterized sql insert map into a statement suitable for batch use. Returns a sequence that can be destructured as `[sql &amp; param-groups]`&quot; [{:keys [insert-into values]}] (let [key-count (-&gt; values first keys count) [raw-sql &amp; raw-params] (sql/format {:insert-into insert-into :values values}) sql (-&gt;&gt; (str/split raw-sql &quot;)&quot;) (take 2) (str/join &quot;)&quot;) (#(str % &quot;)&quot;)))] (concat [sql] (partition key-count raw-params)))) Obviously the impl could be cleaner inside of honeysql itself"><y>#</y><d>2022-05-20</d><h>16:00</h><w>rschmukler</w>What I currently have (and works fine - but just wondering if this is something honeysql would like):

<pre>(defn- -format-batch-insert
  &quot;Convert a multi-parameterized sql insert map into a statement suitable for batch use.
  Returns a sequence that can be destructured as `[sql &amp; param-groups]`&quot;
  [{:keys [insert-into values]}]
  (let [key-count              (-&gt; values first keys count)
        [raw-sql &amp; raw-params] (sql/format {:insert-into insert-into :values values})
        sql                    (-&gt;&gt; (str/split raw-sql &quot;)&quot;)
                                    (take 2)
                                    (str/join &quot;)&quot;)
                                    (#(str % &quot;)&quot;)))]
    (concat
      [sql]
      (partition key-count raw-params))))</pre>
Obviously the impl could be cleaner inside of honeysql itself</z><z id="t1653467665" t="Benjamin target output: SELECT &quot;timestamp&quot; from table (sql/format {:select &apos;[&quot;\&quot;timestamp\&quot;&quot;] :from &apos;table} {:inline true}) [&quot;SELECT &apos;\&quot;timestamp\&quot;&apos; FROM table&quot;]"><y>#</y><d>2022-05-25</d><h>08:34</h><w>Benjamin</w>target output:
<pre>SELECT &quot;timestamp&quot; from table</pre>
<pre>(sql/format {:select &apos;[&quot;\&quot;timestamp\&quot;&quot;] :from &apos;table} {:inline true})
  [&quot;SELECT &apos;\&quot;timestamp\&quot;&apos; FROM table&quot;]</pre></z><z id="t1653482043" t="seancorfield If you&apos;re using PostgreSQL (or some other relatively ANSI-compliant database), that&apos;s just normal quoting, so {:select :timestamp :from :table} with {:quoted true}"><y>#</y><d>2022-05-25</d><h>12:34</h><r>seancorfield</r>If you&apos;re using PostgreSQL (or some other relatively ANSI-compliant database), that&apos;s just normal quoting, so <code>{:select :timestamp :from :table}</code> with <code>{:quoted true}</code></z><z id="t1653486217" t="Benjamin 👀"><y>#</y><d>2022-05-25</d><h>13:43</h><r>Benjamin</r><b>👀</b></z><z id="t1653487350" t="seancorfield Now I&apos;m at my desk, instead of on my phone: (! 506)-&gt; clj Clojure 1.9.0 user=&gt; (require &apos;[honey.sql :as sql]) nil user=&gt; (sql/format {:select :timestamp :from :table} {:quoted true}) [&quot;SELECT \&quot;timestamp\&quot; FROM \&quot;table\&quot;&quot;]"><y>#</y><d>2022-05-25</d><h>14:02</h><r>seancorfield</r>Now I&apos;m at my desk, instead of on my phone:
<pre>(! 506)-&gt; clj
Clojure 1.9.0
user=&gt; (require &apos;[honey.sql :as sql])
nil
user=&gt; (sql/format {:select :timestamp :from :table} {:quoted true})
[&quot;SELECT \&quot;timestamp\&quot; FROM \&quot;table\&quot;&quot;]</pre></z><z id="t1653487477" t="seancorfield ANSI/PostgreSQL is the default dialect, but you can get quoting in other dialects too: user=&gt; (sql/format {:select :timestamp :from :table} {:dialect :mysql}) [&quot;SELECT `timestamp` FROM `table`&quot;] user=&gt; (sql/format {:select :timestamp :from :table} {:dialect :sqlserver}) [&quot;SELECT [timestamp] FROM [table]&quot;]"><y>#</y><d>2022-05-25</d><h>14:04</h><r>seancorfield</r>ANSI/PostgreSQL is the default dialect, but you can get quoting in other dialects too:
<pre>user=&gt; (sql/format {:select :timestamp :from :table} {:dialect :mysql})
[&quot;SELECT `timestamp` FROM `table`&quot;]
user=&gt; (sql/format {:select :timestamp :from :table} {:dialect :sqlserver})
[&quot;SELECT [timestamp] FROM [table]&quot;]</pre></z><z id="t1653487577" t="seancorfield (if you specify a :dialect , quoting is enabled by default and you can turn it off with :quoted false ; if you have a default dialect -- either ANSI/PostgreSQL out of the box or via set-dialect! or register-dialect! -- then you have to explicitly ask for :quoted true )"><y>#</y><d>2022-05-25</d><h>14:06</h><r>seancorfield</r>(if you specify a <code>:dialect</code>, quoting is enabled by default and you can turn it off with <code>:quoted false</code>; if you have a default dialect -- either ANSI/PostgreSQL out of the box or via <code>set-dialect!</code> or <code>register-dialect!</code> -- then you have to explicitly ask for <code>:quoted true</code>)</z><z id="t1654622754" t="slipset Given a fn like (defn- delete-resource [store key] (-&gt; (hh/update :plugin_store) (hh/set {:keys [:raw (str &quot;keys - &apos;&quot; (sanitize-key key) &quot;&apos;&quot;)]}) (hh/where [:= :_id (core/id store)]) (honey/format {:quoted true}))) I can do the following (jdbc/execute-one! ds (delete-resource {:id &quot;lol&quot;} &quot;&apos;; drop table plugin_store -- k&quot; )) And my table is gone 😕 What would be a safer way to do what I’m trying to achieve here, that is unsetting the attribute key on keys I could of course write a better sanitize-key but I’d really love to get this as a prepared statement of some sort."><y>#</y><d>2022-06-07</d><h>17:25</h><w>slipset</w>Given a fn like
<pre>(defn- delete-resource [store key]
  (-&gt; (hh/update :plugin_store)
      (hh/set {:keys [:raw (str &quot;keys - &apos;&quot; (sanitize-key key) &quot;&apos;&quot;)]})
      (hh/where [:= :_id (core/id store)])
      (honey/format {:quoted true})))</pre>
I can do the following
<pre>(jdbc/execute-one! ds (delete-resource {:id &quot;lol&quot;} &quot;&apos;; drop table plugin_store -- k&quot; ))</pre>
And my table is gone <b>😕</b>
What would be a safer way to do what I’m trying to achieve here, that is unsetting the attribute <code>key</code> on <code>keys</code>
I could of course write a better <code>sanitize-key</code> but I’d really love to get this as a prepared statement of some sort.</z><z id="t1654631159" t="kolstae Wouldn&apos;t that be (-&gt; (hh/update :plugin_store) (hh/set {:keys [:- :keys &quot;key&quot;]}) (hh/where [:= :_id &quot;abc&quot;]) (honey.sql/format {:quoted true})) =&gt; [&quot;UPDATE \&quot;plugin_store\&quot; SET \&quot;keys\&quot; = \&quot;keys\&quot; - ? WHERE \&quot;_id\&quot; = ?&quot; &quot;key&quot; &quot;abc&quot;]"><y>#</y><d>2022-06-07</d><h>19:45</h><r>kolstae</r>Wouldn&apos;t that be
<pre>(-&gt; (hh/update :plugin_store)
    (hh/set {:keys [:- :keys &quot;key&quot;]})
    (hh/where [:= :_id &quot;abc&quot;])
    (honey.sql/format {:quoted true}))
=&gt; [&quot;UPDATE \&quot;plugin_store\&quot; SET \&quot;keys\&quot; = \&quot;keys\&quot; - ? WHERE \&quot;_id\&quot; = ?&quot; &quot;key&quot; &quot;abc&quot;]</pre></z><z id="t1654631350" t="slipset It just very well would."><y>#</y><d>2022-06-07</d><h>19:49</h><r>slipset</r>It just very well would.</z><z id="t1654623110" t="slipset That is for Postgres btw"><y>#</y><d>2022-06-07</d><h>17:31</h><w>slipset</w>That is for Postgres btw</z><z id="t1654787443" t="miso How can I select from a function with parameters in honeysql 1.x? Based on the docs this is what I have so far but I get the following error Assert failed: Alias should have two parts[&quot;foo(?,?,?)&quot; #sql/param :a #sql/param :b #sql/param :c] (honeysql/format {:select [:res] :from #sql/raw [&quot;foo(?,?,?)&quot; #sql/param :a #sql/param :b #sql/param :c]} {:params {:a 1 :b &quot;string&quot; :c [1 2 3]}})"><y>#</y><d>2022-06-09</d><h>15:10</h><w>miso</w>How can I select from a function with parameters in honeysql 1.x?
Based on the docs this is what I have so far but I get the following error <code>Assert failed: Alias should have two parts[&quot;foo(?,?,?)&quot; #sql/param :a #sql/param :b #sql/param :c]</code>
<pre>(honeysql/format
    {:select [:res]
     :from   #sql/raw [&quot;foo(?,?,?)&quot; #sql/param :a #sql/param :b #sql/param :c]}
    {:params
     {:a 1
      :b &quot;string&quot;
      :c [1 2 3]}})</pre></z><z id="t1654788996" t="seancorfield I don&apos;t think it can be done in 1.x. My recommendation would be to add 2.x to your project (you can have both versions in the same project) and switch that one query over to use the 2.x namespaces -- then you won&apos;t need raw , you can do an actual function call there."><y>#</y><d>2022-06-09</d><h>15:36</h><r>seancorfield</r>I don&apos;t think it can be done in 1.x. My recommendation would be to add 2.x to your project (you can have both versions in the same project) and switch that one query over to use the 2.x namespaces -- then you won&apos;t need <code>raw</code>, you can do an actual function call there.</z><z id="t1654789137" t="seancorfield user=&gt; (require &apos;[honey.sql :as hsql]) nil user=&gt; (hsql/format {:select [:res] :from [[[:foo :?a :?b :?c]]]} {:params {:a 1 :b &quot;string&quot; :c [1 2 3]}}) [&quot;SELECT res FROM FOO(?, ?, ?)&quot; 1 &quot;string&quot; [1 2 3]] user=&gt;"><y>#</y><d>2022-06-09</d><h>15:38</h><r>seancorfield</r><pre>user=&gt; (require &apos;[honey.sql :as hsql])
nil
user=&gt; (hsql/format {:select [:res] :from [[[:foo :?a :?b :?c]]]} {:params {:a 1 :b &quot;string&quot; :c [1 2 3]}})
[&quot;SELECT res FROM FOO(?, ?, ?)&quot; 1 &quot;string&quot; [1 2 3]]
user=&gt;</pre></z><z id="t1654790451" t="miso Actually it can :thumbsup: and its quite simple (let [a 1 b &quot;string&quot; c [1 2 3]] (honeysql/format {:select [:res] :from [(honeysql/call :foo a b (into-array c))]}))"><y>#</y><d>2022-06-09</d><h>16:00</h><r>miso</r>Actually it can <b>:thumbsup:</b>  and its quite simple

<pre>(let [a 1
       b &quot;string&quot;
       c [1 2 3]] 
    (honeysql/format
     {:select [:res]
      :from   [(honeysql/call :foo a b (into-array c))]}))</pre></z><z id="t1654791182" t="miso But yeah definitely need to migrate to 2x"><y>#</y><d>2022-06-09</d><h>16:13</h><r>miso</r>But yeah definitely need to migrate to 2x</z><z id="t1654795152" t="seancorfield Ah, I wasn&apos;t sure if the call mechanism would work there. It doesn&apos;t work in all contexts."><y>#</y><d>2022-06-09</d><h>17:19</h><r>seancorfield</r>Ah, I wasn&apos;t sure if the call mechanism would work there. It doesn&apos;t work in all contexts.</z><z id="t1654787548" t="Noah Bogart question about differences between v1 and v2: right now with v1 we have (-&gt; (insert-into :temp-table) (query-values (-&gt; (select :col1 :col2) (from :other_table) (where [:= :other_col param1]))) (sql/format :parameterizer :none)) which produces the sql string INSERT INTO temp_table (SELECT col_1, col_2 FROM other_table WHERE (other_col = &apos;param1&apos;)) . As you can see, it neatly inserts the subquery. my attempts at reproducing this with v2 are failing me. (-&gt; (insert-into :temp-table) (columns :col1 :col2) (values (-&gt; (select :col1 :col2) (from :other_table) (where [:= :other_col param1]))) (v2/format :parameterizer true)) produces the sql string INSERT INTO temp_table (col1, col2) VALUES (select, COL1(col2)), (from, OTHER_TABLE()), (where, (other_col = &apos;param1&apos;)) , which is obviously wrong lol. and switching values to from produces INSERT INTO temp_table (col1, col2) FROM (SELECT col1, col2 FROM other_table WHERE other_col = &quot;param1&quot;) , which throws an error on the first FROM . any ideas on how to solve this?"><y>#</y><d>2022-06-09</d><h>15:12</h><w>Noah Bogart</w>question about differences between v1 and v2: right now with v1 we have
<pre>(-&gt; (insert-into :temp-table)
    (query-values (-&gt; (select :col1 :col2)
                      (from :other_table)
                      (where [:= :other_col param1])))
    (sql/format :parameterizer :none))</pre>
which produces the sql string <code>INSERT INTO temp_table (SELECT col_1, col_2 FROM other_table WHERE (other_col = &apos;param1&apos;))</code> . As you can see, it neatly inserts the subquery.
my attempts at reproducing this with v2 are failing me.
<pre>(-&gt; (insert-into :temp-table)
    (columns :col1 :col2)
    (values (-&gt; (select :col1 :col2)
                (from :other_table)
                (where [:= :other_col param1])))
    (v2/format :parameterizer true))</pre>
produces the sql string <code>INSERT INTO temp_table (col1, col2) VALUES (select, COL1(col2)), (from, OTHER_TABLE()), (where, (other_col = &apos;param1&apos;))</code> , which is obviously wrong lol. and switching <code>values</code> to <code>from</code> produces <code>INSERT INTO temp_table (col1, col2) FROM (SELECT col1, col2 FROM other_table WHERE other_col = &quot;param1&quot;)</code> , which throws an error on the first <code>FROM</code>.
any ideas on how to solve this?</z><z id="t1654789247" t="seancorfield First off, the :parameterizer true stuff doesn&apos;t exist in v2 and format takes a hash map of options, not named args."><y>#</y><d>2022-06-09</d><h>15:40</h><r>seancorfield</r>First off, the <code>:parameterizer true</code> stuff doesn&apos;t exist in v2 and <code>format</code> takes a hash map of options, not named args.</z><z id="t1654789291" t="Noah Bogart oops, i do have it as a map in my actual code but missed that :parameterizer doesn&apos;t exist"><y>#</y><d>2022-06-09</d><h>15:41</h><r>Noah Bogart</r>oops, i do have it as a map in my actual code but missed that <code>:parameterizer</code> doesn&apos;t exist</z><z id="t1654789502" t="seancorfield You&apos;re looking for something like this? (is (= (format {:insert-into [[:foo [:a :b :c]] {:select [:d :e :f] :from [:baz]}]}) [&quot;INSERT INTO foo (a, b, c) SELECT d, e, f FROM baz&quot;])) (that&apos;s taken from the tests for HoneySQL)"><y>#</y><d>2022-06-09</d><h>15:45</h><r>seancorfield</r>You&apos;re looking for something like this?
<pre>(is (= (format {:insert-into [[:foo [:a :b :c]] {:select [:d :e :f] :from [:baz]}]})
         [&quot;INSERT INTO foo (a, b, c) SELECT d, e, f FROM baz&quot;]))</pre>
(that&apos;s taken from the tests for HoneySQL)</z><z id="t1654789590" t="Noah Bogart oh, yes. i guess i never tried (-&gt; (insert-into :temp-table) (select ...)) . that looks like it works"><y>#</y><d>2022-06-09</d><h>15:46</h><r>Noah Bogart</r>oh, yes. i guess i never tried <code>(-&gt; (insert-into :temp-table) (select ...))</code>. that looks like it works</z><z id="t1654789658" t="Noah Bogart thank you"><y>#</y><d>2022-06-09</d><h>15:47</h><r>Noah Bogart</r>thank you</z><z id="t1654789763" t="seancorfield Is this is? user=&gt; (-&gt; (insert-into :temp-table [:col1 :col2] #_=&gt; (-&gt; (select :col1 :col2) #_=&gt; (from :other_table) #_=&gt; (where [:= :other_col 42]))) #_=&gt; (hsql/format)) [&quot;INSERT INTO temp_table (col1, col2) SELECT col1, col2 FROM other_table WHERE other_col = ?&quot; 42] user=&gt;"><y>#</y><d>2022-06-09</d><h>15:49</h><r>seancorfield</r>Is this is?
<pre>user=&gt; (-&gt; (insert-into :temp-table [:col1 :col2]                                                                                                              #_=&gt;     (-&gt; (select :col1 :col2)
  #_=&gt;         (from :other_table)
  #_=&gt;         (where [:= :other_col 42])))
  #_=&gt;     (hsql/format))
[&quot;INSERT INTO temp_table (col1, col2) SELECT col1, col2 FROM other_table WHERE other_col = ?&quot; 42]
user=&gt;</pre></z><z id="t1654789878" t="Noah Bogart yep, that works. got hung up on the query-values call from the v1"><y>#</y><d>2022-06-09</d><h>15:51</h><r>Noah Bogart</r>yep, that works. got hung up on the <code>query-values</code> call from the v1</z><z id="t1655059633" t="sheluchin Sorry if I&apos;m missing it in the docs, but could someone suggest how I&apos;d do a bulk update with Postgres? Given a set of rows like [{:id 1 :x &quot;foo&quot; :y nil} {:id 2 :x &quot;bar&quot; :y nil}] , I want to update the value of the :y by merging a vector of maps that I have in Clojure, like [{:id 1 :y 100} {:id 2, :y 200}] , so the resulting rows would be [{:id 1 :x &quot;foo&quot; :y 100} {:id 2 :x &quot;bar&quot; :y 200}] ."><y>#</y><d>2022-06-12</d><h>18:47</h><w>sheluchin</w>Sorry if I&apos;m missing it in the docs, but could someone suggest how I&apos;d do a bulk update with Postgres?

Given a set of rows like <code>[{:id 1 :x &quot;foo&quot; :y nil} {:id 2 :x &quot;bar&quot; :y nil}]</code>, I want to update the value of the <code>:y</code> by merging a vector of maps that I have in Clojure, like <code>[{:id 1 :y 100} {:id 2, :y 200}]</code>, so the resulting rows would be <code>[{:id 1 :x &quot;foo&quot; :y 100} {:id 2 :x &quot;bar&quot; :y 200}]</code>.</z><z id="t1655134430" t="sheluchin I think I got it: (execute! db (-&gt; (hh/create-table :test) (hh/with-columns [[:did :int] [:x :varchar] [:y :int] [:z :int] [[:primary-key :did :x]]]) (sql/format))) (execute! db (-&gt; (hh/insert-into :test) (hh/values [{:did 1 :x &quot;foo&quot;} {:did 2 :x &quot;bar&quot;}]) (sql/format {:pretty true}))) (execute! db (-&gt; (hh/insert-into :test) (hh/values [{:did 1 :x &quot;foo&quot; :y 100} {:did 2 :x &quot;bar&quot; :y 200}]) (hh/on-conflict (hh/on-constraint :test_pkey)) (hh/do-update-set :y) (sql/format))) (execute! db (-&gt; (hh/insert-into :test) (hh/values [{:did 1 :x &quot;foo&quot; :z 888} {:did 2 :x &quot;bar&quot; :z 999}]) (hh/on-conflict (hh/on-constraint :test_pkey)) (hh/do-update-set :z) (sql/format))) Please suggest if there is a better way. Also curious if there is a way to skip the operation if a matching PK does not exist."><y>#</y><d>2022-06-13</d><h>15:33</h><r>sheluchin</r>I think I got it:

<pre>(execute! db
          (-&gt; (hh/create-table :test)
              (hh/with-columns
                [[:did :int]
                 [:x :varchar]
                 [:y :int]
                 [:z :int]
                 [[:primary-key :did :x]]])
              (sql/format)))
(execute! db
          (-&gt; (hh/insert-into :test)
              (hh/values [{:did 1 :x &quot;foo&quot;}
                          {:did 2 :x &quot;bar&quot;}])
              (sql/format {:pretty true})))
(execute! db
          (-&gt; (hh/insert-into :test)
              (hh/values [{:did 1 :x &quot;foo&quot; :y 100}
                          {:did 2 :x &quot;bar&quot; :y 200}])
              (hh/on-conflict (hh/on-constraint :test_pkey))
              (hh/do-update-set :y)
              (sql/format)))
(execute! db
          (-&gt; (hh/insert-into :test)
              (hh/values [{:did 1 :x &quot;foo&quot; :z 888}
                          {:did 2 :x &quot;bar&quot; :z 999}])
              (hh/on-conflict (hh/on-constraint :test_pkey))
              (hh/do-update-set :z)
              (sql/format)))</pre>
Please suggest if there is a better way. Also curious if there is a way to skip the operation if a matching PK does not exist.</z><z id="t1655303854" t="sheluchin I ultimately arrived at using Postgres CTE: (-&gt; (hh/with [[:updates {:columns [:did :y]}] {:values [[1 100] [2 200]]}]) (hh/update :test) (hh/set {:y :updates/y}) (hh/from :updates) (hh/where := :test/did :updates/did) (sql/format)))) "><y>#</y><d>2022-06-15</d><h>14:37</h><r>sheluchin</r>I ultimately arrived at using Postgres CTE:
<pre>(-&gt; (hh/with [[:updates {:columns [:did :y]}] 
              {:values [[1 100]               
                        [2 200]]}])           
    (hh/update :test)                         
    (hh/set {:y :updates/y})                  
    (hh/from :updates)                        
    (hh/where := :test/did :updates/did)      
    (sql/format))))                           </pre></z><z id="t1655321101" t="markbastian How would I do a select distinct on in honeysql? Something like this: SELECT DISTINCT ON (url) url, request_duration FROM logs ORDER BY url, timestamp DESC "><y>#</y><d>2022-06-15</d><h>19:25</h><w>markbastian</w>How would I do a select distinct on in honeysql? Something like this:
<pre>SELECT DISTINCT ON (url) url, request_duration
FROM logs
ORDER BY url, timestamp DESC</pre>
</z><z id="t1655321784" t="sheluchin https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/api/honey.sql.helpers#select-distinct-on"><y>#</y><d>2022-06-15</d><h>19:36</h><r>sheluchin</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/api/honey.sql.helpers#select-distinct-on" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/api/honey.sql.helpers#select-distinct-on</a></z><z id="t1655370527" t="pinkfrog Hi. Sounds like honeysql can be used in clojurescript. Anyone has used honeysql with an in-browser database like sql.js, how do you feel?"><y>#</y><d>2022-06-16</d><h>09:08</h><w>pinkfrog</w>Hi. Sounds like honeysql can be used in clojurescript. Anyone has used honeysql with an in-browser database like sql.js, how do you feel?</z><z id="t1655399471" t="wombawomba I&apos;d like to extend HoneySQL (1) to support H2&apos;s MERGE INTO syntax (`MERGE INTO mytable (x, y, x) KEY(x) VALUES(&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;)`). How would I go about this?"><y>#</y><d>2022-06-16</d><h>17:11</h><w>wombawomba</w>I&apos;d like to extend HoneySQL (1) to support H2&apos;s <code>MERGE INTO</code> syntax (`MERGE INTO mytable (x, y, x) KEY(x) VALUES(&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;)`). How would I go about this?</z><z id="t1655400864" t="wombawomba Nevermind! Turns out it was way easier than I&apos;d thought it&apos;d be: (defmethod honeysql.format/format-clause :merge-into [[_ table] _] (str &quot;MERGE INTO &quot; (honeysql.format/to-sql table))) (defmethod honeysql.format/format-clause :key [[_ ks] _] (str &quot;KEY (&quot; (clojure.string/join &quot;, &quot; (map name ks)) \))) (honeysql.format/register-clause! :merge-into 61) (honeysql.format/register-clause! :key 91) (hh/format {:merge-into :foo, :key [:foo :bar], :columns [:foo :bar :baz], :values [[1 2 3]]}) ; =&gt; [&quot;MERGE INTO foo (foo, bar, baz) KEY (foo, bar) VALUES (?, ?, ?)&quot; 1 2 3]"><y>#</y><d>2022-06-16</d><h>17:34</h><r>wombawomba</r>Nevermind! Turns out it was way easier than I&apos;d thought it&apos;d be:
<pre>(defmethod honeysql.format/format-clause :merge-into [[_ table] _]
  (str &quot;MERGE INTO &quot; (honeysql.format/to-sql table)))

(defmethod honeysql.format/format-clause :key [[_ ks] _]
  (str &quot;KEY (&quot; (clojure.string/join &quot;, &quot; (map name ks)) \)))

(honeysql.format/register-clause! :merge-into 61)
(honeysql.format/register-clause! :key 91)</pre>
<pre>(hh/format {:merge-into :foo, :key [:foo :bar], :columns [:foo :bar :baz], :values [[1 2 3]]})
; =&gt; [&quot;MERGE INTO foo (foo, bar, baz) KEY (foo, bar) VALUES (?, ?, ?)&quot; 1 2 3]</pre></z><z id="t1656016736" t="markbastian What’s the best way to cast a select result to a string in honeysql? Say, my raw SQL is SELECT ID FROM TABLE; where ID is a UUID. I want to cast that to a string or varchar type."><y>#</y><d>2022-06-23</d><h>20:38</h><w>markbastian</w>What’s the best way to cast a select result to a string in honeysql? Say, my raw SQL is <code>SELECT ID FROM TABLE;</code> where ID is a UUID. I want to cast that to a string or varchar type.</z><z id="t1656018356" t="sheluchin Probably depends on your database. HoneySQL just creates queries out of Clojure data structures. For Postgres: (hh/select [[[:cast :did :text]] :did-as-txt])"><y>#</y><d>2022-06-23</d><h>21:05</h><r>sheluchin</r>Probably depends on your database. HoneySQL just creates queries out of Clojure data structures.

For Postgres:

<pre>(hh/select [[[:cast :did :text]] :did-as-txt])</pre></z><z id="t1656018493" t="markbastian Cool, thanks! I also did a little experimentation and discovered: [(hsql/raw &quot;row.id::text&quot;) :row_id]"><y>#</y><d>2022-06-23</d><h>21:08</h><r>markbastian</r>Cool, thanks! I also did a little experimentation and discovered:
<pre>[(hsql/raw &quot;row.id::text&quot;) :row_id]</pre></z><z id="t1656028510" t="seancorfield That looks like HoneySQL v1? For anyone else reading this thread, in HoneySQL v2, :raw is a &quot;function&quot; now, [:raw &quot;row.id::text&quot;]"><y>#</y><d>2022-06-23</d><h>23:55</h><r>seancorfield</r>That looks like HoneySQL v1? For anyone else reading this thread, in HoneySQL v2, <code>:raw</code> is a &quot;function&quot; now, <code>[:raw &quot;row.id::text&quot;]</code></z><z id="t1656076879" t="markbastian Yeah, that’s v1. Good callout. Thanks!"><y>#</y><d>2022-06-24</d><h>13:21</h><r>markbastian</r>Yeah, that’s v1. Good callout. Thanks!</z><z id="t1656052299" t="slipset One little gotcha that we’ve stumble upon is that something like (-&gt; (hh/delete-from :foo) (hh/where (map clauses nil-xs))) might lead to something rather unexpected, ie instead of deleting nothing, you delete everything. We’ve introduced a sentinel value ::all to use when we really want all and and throw if we “accidentally” pass something that leads to hh/where returning empty"><y>#</y><d>2022-06-24</d><h>06:31</h><w>slipset</w>One little gotcha that we’ve stumble upon is that something like
<pre>(-&gt; (hh/delete-from :foo) (hh/where (map clauses nil-xs)))</pre>
might lead to something rather unexpected, ie instead of deleting nothing, you delete everything.

We’ve introduced a sentinel value <code>::all</code> to use when we really want all and and throw if we “accidentally”  pass something that leads to <code>hh/where</code> returning empty</z><z id="t1656087573" t="seancorfield [:attrs {:href &quot;/_/_/users/U04V5VAUN&quot;}] HoneySQL has a couple of modes where it highlights &quot;unusual&quot; conditions etc -- do you think it would be worth a check on :delete-from to ensure it has a non-empty condition and warn/throw on that?"><y>#</y><d>2022-06-24</d><h>16:19</h><w>seancorfield</w><a>@slipset</a> HoneySQL has a couple of modes where it highlights &quot;unusual&quot; conditions etc -- do you think it would be worth a check on <code>:delete-from</code> to ensure it has a non-empty condition and warn/throw on that?</z><z id="t1656087629" t="slipset Not sure what would be a general solution, but I’ve done this in our specific case."><y>#</y><d>2022-06-24</d><h>16:20</h><w>slipset</w>Not sure what would be a general solution, but I’ve done this in our specific case.</z><z id="t1656087648" t="slipset Basically just providing a problem with one possible solution 🙂"><y>#</y><d>2022-06-24</d><h>16:20</h><w>slipset</w>Basically just providing a problem with one possible solution <b>🙂</b></z><z id="t1656087687" t="slipset One could argue that this would be a problem with update as well. I know I’ve fat fingered updates without clauses in a console."><y>#</y><d>2022-06-24</d><h>16:21</h><w>slipset</w>One could argue that this would be a problem with update as well. I know I’ve fat fingered updates without clauses in a console.</z><z id="t1656087853" t="seancorfield Read over what :checking does in https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started?q=checking#format-options and let me know if you think extending that to delete from and update would help (by creating an issue). Someone who genuinely wants to delete/update all rows could added a dummy true condition to suppress it (which I see a lot of people doing in SQL anyway with WHERE 1 = 1 )"><y>#</y><d>2022-06-24</d><h>16:24</h><w>seancorfield</w>Read over what <code>:checking</code> does in <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started?q=checking#format-options" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started?q=checking#format-options</a> and let me know if you think extending that to <code>delete from</code> and <code>update</code> would help (by creating an issue). Someone who genuinely wants to delete/update all rows  could added a dummy true condition to suppress it (which I see a lot of people doing in SQL anyway with <code>WHERE 1 = 1</code>)</z><z id="t1656103937" t="slipset I guess (hh/where nil) could be flagged?"><y>#</y><d>2022-06-24</d><h>20:52</h><w>slipset</w>I guess <code>(hh/where nil)</code> could be flagged?</z><z id="t1656103942" t="slipset I’ll open an issue"><y>#</y><d>2022-06-24</d><h>20:52</h><w>slipset</w>I’ll open an issue</z><z id="t1656517294" t="bortexz I’m trying to generate SQL to create an index in postgresql, but it seems that the (add-index) fn only works for :primary-key and :unique, has anyone faced this problem? In postgresql docs, I can only find the CREATE INDEX clause to create new indexes on certain column(s), but not the alter table … add index …. as generated by honeysql"><y>#</y><d>2022-06-29</d><h>15:41</h><w>bortexz</w>I’m trying to generate SQL to create an index in postgresql, but it seems that the (add-index) fn only works for :primary-key and :unique, has anyone faced this problem? In postgresql docs, I can only find the <code>CREATE INDEX</code> clause to create new indexes on certain column(s), but not the <code>alter table … add index ….</code> as generated by honeysql</z><z id="t1656518348" t="seancorfield https://github.com/seancorfield/honeysql/issues/348 -- TL;DR: it&apos;s hard to support generically because it&apos;s almost entirely database-specific."><y>#</y><d>2022-06-29</d><h>15:59</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/348" target="_blank">https://github.com/seancorfield/honeysql/issues/348</a> -- TL;DR: it&apos;s hard to support generically because it&apos;s almost entirely database-specific.</z><z id="t1656518470" t="seancorfield You should be able to add a general index (without primary or unique) -- see https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started/sql-clause-reference#add-index-drop-index [:attrs {:href &quot;/_/_/users/U6CN6JQ22&quot;}]"><y>#</y><d>2022-06-29</d><h>16:01</h><r>seancorfield</r>You should be able to add a general index (without primary or unique) -- see <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started/sql-clause-reference#add-index-drop-index" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.2.891/doc/getting-started/sql-clause-reference#add-index-drop-index</a> <a>@U6CN6JQ22</a></z><z id="t1656518684" t="bortexz I tried to execute the SQL generated directly on postgres, but it seems that syntax is not supported: type &quot;look&quot; does not exist"><y>#</y><d>2022-06-29</d><h>16:04</h><r>bortexz</r>I tried to execute the SQL generated directly on postgres, but it seems that syntax is not supported:
<pre>type &quot;look&quot; does not exist</pre></z><z id="t1656518735" t="seancorfield What exact SQL are you trying to run there?"><y>#</y><d>2022-06-29</d><h>16:05</h><r>seancorfield</r>What exact SQL are you trying to run there?</z><z id="t1656518803" t="bortexz ALTER TABLE fruit ADD INDEX look(appearance) ^ This one, having a table fruit with appearance column"><y>#</y><d>2022-06-29</d><h>16:06</h><r>bortexz</r><pre>ALTER TABLE fruit ADD INDEX look(appearance)</pre>
^ This one, having a table fruit with appearance column</z><z id="t1656518820" t="bortexz Using postgresql 14"><y>#</y><d>2022-06-29</d><h>16:07</h><r>bortexz</r>Using postgresql 14</z><z id="t1656518856" t="seancorfield So it&apos;s expecting a type of index where you currently look . Let me look at the PG docs..."><y>#</y><d>2022-06-29</d><h>16:07</h><r>seancorfield</r>So it&apos;s expecting a type of index where you currently <code>look</code>. Let me look at the PG docs...</z><z id="t1656518936" t="seancorfield Try adding {:quoted true} to the format call. All the examples I can find of alter table .. add index .. for PG seem to use quoted names."><y>#</y><d>2022-06-29</d><h>16:08</h><r>seancorfield</r>Try adding <code>{:quoted true}</code> to the <code>format</code> call. All the examples I can find of <code>alter table .. add index ..</code> for PG seem to use quoted names.</z><z id="t1656519237" t="seancorfield DDL is a giant mess and varies dramatically from database to database which is why HoneySQL hadn&apos;t used to support any DDL. I&apos;m gradually adding the more common pieces but some of them are just really hard to add in any way that works across multiple databases."><y>#</y><d>2022-06-29</d><h>16:13</h><r>seancorfield</r>DDL is a giant mess and varies dramatically from database to database which is why HoneySQL hadn&apos;t used to support any DDL. I&apos;m gradually adding the more common pieces but some of them are just really hard to add in any way that works across multiple databases.</z><z id="t1656519465" t="bortexz Adding :quoted true didn’t work, it still complains. Even executing the SQL with quotes doesn’t work ALTER TABLE fruit ADD INDEX &apos;look&apos;(&apos;appearance&apos;) (now a syntax error) I imagine it’s a mess and by the issue you posted looks like create index might not be that general, for now I will create and register the clause myself thanks for the help 🙂"><y>#</y><d>2022-06-29</d><h>16:17</h><r>bortexz</r>Adding :quoted true didn’t work, it still complains. Even executing the SQL with quotes doesn’t work
<pre>ALTER TABLE fruit ADD INDEX &apos;look&apos;(&apos;appearance&apos;)</pre>
(now a syntax error)

I imagine it’s a mess and by the issue you posted looks like create index might not be that general, for now I will create and register the clause myself

thanks for the help <b>🙂</b></z><z id="t1656519596" t="seancorfield It should be double quotes, not single."><y>#</y><d>2022-06-29</d><h>16:19</h><r>seancorfield</r>It should be double quotes, not single.</z><z id="t1656519612" t="seancorfield ALTER TABLE &quot;fruit&quot; ADD INDEX &quot;look&quot; (&quot;appearance&quot;)"><y>#</y><d>2022-06-29</d><h>16:20</h><r>seancorfield</r><code>ALTER TABLE &quot;fruit&quot; ADD INDEX &quot;look&quot; (&quot;appearance&quot;)</code></z><z id="t1656519638" t="seancorfield That syntax is used in several tutorials I found for PostgreSQL so I assumed it works -- I don&apos;t use PG myself."><y>#</y><d>2022-06-29</d><h>16:20</h><r>seancorfield</r>That syntax is used in several tutorials I found for PostgreSQL so I assumed it works -- I don&apos;t use PG myself.</z><z id="t1656519690" t="seancorfield I also don&apos;t currently have DDL tests for this so I should add those."><y>#</y><d>2022-06-29</d><h>16:21</h><r>seancorfield</r>I also don&apos;t currently have DDL tests for this so I should add those.</z><z id="t1656519705" t="bortexz still complains about type “look” not existing"><y>#</y><d>2022-06-29</d><h>16:21</h><r>bortexz</r>still complains about type “look” not existing</z><z id="t1656519731" t="seancorfield OK. Thanks for testing that. The tutorials must be wrong (no surprise, I guess)."><y>#</y><d>2022-06-29</d><h>16:22</h><r>seancorfield</r>OK. Thanks for testing that. The tutorials must be wrong (no surprise, I guess).</z><z id="t1656519759" t="bortexz I also found a tutorial that made use of add index in postgres, wondering if they used to support it? But when looking through the docs of alter table on postgres 14 I couldn’t find generic add index supported, only for primary keys, constraints, uniques etc"><y>#</y><d>2022-06-29</d><h>16:22</h><r>bortexz</r>I also found a tutorial that made use of add index in postgres, wondering if they used to support it? But when looking through the docs of alter table on postgres 14 I couldn’t find generic add index supported, only for primary keys, constraints, uniques etc</z><z id="t1656561930" t="Otza Hi ! So, I got this project running on honeysql 1.x and the migration work isn’t scheduled for anytime soon. The code is hooked to a mysql database and I want to use https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html function to get change the timezone of a value using a timezone from a different column. &gt; SELECT CONVERT_TZ (foo, &apos;Europe/Oslo&apos;,&apos;UTC&apos;); How can I achieve that using the raw helper ?"><y>#</y><d>2022-06-30</d><h>04:05</h><w>Otza</w>Hi ! So, I got this project running on honeysql 1.x and the migration work isn’t scheduled for anytime soon.
The code is hooked to a mysql database and I want to use <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html" target="_blank">https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html</a> function to get change the timezone of a value using a timezone from a different column.
&gt; <pre>SELECT CONVERT_TZ (foo, &apos;Europe/Oslo&apos;,&apos;UTC&apos;);</pre>
How can I achieve that using the raw helper ?</z><z id="t1656610027" t="seancorfield Are you looking for something like this: dev=&gt; (sql/format {:select [(sql/call :convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;)] :from [:table]}) [&quot;SELECT convert_tz(foo, ?, ?) FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;] dev=&gt; You could specify column names instead of either string. No need to use raw here."><y>#</y><d>2022-06-30</d><h>17:27</h><r>seancorfield</r>Are you looking for something like this:
<pre>dev=&gt; (sql/format {:select [(sql/call :convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;)] :from [:table]})
[&quot;SELECT convert_tz(foo, ?, ?) FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;]
dev=&gt;</pre>
You could specify column names instead of either string. No need to use <code>raw</code> here.</z><z id="t1656610268" t="seancorfield And just for comparison, in v2 you don&apos;t need call -- you can use the &quot;regular&quot; vector form for calls, but because of the possibility of column aliases in :select , you need extra nesting: dev=&gt; (sql/format {:select [[[:convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;]]] :from [:table]}) [&quot;SELECT CONVERT_TZ(foo, ?, ?) FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;] dev=&gt; because this has to be possible: dev=&gt; (sql/format {:select [:col1 [:col2 :alias2] [[:convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;] :alias3]] :from [:table]}) [&quot;SELECT col1, col2 AS alias2, CONVERT_TZ(foo, ?, ?) AS alias3 FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;] dev=&gt;"><y>#</y><d>2022-06-30</d><h>17:31</h><r>seancorfield</r>And just for comparison, in v2 you don&apos;t need <code>call</code> -- you can use the &quot;regular&quot; vector form for calls, but because of the possibility of column aliases in <code>:select</code>, you need extra nesting:
<pre>dev=&gt; (sql/format {:select [[[:convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;]]] :from [:table]})
[&quot;SELECT CONVERT_TZ(foo, ?, ?) FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;]
dev=&gt;</pre>
because this has to be possible:
<pre>dev=&gt; (sql/format {:select [:col1 [:col2 :alias2] [[:convert_tz :foo &quot;Europe/Oslo&quot; &quot;UTC&quot;] :alias3]] :from [:table]})
[&quot;SELECT col1, col2 AS alias2, CONVERT_TZ(foo, ?, ?) AS alias3 FROM table&quot; &quot;Europe/Oslo&quot; &quot;UTC&quot;]
dev=&gt;</pre></z><z id="t1656610282" t="seancorfield Does that help [:attrs {:href &quot;/_/_/users/UTQF861NK&quot;}] ?"><y>#</y><d>2022-06-30</d><h>17:31</h><r>seancorfield</r>Does that help <a>@UTQF861NK</a>?</z><z id="t1657002525" t="Otza that worked ! thank you 😄"><y>#</y><d>2022-07-05</d><h>06:28</h><r>Otza</r>that worked ! thank you <b>😄</b></z><z id="t1656675556" t="andersmurphy Is there a way to remove the table namespace part of a result when aliasing? Or do I have to turn off table namespaces at the JDBC level completely? For context the table namespaces are handy but we’ve recently started pushing more on to the database. So we get the database to return the keys the client wants (where namespaces matter less because json/js)."><y>#</y><d>2022-07-01</d><h>11:39</h><w>andersmurphy</w>Is there a way to remove the table namespace part of a result when aliasing? Or do I have to turn off table namespaces at the JDBC level completely? For context the table namespaces are handy but we’ve recently started pushing more on to the database. So we get the database to return the keys the client wants (where namespaces matter less because json/js).</z><z id="t1656696993" t="seancorfield I&apos;m having a hard time associating the questions here with HoneySQL. Can you provide a more concrete example of what you&apos;re asking? I think you&apos;re asking about next.jdbc behavior perhaps and not HoneySQL?"><y>#</y><d>2022-07-01</d><h>17:36</h><r>seancorfield</r>I&apos;m having a hard time associating the questions here with HoneySQL. Can you provide a more concrete example of what you&apos;re asking? I think you&apos;re asking about <code>next.jdbc</code> behavior perhaps and not HoneySQL?</z><z id="t1656737496" t="andersmurphy With jdbc.next when you alias you still get :table/alias-column-name. Is there any way to just get :alias-column-name? For a specific result/set query. .ie without turning all result sets into unqualified results. I posted it here cause I thought honesql might have some syntax for that, like :unqualified or something. Pretty uncommon used case. I think it might be easier for me to either pass in unqualified-snake-kebab-opts when calling execute! or just stripe out the qualification in clojure. I’ve somewhat answered my own question. I guess I’m having a bit of a keyword existential crisis. I’ve been enjoying the qualified keywords (previous project didn’t have them as we were using the old jdbc lib), but honeysql makes writing sql so nice that we are now using postgresql to build the exact data the client expects, so suddenly qualified keywords are a hindrance. But I’m not quite ready to drop them completely, so was looking at some halfway house of being able to turn them off in certain cases. 😅"><y>#</y><d>2022-07-02</d><h>04:51</h><r>andersmurphy</r>With jdbc.next when you alias you still get :table/alias-column-name. Is there any way to just get :alias-column-name? For a specific result/set query. .ie without turning all result sets into unqualified results. I posted it here cause I thought honesql might have some syntax for that, like :unqualified or something. Pretty uncommon used case.

I think it might be easier for me to either pass in unqualified-snake-kebab-opts when calling <code>execute!</code> or just stripe out the qualification in clojure.

I’ve somewhat answered my own question.

I guess I’m having a bit of a keyword existential crisis. I’ve been enjoying the qualified keywords (previous project didn’t have them as we were using the old jdbc lib), but honeysql makes writing sql so nice that we are now using postgresql to build the exact data the client expects, so suddenly qualified keywords are a hindrance. But I’m not quite ready to drop them completely, so was looking at some halfway house of being able to turn them off in certain cases. <b>😅</b></z><z id="t1656778528" t="seancorfield HoneySQL just builds SQL. It doesn&apos;t execute it."><y>#</y><d>2022-07-02</d><h>16:15</h><r>seancorfield</r>HoneySQL just builds SQL. It doesn&apos;t execute it.</z><z id="t1656778679" t="seancorfield You can specify a :builder-fn for an individual call to next.jdbc/execute! If you really need to. But I would recommend explicitly building the client data from result sets at the point of handoff, rather than trying to do that purely at the database level - you&apos;re mixing abstraction levels."><y>#</y><d>2022-07-02</d><h>16:17</h><r>seancorfield</r>You can specify a <code>:builder-fn</code> for an individual call to <code>next.jdbc/execute!</code> If you really need to. But I would recommend explicitly building the client data from result sets at the point of handoff, rather than trying to do that purely at the database level - you&apos;re mixing abstraction levels.</z><z id="t1656883561" t="andersmurphy “you’re mixing abstraction levels.” - You’re right. You’ve put into words what has been bothering me. Maybe we’re pushing too much onto the database, next thing I know I’ll be writing stored procedures. I guess just because honeysql makes it pleasant to do almost everything ins SQL, doesn’t mean you should. Thanks for the advice!"><y>#</y><d>2022-07-03</d><h>21:26</h><r>andersmurphy</r>“you’re mixing abstraction levels.” - You’re right. You’ve put into words what has been bothering me. Maybe we’re pushing too much onto the database, next thing I know I’ll be writing stored procedures. I guess just because honeysql makes it pleasant to do almost everything ins SQL, doesn’t mean you should. Thanks for the advice!</z><z id="t1657272307" t="slipset I really enjoy working with honeysql! Being able to write stuff like: (apply pq/or (map (fn [r] [hpg/at&gt; :components [:lift [r]]]) q)) rather than having to string concat is huge!"><y>#</y><d>2022-07-08</d><h>09:25</h><w>slipset</w>I  really enjoy working with honeysql! Being able to write stuff like:
<pre>(apply pq/or (map (fn [r] [hpg/at&gt; :components [:lift [r]]]) q))</pre>
rather than having to string concat is huge!</z><z id="t1657890940" t="valtteri Hi! Is it possible to use case in order-by ? I tried this and it outputs weird results (sql2/format {:select [:*] :from :my-table :order-by [:case [:= :a 1] :a :else :b]}) =&gt; [&quot;SELECT * FROM my_table ORDER BY case ASC, = A, a ASC, else ASC, b ASC&quot;] I also tried wrapping case to extra set of [] but that throws an exception that it&apos;s expecting a keyword."><y>#</y><d>2022-07-15</d><h>13:15</h><w>valtteri</w>Hi! Is it possible to use <code>case</code>  in <code>order-by</code> ? I tried this and it outputs weird results
<pre>(sql2/format {:select [:*]
                :from :my-table
                :order-by [:case [:= :a 1] :a :else :b]})

=&gt; [&quot;SELECT * FROM my_table ORDER BY case ASC, = A, a ASC, else ASC, b ASC&quot;]</pre>
I also tried wrapping <code>case</code> to extra set of <code>[]</code> but that throws an exception that it&apos;s expecting a keyword.</z><z id="t1657891038" t="valtteri I&apos;m trying to sort conditionally by different fields. This is supported at least in postgres"><y>#</y><d>2022-07-15</d><h>13:17</h><r>valtteri</r>I&apos;m trying to sort conditionally by different fields. This is supported at least in postgres</z><z id="t1657891222" t="valtteri Maybe the question is how do I tell that case is an expression and not a column :thinking_face:"><y>#</y><d>2022-07-15</d><h>13:20</h><r>valtteri</r>Maybe the question is how do I tell that <code>case</code>  is an  expression and not a column <b>:thinking_face:</b></z><z id="t1657896539" t="seancorfield I&apos;m on vacation today but if you create an issue on GH with details, I&apos;ll try to take a look this weekend and either add a solution to the issues (and docs) or turn it into an enhancement to be added."><y>#</y><d>2022-07-15</d><h>14:48</h><r>seancorfield</r>I&apos;m on vacation today but if you create an issue on GH with details, I&apos;ll try to take a look this weekend and either add a solution to the issues (and docs) or turn it into an enhancement to be added.</z><z id="t1657899241" t="valtteri Thanks Sean! I created an issue https://github.com/seancorfield/honeysql/issues/414 Have a nice vacation! 😎"><y>#</y><d>2022-07-15</d><h>15:34</h><r>valtteri</r>Thanks Sean! I created an issue <a href="https://github.com/seancorfield/honeysql/issues/414" target="_blank">https://github.com/seancorfield/honeysql/issues/414</a>

Have a nice vacation! <b>😎</b></z><z id="t1657916433" t="seancorfield Just in case anyone needs to know the answer, without having to read the GH issue: user=&gt; (sql/format {:select [:*] #_=&gt; :from :my-table #_=&gt; :order-by [[[:case [:= :field_x 1] :field_y :else :field_z]]]}) [&quot;SELECT * FROM my_table ORDER BY CASE WHEN field_x = ? THEN field_y ELSE field_z END ASC&quot; 1] user=&gt; and I&apos;m updating the docs to include that example for :order-by"><y>#</y><d>2022-07-15</d><h>20:20</h><r>seancorfield</r>Just in case anyone needs to know the answer, without having to read the GH issue:
<pre>user=&gt; (sql/format {:select [:*]
  #_=&gt;              :from :my-table
  #_=&gt;              :order-by [[[:case [:= :field_x 1] :field_y :else :field_z]]]})
[&quot;SELECT * FROM my_table ORDER BY CASE WHEN field_x = ? THEN field_y ELSE field_z END ASC&quot; 1]
user=&gt;</pre>
and I&apos;m updating the docs to include that example for <code>:order-by</code></z><z id="t1657916433" t="seancorfield Just in case anyone needs to know the answer, without having to read the GH issue: user=&gt; (sql/format {:select [:*] #_=&gt; :from :my-table #_=&gt; :order-by [[[:case [:= :field_x 1] :field_y :else :field_z]]]}) [&quot;SELECT * FROM my_table ORDER BY CASE WHEN field_x = ? THEN field_y ELSE field_z END ASC&quot; 1] user=&gt; and I&apos;m updating the docs to include that example for :order-by"><y>#</y><d>2022-07-15</d><h>20:20</h><w>seancorfield</w>Just in case anyone needs to know the answer, without having to read the GH issue:
<pre>user=&gt; (sql/format {:select [:*]
  #_=&gt;              :from :my-table
  #_=&gt;              :order-by [[[:case [:= :field_x 1] :field_y :else :field_z]]]})
[&quot;SELECT * FROM my_table ORDER BY CASE WHEN field_x = ? THEN field_y ELSE field_z END ASC&quot; 1]
user=&gt;</pre>
and I&apos;m updating the docs to include that example for <code>:order-by</code></z><z id="t1658430867" t="kwrooijen Is there a way to drop multiple columns with honeysql? Currently: (-&gt; (honey.sql.helpers/alter-table :account) (honey.sql.helpers/drop-column [:name :email]) (honey.sql/format)) ;; =&gt; [&quot;ALTER TABLE account DROP COLUMN name, email&quot;] Which isn&apos;t correct. It should be: [&quot;ALTER TABLE account DROP COLUMN name, DROP COLUMN email&quot;]"><y>#</y><d>2022-07-21</d><h>19:14</h><w>kwrooijen</w>Is there a way to drop multiple columns with honeysql?

Currently:
<pre>(-&gt; (honey.sql.helpers/alter-table :account)
    (honey.sql.helpers/drop-column [:name :email])
    (honey.sql/format))

;; =&gt; [&quot;ALTER TABLE account DROP COLUMN name, email&quot;]</pre>
Which isn&apos;t correct. It should be:
<pre>[&quot;ALTER TABLE account DROP COLUMN name, DROP COLUMN email&quot;]</pre></z><z id="t1658430955" t="seancorfield I&apos;ll have to check how it works on other DBs but please create a GH issue so I&apos;ll remember to look at it."><y>#</y><d>2022-07-21</d><h>19:15</h><r>seancorfield</r>I&apos;ll have to check how it works on other DBs but please create a GH issue so I&apos;ll remember to look at it.</z><z id="t1658430966" t="seancorfield DDL support is fraught with edge cases, unfortunately."><y>#</y><d>2022-07-21</d><h>19:16</h><r>seancorfield</r>DDL support is fraught with edge cases, unfortunately.</z><z id="t1658431030" t="kwrooijen Will do. Apparently I wrote my own format-clause for honeysql/v1 in the past (defmethod format-clause :drop-column* [[_ fields] _] (-&gt;&gt; fields (map #(str &quot;DROP COLUMN &quot; (sqlf/to-sql %))) (string/join &quot;,\n&quot;)))"><y>#</y><d>2022-07-21</d><h>19:17</h><r>kwrooijen</r>Will do. Apparently I wrote my own <code>format-clause</code> for honeysql/v1 in the past

<pre>(defmethod format-clause :drop-column* [[_ fields] _]
  (-&gt;&gt; fields
       (map #(str &quot;DROP COLUMN &quot; (sqlf/to-sql %)))
       (string/join &quot;,\n&quot;)))</pre></z><z id="t1658430882" t="kwrooijen (postgres)"><y>#</y><d>2022-07-21</d><h>19:14</h><w>kwrooijen</w>(postgres)</z><z id="t1659044177" t="Cora (she/her) I have a fun little issue"><y>#</y><d>2022-07-28</d><h>21:36</h><w>Cora (she/her)</w>I have a fun little issue</z><z id="t1659044205" t="Cora (she/her) this assertion is tripping me up https://github.com/seancorfield/honeysql/blob/v2.2.891/src/honey/sql/helpers.cljc#L1031-L1036"><y>#</y><d>2022-07-28</d><h>21:36</h><w>Cora (she/her)</w>this assertion is tripping me up <a href="https://github.com/seancorfield/honeysql/blob/v2.2.891/src/honey/sql/helpers.cljc#L1031-L1036" target="_blank">https://github.com/seancorfield/honeysql/blob/v2.2.891/src/honey/sql/helpers.cljc#L1031-L1036</a></z><z id="t1659044252" t="Cora (she/her) specifically I have a library that registers a clause before honeysql helpers are loaded"><y>#</y><d>2022-07-28</d><h>21:37</h><w>Cora (she/her)</w>specifically I have a library that registers a clause before honeysql helpers are loaded</z><z id="t1659044263" t="Cora (she/her) and so this assertion fails"><y>#</y><d>2022-07-28</d><h>21:37</h><w>Cora (she/her)</w>and so this assertion fails</z><z id="t1659044333" t="Cora (she/her) you can open a repl using clj -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:mvn/version &quot;2.2.891&quot;}}}&apos;"><y>#</y><d>2022-07-28</d><h>21:38</h><w>Cora (she/her)</w>you can open a repl using <code>clj -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:mvn/version &quot;2.2.891&quot;}}}&apos;</code></z><z id="t1659044347" t="Cora (she/her) and then use this to trigger the assertion error (require &apos;[honey.sql :as sql] &apos;[clojure.string :as str]) (sql/register-clause! :on (fn [_ [table &amp; columns]] [(str (sql/sql-kw :on) &quot; &quot; (sql/format-entity table) &quot;(&quot; (str/join &quot;, &quot; (mapcat sql/format-expr columns)) &quot;)&quot;)]) nil) (require &apos;[honey.sql.helpers :as sql.helpers]) "><y>#</y><d>2022-07-28</d><h>21:39</h><w>Cora (she/her)</w>and then use this to trigger the assertion error
<pre>(require &apos;[honey.sql :as sql]
         &apos;[clojure.string :as str])

(sql/register-clause!
 :on
 (fn [_ [table &amp; columns]]
   [(str (sql/sql-kw :on)
         &quot; &quot;
         (sql/format-entity table)
         &quot;(&quot;
         (str/join &quot;, &quot;
                   (mapcat sql/format-expr columns))
         &quot;)&quot;)])
 nil)

(require &apos;[honey.sql.helpers :as sql.helpers])</pre>
</z><z id="t1659044351" t="Cora (she/her) I&apos;ll file an issue"><y>#</y><d>2022-07-28</d><h>21:39</h><w>Cora (she/her)</w>I&apos;ll file an issue</z><z id="t1659044354" t="Cora (she/her) and maybe do a PR"><y>#</y><d>2022-07-28</d><h>21:39</h><w>Cora (she/her)</w>and maybe do a PR</z><z id="t1659045857" t="Cora (she/her) https://github.com/seancorfield/honeysql/pull/417"><y>#</y><d>2022-07-28</d><h>22:04</h><w>Cora (she/her)</w><a href="https://github.com/seancorfield/honeysql/pull/417" target="_blank">https://github.com/seancorfield/honeysql/pull/417</a></z><z id="t1659046117" t="Cora (she/her) I ran into this because I have non-helper-generated clauses that I need to merge and wanted to use the helpers to do it"><y>#</y><d>2022-07-28</d><h>22:08</h><w>Cora (she/her)</w>I ran into this because I have non-helper-generated clauses that I need to merge and wanted to use the helpers to do it</z><z id="t1659046138" t="Cora (she/her) it would be super nice to have a merge that would merge each of the clause types between two maps"><y>#</y><d>2022-07-28</d><h>22:08</h><w>Cora (she/her)</w>it would be super nice to have a merge that would merge each of the clause types between two maps</z><z id="t1659046156" t="Cora (she/her) but I&apos;ll definitely work something out in my app before considering contributing it back"><y>#</y><d>2022-07-28</d><h>22:09</h><w>Cora (she/her)</w>but I&apos;ll definitely work something out in my app before considering contributing it back</z><z id="t1659047231" t="seancorfield [:attrs {:href &quot;/_/_/users/U02N27RK69K&quot;}] It would probably be better to add a builtin-base-clause-order and use that in the assert and have base-clause-order initialized from that new sequence?"><y>#</y><d>2022-07-28</d><h>22:27</h><w>seancorfield</w><a>@corasaurus-hex</a> It would probably be better to add a <code>builtin-base-clause-order</code> and use that in the <code>assert</code> and have <code>base-clause-order</code> initialized from that new sequence?</z><z id="t1659065598" t="Cora (she/her) https://github.com/corasaurus-hex/honeysql/blob/d802d885e914aae69c8d2c804e0e89dd258b38fe/src/honey/sql.cljc#L928-L932 it looks like we already have this as default-clause-order"><y>#</y><d>2022-07-29</d><h>03:33</h><r>Cora (she/her)</r><a href="https://github.com/corasaurus-hex/honeysql/blob/d802d885e914aae69c8d2c804e0e89dd258b38fe/src/honey/sql.cljc#L928-L932" target="_blank">https://github.com/corasaurus-hex/honeysql/blob/d802d885e914aae69c8d2c804e0e89dd258b38fe/src/honey/sql.cljc#L928-L932</a> it looks like we already have this as <code>default-clause-order</code></z><z id="t1659065795" t="seancorfield Hmm, yeah, I just happened to have that file open right now, looking at another issue. I wonder why I set up the assert on the mutable clause order instead of the base one...?"><y>#</y><d>2022-07-29</d><h>03:36</h><r>seancorfield</r>Hmm, yeah, I just happened to have that file open right now, looking at another issue. I wonder why I set up the assert on the mutable clause order instead of the base one...?</z><z id="t1659066065" t="seancorfield So I think I can just change that one line in the assert and we&apos;re all good [:attrs {:href &quot;/_/_/users/U02N27RK69K&quot;}] ?"><y>#</y><d>2022-07-29</d><h>03:41</h><r>seancorfield</r>So I think I can just change that one line in the assert and we&apos;re all good <a>@corasaurus-hex</a>?</z><z id="t1659066066" t="Cora (she/her) I&apos;ll bet you started with base-clause-order or current-clause-order and then needed to re-use the same starting structure with the other var, giving you default-clause-order"><y>#</y><d>2022-07-29</d><h>03:41</h><r>Cora (she/her)</r>I&apos;ll bet you started with <code>base-clause-order</code> or <code>current-clause-order</code> and then needed to re-use the same starting structure with the other var, giving you <code>default-clause-order</code></z><z id="t1659066075" t="Cora (she/her) I just pushed up to that branch"><y>#</y><d>2022-07-29</d><h>03:41</h><r>Cora (she/her)</r>I just pushed up to that branch</z><z id="t1659066079" t="Cora (she/her) if you&apos;d rather just merge"><y>#</y><d>2022-07-29</d><h>03:41</h><r>Cora (she/her)</r>if you&apos;d rather just merge</z><z id="t1659066091" t="Cora (she/her) https://github.com/seancorfield/honeysql/pull/417"><y>#</y><d>2022-07-29</d><h>03:41</h><r>Cora (she/her)</r><a href="https://github.com/seancorfield/honeysql/pull/417" target="_blank">https://github.com/seancorfield/honeysql/pull/417</a></z><z id="t1659066104" t="seancorfield Heh, I already made the one word change locally but I&apos;ll check your PR and take that instead 🙂"><y>#</y><d>2022-07-29</d><h>03:41</h><r>seancorfield</r>Heh, I already made the one word change locally but I&apos;ll check your PR and take that instead <b>🙂</b></z><z id="t1659066196" t="Cora (she/her) thanks 😄"><y>#</y><d>2022-07-29</d><h>03:43</h><r>Cora (she/her)</r>thanks <b>😄</b></z><z id="t1659066821" t="seancorfield Updated changelog. There should be a new SNAPSHOT up on Clojars shortly that you can use, or via git deps. I have a few more problems to solve before I release 2.3.x..."><y>#</y><d>2022-07-29</d><h>03:53</h><r>seancorfield</r>Updated changelog. There should be a new SNAPSHOT up on Clojars shortly that you can use, or via git deps. I have a few more problems to solve before I release 2.3.x...</z><z id="t1659066861" t="seancorfield Much appreciated -- that&apos;s a really interesting edge case to have detected. Thank you!"><y>#</y><d>2022-07-29</d><h>03:54</h><r>seancorfield</r>Much appreciated -- that&apos;s a really interesting edge case to have detected. Thank you!</z><z id="t1659047264" t="seancorfield (so the builtin list never changes -- and then the assert correctly reflects the internal consistency that is needed there)"><y>#</y><d>2022-07-28</d><h>22:27</h><w>seancorfield</w>(so the builtin list never changes -- and then the assert correctly reflects the internal consistency that is needed there)</z><z id="t1659048541" t="Cora (she/her) sure, that would work"><y>#</y><d>2022-07-28</d><h>22:49</h><w>Cora (she/her)</w>sure, that would work</z><z id="t1659048603" t="Cora (she/her) i&apos;m afk right now but i&apos;ll update when i&apos;m home"><y>#</y><d>2022-07-28</d><h>22:50</h><w>Cora (she/her)</w>i&apos;m afk right now but i&apos;ll update when i&apos;m home</z><z id="t1659075442" t="orestis Yesterday I opened a PR that completely removes honeysql v1 from our codebase. I wanted to say thank you [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] for making this possible with the good decisions of honeysql v2. Much appreciated!"><y>#</y><d>2022-07-29</d><h>06:17</h><w>orestis</w>Yesterday I opened a PR that completely removes honeysql v1 from our codebase. I wanted to say thank you <a>@seancorfield</a> for making this possible with the good decisions of honeysql v2. Much appreciated!</z><z id="t1659086818" t="seancorfield Is the migration from 1.x to 2.x something you might write up as a blog post or something?"><y>#</y><d>2022-07-29</d><h>09:26</h><r>seancorfield</r>Is the migration from 1.x to 2.x something you might write up as a blog post or something?</z><z id="t1659091257" t="orestis It was rather boring to be honest! The best kind of migration. "><y>#</y><d>2022-07-29</d><h>10:40</h><r>orestis</r>It was rather boring to be honest! The best kind of migration. </z><z id="t1659091337" t="orestis We introduced the new library, decreed that no more new v1 code, and no changes to v1 code (if you want to change, rewrite to v2 first). "><y>#</y><d>2022-07-29</d><h>10:42</h><r>orestis</r>We introduced the new library, decreed that no more new v1 code, and no changes to v1 code (if you want to change, rewrite to v2 first). </z><z id="t1659091398" t="orestis The new namespace was critical to be able to do it. If it was an in-place update, we wouldn&apos;t do it. "><y>#</y><d>2022-07-29</d><h>10:43</h><r>orestis</r>The new namespace was critical to be able to do it. If it was an in-place update, we wouldn&apos;t do it. </z><z id="t1659110380" t="seancorfield That sounds like how we&apos;re doing our migration too 🙂"><y>#</y><d>2022-07-29</d><h>15:59</h><r>seancorfield</r>That sounds like how we&apos;re doing our migration too <b>🙂</b></z><z id="t1659136129" t="seancorfield I thinking about https://github.com/seancorfield/honeysql/issues/413 and wondered how many people are using the :checking option already? I&apos;m considering adding checks to :delete , :delete-from , and :update to throw an exception if there is no :where clause present or the :where conditions are empty -- if :checking :strict (or perhaps :checking :basic ). Are there valid scenarios for these three statements that do not delete/update all rows but also do not have WHERE clauses?"><y>#</y><d>2022-07-29</d><h>23:08</h><w>seancorfield</w>I thinking about <a href="https://github.com/seancorfield/honeysql/issues/413" target="_blank">https://github.com/seancorfield/honeysql/issues/413</a> and wondered how many people are using the <code>:checking</code> option already? I&apos;m considering adding checks to <code>:delete</code>, <code>:delete-from</code>, and <code>:update</code> to throw an exception if there is no <code>:where</code> clause present or the <code>:where</code> conditions are empty -- if <code>:checking :strict</code> (or perhaps <code>:checking :basic</code>). Are there valid scenarios for these three statements that do not delete/update all rows but also do not have <code>WHERE</code> clauses?</z><z id="t1659149097" t="seancorfield Although most of this is documentation updates, the key new feature is the ability to register your own dialects. Thank you to everyone who contributed code and uncovered bugs and helped improve the documentation!"><y>#</y><d>2022-07-30</d><h>02:44</h><w>seancorfield</w>Although most of this is documentation updates, the key new feature is the ability to register your own dialects. Thank you to everyone who contributed code and uncovered bugs and helped improve the documentation!</z><z id="t1659149785" t="seancorfield For folks who create their own dialects, register their own functions and clauses to go with those dialects -- create issues on the repo with details; send PRs. I&apos;d love to expand the dialects and databases that HoneySQL supports out of the box!"><y>#</y><d>2022-07-30</d><h>02:56</h><w>seancorfield</w>For folks who create their own dialects, register their own functions and clauses to go with those dialects -- create issues on the repo with details; send PRs. I&apos;d love to expand the dialects and databases that HoneySQL supports out of the box!</z><z id="t1659413802" t="quan xing I want to generate dynamic sql where conditions with honeysql . Here is my code that has achieved the result I want. Is there a better or easy way to write it? (defn select-audit-list [conn {revitId :revitId type :type pro :pro username :username}] (let [con (data.common/with-logging conn)] (let [ wheresql (cond-&gt; [:and [:= revitId :RevitID]] (not (empty? type)) (conj [:in :Type type]) (not (empty? pro)) (conj [:in :Pro pro]) (not (empty? username)) (conj [:in :username username])) sqlmap {:select :* :from :audit :where wheresql}] sqlmap (sql/format sqlmap {:inline true})))) (def args { :revitId &quot;123&quot; :type [1 2 3] :pro [&quot;p1&quot; &quot;p2&quot; &quot;p3&quot;] :username [&quot;user1&quot;] }) (select-audit-list nil args) ==&gt; [&quot;SELECT * FROM audit WHERE (&apos;123&apos; = RevitID) AND (Type IN (1, 2, 3)) AND (Pro IN (&apos;p1&apos;, &apos;p2&apos;, &apos;p3&apos;)) AND (username IN (&apos;user1&apos;))&quot;] (select-audit-list2 nil (assoc args :username [])) ==&gt; [&quot;SELECT * FROM audit WHERE (&apos;123&apos; = RevitID) AND (Type IN (1, 2, 3)) AND (Pro IN (&apos;p1&apos;, &apos;p2&apos;, &apos;p3&apos;))&quot;]"><y>#</y><d>2022-08-02</d><h>04:16</h><w>quan xing</w>I want to generate dynamic sql where conditions with honeysql . Here is my code that has achieved the result I want.  Is there a better or easy way to write it?
<pre>(defn select-audit-list
  [conn {revitId :revitId
         type :type 
         pro :pro
         username :username}]
  (let [con (data.common/with-logging conn)]
    (let [
          wheresql (cond-&gt; [:and [:= revitId :RevitID]]
                     (not (empty? type)) (conj [:in :Type type])
                     (not (empty? pro)) (conj [:in :Pro pro])
                     (not (empty? username)) (conj [:in :username username]))
          sqlmap {:select :*
                  :from :audit
                  :where wheresql}]
      sqlmap
      (sql/format sqlmap {:inline true}))))
  
(def args {
             :revitId &quot;123&quot;
             :type [1 2 3]
             :pro [&quot;p1&quot; &quot;p2&quot; &quot;p3&quot;]
             :username [&quot;user1&quot;]
  })
  
(select-audit-list nil args)
==&gt; [&quot;SELECT * FROM audit WHERE (&apos;123&apos; = RevitID) AND (Type IN (1, 2, 3)) AND (Pro IN (&apos;p1&apos;, &apos;p2&apos;, &apos;p3&apos;)) AND (username IN (&apos;user1&apos;))&quot;]

(select-audit-list2 nil (assoc args :username []))
==&gt; [&quot;SELECT * FROM audit WHERE (&apos;123&apos; = RevitID) AND (Type IN (1, 2, 3)) AND (Pro IN (&apos;p1&apos;, &apos;p2&apos;, &apos;p3&apos;))&quot;]</pre></z><z id="t1659414701" t="seancorfield Using the where helper would make this easier since it takes care of the connectives: (require [honey.sql.helpers :refer [where]]) ... (cond-&gt; (where := :revitId :RevitID) (seq type) (where :in :Type type) (seq pro) (where :in :Pro pro) (seq username) (where :in :username username)) Assuming you&apos;re using HoneySQL 2.x"><y>#</y><d>2022-08-02</d><h>04:31</h><r>seancorfield</r>Using the <code>where</code> helper would make this easier since it takes care of the connectives:
<pre>(require [honey.sql.helpers :refer [where]])
...
(cond-&gt; (where := :revitId :RevitID)
  (seq type) (where :in :Type type)
  (seq pro) (where :in :Pro pro)
  (seq username) (where :in :username username))</pre>
Assuming you&apos;re using HoneySQL 2.x</z><z id="t1659415091" t="seancorfield As an example: user=&gt; (let [username &quot;test&quot; type [1 2 3] revitId 42] #_=&gt; (cond-&gt; (where := revitId :RevitID) #_=&gt; (seq type) (where :in :Type type) #_=&gt; (seq username) (where := username :username) #_=&gt; :and (select :*) #_=&gt; :then (from :table) #_=&gt; :format (sql/format))) [&quot;SELECT * FROM table WHERE (? = RevitID) AND (Type IN (?, ?, ?)) AND (? = username)&quot; 42 1 2 3 &quot;test&quot;] user=&gt; (I know that&apos;s not quite the data you have but it should give you an idea of what I&apos;m suggesting)"><y>#</y><d>2022-08-02</d><h>04:38</h><r>seancorfield</r>As an example:
<pre>user=&gt; (let [username &quot;test&quot; type [1 2 3] revitId 42]                                                                                                          #_=&gt;   (cond-&gt; (where := revitId :RevitID)
  #_=&gt;     (seq type) (where :in :Type type)
  #_=&gt;     (seq username) (where := username :username)
  #_=&gt;     :and (select :*)                                                                                                                                    #_=&gt;     :then (from :table)
  #_=&gt;     :format (sql/format)))
[&quot;SELECT * FROM table WHERE (? = RevitID) AND (Type IN (?, ?, ?)) AND (? = username)&quot; 42 1 2 3 &quot;test&quot;]
user=&gt;</pre>
(I know that&apos;s not quite the data you have but it should give you an idea of what I&apos;m suggesting)</z><z id="t1659415149" t="seancorfield Note, in particular, that (seq foo) is more idiomatic than (not (empty? foo)) per the empty? docstring: clojure.core/empty? ([coll]) Returns true if coll has no items - same as (not (seq coll)). Please use the idiom (seq x) rather than (not (empty? x))"><y>#</y><d>2022-08-02</d><h>04:39</h><r>seancorfield</r>Note, in particular, that <code>(seq foo)</code> is more idiomatic than <code>(not (empty? foo))</code> per the <code>empty?</code> docstring:
<pre>clojure.core/empty?
([coll])
  Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))</pre></z><z id="t1659420544" t="quan xing Thank you very much [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2022-08-02</d><h>06:09</h><r>quan xing</r>Thank you very much <a>@U04V70XH6</a></z><z id="t1659420404" t="slipset FYI. We’ve built some fns on top of honey to make stuff a bit more fluent and saves us from runtime errors: (def none [:= true false]) (def all [:= true true]) (defn in [column-name values] (if (seq values) [:in column-name (set values)] none)) (defn and [&amp; clauses] (into [:and] (seq clauses))) (defn or [&amp; clauses] (into [:or] (seq clauses))) (defn lift [x] [:lift x]) "><y>#</y><d>2022-08-02</d><h>06:06</h><w>slipset</w>FYI. We’ve built some fns on top of honey to make stuff a bit more fluent and saves us from runtime errors:
<pre>(def none [:= true false])

(def all [:= true true])

(defn in
  [column-name values]
  (if (seq values)
    [:in column-name (set values)]
    none))

(defn and [&amp; clauses]
  (into [:and] (seq clauses)))

(defn or [&amp; clauses]
  (into [:or] (seq clauses)))

(defn lift [x]
  [:lift x])</pre>
</z><z id="t1659420829" t="Cora (she/her) now that&apos;s interesting"><y>#</y><d>2022-08-02</d><h>06:13</h><w>Cora (she/her)</w>now that&apos;s interesting</z><z id="t1659420886" t="Cora (she/her) the in bit especially"><y>#</y><d>2022-08-02</d><h>06:14</h><w>Cora (she/her)</w>the <code>in</code> bit especially</z><z id="t1659421044" t="Cora (she/her) filtering of nil clauses would be useful, so you could go (and (when (seq type) (in :Type type)) (when (seq pro) (in :Pro pro)))"><y>#</y><d>2022-08-02</d><h>06:17</h><w>Cora (she/her)</w>filtering of nil clauses would be useful, so you could go <code>(and (when (seq type) (in :Type type)) (when (seq pro) (in :Pro pro)))</code></z><z id="t1659421342" t="Cora (she/her) (defmacro in-when [condition column-name values] `(when ~condition [:in ~column-name ~values])) "><y>#</y><d>2022-08-02</d><h>06:22</h><w>Cora (she/her)</w><pre>(defmacro in-when
  [condition column-name values]
  `(when ~condition
     [:in ~column-name ~values]))</pre>
</z><z id="t1659421565" t="Cora (she/her) (defn and [&amp; clauses] (let [c (remove nil? clauses)] (when (seq c) (if (second c) (into [:and] (seq c)) (first c))))) "><y>#</y><d>2022-08-02</d><h>06:26</h><w>Cora (she/her)</w><pre>(defn and [&amp; clauses]
  (let [c (remove nil? clauses)]
    (when (seq c)
      (if (second c)
        (into [:and] (seq c))
        (first c)))))</pre>
</z><z id="t1659421603" t="Cora (she/her) you could do the same with or"><y>#</y><d>2022-08-02</d><h>06:26</h><w>Cora (she/her)</w>you could do the same with or</z><z id="t1659421968" t="slipset The and and or are nice in so far that you can write (pq/and foo bar baz) but, it’s a bit sucky in this situation (apply pq/and (map lol xs))"><y>#</y><d>2022-08-02</d><h>06:32</h><w>slipset</w>The <code>and</code> and <code>or</code> are nice in so far that you can write <code>(pq/and foo bar baz)</code> but, it’s a bit sucky in this situation <code>(apply pq/and (map lol xs))</code></z><z id="t1659422005" t="slipset The reason for lift is so that you can (update foo :myjsonprop lift)"><y>#</y><d>2022-08-02</d><h>06:33</h><w>slipset</w>The reason for <code>lift</code> is so that you can <code>(update foo :myjsonprop lift)</code></z><z id="t1659446670" t="ts1503 Hello guys. How can I use :drop-table clause with table names such as user (reserved names) I’m trying these things (sql/format {:drop-table &quot;foo&quot;}) =&gt; [&quot;DROP TABLE FOO&quot;] (sql/format {:drop-table :foo}) =&gt; [&quot;DROP TABLE foo&quot;] and it doesn’t work"><y>#</y><d>2022-08-02</d><h>13:24</h><w>ts1503</w>Hello guys.
How can I use <code>:drop-table</code>  clause with table names such as <code>user</code> (reserved names)
I’m trying these things
<code>(sql/format {:drop-table &quot;foo&quot;})</code>  =&gt; <code>[&quot;DROP TABLE  FOO&quot;]</code>
<code>(sql/format {:drop-table :foo})</code>  =&gt; <code>[&quot;DROP TABLE foo&quot;]</code>
and it doesn’t work</z><z id="t1659453024" t="seancorfield Check the docs for the :quoted option. You can also select the :dialect to get the quoting store you want for your database."><y>#</y><d>2022-08-02</d><h>15:10</h><r>seancorfield</r>Check the docs for the <code>:quoted</code> option. You can also select the <code>:dialect</code> to get the quoting store you want for your database.</z><z id="t1659473338" t="ts1503 that helps. thanks a lot"><y>#</y><d>2022-08-02</d><h>20:48</h><r>ts1503</r>that helps. thanks a lot</z><z id="t1659446737" t="ts1503 (sql/format {:create-table &quot;foo&quot;}) does work indeed =&gt; [&quot;CREATE TABLE \&quot;foo\&quot;&quot;]"><y>#</y><d>2022-08-02</d><h>13:25</h><w>ts1503</w><code>(sql/format {:create-table &quot;foo&quot;})</code> does work indeed
<code>=&gt; [&quot;CREATE TABLE \&quot;foo\&quot;&quot;]</code></z><z id="t1659452570" t="Cora (she/her) wanted to run some functions by you to see if you&apos;re interested in something like this in honeysql. putting it in this thread"><y>#</y><d>2022-08-02</d><h>15:02</h><w>Cora (she/her)</w>wanted to run some functions by you to see if you&apos;re interested in something like this in honeysql. putting it in this thread</z><z id="t1659452587" t="Cora (she/her)"><y>#</y><d>2022-08-02</d><h>15:03</h><r>Cora (she/her)</r></z><z id="t1659457900" t="Cora (she/her) they&apos;re rather a lot but if you have multiple queries and need to merge their concerns this gets you there. I&apos;m not a huge fan but it ended up being something we needed. it perhaps could be written better"><y>#</y><d>2022-08-02</d><h>16:31</h><r>Cora (she/her)</r>they&apos;re rather a lot but if you have multiple queries and need to merge their concerns this gets you there. I&apos;m not a huge fan but it ended up being something we needed. it perhaps could be written better</z><z id="t1659543907" t="seancorfield Looks interesting but I have a couple of concerns: a) it assumes there is a helper for every clause -- which isn&apos;t true out of the box b) it won&apos;t work for any clauses registered by users c) does ns-publics and resolve work in ClojureScript?"><y>#</y><d>2022-08-03</d><h>16:25</h><r>seancorfield</r>Looks interesting but I have a couple of concerns:
a) it assumes there is a helper for every clause -- which isn&apos;t true out of the box
b) it won&apos;t work for any clauses registered by users
c) does <code>ns-publics</code> and <code>resolve</code> work in ClojureScript?</z><z id="t1659543986" t="Cora (she/her) ahhh ok good call. never mind!"><y>#</y><d>2022-08-03</d><h>16:26</h><r>Cora (she/her)</r>ahhh ok good call. never mind!</z><z id="t1659544563" t="Cora (she/her) I&apos;m sure there would be a way to handle this well, but maybe it&apos;s not a good call overall"><y>#</y><d>2022-08-03</d><h>16:36</h><r>Cora (she/her)</r>I&apos;m sure there would be a way to handle this well, but maybe it&apos;s not a good call overall</z><z id="t1659544625" t="seancorfield I recommend always using the helpers to builder queries and just keep threading stuff together instead of building separate pieces and trying to merge them after the fact."><y>#</y><d>2022-08-03</d><h>16:37</h><r>seancorfield</r>I recommend always using the helpers to builder queries and just keep threading stuff together instead of building separate pieces and trying to merge them after the fact.</z><z id="t1659544665" t="Cora (she/her) that ship has sailed a bit, for a number of reasons, but mostly my colleagues don&apos;t like to use the helpers ¯\(ツ)/¯"><y>#</y><d>2022-08-03</d><h>16:37</h><r>Cora (she/her)</r>that ship has sailed a bit, for a number of reasons, but mostly my colleagues don&apos;t like to use the helpers ¯\(ツ)/¯</z><z id="t1659544789" t="seancorfield Hmm, maybe there&apos;s a lesson to be had in that then? 😉"><y>#</y><d>2022-08-03</d><h>16:39</h><r>seancorfield</r>Hmm, maybe there&apos;s a lesson to be had in that then? <b>😉</b></z><z id="t1659544986" t="Cora (she/her) well, sure, I agree"><y>#</y><d>2022-08-03</d><h>16:43</h><r>Cora (she/her)</r>well, sure, I agree</z><z id="t1659539939" t="raymcdermott I would like to use honeysql to connect to Postgres using nbb , so via ClojureScript - has anyone done this yet?"><y>#</y><d>2022-08-03</d><h>15:18</h><w>raymcdermott</w>I would like to use <code>honeysql</code> to connect to <code>Postgres</code> using <code>nbb</code>, so via <code>ClojureScript</code> - has anyone done this yet?</z><z id="t1659539975" t="borkdude honeysql is only for producing SQL queries, it does not make connections"><y>#</y><d>2022-08-03</d><h>15:19</h><r>borkdude</r>honeysql is only for producing SQL queries, it does not make connections</z><z id="t1659540010" t="borkdude I have an example here for honeysql + sqlite: https://github.com/babashka/nbb/blob/main/examples/sqlite/honeysql.cljs"><y>#</y><d>2022-08-03</d><h>15:20</h><r>borkdude</r>I have an example here for honeysql + sqlite:

<a href="https://github.com/babashka/nbb/blob/main/examples/sqlite/honeysql.cljs" target="_blank">https://github.com/babashka/nbb/blob/main/examples/sqlite/honeysql.cljs</a></z><z id="t1659540019" t="borkdude It should be similar for postgres"><y>#</y><d>2022-08-03</d><h>15:20</h><r>borkdude</r>It should be similar for postgres</z><z id="t1659540116" t="borkdude https://node-postgres.com/"><y>#</y><d>2022-08-03</d><h>15:21</h><r>borkdude</r><a href="https://node-postgres.com/" target="_blank">https://node-postgres.com/</a></z><z id="t1659540201" t="raymcdermott I know but come on man, I just want to cut n paste :rolling_on_the_floor_laughing:"><y>#</y><d>2022-08-03</d><h>15:23</h><r>raymcdermott</r>I know but come on man, I just want to cut n paste <b>:rolling_on_the_floor_laughing:</b></z><z id="t1659540223" t="raymcdermott I&apos;ll work it out"><y>#</y><d>2022-08-03</d><h>15:23</h><r>raymcdermott</r>I&apos;ll work it out</z><z id="t1659540350" t="borkdude I notice the syntax expected by this pg lib is $1 instead of ? what honeysql uses."><y>#</y><d>2022-08-03</d><h>15:25</h><r>borkdude</r>I notice the syntax expected by this pg lib is <code>$1</code> instead of <code>?</code> what honeysql uses.</z><z id="t1659540358" t="raymcdermott searching around GH I see that this lib has done it before"><y>#</y><d>2022-08-03</d><h>15:25</h><r>raymcdermott</r>searching around GH I see that this lib has done it before</z><z id="t1659540360" t="raymcdermott https://github.com/talented0312/jobsite/blob/3bf03eda55b40c016e613ad184b415d2623216f2/src/district/server/async_db.cljs"><y>#</y><d>2022-08-03</d><h>15:26</h><r>raymcdermott</r><a href="https://github.com/talented0312/jobsite/blob/3bf03eda55b40c016e613ad184b415d2623216f2/src/district/server/async_db.cljs" target="_blank">https://github.com/talented0312/jobsite/blob/3bf03eda55b40c016e613ad184b415d2623216f2/src/district/server/async_db.cljs</a></z><z id="t1659540376" t="raymcdermott so I&apos;ll take it from there"><y>#</y><d>2022-08-03</d><h>15:26</h><r>raymcdermott</r>so I&apos;ll take it from there</z><z id="t1659542952" t="seancorfield Yeah, the Node PG lib doesn&apos;t support regular ? placeholders -- and HoneySQL does not produce the numbered parameters. There&apos;s a ticket in the backlog for HoneySQL but it turns out to be extremely tricky with the current machinery -- although I have some ideas about making it work. HoneySQL v1 used to support the numbered parameters but almost no one was using it and since it was really handled &quot;under the hood&quot; it didn&apos;t matter much."><y>#</y><d>2022-08-03</d><h>16:09</h><r>seancorfield</r>Yeah, the Node PG lib doesn&apos;t support regular <code>?</code> placeholders -- and HoneySQL does not produce the numbered parameters. There&apos;s a ticket in the backlog for HoneySQL but it turns out to be extremely tricky with the current machinery -- although I have some ideas about making it work. HoneySQL v1 used to support the numbered parameters but almost no one was using it and since it was really handled &quot;under the hood&quot; it didn&apos;t matter much.</z><z id="t1659543057" t="borkdude I wonder how that async_db.cljs example works then"><y>#</y><d>2022-08-03</d><h>16:10</h><r>borkdude</r>I wonder how that <code>async_db.cljs</code> example works then</z><z id="t1659544141" t="seancorfield It uses HoneySQL v1 not v2. And it uses the PG extensions library for HoneySQL v1."><y>#</y><d>2022-08-03</d><h>16:29</h><r>seancorfield</r>It uses HoneySQL v1 not v2. And it uses the PG extensions library for HoneySQL v1.</z><z id="t1659544171" t="borkdude oh right"><y>#</y><d>2022-08-03</d><h>16:29</h><r>borkdude</r>oh right</z><z id="t1659544199" t="borkdude Perhaps it&apos;s not difficult to hack around this: replace each ? with a $ + an incremental number"><y>#</y><d>2022-08-03</d><h>16:29</h><r>borkdude</r>Perhaps it&apos;s not difficult to hack around this: replace each ? with a $ + an incremental number</z><z id="t1659544398" t="seancorfield In SQL ?? is the escaped version of a ? when you don&apos;t want a placeholder and PG has (at least) ~three~ four operators that include a ?"><y>#</y><d>2022-08-03</d><h>16:33</h><r>seancorfield</r>In SQL <code>??</code> is the escaped version of a <code>?</code> when you don&apos;t want a placeholder and PG has (at least) ~three~ four operators that include a <code>?</code></z><z id="t1659544467" t="seancorfield So you can &quot;hack around&quot; it for simple cases if you know what your SQL is going to contain 🙂"><y>#</y><d>2022-08-03</d><h>16:34</h><r>seancorfield</r>So you can &quot;hack around&quot; it for simple cases if you know what your SQL is going to contain <b>🙂</b></z><z id="t1659544475" t="borkdude hehe yeah..."><y>#</y><d>2022-08-03</d><h>16:34</h><r>borkdude</r>hehe yeah...</z><z id="t1659544569" t="seancorfield Have I said lately just how much I dislike SQL? And how much I particularly like PostgreSQL&apos;s extensions to SQL? 😆"><y>#</y><d>2022-08-03</d><h>16:36</h><r>seancorfield</r>Have I said lately just how much I dislike SQL? And how much I particularly like PostgreSQL&apos;s extensions to SQL? <b>😆</b></z><z id="t1659544583" t="borkdude I heard your podcast :)"><y>#</y><d>2022-08-03</d><h>16:36</h><r>borkdude</r>I heard your podcast :)</z><z id="t1659544647" t="seancorfield I should go listen to myself rant... maybe..."><y>#</y><d>2022-08-03</d><h>16:37</h><r>seancorfield</r>I should go listen to myself rant... maybe...</z><z id="t1659556569" t="raymcdermott are you suggesting that it&apos;s not recommended [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ?"><y>#</y><d>2022-08-03</d><h>19:56</h><r>raymcdermott</r>are you suggesting that it&apos;s not recommended <a>@U04V70XH6</a>?</z><z id="t1659556589" t="raymcdermott my uses cases are pretty simple tbh"><y>#</y><d>2022-08-03</d><h>19:56</h><r>raymcdermott</r>my uses cases are pretty simple tbh</z><z id="t1659556606" t="raymcdermott so strings are likely good enough"><y>#</y><d>2022-08-03</d><h>19:56</h><r>raymcdermott</r>so strings are likely good enough</z><z id="t1659558494" t="borkdude [:attrs {:href &quot;/_/_/users/U04V5V0V4&quot;}] Perhaps this also works: {:select :$1 :from :$2} "><y>#</y><d>2022-08-03</d><h>20:28</h><r>borkdude</r><a>@U04V5V0V4</a> Perhaps this also works:

<pre>{:select :$1 :from :$2}</pre>
</z><z id="t1659558537" t="borkdude {:select :$1 :from :$2 :where [[:= :x :$3]]}"><y>#</y><d>2022-08-03</d><h>20:28</h><r>borkdude</r><pre>{:select :$1 :from :$2 :where [[:= :x :$3]]}</pre></z><z id="t1659558595" t="borkdude and then you&apos;re own your own for passing those arguments in the right order"><y>#</y><d>2022-08-03</d><h>20:29</h><r>borkdude</r>and then you&apos;re own your own for passing those arguments in the right order</z><z id="t1659558765" t="seancorfield Maybe I&apos;ll try to set aside a day or two to add support for it 😞 I sort of know how to go about it (the complication is that you can&apos;t guarantee formatting actually happens strictly left-to-right -- so the actual parameters potentially need to be reordered at the end to match the order the $n were actually embedded in the final string)."><y>#</y><d>2022-08-03</d><h>20:32</h><r>seancorfield</r>Maybe I&apos;ll try to set aside a day or two to add support for it <b>😞</b> I sort of know how to go about it (the complication is that you can&apos;t guarantee formatting actually happens strictly left-to-right -- so the actual parameters potentially need to be reordered at the end to match the order the <code>$n</code> were actually embedded in the final string).</z><z id="t1659558815" t="borkdude So is this $n syntax coming from the library or is it actually a postgres syntax?"><y>#</y><d>2022-08-03</d><h>20:33</h><r>borkdude</r>So is this $n syntax coming from the library or is it actually a postgres syntax?</z><z id="t1659558878" t="seancorfield PostgreSQL supports both ? in SQL strings and $n -- presumably at the JDBC driver level."><y>#</y><d>2022-08-03</d><h>20:34</h><r>seancorfield</r>PostgreSQL supports both <code>?</code> in SQL strings and <code>$n</code> -- presumably at the JDBC driver level.</z><z id="t1659558906" t="seancorfield &quot;all&quot; JDBC drivers support ? . But not all PG drivers across all platforms support ? ."><y>#</y><d>2022-08-03</d><h>20:35</h><r>seancorfield</r>&quot;all&quot; JDBC drivers support <code>?</code>. But not all PG drivers across all platforms support <code>?</code>.</z><z id="t1659558925" t="borkdude so JDBC does the ? =&gt; $n translation?"><y>#</y><d>2022-08-03</d><h>20:35</h><r>borkdude</r>so JDBC does the ? =&gt; $n translation?</z><z id="t1659558982" t="seancorfield I&apos;m not sure what you mean by &quot;translation&quot; there."><y>#</y><d>2022-08-03</d><h>20:36</h><r>seancorfield</r>I&apos;m not sure what you mean by &quot;translation&quot; there.</z><z id="t1659559014" t="seancorfield For JDBC, generally you provide a SQL string, with a ? placeholder in the string for each parameter for the statement, in the same matching order."><y>#</y><d>2022-08-03</d><h>20:36</h><r>seancorfield</r>For JDBC, generally you provide a SQL string, with a <code>?</code> placeholder in the string for each parameter for the statement, in the same matching order.</z><z id="t1659559035" t="borkdude if postgres expects $n syntax, but JDBC supports writing ?, does JDBC driver translate this before passing it to PG? Or do drivers convert the string + arguments into something else at the driver level?"><y>#</y><d>2022-08-03</d><h>20:37</h><r>borkdude</r>if postgres expects $n syntax, but JDBC supports writing ?, does JDBC driver translate this before passing it to PG? Or do drivers convert the string + arguments into something else at the driver level?</z><z id="t1659559069" t="seancorfield PG&apos;s driver supports ? for JDBC."><y>#</y><d>2022-08-03</d><h>20:37</h><r>seancorfield</r>PG&apos;s driver supports <code>?</code> for JDBC.</z><z id="t1659559124" t="seancorfield I don&apos;t know that drivers parse the SQL string (I find that extremely unlikely but, hey, databases and drivers are weird). The generic JDBC docs talk about using ? ."><y>#</y><d>2022-08-03</d><h>20:38</h><r>seancorfield</r>I don&apos;t know that drivers parse the SQL string (I find that extremely unlikely but, hey, databases and drivers are weird). The generic JDBC docs talk about using <code>?</code>.</z><z id="t1659559174" t="seancorfield Under the hood, how each JDBC driver talks to its specific database tends to be proprietary. So &quot;anything&quot; could be happening there."><y>#</y><d>2022-08-03</d><h>20:39</h><r>seancorfield</r>Under the hood, how each JDBC driver talks to its specific database tends to be proprietary. So &quot;anything&quot; could be happening there.</z><z id="t1659559196" t="borkdude After skimming a little bit, my assumption now is that PG only supports the $n syntax natively and JDBC drivers do the ? to $n translation to offer a uniform interface"><y>#</y><d>2022-08-03</d><h>20:39</h><r>borkdude</r>After skimming a little bit, my assumption now is that PG only supports the $n syntax natively and JDBC drivers do the ? to $n translation to offer a uniform interface</z><z id="t1659559238" t="seancorfield So it&apos;s entirely possible that PG&apos;s underlying ... yeah, I was just about to say that and that&apos;s probably why the PG node driver doesn&apos;t bother and just forces users to put $n in their SQL strings."><y>#</y><d>2022-08-03</d><h>20:40</h><r>seancorfield</r>So it&apos;s entirely possible that PG&apos;s underlying ... yeah, I was just about to say that and that&apos;s probably why the PG node driver doesn&apos;t bother and just forces users to put <code>$n</code> in their SQL strings.</z><z id="t1659559277" t="seancorfield HoneySQL currently &quot;assumes&quot; JDBC even tho&apos; it is technically a clj/s library."><y>#</y><d>2022-08-03</d><h>20:41</h><r>seancorfield</r>HoneySQL currently &quot;assumes&quot; JDBC even tho&apos; it is technically a clj/s library.</z><z id="t1659591702" t="raymcdermott Does JavaScript have JDBC? 🥴"><y>#</y><d>2022-08-04</d><h>05:41</h><r>raymcdermott</r>Does JavaScript have JDBC? <b>🥴</b></z><z id="t1659735532" t="alpox Looks like the go-to querybuilder of the node-universe (KnexJS) does in its postgres adapter a simple regex replace: https://github.com/knex/knex/blob/master/lib/dialects/postgres/index.js#L140"><y>#</y><d>2022-08-05</d><h>21:38</h><r>alpox</r>Looks like the go-to querybuilder of the node-universe (KnexJS) does in its postgres adapter a simple regex replace: <a href="https://github.com/knex/knex/blob/master/lib/dialects/postgres/index.js#L140" target="_blank">https://github.com/knex/knex/blob/master/lib/dialects/postgres/index.js#L140</a></z><z id="t1659736876" t="seancorfield And what of SQL like this? &quot;SELECT &apos; ? &apos; AS answer&quot; To be fair, Apache Derby and HSQLDB both throw exceptions trying to parse this but all the other DBs/drivers I test next.jdbc against are happy with this SQL."><y>#</y><d>2022-08-05</d><h>22:01</h><r>seancorfield</r>And what of SQL like this? <code>&quot;SELECT &apos; ? &apos; AS answer&quot;</code> To be fair, Apache Derby and HSQLDB both throw exceptions trying to parse this but all the other DBs/drivers I test <code>next.jdbc</code> against are happy with this SQL.</z><z id="t1659737062" t="borkdude also the sqlite go library seemed to accept the ? output from honeysql"><y>#</y><d>2022-08-05</d><h>22:04</h><r>borkdude</r>also the sqlite go library seemed to accept the ? output from honeysql</z><z id="t1659858798" t="namenu I&apos;m using honeysql with mysql. every now and then I get fatal runtime errors caused by misused &apos;where in&apos; form. the arguments passed into in must not empty, but in reality, this check easily be omitted. Whenever this happens, I terribly miss the non-empty type. I wonder how others handle this case?"><y>#</y><d>2022-08-07</d><h>07:53</h><w>namenu</w>I&apos;m using honeysql with mysql.

every now and then I get fatal runtime errors caused by misused &apos;where in&apos; form.
the arguments passed into <code>in</code> must not empty, but in reality, this check easily be omitted.
Whenever this happens, I terribly miss the non-empty type.

I wonder how others handle this case?</z><z id="t1659859483" t="namenu idea: what if we replace where-in with logical false when the argument is empty?"><y>#</y><d>2022-08-07</d><h>08:04</h><r>namenu</r>idea:
what if we replace where-in with logical false when the argument is empty?</z><z id="t1659896910" t="seancorfield Since it&apos;s impossible to know whether this is a programming error or intended to be either a logical false or a logical true, there&apos;s :checking so you can get an exception from HoneySQL itself."><y>#</y><d>2022-08-07</d><h>18:28</h><r>seancorfield</r>Since it&apos;s impossible to know whether this is a programming error or intended to be either a logical false or a logical true, there&apos;s <code>:checking</code> so you can get an exception from HoneySQL itself.</z><z id="t1659925088" t="namenu but logically A ⊂ ∅ is always ∅ , so isn&apos;t that irrelevant to the programmer&apos;s intent?"><y>#</y><d>2022-08-08</d><h>02:18</h><r>namenu</r>but logically <code>A ⊂ ∅</code>  is always <code>∅</code> , so isn&apos;t that irrelevant to the programmer&apos;s intent?</z><z id="t1659928446" t="seancorfield I can construct a SQL statement with a join over an IN condition that will likely give you an &quot;unexpected&quot; result if IN () produced false -- so you&apos;re much safer getting an exception."><y>#</y><d>2022-08-08</d><h>03:14</h><r>seancorfield</r>I can construct a SQL statement with a join over an <code>IN</code> condition that will likely give you an &quot;unexpected&quot; result if <code>IN ()</code> produced <code>false</code> -- so you&apos;re much safer getting an exception.</z><z id="t1660048923" t="sheluchin Is there any way to convert raw SQL to HoneySQL expressions?"><y>#</y><d>2022-08-09</d><h>12:42</h><w>sheluchin</w>Is there any way to convert raw SQL to HoneySQL expressions?</z><z id="t1660070939" t="seancorfield Someone would have to write a full SQL parser. That&apos;s a lot of work (and very hard)."><y>#</y><d>2022-08-09</d><h>18:48</h><r>seancorfield</r>Someone would have to write a full SQL parser. That&apos;s a lot of work (and very hard).</z><z id="t1660071522" t="sheluchin Fair enough. Thought I&apos;d ask just in case. Some changes are just so easy to make in DB GUI - it would make to a nice workflow to be able to copy stuff from the transaction log and into your clj project as HoneySQL. Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ."><y>#</y><d>2022-08-09</d><h>18:58</h><r>sheluchin</r>Fair enough. Thought I&apos;d ask just in case. Some changes are just so easy to make in DB GUI  - it would make to a nice workflow to be able to copy stuff from the transaction log and into your clj project as HoneySQL.

Thanks <a>@U04V70XH6</a>.</z><z id="t1660071568" t="seancorfield It&apos;s been asked several times over the years -- but no one is willing to put in the time and effort to write such a thing 🙂"><y>#</y><d>2022-08-09</d><h>18:59</h><r>seancorfield</r>It&apos;s been asked several times over the years -- but no one is willing to put in the time and effort to write such a thing <b>🙂</b></z></g><g id="s7"><z id="t1660071628" t="sheluchin And that&apos;s understandable, but it would sure be cool 🙂"><y>#</y><d>2022-08-09</d><h>19:00</h><r>sheluchin</r>And that&apos;s understandable, but it would sure be cool <b>🙂</b></z><z id="t1660152911" t="krydos There is https://github.com/camsaul/sqlhoney by [:attrs {:href &quot;/_/_/users/U42REFCKA&quot;}] It’s unable to parse complex queries but it’s a good base for that special someone who’s willing to spend time on this. It also has the best name for such kind of tool indeed"><y>#</y><d>2022-08-10</d><h>17:35</h><r>krydos</r>There is <a href="https://github.com/camsaul/sqlhoney" target="_blank">https://github.com/camsaul/sqlhoney</a> by <a>@U42REFCKA</a>
It’s unable to parse complex queries but it’s a good base for that special someone who’s willing to spend time on this.

It also has the best name for such kind of tool indeed</z><z id="t1660152971" t="sheluchin [:attrs {:href &quot;/_/_/users/U03G0UUUD8E&quot;}] thanks for the link. That name is a home run, for sure."><y>#</y><d>2022-08-10</d><h>17:36</h><r>sheluchin</r><a>@U03G0UUUD8E</a> thanks for the link. That name is a home run, for sure.</z><z id="t1660153064" t="Cam Saul It&apos;s definitely not ready for prime time, more of a proof of concept than anything else. I do plan on fleshing it out at some point in the next year or so. SQL parsing is something we want to add to Metabase so if anything I&apos;ll need to do it as part of my day job "><y>#</y><d>2022-08-10</d><h>17:37</h><r>Cam Saul</r>It&apos;s definitely not ready for prime time, more of a proof of concept than anything else. I do plan on fleshing it out at some point in the next year or so. SQL parsing is something we want to add to Metabase so if anything I&apos;ll need to do it as part of my day job </z><z id="t1660153090" t="Cam Saul In the meantime tho you should be able to build on it to do what you need "><y>#</y><d>2022-08-10</d><h>17:38</h><r>Cam Saul</r>In the meantime tho you should be able to build on it to do what you need </z><z id="t1660612647" t="quan xing how can I generate replace into table valeus use honeysql"><y>#</y><d>2022-08-16</d><h>01:17</h><w>quan xing</w>how can I generate <code>replace into table valeus</code> use honeysql</z><z id="t1660615670" t="seancorfield There&apos;s currently no support for that. I hadn&apos;t even heard of it. Can you provide a link to some docs for what the actual syntax should be?"><y>#</y><d>2022-08-16</d><h>02:07</h><r>seancorfield</r>There&apos;s currently no support for that. I hadn&apos;t even heard of it. Can you provide a link to some docs for what the actual syntax should be?</z><z id="t1660707846" t="quan xing https://dev.mysql.com/doc/refman/8.0/en/replace.html the old row is deleted before the new row is inserted"><y>#</y><d>2022-08-17</d><h>03:44</h><r>quan xing</r><a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html" target="_blank">https://dev.mysql.com/doc/refman/8.0/en/replace.html</a>
the old row is deleted before the new row is inserted</z><z id="t1660709458" t="seancorfield Create an issue on GitHub with that link and I&apos;ll take a look. Maybe there&apos;s similar equivalent things in other databases."><y>#</y><d>2022-08-17</d><h>04:10</h><r>seancorfield</r>Create an issue on GitHub with that link and I&apos;ll take a look. Maybe there&apos;s similar equivalent things in other databases.</z><z id="t1660796304" t="seancorfield Thanks for the issue [:attrs {:href &quot;/_/_/users/U025AG2H55F&quot;}] - I&apos;ll try to take a look this weekend."><y>#</y><d>2022-08-18</d><h>04:18</h><r>seancorfield</r>Thanks for the issue <a>@U025AG2H55F</a> - I&apos;ll try to take a look this weekend.</z><z id="t1661279652" t="steven kent Hi, in honeysql 1.0.461, does :except get converted to minus in an Oracle 18 context? Thank you"><y>#</y><d>2022-08-23</d><h>18:34</h><w>steven kent</w>Hi, in honeysql 1.0.461, does <code>:except</code> get converted to <code>minus</code> in an Oracle 18 context? Thank you</z><z id="t1661282137" t="seancorfield HoneySQL 1.x knows nothing about dialects so if it supports :except at all it would always produce EXCEPT -- but I don&apos;t think it supports that?"><y>#</y><d>2022-08-23</d><h>19:15</h><r>seancorfield</r>HoneySQL 1.x knows nothing about dialects so if it supports <code>:except</code> at all it would always produce <code>EXCEPT</code> -- but I don&apos;t think it supports that?</z><z id="t1661282260" t="seancorfield Ah, yeah, looks like :except support was added in 0.9.10 back in March 2020. And it&apos;s a pretty simple formatter: (defmethod format-clause :except [[_ maps] _] (binding [*subquery?* false] (string/join &quot; EXCEPT &quot; (map to-sql maps))))"><y>#</y><d>2022-08-23</d><h>19:17</h><r>seancorfield</r>Ah, yeah, looks like <code>:except</code> support was added in 0.9.10 back in March 2020. And it&apos;s a pretty simple formatter:
<pre>(defmethod format-clause :except [[_ maps] _]
  (binding [*subquery?* false]
    (string/join &quot; EXCEPT &quot; (map to-sql maps))))</pre></z><z id="t1661283245" t="steven kent Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2022-08-23</d><h>19:34</h><r>steven kent</r>Thanks <a>@U04V70XH6</a></z><z id="t1661283284" t="seancorfield Are you getting some strange behavior?"><y>#</y><d>2022-08-23</d><h>19:34</h><r>seancorfield</r>Are you getting some strange behavior?</z><z id="t1661285095" t="steven kent No sir, this was just a question that came up. I looked at this line, trying to answer it https://github.com/seancorfield/honeysql/blob/v1/src/honeysql/helpers.cljc#L381 but apparently that isn&apos;t the same place you pointed out"><y>#</y><d>2022-08-23</d><h>20:04</h><r>steven kent</r>No sir, this was just a question that came up. I looked at this line, trying to answer it <a href="https://github.com/seancorfield/honeysql/blob/v1/src/honeysql/helpers.cljc#L381" target="_blank">https://github.com/seancorfield/honeysql/blob/v1/src/honeysql/helpers.cljc#L381</a> but apparently that isn&apos;t the same place you pointed out</z><z id="t1661295526" t="seancorfield Ah, yes, the build-clause stuff is how the helpers were handled in v1, and they build a data structure -- nothing more -- which is then turned into SQL via format-clause which is what I linked to."><y>#</y><d>2022-08-23</d><h>22:58</h><r>seancorfield</r>Ah, yes, the <code>build-clause</code> stuff is how the helpers were handled in v1, and they build a data structure -- nothing more -- which is then turned into SQL via <code>format-clause</code> which is what I linked to.</z><z id="t1661331286" t="oly On the of chance anyone has some ideas, I was curious if honey would work with klipse for interactive snippets, I can import the library but running a simple example fails with this. ERROR: TypeError: clojure.core.into is not a function Evaluating this simple example (-&gt; (sqlh/select :*) (sqlh/from :company) (sqlh/where [:= :id 1])) Anyone tried this before or know if it may be possible ?"><y>#</y><d>2022-08-24</d><h>08:54</h><w>oly</w>On the of chance anyone has some ideas, I was curious if honey would work with klipse for interactive snippets, I can import the library but running a simple example fails with this.
<pre>ERROR: TypeError: clojure.core.into is not a function</pre>
Evaluating this simple example
<pre>(-&gt; (sqlh/select :*)
  (sqlh/from :company)
  (sqlh/where [:= :id 1]))</pre>
Anyone tried this before or know if it may be possible ?</z><z id="t1661378732" t="krydos I haven’t played with klipse but do you have any example of how you were able to import honeysql so we can try it on our end? It looks like honeysql works well with clojurescript and there is even this nice web app - https://john.shaffe.rs/honeysql/ where you can play with it. it looks like klipse is able to load libraries just based on what’s defined in require but I I’m not sure if it works with honeysql."><y>#</y><d>2022-08-24</d><h>22:05</h><r>krydos</r>I haven’t played with klipse but do you have any example of how you were able to import honeysql so we can try it on our end?
It looks like honeysql works well with clojurescript and there is even this nice web app - <a href="https://john.shaffe.rs/honeysql/" target="_blank">https://john.shaffe.rs/honeysql/</a> where you can play with it.

it looks like klipse is able to load libraries just based on what’s defined in <code>require</code> but I I’m not sure if it works with honeysql.</z><z id="t1661415964" t="oly [:pre.cm-s-rdark.bg-near-black.silver.pa2.hljs.roboto.overflow-auto.klipse {:data-external-libs &quot;&quot;} content] So basically you add the data-external-libs as an attribute to include it then you just require honey as usual so a block like this in side the pre tag above. (ns core.demo (:require [honey.sql :as sql] [honey.sql.helpers :as sqlh])) (-&gt; (sqlh/select :*) (sqlh/from :company) (sqlh/where [:= :id 1])) Docs mention data external libs below. https://github.com/viebel/klipse/blob/master/README.md#clojure-only-1"><y>#</y><d>2022-08-25</d><h>08:26</h><r>oly</r><pre>[:pre.cm-s-rdark.bg-near-black.silver.pa2.hljs.roboto.overflow-auto.klipse
                                               {:data-external-libs &quot;&quot;} content]</pre>
So basically you add the data-external-libs as an attribute to include it then you just require honey as usual so a block like this in side the pre tag above.
<pre>(ns core.demo
  (:require
   [honey.sql :as sql]
   [honey.sql.helpers :as sqlh]))

(-&gt; (sqlh/select :*)
    (sqlh/from :company)
    (sqlh/where [:= :id 1]))</pre>
Docs mention data external libs below.
<a href="https://github.com/viebel/klipse/blob/master/README.md#clojure-only-1" target="_blank">https://github.com/viebel/klipse/blob/master/README.md#clojure-only-1</a></z><z id="t1661487133" t="seancorfield I see you asked in the #klipse channel in early July and didn&apos;t get an answer to that? HoneySQL definitely works in regular ClojureScript environments so I suspect this is something to do with Klipse perhaps getting confused by the :refer-clojure :exclude stuff? You&apos;ll have to push harder there for an answer I think. Perhaps you can create a tiny repro using a fresh GH repro and a ns that excludes a core function and then redefines it and see what Klipse does?"><y>#</y><d>2022-08-26</d><h>04:12</h><r>seancorfield</r>I see you asked in the #klipse channel in early July and didn&apos;t get an answer to that? HoneySQL definitely works in regular ClojureScript environments so I suspect this is something to do with Klipse perhaps getting confused by the <code>:refer-clojure :exclude</code> stuff? You&apos;ll have to push harder there for an answer I think. Perhaps you can create a tiny repro using a fresh GH repro and a ns that excludes a core function and then redefines it and see what Klipse does?</z><z id="t1661519982" t="oliver marks yeah I thought that could be the, case one of those things I looked into and got around to taking another stab, but like to ask around in case any oe has tried previously before spending to much time on the issue."><y>#</y><d>2022-08-26</d><h>13:19</h><r>oliver marks</r>yeah I thought that could be the, case one of those things I looked into and got around to taking another stab, but like to ask around in case any oe has tried previously before spending to much time on the issue.</z><z id="t1661331396" t="oly I noticed in the code honey seems to have it&apos;s own into function so I wonder if its related to that"><y>#</y><d>2022-08-24</d><h>08:56</h><w>oly</w>I noticed in the code honey seems to have it&apos;s own into function so I wonder if its related to that</z><z id="t1661863848" t="sheluchin Is it possible to generate PG&apos;s lateral joins? I&apos;m trying to translate this to honeysql helper calls: SELECT * FROM tags t JOIN LATERAL ( SELECT m.* FROM movies m WHERE m.tag_id = t.id ORDER BY m.created_at DESC FETCH FIRST 2 ROWS ONLY ) e1 ON true"><y>#</y><d>2022-08-30</d><h>12:50</h><w>sheluchin</w>Is it possible to generate PG&apos;s lateral joins? I&apos;m trying to translate this to honeysql helper calls:
<pre>SELECT *
FROM tags t
JOIN LATERAL (
  SELECT m.*
  FROM movies m
  WHERE m.tag_id = t.id
  ORDER BY m.created_at DESC
  FETCH FIRST 2 ROWS ONLY
) e1 ON true</pre></z><z id="t1661863955" t="sheluchin Closest I got is: (-&gt; (hh/select :*) (hh/from [:tags :t]) (hh/join (hh/lateral (-&gt; (hh/select :m.*) (hh/from [:movies :m]) (hh/where [:= :m.tag-id :t.id]) (hh/order-by [:m.created-at :desc]) (hh/fetch 10))) true))) select * from tags as t inner join lateral as ( select m.* from movies as m where m.tag_id = t.id order by m.created_at desc fetch first 10 rows only) on true"><y>#</y><d>2022-08-30</d><h>12:52</h><r>sheluchin</r>Closest I got is:
<pre>(-&gt; (hh/select :*)
      (hh/from [:tags :t])
      (hh/join
        (hh/lateral (-&gt; (hh/select :m.*)
                        (hh/from [:movies :m])
                        (hh/where [:= :m.tag-id :t.id])
                        (hh/order-by [:m.created-at :desc])
                        (hh/fetch 10)))
       true)))</pre>
<pre>select
	*
from
	tags as t
inner join lateral as (
	select
		m.*
	from
		movies as m
	where
		m.tag_id = t.id
	order by
		m.created_at desc 
    fetch first 10 rows only)
on true</pre></z><z id="t1661873120" t="seancorfield I suspect you need [ .. ] around the hh/lateral call."><y>#</y><d>2022-08-30</d><h>15:25</h><r>seancorfield</r>I suspect you need <code>[</code> .. <code>]</code> around the <code>hh/lateral</code> call.</z><z id="t1661873156" t="seancorfield (because of what the arguments to hh/join expect)"><y>#</y><d>2022-08-30</d><h>15:25</h><r>seancorfield</r>(because of what the arguments to <code>hh/join</code> expect)</z><z id="t1661873330" t="seancorfield user=&gt; (-&gt; (hh/select :*) #_=&gt; (hh/from [:tags :t]) #_=&gt; (hh/join #_=&gt; [(hh/lateral (-&gt; (hh/select :m.*) #_=&gt; (hh/from [:movies :m]) #_=&gt; (hh/where [:= :m.tag-id :t.id]) #_=&gt; (hh/order-by [:m.created-at :desc]) #_=&gt; (hh/fetch 10)))] #_=&gt; true) #_=&gt; (sql/format)) [&quot;SELECT * FROM tags AS t INNER JOIN LATERAL (SELECT m.* FROM movies AS m WHERE m.tag_id = t.id ORDER BY m.created_at DESC FETCH FIRST ? ROWS ONLY) ON TRUE&quot; 10]"><y>#</y><d>2022-08-30</d><h>15:28</h><r>seancorfield</r><pre>user=&gt; (-&gt; (hh/select :*)
  #_=&gt;       (hh/from [:tags :t])
  #_=&gt;       (hh/join
  #_=&gt;         [(hh/lateral (-&gt; (hh/select :m.*)
  #_=&gt;                         (hh/from [:movies :m])
  #_=&gt;                         (hh/where [:= :m.tag-id :t.id])
  #_=&gt;                         (hh/order-by [:m.created-at :desc])
  #_=&gt;                         (hh/fetch 10)))]
  #_=&gt;        true)
  #_=&gt;     (sql/format))
[&quot;SELECT * FROM tags AS t INNER JOIN LATERAL (SELECT m.* FROM movies AS m WHERE m.tag_id = t.id ORDER BY m.created_at DESC FETCH FIRST ? ROWS ONLY) ON TRUE&quot; 10]</pre></z><z id="t1661873418" t="sheluchin Ah, I was close 🙂 Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] . Now to translate this simplified example to my real query."><y>#</y><d>2022-08-30</d><h>15:30</h><r>sheluchin</r>Ah, I was close <b>🙂</b> Thanks <a>@U04V70XH6</a>. Now to translate this simplified example to my real query.</z><z id="t1661873421" t="seancorfield The example in the reference docs shows the raw data structure needed: user=&gt; (sql/format {:select [:foo.id [:x.id :x_id] :x.value] :cross-join [[[:lateral [:jsonb_to_recordset :foo.json_value]] [[:raw &quot;x(id text, value jsonb)&quot;]]]] :from [:foo]}) [&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)&quot;] Note the nested [ .. ] since :lateral is essentially a function call"><y>#</y><d>2022-08-30</d><h>15:30</h><r>seancorfield</r>The example in the reference docs shows the raw data structure needed:
<pre>user=&gt; (sql/format {:select [:foo.id [:x.id :x_id] :x.value]
                    :cross-join [[[:lateral
                                   [:jsonb_to_recordset :foo.json_value]]
                                  [[:raw &quot;x(id text, value jsonb)&quot;]]]]
                    :from [:foo]})
[&quot;SELECT foo.id, x.id AS x_id, x.value FROM foo CROSS JOIN LATERAL JSONB_TO_RECORDSET(foo.json_value) x(id text, value jsonb)&quot;]</pre>
Note the nested <code>[</code> .. <code>]</code> since <code>:lateral</code> is essentially a function call</z><z id="t1661873478" t="sheluchin Yes, I was looking at that and the unit tests but made an error in the translation."><y>#</y><d>2022-08-30</d><h>15:31</h><r>sheluchin</r>Yes, I was looking at that and the unit tests but made an error in the translation.</z><z id="t1661873571" t="sheluchin BTW, is there some way to get format to return the SQL string with linebreaks/formatting? Not a huge trouble to paste it to the GUI and format it there, but it would be convenient to skip that step."><y>#</y><d>2022-08-30</d><h>15:32</h><r>sheluchin</r>BTW, is there some way to get <code>format</code> to return the SQL string with linebreaks/formatting? Not a huge trouble to paste it to the GUI and format it there, but it would be convenient to skip that step.</z><z id="t1661873589" t="seancorfield There&apos;s a pretty print option -- see the docs."><y>#</y><d>2022-08-30</d><h>15:33</h><r>seancorfield</r>There&apos;s a pretty print option -- see the docs.</z><z id="t1661873699" t="sheluchin Got it. Thank you."><y>#</y><d>2022-08-30</d><h>15:34</h><r>sheluchin</r>Got it. Thank you.</z><z id="t1662313498" t="seancorfield A potentially important security update (#422), quite a few language extensions, improved extensibility (for inlining values), improved checking for &quot;unusual&quot; expressions."><y>#</y><d>2022-09-04</d><h>17:44</h><w>seancorfield</w>A potentially important security update (#422), quite a few language extensions, improved extensibility (for inlining values), improved checking for &quot;unusual&quot; expressions.</z><z id="t1662565275" t="Max Is there a way to set the honeysql checking mode globally you can for the dialect and quoting options?"><y>#</y><d>2022-09-07</d><h>15:41</h><w>Max</w>Is there a way to set the honeysql checking mode globally you can for the dialect and quoting options?</z><z id="t1662573578" t="seancorfield Not currently. Feel free to create a GH issue about it!"><y>#</y><d>2022-09-07</d><h>17:59</h><r>seancorfield</r>Not currently. Feel free to create a GH issue about it!</z><z id="t1662573975" t="Max Filed! https://github.com/seancorfield/honeysql/issues/427"><y>#</y><d>2022-09-07</d><h>18:06</h><r>Max</r>Filed! <a href="https://github.com/seancorfield/honeysql/issues/427" target="_blank">https://github.com/seancorfield/honeysql/issues/427</a></z><z id="t1662578366" t="fabrao hello all, how do I convert this to helper? {:with [[:ce {:insert-into ...} to: (sqlh/with (sqlh/insert-into ...)) ?"><y>#</y><d>2022-09-07</d><h>19:19</h><w>fabrao</w>hello all, how do I convert this to helper?
<pre>{:with [[:ce {:insert-into  ...}
to:
(sqlh/with 
       (sqlh/insert-into ...)) ?</pre></z><z id="t1662579433" t="seancorfield Are you looking for this result? user=&gt; (-&gt; (with [:ce (insert-into :table)]) (sql/format)) [&quot;WITH ce AS (INSERT INTO table)&quot;] user=&gt;"><y>#</y><d>2022-09-07</d><h>19:37</h><r>seancorfield</r>Are you looking for this result?
<pre>user=&gt; (-&gt; (with [:ce (insert-into :table)]) (sql/format))
[&quot;WITH ce AS (INSERT INTO table)&quot;]
user=&gt;</pre></z><z id="t1662579504" t="fabrao thank you Sean, I&apos;ll try that"><y>#</y><d>2022-09-07</d><h>19:38</h><r>fabrao</r>thank you Sean, I&apos;ll try that</z><z id="t1662579536" t="fabrao what is that [:ce stuff?"><y>#</y><d>2022-09-07</d><h>19:38</h><r>fabrao</r>what is that <code> [:ce </code> stuff?</z><z id="t1662583059" t="seancorfield I copied it from your code [:attrs {:href &quot;/_/_/users/U0YJJPFRA&quot;}] {:with [[:ce {:insert-into ...} The :with clause takes a sequence of pairs as a value. The helper takes any number of pairs. That&apos;s typically how all helpers work."><y>#</y><d>2022-09-07</d><h>20:37</h><r>seancorfield</r>I copied it from your code <a>@U0YJJPFRA</a>
<pre>{:with [[:ce {:insert-into  ...}</pre>
The <code>:with</code> clause takes a sequence of pairs as a value. The helper takes any number of pairs. That&apos;s typically how all helpers work.</z><z id="t1662583195" t="fabrao oh ok. It&apos;s information for with and not an operator, I got it, thank you again"><y>#</y><d>2022-09-07</d><h>20:39</h><r>fabrao</r>oh ok. It&apos;s information for <code>with</code> and not an operator, I got it, thank you again</z><z id="t1662583284" t="seancorfield It&apos;s like this: user=&gt; (-&gt; (select :a [:b :c] [[:+ :d :e] :f]) (from :table) (sql/format)) [&quot;SELECT a, b AS c, d + e AS f FROM table&quot;] user=&gt;"><y>#</y><d>2022-09-07</d><h>20:41</h><r>seancorfield</r>It&apos;s like this:
<pre>user=&gt; (-&gt; (select :a [:b :c] [[:+ :d :e] :f]) (from :table) (sql/format))
[&quot;SELECT a, b AS c, d + e AS f FROM table&quot;]
user=&gt;</pre></z><z id="t1662583319" t="seancorfield Compare with the raw data structure: user=&gt; (-&gt; (select :a [:b :c] [[:+ :d :e] :f]) (from :table)) {:select [:a [:b :c] [[:+ :d :e] :f]], :from [:table]} user=&gt;"><y>#</y><d>2022-09-07</d><h>20:41</h><r>seancorfield</r>Compare with the raw data structure:
<pre>user=&gt; (-&gt; (select :a [:b :c] [[:+ :d :e] :f]) (from :table))
{:select [:a [:b :c] [[:+ :d :e] :f]], :from [:table]}
user=&gt;</pre></z><z id="t1662583360" t="fabrao yes, undertood"><y>#</y><d>2022-09-07</d><h>20:42</h><r>fabrao</r>yes, undertood</z><z id="t1663192385" t="mattly does anyone know if there’s been much prior art for helpers on the frame clause of a postgresql window function? I’m talking about the part such as ROWS BETWEN UNBOUNDED PRECEDING AND 1 FOLLOWING EXCLUDING CURRENT ROW"><y>#</y><d>2022-09-14</d><h>21:53</h><w>mattly</w>does anyone know if there’s been much prior art for helpers on the frame clause of a postgresql window function? I’m talking about the part such as <code>ROWS BETWEN UNBOUNDED PRECEDING AND 1 FOLLOWING EXCLUDING CURRENT ROW</code></z><z id="t1663193777" t="seancorfield I don&apos;t know of anything. I don&apos;t know how much folks are using HoneySQL for window stuff at all right now..."><y>#</y><d>2022-09-14</d><h>22:16</h><r>seancorfield</r>I don&apos;t know of anything. I don&apos;t know how much folks are using HoneySQL for window stuff at all right now...</z><z id="t1663193804" t="mattly thanks;"><y>#</y><d>2022-09-14</d><h>22:16</h><r>mattly</r>thanks;</z><z id="t1663193893" t="mattly I’ve been using honeysql a lot as part of prototyping out a larger query engine, it’s been great for that"><y>#</y><d>2022-09-14</d><h>22:18</h><r>mattly</r>I’ve been using honeysql a lot as part of prototyping out a larger query engine, it’s been great for that</z><z id="t1663193899" t="mattly I may have to blaze this trail"><y>#</y><d>2022-09-14</d><h>22:18</h><r>mattly</r>I may have to blaze this trail</z><z id="t1663193963" t="seancorfield I&apos;m happy to add support into the core if you create a GH issue with details of the syntax in context and a link to the PG docs for it."><y>#</y><d>2022-09-14</d><h>22:19</h><r>seancorfield</r>I&apos;m happy to add support into the core if you create a GH issue with details of the syntax in context and a link to the PG docs for it.</z><z id="t1663575868" t="ts1503 Hello guys! Is it possible to use lower case table names when constructing create-table query? For example I have a table in my Postgres - &quot;user&quot; quoted, so in all my queries I should use a lover case name And I’m trying to do something like this (sql/format {:create-table :table :with-columns [[:user :uuid [:references :user]]]} {:quoted true}) which gives me [&quot;CREATE TABLE \&quot;table\&quot; (\&quot;user\&quot; \&quot;UUID\&quot; REFERENCES \&quot;USER\&quot;)&quot;] string with upper case &quot;USER&quot; as a table name. But Postgres doesn’t recognize it as an existing table user . and I see that HoneySQL is calling upper-case function for all columns here."><y>#</y><d>2022-09-19</d><h>08:24</h><w>ts1503</w>Hello guys!
Is it possible to use lower case table names when constructing <code>create-table</code> query?
For example I have a table in my Postgres - <code>&quot;user&quot;</code>  quoted, so in all my queries I should use a lover case name
And I’m trying to do something like this
<pre>(sql/format {:create-table :table
             :with-columns [[:user :uuid [:references :user]]]}
            {:quoted true})</pre>
which gives me <code>[&quot;CREATE TABLE \&quot;table\&quot; (\&quot;user\&quot; \&quot;UUID\&quot; REFERENCES \&quot;USER\&quot;)&quot;]</code>  string with upper case <code>&quot;USER&quot;</code> as a table name. But Postgres doesn’t recognize it as an existing table <code>user</code>.
and I see that HoneySQL is calling <code>upper-case</code> function for all columns here.</z><z id="t1663626846" t="seancorfield There&apos;s no real good solution right now but it&apos;s something I&apos;m looking at because the logic around DDL creation and casing is... a bit of a hack. If you&apos;re on a recent version of HoneySQL, you could try [:references :&apos;user] which should treat user as something literal but will probably not quote the name."><y>#</y><d>2022-09-19</d><h>22:34</h><r>seancorfield</r>There&apos;s no real good solution right now but it&apos;s something I&apos;m looking at because the logic around DDL creation and casing is... a bit of a hack. If you&apos;re on a recent version of HoneySQL, you could try <code>[:references :&apos;user]</code> which should treat <code>user</code> as something literal but will probably not quote the name.</z><z id="t1663626984" t="seancorfield As I suspected, using the &quot;literal name&quot; escape hatch also (deliberately) avoids quoting: user=&gt; (sql/format {:create-table :table :with-columns [[:user :uuid [:references :&apos;user]]]} {:quoted true}) [&quot;CREATE TABLE \&quot;table\&quot; (\&quot;user\&quot; \&quot;UUID\&quot; REFERENCES user)&quot;] user=&gt;"><y>#</y><d>2022-09-19</d><h>22:36</h><r>seancorfield</r>As I suspected, using the &quot;literal name&quot; escape hatch also (deliberately) avoids quoting:
<pre>user=&gt; (sql/format {:create-table :table
             :with-columns [[:user :uuid [:references :&apos;user]]]}
            {:quoted true})
[&quot;CREATE TABLE \&quot;table\&quot; (\&quot;user\&quot; \&quot;UUID\&quot; REFERENCES user)&quot;]
user=&gt;</pre></z><z id="t1663669479" t="ts1503 Thanks, but I think Postgres wouldn’t accept that as user is a reserved keyword and have to be quoted"><y>#</y><d>2022-09-20</d><h>10:24</h><r>ts1503</r>Thanks, but I think Postgres wouldn’t accept that as <code>user</code> is a reserved keyword and have to be quoted</z><z id="t1663669525" t="ts1503 I ended up with some custom clause for now (defn format-raw-update [_ x] [(str &quot;UPDATE &quot; (first (sql/format-expr [:inline x])))]) (sql/register-clause! :update-raw format-raw-update :update)"><y>#</y><d>2022-09-20</d><h>10:25</h><r>ts1503</r>I ended up with some custom clause for now
<pre>(defn format-raw-update [_ x]
  [(str &quot;UPDATE &quot; (first (sql/format-expr [:inline x])))])


(sql/register-clause! :update-raw format-raw-update :update)</pre></z><z id="t1663669729" t="ts1503 seems a little bit hacky but it works. Will wait for a proper solution. :thumbsup:"><y>#</y><d>2022-09-20</d><h>10:28</h><r>ts1503</r>seems a little bit hacky but it works. Will wait for a proper solution. <b>:thumbsup:</b></z><z id="t1663575899" t="ts1503 Is there a way to tell HoneySQL to leave the column name in lower case?"><y>#</y><d>2022-09-19</d><h>08:24</h><w>ts1503</w>Is there a way to tell HoneySQL to leave the column name in lower case?</z><z id="t1663869919" t="vonadz Am I missing something about how to use the -&gt;&gt; json operator for postgresql? I&apos;ve tried to no avail in the select clause (select ...) [:-&gt;&gt; :report_summary :clicks] and [:-&gt;&gt; :report_summary &quot;clicks&quot;]"><y>#</y><d>2022-09-22</d><h>18:05</h><w>vonadz</w>Am I missing something about how to use the -&gt;&gt; json operator for postgresql? I&apos;ve tried to no avail in the select clause (select ...)

<pre>[:-&gt;&gt; :report_summary :clicks]
and
[:-&gt;&gt; :report_summary &quot;clicks&quot;]</pre></z><z id="t1663871468" t="seancorfield Did you require the honey.sql.pg-ops namespace? {:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;8efdebefe0edceddebefe0a3f9e7e0a3bfbfa3e2effefae1fe&quot;}, :content (&quot;[email protected]&quot;)} See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/postgresql-support#operators-with---and-"><y>#</y><d>2022-09-22</d><h>18:31</h><r>seancorfield</r>Did you require the <code>honey.sql.pg-ops</code> namespace?
<pre>{:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;8efdebefe0edceddebefe0a3f9e7e0a3bfbfa3e2effefae1fe&quot;}, :content (&quot;[email protected]&quot;)}</pre>
See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/postgresql-support#operators-with---and-" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/postgresql-support#operators-with---and-</a></z><z id="t1663871708" t="vonadz Yes. I&apos;m getting &quot;illegal syntax in select expression &quot; Which goes away when I remove the line"><y>#</y><d>2022-09-22</d><h>18:35</h><r>vonadz</r>Yes. I&apos;m getting
&quot;illegal syntax in select expression &quot;
Which goes away when I remove the line</z><z id="t1663871747" t="seancorfield Show more of your code, please. As you can see above, it works."><y>#</y><d>2022-09-22</d><h>18:35</h><r>seancorfield</r>Show more of your code, please. As you can see above, it works.</z><z id="t1663872109" t="vonadz Running gives me the same error for the select expression. (require &apos;[honey.sql :as sql] &apos;[honey.sql.helpers :refer :all] &apos;[honey.sql.pg-ops :as pg] :reload) (-&gt; {} (select [:-&gt;&gt; :report_summary :clicks]) (from :campaigns) (sql/format))"><y>#</y><d>2022-09-22</d><h>18:41</h><r>vonadz</r>Running gives me the same error for the select expression.
<pre>(require &apos;[honey.sql :as sql] &apos;[honey.sql.helpers :refer :all] &apos;[honey.sql.pg-ops :as pg] :reload)

(-&gt; {}
    (select
     [:-&gt;&gt; :report_summary :clicks])
    (from :campaigns)
    (sql/format))</pre></z><z id="t1663872202" t="vonadz If I run it like you, in the where clause, it works"><y>#</y><d>2022-09-22</d><h>18:43</h><r>vonadz</r>If I run it like you, in the where clause, it works</z><z id="t1663872241" t="vonadz Seems like the issue is having it in select."><y>#</y><d>2022-09-22</d><h>18:44</h><r>vonadz</r>Seems like the issue is having it in select.</z><z id="t1663872519" t="vonadz temporary work around is to just use raw"><y>#</y><d>2022-09-22</d><h>18:48</h><r>vonadz</r>temporary work around is to just use raw</z><z id="t1663872559" t="seancorfield Your syntax is wrong. Read the docs around SELECT and expressions to get the nesting correct."><y>#</y><d>2022-09-22</d><h>18:49</h><r>seancorfield</r>Your syntax is wrong. Read the docs around <code>SELECT</code> and expressions to get the nesting correct.</z><z id="t1663872574" t="seancorfield Sorry for shortness. Very busy right now."><y>#</y><d>2022-09-22</d><h>18:49</h><r>seancorfield</r>Sorry for shortness. Very busy right now.</z><z id="t1663872632" t="seancorfield user=&gt; (-&gt; (select :col1 [:col2 :alias] [[:-&gt;&gt; :report_summary :clicks]]) (from :table) (sql/format)) [&quot;SELECT col1, col2 AS alias, report_summary -&gt;&gt; clicks FROM table&quot;] user=&gt;"><y>#</y><d>2022-09-22</d><h>18:50</h><r>seancorfield</r><pre>user=&gt; (-&gt; (select :col1 [:col2 :alias] [[:-&gt;&gt; :report_summary :clicks]]) (from :table) (sql/format))
[&quot;SELECT col1, col2 AS alias, report_summary -&gt;&gt; clicks FROM table&quot;]
user=&gt;</pre></z><z id="t1663872825" t="vonadz Ah tits, thanks for catching that. Sorry for the false alarm"><y>#</y><d>2022-09-22</d><h>18:53</h><r>vonadz</r>Ah tits, thanks for catching that. Sorry for the false alarm</z><z id="t1663873012" t="vonadz Small correction if anyone sees this in the future: [[:-&gt;&gt; :report_summary :clicks]] should be [[:-&gt;&gt; :report_summary &quot;clicks&quot;]]"><y>#</y><d>2022-09-22</d><h>18:56</h><r>vonadz</r>Small correction if anyone sees this in the future:
<pre>[[:-&gt;&gt; :report_summary :clicks]]</pre>
should be
<pre>[[:-&gt;&gt; :report_summary &quot;clicks&quot;]]</pre></z><z id="t1664103273" t="slipset I’ve glanced over the docs, so please feel free to direct me to the correct place with a RTFM, but I havent found how to express: insert into foo (select * from foo where bar = baz); Because it seems like hh/insert-into gets confused if it doesn’t get a hh/values ?"><y>#</y><d>2022-09-25</d><h>10:54</h><w>slipset</w>I’ve glanced over the docs, so please feel free to direct me to the correct place with a RTFM, but I havent found how to express:
<pre>insert into foo (select * from foo where bar = baz);</pre>
Because it seems like <code>hh/insert-into</code> gets confused if it doesn’t  get a <code>hh/values</code> ?</z><z id="t1664125281" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/sql-clause-reference#insert-into-replace-into has examples of this."><y>#</y><d>2022-09-25</d><h>17:01</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/sql-clause-reference#insert-into-replace-into" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/getting-started/sql-clause-reference#insert-into-replace-into</a> has examples of this.</z><z id="t1664128727" t="slipset Got it working! Thanks!"><y>#</y><d>2022-09-25</d><h>17:58</h><r>slipset</r>Got it working! Thanks!</z><z id="t1664103302" t="slipset and hh/values seem to be wanting a list of maps?"><y>#</y><d>2022-09-25</d><h>10:55</h><w>slipset</w>and <code>hh/values</code> seem to be wanting a list of maps?</z><z id="t1664535686" t="slipset New day, new question. I would love to be able to create a temporary table, but there doesn’t seem to be a hh/create-tmp-table (or underlying support for {:create-tmp-table ...} ?"><y>#</y><d>2022-09-30</d><h>11:01</h><w>slipset</w>New day, new question. I would love to be able to create a temporary table, but there doesn’t seem to be a <code>hh/create-tmp-table</code> (or underlying support for <code>{:create-tmp-table ...}</code> ?</z><z id="t1664536648" t="slipset I ended up with (at least for now) (honey.sql/register-clause! :create-temp-table (fn [_ args] [(str &quot;CREATE TEMP TABLE &quot; (name args) &quot; AS&quot;)]) :select)"><y>#</y><d>2022-09-30</d><h>11:17</h><w>slipset</w>I ended up with (at least for now)
<pre>(honey.sql/register-clause! :create-temp-table (fn [_ args]
                                                 [(str &quot;CREATE TEMP TABLE &quot; (name args) &quot; AS&quot;)])
                            :select)</pre></z><z id="t1664537457" t="slipset Next question: I want to duplicate some rows in a table while changing one column. I don’t want to enumerate all the columns, so I’ve come up with this: CREATE TEMP TABLE tmp AS (select * from foo where lol = 42); UPDATE tmp SET lol = 43; INSERT INTO foo (SELECT * from tmp); DROP TABLE tmp; (I’d be happy to get recommendations for better solutions) So these seem to be four separate sql statements, which means I need to call honey/format on a vector containing these, as my honey atm looks like: (let [tmp-table (gensym)] [(-&gt; {:create-temp-table (keyword tmp-table)} (hh/select :*) (hh/from (keyword &quot;foo&quot;) (hh/where [:= :lol 42)) (-&gt; (hh/update (keyword tmp-table)) (hh/set {:lol 43})) (-&gt; (hh/insert-into [(keyword &quot;foo&quot;) (-&gt; (hh/select :*) (hh/from (keyword tmp-table)))])) (hh/drop-table tmp-table)])) And then, somewhere else, I’d need: (map honey/format xs) Is this the approach or am I missing somehting?"><y>#</y><d>2022-09-30</d><h>11:30</h><w>slipset</w>Next question: I want to duplicate some rows in a table while changing one column. I don’t want to enumerate all the columns, so I’ve come up with this:
<pre>CREATE TEMP TABLE tmp AS (select * from foo where lol = 42);
UPDATE tmp SET lol = 43;
INSERT INTO foo (SELECT * from tmp);
DROP TABLE tmp;</pre>
(I’d be happy to get recommendations for better solutions)
So these seem to be four separate sql statements, which means I need to call <code>honey/format</code> on a vector containing these, as my honey atm looks like:
<pre>(let [tmp-table (gensym)]
    [(-&gt; {:create-temp-table (keyword tmp-table)}
         (hh/select :*)
         (hh/from (keyword &quot;foo&quot;)
         (hh/where [:= :lol 42))
     (-&gt; (hh/update (keyword tmp-table))
         (hh/set {:lol 43}))
     (-&gt; (hh/insert-into [(keyword &quot;foo&quot;)
                          (-&gt; (hh/select :*)
                              (hh/from (keyword tmp-table)))]))
     (hh/drop-table tmp-table)]))</pre>
And then, somewhere else, I’d need:
<code>(map honey/format xs)</code>

Is this the approach or am I missing somehting?</z><z id="t1664541758" t="slipset Oh, my colleague was smarter than me: (hh/create-table-as :temp (keyword tmp-table)) gives me a temp table 🙂"><y>#</y><d>2022-09-30</d><h>12:42</h><w>slipset</w>Oh, my colleague was smarter than me:
<code>(hh/create-table-as :temp (keyword tmp-table))</code>
gives me a temp table <b>🙂</b></z><z id="t1664560021" t="seancorfield Yeah, I should probably call that out in the docs that all the :create* operations accept one or more keywords and just make SQL out of them 🙂"><y>#</y><d>2022-09-30</d><h>17:47</h><w>seancorfield</w>Yeah, I should probably call that out in the docs that all the <code>:create*</code> operations accept one or more keywords and just make SQL out of them <b>🙂</b></z><z id="t1664560085" t="seancorfield user=&gt; (sql/format (-&gt; (create-table-as :fee :fie :foe :fum) (select :*) (from :bar))) [&quot;CREATE FEE FIE FOE TABLE fum AS SELECT * FROM bar&quot;] user=&gt;"><y>#</y><d>2022-09-30</d><h>17:48</h><w>seancorfield</w><pre>user=&gt; (sql/format (-&gt; (create-table-as :fee :fie :foe :fum) (select :*) (from :bar)))
[&quot;CREATE FEE FIE FOE TABLE fum AS SELECT * FROM bar&quot;]
user=&gt;</pre></z><z id="t1664560258" t="seancorfield https://github.com/seancorfield/honeysql/issues/435"><y>#</y><d>2022-09-30</d><h>17:50</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/435" target="_blank">https://github.com/seancorfield/honeysql/issues/435</a></z><z id="t1664565689" t="slipset And, just in case you weren&apos;t aware, I&apos;m really appreciative of the work you do with next.jdbc and honey. They&apos;re such a pleasure to work with!"><y>#</y><d>2022-09-30</d><h>19:21</h><w>slipset</w>And, just in case you weren&apos;t aware, I&apos;m really appreciative of the work you do with next.jdbc and honey. They&apos;re such a pleasure to work with!</z><z id="t1664566229" t="seancorfield Thank you! It&apos;s always nice to hear that. As you well know, as a project maintainer, all you tend to see is a steady stream of complaints about documentation and bugs and questions that are often answered by RTFM 🙂"><y>#</y><d>2022-09-30</d><h>19:30</h><r>seancorfield</r>Thank you! It&apos;s always nice to hear that. As you well know, as a project maintainer, all you tend to see is a steady stream of complaints about documentation and bugs and questions that are often answered by RTFM <b>🙂</b></z><z id="t1664570277" t="lread To jump on the gratitude bandwagon: I’ve only used honeysql once, but absolutely loved it! It was early on in my Clojure journey and the power of seeing SQL statements as easy to manipulate data really opened my eyes. I look forward to using it again!"><y>#</y><d>2022-09-30</d><h>20:37</h><r>lread</r>To jump on the gratitude bandwagon: I’ve only used honeysql once, but absolutely loved it!  It was early on in my Clojure journey and the power of seeing SQL statements as easy to manipulate data really opened my eyes. I look forward to using it again!</z><z id="t1664910363" t="David Pham Thanks a lot for honeySQL it is a wonderful library :)"><y>#</y><d>2022-10-04</d><h>19:06</h><w>David Pham</w>Thanks a lot for honeySQL it is a wonderful library :)</z><z id="t1665487409" t="sheluchin Sorry if I&apos;m missing it in the docs, but how do I keep something from being wrapped in parens? I&apos;m trying to get: REFERENCES FOO ON DELETE CASCADE but end up with: REFERENCES FOO ON DELETE(CASCADE)"><y>#</y><d>2022-10-11</d><h>11:23</h><w>sheluchin</w>Sorry if I&apos;m missing it in the docs, but how do I keep something from being wrapped in parens?

I&apos;m trying to get:
<pre>REFERENCES FOO ON DELETE CASCADE</pre>
but end up with:
<pre>REFERENCES FOO ON DELETE(CASCADE)</pre></z><z id="t1665499215" t="seancorfield In DDL you can probably use :delete-cascade to produce plain SQL keywords with spaces."><y>#</y><d>2022-10-11</d><h>14:40</h><r>seancorfield</r>In DDL you can probably use <code>:delete-cascade</code> to produce plain SQL keywords with spaces.</z><z id="t1665499277" t="seancorfield But it would help if you showed what DSL day you are trying... 😁"><y>#</y><d>2022-10-11</d><h>14:41</h><r>seancorfield</r>But it would help if you showed what DSL day you are trying...<b>😁</b></z><z id="t1665499833" t="sheluchin [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I&apos;m trying to do something like this: (-&gt; (hh/create-table :bar) (hh/with-columns [[:did :uuid [:default [:gen_random_uuid]]] [:foo-id :varchar [:not nil]] [[:primary-key :did :foo-id]] [[:foreign-key :foo-id] [:references :foo] [:on-delete :cascade]]])) The Postgres syntax I&apos;m trying to produce is like this: CREATE TABLE order_items ( product_no integer REFERENCES products ON DELETE RESTRICT, order_id integer REFERENCES orders ON DELETE CASCADE, quantity integer, PRIMARY KEY (product_no, order_id) );"><y>#</y><d>2022-10-11</d><h>14:50</h><r>sheluchin</r><a>@U04V70XH6</a> I&apos;m trying to do something like this:
<pre>(-&gt; (hh/create-table :bar)
    (hh/with-columns
      [[:did :uuid [:default [:gen_random_uuid]]]
       [:foo-id :varchar [:not nil]]
       [[:primary-key :did :foo-id]]
       [[:foreign-key :foo-id]
        [:references :foo]
        [:on-delete :cascade]]]))</pre>
The Postgres syntax I&apos;m trying to produce is like this:

<pre>CREATE TABLE order_items (
    product_no integer REFERENCES products ON DELETE RESTRICT,
    order_id integer REFERENCES orders ON DELETE CASCADE,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);</pre></z><z id="t1665505908" t="seancorfield Can you create a GH issue with that example so I can think about it? DDL is horribly non-regular so trying to figure out DSL syntax for it is tricky at times. I&apos;m not sure right now what the best solution for this case is -- I&apos;ll have to look at how various databases handle this."><y>#</y><d>2022-10-11</d><h>16:31</h><r>seancorfield</r>Can you create a GH issue with that example so I can think about it? DDL is horribly non-regular so trying to figure out DSL syntax for it is tricky at times. I&apos;m not sure right now what the best solution for this case is -- I&apos;ll have to look at how various databases handle this.</z><z id="t1665506162" t="sheluchin Thanks, [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] . I&apos;ll have that issue up sometime soon. I was asking in here just in case I missed it. Grepping through the project I saw there was some mention of added support for CREATE TABLE / CASCADE a while ago, but couldn&apos;t find supporting examples to match my target: https://github.com/seancorfield/honeysql/blob/dda3aa017e62b54863d302252c574fabf687543c/CHANGELOG.md?plain=1#L139-L141"><y>#</y><d>2022-10-11</d><h>16:36</h><r>sheluchin</r>Thanks, <a>@U04V70XH6</a>. I&apos;ll have that issue up sometime soon. I was asking in here just in case I missed it. Grepping through the project I saw there was some mention of added support for <code>CREATE TABLE</code> / <code>CASCADE</code> a while ago, but couldn&apos;t find supporting examples to match my target:

<a href="https://github.com/seancorfield/honeysql/blob/dda3aa017e62b54863d302252c574fabf687543c/CHANGELOG.md?plain=1#L139-L141" target="_blank">https://github.com/seancorfield/honeysql/blob/dda3aa017e62b54863d302252c574fabf687543c/CHANGELOG.md?plain=1#L139-L141</a></z><z id="t1665506385" t="seancorfield DROP .. CASCADE is supported, as I recall, but that change entry refers to the top-level DSL clauses, not columns within CREATE TABLE ."><y>#</y><d>2022-10-11</d><h>16:39</h><r>seancorfield</r><code>DROP .. CASCADE</code> is supported, as I recall, but that change entry refers to the top-level DSL clauses, not columns within <code>CREATE TABLE</code>.</z><z id="t1665835792" t="sheluchin https://github.com/seancorfield/honeysql/issues/437 Just leaving the link to the issue here for reference."><y>#</y><d>2022-10-15</d><h>12:09</h><r>sheluchin</r><a href="https://github.com/seancorfield/honeysql/issues/437" target="_blank">https://github.com/seancorfield/honeysql/issues/437</a>

Just leaving the link to the issue here for reference.</z><z id="t1666623057" t="hifumi123 Recently I had to deal with DDLs as well. In particular clauses like ON DELETE SET NULL ON UPDATE CASCADE . I wasn&apos;t able to get this outputted with e.g. [:on-delete :set nil] , but as a temporary workaround you can use individual keywords. That is, you can use :on :delete :set nil :on :update :cascade for the time being. This is what I plan to do until HoneySQL improves support for this kind of syntax"><y>#</y><d>2022-10-24</d><h>14:50</h><r>hifumi123</r>Recently I had to deal with DDLs as well. In particular clauses like <code>ON DELETE SET NULL ON UPDATE CASCADE</code>. I wasn&apos;t able to get this outputted with e.g. <code>[:on-delete :set nil]</code>, but as a temporary workaround you can use individual keywords. That is, you can use <code>:on :delete :set nil :on :update :cascade</code> for the time being. This is what I plan to do until HoneySQL improves support for this kind of syntax</z><z id="t1666041561" t="Max Is there a way to do DELETE FROM ? CASCADE in honeysql?"><y>#</y><d>2022-10-17</d><h>21:19</h><w>Max</w>Is there a way to do <code>DELETE FROM ? CASCADE</code> in honeysql?</z><z id="t1666050134" t="seancorfield No. Feel free to open a GH issue for it, with links to the database documentation for the syntax that shows what is possible (and then I have to determine whether this portable across multiple databases etc)."><y>#</y><d>2022-10-17</d><h>23:42</h><r>seancorfield</r>No. Feel free to open a GH issue for it, with links to the database documentation for the syntax that shows what is possible (and then I have to determine whether this portable across multiple databases etc).</z><z id="t1666050861" t="Max Filed: https://github.com/seancorfield/honeysql/issues/438"><y>#</y><d>2022-10-17</d><h>23:54</h><r>Max</r>Filed: <a href="https://github.com/seancorfield/honeysql/issues/438" target="_blank">https://github.com/seancorfield/honeysql/issues/438</a></z><z id="t1666051029" t="seancorfield Not delete from? 🙂"><y>#</y><d>2022-10-17</d><h>23:57</h><r>seancorfield</r>Not delete from? <b>🙂</b></z><z id="t1666051076" t="Max facepalm typo, delete doesn’t support cascade. Just truncate"><y>#</y><d>2022-10-17</d><h>23:57</h><r>Max</r><b>facepalm</b> typo, delete doesn’t support cascade. Just truncate</z><z id="t1666051101" t="Max That should teach me to ask questions at 5pm"><y>#</y><d>2022-10-17</d><h>23:58</h><r>Max</r>That should teach me to ask questions at 5pm</z><z id="t1666333323" t="Денис Нибаев Hello. Is there any way to add filter to windos function? Something like: {:select [[[:over [[:count :fact_2] {:partition-by [:p] :filter {:where [:is-not :fact_2 nil]}} :stage_2_count]]]]} "><y>#</y><d>2022-10-21</d><h>06:22</h><w>Денис Нибаев</w>Hello. Is there any way to add filter to windos function? Something like:
<pre>{:select [[[:over
               [[:count :fact_2]
                {:partition-by [:p]
                 :filter       {:where [:is-not :fact_2 nil]}}
                :stage_2_count]]]]}</pre>
</z><z id="t1666377702" t="seancorfield Create a GH issue and I&apos;ll take a look at adding support for that."><y>#</y><d>2022-10-21</d><h>18:41</h><r>seancorfield</r>Create a GH issue and I&apos;ll take a look at adding support for that.</z><z id="t1666358474" t="ivana Hello! format returns [&quot;FROM heron.heron_file hf WHERE hf.external_file_id = ?&quot; 33] May I get just raw string, i.e. &quot;FROM heron.heron_file hf WHERE hf.external_file_id = 33&quot; somehow, with already substituted all the ? by param values?"><y>#</y><d>2022-10-21</d><h>13:21</h><w>ivana</w>Hello! <code>format</code>  returns <code>[&quot;FROM heron.heron_file hf WHERE hf.external_file_id = ?&quot; 33]</code>  May I get just raw string, i.e. <code>&quot;FROM heron.heron_file hf WHERE hf.external_file_id = 33&quot;</code>  somehow, with already substituted all the ? by param values?</z><z id="t1666361001" t="Pragyan Tripathi You need to pass options parameter :inline true"><y>#</y><d>2022-10-21</d><h>14:03</h><r>Pragyan Tripathi</r>You need to pass options parameter <code>:inline true</code></z><z id="t1666361039" t="ivana Thanks alot!"><y>#</y><d>2022-10-21</d><h>14:03</h><r>ivana</r>Thanks alot!</z><z id="t1666377812" t="seancorfield Just be aware of security issues here -- only use :inline true when you are guaranteed that all parameters are under your control and are validated! If you want to inline just one known-safe value, wrap it in [:inline 33] (and then you don&apos;t need :inline true as an option). The docs have warnings about security and :inline ."><y>#</y><d>2022-10-21</d><h>18:43</h><r>seancorfield</r>Just be aware of security issues here -- only use <code>:inline true</code> when you are guaranteed that all parameters are under your control and are validated!

If you want to inline just one known-safe value, wrap it in <code>[:inline 33]</code> (and then you don&apos;t need <code>:inline true</code> as an option).

The docs have warnings about security and <code>:inline</code>.</z><z id="t1666386904" t="ivana Thanks, didn&apos;t know. Anyway I tried to solve some problems with version 1 and tried to write my own helpers &amp; wrappers for it. But finally I found, yhat version 2 works also with some bugs, but much better than 1 and may be extended in a custom way without inlining parameters."><y>#</y><d>2022-10-21</d><h>21:15</h><r>ivana</r>Thanks, didn&apos;t know. Anyway I tried to solve some problems with version 1 and tried to write my own helpers &amp; wrappers for it. But finally I found, yhat version 2 works also with some bugs, but much better than 1 and may be extended in a custom way without inlining parameters.</z><z id="t1666389450" t="seancorfield [:attrs {:href &quot;/_/_/users/U0A6H3MFT&quot;}] The docs are also substantially better for v2 🙂"><y>#</y><d>2022-10-21</d><h>21:57</h><r>seancorfield</r><a>@U0A6H3MFT</a> The docs are also substantially better for v2 <b>🙂</b></z><z id="t1666589719" t="hifumi123 ~How would one express ~ EDIT: Never mind, it works as intended. I misread the output from my REPL."><y>#</y><d>2022-10-24</d><h>05:35</h><w>hifumi123</w>~How would one express ~

EDIT: Never mind, it works as intended. I misread the output from my REPL.</z><z id="t1666698605" t="Jakub Holý (HolyJak) Hello! I can I use column = ANY &lt;array expression&gt; with Honey? https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.30.16 . Do I need to fall back on :raw ? [:= column-name [:ANY (into-array String values)]] seems to work"><y>#</y><d>2022-10-25</d><h>11:50</h><w>Jakub Holý (HolyJak)</w>Hello! I can I use <code>column = ANY &lt;array expression&gt;</code> with Honey? <a href="https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.30.16" target="_blank">https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.30.16</a>. Do I need to fall back on <code>:raw</code> ?

<code>[:= column-name [:ANY (into-array String values)]]</code> seems to work</z><z id="t1666780543" t="Pragyan Tripathi How can I create honeysql equivalent for: CREATE TABLE IF NOT EXISTS &quot;Blog&quot; ( &quot;id&quot; SERIAL NOT NULL, &quot;title&quot; TEXT NOT NULL, &quot;comments&quot; TEXT[] DEFAULT ARRAY[&apos;hello&apos;, &apos;world&apos;]::TEXT[], CONSTRAINT &quot;blog_pkey&quot; PRIMARY KEY (&quot;id&quot;) ); I am using following: {:create-table [:blog :if-not-exists], :with-columns [[:id :uuid [:not nil]] [:comments [:raw &quot;text[]&quot;] [:default [:raw &quot;ARRAY[hello, world]::text[]&quot;]]] [[:constraint :blog_pkey] [:primary-key :id]]]} But this results in [&quot;CREATE TABLE IF NOT EXISTS blog (id UUID NOT NULL, comments TEXT[] DEFAULT ARRAY[HELLO, WORLD]::TEXT[], CONSTRAINT blog_pkey PRIMARY KEY(ID))&quot;] Cases in the default values are incorrect. Is there a way I can do it without using :raw operator."><y>#</y><d>2022-10-26</d><h>10:35</h><w>Pragyan Tripathi</w>How can I create honeysql equivalent for:

<pre>CREATE TABLE IF NOT EXISTS &quot;Blog&quot; (
    &quot;id&quot; SERIAL NOT NULL,
    &quot;title&quot; TEXT NOT NULL,
    &quot;comments&quot; TEXT[] DEFAULT ARRAY[&apos;hello&apos;, &apos;world&apos;]::TEXT[],

    CONSTRAINT &quot;blog_pkey&quot; PRIMARY KEY (&quot;id&quot;)
);</pre>
I am using following:

<pre>{:create-table [:blog :if-not-exists],
 :with-columns
 [[:id :uuid [:not nil]]
  [:comments
   [:raw &quot;text[]&quot;]
   [:default [:raw &quot;ARRAY[hello, world]::text[]&quot;]]]
  [[:constraint :blog_pkey] [:primary-key :id]]]}</pre>
But this results in

<pre>[&quot;CREATE TABLE IF NOT EXISTS blog (id UUID NOT NULL, comments TEXT[] DEFAULT ARRAY[HELLO, WORLD]::TEXT[], CONSTRAINT blog_pkey PRIMARY KEY(ID))&quot;]</pre>
Cases in the default values are incorrect.

Is there a way I can do it without using <code>:raw</code> operator.</z><z id="t1666813661" t="seancorfield There&apos;s a GH issue open that mentions this https://github.com/seancorfield/honeysql/issues/386 -- DDL support is very tricky to get right since it is so vendor-specific and the heuristic for upper-casing parts of the declaration is too zealous at the moment. So the TL;DR: is &quot;No, you can&apos;t do this right now&quot; but I plan to fix it at some point."><y>#</y><d>2022-10-26</d><h>19:47</h><r>seancorfield</r>There&apos;s a GH issue open that mentions this <a href="https://github.com/seancorfield/honeysql/issues/386" target="_blank">https://github.com/seancorfield/honeysql/issues/386</a> -- DDL support is very tricky to get right since it is so vendor-specific and the heuristic for upper-casing parts of the declaration is too zealous at the moment.

So the TL;DR: is &quot;No, you can&apos;t do this right now&quot; but I plan to fix it at some point.</z><z id="t1666842693" t="Pragyan Tripathi Got it. Thanks. Are there ideas about how you are planning to solve it? I can try to implement it for my use case."><y>#</y><d>2022-10-27</d><h>03:51</h><r>Pragyan Tripathi</r>Got it. Thanks. Are there ideas about how you are planning to solve it? I can try to implement it for my use case.</z><z id="t1666844190" t="seancorfield I don&apos;t know yet. DDL is horribly inconsistent and doesn&apos;t follow the &quot;normal&quot; rules of SQL syntax."><y>#</y><d>2022-10-27</d><h>04:16</h><r>seancorfield</r>I don&apos;t know yet. DDL is horribly inconsistent and doesn&apos;t follow the &quot;normal&quot; rules of SQL syntax.</z><z id="t1666844268" t="seancorfield There are good reasons why HoneySQL v1 pretty much didn&apos;t touch DDL at all 🙂"><y>#</y><d>2022-10-27</d><h>04:17</h><r>seancorfield</r>There are good reasons why HoneySQL v1 pretty much didn&apos;t touch DDL at all <b>🙂</b></z><z id="t1666878123" t="ts1503 Hey [:attrs {:href &quot;/_/_/users/U02JRAM6CBA&quot;}] I ended up with custom clause like this one"><y>#</y><d>2022-10-27</d><h>13:42</h><r>ts1503</r>Hey <a>@U02JRAM6CBA</a>
I ended up with custom clause like this one</z><z id="t1666878204" t="ts1503 last screenshot didn’t capture all code"><y>#</y><d>2022-10-27</d><h>13:43</h><r>ts1503</r>last screenshot didn’t capture all code</z><z id="t1666918097" t="Pragyan Tripathi This is great. WIll give adding custom-clause a try."><y>#</y><d>2022-10-28</d><h>00:48</h><r>Pragyan Tripathi</r>This is great. WIll give adding custom-clause a try.</z><z id="t1666912129" t="Jungwoo Kim Hello! Does honeysql support *&amp;lt;&lt;https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to%7C&amp;lt;=&amp;gt;&amp;gt;*(null-safe&gt; operator) in mysql? I’ve checked out &lt;https://github.com/seancorfield/honeysql/blob/develop/doc/operator-reference.md|here&gt;. Is there any workaround instead of `:raw`?"><y>#</y><d>2022-10-27</d><h>23:08</h><w>Jungwoo Kim</w>Hello! Does honeysql support *&amp;lt;&lt;https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to%7C&amp;lt;=&amp;gt;&amp;gt;*(null-safe&gt; operator) in mysql? I’ve checked out &lt;https://github.com/seancorfield/honeysql/blob/develop/doc/operator-reference.md|here&gt;. Is there any workaround instead of `:raw`?</z><z id="t1666913407" t="seancorfield It&apos;s not built-in but that example is specifically given in both the README https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/readme#extensibility and Extending HoneySQL https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/extending-honeysql#registering-a-new-operator"><y>#</y><d>2022-10-27</d><h>23:30</h><r>seancorfield</r>It&apos;s not built-in but that example is specifically given in both the README <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/readme#extensibility" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/readme#extensibility</a> and Extending HoneySQL <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/extending-honeysql#registering-a-new-operator" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.3.928/doc/extending-honeysql#registering-a-new-operator</a></z><z id="t1666913438" t="seancorfield Feel free to create a GH issue so it gets registered by default when the :mysql dialect is selected."><y>#</y><d>2022-10-27</d><h>23:30</h><r>seancorfield</r>Feel free to create a GH issue so it gets registered by default when the <code>:mysql</code> dialect is selected.</z><z id="t1666913463" t="seancorfield (I&apos;ve used MySQL for over a decade and I&apos;ve never encountered that operator!)"><y>#</y><d>2022-10-27</d><h>23:31</h><r>seancorfield</r>(I&apos;ve used MySQL for over a decade and I&apos;ve never encountered that operator!)</z><z id="t1666913483" t="seancorfield Maybe it&apos;s new in 8.0? (we&apos;re still on 5.7 for... reasons...)"><y>#</y><d>2022-10-27</d><h>23:31</h><r>seancorfield</r>Maybe it&apos;s new in 8.0? (we&apos;re still on 5.7 for... reasons...)</z><z id="t1666913488" t="hifumi123 Aha, I was about to mention that it should be possible to patch into HoneySQL by using register-op! I also can&apos;t say I&apos;ve used &lt;=&gt; before, but I mostly use PostgreSQL, which probably lacks it"><y>#</y><d>2022-10-27</d><h>23:31</h><r>hifumi123</r>Aha, I was about to mention that it should be possible to patch into HoneySQL by using
<pre>register-op!</pre>
I also can&apos;t say I&apos;ve used <code>&lt;=&gt;</code> before, but I mostly use PostgreSQL, which probably lacks it</z><z id="t1666913798" t="Jungwoo Kim Thanks you all. I would try to use register op first."><y>#</y><d>2022-10-27</d><h>23:36</h><r>Jungwoo Kim</r>Thanks you all. I would try to use register op first.</z><z id="t1667313314" t="markaddleman I’m writing a custom function to support BigQuery’s SAFE_OFFSET syntax. Normally, the function will produce a vector result like [&quot;ARRAY[SAFE_OFFSET(?)]&quot; idx] but when sql/format is called with :inline true , I’d like my function to return a result with arguments inlined. My stumbling block is honey.sql/*inline* is private. I don’t see another method of determining if the client wants an inline result."><y>#</y><d>2022-11-01</d><h>14:35</h><w>markaddleman</w>I’m writing a custom function to support BigQuery’s SAFE_OFFSET syntax.  Normally, the function will produce a vector result like <code>[&quot;ARRAY[SAFE_OFFSET(?)]&quot; idx]</code> but when <code>sql/format</code> is called with <code>:inline true</code>, I’d like my function to return a result with arguments inlined.  My stumbling block is <code>honey.sql/*inline*</code> is private.  I don’t see another method of determining if the client wants an inline result.</z><z id="t1667328560" t="seancorfield If you call format-expr on the argument to safe_offset, that will take care of the inlining for you."><y>#</y><d>2022-11-01</d><h>18:49</h><r>seancorfield</r>If you call <code>format-expr</code> on the argument to safe_offset, that will take care of the inlining for you.</z><z id="t1667328755" t="markaddleman doh - of course. Thanks"><y>#</y><d>2022-11-01</d><h>18:52</h><r>markaddleman</r>doh - of course.  Thanks</z><z id="t1667471213" t="quan xing how can I covert string vector to honeysql like this: (defn sql-vec [&quot;or&quot;, [&quot;and&quot;, [&quot;=&quot;,&quot;col_a&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;col_b&quot;,1]] , [&quot;and&quot;, [&quot;=&quot;,&quot;col_d&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;col_e&quot;,1]]]) (what-fn sql-vec) output : [:or [:and [:= :col_a &quot;a&quot;],[:= :col_b 1] [:and [:= :col_c &quot;a&quot;],[:= :col_d 1]]] Is there a function that already exists"><y>#</y><d>2022-11-03</d><h>10:26</h><w>quan xing</w>how can I covert string vector to honeysql like this:
<pre>(defn sql-vec [&quot;or&quot;,
                [&quot;and&quot;, [&quot;=&quot;,&quot;col_a&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;col_b&quot;,1]]
                ,
                [&quot;and&quot;, [&quot;=&quot;,&quot;col_d&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;col_e&quot;,1]]])

(what-fn sql-vec)
output :
 [:or
     [:and [:= :col_a &quot;a&quot;],[:= :col_b 1]
     [:and [:= :col_c &quot;a&quot;],[:= :col_d 1]]]</pre>
Is there a function that already exists</z><z id="t1667489951" t="seancorfield How would you tell the difference between a column or function name and an actual string value? How/why are you using strings in the first place? HoneySQL accepts symbols as well as keywords, if that&apos;s any help and lets you use lists instead of vectors in most places: &apos;(or (and (= col_a &quot;a&quot;) (= col_b 1)) (and (= col_d &quot;a&quot;) (= col_e 1)))"><y>#</y><d>2022-11-03</d><h>15:39</h><r>seancorfield</r>How would you tell the difference between a column or function name and an actual string value?

How/why are you using strings in the first place? HoneySQL accepts symbols as well as keywords, if that&apos;s any help and lets you use lists instead of vectors in most places: <code>&apos;(or (and (= col_a &quot;a&quot;) (= col_b 1)) (and (= col_d &quot;a&quot;) (= col_e 1)))</code></z><z id="t1667492780" t="quan xing thank you. but I want to use a json string to define sql where condition, frontend post json where to backend. I wrote it for a long time, and it basically worked. but it felt ugly. the recursive processing of the data confused me. (defn first-second-&gt;key [[f1 f2 f3]] [(keyword f1) (keyword f2) f3]) (defn reslove-exp-v [v] (if (vector? v) (if (every? #(not (vector? %)) v) (first-second-&gt;key v) (mapv reslove-exp-v v)) (keyword v))) (defn reslove-exp [exp] (if (every? #(not (vector? %)) exp) (first-second-&gt;key exp) (mapv reslove-exp-v exp))) (reslove-exp [&quot;=&quot; &quot;id&quot; &quot;1234&quot;]) ;; =&gt; [:= :id &quot;1234&quot;] (reslove-exp [&quot;or&quot;, [&quot;and&quot;, [&quot;=&quot;,&quot;col_a&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;dff&quot;,1]] , [&quot;and&quot;, [&quot;=&quot;,&quot;col_b&quot;,&quot;bb&quot;],[&quot;=&quot;,&quot;abc&quot;,1]]]) ;; =&gt; [:or [:and [:= :col_a &quot;a&quot;] [:= :dff 1]] [:and [:= :col_b &quot;bb&quot;] [:= :abc 1]]]"><y>#</y><d>2022-11-03</d><h>16:26</h><r>quan xing</r>thank you. but I want to use a json string to define sql where condition, frontend post json where to backend.

I wrote it for a long time, and it basically worked.  but it felt ugly.  the recursive processing of the data confused me.

<pre>(defn first-second-&gt;key
    [[f1 f2 f3]]
    [(keyword f1) (keyword f2) f3])

  (defn reslove-exp-v
    [v]
    (if (vector? v)
      (if (every? #(not (vector? %)) v)
        (first-second-&gt;key v)
        (mapv reslove-exp-v v))
      (keyword v)))

  (defn reslove-exp
    [exp]
    (if (every? #(not (vector? %)) exp)
      (first-second-&gt;key exp)
      (mapv reslove-exp-v exp)))

  
  (reslove-exp [&quot;=&quot; &quot;id&quot; &quot;1234&quot;])
  ;; =&gt; [:= :id &quot;1234&quot;]

  (reslove-exp [&quot;or&quot;,
                [&quot;and&quot;, [&quot;=&quot;,&quot;col_a&quot;,&quot;a&quot;],[&quot;=&quot;,&quot;dff&quot;,1]]
                ,
                [&quot;and&quot;, [&quot;=&quot;,&quot;col_b&quot;,&quot;bb&quot;],[&quot;=&quot;,&quot;abc&quot;,1]]])
  ;; =&gt; [:or [:and [:= :col_a &quot;a&quot;] [:= :dff 1]] [:and [:= :col_b &quot;bb&quot;] [:= :abc 1]]]</pre></z><z id="t1667493520" t="seancorfield Bear in mind that [:= &quot;a&quot; :col_x] is a perfectly valid condition too..."><y>#</y><d>2022-11-03</d><h>16:38</h><r>seancorfield</r>Bear in mind that <code>[:= &quot;a&quot; :col_x]</code> is a perfectly valid condition too...</z><z id="t1667522253" t="quan xing ok, thank you!"><y>#</y><d>2022-11-04</d><h>00:37</h><r>quan xing</r>ok, thank you!</z><z id="t1668103473" t="orestis Having seen systems that send “where” queries to the backend, I would strongly suggest you find a different approach. Eg find your own mini-language or data structure to encode this information. "><y>#</y><d>2022-11-10</d><h>18:04</h><r>orestis</r>Having seen systems that send “where” queries to the backend, I would strongly suggest you find a different approach. Eg find your own mini-language or data structure to encode this information. </z><z id="t1668103554" t="orestis Your approach and your function can easily be circumvented to bypass all your where clauses. "><y>#</y><d>2022-11-10</d><h>18:05</h><r>orestis</r>Your approach and your function can easily be circumvented to bypass all your where clauses. </z><z id="t1667619769" t="hifumi123 Is there some dialect available for H2 database when building HoneySQL statements? I&apos;m asking because I currently have to employ a workaround when referencing tables in DDLs. e.g. [[:constraint :some-constraint] [:references :table/column]] will produce CONSTRAINT some_constraint REFERENCES table.column , but H2 requires the reference to be schema.table(column) , even if you are in the same schema as the table you&apos;re referencing, leading me to using workarounds like [[:constraint :some-constraint] [:references [:public.table :column]]]"><y>#</y><d>2022-11-05</d><h>03:42</h><w>hifumi123</w>Is there some dialect available for H2 database when building HoneySQL statements? I&apos;m asking because I currently have to employ a workaround when referencing tables in DDLs.

e.g. <code>[[:constraint :some-constraint] [:references :table/column]]</code> will produce <code>CONSTRAINT some_constraint REFERENCES table.column</code>, but H2 requires the reference to be <code>schema.table(column)</code>, even if you are in the same schema as the table you&apos;re referencing, leading me to using workarounds like <code>[[:constraint :some-constraint] [:references [:public.table :column]]]</code></z><z id="t1667619883" t="seancorfield I&apos;m not sure why you consider that to be a workaround?"><y>#</y><d>2022-11-05</d><h>03:44</h><r>seancorfield</r>I&apos;m not sure why you consider that to be a workaround?</z><z id="t1667619941" t="hifumi123 hm... I guess I consider it a workaround because HoneySQL documentation seems to suggest :table/column is the &quot;natural&quot; way to reference table.column , rather than doing what I am currently doing. As long as this seems OK in your eyes then I&apos;m willing to accept it 🙂"><y>#</y><d>2022-11-05</d><h>03:45</h><r>hifumi123</r>hm... I guess I consider it a workaround because HoneySQL documentation seems to suggest <code>:table/column</code> is the &quot;natural&quot; way to reference <code>table.column</code> , rather than doing what I am currently doing. As long as this seems OK in your eyes then I&apos;m willing to accept it <b>🙂</b></z><z id="t1667619988" t="seancorfield If you need to specify the schema where would HoneySQL get that from, unless you tell it somehow? [:schema.table :column] seems like a good notation for that."><y>#</y><d>2022-11-05</d><h>03:46</h><r>seancorfield</r>If you need to specify the schema where would HoneySQL get that from, unless you tell it somehow? <code>[:schema.table :column]</code> seems like a good notation for that.</z><z id="t1667620032" t="seancorfield (and, as I keep saying over and over, DDL is so horribly DB-specific and non-regular that supporting it &quot;fully&quot; is... a pipe dream at best)"><y>#</y><d>2022-11-05</d><h>03:47</h><r>seancorfield</r>(and, as I keep saying over and over, DDL is so horribly DB-specific and non-regular that supporting it &quot;fully&quot; is... a pipe dream at best)</z><z id="t1667620102" t="hifumi123 Makes sense. Thanks for the quick response btw. I was just making sure I&apos;m using HoneySQL as intended, and I&apos;m fine with things as they currently are"><y>#</y><d>2022-11-05</d><h>03:48</h><r>hifumi123</r>Makes sense. Thanks for the quick response btw. I was just making sure I&apos;m using HoneySQL as intended, and I&apos;m fine with things as they currently are</z><z id="t1667620158" t="seancorfield &quot;as intended&quot; implies HoneySQL is opinionated 🙂 I think, when it comes to DDL, whatever works is acceptable."><y>#</y><d>2022-11-05</d><h>03:49</h><r>seancorfield</r>&quot;as intended&quot; implies HoneySQL is opinionated <b>🙂</b> I think, when it comes to DDL, whatever works is acceptable.</z><z id="t1667696213" t="seancorfield If you&apos;re a heavy user of HoneySQL for generating DDL statements, this release may impact you (but hopefully will just make your life easier!)."><y>#</y><d>2022-11-06</d><h>00:56</h><w>seancorfield</w>If you&apos;re a heavy user of HoneySQL for generating DDL statements, this release may impact you (but hopefully will just make your life easier!).</z><z id="t1667807968" t="slipset It seems to me from the examples bit of the https://www.postgresql.org/docs/current/sql-truncate.html that postgres accepts multiple tables to truncate, whereas honey does not? =# create table t1 (id int); CREATE TABLE =# create table t2 (id int); CREATE TABLE =# insert into t1 values (1); INSERT 0 1 =# insert into t2 values (2); INSERT 0 1 =# select * from t1; id ---- 1 (1 row) =# select * from t2; id ---- 2 (1 row) =# truncate t1, t2; TRUNCATE TABLE =# select * from t1; id ---- (0 rows) =# select * from t2; id ---- (0 rows) =# Is this worth reporting as an issue?"><y>#</y><d>2022-11-07</d><h>07:59</h><w>slipset</w>It seems to me from the examples bit of the <a href="https://www.postgresql.org/docs/current/sql-truncate.html" target="_blank">https://www.postgresql.org/docs/current/sql-truncate.html</a> that postgres accepts multiple tables to truncate, whereas honey does not?
<pre>=# create table t1 (id int);
CREATE TABLE
=# create table t2 (id int);
CREATE TABLE
=# insert into t1 values (1);
INSERT 0 1
=# insert into t2 values (2);
INSERT 0 1
=# select * from t1;
 id
----
  1
(1 row)

=# select * from t2;
 id
----
  2
(1 row)

=# truncate t1, t2;
TRUNCATE TABLE
=# select * from t1;
 id
----
(0 rows)

=# select * from t2;
 id
----
(0 rows)

=#</pre>
Is this worth reporting as an issue?</z><z id="t1667809397" t="seancorfield Sure, open an issue. I was looking at this just the other day as I extended truncate to support cascade etc. Not sure what the syntax would have to be now, since a sequence argument already means &quot;table + options&quot;, but I&apos;ll give it some thought."><y>#</y><d>2022-11-07</d><h>08:23</h><r>seancorfield</r>Sure, open an issue. I was looking at this just the other day as I extended truncate to support cascade etc. Not sure what the syntax would have to be now, since a sequence argument already means &quot;table + options&quot;, but I&apos;ll give it some thought.</z><z id="t1667834783" t="valerauko does honeysql (2) have some hidden state that persists across calls?"><y>#</y><d>2022-11-07</d><h>15:26</h><w>valerauko</w>does honeysql (2) have some hidden state that persists across calls?</z><z id="t1667834958" t="valerauko I&apos;m observing super weird behavior: user=&gt; (honey.sql/format {:replace-into :accounts :values [{:public-key 1 :private-key 2}] :returning [:*]}) ExceptionInfo These SQL clauses are unknown or have nil values: :replace-into {:replace-into :accounts} user=&gt; (honey.sql/format {:replace-into :accounts :values [{:public-key 1 :private-key 2}] :returning [:*]} {:dialect :mysql :quoted-kebab true}) ExceptionInfo These SQL clauses are unknown or have nil values: :replace-into {:replace-into :accounts} And then suddenly... user=&gt; (honey.sql/format {:replace-into :accounts :values [{:public-key 1 :private-key 2}] :returning [:*]} {:dialect :mysql :quoted-kebab true}) [&quot;REPLACE INTO `accounts` (`public-key`, `private-key`) VALUES (?, ?) RETURNING *&quot; 1 2] user=&gt; (honey.sql/format {:replace-into :accounts :values [{:public-key 1 :private-key 2}] :returning [:*]}) [&quot;REPLACE INTO accounts (public_key, private_key) VALUES (?, ?) RETURNING *&quot; 1 2] I thought format was &quot;just&quot; a function but then how come it&apos;s not consistent? Does it have some state outside the function for the options?"><y>#</y><d>2022-11-07</d><h>15:29</h><r>valerauko</r>I&apos;m observing super weird behavior:
<pre>user=&gt; (honey.sql/format
  {:replace-into :accounts
   :values [{:public-key 1 :private-key 2}]
   :returning [:*]})
ExceptionInfo These SQL clauses are unknown or have nil values: :replace-into {:replace-into :accounts}
user=&gt; (honey.sql/format
  {:replace-into :accounts
   :values [{:public-key 1 :private-key 2}]
   :returning [:*]}
  {:dialect :mysql
   :quoted-kebab true})
ExceptionInfo These SQL clauses are unknown or have nil values: :replace-into {:replace-into :accounts}</pre>
And then suddenly...
<pre>user=&gt; (honey.sql/format
  {:replace-into :accounts
   :values [{:public-key 1 :private-key 2}]
   :returning [:*]}
  {:dialect :mysql
   :quoted-kebab true})
[&quot;REPLACE INTO `accounts` (`public-key`, `private-key`) VALUES (?, ?) RETURNING *&quot; 1 2]
user=&gt; (honey.sql/format
  {:replace-into :accounts
   :values [{:public-key 1 :private-key 2}]
   :returning [:*]})
[&quot;REPLACE INTO accounts (public_key, private_key) VALUES (?, ?) RETURNING *&quot; 1 2]</pre>
I thought format was &quot;just&quot; a function but then how come it&apos;s not consistent? Does it have some state outside the function for the options?</z><z id="t1667835363" t="valerauko Oh okay digging in the source I figured it out. The first time the :mysql dialect is used it adds the clauses globally which means later calls (even if the :dialect passed to format is not :mysql) have access to it. https://github.com/seancorfield/honeysql/blob/23be700b7eb74ff75096bc5c8324634a8e2b9e84/src/honey/sql.cljc#L109"><y>#</y><d>2022-11-07</d><h>15:36</h><r>valerauko</r>Oh okay digging in the source I figured it out. The first time the :mysql dialect is used it adds the clauses globally which means later calls (even if the :dialect passed to format is not :mysql) have access to it.
<a href="https://github.com/seancorfield/honeysql/blob/23be700b7eb74ff75096bc5c8324634a8e2b9e84/src/honey/sql.cljc#L109" target="_blank">https://github.com/seancorfield/honeysql/blob/23be700b7eb74ff75096bc5c8324634a8e2b9e84/src/honey/sql.cljc#L109</a></z><z id="t1667844663" t="seancorfield Yeah, my feeling with that was that if you use a dialect, it&apos;s &quot;harmless&quot; to have any additions it makes stay in play -- if two dialects conflict, selecting back and forth between them should &quot;correct&quot; the formatting anyway. If you are only using one dialect, you probably should set-dialect! at startup. Specifying :dialect in a format call also turns on quoting for that call (unless you also say :quoted false )."><y>#</y><d>2022-11-07</d><h>18:11</h><r>seancorfield</r>Yeah, my feeling with that was that if you use a dialect, it&apos;s &quot;harmless&quot; to have any additions it makes stay in play -- if two dialects conflict, selecting back and forth between them should &quot;correct&quot; the formatting anyway.

If you are only using one dialect, you probably should <code>set-dialect!</code> at startup. Specifying <code>:dialect</code> in a <code>format</code> call also turns on quoting for that call (unless you also say <code>:quoted false</code>).</z><z id="t1667871137" t="valerauko Yeah I can understand that. I think the element that really bugged me was that the first call with :dialect :mysql would fail"><y>#</y><d>2022-11-08</d><h>01:32</h><r>valerauko</r>Yeah I can understand that. I think the element that really bugged me was that the first call with :dialect :mysql would fail</z><z id="t1667871557" t="seancorfield With? Or without?"><y>#</y><d>2022-11-08</d><h>01:39</h><r>seancorfield</r>With? Or without?</z><z id="t1667871642" t="valerauko In the example above, it&apos;d fail the first call with :dialect"><y>#</y><d>2022-11-08</d><h>01:40</h><r>valerauko</r>In the example above, it&apos;d fail the first call with :dialect</z><z id="t1667871685" t="seancorfield Oh, that&apos;s definitely a bug - can you open an issue? I&apos;m on my phone."><y>#</y><d>2022-11-08</d><h>01:41</h><r>seancorfield</r>Oh, that&apos;s definitely a bug - can you open an issue? I&apos;m on my phone.</z><z id="t1667871707" t="valerauko Will do"><y>#</y><d>2022-11-08</d><h>01:41</h><r>valerauko</r>Will do</z><z id="t1667872013" t="valerauko https://github.com/seancorfield/honeysql/issues/441"><y>#</y><d>2022-11-08</d><h>01:46</h><r>valerauko</r><a href="https://github.com/seancorfield/honeysql/issues/441" target="_blank">https://github.com/seancorfield/honeysql/issues/441</a></z><z id="t1668525842" t="emccue Does anyone remember how to get around postgres parameter limits with :in ? My brain is going &quot;PGArray&quot; but im only 30% confident about that (and trying it at the repl yields no success)"><y>#</y><d>2022-11-15</d><h>15:24</h><w>emccue</w>Does anyone remember how to get around postgres parameter limits with <code>:in</code> ? My brain is going &quot;PGArray&quot; but im only 30% confident about that

(and trying it at the repl yields no success)</z><z id="t1668583512" t="orestis Hm, we have a utility function (defn cast-ids [ids] [:cast [:lift (mapv str ids)] [:raw &quot;mongo_id[]&quot;]]) Where the interesting thing is the :lift that passes in the whole CLJ vector as a single parameter, which somewhere down the stack is converted in a PG array"><y>#</y><d>2022-11-16</d><h>07:25</h><w>orestis</w>Hm, we have a utility function
<pre>(defn cast-ids [ids]
  [:cast [:lift (mapv str ids)]
   [:raw &quot;mongo_id[]&quot;]])</pre>
Where the interesting thing is the <code>:lift</code> that passes in the whole CLJ vector as a single parameter, which somewhere down the stack is converted in a PG array</z><z id="t1668612829" t="emccue What does :lift do?"><y>#</y><d>2022-11-16</d><h>15:33</h><r>emccue</r>What does <code>:lift</code> do?</z><z id="t1668612883" t="emccue and q. specific to your example - what is a mongo_id[] ? do you have a custom type in postgres?"><y>#</y><d>2022-11-16</d><h>15:34</h><r>emccue</r>and q. specific to your example - what is a <code>mongo_id[]</code>? do you have a custom type in postgres?</z><z id="t1668615508" t="orestis Re mongo_id, yes, it’s a custom type - so we cast to an array of those. "><y>#</y><d>2022-11-16</d><h>16:18</h><r>orestis</r>Re mongo_id, yes, it’s a custom type - so we cast to an array of those. </z><z id="t1668615629" t="orestis :lift will, IIRC, instruct honey sql to treat the argument as a single value and to not infer anything from the values type - it’s a honey sql2 thing. "><y>#</y><d>2022-11-16</d><h>16:20</h><r>orestis</r>:lift will, IIRC, instruct honey sql to treat the argument as a single value and to not infer anything from the values type - it’s a honey sql2 thing. </z><z id="t1668617496" t="orestis https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md"><y>#</y><d>2022-11-16</d><h>16:51</h><r>orestis</r><a href="https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md</a></z><z id="t1668617505" t="orestis I think that array would better than lift "><y>#</y><d>2022-11-16</d><h>16:51</h><r>orestis</r>I think that array would better than lift </z><z id="t1668620970" t="emccue i might be on honeysql 1..."><y>#</y><d>2022-11-16</d><h>17:49</h><r>emccue</r>i might be on honeysql 1...</z><z id="t1668628918" t="orestis Ah, the docs say that honeysql has “value” for something equivalent - we upgraded all of our code to honeysql2 a couple of months back. "><y>#</y><d>2022-11-16</d><h>20:01</h><r>orestis</r>Ah, the docs say that honeysql has “value” for something equivalent - we upgraded all of our code to honeysql2 a couple of months back. </z><z id="t1668583539" t="orestis Another instance: {:select [:*] :from [:statuses] :where [[:= :title [:any [:lift (into-array status-titles)]]]]} "><y>#</y><d>2022-11-16</d><h>07:25</h><w>orestis</w>Another instance:
<pre>{:select [:*]
   :from [:statuses]
   :where [[:= :title [:any [:lift (into-array status-titles)]]]]}</pre>
</z><z id="t1668583591" t="orestis We don&apos;t really use :in in many places [:attrs {:href &quot;/_/_/users/U3JH98J4R&quot;}]"><y>#</y><d>2022-11-16</d><h>07:26</h><w>orestis</w>We don&apos;t really use <code>:in</code> in many places <a>@emccue</a></z><z id="t1668698231" t="Ben Lieberman First time using HoneySQL this morning and this error is a bit confusing to me: Execution error (ExceptionInfo) at honey.sql/format-values (sql.cljc:794). ; :values expects sequences or maps I worked around it by calling (into []) , but I would like to understand what I&apos;m doing wrong. (-&gt; (h/insert-into :posts) (h/values (-&gt;Post 1 &quot;testing a new post&quot; (LocalDateTime/now) 1)) sql/format) What is my Post record instance here if not a map?"><y>#</y><d>2022-11-17</d><h>15:17</h><w>Ben Lieberman</w>First time using HoneySQL this morning and this error is a bit confusing to me:
<pre>Execution error (ExceptionInfo) at honey.sql/format-values (sql.cljc:794).
; :values expects sequences or maps</pre>
I worked around it by calling <code>(into [])</code> , but I would like to understand what I&apos;m doing wrong.
<pre>(-&gt; (h/insert-into :posts) 
                    (h/values
                     (-&gt;Post 1 &quot;testing a new post&quot; (LocalDateTime/now) 1)) 
                    sql/format)</pre>
What is my <code>Post</code> record instance here if not a map?</z><z id="t1668699932" t="seancorfield You are trying to pass a single hash map. :values expects a sequence of hash maps (or a sequence of column values -- a sequence of sequences)."><y>#</y><d>2022-11-17</d><h>15:45</h><r>seancorfield</r>You are trying to pass a single hash map. <code>:values</code> expects a sequence of hash maps (or a sequence of column values -- a sequence of sequences).</z><z id="t1668700278" t="seancorfield Looking at it, I can see how many folks would expect to be able to pass one or more hash maps to the values helper and for it to &quot;do the right thing&quot;... so I&apos;ll create a ticket for that."><y>#</y><d>2022-11-17</d><h>15:51</h><r>seancorfield</r>Looking at it, I can see how many folks would expect to be able to pass one or more hash maps to the <code>values</code> helper and for it to &quot;do the right thing&quot;... so I&apos;ll create a ticket for that.</z><z id="t1668700435" t="Ben Lieberman Thanks, Sean. I think the &quot;or&quot; is what put me off the scent there."><y>#</y><d>2022-11-17</d><h>15:53</h><r>Ben Lieberman</r>Thanks, Sean. I think the &quot;or&quot; is what put me off the scent there.</z><z id="t1668700437" t="seancorfield https://github.com/seancorfield/honeysql/issues/442"><y>#</y><d>2022-11-17</d><h>15:53</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/442" target="_blank">https://github.com/seancorfield/honeysql/issues/442</a></z><z id="t1668700512" t="seancorfield The problem is that :values sees [(map-entry ..) (map-entry ..) (map-entry ..)] and says &quot;Hey, I&apos;m expecting sequences or maps but I got a MapEntry !&quot;"><y>#</y><d>2022-11-17</d><h>15:55</h><r>seancorfield</r>The problem is that <code>:values</code> sees <code>[(map-entry ..) (map-entry ..) (map-entry ..)]</code> and says &quot;Hey, I&apos;m expecting sequences or maps but I got a <code>MapEntry</code>!&quot;</z><z id="t1668700525" t="seancorfield I can make the error message better as well 🙂"><y>#</y><d>2022-11-17</d><h>15:55</h><r>seancorfield</r>I can make the error message better as well <b>🙂</b></z><z id="t1668700619" t="seancorfield I&apos;m changing it to :values expects a sequence of rows (maps) or column values (sequences)"><y>#</y><d>2022-11-17</d><h>15:56</h><r>seancorfield</r>I&apos;m changing it to
<pre>:values expects a sequence of rows (maps) or column values (sequences)</pre></z><z id="t1668701488" t="seancorfield FWIW, the docstring of values says: Accepts a single argument: a collection of row values. Each row value can be either a sequence of column values or a hash map of column name/column value pairs. I can fairly easily make it take one or more hash maps or two or more &quot;sequence of column values&quot; but determining whether a single argument of [[..] ..] or [{..} ..] is a single row with compound data values or a sequence of row values is much tougher, so I&apos;ll have to give that some thought so I don&apos;t break any existing code..."><y>#</y><d>2022-11-17</d><h>16:11</h><r>seancorfield</r>FWIW, the docstring of <code>values</code> says:
<pre>Accepts a single argument: a collection of row values.
  Each row value can be either a sequence of column values
  or a hash map of column name/column value pairs.</pre>
I can fairly easily make it take one or more hash maps or two or more &quot;sequence of column values&quot; but determining whether a single argument of <code>[[..] ..]</code> or <code>[{..} ..]</code> is a single row with compound data values or a sequence of row values is much tougher, so I&apos;ll have to give that some thought so I don&apos;t break any existing code...</z><z id="t1668702168" t="Ben Lieberman Duly noted re: values docstring. Given my incomplete understanding of seqs, I am curious why calling values on a single hashmap/record like I am doing here works? The exception only happens when I pass it to format ."><y>#</y><d>2022-11-17</d><h>16:22</h><r>Ben Lieberman</r>Duly noted re: <code>values</code> docstring. Given my incomplete understanding of seqs, I am curious why calling <code>values</code> on a single hashmap/record like I am doing here works? The exception only happens when I pass it to <code>format</code>.</z><z id="t1668702212" t="Ben Lieberman I suppose that I expect the exception to be thrown in values and not in format"><y>#</y><d>2022-11-17</d><h>16:23</h><r>Ben Lieberman</r>I suppose that I expect the exception to be thrown in <code>values</code> and not in <code>format</code></z><z id="t1668702244" t="Ben Lieberman On the other hand, my use case is so trivial I can see why this behavior would never be encountered by anyone else."><y>#</y><d>2022-11-17</d><h>16:24</h><r>Ben Lieberman</r>On the other hand, my use case is so trivial I can see why this behavior would never be encountered by anyone else.</z><z id="t1668702359" t="seancorfield values only constructs data. format turns data into SQL. format is where all the checks are."><y>#</y><d>2022-11-17</d><h>16:25</h><r>seancorfield</r><code>values</code> only constructs data. <code>format</code> turns data into SQL. <code>format</code> is where all the checks are.</z><z id="t1668702664" t="seancorfield It looks like this is going to be harder to fix than I thought (without breaking backward compatibility). I&apos;ll have to give it some thought."><y>#</y><d>2022-11-17</d><h>16:31</h><r>seancorfield</r>It looks like this is going to be harder to fix than I thought (without breaking backward compatibility). I&apos;ll have to give it some thought.</z><z id="t1668702742" t="Ben Lieberman Not a problem. Now that I know how this works as-is, I think I&apos;ll be alright. Thanks as always."><y>#</y><d>2022-11-17</d><h>16:32</h><r>Ben Lieberman</r>Not a problem. Now that I know how this works as-is, I think I&apos;ll be alright. Thanks as always.</z><z id="t1668702753" t="seancorfield (because all the helpers are variadic and can optionally take a DSL hash map as their first argument)"><y>#</y><d>2022-11-17</d><h>16:32</h><r>seancorfield</r>(because all the helpers are variadic and can optionally take a DSL hash map as their first argument)</z><z id="t1668702932" t="seancorfield so (values {:insert-into :posts} {:foo 42}) could reasonably mean either &quot;add :values [{:foo 42}] to the DSL&quot; or &quot;build an initial DSL with two rows for :values &quot; 🙂 Even tho&apos; the column value is funky there (but a string would be legal as a table name!)."><y>#</y><d>2022-11-17</d><h>16:35</h><r>seancorfield</r>so <code>(values {:insert-into :posts} {:foo 42})</code> could reasonably mean either &quot;add <code>:values [{:foo 42}]</code> to the DSL&quot; or &quot;build an initial DSL with two rows for <code>:values</code>&quot; <b>🙂</b> Even tho&apos; the column value is funky there (but a string would be legal as a table name!).</z><z id="t1668703211" t="Ben Lieberman Huh, I&apos;ll have to give that some thought myself as DSLs are relatively new to me in general. I&apos;m wondering whether I&apos;m maybe trying to do too little with HoneySQL anyway :thinking_face: my queries are so simple I might be better off just passing them as strings to postgres if that&apos;s possible."><y>#</y><d>2022-11-17</d><h>16:40</h><r>Ben Lieberman</r>Huh, I&apos;ll have to give that some thought myself as DSLs are relatively new to me in general. I&apos;m wondering whether I&apos;m maybe trying to do too little with HoneySQL anyway <b>:thinking_face:</b> my queries are so simple I might be better off just passing them as strings to postgres if that&apos;s possible.</z><z id="t1668705182" t="seancorfield String-bashing is never nice, so HoneySQL helps even in fairly simple cases. The data DSL behind HoneySQL is mostly fairly straightforward but the helpers introduce both convenience and some confusion -- some people love them, some people hate them. I tend to use a mixture of helpers and raw data (but mostly helpers). The key with the helpers is that you can thread them in any order so (-&gt; (h/insert-info :posts) (h/values [(-&gt;Post ..)]) ..) and (-&gt; (h/values [(-&gt;Post ..)]) (h/insert-info :posts) ..) generate identical data (or at least should generate identical data!), which is what allows users to build the SQL statement up across multiple functions and via conditional logic. But that does tend to make the helper functions a little odd/complex at times because the data DSL is a hash map and all helpers have essentially two arities: one with the DSL as the first argument (to allow threading) and one without the DSL as the first argument -- which means that (some-helper my-hash-map another-hash-map) is ambiguous if some-helper could also be called as (some-helper the-dsl my-hash-map another-hash-map) And given that some users build up that data DSL using regular Clojure code without helpers, it can be hard to tell the difference 🙂"><y>#</y><d>2022-11-17</d><h>17:13</h><r>seancorfield</r>String-bashing is never nice, so HoneySQL helps even in fairly simple cases. The data DSL behind HoneySQL is mostly fairly straightforward but the helpers introduce both convenience and some confusion -- some people love them, some people hate them. I tend to use a mixture of helpers and raw data (but mostly helpers).

The key with the helpers is that you can thread them in any order so
<pre>(-&gt; (h/insert-info :posts) (h/values [(-&gt;Post ..)]) ..)</pre>
and
<pre>(-&gt; (h/values [(-&gt;Post ..)]) (h/insert-info :posts) ..)</pre>
generate identical data (or at least should generate identical data!), which is what allows users to build the SQL statement up across multiple functions and via conditional logic.

But that does tend to make the helper functions a little odd/complex at times because the data DSL is a hash map and all helpers have essentially two arities: one with the DSL as the first argument (to allow threading) and one without the DSL as the first argument -- which means that <code>(some-helper my-hash-map another-hash-map)</code> is ambiguous if <code>some-helper</code> could also be called as <code>(some-helper the-dsl my-hash-map another-hash-map)</code>

And given that some users build up that data DSL using regular Clojure code without helpers, it can be hard to tell the difference <b>🙂</b></z><z id="t1668714011" t="ozymandias33 I found an interesting unexpected behavior where honeysql is passing invalid column names when the table name is wrapped in a vector. It took a non-trivial amount of time to debug. Did I miss something in the docs? Does anyone know if there is an open issue on this? ; DEPENDENCY =&gt; [com.github.seancorfield/honeysql &quot;2.4.947&quot;] ;; VALID (-&gt; (honey.sql.helpers/insert-into :my_pg_table) (honey.sql.helpers/values [{:foo &quot;Always look...&quot; :bar &quot;on the bright side of life&quot;}]) (honey.sql/format)) ;=&gt; [&quot;INSERT INTO my_pg_table (foo, bar) VALUES (?, ?)&quot; &quot;Always look...&quot; &quot;on the bright side of life&quot;] ;; ERROR =&gt; note the declaration &quot;MY_PG_TABLE() (foo, bar)&quot; in the output block (-&gt; (honey.sql.helpers/insert-into [:my_pg_table]) ;; Vector Wrapper (honey.sql.helpers/values [{:foo &quot;Always look...&quot; :bar &quot;on the bright side of life&quot;}]) (honey.sql/format)) ;=&gt; [&quot;INSERT INTO MY_PG_TABLE() (foo, bar) VALUES (?, ?)&quot; &quot;Always look...&quot; &quot;on the bright side of life&quot;]"><y>#</y><d>2022-11-17</d><h>19:40</h><w>ozymandias33</w>I found an interesting unexpected behavior where honeysql is passing invalid column names when the table name is wrapped in a vector. It took a non-trivial amount of time to debug. Did I miss something in the docs? Does anyone know if there is an open issue on this?
<pre>; DEPENDENCY =&gt; [com.github.seancorfield/honeysql &quot;2.4.947&quot;]

;; VALID
(-&gt; (honey.sql.helpers/insert-into :my_pg_table)
    (honey.sql.helpers/values [{:foo &quot;Always look...&quot; :bar &quot;on the bright side of life&quot;}])
    (honey.sql/format))
;=&gt; [&quot;INSERT INTO my_pg_table (foo, bar) VALUES (?, ?)&quot; &quot;Always look...&quot; &quot;on the bright side of life&quot;]

;; ERROR =&gt; note the declaration &quot;MY_PG_TABLE() (foo, bar)&quot; in the output block
(-&gt; (honey.sql.helpers/insert-into [:my_pg_table])  ;; Vector Wrapper
    (honey.sql.helpers/values [{:foo &quot;Always look...&quot; :bar &quot;on the bright side of life&quot;}])
    (honey.sql/format))
;=&gt; [&quot;INSERT INTO MY_PG_TABLE() (foo, bar) VALUES (?, ?)&quot; &quot;Always look...&quot; &quot;on the bright side of life&quot;]</pre></z><z id="t1668714151" t="ozymandias33 Or maybe just missing the best practice on using positional params vs vectors in the DSL functions?"><y>#</y><d>2022-11-17</d><h>19:42</h><r>ozymandias33</r>Or maybe just missing the best practice on using positional params vs vectors in the DSL functions?</z><z id="t1668714191" t="valtteri A keyword inside a vector gets treated as a function https://github.com/seancorfield/honeysql#functions"><y>#</y><d>2022-11-17</d><h>19:43</h><r>valtteri</r>A keyword inside a vector gets treated as a function <a href="https://github.com/seancorfield/honeysql#functions" target="_blank">https://github.com/seancorfield/honeysql#functions</a></z><z id="t1668714275" t="ozymandias33 Ah. Thank you so much 🙏"><y>#</y><d>2022-11-17</d><h>19:44</h><r>ozymandias33</r>Ah. Thank you so much <b>🙏</b></z><z id="t1668714326" t="valtteri No problem. 🙂 I think honeysql is working correctly because ~at least theoretically table name~ from clause could be resolved by a function"><y>#</y><d>2022-11-17</d><h>19:45</h><r>valtteri</r>No problem. <b>🙂</b> I think honeysql is working correctly because ~at least theoretically table name~  from clause could be resolved by a function</z><z id="t1668714443" t="ozymandias33 I agree with that given the docs. No need to open an issue"><y>#</y><d>2022-11-17</d><h>19:47</h><r>ozymandias33</r>I agree with that given the docs. No need to open an issue</z><z id="t1668714554" t="seancorfield Specifically, this is legal: user=&gt; (sql/format {:insert-into [:table :alternative] :columns [:foo :bar] :values [[1 2]]}) [&quot;INSERT INTO table AS alternative (foo, bar) VALUES (?, ?)&quot; 1 2] user=&gt;"><y>#</y><d>2022-11-17</d><h>19:49</h><r>seancorfield</r>Specifically, this is legal:
<pre>user=&gt; (sql/format {:insert-into [:table :alternative] :columns [:foo :bar] :values [[1 2]]})
[&quot;INSERT INTO table AS alternative (foo, bar) VALUES (?, ?)&quot; 1 2]
user=&gt;</pre></z><z id="t1668714580" t="seancorfield So HoneySQL accepts generalized expressions there to make life easier."><y>#</y><d>2022-11-17</d><h>19:49</h><r>seancorfield</r>So HoneySQL accepts generalized expressions there to make life easier.</z><z id="t1668714678" t="seancorfield (I think it reuses part of the formatter from :select so that aliasing works the same way -- and the [:table] ;=&gt; TABLE() is just an artifact of that)"><y>#</y><d>2022-11-17</d><h>19:51</h><r>seancorfield</r>(I think it reuses part of the formatter from <code>:select</code> so that aliasing works the same way -- and the <code>[:table]</code> ;=&gt; <code>TABLE()</code> is just an artifact of that)</z><z id="t1668719823" t="ozymandias33 Of course it was a gap in understanding the meaning of the vector structure. Need to spend some time with the DSL to understand the particulars. I really like the expressiveness though. Someday we’ll play Conway’s Game of [Honey]SQL 😁"><y>#</y><d>2022-11-17</d><h>21:17</h><r>ozymandias33</r>Of course it was a gap in understanding the meaning of the vector structure. Need to spend some time with the DSL to understand the particulars. I really like the expressiveness though. Someday we’ll play Conway’s Game of [Honey]SQL <b>😁</b></z><z id="t1668719866" t="ozymandias33 Or I suppose it will be Corfield’s Game of HoneySQL"><y>#</y><d>2022-11-17</d><h>21:17</h><r>ozymandias33</r>Or I suppose it will be Corfield’s Game of HoneySQL</z><z id="t1668720089" t="seancorfield SQL is just so... gnarly..."><y>#</y><d>2022-11-17</d><h>21:21</h><r>seancorfield</r>SQL is just so... gnarly...</z><z id="t1668723286" t="ozymandias33 Yeah. It’s the 21st century. Let’s start modeling relational databases on general data structures and algebraic data types. I’ll bash out shell scripts like the rest of us, but at some point a string-driven interface becomes too much overhead. Same goes for SQL"><y>#</y><d>2022-11-17</d><h>22:14</h><r>ozymandias33</r>Yeah. It’s the 21st century. Let’s start modeling relational databases on general data structures and algebraic data types. I’ll bash out shell scripts like the rest of us, but at some point a string-driven interface becomes too much overhead. Same goes for SQL</z><z id="t1668890834" t="kotlenik Hi guys! I have had and issue writing simple query to fetch records based on primary keys given in vector to get something like this SELECT * FROM s_lab_results WHERE key IN (23, 456, 890)"><y>#</y><d>2022-11-19</d><h>20:47</h><w>kotlenik</w>Hi guys! I have had and issue writing simple query to fetch records
based on primary keys given in vector to get something like this
<code>SELECT * FROM s_lab_results WHERE key IN (23, 456, 890)</code></z><z id="t1668890866" t="kotlenik I have started with query building function as: (defn records-for-keys-alt [table-name primary-key-column records-keys] (let [table-name-for-hsql (keyword table-name) primary-key-hsql (keyword primary-key-column)] (first (hsql/format {:select [:*] :from [table-name-for-hsql] :where [:in primary-key-hsql :?values]} {:params {:values records-keys} :pretty true :inline true}))))"><y>#</y><d>2022-11-19</d><h>20:47</h><r>kotlenik</r>I have started with query building function as:

<pre>(defn records-for-keys-alt
  [table-name primary-key-column records-keys]
  (let [table-name-for-hsql (keyword table-name)
        primary-key-hsql (keyword primary-key-column)]
    (first (hsql/format {:select [:*]
                         :from   [table-name-for-hsql]
                         :where  [:in primary-key-hsql :?values]}
                        {:params {:values records-keys}
                         :pretty true
                         :inline true}))))</pre></z><z id="t1668890905" t="kotlenik but it has resulted with : &quot;\nSELECT *\nFROM s_lab_results\nWHERE key IN [23, 456, 890]\n&quot; which is not correct due to usage of [] brackets."><y>#</y><d>2022-11-19</d><h>20:48</h><r>kotlenik</r>but it has resulted with :
<code>&quot;\nSELECT *\nFROM s_lab_results\nWHERE key IN [23, 456, 890]\n&quot;</code>
which is not correct due to usage of [] brackets.</z><z id="t1668890947" t="kotlenik What was working after colleague had helped me was: (defn records-for-keys [table-name primary-key-column records-keys] (let [table-name-for-hsql (keyword table-name) primary-key-hsql (keyword primary-key-column) records-keys-inline (mapv #(vector :inline %) records-keys)] (first (hsql/format {:select [:*] :from [table-name-for-hsql] :where [:in primary-key-hsql records-keys-inline]} {:pretty true})))) which gives: &quot;\nSELECT *\nFROM s_lab_results\nWHERE key IN (23, 456, 890)\n&quot; but I am not sure where I have made error in initial function. What do you think?"><y>#</y><d>2022-11-19</d><h>20:49</h><r>kotlenik</r>What was working after colleague had helped me was:

<pre>(defn records-for-keys
  [table-name primary-key-column records-keys]
  (let [table-name-for-hsql (keyword table-name)
        primary-key-hsql (keyword primary-key-column)
        records-keys-inline (mapv #(vector :inline %) records-keys)]
    (first (hsql/format {:select [:*]
                         :from   [table-name-for-hsql]
                         :where  [:in primary-key-hsql records-keys-inline]}
                        {:pretty true}))))</pre>
which gives:

<code>&quot;\nSELECT *\nFROM s_lab_results\nWHERE key IN (23, 456, 890)\n&quot;</code>

but I am not sure where I have made error in initial function.
What do you think?</z><z id="t1668891650" t="seancorfield The documentation explains why you can&apos;t do that (named parameter vector with :in). And that second example isn&apos;t safe either. Why are you inlining values? That&apos;s not safe in general (SQL injection risks)"><y>#</y><d>2022-11-19</d><h>21:00</h><r>seancorfield</r>The documentation explains why you can&apos;t do that (named parameter vector with :in). And that second example isn&apos;t safe either. Why are you inlining values? That&apos;s not safe in general (SQL injection risks)</z><z id="t1668891762" t="kotlenik Understood, thanks! Values are collection of integers. Actual call may be like (q/records-for-keys-alt &quot;s_lab_results&quot; &quot;key&quot; [23 456 890]) "><y>#</y><d>2022-11-19</d><h>21:02</h><r>kotlenik</r>Understood, thanks! Values are collection of integers. Actual call may be like <code>(q/records-for-keys-alt &quot;s_lab_results&quot; &quot;key&quot; [23 456 890])</code> </z><z id="t1668891843" t="kotlenik Integers are always checked, since they are results of diff between source and destination database in data integration mechanism."><y>#</y><d>2022-11-19</d><h>21:04</h><r>kotlenik</r>Integers are always checked, since they are results of diff between source and destination database in data integration mechanism.</z><z id="t1669152888" t="marciol Hey folks, I have a query that selects a column of enum type. I would now if there is a way to make it return a keyword instead of a string as it is doing right now."><y>#</y><d>2022-11-22</d><h>21:34</h><w>marciol</w>Hey folks, I have a query that selects a column of enum type. I would now if there is a way to make it return a keyword instead of a string as it is doing right now.</z><z id="t1669155127" t="seancorfield As an FYI, how data is returned from JDBC is not related to HoneySQL -- it&apos;s about the JDBC wrapper you&apos;re using (so this Q belongs in #C1Q164V29). Depending on the wrapper, you could probably arrange for such columns to be auto-coerced but it would require runtime reflection on the metadata of the columns in the ResultSet but I think I would avoid that generic approach and explicitly post-process certain known columns directly."><y>#</y><d>2022-11-22</d><h>22:12</h><r>seancorfield</r>As an FYI, how data is returned from JDBC is not related to HoneySQL -- it&apos;s about the JDBC wrapper you&apos;re using (so this Q belongs in #C1Q164V29).

Depending on the wrapper, you could probably arrange for such columns to be auto-coerced but it would require runtime reflection on the metadata of the columns in the <code>ResultSet</code> but I think I would avoid that generic approach and explicitly post-process certain known columns directly.</z><z id="t1669155190" t="marciol Yes, it&apos;s what I&apos;m gonna do. [:attrs {:href &quot;/_/_/users/U3Y18N0UC&quot;}] told me that this is the approach he uses."><y>#</y><d>2022-11-22</d><h>22:13</h><r>marciol</r>Yes, it&apos;s what I&apos;m gonna do. <a>@U3Y18N0UC</a> told me that this is the approach he uses.</z><z id="t1669155194" t="marciol Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2022-11-22</d><h>22:13</h><r>marciol</r>Thanks <a>@U04V70XH6</a></z><z id="t1669154049" t="marciol I think that I gonna use malli to coerce each row. thx"><y>#</y><d>2022-11-22</d><h>21:54</h><w>marciol</w>I think that I gonna use malli to coerce each row. thx</z><z id="t1669422331" t="fabrao Hello all, I have a situation that I want to select the update operation with case. How can I do this in honeysql? :update :table :set {:source [:case [:&gt; source destination] (sql/call :+ :sort-order 1) :else (sql/call :+ :sort-order 1)]} :where ... how can I use the case in this case?"><y>#</y><d>2022-11-26</d><h>00:25</h><w>fabrao</w>Hello all, I have a situation that I want to select the update operation with case. How can I do this in honeysql?
<pre>:update :table :set {:source [:case [:&gt; source destination] (sql/call :+ :sort-order 1) :else (sql/call :+ :sort-order 1)]} :where ...</pre>
how can I use the case in this case?</z><z id="t1669424053" t="seancorfield Sorry, I don&apos;t understand your question. Is it producing SQL you didn&apos;t expect?"><y>#</y><d>2022-11-26</d><h>00:54</h><r>seancorfield</r>Sorry, I don&apos;t understand your question. Is it producing SQL you didn&apos;t expect?</z><z id="t1669424223" t="fabrao Hello Sean, I expect the case be converted to CASE WHEN (source &gt; destination) THEN sort_order + 1 ELSE sort_order - 1 END"><y>#</y><d>2022-11-26</d><h>00:57</h><r>fabrao</r>Hello Sean, I expect the case be converted to
<pre>CASE WHEN (source &gt; destination) THEN sort_order + 1 ELSE sort_order - 1 END</pre></z><z id="t1669424261" t="fabrao I don&apos;t how to write it to have the output"><y>#</y><d>2022-11-26</d><h>00:57</h><r>fabrao</r>I don&apos;t how to write it to have the output</z><z id="t1669424615" t="seancorfield I still don&apos;t understand. What does it produce? And why is what it produces not correct for you?"><y>#</y><d>2022-11-26</d><h>01:03</h><r>seancorfield</r>I still don&apos;t understand. What does it produce? And why is what it produces not correct for you?</z><z id="t1669424925" t="fabrao Sorry to not be clear. How can I use the :case to produce a case for set sort = ?"><y>#</y><d>2022-11-26</d><h>01:08</h><r>fabrao</r>Sorry to not be clear. How can I use the :case to produce a case for set sort = ?</z><z id="t1669425015" t="fabrao I have the query in string format, and I&apos;m trying to convert it to honeysql"><y>#</y><d>2022-11-26</d><h>01:10</h><r>fabrao</r>I have the query in string format, and I&apos;m trying to convert it to honeysql</z><z id="t1669425047" t="seancorfield What did you try and what did it produce?"><y>#</y><d>2022-11-26</d><h>01:10</h><r>seancorfield</r>What did you try and what did it produce?</z><z id="t1669425059" t="seancorfield user=&gt; (sql/format {:update :table :set {:source [:case [:&gt; :source :destination] (sql/call :+ :sort-order 1) :else (sql/call :+ :sort-order 1)]}}) [&quot;UPDATE table SET source = CASE WHEN source &gt; destination THEN sort_order + ? ELSE sort_order + ? END&quot; 1 1] user=&gt;"><y>#</y><d>2022-11-26</d><h>01:10</h><r>seancorfield</r><pre>user=&gt; (sql/format {:update :table :set {:source [:case [:&gt; :source :destination] (sql/call :+ :sort-order 1) :else (sql/call :+ :sort-order 1)]}})
[&quot;UPDATE table SET source = CASE WHEN source &gt; destination THEN sort_order + ? ELSE sort_order + ? END&quot; 1 1]
user=&gt;</pre></z><z id="t1669425084" t="seancorfield That&apos;s with HoneySQL v2 -- although it could be written without sql/call now: user=&gt; (sql/format {:update :table :set {:source [:case [:&gt; :source :destination] [:+ :sort-order 1] :else [:+ :sort-order 1]]}}) [&quot;UPDATE table SET source = CASE WHEN source &gt; destination THEN sort_order + ? ELSE sort_order + ? END&quot; 1 1] user=&gt;"><y>#</y><d>2022-11-26</d><h>01:11</h><r>seancorfield</r>That&apos;s with HoneySQL v2 -- although it could be written without <code>sql/call</code> now:
<pre>user=&gt; (sql/format {:update :table :set {:source [:case [:&gt; :source :destination] [:+ :sort-order 1] :else [:+ :sort-order 1]]}})
[&quot;UPDATE table SET source = CASE WHEN source &gt; destination THEN sort_order + ? ELSE sort_order + ? END&quot; 1 1]
user=&gt;</pre></z><z id="t1669426191" t="seancorfield I basically typed what you wrote into a REPL [:attrs {:href &quot;/_/_/users/U0YJJPFRA&quot;}]"><y>#</y><d>2022-11-26</d><h>01:29</h><r>seancorfield</r>I basically typed what you wrote into a REPL <a>@U0YJJPFRA</a></z><z id="t1669429597" t="fabrao thank you"><y>#</y><d>2022-11-26</d><h>02:26</h><r>fabrao</r>thank you</z><z id="t1669900936" t="orestis Are there facilities to, er, query a HoneySQLv2 query map? For example, I want to check if a table is already left-joined. The function is trivial to write myself, but I was wondering if people tend to do this kind of thing."><y>#</y><d>2022-12-01</d><h>13:22</h><w>orestis</w>Are there facilities to, er, query a HoneySQLv2 query map? For example, I want to check if a table is already left-joined. The function is trivial to write myself, but I was wondering if people tend to do this kind of thing.</z><z id="t1669900968" t="orestis I&apos;ve had to also add facilities to join/filter/select using &quot;dynamic&quot; table names so that you would be able to do it more than once."><y>#</y><d>2022-12-01</d><h>13:22</h><r>orestis</r>I&apos;ve had to also add facilities to join/filter/select using &quot;dynamic&quot; table names so that you would be able to do it more than once.</z><z id="t1669902982" t="markaddleman There are SQLisms that make this a difficult prospect in general - particularly aliases. But, if you ignore that, I have had good experience using #CFFTD7R6Z to parse through Honey data structures"><y>#</y><d>2022-12-01</d><h>13:56</h><r>markaddleman</r>There are SQLisms that make this a difficult prospect in general - particularly aliases.  But, if you ignore that, I have had good experience using #CFFTD7R6Z to parse through Honey data structures</z><z id="t1669905130" t="orestis I think that given honeysql has a somewhat well defined grammar, the SQLisms are not such big of a deal. "><y>#</y><d>2022-12-01</d><h>14:32</h><r>orestis</r>I think that given honeysql has a somewhat well defined grammar, the SQLisms are not such big of a deal. </z><z id="t1669905140" t="orestis Eg a table name is either a keyword or a vector "><y>#</y><d>2022-12-01</d><h>14:32</h><r>orestis</r>Eg a table name is either a keyword or a vector </z><z id="t1669905272" t="markaddleman Grammar isn’t the issue but semantics are. For example: {:with [[:cte {:select [:a] :from [:t]}]] :select [:a] :from [:s] :join [:cte]} (edited to fix the syntax)"><y>#</y><d>2022-12-01</d><h>14:34</h><r>markaddleman</r>Grammar isn’t the issue but semantics are.  For example:
<pre>{:with [[:cte {:select [:a] :from [:t]}]] :select [:a] :from [:s] :join [:cte]}</pre>
(edited to fix the syntax)</z><z id="t1669905286" t="markaddleman Is :t in the join?"><y>#</y><d>2022-12-01</d><h>14:34</h><r>markaddleman</r>Is <code>:t</code> in the join?</z><z id="t1669905384" t="orestis Ah true. I’m not concerned with that though. I’m more interested in not writing functions to get the table names in the join clause. "><y>#</y><d>2022-12-01</d><h>14:36</h><r>orestis</r>Ah true. I’m not concerned with that though. I’m more interested in not writing functions to get the table names in the join clause. </z><z id="t1669905455" t="markaddleman Ah, ok. Then, I’ve had good experience using meander to parse and recursively descend into honey data structures. Meander makes it very straightforward."><y>#</y><d>2022-12-01</d><h>14:37</h><r>markaddleman</r>Ah, ok.  Then, I’ve had good experience using meander to parse and recursively descend into honey data structures.  Meander makes it very straightforward.</z><z id="t1669905541" t="orestis I do love how honeysql makes this even possible. We’ve written some terrible looking code that “prunes” an SQL query based on what the API request is. Impossible with string based sql"><y>#</y><d>2022-12-01</d><h>14:39</h><r>orestis</r>I do love how honeysql makes this even possible. We’ve written some terrible looking code that “prunes” an SQL query based on what the API request is. Impossible with string based sql</z><z id="t1669905576" t="markaddleman Agreed!"><y>#</y><d>2022-12-01</d><h>14:39</h><r>markaddleman</r>Agreed!</z><z id="t1669918999" t="seancorfield [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] That would be &quot;trivial&quot; if HoneySQL used sets for :join clauses I think? The only problem would be that JOIN order can be significant (which is why HoneySQL has a specific construct for ordering multiple JOIN clauses as well). Or I guess the join-merging logic could always apply distinct to the sequence of JOIN s?"><y>#</y><d>2022-12-01</d><h>18:23</h><r>seancorfield</r><a>@U7PBP4UVA</a> That would be &quot;trivial&quot; if HoneySQL used sets for <code>:join</code> clauses I think? The only problem would be that <code>JOIN</code> order can be significant (which is why HoneySQL has a specific construct for ordering multiple <code>JOIN</code> clauses as well). Or I guess the join-merging logic could always apply <code>distinct</code> to the sequence of <code>JOIN</code>s?</z><z id="t1669919038" t="seancorfield Feel free to create a GH issue if you think there&apos;s anything HoneySQL could do better in this area to help support your use case."><y>#</y><d>2022-12-01</d><h>18:23</h><r>seancorfield</r>Feel free to create a GH issue if you think there&apos;s anything HoneySQL could do better in this area to help support your use case.</z><z id="t1669921588" t="orestis (-&gt;&gt; query :left-join (partition-all 2) (into #{} (map first)))"><y>#</y><d>2022-12-01</d><h>19:06</h><r>orestis</r><code>(-&gt;&gt; query :left-join (partition-all 2) (into #{} (map first)))</code></z><z id="t1669921631" t="orestis This works nicely but I think doesn&apos;t handle aliasing the joined table as something else. It handles the specific query it was written for though (which assumes uniqueness, hence the cast to the set at the end)"><y>#</y><d>2022-12-01</d><h>19:07</h><r>orestis</r>This works nicely but I think doesn&apos;t handle aliasing the joined table as something else. It handles the specific query it was written for though (which assumes uniqueness, hence the cast to the set at the end)</z><z id="t1669921697" t="orestis I wouldn&apos;t change HoneySQL at all - this is a very much secondary problem that is definitely solvable in user land. I was more wondering if there are other people that are actually querying maps to find information, then some helpers might be in order."><y>#</y><d>2022-12-01</d><h>19:08</h><r>orestis</r>I wouldn&apos;t change HoneySQL at all - this is a very much secondary problem that is definitely solvable in user land. I was more wondering if there are other people that are actually querying maps to find information, then some helpers might be in order.</z><z id="t1669943267" t="eccentric J I&apos;m using HoneySQL with node&apos;s pg library. Was going smoothly until this road bump: • honeysql formats the queries like [&quot;SELECT * FROM table WHERE field = ?&quot;, &quot;value&quot;] • pg expects [ &quot;SELECT * FROM table where field = $1&quot;, [&quot;value&quot;] ] Is there an existing honeysql option to use a format that matches what pg expects? Or would it be better to just use the :inline true option with honeysql?"><y>#</y><d>2022-12-02</d><h>01:07</h><w>eccentric J</w>I&apos;m using HoneySQL with node&apos;s pg library. Was going smoothly until this road bump:
• honeysql formats the queries like <code>[&quot;SELECT * FROM table WHERE field = ?&quot;, &quot;value&quot;]</code>
• pg expects <code>[ &quot;SELECT * FROM table where field = $1&quot;, [&quot;value&quot;] ]</code> 
Is there an existing honeysql option to use a format that matches what pg expects?
Or would it be better to just use the <code>:inline true</code> option with honeysql?</z><z id="t1669943768" t="seancorfield There&apos;s an open issue for that."><y>#</y><d>2022-12-02</d><h>01:16</h><r>seancorfield</r>There&apos;s an open issue for that.</z><z id="t1669943824" t="seancorfield I have an idea of how to make it work but there&apos;s some edge cases that are a bit gnarly."><y>#</y><d>2022-12-02</d><h>01:17</h><r>seancorfield</r>I have an idea of how to make it work but there&apos;s some edge cases that are a bit gnarly.</z><z id="t1669943992" t="eccentric J Just read through the issue. What are the kinds of edge cases that would mess it up?"><y>#</y><d>2022-12-02</d><h>01:19</h><r>eccentric J</r>Just read through the issue. What are the kinds of edge cases that would mess it up?</z><z id="t1669944273" t="seancorfield I&apos;m at the chiropractor right now so I can&apos;t look up my notes on it."><y>#</y><d>2022-12-02</d><h>01:24</h><r>seancorfield</r>I&apos;m at the chiropractor right now so I can&apos;t look up my notes on it.</z><z id="t1669944363" t="eccentric J No rush, not likely to have a solution, but just curious what kind of edge cases come up with a tool like this"><y>#</y><d>2022-12-02</d><h>01:26</h><r>eccentric J</r>No rush, not likely to have a solution, but just curious what kind of edge cases come up with a tool like this</z><z id="t1669944383" t="seancorfield I think there were some corner cases around expansion of in and array since those are special cases today."><y>#</y><d>2022-12-02</d><h>01:26</h><r>seancorfield</r>I think there were some corner cases around expansion of <code>in</code> and <code>array</code> since those are special cases today.</z><z id="t1669944510" t="seancorfield But it&apos;s kind of nasty since you can&apos;t guarantee everything is generated left to right, especially if folks write their own formatters. So you have to sit out so two passes."><y>#</y><d>2022-12-02</d><h>01:28</h><r>seancorfield</r>But it&apos;s kind of nasty since you can&apos;t guarantee everything is generated left to right, especially if folks write their own formatters. So you have to sit out so two passes.</z><z id="t1669944549" t="eccentric J I see. Are there any node libraries known to be compatible with honeysql? It&apos;s a green project so can switch to another library"><y>#</y><d>2022-12-02</d><h>01:29</h><r>eccentric J</r>I see. Are there any node libraries known to be compatible with honeysql? It&apos;s a green project so can switch to another library</z><z id="t1669944926" t="seancorfield No idea. I don&apos;t do any JS."><y>#</y><d>2022-12-02</d><h>01:35</h><r>seancorfield</r>No idea. I don&apos;t do any JS.</z><z id="t1669947430" t="eccentric J Looked at a few on npmjs, seems they exclusively use that numbered format. I think given that I just have to demo a small project tomorrow I’ll just use the inline option and fix it later."><y>#</y><d>2022-12-02</d><h>02:17</h><r>eccentric J</r>Looked at a few on npmjs, seems they exclusively use that numbered format. I think given that I just have to demo a small project tomorrow I’ll just use the inline option and fix it later.</z><z id="t1669976083" t="FiVo Hey, I am trying to figure out how to create a composite primary key. (def table {:create-table :hello :with-columns [[:a :int] [:b :int]]}) (sql/format table) ;; =&gt; [&quot;CREATE TABLE hello (a INT, b INT)&quot;] (sql/format-expr [:primary-key :a :b]) ;; =&gt; [&quot;PRIMARY KEY(a, b)&quot;] How do I combine the two without doing awkward string manipulation?"><y>#</y><d>2022-12-02</d><h>10:14</h><w>FiVo</w>Hey, I am trying to figure out how to create a composite primary key.
<pre>(def table {:create-table :hello
            :with-columns
            [[:a :int]
             [:b :int]]})

(sql/format table)
;; =&gt; [&quot;CREATE TABLE hello (a INT, b INT)&quot;]

(sql/format-expr [:primary-key :a :b])
;; =&gt; [&quot;PRIMARY KEY(a, b)&quot;]</pre>
How do I combine the two without doing awkward string manipulation?</z><z id="t1669976280" t="FiVo Postgres style btw https://kb.objectrocket.com/postgresql/postgresql-composite-primary-keys-629"><y>#</y><d>2022-12-02</d><h>10:18</h><r>FiVo</r>Postgres style btw <a href="https://kb.objectrocket.com/postgresql/postgresql-composite-primary-keys-629" target="_blank">https://kb.objectrocket.com/postgresql/postgresql-composite-primary-keys-629</a></z><z id="t1669999849" t="seancorfield Not sure what you mean by &quot;combine&quot;? The primary key declaration should be part of the columns for the table, yes?"><y>#</y><d>2022-12-02</d><h>16:50</h><r>seancorfield</r>Not sure what you mean by &quot;combine&quot;? The primary key declaration should be part of the columns for the table, yes?</z><z id="t1670231268" t="FiVo I would like to add a composite primary key, I only know how to add a &quot;standard&quot; primary keys. (def table {:create-table :hello :with-columns [[:a :int [:primary-key]] [:b :int [:primary-key]]]}) (-&gt; (sql/format table) first) ;; =&gt; &quot;CREATE TABLE hello (a INT PRIMARY KEY, b INT PRIMARY KEY)&quot; ;; what I would like to have &quot;CREATE TABLE hello ( a INT, b INT, PRIMARY KEY(a,b))&quot;"><y>#</y><d>2022-12-05</d><h>09:07</h><r>FiVo</r>I would like to add a composite primary key, I only know how to add a &quot;standard&quot; primary keys.
<pre>(def table {:create-table :hello
              :with-columns
              [[:a :int [:primary-key]]
               [:b :int [:primary-key]]]})

  (-&gt; (sql/format table) first)
  ;; =&gt; &quot;CREATE TABLE hello (a INT PRIMARY KEY, b INT PRIMARY KEY)&quot;

  ;; what I would like to have 
  &quot;CREATE TABLE hello (
       a INT,
       b INT,
       PRIMARY KEY(a,b))&quot;</pre></z><z id="t1670263164" t="seancorfield [:attrs {:href &quot;/_/_/users/UL638RXE2&quot;}] user=&gt; (-&gt; {:create-table :foo :with-columns [[:a :int] [:b :int] [[:primary-key :a :b]]]} (sql/format)) [&quot;CREATE TABLE foo (a INT, b INT, PRIMARY KEY(a, b))&quot;] user=&gt; See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.947/doc/getting-started/sql-special-syntax-#column-descriptors"><y>#</y><d>2022-12-05</d><h>17:59</h><r>seancorfield</r><a>@UL638RXE2</a>
<pre>user=&gt; (-&gt; {:create-table :foo :with-columns [[:a :int] [:b :int] [[:primary-key :a :b]]]} (sql/format))
[&quot;CREATE TABLE foo (a INT, b INT, PRIMARY KEY(a, b))&quot;]
user=&gt;</pre>
See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.947/doc/getting-started/sql-special-syntax-#column-descriptors" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.947/doc/getting-started/sql-special-syntax-#column-descriptors</a></z><z id="t1670263235" t="seancorfield I&apos;ll create a ticket to add an example in :create-table and :with-columns showing how to do this, and probably duplicate that example into that linked section."><y>#</y><d>2022-12-05</d><h>18:00</h><r>seancorfield</r>I&apos;ll create a ticket to add an example in  <code>:create-table</code> and <code>:with-columns</code> showing how to do this, and probably duplicate that example into that linked section.</z><z id="t1670263767" t="seancorfield https://github.com/seancorfield/honeysql/issues/445"><y>#</y><d>2022-12-05</d><h>18:09</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/445" target="_blank">https://github.com/seancorfield/honeysql/issues/445</a></z><z id="t1670315892" t="FiVo Thank you 🙏 . I saw the special syntax section, but didn&apos;t make the connection. Haven&apos;t used SQL in Clojure. I think I even tried something similar to the above, but didn&apos;t nest [:primary-key :a :b] once more."><y>#</y><d>2022-12-06</d><h>08:38</h><r>FiVo</r>Thank you <b>🙏</b> . I saw the special syntax section, but didn&apos;t make the connection. Haven&apos;t used SQL in Clojure. I think I even tried something similar to the above, but didn&apos;t nest <code>[:primary-key :a :b]</code> once more.</z><z id="t1669991268" t="Noah Bogart My team is trying to move us from v1 to v2. We have a fmt-and-query function that we use everywhere as the primary way to write a query and then execute it with jdbc: (defn fmt-and-query [db-spec query] (try (jdbc/query db-spec (sql/format query :quoting :ansi :allow-dashed-names? true)) (catch Exception exc (handle-exception exc)))) Because we rely on this so much, it&apos;s been challenging to switch us to v2, due to the tight coupling of &quot;make a sql query map&quot; and &quot;format and use the query map&quot;. How do y&apos;all go about decomplecting your honeysql stuff from your jdbc stuff? What patterns have you come up with to help ease the transition?"><y>#</y><d>2022-12-02</d><h>14:27</h><w>Noah Bogart</w>My team is trying to move us from v1 to v2. We have a <code>fmt-and-query</code> function that we use everywhere as the primary way to write a query and then execute it with jdbc:
<pre>(defn fmt-and-query
  [db-spec query]
  (try (jdbc/query db-spec (sql/format query :quoting :ansi :allow-dashed-names? true))
       (catch Exception exc (handle-exception exc))))</pre>
Because we rely on this so much, it&apos;s been challenging to switch us to v2, due to the tight coupling of &quot;make a sql query map&quot; and &quot;format and use the query map&quot;. How do y&apos;all go about decomplecting your honeysql stuff from your jdbc stuff? What patterns have you come up with to help ease the transition?</z><z id="t1670000040" t="seancorfield It would never have occurred to me to combine formatting and querying into a single function like that 👀 Why did you couple those operations in the first place?"><y>#</y><d>2022-12-02</d><h>16:54</h><r>seancorfield</r>It would never have occurred to me to combine formatting and querying into a single function like that <b>👀</b> Why did you couple those operations in the first place?</z><z id="t1670000212" t="seancorfield We use a mix of clojure.java.jdbc and next.jdbc and a mix of HoneySQL v1 and v2. Your combined function ties you to just one of each - that&apos;s a lot of coupling."><y>#</y><d>2022-12-02</d><h>16:56</h><r>seancorfield</r>We use a mix of <code>clojure.java.jdbc</code> and <code>next.jdbc</code> and a mix of HoneySQL v1 and v2. Your combined function ties you to just one of each - that&apos;s a lot of coupling.</z><z id="t1670000481" t="Noah Bogart haha I didn&apos;t do this, the original dev of the project did it in early 2019. Looking at git history, seems they were coupled to not have to repeat the :allow-dashed-names? formatting flags. Glad to know you are doing it the way I&apos;ve proposed internally. I think set-dialect! will help us out a lot in the transition."><y>#</y><d>2022-12-02</d><h>17:01</h><r>Noah Bogart</r>haha I didn&apos;t do this, the original dev of the project did it in early 2019. Looking at git history, seems they were coupled to not have to repeat the <code>:allow-dashed-names?</code> formatting flags.

Glad to know you are doing it the way I&apos;ve proposed internally. I think <code>set-dialect!</code> will help us out a lot in the transition.</z><z id="t1670004083" t="seancorfield Even having two separate wrappers -- one to do the formatting with those options and one to call query with error handling -- would be better, but complecting two separate concerns like that was a poor decision however you slice and dice it 😞"><y>#</y><d>2022-12-02</d><h>18:01</h><r>seancorfield</r>Even having two separate wrappers -- one to do the formatting with those options and one to call <code>query</code> with error handling -- would be better, but complecting two separate concerns like that was a poor decision however you slice and dice it <b>😞</b></z><z id="t1670004131" t="seancorfield FWIW, one of our original devs did something similar for one piece of our codebase but we didn&apos;t let it spread to other parts 🙂"><y>#</y><d>2022-12-02</d><h>18:02</h><r>seancorfield</r>FWIW, one of our original devs did something similar for one piece of our codebase but we didn&apos;t let it spread to other parts <b>🙂</b></z><z id="t1670014382" t="Noah Bogart Yeah, it&apos;s a pain in the butt now, that&apos;s for sure. Thanks for the input, will be helpful as we make this transition ourselves"><y>#</y><d>2022-12-02</d><h>20:53</h><r>Noah Bogart</r>Yeah, it&apos;s a pain in the butt now, that&apos;s for sure. Thanks for the input, will be helpful as we make this transition ourselves</z><z id="t1671019845" t="Abhinav HI, is there a way to write this in honeysql? I couldn’t find any mention of the epoch from … syntax. thanks SELECT EXTRACT(EPOCH FROM (timestamp_B - timestamp_A)) FROM TableA"><y>#</y><d>2022-12-14</d><h>12:10</h><w>Abhinav</w>HI, is there a way to write this in honeysql?

I couldn’t find any mention of the <code>epoch from …</code> syntax.
thanks
<pre>SELECT EXTRACT(EPOCH FROM (timestamp_B - timestamp_A))
FROM TableA</pre></z><z id="t1671024789" t="slipset [:extract [:epoch-from [:- [:raw &quot;current_timestamp&quot;] :lastUpdated]]]"><y>#</y><d>2022-12-14</d><h>13:33</h><w>slipset</w><pre>[:extract
     [:epoch-from
      [:-
       [:raw &quot;current_timestamp&quot;]
       :lastUpdated]]]</pre></z><z id="t1671024807" t="slipset Is a piece of code from our codebase. I’m sure you can adapt that?"><y>#</y><d>2022-12-14</d><h>13:33</h><w>slipset</w>Is a piece of code from our codebase. I’m sure you can adapt that?</z><z id="t1671076057" t="Abhinav oh yes, that works. thanks"><y>#</y><d>2022-12-15</d><h>03:47</h><w>Abhinav</w>oh yes, that works. thanks</z><z id="t1671264452" t="seancorfield If anyone wants to try the first cut of numbered parameters (using $1 , $2 etc instead of ? ), take a look at https://github.com/seancorfield/honeysql/issues/405 and you can use a git dep with a SHA of c62f5da3f8d4a7f3978fa70ecec85c117b280e73"><y>#</y><d>2022-12-17</d><h>08:07</h><w>seancorfield</w>If anyone wants to try the first cut of numbered parameters (using <code>$1</code>, <code>$2</code> etc instead of <code>?</code>), take a look at <a href="https://github.com/seancorfield/honeysql/issues/405" target="_blank">https://github.com/seancorfield/honeysql/issues/405</a> and you can use a git dep with a SHA of c62f5da3f8d4a7f3978fa70ecec85c117b280e73</z><z id="t1671323264" t="seancorfield Numbered placeholder support is now available in a full release. There are tests and also examples in the docs which are automatically tested but it&apos;s possible there are edge-case bugs in this functionality since it is brand new. If you use Node.js and PostgreSQL (which requires numbered placeholders), I would really appreciate you testing this and reporting any bugs with repro cases as GH issues. Thank you!"><y>#</y><d>2022-12-18</d><h>00:27</h><w>seancorfield</w>Numbered placeholder support is now available in a full release. There are tests and also examples in the docs which are automatically tested but it&apos;s possible there are edge-case bugs in this functionality since it is brand new. If you use Node.js and PostgreSQL (which requires numbered placeholders), I would really appreciate you testing this and reporting any bugs with repro cases as GH issues. Thank you!</z><z id="t1671327464" t="seancorfield This first version of numbered placeholders does not attempt to reuse duplicate values but that&apos;s something I might add in future, if folks think it&apos;s worth it?"><y>#</y><d>2022-12-18</d><h>01:37</h><w>seancorfield</w>This first version of numbered placeholders does not attempt to reuse duplicate values but that&apos;s something I might add in future, if folks think it&apos;s worth it?</z><z id="t1671449196" t="orestis Interesting edge-case: (h/where {:where [:= 1 1]} false) ;=&gt; {:where [:and [:= 1 1] false]} but (h/where {} false) ;=&gt; {}"><y>#</y><d>2022-12-19</d><h>11:26</h><w>orestis</w>Interesting edge-case:
<pre>(h/where {:where [:= 1 1]} false)
;=&gt; {:where [:and [:= 1 1] false]}</pre>
but
<pre>(h/where {} false)
;=&gt; {}</pre></z><z id="t1671449378" t="orestis I worked around this by doing instead (h/where query [:= [:inline false] [:inline true]]) "><y>#</y><d>2022-12-19</d><h>11:29</h><r>orestis</r>I worked around this by doing instead
<pre>(h/where query [:= [:inline false] [:inline true]])</pre>
</z><z id="t1671472069" t="seancorfield Is that using the latest version? There was a bug in where around that which was addressed recently."><y>#</y><d>2022-12-19</d><h>17:47</h><r>seancorfield</r>Is that using the latest version? There was a bug in <code>where</code> around that which was addressed recently.</z><z id="t1671475206" t="orestis Ah perhaps I am running some versions behind. We need to really automate updating our clj dependencies."><y>#</y><d>2022-12-19</d><h>18:40</h><r>orestis</r>Ah perhaps I am running some versions behind. We need to really automate updating our clj dependencies.</z><z id="t1671475281" t="seancorfield This sounds like issue #431 which was fixed in 2.4.947 -- 2022-11-05"><y>#</y><d>2022-12-19</d><h>18:41</h><r>seancorfield</r>This sounds like issue #431 which was fixed in 2.4.947 -- 2022-11-05</z><z id="t1671475509" t="orestis Still on 2.2.868 😳"><y>#</y><d>2022-12-19</d><h>18:45</h><r>orestis</r>Still on 2.2.868 <b>😳</b></z><z id="t1671475923" t="seancorfield That&apos;s only a few releases behind 🙂"><y>#</y><d>2022-12-19</d><h>18:52</h><r>seancorfield</r>That&apos;s only a few releases behind <b>🙂</b></z><z id="t1672075963" t="markaddleman Is there honeysql syntax for array subscripts? ie, https://cloud.google.com/bigquery/docs/reference/standard-sql/operators#array_subscript_operator"><y>#</y><d>2022-12-26</d><h>17:32</h><w>markaddleman</w>Is there honeysql syntax for array subscripts? ie, <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/operators#array_subscript_operator" target="_blank">https://cloud.google.com/bigquery/docs/reference/standard-sql/operators#array_subscript_operator</a></z><z id="t1672076710" t="markaddleman Asked and answered before https://clojurians.slack.com/archives/C66EM8D5H/p1667313314499199 (lay off the eggnog, @me)"><y>#</y><d>2022-12-26</d><h>17:45</h><r>markaddleman</r>Asked and answered before <a href="https://clojurians.slack.com/archives/C66EM8D5H/p1667313314499199" target="_blank">https://clojurians.slack.com/archives/C66EM8D5H/p1667313314499199</a>  (lay off the eggnog, @me)</z><z id="t1672324815" t="fabrao Hello all, how do I transform this query where WHERE payload -&gt;&gt; &apos;template_id&apos; = &apos;4de1b0da-78b8-4fdd-b376-2b7548ea49d3&apos; to honeysql hashmap structure?"><y>#</y><d>2022-12-29</d><h>14:40</h><w>fabrao</w>Hello all, how do I transform this query where <code>WHERE payload -&gt;&gt; &apos;template_id&apos; = &apos;4de1b0da-78b8-4fdd-b376-2b7548ea49d3&apos;</code> to honeysql hashmap structure?</z><z id="t1672332932" t="orestis (sql/register-op! :-&gt; :variadic true) (sql/register-op! :-&gt;&gt; :variadic true) "><y>#</y><d>2022-12-29</d><h>16:55</h><r>orestis</r><pre>(sql/register-op! :-&gt; :variadic true)
(sql/register-op! :-&gt;&gt; :variadic true)</pre>
</z><z id="t1672333030" t="orestis You can then use :-&gt;&gt; as an operator: [:where [:= &quot;4de1b0da-78b8-4fdd-b376-2b7548ea49d3&quot; [:-&gt;&gt; :payload [:inline &quot;template_id&quot;]]]] "><y>#</y><d>2022-12-29</d><h>16:57</h><r>orestis</r>You can then use <code>:-&gt;&gt;</code> as an operator:
<pre>[:where 
 [:=
   &quot;4de1b0da-78b8-4fdd-b376-2b7548ea49d3&quot;
   [:-&gt;&gt; :payload [:inline &quot;template_id&quot;]]]] </pre>
</z><z id="t1672333054" t="orestis The :inline isn&apos;t strictly needed but for static paths it saves you one JDBC parameter in the resulting query."><y>#</y><d>2022-12-29</d><h>16:57</h><r>orestis</r>The <code>:inline</code> isn&apos;t strictly needed but for static paths it saves you one JDBC parameter in the resulting query.</z><z id="t1672333067" t="fabrao oh, I&apos;ll test here, thank you"><y>#</y><d>2022-12-29</d><h>16:57</h><r>fabrao</r>oh, I&apos;ll test here, thank you</z><z id="t1672333100" t="orestis Since :-&gt;&gt; is variadic you can keep adding path elements... [:-&gt;&gt; payload &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]"><y>#</y><d>2022-12-29</d><h>16:58</h><r>orestis</r>Since <code>:-&gt;&gt;</code> is variadic you can keep adding path elements...
<code>[:-&gt;&gt; payload &quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</code></z><z id="t1672333136" t="fabrao I used :where [:= &quot;payload-&gt;&gt;&apos;template_id&apos;&quot; id] and worked too"><y>#</y><d>2022-12-29</d><h>16:58</h><r>fabrao</r>I used <code>:where [:= &quot;payload-&gt;&gt;&apos;template_id&apos;&quot; id]</code>  and worked too</z><z id="t1672334049" t="orestis That looks like it would work, yes!"><y>#</y><d>2022-12-29</d><h>17:14</h><r>orestis</r>That looks like it would work, yes!</z><z id="t1672345464" t="seancorfield These are built-in for HoneySQL -- no need to register new ops -- but you do need to require the pg-ops namespace. See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/api/honey.sql.pg-ops"><y>#</y><d>2022-12-29</d><h>20:24</h><r>seancorfield</r>These are built-in for HoneySQL -- no need to register new ops -- but you do need to require the <code>pg-ops</code> namespace. See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/api/honey.sql.pg-ops" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/api/honey.sql.pg-ops</a></z><z id="t1672345520" t="seancorfield Also see https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/doc/getting-started/postgresql-support#operators-with---and- for notes on some PG ops that cannot be represented as Clojure keywords/symbols."><y>#</y><d>2022-12-29</d><h>20:25</h><r>seancorfield</r>Also see <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/doc/getting-started/postgresql-support#operators-with---and-" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.962/doc/getting-started/postgresql-support#operators-with---and-</a> for notes on some PG ops that cannot be represented as Clojure keywords/symbols.</z><z id="t1672942686" t="marrs Are there any libs based on Honeysql for manipulating DB schemas?"><y>#</y><d>2023-01-05</d><h>18:18</h><w>marrs</w>Are there any libs based on Honeysql for manipulating DB schemas?</z><z id="t1672944316" t="marrs I should have mentioned, I already know about the helpers provided"><y>#</y><d>2023-01-05</d><h>18:45</h><r>marrs</r>I should have mentioned, I already know about the helpers provided</z><z id="t1672995005" t="ts1503 I’m working on a such library but it’s not ready yet. it works only for postgres right now https://github.com/parencat/fx/blob/master/src/fx/migrate.clj the idea here that it will read a malli schemas and will produce a ddl statements for postgres"><y>#</y><d>2023-01-06</d><h>08:50</h><r>ts1503</r>I’m working on a such library but it’s not ready yet. it works only for postgres right now <a href="https://github.com/parencat/fx/blob/master/src/fx/migrate.clj" target="_blank">https://github.com/parencat/fx/blob/master/src/fx/migrate.clj</a>
the idea here that it will read a malli schemas and will produce a ddl statements for postgres</z><z id="t1673194558" t="marrs [:attrs {:href &quot;/_/_/users/U19BK6W0L&quot;}] thanks, I&apos;m working with PG so that works for me. I&apos;m trying to come up with a way to migrate table definitions declaritively instead of manually defining roll-forward/back procedures for every change. The idea is that you can compare 2 schemas defined in different commits and generate the necessary ddl to migrate between them automatically"><y>#</y><d>2023-01-08</d><h>16:15</h><r>marrs</r><a>@U19BK6W0L</a> thanks, I&apos;m working with PG so that works for me.

I&apos;m trying to come up with a way to migrate table definitions declaritively instead of manually defining roll-forward/back procedures for every change.  The idea is that you can compare 2 schemas defined in different commits and generate the necessary ddl to migrate between them automatically</z><z id="t1673357194" t="marrs [:attrs {:href &quot;/_/_/users/U19BK6W0L&quot;}] It looks like your approach is similar but works to the definition installed on the database instead. Did I get that right? How far along is this project? What can you do with it so far?"><y>#</y><d>2023-01-10</d><h>13:26</h><r>marrs</r><a>@U19BK6W0L</a> It looks like your approach is similar but works to the definition installed on the database instead.  Did I get that right?  How far along is this project?  What can you do with it so far?</z><z id="t1673358143" t="ts1503 Hi [:attrs {:href &quot;/_/_/users/UVDD67FFX&quot;}] Sorry for long response. I can show some examples later today. Just need to finish my work "><y>#</y><d>2023-01-10</d><h>13:42</h><r>ts1503</r>Hi <a>@UVDD67FFX</a> 
Sorry for long response. I can show some examples later today. Just need to finish my work </z></g><g id="s8"><z id="t1673013329" t="David Yang Are there any patterns/libraries that normalize the results of queries with left joins? For example if I do something like select * from blog_posts left join comments I want to get a list of blog_post maps that have comments being a list of comment maps?"><y>#</y><d>2023-01-06</d><h>13:55</h><w>David Yang</w>Are there any patterns/libraries that normalize the results of queries with left joins?  For example if I do something like <code>select * from blog_posts left join comments</code>  I want to get a list of blog_post maps that have <code>comments</code> being a list of comment maps?</z><z id="t1673013415" t="orestis Looking how popular ORMs do this (outside of Clojure), it seems they will do two queries. One for blog_posts, then one for comments."><y>#</y><d>2023-01-06</d><h>13:56</h><r>orestis</r>Looking how popular ORMs do this (outside of Clojure), it seems they will do two queries. One for blog_posts, then one for comments.</z><z id="t1673013446" t="orestis Clojure could easily let you group-by blog_posts.id"><y>#</y><d>2023-01-06</d><h>13:57</h><r>orestis</r>Clojure could easily let you group-by <code>blog_posts.id</code></z><z id="t1673013668" t="David Yang Thanks [:attrs {:href &quot;/_/_/users/U7PBP4UVA&quot;}] - ideally I’d like to get it into a format that I could pump into pyramid so then I could run pull queries"><y>#</y><d>2023-01-06</d><h>14:01</h><r>David Yang</r>Thanks <a>@U7PBP4UVA</a> - ideally I’d like to get it into a format that I could pump into <code>pyramid</code> so then I could run pull queries</z><z id="t1673013742" t="David Yang I was thinking if that’s too hard then I could just do something like (-&gt; :blog_post/id distinct) and then iterate over that"><y>#</y><d>2023-01-06</d><h>14:02</h><r>David Yang</r>I was thinking if that’s too hard then  I could just do something like <code>(-&gt; :blog_post/id distinct)</code> and then iterate over that</z><z id="t1673013838" t="orestis (group-by (fn [row] (select-keys row [:blog_post/id :blog_post/title ,,,]) rows) "><y>#</y><d>2023-01-06</d><h>14:03</h><r>orestis</r><pre>(group-by (fn [row] (select-keys row [:blog_post/id :blog_post/title ,,,]) rows)</pre>
</z><z id="t1673013874" t="orestis This should give you a map with the keys being the blog posts, and for each blog post the sql rows (you would need to map another select-keys there to get only the comment columns)..."><y>#</y><d>2023-01-06</d><h>14:04</h><r>orestis</r>This should give you a map with the keys being the blog posts, and for each blog post the sql rows (you would need to map another <code>select-keys</code> there to get only the comment columns)...</z><z id="t1673014026" t="David Yang I see - that makes sense - that would give me a map with blog-post maps as keys right?"><y>#</y><d>2023-01-06</d><h>14:07</h><r>David Yang</r>I see - that makes sense - that would give me a map with blog-post maps as keys right?</z><z id="t1673014035" t="orestis yes"><y>#</y><d>2023-01-06</d><h>14:07</h><r>orestis</r>yes</z><z id="t1673014037" t="David Yang but not necessarily preserve order"><y>#</y><d>2023-01-06</d><h>14:07</h><r>David Yang</r>but not necessarily preserve order</z><z id="t1673014085" t="orestis No, order will be lost since you get a map. Another think you could consider is using aggregate functions - if you use PostgreSQL you can get one row per blog post with the comments as a PG array or a JSONB array."><y>#</y><d>2023-01-06</d><h>14:08</h><r>orestis</r>No, order will be lost since you get a map. Another think you could consider is using aggregate functions - if you use PostgreSQL you can get one row per blog post with the comments as a PG array or a JSONB array.</z><z id="t1673014114" t="David Yang cool - alright thanks for the help!"><y>#</y><d>2023-01-06</d><h>14:08</h><r>David Yang</r>cool - alright thanks for the help!</z><z id="t1673014160" t="orestis The issues with SQL aggregates is data type loss: jsonb for example is only JSON, so if you have dates and such they will be converted to strings."><y>#</y><d>2023-01-06</d><h>14:09</h><r>orestis</r>The issues with SQL aggregates is data type loss: jsonb for example is only JSON, so if you have dates and such they will be converted to strings.</z><z id="t1673014211" t="David Yang I don’t want to get too in bed with SQL in my queries, I feel like that complicates the queries and also require mentally understanding nuances of pg aggregates"><y>#</y><d>2023-01-06</d><h>14:10</h><r>David Yang</r>I don’t want to get too in bed with SQL in my queries, I feel like that complicates the queries and also require mentally understanding nuances of pg aggregates</z><z id="t1673014231" t="orestis Yep that&apos;s the tradeoff 🙂"><y>#</y><d>2023-01-06</d><h>14:10</h><r>orestis</r>Yep that&apos;s the tradeoff <b>🙂</b></z><z id="t1673014287" t="David Yang I basically want something like Datomic’s pull syntax for SQL - the closest thing I’ve found is https://walkable.gitlab.io/ but looking to do it over honeysql 🙂"><y>#</y><d>2023-01-06</d><h>14:11</h><r>David Yang</r>I basically want something like Datomic’s pull syntax for SQL - the closest thing I’ve found is <a href="https://walkable.gitlab.io/" target="_blank">https://walkable.gitlab.io/</a> but looking to do it over honeysql <b>🙂</b></z><z id="t1673014352" t="orestis There&apos;s also https://pathom3.wsscode.com"><y>#</y><d>2023-01-06</d><h>14:12</h><r>orestis</r>There&apos;s also <a href="https://pathom3.wsscode.com" target="_blank">https://pathom3.wsscode.com</a></z><z id="t1673014358" t="orestis I haven&apos;t used any of those though."><y>#</y><d>2023-01-06</d><h>14:12</h><r>orestis</r>I haven&apos;t used any of those though.</z><z id="t1673741170" t="seancorfield"><y>#</y><d>2023-01-15</d><h>00:06</h><w>seancorfield</w></z><z id="t1675116143" t="nigel I want to convert boolean values to bit values for DBs that don&apos;t have BOOLEAN values (sqlserver, oracle) in a consistent way (say, convert INT), while also keeping TRUE/FALSE values for dbs with native boolean support. a) Is this supported with HoneySQL? It doesn&apos;t appear to be. b) would registering a new dialect be a good approach, or should this be handled in application code?"><y>#</y><d>2023-01-30</d><h>22:02</h><w>nigel</w>I want to convert boolean values to bit values for DBs that don&apos;t have BOOLEAN values (sqlserver, oracle) in a consistent way (say, convert INT), while also keeping TRUE/FALSE values for dbs with native boolean support.
a) Is this supported with HoneySQL? It doesn&apos;t appear to be.
b) would registering a new dialect be a good approach, or should this be handled in application code?</z><z id="t1675116392" t="seancorfield I&apos;m not even sure what you&apos;re asking in terms of HoneySQL -- bit/boolean conversion happens at the JDBC level."><y>#</y><d>2023-01-30</d><h>22:06</h><r>seancorfield</r>I&apos;m not even sure what you&apos;re asking in terms of HoneySQL -- bit/boolean conversion happens at the JDBC level.</z><z id="t1675116947" t="nigel Thanks. I guess my question was really &quot;where should this happen&quot;"><y>#</y><d>2023-01-30</d><h>22:15</h><r>nigel</r>Thanks. I guess my question was really &quot;where should this happen&quot;</z><z id="t1675117402" t="seancorfield MySQL does not have a BOOLEAN data type, but its JDBC driver converts to/from Boolean just fine for a BIT(1) field. It&apos;s not even done in next.jdbc ."><y>#</y><d>2023-01-30</d><h>22:23</h><r>seancorfield</r>MySQL does not have a BOOLEAN data type, but its JDBC driver converts to/from Boolean just fine for a BIT(1) field. It&apos;s not even done in <code>next.jdbc</code>.</z><z id="t1675117455" t="seancorfield For a JDBC driver that doesn&apos;t do the conversion you want, you can generally extend the protocols in next.jdbc to &quot;force&quot; the conversion but you have to be a bit careful since such conversions will be global to your application."><y>#</y><d>2023-01-30</d><h>22:24</h><r>seancorfield</r>For a JDBC driver that doesn&apos;t do the conversion you want, you can generally extend the protocols in <code>next.jdbc</code> to &quot;force&quot; the conversion but you have to be a bit careful since such conversions will be global to your application.</z><z id="t1675117533" t="nigel Excellent. Thanks for the help."><y>#</y><d>2023-01-30</d><h>22:25</h><r>nigel</r>Excellent. Thanks for the help.</z><z id="t1675363677" t="seancorfield Thanks to [:attrs {:href &quot;/_/_/users/U42REFCKA&quot;}] for suggesting this migration enhancement!"><y>#</y><d>2023-02-02</d><h>18:47</h><w>seancorfield</w>Thanks to <a>@camsaul</a> for suggesting this migration enhancement!</z><z id="t1675365439" t="refset Hi, has anyone here already looked at Julia&apos;s FunSQL library and formed an opinion about how HoneySQL compares? This is a nice overview of roughly how FunSQL works in contrast to more typical query builders: https://mechanicalrabbit.github.io/FunSQL.jl/stable/two-kinds-of-sql-query-builders/ My crude impression is that FunSQL somehow offers a more abstract level of representation &amp; composition. In any case I wonder whether there are new/useful ideas that could be borrowed and applied on top of HoneySQL (potentially in another lib altogether), e.g. the ability to do things like https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.Bind-Tuple : &gt; In a scalar context, the Bind node is translated to a correlated subquery. When Bind is applied to the joinee branch of a Join node, it is translated to a JOIN LATERAL query."><y>#</y><d>2023-02-02</d><h>19:17</h><w>refset</w>Hi, has anyone here already looked at Julia&apos;s FunSQL library and formed an opinion about how HoneySQL compares? This is a nice overview of roughly how FunSQL works in contrast to more typical query builders: <a href="https://mechanicalrabbit.github.io/FunSQL.jl/stable/two-kinds-of-sql-query-builders/" target="_blank">https://mechanicalrabbit.github.io/FunSQL.jl/stable/two-kinds-of-sql-query-builders/</a>

My crude impression is that FunSQL somehow offers a more abstract level of representation &amp; composition. In any case I wonder whether there are new/useful ideas that could be borrowed and applied on top of HoneySQL (potentially in another lib altogether), e.g. the ability to do things like <a href="https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.Bind-Tuple" target="_blank">https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.Bind-Tuple</a>:
&gt; In a scalar context, the <code>Bind</code> node is translated to a correlated subquery. When <code>Bind</code> is applied to the <code>joinee</code> branch of a <code>Join</code> node, it is translated to a <code>JOIN LATERAL</code> query.</z><z id="t1675368040" t="seancorfield I have to be honest, I find those Julia examples much, much harder to comprehend than a HoneySQL query with explicit aliases used to disambiguate the inner/outer table references..."><y>#</y><d>2023-02-02</d><h>20:00</h><r>seancorfield</r>I have to be honest, I find those Julia examples much, much harder to comprehend than a HoneySQL query with explicit aliases used to disambiguate the inner/outer table references...</z><z id="t1675368148" t="seancorfield I also find the idea of ordering of clauses affecting the generated SQL to be just a potential for all sorts of weird bugs. HoneySQL (and most of those other SQL builders) is not order sensitive, which makes programmatic building of queries much easier -- and how could you be order sensitive when the underlying data representation is a hash map?"><y>#</y><d>2023-02-02</d><h>20:02</h><r>seancorfield</r>I also find the idea of ordering of clauses affecting the generated SQL to be just a potential for all sorts of weird bugs. HoneySQL (and most of those other SQL builders) is not order sensitive, which makes programmatic building of queries much easier -- and how could you be order sensitive when the underlying data representation is a hash map?</z><z id="t1675368189" t="slipset The quote given turns me off with out knowing anything about funsql. The beauty of honeysql for me is that it has a fairly simple mapping to plain old sql, and I can combine bits of honey with the usual suspects from the core library."><y>#</y><d>2023-02-02</d><h>20:03</h><r>slipset</r>The quote given turns me off with out knowing anything about funsql. The beauty of honeysql for me is that it has a fairly simple mapping to plain old sql, and I can combine bits of honey with the usual suspects from the core library.</z><z id="t1675368209" t="seancorfield (in fact, that&apos;s a specific issue that HoneySQL provides a way to control: join ordering, because that can be sensitive to clause order and a user needs to have control over that)"><y>#</y><d>2023-02-02</d><h>20:03</h><r>seancorfield</r>(in fact, that&apos;s a specific issue that HoneySQL provides a way to control: join ordering, because that can be sensitive to clause order and a user needs to have control over that)</z><z id="t1675368293" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.972/doc/getting-started/sql-clause-reference#join-by -- for the cases where JOIN order actually matters (and I feel like saying #notalldatabases here since I believe only some databases are sensitive to this issue?)."><y>#</y><d>2023-02-02</d><h>20:04</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.972/doc/getting-started/sql-clause-reference#join-by" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.972/doc/getting-started/sql-clause-reference#join-by</a> -- for the cases where <code>JOIN</code> order actually matters (and I feel like saying #notalldatabases here since I believe only some databases are sensitive to this issue?).</z><z id="t1675368334" t="seancorfield And, yeah, what [:attrs {:href &quot;/_/_/users/U04V5VAUN&quot;}] said: context-sensitive changes to semantics are nearly always problematic."><y>#</y><d>2023-02-02</d><h>20:05</h><r>seancorfield</r>And, yeah, what <a>@U04V5VAUN</a> said: context-sensitive changes to semantics are nearly always problematic.</z><z id="t1675368391" t="seancorfield But if there are specific things that FunSQL can do that you&apos;d like to see added to HoneySQL [:attrs {:href &quot;/_/_/users/U899JBRPF&quot;}] please feel free to create issues on GH so I can take a look at those use cases! I&apos;m always open to specific ways to improve the library."><y>#</y><d>2023-02-02</d><h>20:06</h><r>seancorfield</r>But if there are specific things that FunSQL can do that you&apos;d like to see added to HoneySQL <a>@U899JBRPF</a> please feel free to create issues on GH so I can take a look at those use cases! I&apos;m always open to specific ways to improve the library.</z><z id="t1675368441" t="seancorfield (Datalog clauses are order sensitive, right? That&apos;s why they use vectors...?)"><y>#</y><d>2023-02-02</d><h>20:07</h><r>seancorfield</r>(Datalog clauses are order sensitive, right? That&apos;s why they use vectors...?)</z><z id="t1675373349" t="refset Thank you for the responses! I will give this some more reflection soon 🙂 &gt; Datalog clauses are order sensitive, right? That&apos;s why they use vectors...? The compsci definition of Datalog is fully declarative (first-order logic), but some implementations use the user-provided clause ordering to determine the physical execution plan (rather than having an optimizer doing statistics and join planning)."><y>#</y><d>2023-02-02</d><h>21:29</h><r>refset</r>Thank you for the responses! I will give this some more reflection soon <b>🙂</b>

&gt;  Datalog clauses are order sensitive, right? That&apos;s why they use vectors...?
The compsci definition of Datalog is fully declarative (first-order logic), but some implementations use the user-provided clause ordering to determine the physical execution plan (rather than having an optimizer doing statistics and join planning).</z><z id="t1675413309" t="Cam Saul RE join order: Postgres and MySQL are sensitive about the order of joins. H2 is not. Not sure about anything else. I can write a test and run it against the 14 SQL databases we support in Metabase and get a more detailed answer if it would be useful "><y>#</y><d>2023-02-03</d><h>08:35</h><r>Cam Saul</r>RE join order: Postgres and MySQL are sensitive about the order of joins. H2 is not. Not sure about anything else. I can write a test and run it against the 14 SQL databases we support in Metabase and get a more detailed answer if it would be useful </z><z id="t1675425249" t="refset I learned recently that SQLite has a CROSS JOIN https://www.sqlite.org/optoverview.html#:~:text=SQLite%20treats%20the%20CROSS%20JOIN%20operator%20specially.%20The%20CROSS%20JOIN%20operator%20is%20commutative%2C%20in%20theory.%20However%2C%20SQLite%20chooses%20to%20never%20reorder%20tables%20in%20a%20CROSS%20JOIN.%20This%20provides%20a%20mechanism%20by%20which%20the%20programmer%20can%20force%20SQLite%20to%20choose%20a%20particular%20loop%20nesting%20order. : &gt; SQLite https://www.sqlite.org/lang_select.html#crossjoin . The CROSS JOIN operator is commutative, in theory. However, SQLite chooses to never reorder tables in a CROSS JOIN. This provides a mechanism by which the programmer can force SQLite to choose a particular loop nesting order."><y>#</y><d>2023-02-03</d><h>11:54</h><r>refset</r>I learned recently that SQLite has a <code>CROSS JOIN</code> <a href="https://www.sqlite.org/optoverview.html#:~:text=SQLite%20treats%20the%20CROSS%20JOIN%20operator%20specially.%20The%20CROSS%20JOIN%20operator%20is%20commutative%2C%20in%20theory.%20However%2C%20SQLite%20chooses%20to%20never%20reorder%20tables%20in%20a%20CROSS%20JOIN.%20This%20provides%20a%20mechanism%20by%20which%20the%20programmer%20can%20force%20SQLite%20to%20choose%20a%20particular%20loop%20nesting%20order." target="_blank">https://www.sqlite.org/optoverview.html#:~:text=SQLite%20treats%20the%20CROSS%20JOIN%20operator%20specially.%20The%20CROSS%20JOIN%20operator%20is%20commutative%2C%20in%20theory.%20However%2C%20SQLite%20chooses%20to%20never%20reorder%20tables%20in%20a%20CROSS%20JOIN.%20This%20provides%20a%20mechanism%20by%20which%20the%20programmer%20can%20force%20SQLite%20to%20choose%20a%20particular%20loop%20nesting%20order.</a>:
&gt; SQLite <a href="https://www.sqlite.org/lang_select.html#crossjoin" target="_blank">https://www.sqlite.org/lang_select.html#crossjoin</a>. The CROSS JOIN operator is commutative, in theory. However, SQLite chooses to never reorder tables in a CROSS JOIN. This provides a mechanism by which the programmer can force SQLite to choose a particular loop nesting order.</z><z id="t1675878669" t="marrs [:attrs {:href &quot;/_/_/users/U899JBRPF&quot;}] I&apos;d not heard of FunSQL before so I&apos;ve just read the article you linked to in your first post. My gut reaction to it is that it&apos;s an abstraction too far removed from the underlying database to want to use it instead of an AST like HoneySQL. I might however wish to implement something like it on top of HoneySQL. It seems from the examples that you can get much of the same experience by just changing the order in which you build your map. Just write {:from, :select} rather than {:select, :from} . But that&apos;s by the by. The article says that &quot;syntax-oriented query builders are harder to use&quot;. I guess that depends on what you&apos;re trying to use them for. Fundamentally, I&apos;m writing SQL whether I know it or not, and that&apos;s what I&apos;m going to be working with if ever I have to debug a broken query, or optimise a slow query, or whatever. I&apos;m going to be reading and comprehending SQL and, once I&apos;ve worked out how to fix it, I&apos;m then going to be trying to work out how to change my library code to generate that fix. HSQL is essentially a one-to-one mapping. You can intuit just by looking at it what SQL it will produce. That&apos;s a big win when fighting with queries. Another thing worth noting about HoneySQL that you should always look for in libraries: it has an escape hatch. If ever the library can&apos;t do what you need (or you can&apos;t work out what it can do) you can just use :raw to write SQL directly and move on with your life. Frankly, that is worth way more to me than any level of architectural purity. Having said that, I&apos;ve not looked at this library, so I&apos;m not saying anything about it specifically. These are just the things I would be considering if I were evaluating it for use in one of my projects."><y>#</y><d>2023-02-08</d><h>17:51</h><r>marrs</r><a>@U899JBRPF</a> I&apos;d not heard of FunSQL before so I&apos;ve just read the article you linked to in your first post.

My gut reaction to it is that it&apos;s an abstraction too far removed from the underlying database to want to use it instead of an AST like HoneySQL.  I might however wish to implement something like it on top of HoneySQL.

It seems from the examples that you can get much of the same experience by just changing the order in which you build your map.  Just write <code>{:from, :select}</code> rather than <code>{:select, :from}</code>.

But that&apos;s by the by.  The article says that &quot;syntax-oriented query builders are harder to use&quot;.  I guess that depends on what you&apos;re trying to use them for.  Fundamentally, I&apos;m writing SQL whether I know it or not, and that&apos;s what I&apos;m going to be working with if ever I have to debug a broken query, or optimise a slow query, or whatever.  I&apos;m going to be reading and comprehending SQL and, once I&apos;ve worked out how to fix it, I&apos;m then going to be trying to work out how to change my library code to generate that fix.

HSQL is essentially a one-to-one mapping.  You can intuit just by looking at it what SQL it will produce.  That&apos;s a big win when fighting with queries.

Another thing worth noting about HoneySQL that you should always look for in libraries: it has an escape hatch.  If ever the library can&apos;t do what you need (or you can&apos;t work out what it can do) you can just use <code>:raw</code> to write SQL directly and move on with your life.

Frankly, that is worth way more to me than any level of architectural purity.

Having said that, I&apos;ve not looked at this library, so I&apos;m not saying anything about it specifically.  These are just the things I would be considering if I were evaluating it for use in one of my projects.</z><z id="t1675878923" t="slipset Especially about the :raw"><y>#</y><d>2023-02-08</d><h>17:55</h><r>slipset</r>Especially about the <code>:raw</code></z><z id="t1675966782" t="marrs [:attrs {:href &quot;/_/_/users/U899JBRPF&quot;}] This may interest you: https://walkable.gitlab.io/ . It&apos;s at a similar level of abstraction to FunSQL. Again, I have no practical experience with it"><y>#</y><d>2023-02-09</d><h>18:19</h><r>marrs</r><a>@U899JBRPF</a> This may interest you: <a href="https://walkable.gitlab.io/" target="_blank">https://walkable.gitlab.io/</a>.  It&apos;s at a similar level of abstraction to FunSQL.  Again, I have no practical experience with it</z><z id="t1676152606" t="seancorfield More compatibility with 1.x; improvements to extension machinery:"><y>#</y><d>2023-02-11</d><h>21:56</h><w>seancorfield</w>More compatibility with 1.x; improvements to extension machinery:</z><z id="t1676528476" t="seancorfield [:attrs {:href &quot;/_/_/users/U08E8UGF7&quot;}] gratitude for finding and reporting that bug so quickly!"><y>#</y><d>2023-02-16</d><h>06:21</h><w>seancorfield</w><a>@thenonameguy</a> <b>gratitude</b> for finding and reporting that bug so quickly!</z><z id="t1676665340" t="stopa dropping by to say...oof honeysql is so cool and useful! Maybe the best sql builder I&apos;ve ever used. Great work!"><y>#</y><d>2023-02-17</d><h>20:22</h><w>stopa</w>dropping by to say...oof honeysql is so cool and useful! Maybe the best sql builder I&apos;ve ever used. Great work!</z><z id="t1676684376" t="seancorfield Thank you! It&apos;s always nice to hear praise (instead of complaints!)."><y>#</y><d>2023-02-18</d><h>01:39</h><r>seancorfield</r>Thank you! It&apos;s always nice to hear praise (instead of complaints!).</z><z id="t1676778742" t="hifumi123 Yup. At first I didn’t like HoneySQL because I thought it was just handwriting SQL statements in vectors. But the “aha!” moment for me was being able to use HoneySQL to build “template” queries and merge data together in ways that’s simply impossible with SQL itself. I’ve also found it really nice to have EDN files act as data for migration scripts. I do this with the ragtime library, which doesn’t officially support my use case, but there’s a nice way to make it work together with HoneySQL. Super convenient stuff"><y>#</y><d>2023-02-19</d><h>03:52</h><r>hifumi123</r>Yup. At first I didn’t like HoneySQL because I thought it was just handwriting SQL statements in vectors. But the “aha!” moment for me was being able to use HoneySQL to build “template” queries and merge data together in ways that’s simply impossible with SQL itself.

I’ve also found it really nice to have EDN files act as data for migration scripts. I do this with the ragtime library, which doesn’t officially support my use case, but there’s a nice way to make it work together with HoneySQL. Super convenient stuff</z><z id="t1676909343" t="henrik Playing around with H2 and HoneySQL. Very cool! A question regarding variables; I’m inserting a bunch of rows where one value is a foreign key. It’s the same foreign key for all entries, so I’d like to look up the foreign key once, bind it to a variable. Doing the lookup inline in the :insert-into looks like it might become a bit verbose when there are many entries. Long story short, is there syntax for binding the result of a select into a variable that I can use in the insert?"><y>#</y><d>2023-02-20</d><h>16:09</h><w>henrik</w>Playing around with H2 and HoneySQL. Very cool!

A question regarding variables; I’m inserting a bunch of rows where one value is a foreign key. It’s the same foreign key for all entries, so I’d like to look up the foreign key once, bind it to a variable. Doing the lookup inline in the <code>:insert-into</code> looks like it might become a bit verbose when there are many entries.

Long story short, is there syntax for binding the result of a select into a variable that I can use in the insert?</z><z id="t1677019252" t="nigel Is there are way to quote a field or column only in special edge cases? Say I have a quote-for-safety? fn that returns a bool if a word contains certain special characters. I suppose I could register a new dialect and create a new :quote fn that only quotes conditionally. Alternatively, is there any way to map onto the just the keywords and columns of a honeysql expression?"><y>#</y><d>2023-02-21</d><h>22:40</h><w>nigel</w>Is there are way to quote a field or column only in special edge cases? Say I have a <code>quote-for-safety?</code> fn that returns a bool if a word contains certain special characters.
I suppose I could register a new dialect and create a new <code>:quote</code> fn that only quotes conditionally.
Alternatively, is there any way to map onto the just the keywords and columns of a honeysql expression?</z><z id="t1677020082" t="seancorfield [:attrs {:href &quot;/_/_/users/U0ZCYC77T&quot;}] Can you explain what problem you are trying to solve? Or is this just a preference in terms of the generated SQL?"><y>#</y><d>2023-02-21</d><h>22:54</h><r>seancorfield</r><a>@U0ZCYC77T</a> Can you explain what problem you are trying to solve?

Or is this just a preference in terms of the generated SQL?</z><z id="t1677020854" t="nigel [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Here&apos;s the specific problem I&apos;m running into: ; I want this quoting behavior, but with :sqlserver quotes (sql/format {:select [:some##field :another-field]}) ;; =&gt; [&quot;SELECT \&quot;some##field\&quot;, another_field&quot;] ;; ;; passing a dialect quotes everything (sql/format {:select [:some##field :another-field]} {:dialect :sqlserver}) ;; =&gt; [&quot;SELECT [some##field], [another-field]&quot;] ;; ;; turning quoting off passes the first field unquoted (sql/format {:select [:some##field :another-field]} {:dialect :sqlserver :quoted false}) ;; =&gt; [&quot;SELECT some##field, another_field&quot;] using com.github.seancorfield/honeysql {:mvn/version &quot;2.4.969&quot;}"><y>#</y><d>2023-02-21</d><h>23:07</h><r>nigel</r><a>@U04V70XH6</a> Here&apos;s the specific problem I&apos;m running into:
<pre>; I want this quoting behavior, but with :sqlserver quotes
(sql/format {:select [:some##field :another-field]})
;; =&gt; [&quot;SELECT \&quot;some##field\&quot;, another_field&quot;]
;; 
;; passing a dialect quotes everything
(sql/format {:select [:some##field :another-field]} {:dialect :sqlserver})
;; =&gt; [&quot;SELECT [some##field], [another-field]&quot;]
;; 
;; turning quoting off passes the first field unquoted
(sql/format {:select [:some##field :another-field]} {:dialect :sqlserver :quoted false})
;; =&gt; [&quot;SELECT some##field, another_field&quot;]</pre>
using <code>com.github.seancorfield/honeysql   {:mvn/version &quot;2.4.969&quot;}</code></z><z id="t1677021805" t="seancorfield Right, but what problem are you trying to solve? Quoting all the fields is not a problem in itself."><y>#</y><d>2023-02-21</d><h>23:23</h><r>seancorfield</r>Right, but what problem are you trying to solve? Quoting all the fields is not a problem in itself.</z><z id="t1677021820" t="seancorfield That&apos;s why I asked if this is just preference on your part?"><y>#</y><d>2023-02-21</d><h>23:23</h><r>seancorfield</r>That&apos;s why I asked if this is just preference on your part?</z><z id="t1677021886" t="seancorfield You can set the (default) dialect globally -- is that what you&apos;re asking about?"><y>#</y><d>2023-02-21</d><h>23:24</h><r>seancorfield</r>You can set the (default) dialect globally -- is that what you&apos;re asking about?</z><z id="t1677021925" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/api/honey.sql#set-dialect !"><y>#</y><d>2023-02-21</d><h>23:25</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/api/honey.sql#set-dialect" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/api/honey.sql#set-dialect</a>!</z><z id="t1677022226" t="seancorfield Was that the answer? You wanted the default dialect to be SQL Server, rather than ANSI?"><y>#</y><d>2023-02-21</d><h>23:30</h><r>seancorfield</r>Was that the answer? You wanted the default dialect to be SQL Server, rather than ANSI?</z><z id="t1677022234" t="nigel Oh, sorry. I&apos;m migrating a codebase from HoneySQL 1 -&gt; 2, was just trying to match the existing behavior. I&apos;m actually not sure if quoting everything will cause a problem in our case, I&apos;ll try that."><y>#</y><d>2023-02-21</d><h>23:30</h><r>nigel</r>Oh, sorry. I&apos;m migrating a codebase from HoneySQL 1 -&gt; 2, was just trying to match the existing behavior. I&apos;m actually not sure if quoting everything will cause a problem in our case, I&apos;ll try that.</z><z id="t1677022247" t="nigel And, I just figured out what I needed: (sql/format {:select [:some##field :another-field]} {:dialect :sqlserver}) ;; =&gt; [&quot;SELECT [some##field], [another-field]&quot;] ;; (sql/format {:select [:some##field :another-field]} {:dialect :sqlserver :quoted nil}) ;; =&gt; [&quot;SELECT [some##field], another_field&quot;]"><y>#</y><d>2023-02-21</d><h>23:30</h><r>nigel</r>And, I just figured out what I needed:
<pre>(sql/format {:select [:some##field :another-field]} {:dialect :sqlserver})
;; =&gt; [&quot;SELECT [some##field], [another-field]&quot;]
;;
(sql/format {:select [:some##field :another-field]} {:dialect :sqlserver :quoted nil})
;; =&gt; [&quot;SELECT [some##field], another_field&quot;]</pre></z><z id="t1677022325" t="nigel :quoted nil restores the default quoting strategy (only quoting unusual entity names) Many thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}]"><y>#</y><d>2023-02-21</d><h>23:32</h><r>nigel</r><code>:quoted nil</code> restores the default quoting strategy (only quoting unusual entity names)

Many thanks <a>@U04V70XH6</a></z><z id="t1677022361" t="seancorfield You have multiple DB dialects in play? Else you could just set one as the global default: user=&gt; (require &apos;[honey.sql :as h]) nil user=&gt; (h/set-dialect! :sqlserver) nil user=&gt; (h/format {:select [:some##field :another-field]}) [&quot;SELECT [some##field], another_field&quot;] user=&gt;"><y>#</y><d>2023-02-21</d><h>23:32</h><r>seancorfield</r>You have multiple DB dialects in play? Else you could just set one as the global default:
<pre>user=&gt; (require &apos;[honey.sql :as h])
nil
user=&gt; (h/set-dialect! :sqlserver)
nil
user=&gt; (h/format {:select [:some##field :another-field]})
[&quot;SELECT [some##field], another_field&quot;]
user=&gt;</pre></z><z id="t1677022404" t="nigel We do, we&apos;re using honey.sql in a data warehouse coordinator system"><y>#</y><d>2023-02-21</d><h>23:33</h><r>nigel</r>We do, we&apos;re using honey.sql in a data warehouse coordinator system</z><z id="t1677022414" t="nigel ETL from a bunch of source DBs"><y>#</y><d>2023-02-21</d><h>23:33</h><r>nigel</r>ETL from a bunch of source DBs</z><z id="t1677022465" t="nigel Thanks again!"><y>#</y><d>2023-02-21</d><h>23:34</h><r>nigel</r>Thanks again!</z><z id="t1677022504" t="seancorfield I&apos;ll create an issue to review the docs around the :dialect option and make sure it&apos;s clear that you can explicitly use the &quot;default quoting&quot; via :quoted nil"><y>#</y><d>2023-02-21</d><h>23:35</h><r>seancorfield</r>I&apos;ll create an issue to review the docs around the <code>:dialect</code> option and make sure it&apos;s clear that you can explicitly use the &quot;default quoting&quot; via <code>:quoted nil</code></z><z id="t1677022521" t="nigel I&apos;m happy to work on that"><y>#</y><d>2023-02-21</d><h>23:35</h><r>nigel</r>I&apos;m happy to work on that</z><z id="t1677022629" t="seancorfield https://github.com/seancorfield/honeysql/issues/463"><y>#</y><d>2023-02-21</d><h>23:37</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/463" target="_blank">https://github.com/seancorfield/honeysql/issues/463</a></z><z id="t1677022659" t="seancorfield If you want to send a PR for it, that would be great since I may not get to it for a few weeks."><y>#</y><d>2023-02-21</d><h>23:37</h><r>seancorfield</r>If you want to send a PR for it, that would be great since I may not get to it for a few weeks.</z><z id="t1677022718" t="nigel Will be happy to."><y>#</y><d>2023-02-21</d><h>23:38</h><r>nigel</r>Will be happy to.</z><z id="t1677248020" t="p-himik Is there a better way to CAST(... AS INTEGER[]) than using [:raw &quot;integer[]&quot;] ? Tried [:array :integer] and got yelled at: Execution error (ExceptionInfo) at honey.sql/format-expr-list (sql.cljc:480). format-expr-list expects a sequence of expressions, found: class clojure.lang.Keyword"><y>#</y><d>2023-02-24</d><h>14:13</h><w>p-himik</w>Is there a better way to <code>CAST(... AS INTEGER[])</code> than using <code>[:raw &quot;integer[]&quot;]</code>?
Tried <code>[:array :integer]</code> and got yelled at:
<pre>Execution error (ExceptionInfo) at honey.sql/format-expr-list (sql.cljc:480).
format-expr-list expects a sequence of expressions, found: class clojure.lang.Keyword</pre></z><z id="t1677260248" t="seancorfield Probably not. Feel free to open an issue with a link to whatever DB docs describes that."><y>#</y><d>2023-02-24</d><h>17:37</h><r>seancorfield</r>Probably not. Feel free to open an issue with a link to whatever DB docs describes that.</z><z id="t1677273088" t="p-himik Done: https://github.com/seancorfield/honeysql/issues/464"><y>#</y><d>2023-02-24</d><h>21:11</h><r>p-himik</r>Done: <a href="https://github.com/seancorfield/honeysql/issues/464" target="_blank">https://github.com/seancorfield/honeysql/issues/464</a></z><z id="t1677248540" t="p-himik Another question - is there a way to generate ARRAY_AGG(x ORDER BY a ASC, b DESC) ?"><y>#</y><d>2023-02-24</d><h>14:22</h><w>p-himik</w>Another question - is there a way to generate <code>ARRAY_AGG(x ORDER BY a ASC, b DESC)</code>?</z><z id="t1677260327" t="seancorfield Hmm, pretty sure there isn&apos;t. Create an issue with a link to the DB docs that describe that syntax and I&apos;ll take a look. It probably needs special syntax added for that sort of thing."><y>#</y><d>2023-02-24</d><h>17:38</h><r>seancorfield</r>Hmm, pretty sure there isn&apos;t. Create an issue with a link to the DB docs that describe that syntax and I&apos;ll take a look. It probably needs special syntax added for that sort of thing.</z><z id="t1677273591" t="p-himik Done: https://github.com/seancorfield/honeysql/issues/465"><y>#</y><d>2023-02-24</d><h>21:19</h><r>p-himik</r>Done: <a href="https://github.com/seancorfield/honeysql/issues/465" target="_blank">https://github.com/seancorfield/honeysql/issues/465</a></z><z id="t1677362941" t="p-himik Lots of https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-SQL need to have things like a FROM b in their arguments, e.g. substring(scope FROM 5 FOR 7) . Do I understand it correctly that a proper way to do it is to register a custom function?"><y>#</y><d>2023-02-25</d><h>22:09</h><w>p-himik</w>Lots of <a href="https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-SQL" target="_blank">https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-SQL</a> need to have things like <code>a FROM b</code> in their arguments, e.g. <code>substring(scope FROM 5 FOR 7)</code>.

Do I understand it correctly that a proper way to do it is to register a custom function?</z><z id="t1677521330" t="seancorfield Yes, register-fn! will let you add special syntax. This sounds worth being added to core -- can you create an issue with a link to the relevant PG docs and I&apos;ll take a look?"><y>#</y><d>2023-02-27</d><h>18:08</h><r>seancorfield</r>Yes, <code>register-fn!</code> will let you add special syntax. This sounds worth being added to core -- can you create an issue with a link to the relevant PG docs and I&apos;ll take a look?</z><z id="t1677532493" t="p-himik Done: https://github.com/seancorfield/honeysql/issues/471"><y>#</y><d>2023-02-27</d><h>21:14</h><r>p-himik</r>Done: <a href="https://github.com/seancorfield/honeysql/issues/471" target="_blank">https://github.com/seancorfield/honeysql/issues/471</a></z><z id="t1677650125" t="seancorfield For anyone interested in trying out the potential solution to this, develop has been updated with :*foo style keywords in function arguments being treated as a interspersed SQL keywords -- see these tests for examples: https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132 -- the syntax is still open to debate but the machinery seems reasonable."><y>#</y><d>2023-03-01</d><h>05:55</h><r>seancorfield</r>For anyone interested in trying out the potential solution to this, develop has been updated with <code>:*foo</code> style keywords in function arguments being treated as a interspersed SQL keywords -- see these tests for examples: <a href="https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132</a> -- the syntax is still open to debate but the machinery seems reasonable.</z><z id="t1677521330" t="seancorfield Yes, register-fn! will let you add special syntax. This sounds worth being added to core -- can you create an issue with a link to the relevant PG docs and I&apos;ll take a look?"><y>#</y><d>2023-02-27</d><h>18:08</h><w>seancorfield</w>Yes, <code>register-fn!</code> will let you add special syntax. This sounds worth being added to core -- can you create an issue with a link to the relevant PG docs and I&apos;ll take a look?</z><z id="t1677650125" t="seancorfield For anyone interested in trying out the potential solution to this, develop has been updated with :*foo style keywords in function arguments being treated as a interspersed SQL keywords -- see these tests for examples: https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132 -- the syntax is still open to debate but the machinery seems reasonable."><y>#</y><d>2023-03-01</d><h>05:55</h><w>seancorfield</w>For anyone interested in trying out the potential solution to this, develop has been updated with <code>:*foo</code> style keywords in function arguments being treated as a interspersed SQL keywords -- see these tests for examples: <a href="https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/test/honey/sql_test.cljc#L1112-L1132</a> -- the syntax is still open to debate but the machinery seems reasonable.</z><z id="t1677416808" t="Daniel Shriki hi y’all 🙂 I want to use jdbc/execute-batch! for updating several records with batch. how can I use it with honeysql? honey.sql/format function is working only for 1 record and not batch. tnx!"><y>#</y><d>2023-02-26</d><h>13:06</h><w>Daniel Shriki</w>hi y’all <b>🙂</b> I want to use jdbc/execute-batch! for updating several records with batch. how can I use it with honeysql? <code>honey.sql/format</code> function is working only for 1 record and not batch. tnx!</z><z id="t1677417198" t="p-himik A somewhat similar previous discussion: https://clojurians.slack.com/archives/C66EM8D5H/p1625797454111000 That doesn&apos;t exactly answer your question, but if you need that to insert multiple items then there&apos;s insert-multi! ."><y>#</y><d>2023-02-26</d><h>13:13</h><r>p-himik</r>A somewhat similar previous discussion: <a href="https://clojurians.slack.com/archives/C66EM8D5H/p1625797454111000" target="_blank">https://clojurians.slack.com/archives/C66EM8D5H/p1625797454111000</a>

That doesn&apos;t exactly answer your question, but if you need that to insert multiple items then there&apos;s <code>insert-multi!</code>.</z><z id="t1677418522" t="Daniel Shriki Unfortunately it’s not the use-case…"><y>#</y><d>2023-02-26</d><h>13:35</h><r>Daniel Shriki</r>Unfortunately it’s not the use-case…</z><z id="t1677418563" t="Daniel Shriki I need to update values in batch, so I’m searching something with this template:"><y>#</y><d>2023-02-26</d><h>13:36</h><r>Daniel Shriki</r>I need to update values in batch, so I’m searching something with this template:</z><z id="t1677418702" t="Daniel Shriki (jdbc/execute-batch! ds &quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot; [[&quot;id1&quot; &quot;eid1&quot;] [&quot;id2&quot; &quot;eid2&quot;] [&quot;id3 &quot;eid3&quot;]]) Only that I want to use honey.sql to build the sql statement instead of writing the statement itself"><y>#</y><d>2023-02-26</d><h>13:38</h><r>Daniel Shriki</r><pre>(jdbc/execute-batch! ds
                        &quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot;
                     [[&quot;id1&quot; &quot;eid1&quot;] [&quot;id2&quot; &quot;eid2&quot;] [&quot;id3 &quot;eid3&quot;]])</pre>
Only that I want to use honey.sql to build the sql statement instead of writing the statement itself</z><z id="t1677418718" t="Daniel Shriki trying to figure out what will work on this case"><y>#</y><d>2023-02-26</d><h>13:38</h><r>Daniel Shriki</r>trying to figure out what will work on this case</z><z id="t1677420265" t="p-himik Not sure whether it&apos;s the best approach but you can create a regular sqlmap where all the positional parameters are represented by [:raw &quot;?&quot;] ."><y>#</y><d>2023-02-26</d><h>14:04</h><r>p-himik</r>Not sure whether it&apos;s the best approach but you can create a regular sqlmap where all the positional parameters are represented by <code>[:raw &quot;?&quot;]</code>.</z><z id="t1677420282" t="p-himik (honey.sql/format {:update :agent-event :set {:seen [:inline true]} :where [:and [:= :agent-id [:raw &quot;?&quot;]] [:in :event-id [[:raw &quot;?&quot;]]]]}) =&gt; [&quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot;]"><y>#</y><d>2023-02-26</d><h>14:04</h><r>p-himik</r><pre>(honey.sql/format {:update :agent-event
                   :set    {:seen [:inline true]}
                   :where  [:and
                            [:= :agent-id [:raw &quot;?&quot;]]
                            [:in :event-id [[:raw &quot;?&quot;]]]]})
=&gt; [&quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot;]</pre></z><z id="t1677422164" t="Daniel Shriki Thanks 🙏 I had [:raw &quot;?&quot;] missing 🙂"><y>#</y><d>2023-02-26</d><h>14:36</h><r>Daniel Shriki</r>Thanks <b>🙏</b>  I had <code>[:raw &quot;?&quot;]</code> missing <b>🙂</b></z><z id="t1677521543" t="seancorfield Perhaps slightly less ugly: user=&gt; (honey.sql/format {:update :agent-event #_=&gt; :set {:seen [:inline true]} #_=&gt; :where [:and #_=&gt; [:= :agent-id :&apos;?] #_=&gt; [:in :event-id [:nest :&apos;?]]]}) [&quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot;]"><y>#</y><d>2023-02-27</d><h>18:12</h><r>seancorfield</r>Perhaps slightly less ugly:
<pre>user=&gt; (honey.sql/format {:update :agent-event
  #_=&gt;                    :set    {:seen [:inline true]}
  #_=&gt;                    :where  [:and
  #_=&gt;                             [:= :agent-id :&apos;?]
  #_=&gt;                             [:in :event-id [:nest :&apos;?]]]})
[&quot;UPDATE agent_event SET seen = TRUE WHERE (agent_id = ?) AND (event_id IN (?))&quot;]</pre></z><z id="t1677521566" t="seancorfield :&apos; allows for &quot;literal&quot; symbols"><y>#</y><d>2023-02-27</d><h>18:12</h><r>seancorfield</r><code>:&apos;</code> allows for &quot;literal&quot; symbols</z><z id="t1677593645" t="stopa (println (hsql/format {:with [[:foo {:select :* :from :foo}] [:bar {:select :* :from :bar}]] :select :* :from :bar} {:pretty true})) ; (out) [ ; (out) WITH foo AS (SELECT * FROM foo), bar AS (SELECT * FROM bar) ; (out) SELECT * ; (out) FROM bar ; (out) ] Hey team! I noticed that newlines don&apos;t come in in the with part of the CTE. Is there a way I could see the string in a more pretty way?"><y>#</y><d>2023-02-28</d><h>14:14</h><w>stopa</w><pre>(println (hsql/format
          {:with [[:foo {:select :* :from :foo}]
                  [:bar {:select :* :from :bar}]]
           :select :* :from :bar}
          {:pretty true}))

; (out) [
; (out) WITH foo AS (SELECT * FROM foo), bar AS (SELECT * FROM bar)
; (out) SELECT *
; (out) FROM bar
; (out) ]</pre>
Hey team! I noticed that newlines don&apos;t come in in the <code>with</code> part of the CTE. Is there a way I could see the string in a more pretty way?</z><z id="t1677594709" t="markaddleman I recently discovered https://github.com/vertical-blank/sql-formatter . It does a decent job of formatting SQL"><y>#</y><d>2023-02-28</d><h>14:31</h><r>markaddleman</r>I recently discovered <a href="https://github.com/vertical-blank/sql-formatter" target="_blank">https://github.com/vertical-blank/sql-formatter</a> .  It does a decent job of formatting SQL</z><z id="t1677596757" t="stopa This works great! Thanks [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}]"><y>#</y><d>2023-02-28</d><h>15:05</h><r>stopa</r>This works great! Thanks <a>@U2845S9KL</a></z><z id="t1677594517" t="p-himik Would you say that format-entity is OK to use when I need to have a table name in plain string format but still want to use keywords in the code to facilitate searching? Like in: {:select :relispopulated :from :pg-class :where [:= :relname (sql/format-entity :my-table)]}"><y>#</y><d>2023-02-28</d><h>14:28</h><w>p-himik</w>Would you say that <code>format-entity</code> is OK to use when I need to have a table name in plain string format but still want to use keywords in the code to facilitate searching?
Like in:
<pre>{:select :relispopulated
 :from   :pg-class
 :where  [:= :relname (sql/format-entity :my-table)]}</pre></z><z id="t1677608145" t="seancorfield Yes, anything listed in the ns docstring should be considered fair game. Be aware that format binds a lot of dynamic Vars that affect formatting and you don&apos;t get those if you call something like format-entity outside of format ."><y>#</y><d>2023-02-28</d><h>18:15</h><r>seancorfield</r>Yes, anything listed in the <code>ns</code> docstring should be considered fair game. Be aware that <code>format</code> binds a lot of dynamic Vars that affect formatting and you don&apos;t get those if you call something like <code>format-entity</code> outside of <code>format</code>.</z><z id="t1677608225" t="seancorfield If you want full-featured, full control, I&apos;d use format instead, which understands expressions too: user=&gt; (honey.sql/format :my-table) [&quot;my_table&quot;] user=&gt; (honey.sql/format :my-table {:dialect :sqlserver}) [&quot;[my-table]&quot;] user=&gt;"><y>#</y><d>2023-02-28</d><h>18:17</h><r>seancorfield</r>If you want full-featured, full control, I&apos;d use <code>format</code> instead, which understands expressions too:
<pre>user=&gt; (honey.sql/format :my-table)
[&quot;my_table&quot;]
user=&gt; (honey.sql/format :my-table {:dialect :sqlserver})
[&quot;[my-table]&quot;]
user=&gt;</pre></z><z id="t1677608311" t="seancorfield (although in all these cases, you&apos;ll get a string back and if you have [:= :relname &quot;[my-table]&quot;] that will turn into relname = ? unless you flag it as an :inline expression)"><y>#</y><d>2023-02-28</d><h>18:18</h><r>seancorfield</r>(although in all these cases, you&apos;ll get a string back and if you have <code>[:= :relname &quot;[my-table]&quot;]</code> that will turn into <code>relname = ?</code> unless you flag it as an <code>:inline</code> expression)</z><z id="t1677608362" t="seancorfield i.e., user=&gt; (honey.sql/format {:select :relispopulated #_=&gt; :from :pg-class #_=&gt; :where [:= :relname (honey.sql/format-entity :my-table)]}) [&quot;SELECT relispopulated FROM pg_class WHERE relname = ?&quot; &quot;my_table&quot;] user=&gt;"><y>#</y><d>2023-02-28</d><h>18:19</h><r>seancorfield</r>i.e.,
<pre>user=&gt; (honey.sql/format {:select :relispopulated
  #_=&gt;  :from   :pg-class
  #_=&gt;  :where  [:= :relname (honey.sql/format-entity :my-table)]})
[&quot;SELECT relispopulated FROM pg_class WHERE relname = ?&quot; &quot;my_table&quot;]
user=&gt;</pre></z><z id="t1677608614" t="seancorfield [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] You would probably be better off using the :entity special syntax: user=&gt; (honey.sql/format {:select :relispopulated #_=&gt; :from :pg-class #_=&gt; :where [:= :relname [:entity :my-table]]}) [&quot;SELECT relispopulated FROM pg_class WHERE relname = my_table&quot;] user=&gt;"><y>#</y><d>2023-02-28</d><h>18:23</h><r>seancorfield</r><a>@U2FRKM4TW</a> You would probably be better off using the <code>:entity</code> special syntax:
<pre>user=&gt; (honey.sql/format {:select :relispopulated
  #_=&gt;  :from   :pg-class
  #_=&gt;  :where  [:= :relname [:entity :my-table]]})
[&quot;SELECT relispopulated FROM pg_class WHERE relname = my_table&quot;]
user=&gt;</pre></z><z id="t1677614348" t="p-himik Oh, didn&apos;t realize there&apos;s :entity , thanks!"><y>#</y><d>2023-02-28</d><h>19:59</h><r>p-himik</r>Oh, didn&apos;t realize there&apos;s <code>:entity</code>, thanks!</z><z id="t1677614382" t="p-himik Ah, wait - there should be quotes there, relname = &apos;my_table&apos; ."><y>#</y><d>2023-02-28</d><h>19:59</h><r>p-himik</r>Ah, wait - there should be quotes there, <code>relname = &apos;my_table&apos;</code>.</z><z id="t1677617373" t="seancorfield Oh... you wanted the table as a string?!? Then, yeah, format-entity is going to be your best path."><y>#</y><d>2023-02-28</d><h>20:49</h><r>seancorfield</r>Oh... you wanted the table as a string?!? Then, yeah, <code>format-entity</code> is going to be your best path.</z><z id="t1677617398" t="seancorfield (unless you need all the format bells and whistles, in which case (first (format :my-table)) 🙂"><y>#</y><d>2023-02-28</d><h>20:49</h><r>seancorfield</r>(unless you need all the <code>format</code> bells and whistles, in which case <code>(first (format :my-table))</code> <b>🙂</b></z><z id="t1677602748" t="Akiz Hi, I am trying to solve one problem. I am using HoneySQL and Next.jdbc. 1. Generally speaking - when you load JSON from DB, it is converted to hash-map…. 2. But when you have query like this [[:coalesce :column1 [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;] (j/write-value-as-string {:is-active true}) :else (j/write-value-as-string {:is-active false})]] &quot;new column&quot;] It will fail because ERROR: CASE types jsonb and text cannot be matched 3. If you update the first part of query to [:cast :column1 :text] 4. Then it won’t fail but you will receive string and not map anymore 5. I would like to get back hashmap as I do in this example: [[:coalesce :column1 [(j/write-value-as-string {:is-active false})]] &quot;new-column&quot;] 6. What am I missing? 🙂"><y>#</y><d>2023-02-28</d><h>16:45</h><w>Akiz</w>Hi, I am trying to solve one problem. I am using HoneySQL and Next.jdbc.
1. Generally speaking - when you load JSON from DB, it is converted to hash-map….
2. But when you have query like this 
<pre>[[:coalesce :column1
      [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;]
       (j/write-value-as-string {:is-active true})
       :else
       (j/write-value-as-string {:is-active false})]] &quot;new column&quot;]</pre>
It will fail because <code>ERROR: CASE types jsonb and text cannot be matched</code>
3. If you update the first part of query to
<pre>[:cast :column1 :text]</pre>
4. Then it won’t fail but you will receive string and not map anymore
5. I would like to get back hashmap as I do in this example: 
<pre>[[:coalesce :column1 [(j/write-value-as-string {:is-active false})]] &quot;new-column&quot;]</pre>
6. What am I missing? <b>🙂</b></z><z id="t1677608511" t="seancorfield Can you explain what SQL you are trying to generate? I suspect the problem is that you are generating a (JSON) string from the Clojure data structure -- so HoneySQL sees a string, not a (JSON) data structure."><y>#</y><d>2023-02-28</d><h>18:21</h><r>seancorfield</r>Can you explain what SQL you are trying to generate? I suspect the problem is that you are generating a (JSON) string from the Clojure data structure -- so HoneySQL sees a string, not a (JSON) data structure.</z><z id="t1677608787" t="seancorfield You&apos;ll need to wrap the data in :lift so it is not parsed as part of the DSL: user=&gt; (require &apos;honey.sql.pg-ops) nil user=&gt; (honey.sql/format {:select [[[:coalesce :column1 #_=&gt; [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;] #_=&gt; [:lift {:is-active true}] #_=&gt; :else #_=&gt; [:lift {:is-active false}]]] &quot;new column&quot;]]}) [&quot;SELECT COALESCE(column1, CASE WHEN (attributes -&gt;&gt; ?) = ? THEN ? ELSE ? END) AS \&quot;new column\&quot;&quot; &quot;is-required&quot; &quot;true&quot; {:is-active true} {:is-active false}] user=&gt; (I doubt that&apos;s what you&apos;re trying to generate but it should be closer) edited to require the "><y>#</y><d>2023-02-28</d><h>18:26</h><r>seancorfield</r>You&apos;ll need to wrap the data in <code>:lift</code> so it is not parsed as part of the DSL:
<pre>user=&gt; (require &apos;honey.sql.pg-ops)
nil
user=&gt; (honey.sql/format {:select [[[:coalesce :column1
  #_=&gt;       [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;]
  #_=&gt;        [:lift {:is-active true}]
  #_=&gt;        :else
  #_=&gt;        [:lift {:is-active false}]]] &quot;new column&quot;]]})
[&quot;SELECT COALESCE(column1, CASE WHEN (attributes -&gt;&gt; ?) = ? THEN ? ELSE ? END) AS \&quot;new column\&quot;&quot; &quot;is-required&quot; &quot;true&quot; {:is-active true} {:is-active false}]
user=&gt;</pre>
(I doubt that&apos;s what you&apos;re trying to generate but it should be closer)

edited to require the </z><z id="t1677609832" t="Akiz LIFT did not help me, it seems that the “problem” is on SQL level. I mean, this generated SQL (5th step) works: COALESCE(column1, &apos;{&quot;is-active&quot;: true}&apos;) but this SQL (that I am generating) does not: coalesce(column1, CASE WHEN (attributes -&gt;&gt; &apos;is-required&apos;) = &apos;true&apos; THEN &apos;{&quot;is-active&quot;: true}&apos; ELSE &apos;{&quot;is-active&quot;: false}&apos; END) • it works once i cast JSONs in THEN and ELSE to :: jsonb. • I do not understand why SQL interprets string in first example as a JSONB but it is a different story for the second example"><y>#</y><d>2023-02-28</d><h>18:43</h><r>Akiz</r>LIFT did not help me, it seems that the “problem” is on SQL level.
I mean, this generated SQL (5th step) works:
<pre>COALESCE(column1, &apos;{&quot;is-active&quot;: true}&apos;)</pre>
but this SQL (that I am generating) does not:
<pre>coalesce(column1,
CASE WHEN (attributes -&gt;&gt; &apos;is-required&apos;) = &apos;true&apos; 
THEN &apos;{&quot;is-active&quot;: true}&apos;
ELSE &apos;{&quot;is-active&quot;: false}&apos;
END)</pre>
• it works once i cast JSONs in THEN and ELSE to <b>::</b>jsonb. 
• I do not understand why SQL interprets string in first example as a JSONB but it is a different story for the second example</z><z id="t1677609911" t="Akiz So, this is the solution (if there is nothing better ;-)) So it is not related to the honeysql / next.jdbc in the end.. [[:coalesce :column1 [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;] [:cast (j/write-value-as-string {:is-active true}) :jsonb] :else [:cast (j/write-value-as-string {:is-active false}) :jsonb]]] &quot;new column&quot;]"><y>#</y><d>2023-02-28</d><h>18:45</h><r>Akiz</r>So, this is the solution (if there is nothing better ;-))
So it is not related to the honeysql / next.jdbc in the end..
<pre>[[:coalesce :column1
      [:case [:= [:-&gt;&gt; :attributes &quot;is-required&quot;] &quot;true&quot;]
       [:cast (j/write-value-as-string {:is-active true}) :jsonb]
       :else
       [:cast (j/write-value-as-string {:is-active false}) :jsonb]]] &quot;new column&quot;]</pre></z><z id="t1677610022" t="seancorfield You could wrap the CAST around the CASE so you only have one of them..."><y>#</y><d>2023-02-28</d><h>18:47</h><r>seancorfield</r>You could wrap the <code>CAST</code> around the <code>CASE</code> so you only have one of them...</z><z id="t1677610487" t="Akiz I asked ChatGPT about this one… 😅 &gt; In PostgreSQL, the simple coalescence operator COALESCE returns the first non-null value in a list of expressions. When you use a string literal as a JSON value in a COALESCE expression, PostgreSQL implicitly casts it to a JSON value and returns it. &gt; However, when you use the same string literal in a nested CASE expression, PostgreSQL may not be able to implicitly cast it to a JSON value. This is because the CASE expression has multiple possible return types, and PostgreSQL may not be able to determine which type to cast the string to."><y>#</y><d>2023-02-28</d><h>18:54</h><r>Akiz</r>I asked ChatGPT about this one… <b>😅</b>
&gt; In PostgreSQL, the simple coalescence operator <code>COALESCE</code> returns the first non-null value in a list of expressions. When you use a string literal as a JSON value in a COALESCE expression, PostgreSQL implicitly casts it to a JSON value and returns it.
&gt; However, when you use the same string literal in a nested CASE expression, PostgreSQL may not be able to implicitly cast it to a JSON value. This is because the CASE expression has multiple possible return types, and PostgreSQL may not be able to determine which type to cast the string to.</z><z id="t1677612296" t="seancorfield My experiences with ChatGPT have been less than stellar: it has very confidently told me stuff that is blatantly false and easily provable to be so. YMMV. I pretty much don&apos;t trust anything it generates."><y>#</y><d>2023-02-28</d><h>19:24</h><r>seancorfield</r>My experiences with ChatGPT have been less than stellar: it has very confidently told me stuff that is blatantly false and easily provable to be so. YMMV. I pretty much don&apos;t trust anything it generates.</z><z id="t1677620474" t="Akiz Yep, that answer is not quite right. I’ve had a moment to think about it. I believe it’s because COALESCE’s arguments must all be convertible to a common data type, so it’s easy to guess what the second string should be converted to if the first element is JSON. But in the case of CASE, it’s not so easy, so it makes sense to explicitly convert it."><y>#</y><d>2023-02-28</d><h>21:41</h><r>Akiz</r>Yep, that answer is not quite right. I’ve had a moment to think about it.
I believe it’s because COALESCE’s arguments must all be convertible to a common data type, so it’s easy to guess what the second string should be converted to if the first element is JSON.
But in the case of CASE, it’s not so easy, so it makes sense to explicitly convert it.</z><z id="t1677605358" t="Jakub Holý (HolyJak) Hello good people! I want to write SELECT &apos;{&quot;kids&quot;:[{&quot;name&quot;:&quot;Jo&quot;}]}&apos;::jsonb -&gt; &apos;kids&apos; using Honey. Is the following really the best I can do: (honey.sql/format {:select [[[honey.sql.pg-ops/-&gt; [[:raw &quot;&apos;{\&quot;kids\&quot;:[1,2]}&apos;::jsonb&quot;]] [:inline &quot;kids&quot;]]]]}) ? Mainly I guess there is no way to avoid the :inline so Honey with [:-&gt; :column [:inline &quot;x&quot;] [:inline &quot;y&quot;]] will always be more noisy than SQL’s column -&gt; &apos;x&apos; -&gt; &apos;y&apos; , right? 🙏 Also in SQL I can write ~ SELECT &lt;some jsonb&gt; -&gt; &apos;kids&apos; -&gt; 0 -&gt;&gt; &apos;name&apos; which in Honey becomes {:select [[[:-&gt;&gt; [:-&gt; &lt;some jsonb&gt; [:inline &quot;kids&quot;] [:inline 0]] [:inline &quot;name&quot;]]]]} ."><y>#</y><d>2023-02-28</d><h>17:29</h><w>Jakub Holý (HolyJak)</w>Hello good people! I want to write
<pre>SELECT &apos;{&quot;kids&quot;:[{&quot;name&quot;:&quot;Jo&quot;}]}&apos;::jsonb -&gt; &apos;kids&apos;</pre>
using Honey. Is the following really the best I can do:
<pre>(honey.sql/format {:select [[[honey.sql.pg-ops/-&gt; [[:raw &quot;&apos;{\&quot;kids\&quot;:[1,2]}&apos;::jsonb&quot;]] [:inline &quot;kids&quot;]]]]})</pre>
? Mainly I guess there is no way to avoid the <code>:inline</code> so Honey with <code>[:-&gt; :column [:inline &quot;x&quot;]  [:inline &quot;y&quot;]]</code> will always be more noisy than SQL’s <code>column -&gt; &apos;x&apos; -&gt; &apos;y&apos;</code> , right? <b>🙏</b>

Also in SQL I can write ~ <code>SELECT &lt;some jsonb&gt; -&gt; &apos;kids&apos; -&gt; 0 -&gt;&gt; &apos;name&apos;</code> which in Honey becomes  <code>{:select [[[:-&gt;&gt; [:-&gt; &lt;some jsonb&gt; [:inline &quot;kids&quot;] [:inline 0]] [:inline &quot;name&quot;]]]]}</code> .</z><z id="t1677608620" t="Akiz You can not use anonymous sql params as? (honey.sql/format {:select [[[honey.sql.pg-ops/-&gt; [[:raw &quot;&apos;{\&quot;kids\&quot;:[1,2]}&apos;::jsonb&quot;]] &quot;kids&quot;]]]})"><y>#</y><d>2023-02-28</d><h>18:23</h><r>Akiz</r>You can not use anonymous sql params as?
<code>(honey.sql/format {:select [[[honey.sql.pg-ops/-&gt; [[:raw &quot;&apos;{\&quot;kids\&quot;:[1,2]}&apos;::jsonb&quot;]] &quot;kids&quot;]]]})</code></z><z id="t1677609055" t="seancorfield [:attrs {:href &quot;/_/_/users/U0522TWDA&quot;}] Either of these close to what you need? user=&gt; (require &apos;honey.sql.pg-ops) nil user=&gt; (honey.sql/format {:select [[[:-&gt; [:cast [:lift {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]}] :jsonb] &quot;kids&quot;]]]}) [&quot;SELECT CAST(? AS JSONB) -&gt; ?&quot; {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]} &quot;kids&quot;] user=&gt; (honey.sql/format {:select [[[:-&gt; [:cast [:lift {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]}] :jsonb] &quot;kids&quot;]]]} {:inline true}) [&quot;SELECT CAST({\&quot;kids\&quot; [{\&quot;name\&quot; \&quot;Jo\&quot;}]} AS JSONB) -&gt; &apos;kids&apos;&quot;] user=&gt;"><y>#</y><d>2023-02-28</d><h>18:30</h><r>seancorfield</r><a>@U0522TWDA</a> Either of these close to what you need?
<pre>user=&gt; (require &apos;honey.sql.pg-ops)
nil
user=&gt; (honey.sql/format {:select [[[:-&gt; [:cast [:lift {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]}] :jsonb] &quot;kids&quot;]]]})
[&quot;SELECT CAST(? AS JSONB) -&gt; ?&quot; {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]} &quot;kids&quot;]
user=&gt; (honey.sql/format {:select [[[:-&gt; [:cast [:lift {&quot;kids&quot; [{&quot;name&quot; &quot;Jo&quot;}]}] :jsonb] &quot;kids&quot;]]]} {:inline true})
[&quot;SELECT CAST({\&quot;kids\&quot; [{\&quot;name\&quot; \&quot;Jo\&quot;}]} AS JSONB) -&gt; &apos;kids&apos;&quot;]
user=&gt;</pre></z><z id="t1677609119" t="seancorfield (I suspect you don&apos;t need the cast if you pass a data structure here rather than a string?)"><y>#</y><d>2023-02-28</d><h>18:31</h><r>seancorfield</r>(I suspect you don&apos;t need the cast if you pass a data structure here rather than a string?)</z><z id="t1677611039" t="Jakub Holý (HolyJak) Sorry for being unclear, I do not care here about the jsonb input, that is just for demo, in practice it would be a :some-column. What bothers me is that I must :inline the arguments to :-&gt;, which IMO doesn&apos;t make sense (I don&apos;t believe Pg supports params at those positions)."><y>#</y><d>2023-02-28</d><h>19:03</h><r>Jakub Holý (HolyJak)</r>Sorry for being unclear, I do not care here about the jsonb input, that is just for demo, in practice it would be a :some-column. What bothers me is that I must :inline the arguments to :-&gt;, which IMO doesn&apos;t make sense (I don&apos;t believe Pg supports params at those positions).</z><z id="t1677611104" t="Jakub Holý (HolyJak) [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] when I don&apos;t wrap kids with :inline then I end up with ? in the sql"><y>#</y><d>2023-02-28</d><h>19:05</h><r>Jakub Holý (HolyJak)</r><a>@UBRV1HXPD</a> when I don&apos;t wrap kids with :inline then I end up with ? in the sql</z><z id="t1677612201" t="seancorfield [:attrs {:href &quot;/_/_/users/U0522TWDA&quot;}] OK, that makes (more) sense to me now. The -&gt; , -&gt;&gt; etc operators are all generic at the moment, so they have the exact same semantics in the DSL as anything else. I could force them to inline their second/subsequent arguments if that is the case that no dialect of SQL uses them in a way that doesn&apos;t require literal SQL strings for arguments. Feel free to create an issue on GH. [:-&gt; :col &quot;a&quot; &quot;b&quot; &quot;c&quot;] would then become col -&gt; &apos;a&apos; -&gt; &apos;b&apos; -&gt; &apos;c&apos;"><y>#</y><d>2023-02-28</d><h>19:23</h><r>seancorfield</r><a>@U0522TWDA</a> OK, that makes (more) sense to me now. The <code>-&gt;</code>, <code>-&gt;&gt;</code> etc operators are all generic at the moment, so they have the exact same semantics in the DSL as anything else. I could force them to inline their second/subsequent arguments if that is the case that no dialect of SQL uses them in a way that doesn&apos;t require literal SQL strings for arguments. Feel free to create an issue on GH. <code>[:-&gt; :col &quot;a&quot; &quot;b&quot; &quot;c&quot;]</code> would then become <code>col -&gt; &apos;a&apos; -&gt; &apos;b&apos; -&gt; &apos;c&apos;</code></z><z id="t1677612254" t="Akiz [:attrs {:href &quot;/_/_/users/U0522TWDA&quot;}] Ah, if you don’t want input parameters, you can do (hsql/format query {:inline true})"><y>#</y><d>2023-02-28</d><h>19:24</h><r>Akiz</r><a>@U0522TWDA</a> Ah, if you don’t want input parameters, you can do <code>(hsql/format query {:inline true})</code></z><z id="t1677612333" t="seancorfield Right, but that inlines everything in the query which is not always safe."><y>#</y><d>2023-02-28</d><h>19:25</h><r>seancorfield</r>Right, but that inlines everything in the <code>query</code> which is not always safe.</z><z id="t1677612392" t="Akiz Yeah, but the params at those positions should be supported by pg, no?"><y>#</y><d>2023-02-28</d><h>19:26</h><r>Akiz</r>Yeah, but the params at those positions should be supported by pg, no?</z><z id="t1677612399" t="seancorfield (I was under the impression that PG actually understood JSON directly but when I read the docs it seems that it just treats certain strings as JSON instead which definitely makes using JSON with HoneySQL more painful!)"><y>#</y><d>2023-02-28</d><h>19:26</h><r>seancorfield</r>(I was under the impression that PG actually understood JSON directly but when I read the docs it seems that it just treats certain strings as JSON instead which definitely makes using JSON with HoneySQL more painful!)</z><z id="t1677612447" t="seancorfield [:attrs {:href &quot;/_/_/users/UBRV1HXPD&quot;}] You mean ? -&gt; ? should be legal in PG? I would have expected so as well but apparently not?"><y>#</y><d>2023-02-28</d><h>19:27</h><r>seancorfield</r><a>@UBRV1HXPD</a> You mean <code>? -&gt; ?</code> should be legal in PG? I would have expected so as well but apparently not?</z><z id="t1677612834" t="Akiz Yeah, i have just tried this example, seems fine. https://www.loom.com/share/75e20bf54af343ce8e443d48e77336ab"><y>#</y><d>2023-02-28</d><h>19:33</h><r>Akiz</r>Yeah, i have just tried this example, seems fine.
<a href="https://www.loom.com/share/75e20bf54af343ce8e443d48e77336ab" target="_blank">https://www.loom.com/share/75e20bf54af343ce8e443d48e77336ab</a></z><z id="t1677616156" t="Jakub Holý (HolyJak) I am sorry, you are right. I have not expected Pg to be able to do that 😅 Thank you for your support!"><y>#</y><d>2023-02-28</d><h>20:29</h><r>Jakub Holý (HolyJak)</r>I am sorry, you are right. I have not expected Pg to be able to do that <b>😅</b>

Thank you for your support!</z><z id="t1677696370" t="p-himik Given :record , there&apos;s no way to write (&quot;record&quot;).* without using :raw , right?"><y>#</y><d>2023-03-01</d><h>18:46</h><w>p-himik</w>Given <code>:record</code>, there&apos;s no way to write <code>(&quot;record&quot;).*</code> without using <code>:raw</code>, right?</z><z id="t1677696620" t="seancorfield The literal SQL needs double-quotes in it?"><y>#</y><d>2023-03-01</d><h>18:50</h><r>seancorfield</r>The literal SQL needs double-quotes in it?</z><z id="t1677696825" t="seancorfield Can you link me to some sql/db docs that explain what that syntax means? I&apos;ve never seen anything like it..."><y>#</y><d>2023-03-01</d><h>18:53</h><r>seancorfield</r>Can you link me to some sql/db docs that explain what that syntax means? I&apos;ve never seen anything like it...</z><z id="t1677697375" t="p-himik Double quotes are just escaping of record . That syntax is record expansion in PostgreSQL. For example, you have to use it here to get a proper table instead of a column of records: SELECT (v).* FROM (SELECT v, row_number() OVER () rn FROM (VALUES (1, 2), (2, 3)) v(a, b)) v2 WHERE rn = 2;"><y>#</y><d>2023-03-01</d><h>19:02</h><r>p-himik</r>Double quotes are just escaping of <code>record</code>.
That syntax is record expansion in PostgreSQL.
For example, you have to use it here to get a proper table instead of a column of records:
<pre>SELECT (v).*
FROM (SELECT v, row_number() OVER () rn FROM (VALUES (1, 2), (2, 3)) v(a, b)) v2
WHERE rn = 2;</pre></z><z id="t1677697404" t="p-himik If you use just v , it&apos;ll return a column of records. If you use v.* , it&apos;ll complain with [42P01] ERROR: missing FROM-clause entry for table &quot;v&quot; ."><y>#</y><d>2023-03-01</d><h>19:03</h><r>p-himik</r>If you use just <code>v</code>, it&apos;ll return a column of records. If you use <code>v.*</code>, it&apos;ll complain with <code>[42P01] ERROR: missing FROM-clause entry for table &quot;v&quot;</code>.</z><z id="t1677697599" t="p-himik The docs mention it here: https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-USAGE &gt; PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown above, you need to write parentheses around the value that .* is applied to whenever it&apos;s not a simple table name."><y>#</y><d>2023-03-01</d><h>19:06</h><r>p-himik</r>The docs mention it here: <a href="https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-USAGE" target="_blank">https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-USAGE</a>
&gt; PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown above, you need to write parentheses around the value that <code>.*</code> is applied to whenever it&apos;s not a simple table name.</z><z id="t1677698826" t="seancorfield Gods, I hate PostgreSQL because of stuff like this 🙂"><y>#</y><d>2023-03-01</d><h>19:27</h><r>seancorfield</r>Gods, I hate PostgreSQL because of stuff like this <b>🙂</b></z><z id="t1677698882" t="seancorfield Can you create a GH issue and I&apos;ll give it some thought... if you have any suggestions for a suitable syntax, feel free to share..."><y>#</y><d>2023-03-01</d><h>19:28</h><r>seancorfield</r>Can you create a GH issue and I&apos;ll give it some thought... if you have any suggestions for a suitable syntax, feel free to share...</z><z id="t1677698942" t="seancorfield There&apos;s already :composite but it wouldn&apos;t support column selection of the result -- although maybe there&apos;s a way to expand that syntax?"><y>#</y><d>2023-03-01</d><h>19:29</h><r>seancorfield</r>There&apos;s already <code>:composite</code> but it wouldn&apos;t support column selection of the result -- although maybe there&apos;s a way to expand that syntax?</z><z id="t1677699055" t="seancorfield [:composite :record.*] perhaps? Not sure if that would break any existing code since [:composite :record.a :record.b] is valid today and means (record.a, record.b)"><y>#</y><d>2023-03-01</d><h>19:30</h><r>seancorfield</r><code>[:composite :record.*]</code> perhaps? Not sure if that would break any existing code since <code>[:composite :record.a :record.b]</code> is valid today and means <code>(record.a, record.b)</code></z><z id="t1677699114" t="seancorfield (and so it wouldn&apos;t help with (record).x would it...)"><y>#</y><d>2023-03-01</d><h>19:31</h><r>seancorfield</r>(and so it wouldn&apos;t help with <code>(record).x</code> would it...)</z><z id="t1677702417" t="p-himik &gt; I hate PostgreSQL because of stuff like this To the best of my knowledge, every DB has its own idiosyncrasies. :) Sometimes justified, sometimes not so much."><y>#</y><d>2023-03-01</d><h>20:26</h><r>p-himik</r>&gt; I hate PostgreSQL because of stuff like this
To the best of my knowledge, every DB has its own idiosyncrasies. :) Sometimes justified, sometimes not so much.</z><z id="t1677702645" t="p-himik Created: https://github.com/seancorfield/honeysql/issues/474 BTW, why does :raw require a vector? I see that it can be used with a single argument, as in [:raw &quot;value&quot;] but you can&apos;t use [:raw &quot;(&quot; &quot;stuff&quot; &quot;)&quot;] , you have to wrap all those in a vector. Otherwise, &quot;stuff&quot; and &quot;)&quot; will be silently ignored."><y>#</y><d>2023-03-01</d><h>20:30</h><r>p-himik</r>Created: <a href="https://github.com/seancorfield/honeysql/issues/474" target="_blank">https://github.com/seancorfield/honeysql/issues/474</a>

BTW, why does <code>:raw</code> require a vector? I see that it can be used with a single argument, as in <code>[:raw &quot;value&quot;]</code> but you can&apos;t use <code>[:raw &quot;(&quot; &quot;stuff&quot; &quot;)&quot;]</code>, you have to wrap all those in a vector. Otherwise, <code>&quot;stuff&quot;</code> and <code>&quot;)&quot;</code> will be silently ignored.</z><z id="t1677702883" t="seancorfield I don&apos;t know -- I&apos;d have to compare v1 and v2 to see why I chose to do it that way..."><y>#</y><d>2023-03-01</d><h>20:34</h><r>seancorfield</r>I don&apos;t know -- I&apos;d have to compare v1 and v2 to see why I chose to do it that way...</z><z id="t1677706019" t="seancorfield How would something like this be: user=&gt; (sql/register-fn! :project (fn [_ [expr col]] (let [[sql &amp; params] (sql/format-expr expr)] (into [(str &quot;(&quot; sql &quot;).&quot; (sql/format-entity col))] params)))) ... user=&gt; (sql/format {:select [[[:project :v :*]]]}) [&quot;SELECT (v).*&quot;] user=&gt; (sql/format {:select [[[:project :v :*]]]} {:quoted true}) [&quot;SELECT (\&quot;v\&quot;).*&quot;] user=&gt; (sql/format {:select [[[:project :v :a]]]} {:quoted true}) [&quot;SELECT (\&quot;v\&quot;).\&quot;a\&quot;&quot;] user=&gt;"><y>#</y><d>2023-03-01</d><h>21:26</h><r>seancorfield</r>How would something like this be:
<pre>user=&gt; (sql/register-fn! :project (fn [_ [expr col]] (let [[sql &amp; params] (sql/format-expr expr)] (into [(str &quot;(&quot; sql &quot;).&quot; (sql/format-entity col))] params))))
...
user=&gt; (sql/format {:select [[[:project :v :*]]]})
[&quot;SELECT (v).*&quot;]
user=&gt; (sql/format {:select [[[:project :v :*]]]} {:quoted true})
[&quot;SELECT (\&quot;v\&quot;).*&quot;]
user=&gt; (sql/format {:select [[[:project :v :a]]]} {:quoted true})
[&quot;SELECT (\&quot;v\&quot;).\&quot;a\&quot;&quot;]
user=&gt;</pre></z><z id="t1677706159" t="p-himik Seems alright!"><y>#</y><d>2023-03-01</d><h>21:29</h><r>p-himik</r>Seems alright!</z><z id="t1677706193" t="seancorfield user=&gt; (sql/format {:select [[[:project [:myfunc :b] :a]]]} {:quoted true}) [&quot;SELECT (MYFUNC(\&quot;b\&quot;)).\&quot;a\&quot;&quot;] Functions returning composites too."><y>#</y><d>2023-03-01</d><h>21:29</h><r>seancorfield</r><pre>user=&gt; (sql/format {:select [[[:project [:myfunc :b] :a]]]} {:quoted true})
[&quot;SELECT (MYFUNC(\&quot;b\&quot;)).\&quot;a\&quot;&quot;]</pre>
Functions returning composites too.</z><z id="t1677706234" t="seancorfield I&apos;m not in love with the name so suggestions welcome..."><y>#</y><d>2023-03-01</d><h>21:30</h><r>seancorfield</r>I&apos;m not in love with the name so suggestions welcome...</z><z id="t1677706315" t="seancorfield Maybe :field since it selects a field (or * ) from a composite?"><y>#</y><d>2023-03-01</d><h>21:31</h><r>seancorfield</r>Maybe <code>:field</code> since it selects a field (or <code>*</code>) from a composite?</z><z id="t1677706430" t="p-himik :field feels better. As an alternative, maybe it should be a combination of :nest and e.g. :dot . :dot is actually useful by itself to some extent, at least for me because I used to use qualify from v1 and now I have it in my own code (dynamic field names)."><y>#</y><d>2023-03-01</d><h>21:33</h><r>p-himik</r><code>:field</code> feels better.
As an alternative, maybe it should be a combination of <code>:nest</code> and e.g. <code>:dot</code>. <code>:dot</code> is actually useful by itself to some extent, at least for me because I used to use <code>qualify</code> from v1 and now I have it in my own code (dynamic field names).</z><z id="t1677706457" t="p-himik So [:dot [:nest [:myfunc :b]] :a] ."><y>#</y><d>2023-03-01</d><h>21:34</h><r>p-himik</r>So <code>[:dot [:nest [:myfunc :b]] :a]</code>.</z><z id="t1677706490" t="p-himik Oh, dots are actually &quot;legal but not documented&quot; characters in keywords, so maybe even :. . :D"><y>#</y><d>2023-03-01</d><h>21:34</h><r>p-himik</r>Oh, dots are actually &quot;legal but not documented&quot; characters in keywords, so maybe even <code>:.</code>. :D</z><z id="t1677706544" t="seancorfield Hmm... can you explain what your use of :dot would be (without :nest )?"><y>#</y><d>2023-03-01</d><h>21:35</h><r>seancorfield</r>Hmm... can you explain what your use of <code>:dot</code> would be (without <code>:nest</code>)?</z><z id="t1677706668" t="p-himik [:dot table-name :some-field] or [:dot :my-table some-field] . E.g. suppose a user orders a table in the UI. The column name is sent as is to the backend and then used with :dot to add it to :order-by . It&apos;s not always that you can use the column name as is because you can potentially have multiple tables used in the same query that have the same column."><y>#</y><d>2023-03-01</d><h>21:37</h><r>p-himik</r><code>[:dot table-name :some-field]</code> or <code>[:dot :my-table some-field]</code>.
E.g. suppose a user orders a table in the UI. The column name is sent as is to the backend and then used with <code>:dot</code> to add it to <code>:order-by</code>. It&apos;s not always that you can use the column name as is because you can potentially have multiple tables used in the same query that have the same column.</z><z id="t1677706691" t="p-himik (Needless to say, I was kinda surprised that qualify was removed in v2.)"><y>#</y><d>2023-03-01</d><h>21:38</h><r>p-himik</r>(Needless to say, I was kinda surprised that <code>qualify</code> was removed in v2.)</z><z id="t1677706716" t="seancorfield Ah, OK. That&apos;s reasonable."><y>#</y><d>2023-03-01</d><h>21:38</h><r>seancorfield</r>Ah, OK. That&apos;s reasonable.</z><z id="t1677706770" t="seancorfield So... :. or &apos;. seems like the obvious compact syntax -- datalog style &apos;{select (((. (nest (myfunc b)) a)))}"><y>#</y><d>2023-03-01</d><h>21:39</h><r>seancorfield</r>So... <code>:.</code> or <code>&apos;.</code> seems like the obvious compact syntax -- datalog style <code>&apos;{select (((. (nest (myfunc b)) a)))}</code></z><z id="t1677706810" t="p-himik Yeah!"><y>#</y><d>2023-03-01</d><h>21:40</h><r>p-himik</r>Yeah!</z><z id="t1677706813" t="seancorfield I&apos;ll update the ticket..."><y>#</y><d>2023-03-01</d><h>21:40</h><r>seancorfield</r>I&apos;ll update the ticket...</z><z id="t1677747717" t="p-himik Is it a reasonable proposal to automatically inline everything that can&apos;t be used for injections? Like numbers or dates."><y>#</y><d>2023-03-02</d><h>09:01</h><w>p-himik</w>Is it a reasonable proposal to automatically inline everything that can&apos;t be used for injections? Like numbers or dates.</z><z id="t1677753932" t="kolstae This would potentially reduce the effect of statement-caching + increase the parsing overhead of your queries (server-side). But this might not be that important"><y>#</y><d>2023-03-02</d><h>10:45</h><r>kolstae</r>This would potentially reduce the effect of statement-caching + increase the parsing overhead of your queries (server-side). But this might not be that important</z><z id="t1677755220" t="p-himik I don&apos;t know where the overhead will come from given that there&apos;s plenty of instance? -like checks there already, but the point about caching is a good one, I haven&apos;t thought of it. Still yet to use caching in my projects."><y>#</y><d>2023-03-02</d><h>11:07</h><r>p-himik</r>I don&apos;t know where the overhead will come from given that there&apos;s plenty of <code>instance?</code>-like checks there already, but the point about caching is a good one, I haven&apos;t thought of it. Still yet to use caching in my projects.</z><z id="t1677755528" t="kolstae When using postgres, statement-caching is enabled by default. I found https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2 to be an excellent explanation"><y>#</y><d>2023-03-02</d><h>11:12</h><r>kolstae</r>When using postgres, statement-caching is enabled by default. I found <a href="https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2" target="_blank">https://dev.to/yugabyte/postgres-query-execution-jdbc-prepared-statements-51e2</a> to be an excellent explanation</z><z id="t1677755628" t="p-himik Ah, we&apos;re talking about different caches. That&apos;s good to know about JDBC. But HoneySQL itself has a cache: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/general-reference?q=cach#caching"><y>#</y><d>2023-03-02</d><h>11:13</h><r>p-himik</r>Ah, we&apos;re talking about different caches. That&apos;s good to know about JDBC. But HoneySQL itself has a cache: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/general-reference?q=cach#caching" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/general-reference?q=cach#caching</a></z><z id="t1677755718" t="kolstae Right - yeah I was not thinking about that 🙂"><y>#</y><d>2023-03-02</d><h>11:15</h><r>kolstae</r>Right - yeah I was not thinking about that <b>🙂</b></z><z id="t1677774708" t="slipset I believe tha eg Oracle keeps several caches around for performance. Eg a query needs to be planned. If you use prepared statements, (again, I believe) that each instance of the prepared statement gets the same plan, whereas if you inline the params, it’d need to create a plan for each instance. "><y>#</y><d>2023-03-02</d><h>16:31</h><r>slipset</r>I  believe tha eg Oracle keeps several caches around for performance. Eg a query needs to be planned. If you use prepared statements, (again, I believe) that each instance of the prepared statement gets the same plan, whereas if you inline the params, it’d need to create a plan for each instance. </z><z id="t1677776043" t="seancorfield Right now, HoneySQL doesn&apos;t know how to inline dates anyway so that would have to be fixed first... 😕"><y>#</y><d>2023-03-02</d><h>16:54</h><r>seancorfield</r>Right now, HoneySQL doesn&apos;t know how to inline dates anyway so that would have to be fixed first... <b>😕</b></z><z id="t1677777118" t="seancorfield (and its not clear what that would need to look like for ClojureScript)"><y>#</y><d>2023-03-02</d><h>17:11</h><r>seancorfield</r>(and its not clear what that would need to look like for ClojureScript)</z><z id="t1677802343" t="Tanner Emerson Hello, we are trying to migrate from honey 1.x to 2.x. We are currently hung up on one of our usages of do-update-set! from honeysql-postgres. Here is our working example. (honeysql.core/format (-&gt; (SQL/insert-into :foo-table) (SQL/values [{:id 1 :data 42}]) (PSQL/upsert (-&gt; (PSQL/on-conflict :id) (PSQL/do-update-set! [:state &quot;enabled&quot;] [:modified (HSQL/call :now)]) (SQL/where [:= :state &quot;disabled&quot;]))))) When we have a conflict, our goal is to update the state to enabled iff the current value of state is disabled . It seems like we are able to set the state when there isn’t a where clause in the upsert. Once we introduce the where, we get a ClassCastException. Is this a supported use case? I included our attempts at writing with honeysql 2.X. ;; GOAL (fails: setting values with a where clause) (honey.sql/format (-&gt; (sql/insert-into :foo-table) (sql/values [{:id 1 :data 42}]) (sql/upsert (-&gt; (sql/on-conflict :id) (sql/do-update-set {:state &quot;enabled&quot; :modified [:now]}) (sql/where [:= :state &quot;disabled&quot;]))))) ;; WORKS (where but uses excluded values) (honey.sql/format (-&gt; (sql/insert-into :foo-table) (sql/values [{:id 1 :data 42 :state &quot;foo&quot; :modified [:now]}]) (sql/upsert (-&gt; (sql/on-conflict :id) (sql/do-update-set :state :modified) (sql/where [:= :state &quot;disabled&quot;]))))) ;; WORKS (no where but we can set values) (honey.sql/format (-&gt; (sql/insert-into :foo-table) (sql/values [{:id 1 :data 42}]) (sql/upsert (-&gt; (sql/on-conflict :id) (sql/do-update-set {:state &quot;enabled&quot; :modified [:now]})))))"><y>#</y><d>2023-03-03</d><h>00:12</h><w>Tanner Emerson</w>Hello, we are trying to migrate from honey 1.x to 2.x. We are currently hung up on one of our usages of <code>do-update-set!</code> from honeysql-postgres. Here is our working example.

<pre>(honeysql.core/format (-&gt; (SQL/insert-into :foo-table)
                          (SQL/values [{:id 1 :data 42}])
                          (PSQL/upsert (-&gt; (PSQL/on-conflict :id)
                                           (PSQL/do-update-set! [:state &quot;enabled&quot;]
                                                                [:modified (HSQL/call :now)])
                                           (SQL/where [:= :state &quot;disabled&quot;])))))</pre>
When we have a conflict, our goal is to update the state to <code>enabled</code> iff the current value of state is <code>disabled</code>.

It seems like we are able to set the state when there isn’t a where clause in the upsert. Once we introduce the where, we get a ClassCastException. Is this a supported use case? I included our attempts at writing with honeysql 2.X.

<pre>;; GOAL (fails: setting values with a where clause)
(honey.sql/format (-&gt; (sql/insert-into :foo-table)
                      (sql/values [{:id 1 :data 42}])
                      (sql/upsert (-&gt; (sql/on-conflict :id)
                                      (sql/do-update-set {:state &quot;enabled&quot;
                                                          :modified [:now]})
                                      (sql/where [:= :state &quot;disabled&quot;])))))

;; WORKS (where but uses excluded values)
(honey.sql/format (-&gt; (sql/insert-into :foo-table)
                      (sql/values [{:id 1 :data 42 :state &quot;foo&quot; :modified [:now]}])
                      (sql/upsert (-&gt; (sql/on-conflict :id)
                                      (sql/do-update-set :state :modified)
                                      (sql/where [:= :state &quot;disabled&quot;])))))

;; WORKS (no where but we can set values)
(honey.sql/format (-&gt; (sql/insert-into :foo-table)
                      (sql/values [{:id 1 :data 42}])
                      (sql/upsert (-&gt; (sql/on-conflict :id)
                                      (sql/do-update-set {:state &quot;enabled&quot;
                                                          :modified [:now]})))))</pre></z><z id="t1677814970" t="seancorfield That sounds like a bug. Can you create a GH issue with a small repro case so I can investigate [:attrs {:href &quot;/_/_/users/U04DSRYBQ3H&quot;}] ? Thanks."><y>#</y><d>2023-03-03</d><h>03:42</h><r>seancorfield</r>That sounds like a bug. Can you create a GH issue with a small repro case so I can investigate <a>@U04DSRYBQ3H</a>? Thanks.</z><z id="t1677887019" t="eccentric J Random idea: Has anyone created a spec that can validate common query types like selects, joins, create table, etc...? Or would it be a massive, sprawling undertaking?"><y>#</y><d>2023-03-03</d><h>23:43</h><w>eccentric J</w>Random idea: Has anyone created a spec that can validate common query types like selects, joins, create table, etc...? Or would it be a massive, sprawling undertaking?</z><z id="t1677889000" t="seancorfield It&apos;s been discussed from time to time. There was a GH issue created years ago to discuss it (but ultimately closed): https://github.com/seancorfield/honeysql/issues/146"><y>#</y><d>2023-03-04</d><h>00:16</h><r>seancorfield</r>It&apos;s been discussed from time to time. There was a GH issue created years ago to discuss it (but ultimately closed): <a href="https://github.com/seancorfield/honeysql/issues/146" target="_blank">https://github.com/seancorfield/honeysql/issues/146</a></z><z id="t1677889055" t="seancorfield I think &quot;massive&quot; and &quot;sprawling&quot; are apt words for this idea 🙂"><y>#</y><d>2023-03-04</d><h>00:17</h><r>seancorfield</r>I think &quot;massive&quot; and &quot;sprawling&quot; are apt words for this idea <b>🙂</b></z><z id="t1677889786" t="eccentric J I see. One thought came to mind, is this a reasonable approximation\starting place?"><y>#</y><d>2023-03-04</d><h>00:29</h><r>eccentric J</r>I see. One thought came to mind, is this a reasonable approximation\starting place?</z><z id="t1677889818" t="eccentric J Hmm that looks off"><y>#</y><d>2023-03-04</d><h>00:30</h><r>eccentric J</r>Hmm that looks off</z><z id="t1677889918" t="seancorfield Hahaha... I wouldn&apos;t trust ChatGPT any further than I could throw it... it very confidently produces incorrect code... sometimes it&apos;s obviously incorrect, sometimes it&apos;s just subtly incorrect."><y>#</y><d>2023-03-04</d><h>00:31</h><r>seancorfield</r>Hahaha... I wouldn&apos;t trust ChatGPT any further than I could throw it... it very confidently produces incorrect code... sometimes it&apos;s obviously incorrect, sometimes it&apos;s just subtly incorrect.</z><z id="t1677889999" t="eccentric J Not unreasonable, but it was worth a shot as a starting place. If I were to begin such a project I&apos;d probably start very small with a separate library and get at least one type of query covered to publish and see community interest\attract collaborators."><y>#</y><d>2023-03-04</d><h>00:33</h><r>eccentric J</r>Not unreasonable, but it was worth a shot as a starting place. If I were to begin such a project I&apos;d probably start very small with a separate library and get at least one type of query covered to publish and see community interest\attract collaborators.</z><z id="t1677890009" t="seancorfield It&apos;s completely wrong about strings -- HoneySQL uses keywords or symbols. Strings are values that are generally lifted out as parameters."><y>#</y><d>2023-03-04</d><h>00:33</h><r>seancorfield</r>It&apos;s completely wrong about strings -- HoneySQL uses keywords or symbols. Strings are values that are generally lifted out as parameters.</z><z id="t1677890087" t="eccentric J On the other hand, it&apos;s not like the dbs it targets doesn&apos;t tell you exactly what&apos;s wrong with the resulting sql if it&apos;s invalid"><y>#</y><d>2023-03-04</d><h>00:34</h><r>eccentric J</r>On the other hand, it&apos;s not like the dbs it targets doesn&apos;t tell you exactly what&apos;s wrong with the resulting sql if it&apos;s invalid</z><z id="t1677890103" t="seancorfield DDL syntax is horrifically variable across databases and HoneySQL supports a lot of it by basically assuming &quot;you know what you&apos;re doing&quot; and accepting fairly arbitrary sequences of keywords and (sub-)sequences of stuff."><y>#</y><d>2023-03-04</d><h>00:35</h><r>seancorfield</r>DDL syntax is horrifically variable across databases and HoneySQL supports a lot of it by basically assuming &quot;you know what you&apos;re doing&quot; and accepting fairly arbitrary sequences of keywords and (sub-)sequences of stuff.</z><z id="t1677890136" t="eccentric J I see. Probably not worth the trouble"><y>#</y><d>2023-03-04</d><h>00:35</h><r>eccentric J</r>I see. Probably not worth the trouble</z><z id="t1677890205" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-clause-reference#create-table-with-columns and https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-special-syntax-#column-descriptors should give you an idea of how... flexible... create table syntax can be 🙂"><y>#</y><d>2023-03-04</d><h>00:36</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-clause-reference#create-table-with-columns" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-clause-reference#create-table-with-columns</a> and <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-special-syntax-#column-descriptors" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1002/doc/getting-started/sql-special-syntax-#column-descriptors</a> should give you an idea of how... flexible... create table syntax can be <b>🙂</b></z><z id="t1677890307" t="seancorfield There&apos;s also the interesting issue that there are plenty of valid-to-HoneySQL data structures that produce absolute garbage SQL -- and what&apos;s valid SQL for one DB might be invalid for another DB, just to add to the fun."><y>#</y><d>2023-03-04</d><h>00:38</h><r>seancorfield</r>There&apos;s also the interesting issue that there are plenty of valid-to-HoneySQL data structures that produce absolute garbage SQL -- and what&apos;s valid SQL for one DB might be invalid for another DB, just to add to the fun.</z><z id="t1677890630" t="eccentric J Yeesh yeah I&apos;m tapping out. Thanks for humoring me 😛"><y>#</y><d>2023-03-04</d><h>00:43</h><r>eccentric J</r>Yeesh yeah I&apos;m tapping out. Thanks for humoring me <b>😛</b></z><z id="t1677923290" t="p-himik A spec could be useful for invalid-to-HoneySQL data structures. Consider a few examples: =&gt; (honey.sql/format {:select [[[:array #{}]]]}) Execution error (ExceptionInfo) at honey.sql/format-expr-list (sql.cljc:483). format-expr-list expects a sequence of expressions, found: class clojure.lang.PersistentHashSet ;; ^ Doesn&apos;t let you know the context where the set was found, could problematic to quickly find when you have a lot of dynamic parameters. =&gt; (honey.sql/format {:where nil}) Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:1258). These SQL clauses are unknown or have nil values: :where ;; ^ Obvious with this simple query but hard to find with deeply nested SQL with a lot of dynamic `:where` =&gt; (honey.sql/format {:select [[[:raw &quot;(&quot; 1 &quot;)&quot;]]]}) [&quot;SELECT (&quot;] ;; ^ No error but still incorrect usage of `:raw` which might potentially even produce syntactically correct SQL, making it hard to debug. But it&apos;s actually hard to come up with the examples. Before the fresh release, it was possible to create errors like Unable to convert: class clojure.lang.Keyword to Object[] but not sure how to produce those ones now. And even without a spec, potentially HoneySQL could report most of the errors itself along with the context. E.g. instead of that :where error there would something like (for a more nested query) These SQL clauses have nil values: :where (at [:from 0 0 :where]) . But hard to say how useful that would be and how hard it is to implement it."><y>#</y><d>2023-03-04</d><h>09:48</h><r>p-himik</r>A spec could be useful for invalid-to-HoneySQL data structures.
Consider a few examples:
<pre>=&gt; (honey.sql/format {:select [[[:array #{}]]]})
Execution error (ExceptionInfo) at honey.sql/format-expr-list (sql.cljc:483).
format-expr-list expects a sequence of expressions, found: class clojure.lang.PersistentHashSet
;; ^ Doesn&apos;t let you know the context where the set was found, could problematic to quickly find when you have a lot of dynamic parameters.

=&gt; (honey.sql/format {:where nil})
Execution error (ExceptionInfo) at honey.sql/format-dsl (sql.cljc:1258).
These SQL clauses are unknown or have nil values: :where
;; ^ Obvious with this simple query but hard to find with deeply nested SQL with a lot of dynamic `:where`

=&gt; (honey.sql/format {:select [[[:raw &quot;(&quot; 1 &quot;)&quot;]]]})
[&quot;SELECT (&quot;]
;; ^ No error but still incorrect usage of `:raw` which might potentially even produce syntactically correct SQL, making it hard to debug.</pre>
But it&apos;s actually hard to come up with the examples. Before the fresh release, it was possible to create errors like <code>Unable to convert: class clojure.lang.Keyword to Object[]</code> but not sure how to produce those ones now.
And even without a spec, potentially HoneySQL could report most of the errors itself along with the context. E.g. instead of that <code>:where</code> error there would something like (for a more nested query) <code>These SQL clauses have nil values: :where (at [:from 0 0 :where])</code>. But hard to say how useful that would be and how hard it is to implement it.</z><z id="t1677958156" t="seancorfield To be fair with those first two, ex-data helps here (I should mention that in the docs): user=&gt; (honey.sql/format {:select [[[:array #{}]]]}) ExceptionInfo format-expr-list expects a sequence of expressions, found: class clojure.lang.PersistentHashSet clojure.core/ex-info (core.clj:4739) user=&gt; (ex-data *e) {:exprs #{}} user=&gt; (honey.sql/format {:where nil}) ExceptionInfo These SQL clauses are unknown or have nil values: :where clojure.core/ex-info (core.clj:4739) user=&gt; (ex-data *e) {:where nil}"><y>#</y><d>2023-03-04</d><h>19:29</h><r>seancorfield</r>To be fair with those first two, <code>ex-data</code> helps here (I should mention that in the docs):
<pre>user=&gt; (honey.sql/format {:select [[[:array #{}]]]})
ExceptionInfo format-expr-list expects a sequence of expressions, found: class clojure.lang.PersistentHashSet  clojure.core/ex-info (core.clj:4739)
user=&gt; (ex-data *e)
{:exprs #{}}
user=&gt; (honey.sql/format {:where nil})
ExceptionInfo These SQL clauses are unknown or have nil values: :where  clojure.core/ex-info (core.clj:4739)
user=&gt; (ex-data *e)
{:where nil}</pre></z><z id="t1677958227" t="seancorfield I need to think about :raw -- I suspect that was an unintended (or poorly thought out) change from 1.x 😕"><y>#</y><d>2023-03-04</d><h>19:30</h><r>seancorfield</r>I need to think about <code>:raw</code> -- I suspect that was an unintended (or poorly thought out) change from 1.x <b>😕</b></z><z id="t1677958257" t="p-himik Ah, right. But still - it shows just the value, not where it is. It&apos;s already helpful but having a &quot;data stack trace&quot; (i.e. a get-in -like path) would be even more helpful."><y>#</y><d>2023-03-04</d><h>19:30</h><r>p-himik</r>Ah, right. But still - it shows just the value, not where it is. It&apos;s already helpful but having a &quot;data stack trace&quot; (i.e. a <code>get-in</code>-like path) would be even more helpful.</z><z id="t1677958401" t="seancorfield I could probably create something from the stacktrace, walking back for honey.sql$format_ matches (on invokeStatic ) to report a better context there, since it is full-on recursive descent formatting. :thinking_face:"><y>#</y><d>2023-03-04</d><h>19:33</h><r>seancorfield</r>I could probably create something from the stacktrace, walking back for <code>honey.sql$format_</code> matches (on <code>invokeStatic</code>) to report a better context there, since it is full-on recursive descent formatting. <b>:thinking_face:</b></z><z id="t1677958733" t="seancorfield https://github.com/seancorfield/honeysql/issues/476 and https://github.com/seancorfield/honeysql/issues/477"><y>#</y><d>2023-03-04</d><h>19:38</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/476" target="_blank">https://github.com/seancorfield/honeysql/issues/476</a> and <a href="https://github.com/seancorfield/honeysql/issues/477" target="_blank">https://github.com/seancorfield/honeysql/issues/477</a></z><z id="t1677968979" t="seancorfield https://github.com/seancorfield/honeysql/issues/476 is fixed on develop -- that was an unintended change so 1.x compatibility should be better now."><y>#</y><d>2023-03-04</d><h>22:29</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/476" target="_blank">https://github.com/seancorfield/honeysql/issues/476</a> is fixed on develop -- that was an unintended change so 1.x compatibility should be better now.</z><z id="t1677968979" t="seancorfield https://github.com/seancorfield/honeysql/issues/476 is fixed on develop -- that was an unintended change so 1.x compatibility should be better now."><y>#</y><d>2023-03-04</d><h>22:29</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/476" target="_blank">https://github.com/seancorfield/honeysql/issues/476</a> is fixed on develop -- that was an unintended change so 1.x compatibility should be better now.</z><z id="t1677888854" t="seancorfield"><y>#</y><d>2023-03-04</d><h>00:14</h><w>seancorfield</w></z><z id="t1678705593" t="orestis I love how I can read the tests for all these PRs to see how would this affect me ❤️"><y>#</y><d>2023-03-13</d><h>11:06</h><r>orestis</r>I love how I can read the tests for all these PRs to see how would this affect me <b>❤️</b></z><z id="t1677969300" t="seancorfield ☝️ :skin-tone-2: What I had intended in 2.x was that :raw could take both literal SQL fragments and expressions, so that [:raw &quot;@foo := &quot; [:myfunc 42]] would work and produce [&quot;@foo := MYFUNC(?)&quot; 42] because that was pretty much impossible in 1.x -- but I accidentally made :raw unary in the process so you actually had to write [:raw [&quot;@foo := &quot; [:myfunc 42]]] instead. The &quot;current&quot; unary behavior is unchanged, but the variadic behavior of 1.x is restored, with the addition of making it possible to embed expressions as well -- so [:raw &quot;@foo := &quot; [:myfunc 42]] works now as well (it previously produced [&quot;@foo := &quot;] which was not what I intended!)."><y>#</y><d>2023-03-04</d><h>22:35</h><w>seancorfield</w><b>☝️</b><b>:skin-tone-2:</b> What I had intended in 2.x was that <code>:raw</code> could take both literal SQL fragments and expressions, so that <code>[:raw &quot;@foo := &quot; [:myfunc 42]]</code> would work and produce <code>[&quot;@foo := MYFUNC(?)&quot; 42]</code> because that was pretty much impossible in 1.x -- but I accidentally made <code>:raw</code> unary in the process so you actually had to write <code>[:raw [&quot;@foo := &quot; [:myfunc 42]]]</code> instead. The &quot;current&quot; unary behavior is unchanged, but the variadic behavior of 1.x is restored, with the addition of making it possible to embed expressions as well -- so <code>[:raw &quot;@foo := &quot; [:myfunc 42]]</code> works now as well (it previously produced <code>[&quot;@foo := &quot;]</code> which was not what I intended!).</z><z id="t1677969337" t="seancorfield Again, thanks [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] for uncovering my mistake!"><y>#</y><d>2023-03-04</d><h>22:35</h><w>seancorfield</w>Again, thanks <a>@p-himik</a> for uncovering my mistake!</z><z id="t1678086603" t="p-himik Would it make sense to add support for COLLATE to HoneySQL? So e.g. [:collate [:lower :name] :C] results in (LOWER(name)) COLLATE &quot;C&quot; . One immediate issue though is that, according to a quick test with SQL Fiddle, different DBs require different syntax: • PostgreSQL requires for the collation name to be quoted • MySQL doesn&apos;t care at all • MS SQL Server requires for it to be unquoted I&apos;m using PostgreSQL so currently I have this: (sql/register-fn! :collate (fn [f [thing collation]] (assert (keyword? collation)) (let [result (sql/format-expr thing)] (update result 0 (fn [sql] (str &quot;(&quot; sql &quot;) &quot; (sql/sql-kw f) &quot; \&quot;&quot; (name collation) &quot;\&quot;&quot;))))))"><y>#</y><d>2023-03-06</d><h>07:10</h><w>p-himik</w>Would it make sense to add support for <code>COLLATE</code> to HoneySQL? So e.g. <code>[:collate [:lower :name] :C]</code> results in <code>(LOWER(name)) COLLATE &quot;C&quot;</code>.
One immediate issue though is that, according to a quick test with SQL Fiddle, different DBs require different syntax:
• PostgreSQL requires for the collation name to be quoted
• MySQL doesn&apos;t care at all
• MS SQL Server requires for it to be unquoted
I&apos;m using PostgreSQL so currently I have this:
<pre>(sql/register-fn! :collate
                  (fn [f [thing collation]]
                    (assert (keyword? collation))
                    (let [result (sql/format-expr thing)]
                      (update result 0
                              (fn [sql]
                                (str &quot;(&quot; sql &quot;) &quot; (sql/sql-kw f) &quot; \&quot;&quot; (name collation) &quot;\&quot;&quot;))))))</pre></z><z id="t1678121292" t="seancorfield Feel free to create a GitHub issue with links to the various DB docs about it."><y>#</y><d>2023-03-06</d><h>16:48</h><r>seancorfield</r>Feel free to create a GitHub issue with links to the various DB docs about it.</z><z id="t1678824785" t="az Hi all. Wondering if there is a way to rename a column to a qualified keyword? How could I make something like the following work? (select [:id :product/id]) "><y>#</y><d>2023-03-14</d><h>20:13</h><w>az</w>Hi all. Wondering if there is a way to rename a column to a qualified keyword?

How could I make something like the following work?

<code>(select [:id :product/id])</code>

<pre></pre></z><z id="t1678825762" t="seancorfield clojure.set/rename-keys I think it&apos;s called?"><y>#</y><d>2023-03-14</d><h>20:29</h><r>seancorfield</r><code>clojure.set/rename-keys</code> I think it&apos;s called?</z><z id="t1678825782" t="seancorfield Yeah https://clojuredocs.org/clojure.set/rename-keys"><y>#</y><d>2023-03-14</d><h>20:29</h><r>seancorfield</r>Yeah <a href="https://clojuredocs.org/clojure.set/rename-keys" target="_blank">https://clojuredocs.org/clojure.set/rename-keys</a></z><z id="t1678825804" t="az I see, yes, just wondering if it was possible to do it right in the hh/select :as"><y>#</y><d>2023-03-14</d><h>20:30</h><r>az</r>I see, yes, just wondering if it was possible to do it right in the hh/select :as</z><z id="t1678825810" t="az Thank you"><y>#</y><d>2023-03-14</d><h>20:30</h><r>az</r>Thank you</z><z id="t1678825815" t="seancorfield But I guess I&apos;d take a step back and ask: what actual problem are you trying to solve?"><y>#</y><d>2023-03-14</d><h>20:30</h><r>seancorfield</r>But I guess I&apos;d take a step back and ask: what actual problem are you trying to solve?</z><z id="t1678825823" t="az It&apos;"><y>#</y><d>2023-03-14</d><h>20:30</h><r>az</r>It&apos;</z><z id="t1678825875" t="az It&apos;s mainly for pathom resolvers. Seems nice during destructuring to allow for values to carry more clarity of what they are"><y>#</y><d>2023-03-14</d><h>20:31</h><r>az</r>It&apos;s mainly for pathom resolvers. Seems nice during destructuring to allow for values to carry more clarity of what they are</z><z id="t1678825974" t="az It&apos;s really the first time I&apos;ve needed to rename keys like this. Basically doing this now (defn get-formatted-production-line-items [production-id] (let [raw (-&gt; (hh/select :*) (hh/from :production_line_items) (hh/where [:= :production_id production-id]) db/execute!)] (mapv (fn [p] (rename-keys p {:id :production-line-item/id :qty :production-line-item/qty :production_id :production-line-item/production :recipe_id :production-line-item/recipe :created_at :production-line-item/created-at :updated_at :production-line-item/updated-at})) raw)))"><y>#</y><d>2023-03-14</d><h>20:32</h><r>az</r>It&apos;s really the first time I&apos;ve needed to rename keys like this. Basically doing this now

<pre>(defn get-formatted-production-line-items
  [production-id]
  (let [raw (-&gt;
             (hh/select :*)
             (hh/from :production_line_items)
             (hh/where [:= :production_id production-id])
             db/execute!)]
    (mapv (fn [p] (rename-keys p {:id :production-line-item/id
                                  :qty :production-line-item/qty
                                  :production_id :production-line-item/production
                                  :recipe_id :production-line-item/recipe
                                  :created_at :production-line-item/created-at
                                  :updated_at :production-line-item/updated-at}))
          raw)))</pre></z><z id="t1678825985" t="seancorfield Why not use qualified keywords in the first place? HoneySQL is fine with those. Or is this about executing the SQL rather than building the SQL?"><y>#</y><d>2023-03-14</d><h>20:33</h><r>seancorfield</r>Why not use qualified keywords in the first place? HoneySQL is fine with those. Or is this about executing the SQL rather than building the SQL?</z><z id="t1678826017" t="seancorfield Oh... I see... you have poorly named DB tables and columns and you want better aliases in the SQL?"><y>#</y><d>2023-03-14</d><h>20:33</h><r>seancorfield</r>Oh... I see... you have poorly named DB tables and columns and you want better aliases in the SQL?</z><z id="t1678826029" t="az in the sql tables, everything is just :id, :name etc"><y>#</y><d>2023-03-14</d><h>20:33</h><r>az</r>in the sql tables, everything is just :id, :name etc</z><z id="t1678826043" t="az yeah, they are poorly named"><y>#</y><d>2023-03-14</d><h>20:34</h><r>az</r>yeah, they are poorly named</z><z id="t1678826051" t="az thank you yes, perfectly said"><y>#</y><d>2023-03-14</d><h>20:34</h><r>az</r>thank you yes, perfectly said</z><z id="t1678826053" t="seancorfield Right, but next.jdbc would give you :table_name/column_name by default."><y>#</y><d>2023-03-14</d><h>20:34</h><r>seancorfield</r>Right, but <code>next.jdbc</code> would give you <code>:table_name/column_name</code> by default.</z><z id="t1678826088" t="seancorfield (and with camel-snake-kebab you could get :table-name/column-name automatically -- although I have opinions about mixing your persistence model names and your data model names like that 🙂 )"><y>#</y><d>2023-03-14</d><h>20:34</h><r>seancorfield</r>(and with camel-snake-kebab you could get <code>:table-name/column-name</code> automatically -- although I have opinions about mixing your persistence model names and your data model names like that <b>🙂</b> )</z><z id="t1678826165" t="az I thnk I need to read the docs again, I must be missing something. This is what I get out with my setup: (-&gt; (hh/select :*) (hh/from :production_line_items) (hh/where [:= :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;]) db/execute!) ;; =&gt; [{:id &quot;5541fbac-fb5a-441b-8516-fdc936472c90&quot;, ;; :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;, ;; :recipe_id &quot;frenchlentilsalad&quot;, ;; :qty 0.0, ;; :created_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;, ;; :updated_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;} ;; {:id &quot;f457f847-6a44-4a1a-87df-8d2541e958bb&quot;, ;; :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;, ;; :recipe_id &quot;tacosalad&quot;, ;; :qty 0.0, ;; :created_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;, ;; :updated_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;}] "><y>#</y><d>2023-03-14</d><h>20:36</h><r>az</r>I thnk I need to read the docs again, I must be missing something. This is what I get out with my setup:

<pre>(-&gt;
 (hh/select :*)
 (hh/from :production_line_items)
 (hh/where [:= :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;])
 db/execute!)
;; =&gt; [{:id &quot;5541fbac-fb5a-441b-8516-fdc936472c90&quot;,
;;      :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;,
;;      :recipe_id &quot;frenchlentilsalad&quot;,
;;      :qty 0.0,
;;      :created_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;,
;;      :updated_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;}
;;     {:id &quot;f457f847-6a44-4a1a-87df-8d2541e958bb&quot;,
;;      :production_id &quot;b3677f96-a76c-4e05-a447-5f269cabea1f&quot;,
;;      :recipe_id &quot;tacosalad&quot;,
;;      :qty 0.0,
;;      :created_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;,
;;      :updated_at #inst &quot;2023-03-13T05:16:32.415000000-00:00&quot;}]</pre>
</z><z id="t1678826179" t="seancorfield What is db ?"><y>#</y><d>2023-03-14</d><h>20:36</h><r>seancorfield</r>What is <code>db</code>?</z><z id="t1678826200" t="az !!!"><y>#</y><d>2023-03-14</d><h>20:36</h><r>az</r>!!!</z><z id="t1678826212" t="az (defn execute! [q &amp; {:keys [connection opts] :or {connection conn opts {}}}] (jdbc/execute! connection (format-sql q) (merge {:return-keys true :builder-fn rs/as-unqualified-lower-maps :pretty true} opts))) "><y>#</y><d>2023-03-14</d><h>20:36</h><r>az</r><pre>(defn execute!
  [q &amp; {:keys [connection opts]
        :or {connection conn
             opts {}}}]
  (jdbc/execute! connection (format-sql q)
                 (merge {:return-keys true
                         :builder-fn rs/as-unqualified-lower-maps
                         :pretty true} opts)))</pre>
</z><z id="t1678826222" t="seancorfield Well, there&apos;s your problem!"><y>#</y><d>2023-03-14</d><h>20:37</h><r>seancorfield</r>Well, there&apos;s your problem!</z><z id="t1678826237" t="az thank you again, lots of lessons here"><y>#</y><d>2023-03-14</d><h>20:37</h><r>az</r>thank you again, lots of lessons here</z><z id="t1678826276" t="seancorfield Not sure what :pretty true is supposed to be doing in a next.jdbc/execute! call...?"><y>#</y><d>2023-03-14</d><h>20:37</h><r>seancorfield</r>Not sure what <code>:pretty true</code> is supposed to be doing in a <code>next.jdbc/execute!</code> call...?</z><z id="t1678826301" t="seancorfield (it&apos;s a HoneySQL option)"><y>#</y><d>2023-03-14</d><h>20:38</h><r>seancorfield</r>(it&apos;s a HoneySQL option)</z><z id="t1678826336" t="az this is great. I&apos;m going to get this updated, and no need for all the remapping."><y>#</y><d>2023-03-14</d><h>20:38</h><r>az</r>this is great. I&apos;m going to get this updated, and no need for all the remapping.</z><z id="t1678826401" t="seancorfield Look at https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.3.862/api/next.jdbc#snake-kebab-opts if you want :table-name/column-name (with my caveat above about mixing layers of abstraction and naming)."><y>#</y><d>2023-03-14</d><h>20:40</h><r>seancorfield</r>Look at <a href="https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.3.862/api/next.jdbc#snake-kebab-opts" target="_blank">https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.3.862/api/next.jdbc#snake-kebab-opts</a> if you want <code>:table-name/column-name</code> (with my caveat above about mixing layers of abstraction and naming).</z><z id="t1678826556" t="az Thank you so much, this is perfect, I just love the work you&apos;ve done"><y>#</y><d>2023-03-14</d><h>20:42</h><r>az</r>Thank you so much, this is perfect, I just love the work you&apos;ve done</z><z id="t1679093825" t="seancorfield"><y>#</y><d>2023-03-17</d><h>22:57</h><w>seancorfield</w></z><z id="t1679401629" t="slipset So at work, we do quite a bit of logging, and in that logging we add a trace-id so we can correlate log messages to the same request. This is not rocket science. It turns out however, that if we do =&gt; /* trace-id: 123456789 */ select * from foo; from the psql console, that comment gets propagated to the logs as: 2023-03-21 11:47:23.146 UTC [29737] LOG: duration: 36.834 ms statement: /* trace-id: 123456789 */ select * from foo; Which would then let us correlate (slow) queries to specific requests, which would again make it very much easier to debug performance problems. Because of how we’ve structured our code, this would be very easy to implement if honey-sql had a (hh/comment ) fn, so we could say something like: (-&gt;&gt; (hh/comment (str &quot;trace-id: &quot; id)) (hh/select ..)) which would render out a comment before the actual statement. Is this already possible (and if not, would it be possible to add)?"><y>#</y><d>2023-03-21</d><h>12:27</h><w>slipset</w>So at work, we do quite a bit of logging, and in that logging we add a <code>trace-id</code> so we can correlate log messages to the same request. This is not rocket science.
It turns out however, that if we do
<pre>=&gt; /* trace-id: 123456789 */ select * from foo;</pre>
from the psql console, that comment gets propagated to the logs as:
<pre>2023-03-21 11:47:23.146 UTC [29737] LOG:  duration: 36.834 ms  statement: /* trace-id: 123456789 */ select * from foo;</pre>
Which would then let us correlate (slow) queries to specific requests, which would again make it very much easier to debug performance problems.
Because of how we’ve structured our code, this would be very easy to implement if honey-sql had a <code>(hh/comment )</code> fn, so we could say something like:
<pre>(-&gt;&gt; (hh/comment (str &quot;trace-id: &quot; id))
     (hh/select ..))  </pre>
which would render out a comment before the actual statement.
Is this already possible (and if not, would it be possible to add)?</z><z id="t1679427546" t="seancorfield TBH, that sounds a bit more like something next.jdbc should be providing but it&apos;s an interesting question and certainly something that is easy to add to HoneySQL -- as you found with register-clause! 🙂 Is it (comments preceding SQL) an ANSI feature or something peculiar to PG?"><y>#</y><d>2023-03-21</d><h>19:39</h><r>seancorfield</r>TBH, that sounds a bit more like something <code>next.jdbc</code> should be providing but it&apos;s an interesting question and certainly something that is easy to add to HoneySQL -- as you found with <code>register-clause!</code> <b>🙂</b> Is it (comments preceding SQL) an ANSI feature or something peculiar to PG?</z><z id="t1679427650" t="slipset I don’t know if it’s ANSI or not."><y>#</y><d>2023-03-21</d><h>19:40</h><r>slipset</r>I don’t know if it’s ANSI or not.</z><z id="t1679427727" t="slipset But, say I wanted to register :comments so that it is added before :insert , :update , :delete :with as well? do I just supply all those keywords as last args?"><y>#</y><d>2023-03-21</d><h>19:42</h><r>slipset</r>But, say I wanted to register <code>:comments</code> so that it is added before <code>:insert</code> , <code>:update</code>, <code>:delete</code> <code>:with</code> as well? do I just supply all those keywords as last args?</z><z id="t1679427882" t="seancorfield Just pick the earliest one you need it to be before..."><y>#</y><d>2023-03-21</d><h>19:44</h><r>seancorfield</r>Just pick the earliest one you need it to be before...</z><z id="t1679427957" t="slipset So basically :with (and then honey will figure out that if :with is not present, it will go before whatever comes after :with )?"><y>#</y><d>2023-03-21</d><h>19:45</h><r>slipset</r>So basically <code>:with</code> (and then honey will figure out that if <code>:with</code> is not present, it will go before whatever comes after <code>:with</code>)?</z><z id="t1679427962" t="seancorfield (def ^:private default-clause-order &quot;The (default) order for known clauses. Can have items added and removed.&quot; [;; DDL comes first (these don&apos;t really have a precedence): :alter-table :add-column :drop-column :alter-column :modify-column :rename-column :add-index :drop-index :rename-table :create-table :create-table-as :with-columns :create-view :create-materialized-view :create-extension :drop-table :drop-view :drop-materialized-view :drop-extension :refresh-materialized-view ;; then SQL clauses in priority order: :raw :nest :with :with-recursive :intersect :union :union-all :except :except-all :table :select :select-distinct :select-distinct-on :select-top :select-distinct-top ..."><y>#</y><d>2023-03-21</d><h>19:46</h><r>seancorfield</r><pre>(def ^:private default-clause-order
  &quot;The (default) order for known clauses. Can have items added and removed.&quot;
  [;; DDL comes first (these don&apos;t really have a precedence):
   :alter-table :add-column :drop-column
   :alter-column :modify-column :rename-column
   :add-index :drop-index :rename-table
   :create-table :create-table-as :with-columns
   :create-view :create-materialized-view :create-extension
   :drop-table :drop-view :drop-materialized-view :drop-extension
   :refresh-materialized-view
   ;; then SQL clauses in priority order:
   :raw :nest :with :with-recursive :intersect :union :union-all :except :except-all
   :table
   :select :select-distinct :select-distinct-on :select-top :select-distinct-top
...</pre></z><z id="t1679428021" t="seancorfield Not sure whether you&apos;d want this to be &quot;before&quot; raw/nest, but with sounds like a reasonable starting point?"><y>#</y><d>2023-03-21</d><h>19:47</h><r>seancorfield</r>Not sure whether you&apos;d want this to be &quot;before&quot; raw/nest, but with sounds like a reasonable starting point?</z><z id="t1679428099" t="slipset We’re not currently using :raw at top-level, and I don’t think we’re using :nest but we’re deffo using :with"><y>#</y><d>2023-03-21</d><h>19:48</h><r>slipset</r>We’re not currently using <code>:raw</code> at top-level, and I don’t think we’re using <code>:nest</code> but we’re deffo using <code>:with</code></z><z id="t1679405852" t="slipset I guess something along the lines of (honey.sql/register-clause! :comment (fn [clause x] [(str&quot;/* &quot; x &quot; */&quot;)]) :select)"><y>#</y><d>2023-03-21</d><h>13:37</h><w>slipset</w>I guess something along the lines of
<pre>(honey.sql/register-clause! :comment
                      (fn [clause x]
                        [(str&quot;/* &quot; x &quot; */&quot;)])
                      :select)</pre></z><z id="t1679415098" t="az Hi all. Wondering how I might achieve the following sql chunk: ARRAY_AGG(DISTINCT (i.name)) FILTER (WHERE i.name IS NOT NULL) I have this in honey, but can&apos;t figure out how to not use a aggregate function as explained in the docs [[:array_agg [:distinct :i.name] [:filter {:where [:not= nil :i.name]}]]] If I don&apos;t use something like :%count, the filter clause doesn&apos;t show up in the output. Any thoughts?"><y>#</y><d>2023-03-21</d><h>16:11</h><w>az</w>Hi all. Wondering how I might achieve the following sql chunk:

<pre>ARRAY_AGG(DISTINCT (i.name)) FILTER (WHERE i.name IS NOT NULL)</pre>
I have this in honey, but can&apos;t figure out how to not use a aggregate function as explained in the docs
<pre>[[:array_agg 
  [:distinct :i.name] 
  [:filter {:where [:not= nil :i.name]}]]]</pre>
If I don&apos;t use something like :%count, the filter clause doesn&apos;t show up in the output. Any thoughts?</z><z id="t1679415524" t="p-himik (sql/format {:select [[[:filter [:array_agg [:distinct :i.name]] {:where [:is-not :i.name nil]}]]]}) =&gt; [&quot;SELECT ARRAY_AGG(DISTINCT i.name) FILTER (WHERE i.name IS NOT NULL)&quot;] Documented at https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/sql-special-syntax-#filter-within-group"><y>#</y><d>2023-03-21</d><h>16:18</h><r>p-himik</r><pre>(sql/format {:select [[[:filter
                        [:array_agg [:distinct :i.name]]
                        {:where [:is-not :i.name nil]}]]]})
=&gt; [&quot;SELECT ARRAY_AGG(DISTINCT i.name) FILTER (WHERE i.name IS NOT NULL)&quot;]</pre>
Documented at <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/sql-special-syntax-#filter-within-group" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.980/doc/getting-started/sql-special-syntax-#filter-within-group</a></z><z id="t1679415612" t="az Hi [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] , thank you. I just don&apos;t see how to create a filter without an aggregate. My query doesn&apos;t work when I use Count"><y>#</y><d>2023-03-21</d><h>16:20</h><r>az</r>Hi <a>@U2FRKM4TW</a>, thank you. I just don&apos;t see how to create a filter without an aggregate. My query doesn&apos;t work when I use Count</z><z id="t1679415641" t="p-himik Not sure what you mean. What exactly do you want as an output?"><y>#</y><d>2023-03-21</d><h>16:20</h><r>p-himik</r>Not sure what you mean. What exactly do you want as an output?</z><z id="t1679415663" t="az ARRAY_AGG(DISTINCT (i.name)) FILTER (WHERE i.name IS NOT NULL) "><y>#</y><d>2023-03-21</d><h>16:21</h><r>az</r><pre>ARRAY_AGG(DISTINCT (i.name)) FILTER (WHERE i.name IS NOT NULL)</pre>
</z><z id="t1679415674" t="p-himik And how is it different from my code snippet?"><y>#</y><d>2023-03-21</d><h>16:21</h><r>p-himik</r>And how is it different from my code snippet?</z><z id="t1679415681" t="az Not ARRAY_AGG(DISTINCT (i.name)) COUNT(*) FILTER (WHERE i.name IS NOT NULL) "><y>#</y><d>2023-03-21</d><h>16:21</h><r>az</r>Not

<pre>ARRAY_AGG(DISTINCT (i.name)) COUNT(*) FILTER (WHERE i.name IS NOT NULL)</pre>
</z><z id="t1679415690" t="p-himik Read my code snippet again. :)"><y>#</y><d>2023-03-21</d><h>16:21</h><r>p-himik</r>Read my code snippet again. :)</z><z id="t1679415715" t="az I&apos;m so sorry! I just saw the link to the docs"><y>#</y><d>2023-03-21</d><h>16:21</h><r>az</r>I&apos;m so sorry! I just saw the link to the docs</z><z id="t1679415743" t="p-himik Yeah, :filter is a modifier on top of an aggregate. Not an argument."><y>#</y><d>2023-03-21</d><h>16:22</h><r>p-himik</r>Yeah, <code>:filter</code> is a modifier on top of an aggregate. Not an argument.</z><z id="t1679415822" t="az Thank you so much this is perfect!"><y>#</y><d>2023-03-21</d><h>16:23</h><r>az</r>Thank you so much this is perfect!</z><z id="t1679498829" t="Noah Bogart I have a v1 insert-into with `query-values` that formats to &quot;insert into temp_table (with &quot;rows&quot; as (select * from ...) ...)&quot;: `(-&amp;gt; (insert-into :temp-table) (query-values (-&amp;gt; (with [:rows (-&amp;gt; (select :*) (from :other) ...)]) ...))`, and i want to transform this to v2. reading the docs, i feel like it should be `(-&amp;gt; (insert-into [:temp-table (-&amp;gt; (with [:rows (-&amp;gt; (select :*) (from :other) ...)]))] ...))` but that doesn&apos;t give me the right output."><y>#</y><d>2023-03-22</d><h>15:27</h><w>Noah Bogart</w>I have a v1 insert-into with `query-values` that formats to &quot;insert into temp_table (with &quot;rows&quot; as (select * from ...) ...)&quot;: `(-&amp;gt; (insert-into :temp-table) (query-values (-&amp;gt; (with [:rows (-&amp;gt; (select :*) (from :other) ...)]) ...))`, and i want to transform this to v2. reading the docs, i feel like it should be `(-&amp;gt; (insert-into [:temp-table (-&amp;gt; (with [:rows (-&amp;gt; (select :*) (from :other) ...)]))] ...))` but that doesn&apos;t give me the right output.</z><z id="t1679499780" t="Noah Bogart Hmm, seems i need to leave off the vector from the insert-into call"><y>#</y><d>2023-03-22</d><h>15:43</h><r>Noah Bogart</r>Hmm, seems i need to leave off the vector from the <code>insert-into</code> call</z><z id="t1679501606" t="Noah Bogart opened a github issue about this misunderstanding (and related misunderstandings) https://github.com/seancorfield/honeysql/issues/480"><y>#</y><d>2023-03-22</d><h>16:13</h><r>Noah Bogart</r>opened a github issue about this misunderstanding (and related misunderstandings) <a href="https://github.com/seancorfield/honeysql/issues/480" target="_blank">https://github.com/seancorfield/honeysql/issues/480</a></z><z id="t1679508092" t="seancorfield I&apos;m not sure if I understand where the root of the confusion is, so I asked a question there to clarify..."><y>#</y><d>2023-03-22</d><h>18:01</h><r>seancorfield</r>I&apos;m not sure if I understand where the root of the confusion is, so I asked a question there to clarify...</z><z id="t1679501606" t="Noah Bogart opened a github issue about this misunderstanding (and related misunderstandings) https://github.com/seancorfield/honeysql/issues/480"><y>#</y><d>2023-03-22</d><h>16:13</h><w>Noah Bogart</w>opened a github issue about this misunderstanding (and related misunderstandings) <a href="https://github.com/seancorfield/honeysql/issues/480" target="_blank">https://github.com/seancorfield/honeysql/issues/480</a></z><z id="t1679585702" t="Daniel Stephens Hi all, does anyone know how to use postgres&apos; on-conflict stuff where the update should increment a value from honeysql. Something like: (honey/format {:insert-into :table :values [{:id &quot;id&quot; :counter 1}] :on-conflict [:id] :do-update-set [:+ :counter 1]}) this is made up, but results in: [&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET + = EXCLUDED.+, counter = EXCLUDED.counter, ? = EXCLUDED.?&quot; &quot;id&quot; 1 1 1] whereas I want something like: [&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET counter = table.counter + ?&quot; &quot;id&quot; 1 1] Probably a bit specific or unusual as a case, but just in case!"><y>#</y><d>2023-03-23</d><h>15:35</h><w>Daniel Stephens</w>Hi all, does anyone know how to use postgres&apos; <code>on-conflict</code> stuff where the update should increment a value from honeysql.
Something like:
<pre>(honey/format
  {:insert-into   :table
   :values        [{:id &quot;id&quot; :counter 1}]
   :on-conflict   [:id]
   :do-update-set [:+ :counter 1]})</pre>
this is made up, but results in:
<pre>[&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET + = EXCLUDED.+, counter = EXCLUDED.counter, ? = EXCLUDED.?&quot;
 &quot;id&quot;
 1
 1
 1]</pre>
whereas I want something like:
<pre>[&quot;INSERT INTO table (id, counter)
   VALUES (?, ?)
   ON CONFLICT (id)
   DO UPDATE SET
   counter = table.counter + ?&quot;
  &quot;id&quot;
  1
  1]</pre>
Probably a bit specific or unusual as a case, but just in case!</z><z id="t1679587130" t="seancorfield You want the hash map form of :do-update-set : user=&gt; (sql/format {:insert-into :table :values [{:id &quot;id&quot; :counter 1}] :on-conflict [:id] :do-update-set {:counter [:+ :counter 1]}}) [&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET counter = counter + ?&quot; &quot;id&quot; 1 1] user=&gt;"><y>#</y><d>2023-03-23</d><h>15:58</h><r>seancorfield</r>You want the hash map form of <code>:do-update-set</code>:
<pre>user=&gt; (sql/format {:insert-into :table :values [{:id &quot;id&quot; :counter 1}] :on-conflict [:id] :do-update-set {:counter [:+ :counter 1]}})
[&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET counter = counter + ?&quot; &quot;id&quot; 1 1]
user=&gt;</pre></z><z id="t1679587189" t="seancorfield If you specifically need table.counter : user=&gt; (sql/format {:insert-into :table :values [{:id &quot;id&quot; :counter 1}] :on-conflict [:id] :do-update-set {:counter [:+ :table.counter 1]}}) [&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET counter = table.counter + ?&quot; &quot;id&quot; 1 1] user=&gt;"><y>#</y><d>2023-03-23</d><h>15:59</h><r>seancorfield</r>If you specifically need <code>table.counter</code>:
<pre>user=&gt; (sql/format {:insert-into :table :values [{:id &quot;id&quot; :counter 1}] :on-conflict [:id] :do-update-set {:counter [:+ :table.counter 1]}})
[&quot;INSERT INTO table (id, counter) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET counter = table.counter + ?&quot; &quot;id&quot; 1 1]
user=&gt;</pre></z><z id="t1679587230" t="seancorfield The vector form of :do-update-set only sets excluded columns."><y>#</y><d>2023-03-23</d><h>16:00</h><r>seancorfield</r>The vector form of <code>:do-update-set</code> only sets excluded columns.</z><z id="t1679587506" t="Daniel Stephens ha, amazing, thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] that was speedy! I appreciate the help, I did look through some docs FWIW and didn&apos;t notice this option https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert"><y>#</y><d>2023-03-23</d><h>16:05</h><r>Daniel Stephens</r>ha, amazing, thanks <a>@U04V70XH6</a> that was speedy! I appreciate the help, I did look through some docs FWIW and didn&apos;t notice this option <a href="https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert" target="_blank">https://cljdoc.org/d/seancorfield/honeysql/2.0.0-rc2/doc/getting-started/postgresql-support#upsert</a></z><z id="t1679590504" t="seancorfield Can you create an issue on GH for me to make that clearer? I suspect there&apos;s a test showing it, but it really should be in the docs too... Thanks."><y>#</y><d>2023-03-23</d><h>16:55</h><r>seancorfield</r>Can you create an issue on GH for me to make that clearer? I suspect there&apos;s a test showing it, but it really should be in the docs too... Thanks.</z><z id="t1679591784" t="Daniel Stephens Done! https://github.com/seancorfield/honeysql/issues/481"><y>#</y><d>2023-03-23</d><h>17:16</h><r>Daniel Stephens</r>Done! <a href="https://github.com/seancorfield/honeysql/issues/481" target="_blank">https://github.com/seancorfield/honeysql/issues/481</a></z><z id="t1679630207" t="seancorfield 2.4.1011 is on its way to Clojars and http://cljdoc.org -- it is purely a documentation update, no code changes"><y>#</y><d>2023-03-24</d><h>03:56</h><w>seancorfield</w>2.4.1011 is on its way to Clojars and <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a> -- it is purely a documentation update, no code changes</z><z id="t1680081410" t="oly hitting a wierd issue with next.jdbc / honey I am doing a group by (substring postcode 1 4) and also the same in the select, pushing the query through sql/format gives me a correct sql query I can run against my db how ever sending it to execute! I get this error. ERROR: column &quot;accounts_address.postcode&quot; must appear in the GROUP BY clause or be used in an aggregate function Which would usually make sense except the query works and I do not need postcode in the group by so feels like I am hitting some caveat or bug or something. Anyone have any suggestions ?"><y>#</y><d>2023-03-29</d><h>09:16</h><w>oly</w>hitting a wierd issue with next.jdbc / honey I am doing a group by  (substring postcode 1 4) and also the same in the select, pushing the query through sql/format gives me a correct sql query I can run against my db how ever sending it to execute! I get this error.

<pre>ERROR: column &quot;accounts_address.postcode&quot; must appear in the GROUP BY clause or be used in an aggregate function</pre>
Which would usually make sense except the query works and I do not need postcode in the group by so feels like I am hitting some caveat or bug or something.

Anyone have any suggestions ?</z><z id="t1680083366" t="p-himik That&apos;s really weird indeed. Are you sure you&apos;re not accidentally executing some outdated code that&apos;s still referenced from somewhere else?"><y>#</y><d>2023-03-29</d><h>09:49</h><r>p-himik</r>That&apos;s really weird indeed.
Are you sure you&apos;re not accidentally executing some outdated code that&apos;s still referenced from somewhere else?</z><z id="t1680083488" t="oly pretty sure but I will jack out and jack in to confirm"><y>#</y><d>2023-03-29</d><h>09:51</h><r>oly</r>pretty sure but I will jack out and jack in to confirm</z><z id="t1680083852" t="oly that&apos;s did not help got a bit further, tried this GROUP BY SUBSTRING(\&quot;accounts_address\&quot;.\&quot;postcode\&quot;, 1, 4)&quot;]) vs GROUP BY SUBSTRING(\&quot;accounts_address\&quot;.\&quot;postcode\&quot;, ?, ?)&quot; 1 4]) so something todo with the dynamic params"><y>#</y><d>2023-03-29</d><h>09:57</h><r>oly</r>that&apos;s did not help got a bit further, tried this
<pre>GROUP BY SUBSTRING(\&quot;accounts_address\&quot;.\&quot;postcode\&quot;, 1, 4)&quot;])</pre>
vs
<pre>GROUP BY SUBSTRING(\&quot;accounts_address\&quot;.\&quot;postcode\&quot;, ?, ?)&quot; 1 4])</pre>
so something todo with the dynamic params</z><z id="t1680083927" t="oly I have resorted to pushing vector versions of the query into execute!"><y>#</y><d>2023-03-29</d><h>09:58</h><r>oly</r>I have resorted to pushing vector versions of the query into execute!</z><z id="t1680083964" t="p-himik So what is the difference exactly, in code, between the version that works and the version that doesn&apos;t?"><y>#</y><d>2023-03-29</d><h>09:59</h><r>p-himik</r>So what is the difference exactly, in code, between the version that works and the version that doesn&apos;t?</z><z id="t1680084007" t="oly one has the values as part of the query the other has them as parameters, ie with ? and with out"><y>#</y><d>2023-03-29</d><h>10:00</h><r>oly</r>one has the values as part of the query the other has them as parameters, ie with ? and with out</z><z id="t1680084024" t="p-himik But which one of them ended up working? The one with ? ?"><y>#</y><d>2023-03-29</d><h>10:00</h><r>p-himik</r>But which one of them ended up working? The one with <code>?</code>?</z><z id="t1680084050" t="oly the one with out the ? works ie part of the query I could use raw I guess to fix this"><y>#</y><d>2023-03-29</d><h>10:00</h><r>oly</r>the one with out the ? works ie part of the query I could use raw I guess to fix this</z><z id="t1680084070" t="p-himik There :inline but it&apos;s suboptimal w.r.t. caching."><y>#</y><d>2023-03-29</d><h>10:01</h><r>p-himik</r>There <code>:inline</code> but it&apos;s suboptimal w.r.t. caching.</z><z id="t1680084123" t="oly I would be happy for works at this point, but equally curious what I am doing wrong as feels like it should work"><y>#</y><d>2023-03-29</d><h>10:02</h><r>oly</r>I would be happy for works at this point, but equally curious what I am doing wrong as feels like it should work</z><z id="t1680084132" t="p-himik It might be that the DB can&apos;t figure out the types of those ? for sure because the substring function is overloaded. Maybe it&apos;ll help providing explicit casts, like substring(x, ?::int, ?::int) , but no idea."><y>#</y><d>2023-03-29</d><h>10:02</h><r>p-himik</r>It might be that the DB can&apos;t figure out the types of those <code>?</code> for sure because the <code>substring</code> function is overloaded.
Maybe it&apos;ll help providing explicit casts, like <code>substring(x, ?::int, ?::int)</code>, but no idea.</z><z id="t1680084231" t="oly could be worth a try as well"><y>#</y><d>2023-03-29</d><h>10:03</h><r>oly</r>could be worth a try as well</z><z id="t1680084288" t="oly inline works a treat, so at least I have an option cheers for that suggestion"><y>#</y><d>2023-03-29</d><h>10:04</h><r>oly</r>inline works a treat, so at least I have an option cheers for that suggestion</z><z id="t1680084575" t="oly Using :cast how ever gives me the same error, (sqlh/group-by [:substring :accounts_address.postcode [:cast 1 :int] [:cast 4 :int] #_#_[:inline 1] [:inline chars]]) So i guess I will use inline for now, cheers for the assistance appreciated 🙂"><y>#</y><d>2023-03-29</d><h>10:09</h><r>oly</r>Using :cast how ever gives me the same error,
<pre>(sqlh/group-by [:substring :accounts_address.postcode
                      [:cast 1 :int]
                      [:cast 4 :int]
                      #_#_[:inline 1]
                        [:inline chars]])</pre>
So i guess I will use inline for now, cheers for the assistance appreciated <b>🙂</b></z><z id="t1680103770" t="seancorfield [:attrs {:href &quot;/_/_/users/UU67HFS2X&quot;}] I&apos;ve seen that with different versions of MySQL: older versions allowed you to omit grouped columns/expressions from the SELECT but later versions required you provide them (although there was a DB setting to relax the new restriction). I think if you add that [:substring ..] call into the :select with an alias, you will be able to :group-by that alias."><y>#</y><d>2023-03-29</d><h>15:29</h><r>seancorfield</r><a>@UU67HFS2X</a> I&apos;ve seen that with different versions of MySQL: older versions allowed you to omit grouped columns/expressions from the <code>SELECT</code> but later versions required you provide them (although there was a DB setting to relax the new restriction). I think if you add that <code>[:substring ..]</code> call into the <code>:select</code> with an alias, you will be able to <code>:group-by</code> that alias.</z><z id="t1680113747" t="oly does the same apply for postgres ? that&apos;s my target in this instance I also realized the cast above is wrong as it should be :: integer not :: int when using the cast function so will need to retry that"><y>#</y><d>2023-03-29</d><h>18:15</h><r>oly</r>does the same apply for postgres ? that&apos;s my target in this instance I also realized the cast above is wrong as it should be <b>::</b>integer not <b>::</b>int when using the cast function so will need to retry that</z><z id="t1680113797" t="seancorfield Given the ERROR: column &quot;accounts_address.postcode&quot; must appear in the GROUP BY clause or be used in an aggregate function error you&apos;re getting, I&apos;m going to say &quot;Yes, it applies to PostgreSQL&quot; 🙂"><y>#</y><d>2023-03-29</d><h>18:16</h><r>seancorfield</r>Given the <code>ERROR: column &quot;accounts_address.postcode&quot; must appear in the GROUP BY clause or be used in an aggregate function</code> error you&apos;re getting, I&apos;m going to say &quot;Yes, it applies to PostgreSQL&quot; <b>🙂</b></z><z id="t1680114615" t="oly okay I will give it a try cheers for the tip 🙂"><y>#</y><d>2023-03-29</d><h>18:30</h><r>oly</r>okay I will give it a try cheers for the tip <b>🙂</b></z><z id="t1680118088" t="p-himik FWIW in PostgreSQL you cannot mention in GROUP BY aliases defined in SELECT ."><y>#</y><d>2023-03-29</d><h>19:28</h><r>p-himik</r>FWIW in PostgreSQL you cannot mention in <code>GROUP BY</code> aliases defined in <code>SELECT</code>.</z><z id="t1680087584" t="oly if you have not thought of doing this, using the chat gpt style apps are pretty good at generating you honeysql code with the correct format, I just asked you chat this question. give me an example of using a summed case statement using honeysql version 2 Which saved me piecing the parts together, surprised how good it is considering honeysql is a bit more niche"><y>#</y><d>2023-03-29</d><h>10:59</h><w>oly</w>if you have not thought of doing this, using the chat gpt style apps are pretty good at generating you honeysql code with the correct format, I just asked you chat this question.
<pre>give me an example of using a summed case statement using honeysql version 2</pre>
Which saved me piecing the parts together, surprised how good it is considering honeysql is a bit more niche</z><z id="t1680087974" t="oly ha, very impressed it does entire queries and if you specify give it to me in threading macro style it can even use the helper functions which are much nicer to read 🙂"><y>#</y><d>2023-03-29</d><h>11:06</h><w>oly</w>ha, very impressed it does entire queries and if you specify give it to me in threading macro style it can even use the helper functions which are much nicer to read <b>🙂</b></z><z id="t1680103528" t="seancorfield Beware of very confident but completely wrong answers from ChatGPT: it will happily invent new functions in libraries, just on the basis that the names sound like they solve the problem -- remember that it is a language model and has no real understanding of Clojure or the specifics of any library!"><y>#</y><d>2023-03-29</d><h>15:25</h><r>seancorfield</r>Beware of very confident but completely wrong answers from ChatGPT: it will happily invent new functions in libraries, just on the basis that the names sound like they solve the problem -- remember that it is a language model and has no real understanding of Clojure or the specifics of any library!</z><z id="t1680118408" t="oly yeah very true, but its handy to give me an idea of the general syntax else I keep having to reference existing queries or lookup in the docs for the format I need, but I have noticed it does get things wrong often just close enough to save me some time 🙂"><y>#</y><d>2023-03-29</d><h>19:33</h><r>oly</r>yeah very true, but its handy to give me an idea of the general syntax else I keep having to reference existing queries or lookup in the docs for the format I need, but I have noticed it does get things wrong often just close enough to save me some time <b>🙂</b></z><z id="t1680286309" t="markaddleman I think I found a bug in honey’s formatting of partition-by"><y>#</y><d>2023-03-31</d><h>18:11</h><w>markaddleman</w>I think I found a bug in honey’s formatting of <code>partition-by</code></z><z id="t1680286329" t="markaddleman (-&gt; {:select [[[:over [[:lead :event] {:partition-by [[:upper :a]]}]] :random]] :from [[:foo :foo]]} (honey.sql/format) (first)) produces SELECT LEAD(event) OVER (PARTITION BY upper a) AS random FROM foo AS foo"><y>#</y><d>2023-03-31</d><h>18:12</h><r>markaddleman</r><pre>(-&gt; {:select [[[:over [[:lead :event]
                         {:partition-by [[:upper :a]]}]]
                 :random]]
       :from   [[:foo :foo]]}
      (honey.sql/format)
      (first))</pre>
produces <code>SELECT LEAD(event) OVER (PARTITION BY upper a) AS random FROM foo AS foo</code></z><z id="t1680286358" t="markaddleman I expected the partition by to be PARTITION BY UPPER(a)"><y>#</y><d>2023-03-31</d><h>18:12</h><r>markaddleman</r>I expected the partition by to be <code>PARTITION BY UPPER(a)</code></z><z id="t1680286402" t="markaddleman this honey produces the correct result (-&gt; {:select [[[:over [[:lead :event] {:partition-by [[[:upper :a]]]}]] :random]] :from [[:foo :foo]]} (honey.sql/format) (first)) SELECT LEAD(event) OVER (PARTITION BY UPPER(a)) AS random FROM foo AS foo"><y>#</y><d>2023-03-31</d><h>18:13</h><r>markaddleman</r>this honey produces the correct result
<pre>(-&gt; {:select [[[:over [[:lead :event]
                         {:partition-by [[[:upper :a]]]}]]
                 :random]]
       :from   [[:foo :foo]]}
      (honey.sql/format)
      (first))</pre>
<code>SELECT LEAD(event) OVER (PARTITION BY UPPER(a)) AS random FROM foo AS foo</code></z><z id="t1680286418" t="markaddleman If this is not user error, I’ll open an issue"><y>#</y><d>2023-03-31</d><h>18:13</h><r>markaddleman</r>If this is not user error, I’ll open an issue</z><z id="t1680286613" t="p-himik Pretty sure it&apos;s user error as :partition-by can accept many columns. Zero nesting, a single keyword - a single column One level of nesting - &gt;= 1 columns Two levels - same but with aliases Three levels - same but with function calls"><y>#</y><d>2023-03-31</d><h>18:16</h><r>p-himik</r>Pretty sure it&apos;s user error as <code>:partition-by</code> can accept many columns.
Zero nesting, a single keyword - a single column
One level of nesting - &gt;= 1 columns
Two levels - same but with aliases
Three levels - same but with function calls</z><z id="t1680286617" t="p-himik Same as with :select ."><y>#</y><d>2023-03-31</d><h>18:16</h><r>p-himik</r>Same as with <code>:select</code>.</z><z id="t1680286644" t="markaddleman SQL partition-by allows aliases? I’m not sure what that would mean"><y>#</y><d>2023-03-31</d><h>18:17</h><r>markaddleman</r>SQL partition-by allows aliases?  I’m not sure what that would mean</z><z id="t1680286681" t="p-himik It probably doesn&apos;t, but I believe that vector nesting is handled in a generic way."><y>#</y><d>2023-03-31</d><h>18:18</h><r>p-himik</r>It probably doesn&apos;t, but I believe that vector nesting is handled in a generic way.</z><z id="t1680286727" t="markaddleman that would make sense. If that’s the case, I contend it’s a bug but, of course, Sean is arbiter 🙂"><y>#</y><d>2023-03-31</d><h>18:18</h><r>markaddleman</r>that would make sense.  If that’s the case, I contend it’s a bug but, of course, Sean is arbiter <b>🙂</b></z><z id="t1680286775" t="markaddleman btw (-&gt; {:select [[[:over [[:lead :event] {:partition-by [[[:upper :a] :A]]}]] :random]] :from [[:foo :foo]]} (honey.sql/format) (first)) produces SELECT LEAD(event) OVER (PARTITION BY UPPER(a) A) AS random FROM foo AS foo"><y>#</y><d>2023-03-31</d><h>18:19</h><r>markaddleman</r>btw
<pre>(-&gt; {:select [[[:over [[:lead :event]
                         {:partition-by [[[:upper :a] :A]]}]]
                 :random]]
       :from   [[:foo :foo]]}
      (honey.sql/format)
      (first))</pre>
produces <code>SELECT LEAD(event) OVER (PARTITION BY UPPER(a) A) AS random FROM foo AS foo</code></z><z id="t1680287012" t="seancorfield Not a bug. Portions of HoneySQL are generic, just to keep maintenance manageable (because SQL is so f***ing complex) -- and there are many, many ways to persuade HoneySQL to generate invalid SQL 🙂"><y>#</y><d>2023-03-31</d><h>18:23</h><r>seancorfield</r>Not a bug. Portions of HoneySQL are generic, just to keep maintenance manageable (because SQL is so f***ing complex) -- and there are many, many ways to persuade HoneySQL to generate invalid SQL <b>🙂</b></z><z id="t1680287087" t="markaddleman Understood"><y>#</y><d>2023-03-31</d><h>18:24</h><r>markaddleman</r>Understood</z><z id="t1680287125" t="markaddleman So, just double wrap functions in the partition by clause?"><y>#</y><d>2023-03-31</d><h>18:25</h><r>markaddleman</r>So, just double wrap functions in the partition by clause?</z><z id="t1680287709" t="seancorfield Exactly like select, yes."><y>#</y><d>2023-03-31</d><h>18:35</h><r>seancorfield</r>Exactly like select, yes.</z><z id="t1680287764" t="seancorfield This is documented, BTW: &gt; :partition-by accepts the same arguments as :select above (even though the allowable SQL generated is much more restrictive). From https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1011/doc/getting-started/sql-clause-reference#window-partition-by-and-over"><y>#</y><d>2023-03-31</d><h>18:36</h><r>seancorfield</r>This is documented, BTW:

&gt; <code>:partition-by</code> accepts the same arguments as <code>:select</code> above (even though the allowable SQL generated is much more restrictive).
From <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1011/doc/getting-started/sql-clause-reference#window-partition-by-and-over" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1011/doc/getting-started/sql-clause-reference#window-partition-by-and-over</a></z><z id="t1680287791" t="markaddleman I should have RTFM. Thanks!"><y>#</y><d>2023-03-31</d><h>18:36</h><r>markaddleman</r>I should have RTFM.  Thanks!</z><z id="t1680287882" t="seancorfield All of the following are formatted like SELECT: :select #&apos;format-selects :select-distinct #&apos;format-selects :select-distinct-on #&apos;format-selects-on :delete (check-where #&apos;format-selects) :from #&apos;format-selects :using #&apos;format-selects :cross-join #&apos;format-selects :partition-by #&apos;format-selects :returning #&apos;format-selects"><y>#</y><d>2023-03-31</d><h>18:38</h><r>seancorfield</r>All of the following are formatted like SELECT:
<pre>:select          #&apos;format-selects
         :select-distinct #&apos;format-selects
         :select-distinct-on #&apos;format-selects-on
         :delete          (check-where #&apos;format-selects)
         :from            #&apos;format-selects
         :using           #&apos;format-selects
         :cross-join      #&apos;format-selects
         :partition-by    #&apos;format-selects
         :returning       #&apos;format-selects</pre></z><z id="t1681386482" t="rpatrelle message moved to #sql"><y>#</y><d>2023-04-13</d><h>11:48</h><w>rpatrelle</w>message moved to #sql</z><z id="t1681600063" t="seancorfield Thanks to several folks who highlighted missing syntax support over the last month or so!"><y>#</y><d>2023-04-15</d><h>23:07</h><w>seancorfield</w>Thanks to several folks who highlighted missing syntax support over the last month or so!</z></g><g id="s9"><z id="t1681725886" t="Jakub Holý (HolyJak) Hello, good people! I am not able to find out how to make Honey produce truncate table cascade I have tried (assoc (hh/truncate _:table_) :raw &quot;cascade&quot;) but that renders &quot;CASCADE TRUNCATE table&quot; 😭 🙏"><y>#</y><d>2023-04-17</d><h>10:04</h><w>Jakub Holý (HolyJak)</w>Hello, good people! I am not able to find out how to make Honey produce <code>truncate table cascade</code>
I have tried <code>(assoc (hh/truncate _:table_) :raw &quot;cascade&quot;)</code> but that renders <code>&quot;CASCADE TRUNCATE table&quot;</code> <b>😭</b> <b>🙏</b></z><z id="t1681726091" t="p-himik (sql/format {:truncate [:my-table :cascade]}) =&gt; [&quot;TRUNCATE my_table CASCADE&quot;]"><y>#</y><d>2023-04-17</d><h>10:08</h><r>p-himik</r><pre>(sql/format {:truncate [:my-table :cascade]})
=&gt; [&quot;TRUNCATE my_table CASCADE&quot;]</pre></z><z id="t1681726134" t="p-himik And with a helper function: (sql/format (hh/truncate [:my-table :cascade])) =&gt; [&quot;TRUNCATE my_table CASCADE&quot;]"><y>#</y><d>2023-04-17</d><h>10:08</h><r>p-himik</r>And with a helper function:
<pre>(sql/format (hh/truncate [:my-table :cascade]))
=&gt; [&quot;TRUNCATE my_table CASCADE&quot;]</pre></z><z id="t1681726824" t="Jakub Holý (HolyJak) many thanks! I would never have figured that out 😅"><y>#</y><d>2023-04-17</d><h>10:20</h><r>Jakub Holý (HolyJak)</r>many thanks! I would never have figured that out <b>😅</b></z><z id="t1681727074" t="p-himik Searching on GitHub brings answers in the speediest of manners. :)"><y>#</y><d>2023-04-17</d><h>10:24</h><r>p-himik</r>Searching on GitHub brings answers in the speediest of manners. :)</z><z id="t1681727186" t="Jakub Holý (HolyJak) What did you search? I searched the honesql GH repo for “cascade” in vain"><y>#</y><d>2023-04-17</d><h>10:26</h><r>Jakub Holý (HolyJak)</r>What did you search? I searched the honesql GH repo for “cascade” in vain</z><z id="t1681727382" t="p-himik That&apos;s actually exactly what I did. It&apos;s just that I look at commits and issues as well. The search landed me on this commit where I quickly saw the highlighted line which made it obvious how to specify :cascade : https://github.com/seancorfield/honeysql/commit/e8ea9283cc3cae5939750a0b540518143b87ff39#diff-49952233047493b6ede50abf2fce16b71d9c717d3b7c050f64e86a4514a1db1bR599"><y>#</y><d>2023-04-17</d><h>10:29</h><r>p-himik</r>That&apos;s actually exactly what I did. It&apos;s just that I look at commits and issues as well.
The search landed me on this commit where I quickly saw the highlighted line which made it obvious how to specify <code>:cascade</code>: <a href="https://github.com/seancorfield/honeysql/commit/e8ea9283cc3cae5939750a0b540518143b87ff39#diff-49952233047493b6ede50abf2fce16b71d9c717d3b7c050f64e86a4514a1db1bR599" target="_blank">https://github.com/seancorfield/honeysql/commit/e8ea9283cc3cae5939750a0b540518143b87ff39#diff-49952233047493b6ede50abf2fce16b71d9c717d3b7c050f64e86a4514a1db1bR599</a></z><z id="t1681765030" t="marrs Can honeysql quote table and column names to prevent clashes with names reserved by the DBRMS and are there any strong opinions about whether or not one should do this?"><y>#</y><d>2023-04-17</d><h>20:57</h><w>marrs</w>Can honeysql quote table and column names to prevent clashes with names reserved by the DBRMS and are there any strong opinions about whether or not one should do this?</z><z id="t1681765118" t="p-himik Yes, quoting is very well documented. And you should definitely do that. There&apos;s no good reason not to quote your identifiers."><y>#</y><d>2023-04-17</d><h>20:58</h><r>p-himik</r>Yes, quoting is very well documented. And you should definitely do that. There&apos;s no good reason not to quote your identifiers.</z><z id="t1681766803" t="marrs Ah, I found the relevant part in the doc. I guess the deeper question is, should one avoid using reserved words even if one is quoting?"><y>#</y><d>2023-04-17</d><h>21:26</h><r>marrs</r>Ah, I found the relevant part in the doc.  I guess the deeper question is, should one avoid using reserved words even if one is quoting?</z><z id="t1681767614" t="p-himik I would say no. E.g. &quot;order&quot; is way too good of a name to pass it up just because the DB reserved it in its unquoted form."><y>#</y><d>2023-04-17</d><h>21:40</h><r>p-himik</r>I would say no. E.g. &quot;order&quot; is way too good of a name to pass it up just because the DB reserved it in its unquoted form.</z><z id="t1681767642" t="p-himik But you probably shouldn&apos;t name your columns &amp;%!@# even if quoted. ;)"><y>#</y><d>2023-04-17</d><h>21:40</h><r>p-himik</r>But you probably shouldn&apos;t name your columns <code>&amp;%!@#</code> even if quoted. ;)</z><z id="t1681768039" t="marrs yeah, that seems fair"><y>#</y><d>2023-04-17</d><h>21:47</h><r>marrs</r>yeah, that seems fair</z><z id="t1681768069" t="marrs thanks for sharing your opinion"><y>#</y><d>2023-04-17</d><h>21:47</h><r>marrs</r>thanks for sharing your opinion</z><z id="t1682083710" t="Bingen Galartza Iparragirre Hi! is it possible to use the WITH _ storage_parameter=value`_ ` options in the create table/view ddl operations using HoneySQL? I don&apos;t know if it&apos;s part of the SQL standard or PSQL specific. https://www.postgresql.org/docs/current/sql-creatematerializedview.html"><y>#</y><d>2023-04-21</d><h>13:28</h><w>Bingen Galartza Iparragirre</w>Hi! is it possible to use the <code>WITH _</code>storage_parameter=value`_ ` options  in the create table/view ddl operations using HoneySQL?

I don&apos;t know if it&apos;s part of the SQL standard or PSQL specific.
<a href="https://www.postgresql.org/docs/current/sql-creatematerializedview.html" target="_blank">https://www.postgresql.org/docs/current/sql-creatematerializedview.html</a></z><z id="t1682349241" t="iarenaza [:attrs {:href &quot;/_/_/users/UK14W219B&quot;}] This should do the trick: user&gt; (sql/format {:create-materialized-view [:product [[:with [:= :storage-parameter &quot;value&quot;]]]] :select [:*] :from [:table] :where [:= :column &quot;value&quot;] :with-data false}) [&quot;CREATE MATERIALIZED VIEW product WITH(storage_parameter = &apos;value&apos;) AS SELECT * FROM table WHERE column = ? WITH NO DATA&quot; &quot;value&quot;]"><y>#</y><d>2023-04-24</d><h>15:14</h><r>iarenaza</r><a>@UK14W219B</a> This should do the trick:

<pre>user&gt; (sql/format {:create-materialized-view [:product [[:with [:= :storage-parameter &quot;value&quot;]]]]
                   :select [:*]
                   :from [:table]
                   :where [:= :column &quot;value&quot;]
                   :with-data false})
[&quot;CREATE MATERIALIZED VIEW product WITH(storage_parameter = &apos;value&apos;) AS SELECT * FROM table WHERE column = ? WITH NO DATA&quot;
 &quot;value&quot;]</pre></z><z id="t1682350957" t="Bingen Galartza Iparragirre Great! Thanks a lot"><y>#</y><d>2023-04-24</d><h>15:42</h><r>Bingen Galartza Iparragirre</r>Great! Thanks a lot</z><z id="t1682338546" t="Daniel Vieira Hi, is there a way to use :quoted together with if exists ? (sql/format (hh/drop-view [:if-exists] :aBc) {:quoted true}) ; =&gt; [&quot;DROP VIEW IF EXISTS ABC&quot;] (sql/format (hh/drop-view :aBc) {:quoted true}) ; =&gt; [&quot;DROP VIEW \&quot;aBc\&quot;&quot;] Expected: (sql/format (hh/drop-view [:if-exists] :aBc) {:quoted true}) ; =&gt; [&quot;DROP VIEW IF EXISTS \&quot;aBc\&quot;&quot;]"><y>#</y><d>2023-04-24</d><h>12:15</h><w>Daniel Vieira</w>Hi, is there a way to use <code>:quoted</code> together with <code>if exists</code>?

(sql/format (hh/drop-view [:if-exists] :aBc) {:quoted true})
; =&gt; [&quot;DROP VIEW  IF EXISTS ABC&quot;]

(sql/format (hh/drop-view :aBc) {:quoted true})
; =&gt; [&quot;DROP VIEW \&quot;aBc\&quot;&quot;]

Expected:
(sql/format (hh/drop-view [:if-exists] :aBc) {:quoted true})
; =&gt; [&quot;DROP VIEW  IF EXISTS \&quot;aBc\&quot;&quot;]</z><z id="t1682338716" t="p-himik (sql/format (hh/drop-view :if-exists :aBc) {:quoted true}) =&gt; [&quot;DROP VIEW IF EXISTS \&quot;aBc\&quot;&quot;]"><y>#</y><d>2023-04-24</d><h>12:18</h><r>p-himik</r><pre>(sql/format (hh/drop-view :if-exists :aBc) {:quoted true})
=&gt; [&quot;DROP VIEW IF EXISTS \&quot;aBc\&quot;&quot;]</pre></z><z id="t1682522903" t="Ben Lieberman bit of a niche thing I suppose but H2&apos;s JAVA_OBJECT type requires the keyword :java_object in order to work correctly. Is there a way to support kebab casing here?"><y>#</y><d>2023-04-26</d><h>15:28</h><w>Ben Lieberman</w>bit of a niche thing I suppose but H2&apos;s <code>JAVA_OBJECT</code> type requires the keyword <code>:java_object</code> in order to work correctly. Is there a way to support kebab casing here?</z><z id="t1682533912" t="seancorfield Can you provide more context/examples &amp; maybe link to some docs?"><y>#</y><d>2023-04-26</d><h>18:31</h><r>seancorfield</r>Can you provide more context/examples &amp; maybe link to some docs?</z><z id="t1682536220" t="Ben Lieberman That type is documented http://www.h2database.com/html/datatypes.html#java_object_type . I&apos;m getting some data from an API into our (test) database and among other things it includes positional data that looks like this {&quot;type&quot; &quot;Point&quot;, &quot;coordinates&quot; [&quot;a-lat&quot; &quot;a-lon&quot;]} H2 has a GEOMETRY type for this but it doesn&apos;t support the additional type parameter so I&apos;m just serializing it as is. It really is not terribly important and is more of an observation that if I write something like (hsql/format {:create-table :foo :with-columns [[:bar :java-object]]}) it gives me back [&quot;CREATE TABLE foo (bar JAVA OBJECT)&quot;] which doesn&apos;t pass muster with H2."><y>#</y><d>2023-04-26</d><h>19:10</h><r>Ben Lieberman</r>That type is documented <a href="http://www.h2database.com/html/datatypes.html#java_object_type" target="_blank">http://www.h2database.com/html/datatypes.html#java_object_type</a>. I&apos;m getting some data from an API into our (test) database and among other things it includes positional data that looks like this
<pre>{&quot;type&quot; &quot;Point&quot;, &quot;coordinates&quot; [&quot;a-lat&quot; &quot;a-lon&quot;]}</pre>
H2 has a <code>GEOMETRY</code> type for this but it doesn&apos;t support the additional type parameter so I&apos;m just serializing it as is.

It really is not terribly important and is more of an observation that if I write something like
<pre>(hsql/format {:create-table :foo
              :with-columns [[:bar :java-object]]})</pre>
it gives me back <code>[&quot;CREATE TABLE foo (bar JAVA OBJECT)&quot;]</code> which doesn&apos;t pass muster with H2.</z><z id="t1682536403" t="seancorfield Ah, gotcha... Not much you can do to get around that at the moment."><y>#</y><d>2023-04-26</d><h>19:13</h><r>seancorfield</r>Ah, gotcha... Not much you can do to get around that at the moment.</z><z id="t1682536477" t="Ben Lieberman No worries, thanks for HoneySQL, it&apos;s awesome!!"><y>#</y><d>2023-04-26</d><h>19:14</h><r>Ben Lieberman</r>No worries, thanks for HoneySQL, it&apos;s awesome!!</z><z id="t1682661402" t="flowthing I’m a bit late with this, but it’s been a while since we updated our deps… it looks like commit https://github.com/seancorfield/honeysql/commit/3073d2852587186e1a1489c3a07b032e014881ac breaks backwards compatibility in that HoneySQL no longer allows hash sets as :values : λ clj -Srepro -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;737699c11acae0863b6c9e76921a2f8c92902ca4&quot;}}}&apos; Clojure 1.11.1 user=&gt; ((requiring-resolve &apos;honey.sql/format) {:insert-into :foo :values #{{:bar &quot;baz&quot;}}}) [&quot;INSERT INTO foo (bar) VALUES (?)&quot; &quot;baz&quot;] vs. λ clj -Srepro -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;3073d2852587186e1a1489c3a07b032e014881ac&quot;}}}&apos; Clojure 1.11.1 user=&gt; ((requiring-resolve &apos;honey.sql/format) {:insert-into :foo :values #{{:bar &quot;baz&quot;}}}) Execution error (ExceptionInfo) at honey.sql/format-values (sql.cljc:768). :values expects sequences or maps Is this an intentional change?"><y>#</y><d>2023-04-28</d><h>05:56</h><w>flowthing</w>I’m a bit late with this, but it’s been a while since we updated our deps… it looks like commit <a href="https://github.com/seancorfield/honeysql/commit/3073d2852587186e1a1489c3a07b032e014881ac" target="_blank">https://github.com/seancorfield/honeysql/commit/3073d2852587186e1a1489c3a07b032e014881ac</a> breaks backwards compatibility in that HoneySQL no longer allows hash sets as <code>:values</code>:

<pre>λ clj -Srepro -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;737699c11acae0863b6c9e76921a2f8c92902ca4&quot;}}}&apos;
Clojure 1.11.1
user=&gt; ((requiring-resolve &apos;honey.sql/format) {:insert-into :foo :values #{{:bar &quot;baz&quot;}}})
[&quot;INSERT INTO foo (bar) VALUES (?)&quot; &quot;baz&quot;]</pre>
vs.

<pre>λ clj -Srepro -Sdeps &apos;{:deps {com.github.seancorfield/honeysql {:git/url &quot;&quot; :sha &quot;3073d2852587186e1a1489c3a07b032e014881ac&quot;}}}&apos;
Clojure 1.11.1
user=&gt; ((requiring-resolve &apos;honey.sql/format) {:insert-into :foo :values #{{:bar &quot;baz&quot;}}})
Execution error (ExceptionInfo) at honey.sql/format-values (sql.cljc:768).
:values expects sequences or maps</pre>
Is this an intentional change?</z><z id="t1682668004" t="p-himik I&apos;d argue that it&apos;s not a breaking change because hash sets were never intended to be used as :values . The docs state: &gt; :values accepts either a sequence of hash maps representing row values or a sequence of sequences, also representing row values. And sets are not sequences. So I&apos;d say you were relying on undefined behavior. Especially given that insertion order is meaningful in general whereas sets are unordered."><y>#</y><d>2023-04-28</d><h>07:46</h><r>p-himik</r>I&apos;d argue that it&apos;s not a breaking change because hash sets were never intended to be used as <code>:values</code>.
The docs state:
&gt;  <code>:values</code> accepts either a sequence of hash maps representing row values or a sequence of sequences, also representing row values.
And sets are not sequences.
So I&apos;d say you were relying on undefined behavior. Especially given that insertion order is meaningful in general whereas sets are unordered.</z><z id="t1682668192" t="flowthing Makes sense, thanks. 👍"><y>#</y><d>2023-04-28</d><h>07:49</h><r>flowthing</r>Makes sense, thanks. <b>👍</b></z><z id="t1682889215" t="marrs I&apos;ve just noticed that :join and :inner-join get added to a query in a different order when combined with :left-join . Is that deliberate?"><y>#</y><d>2023-04-30</d><h>21:13</h><w>marrs</w>I&apos;ve just noticed that <code>:join</code> and <code>:inner-join</code> get added to a query in a different order when combined with <code>:left-join</code>.  Is that deliberate?</z><z id="t1682890158" t="seancorfield The DSL is a hash map: it is inherently unordered. There&apos;s a :join-by construct in the DSL if you need JOIN s in a specific order for your database (the behavior with multiple JOIN s differs between databases... because of course it does)."><y>#</y><d>2023-04-30</d><h>21:29</h><r>seancorfield</r>The DSL is a hash map: it is inherently unordered.

There&apos;s a <code>:join-by</code> construct in the DSL if you need <code>JOIN</code>s in a specific order for your database (the behavior with multiple <code>JOIN</code>s differs between databases... because of course it does).</z><z id="t1682943345" t="marrs Thanks, I switched to that already. I just wondered if I was missing a trick. I&apos;ve noticed that hashmaps tend to be ordered by key alphabetically, and since inner-join and join are both ahead of left-join , I was wondering if you were forcing the behaviour for some reason."><y>#</y><d>2023-05-01</d><h>12:15</h><r>marrs</r>Thanks, I switched to that already.  I just wondered if I was missing a trick.  I&apos;ve noticed that hashmaps tend to be ordered by key alphabetically, and since <code>inner-join</code> and <code>join</code> are both ahead of <code>left-join</code>, I was wondering if you were forcing the behaviour for some reason.</z><z id="t1682956938" t="seancorfield Small hash maps stay in key order because they use an array but that&apos;s a pure implementation detail and should never be relied on: user=&gt; {:b 2 :a 1} {:b 2, :a 1} What HoneySQL does is process clauses in &quot;precedence order&quot; and it uses a vector to determine that, so I&apos;ve probably got all the JOIN-related clauses in alphabetical order just for maintenance purposes: https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L1228-L1238 but modified by https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L709-L717"><y>#</y><d>2023-05-01</d><h>16:02</h><r>seancorfield</r>Small hash maps stay in key order because they use an array but that&apos;s a pure implementation detail and should never be relied on:
<pre>user=&gt; {:b 2 :a 1}
{:b 2, :a 1}</pre>
What HoneySQL does is process clauses in &quot;precedence order&quot; and it uses a vector to determine that, so I&apos;ve probably got all the JOIN-related clauses in alphabetical order just for maintenance purposes: <a href="https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L1228-L1238" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L1228-L1238</a> but modified by <a href="https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L709-L717" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/src/honey/sql.cljc#L709-L717</a></z><z id="t1683285665" t="Pratik Our codebase is in honeysql 1.x version and I am trying to get this query working SELECT * FROM schemes s LEFT JOIN progress p ON p.scheme_id = s.id AND s.term = 1 AND p.date &gt; &apos;2023-04-27&apos; WHERE p.driver_id = &apos;123&apos; ORDER BY p.date DESC LIMIT 10 OFFSET 0; and till left join it’s working as below: (-&gt; (sqle/select* [:*]) (helpers/from [:schemes :s]) (helpers/left-join [:progress :p] [:= :p.scheme-id :s.id]) (honeysql.core/format)) but I am not sure how to add the AND s.term = 1 AND p.date &gt; &apos;2023-04-27&apos; part in honeysql(I want it to be there instead of where condition because it optimizes the query by filtering records at join time)."><y>#</y><d>2023-05-05</d><h>11:21</h><w>Pratik</w>Our codebase is in honeysql 1.x version and I am trying to get this query working
<pre>SELECT *
FROM
    schemes s
    LEFT JOIN progress p ON p.scheme_id = s.id
    AND s.term = 1
    AND p.date &gt; &apos;2023-04-27&apos;
WHERE
    p.driver_id = &apos;123&apos;
    ORDER BY p.date DESC
    LIMIT 10 OFFSET 0;</pre>
and till left join it’s working as below:
<pre>(-&gt; (sqle/select* [:*])
    (helpers/from [:schemes :s])
    (helpers/left-join [:progress :p] [:= :p.scheme-id :s.id])
    (honeysql.core/format))</pre>
but I am not sure how to add the
<pre>AND s.term = 1
AND p.date &gt; &apos;2023-04-27&apos;</pre>
part in honeysql(I want it to be there instead of where condition because it optimizes the query by filtering records at join time).</z><z id="t1683286459" t="p-himik Wrap [:= ...] in [:and ...] . Also, are you sure about that &quot;it optimizes the query&quot; statement? I would be rather surprised if that&apos;s the case since it seems to be a very obvious optimization that a query planner can do on its own. Have you run EXPLAIN ANALYZE on that query and compared it to the one where the conditions are in the WHERE clause?"><y>#</y><d>2023-05-05</d><h>11:34</h><r>p-himik</r>Wrap <code>[:= ...]</code> in <code>[:and ...]</code>.

Also, are you sure about that &quot;it optimizes the query&quot; statement? I would be rather surprised if that&apos;s the case since it seems to be a very obvious optimization that a query planner can do on its own. Have you run <code>EXPLAIN ANALYZE</code> on that query and compared it to the one where the conditions are in the <code>WHERE</code> clause?</z><z id="t1683287149" t="Pratik tried placing [:and [:= :s.term 1]] inside the left-join as well as after it but it’s not working: (-&gt; (sqle/select* [:*]) (sqlh/from [:schemes :s]) (sqlh/left-join [:progress :p] [:= :p.scheme-id :s.id]) ([:and [:= :s.term 1]]) (sqlc/format)) is giving ; Key must be integer error."><y>#</y><d>2023-05-05</d><h>11:45</h><r>Pratik</r>tried placing <code>[:and [:= :s.term 1]]</code> inside the <code>left-join</code> as well as after it but it’s not working:
<pre>(-&gt; (sqle/select* [:*])
    (sqlh/from [:schemes :s])
    (sqlh/left-join [:progress :p] [:= :p.scheme-id :s.id])
    ([:and [:= :s.term 1]])
    (sqlc/format))</pre>
is giving <code>; Key must be integer</code> error.</z><z id="t1683287189" t="Pratik And yes, the query with AND statements is giving less execution time on average than the query with “WHERE” conditions. It was suggested by a colleague and I was also surprised(It’s 30-40% improvement) on running it with explain analyze"><y>#</y><d>2023-05-05</d><h>11:46</h><r>Pratik</r>And yes, the query with AND statements is giving less execution time on average than the query with “WHERE” conditions. It was suggested by a colleague and I was also surprised(It’s 30-40% improvement) on running it with explain analyze</z><z id="t1683288253" t="p-himik I meant to wrap the existing := in :and : (sqlh/left-join [...] [:and [:= ...] [:= ...]]) ."><y>#</y><d>2023-05-05</d><h>12:04</h><r>p-himik</r>I meant to wrap the existing <code>:=</code> in <code>:and</code>: <code>(sqlh/left-join [...] [:and [:= ...] [:= ...]])</code>.</z><z id="t1683288543" t="p-himik &gt; And yes, the query with AND statements is giving less execution time on average Intersting. Are there differences in actual plans? On my end, I can only see &quot;hash join&quot; vs &quot;hash right join&quot; and they don&apos;t result in any difference time-wise."><y>#</y><d>2023-05-05</d><h>12:09</h><r>p-himik</r>&gt; And yes, the query with AND statements is giving less execution time on average
Intersting. Are there differences in actual plans?
On my end, I can only see &quot;hash join&quot; vs &quot;hash right join&quot; and they don&apos;t result in any difference time-wise.</z><z id="t1683288644" t="p-himik Oh, hold on - in your case it&apos;s actually quite important because it&apos;s a left join and not an inner join. Putting the conditions in a different place will result in different results. Didn&apos;t happen on my end because there were always entries in the joined table for any row in the main table."><y>#</y><d>2023-05-05</d><h>12:10</h><r>p-himik</r>Oh, hold on - in your case it&apos;s actually quite important because it&apos;s a left join and not an inner join. Putting the conditions in a different place will result in different results. Didn&apos;t happen on my end because there were always entries in the joined table for any row in the main table.</z><z id="t1683288668" t="p-himik So, there shouldn&apos;t be a difference if you have an inner join - both result- and performance-wise."><y>#</y><d>2023-05-05</d><h>12:11</h><r>p-himik</r>So, there shouldn&apos;t be a difference if you have an inner join - both result- and performance-wise.</z><z id="t1683304102" t="Pratik (-&gt; (sqle/select* [:*]) (sqlh/from [:schemes :s]) (sqlh/left-join [:progress :p] [:= :p.scheme-id :s.id] [:and [:= :s.term 1]]) (sqlc/format)) [&quot;SELECT * FROM schemes s LEFT JOIN progress p ON p.scheme_id = s.id&quot;] that’s not working either, it seems like it’s just ignoring the end part"><y>#</y><d>2023-05-05</d><h>16:28</h><r>Pratik</r><pre>(-&gt; (sqle/select* [:*])
    (sqlh/from [:schemes :s])
    (sqlh/left-join [:progress :p] [:= :p.scheme-id :s.id] [:and [:= :s.term 1]]) 
    (sqlc/format))

[&quot;SELECT * FROM schemes s LEFT JOIN progress p ON p.scheme_id = s.id&quot;]</pre>
that’s not working either, it seems like it’s just ignoring the end part</z><z id="t1683304170" t="p-himik Why do you keep putting that original [:= ...] outside of the [:and ...] ?"><y>#</y><d>2023-05-05</d><h>16:29</h><r>p-himik</r>Why do you keep putting that original <code>[:= ...]</code> outside of the <code>[:and ...]</code>?</z><z id="t1683304196" t="p-himik It should be (sqlh/left-join [:progress :p] [:and [:= :p.scheme-id :s.id] [:= :s.term 1]]) ."><y>#</y><d>2023-05-05</d><h>16:29</h><r>p-himik</r>It should be <code>(sqlh/left-join [:progress :p] [:and [:= :p.scheme-id :s.id] [:= :s.term 1]])</code>.</z><z id="t1683304228" t="p-himik In other words, you need to be joining on :and , not on := ."><y>#</y><d>2023-05-05</d><h>16:30</h><r>p-himik</r>In other words, you need to be joining on <code>:and</code>, not on <code>:=</code>.</z><z id="t1683304252" t="Pratik I see, that worked!"><y>#</y><d>2023-05-05</d><h>16:30</h><r>Pratik</r>I see, that worked!</z><z id="t1683304272" t="Pratik Thanks a lot!"><y>#</y><d>2023-05-05</d><h>16:31</h><r>Pratik</r>Thanks a lot!</z><z id="t1684509280" t="Jakub Holý (HolyJak) Hi! How do I tell Honey that DEFAULT is a Postgres keyword and not a column name that should be quoted? This (-&gt; (hh/update table) (hh/set {:col :DEFAULT}) (honey.sql/format {:quoted true})) produces UPDATE &quot;snapshot&quot; SET &quot;col&quot; = &quot;DEFAULT&quot; while I need UPDATE &quot;snapshot&quot; SET &quot;col&quot; = DEFAULT . I did not find anything in the docs other than [:raw &quot;DEFAULT&quot;] . Is that it, or is there a better way? Thank you!"><y>#</y><d>2023-05-19</d><h>15:14</h><w>Jakub Holý (HolyJak)</w>Hi! How do I tell Honey that <code>DEFAULT</code> is a Postgres keyword and not a column name that should be quoted? This
<pre>(-&gt; (hh/update table)
      (hh/set {:col :DEFAULT})
      (honey.sql/format {:quoted true}))</pre>
produces <code>UPDATE &quot;snapshot&quot; SET &quot;col&quot; = &quot;DEFAULT&quot;</code> while I need <code>UPDATE &quot;snapshot&quot; SET &quot;col&quot; = DEFAULT</code> . I did not find anything in the docs other than <code>[:raw &quot;DEFAULT&quot;]</code> . Is that it, or is there a better way? Thank you!</z><z id="t1684509623" t="p-himik Try using [:default] instead of :DEFAULT ."><y>#</y><d>2023-05-19</d><h>15:20</h><r>p-himik</r>Try using <code>[:default]</code> instead of <code>:DEFAULT</code>.</z><z id="t1684509648" t="Jakub Holý (HolyJak) Doesn’t that produce default() which is a function call?"><y>#</y><d>2023-05-19</d><h>15:20</h><r>Jakub Holý (HolyJak)</r>Doesn’t that produce <code>default()</code> which is a function call?</z><z id="t1684509685" t="p-himik You&apos;re a single REPL execution away from checking. ;)"><y>#</y><d>2023-05-19</d><h>15:21</h><r>p-himik</r>You&apos;re a single REPL execution away from checking. ;)</z><z id="t1684509693" t="p-himik (sql/format {:update :t :set {:col [:default]}}) =&gt; [&quot;UPDATE t SET col = DEFAULT&quot;]"><y>#</y><d>2023-05-19</d><h>15:21</h><r>p-himik</r><pre>(sql/format {:update :t 
             :set    {:col [:default]}})
=&gt; [&quot;UPDATE t SET col = DEFAULT&quot;]</pre></z><z id="t1684509707" t="p-himik [...] is context-dependent."><y>#</y><d>2023-05-19</d><h>15:21</h><r>p-himik</r><code>[...]</code> is context-dependent.</z><z id="t1684509765" t="Jakub Holý (HolyJak) You are right. Sometimes I feel HoneySQL is too magic and beyond my understanding… 😅"><y>#</y><d>2023-05-19</d><h>15:22</h><r>Jakub Holý (HolyJak)</r>You are right. Sometimes I feel HoneySQL is too magic and beyond my understanding… <b>😅</b></z><z id="t1684509772" t="Jakub Holý (HolyJak) thanks a lot!"><y>#</y><d>2023-05-19</d><h>15:22</h><r>Jakub Holý (HolyJak)</r>thanks a lot!</z><z id="t1684509878" t="p-himik Addendum to my &quot;context-dependent&quot; message - [...] is also content-dependent. E.g. :default in a vector expands to DEFAULT but :x expands to x() . So in this case it&apos;s just that HoneySQL treats :default in a special way."><y>#</y><d>2023-05-19</d><h>15:24</h><r>p-himik</r>Addendum to my &quot;context-dependent&quot; message - <code>[...]</code> is also content-dependent.
E.g. <code>:default</code> in a vector expands to <code>DEFAULT</code> but <code>:x</code> expands to <code>x()</code>. So in this case it&apos;s just that HoneySQL treats <code>:default</code> in a special way.</z><z id="t1684512909" t="seancorfield I don&apos;t want to be that guy but... https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/getting-started/sql-special-syntax-#constraint-default-references has examples 🙂"><y>#</y><d>2023-05-19</d><h>16:15</h><r>seancorfield</r>I don&apos;t want to be that guy but... <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/getting-started/sql-special-syntax-#constraint-default-references" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/getting-started/sql-special-syntax-#constraint-default-references</a> has examples <b>🙂</b></z><z id="t1684512949" t="seancorfield But, yes, the docs for :update could certainly be beefed up..."><y>#</y><d>2023-05-19</d><h>16:15</h><r>seancorfield</r>But, yes, the docs for <code>:update</code> could certainly be beefed up...</z><z id="t1684513023" t="Jakub Holý (HolyJak) Ah, I have been on the page but haven&apos;t thought of searching it for default 😅"><y>#</y><d>2023-05-19</d><h>16:17</h><r>Jakub Holý (HolyJak)</r>Ah, I have been on the page but haven&apos;t thought of searching it for default <b>😅</b></z><z id="t1684513046" t="seancorfield Feel free to add notes to https://github.com/seancorfield/honeysql/issues/489"><y>#</y><d>2023-05-19</d><h>16:17</h><r>seancorfield</r>Feel free to add notes to <a href="https://github.com/seancorfield/honeysql/issues/489" target="_blank">https://github.com/seancorfield/honeysql/issues/489</a></z><z id="t1684687785" t="DrLjótsson Anyone aware of efforts to turn string SQL queries into honey sql? Via an AST maybe? This was my first hit when I googled for a sql parser https://github.com/JSQLParser/JSqlParser"><y>#</y><d>2023-05-21</d><h>16:49</h><w>DrLjótsson</w>Anyone aware of efforts to turn string SQL queries into honey sql? Via an AST maybe? This was my first hit when I googled for a sql parser <a href="https://github.com/JSQLParser/JSqlParser" target="_blank">https://github.com/JSQLParser/JSqlParser</a></z><z id="t1684688478" t="refset The XTDB 2.x SQL parser &amp; AST rewrite namespace might be a reasonable starting point for such a thing https://github.com/xtdb/xtdb/blob/2.x/core/src/main/clojure/xtdb/sql/plan.clj"><y>#</y><d>2023-05-21</d><h>17:01</h><r>refset</r>The XTDB 2.x SQL parser &amp; AST rewrite namespace might be a reasonable starting point for such a thing <a href="https://github.com/xtdb/xtdb/blob/2.x/core/src/main/clojure/xtdb/sql/plan.clj" target="_blank">https://github.com/xtdb/xtdb/blob/2.x/core/src/main/clojure/xtdb/sql/plan.clj</a></z><z id="t1684688638" t="refset Maybe something more simplistic could be built specifically for HoneySQL without needing the full semantic analysis machinery, but I wouldn&apos;t bet on it :thinking_face:"><y>#</y><d>2023-05-21</d><h>17:03</h><r>refset</r>Maybe something more simplistic could be built specifically for HoneySQL without needing the full semantic analysis machinery, but I wouldn&apos;t bet on it <b>:thinking_face:</b></z><z id="t1684688649" t="seancorfield It&apos;s been asked repeatedly over the years but SQL parsing is a massive effort -- as the XTDB folks know -- and completely out of scope for HoneySQL."><y>#</y><d>2023-05-21</d><h>17:04</h><r>seancorfield</r>It&apos;s been asked repeatedly over the years but SQL parsing is a massive effort -- as the XTDB folks know -- and completely out of scope for HoneySQL.</z><z id="t1684688733" t="seancorfield See https://github.com/seancorfield/honeysql/issues/182 for at least one thread on it -- and why an ANSI SQL parser alone is not sufficient."><y>#</y><d>2023-05-21</d><h>17:05</h><r>seancorfield</r>See <a href="https://github.com/seancorfield/honeysql/issues/182" target="_blank">https://github.com/seancorfield/honeysql/issues/182</a> for at least one thread on it -- and why an ANSI SQL parser alone is not sufficient.</z><z id="t1684689986" t="DrLjótsson Yeah, I see the issues with being dialect neutral. For me it would be a one-off thing to convert lots of pretty standard MySQL queries into HoneySQL. So I was interested in hearing if anyone has done something similar for migration rather than a general solution. "><y>#</y><d>2023-05-21</d><h>17:26</h><r>DrLjótsson</r>Yeah, I see the issues with being dialect neutral. For me it would be a one-off thing to convert lots of pretty standard MySQL queries into HoneySQL. So I was interested in hearing if anyone has done something similar for migration rather than a general solution. </z><z id="t1684711245" t="seancorfield I&apos;m not sure if anyone here is trying to use ClojureCLR but I just pushed some changes to HoneySQL to get at least basic compatibility in place... testing and feedback welcome!"><y>#</y><d>2023-05-21</d><h>23:20</h><w>seancorfield</w>I&apos;m not sure if anyone here is trying to use ClojureCLR but I just pushed some changes to HoneySQL to get at least basic compatibility in place... testing and feedback welcome!</z><z id="t1684754979" t="valerauko I&apos;m running into some trouble with using postgres enums. I have an user-defined type for an enum called user_status. I&apos;d want to use it from a query like this {:select [:*] :from [:users] :where [:= :status [:user-status input-value]]} where input-value is provided as a parameter. The problem is that quoted-snake doesn&apos;t seem to work (well) with this and generates WHERE (status = USER STATUS(&quot;...&quot;)) . It works fine if I use :user_status in the dsl. My options are :check :strict :quoted-snake true . Is there any way to achieve what I&apos;m trying to do?"><y>#</y><d>2023-05-22</d><h>11:29</h><w>valerauko</w>I&apos;m running into some trouble with using postgres enums. I have an user-defined type for an enum called user_status. I&apos;d want to use it from a query like this
<pre>{:select [:*]
 :from [:users]
 :where [:= :status [:user-status input-value]]}</pre>
where input-value is provided as a parameter. The problem is that quoted-snake doesn&apos;t seem to work (well) with this and generates <code>WHERE (status = USER STATUS(&quot;...&quot;))</code> . It works fine if I use <code>:user_status</code> in the dsl. My options are <code>:check :strict :quoted-snake true</code>.

Is there any way to achieve what I&apos;m trying to do?</z><z id="t1684755129" t="p-himik Why not simply use :user_status ?"><y>#</y><d>2023-05-22</d><h>11:32</h><r>p-himik</r>Why not simply use <code>:user_status</code>?</z><z id="t1684755428" t="p-himik This behavior is documented here: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/readme?q=function#functions And, as it says, you should also be able to use :&apos;user-status ."><y>#</y><d>2023-05-22</d><h>11:37</h><r>p-himik</r>This behavior is documented here: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/readme?q=function#functions" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1026/doc/readme?q=function#functions</a>

And, as it says, you should also be able to use <code>:&apos;user-status</code>.</z><z id="t1684757795" t="valerauko because i hoped to be able to use kebab-case everywhere. but i guess the ambiguity isn&apos;t worth it and i&apos;ll just make it a human-lint-rule to use snake_case for db-side stuff."><y>#</y><d>2023-05-22</d><h>12:16</h><r>valerauko</r>because i hoped to be able to use kebab-case everywhere. but i guess the ambiguity isn&apos;t worth it and i&apos;ll just make it a human-lint-rule to use snake_case for db-side stuff.</z><z id="t1684757946" t="p-himik HoneySQL distinguishes between - and _ - it&apos;s part of the DSL. I usually use kebab-case for schemas/tables/columns and snake-case for functions."><y>#</y><d>2023-05-22</d><h>12:19</h><r>p-himik</r>HoneySQL distinguishes between <code>-</code> and <code>_</code> - it&apos;s part of the DSL.
I usually use kebab-case for schemas/tables/columns and snake-case for functions.</z><z id="t1684857428" t="Jakub Holý (HolyJak) In my experience, transforming between kebab and other case is a nightmare. We use camelCase for columns, and I use them as-is in the code and the API. Otherwise I never knew whether at a particular point in code I was dealing with one or the other."><y>#</y><d>2023-05-23</d><h>15:57</h><r>Jakub Holý (HolyJak)</r>In my experience, transforming between kebab and other case is a nightmare. We use camelCase for columns, and I use them as-is in the code and the API. Otherwise I never knew whether at a particular point in code I was dealing with one or the other.</z><z id="t1684757917" t="valerauko Is the discrepancy between how honey.sql formats quoted-snake and how the next.jdbc built-in as-kebab-maps formats the results known? honey.sql (imo correctly) just replaces - with while camel-snake-kebab that next.jdbc uses inserts a - between different character classes too. I ran into this problem because I had an emailmd5 column that I could query as :email-md5 but the result would come out as :email-md-5"><y>#</y><d>2023-05-22</d><h>12:18</h><w>valerauko</w>Is the discrepancy between how honey.sql formats quoted-snake and how the next.jdbc built-in as-kebab-maps formats the results known?

honey.sql (imo correctly) just replaces - with  while camel-snake-kebab that next.jdbc uses inserts a - between different character classes too. I ran into this problem because I had an emailmd5 column that I could query as :email-md5 but the result would come out as :email-md-5</z><z id="t1684774340" t="seancorfield CSK is an external library that I don&apos;t control but people were commonly using it for round-tripping kebab -&gt; snake -&gt; kebab with next.jdbc so I decided to just depend on it and offer shortcuts to use it. I don&apos;t like using that conversion, personally, and prefer to just use snake case around the database -- you can always write your own builder if the CSK-based builder does not suit your needs."><y>#</y><d>2023-05-22</d><h>16:52</h><r>seancorfield</r>CSK is an external library that I don&apos;t control but people were commonly using it for round-tripping kebab -&gt; snake -&gt; kebab with <code>next.jdbc</code> so I decided to just depend on it and offer shortcuts to use it.

I don&apos;t like using that conversion, personally, and prefer to just use snake case around the database -- you can always write your own builder if the CSK-based builder does not suit your needs.</z><z id="t1684803054" t="valerauko yeah, i wrote a simple replace for this to work around the problem. it just felt weird that the &quot;built-in&quot; conversion worked on the querying side but not on the result side"><y>#</y><d>2023-05-23</d><h>00:50</h><r>valerauko</r>yeah, i wrote a simple replace for this to work around the problem. it just felt weird that the &quot;built-in&quot; conversion worked on the querying side but not on the result side</z><z id="t1684864722" t="Ben Lieberman I&apos;m getting this exception from the SQL Server JDBC driver com.microsoft.sqlserver.jdbc.SQLServerException: Incorrect syntax near the keyword &apos;WITH&apos;. The query itself is a simple CREATE TABLE statement that has no usages of WITH as far as I can see. I used honeysql to generate the query (including the :with-columns syntax) and that&apos;s the only thing I can think of that might be a problem here, but I don&apos;t see how. (I&apos;m also a SQL noob though.) Insights appreciated."><y>#</y><d>2023-05-23</d><h>17:58</h><w>Ben Lieberman</w>I&apos;m getting this exception from the SQL Server JDBC driver
<pre>com.microsoft.sqlserver.jdbc.SQLServerException: Incorrect syntax near the keyword &apos;WITH&apos;.</pre>
The query itself is a simple CREATE TABLE statement that has no usages of WITH as far as I can see. I used honeysql to generate the query (including the <code>:with-columns</code> syntax) and that&apos;s the only thing I can think of that might be a problem here, but I don&apos;t see how. (I&apos;m also a SQL noob though.) Insights appreciated.</z><z id="t1684868344" t="seancorfield Show us the HoneySQL calls and what they produce."><y>#</y><d>2023-05-23</d><h>18:59</h><r>seancorfield</r>Show us the HoneySQL calls and what they produce.</z><z id="t1684868442" t="seancorfield There are some examples in the docs which might help you: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#create-table-with-columns"><y>#</y><d>2023-05-23</d><h>19:00</h><r>seancorfield</r>There are some examples in the docs which might help you: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#create-table-with-columns" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#create-table-with-columns</a></z><z id="t1684869330" t="Ben Lieberman Stumbled on my own typo, actually. Thanks!"><y>#</y><d>2023-05-23</d><h>19:15</h><r>Ben Lieberman</r>Stumbled on my own typo, actually. Thanks!</z><z id="t1685032642" t="Ben Lieberman This is really throwing me for a loop bc I don&apos;t think this is invalid SQL...I&apos;m trying to do a batch insert but I get confusing and contradictory errors. If I try to insert just a few records it throws a syntax error, but if I try to insert the whole dataset (just 1000 rows) it says the parameter limit has been exceeded. Here are the basic functions I&apos;m using to work with the data (defn get-vals [m ^ObjectMapper mapper] (-&gt; m (update :col1 #(.writeValueAsString mapper %)) (update :col2 #(.writeValueAsString mapper %)))) (defn format-query [data] (-&gt; :table-name (h/insert-into (h/values (mapv (comp #(get-vals % om) #(update-keys % keyword) #(into {} %)) data))) (hsql/format {:quoted-snake true}))) (defn perform-insert! [data] (try (sql/query datasource (format-query data)) (catch SQLServerException e (.. e getSQLServerError getLineNumber)))) and the generated SQL looks like [&quot;INSERT INTO table (col1, col2...) values (?, ?, ...), (?, val1, val2, ...)&quot;]"><y>#</y><d>2023-05-25</d><h>16:37</h><w>Ben Lieberman</w>This is really throwing me for a loop bc I don&apos;t think this is invalid SQL...I&apos;m trying to do a batch insert but I get confusing and contradictory errors. If I try to insert just a few records it throws a syntax error, but if I try to insert the whole dataset (just 1000 rows) it says the parameter limit has been exceeded. Here are the basic functions I&apos;m using to work with the data
<pre>(defn get-vals
  [m ^ObjectMapper mapper]
  (-&gt; m 
      (update :col1 #(.writeValueAsString mapper %))
      (update :col2 #(.writeValueAsString mapper %))))

(defn format-query [data]
  (-&gt; :table-name 
      (h/insert-into (h/values (mapv (comp #(get-vals % om) 
                                           #(update-keys % keyword) 
                                           #(into {} %)) data)))
      (hsql/format {:quoted-snake true})))

(defn perform-insert! [data]
  (try (sql/query datasource (format-query data))
       (catch SQLServerException e
         (.. e getSQLServerError getLineNumber))))</pre>
and the generated SQL looks like <code>[&quot;INSERT INTO table (col1, col2...) values (?, ?, ...), (?, val1, val2, ...)&quot;]</code></z><z id="t1685032900" t="p-himik What does the syntax error say exactly?"><y>#</y><d>2023-05-25</d><h>16:41</h><r>p-himik</r>What does the syntax error say exactly?</z><z id="t1685032990" t="Ben Lieberman Just this &quot;Incorrect syntax near &apos;,&apos;.&quot; unfortunately"><y>#</y><d>2023-05-25</d><h>16:43</h><r>Ben Lieberman</r>Just this <code>&quot;Incorrect syntax near &apos;,&apos;.&quot;</code> unfortunately</z><z id="t1685033006" t="seancorfield What database?"><y>#</y><d>2023-05-25</d><h>16:43</h><r>seancorfield</r>What database?</z><z id="t1685033015" t="Ben Lieberman SQL Server"><y>#</y><d>2023-05-25</d><h>16:43</h><r>Ben Lieberman</r>SQL Server</z><z id="t1685033107" t="Ben Lieberman and this is the other error I get if I try to insert the whole dataset &quot;The incoming tabular data stream (TDS) remote procedure call (RPC) protocol stream is incorrect. Too many parameters were provided in this RPC request. The maximum is 2100.&quot;"><y>#</y><d>2023-05-25</d><h>16:45</h><r>Ben Lieberman</r>and this is the other error I get if I try to insert the whole dataset
<pre>&quot;The incoming tabular data stream (TDS) remote procedure call (RPC) protocol stream is incorrect. Too many parameters were provided in this RPC request. The maximum is 2100.&quot;</pre></z><z id="t1685033182" t="seancorfield Yeah, you need a batch insert to get around that (`next.jdbc/execute-batch!` helps)"><y>#</y><d>2023-05-25</d><h>16:46</h><r>seancorfield</r>Yeah, you need a batch insert to get around that (`next.jdbc/execute-batch!` helps)</z><z id="t1685201151" t="Nazral Hi! How can I do json_group_array(table.col) AS foo with honeysql ?"><y>#</y><d>2023-05-27</d><h>15:25</h><w>Nazral</w>Hi! How can I do <code>json_group_array(table.col) AS foo</code> with honeysql ?</z><z id="t1685201216" t="Nazral the AS part I got it no problem, but the json_group_array"><y>#</y><d>2023-05-27</d><h>15:26</h><w>Nazral</w>the <code>AS</code> part I got it no problem, but the <code>json_group_array</code></z><z id="t1685201245" t="p-himik (sql/format {:select [[[:json_group_array :table/col] :foo]]} ) =&gt; [&quot;SELECT JSON_GROUP_ARRAY(table.col) AS foo&quot;]"><y>#</y><d>2023-05-27</d><h>15:27</h><r>p-himik</r><pre>(sql/format {:select [[[:json_group_array :table/col] :foo]]} )
=&gt; [&quot;SELECT JSON_GROUP_ARRAY(table.col) AS foo&quot;]</pre></z><z id="t1685201262" t="Nazral Thanks a lot !"><y>#</y><d>2023-05-27</d><h>15:27</h><r>Nazral</r>Thanks a lot !</z><z id="t1685453341" t="Akiz Hi, why does honeysql formats at? with two question marks? (hsql/format [pg-ops/at? [:-&gt; :a :b] &quot;something&quot;] {:inline true}) =&gt; [&quot;(a -&gt; b) @?? &apos;something&apos;&quot;]"><y>#</y><d>2023-05-30</d><h>13:29</h><w>Akiz</w>Hi, why does honeysql formats <code>at?</code>  with two question marks?
<code>(hsql/format [pg-ops/at? [:-&gt; :a :b] &quot;something&quot;] {:inline true})</code>
<code>=&gt; [&quot;(a -&gt; b) @?? &apos;something&apos;&quot;]</code></z><z id="t1685453438" t="p-himik That seems like an escape sequence. A single ? is a parameter, and ?? is a literal ? , perhaps."><y>#</y><d>2023-05-30</d><h>13:30</h><r>p-himik</r>That seems like an escape sequence. A single <code>?</code> is a parameter, and <code>??</code> is a literal <code>?</code>, perhaps.</z><z id="t1685453456" t="p-himik Unless it doesn&apos;t work?.."><y>#</y><d>2023-05-30</d><h>13:30</h><r>p-himik</r>Unless it doesn&apos;t work?..</z><z id="t1685453833" t="Akiz DBeaver considers it as an input parameter with one and two question marks. If the interpretation of ? as an input parameter is turned off, both versions work the same."><y>#</y><d>2023-05-30</d><h>13:37</h><r>Akiz</r>DBeaver considers it as an input parameter with one and two question marks.
If the interpretation of ? as an input parameter is turned off, both versions work the same.</z><z id="t1685459559" t="p-himik Yeah, I wouldn&apos;t compare a string designed to be prepared with JDBC to something that DBeaver expects. There can be all sorts of potential differences. If that @?? works just fine, then all is well. If it doesn&apos;t, then it should be an issue for HoneySQL."><y>#</y><d>2023-05-30</d><h>15:12</h><r>p-himik</r>Yeah, I wouldn&apos;t compare a string designed to be prepared with JDBC to something that DBeaver expects. There can be all sorts of potential differences.

If that <code>@??</code> works just fine, then all is well. If it doesn&apos;t, then it should be an issue for HoneySQL.</z><z id="t1685464108" t="seancorfield Yes, ?? is an escaped ? for JDBC."><y>#</y><d>2023-05-30</d><h>16:28</h><r>seancorfield</r>Yes, <code>??</code> is an escaped <code>?</code> for JDBC.</z><z id="t1685510522" t="Akiz [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] Sure, but it would be nice to have it there ))."><y>#</y><d>2023-05-31</d><h>05:22</h><r>Akiz</r><a>@U2FRKM4TW</a> Sure, but it would be nice to have it there )).</z><z id="t1685511763" t="seancorfield The goal of HoneySQL is primarily to produce a vector of SQL + params for use with clojure.java.jdbc or next.jdbc . If you use its output for something else, you may well need to make some adjustments."><y>#</y><d>2023-05-31</d><h>05:42</h><r>seancorfield</r>The goal of HoneySQL is primarily to produce a vector of SQL + params for use with <code>clojure.java.jdbc</code> or <code>next.jdbc</code>. If you use its output for something else, you may well need to make some adjustments.</z><z id="t1685547361" t="slipset Given that bar is a jsonb column and I would like to update its value to set it to the empty dictionary: {:update :foo :set {:bar {}}} Running this through honey/format gives: &gt; (honey/format {:update :foo :set {:bar {}}}) ;; =&gt; [&quot;UPDATE foo SET bar = ()&quot;] But this makes postgres unhappy. Clues?"><y>#</y><d>2023-05-31</d><h>15:36</h><w>slipset</w>Given that <code>bar</code> is a jsonb column and I would like to update its value to set it to the empty dictionary:
<pre>{:update :foo :set {:bar {}}}</pre>
Running this through honey/format gives:
<pre>&gt; (honey/format {:update :foo :set {:bar {}}})
;; =&gt; [&quot;UPDATE foo SET bar = ()&quot;]</pre>
But this makes postgres unhappy.
Clues?</z><z id="t1685548162" t="slipset [:lift {}] works 🙂"><y>#</y><d>2023-05-31</d><h>15:49</h><r>slipset</r><code>[:lift {}]</code> works <b>🙂</b></z><z id="t1685549786" t="seancorfield I was just about to link you to the docs about working with PG &amp; JSON that mentions :lift 🙂"><y>#</y><d>2023-05-31</d><h>16:16</h><r>seancorfield</r>I was just about to link you to the docs about working with PG &amp; JSON that mentions <code>:lift</code> <b>🙂</b></z><z id="t1685549817" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/postgresql-support#jsonjsonb"><y>#</y><d>2023-05-31</d><h>16:16</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/postgresql-support#jsonjsonb" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/postgresql-support#jsonjsonb</a></z><z id="t1685731378" t="Samuel Ludwig attempting to create a multi-insert-on-duplicate-update mysql statement in the form of INSERT INTO beautiful (name, age) VALUES (&apos;Helen&apos;, 24), (&apos;Katrina&apos;, 21), (&apos;Samia&apos;, 22), (&apos;Hui Ling&apos;, 25), (&apos;Yumie&apos;, 29) AS newvals ON DUPLICATE KEY UPDATE age = newvals.age ... and am trying to understand what I might need to get that newvals values &quot;alias&quot; to generate I feel like I&apos;m close, this is what I&apos;ve got so far: (def csvrows &apos;([&quot;id&quot; &quot;c1&quot; &quot;c2&quot;] [1 &quot;two&quot; &quot;four&quot;] [2 &quot;five&quot; &quot;six&quot;])) (let [cols (first csvrows)] (-&gt; (insert-into :mytable) (with-columns cols) (values (rest csvrows)) (on-duplicate-key-update (zipmap cols (map (fn [x] (str &quot;newvals.&quot; x)) cols))) (sql/format {:dialect :mysql})))) Which produces [&quot;INSERT INTO `mytable` (?, ?, ?) VALUES (?, ?, ?), (?, ?, ?) ON DUPLICATE KEY UPDATE `id` = ?, `c1` = ?, `c2` = ?&quot; &quot;id&quot; &quot;c1&quot; &quot;c2&quot; 1 &quot;two&quot; &quot;four&quot; 2 &quot;five&quot; &quot;six&quot; &quot;newvals.id&quot; &quot;newvals.c1&quot; &quot;newvals.c2&quot;]"><y>#</y><d>2023-06-02</d><h>18:42</h><w>Samuel Ludwig</w>attempting to create a multi-insert-on-duplicate-update mysql statement in the form of

<pre>INSERT INTO beautiful (name, age)
    VALUES
    (&apos;Helen&apos;, 24),
    (&apos;Katrina&apos;, 21),
    (&apos;Samia&apos;, 22),
    (&apos;Hui Ling&apos;, 25),
    (&apos;Yumie&apos;, 29)
    AS newvals
ON DUPLICATE KEY UPDATE
    age = newvals.age
    ...</pre>
and am trying to understand what I might need to get that <code>newvals</code> values &quot;alias&quot; to generate

I feel like I&apos;m close, this is what I&apos;ve got so far:

<pre>(def csvrows &apos;([&quot;id&quot; &quot;c1&quot; &quot;c2&quot;] [1 &quot;two&quot; &quot;four&quot;] [2 &quot;five&quot; &quot;six&quot;]))
  (let [cols (first csvrows)]
    (-&gt; (insert-into :mytable)
        (with-columns cols)
        (values (rest csvrows))
        (on-duplicate-key-update (zipmap cols (map (fn [x] (str &quot;newvals.&quot; x)) cols)))
        (sql/format {:dialect :mysql}))))</pre>
Which produces
<pre>[&quot;INSERT INTO `mytable` (?, ?, ?) 
  VALUES (?, ?, ?), (?, ?, ?) 
  ON DUPLICATE KEY UPDATE 
  `id` = ?, `c1` = ?, `c2` = ?&quot; 
 &quot;id&quot; &quot;c1&quot; &quot;c2&quot; 
 1 &quot;two&quot; &quot;four&quot; 
 2 &quot;five&quot; &quot;six&quot; 
 &quot;newvals.id&quot; &quot;newvals.c1&quot; &quot;newvals.c2&quot;]</pre></z><z id="t1685741139" t="p-himik Use keywords instead of strings for identifiers such as table, column, or function names."><y>#</y><d>2023-06-02</d><h>21:25</h><r>p-himik</r>Use keywords instead of strings for identifiers such as table, column, or function names.</z><z id="t1685741178" t="p-himik For qualified identifiers, use either a dot directly or / , so either :newvals.age or :newvals/age . Nowadays, I myself prefer the latter."><y>#</y><d>2023-06-02</d><h>21:26</h><r>p-himik</r>For qualified identifiers, use either a dot directly or <code>/</code>, so either <code>:newvals.age</code> or <code>:newvals/age</code>. Nowadays, I myself prefer the latter.</z><z id="t1685742581" t="p-himik And if you need to construct such keywords at run time, it&apos;s easy to do with (keyword &quot;newvals&quot; &quot;age&quot;) ."><y>#</y><d>2023-06-02</d><h>21:49</h><r>p-himik</r>And if you need to construct such keywords at run time, it&apos;s easy to do with <code>(keyword &quot;newvals&quot; &quot;age&quot;)</code>.</z><z id="t1685757082" t="seancorfield [:attrs {:href &quot;/_/_/users/U0482NW9KL1&quot;}] did that answer your question? I&apos;m not sure how you can create an alias in that position, mainly because I&apos;m not sure which part of the statement the alias belongs to - I&apos;ve never seen it in that position before."><y>#</y><d>2023-06-03</d><h>01:51</h><r>seancorfield</r><a>@U0482NW9KL1</a> did that answer your question? I&apos;m not sure how you can create an alias in that position, mainly because I&apos;m not sure which part of the statement the alias belongs to - I&apos;ve never seen it in that position before.</z><z id="t1685762342" t="Samuel Ludwig apologies, i was left without computer access soon after tossing out that question :^) and that was a stack-overflow recommended solution for the case where one might want to make an INSERT+ON DUPLICATE KEY UPDATE on multiple inserts/rows at once, where in the case of a duplicate key, I&apos;d want all values for that row to be updated to the new ones"><y>#</y><d>2023-06-03</d><h>03:19</h><r>Samuel Ludwig</r>apologies, i was left without computer access soon after tossing out that question :^)

and that was a stack-overflow recommended solution for the case where one might want to make an <code>INSERT+ON DUPLICATE KEY UPDATE</code> on multiple inserts/rows at once, where in the case of a duplicate key, I&apos;d want all values for that row to be updated to the new ones</z><z id="t1685762439" t="Samuel Ludwig SO post for reference: https://stackoverflow.com/questions/2714587/mysql-on-duplicate-key-update-for-multiple-rows-insert-in-single-query"><y>#</y><d>2023-06-03</d><h>03:20</h><r>Samuel Ludwig</r>SO post for reference: <a href="https://stackoverflow.com/questions/2714587/mysql-on-duplicate-key-update-for-multiple-rows-insert-in-single-query" target="_blank">https://stackoverflow.com/questions/2714587/mysql-on-duplicate-key-update-for-multiple-rows-insert-in-single-query</a></z><z id="t1685762802" t="Samuel Ludwig i haven&apos;t gotten the chance to test himik&apos;s solution yet, but I don&apos;t think its exactly what im looking for"><y>#</y><d>2023-06-03</d><h>03:26</h><r>Samuel Ludwig</r>i haven&apos;t gotten the chance to test himik&apos;s solution yet, but I don&apos;t think its exactly what im looking for</z><z id="t1685765428" t="seancorfield OK, keep us posted..."><y>#</y><d>2023-06-03</d><h>04:10</h><r>seancorfield</r>OK, keep us posted...</z><z id="t1686140103" t="Pratik Is there a way to turn (sql/raw (str &quot;(p.date + s.term - INTERVAL &apos;1 DAY&apos;)::DATE&quot;)) into sql/call forms with type conversion as well? I am using honeysql 1.x version."><y>#</y><d>2023-06-07</d><h>12:15</h><w>Pratik</w>Is there a way to turn
<pre>(sql/raw (str &quot;(p.date + s.term - INTERVAL &apos;1 DAY&apos;)::DATE&quot;))</pre>
into <code>sql/call</code> forms with type conversion as well?
I am using honeysql 1.x version.</z><z id="t1686145855" t="p-himik Not sure what you mean. Why would you need to change the above if it works? Also, there&apos;s no need for that str since the argument is already a string."><y>#</y><d>2023-06-07</d><h>13:50</h><r>p-himik</r>Not sure what you mean. Why would you need to change the above if it works?
Also, there&apos;s no need for that <code>str</code> since the argument is already a string.</z><z id="t1686145885" t="p-himik Just in case, you can convert types by calling the cast function, at least in PostgreSQL."><y>#</y><d>2023-06-07</d><h>13:51</h><r>p-himik</r>Just in case, you can convert types by calling the <code>cast</code> function, at least in PostgreSQL.</z><z id="t1686219520" t="igrishaev I&apos;m trying to build a query with CTE that carries VALUES: with vals (a, b) as ( values (1, 2), (3, 4) ) select table.* from table join vals on ... here is what I&apos;ve got in my code: {:with [ [[:vals {:columns [:foo :bar]}] {:values [{:foo 1 :bar 2} {:foo 1 :bar 2}]}] ] :select [:*] :from [:events] :join [:vals [:= :foo.bar :events.test]] } which gives &quot;WITH vals (foo, bar) AS ((foo, bar) VALUES (?, ?), (?, ?)) SELECT * FROM events... the problem is, I cannot get rid from the second (foo, bar) in front of VALUES. How can I do this?"><y>#</y><d>2023-06-08</d><h>10:18</h><w>igrishaev</w>I&apos;m trying to build a query with CTE that carries VALUES:
<pre>with vals (a, b) as (
  values (1, 2),
         (3, 4)
) 
select table.*
from table join vals on ...</pre>
here is what I&apos;ve got in my code:
<pre>{:with 
   [
    [[:vals {:columns [:foo :bar]}]
     {:values [{:foo 1 :bar 2} {:foo 1 :bar 2}]}]
    ]
   :select [:*]
   :from [:events]
   :join
   [:vals [:= :foo.bar :events.test]]
   }</pre>
which gives
<pre>&quot;WITH vals (foo, bar) AS ((foo, bar) VALUES (?, ?), (?, ?)) 
SELECT * FROM events...</pre>
the problem is, I cannot get rid from the second <code>(foo, bar)</code> in front of VALUES. How can I do this?</z><z id="t1686219846" t="igrishaev ah, it must have been arrays: {:values [[1 2] [3 4]]}"><y>#</y><d>2023-06-08</d><h>10:24</h><r>igrishaev</r>ah, it must have been arrays:
<pre>{:values [[1 2] [3 4]]}</pre></z><z id="t1686249799" t="seancorfield There is an example in the docs: You can use a VALUES clause in the CTE: user=&gt; (sql/format {:with [[[:stuff {:columns [:id :name]}] {:values [[1 &quot;Sean&quot;] [2 &quot;Jay&quot;]]}]] :select [:id :name] :from [:stuff]}) [&quot;WITH stuff (id, name) AS (VALUES (?, ?), (?, ?)) SELECT id, name FROM stuff&quot; 1 &quot;Sean&quot; 2 &quot;Jay&quot;] from https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#with-with-recursive"><y>#</y><d>2023-06-08</d><h>18:43</h><r>seancorfield</r>There is an example in the docs:
<pre>You can use a VALUES clause in the CTE:

user=&gt; (sql/format {:with [[[:stuff {:columns [:id :name]}]
                            {:values [[1 &quot;Sean&quot;] [2 &quot;Jay&quot;]]}]]
                    :select [:id :name]
                    :from [:stuff]})
[&quot;WITH stuff (id, name) AS (VALUES (?, ?), (?, ?)) SELECT id, name FROM stuff&quot; 1 &quot;Sean&quot; 2 &quot;Jay&quot;]</pre>
from <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#with-with-recursive" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started/sql-clause-reference#with-with-recursive</a></z><z id="t1686250109" t="igrishaev Yeah I missed it somehow. Thank you!"><y>#</y><d>2023-06-08</d><h>18:48</h><r>igrishaev</r>Yeah I missed it somehow. Thank you!</z><z id="t1686251054" t="seancorfield NP. Your Q made me wonder if I&apos;d omitted that from the docs, so I needed to check. I guess it could also state explicitly that you can&apos;t use the vector-of-maps version of :values ..."><y>#</y><d>2023-06-08</d><h>19:04</h><r>seancorfield</r>NP. Your Q made me wonder if I&apos;d omitted that from the docs, so I needed to check. I guess it could also state explicitly that you can&apos;t use the vector-of-maps version of <code>:values</code>...</z><z id="t1686251140" t="seancorfield https://github.com/seancorfield/honeysql/issues/493"><y>#</y><d>2023-06-08</d><h>19:05</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/493" target="_blank">https://github.com/seancorfield/honeysql/issues/493</a></z><z id="t1686773878" t="Nazral Hi! Is there a way to specify a create table foo (...) strict (for https://www.sqlite.org/stricttables.html ) with honeysql helpers ?"><y>#</y><d>2023-06-14</d><h>20:17</h><w>Nazral</w>Hi! Is there a way to specify a <code>create table foo (...) strict</code> (for <a href="https://www.sqlite.org/stricttables.html" target="_blank">https://www.sqlite.org/stricttables.html</a>) with honeysql helpers ?</z><z id="t1686774391" t="p-himik (sql/format {:create-table [:t {:columns [:foo :bar :baz]} [:strict]]}) =&gt; [&quot;CREATE TABLE t (foo, bar, baz) STRICT&quot;]"><y>#</y><d>2023-06-14</d><h>20:26</h><r>p-himik</r><pre>(sql/format {:create-table [:t
                            {:columns [:foo :bar :baz]}
                            [:strict]]})
=&gt; [&quot;CREATE TABLE t (foo, bar, baz) STRICT&quot;]</pre></z><z id="t1686774454" t="Nazral right, thank you 👍 so no helper for this case"><y>#</y><d>2023-06-14</d><h>20:27</h><r>Nazral</r>right, thank you <b>👍</b> so no helper for this case</z><z id="t1686774466" t="Nazral (like with-columns or such)"><y>#</y><d>2023-06-14</d><h>20:27</h><r>Nazral</r>(like <code>with-columns</code> or such)</z><z id="t1686777140" t="seancorfield The syntax that can be supported there is pretty random and it&apos;s database specific so it&apos;s not worth trying to design a helper for it. DDL in general is mostly too unstructured for helpers to improve things. (sql/format (update table-ddl :create-table conj [:strict])) 🙂"><y>#</y><d>2023-06-14</d><h>21:12</h><r>seancorfield</r>The syntax that can be supported there is pretty random and it&apos;s database specific so it&apos;s not worth trying to design a helper for it. DDL in general is mostly too unstructured for helpers to improve things.

<code>(sql/format (update table-ddl :create-table conj [:strict]))</code> <b>🙂</b></z><z id="t1686779388" t="Nazral thanks for the help"><y>#</y><d>2023-06-14</d><h>21:49</h><r>Nazral</r>thanks for the help</z><z id="t1686815323" t="orestis How could I generate this syntax? (Postgres array access subscript): select eb.post_ids[1] from eb;"><y>#</y><d>2023-06-15</d><h>07:48</h><w>orestis</w>How could I generate this syntax? (Postgres array access subscript):
<pre>select eb.post_ids[1] from eb;</pre></z><z id="t1686815354" t="orestis I&apos;m interested mainly in tacking the [1] array subscript to any column in a select..."><y>#</y><d>2023-06-15</d><h>07:49</h><r>orestis</r>I&apos;m interested mainly in tacking the <code>[1]</code> array subscript to any column in a select...</z><z id="t1686819220" t="p-himik I&apos;m surprised I can&apos;t find anything on it, anywhere. Also surprised that I have never had a need for it myself. I&apos;d probably add a custom function/operator and make a PR for HoneySQL."><y>#</y><d>2023-06-15</d><h>08:53</h><r>p-himik</r>I&apos;m surprised I can&apos;t find anything on it, anywhere. Also surprised that I have never had a need for it myself.

I&apos;d probably add a custom function/operator and make a PR for HoneySQL.</z><z id="t1686841194" t="seancorfield I&apos;d be happy to add something like [:ix :col index-expr] =&gt; col[index-expr] but the name needs some consideration + tests + docs."><y>#</y><d>2023-06-15</d><h>14:59</h><r>seancorfield</r>I&apos;d be happy to add something like <code>[:ix :col index-expr]</code> =&gt; <code>col[index-expr]</code> but the name needs some consideration + tests + docs.</z><z id="t1686849767" t="orestis is :[] a valid clojure keyword, I wonder?"><y>#</y><d>2023-06-15</d><h>17:22</h><r>orestis</r>is <code>:[]</code> a valid clojure keyword, I wonder?</z><z id="t1686849855" t="orestis No, it&apos;s not 😄"><y>#</y><d>2023-06-15</d><h>17:24</h><r>orestis</r>No, it&apos;s not <b>😄</b></z><z id="t1686849896" t="orestis The col must also be a col-expr"><y>#</y><d>2023-06-15</d><h>17:24</h><r>orestis</r>The col must also be a <code>col-expr</code></z><z id="t1686849933" t="orestis At least in my case, the I ended up doing [:raw &quot;(array_agg(timestamp))[1] as timestamp&quot;] "><y>#</y><d>2023-06-15</d><h>17:25</h><r>orestis</r>At least in my case, the I ended up doing
<pre>[:raw &quot;(array_agg(timestamp))[1] as timestamp&quot;]</pre>
</z><z id="t1686849945" t="orestis I needed to also wrap the col-expr with parentheses"><y>#</y><d>2023-06-15</d><h>17:25</h><r>orestis</r>I needed to also wrap the <code>col-expr</code> with parentheses</z><z id="t1686849947" t="p-himik PG-related parts of HoneySQL use things like (def at&gt; (keyword &quot;@&gt;&quot;)) ."><y>#</y><d>2023-06-15</d><h>17:25</h><r>p-himik</r>PG-related parts of HoneySQL use things like <code>(def at&gt; (keyword &quot;@&gt;&quot;))</code>.</z><z id="t1686852760" t="seancorfield Good point about needing ( .. ) if you have a col-expr. Does PG allow (col)[1] or are parens only allowed for an expression there? (I never use PG so I&apos;ve no idea how fussy it is)"><y>#</y><d>2023-06-15</d><h>18:12</h><r>seancorfield</r>Good point about needing <code>(</code> .. <code>)</code> if you have a col-expr. Does PG allow <code>(col)[1]</code> or are parens only allowed for an expression there? (I never use PG so I&apos;ve no idea how fussy it is)</z><z id="t1686853577" t="orestis initial testing shows that parenthesis are allowed everywhere, even for a single col"><y>#</y><d>2023-06-15</d><h>18:26</h><r>orestis</r>initial testing shows that parenthesis are allowed everywhere, even for a single col</z><z id="t1686853583" t="orestis they are required for most everything else"><y>#</y><d>2023-06-15</d><h>18:26</h><r>orestis</r>they are required for most everything else</z><z id="t1687249494" t="Jakub Holý (HolyJak) Hello again! I am at a loss, again 😅 How do I generate ... ON CONFLICT (date_trunc(&apos;month&apos;, &quot;my_column&quot;)) DO ... ? https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/api/honey.sql.helpers?q=on-conf#on-conflict does not help me… 🙏 🙏 🙏"><y>#</y><d>2023-06-20</d><h>08:24</h><w>Jakub Holý (HolyJak)</w>Hello again! I am at a loss, again <b>😅</b> How do I generate
<pre>... ON CONFLICT (date_trunc(&apos;month&apos;, &quot;my_column&quot;)) DO  ...</pre>
? <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/api/honey.sql.helpers?q=on-conf#on-conflict" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/api/honey.sql.helpers?q=on-conf#on-conflict</a> does not help me… <b>🙏</b> <b>🙏</b> <b>🙏</b></z><z id="t1687249930" t="p-himik Doesn&apos;t seem like there&apos;s a way to do it without putting the whole ON CONFLICT into :raw , so might be something that warrants HoneySQL&apos;s DSL extension."><y>#</y><d>2023-06-20</d><h>08:32</h><r>p-himik</r>Doesn&apos;t seem like there&apos;s a way to do it without putting the whole <code>ON CONFLICT</code> into <code>:raw</code>, so might be something that warrants HoneySQL&apos;s DSL extension.</z><z id="t1687286876" t="seancorfield [:attrs {:href &quot;/_/_/users/U0522TWDA&quot;}] I&apos;m fixing this so that this works: user=&gt; (sql/format {:on-conflict [[:date_trunc [:inline &quot;month&quot;] :my_column]]} {:quoted true}) [&quot;ON CONFLICT DATE_TRUNC(&apos;month&apos;, \&quot;my_column\&quot;)&quot;]"><y>#</y><d>2023-06-20</d><h>18:47</h><r>seancorfield</r><a>@U0522TWDA</a> I&apos;m fixing this so that this works:
<pre>user=&gt; (sql/format {:on-conflict [[:date_trunc [:inline &quot;month&quot;] :my_column]]} {:quoted true})
[&quot;ON CONFLICT DATE_TRUNC(&apos;month&apos;, \&quot;my_column\&quot;)&quot;]</pre></z><z id="t1687286935" t="seancorfield Does it specifically need those ( .. ) around the expression to be valid syntax?"><y>#</y><d>2023-06-20</d><h>18:48</h><r>seancorfield</r>Does it specifically need those <code>(</code> .. <code>)</code> around the expression to be valid syntax?</z><z id="t1687288169" t="seancorfield https://github.com/seancorfield/honeysql/issues/494 (I&apos;m going to assume it does need the parens)."><y>#</y><d>2023-06-20</d><h>19:09</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/494" target="_blank">https://github.com/seancorfield/honeysql/issues/494</a> (I&apos;m going to assume it does need the parens).</z><z id="t1687288392" t="p-himik It does, yeah."><y>#</y><d>2023-06-20</d><h>19:13</h><r>p-himik</r>It does, yeah.</z><z id="t1687288546" t="seancorfield Here&apos;s how it works now on the latest develop or the latest SNAPSHOT on Clojars: user=&gt; (sql/format {:on-conflict [:a [:date_trunc [:inline &quot;month&quot;] :my_column] :b]} {:quoted true}) [&quot;ON CONFLICT (\&quot;a\&quot;, DATE_TRUNC(&apos;month&apos;, \&quot;my_column\&quot;), \&quot;b\&quot;)&quot;]"><y>#</y><d>2023-06-20</d><h>19:15</h><r>seancorfield</r>Here&apos;s how it works now on the latest develop or the latest SNAPSHOT on Clojars:
<pre>user=&gt; (sql/format {:on-conflict [:a [:date_trunc [:inline &quot;month&quot;] :my_column] :b]} {:quoted true})
[&quot;ON CONFLICT (\&quot;a\&quot;, DATE_TRUNC(&apos;month&apos;, \&quot;my_column\&quot;), \&quot;b\&quot;)&quot;]</pre></z><z id="t1687288604" t="seancorfield I&apos;ll cut a new release before the end of the month. Not sure what else I&apos;ll end up fixing in that release right now."><y>#</y><d>2023-06-20</d><h>19:16</h><r>seancorfield</r>I&apos;ll cut a new release before the end of the month. Not sure what else I&apos;ll end up fixing in that release right now.</z><z id="t1687289701" t="p-himik Not sure how to test it properly given that I can&apos;t use date_trunc in ON CONFLICT without also creating an index on it, and I can&apos;t create an index on it because the function is not marked as immutable. But given the syntax description of INSERT , it seems that you need an extra pair of parents around expressions in ON CONFLICT . Just tried it with col + 1 expression instead of date_trunc - yep, needs extra parens, so the above should be formatted as ON CONFLICT (&quot;a&quot;, (DATE_TRUNC(&apos;month&apos;, &quot;my_column&quot;)), &quot;b&quot;) . If it&apos;s any help, at least in the case of PostgreSQL the whole part after ON CONFLICT follows the CREATE INDEX format as per the docs."><y>#</y><d>2023-06-20</d><h>19:35</h><r>p-himik</r>Not sure how to test it properly given that I can&apos;t use <code>date_trunc</code> in <code>ON CONFLICT</code> without also creating an index on it, and I can&apos;t create an index on it because the function is not marked as immutable.
But given the syntax description of <code>INSERT</code>, it seems that you need an extra pair of parents around expressions in <code>ON CONFLICT</code>.

Just tried it with <code>col + 1</code> expression instead of <code>date_trunc</code> - yep, needs extra parens, so the above should be formatted as <code>ON CONFLICT (&quot;a&quot;, (DATE_TRUNC(&apos;month&apos;, &quot;my_column&quot;)), &quot;b&quot;)</code>.

If it&apos;s any help, at least in the case of PostgreSQL the whole part after <code>ON CONFLICT</code> follows the <code>CREATE INDEX</code> format as per the docs.</z><z id="t1687290692" t="seancorfield Oh, interesting... it needs parens inside the group too??"><y>#</y><d>2023-06-20</d><h>19:51</h><r>seancorfield</r>Oh, interesting... it needs parens inside the group too??</z><z id="t1687290710" t="seancorfield (and, no, matching create index doesn&apos;t help at all 🙂 )"><y>#</y><d>2023-06-20</d><h>19:51</h><r>seancorfield</r>(and, no, matching <code>create index</code> doesn&apos;t help at all <b>🙂</b> )</z><z id="t1687290916" t="p-himik Yeah, otherwise stuff like INSERT INTO t VALUES (1) ON CONFLICT (d + 1) DO NOTHING; fails with ERROR: syntax error at or near &quot;+&quot; Position: 41 . Using ((d + 1)) works."><y>#</y><d>2023-06-20</d><h>19:55</h><r>p-himik</r>Yeah, otherwise stuff like <code>INSERT INTO t VALUES (1) ON CONFLICT (d + 1) DO NOTHING;</code> fails with <code>ERROR: syntax error at or near &quot;+&quot; Position: 41</code>. Using <code>((d + 1))</code> works.</z><z id="t1687291428" t="seancorfield Fix pushed to GH. A new SNAPSHOT will be available &quot;soon&quot;."><y>#</y><d>2023-06-20</d><h>20:03</h><r>seancorfield</r>Fix pushed to GH. A new SNAPSHOT will be available &quot;soon&quot;.</z><z id="t1687327715" t="Jakub Holý (HolyJak) Sorry for the late reply. I see you figured everything out. Many thanks to both of you! I&apos;ll try the snapshot ASAP"><y>#</y><d>2023-06-21</d><h>06:08</h><r>Jakub Holý (HolyJak)</r>Sorry for the late reply. I see you figured everything out. Many thanks to both of you!
I&apos;ll try the snapshot ASAP</z><z id="t1687352260" t="Jakub Holý (HolyJak) It works like a charm! thank you!"><y>#</y><d>2023-06-21</d><h>12:57</h><r>Jakub Holý (HolyJak)</r>It works like a charm! thank you!</z><z id="t1687562136" t="seancorfield A discussion I had today (elsewhere) made me wonder if I could make the quoted symbolic form of HoneySQL queries easier to use. You can write &apos;{select * from users where (= status &quot;approved&quot;)} today and it formats the same as the (longer) keyword version: {:select :* :from :users :where [:= :status &quot;approved&quot;]} -- but it&apos;s hard to use variables/parameters with the quoted form, compared to the keyword form. Sure, you can use ?name and then provide an options hash map with {:params {:name &quot;whatever&quot;}} but that&apos;s quite a bit of extra typing. I figured it might be nicer to have something like (sql/formatf &apos;{select * from users where (= username ?1)} &quot;whatever&quot;) and have it &quot;do the right thing&quot;, i.e., construct an appropriate {:params {...}} hash map for you. I created https://github.com/seancorfield/honeysql/issues/495 for feedback/discussion and implemented a basic version of formatf , currently undocumented. You can try it out via the latest develop SHA on GitHub or as a snapshot version 2.4.9999-SNAPSHOT I guess there are two questions: • Is this actually useful enough to add at all? • How would folks expect/want to see options being passed into a variadic function like that and how/would you care about parameters that are hash maps potentially conflicting with an options hash map? The latter Q is in the issue."><y>#</y><d>2023-06-23</d><h>23:15</h><w>seancorfield</w>A discussion I had today (elsewhere) made me wonder if I could make the quoted symbolic form of HoneySQL queries easier to use. You can write <code>&apos;{select * from users where (= status &quot;approved&quot;)}</code> today and it formats the same as the (longer) keyword version: <code>{:select :* :from :users :where [:= :status &quot;approved&quot;]}</code> -- but it&apos;s hard to use variables/parameters with the quoted form, compared to the keyword form. Sure, you can use <code>?name</code> and then provide an options hash map with <code>{:params {:name &quot;whatever&quot;}}</code> but that&apos;s quite a bit of extra typing.

I figured it might be nicer to have something like <code>(sql/formatf &apos;{select * from users where (= username ?1)} &quot;whatever&quot;)</code> and have it &quot;do the right thing&quot;, i.e., construct an appropriate <code>{:params {...}}</code> hash map for you.

I created <a href="https://github.com/seancorfield/honeysql/issues/495" target="_blank">https://github.com/seancorfield/honeysql/issues/495</a> for feedback/discussion and implemented a basic version of <code>formatf</code>, currently undocumented. You can try it out via the latest develop SHA on GitHub or as a snapshot version 2.4.9999-SNAPSHOT

I guess there are two questions:
• Is this actually useful enough to add at all?
• How would folks expect/want to see options being passed into a variadic function like that and how/would you care about parameters that are hash maps potentially conflicting with an options hash map?
The latter Q is in the issue.</z><z id="t1687597309" t="slipset I don’t think this would solve any problem for me. Typing out the honey is never where I spend significant time. I tend to use the helpers, and occasionally drop down to maps/kws when I’ve spent too much time with the helpers without achieving my goal. Adding a third syntax is not going to help me much. What does throw me off from time to time is when to use a vector and when not. ie {:select :id :name} vs {:select [:id :name]} . This is all on me, as I expect this is well documented, but I feel unsure all and every time this comes up. My mental model hasn’t quite formed. "><y>#</y><d>2023-06-24</d><h>09:01</h><w>slipset</w>I don’t think this would solve any problem for me. Typing out the honey is never where I spend significant time. I tend to use the helpers, and occasionally drop down to maps/kws when I’ve spent too much time with the helpers without achieving my goal. Adding a third syntax is not going to help me much. 

What does throw me off from time to time is when to use a vector and when not. ie <code>{:select :id :name}</code> vs <code>{:select [:id :name]}</code>. This is all on me, as I expect this is well documented, but I feel unsure all and every time this comes up. My mental model hasn’t quite formed. </z><z id="t1687597623" t="p-himik Maps are pairs of keys and values. {:select :id :name} is not just an invalid HoneySQL syntax, it&apos;s an invalid Clojure syntax. SQL clauses in HoneySQL maps are keys, whatever you can consider a parameter of a clause will go to the value position. And you have to be able to group multiple parameters together - that&apos;s why there must be a vector (or sometimes another map, depending on the clause) if there are multiple parameters (you can skip a vector if you need just one column, for example)."><y>#</y><d>2023-06-24</d><h>09:07</h><r>p-himik</r>Maps are pairs of keys and values. <code>{:select :id :name}</code> is not just an invalid HoneySQL syntax, it&apos;s an invalid Clojure syntax.
SQL clauses in HoneySQL maps are keys, whatever you can consider a parameter of a clause will go to the value position. And you have to be able to group multiple parameters together - that&apos;s why there must be a vector (or sometimes another map, depending on the clause) if there are multiple parameters (you can skip a vector if you need just one column, for example).</z><z id="t1687597758" t="slipset Sorry, consider the example as helpers (hh/select :id, :name) vs (hh/select [:id :name])"><y>#</y><d>2023-06-24</d><h>09:09</h><r>slipset</r>Sorry, consider the example as helpers
<code>(hh/select :id, :name)</code> vs <code>(hh/select [:id :name])</code></z><z id="t1687597791" t="p-himik Ah, alright. I avoid helpers so I wouldn&apos;t have any idea either. :D"><y>#</y><d>2023-06-24</d><h>09:09</h><r>p-himik</r>Ah, alright. I avoid helpers so I wouldn&apos;t have any idea either. :D</z><z id="t1687597905" t="slipset I’m fairly confident that the first leads to select id, name and that the second leads to select id as name but I’m never certain :)"><y>#</y><d>2023-06-24</d><h>09:11</h><r>slipset</r>I’m fairly confident that the first leads to <code>select id, name</code> and that the second leads to <code>select id as name</code> but I’m never certain :)</z><z id="t1687623022" t="seancorfield The rule of thumb -- which clearly isn&apos;t explained clearly enough in the docs, despite multiple attempts -- is that the helpers implicitly wrap their arguments in a sequence so you use one level less brackets."><y>#</y><d>2023-06-24</d><h>16:10</h><r>seancorfield</r>The rule of thumb -- which clearly isn&apos;t explained clearly enough in the docs, despite multiple attempts -- is that the helpers implicitly wrap their arguments in a sequence so you use one level less brackets.</z><z id="t1687623199" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started#functional-helpers -- improvements welcome (and I guess the ns docstring for helpers could contain more of this?)."><y>#</y><d>2023-06-24</d><h>16:13</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started#functional-helpers" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1033/doc/getting-started#functional-helpers</a> -- improvements welcome (and I guess the ns docstring for helpers could contain more of this?).</z><z id="t1687623573" t="p-himik I think the explanation is clear, and all the docstrings of helper functions are of great help here. My comment was based solely on the fact that I never use the helpers, so haven&apos;t even checked any of the docs."><y>#</y><d>2023-06-24</d><h>16:19</h><r>p-himik</r>I think the explanation is clear, and all the docstrings of helper functions are of great help here.
My comment was based solely on the fact that I never use the helpers, so haven&apos;t even checked any of the docs.</z><z id="t1687626951" t="markaddleman Fwiw, we never use the helpers either. Constructing the data directly is pretty easy (except for one or two oddball situations) and supports programmatically building SQL - which we do a lot"><y>#</y><d>2023-06-24</d><h>17:15</h><r>markaddleman</r>Fwiw, we never use the helpers either.  Constructing the data directly is pretty easy (except for one or two oddball situations) and supports programmatically building SQL - which we do a lot</z><z id="t1687627158" t="seancorfield Funnily enough, programmatically building SQL is where I use helpers the most, to take care of the automatic merging of multiple where or select clauses, for example... (This is all great feedback -- thank you!)"><y>#</y><d>2023-06-24</d><h>17:19</h><r>seancorfield</r>Funnily enough, programmatically building SQL is where I use helpers the most, to take care of the automatic merging of multiple <code>where</code> or <code>select</code> clauses, for example...

(This is all great feedback -- thank you!)</z><z id="t1687627486" t="seancorfield I just added the (helper :foo expr) example from Getting Started to the honey.sql.helpers ns docstring (for folks who rely more on docstrings than the online docs)."><y>#</y><d>2023-06-24</d><h>17:24</h><r>seancorfield</r>I just added the <code>(helper :foo expr)</code> example from Getting Started to the <code>honey.sql.helpers</code> ns docstring (for folks who rely more on docstrings than the online docs).</z><z id="t1687627588" t="markaddleman Interesting. I hadn&apos;t thought about using the helpers that way. I could probably replace some custom functions."><y>#</y><d>2023-06-24</d><h>17:26</h><r>markaddleman</r>Interesting. I hadn&apos;t thought about using the helpers that way. I could probably replace some custom functions.</z><z id="t1687628434" t="seancorfield I&apos;m guessing that the Datalog-style quoted data structure form of query just isn&apos;t widely used with HoneySQL (yet? it&apos;s new in 2.x)..."><y>#</y><d>2023-06-24</d><h>17:40</h><r>seancorfield</r>I&apos;m guessing that the Datalog-style quoted data structure form of query just isn&apos;t widely used with HoneySQL (yet? it&apos;s new in 2.x)...</z><z id="t1687629115" t="p-himik FWIW, when switching from v1 to v2 in a project that was using helpers and where I wanted to stop using helpers, I went with maps after some deliberation. While the quoted syntax is shorter, it&apos;s somewhat harder to use even without taking variables/parameters into consideration. My current IDE (Cursive) can highlight and search for a keyword, which is useful in complex queries. And it might be the most subjective thing, but for me it&apos;s much easier to think of keywords as data rather than symbols as data. When I see a symbol, my internal gauge of the chance of it being eventually resolved rises significantly, adding a bit to the overall cognitive load. Especially when it comes to stuff like and , = , &gt; , etc."><y>#</y><d>2023-06-24</d><h>17:51</h><r>p-himik</r>FWIW, when switching from v1 to v2 in a project that was using helpers and where I wanted to stop using helpers, I went with maps after some deliberation.
While the quoted syntax is shorter, it&apos;s somewhat harder to use even without taking variables/parameters into consideration. My current IDE (Cursive) can highlight and search for a keyword, which is useful in complex queries.
And it might be the most subjective thing, but for me it&apos;s much easier to think of keywords as data rather than symbols as data. When I see a symbol, my internal gauge of the chance of it being eventually resolved rises significantly, adding a bit to the overall cognitive load. Especially when it comes to stuff like <code>and</code>, <code>=</code>, <code>&gt;</code>, etc.</z><z id="t1687629470" t="seancorfield &gt; it&apos;s somewhat harder to use even without taking variables/parameters into consideration Yeah, this is what inspired the thinking behind formatf ... I feel like the queries are easier to read but parameters are harder to deal with... and quite a few people were asking for the quoted symbol form and it was mostly easy to add in the v2 rewrite so here we are 🙂"><y>#</y><d>2023-06-24</d><h>17:57</h><r>seancorfield</r>&gt; it&apos;s somewhat harder to use even without taking variables/parameters into consideration
Yeah, this is what inspired the thinking behind <code>formatf</code>... I feel like the queries are easier to read but parameters are harder to deal with... and quite a few people were asking for the quoted symbol form and it was mostly easy to add in the v2 rewrite so here we are <b>🙂</b></z><z id="t1687643594" t="potetm fwiw I much prefer quoted symbols. I&apos;m not totally following the proposal, but when I started using honeysql, I spent an hour or so futzing around with symbols/keywords/quoting before deciding to just (un)quote as needed."><y>#</y><d>2023-06-24</d><h>21:53</h><r>potetm</r>fwiw I much prefer quoted symbols. I&apos;m not totally following the proposal, but when I started using honeysql, I spent an hour or so futzing around with symbols/keywords/quoting before deciding to just (un)quote as needed.</z><z id="t1687644623" t="seancorfield [:attrs {:href &quot;/_/_/users/U07S8JGF7&quot;}] The main issue with the quoted symbol version is how do you handle variables/parameters? In the (non-quoted) keyword version, you can put values and local symbols in and they get turned into ? and parameters automatically (because they are evaluated and are not keywords). In the quoted version, you can&apos;t do that for local symbols... ...of course, you can use ?param in the quoted symbol form and then pass {:param some-val} in the :params options but that gets a bit verbose: every parameter name is repeated -- once in the quoted symbol form with a ? and then in the options with a : -- and you need to wrap that up in {:params {..}} as well... ...so the proposal is just a shorthand so you can use ?1 , ?2 , ... in the quoted symbol form and provide those parameters in order in the formatf call and it &quot;does the right thing&quot; behind the scenes (building the {:params {:1 ... :2 ...}} options map for you)."><y>#</y><d>2023-06-24</d><h>22:10</h><r>seancorfield</r><a>@U07S8JGF7</a> The main issue with the quoted symbol version is how do you handle variables/parameters? In the (non-quoted) keyword version, you can put values and local symbols in and they get turned into <code>?</code> and parameters automatically (because they are evaluated and are not keywords). In the quoted version, you can&apos;t do that for local symbols...

...of course, you can use <code>?param</code> in the quoted symbol form and then pass <code>{:param some-val}</code> in the <code>:params</code> options but that gets a bit verbose: every parameter name is repeated -- once in the quoted symbol form with a <code>?</code> and then in the options with a <code>:</code> -- and you need to wrap that up in <code>{:params {..}}</code> as well...

...so the proposal is just a shorthand so you can use <code>?1</code>, <code>?2</code>, ... in the quoted symbol form and provide those parameters in order in the <code>formatf</code> call and it &quot;does the right thing&quot; behind the scenes (building the <code>{:params {:1 ... :2 ...}}</code> options map for you).</z><z id="t1687916248" t="Daniel Vieira https://clojurians.slack.com/archives/C66EM8D5H/p1687627158290349?thread_ts=1687597309.539309&amp;amp;cid=C66EM8D5H Yes. This is very helpful. Updating a query with helper/where adds the new clause using &quot;AND&quot;. Also if you update with nil it just keeps the original query. So one can rely on that to (update query h/where (when something [:= :x 1])) or something like that. Very handy IMHO"><y>#</y><d>2023-06-28</d><h>01:37</h><r>Daniel Vieira</r><a href="https://clojurians.slack.com/archives/C66EM8D5H/p1687627158290349?thread_ts=1687597309.539309&amp;amp;cid=C66EM8D5H" target="_blank">https://clojurians.slack.com/archives/C66EM8D5H/p1687627158290349?thread_ts=1687597309.539309&amp;amp;cid=C66EM8D5H</a>

Yes. This is very helpful. Updating a query with helper/where adds the new clause using &quot;AND&quot;. Also if you update with nil it just keeps the original query.

So one can rely on that to
(update query h/where (when something [:= :x 1])) or something like that.

Very handy IMHO</z><z id="t1687628434" t="seancorfield I&apos;m guessing that the Datalog-style quoted data structure form of query just isn&apos;t widely used with HoneySQL (yet? it&apos;s new in 2.x)..."><y>#</y><d>2023-06-24</d><h>17:40</h><w>seancorfield</w>I&apos;m guessing that the Datalog-style quoted data structure form of query just isn&apos;t widely used with HoneySQL (yet? it&apos;s new in 2.x)...</z><z id="t1687728534" t="Shlomit Sibony Hi all, will appreciate any help with this issue 🙏 https://clojurians.slack.com/archives/C1Q164V29/p1687703215327339"><y>#</y><d>2023-06-25</d><h>21:28</h><w>Shlomit Sibony</w>Hi all, will appreciate any help with this issue <b>🙏</b>
<a href="https://clojurians.slack.com/archives/C1Q164V29/p1687703215327339" target="_blank">https://clojurians.slack.com/archives/C1Q164V29/p1687703215327339</a></z><z id="t1687729791" t="p-himik What is the code that you currently have?"><y>#</y><d>2023-06-25</d><h>21:49</h><r>p-himik</r>What is the code that you currently have?</z><z id="t1687730189" t="seancorfield [:attrs {:href &quot;/_/_/users/U05AM1M2095&quot;}] I&apos;m wondering if HoneySQL&apos;s :array syntax will help here, based on the manually constructed insert you showed that worked: https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md#array"><y>#</y><d>2023-06-25</d><h>21:56</h><r>seancorfield</r><a>@U05AM1M2095</a> I&apos;m wondering if HoneySQL&apos;s <code>:array</code> syntax will help here, based on the manually constructed insert you showed that worked: <a href="https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md#array" target="_blank">https://github.com/seancorfield/honeysql/blob/develop/doc/special-syntax.md#array</a></z><z id="t1687730211" t="seancorfield (I&apos;d point you at the better-formatted docs but http://cljdoc.org is down right now)"><y>#</y><d>2023-06-25</d><h>21:56</h><r>seancorfield</r>(I&apos;d point you at the better-formatted docs but <a href="http://cljdoc.org" target="_blank">http://cljdoc.org</a> is down right now)</z><z id="t1687730755" t="p-himik Somewhat related - when working with lots of similar values, I prefer to bind them as a single array parameter and not as multiple separate parameters. To do that, I have a few helpers. E.g. when I need to query some items based on their integer IDs, I use this: (defn ids [coll] (into-array Integer/TYPE coll)) Perhaps a similar approach can work here. Probably not with plain arrays but your own custom wrapper type that has special PG&lt;-&gt;CLJ conversion defined for it."><y>#</y><d>2023-06-25</d><h>22:05</h><r>p-himik</r>Somewhat related - when working with lots of similar values, I prefer to bind them as a single array parameter and not as multiple separate parameters.
To do that, I have a few helpers. E.g. when I need to query some items based on their integer IDs, I use this:
<pre>(defn ids [coll]
  (into-array Integer/TYPE coll))</pre>
Perhaps a similar approach can work here. Probably not with plain arrays but your own custom wrapper type that has special PG&lt;-&gt;CLJ conversion defined for it.</z><z id="t1687760536" t="Shlomit Sibony thanks [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] , I use the -&gt;pgobject wrapper as written in https://github.com/seancorfield/next-jdbc/blob/8e68c1be61c9aa7d71d0faa373accbe2762e35c8/doc/tips-and-tricks.md#working-with-json-and-jsonb How can I extend it to array of pg objects in prepare/SettableParameter of IPersistentVector using the method you suggested?"><y>#</y><d>2023-06-26</d><h>06:22</h><r>Shlomit Sibony</r>thanks <a>@U2FRKM4TW</a>,  I use the <code>-&gt;pgobject</code> wrapper as written in <a href="https://github.com/seancorfield/next-jdbc/blob/8e68c1be61c9aa7d71d0faa373accbe2762e35c8/doc/tips-and-tricks.md#working-with-json-and-jsonb" target="_blank">https://github.com/seancorfield/next-jdbc/blob/8e68c1be61c9aa7d71d0faa373accbe2762e35c8/doc/tips-and-tricks.md#working-with-json-and-jsonb</a>
How can I extend it to array of pg objects in <code>prepare/SettableParameter</code> of IPersistentVector using the method you suggested?</z><z id="t1687764675" t="Shlomit Sibony [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] that worked!!! I had to change prepare/SettableParameter from: IPersistentVector (set-parameter [v ^PreparedStatement s i] (.setObject s i (-&gt;pgobject v))) to IPersistentVector (set-parameter [v ^PreparedStatement s i] (.setObject s i (into-array PGobject (mapv -&gt;pgobject v)))) Thank you! 👑"><y>#</y><d>2023-06-26</d><h>07:31</h><r>Shlomit Sibony</r><a>@U2FRKM4TW</a> that worked!!!
I had to change prepare/SettableParameter from:
<pre>IPersistentVector
  (set-parameter [v ^PreparedStatement s i]
    (.setObject s i (-&gt;pgobject v)))</pre>
to
<pre>IPersistentVector
  (set-parameter [v ^PreparedStatement s i]
    (.setObject s i (into-array PGobject (mapv -&gt;pgobject v))))</pre>
Thank you! <b>👑</b></z><z id="t1687734331" t="seancorfield Although not mentioned in #C015AL9QYH1 this also includes the experimental formatf function for folks to play with and provide feedback on."><y>#</y><d>2023-06-25</d><h>23:05</h><w>seancorfield</w>Although not mentioned in #C015AL9QYH1 this also includes the experimental <code>formatf</code> function for folks to play with and provide feedback on.</z><z id="t1688597438" t="Gonzalo Rafael Acosta Hello all, quick beginners question, how do you declare an array type in a create table statement? CREATE TABLE table_name (attribute_name INT[]) "><y>#</y><d>2023-07-05</d><h>22:50</h><w>Gonzalo Rafael Acosta</w>Hello all, quick beginners question, how do you declare an array type in a create table statement?
<pre>CREATE TABLE table_name (attribute_name INT[])</pre>
</z><z id="t1688600701" t="seancorfield You probably need to use [:raw &quot;INT[]&quot;] for that."><y>#</y><d>2023-07-05</d><h>23:45</h><r>seancorfield</r>You probably need to use <code>[:raw &quot;INT[]&quot;]</code> for that.</z><z id="t1688603812" t="Gonzalo Rafael Acosta 👌 thanks"><y>#</y><d>2023-07-06</d><h>00:36</h><r>Gonzalo Rafael Acosta</r><b>👌</b> thanks</z><z id="t1688627308" t="Pragyan Tripathi I registered a function to do extactly this (hsql/register-fn! :array (fn [_ [type]] (if type [(str (hsql/sql-kw type) &quot;[]&quot;)] [&quot;&apos;[]&apos;&quot;]))) #_(hsql/format [:array :int]) ;; =&gt; [&quot;INT[]&quot;] #_(hsql/format {:create-table :table-name :with-columns [[:attribute-name [:array :int]]]}) ;; =&gt; [&quot;CREATE TABLE table_name (attribute_name INT[])&quot;] "><y>#</y><d>2023-07-06</d><h>07:08</h><r>Pragyan Tripathi</r>I registered a function to do extactly this
<pre>(hsql/register-fn! :array (fn [_ [type]]
                            (if type
                              [(str (hsql/sql-kw type) &quot;[]&quot;)]
                              [&quot;&apos;[]&apos;&quot;])))

#_(hsql/format [:array :int])
  ;; =&gt; [&quot;INT[]&quot;]

#_(hsql/format {:create-table :table-name
                :with-columns [[:attribute-name [:array :int]]]})
  ;; =&gt; [&quot;CREATE TABLE table_name (attribute_name INT[])&quot;]</pre>
</z><z id="t1688660904" t="seancorfield [:attrs {:href &quot;/_/_/users/U02JRAM6CBA&quot;}] That&apos;s probably not a good idea since there&apos;s a built-in for :array already https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started/sql-special-syntax-#array -- it just means something different."><y>#</y><d>2023-07-06</d><h>16:28</h><r>seancorfield</r><a>@U02JRAM6CBA</a> That&apos;s probably not a good idea since there&apos;s a built-in for <code>:array</code> already <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started/sql-special-syntax-#array" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started/sql-special-syntax-#array</a> -- it just means something different.</z><z id="t1688691408" t="Pragyan Tripathi Oh. Thanks for pointing it out."><y>#</y><d>2023-07-07</d><h>00:56</h><r>Pragyan Tripathi</r>Oh. Thanks for pointing it out.</z><z id="t1689281630" t="Michael Gardner I&apos;m wondering how HoneySQL could support OVERRIDING SYSTEM VALUE for inserts on columns that were created with GENERATED ALWAYS . I believe it&apos;s part of the SQL standard, although I don&apos;t have access to the spec. But https://www.postgresql.org/docs/current/sql-insert.html , at least."><y>#</y><d>2023-07-13</d><h>20:53</h><w>Michael Gardner</w>I&apos;m wondering how HoneySQL could support <code>OVERRIDING SYSTEM VALUE</code> for inserts on columns that were created with <code>GENERATED ALWAYS</code>. I believe it&apos;s part of the SQL standard, although I don&apos;t have access to the spec. But <a href="https://www.postgresql.org/docs/current/sql-insert.html" target="_blank">https://www.postgresql.org/docs/current/sql-insert.html</a>, at least.</z><z id="t1689284051" t="seancorfield Please create a GH issue with a link to the (PG) docs and I&apos;ll take a look when I&apos;m next working on HoneySQL."><y>#</y><d>2023-07-13</d><h>21:34</h><r>seancorfield</r>Please create a GH issue with a link to the (PG) docs and I&apos;ll take a look when I&apos;m next working on HoneySQL.</z><z id="t1689620781" t="whiterose We have a system at work which uses honeysql. It is time critical and even few ms increase is a huge burden. The version of honeysql we use is quite old(v0.9.4) and I see the caching was introduced in later versions according to the https://github.com/seancorfield/honeysql/pull/378 PR. But still I see that the first query creation takes lot more time(almost 10 - 15x) than the following ones and it just flattens. Was there any sort of mechanism to cache queries earlier as well? Our queries are usually identical so I believe this spike in query creation would only be when the deployment is done and honeysql freshly starts caching the queries. Because of the throughput this would be less than few minutes before all pods catch up. Would love to learn more about this. Thanks."><y>#</y><d>2023-07-17</d><h>19:06</h><w>whiterose</w>We have a system at work which uses honeysql. It is time critical and even few ms increase is a huge burden. The version of honeysql we use is quite old(v0.9.4) and I see the caching was introduced in later versions according to the <a href="https://github.com/seancorfield/honeysql/pull/378" target="_blank">https://github.com/seancorfield/honeysql/pull/378</a> PR. But still I see that the first query creation takes lot more time(almost 10 - 15x) than the following ones and it just flattens. Was there any sort of mechanism to cache queries earlier as well?

Our queries are usually identical so I believe this spike in query creation would only be when the deployment is done and honeysql freshly starts caching the queries. Because of the throughput this would be less than few minutes before all pods catch up. Would love to learn more about this. Thanks.</z><z id="t1689621334" t="seancorfield Sounds like you should run format for those queries at startup so they are precalculated and in the cache by the time your &quot;time critical&quot; code runs?"><y>#</y><d>2023-07-17</d><h>19:15</h><r>seancorfield</r>Sounds like you should run <code>format</code> for those queries at startup so they are precalculated and in the cache by the time your &quot;time critical&quot; code runs?</z><z id="t1689621668" t="whiterose That would be right yes. We can just do a format once with random values and it would be able to cache or is there any other approach? But even then I would be fine with those spikes at the start since we are initialising a lot of clients. Few requests get timed out anyways. Just wanted to understand if this caching was already there even before that caching formatter PR."><y>#</y><d>2023-07-17</d><h>19:21</h><r>whiterose</r>That would be right yes. We can just do a format once with random values and it would be able to cache or is there any other approach? But even then I would be fine with those spikes at the start since we are initialising a lot of clients. Few requests get timed out anyways. 

Just wanted to understand if this caching was already there even before that caching formatter PR.</z><z id="t1689623320" t="seancorfield Ah, I misunderstood your question. No, there was no caching at all prior to that change. And after that change, if you provided a cache object to format , the first parse would populate the cache so subsequent parses could be skipped."><y>#</y><d>2023-07-17</d><h>19:48</h><r>seancorfield</r>Ah, I misunderstood your question. No, there was no caching at all prior to that change. And after that change, if you provided a cache object to <code>format</code>, the first parse would populate the cache so subsequent parses could be skipped.</z><z id="t1689623463" t="seancorfield (and you have to use :params so that the query DSL is identical on each format call -- which also means you can&apos;t use :in and a few other things that break caching)"><y>#</y><d>2023-07-17</d><h>19:51</h><r>seancorfield</r>(and you have to use <code>:params</code> so that the query DSL is identical on each <code>format</code> call -- which also means you can&apos;t use <code>:in</code> and a few other things that break caching)</z><z id="t1689623567" t="seancorfield If your queries are identical (and time critical), perhaps using plain SQL strings instead of HoneySQL might be a better choice anyway? Or perhaps explicitly calling format with dummy values at startup and explicitly caching the SQL string yourself?"><y>#</y><d>2023-07-17</d><h>19:52</h><r>seancorfield</r>If your queries are identical (and time critical), perhaps using plain SQL strings instead of HoneySQL might be a better choice anyway? Or perhaps explicitly calling <code>format</code> with dummy values at startup and explicitly caching the SQL string yourself?</z><z id="t1689625688" t="slipset not knowing the domain at all, but it would seem strange to me that generating the sql string from honey would be significant?"><y>#</y><d>2023-07-17</d><h>20:28</h><r>slipset</r>not knowing the domain at all, but it would seem strange to me that generating the sql string from honey would be significant?</z><z id="t1689625768" t="slipset If it were, couldn’t you then also make some macrology that turned honey into sql strings (at compile time) which you could then feed to a prepared statement?"><y>#</y><d>2023-07-17</d><h>20:29</h><r>slipset</r>If it were, couldn’t you then also make some macrology that turned honey into sql strings (at compile time)  which you could then feed to a prepared statement?</z><z id="t1689633659" t="seancorfield [:attrs {:href &quot;/_/_/users/U04V5VAUN&quot;}] It would depend on how complex the DSL for the query was. Although we don&apos;t use the caching at work, several people have complained about the DSL parsing overhead for performance critical code so..."><y>#</y><d>2023-07-17</d><h>22:40</h><r>seancorfield</r><a>@U04V5VAUN</a> It would depend on how complex the DSL for the query was. Although we don&apos;t use the caching at work, several people have complained about the DSL parsing overhead for performance critical code so...</z><z id="t1689658425" t="whiterose &gt; (and you have to use :params so that the query DSL is identical on each format call -- which also means you can&apos;t use :in and a few other things that break caching) &gt; We are using an old version and so we don&apos;t pass this :params for caching and all the values are inside the data structures itself. This query uses :in operators at multiple places. Now I&apos;m wondering how it is able to memorize/cache without any explicit mechanism in place 😅"><y>#</y><d>2023-07-18</d><h>05:33</h><r>whiterose</r>&gt; (and you have to use :params so that the query DSL is identical on each format call -- which also means you can&apos;t use :in and a few other things that break caching)
&gt; 
We are using an old version and so we don&apos;t pass this :params for caching and all the values are inside the data structures itself. This query uses :in operators at multiple places. 

Now I&apos;m wondering how it is able to memorize/cache without any explicit mechanism in place <b>😅</b></z><z id="t1689658549" t="seancorfield It isn&apos;t. You&apos;re likely just seeing other effects of the JVM optimizing frequently executed code paths and the JIT system..."><y>#</y><d>2023-07-18</d><h>05:35</h><r>seancorfield</r>It isn&apos;t. You&apos;re likely just seeing other effects of the JVM optimizing frequently executed code paths and the JIT system...</z><z id="t1689660819" t="whiterose Nice. I think it&apos;s good to replace the query with just plain SQL as well for this one critical query. This critical flow only has one db call."><y>#</y><d>2023-07-18</d><h>06:13</h><r>whiterose</r>Nice. I think it&apos;s good to replace the query with just plain SQL as well for this one critical query. This critical flow only has one db call.</z><z id="t1689681898" t="slipset [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] I do understand that complex queries will take time to format, but I’d like to see a query where the query formatting time was significant in relation to the query time. "><y>#</y><d>2023-07-18</d><h>12:04</h><r>slipset</r><a>@U04V70XH6</a> I do understand that complex queries will take time to format,  but I’d like to see a query where the query formatting time was significant in relation to the query time. </z><z id="t1689696932" t="seancorfield Oh, I doubt there are many queries where the formatting time is really the bottle neck. I just took the OP&apos;s question at face value."><y>#</y><d>2023-07-18</d><h>16:15</h><r>seancorfield</r>Oh, I doubt there are many queries where the formatting time is really the bottle neck. I just took the OP&apos;s question at face value.</z><z id="t1689885166" t="whiterose What would be the best way to measure this? I believe the queries would not be bottleneck as it is simple to select a few columns with a couple of where in clauses. Just want to know what would be the best way to benchmark this."><y>#</y><d>2023-07-20</d><h>20:32</h><r>whiterose</r>What would be the best way to measure this? I believe the queries would not be bottleneck as it is simple to select a few columns with a couple of where in clauses. 
Just want to know what would be the best way to benchmark this.</z><z id="t1691083660" t="nbardiuk Is there a way to reference a quoted alias without :raw ? I want to use quoted alias in ORDER BY clause SELECT column_name AS &quot;some-alias&quot; FROM b ORDER BY &quot;some-alias&quot; ASC I would like to avoid using :raw because the alias value comes from 3d party (honey.sql/format {:select [[:column-name &quot;some-alias&quot;]] :from :b :order-by [[[:raw &quot;\&quot;some-alias\&quot;&quot;]]]}) Quoting everything doesn&apos;t work because it doesn&apos;t convert kebab column names to underscores (honey.sql/format {:select [[:column-name &quot;some-alias&quot;]] :from :b :order-by [:some-alias]} {:quoted true}) SELECT &quot;column-name&quot; AS &quot;some-alias&quot; FROM &quot;b&quot; ORDER BY &quot;some-alias&quot; ASC And quoted-snake corrupts dashes in aliases (honey.sql/format {:select [[:column-name &quot;some-alias&quot;]] :from :b :order-by [:some-alias]} {:quoted-snake true}) SELECT column_name AS &quot;some_alias&quot; FROM b ORDER BY some_alias ASC"><y>#</y><d>2023-08-03</d><h>17:27</h><w>nbardiuk</w>Is there a way to reference a quoted alias without <code>:raw</code>?
I want to use quoted alias in ORDER BY clause
<pre>SELECT column_name AS &quot;some-alias&quot; FROM b ORDER BY &quot;some-alias&quot; ASC</pre>
I would like to avoid using <code>:raw</code> because the alias value comes from 3d party
<pre>(honey.sql/format {:select [[:column-name &quot;some-alias&quot;]]
                   :from :b
                   :order-by [[[:raw &quot;\&quot;some-alias\&quot;&quot;]]]})</pre>
Quoting everything doesn&apos;t work because it doesn&apos;t convert kebab column names to underscores
<pre>(honey.sql/format {:select [[:column-name &quot;some-alias&quot;]]
                   :from :b
                   :order-by [:some-alias]}
                  {:quoted true})</pre>
<pre>SELECT &quot;column-name&quot; AS &quot;some-alias&quot; FROM &quot;b&quot; ORDER BY &quot;some-alias&quot; ASC</pre>
And <code>quoted-snake</code> corrupts dashes in aliases
<pre>(honey.sql/format {:select [[:column-name &quot;some-alias&quot;]]
                   :from :b
                   :order-by [:some-alias]}
                  {:quoted-snake true})</pre>
<pre>SELECT column_name AS &quot;some_alias&quot; FROM b ORDER BY some_alias ASC</pre></z><z id="t1691083962" t="p-himik Oh, huh. There&apos;s stuff like :&apos;x but apparently it works only when it&apos;s in a function-calling context."><y>#</y><d>2023-08-03</d><h>17:32</h><r>p-himik</r>Oh, huh. There&apos;s stuff like <code>:&apos;x</code> but apparently it works only when it&apos;s in a function-calling context.</z><z id="t1691084213" t="nbardiuk thank you for the :&apos;x didn&apos;t know it exists, it can cover some cases"><y>#</y><d>2023-08-03</d><h>17:36</h><r>nbardiuk</r>thank you for the <code>:&apos;x</code> didn&apos;t know it exists, it can cover some cases</z><z id="t1691086257" t="seancorfield [:attrs {:href &quot;/_/_/users/U076FM90B&quot;}] Feel free to create an issue on GitHub for me to look at. AS aliases have special treatment so maybe I&apos;ll need to add special syntax like [:alias &quot;some-alias&quot;] so you can get that treatment elsewhere..."><y>#</y><d>2023-08-03</d><h>18:10</h><r>seancorfield</r><a>@U076FM90B</a> Feel free to create an issue on GitHub for me to look at. <code>AS</code> aliases have special treatment so maybe I&apos;ll need to add special syntax like <code>[:alias &quot;some-alias&quot;]</code> so you can get that treatment elsewhere...</z><z id="t1691086845" t="nbardiuk https://github.com/seancorfield/honeysql/issues/497"><y>#</y><d>2023-08-03</d><h>18:20</h><r>nbardiuk</r><a href="https://github.com/seancorfield/honeysql/issues/497" target="_blank">https://github.com/seancorfield/honeysql/issues/497</a></z><z id="t1691086903" t="p-himik [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] Wouldn&apos;t it make more sense to support :&apos;x everywhere? A breaking change, I suppose, but maybe could be put behind an opt-in flag?"><y>#</y><d>2023-08-03</d><h>18:21</h><r>p-himik</r><a>@U04V70XH6</a> Wouldn&apos;t it make more sense to support <code>:&apos;x</code> everywhere? A breaking change, I suppose, but maybe could be put behind an opt-in flag?</z><z id="t1691087646" t="seancorfield That&apos;s something I&apos;ll take a look at as part of this issue."><y>#</y><d>2023-08-03</d><h>18:34</h><r>seancorfield</r>That&apos;s something I&apos;ll take a look at as part of this issue.</z><z id="t1691087685" t="seancorfield I think the behavior of :&apos;x may already be context-dependent but I&apos;d have to refresh my memory..."><y>#</y><d>2023-08-03</d><h>18:34</h><r>seancorfield</r>I think the behavior of <code>:&apos;x</code> may already be context-dependent but I&apos;d have to refresh my memory...</z><z id="t1691334976" t="kenny Morning 🙂 Is it possible to write the values + as clause in this pg query? update users as u set -- postgres FTW email = u2.email, first_name = u2.first_name, last_name = u2.last_name from (values (1, &apos;"><y>#</y><d>2023-08-06</d><h>15:16</h><w>kenny</w>Morning <b>🙂</b> Is it possible to write the values + as clause in this pg query?
<pre>update users as u set -- postgres FTW
  email = u2.email,
  first_name = u2.first_name,
  last_name = u2.last_name
from (values
  (1, &apos;</pre></z><z id="t1691334994" t="kenny I currently think I need to resort to :raw ."><y>#</y><d>2023-08-06</d><h>15:16</h><r>kenny</r>I currently think I need to resort to <code>:raw</code>.</z><z id="t1691335024" t="kenny e.g., (defn update-many-sql [ms] (let [ks (reduce (fn [acc m] (apply conj acc (keys m))) #{} ms)] {:from [[[{:values (map (fn [m] (map (fn [k] (m k)) ks)) ms)}] [:v [:raw &quot;(&quot; (str/join &quot;, &quot; (map name ks)) &quot;)&quot;]]]]}))"><y>#</y><d>2023-08-06</d><h>15:17</h><r>kenny</r>e.g.,
<pre>(defn update-many-sql
  [ms]
  (let [ks (reduce (fn [acc m] (apply conj acc (keys m))) #{} ms)]
    {:from [[[{:values (map (fn [m] (map (fn [k] (m k)) ks)) ms)}] [:v [:raw &quot;(&quot; (str/join &quot;, &quot; (map name ks)) &quot;)&quot;]]]]}))</pre></z><z id="t1691339958" t="seancorfield Create a GitHub issue and I&apos;ll have a think about this."><y>#</y><d>2023-08-06</d><h>16:39</h><r>seancorfield</r>Create a GitHub issue and I&apos;ll have a think about this.</z><z id="t1691341683" t="kenny Sure. https://github.com/seancorfield/honeysql/issues/498"><y>#</y><d>2023-08-06</d><h>17:08</h><r>kenny</r>Sure. <a href="https://github.com/seancorfield/honeysql/issues/498" target="_blank">https://github.com/seancorfield/honeysql/issues/498</a></z><z id="t1691394050" t="dekel I believe there’s a bug around IN clauses and inline formatting when using parameters, but I just wanted to check I’m not missing a step (or that this is explicitly not supported) before I open an issue: ;NO PARAMETERS: (hsql/format {:select :* :from :some-table :where [:in :id [1 2 3]]} {}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN (?, ?, ?)&quot; 1 2 3] (hsql/format {:select :* :from :some-table :where [:in :id [1 2 3]]} {:inline true}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN (1, 2, 3)&quot;] ;correct ;PARAMETERS: (hsql/format {:select :* :from :some-table :where [:in :id :?ids]} {:params {:ids [1 2 3]}}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN (?, ?, ?)&quot; 1 2 3] ;correct without inline (hsql/format {:select :* :from :some-table :where [:in :id :?ids]} {:params {:ids (seq [1 2 3])} :inline true}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN (1 2 3)&quot;] ;no commas (hsql/format {:select :* :from :some-table :where [:in :id :?ids]} {:params {:ids [1 2 3]} :inline true}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN [1, 2, 3]&quot;] ;square brackets (hsql/format {:select :* :from :some-table :where [:in :id :?ids]} {:params {:ids #{1 2 3}} :inline true}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN #{1 3 2}&quot;] ;set, no commas (hsql/format {:select :* :from :some-table :where [:in :id :?ids]} {:params {:ids (map inc [1 2 3])} :inline true}) =&gt; [&quot;SELECT * FROM some_table WHERE id IN clojure.lang.LazySeq@7c42&quot;] ;etc"><y>#</y><d>2023-08-07</d><h>07:40</h><w>dekel</w>I believe there’s a bug around <code>IN</code> clauses and <code>inline</code> formatting when using parameters, but I just wanted to check I’m not missing a step (or that this is explicitly not supported) before I open an issue:
<pre>;NO PARAMETERS:
(hsql/format
  {:select :* :from :some-table :where [:in :id [1 2 3]]}
  {})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN (?, ?, ?)&quot; 1 2 3]
(hsql/format
  {:select :* :from :some-table :where [:in :id [1 2 3]]}
  {:inline true})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN (1, 2, 3)&quot;] ;correct

;PARAMETERS:
(hsql/format
  {:select :* :from :some-table :where [:in :id :?ids]}
  {:params {:ids [1 2 3]}})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN (?, ?, ?)&quot; 1 2 3] ;correct without inline
(hsql/format
  {:select :* :from :some-table :where [:in :id :?ids]}
  {:params {:ids (seq [1 2 3])}
   :inline true})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN (1 2 3)&quot;] ;no commas
(hsql/format
  {:select :* :from :some-table :where [:in :id :?ids]}
  {:params {:ids [1 2 3]}
   :inline true})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN [1, 2, 3]&quot;] ;square brackets
(hsql/format
  {:select :* :from :some-table :where [:in :id :?ids]}
  {:params {:ids #{1 2 3}}
   :inline true})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN #{1 3 2}&quot;] ;set, no commas
(hsql/format
  {:select :* :from :some-table :where [:in :id :?ids]}
  {:params {:ids (map inc [1 2 3])}
   :inline true})
=&gt; [&quot;SELECT * FROM some_table WHERE id IN clojure.lang.LazySeq@7c42&quot;] ;etc</pre></z><z id="t1691396055" t="p-himik Seems like it&apos;s intended and documented: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/all-the-options?q=%3Ainline#inline &gt; everything else is just turned into a string (by calling str )"><y>#</y><d>2023-08-07</d><h>08:14</h><r>p-himik</r>Seems like it&apos;s intended and documented: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/all-the-options?q=%3Ainline#inline" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/all-the-options?q=%3Ainline#inline</a>
&gt; everything else is just turned into a string (by calling <code>str</code>)</z><z id="t1691396111" t="dekel Ah, wonderful, thank you for that, I was looking for things related to in specifically"><y>#</y><d>2023-08-07</d><h>08:15</h><r>dekel</r>Ah, wonderful, thank you for that, I was looking for things related to <code>in</code> specifically</z><z id="t1691702334" t="joshuamz Hi. Is it possible to express this syntax (`merge into`) in Honey SQL? I&apos;m using Snowflake as my data storage and I think https://docs.snowflake.com/en/sql-reference/sql/merge . I&apos;m trying to implement an upsert operation with a single query. Thanks! MERGE INTO t1 USING t2 ON t1.t1Key = t2.t2Key WHEN MATCHED AND t2.marked = 1 THEN DELETE WHEN MATCHED AND t2.isNewStatus = 1 THEN UPDATE SET val = t2.newVal, status = t2.newStatus WHEN MATCHED THEN UPDATE SET val = t2.newVal WHEN NOT MATCHED THEN INSERT (val, status) VALUES (t2.newVal, t2.newStatus);"><y>#</y><d>2023-08-10</d><h>21:18</h><w>joshuamz</w>Hi. Is it possible to express this syntax (`merge into`) in Honey SQL?

I&apos;m using Snowflake as my data storage and I think <a href="https://docs.snowflake.com/en/sql-reference/sql/merge" target="_blank">https://docs.snowflake.com/en/sql-reference/sql/merge</a>.

I&apos;m trying to implement an upsert operation with a single query.

Thanks!

<pre>MERGE INTO t1 USING t2 ON t1.t1Key = t2.t2Key
    WHEN MATCHED AND t2.marked = 1 THEN DELETE
    WHEN MATCHED AND t2.isNewStatus = 1 THEN UPDATE SET val = t2.newVal, status = t2.newStatus
    WHEN MATCHED THEN UPDATE SET val = t2.newVal
    WHEN NOT MATCHED THEN INSERT (val, status) VALUES (t2.newVal, t2.newStatus);</pre></z><z id="t1691702710" t="p-himik Yeah, definitely non-standard. I don&apos;t think there&apos;s a built-in way to do something like that in an ergonomic way. But you can always extend HoneySQL by writing your own project-local custom formatter so that something like {:merge-into [:t1 [:t2 [:= :t1/t1Key :t2/t2Key]] [[:and :matched [:= :t2/marked 1]] :delete] ...]} becomes the string that you want."><y>#</y><d>2023-08-10</d><h>21:25</h><r>p-himik</r>Yeah, definitely non-standard.

I don&apos;t think there&apos;s a built-in way to do something like that in an ergonomic way.
But you can always extend HoneySQL by writing your own project-local custom formatter so that something like
<pre>{:merge-into [:t1 [:t2 [:= :t1/t1Key :t2/t2Key]]
              [[:and :matched [:= :t2/marked 1]] :delete]
              ...]}</pre>
becomes the string that you want.</z><z id="t1691702758" t="seancorfield MS SQL Server has it too https://learn.microsoft.com/en-us/sql/t-sql/statements/merge-transact-sql?view=sql-server-ver16"><y>#</y><d>2023-08-10</d><h>21:25</h><r>seancorfield</r>MS SQL Server has it too<a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/merge-transact-sql?view=sql-server-ver16" target="_blank">https://learn.microsoft.com/en-us/sql/t-sql/statements/merge-transact-sql?view=sql-server-ver16</a></z><z id="t1691702805" t="p-himik Oh... what?! PG also has it!"><y>#</y><d>2023-08-10</d><h>21:26</h><r>p-himik</r>Oh... what?! PG also has it!</z><z id="t1691702807" t="seancorfield Ah, it&apos;s ANSI Standard https://en.wikipedia.org/wiki/Merge_%28SQL%29"><y>#</y><d>2023-08-10</d><h>21:26</h><r>seancorfield</r>Ah, it&apos;s ANSI Standard <a href="https://en.wikipedia.org/wiki/Merge_%28SQL%29" target="_blank">https://en.wikipedia.org/wiki/Merge_%28SQL%29</a></z><z id="t1691702821" t="p-himik Ahhh, in PG it&apos;s only in version 15, the latest one."><y>#</y><d>2023-08-10</d><h>21:27</h><r>p-himik</r>Ahhh, in PG it&apos;s only in version 15, the latest one.</z><z id="t1691702831" t="seancorfield [:attrs {:href &quot;/_/_/users/U02BATFPN78&quot;}] Create a GH issue and I&apos;ll add it into the core."><y>#</y><d>2023-08-10</d><h>21:27</h><r>seancorfield</r><a>@U02BATFPN78</a> Create a GH issue and I&apos;ll add it into the core.</z><z id="t1691702846" t="joshuamz Wow! Yes, thank you!"><y>#</y><d>2023-08-10</d><h>21:27</h><r>joshuamz</r>Wow! Yes, thank you!</z><z id="t1691702870" t="seancorfield I&apos;m planning a big HoneySQL blitz soon to try to get through the backlog of issues. Esp. the temporal stuff since I will need that for XTDB 2.0 🙂"><y>#</y><d>2023-08-10</d><h>21:27</h><r>seancorfield</r>I&apos;m planning a big HoneySQL blitz soon to try to get through the backlog of issues. Esp. the temporal stuff since I will need that for XTDB 2.0 <b>🙂</b></z><z id="t1691702951" t="p-himik &gt; It was officially introduced in the https://en.wikipedia.org/wiki/SQL:2003 standard, and expanded in the https://en.wikipedia.org/wiki/SQL:2008 standard Wow... It&apos;s been there for 20 years. And when I needed something that INSERT ... ON CONFLICT ... couldn&apos;t handle, I had to write a terrible CTE or straight up split the thing into multiple expressions."><y>#</y><d>2023-08-10</d><h>21:29</h><r>p-himik</r>&gt; It was officially introduced in the <a href="https://en.wikipedia.org/wiki/SQL:2003" target="_blank">https://en.wikipedia.org/wiki/SQL:2003</a> standard, and expanded in the <a href="https://en.wikipedia.org/wiki/SQL:2008" target="_blank">https://en.wikipedia.org/wiki/SQL:2008</a> standard
Wow... It&apos;s been there for 20 years. And when I needed something that <code>INSERT ... ON CONFLICT ...</code> couldn&apos;t handle, I had to write a terrible CTE or straight up split the thing into multiple expressions.</z><z id="t1691702999" t="joshuamz https://github.com/seancorfield/honeysql/issues/499"><y>#</y><d>2023-08-10</d><h>21:29</h><r>joshuamz</r><a href="https://github.com/seancorfield/honeysql/issues/499" target="_blank">https://github.com/seancorfield/honeysql/issues/499</a></z><z id="t1691703018" t="seancorfield Thanks!"><y>#</y><d>2023-08-10</d><h>21:30</h><r>seancorfield</r>Thanks!</z><z id="t1691703035" t="joshuamz Thank you sir :saluting_face:"><y>#</y><d>2023-08-10</d><h>21:30</h><r>joshuamz</r>Thank you sir <b>:saluting_face:</b></z><z id="t1691864384" t="rafaeldelboni Hi I have the following data query: {:select [:*], :from [:definition], :full-join [:note [:= :note/definition-id :definition/definition-id]], :join [[:author :note-author] [:= :note/author-id :note-author/author-id]]} and its producing the following sql: SELECT * FROM definition INNER JOIN author AS note_author ON note.author_id = note_author.author_id FULL JOIN note ON note.definition_id = definition.definition_id What should I do to make the inner join appear after the full join?"><y>#</y><d>2023-08-12</d><h>18:19</h><w>rafaeldelboni</w>Hi I have the following data query:
<pre>{:select [:*],
 :from [:definition],
 :full-join [:note [:= :note/definition-id :definition/definition-id]],
 :join
 [[:author :note-author] [:= :note/author-id :note-author/author-id]]}</pre>
and its producing the following sql:
<pre>SELECT *
  FROM definition
  INNER JOIN author AS note_author ON note.author_id = note_author.author_id
  FULL JOIN note ON note.definition_id = definition.definition_id</pre>
What should I do to make the inner join appear after the full join?</z><z id="t1691864654" t="rafaeldelboni Ow wow I just read about :join-by in the docs {:select [:*], :from [:definition], :join-by [:full [:note [:= :note/definition-id :definition/definition-id]] :join [[:author :note-author] [:= :note/author-id :note-author/author-id]]]} This solves my problem"><y>#</y><d>2023-08-12</d><h>18:24</h><r>rafaeldelboni</r>Ow wow I just read about <code>:join-by</code> in the docs
<pre>{:select [:*],
 :from [:definition],
 :join-by
 [:full
  [:note [:= :note/definition-id :definition/definition-id]]
  :join
  [[:author :note-author] [:= :note/author-id :note-author/author-id]]]}</pre>
This solves my problem</z><z id="t1691867624" t="seancorfield Yup, not all databases care about join order but some do -- so :join-by was added for those &quot;sensitive&quot; databases 🙂"><y>#</y><d>2023-08-12</d><h>19:13</h><r>seancorfield</r>Yup, not all databases care about join order but some do -- so <code>:join-by</code> was added for those &quot;sensitive&quot; databases <b>🙂</b></z><z id="t1691867642" t="seancorfield (I mean, SQL is relational so order absolutely should not matter)"><y>#</y><d>2023-08-12</d><h>19:14</h><r>seancorfield</r>(I mean, SQL is relational so order absolutely should not matter)</z><z id="t1691868816" t="rafaeldelboni Yeah looks like postres is a bit more sensitive 😆"><y>#</y><d>2023-08-12</d><h>19:33</h><r>rafaeldelboni</r>Yeah looks like postres is a bit more sensitive <b>😆</b></z><z id="t1691869572" t="seancorfield https://github.com/seancorfield/honeysql/issues/277 was the issue."><y>#</y><d>2023-08-12</d><h>19:46</h><r>seancorfield</r><a href="https://github.com/seancorfield/honeysql/issues/277" target="_blank">https://github.com/seancorfield/honeysql/issues/277</a> was the issue.</z><z id="t1691870643" t="rafaeldelboni Thanks a lot for all your work on this, this is a incredible library together next-jdbc it&apos;s super powerfull"><y>#</y><d>2023-08-12</d><h>20:04</h><r>rafaeldelboni</r>Thanks a lot for all your work on this, this is a incredible library together next-jdbc it&apos;s super powerfull</z><z id="t1692313319" t="markbastian How might I do an expression such as this in honesql (request_end and request_begin are columns): avg((request_end - request_begin) / 1000.0) as avg_exec_time"><y>#</y><d>2023-08-17</d><h>23:01</h><w>markbastian</w>How might I do an expression such as this in honesql (request_end and request_begin are columns):
<pre>avg((request_end - request_begin) / 1000.0) as avg_exec_time</pre></z><z id="t1692317880" t="seancorfield [:- :request_end :request_begin] for the subtraction... [:/ ... 1000.0] for the divide... [:avg ...] for the function call... [... :avg_exec_time] for the alias"><y>#</y><d>2023-08-18</d><h>00:18</h><r>seancorfield</r><code>[:- :request_end :request_begin]</code> for the subtraction...

<code>[:/ ... 1000.0]</code> for the divide...

<code>[:avg ...]</code> for the function call...

<code>[... :avg_exec_time]</code> for the alias</z><z id="t1692318027" t="seancorfield And then I assume you want to use it in a SELECT ? {:select [ expr expr expr ... ] ...} so putting that all together you get: {:select [[[:avg [:/ [:- :request_end :request_begin] 1000.0]] :avg_exec_time] ...] ...} depending on whether you need to select a second or subsequent expression..."><y>#</y><d>2023-08-18</d><h>00:20</h><r>seancorfield</r>And then I assume you want to use it in a <code>SELECT</code>?

<code>{:select [ expr expr expr ... ] ...}</code> so putting that all together you get:
<pre>{:select [[[:avg [:/ [:- :request_end :request_begin] 1000.0]] :avg_exec_time] ...] ...}</pre>
depending on whether you need to select a second or subsequent expression...</z><z id="t1692318046" t="seancorfield If the documentation can make this clearer, let me know."><y>#</y><d>2023-08-18</d><h>00:20</h><r>seancorfield</r>If the documentation can make this clearer, let me know.</z><z id="t1692318105" t="markbastian Cool! I’ll give that a shot. I think the main thing is just knowing where to look. Thanks!"><y>#</y><d>2023-08-18</d><h>00:21</h><r>markbastian</r>Cool! I’ll give that a shot. I think the main thing is just knowing where to look. Thanks!</z><z id="t1692318148" t="seancorfield The Getting Started page has these examples:"><y>#</y><d>2023-08-18</d><h>00:22</h><r>seancorfield</r>The Getting Started page has these examples:</z><z id="t1692318153" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started"><y>#</y><d>2023-08-18</d><h>00:22</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1045/doc/getting-started</a></z><z id="t1692318490" t="markbastian Ah, I thought I was doing the above but it’s the nested brackets that got me originally. I was doing: (hsql/format {:select [[:- :request_end :request_begin]] :from [:foo]}) but need to do: (hsql/format {:select [[[:- :request_end :request_begin] :diff]] :from [:foo]}) Once I got it, it makes sense that you need to add the extra nesting to capture the expression and the alias. If I get some time maybe I’ll put together a doc PR."><y>#</y><d>2023-08-18</d><h>00:28</h><r>markbastian</r>Ah, I thought I was doing the above but it’s the nested brackets that got me originally.

I was doing:
<pre>(hsql/format
  {:select [[:- :request_end :request_begin]]
   :from   [:foo]})</pre>
but need to do:
<pre>(hsql/format
  {:select [[[:- :request_end :request_begin] :diff]]
   :from   [:foo]})</pre>
Once I got it, it makes sense that you need to add the extra nesting to capture the expression and the alias.

If I get some time maybe I’ll put together a doc PR.</z><z id="t1692318498" t="markbastian Thanks for the clarification!"><y>#</y><d>2023-08-18</d><h>00:28</h><r>markbastian</r>Thanks for the clarification!</z><z id="t1692396600" t="lukasz Might be a long shot, but worth trying: I made a mistake and used inline parameters in my queries, now I&apos;m realizing that using :params is the way to go - did anyone run into this and wrote code to convert existing queries to parametrized ones? Probably doesn&apos;t even need rewrite-clj. Thanks!"><y>#</y><d>2023-08-18</d><h>22:10</h><w>lukasz</w>Might be a long shot, but worth trying: I made a mistake and used inline parameters in my queries, now I&apos;m realizing that using <code>:params</code> is the way to go - did anyone run into this and wrote code to convert existing queries to parametrized ones? Probably doesn&apos;t even need rewrite-clj. Thanks!</z><z id="t1692396748" t="seancorfield Can you explain the &quot;mistake&quot; in a bit more detail? When I hear &quot;inline&quot; and &quot;mistake&quot;, I think of :inline putting the values into the SQL string. But I don&apos;t think that&apos;s what you mean?"><y>#</y><d>2023-08-18</d><h>22:12</h><r>seancorfield</r>Can you explain the &quot;mistake&quot; in a bit more detail?

When I hear &quot;inline&quot; and &quot;mistake&quot;, I think of <code>:inline</code> putting the values into the SQL string. But I don&apos;t think that&apos;s what you mean?</z><z id="t1692396833" t="seancorfield The only reason I can think of that you might prefer :params over values in the DSL is for caching purposes (but I don&apos;t think many people use the caching system because of the restrictions it places on IN and ARRAY etc)."><y>#</y><d>2023-08-18</d><h>22:13</h><r>seancorfield</r>The only reason I can think of that you might prefer <code>:params</code> over values in the DSL is for caching purposes (but I don&apos;t think many people use the caching system because of the restrictions it places on <code>IN</code> and <code>ARRAY</code> etc).</z><z id="t1692396905" t="seancorfield FWIW, I&apos;ve never used named parameters with HoneySQL in my own code."><y>#</y><d>2023-08-18</d><h>22:15</h><r>seancorfield</r>FWIW, I&apos;ve never used named parameters with HoneySQL in my own code.</z><z id="t1692397666" t="lukasz For one, I cannot use caches, other part is that after experimenting a bit I found it easier to compose queries from bigger re-usable bits when parameters were involved. The last bit is because I have to work with JSONB there&apos;s a lot of :inline all over the place that I can avoid if I switch to named parameters"><y>#</y><d>2023-08-18</d><h>22:27</h><r>lukasz</r>For one, I cannot use caches, other part is that after experimenting a bit I found it easier to compose queries from bigger re-usable bits when parameters were involved. The last bit is because I have to work with JSONB there&apos;s a lot of <code>:inline</code> all over the place that I can avoid if I switch to named parameters</z><z id="t1692397766" t="seancorfield Hmm... :inline ? Why? Wouldn&apos;t you use :lift to wrap JSON-like data inside the DSL? I&apos;m curious about the use case to see if I can make it easier...?"><y>#</y><d>2023-08-18</d><h>22:29</h><r>seancorfield</r>Hmm... <code>:inline</code>? Why? Wouldn&apos;t you use <code>:lift</code> to wrap JSON-like data inside the DSL?

I&apos;m curious about the use case to see if I can make it easier...?</z><z id="t1692397925" t="lukasz ah sorry, I meant :lift (it&apos;s been a long day) , but yes - I do have a lot of :inline too (for example when querying for boolean fields [:= :u.deleted [:inline false]] or constructing objects from sub-queries/joins [:json_build_object [:inline &quot;id&quot;] :u.id] )"><y>#</y><d>2023-08-18</d><h>22:32</h><r>lukasz</r>ah sorry, I meant <code>:lift</code> (it&apos;s been a long day) , but yes - I do have a lot of <code>:inline</code>  too (for example when querying for boolean fields <code>[:= :u.deleted [:inline false]]</code> or  constructing objects from sub-queries/joins <code>[:json_build_object [:inline &quot;id&quot;] :u.id]</code> )</z><z id="t1692398008" t="lukasz but named parameters won&apos;t help here anyway"><y>#</y><d>2023-08-18</d><h>22:33</h><r>lukasz</r>but named parameters won&apos;t help here anyway</z><z id="t1692558393" t="Raghav is there any sort of benifit in inlining the input instead of just passing it?"><y>#</y><d>2023-08-20</d><h>19:06</h><r>Raghav</r>is there any sort of benifit in inlining the input instead of just passing it?</z><z id="t1692570714" t="lukasz Small benefit for me is that all my queries ignore records that are marked as deleted, and there&apos;s no way to override that - so inlining boolean conditions guarantees that"><y>#</y><d>2023-08-20</d><h>22:31</h><r>lukasz</r>Small benefit for me is that all my queries ignore records that are marked as deleted, and there&apos;s no way to override that - so inlining boolean conditions guarantees that</z><z id="t1693063296" t="Patrick Winter I have the following query for a PostgreSQL database + TimescaleDB extension: (defn get-most-recent-sample &quot;Return most recent sample of `type` for `plant-id`.&quot; [plant-id type] (-&gt;&gt; {:select [[[:time_bucket &quot;1 hour&quot; :time] :bucket] [[:last :value :time] :value] [[:sign [:- [:last :value :time] [:first :value :time]]] :trend]] :from :samples :where [:and [:= :plant-id plant-id] [:= :type (as-other (name type))] [:&gt; :time [:- [:now] [:cast &quot;1 hours&quot; :interval]]]] :group-by [:bucket] :order-by [[:bucket :asc]] :limit 4} sql/format (jdbc/execute! *db*) first)) Running it through honesql.sql/format returns the following: [&quot;SELECT TIME_BUCKET(?, time) AS bucket, LAST(value, time) AS value, SIGN(LAST(value, time) - FIRST(value, time)) AS trend FROM samples WHERE (plant_id = ?) AND (type = ?) AND (time &gt; (NOW() - CAST(? AS interval))) GROUP BY bucket ORDER BY bucket ASC LIMIT ?&quot; &quot;1 hour&quot; #uuid &quot;73c41a17-f698-4c58-9ac4-cfa55c207131&quot; #function[clojure.lang.AFunction/1] &quot;1 hours&quot; 4] If I run this query through psql it works as expected: SELECT TIME_BUCKET(&apos;1 hour&apos;, time) AS bucket, LAST(value, time) AS value, SIGN(LAST(value, time) - FIRST(value, time)) AS trend FROM samples WHERE (plant_id = &apos;73c41a17-f698-4c58-9ac4-cfa55c207131&apos;) AND (type = &apos;temperature&apos;) AND (time &gt; (NOW() - CAST(&apos;1 hours&apos; AS interval))) GROUP BY bucket ORDER BY bucket ASC LIMIT 4 Executing it in Clojure throws the following exception: org.postgresql.util.PSQLException: ERROR: function time_bucket(character varying, timestamp with time zone) does not exist Hint: No function matches the given name and argument types. You might need to add explicit type casts. Position: 8 Any ideas why this happens and what I need to do to fix it?"><y>#</y><d>2023-08-26</d><h>15:21</h><w>Patrick Winter</w>I have the following query for a PostgreSQL database + TimescaleDB extension:
<pre>(defn get-most-recent-sample
  &quot;Return most recent sample of `type` for `plant-id`.&quot;
  [plant-id type]
  (-&gt;&gt;  {:select [[[:time_bucket &quot;1 hour&quot; :time] :bucket]
                  [[:last :value :time] :value]
                  [[:sign [:- [:last :value :time] [:first :value :time]]] :trend]]
         :from :samples
         :where [:and
                 [:= :plant-id plant-id]
                 [:= :type (as-other (name type))]
                 [:&gt; :time [:- [:now] [:cast &quot;1 hours&quot; :interval]]]]
         :group-by [:bucket]
         :order-by [[:bucket :asc]]
         :limit 4}
        sql/format
        (jdbc/execute! *db*)
        first))</pre>
Running it through <code>honesql.sql/format</code> returns the following:
<pre>[&quot;SELECT TIME_BUCKET(?, time) AS bucket, LAST(value, time) AS value, SIGN(LAST(value, time) - FIRST(value, time)) AS trend FROM samples WHERE (plant_id = ?) AND (type = ?) AND (time &gt; (NOW() - CAST(? AS interval))) GROUP BY bucket ORDER BY bucket ASC LIMIT ?&quot;
 &quot;1 hour&quot;
 #uuid &quot;73c41a17-f698-4c58-9ac4-cfa55c207131&quot;
 #function[clojure.lang.AFunction/1]
 &quot;1 hours&quot;
 4]</pre>
If I run this query through <code>psql</code> it works as expected:
<pre>SELECT TIME_BUCKET(&apos;1 hour&apos;, time) AS bucket,
         LAST(value, time) AS value,
         SIGN(LAST(value, time) - FIRST(value, time)) AS trend
    FROM samples WHERE (plant_id = &apos;73c41a17-f698-4c58-9ac4-cfa55c207131&apos;)
     AND (type = &apos;temperature&apos;) AND (time &gt; (NOW() - CAST(&apos;1 hours&apos; AS interval)))
GROUP BY bucket ORDER BY bucket ASC LIMIT 4</pre>
Executing it in Clojure throws the following exception:
<pre>org.postgresql.util.PSQLException: ERROR: function time_bucket(character varying, timestamp with time zone) does not exist
  Hint: No function matches the given name and argument types. You might need to add explicit type casts.
  Position: 8</pre>
Any ideas why this happens and what I need to do to fix it?</z><z id="t1693064110" t="Patrick Winter I think I found a workaround: [:raw &quot;time_bucket(&apos;1 hour&apos;, time)&quot;]"><y>#</y><d>2023-08-26</d><h>15:35</h><r>Patrick Winter</r>I think I found a workaround:
<code>[:raw &quot;time_bucket(&apos;1 hour&apos;, time)&quot;]</code></z><z id="t1693072037" t="seancorfield You could use [:inline &quot;1 hour&quot;] there. No need to revert to :raw ."><y>#</y><d>2023-08-26</d><h>17:47</h><r>seancorfield</r>You could use <code>[:inline &quot;1 hour&quot;]</code> there. No need to revert to <code>:raw</code>.</z><z id="t1693094834" t="seancorfield If anyone feels inclined to test &quot;what&apos;s coming next&quot;, I&apos;d appreciate feedback on the current develop branch either via git deps or the 2.4.9999-SNAPSHOT on Clojars. Here&apos;s what in so far: • 2.4.next in progress • Add :select with function call and alias example to README (PR https://github.com/seancorfield/honeysql/pull/502 [:attrs {:href &quot;/_/_/users/U0JUR9FPH&quot;}] ). • Address https://github.com/seancorfield/honeysql/issues/501 by making INSERT INTO (and REPLACE INTO ) use the :columns or :values clauses to produce column names (which are then omitted from those other clauses). • Address https://github.com/seancorfield/honeysql/issues/497 by adding :alias special syntax. • Address https://github.com/seancorfield/honeysql/issues/496 by adding :overriding-value option to :insert clause. Documentation TBD. • Address https://github.com/seancorfield/honeysql/issues/407 by adding support for temporal queries (see FROM in https://cljdoc.org/d/com.github.seancorfield/honeysql/CURRENT/doc/getting-started/sql-clause-reference#from ). • Address https://github.com/seancorfield/honeysql/issues/389 by adding examples of [:only :table] producing ONLY(table) . • Add :create-or-replace-view to support PostgreSQL&apos;s lack of IF NOT EXISTS for CREATE VIEW . • Attempt to clarify the formatting behavior of the :values clause when used to produce column names. • Update tools.build to 0.9.5 (and remove :java-opts setting from build/run-task )"><y>#</y><d>2023-08-27</d><h>00:07</h><w>seancorfield</w>If anyone feels inclined to test &quot;what&apos;s coming next&quot;, I&apos;d appreciate feedback on the current develop branch either via git deps or the 2.4.9999-SNAPSHOT on Clojars. Here&apos;s what in so far:
• 2.4.next in progress
• Add <code>:select</code> with function call and alias example to README (PR <a href="https://github.com/seancorfield/honeysql/pull/502" target="_blank">https://github.com/seancorfield/honeysql/pull/502</a> <a>@markbastian</a>).
• Address <a href="https://github.com/seancorfield/honeysql/issues/501" target="_blank">https://github.com/seancorfield/honeysql/issues/501</a> by making <code>INSERT INTO</code> (and <code>REPLACE INTO</code>) use the <code>:columns</code> or <code>:values</code> clauses to produce column names (which are then omitted from those other clauses).
• Address <a href="https://github.com/seancorfield/honeysql/issues/497" target="_blank">https://github.com/seancorfield/honeysql/issues/497</a> by adding <code>:alias</code> special syntax.
• Address <a href="https://github.com/seancorfield/honeysql/issues/496" target="_blank">https://github.com/seancorfield/honeysql/issues/496</a> by adding <code>:overriding-value</code> option to <code>:insert</code> clause. Documentation TBD.
• Address <a href="https://github.com/seancorfield/honeysql/issues/407" target="_blank">https://github.com/seancorfield/honeysql/issues/407</a> by adding support for temporal queries (see <code>FROM</code> in <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/CURRENT/doc/getting-started/sql-clause-reference#from" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/CURRENT/doc/getting-started/sql-clause-reference#from</a>).
• Address <a href="https://github.com/seancorfield/honeysql/issues/389" target="_blank">https://github.com/seancorfield/honeysql/issues/389</a> by adding examples of <code>[:only :table]</code> producing <code>ONLY(table)</code>.
• Add <code>:create-or-replace-view</code> to support PostgreSQL&apos;s lack of <code>IF NOT EXISTS</code> for <code>CREATE VIEW</code>.
• Attempt to clarify the formatting behavior of the <code>:values</code> clause when used to produce column names.
• Update <code>tools.build</code> to 0.9.5 (and remove <code>:java-opts</code> setting from <code>build/run-task</code>)</z><z id="t1693166286" t="dharrigan awesome-sauce! 🙂"><y>#</y><d>2023-08-27</d><h>19:58</h><r>dharrigan</r>awesome-sauce! <b>🙂</b></z><z id="t1693170154" t="seancorfield [:attrs {:href &quot;/_/_/users/U11EL3P9U&quot;}] The temporal query stuff is because I&apos;m hoping to use HoneySQL to produce XTDB 2 SQL at some point 🙂"><y>#</y><d>2023-08-27</d><h>21:02</h><r>seancorfield</r><a>@U11EL3P9U</a> The temporal query stuff is because I&apos;m hoping to use HoneySQL to produce XTDB 2 SQL at some point <b>🙂</b></z><z id="t1693170452" t="dharrigan Very interesting stuff - I&apos;ll have to read up on it more! 🙂"><y>#</y><d>2023-08-27</d><h>21:07</h><r>dharrigan</r>Very interesting stuff - I&apos;ll have to read up on it more! <b>🙂</b></z><z id="t1693158055" t="seancorfield This message contains interactive elements."><y>#</y><d>2023-08-27</d><h>17:40</h><w>seancorfield</w>This message contains interactive elements.</z><z id="t1693298929" t="Ernesto Garcia Not sure if there is a way in HoneySQL to write: SELECT date AT TIME ZONE &apos;Europe/London&apos;, ... "><y>#</y><d>2023-08-29</d><h>08:48</h><w>Ernesto Garcia</w>Not sure if there is a way in HoneySQL to write:
<pre>SELECT date AT TIME ZONE &apos;Europe/London&apos;, ...</pre>
</z><z id="t1693299924" t="p-himik Nothing built-in but you can always use :raw or add your own formatter."><y>#</y><d>2023-08-29</d><h>09:05</h><r>p-himik</r>Nothing built-in but you can always use <code>:raw</code> or add your own formatter.</z><z id="t1693299953" t="Ernesto Garcia Yeah, I&apos;m doing (str (sql/format-entity :bank-transaction/date) &quot; AT TIME ZONE &quot; \&apos; dates/*default-zone-id* \&apos;)"><y>#</y><d>2023-08-29</d><h>09:05</h><r>Ernesto Garcia</r>Yeah, I&apos;m doing
<pre>(str (sql/format-entity :bank-transaction/date)
     &quot; AT TIME ZONE &quot;
     \&apos; dates/*default-zone-id* \&apos;)</pre></z><z id="t1693300033" t="Ernesto Garcia ...into a :raw"><y>#</y><d>2023-08-29</d><h>09:07</h><r>Ernesto Garcia</r>...into a <code>:raw</code></z><z id="t1693300603" t="p-himik Yeah, that works. But you also don&apos;t need to call str , you can just use [:raw &quot;str1&quot; &quot; str2 &quot; &quot;str3&quot;] . Note the spaces though since :raw doesn&apos;t add them for you."><y>#</y><d>2023-08-29</d><h>09:16</h><r>p-himik</r>Yeah, that works. But you also don&apos;t need to call <code>str</code>, you can just use <code>[:raw &quot;str1&quot; &quot; str2 &quot; &quot;str3&quot;]</code>. Note the spaces though since <code>:raw</code> doesn&apos;t add them for you.</z><z id="t1693300644" t="p-himik But if you use AT TIME ZONE more than once, I&apos;d recommend adding your own formatter/function/whatever might be more suitable. It&apos;s all well documented."><y>#</y><d>2023-08-29</d><h>09:17</h><r>p-himik</r>But if you use <code>AT TIME ZONE</code> more than once, I&apos;d recommend adding your own formatter/function/whatever might be more suitable. It&apos;s all well documented.</z><z id="t1693300812" t="Ernesto Garcia Yes, I found this implementation: https://github.com/metabase/metabase/blob/435fada0b27f9271f26353cf7ad25162bab70457/src/metabase/util/honey_sql_2.clj#L183"><y>#</y><d>2023-08-29</d><h>09:20</h><r>Ernesto Garcia</r>Yes, I found this implementation: <a href="https://github.com/metabase/metabase/blob/435fada0b27f9271f26353cf7ad25162bab70457/src/metabase/util/honey_sql_2.clj#L183" target="_blank">https://github.com/metabase/metabase/blob/435fada0b27f9271f26353cf7ad25162bab70457/src/metabase/util/honey_sql_2.clj#L183</a></z><z id="t1693332008" t="seancorfield Seems like this is fairly widely-supported SQL so I&apos;ll add it to core https://github.com/seancorfield/honeysql/issues/503 Looks like this is widely-enough supported that it ought to be in the core. Can you create a GitHub issue"><y>#</y><d>2023-08-29</d><h>18:00</h><r>seancorfield</r>Seems like this is fairly widely-supported SQL so I&apos;ll add it to core <a href="https://github.com/seancorfield/honeysql/issues/503" target="_blank">https://github.com/seancorfield/honeysql/issues/503</a>
Looks like this is widely-enough supported that it ought to be in the core. Can you create a GitHub issue</z><z id="t1693332008" t="seancorfield Seems like this is fairly widely-supported SQL so I&apos;ll add it to core https://github.com/seancorfield/honeysql/issues/503 Looks like this is widely-enough supported that it ought to be in the core. Can you create a GitHub issue"><y>#</y><d>2023-08-29</d><h>18:00</h><w>seancorfield</w>Seems like this is fairly widely-supported SQL so I&apos;ll add it to core <a href="https://github.com/seancorfield/honeysql/issues/503" target="_blank">https://github.com/seancorfield/honeysql/issues/503</a>
Looks like this is widely-enough supported that it ought to be in the core. Can you create a GitHub issue</z><z id="t1693851934" t="markaddleman Is there a special incantation to to produce ARRAY_AGG(col IGNORE NULLS) ? I’ve successfully used [:ignore-nulls :col] in analytic functions but it doesn’t seem to work for :array_agg"><y>#</y><d>2023-09-04</d><h>18:25</h><w>markaddleman</w>Is there a special incantation to to produce <code>ARRAY_AGG(col IGNORE NULLS)</code> ?  I’ve successfully used <code>[:ignore-nulls :col]</code> in analytic functions but it doesn’t seem to work for <code>:array_agg</code></z><z id="t1693852586" t="seancorfield :ignore-nulls isn&apos;t built-in -- can you provide a bit more context here?"><y>#</y><d>2023-09-04</d><h>18:36</h><r>seancorfield</r><code>:ignore-nulls</code> isn&apos;t built-in -- can you provide a bit more context here?</z><z id="t1693852668" t="markaddleman I completely forgot that I registered my own :ignore-nulls function. That’s kind of embarrassing 🙂"><y>#</y><d>2023-09-04</d><h>18:37</h><r>markaddleman</r>I completely forgot that I registered my own <code>:ignore-nulls</code> function.  That’s kind of embarrassing <b>🙂</b></z><z id="t1693852709" t="markaddleman I’m not sure how common it is across dialects but it’s regularly used in BigQuery SQL"><y>#</y><d>2023-09-04</d><h>18:38</h><r>markaddleman</r>I’m not sure how common it is across dialects but it’s regularly used in BigQuery SQL</z><z id="t1693852916" t="seancorfield Feel free to create a GH issue for it to be added with a link to supporting docs."><y>#</y><d>2023-09-04</d><h>18:41</h><r>seancorfield</r>Feel free to create a GH issue for it to be added with a link to supporting docs.</z><z id="t1694189192" t="markaddleman Finally got to it: https://github.com/seancorfield/honeysql/issues/504"><y>#</y><d>2023-09-08</d><h>16:06</h><r>markaddleman</r>Finally got to it:  <a href="https://github.com/seancorfield/honeysql/issues/504" target="_blank">https://github.com/seancorfield/honeysql/issues/504</a></z><z id="t1694189199" t="markaddleman Happy to add more docs if helpful"><y>#</y><d>2023-09-08</d><h>16:06</h><r>markaddleman</r>Happy to add more docs if helpful</z><z id="t1694193123" t="seancorfield Thanks. I&apos;ll add :ignore-nulls and :respect-nulls as &quot;special syntax&quot;."><y>#</y><d>2023-09-08</d><h>17:12</h><r>seancorfield</r>Thanks. I&apos;ll add <code>:ignore-nulls</code> and <code>:respect-nulls</code> as &quot;special syntax&quot;.</z><z id="t1695308524" t="seancorfield /github subscribe https://github.com/seancorfield/honeysql"><y>#</y><d>2023-09-21</d><h>15:02</h><w>seancorfield</w>/github subscribe <a href="https://github.com/seancorfield/honeysql" target="_blank">https://github.com/seancorfield/honeysql</a></z><z id="t1695724394" t="Asher Serling Hi, I hope this is the right place to ask, as it&apos;s not only about HoneySql. I&apos;m working on a luminus project. I need to implement some sort of mechanism to ensure that all queries which touch certain tables include certain WHERE conditions, depending on the user for whom the query is being run. I don&apos;t want to have to pass the current user into each query, I&apos;d rather set some sort of global variable, but only for the context of the users request. I&apos;d love to hear recommendations of how to do this nicely, or recommendations for a different direction as well if you have one"><y>#</y><d>2023-09-26</d><h>10:33</h><w>Asher Serling</w>Hi, I hope this is the right place to ask, as it&apos;s not only about HoneySql. I&apos;m working on a luminus project. I need to implement some sort of mechanism to ensure that all queries which touch certain tables include certain WHERE conditions, depending on the user for whom the query is being run. I don&apos;t want to have to pass the current user into each query, I&apos;d rather set some sort of global variable, but only for the context of the users request. I&apos;d love to hear recommendations of how to do this nicely, or recommendations for a different direction as well if you have one</z><z id="t1695724538" t="Asher Serling Would using &apos;binding&apos; be an appropriate solution?"><y>#</y><d>2023-09-26</d><h>10:35</h><w>Asher Serling</w>Would using &apos;binding&apos; be an appropriate solution?</z><z id="t1695732486" t="p-himik In case it&apos;s for security, I&apos;d first reach out to the tools available at the DB level. E.g. PostgreSQL has RLS (Row-Level Security) support built in. I don&apos;t know for sure but if you don&apos;t have separate DB users for each service user you can still set some transaction-level variable to the username and perhaps that can be used inside RLS as well."><y>#</y><d>2023-09-26</d><h>12:48</h><r>p-himik</r>In case it&apos;s for security, I&apos;d first reach out to the tools available at the DB level.
E.g. PostgreSQL has RLS (Row-Level Security) support built in. I don&apos;t know for sure but if you don&apos;t have separate DB users for each service user you can still set some transaction-level variable to the username and perhaps that can be used inside RLS as well.</z><z id="t1695732588" t="Asher Serling It is indeed for security, but it is in this case necessary to implement this mechanism at the application level. I am using PlanetScale, which provides horizontally sharded MySql. They dispatch the query to the correct shard based on the filters in the query"><y>#</y><d>2023-09-26</d><h>12:49</h><r>Asher Serling</r>It is indeed for security, but it is in this case necessary to implement this mechanism at the application level. I am using PlanetScale, which provides horizontally sharded MySql. They dispatch the query to the correct shard based on the filters in the query</z><z id="t1695732637" t="p-himik Huh. Does it also work for all the things like subqueries and CTEs?"><y>#</y><d>2023-09-26</d><h>12:50</h><r>p-himik</r>Huh. Does it also work for all the things like subqueries and CTEs?</z><z id="t1695732757" t="Asher Serling PlanetScale does support subqueries, if that&apos;s what you&apos;re asking. (at least it&apos;s not in the list of things they don&apos;t support)"><y>#</y><d>2023-09-26</d><h>12:52</h><r>Asher Serling</r>PlanetScale does support subqueries, if that&apos;s what you&apos;re asking. (at least it&apos;s not in the list of things they don&apos;t support)</z><z id="t1695732817" t="p-himik Another hypothesis: perhaps you can still set that transaction-level variable to the right username, use the variable in a view definition to always have that WHERE statement, and then only use that view in the right contexts. If that&apos;s a no-go for some reason, I myself would definitely prefer passing the username around. You can create a reasonable abstraction layer around it that combines the connection data (which, I presume, you&apos;re already passing around) with the username. But if you don&apos;t like that approach, dynamic variables with binding is also a solution, yes."><y>#</y><d>2023-09-26</d><h>12:53</h><r>p-himik</r>Another hypothesis: perhaps you can still set that transaction-level variable to the right username, use the variable in a view definition to always have that <code>WHERE</code> statement, and then only use that view in the right contexts.

If that&apos;s a no-go for some reason, I myself would definitely prefer passing the username around. You can create a reasonable abstraction layer around it that combines the connection data (which, I presume, you&apos;re already passing around) with the username.
But if you don&apos;t like that approach, dynamic variables with <code>binding</code> is also a solution, yes.</z><z id="t1695733171" t="Asher Serling Interesting. I would be concerned that developers would forget to use that view. Also, wouldn&apos;t that not be sufficient for update/insert statements? On the other hand, if i have a dynamic variable which determines the behaviour of my system wide function for communicating with the database I could sleep (more) soundly"><y>#</y><d>2023-09-26</d><h>12:59</h><r>Asher Serling</r>Interesting. I would be concerned that developers would forget to use that view. Also, wouldn&apos;t that not be sufficient for update/insert statements? On the other hand, if i have a dynamic variable which determines the behaviour of my system wide function for communicating with the database I could sleep (more) soundly</z><z id="t1695733270" t="Asher Serling That being said I do want to avoid some sneaky dynamic global value"><y>#</y><d>2023-09-26</d><h>13:01</h><r>Asher Serling</r>That being said I do want to avoid some sneaky dynamic global value</z><z id="t1695737641" t="Max Personally, I’d wrap some part of the db interface in a new function that enforced this constraint and checked its input data for a username, throwing an exception if it’s not present. I’d just pass the username down the callstack rather than use some kind of fancy global, it’d probably hang out in some kind of data map that was working its way down the callstack anyways. I’ve long thought that despite the many advantages of the Clojure community’s minimalist approach to database interaction, one disadvantage is that there’s not a good place to encode constraints like “always add a where clause to this table”. With ORMs there’s usually some method on the table class you can use for that sort of thing. I have some half-finished designs in a doc somewhere for a functional approach to this sort of thing, but I never got around to actually implementing it. "><y>#</y><d>2023-09-26</d><h>14:14</h><r>Max</r>Personally, I’d wrap some part of the db interface in a new function that enforced this constraint and checked its input data for a username, throwing an exception if it’s not present. I’d just pass the username down the callstack rather than use some kind of fancy global, it’d probably hang out in some kind of data map that was working its way down the callstack anyways. 

I’ve long thought that despite the many advantages of the Clojure community’s minimalist approach to database interaction, one disadvantage is that there’s not a good place to encode constraints like “always add a where clause to this table”. With ORMs there’s usually some method on the table class you can use for that sort of thing. I have some half-finished designs in a doc somewhere for a functional approach to this sort of thing, but I never got around to actually implementing it. </z><z id="t1695741403" t="p-himik &gt; I would be concerned that developers would forget to use that view The underlying table can be named in an inconvenient way that would e.g. preclude using keyword literals. Or just precede it with - . But it assumes that you can change the names of those tables, of course. &gt; wouldn&apos;t that not be sufficient for update/insert statements? PostgreSQL supports INSTEAD OF triggers that let you define the behavior of data changing queries on a view. Perhaps MySQL has something similar. &gt; I’d just pass the username down the callstack rather than use some kind of fancy global, it’d probably hang out in some kind of data map that was working its way down the callstack anyways. Yeah, that&apos;s exactly what I meant by putting the username behind some abstraction, whatever it might be. &gt; there’s not a good place to encode constraints like “always add a where clause to this table” There is - in your own wrapper for all the DB stuff. If you need this functionality, especially if you need it for many tables, it&apos;s somewhat natural to completely eschew working directly with HoneySQL and route everything via your wrapper with an API that&apos;s suitable for this kind of logic. Even if an ORM has something like that that&apos;s also easy to use and will work in all sorts of nested scenarios, using it still wouldn&apos;t be worth it IMO. :)"><y>#</y><d>2023-09-26</d><h>15:16</h><r>p-himik</r>&gt; I would be concerned that developers would forget to use that view
The underlying table can be named in an inconvenient way that would e.g. preclude using keyword literals. Or just precede it with <code>-</code>. But it assumes that you can change the names of those tables, of course.

&gt; wouldn&apos;t that not be sufficient for update/insert statements?
PostgreSQL supports <code>INSTEAD OF</code> triggers that let you define the behavior of data changing queries on a view.
Perhaps MySQL has something similar.

&gt; I’d just pass the username down the callstack rather than use some kind of fancy global, it’d probably hang out in some kind of data map that was working its way down the callstack anyways.
Yeah, that&apos;s exactly what I meant by putting the username behind some abstraction, whatever it might be.

&gt; there’s not a good place to encode constraints like “always add a where clause to this table”
There is - in your own wrapper for all the DB stuff. If you need this functionality, especially if you need it for many tables, it&apos;s somewhat natural to completely eschew working directly with HoneySQL and route everything via your wrapper with an API that&apos;s suitable for this kind of logic.
Even if an ORM has something like that that&apos;s also easy to use and will work in all sorts of nested scenarios, using it still wouldn&apos;t be worth it IMO. :)</z><z id="t1695741720" t="Max Eh, I think there’s a way to do it while still maintaining the flexibility of using honeysql. The entire advantage of representing queries as data is that data is more composable. That doesn’t have to be thrown out the window to compose in one additional clause. The interesting part is where you compose that clause in…"><y>#</y><d>2023-09-26</d><h>15:22</h><r>Max</r>Eh, I think there’s a way to do it while still maintaining the flexibility of using honeysql. The entire advantage of representing queries as data is that data is more composable. That doesn’t have to be thrown out the window to compose in one additional clause. The interesting part is where you compose that clause in…</z><z id="t1695742268" t="p-himik I&apos;m not talking about query representation, I&apos;m talking about query construction. The latter can be done via a custom API, similar to how Honey&apos;s helpers do it, only in an app-specific way."><y>#</y><d>2023-09-26</d><h>15:31</h><r>p-himik</r>I&apos;m not talking about query representation, I&apos;m talking about query construction. The latter can be done via a custom API, similar to how Honey&apos;s helpers do it, only in an app-specific way.</z><z id="t1695757735" t="Asher Serling [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] i didn&apos;t follow what the advantage of leaving honeySQL for this would be, can you please clarify? What I am considering is always querying the db through a function which accepts a honeySQL data structure, and for that function to update that honeySQL data structure based on the global context. what would be the advantage of implementing logic for working with the query string over working with the data representation of the query?"><y>#</y><d>2023-09-26</d><h>19:48</h><r>Asher Serling</r><a>@U2FRKM4TW</a> i didn&apos;t follow what the advantage of leaving honeySQL for this would be, can you please clarify? What I am considering is always querying the db through a function which accepts a honeySQL data structure, and for that function to update that honeySQL data structure based on the global context. what would be the advantage of implementing logic for working with the query string over working with the data representation of the query?</z><z id="t1695757849" t="Asher Serling [:attrs {:href &quot;/_/_/users/U01EB0V3H39&quot;}] regarding ORMs giving a nice way to register logic that should always be applied, how is that different from modifying a global variable which you don&apos;t like? In working with Laravel&apos;s ORM I have been put off by the magic of registering a &apos;scope&apos; which magically gets applied. I would rather have a single place in my own code which registers some global value that i have full control over"><y>#</y><d>2023-09-26</d><h>19:50</h><r>Asher Serling</r><a>@U01EB0V3H39</a> regarding ORMs giving a nice way to register logic that should always be applied, how is that different from modifying a global variable which you don&apos;t like? In working with Laravel&apos;s ORM I have been put off by the magic of registering a &apos;scope&apos; which magically gets applied. I would rather have a single place in my own code which registers some global value that i have full control over</z></g><g id="s10"><z id="t1695757905" t="Max Re having a fn update the query data structure: that’s exactly what I’d recommend doing, as long as you have a good way to make sure people don’t forget to use that fn. That’s the tricky part 😜 "><y>#</y><d>2023-09-26</d><h>19:51</h><r>Max</r>Re having a fn update the query data structure: that’s exactly what I’d recommend doing, as long as you have a good way to make sure people don’t forget to use that fn. That’s the tricky part <b>😜</b> </z><z id="t1695758182" t="Asher Serling Yes I hear that. I don&apos;t know if it&apos;s possible to completely prevent developers from having to make the right decision, but I think it will be easier to form the habit of always using the same function (which has the db connection string pre-loaded by the way...) than to form the habit of thinking about how to query. What [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] is suggesting regarding giving the tables inconvenient names is interesting, but I would like to have a convenient database to interact with from the sql console too."><y>#</y><d>2023-09-26</d><h>19:56</h><r>Asher Serling</r>Yes I hear that. I don&apos;t know if it&apos;s possible to completely prevent developers from having to make the right decision, but I think it will be easier to form the habit of always using the same function (which has the db connection string pre-loaded by the way...) than to form the habit of thinking about how to query. What <a>@U2FRKM4TW</a> is suggesting regarding giving the tables inconvenient names is interesting, but I would like to have a convenient database to interact with from the sql console too.</z><z id="t1695758874" t="Max To answer your other question, there are two different bits happening here: 1. How to get the username into the query-building fn 2. How to add the where clause to the query, hopefully in a way that makes it hard for devs to forget to add it My recommendation for 1 is just pass it down the callstack, probably in some data map with other stuff in it. There’ll be a fn somewhere that adds the where clause, and possibly it should blow up if it’s not given a username. That’s definitely preferable to a global var. For 2, it sounds like [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] and I both agree you can have a fn that adds it in. If you wanted to go further to ensure devs don’t forget to use it, you could bundle a call to that fn into a replacement for one of the library fns (e.g. sql/format ) so devs literally can’t forget to use it. The design I was playing with did just that, but abstracted through some multimethods that made it easier to define such rules per-table (and query method, etc.) kind of like middleware for db interactions. That’s the thing I was saying I miss from ORMs, being able to hang additional constraint enforcement off of tables. You’d still have to pass the username in, but you wouldn’t be able to forget to apply the constraint. Anyways, you’ll have to determine whether you think that’s a good idea for your project or not."><y>#</y><d>2023-09-26</d><h>20:07</h><r>Max</r>To answer your other question, there are two different bits happening here:
1. How to get the username into the query-building fn
2. How to add the <code>where</code> clause to the query, hopefully in a way that makes it hard for devs to forget to add it
My recommendation for 1 is just pass it down the callstack, probably in some data map with other stuff in it. There’ll be a fn somewhere that adds the <code>where</code> clause, and possibly it should blow up if it’s not given a username. That’s definitely preferable to a global var.

For 2, it sounds like <a>@U2FRKM4TW</a> and I both agree you can have a fn that adds it in. If you wanted to go further to ensure devs don’t forget to use it, you could bundle a call to that fn into a replacement for one of the library fns (e.g. <code>sql/format</code>) so devs literally can’t forget to use it. The design I was playing with did just that, but abstracted through some multimethods that made it easier to define such rules per-table (and query method, etc.) kind of like middleware for db interactions. That’s the thing I was saying I miss from ORMs, being able to hang additional constraint enforcement off of tables. You’d still have to pass the username in, but you wouldn’t be able to forget to apply the constraint. Anyways, you’ll have to determine whether you think that’s a good idea for your project or not.</z><z id="t1695761023" t="p-himik &gt; i didn&apos;t follow what the advantage of leaving honeySQL for this would be, can you please clarify? Yeah, I didn&apos;t mean to drop HoneySQL, I meant to avoid using plain HoneySQL maps and its helpers and instead use your own helpers that would wrap everything the way you want."><y>#</y><d>2023-09-26</d><h>20:43</h><r>p-himik</r>&gt; i didn&apos;t follow what the advantage of leaving honeySQL for this would be, can you please clarify?
Yeah, I didn&apos;t mean to drop HoneySQL, I meant to avoid using plain HoneySQL maps and its helpers and instead use your own helpers that would wrap everything the way you want.</z><z id="t1695858003" t="GitHub"><y>#</y><d>2023-09-27</d><h>23:40</h><w>GitHub</w></z><z id="t1695881601" t="GitHub"><y>#</y><d>2023-09-28</d><h>06:13</h><w>GitHub</w></z><z id="t1696360901" t="GitHub"><y>#</y><d>2023-10-03</d><h>19:21</h><w>GitHub</w></z><z id="t1696477084" t="GitHub"><y>#</y><d>2023-10-05</d><h>03:38</h><w>GitHub</w></z><z id="t1696630309" t="GitHub"><y>#</y><d>2023-10-06</d><h>22:11</h><w>GitHub</w></z><z id="t1696632303" t="GitHub"><y>#</y><d>2023-10-06</d><h>22:45</h><w>GitHub</w></z><z id="t1696706604" t="GitHub"><y>#</y><d>2023-10-07</d><h>19:23</h><w>GitHub</w></z><z id="t1696706702" t="GitHub"><y>#</y><d>2023-10-07</d><h>19:25</h><w>GitHub</w></z><z id="t1696707368" t="seancorfield /github unsubscribe seancorfield/honeysql commits"><y>#</y><d>2023-10-07</d><h>19:36</h><w>seancorfield</w>/github unsubscribe seancorfield/honeysql commits</z><z id="t1697105165" t="tcrawley Morning! I&apos;m in the process of converting Clojars from using yesql to honeysql, and have a query that I don&apos;t know how to write in the honeysql map format. The issue is the query has two LEFT JOIN s, and I&apos;m not sure how to express that. The query in question is https://github.com/clojars/clojars-web/blob/main/resources/queries/queryfile.sql#L466-L494 . The direct translation is the following, but clearly won&apos;t work due to duplicate map keys. I suspect I&apos;m just missing something obvious, but any help would be appreciated! {:select [:j.jar_name :j.group_name :homepage :description :user [:j.version :latest_version] [:r2.version :latest_release]] :from [[:jars :j]] ;; find the latest version :join [[{:select [:jar_name :group_name [[:max :created] :created]] :from :jars :where [:= :group_name group-id] :group-by [:group_name :jar_name]} :l] [:and [:= :j.jar_name :l.jar_name] [:= :j.group_name :l.group_name] [:= :j.created :l.created]]] ;; Find the created ts for latest release :left-join [[{:select [:jar_name :group_name [[:max :created] :created]] :from :jars :where [:and [:= :group_name group-id] [:not [:like :version [:inline &quot;%-SNAPSHOT&quot;]]]] :group-by [:group_name :jar_name]} :r] [:and [:= :j.jar_name :r.jar_name] [:= :j.group_name :r.group_name]]] ;; Find version for latest release :left-join [[{:select [:jar_name :group_name :version :created] :from :jars :where [:= :group_name group-id]} :r2] [:and [:= :j.jar_name :r2.jar_name] [:= :j.group_name :r2.group_name] [:= :r.created :r2.created]]] :where [:= :j.group_name group-id] :order-by [[:j.group_name :asc] [:j.jar_name :asc]]}"><y>#</y><d>2023-10-12</d><h>10:06</h><w>tcrawley</w>Morning! I&apos;m in the process of converting Clojars from using yesql to honeysql, and have a query that I don&apos;t know how to write in the honeysql map format. The issue is the query has two <code>LEFT JOIN</code>s, and I&apos;m not sure how to express that. The query in question is <a href="https://github.com/clojars/clojars-web/blob/main/resources/queries/queryfile.sql#L466-L494" target="_blank">https://github.com/clojars/clojars-web/blob/main/resources/queries/queryfile.sql#L466-L494</a>. The direct translation is the following, but clearly won&apos;t work due to duplicate map keys. I suspect I&apos;m just missing something obvious, but any help would be appreciated!

<pre>{:select [:j.jar_name :j.group_name :homepage :description
               :user [:j.version :latest_version] [:r2.version :latest_release]]
      :from [[:jars :j]]
      ;; find the latest version
      :join [[{:select [:jar_name :group_name [[:max :created] :created]]
               :from :jars
               :where [:= :group_name group-id]
               :group-by [:group_name :jar_name]} :l]
             [:and
              [:= :j.jar_name :l.jar_name]
              [:= :j.group_name :l.group_name]
              [:= :j.created :l.created]]]
      ;; Find the created ts for latest release
      :left-join [[{:select [:jar_name :group_name [[:max :created] :created]]
                    :from :jars
                    :where [:and
                            [:= :group_name group-id]
                            [:not [:like :version [:inline &quot;%-SNAPSHOT&quot;]]]]
                    :group-by [:group_name :jar_name]} :r]
                  [:and
                   [:= :j.jar_name :r.jar_name]
                   [:= :j.group_name :r.group_name]]]
      ;; Find version for latest release
      :left-join [[{:select [:jar_name :group_name :version :created]
                     :from :jars
                     :where [:= :group_name group-id]} :r2]
                   [:and
                    [:= :j.jar_name :r2.jar_name]
                    [:= :j.group_name :r2.group_name]
                    [:= :r.created :r2.created]]]
      :where [:= :j.group_name group-id]
      :order-by [[:j.group_name :asc]
                 [:j.jar_name :asc]]}</pre></z><z id="t1697105664" t="p-himik All joins accept kv-pairs, similar to e.g. hash-map . So, :left-join [t1 cond1 t2 cond2 ...] ."><y>#</y><d>2023-10-12</d><h>10:14</h><r>p-himik</r>All joins accept kv-pairs, similar to e.g. <code>hash-map</code>.
So, <code>:left-join [t1 cond1 t2 cond2 ...]</code>.</z><z id="t1697105812" t="p-himik Also, just in case - stuff like :table.column can be written as :table/column . Personally, I find it easier to read but it&apos;s also easier to create dynamically - (keyword (name table) (name column)) instead of (keyword (str (name table) &quot;.&quot; (name column))) ."><y>#</y><d>2023-10-12</d><h>10:16</h><r>p-himik</r>Also, just in case - stuff like <code>:table.column</code> can be written as <code>:table/column</code>. Personally, I find it easier to read but it&apos;s also easier to create dynamically - <code>(keyword (name table) (name column))</code> instead of <code>(keyword (str (name table) &quot;.&quot; (name column)))</code>.</z><z id="t1697106995" t="tcrawley Thanks [:attrs {:href &quot;/_/_/users/U2FRKM4TW&quot;}] ! I think that did the trick! I tried that earlier, but had an extra vector wrapping the pairs. And thanks for the tip on :table/column"><y>#</y><d>2023-10-12</d><h>10:36</h><r>tcrawley</r>Thanks <a>@U2FRKM4TW</a>! I think that did the trick! I tried that earlier, but had an extra vector wrapping the pairs.

And thanks for the tip on <code>:table/column</code></z><z id="t1697128333" t="seancorfield And if you happen to be working with a database that cares about JOIN order: https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1078/doc/getting-started/sql-clause-reference#join-by"><y>#</y><d>2023-10-12</d><h>16:32</h><r>seancorfield</r>And if you happen to be working with a database that cares about JOIN order: <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1078/doc/getting-started/sql-clause-reference#join-by" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.4.1078/doc/getting-started/sql-clause-reference#join-by</a></z><z id="t1697128484" t="seancorfield Also, don&apos;t forget that HoneySQL also supports the datalog-style of quoted symbolic DSL too: &apos;{select (j/jar_name j/group_name homepage description user (j/version latest_version) (r2/version latest_release)) from ((jars j)) join ...} just in case you get tired of typing all those colons and square brackets 🙂"><y>#</y><d>2023-10-12</d><h>16:34</h><r>seancorfield</r>Also, don&apos;t forget that HoneySQL also supports the datalog-style of quoted symbolic DSL too:
<pre>&apos;{select (j/jar_name j/group_name homepage description
         user (j/version latest_version) (r2/version latest_release))
 from ((jars j))
 join ...}</pre>
just in case you get tired of typing all those colons and square brackets <b>🙂</b></z><z id="t1697139118" t="slipset Not knowing much about anything, but I’d argue that if your database supports common table expressions (CTE), you could rewrite this query to be somewhat more understandable. The three selects you have in your left-joins could be CTEs"><y>#</y><d>2023-10-12</d><h>19:31</h><r>slipset</r>Not knowing much about anything, but I’d argue that if your database supports common table expressions (CTE), you could rewrite this query to be somewhat more understandable.
The three selects you have in your left-joins could be CTEs</z><z id="t1697139248" t="tcrawley Thanks [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] ! The query as translated still works without using join-by (we&apos;re using postgres)"><y>#</y><d>2023-10-12</d><h>19:34</h><r>tcrawley</r>Thanks <a>@U04V70XH6</a>! The query as translated still works without using <code>join-by</code> (we&apos;re using postgres)</z><z id="t1697139279" t="tcrawley [:attrs {:href &quot;/_/_/users/U04V5VAUN&quot;}] I don&apos;t know what CTEs are :) But I&apos;ll check them out, thanks!"><y>#</y><d>2023-10-12</d><h>19:34</h><r>tcrawley</r><a>@U04V5VAUN</a> I don&apos;t know what CTEs are :) But I&apos;ll check them out, thanks!</z><z id="t1697139764" t="p-himik [:attrs {:href &quot;/_/_/users/U04V5VAUN&quot;}] [:attrs {:href &quot;/_/_/users/U06SGCEHJ&quot;}] At least in the case of PostgreSQL, CTEs are evaluated in advance, outside of the context of the main query, so the results will be stored in-memory, there will be no pre-emptive index lookups and so on. I&apos;d argue that a lateral join would be best here. Of course, should be measured if performance is important, but IME a lateral join, when it&apos;s applicable, is always faster than a regular join."><y>#</y><d>2023-10-12</d><h>19:42</h><r>p-himik</r><a>@U04V5VAUN</a> <a>@U06SGCEHJ</a> At least in the case of PostgreSQL, CTEs are evaluated in advance, outside of the context of the main query, so the results will be stored in-memory, there will be no pre-emptive index lookups and so on.

I&apos;d argue that a lateral join would be best here.
Of course, should be measured if performance is important, but IME a lateral join, when it&apos;s applicable, is always faster than a regular join.</z><z id="t1697141640" t="slipset Can’t argue with that, but I will still argue that CTE’s can be easier to read, and also sometimes easier to compose."><y>#</y><d>2023-10-12</d><h>20:14</h><r>slipset</r>Can’t argue with that, but I will still argue that CTE’s can be easier to read, and also sometimes easier to compose.</z><z id="t1697141686" t="p-himik With HoneySQL, any part of the DSL can become a &quot;CTE&quot; of sorts since we have let . :)"><y>#</y><d>2023-10-12</d><h>20:14</h><r>p-himik</r>With HoneySQL, any part of the DSL can become a &quot;CTE&quot; of sorts since we have <code>let</code>. :)</z><z id="t1697142542" t="slipset So your sql would be something like this: WITH latest_jar as (SELECT jar_name, group_name, MAX(created) AS created FROM jars GROUP BY group_name, jar_name), lastest_release AS (SELECT jar_name, group_name, MAX(created) AS created FROM jars WHERE NOT (version LIKE &apos;%-SNAPSHOT&apos;) GROUP BY group_name, jar_name), latest_versions AS (SELECT jar_name, group_name, version, created FROM jars) SELECT j.jar_name, j.group_name, homepage, description, user, j.version AS latest_version, r2.version AS latest_release FROM jars AS j INNER JOIN latest_jar AS l ON (j.jar_name = l.jar_name) AND (j.group_name = l.group_name) AND (j.created = l.created) LEFT JOIN lastest_release AS r ON (j.jar_name = r.jar_name) AND (j.group_name = r.group_name) LEFT JOIN latest_versions AS r2 ON (j.jar_name = r2.jar_name) AND (j.group_name = r2.group_name) AND (r.created = r2.created) WHERE j.group_name = ? ORDER BY j.group_name ASC, j.jar_name ASC I’ve most likely introduced at least 3 errors and missed 5 important things, but you get the gist."><y>#</y><d>2023-10-12</d><h>20:29</h><r>slipset</r>So your sql would be something like this:
<pre>WITH latest_jar as (SELECT jar_name, group_name, MAX(created) AS created FROM jars GROUP BY group_name, jar_name),
lastest_release AS (SELECT jar_name, group_name, MAX(created) AS created FROM jars WHERE NOT (version LIKE &apos;%-SNAPSHOT&apos;) GROUP BY group_name, jar_name),
latest_versions AS (SELECT jar_name, group_name, version, created FROM jars)
SELECT j.jar_name, j.group_name, homepage, description, user, j.version AS latest_version, r2.version AS latest_release
FROM jars AS j
INNER JOIN latest_jar AS l
ON (j.jar_name = l.jar_name)
   AND (j.group_name = l.group_name)
   AND (j.created = l.created)
LEFT JOIN  lastest_release AS r
ON (j.jar_name = r.jar_name)
   AND (j.group_name = r.group_name)
LEFT JOIN latest_versions AS r2
ON (j.jar_name = r2.jar_name)
   AND (j.group_name = r2.group_name)
   AND (r.created = r2.created)
WHERE j.group_name = ?
ORDER BY j.group_name ASC, j.jar_name ASC</pre>
I’ve most likely introduced at least 3 errors and missed 5 important things, but you get the gist.</z><z id="t1697142707" t="p-himik I treat SQL as bytecode - I never read (let alone write) it unless I really have to. It&apos;s hard for me to understand why its readability would be important in the context of HoneySQL."><y>#</y><d>2023-10-12</d><h>20:31</h><r>p-himik</r>I treat SQL as bytecode - I never read (let alone write) it unless I really have to. It&apos;s hard for me to understand why its readability would be important in the context of HoneySQL.</z><z id="t1697142785" t="slipset Interesting. I/we treat our queries as the “important” stuff in our codebase."><y>#</y><d>2023-10-12</d><h>20:33</h><r>slipset</r>Interesting. I/we treat our queries as the “important” stuff in our codebase.</z><z id="t1697142805" t="p-himik Queries - yes. SQL - no."><y>#</y><d>2023-10-12</d><h>20:33</h><r>p-himik</r>Queries - yes. SQL - no.</z><z id="t1697142862" t="p-himik Unfortunately, still have to deal with the implementation details, like the aforementioned fact about large (in the data sense) CTEs being detrimental to performance, potentially significantly."><y>#</y><d>2023-10-12</d><h>20:34</h><r>p-himik</r>Unfortunately, still have to deal with the implementation details, like the aforementioned fact about large (in the data sense) CTEs being detrimental to performance, potentially significantly.</z><z id="t1697142879" t="slipset Hmm, but I/we express our queries in honeysql, so it matters to me that the honey is readable. How do you represent your queries?"><y>#</y><d>2023-10-12</d><h>20:34</h><r>slipset</r>Hmm, but I/we express our queries in honeysql, so it matters to me that the honey is readable. How do you represent your queries?</z><z id="t1697142904" t="slipset Also (in my case), I prefer readable over performant until the performance becomes a problem."><y>#</y><d>2023-10-12</d><h>20:35</h><r>slipset</r>Also (in my case), I prefer readable over performant until the performance becomes a problem.</z><z id="t1697142953" t="p-himik As I said - I use let . If you don&apos;t like to join on something in the middle of a DSL data structure, you can trivially move it to any place outside of that structure."><y>#</y><d>2023-10-12</d><h>20:35</h><r>p-himik</r>As I said - I use <code>let</code>.
If you don&apos;t like to join on something in the middle of a DSL data structure, you can trivially move it to any place outside of that structure.</z><z id="t1697142993" t="slipset Right."><y>#</y><d>2023-10-12</d><h>20:36</h><r>slipset</r>Right.</z><z id="t1697143374" t="p-himik Oh, and even without let , it&apos;s still possible here, at least when there are no deeply nested subqueries, because the data structure is a map - the order of the keys doesn&apos;t matter. Something like: {:left-join [...] :select ... :from ...}"><y>#</y><d>2023-10-12</d><h>20:42</h><r>p-himik</r>Oh, and even without <code>let</code>, it&apos;s still possible here, at least when there are no deeply nested subqueries, because the data structure is a map - the order of the keys doesn&apos;t matter.
Something like:
<pre>{:left-join [...]
 :select    ...
 :from      ...}</pre></z><z id="t1697143911" t="seancorfield And queries compose in HoneySQL so -&gt; through a bunch of smaller functions with good names can often really help readability."><y>#</y><d>2023-10-12</d><h>20:51</h><r>seancorfield</r>And queries compose in HoneySQL so <code>-&gt;</code> through a bunch of smaller functions with good names can often really help readability.</z><z id="t1697144307" t="slipset Agreed."><y>#</y><d>2023-10-12</d><h>20:58</h><r>slipset</r>Agreed.</z><z id="t1700662008" t="Jo Øivind Gjernes Re postgres+CTE / performance: since postgres 12: &gt; Specifically, CTEs are automatically inlined if they have no side-effects, are not recursive, and are referenced only once in the query. Inlining can be prevented by specifying MATERIALIZED, or forced for multiply-referenced CTEs by specifying NOT MATERIALIZED. Previously, CTEs were never inlined and were always evaluated before the rest of the query. Source: https://www.postgresql.org/docs/release/12.0/"><y>#</y><d>2023-11-22</d><h>14:06</h><r>Jo Øivind Gjernes</r>Re postgres+CTE / performance: since postgres 12:

&gt; Specifically, CTEs are automatically inlined if they have no side-effects, are not recursive, and are referenced only once in the query. Inlining can be prevented by specifying MATERIALIZED, or forced for multiply-referenced CTEs by specifying NOT MATERIALIZED. Previously, CTEs were never inlined and were always evaluated before the rest of the query.
Source: <a href="https://www.postgresql.org/docs/release/12.0/" target="_blank">https://www.postgresql.org/docs/release/12.0/</a></z><z id="t1697481013" t="GitHub"><y>#</y><d>2023-10-16</d><h>18:30</h><w>GitHub</w></z><z id="t1697498674" t="GitHub"><y>#</y><d>2023-10-16</d><h>23:24</h><w>GitHub</w></z><z id="t1697556834" t="Ben Lieberman so I have this vector of HoneySQL syntax [[:constraint :FKPostedBy] [:foreign-key :PostedBy] [:references :User :Person]] that outputs this SQL: CONSTRAINT FKPostedBy FOREIGN KEY(PostedBy) REFERENCES User(Person) which seems to accord with SQL Server documentation on the subject of foreign keys...but the DB itself says incorrect syntax near &apos;User&apos; . I have other constraints formatted precisely the same it accepts, however. Any ideas about what I&apos;m missing?"><y>#</y><d>2023-10-17</d><h>15:33</h><w>Ben Lieberman</w>so I have this vector of HoneySQL syntax
<pre>[[:constraint :FKPostedBy] [:foreign-key :PostedBy] [:references :User :Person]]</pre>
that outputs this SQL:
<pre>CONSTRAINT FKPostedBy FOREIGN KEY(PostedBy) REFERENCES User(Person)</pre>
which seems to accord with SQL Server documentation on the subject of foreign keys...but the DB itself says <code>incorrect syntax near &apos;User&apos;</code>. I have other constraints formatted precisely the same it accepts, however. Any ideas about what I&apos;m missing?</z><z id="t1697557111" t="Ben Lieberman Could it be there&apos;s a conflict between the table I&apos;m referencing and one of the internal tables used by SQL Server for database users? I suppose if that&apos;s so I could disambiguate by providing the schema..."><y>#</y><d>2023-10-17</d><h>15:38</h><r>Ben Lieberman</r>Could it be there&apos;s a conflict between the table I&apos;m referencing and one of the internal tables used by SQL Server for database users? I suppose if that&apos;s so I could disambiguate by providing the schema...</z><z id="t1697558997" t="seancorfield I think you need :quoted true"><y>#</y><d>2023-10-17</d><h>16:09</h><r>seancorfield</r>I think you need <code>:quoted true</code></z><z id="t1697559548" t="Ben Lieberman oh nice! That was it. I was trying :raw which did get me past the syntax error as well."><y>#</y><d>2023-10-17</d><h>16:19</h><r>Ben Lieberman</r>oh nice! That was it. I was trying <code>:raw</code> which did get me past the syntax error as well.</z><z id="t1697564302" t="seancorfield :raw should pretty much always be a last resort at this point..."><y>#</y><d>2023-10-17</d><h>17:38</h><r>seancorfield</r><code>:raw</code> should pretty much always be a last resort at this point...</z><z id="t1697564320" t="Ben Lieberman duly noted! :saluting_face:"><y>#</y><d>2023-10-17</d><h>17:38</h><r>Ben Lieberman</r>duly noted! <b>:saluting_face:</b></z><z id="t1697582470" t="Ben Lieberman Question: when dealing with PreparedStatement s is it better to just go for handwriting a string of SQL? I just ran into a problem the solution to which is clear in hindsight but I spent some time overlooking, namely that HoneySQL, given something like (sql/format {:insert-into :a-table :columns [:a-column :another] :values [[1 :foo] [2 :bar]]}) it produces multiple sets of (?, ?) in the resulting string. But as far as I can tell, PreparedStatement only ever wants one of those, is that correct?"><y>#</y><d>2023-10-17</d><h>22:41</h><w>Ben Lieberman</w>Question: when dealing with <code>PreparedStatement</code>s is it better to just go for handwriting a string of SQL? I just ran into a problem the solution to which is clear in hindsight but I spent some time overlooking, namely that HoneySQL, given something like
<pre>(sql/format {:insert-into :a-table
             :columns [:a-column :another]
             :values [[1 :foo] [2 :bar]]})</pre>
it produces multiple sets of <code>(?, ?)</code> in the resulting string. But as far as I can tell, <code>PreparedStatement</code> only ever wants one of those, is that correct?</z><z id="t1697582604" t="seancorfield The short answer is: no, not correct. Can you back up and explain more of the context and whether you&apos;ve actually run into a problem?"><y>#</y><d>2023-10-17</d><h>22:43</h><r>seancorfield</r>The short answer is: no, not correct.

Can you back up and explain more of the context and whether you&apos;ve actually run into a problem?</z><z id="t1697582670" t="seancorfield PreparedStatement has nothing to do with HoneySQL, so it seems you&apos;re asking about some next.jdbc issue here really?"><y>#</y><d>2023-10-17</d><h>22:44</h><r>seancorfield</r><code>PreparedStatement</code> has nothing to do with HoneySQL, so it seems you&apos;re asking about some <code>next.jdbc</code> issue here really?</z><z id="t1697582750" t="Ben Lieberman yeah, the root of the problem for me originated in JDBC but I think I was using the HoneySQL DDL in a manner that was producing a SQL string that JDBC didn&apos;t like"><y>#</y><d>2023-10-17</d><h>22:45</h><r>Ben Lieberman</r>yeah, the root of the problem for me originated in JDBC but I think I was using the HoneySQL DDL in a manner that was producing a SQL string that JDBC didn&apos;t like</z><z id="t1697582770" t="seancorfield DDL != SQL -- you mean DSL?"><y>#</y><d>2023-10-17</d><h>22:46</h><r>seancorfield</r>DDL != SQL -- you mean DSL?</z><z id="t1697582783" t="Ben Lieberman yes"><y>#</y><d>2023-10-17</d><h>22:46</h><r>Ben Lieberman</r>yes</z><z id="t1697582808" t="seancorfield OK, so you have some vector with SQL + params and how are you processing that?"><y>#</y><d>2023-10-17</d><h>22:46</h><r>seancorfield</r>OK, so you have some vector with SQL + params and how are you processing that?</z><z id="t1697582811" t="seancorfield (show code)"><y>#</y><d>2023-10-17</d><h>22:46</h><r>seancorfield</r>(show code)</z><z id="t1697582896" t="seancorfield Which database? Which driver? Versions of both? What exactly is the error you get? Is this for next.jdbc or c.j.j?"><y>#</y><d>2023-10-17</d><h>22:48</h><r>seancorfield</r>Which database? Which driver? Versions of both? What exactly is the error you get? Is this for <code>next.jdbc</code> or c.j.j?</z><z id="t1697583172" t="Ben Lieberman I had a vector of seqs of data like [(1,2,3),(4,5,6)...] that I was passing into the :values key like so {:insert-into :a-table :columns [:a-column :another :a-third] :values [(1,2,3),(4,5,6)]} and it was producing [&quot;INSERT INTO a-table (a-column, another, a third) values (?, ?, ?), (?,?,?)&quot;] which SQL Server (unfortunately a literally archaic version, 2012) doesn&apos;t like. But it gives me this error the conversion from UNKNOWN to UNKNOWN is unsupported "><y>#</y><d>2023-10-17</d><h>22:52</h><r>Ben Lieberman</r>I had a vector of seqs of data like
<pre>[(1,2,3),(4,5,6)...]</pre>
that I was passing into the :values key like so
<pre>{:insert-into :a-table
             :columns [:a-column :another :a-third]
             :values [(1,2,3),(4,5,6)]}</pre>
and it was producing
<pre>[&quot;INSERT INTO a-table (a-column, another, a third) values (?, ?, ?), (?,?,?)&quot;]</pre>
which SQL Server (unfortunately a literally archaic version, 2012) doesn&apos;t like. But it gives me this error
<pre>the conversion from UNKNOWN to UNKNOWN is unsupported</pre>
</z><z id="t1697583227" t="Ben Lieberman What I ended up doing is only using the :insert-into and :columns keys and adding the rest by hand"><y>#</y><d>2023-10-17</d><h>22:53</h><r>Ben Lieberman</r>What I ended up doing is only using the <code>:insert-into</code> and <code>:columns</code> keys and adding the rest by hand</z><z id="t1697583231" t="Ben Lieberman which works"><y>#</y><d>2023-10-17</d><h>22:53</h><r>Ben Lieberman</r>which works</z><z id="t1697583239" t="seancorfield &gt; and it was producing Presumably with 1 2 3 4 5 6 in that vector as well?"><y>#</y><d>2023-10-17</d><h>22:53</h><r>seancorfield</r>&gt; and it was producing
Presumably with <code>1 2 3 4 5 6</code> in that vector as well?</z><z id="t1697583268" t="seancorfield You&apos;re still not describing any of the JDBC side of this -- HoneySQL does not execute SQL."><y>#</y><d>2023-10-17</d><h>22:54</h><r>seancorfield</r>You&apos;re still not describing any of the JDBC side of this -- HoneySQL does not execute SQL.</z><z id="t1697583390" t="Ben Lieberman this is the non-working code (let [[sql &amp; param-groups] (sql/format insert-pop-data :quoted true)] (try (jdbc/execute-batch! ds sql [(partition 26 param-groups)] {:batch-size 100 :return-keys true}) (catch SQLServerException e (Throwable-&gt;map e)))) and this is what works (with-open [conn (jdbc/get-connection ds) stmt (jdbc/prepare conn insert-pop-data)] (jdbc/execute-batch! stmt test-data {:batch-size 100 :return-keys true}))"><y>#</y><d>2023-10-17</d><h>22:56</h><r>Ben Lieberman</r>this is the non-working code
<pre>(let [[sql &amp; param-groups]  (sql/format insert-pop-data :quoted true)]
    (try (jdbc/execute-batch! ds sql [(partition 26 param-groups)] {:batch-size 100
                                                                    :return-keys true})
         (catch SQLServerException e
           (Throwable-&gt;map e))))</pre>
and this is what works
<pre>(with-open [conn (jdbc/get-connection ds)
              stmt (jdbc/prepare conn insert-pop-data)]
    (jdbc/execute-batch! stmt test-data {:batch-size 100
                                         :return-keys true}))</pre></z><z id="t1697583459" t="seancorfield OK, execute-batch! is kind of weird -- it doesn&apos;t take a standard [SQL+params]` vector"><y>#</y><d>2023-10-17</d><h>22:57</h><r>seancorfield</r>OK, <code>execute-batch!</code> is kind of weird -- it doesn&apos;t take a standard [SQL+params]` vector</z><z id="t1697583496" t="seancorfield If you use regular execute! , the generated HoneySQL stuff works, but that won&apos;t necessarily get you the fast batch insertion."><y>#</y><d>2023-10-17</d><h>22:58</h><r>seancorfield</r>If you use regular <code>execute!</code>, the generated HoneySQL stuff works, but that won&apos;t necessarily get you the fast batch insertion.</z><z id="t1697583556" t="Ben Lieberman yeah I moved to execute-batch! from execute! because I was hitting the TDS parameter limit"><y>#</y><d>2023-10-17</d><h>22:59</h><r>Ben Lieberman</r>yeah I moved to <code>execute-batch!</code> from <code>execute!</code> because I was hitting the TDS parameter limit</z><z id="t1697583654" t="seancorfield What you can do in have a HoneySQL DSL with just one row of (dummy) data -- dummy, since you&apos;ll throw it away -- and generate [SQL+params] which will have the dummy params and then use the SQL portion with a partition of your original data. But you can&apos;t just pass all that data into HoneySQL if your target is execute-batch!"><y>#</y><d>2023-10-17</d><h>23:00</h><r>seancorfield</r>What you can do in have a HoneySQL DSL with just one row of (dummy) data -- dummy, since you&apos;ll throw it away -- and generate [SQL+params] which will have the dummy params and then use the SQL portion with a partition of your original data. But you can&apos;t just pass all that data into HoneySQL if your target is <code>execute-batch!</code></z><z id="t1697583750" t="seancorfield The issue is that the SQL needed for execute-batch! is as-if you are inserting only one row, but then you pass multiple rows to execute-batch! itself and it does the &quot;magic&quot; behind the scenes."><y>#</y><d>2023-10-17</d><h>23:02</h><r>seancorfield</r>The issue is that the SQL needed for <code>execute-batch!</code> is as-if you are inserting only one row, but then you pass multiple rows to <code>execute-batch!</code> itself and it does the &quot;magic&quot; behind the scenes.</z><z id="t1697583815" t="seancorfield execute! uses PreparedStatement and .execute() under the hood so this is not a limitation of PreparedStatement . execute-batch! uses .executeBatch() under the hood so it&apos;s different at the JDBC level."><y>#</y><d>2023-10-17</d><h>23:03</h><r>seancorfield</r><code>execute!</code> uses <code>PreparedStatement</code> and <code>.execute()</code> under the hood so this is not a limitation of <code>PreparedStatement</code>. <code>execute-batch!</code> uses <code>.executeBatch()</code> under the hood so it&apos;s different at the JDBC level.</z><z id="t1697583825" t="Ben Lieberman somewhat awful but the hack I did was (-&gt; (sql/format {:insert-into :table :columns [:a, :b, :c]} first (str &quot; VALUES (?,?,?)&quot;) vector) which does work but is surely not great"><y>#</y><d>2023-10-17</d><h>23:03</h><r>Ben Lieberman</r>somewhat awful but the hack I did was
<pre>(-&gt; (sql/format {:insert-into :table
                 :columns [:a, :b, :c]}
   first
   (str &quot; VALUES (?,?,?)&quot;)
   vector)</pre>
which does work but is surely not great</z><z id="t1697583859" t="seancorfield That is certainly up there on the list of things which are &quot;not great&quot;, yes 😄"><y>#</y><d>2023-10-17</d><h>23:04</h><r>seancorfield</r>That is certainly up there on the list of things which are &quot;not great&quot;, yes <b>😄</b></z><z id="t1697583906" t="seancorfield :values [(first data)] where data is all your rows."><y>#</y><d>2023-10-17</d><h>23:05</h><r>seancorfield</r><code>:values [(first data)]</code> where <code>data</code> is all your rows.</z><z id="t1697583957" t="seancorfield Just watch out for nil and true / false getting generated inline..."><y>#</y><d>2023-10-17</d><h>23:05</h><r>seancorfield</r>Just watch out for <code>nil</code> and <code>true</code> / <code>false</code> getting generated inline...</z><z id="t1697583965" t="seancorfield OK, gotta run."><y>#</y><d>2023-10-17</d><h>23:06</h><r>seancorfield</r>OK, gotta run.</z><z id="t1697583975" t="Ben Lieberman I spent a long time banging my head against the wall over this, largely due to that stunningly opaque error cited above, so thank you for your help and insight!"><y>#</y><d>2023-10-17</d><h>23:06</h><r>Ben Lieberman</r>I spent a long time banging my head against the wall over this, largely due to that stunningly opaque error cited above, so thank you for your help and insight!</z><z id="t1697584929" t="seancorfield Yeah, SQL Server (or its driver) is being spectacularly unhelpful there..."><y>#</y><d>2023-10-17</d><h>23:22</h><r>seancorfield</r>Yeah, SQL Server (or its driver) is being spectacularly unhelpful there...</z><z id="t1697585193" t="seancorfield Unfortunately, this is just one of those JDBC oddities for which there is no really good solution re: HoneySQL since it is a generic formatter. As you can see, if you start with a vector of vectors (rows) of data, it&apos;s that vector you need to pass to execute-batch! and the parameters in the SQL+params vector produced by HoneySQL really don&apos;t matter (after all, why would you pass vector of vectors to HoneySQL only to have it unroll them into that SQL+params data again?)."><y>#</y><d>2023-10-17</d><h>23:26</h><r>seancorfield</r>Unfortunately, this is just one of those JDBC oddities for which there is no really good solution re: HoneySQL since it is a generic formatter. As you can see, if you start with a vector of vectors (rows) of data, it&apos;s that vector you need to pass to <code>execute-batch!</code> and the parameters in the SQL+params vector produced by HoneySQL really don&apos;t matter (after all, why would you pass vector of vectors to HoneySQL only to have it unroll them into that SQL+params data again?).</z><z id="t1697585209" t="seancorfield Anyways, off to the gym now for real."><y>#</y><d>2023-10-17</d><h>23:26</h><r>seancorfield</r>Anyways, off to the gym now for real.</z><z id="t1697823744" t="GitHub"><y>#</y><d>2023-10-20</d><h>17:42</h><w>GitHub</w></z><z id="t1697926534" t="john-shaffer https://honeysql.fly.dev/ prototype SQL to HoneySQL translator"><y>#</y><d>2023-10-21</d><h>22:15</h><w>john-shaffer</w><a href="https://honeysql.fly.dev/" target="_blank">https://honeysql.fly.dev/</a>
prototype SQL to HoneySQL translator</z><z id="t1697926694" t="seancorfield I typed in select a from x and got nothing -- is there some button or action to trigger the translator?"><y>#</y><d>2023-10-21</d><h>22:18</h><r>seancorfield</r>I typed in <code>select a from x</code> and got nothing -- is there some button or action to trigger the translator?</z><z id="t1697926714" t="john-shaffer oh sorry, i always do ctrl-enter"><y>#</y><d>2023-10-21</d><h>22:18</h><r>john-shaffer</r>oh sorry, i always do ctrl-enter</z><z id="t1697926720" t="john-shaffer was going to add a button and just forgot"><y>#</y><d>2023-10-21</d><h>22:18</h><r>john-shaffer</r>was going to add a button and just forgot</z><z id="t1697926822" t="seancorfield"><y>#</y><d>2023-10-21</d><h>22:20</h><r>seancorfield</r></z><z id="t1697926886" t="seancorfield It looks a bit LLM-ish -- is that how it works behind the scenes? Ask for HoneySQL expression to generate the given SQL, then run it through format to see if it produces the right output?"><y>#</y><d>2023-10-21</d><h>22:21</h><r>seancorfield</r>It looks a bit LLM-ish -- is that how it works behind the scenes? Ask for HoneySQL expression to generate the given SQL, then run it through format to see if it produces the right output?</z><z id="t1697926968" t="john-shaffer yes, it is a fine-tuned gpt-3.5"><y>#</y><d>2023-10-21</d><h>22:22</h><r>john-shaffer</r>yes, it is a fine-tuned gpt-3.5</z><z id="t1697927068" t="john-shaffer hopefully more training data will help with those cases"><y>#</y><d>2023-10-21</d><h>22:24</h><r>john-shaffer</r>hopefully more training data will help with those cases</z><z id="t1697927097" t="john-shaffer it doesn&apos;t do insert into x select yet either"><y>#</y><d>2023-10-21</d><h>22:24</h><r>john-shaffer</r>it doesn&apos;t do insert into x select yet either</z><z id="t1697927249" t="seancorfield Interesting approach..."><y>#</y><d>2023-10-21</d><h>22:27</h><r>seancorfield</r>Interesting approach...</z><z id="t1697927409" t="john-shaffer So far I&apos;m seeing it get SELECT a AS b and INSERT INTO a SELECT ... wrong. Postgres operators like -&gt; too"><y>#</y><d>2023-10-21</d><h>22:30</h><r>john-shaffer</r>So far I&apos;m seeing it get <code>SELECT a AS b</code> and <code>INSERT INTO a SELECT ...</code> wrong. Postgres operators like <code>-&gt;</code> too</z><z id="t1697931032" t="seancorfield I plan to cut a new HoneySQL release before the end of the month with https://github.com/seancorfield/honeysql/issues/510 and https://github.com/seancorfield/honeysql/issues/511 both addressed. A first cut of both is available on the latest develop branch and as the latest 2.4.9999-SNAPSHOT if folks would like to test the new features and a) make sure they work and b) provide feedback. The NRQL dialect is very much a &quot;first cut&quot;. It doesn&apos;t support all of the NRQL extensions to SQL: I want to see what sort of stuff people want/need before I spend effort on extensions that &quot;no one uses&quot; 🙂"><y>#</y><d>2023-10-21</d><h>23:30</h><w>seancorfield</w>I plan to cut a new HoneySQL release before the end of the month with <a href="https://github.com/seancorfield/honeysql/issues/510" target="_blank">https://github.com/seancorfield/honeysql/issues/510</a> and <a href="https://github.com/seancorfield/honeysql/issues/511" target="_blank">https://github.com/seancorfield/honeysql/issues/511</a> both addressed. A first cut of both is available on the latest develop branch and as the latest 2.4.9999-SNAPSHOT if folks would like to test the new features and a) make sure they work and b) provide feedback.

The NRQL dialect is very much a &quot;first cut&quot;. It doesn&apos;t support all of the NRQL extensions to SQL: I want to see what sort of stuff people want/need before I spend effort on extensions that &quot;no one uses&quot; <b>🙂</b></z><z id="t1698012402" t="nate I think the initial NRQL support is sufficient for my needs. I’ll double check tomorrow. "><y>#</y><d>2023-10-22</d><h>22:06</h><r>nate</r>I think the initial NRQL support is sufficient for my needs. I’ll double check tomorrow. </z><z id="t1698071488" t="seancorfield [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] How&apos;s the improved BigQuery support working for you?"><y>#</y><d>2023-10-23</d><h>14:31</h><r>seancorfield</r><a>@U2845S9KL</a> How&apos;s the improved BigQuery support working for you?</z><z id="t1698071568" t="markaddleman Works great. I have a very simple use case and I’m not sure how complicated it gets but the implementation looks good to go"><y>#</y><d>2023-10-23</d><h>14:32</h><r>markaddleman</r>Works great.  I have a very simple use case and I’m not sure how complicated it gets but the implementation looks good to go</z><z id="t1698074538" t="seancorfield Thank you, both. I&apos;ll probably cut the release mid-week."><y>#</y><d>2023-10-23</d><h>15:22</h><r>seancorfield</r>Thank you, both. I&apos;ll probably cut the release mid-week.</z><z id="t1698097160" t="nate I double checked, and it&apos;s good for me for now. Thank you Sean!"><y>#</y><d>2023-10-23</d><h>21:39</h><r>nate</r>I double checked, and it&apos;s good for me for now. Thank you Sean!</z><z id="t1698503313" t="GitHub"><y>#</y><d>2023-10-28</d><h>14:28</h><w>GitHub</w></z><z id="t1699978560" t="Sam H on this, my work colleague ran into the metadata issue when something was adding :end-line and :end-column with numbers as values. (`file` was also there but that had a string value) They were using doomacs so maybe something on cider / refactor-nrepl side added the extra key-values"><y>#</y><d>2023-11-14</d><h>16:16</h><w>Sam H</w>on this, my work colleague ran into the metadata issue when something was adding <code>:end-line</code> and <code>:end-column</code> with numbers as values. (`file` was also there but that had a string value)
They were using doomacs so maybe something on cider / refactor-nrepl side added the extra key-values</z><z id="t1699983447" t="seancorfield https://github.com/seancorfield/honeysql/issues/513"><y>#</y><d>2023-11-14</d><h>17:37</h><w>seancorfield</w><a href="https://github.com/seancorfield/honeysql/issues/513" target="_blank">https://github.com/seancorfield/honeysql/issues/513</a></z><z id="t1699229306" t="Bailey Kocin Is there a better channel to ask honeysql questions? I want to know if I can manage to create a delete like so delete from table where (first, second) in ((1,2), (2,1)) by just using the helpers and not having to dip into raw sql.... I know this tuple syntax works in postgres at least, not sure if its common either...."><y>#</y><d>2023-11-06</d><h>00:08</h><w>Bailey Kocin</w>Is there a better channel to ask honeysql questions? I want to know if I can manage to create a delete like so

<pre>delete from table where (first, second) in ((1,2), (2,1))</pre>
by just using the helpers and not having to dip into raw sql....

I know this tuple syntax works in postgres at least, not sure if its common either....</z><z id="t1699229625" t="seancorfield This is the HoneySQL channel so you&apos;re in the right place. What have you tried? How close did you get to what you wanted?"><y>#</y><d>2023-11-06</d><h>00:13</h><r>seancorfield</r>This is the HoneySQL channel so you&apos;re in the right place.

What have you tried? How close did you get to what you wanted?</z><z id="t1699229734" t="seancorfield You probably want :composite to build those tuples."><y>#</y><d>2023-11-06</d><h>00:15</h><r>seancorfield</r>You probably want <code>:composite</code> to build those tuples.</z><z id="t1699230004" t="Bailey Kocin Well I did not the :composite keyword/helper existed so this is a start, I was just using the raw syntax and was wondering if something like this existed so thanks!"><y>#</y><d>2023-11-06</d><h>00:20</h><r>Bailey Kocin</r>Well I did not the :composite keyword/helper existed so this is a start, I was just using the raw syntax and was wondering if something like this existed so thanks!</z><z id="t1699230197" t="seancorfield (-&gt; (delete-from :table) (where [:in (composite :first :second) [(composite 1 2) (composite 2 1)]]) (format))"><y>#</y><d>2023-11-06</d><h>00:23</h><r>seancorfield</r><pre>(-&gt; (delete-from :table)
      (where [:in (composite :first :second)
              [(composite 1 2) (composite 2 1)]])
      (format))</pre></z><z id="t1699230234" t="seancorfield https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/api/honey.sql.helpers lists all the helpers"><y>#</y><d>2023-11-06</d><h>00:23</h><r>seancorfield</r><a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/api/honey.sql.helpers" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/api/honey.sql.helpers</a> lists all the helpers</z><z id="t1699230342" t="seancorfield composite is mentioned in https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started#functional-helpers and there&apos;s an example in the README too (according to that section of the Getting Started doc)."><y>#</y><d>2023-11-06</d><h>00:25</h><r>seancorfield</r><code>composite</code> is mentioned in <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started#functional-helpers" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started#functional-helpers</a> and there&apos;s an example in the README too (according to that section of the Getting Started doc).</z><z id="t1699230372" t="seancorfield Ah yes, there&apos;s a whole section in the README about composite types https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/readme#composite-types"><y>#</y><d>2023-11-06</d><h>00:26</h><r>seancorfield</r>Ah yes, there&apos;s a whole section in the README about composite types <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/readme#composite-types" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/readme#composite-types</a></z><z id="t1699284929" t="Bailey Kocin Thanks!"><y>#</y><d>2023-11-06</d><h>15:35</h><r>Bailey Kocin</r>Thanks!</z><z id="t1699264347" t="p-himik [:attrs {:href &quot;/_/_/users/U04V70XH6&quot;}] In https://github.com/seancorfield/next-jdbc/commit/3a6539f3e2704ad79a7b070c4ab13d8671adf155 you have switched from com.opentable.components/otj-pg-embedded to io.zonky.test/embedded-postgres , probably because the former wasn&apos;t maintained. But seems that the former has picked up the pace. I wonder - have you re-evaluated otj-pg-embedded any time recently? Trying to decide which one to use in my projects."><y>#</y><d>2023-11-06</d><h>09:52</h><w>p-himik</w><a>@seancorfield</a> In <a href="https://github.com/seancorfield/next-jdbc/commit/3a6539f3e2704ad79a7b070c4ab13d8671adf155" target="_blank">https://github.com/seancorfield/next-jdbc/commit/3a6539f3e2704ad79a7b070c4ab13d8671adf155</a> you have switched from <code>com.opentable.components/otj-pg-embedded</code> to <code>io.zonky.test/embedded-postgres</code>, probably because the former wasn&apos;t maintained.
But seems that the former has picked up the pace.
I wonder - have you re-evaluated <code>otj-pg-embedded</code> any time recently? Trying to decide which one to use in my projects.</z><z id="t1699289531" t="seancorfield Since zonky seemed to be continuously maintained I haven&apos;t looked at alternatives. I don&apos;t use postgresql so this is &quot;just&quot; a testing convenience for me."><y>#</y><d>2023-11-06</d><h>16:52</h><r>seancorfield</r>Since zonky seemed to be continuously maintained I haven&apos;t looked at alternatives. I don&apos;t use postgresql so this is &quot;just&quot; a testing convenience for me.</z><z id="t1699364673" t="Akiz I am trying to convert this PostgreSQL query into HoneySQL `SELECT` *types*.value -&gt;&gt; &apos;name&apos; *AS* *`name`* *from* my_types mt, *jsonb_each*(mt.type_data -&gt; &apos;types&apos;) *AS* *`types`* How can I write jsonb_each in honeysql?"><y>#</y><d>2023-11-07</d><h>13:44</h><w>Akiz</w>I am trying to convert this PostgreSQL query into HoneySQL
`SELECT` <code>*types*.value -&gt;&gt; &apos;name&apos; *AS*</code> *`name`*
<code>*from* my_types mt,</code>
<code>*jsonb_each*(mt.type_data -&gt; &apos;types&apos;) *AS*</code> *`types`*

How can I write <code>jsonb_each</code> in honeysql?</z><z id="t1699365177" t="oly Not familiar with -&gt; and -&gt;&gt; in postgres but I think this gives you what you want (-&gt; (sqlh/select :types.value [[:raw &quot;-&gt;&gt; name&quot;]] :name) (sqlh/from :mt_types [ [:jsonb_each :mt.type_data [:raw &quot;-&gt; types&quot;]] :types]) (sql/format)) ;; =&gt; [&quot;SELECT types.value, -&gt;&gt; name, name FROM mt_types, JSONB_EACH(mt.type_data, -&gt; types) AS types&quot;]"><y>#</y><d>2023-11-07</d><h>13:52</h><r>oly</r>Not familiar with -&gt; and -&gt;&gt; in postgres but I think this gives you what you want
<pre>(-&gt; (sqlh/select :types.value [[:raw &quot;-&gt;&gt; name&quot;]] :name)
    (sqlh/from :mt_types [ [:jsonb_each :mt.type_data [:raw &quot;-&gt; types&quot;]] :types])
    (sql/format))
;; =&gt; [&quot;SELECT types.value, -&gt;&gt; name, name FROM mt_types, JSONB_EACH(mt.type_data, -&gt; types) AS types&quot;]</pre></z><z id="t1699365241" t="Akiz Thank you, this is exactly what I want. I didn’t realize that jsonb_each is part of from :-)."><y>#</y><d>2023-11-07</d><h>13:54</h><r>Akiz</r>Thank you, this is exactly what I want.
I didn’t realize that <code>jsonb_each</code> is part of <code>from</code> :-).</z><z id="t1699365329" t="oly yeah I did not notice at first, not written a postgres query like that before, but seemed an interesting challenge to test my honeysql knowledge 🙂"><y>#</y><d>2023-11-07</d><h>13:55</h><r>oly</r>yeah I did not notice at first, not written a postgres query like that before, but seemed an interesting challenge to test my honeysql knowledge <b>🙂</b></z><z id="t1699365352" t="Akiz Working query.. {:select [[[:-&gt;&gt; :types.values &quot;name&quot;] &quot;name&quot;]] :from [[:my_types :mt] [:jsonb_each [[:-&gt; :mt.type-data &quot;types&quot;] &quot;types&quot;]]] }"><y>#</y><d>2023-11-07</d><h>13:55</h><r>Akiz</r>Working query..

<code>{:select [[[:-&gt;&gt; :types.values &quot;name&quot;] &quot;name&quot;]]</code>
 <code>:from [[:my_types :mt]</code>
        <code>[:jsonb_each [[:-&gt; :mt.type-data &quot;types&quot;] &quot;types&quot;]]]</code>
<code>}</code></z><z id="t1699365397" t="Akiz (to have support for :-&gt; next.jdbc pg-opts must be loaded.."><y>#</y><d>2023-11-07</d><h>13:56</h><r>Akiz</r>(to have support for <code>:-&gt;</code>  next.jdbc pg-opts must be loaded..</z><z id="t1699365449" t="oly cool glad it helped :)"><y>#</y><d>2023-11-07</d><h>13:57</h><r>oly</r>cool glad it helped :)</z><z id="t1699576508" t="Nick McAvoy Query a and query b return the same set of keys, but if I do (-&gt; query-a (union query-b)) , the resulting keys are not namespaced. e.g. instead of :atable/column_a , just :column_a . Is this expected? Is there any easy workaround? Thank you!"><y>#</y><d>2023-11-10</d><h>00:35</h><w>Nick McAvoy</w>Query <code>a</code> and query <code>b</code> return the same set of keys, but if I do <code>(-&gt; query-a (union query-b))</code>, the resulting keys are not namespaced. e.g. instead of <code>:atable/column_a</code>, just <code>:column_a</code>.

Is this expected? Is there any easy workaround? Thank you!</z><z id="t1699588168" t="seancorfield It&apos;s up to the database/driver whether table names are provided to the caller. If next.jdbc doesn&apos;t return qualified keys, then the driver didn&apos;t make table names available. (And this has nothing to do with HoneySQL)"><y>#</y><d>2023-11-10</d><h>03:49</h><r>seancorfield</r>It&apos;s up to the database/driver whether table names are provided to the caller. If <code>next.jdbc</code> doesn&apos;t return qualified keys, then the driver didn&apos;t make table names available.

(And this has nothing to do with HoneySQL)</z><z id="t1699714841" t="Ngoc Khuat 👋 👋 Could anyone please help me understand why this is an illegal syntax? (honey.sql/format {:select [[:+ 1 1]]}) ;; =&gt; illegal syntax in select expression I’m expecting it to generate select 1 + 1;"><y>#</y><d>2023-11-11</d><h>15:00</h><w>Ngoc Khuat</w><b>👋</b> <b>👋</b>

Could anyone please help me understand why this is an illegal syntax?

<pre>(honey.sql/format {:select [[:+ 1 1]]})
;; =&gt; illegal syntax in select expression</pre>
I’m expecting it to generate <code>select 1 + 1;</code></z><z id="t1699718202" t="p-himik A scalar in :select means value/identifier. A 1-level vector means multiple values/identifiers. A 2-level vector means the same, but with aliases. A 3-level vector means the same, but with function calls. So you need a 3-level vector. And by &quot;3-level&quot; I mean &quot;nested 3 levels deep&quot;, so [[[:+ 1 1]]] should work."><y>#</y><d>2023-11-11</d><h>15:56</h><r>p-himik</r>A scalar in <code>:select</code> means value/identifier.
A 1-level vector means multiple values/identifiers.
A 2-level vector means the same, but with aliases.
A 3-level vector means the same, but with function calls.

So you need a 3-level vector. And by &quot;3-level&quot; I mean &quot;nested 3 levels deep&quot;, so <code>[[[:+ 1 1]]]</code> should work.</z><z id="t1699726615" t="seancorfield [:attrs {:href &quot;/_/_/users/U023C0QKU4W&quot;}] Take a look at the SQL Expressions section early in Getting Started https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started -- it has examples of :select with those 3 levels of vectors."><y>#</y><d>2023-11-11</d><h>18:16</h><r>seancorfield</r><a>@U023C0QKU4W</a> Take a look at the SQL Expressions section early in Getting Started <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started</a> -- it has examples of <code>:select</code> with those 3 levels of vectors.</z><z id="t1699802475" t="Ngoc Khuat That makes sense! thanks!"><y>#</y><d>2023-11-12</d><h>15:21</h><r>Ngoc Khuat</r>That makes sense! thanks!</z><z id="t1699974167" t="markaddleman Is there a way to prevent upper-casing of function names?"><y>#</y><d>2023-11-14</d><h>15:02</h><w>markaddleman</w>Is there a way to prevent upper-casing of function names?</z><z id="t1699974211" t="markaddleman Although I haven’t found documentation to support this, it appears that external BigQuery JavaScript UDFs are case sensitive."><y>#</y><d>2023-11-14</d><h>15:03</h><r>markaddleman</r>Although I haven’t found documentation to support this, it appears that external BigQuery JavaScript UDFs are case sensitive.</z><z id="t1699974260" t="markaddleman The library of community-built UDFs have lower case names which makes them cumbersome to reference with honey"><y>#</y><d>2023-11-14</d><h>15:04</h><r>markaddleman</r>The library of community-built UDFs have lower case names which makes them cumbersome to reference with honey</z><z id="t1699974364" t="markaddleman Examples are here: https://github.com/GoogleCloudPlatform/bigquery-utils/blob/master/udfs/community/README.md#cw_array_distinctarr-any-type"><y>#</y><d>2023-11-14</d><h>15:06</h><r>markaddleman</r>Examples are here: <a href="https://github.com/GoogleCloudPlatform/bigquery-utils/blob/master/udfs/community/README.md#cw_array_distinctarr-any-type" target="_blank">https://github.com/GoogleCloudPlatform/bigquery-utils/blob/master/udfs/community/README.md#cw_array_distinctarr-any-type</a></z><z id="t1699974406" t="markaddleman Currently, I have a custom formatter and reference using {:select [[[:fn.cw_array_distinct [:array_agg :a]] :step-array]]} "><y>#</y><d>2023-11-14</d><h>15:06</h><r>markaddleman</r>Currently, I have a custom formatter and reference using
<pre>{:select [[[:fn.cw_array_distinct [:array_agg :a]]
                         :step-array]]} </pre></z><z id="t1699974426" t="markaddleman I couldn’t figure out how to get :raw to work in function call position"><y>#</y><d>2023-11-14</d><h>15:07</h><r>markaddleman</r>I couldn’t figure out how to get <code>:raw</code> to work in function call position</z><z id="t1699975352" t="p-himik Add &apos; after : , as in: (sql/format {:select [[[:&apos;fn.cw_array_distinct [:array_agg :a]] :step-array]]} ) =&gt; [&quot;SELECT fn.cw_array_distinct(ARRAY_AGG(a)) AS step_array&quot;]"><y>#</y><d>2023-11-14</d><h>15:22</h><r>p-himik</r>Add <code>&apos;</code> after <code>:</code>, as in:
<pre>(sql/format {:select [[[:&apos;fn.cw_array_distinct [:array_agg :a]]
                       :step-array]]}
            )
=&gt; [&quot;SELECT fn.cw_array_distinct(ARRAY_AGG(a)) AS step_array&quot;]</pre></z><z id="t1699975409" t="markaddleman Nice! Thanks!"><y>#</y><d>2023-11-14</d><h>15:23</h><r>markaddleman</r>Nice!  Thanks!</z><z id="t1699983078" t="seancorfield [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] See https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started/other-databases#bigquery-google (happy to add more BigQuery hints and tips there)."><y>#</y><d>2023-11-14</d><h>17:31</h><r>seancorfield</r><a>@U2845S9KL</a> See <a href="https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started/other-databases#bigquery-google" target="_blank">https://cljdoc.org/d/com.github.seancorfield/honeysql/2.5.1091/doc/getting-started/other-databases#bigquery-google</a> (happy to add more BigQuery hints and tips there).</z><z id="t1699991918" t="markaddleman Thanks for the pointer! Somehow I missed this in my search"><y>#</y><d>2023-11-14</d><h>19:58</h><r>markaddleman</r>Thanks for the pointer!  Somehow I missed this in my search</z><z id="t1699983438" t="GitHub"><y>#</y><d>2023-11-14</d><h>17:37</h><w>GitHub</w></z><z id="t1700063546" t="GitHub"><y>#</y><d>2023-11-15</d><h>15:52</h><w>GitHub</w></z><z id="t1700071256" t="seancorfield Folks, as a point of procedure, please don&apos;t create Pull Requests without either discussion here or in an issue that agrees a) there is a problem to be solved and b) that a specific solution is appropriate. Thanks."><y>#</y><d>2023-11-15</d><h>18:00</h><w>seancorfield</w>Folks, as a point of procedure, please don&apos;t create Pull Requests without either discussion here or in an issue that agrees a) there is a problem to be solved and b) that a specific solution is appropriate. Thanks.</z></g></div></body>